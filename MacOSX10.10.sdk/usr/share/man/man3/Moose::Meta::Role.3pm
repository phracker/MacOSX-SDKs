.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Moose::Meta::Role 3"
.TH Moose::Meta::Role 3 "2014-01-19" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Moose::Meta::Role \- The Moose Role metaclass
.SH "VERSION"
.IX Header "VERSION"
version 2.1202
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This class is a subclass of Class::MOP::Module that provides
additional Moose-specific functionality.
.PP
Its \s-1API\s0 looks a lot like Moose::Meta::Class, but internally it
implements many things differently. This may change in the future.
.SH "INHERITANCE"
.IX Header "INHERITANCE"
\&\f(CW\*(C`Moose::Meta::Role\*(C'\fR is a subclass of Class::MOP::Module.
.SH "METHODS"
.IX Header "METHODS"
.SS "Construction"
.IX Subsection "Construction"
.IP "\fBMoose::Meta::Role\->initialize($role_name)\fR" 4
.IX Item "Moose::Meta::Role->initialize($role_name)"
This method creates a new role object with the provided name.
.ie n .IP "\fBMoose::Meta::Role\->combine( [ \fB$role\fB => { ... } ], [ \f(BI$role\fB ], ... )\fR" 4
.el .IP "\fBMoose::Meta::Role\->combine( [ \f(CB$role\fB => { ... } ], [ \f(CB$role\fB ], ... )\fR" 4
.IX Item "Moose::Meta::Role->combine( [ $role => { ... } ], [ $role ], ... )"
This method accepts a list of array references. Each array reference
should contain a role name or Moose::Meta::Role object as its first element. The second element is
an optional hash reference. The hash reference can contain \f(CW\*(C`\-excludes\*(C'\fR
and \f(CW\*(C`\-alias\*(C'\fR keys to control how methods are composed from the role.
.Sp
The return value is a new Moose::Meta::Role::Composite that
represents the combined roles.
.ie n .IP "\fB\fB$metarole\fB\->composition_class_roles\fR" 4
.el .IP "\fB\f(CB$metarole\fB\->composition_class_roles\fR" 4
.IX Item "$metarole->composition_class_roles"
When combining multiple roles using \f(CW\*(C`combine\*(C'\fR, this method is used to obtain a
list of role names to be applied to the Moose::Meta::Role::Composite
instance returned by \f(CW\*(C`combine\*(C'\fR. The default implementation returns an empty
list. Extensions that need to hook into role combination may wrap this method
to return additional role names.
.ie n .IP "\fBMoose::Meta::Role\->create($name, \fB%options\fB)\fR" 4
.el .IP "\fBMoose::Meta::Role\->create($name, \f(CB%options\fB)\fR" 4
.IX Item "Moose::Meta::Role->create($name, %options)"
This method is identical to the Moose::Meta::Class \f(CW\*(C`create\*(C'\fR
method.
.IP "\fBMoose::Meta::Role\->create_anon_role\fR" 4
.IX Item "Moose::Meta::Role->create_anon_role"
This method is identical to the Moose::Meta::Class
\&\f(CW\*(C`create_anon_class\*(C'\fR method.
.ie n .IP "\fB\fB$metarole\fB\->is_anon_role\fR" 4
.el .IP "\fB\f(CB$metarole\fB\->is_anon_role\fR" 4
.IX Item "$metarole->is_anon_role"
Returns true if the role is an anonymous role.
.ie n .IP "\fB\fB$metarole\fB\->consumers\fR" 4
.el .IP "\fB\f(CB$metarole\fB\->consumers\fR" 4
.IX Item "$metarole->consumers"
Returns a list of names of classes and roles which consume this role.
.SS "Role application"
.IX Subsection "Role application"
.ie n .IP "\fB\fB$metarole\fB\->apply( \f(BI$thing\fB, \f(CB@options\fB )\fR" 4
.el .IP "\fB\f(CB$metarole\fB\->apply( \f(CB$thing\fB, \f(CB@options\fB )\fR" 4
.IX Item "$metarole->apply( $thing, @options )"
This method applies a role to the given \f(CW$thing\fR. That can be another
Moose::Meta::Role, object, a Moose::Meta::Class object, or a
(non-meta) object instance.
.Sp
The options are passed directly to the constructor for the appropriate
Moose::Meta::Role::Application subclass.
.Sp
Note that this will apply the role even if the \f(CW$thing\fR in question already
\&\f(CW\*(C`does\*(C'\fR this role.  \*(L"does_role\*(R" in Moose::Util is a convenient wrapper for
finding out if role application is necessary.
.SS "Roles and other roles"
.IX Subsection "Roles and other roles"
.ie n .IP "\fB\fB$metarole\fB\->get_roles\fR" 4
.el .IP "\fB\f(CB$metarole\fB\->get_roles\fR" 4
.IX Item "$metarole->get_roles"
This returns an array reference of roles which this role does. This
list may include duplicates.
.ie n .IP "\fB\fB$metarole\fB\->calculate_all_roles\fR" 4
.el .IP "\fB\f(CB$metarole\fB\->calculate_all_roles\fR" 4
.IX Item "$metarole->calculate_all_roles"
This returns a \fIunique\fR list of all roles that this role does, and
all the roles that its roles do.
.ie n .IP "\fB\fB$metarole\fB\->does_role($role)\fR" 4
.el .IP "\fB\f(CB$metarole\fB\->does_role($role)\fR" 4
.IX Item "$metarole->does_role($role)"
Given a role \fIname\fR or Moose::Meta::Role object, returns true if this role
does the given role.
.ie n .IP "\fB\fB$metarole\fB\->add_role($role)\fR" 4
.el .IP "\fB\f(CB$metarole\fB\->add_role($role)\fR" 4
.IX Item "$metarole->add_role($role)"
Given a Moose::Meta::Role object, this adds the role to the list of
roles that the role does.
.ie n .IP "\fB\fB$metarole\fB\->get_excluded_roles_list\fR" 4
.el .IP "\fB\f(CB$metarole\fB\->get_excluded_roles_list\fR" 4
.IX Item "$metarole->get_excluded_roles_list"
Returns a list of role names which this role excludes.
.ie n .IP "\fB\fB$metarole\fB\->excludes_role($role_name)\fR" 4
.el .IP "\fB\f(CB$metarole\fB\->excludes_role($role_name)\fR" 4
.IX Item "$metarole->excludes_role($role_name)"
Given a role \fIname\fR, returns true if this role excludes the named
role.
.ie n .IP "\fB\fB$metarole\fB\->add_excluded_roles(@role_names)\fR" 4
.el .IP "\fB\f(CB$metarole\fB\->add_excluded_roles(@role_names)\fR" 4
.IX Item "$metarole->add_excluded_roles(@role_names)"
Given one or more role names, adds those roles to the list of excluded
roles.
.SS "Methods"
.IX Subsection "Methods"
The methods for dealing with a role's methods are all identical in \s-1API\s0
and behavior to the same methods in Class::MOP::Class.
.ie n .IP "\fB\fB$metarole\fB\->method_metaclass\fR" 4
.el .IP "\fB\f(CB$metarole\fB\->method_metaclass\fR" 4
.IX Item "$metarole->method_metaclass"
Returns the method metaclass name for the role. This defaults to
Moose::Meta::Role::Method.
.ie n .IP "\fB\fB$metarole\fB\->get_method($name)\fR" 4
.el .IP "\fB\f(CB$metarole\fB\->get_method($name)\fR" 4
.IX Item "$metarole->get_method($name)"
.PD 0
.ie n .IP "\fB\fB$metarole\fB\->has_method($name)\fR" 4
.el .IP "\fB\f(CB$metarole\fB\->has_method($name)\fR" 4
.IX Item "$metarole->has_method($name)"
.ie n .IP "\fB\fB$metarole\fB\->add_method( \f(BI$name\fB, \f(CB$body\fB )\fR" 4
.el .IP "\fB\f(CB$metarole\fB\->add_method( \f(CB$name\fB, \f(CB$body\fB )\fR" 4
.IX Item "$metarole->add_method( $name, $body )"
.ie n .IP "\fB\fB$metarole\fB\->get_method_list\fR" 4
.el .IP "\fB\f(CB$metarole\fB\->get_method_list\fR" 4
.IX Item "$metarole->get_method_list"
.ie n .IP "\fB\fB$metarole\fB\->find_method_by_name($name)\fR" 4
.el .IP "\fB\f(CB$metarole\fB\->find_method_by_name($name)\fR" 4
.IX Item "$metarole->find_method_by_name($name)"
.PD
These methods are all identical to the methods of the same name in
Class::MOP::Package
.SS "Attributes"
.IX Subsection "Attributes"
As with methods, the methods for dealing with a role's attribute are
all identical in \s-1API\s0 and behavior to the same methods in
Class::MOP::Class.
.PP
However, attributes stored in this class are \fInot\fR stored as
objects. Rather, the attribute definition is stored as a hash
reference. When a role is composed into a class, this hash reference
is passed directly to the metaclass's \f(CW\*(C`add_attribute\*(C'\fR method.
.PP
This is quite likely to change in the future.
.ie n .IP "\fB\fB$metarole\fB\->get_attribute($attribute_name)\fR" 4
.el .IP "\fB\f(CB$metarole\fB\->get_attribute($attribute_name)\fR" 4
.IX Item "$metarole->get_attribute($attribute_name)"
.PD 0
.ie n .IP "\fB\fB$metarole\fB\->has_attribute($attribute_name)\fR" 4
.el .IP "\fB\f(CB$metarole\fB\->has_attribute($attribute_name)\fR" 4
.IX Item "$metarole->has_attribute($attribute_name)"
.ie n .IP "\fB\fB$metarole\fB\->get_attribute_list\fR" 4
.el .IP "\fB\f(CB$metarole\fB\->get_attribute_list\fR" 4
.IX Item "$metarole->get_attribute_list"
.ie n .IP "\fB\fB$metarole\fB\->add_attribute($name, \f(BI%options\fB)\fR" 4
.el .IP "\fB\f(CB$metarole\fB\->add_attribute($name, \f(CB%options\fB)\fR" 4
.IX Item "$metarole->add_attribute($name, %options)"
.ie n .IP "\fB\fB$metarole\fB\->remove_attribute($attribute_name)\fR" 4
.el .IP "\fB\f(CB$metarole\fB\->remove_attribute($attribute_name)\fR" 4
.IX Item "$metarole->remove_attribute($attribute_name)"
.PD
.SS "Overload introspection and creation"
.IX Subsection "Overload introspection and creation"
The methods for dealing with a role's overloads are all identical in \s-1API\s0
and behavior to the same methods in Class::MOP::Class. Note that these are
not particularly useful (yet), because overloads do not participate in role
composition.
.ie n .IP "\fB\fB$metarole\fB\->is_overloaded\fR" 4
.el .IP "\fB\f(CB$metarole\fB\->is_overloaded\fR" 4
.IX Item "$metarole->is_overloaded"
.PD 0
.ie n .IP "\fB\fB$metarole\fB\->get_overloaded_operator($op)\fR" 4
.el .IP "\fB\f(CB$metarole\fB\->get_overloaded_operator($op)\fR" 4
.IX Item "$metarole->get_overloaded_operator($op)"
.ie n .IP "\fB\fB$metarole\fB\->has_overloaded_operator($op)\fR" 4
.el .IP "\fB\f(CB$metarole\fB\->has_overloaded_operator($op)\fR" 4
.IX Item "$metarole->has_overloaded_operator($op)"
.ie n .IP "\fB\fB$metarole\fB\->get_overload_list\fR" 4
.el .IP "\fB\f(CB$metarole\fB\->get_overload_list\fR" 4
.IX Item "$metarole->get_overload_list"
.ie n .IP "\fB\fB$metarole\fB\->get_all_overloaded_operators\fR" 4
.el .IP "\fB\f(CB$metarole\fB\->get_all_overloaded_operators\fR" 4
.IX Item "$metarole->get_all_overloaded_operators"
.ie n .IP "\fB\fB$metarole\fB\->add_overloaded_operator($op, \f(BI$impl\fB)\fR" 4
.el .IP "\fB\f(CB$metarole\fB\->add_overloaded_operator($op, \f(CB$impl\fB)\fR" 4
.IX Item "$metarole->add_overloaded_operator($op, $impl)"
.ie n .IP "\fB\fB$metarole\fB\->remove_overloaded_operator($op)\fR" 4
.el .IP "\fB\f(CB$metarole\fB\->remove_overloaded_operator($op)\fR" 4
.IX Item "$metarole->remove_overloaded_operator($op)"
.PD
.SS "Required methods"
.IX Subsection "Required methods"
.ie n .IP "\fB\fB$metarole\fB\->get_required_method_list\fR" 4
.el .IP "\fB\f(CB$metarole\fB\->get_required_method_list\fR" 4
.IX Item "$metarole->get_required_method_list"
Returns the list of methods required by the role.
.ie n .IP "\fB\fB$metarole\fB\->requires_method($name)\fR" 4
.el .IP "\fB\f(CB$metarole\fB\->requires_method($name)\fR" 4
.IX Item "$metarole->requires_method($name)"
Returns true if the role requires the named method.
.ie n .IP "\fB\fB$metarole\fB\->add_required_methods(@names)\fR" 4
.el .IP "\fB\f(CB$metarole\fB\->add_required_methods(@names)\fR" 4
.IX Item "$metarole->add_required_methods(@names)"
Adds the named methods to the role's list of required methods.
.ie n .IP "\fB\fB$metarole\fB\->remove_required_methods(@names)\fR" 4
.el .IP "\fB\f(CB$metarole\fB\->remove_required_methods(@names)\fR" 4
.IX Item "$metarole->remove_required_methods(@names)"
Removes the named methods from the role's list of required methods.
.ie n .IP "\fB\fB$metarole\fB\->add_conflicting_method(%params)\fR" 4
.el .IP "\fB\f(CB$metarole\fB\->add_conflicting_method(%params)\fR" 4
.IX Item "$metarole->add_conflicting_method(%params)"
Instantiate the parameters as a Moose::Meta::Role::Method::Conflicting
object, then add it to the required method list.
.SS "Method modifiers"
.IX Subsection "Method modifiers"
These methods act like their counterparts in Class::MOP::Class and
Moose::Meta::Class.
.PP
However, method modifiers are simply stored internally, and are not
applied until the role itself is applied to a class.
.ie n .IP "\fB\fB$metarole\fB\->add_after_method_modifier($method_name, \f(BI$method\fB)\fR" 4
.el .IP "\fB\f(CB$metarole\fB\->add_after_method_modifier($method_name, \f(CB$method\fB)\fR" 4
.IX Item "$metarole->add_after_method_modifier($method_name, $method)"
.PD 0
.ie n .IP "\fB\fB$metarole\fB\->add_around_method_modifier($method_name, \f(BI$method\fB)\fR" 4
.el .IP "\fB\f(CB$metarole\fB\->add_around_method_modifier($method_name, \f(CB$method\fB)\fR" 4
.IX Item "$metarole->add_around_method_modifier($method_name, $method)"
.ie n .IP "\fB\fB$metarole\fB\->add_before_method_modifier($method_name, \f(BI$method\fB)\fR" 4
.el .IP "\fB\f(CB$metarole\fB\->add_before_method_modifier($method_name, \f(CB$method\fB)\fR" 4
.IX Item "$metarole->add_before_method_modifier($method_name, $method)"
.ie n .IP "\fB\fB$metarole\fB\->add_override_method_modifier($method_name, \f(BI$method\fB)\fR" 4
.el .IP "\fB\f(CB$metarole\fB\->add_override_method_modifier($method_name, \f(CB$method\fB)\fR" 4
.IX Item "$metarole->add_override_method_modifier($method_name, $method)"
.PD
These methods all add an appropriate modifier to the internal list of
modifiers.
.ie n .IP "\fB\fB$metarole\fB\->has_after_method_modifiers\fR" 4
.el .IP "\fB\f(CB$metarole\fB\->has_after_method_modifiers\fR" 4
.IX Item "$metarole->has_after_method_modifiers"
.PD 0
.ie n .IP "\fB\fB$metarole\fB\->has_around_method_modifiers\fR" 4
.el .IP "\fB\f(CB$metarole\fB\->has_around_method_modifiers\fR" 4
.IX Item "$metarole->has_around_method_modifiers"
.ie n .IP "\fB\fB$metarole\fB\->has_before_method_modifiers\fR" 4
.el .IP "\fB\f(CB$metarole\fB\->has_before_method_modifiers\fR" 4
.IX Item "$metarole->has_before_method_modifiers"
.ie n .IP "\fB\fB$metarole\fB\->has_override_method_modifier\fR" 4
.el .IP "\fB\f(CB$metarole\fB\->has_override_method_modifier\fR" 4
.IX Item "$metarole->has_override_method_modifier"
.PD
Return true if the role has any modifiers of the given type.
.ie n .IP "\fB\fB$metarole\fB\->get_after_method_modifiers($method_name)\fR" 4
.el .IP "\fB\f(CB$metarole\fB\->get_after_method_modifiers($method_name)\fR" 4
.IX Item "$metarole->get_after_method_modifiers($method_name)"
.PD 0
.ie n .IP "\fB\fB$metarole\fB\->get_around_method_modifiers($method_name)\fR" 4
.el .IP "\fB\f(CB$metarole\fB\->get_around_method_modifiers($method_name)\fR" 4
.IX Item "$metarole->get_around_method_modifiers($method_name)"
.ie n .IP "\fB\fB$metarole\fB\->get_before_method_modifiers($method_name)\fR" 4
.el .IP "\fB\f(CB$metarole\fB\->get_before_method_modifiers($method_name)\fR" 4
.IX Item "$metarole->get_before_method_modifiers($method_name)"
.PD
Given a method name, returns a list of the appropriate modifiers for
that method.
.ie n .IP "\fB\fB$metarole\fB\->get_override_method_modifier($method_name)\fR" 4
.el .IP "\fB\f(CB$metarole\fB\->get_override_method_modifier($method_name)\fR" 4
.IX Item "$metarole->get_override_method_modifier($method_name)"
Given a method name, returns the override method modifier for that
method, if it has one.
.SS "Introspection"
.IX Subsection "Introspection"
.IP "\fBMoose::Meta::Role\->meta\fR" 4
.IX Item "Moose::Meta::Role->meta"
This will return a Class::MOP::Class instance for this class.
.SH "BUGS"
.IX Header "BUGS"
See \*(L"\s-1BUGS\*(R"\s0 in Moose for details on reporting bugs.
.SH "AUTHORS"
.IX Header "AUTHORS"
.IP "\(bu" 4
Stevan Little <stevan.little@iinteractive.com>
.IP "\(bu" 4
Dave Rolsky <autarch@urth.org>
.IP "\(bu" 4
Jesse Luehrs <doy@tozt.net>
.IP "\(bu" 4
Shawn M Moore <code@sartak.org>
.IP "\(bu" 4
\&\s-1XXXX XXX\s0'\s-1XX \s0(Yuval Kogman) <nothingmuch@woobling.org>
.IP "\(bu" 4
Karen Etheridge <ether@cpan.org>
.IP "\(bu" 4
Florian Ragwitz <rafl@debian.org>
.IP "\(bu" 4
Hans Dieter Pearcey <hdp@weftsoar.net>
.IP "\(bu" 4
Chris Prather <chris@prather.org>
.IP "\(bu" 4
Matt S Trout <mst@shadowcat.co.uk>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is copyright (c) 2006 by Infinity Interactive, Inc..
.PP
This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.
