.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Term::Cap 3pm"
.TH Term::Cap 3pm "2014-01-06" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Term::Cap \- Perl termcap interface
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 6
\&    require Term::Cap;
\&    $terminal = Tgetent Term::Cap { TERM => undef, OSPEED => $ospeed };
\&    $terminal\->Trequire(qw/ce ku kd/);
\&    $terminal\->Tgoto(\*(Aqcm\*(Aq, $col, $row, $FH);
\&    $terminal\->Tputs(\*(Aqdl\*(Aq, $count, $FH);
\&    $terminal\->Tpad($string, $count, $FH);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
These are low-level functions to extract and use capabilities from
a terminal capability (termcap) database.
.PP
More information on the terminal capabilities will be found in the
termcap manpage on most Unix-like systems.
.SS "\s-1METHODS\s0"
.IX Subsection "METHODS"
The output strings for \fBTputs\fR are cached for counts of 1 for performance.
\&\fBTgoto\fR and \fBTpad\fR do not cache.  \f(CW\*(C`$self\->{_xx}\*(C'\fR is the raw termcap
data and \f(CW\*(C`$self\->{xx}\*(C'\fR is the cached version.
.PP
.Vb 1
\&    print $terminal\->Tpad($self\->{_xx}, 1);
.Ve
.PP
\&\fBTgoto\fR, \fBTputs\fR, and \fBTpad\fR return the string and will also
output the string to \f(CW$FH\fR if specified.
.IP "\fBTgetent\fR" 4
.IX Item "Tgetent"
Returns a blessed object reference which the user can
then use to send the control strings to the terminal using \fBTputs\fR
and \fBTgoto\fR.
.Sp
The function extracts the entry of the specified terminal
type \fI\s-1TERM\s0\fR (defaults to the environment variable \fI\s-1TERM\s0\fR) from the
database.
.Sp
It will look in the environment for a \fI\s-1TERMCAP\s0\fR variable.  If
found, and the value does not begin with a slash, and the terminal
type name is the same as the environment string \fI\s-1TERM\s0\fR, the
\&\fI\s-1TERMCAP\s0\fR string is used instead of reading a termcap file.  If
it does begin with a slash, the string is used as a path name of
the termcap file to search.  If \fI\s-1TERMCAP\s0\fR does not begin with a
slash and name is different from \fI\s-1TERM\s0\fR, \fBTgetent\fR searches the
files \fI\f(CI$HOME\fI/.termcap\fR, \fI/etc/termcap\fR, and \fI/usr/share/misc/termcap\fR,
in that order, unless the environment variable \fI\s-1TERMPATH\s0\fR exists,
in which case it specifies a list of file pathnames (separated by
spaces or colons) to be searched \fBinstead\fR.  Whenever multiple
files are searched and a tc field occurs in the requested entry,
the entry it names must be found in the same file or one of the
succeeding files.  If there is a \f(CW\*(C`:tc=...:\*(C'\fR in the \fI\s-1TERMCAP\s0\fR
environment variable string it will continue the search in the
files as above.
.Sp
The extracted termcap entry is available in the object
as \f(CW\*(C`$self\->{TERMCAP}\*(C'\fR.
.Sp
It takes a hash reference as an argument with two optional keys:
.RS 4
.IP "\s-1OSPEED\s0" 2
.IX Item "OSPEED"
The terminal output bit rate (often mistakenly called the baud rate)
for this terminal \- if not set a warning will be generated
and it will be defaulted to 9600.  \fI\s-1OSPEED\s0\fR can be be specified as
either a \s-1POSIX\s0 termios/SYSV termio speeds (where 9600 equals 9600) or
an old DSD-style speed ( where 13 equals 9600).
.IP "\s-1TERM\s0" 2
.IX Item "TERM"
The terminal type whose termcap entry will be used \- if not supplied it will
default to \f(CW$ENV\fR{\s-1TERM\s0}: if that is not set then \fBTgetent\fR will croak.
.RE
.RS 4
.Sp
It calls \f(CW\*(C`croak\*(C'\fR on failure.
.RE
.IP "\fBTpad\fR" 4
.IX Item "Tpad"
Outputs a literal string with appropriate padding for the current terminal.
.Sp
It takes three arguments:
.RS 4
.ie n .IP "\fB\fB$string\fB\fR" 2
.el .IP "\fB\f(CB$string\fB\fR" 2
.IX Item "$string"
The literal string to be output.  If it starts with a number and an optional
\&'*' then the padding will be increased by an amount relative to this number,
if the '*' is present then this amount will me multiplied by \f(CW$cnt\fR.  This part
of \f(CW$string\fR is removed before output/
.ie n .IP "\fB\fB$cnt\fB\fR" 2
.el .IP "\fB\f(CB$cnt\fB\fR" 2
.IX Item "$cnt"
Will be used to modify the padding applied to string as described above.
.ie n .IP "\fB\fB$FH\fB\fR" 2
.el .IP "\fB\f(CB$FH\fB\fR" 2
.IX Item "$FH"
An optional filehandle (or IO::Handle ) that output will be printed to.
.RE
.RS 4
.Sp
The padded \f(CW$string\fR is returned.
.RE
.IP "\fBTputs\fR" 4
.IX Item "Tputs"
Output the string for the given capability padded as appropriate without
any parameter substitution.
.Sp
It takes three arguments:
.RS 4
.ie n .IP "\fB\fB$cap\fB\fR" 2
.el .IP "\fB\f(CB$cap\fB\fR" 2
.IX Item "$cap"
The capability whose string is to be output.
.ie n .IP "\fB\fB$cnt\fB\fR" 2
.el .IP "\fB\f(CB$cnt\fB\fR" 2
.IX Item "$cnt"
A count passed to Tpad to modify the padding applied to the output string.
If \f(CW$cnt\fR is zero or one then the resulting string will be cached.
.ie n .IP "\fB\fB$FH\fB\fR" 2
.el .IP "\fB\f(CB$FH\fB\fR" 2
.IX Item "$FH"
An optional filehandle (or IO::Handle ) that output will be printed to.
.RE
.RS 4
.Sp
The appropriate string for the capability will be returned.
.RE
.IP "\fBTgoto\fR" 4
.IX Item "Tgoto"
\&\fBTgoto\fR decodes a cursor addressing string with the given parameters.
.Sp
There are four arguments:
.RS 4
.ie n .IP "\fB\fB$cap\fB\fR" 2
.el .IP "\fB\f(CB$cap\fB\fR" 2
.IX Item "$cap"
The name of the capability to be output.
.ie n .IP "\fB\fB$col\fB\fR" 2
.el .IP "\fB\f(CB$col\fB\fR" 2
.IX Item "$col"
The first value to be substituted in the output string ( usually the column
in a cursor addressing capability )
.ie n .IP "\fB\fB$row\fB\fR" 2
.el .IP "\fB\f(CB$row\fB\fR" 2
.IX Item "$row"
The second value to be substituted in the output string (usually the row
in cursor addressing capabilities)
.ie n .IP "\fB\fB$FH\fB\fR" 2
.el .IP "\fB\f(CB$FH\fB\fR" 2
.IX Item "$FH"
An optional filehandle (or IO::Handle ) to which the output string will be
printed.
.RE
.RS 4
.Sp
Substitutions are made with \f(CW$col\fR and \f(CW$row\fR in the output string with the
following \fIsprintf()\fR line formats:
.Sp
.Vb 6
\& %%   output \`%\*(Aq
\& %d   output value as in printf %d
\& %2   output value as in printf %2d
\& %3   output value as in printf %3d
\& %.   output value as in printf %c
\& %+x  add x to value, then do %.
\&
\& %>xy if value > x then add y, no output
\& %r   reverse order of two parameters, no output
\& %i   increment by one, no output
\& %B   BCD (16*(value/10)) + (value%10), no output
\&
\& %n   exclusive\-or all parameters with 0140 (Datamedia 2500)
\& %D   Reverse coding (value \- 2*(value%16)), no output (Delta Data)
.Ve
.Sp
The output string will be returned.
.RE
.IP "\fBTrequire\fR" 4
.IX Item "Trequire"
Takes a list of capabilities as an argument and will croak if one is not
found.
.SH "EXAMPLES"
.IX Header "EXAMPLES"
.Vb 1
\&    use Term::Cap;
\&
\&    # Get terminal output speed
\&    require POSIX;
\&    my $termios = new POSIX::Termios;
\&    $termios\->getattr;
\&    my $ospeed = $termios\->getospeed;
\&
\&    # Old\-style ioctl code to get ospeed:
\&    #     require \*(Aqioctl.pl\*(Aq;
\&    #     ioctl(TTY,$TIOCGETP,$sgtty);
\&    #     ($ispeed,$ospeed) = unpack(\*(Aqcc\*(Aq,$sgtty);
\&
\&    # allocate and initialize a terminal structure
\&    $terminal = Tgetent Term::Cap { TERM => undef, OSPEED => $ospeed };
\&
\&    # require certain capabilities to be available
\&    $terminal\->Trequire(qw/ce ku kd/);
\&
\&    # Output Routines, if $FH is undefined these just return the string
\&
\&    # Tgoto does the % expansion stuff with the given args
\&    $terminal\->Tgoto(\*(Aqcm\*(Aq, $col, $row, $FH);
\&
\&    # Tputs doesn\*(Aqt do any % expansion.
\&    $terminal\->Tputs(\*(Aqdl\*(Aq, $count = 1, $FH);
.Ve
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Please see the \s-1README\s0 file in distribution.
.SH "AUTHOR"
.IX Header "AUTHOR"
This module is part of the core Perl distribution and is also maintained
for \s-1CPAN\s0 by Jonathan Stowe <jns@gellyfish.com>.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fItermcap\fR\|(5)
