.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PPI::Structure 3"
.TH PPI::Structure 3 "2011-02-25" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
PPI::Structure \- The base class for Perl braced structures
.SH "INHERITANCE"
.IX Header "INHERITANCE"
.Vb 3
\&  PPI::Structure
\&  isa PPI::Node
\&      isa PPI::Element
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
PPI::Structure is the root class for all Perl bracing structures. This
covers all forms of \f(CW\*(C` [ ... ] \*(C'\fR, \f(CW\*(C` { ... } \*(C'\fR, and \f(CW\*(C` ( ... ) \*(C'\fR brace
types, and includes cases where only one half of the pair exist.
.PP
The class PPI::Structure itself is full abstract and no objects of that
type should actually exist in the tree.
.SS "Elements vs Children"
.IX Subsection "Elements vs Children"
A \fBPPI::Structure\fR has an unusual existance. Unlike a PPI::Document
or PPI::Statement, which both simply contain other elements, a
structure \fBboth\fR contains and consists of content.
.PP
That is, the brace tokens are \fBnot\fR considered to be \*(L"children\*(R" of the
structure, but are part of it.
.PP
In practice, this will mean that while the \->elements and \->tokens
methods (and related) \fBwill\fR return a list with the brace tokens at either
end, the \->children method explicitly will \fBnot\fR return the brace.
.SH "STRUCTURE CLASSES"
.IX Header "STRUCTURE CLASSES"
Excluding the transient PPI::Structure::Unknown that exists briefly
inside the parser, there are eight types of structure.
.SS "PPI::Structure::List"
.IX Subsection "PPI::Structure::List"
This covers all round braces used for function arguments, in \f(CW\*(C`foreach\*(C'\fR
loops, literal lists, and braces used for precedence-ordering purposes.
.SS "PPI::Structure::For"
.IX Subsection "PPI::Structure::For"
Although \fBnot\fR used for the \f(CW\*(C`foreach\*(C'\fR loop list, this \fBis\fR used for
the special case of the round-brace three-part semicolon-seperated \f(CW\*(C`for\*(C'\fR
loop expression (the traditional C style for loop).
.SS "PPI::Structure::Given"
.IX Subsection "PPI::Structure::Given"
This is for the expression being matched in switch statements.
.SS "PPI::Structure::When"
.IX Subsection "PPI::Structure::When"
This is for the matching expression in \*(L"when\*(R" statements.
.SS "PPI::Structure::Condition"
.IX Subsection "PPI::Structure::Condition"
This round-brace structure covers boolean conditional braces, such as
for \f(CW\*(C`if\*(C'\fR and \f(CW\*(C`while\*(C'\fR blocks.
.SS "PPI::Structure::Block"
.IX Subsection "PPI::Structure::Block"
This curly-brace and common structure is used for all form of code
blocks. This includes those for \f(CW\*(C`if\*(C'\fR, \f(CW\*(C`do\*(C'\fR and similar, as well
as \f(CW\*(C`grep\*(C'\fR, \f(CW\*(C`map\*(C'\fR, \f(CW\*(C`sort\*(C'\fR, \f(CW\*(C`sub\*(C'\fR and (labelled or anonymous) 
scoping blocks.
.SS "PPI::Structure::Constructor"
.IX Subsection "PPI::Structure::Constructor"
This class covers brace structures used for the construction of
anonymous \f(CW\*(C`ARRAY\*(C'\fR and \f(CW\*(C`HASH\*(C'\fR references.
.SS "PPI::Structure::Subscript"
.IX Subsection "PPI::Structure::Subscript"
This class covers square-braces and curly-braces used after a
\&\-> pointer to access the subscript of an \f(CW\*(C`ARRAY\*(C'\fR or \f(CW\*(C`HASH\*(C'\fR.
.SH "METHODS"
.IX Header "METHODS"
\&\f(CW\*(C`PPI::Structure\*(C'\fR itself has very few methods. Most of the time, you will be
working with the more generic PPI::Element or PPI::Node methods, or one
of the methods that are subclass-specific.
.SS "start"
.IX Subsection "start"
For lack of better terminology (like \*(L"open\*(R" and \*(L"close\*(R") that has not
already in use for some other more important purpose, the two individual
braces for the structure are known within \s-1PPI\s0 as the \*(L"start\*(R" and \*(L"finish\*(R"
braces (at least for method purposes).
.PP
The \f(CW\*(C`start\*(C'\fR method returns the start brace for the structure (i.e. the
opening brace).
.PP
Returns the brace as a PPI::Token::Structure or \f(CW\*(C`undef\*(C'\fR if the
structure does not have a starting brace.
.PP
Under normal parsing circumstances this should never occur, but may happen
due to manipulation of the \s-1PDOM\s0 tree.
.SS "finish"
.IX Subsection "finish"
The \f(CW\*(C`finish\*(C'\fR method returns the finish brace for the structure (i.e. the
closing brace).
.PP
Returns the brace as a PPI::Token::Structure or \f(CW\*(C`undef\*(C'\fR if the
structure does not have a finishing brace. This can be quite common if
the document is not complete (for example, from an editor where the user
may be halfway through typeing a subroutine).
.SS "braces"
.IX Subsection "braces"
The \f(CW\*(C`braces\*(C'\fR method is a utility method which returns the brace type,
regardless of whether has both braces defined, or just the starting
brace, or just the ending brace.
.PP
Returns on of the three strings \f(CW\*(Aq[]\*(Aq\fR, \f(CW\*(Aq{}\*(Aq\fR, or \f(CW\*(Aq()\*(Aq\fR, or \f(CW\*(C`undef\*(C'\fR
on error (primarily not having a start brace, as mentioned above).
.SH "complete"
.IX Header "complete"
The \f(CW\*(C`complete\*(C'\fR method is a convenience method that returns true if
the both braces are defined for the structure, or false if only one
brace is defined.
.PP
Unlike the top level \f(CW\*(C`complete\*(C'\fR method which checks for completeness
in depth, the structure complete method \s-1ONLY\s0 confirms completeness
for the braces, and does not recurse downwards.
.SH "SUPPORT"
.IX Header "SUPPORT"
See the support section in the main module.
.SH "AUTHOR"
.IX Header "AUTHOR"
Adam Kennedy <adamk@cpan.org>
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright 2001 \- 2011 Adam Kennedy.
.PP
This program is free software; you can redistribute
it and/or modify it under the same terms as Perl itself.
.PP
The full text of the license can be found in the
\&\s-1LICENSE\s0 file included with this module.
