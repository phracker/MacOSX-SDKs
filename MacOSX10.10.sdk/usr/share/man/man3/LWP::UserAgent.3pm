.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "LWP::UserAgent 3"
.TH LWP::UserAgent 3 "2013-03-11" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
LWP::UserAgent \- Web user agent class
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& require LWP::UserAgent;
\& 
\& my $ua = LWP::UserAgent\->new;
\& $ua\->timeout(10);
\& $ua\->env_proxy;
\& 
\& my $response = $ua\->get(\*(Aqhttp://search.cpan.org/\*(Aq);
\& 
\& if ($response\->is_success) {
\&     print $response\->decoded_content;  # or whatever
\& }
\& else {
\&     die $response\->status_line;
\& }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The \f(CW\*(C`LWP::UserAgent\*(C'\fR is a class implementing a web user agent.
\&\f(CW\*(C`LWP::UserAgent\*(C'\fR objects can be used to dispatch web requests.
.PP
In normal use the application creates an \f(CW\*(C`LWP::UserAgent\*(C'\fR object, and
then configures it with values for timeouts, proxies, name, etc. It
then creates an instance of \f(CW\*(C`HTTP::Request\*(C'\fR for the request that
needs to be performed. This request is then passed to one of the
request method the UserAgent, which dispatches it using the relevant
protocol, and returns a \f(CW\*(C`HTTP::Response\*(C'\fR object.  There are
convenience methods for sending the most common request types: \fIget()\fR,
\&\fIhead()\fR, \fIpost()\fR, \fIput()\fR and \fIdelete()\fR.  When using these methods then the
creation of the request object is hidden as shown in the synopsis above.
.PP
The basic approach of the library is to use \s-1HTTP\s0 style communication
for all protocol schemes.  This means that you will construct
\&\f(CW\*(C`HTTP::Request\*(C'\fR objects and receive \f(CW\*(C`HTTP::Response\*(C'\fR objects even
for non-HTTP resources like \fIgopher\fR and \fIftp\fR.  In order to achieve
even more similarity to \s-1HTTP\s0 style communications, gopher menus and
file directories are converted to \s-1HTML\s0 documents.
.SH "CONSTRUCTOR METHODS"
.IX Header "CONSTRUCTOR METHODS"
The following constructor methods are available:
.ie n .IP "$ua = LWP::UserAgent\->new( %options )" 4
.el .IP "\f(CW$ua\fR = LWP::UserAgent\->new( \f(CW%options\fR )" 4
.IX Item "$ua = LWP::UserAgent->new( %options )"
This method constructs a new \f(CW\*(C`LWP::UserAgent\*(C'\fR object and returns it.
Key/value pair arguments may be provided to set up the initial state.
The following options correspond to attribute methods described below:
.Sp
.Vb 10
\&   KEY                     DEFAULT
\&   \-\-\-\-\-\-\-\-\-\-\-             \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&   agent                   "libwww\-perl/#.###"
\&   from                    undef
\&   conn_cache              undef
\&   cookie_jar              undef
\&   default_headers         HTTP::Headers\->new
\&   local_address           undef
\&   ssl_opts                { verify_hostname => 1 }
\&   max_size                undef
\&   max_redirect            7
\&   parse_head              1
\&   protocols_allowed       undef
\&   protocols_forbidden     undef
\&   requests_redirectable   [\*(AqGET\*(Aq, \*(AqHEAD\*(Aq]
\&   timeout                 180
.Ve
.Sp
The following additional options are also accepted: If the \f(CW\*(C`env_proxy\*(C'\fR option
is passed in with a \s-1TRUE\s0 value, then proxy settings are read from environment
variables (see \fIenv_proxy()\fR method below).  If \f(CW\*(C`env_proxy\*(C'\fR isn't provided the
\&\f(CW\*(C`PERL_LWP_ENV_PROXY\*(C'\fR environment variable controls if \fIenv_proxy()\fR is called
during initialization.  If the \f(CW\*(C`keep_alive\*(C'\fR option is passed in, then a
\&\f(CW\*(C`LWP::ConnCache\*(C'\fR is set up (see \fIconn_cache()\fR method below).  The \f(CW\*(C`keep_alive\*(C'\fR
value is passed on as the \f(CW\*(C`total_capacity\*(C'\fR for the connection cache.
.ie n .IP "$ua\->clone" 4
.el .IP "\f(CW$ua\fR\->clone" 4
.IX Item "$ua->clone"
Returns a copy of the LWP::UserAgent object.
.SH "ATTRIBUTES"
.IX Header "ATTRIBUTES"
The settings of the configuration attributes modify the behaviour of the
\&\f(CW\*(C`LWP::UserAgent\*(C'\fR when it dispatches requests.  Most of these can also
be initialized by options passed to the constructor method.
.PP
The following attribute methods are provided.  The attribute value is
left unchanged if no argument is given.  The return value from each
method is the old attribute value.
.ie n .IP "$ua\->agent" 4
.el .IP "\f(CW$ua\fR\->agent" 4
.IX Item "$ua->agent"
.PD 0
.ie n .IP "$ua\->agent( $product_id )" 4
.el .IP "\f(CW$ua\fR\->agent( \f(CW$product_id\fR )" 4
.IX Item "$ua->agent( $product_id )"
.PD
Get/set the product token that is used to identify the user agent on
the network.  The agent value is sent as the \*(L"User-Agent\*(R" header in
the requests.  The default is the string returned by the \fI_agent()\fR
method (see below).
.Sp
If the \f(CW$product_id\fR ends with space then the \fI_agent()\fR string is
appended to it.
.Sp
The user agent string should be one or more simple product identifiers
with an optional version number separated by the \*(L"/\*(R" character.
Examples are:
.Sp
.Vb 4
\&  $ua\->agent(\*(AqCheckbot/0.4 \*(Aq . $ua\->_agent);
\&  $ua\->agent(\*(AqCheckbot/0.4 \*(Aq);    # same as above
\&  $ua\->agent(\*(AqMozilla/5.0\*(Aq);
\&  $ua\->agent("");                 # don\*(Aqt identify
.Ve
.ie n .IP "$ua\->_agent" 4
.el .IP "\f(CW$ua\fR\->_agent" 4
.IX Item "$ua->_agent"
Returns the default agent identifier.  This is a string of the form
\&\*(L"libwww\-perl/#.###\*(R", where \*(L"#.###\*(R" is substituted with the version number
of this library.
.ie n .IP "$ua\->from" 4
.el .IP "\f(CW$ua\fR\->from" 4
.IX Item "$ua->from"
.PD 0
.ie n .IP "$ua\->from( $email_address )" 4
.el .IP "\f(CW$ua\fR\->from( \f(CW$email_address\fR )" 4
.IX Item "$ua->from( $email_address )"
.PD
Get/set the e\-mail address for the human user who controls
the requesting user agent.  The address should be machine-usable, as
defined in \s-1RFC 822. \s0 The \f(CW\*(C`from\*(C'\fR value is send as the \*(L"From\*(R" header in
the requests.  Example:
.Sp
.Vb 1
\&  $ua\->from(\*(Aqgaas@cpan.org\*(Aq);
.Ve
.Sp
The default is to not send a \*(L"From\*(R" header.  See the \fIdefault_headers()\fR
method for the more general interface that allow any header to be defaulted.
.ie n .IP "$ua\->cookie_jar" 4
.el .IP "\f(CW$ua\fR\->cookie_jar" 4
.IX Item "$ua->cookie_jar"
.PD 0
.ie n .IP "$ua\->cookie_jar( $cookie_jar_obj )" 4
.el .IP "\f(CW$ua\fR\->cookie_jar( \f(CW$cookie_jar_obj\fR )" 4
.IX Item "$ua->cookie_jar( $cookie_jar_obj )"
.PD
Get/set the cookie jar object to use.  The only requirement is that
the cookie jar object must implement the extract_cookies($request) and
add_cookie_header($response) methods.  These methods will then be
invoked by the user agent as requests are sent and responses are
received.  Normally this will be a \f(CW\*(C`HTTP::Cookies\*(C'\fR object or some
subclass.
.Sp
The default is to have no cookie_jar, i.e. never automatically add
\&\*(L"Cookie\*(R" headers to the requests.
.Sp
Shortcut: If a reference to a plain hash is passed in as the
\&\f(CW$cookie_jar_object\fR, then it is replaced with an instance of
\&\f(CW\*(C`HTTP::Cookies\*(C'\fR that is initialized based on the hash.  This form also
automatically loads the \f(CW\*(C`HTTP::Cookies\*(C'\fR module.  It means that:
.Sp
.Vb 1
\&  $ua\->cookie_jar({ file => "$ENV{HOME}/.cookies.txt" });
.Ve
.Sp
is really just a shortcut for:
.Sp
.Vb 2
\&  require HTTP::Cookies;
\&  $ua\->cookie_jar(HTTP::Cookies\->new(file => "$ENV{HOME}/.cookies.txt"));
.Ve
.ie n .IP "$ua\->default_headers" 4
.el .IP "\f(CW$ua\fR\->default_headers" 4
.IX Item "$ua->default_headers"
.PD 0
.ie n .IP "$ua\->default_headers( $headers_obj )" 4
.el .IP "\f(CW$ua\fR\->default_headers( \f(CW$headers_obj\fR )" 4
.IX Item "$ua->default_headers( $headers_obj )"
.PD
Get/set the headers object that will provide default header values for
any requests sent.  By default this will be an empty \f(CW\*(C`HTTP::Headers\*(C'\fR
object.
.ie n .IP "$ua\->default_header( $field )" 4
.el .IP "\f(CW$ua\fR\->default_header( \f(CW$field\fR )" 4
.IX Item "$ua->default_header( $field )"
.PD 0
.ie n .IP "$ua\->default_header( $field => $value )" 4
.el .IP "\f(CW$ua\fR\->default_header( \f(CW$field\fR => \f(CW$value\fR )" 4
.IX Item "$ua->default_header( $field => $value )"
.PD
This is just a short-cut for \f(CW$ua\fR\->default_headers\->header( \f(CW$field\fR =>
\&\f(CW$value\fR ). Example:
.Sp
.Vb 2
\&  $ua\->default_header(\*(AqAccept\-Encoding\*(Aq => scalar HTTP::Message::decodable());
\&  $ua\->default_header(\*(AqAccept\-Language\*(Aq => "no, en");
.Ve
.ie n .IP "$ua\->conn_cache" 4
.el .IP "\f(CW$ua\fR\->conn_cache" 4
.IX Item "$ua->conn_cache"
.PD 0
.ie n .IP "$ua\->conn_cache( $cache_obj )" 4
.el .IP "\f(CW$ua\fR\->conn_cache( \f(CW$cache_obj\fR )" 4
.IX Item "$ua->conn_cache( $cache_obj )"
.PD
Get/set the \f(CW\*(C`LWP::ConnCache\*(C'\fR object to use.  See LWP::ConnCache
for details.
.ie n .IP "$ua\->credentials( $netloc, $realm )" 4
.el .IP "\f(CW$ua\fR\->credentials( \f(CW$netloc\fR, \f(CW$realm\fR )" 4
.IX Item "$ua->credentials( $netloc, $realm )"
.PD 0
.ie n .IP "$ua\->credentials( $netloc, $realm, $uname, $pass )" 4
.el .IP "\f(CW$ua\fR\->credentials( \f(CW$netloc\fR, \f(CW$realm\fR, \f(CW$uname\fR, \f(CW$pass\fR )" 4
.IX Item "$ua->credentials( $netloc, $realm, $uname, $pass )"
.PD
Get/set the user name and password to be used for a realm.
.Sp
The \f(CW$netloc\fR is a string of the form \*(L"<host>:<port>\*(R".  The username and
password will only be passed to this server.  Example:
.Sp
.Vb 1
\&  $ua\->credentials("www.example.com:80", "Some Realm", "foo", "secret");
.Ve
.ie n .IP "$ua\->local_address" 4
.el .IP "\f(CW$ua\fR\->local_address" 4
.IX Item "$ua->local_address"
.PD 0
.ie n .IP "$ua\->local_address( $address )" 4
.el .IP "\f(CW$ua\fR\->local_address( \f(CW$address\fR )" 4
.IX Item "$ua->local_address( $address )"
.PD
Get/set the local interface to bind to for network connections.  The interface
can be specified as a hostname or an \s-1IP\s0 address.  This value is passed as the
\&\f(CW\*(C`LocalAddr\*(C'\fR argument to IO::Socket::INET.
.ie n .IP "$ua\->max_size" 4
.el .IP "\f(CW$ua\fR\->max_size" 4
.IX Item "$ua->max_size"
.PD 0
.ie n .IP "$ua\->max_size( $bytes )" 4
.el .IP "\f(CW$ua\fR\->max_size( \f(CW$bytes\fR )" 4
.IX Item "$ua->max_size( $bytes )"
.PD
Get/set the size limit for response content.  The default is \f(CW\*(C`undef\*(C'\fR,
which means that there is no limit.  If the returned response content
is only partial, because the size limit was exceeded, then a
\&\*(L"Client-Aborted\*(R" header will be added to the response.  The content
might end up longer than \f(CW\*(C`max_size\*(C'\fR as we abort once appending a
chunk of data makes the length exceed the limit.  The \*(L"Content-Length\*(R"
header, if present, will indicate the length of the full content and
will normally not be the same as \f(CW\*(C`length($res\->content)\*(C'\fR.
.ie n .IP "$ua\->max_redirect" 4
.el .IP "\f(CW$ua\fR\->max_redirect" 4
.IX Item "$ua->max_redirect"
.PD 0
.ie n .IP "$ua\->max_redirect( $n )" 4
.el .IP "\f(CW$ua\fR\->max_redirect( \f(CW$n\fR )" 4
.IX Item "$ua->max_redirect( $n )"
.PD
This reads or sets the object's limit of how many times it will obey
redirection responses in a given request cycle.
.Sp
By default, the value is 7. This means that if you call \fIrequest()\fR
method and the response is a redirect elsewhere which is in turn a
redirect, and so on seven times, then \s-1LWP\s0 gives up after that seventh
request.
.ie n .IP "$ua\->parse_head" 4
.el .IP "\f(CW$ua\fR\->parse_head" 4
.IX Item "$ua->parse_head"
.PD 0
.ie n .IP "$ua\->parse_head( $boolean )" 4
.el .IP "\f(CW$ua\fR\->parse_head( \f(CW$boolean\fR )" 4
.IX Item "$ua->parse_head( $boolean )"
.PD
Get/set a value indicating whether we should initialize response
headers from the <head> section of \s-1HTML\s0 documents. The default is
\&\s-1TRUE. \s0 Do not turn this off, unless you know what you are doing.
.ie n .IP "$ua\->protocols_allowed" 4
.el .IP "\f(CW$ua\fR\->protocols_allowed" 4
.IX Item "$ua->protocols_allowed"
.PD 0
.ie n .IP "$ua\->protocols_allowed( \e@protocols )" 4
.el .IP "\f(CW$ua\fR\->protocols_allowed( \e@protocols )" 4
.IX Item "$ua->protocols_allowed( @protocols )"
.PD
This reads (or sets) this user agent's list of protocols that the
request methods will exclusively allow.  The protocol names are case
insensitive.
.Sp
For example: \f(CW\*(C`$ua\->protocols_allowed( [ \*(Aqhttp\*(Aq, \*(Aqhttps\*(Aq] );\*(C'\fR
means that this user agent will \fIallow only\fR those protocols,
and attempts to use this user agent to access URLs with any other
schemes (like \*(L"ftp://...\*(R") will result in a 500 error.
.Sp
To delete the list, call: \f(CW\*(C`$ua\->protocols_allowed(undef)\*(C'\fR
.Sp
By default, an object has neither a \f(CW\*(C`protocols_allowed\*(C'\fR list, nor a
\&\f(CW\*(C`protocols_forbidden\*(C'\fR list.
.Sp
Note that having a \f(CW\*(C`protocols_allowed\*(C'\fR list causes any
\&\f(CW\*(C`protocols_forbidden\*(C'\fR list to be ignored.
.ie n .IP "$ua\->protocols_forbidden" 4
.el .IP "\f(CW$ua\fR\->protocols_forbidden" 4
.IX Item "$ua->protocols_forbidden"
.PD 0
.ie n .IP "$ua\->protocols_forbidden( \e@protocols )" 4
.el .IP "\f(CW$ua\fR\->protocols_forbidden( \e@protocols )" 4
.IX Item "$ua->protocols_forbidden( @protocols )"
.PD
This reads (or sets) this user agent's list of protocols that the
request method will \fInot\fR allow. The protocol names are case
insensitive.
.Sp
For example: \f(CW\*(C`$ua\->protocols_forbidden( [ \*(Aqfile\*(Aq, \*(Aqmailto\*(Aq] );\*(C'\fR
means that this user agent will \fInot\fR allow those protocols, and
attempts to use this user agent to access URLs with those schemes
will result in a 500 error.
.Sp
To delete the list, call: \f(CW\*(C`$ua\->protocols_forbidden(undef)\*(C'\fR
.ie n .IP "$ua\->requests_redirectable" 4
.el .IP "\f(CW$ua\fR\->requests_redirectable" 4
.IX Item "$ua->requests_redirectable"
.PD 0
.ie n .IP "$ua\->requests_redirectable( \e@requests )" 4
.el .IP "\f(CW$ua\fR\->requests_redirectable( \e@requests )" 4
.IX Item "$ua->requests_redirectable( @requests )"
.PD
This reads or sets the object's list of request names that
\&\f(CW\*(C`$ua\->redirect_ok(...)\*(C'\fR will allow redirection for.  By
default, this is \f(CW\*(C`[\*(AqGET\*(Aq, \*(AqHEAD\*(Aq]\*(C'\fR, as per \s-1RFC 2616. \s0 To
change to include '\s-1POST\s0', consider:
.Sp
.Vb 1
\&   push @{ $ua\->requests_redirectable }, \*(AqPOST\*(Aq;
.Ve
.ie n .IP "$ua\->show_progress" 4
.el .IP "\f(CW$ua\fR\->show_progress" 4
.IX Item "$ua->show_progress"
.PD 0
.ie n .IP "$ua\->show_progress( $boolean )" 4
.el .IP "\f(CW$ua\fR\->show_progress( \f(CW$boolean\fR )" 4
.IX Item "$ua->show_progress( $boolean )"
.PD
Get/set a value indicating whether a progress bar should be displayed
on on the terminal as requests are processed. The default is \s-1FALSE.\s0
.ie n .IP "$ua\->timeout" 4
.el .IP "\f(CW$ua\fR\->timeout" 4
.IX Item "$ua->timeout"
.PD 0
.ie n .IP "$ua\->timeout( $secs )" 4
.el .IP "\f(CW$ua\fR\->timeout( \f(CW$secs\fR )" 4
.IX Item "$ua->timeout( $secs )"
.PD
Get/set the timeout value in seconds. The default \fItimeout()\fR value is
180 seconds, i.e. 3 minutes.
.Sp
The requests is aborted if no activity on the connection to the server
is observed for \f(CW\*(C`timeout\*(C'\fR seconds.  This means that the time it takes
for the complete transaction and the \fIrequest()\fR method to actually
return might be longer.
.ie n .IP "$ua\->ssl_opts" 4
.el .IP "\f(CW$ua\fR\->ssl_opts" 4
.IX Item "$ua->ssl_opts"
.PD 0
.ie n .IP "$ua\->ssl_opts( $key )" 4
.el .IP "\f(CW$ua\fR\->ssl_opts( \f(CW$key\fR )" 4
.IX Item "$ua->ssl_opts( $key )"
.ie n .IP "$ua\->ssl_opts( $key => $value )" 4
.el .IP "\f(CW$ua\fR\->ssl_opts( \f(CW$key\fR => \f(CW$value\fR )" 4
.IX Item "$ua->ssl_opts( $key => $value )"
.PD
Get/set the options for \s-1SSL\s0 connections.  Without argument return the list
of options keys currently set.  With a single argument return the current
value for the given option.  With 2 arguments set the option value and return
the old.  Setting an option to the value \f(CW\*(C`undef\*(C'\fR removes this option.
.Sp
The options that \s-1LWP\s0 relates to are:
.RS 4
.ie n .IP """verify_hostname"" => $bool" 4
.el .IP "\f(CWverify_hostname\fR => \f(CW$bool\fR" 4
.IX Item "verify_hostname => $bool"
When \s-1TRUE LWP\s0 will for secure protocol schemes ensure it connects to servers
that have a valid certificate matching the expected hostname.  If \s-1FALSE\s0 no
checks are made and you can't be sure that you communicate with the expected peer.
The no checks behaviour was the default for libwww\-perl\-5.837 and earlier releases.
.Sp
This option is initialized from the \s-1PERL_LWP_SSL_VERIFY_HOSTNAME\s0 environment
variable.  If this environment variable isn't set; then \f(CW\*(C`verify_hostname\*(C'\fR
defaults to 1.
.ie n .IP """SSL_ca_file"" => $path" 4
.el .IP "\f(CWSSL_ca_file\fR => \f(CW$path\fR" 4
.IX Item "SSL_ca_file => $path"
The path to a file containing Certificate Authority certificates.
A default setting for this option is provided by checking the environment
variables \f(CW\*(C`PERL_LWP_SSL_CA_FILE\*(C'\fR and \f(CW\*(C`HTTPS_CA_FILE\*(C'\fR in order.
.ie n .IP """SSL_ca_path"" => $path" 4
.el .IP "\f(CWSSL_ca_path\fR => \f(CW$path\fR" 4
.IX Item "SSL_ca_path => $path"
The path to a directory containing files containing Certificate Authority
certificates.
A default setting for this option is provided by checking the environment
variables \f(CW\*(C`PERL_LWP_SSL_CA_PATH\*(C'\fR and \f(CW\*(C`HTTPS_CA_DIR\*(C'\fR in order.
.RE
.RS 4
.Sp
Other options can be set and are processed directly by the \s-1SSL\s0 Socket implementation
in use.  See IO::Socket::SSL or Net::SSL for details.
.Sp
The libwww-perl core no longer bundles protocol plugins for \s-1SSL. \s0 You will need
to install LWP::Protocol::https separately to enable support for processing
https-URLs.
.RE
.SS "Proxy attributes"
.IX Subsection "Proxy attributes"
The following methods set up when requests should be passed via a
proxy server.
.ie n .IP "$ua\->proxy(\e@schemes, $proxy_url)" 4
.el .IP "\f(CW$ua\fR\->proxy(\e@schemes, \f(CW$proxy_url\fR)" 4
.IX Item "$ua->proxy(@schemes, $proxy_url)"
.PD 0
.ie n .IP "$ua\->proxy($scheme, $proxy_url)" 4
.el .IP "\f(CW$ua\fR\->proxy($scheme, \f(CW$proxy_url\fR)" 4
.IX Item "$ua->proxy($scheme, $proxy_url)"
.PD
Set/retrieve proxy \s-1URL\s0 for a scheme:
.Sp
.Vb 2
\& $ua\->proxy([\*(Aqhttp\*(Aq, \*(Aqftp\*(Aq], \*(Aqhttp://proxy.sn.no:8001/\*(Aq);
\& $ua\->proxy(\*(Aqgopher\*(Aq, \*(Aqhttp://proxy.sn.no:8001/\*(Aq);
.Ve
.Sp
The first form specifies that the \s-1URL\s0 is to be used for proxying of
access methods listed in the list in the first method argument,
i.e. 'http' and 'ftp'.
.Sp
The second form shows a shorthand form for specifying
proxy \s-1URL\s0 for a single access scheme.
.ie n .IP "$ua\->no_proxy( $domain, ... )" 4
.el .IP "\f(CW$ua\fR\->no_proxy( \f(CW$domain\fR, ... )" 4
.IX Item "$ua->no_proxy( $domain, ... )"
Do not proxy requests to the given domains.  Calling no_proxy without
any domains clears the list of domains. Eg:
.Sp
.Vb 1
\& $ua\->no_proxy(\*(Aqlocalhost\*(Aq, \*(Aqexample.com\*(Aq);
.Ve
.ie n .IP "$ua\->env_proxy" 4
.el .IP "\f(CW$ua\fR\->env_proxy" 4
.IX Item "$ua->env_proxy"
Load proxy settings from *_proxy environment variables.  You might
specify proxies like this (sh-syntax):
.Sp
.Vb 4
\&  gopher_proxy=http://proxy.my.place/
\&  wais_proxy=http://proxy.my.place/
\&  no_proxy="localhost,example.com"
\&  export gopher_proxy wais_proxy no_proxy
.Ve
.Sp
csh or tcsh users should use the \f(CW\*(C`setenv\*(C'\fR command to define these
environment variables.
.Sp
On systems with case insensitive environment variables there exists a
name clash between the \s-1CGI\s0 environment variables and the \f(CW\*(C`HTTP_PROXY\*(C'\fR
environment variable normally picked up by \fIenv_proxy()\fR.  Because of
this \f(CW\*(C`HTTP_PROXY\*(C'\fR is not honored for \s-1CGI\s0 scripts.  The
\&\f(CW\*(C`CGI_HTTP_PROXY\*(C'\fR environment variable can be used instead.
.SS "Handlers"
.IX Subsection "Handlers"
Handlers are code that injected at various phases during the
processing of requests.  The following methods are provided to manage
the active handlers:
.ie n .IP "$ua\->add_handler( $phase => \e&cb, %matchspec )" 4
.el .IP "\f(CW$ua\fR\->add_handler( \f(CW$phase\fR => \e&cb, \f(CW%matchspec\fR )" 4
.IX Item "$ua->add_handler( $phase => &cb, %matchspec )"
Add handler to be invoked in the given processing phase.  For how to
specify \f(CW%matchspec\fR see \*(L"Matching\*(R" in HTTP::Config.
.Sp
The possible values \f(CW$phase\fR and the corresponding callback signatures are:
.RS 4
.ie n .IP "request_preprepare => sub { my($request, $ua, $h) = @_; ... }" 4
.el .IP "request_preprepare => sub { my($request, \f(CW$ua\fR, \f(CW$h\fR) = \f(CW@_\fR; ... }" 4
.IX Item "request_preprepare => sub { my($request, $ua, $h) = @_; ... }"
The handler is called before the \f(CW\*(C`request_prepare\*(C'\fR and other standard
initialization of of the request.  This can be used to set up headers
and attributes that the \f(CW\*(C`request_prepare\*(C'\fR handler depends on.  Proxy
initialization should take place here; but in general don't register
handlers for this phase.
.ie n .IP "request_prepare => sub { my($request, $ua, $h) = @_; ... }" 4
.el .IP "request_prepare => sub { my($request, \f(CW$ua\fR, \f(CW$h\fR) = \f(CW@_\fR; ... }" 4
.IX Item "request_prepare => sub { my($request, $ua, $h) = @_; ... }"
The handler is called before the request is sent and can modify the
request any way it see fit.  This can for instance be used to add
certain headers to specific requests.
.Sp
The method can assign a new request object to \f(CW$_\fR[0] to replace the
request that is sent fully.
.Sp
The return value from the callback is ignored.  If an exception is
raised it will abort the request and make the request method return a
\&\*(L"400 Bad request\*(R" response.
.ie n .IP "request_send => sub { my($request, $ua, $h) = @_; ... }" 4
.el .IP "request_send => sub { my($request, \f(CW$ua\fR, \f(CW$h\fR) = \f(CW@_\fR; ... }" 4
.IX Item "request_send => sub { my($request, $ua, $h) = @_; ... }"
This handler gets a chance of handling requests before they're sent to the
protocol handlers.  It should return an HTTP::Response object if it
wishes to terminate the processing; otherwise it should return nothing.
.Sp
The \f(CW\*(C`response_header\*(C'\fR and \f(CW\*(C`response_data\*(C'\fR handlers will not be
invoked for this response, but the \f(CW\*(C`response_done\*(C'\fR will be.
.ie n .IP "response_header => sub { my($response, $ua, $h) = @_; ... }" 4
.el .IP "response_header => sub { my($response, \f(CW$ua\fR, \f(CW$h\fR) = \f(CW@_\fR; ... }" 4
.IX Item "response_header => sub { my($response, $ua, $h) = @_; ... }"
This handler is called right after the response headers have been
received, but before any content data.  The handler might set up
handlers for data and might croak to abort the request.
.Sp
The handler might set the \f(CW$response\fR\->{default_add_content} value to
control if any received data should be added to the response object
directly.  This will initially be false if the \f(CW$ua\fR\->\fIrequest()\fR method
was called with a \f(CW$content_file\fR or \f(CW$content_cb\fR argument; otherwise true.
.ie n .IP "response_data => sub { my($response, $ua, $h, $data) = @_; ... }" 4
.el .IP "response_data => sub { my($response, \f(CW$ua\fR, \f(CW$h\fR, \f(CW$data\fR) = \f(CW@_\fR; ... }" 4
.IX Item "response_data => sub { my($response, $ua, $h, $data) = @_; ... }"
This handler is called for each chunk of data received for the
response.  The handler might croak to abort the request.
.Sp
This handler needs to return a \s-1TRUE\s0 value to be called again for
subsequent chunks for the same request.
.ie n .IP "response_done => sub { my($response, $ua, $h) = @_; ... }" 4
.el .IP "response_done => sub { my($response, \f(CW$ua\fR, \f(CW$h\fR) = \f(CW@_\fR; ... }" 4
.IX Item "response_done => sub { my($response, $ua, $h) = @_; ... }"
The handler is called after the response has been fully received, but
before any redirect handling is attempted.  The handler can be used to
extract information or modify the response.
.ie n .IP "response_redirect => sub { my($response, $ua, $h) = @_; ... }" 4
.el .IP "response_redirect => sub { my($response, \f(CW$ua\fR, \f(CW$h\fR) = \f(CW@_\fR; ... }" 4
.IX Item "response_redirect => sub { my($response, $ua, $h) = @_; ... }"
The handler is called in \f(CW$ua\fR\->request after \f(CW\*(C`response_done\*(C'\fR.  If the
handler returns an HTTP::Request object we'll start over with processing
this request instead.
.RE
.RS 4
.RE
.ie n .IP "$ua\->remove_handler( undef, %matchspec )" 4
.el .IP "\f(CW$ua\fR\->remove_handler( undef, \f(CW%matchspec\fR )" 4
.IX Item "$ua->remove_handler( undef, %matchspec )"
.PD 0
.ie n .IP "$ua\->remove_handler( $phase, %matchspec )" 4
.el .IP "\f(CW$ua\fR\->remove_handler( \f(CW$phase\fR, \f(CW%matchspec\fR )" 4
.IX Item "$ua->remove_handler( $phase, %matchspec )"
.PD
Remove handlers that match the given \f(CW%matchspec\fR.  If \f(CW$phase\fR is not
provided remove handlers from all phases.
.Sp
Be careful as calling this function with \f(CW%matchspec\fR that is not not
specific enough can remove handlers not owned by you.  It's probably
better to use the \fIset_my_handler()\fR method instead.
.Sp
The removed handlers are returned.
.ie n .IP "$ua\->set_my_handler( $phase, $cb, %matchspec )" 4
.el .IP "\f(CW$ua\fR\->set_my_handler( \f(CW$phase\fR, \f(CW$cb\fR, \f(CW%matchspec\fR )" 4
.IX Item "$ua->set_my_handler( $phase, $cb, %matchspec )"
Set handlers private to the executing subroutine.  Works by defaulting
an \f(CW\*(C`owner\*(C'\fR field to the \f(CW%matchspec\fR that holds the name of the called
subroutine.  You might pass an explicit \f(CW\*(C`owner\*(C'\fR to override this.
.Sp
If \f(CW$cb\fR is passed as \f(CW\*(C`undef\*(C'\fR, remove the handler.
.ie n .IP "$ua\->get_my_handler( $phase, %matchspec )" 4
.el .IP "\f(CW$ua\fR\->get_my_handler( \f(CW$phase\fR, \f(CW%matchspec\fR )" 4
.IX Item "$ua->get_my_handler( $phase, %matchspec )"
.PD 0
.ie n .IP "$ua\->get_my_handler( $phase, %matchspec, $init )" 4
.el .IP "\f(CW$ua\fR\->get_my_handler( \f(CW$phase\fR, \f(CW%matchspec\fR, \f(CW$init\fR )" 4
.IX Item "$ua->get_my_handler( $phase, %matchspec, $init )"
.PD
Will retrieve the matching handler as hash ref.
.Sp
If \f(CW$init\fR is passed passed as a \s-1TRUE\s0 value, create and add the
handler if it's not found.  If \f(CW$init\fR is a subroutine reference, then
it's called with the created handler hash as argument.  This sub might
populate the hash with extra fields; especially the callback.  If
\&\f(CW$init\fR is a hash reference, merge the hashes.
.ie n .IP "$ua\->handlers( $phase, $request )" 4
.el .IP "\f(CW$ua\fR\->handlers( \f(CW$phase\fR, \f(CW$request\fR )" 4
.IX Item "$ua->handlers( $phase, $request )"
.PD 0
.ie n .IP "$ua\->handlers( $phase, $response )" 4
.el .IP "\f(CW$ua\fR\->handlers( \f(CW$phase\fR, \f(CW$response\fR )" 4
.IX Item "$ua->handlers( $phase, $response )"
.PD
Returns the handlers that apply to the given request or response at
the given processing phase.
.SH "REQUEST METHODS"
.IX Header "REQUEST METHODS"
The methods described in this section are used to dispatch requests
via the user agent.  The following request methods are provided:
.ie n .IP "$ua\->get( $url )" 4
.el .IP "\f(CW$ua\fR\->get( \f(CW$url\fR )" 4
.IX Item "$ua->get( $url )"
.PD 0
.ie n .IP "$ua\->get( $url , $field_name => $value, ... )" 4
.el .IP "\f(CW$ua\fR\->get( \f(CW$url\fR , \f(CW$field_name\fR => \f(CW$value\fR, ... )" 4
.IX Item "$ua->get( $url , $field_name => $value, ... )"
.PD
This method will dispatch a \f(CW\*(C`GET\*(C'\fR request on the given \f(CW$url\fR.  Further
arguments can be given to initialize the headers of the request. These
are given as separate name/value pairs.  The return value is a
response object.  See HTTP::Response for a description of the
interface it provides.
.Sp
There will still be a response object returned when \s-1LWP\s0 can't connect to the
server specified in the \s-1URL\s0 or when other failures in protocol handlers occur.
These internal responses use the standard \s-1HTTP\s0 status codes, so the responses
can't be differentiated by testing the response status code alone.  Error
responses that \s-1LWP\s0 generates internally will have the \*(L"Client-Warning\*(R" header
set to the value \*(L"Internal response\*(R".  If you need to differentiate these
internal responses from responses that a remote server actually generates, you
need to test this header value.
.Sp
Fields names that start with \*(L":\*(R" are special.  These will not
initialize headers of the request but will determine how the response
content is treated.  The following special field names are recognized:
.Sp
.Vb 3
\&    :content_file   => $filename
\&    :content_cb     => \e&callback
\&    :read_size_hint => $bytes
.Ve
.Sp
If a \f(CW$filename\fR is provided with the \f(CW\*(C`:content_file\*(C'\fR option, then the
response content will be saved here instead of in the response
object.  If a callback is provided with the \f(CW\*(C`:content_cb\*(C'\fR option then
this function will be called for each chunk of the response content as
it is received from the server.  If neither of these options are
given, then the response content will accumulate in the response
object itself.  This might not be suitable for very large response
bodies.  Only one of \f(CW\*(C`:content_file\*(C'\fR or \f(CW\*(C`:content_cb\*(C'\fR can be
specified.  The content of unsuccessful responses will always
accumulate in the response object itself, regardless of the
\&\f(CW\*(C`:content_file\*(C'\fR or \f(CW\*(C`:content_cb\*(C'\fR options passed in.
.Sp
The \f(CW\*(C`:read_size_hint\*(C'\fR option is passed to the protocol module which
will try to read data from the server in chunks of this size.  A
smaller value for the \f(CW\*(C`:read_size_hint\*(C'\fR will result in a higher
number of callback invocations.
.Sp
The callback function is called with 3 arguments: a chunk of data, a
reference to the response object, and a reference to the protocol
object.  The callback can abort the request by invoking \fIdie()\fR.  The
exception message will show up as the \*(L"X\-Died\*(R" header field in the
response returned by the \fIget()\fR function.
.ie n .IP "$ua\->head( $url )" 4
.el .IP "\f(CW$ua\fR\->head( \f(CW$url\fR )" 4
.IX Item "$ua->head( $url )"
.PD 0
.ie n .IP "$ua\->head( $url , $field_name => $value, ... )" 4
.el .IP "\f(CW$ua\fR\->head( \f(CW$url\fR , \f(CW$field_name\fR => \f(CW$value\fR, ... )" 4
.IX Item "$ua->head( $url , $field_name => $value, ... )"
.PD
This method will dispatch a \f(CW\*(C`HEAD\*(C'\fR request on the given \f(CW$url\fR.
Otherwise it works like the \fIget()\fR method described above.
.ie n .IP "$ua\->post( $url, \e%form )" 4
.el .IP "\f(CW$ua\fR\->post( \f(CW$url\fR, \e%form )" 4
.IX Item "$ua->post( $url, %form )"
.PD 0
.ie n .IP "$ua\->post( $url, \e@form )" 4
.el .IP "\f(CW$ua\fR\->post( \f(CW$url\fR, \e@form )" 4
.IX Item "$ua->post( $url, @form )"
.ie n .IP "$ua\->post( $url, \e%form, $field_name => $value, ... )" 4
.el .IP "\f(CW$ua\fR\->post( \f(CW$url\fR, \e%form, \f(CW$field_name\fR => \f(CW$value\fR, ... )" 4
.IX Item "$ua->post( $url, %form, $field_name => $value, ... )"
.ie n .IP "$ua\->post( $url, $field_name => $value,... Content => \e%form )" 4
.el .IP "\f(CW$ua\fR\->post( \f(CW$url\fR, \f(CW$field_name\fR => \f(CW$value\fR,... Content => \e%form )" 4
.IX Item "$ua->post( $url, $field_name => $value,... Content => %form )"
.ie n .IP "$ua\->post( $url, $field_name => $value,... Content => \e@form )" 4
.el .IP "\f(CW$ua\fR\->post( \f(CW$url\fR, \f(CW$field_name\fR => \f(CW$value\fR,... Content => \e@form )" 4
.IX Item "$ua->post( $url, $field_name => $value,... Content => @form )"
.ie n .IP "$ua\->post( $url, $field_name => $value,... Content => $content )" 4
.el .IP "\f(CW$ua\fR\->post( \f(CW$url\fR, \f(CW$field_name\fR => \f(CW$value\fR,... Content => \f(CW$content\fR )" 4
.IX Item "$ua->post( $url, $field_name => $value,... Content => $content )"
.PD
This method will dispatch a \f(CW\*(C`POST\*(C'\fR request on the given \f(CW$url\fR, with
\&\f(CW%form\fR or \f(CW@form\fR providing the key/value pairs for the fill-in form
content. Additional headers and content options are the same as for
the \fIget()\fR method.
.Sp
This method will use the \s-1\fIPOST\s0()\fR function from \f(CW\*(C`HTTP::Request::Common\*(C'\fR
to build the request.  See HTTP::Request::Common for a details on
how to pass form content and other advanced features.
.ie n .IP "$ua\->put( $url, \e%form )" 4
.el .IP "\f(CW$ua\fR\->put( \f(CW$url\fR, \e%form )" 4
.IX Item "$ua->put( $url, %form )"
.PD 0
.ie n .IP "$ua\->put( $url, \e@form )" 4
.el .IP "\f(CW$ua\fR\->put( \f(CW$url\fR, \e@form )" 4
.IX Item "$ua->put( $url, @form )"
.ie n .IP "$ua\->put( $url, \e%form, $field_name => $value, ... )" 4
.el .IP "\f(CW$ua\fR\->put( \f(CW$url\fR, \e%form, \f(CW$field_name\fR => \f(CW$value\fR, ... )" 4
.IX Item "$ua->put( $url, %form, $field_name => $value, ... )"
.ie n .IP "$ua\->put( $url, $field_name => $value,... Content => \e%form )" 4
.el .IP "\f(CW$ua\fR\->put( \f(CW$url\fR, \f(CW$field_name\fR => \f(CW$value\fR,... Content => \e%form )" 4
.IX Item "$ua->put( $url, $field_name => $value,... Content => %form )"
.ie n .IP "$ua\->put( $url, $field_name => $value,... Content => \e@form )" 4
.el .IP "\f(CW$ua\fR\->put( \f(CW$url\fR, \f(CW$field_name\fR => \f(CW$value\fR,... Content => \e@form )" 4
.IX Item "$ua->put( $url, $field_name => $value,... Content => @form )"
.ie n .IP "$ua\->put( $url, $field_name => $value,... Content => $content )" 4
.el .IP "\f(CW$ua\fR\->put( \f(CW$url\fR, \f(CW$field_name\fR => \f(CW$value\fR,... Content => \f(CW$content\fR )" 4
.IX Item "$ua->put( $url, $field_name => $value,... Content => $content )"
.PD
This method will dispatch a \f(CW\*(C`PUT\*(C'\fR request on the given \f(CW$url\fR, with
\&\f(CW%form\fR or \f(CW@form\fR providing the key/value pairs for the fill-in form
content. Additional headers and content options are the same as for
the \fIget()\fR method.
.Sp
This method will use the \s-1\fIPUT\s0()\fR function from \f(CW\*(C`HTTP::Request::Common\*(C'\fR
to build the request.  See HTTP::Request::Common for a details on
how to pass form content and other advanced features.
.ie n .IP "$ua\->delete( $url )" 4
.el .IP "\f(CW$ua\fR\->delete( \f(CW$url\fR )" 4
.IX Item "$ua->delete( $url )"
.PD 0
.ie n .IP "$ua\->delete( $url, $field_name => $value, ... )" 4
.el .IP "\f(CW$ua\fR\->delete( \f(CW$url\fR, \f(CW$field_name\fR => \f(CW$value\fR, ... )" 4
.IX Item "$ua->delete( $url, $field_name => $value, ... )"
.PD
This method will dispatch a \f(CW\*(C`DELETE\*(C'\fR request on the given \f(CW$url\fR.  Additional
headers and content options are the same as for the \fIget()\fR method.
.Sp
This method will use the \s-1\fIDELETE\s0()\fR function from \f(CW\*(C`HTTP::Request::Common\*(C'\fR
to build the request.  See HTTP::Request::Common for a details on
how to pass form content and other advanced features.
.ie n .IP "$ua\->mirror( $url, $filename )" 4
.el .IP "\f(CW$ua\fR\->mirror( \f(CW$url\fR, \f(CW$filename\fR )" 4
.IX Item "$ua->mirror( $url, $filename )"
This method will get the document identified by \f(CW$url\fR and store it in
file called \f(CW$filename\fR.  If the file already exists, then the request
will contain an \*(L"If-Modified-Since\*(R" header matching the modification
time of the file.  If the document on the server has not changed since
this time, then nothing happens.  If the document has been updated, it
will be downloaded again.  The modification time of the file will be
forced to match that of the server.
.Sp
The return value is the the response object.
.ie n .IP "$ua\->request( $request )" 4
.el .IP "\f(CW$ua\fR\->request( \f(CW$request\fR )" 4
.IX Item "$ua->request( $request )"
.PD 0
.ie n .IP "$ua\->request( $request, $content_file )" 4
.el .IP "\f(CW$ua\fR\->request( \f(CW$request\fR, \f(CW$content_file\fR )" 4
.IX Item "$ua->request( $request, $content_file )"
.ie n .IP "$ua\->request( $request, $content_cb )" 4
.el .IP "\f(CW$ua\fR\->request( \f(CW$request\fR, \f(CW$content_cb\fR )" 4
.IX Item "$ua->request( $request, $content_cb )"
.ie n .IP "$ua\->request( $request, $content_cb, $read_size_hint )" 4
.el .IP "\f(CW$ua\fR\->request( \f(CW$request\fR, \f(CW$content_cb\fR, \f(CW$read_size_hint\fR )" 4
.IX Item "$ua->request( $request, $content_cb, $read_size_hint )"
.PD
This method will dispatch the given \f(CW$request\fR object.  Normally this
will be an instance of the \f(CW\*(C`HTTP::Request\*(C'\fR class, but any object with
a similar interface will do.  The return value is a response object.
See HTTP::Request and HTTP::Response for a description of the
interface provided by these classes.
.Sp
The \fIrequest()\fR method will process redirects and authentication
responses transparently.  This means that it may actually send several
simple requests via the \fIsimple_request()\fR method described below.
.Sp
The request methods described above; \fIget()\fR, \fIhead()\fR, \fIpost()\fR and
\&\fImirror()\fR, will all dispatch the request they build via this method.
They are convenience methods that simply hides the creation of the
request object for you.
.Sp
The \f(CW$content_file\fR, \f(CW$content_cb\fR and \f(CW$read_size_hint\fR all correspond to
options described with the \fIget()\fR method above.
.Sp
You are allowed to use a \s-1CODE\s0 reference as \f(CW\*(C`content\*(C'\fR in the request
object passed in.  The \f(CW\*(C`content\*(C'\fR function should return the content
when called.  The content can be returned in chunks.  The content
function will be invoked repeatedly until it return an empty string to
signal that there is no more content.
.ie n .IP "$ua\->simple_request( $request )" 4
.el .IP "\f(CW$ua\fR\->simple_request( \f(CW$request\fR )" 4
.IX Item "$ua->simple_request( $request )"
.PD 0
.ie n .IP "$ua\->simple_request( $request, $content_file )" 4
.el .IP "\f(CW$ua\fR\->simple_request( \f(CW$request\fR, \f(CW$content_file\fR )" 4
.IX Item "$ua->simple_request( $request, $content_file )"
.ie n .IP "$ua\->simple_request( $request, $content_cb )" 4
.el .IP "\f(CW$ua\fR\->simple_request( \f(CW$request\fR, \f(CW$content_cb\fR )" 4
.IX Item "$ua->simple_request( $request, $content_cb )"
.ie n .IP "$ua\->simple_request( $request, $content_cb, $read_size_hint )" 4
.el .IP "\f(CW$ua\fR\->simple_request( \f(CW$request\fR, \f(CW$content_cb\fR, \f(CW$read_size_hint\fR )" 4
.IX Item "$ua->simple_request( $request, $content_cb, $read_size_hint )"
.PD
This method dispatches a single request and returns the response
received.  Arguments are the same as for \fIrequest()\fR described above.
.Sp
The difference from \fIrequest()\fR is that \fIsimple_request()\fR will not try to
handle redirects or authentication responses.  The \fIrequest()\fR method
will in fact invoke this method for each simple request it sends.
.ie n .IP "$ua\->is_online" 4
.el .IP "\f(CW$ua\fR\->is_online" 4
.IX Item "$ua->is_online"
Tries to determine if you have access to the Internet.  Returns
\&\s-1TRUE\s0 if the built-in heuristics determine that the user agent is
able to access the Internet (over \s-1HTTP\s0).  See also LWP::Online.
.ie n .IP "$ua\->is_protocol_supported( $scheme )" 4
.el .IP "\f(CW$ua\fR\->is_protocol_supported( \f(CW$scheme\fR )" 4
.IX Item "$ua->is_protocol_supported( $scheme )"
You can use this method to test whether this user agent object supports the
specified \f(CW\*(C`scheme\*(C'\fR.  (The \f(CW\*(C`scheme\*(C'\fR might be a string (like 'http' or
\&'ftp') or it might be an \s-1URI\s0 object reference.)
.Sp
Whether a scheme is supported, is determined by the user agent's
\&\f(CW\*(C`protocols_allowed\*(C'\fR or \f(CW\*(C`protocols_forbidden\*(C'\fR lists (if any), and by
the capabilities of \s-1LWP.  I\s0.e., this will return \s-1TRUE\s0 only if \s-1LWP\s0
supports this protocol \fIand\fR it's permitted for this particular
object.
.SS "Callback methods"
.IX Subsection "Callback methods"
The following methods will be invoked as requests are processed. These
methods are documented here because subclasses of \f(CW\*(C`LWP::UserAgent\*(C'\fR
might want to override their behaviour.
.ie n .IP "$ua\->prepare_request( $request )" 4
.el .IP "\f(CW$ua\fR\->prepare_request( \f(CW$request\fR )" 4
.IX Item "$ua->prepare_request( $request )"
This method is invoked by \fIsimple_request()\fR.  Its task is to modify the
given \f(CW$request\fR object by setting up various headers based on the
attributes of the user agent. The return value should normally be the
\&\f(CW$request\fR object passed in.  If a different request object is returned
it will be the one actually processed.
.Sp
The headers affected by the base implementation are; \*(L"User-Agent\*(R",
\&\*(L"From\*(R", \*(L"Range\*(R" and \*(L"Cookie\*(R".
.ie n .IP "$ua\->redirect_ok( $prospective_request, $response )" 4
.el .IP "\f(CW$ua\fR\->redirect_ok( \f(CW$prospective_request\fR, \f(CW$response\fR )" 4
.IX Item "$ua->redirect_ok( $prospective_request, $response )"
This method is called by \fIrequest()\fR before it tries to follow a
redirection to the request in \f(CW$response\fR.  This should return a \s-1TRUE\s0
value if this redirection is permissible.  The \f(CW$prospective_request\fR
will be the request to be sent if this method returns \s-1TRUE.\s0
.Sp
The base implementation will return \s-1FALSE\s0 unless the method
is in the object's \f(CW\*(C`requests_redirectable\*(C'\fR list,
\&\s-1FALSE\s0 if the proposed redirection is to a \*(L"file://...\*(R"
\&\s-1URL,\s0 and \s-1TRUE\s0 otherwise.
.ie n .IP "$ua\->get_basic_credentials( $realm, $uri, $isproxy )" 4
.el .IP "\f(CW$ua\fR\->get_basic_credentials( \f(CW$realm\fR, \f(CW$uri\fR, \f(CW$isproxy\fR )" 4
.IX Item "$ua->get_basic_credentials( $realm, $uri, $isproxy )"
This is called by \fIrequest()\fR to retrieve credentials for documents
protected by Basic or Digest Authentication.  The arguments passed in
is the \f(CW$realm\fR provided by the server, the \f(CW$uri\fR requested and a boolean
flag to indicate if this is authentication against a proxy server.
.Sp
The method should return a username and password.  It should return an
empty list to abort the authentication resolution attempt.  Subclasses
can override this method to prompt the user for the information. An
example of this can be found in \f(CW\*(C`lwp\-request\*(C'\fR program distributed
with this library.
.Sp
The base implementation simply checks a set of pre-stored member
variables, set up with the \fIcredentials()\fR method.
.ie n .IP "$ua\->progress( $status, $request_or_response )" 4
.el .IP "\f(CW$ua\fR\->progress( \f(CW$status\fR, \f(CW$request_or_response\fR )" 4
.IX Item "$ua->progress( $status, $request_or_response )"
This is called frequently as the response is received regardless of
how the content is processed.  The method is called with \f(CW$status\fR
\&\*(L"begin\*(R" at the start of processing the request and with \f(CW$state\fR \*(L"end\*(R"
before the request method returns.  In between these \f(CW$status\fR will be
the fraction of the response currently received or the string \*(L"tick\*(R"
if the fraction can't be calculated.
.Sp
When \f(CW$status\fR is \*(L"begin\*(R" the second argument is the request object,
otherwise it is the response object.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
See \s-1LWP\s0 for a complete overview of libwww\-perl5.  See lwpcook
and the scripts \fIlwp-request\fR and \fIlwp-download\fR for examples of
usage.
.PP
See HTTP::Request and HTTP::Response for a description of the
message objects dispatched and received.  See HTTP::Request::Common
and HTML::Form for other ways to build request objects.
.PP
See WWW::Mechanize and WWW::Search for examples of more
specialized user agents based on \f(CW\*(C`LWP::UserAgent\*(C'\fR.
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright 1995\-2009 Gisle Aas.
.PP
This library is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.
