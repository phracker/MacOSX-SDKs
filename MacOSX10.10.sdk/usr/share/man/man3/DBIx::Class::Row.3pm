.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "DBIx::Class::Row 3"
.TH DBIx::Class::Row 3 "2014-01-22" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
DBIx::Class::Row \- Basic row methods
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This class is responsible for defining and doing basic operations on rows
derived from DBIx::Class::ResultSource objects.
.PP
Result objects are returned from DBIx::Class::ResultSets using the
create, find,
next and all methods,
as well as invocations of 'single' (
belongs_to,
has_one or
might_have)
relationship accessors of Result objects.
.SH "NOTE"
.IX Header "NOTE"
All \*(L"Row objects\*(R" derived from a Schema-attached DBIx::Class::ResultSet
object (such as a typical \f(CW\*(C`search\->
next\*(C'\fR call) are actually Result
instances, based on your application's
Result class.
.PP
DBIx::Class::Row implements most of the row-based communication with the
underlying storage, but a Result class \fBshould not inherit from it directly\fR.
Usually, Result classes inherit from DBIx::Class::Core, which in turn
combines the methods from several classes, one of them being
DBIx::Class::Row.  Therefore, while many of the methods available to a
DBIx::Class::Core\-derived Result class are described in the following
documentation, it does not detail all of the methods available to Result
objects.  Refer to DBIx::Class::Manual::ResultClass for more info.
.SH "METHODS"
.IX Header "METHODS"
.SS "new"
.IX Subsection "new"
.Vb 1
\&  my $result = My::Class\->new(\e%attrs);
\&
\&  my $result = $schema\->resultset(\*(AqMySource\*(Aq)\->new(\e%colsandvalues);
.Ve
.IP "Arguments: \e%attrs or \e%colsandvalues" 4
.IX Item "Arguments: %attrs or %colsandvalues"
.PD 0
.ie n .IP "Return Value: $result" 4
.el .IP "Return Value: \f(CW$result\fR" 4
.IX Item "Return Value: $result"
.PD
.PP
While you can create a new result object by calling \f(CW\*(C`new\*(C'\fR directly on
this class, you are better off calling it on a
DBIx::Class::ResultSet object.
.PP
When calling it directly, you will not get a complete, usable row
object until you pass or set the \f(CW\*(C`result_source\*(C'\fR attribute, to a
DBIx::Class::ResultSource instance that is attached to a
DBIx::Class::Schema with a valid connection.
.PP
\&\f(CW$attrs\fR is a hashref of column name, value data. It can also contain
some other attributes such as the \f(CW\*(C`result_source\*(C'\fR.
.PP
Passing an object, or an arrayref of objects as a value will call
\&\*(L"set_from_related\*(R" in DBIx::Class::Relationship::Base for you. When
passed a hashref or an arrayref of hashrefs as the value, these will
be turned into objects via new_related, and treated as if you had
passed objects.
.PP
For a more involved explanation, see \*(L"create\*(R" in DBIx::Class::ResultSet.
.PP
Please note that if a value is not passed to new, no value will be sent
in the \s-1SQL INSERT\s0 call, and the column will therefore assume whatever
default value was specified in your database. While \s-1DBIC\s0 will retrieve the
value of autoincrement columns, it will never make an explicit database
trip to retrieve default values assigned by the \s-1RDBMS.\s0 You can explicitly
request that all values be fetched back from the database by calling
\&\*(L"discard_changes\*(R", or you can supply an explicit \f(CW\*(C`undef\*(C'\fR to columns
with \s-1NULL\s0 as the default, and save yourself a \s-1SELECT.\s0
.PP
.Vb 1
\& CAVEAT:
\&
\& The behavior described above will backfire if you use a foreign key column
\& with a database\-defined default. If you call the relationship accessor on
\& an object that doesn\*(Aqt have a set value for the FK column, DBIC will throw
\& an exception, as it has no way of knowing the PK of the related object (if
\& there is one).
.Ve
.ie n .SS "$column_accessor"
.el .SS "\f(CW$column_accessor\fP"
.IX Subsection "$column_accessor"
.Vb 1
\&  # Each pair does the same thing
\&
\&  # (un\-inflated, regular column)
\&  my $val = $result\->get_column(\*(Aqfirst_name\*(Aq);
\&  my $val = $result\->first_name;
\&
\&  $result\->set_column(\*(Aqfirst_name\*(Aq => $val);
\&  $result\->first_name($val);
\&
\&  # (inflated column via DBIx::Class::InflateColumn::DateTime)
\&  my $val = $result\->get_inflated_column(\*(Aqlast_modified\*(Aq);
\&  my $val = $result\->last_modified;
\&
\&  $result\->set_inflated_column(\*(Aqlast_modified\*(Aq => $val);
\&  $result\->last_modified($val);
.Ve
.ie n .IP "Arguments: $value?" 4
.el .IP "Arguments: \f(CW$value\fR?" 4
.IX Item "Arguments: $value?"
.PD 0
.ie n .IP "Return Value: $value" 4
.el .IP "Return Value: \f(CW$value\fR" 4
.IX Item "Return Value: $value"
.PD
.PP
A column accessor method is created for each column, which is used for
getting/setting the value for that column.
.PP
The actual method name is based on the
accessor name given during the
Result Class column definition
\&. Like \*(L"set_column\*(R", this
will not store the data in the database until \*(L"insert\*(R" or \*(L"update\*(R"
is called on the row.
.SS "insert"
.IX Subsection "insert"
.Vb 1
\&  $result\->insert;
.Ve
.IP "Arguments: none" 4
.IX Item "Arguments: none"
.PD 0
.ie n .IP "Return Value: $result" 4
.el .IP "Return Value: \f(CW$result\fR" 4
.IX Item "Return Value: $result"
.PD
.PP
Inserts an object previously created by \*(L"new\*(R" into the database if
it isn't already in there. Returns the object itself. To insert an
entirely new row into the database, use \*(L"create\*(R" in DBIx::Class::ResultSet.
.PP
To fetch an uninserted result object, call
new_result on a resultset.
.PP
This will also insert any uninserted, related objects held inside this
one, see \*(L"create\*(R" in DBIx::Class::ResultSet for more details.
.SS "in_storage"
.IX Subsection "in_storage"
.Vb 2
\&  $result\->in_storage; # Get value
\&  $result\->in_storage(1); # Set value
.Ve
.IP "Arguments: none or 1|0" 4
.IX Item "Arguments: none or 1|0"
.PD 0
.IP "Return Value: 1|0" 4
.IX Item "Return Value: 1|0"
.PD
.PP
Indicates whether the object exists as a row in the database or
not. This is set to true when \*(L"find\*(R" in DBIx::Class::ResultSet,
\&\*(L"create\*(R" in DBIx::Class::ResultSet or \*(L"insert\*(R" in DBIx::Class::ResultSet
are used.
.PP
Creating a result object using \*(L"new_result\*(R" in DBIx::Class::ResultSet, or
calling \*(L"delete\*(R" on one, sets it to false.
.SS "update"
.IX Subsection "update"
.Vb 1
\&  $result\->update(\e%columns?)
.Ve
.IP "Arguments: none or a hashref" 4
.IX Item "Arguments: none or a hashref"
.PD 0
.ie n .IP "Return Value: $result" 4
.el .IP "Return Value: \f(CW$result\fR" 4
.IX Item "Return Value: $result"
.PD
.PP
Throws an exception if the result object is not yet in the database,
according to \*(L"in_storage\*(R". Returns the object itself.
.PP
This method issues an \s-1SQL UPDATE\s0 query to commit any changes to the
object to the database if required (see \*(L"get_dirty_columns\*(R").
It throws an exception if a proper \s-1WHERE\s0 clause uniquely identifying
the database row can not be constructed (see
significance of primary keys
for more details).
.PP
Also takes an optional hashref of \f(CW\*(C`column_name => value\*(C'\fR pairs
to update on the object first. Be aware that the hashref will be
passed to \f(CW\*(C`set_inflated_columns\*(C'\fR, which might edit it in place, so
don't rely on it being the same after a call to \f(CW\*(C`update\*(C'\fR.  If you
need to preserve the hashref, it is sufficient to pass a shallow copy
to \f(CW\*(C`update\*(C'\fR, e.g. ( { %{ \f(CW$href\fR } } )
.PP
If the values passed or any of the column values set on the object
contain scalar references, e.g.:
.PP
.Vb 3
\&  $result\->last_modified(\e\*(AqNOW()\*(Aq)\->update();
\&  # OR
\&  $result\->update({ last_modified => \e\*(AqNOW()\*(Aq });
.Ve
.PP
The update will pass the values verbatim into \s-1SQL. \s0(See
SQL::Abstract docs).  The values in your Result object will \s-1NOT\s0 change
as a result of the update call, if you want the object to be updated
with the actual values from the database, call \*(L"discard_changes\*(R"
after the update.
.PP
.Vb 1
\&  $result\->update()\->discard_changes();
.Ve
.PP
To determine before calling this method, which column values have
changed and will be updated, call \*(L"get_dirty_columns\*(R".
.PP
To check if any columns will be updated, call \*(L"is_changed\*(R".
.PP
To force a column to be updated, call \*(L"make_column_dirty\*(R" before
this method.
.SS "delete"
.IX Subsection "delete"
.Vb 1
\&  $result\->delete
.Ve
.IP "Arguments: none" 4
.IX Item "Arguments: none"
.PD 0
.ie n .IP "Return Value: $result" 4
.el .IP "Return Value: \f(CW$result\fR" 4
.IX Item "Return Value: $result"
.PD
.PP
Throws an exception if the object is not in the database according to
\&\*(L"in_storage\*(R". Also throws an exception if a proper \s-1WHERE\s0 clause
uniquely identifying the database row can not be constructed (see
significance of primary keys
for more details).
.PP
The object is still perfectly usable, but \*(L"in_storage\*(R" will
now return 0 and the object must be reinserted using \*(L"insert\*(R"
before it can be used to \*(L"update\*(R" the row again.
.PP
If you delete an object in a class with a \f(CW\*(C`has_many\*(C'\fR relationship, an
attempt is made to delete all the related objects as well. To turn
this behaviour off, pass \f(CW\*(C`cascade_delete => 0\*(C'\fR in the \f(CW$attr\fR
hashref of the relationship, see DBIx::Class::Relationship. Any
database-level cascade or restrict will take precedence over a
DBIx-Class-based cascading delete, since DBIx-Class \fBdeletes the
main row first\fR and only then attempts to delete any remaining related
rows.
.PP
If you delete an object within a \fItxn_do()\fR (see \*(L"txn_do\*(R" in DBIx::Class::Storage)
and the transaction subsequently fails, the result object will remain marked as
not being in storage. If you know for a fact that the object is still in
storage (i.e. by inspecting the cause of the transaction's failure), you can
use \f(CW\*(C`$obj\->in_storage(1)\*(C'\fR to restore consistency between the object and
the database. This would allow a subsequent \f(CW\*(C`$obj\->delete\*(C'\fR to work
as expected.
.PP
See also \*(L"delete\*(R" in DBIx::Class::ResultSet.
.SS "get_column"
.IX Subsection "get_column"
.Vb 1
\&  my $val = $result\->get_column($col);
.Ve
.ie n .IP "Arguments: $columnname" 4
.el .IP "Arguments: \f(CW$columnname\fR" 4
.IX Item "Arguments: $columnname"
.PD 0
.IP "Return Value: The value of the column" 4
.IX Item "Return Value: The value of the column"
.PD
.PP
Throws an exception if the column name given doesn't exist according
to has_column.
.PP
Returns a raw column value from the result object, if it has already
been fetched from the database or set by an accessor.
.PP
If an inflated value has been set, it
will be deflated and returned.
.PP
Note that if you used the \f(CW\*(C`columns\*(C'\fR or the \f(CW\*(C`select/as\*(C'\fR
search attributes on the resultset from
which \f(CW$result\fR was derived, and \fBdid not include\fR \f(CW$columnname\fR in the list,
this method will return \f(CW\*(C`undef\*(C'\fR even if the database contains some value.
.PP
To retrieve all loaded column values as a hash, use \*(L"get_columns\*(R".
.SS "has_column_loaded"
.IX Subsection "has_column_loaded"
.Vb 3
\&  if ( $result\->has_column_loaded($col) ) {
\&     print "$col has been loaded from db";
\&  }
.Ve
.ie n .IP "Arguments: $columnname" 4
.el .IP "Arguments: \f(CW$columnname\fR" 4
.IX Item "Arguments: $columnname"
.PD 0
.IP "Return Value: 0|1" 4
.IX Item "Return Value: 0|1"
.PD
.PP
Returns a true value if the column value has been loaded from the
database (or set locally).
.SS "get_columns"
.IX Subsection "get_columns"
.Vb 1
\&  my %data = $result\->get_columns;
.Ve
.IP "Arguments: none" 4
.IX Item "Arguments: none"
.PD 0
.IP "Return Value: A hash of columnname, value pairs." 4
.IX Item "Return Value: A hash of columnname, value pairs."
.PD
.PP
Returns all loaded column data as a hash, containing raw values. To
get just one value for a particular column, use \*(L"get_column\*(R".
.PP
See \*(L"get_inflated_columns\*(R" to get the inflated values.
.SS "get_dirty_columns"
.IX Subsection "get_dirty_columns"
.Vb 1
\&  my %data = $result\->get_dirty_columns;
.Ve
.IP "Arguments: none" 4
.IX Item "Arguments: none"
.PD 0
.IP "Return Value: A hash of column, value pairs" 4
.IX Item "Return Value: A hash of column, value pairs"
.PD
.PP
Only returns the column, value pairs for those columns that have been
changed on this object since the last \*(L"update\*(R" or \*(L"insert\*(R" call.
.PP
See \*(L"get_columns\*(R" to fetch all column/value pairs.
.SS "make_column_dirty"
.IX Subsection "make_column_dirty"
.Vb 1
\&  $result\->make_column_dirty($col)
.Ve
.ie n .IP "Arguments: $columnname" 4
.el .IP "Arguments: \f(CW$columnname\fR" 4
.IX Item "Arguments: $columnname"
.PD 0
.IP "Return Value: not defined" 4
.IX Item "Return Value: not defined"
.PD
.PP
Throws an exception if the column does not exist.
.PP
Marks a column as having been changed regardless of whether it has
really changed.
.SS "get_inflated_columns"
.IX Subsection "get_inflated_columns"
.Vb 1
\&  my %inflated_data = $obj\->get_inflated_columns;
.Ve
.IP "Arguments: none" 4
.IX Item "Arguments: none"
.PD 0
.IP "Return Value: A hash of column, object|value pairs" 4
.IX Item "Return Value: A hash of column, object|value pairs"
.PD
.PP
Returns a hash of all column keys and associated values. Values for any
columns set to use inflation will be inflated and returns as objects.
.PP
See \*(L"get_columns\*(R" to get the uninflated values.
.PP
See DBIx::Class::InflateColumn for how to setup inflation.
.SS "set_column"
.IX Subsection "set_column"
.Vb 1
\&  $result\->set_column($col => $val);
.Ve
.ie n .IP "Arguments: $columnname, $value" 4
.el .IP "Arguments: \f(CW$columnname\fR, \f(CW$value\fR" 4
.IX Item "Arguments: $columnname, $value"
.PD 0
.ie n .IP "Return Value: $value" 4
.el .IP "Return Value: \f(CW$value\fR" 4
.IX Item "Return Value: $value"
.PD
.PP
Sets a raw column value. If the new value is different from the old one,
the column is marked as dirty for when you next call \*(L"update\*(R".
.PP
If passed an object or reference as a value, this method will happily
attempt to store it, and a later \*(L"insert\*(R" or \*(L"update\*(R" will try and
stringify/numify as appropriate. To set an object to be deflated
instead, see \*(L"set_inflated_columns\*(R", or better yet, use \*(L"$column_accessor\*(R".
.SS "set_columns"
.IX Subsection "set_columns"
.Vb 1
\&  $result\->set_columns({ $col => $val, ... });
.Ve
.IP "Arguments: \e%columndata" 4
.IX Item "Arguments: %columndata"
.PD 0
.ie n .IP "Return Value: $result" 4
.el .IP "Return Value: \f(CW$result\fR" 4
.IX Item "Return Value: $result"
.PD
.PP
Sets multiple column, raw value pairs at once.
.PP
Works as \*(L"set_column\*(R".
.SS "set_inflated_columns"
.IX Subsection "set_inflated_columns"
.Vb 1
\&  $result\->set_inflated_columns({ $col => $val, $relname => $obj, ... });
.Ve
.IP "Arguments: \e%columndata" 4
.IX Item "Arguments: %columndata"
.PD 0
.ie n .IP "Return Value: $result" 4
.el .IP "Return Value: \f(CW$result\fR" 4
.IX Item "Return Value: $result"
.PD
.PP
Sets more than one column value at once. Any inflated values are
deflated and the raw values stored.
.PP
Any related values passed as Result objects, using the relation name as a
key, are reduced to the appropriate foreign key values and stored. If
instead of related result objects, a hashref of column, value data is
passed, will create the related object first then store.
.PP
Will even accept arrayrefs of data as a value to a
\&\*(L"has_many\*(R" in DBIx::Class::Relationship key, and create the related
objects if necessary.
.PP
Be aware that the input hashref might be edited in place, so don't rely
on it being the same after a call to \f(CW\*(C`set_inflated_columns\*(C'\fR. If you
need to preserve the hashref, it is sufficient to pass a shallow copy
to \f(CW\*(C`set_inflated_columns\*(C'\fR, e.g. ( { %{ \f(CW$href\fR } } )
.PP
See also \*(L"set_from_related\*(R" in DBIx::Class::Relationship::Base.
.SS "copy"
.IX Subsection "copy"
.Vb 1
\&  my $copy = $orig\->copy({ change => $to, ... });
.Ve
.IP "Arguments: \e%replacementdata" 4
.IX Item "Arguments: %replacementdata"
.PD 0
.ie n .IP "Return Value: $result copy" 4
.el .IP "Return Value: \f(CW$result\fR copy" 4
.IX Item "Return Value: $result copy"
.PD
.PP
Inserts a new row into the database, as a copy of the original
object. If a hashref of replacement data is supplied, these will take
precedence over data in the original. Also any columns which have
the column info attribute
\&\f(CW\*(C`is_auto_increment => 1\*(C'\fR are explicitly removed before the copy,
so that the database can insert its own autoincremented values into
the new object.
.PP
Relationships will be followed by the copy procedure \fBonly\fR if the
relationship specifies a true value for its
cascade_copy attribute. \f(CW\*(C`cascade_copy\*(C'\fR
is set by default on \f(CW\*(C`has_many\*(C'\fR relationships and unset on all others.
.SS "store_column"
.IX Subsection "store_column"
.Vb 1
\&  $result\->store_column($col => $val);
.Ve
.ie n .IP "Arguments: $columnname, $value" 4
.el .IP "Arguments: \f(CW$columnname\fR, \f(CW$value\fR" 4
.IX Item "Arguments: $columnname, $value"
.PD 0
.IP "Return Value: The value sent to storage" 4
.IX Item "Return Value: The value sent to storage"
.PD
.PP
Set a raw value for a column without marking it as changed. This
method is used internally by \*(L"set_column\*(R" which you should probably
be using.
.PP
This is the lowest level at which data is set on a result object,
extend this method to catch all data setting methods.
.SS "inflate_result"
.IX Subsection "inflate_result"
.Vb 1
\&  Class\->inflate_result($result_source, \e%me, \e%prefetch?)
.Ve
.ie n .IP "Arguments: $result_source, \e%columndata, \e%prefetcheddata" 4
.el .IP "Arguments: \f(CW$result_source\fR, \e%columndata, \e%prefetcheddata" 4
.IX Item "Arguments: $result_source, %columndata, %prefetcheddata"
.PD 0
.ie n .IP "Return Value: $result" 4
.el .IP "Return Value: \f(CW$result\fR" 4
.IX Item "Return Value: $result"
.PD
.PP
All DBIx::Class::ResultSet methods that retrieve data from the
database and turn it into result objects call this method.
.PP
Extend this method in your Result classes to hook into this process,
for example to rebless the result into a different class.
.PP
Reblessing can also be done more easily by setting \f(CW\*(C`result_class\*(C'\fR in
your Result class. See \*(L"result_class\*(R" in DBIx::Class::ResultSource.
.PP
Different types of results can also be created from a particular
DBIx::Class::ResultSet, see \*(L"result_class\*(R" in DBIx::Class::ResultSet.
.SS "update_or_insert"
.IX Subsection "update_or_insert"
.Vb 1
\&  $result\->update_or_insert
.Ve
.IP "Arguments: none" 4
.IX Item "Arguments: none"
.PD 0
.IP "Return Value: Result of update or insert operation" 4
.IX Item "Return Value: Result of update or insert operation"
.PD
.PP
\&\*(L"Update\*(R"s the object if it's already in the database, according to
\&\*(L"in_storage\*(R", else \*(L"insert\*(R"s it.
.SS "insert_or_update"
.IX Subsection "insert_or_update"
.Vb 1
\&  $obj\->insert_or_update
.Ve
.PP
Alias for \*(L"update_or_insert\*(R"
.SS "is_changed"
.IX Subsection "is_changed"
.Vb 2
\&  my @changed_col_names = $result\->is_changed();
\&  if ($result\->is_changed()) { ... }
.Ve
.IP "Arguments: none" 4
.IX Item "Arguments: none"
.PD 0
.ie n .IP "Return Value: 0|1 or @columnnames" 4
.el .IP "Return Value: 0|1 or \f(CW@columnnames\fR" 4
.IX Item "Return Value: 0|1 or @columnnames"
.PD
.PP
In list context returns a list of columns with uncommited changes, or
in scalar context returns a true value if there are uncommitted
changes.
.SS "is_column_changed"
.IX Subsection "is_column_changed"
.Vb 1
\&  if ($result\->is_column_changed(\*(Aqcol\*(Aq)) { ... }
.Ve
.ie n .IP "Arguments: $columname" 4
.el .IP "Arguments: \f(CW$columname\fR" 4
.IX Item "Arguments: $columname"
.PD 0
.IP "Return Value: 0|1" 4
.IX Item "Return Value: 0|1"
.PD
.PP
Returns a true value if the column has uncommitted changes.
.SS "result_source"
.IX Subsection "result_source"
.Vb 1
\&  my $resultsource = $result\->result_source;
.Ve
.ie n .IP "Arguments: $result_source?" 4
.el .IP "Arguments: \f(CW$result_source\fR?" 4
.IX Item "Arguments: $result_source?"
.PD 0
.ie n .IP "Return Value: $result_source" 4
.el .IP "Return Value: \f(CW$result_source\fR" 4
.IX Item "Return Value: $result_source"
.PD
.PP
Accessor to the DBIx::Class::ResultSource this object was created from.
.SS "register_column"
.IX Subsection "register_column"
.Vb 2
\&  $column_info = { .... };
\&  $class\->register_column($column_name, $column_info);
.Ve
.ie n .IP "Arguments: $columnname, \e%columninfo" 4
.el .IP "Arguments: \f(CW$columnname\fR, \e%columninfo" 4
.IX Item "Arguments: $columnname, %columninfo"
.PD 0
.IP "Return Value: not defined" 4
.IX Item "Return Value: not defined"
.PD
.PP
Registers a column on the class. If the column_info has an 'accessor'
key, creates an accessor named after the value if defined; if there is
no such key, creates an accessor with the same name as the column
.PP
The column_info attributes are described in
\&\*(L"add_columns\*(R" in DBIx::Class::ResultSource
.SS "get_from_storage"
.IX Subsection "get_from_storage"
.Vb 1
\&  my $copy = $result\->get_from_storage($attrs)
.Ve
.IP "Arguments: \e%attrs" 4
.IX Item "Arguments: %attrs"
.PD 0
.IP "Return Value: A Result object" 4
.IX Item "Return Value: A Result object"
.PD
.PP
Fetches a fresh copy of the Result object from the database and returns it.
Throws an exception if a proper \s-1WHERE\s0 clause identifying the database row
can not be constructed (i.e. if the original object does not contain its
entire
 primary key
). If passed the \e%attrs argument, will first apply these attributes to
the resultset used to find the row.
.PP
This copy can then be used to compare to an existing result object, to
determine if any changes have been made in the database since it was
created.
.PP
To just update your Result object with any latest changes from the
database, use \*(L"discard_changes\*(R" instead.
.PP
The \e%attrs argument should be compatible with
\&\*(L"\s-1ATTRIBUTES\*(R"\s0 in DBIx::Class::ResultSet.
.SS "discard_changes"
.IX Subsection "discard_changes"
.Vb 1
\&  $result\->discard_changes
.Ve
.ie n .IP "Arguments: none or $attrs" 4
.el .IP "Arguments: none or \f(CW$attrs\fR" 4
.IX Item "Arguments: none or $attrs"
.PD 0
.IP "Return Value: self (updates object in-place)" 4
.IX Item "Return Value: self (updates object in-place)"
.PD
.PP
Re-selects the row from the database, losing any changes that had
been made. Throws an exception if a proper \f(CW\*(C`WHERE\*(C'\fR clause identifying
the database row can not be constructed (i.e. if the original object
does not contain its entire
primary key).
.PP
This method can also be used to refresh from storage, retrieving any
changes made since the row was last read from storage.
.PP
\&\f(CW$attrs\fR, if supplied, is expected to be a hashref of attributes suitable for passing as the
second argument to \f(CW\*(C`$resultset\->search($cond, $attrs)\*(C'\fR;
.PP
Note: If you are using DBIx::Class::Storage::DBI::Replicated as your
storage, please kept in mind that if you \*(L"discard_changes\*(R" on a row that you
just updated or created, you should wrap the entire bit inside a transaction.
Otherwise you run the risk that you insert or update to the master database
but read from a replicant database that has not yet been updated from the
master.  This will result in unexpected results.
.SS "throw_exception"
.IX Subsection "throw_exception"
See \*(L"throw_exception\*(R" in DBIx::Class::Schema.
.SS "id"
.IX Subsection "id"
.Vb 1
\&  my @pk = $result\->id;
.Ve
.IP "Arguments: none" 4
.IX Item "Arguments: none"
.PD 0
.IP "Returns: A list of primary key values" 4
.IX Item "Returns: A list of primary key values"
.PD
.PP
Returns the primary key(s) for a row. Can't be called as a class method.
Actually implemented in DBIx::Class::PK
.SH "AUTHOR AND CONTRIBUTORS"
.IX Header "AUTHOR AND CONTRIBUTORS"
See \s-1AUTHOR\s0 and \s-1CONTRIBUTORS\s0 in DBIx::Class
.SH "LICENSE"
.IX Header "LICENSE"
You may distribute this code under the same terms as Perl itself.
