.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Devel::StackTrace 3"
.TH Devel::StackTrace 3 "2014-01-16" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Devel::StackTrace \- An object representing a stack trace
.SH "VERSION"
.IX Header "VERSION"
version 1.31
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use Devel::StackTrace;
\&
\&  my $trace = Devel::StackTrace\->new();
\&
\&  print $trace\->as_string(); # like carp
\&
\&  # from top (most recent) of stack to bottom.
\&  while ( my $frame = $trace\->next_frame() ) {
\&      print "Has args\en" if $frame\->hasargs();
\&  }
\&
\&  # from bottom (least recent) of stack to top.
\&  while ( my $frame = $trace\->prev_frame() ) {
\&      print "Sub: ", $frame\->subroutine(), "\en";
\&  }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The \f(CW\*(C`Devel::StackTrace\*(C'\fR module contains two classes, C,Devel::StackTrace> and
Devel::StackTrace::Frame. These objects encapsulate the information that
can retrieved via Perl's \f(CW\*(C`caller()\*(C'\fR function, as well as providing a simple
interface to this data.
.PP
The \f(CW\*(C`Devel::StackTrace\*(C'\fR object contains a set of \f(CW\*(C`Devel::StackTrace::Frame\*(C'\fR
objects, one for each level of the stack. The frames contain all the data
available from \f(CW\*(C`caller()\*(C'\fR.
.PP
This code was created to support my Exception::Class::Base class (part of
Exception::Class) but may be useful in other contexts.
.SH "'TOP' AND 'BOTTOM' OF THE STACK"
.IX Header "'TOP' AND 'BOTTOM' OF THE STACK"
When describing the methods of the trace object, I use the words 'top' and
\&'bottom'. In this context, the 'top' frame on the stack is the most recent
frame and the 'bottom' is the least recent.
.PP
Here's an example:
.PP
.Vb 1
\&  foo();  # bottom frame is here
\&
\&  sub foo {
\&     bar();
\&  }
\&
\&  sub bar {
\&     Devel::StackTrace\->new();  # top frame is here.
\&  }
.Ve
.SH "METHODS"
.IX Header "METHODS"
This class provide the following methods:
.SS "Devel::StackTrace\->new(%named_params)"
.IX Subsection "Devel::StackTrace->new(%named_params)"
Returns a new Devel::StackTrace object.
.PP
Takes the following parameters:
.IP "\(bu" 4
frame_filter => \f(CW$sub\fR
.Sp
By default, Devel::StackTrace will include all stack frames before the
call to its constructor.
.Sp
However, you may want to filter out some frames with more granularity
than 'ignore_package' or 'ignore_class' allow.
.Sp
You can provide a subroutine which is called with the raw frame data
for each frame. This is a hash reference with two keys, \*(L"caller\*(R", and
\&\*(L"args\*(R", both of which are array references. The \*(L"caller\*(R" key is the
raw data as returned by Perl's \f(CW\*(C`caller()\*(C'\fR function, and the \*(L"args\*(R"
key are the subroutine arguments found in \f(CW@DB::args\fR.
.Sp
The filter should return true if the frame should be included, or
false if it should be skipped.
.IP "\(bu" 4
ignore_package => \f(CW$package_name\fR \s-1OR\s0 \e@package_names
.Sp
Any frames where the package is one of these packages will not be on
the stack.
.IP "\(bu" 4
ignore_class => \f(CW$package_name\fR \s-1OR\s0 \e@package_names
.Sp
Any frames where the package is a subclass of one of these packages
(or is the same package) will not be on the stack.
.Sp
Devel::StackTrace internally adds itself to the 'ignore_package'
parameter, meaning that the Devel::StackTrace package is \fB\s-1ALWAYS\s0\fR
ignored. However, if you create a subclass of Devel::StackTrace it
will not be ignored.
.IP "\(bu" 4
no_refs => \f(CW$boolean\fR
.Sp
If this parameter is true, then Devel::StackTrace will not store
references internally when generating stacktrace frames. This lets
your objects go out of scope.
.Sp
Devel::StackTrace replaces any references with their stringified
representation.
.IP "\(bu" 4
no_args => \f(CW$boolean\fR
.Sp
If this parameter is true, then Devel::StackTrace will not store caller
arguments in stack trace frames at all.
.IP "\(bu" 4
respect_overload => \f(CW$boolean\fR
.Sp
By default, Devel::StackTrace will call \f(CW\*(C`overload::AddrRef()\*(C'\fR to get
the underlying string representation of an object, instead of
respecting the object's stringification overloading. If you would
prefer to see the overloaded representation of objects in stack
traces, then set this parameter to true.
.IP "\(bu" 4
max_arg_length => \f(CW$integer\fR
.Sp
By default, Devel::StackTrace will display the entire argument for each
subroutine call. Setting this parameter causes truncates each subroutine
argument's string representation if it is longer than this number of
characters.
.IP "\(bu" 4
message => \f(CW$string\fR
.Sp
By default, Devel::StackTrace will use 'Trace begun' as the message for the
first stack frame when you call \f(CW\*(C`as_string\*(C'\fR. You can supply an alternative
message using this option.
.IP "\(bu" 4
indent => \f(CW$boolean\fR
.Sp
If this parameter is true, each stack frame after the first will start with a
tab character, just like \f(CW\*(C`Carp::confess()\*(C'\fR.
.ie n .SS "$trace\->\fInext_frame()\fP"
.el .SS "\f(CW$trace\fP\->\fInext_frame()\fP"
.IX Subsection "$trace->next_frame()"
Returns the next Devel::StackTrace::Frame object on the stack, going
down. If this method hasn't been called before it returns the first frame. It
returns \f(CW\*(C`undef\*(C'\fR when it reaches the bottom of the stack and then resets its
pointer so the next call to \f(CW\*(C`$trace\->next_frame()\*(C'\fR or \f(CW\*(C`$trace\->prev_frame()\*(C'\fR will work properly.
.ie n .SS "$trace\->\fIprev_frame()\fP"
.el .SS "\f(CW$trace\fP\->\fIprev_frame()\fP"
.IX Subsection "$trace->prev_frame()"
Returns the next Devel::StackTrace::Frame object on the stack, going up. If
this method hasn't been called before it returns the last frame. It returns
undef when it reaches the top of the stack and then resets its pointer so the
next call to \f(CW\*(C`$trace\->next_frame()\*(C'\fR or \f(CW\*(C`$trace\->prev_frame()\*(C'\fR will
work properly.
.ie n .SS "$trace\->reset_pointer"
.el .SS "\f(CW$trace\fP\->reset_pointer"
.IX Subsection "$trace->reset_pointer"
Resets the pointer so that the next call to \f(CW\*(C`$trace\->next_frame()\*(C'\fR or \f(CW\*(C`$trace\->prev_frame()\*(C'\fR will start at the top or bottom of the stack, as
appropriate.
.ie n .SS "$trace\->\fIframes()\fP"
.el .SS "\f(CW$trace\fP\->\fIframes()\fP"
.IX Subsection "$trace->frames()"
When this method is called with no arguments, it returns a list of
Devel::StackTrace::Frame objects. They are returned in order from top (most
recent) to bottom.
.PP
This method can also be used to set the object's frames if you pass it a list
of Devel::StackTrace::Frame objects.
.PP
This is useful if you want to filter the list of frames in ways that are more
complex than can be handled by the \f(CW\*(C`$trace\->filter_frames()\*(C'\fR method:
.PP
.Vb 1
\&  $stacktrace\->frames( my_filter( $stacktrace\->frames() ) );
.Ve
.ie n .SS "$trace\->frame($index)"
.el .SS "\f(CW$trace\fP\->frame($index)"
.IX Subsection "$trace->frame($index)"
Given an index, this method returns the relevant frame, or undef if there is
no frame at that index. The index is exactly like a Perl array. The first
frame is 0 and negative indexes are allowed.
.ie n .SS "$trace\->\fIframe_count()\fP"
.el .SS "\f(CW$trace\fP\->\fIframe_count()\fP"
.IX Subsection "$trace->frame_count()"
Returns the number of frames in the trace object.
.ie n .SS "$trace\->as_string(\e%p)"
.el .SS "\f(CW$trace\fP\->as_string(\e%p)"
.IX Subsection "$trace->as_string(%p)"
Calls \f(CW\*(C`$frame\->as_string()\*(C'\fR on each frame from top to bottom, producing
output quite similar to the Carp module's cluck/confess methods.
.PP
The optional \f(CW\*(C`\e%p\*(C'\fR parameter only has one option. The \f(CW\*(C`max_arg_length\*(C'\fR
parameter truncates each subroutine argument's string representation if it is
longer than this number of characters.
.SH "SUPPORT"
.IX Header "SUPPORT"
Please submit bugs to the \s-1CPAN RT\s0 system at
http://rt.cpan.org/NoAuth/ReportBug.html?Queue=Devel%3A%3AStackTrace
or via email at bug\-devel\-stacktrace@rt.cpan.org.
.SH "AUTHOR"
.IX Header "AUTHOR"
Dave Rolsky <autarch@urth.org>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is Copyright (c) 2014 by Dave Rolsky.
.PP
This is free software, licensed under:
.PP
.Vb 1
\&  The Artistic License 2.0 (GPL Compatible)
.Ve
