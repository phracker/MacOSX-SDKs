.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Class::Inspector 3"
.TH Class::Inspector 3 "2012-10-19" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Class::Inspector \- Get information about a class and its structure
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use Class::Inspector;
\&  
\&  # Is a class installed and/or loaded
\&  Class::Inspector\->installed( \*(AqFoo::Class\*(Aq );
\&  Class::Inspector\->loaded( \*(AqFoo::Class\*(Aq );
\&  
\&  # Filename related information
\&  Class::Inspector\->filename( \*(AqFoo::Class\*(Aq );
\&  Class::Inspector\->resolved_filename( \*(AqFoo::Class\*(Aq );
\&  
\&  # Get subroutine related information
\&  Class::Inspector\->functions( \*(AqFoo::Class\*(Aq );
\&  Class::Inspector\->function_refs( \*(AqFoo::Class\*(Aq );
\&  Class::Inspector\->function_exists( \*(AqFoo::Class\*(Aq, \*(Aqbar\*(Aq );
\&  Class::Inspector\->methods( \*(AqFoo::Class\*(Aq, \*(Aqfull\*(Aq, \*(Aqpublic\*(Aq );
\&  
\&  # Find all loaded subclasses or something
\&  Class::Inspector\->subclasses( \*(AqFoo::Class\*(Aq );
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Class::Inspector allows you to get information about a loaded class. Most or
all of this information can be found in other ways, but they aren't always
very friendly, and usually involve a relatively high level of Perl wizardry,
or strange and unusual looking code. Class::Inspector attempts to provide 
an easier, more friendly interface to this information.
.SH "METHODS"
.IX Header "METHODS"
.ie n .SS "installed $class"
.el .SS "installed \f(CW$class\fP"
.IX Subsection "installed $class"
The \f(CW\*(C`installed\*(C'\fR static method tries to determine if a class is installed
on the machine, or at least available to Perl. It does this by wrapping
around \f(CW\*(C`resolved_filename\*(C'\fR.
.PP
Returns true if installed/available, false if the class is not installed,
or \f(CW\*(C`undef\*(C'\fR if the class name is invalid.
.ie n .SS "loaded $class"
.el .SS "loaded \f(CW$class\fP"
.IX Subsection "loaded $class"
The \f(CW\*(C`loaded\*(C'\fR static method tries to determine if a class is loaded by
looking for symbol table entries.
.PP
This method it uses to determine this will work even if the class does not
have its own file, but is contained inside a single file with multiple
classes in it. Even in the case of some sort of run-time loading class
being used, these typically leave some trace in the symbol table, so an
Autoload or Class::Autouse\-based class should correctly appear
loaded.
.PP
Returns true if the class is loaded, false if not, or \f(CW\*(C`undef\*(C'\fR if the
class name is invalid.
.ie n .SS "filename $class"
.el .SS "filename \f(CW$class\fP"
.IX Subsection "filename $class"
For a given class, returns the base filename for the class. This will \s-1NOT\s0
be a fully resolved filename, just the part of the filename \s-1BELOW\s0 the
\&\f(CW@INC\fR entry.
.PP
.Vb 2
\&  print Class\->filename( \*(AqFoo::Bar\*(Aq );
\&  > Foo/Bar.pm
.Ve
.PP
This filename will be returned with the right seperator for the local
platform, and should work on all platforms.
.PP
Returns the filename on success or \f(CW\*(C`undef\*(C'\fR if the class name is invalid.
.ie n .SS "resolved_filename $class, @try_first"
.el .SS "resolved_filename \f(CW$class\fP, \f(CW@try_first\fP"
.IX Subsection "resolved_filename $class, @try_first"
For a given class, the \f(CW\*(C`resolved_filename\*(C'\fR static method returns the fully
resolved filename for a class. That is, the file that the class would be
loaded from.
.PP
This is not nescesarily the file that the class \s-1WAS\s0 loaded from, as the
value returned is determined each time it runs, and the \f(CW@INC\fR include
path may change.
.PP
To get the actual file for a loaded class, see the \f(CW\*(C`loaded_filename\*(C'\fR
method.
.PP
Returns the filename for the class, or \f(CW\*(C`undef\*(C'\fR if the class name is
invalid.
.ie n .SS "loaded_filename $class"
.el .SS "loaded_filename \f(CW$class\fP"
.IX Subsection "loaded_filename $class"
For a given loaded class, the \f(CW\*(C`loaded_filename\*(C'\fR static method determines
(via the \f(CW%INC\fR hash) the name of the file that it was originally loaded
from.
.PP
Returns a resolved file path, or false if the class did not have it's own
file.
.ie n .SS "functions $class"
.el .SS "functions \f(CW$class\fP"
.IX Subsection "functions $class"
For a loaded class, the \f(CW\*(C`functions\*(C'\fR static method returns a list of the
names of all the functions in the classes immediate namespace.
.PP
Note that this is not the \s-1METHODS\s0 of the class, just the functions.
.PP
Returns a reference to an array of the function names on success, or \f(CW\*(C`undef\*(C'\fR
if the class name is invalid or the class is not loaded.
.ie n .SS "function_refs $class"
.el .SS "function_refs \f(CW$class\fP"
.IX Subsection "function_refs $class"
For a loaded class, the \f(CW\*(C`function_refs\*(C'\fR static method returns references to
all the functions in the classes immediate namespace.
.PP
Note that this is not the \s-1METHODS\s0 of the class, just the functions.
.PP
Returns a reference to an array of \f(CW\*(C`CODE\*(C'\fR refs of the functions on
success, or \f(CW\*(C`undef\*(C'\fR if the class is not loaded.
.ie n .SS "function_exists $class, $function"
.el .SS "function_exists \f(CW$class\fP, \f(CW$function\fP"
.IX Subsection "function_exists $class, $function"
Given a class and function name the \f(CW\*(C`function_exists\*(C'\fR static method will
check to see if the function exists in the class.
.PP
Note that this is as a function, not as a method. To see if a method
exists for a class, use the \f(CW\*(C`can\*(C'\fR method for any class or object.
.PP
Returns true if the function exists, false if not, or \f(CW\*(C`undef\*(C'\fR if the
class or function name are invalid, or the class is not loaded.
.ie n .SS "methods $class, @options"
.el .SS "methods \f(CW$class\fP, \f(CW@options\fP"
.IX Subsection "methods $class, @options"
For a given class name, the \f(CW\*(C`methods\*(C'\fR static method will returns \s-1ALL\s0
the methods available to that class. This includes all methods available
from every class up the class' \f(CW@ISA\fR tree.
.PP
Returns a reference to an array of the names of all the available methods
on success, or \f(CW\*(C`undef\*(C'\fR if the class name is invalid or the class is not
loaded.
.PP
A number of options are available to the \f(CW\*(C`methods\*(C'\fR method that will alter
the results returned. These should be listed after the class name, in any
order.
.PP
.Vb 2
\&  # Only get public methods
\&  my $method = Class::Inspector\->methods( \*(AqMy::Class\*(Aq, \*(Aqpublic\*(Aq );
.Ve
.IP "public" 4
.IX Item "public"
The \f(CW\*(C`public\*(C'\fR option will return only 'public' methods, as defined by the Perl
convention of prepending an underscore to any 'private' methods. The \f(CW\*(C`public\*(C'\fR 
option will effectively remove any methods that start with an underscore.
.IP "private" 4
.IX Item "private"
The \f(CW\*(C`private\*(C'\fR options will return only 'private' methods, as defined by the
Perl convention of prepending an underscore to an private methods. The
\&\f(CW\*(C`private\*(C'\fR option will effectively remove an method that do not start with an
underscore.
.Sp
\&\fBNote: The \f(CB\*(C`public\*(C'\fB and \f(CB\*(C`private\*(C'\fB options are mutually exclusive\fR
.IP "full" 4
.IX Item "full"
\&\f(CW\*(C`methods\*(C'\fR normally returns just the method name. Supplying the \f(CW\*(C`full\*(C'\fR option
will cause the methods to be returned as the full names. That is, instead of
returning \f(CW\*(C`[ \*(Aqmethod1\*(Aq, \*(Aqmethod2\*(Aq, \*(Aqmethod3\*(Aq ]\*(C'\fR, you would instead get
\&\f(CW\*(C`[ \*(AqClass::method1\*(Aq, \*(AqAnotherClass::method2\*(Aq, \*(AqClass::method3\*(Aq ]\*(C'\fR.
.IP "expanded" 4
.IX Item "expanded"
The \f(CW\*(C`expanded\*(C'\fR option will cause a lot more information about method to be 
returned. Instead of just the method name, you will instead get an array
reference containing the method name as a single combined name, ala \f(CW\*(C`full\*(C'\fR,
the seperate class and method, and a \s-1CODE\s0 ref to the actual function ( if
available ). Please note that the function reference is not guarenteed to 
be available. \f(CW\*(C`Class::Inspector\*(C'\fR is intended at some later time, work 
with modules that have some some of common run-time loader in place ( e.g
\&\f(CW\*(C`Autoloader\*(C'\fR or \f(CW\*(C`Class::Autouse\*(C'\fR for example.
.Sp
The response from \f(CW\*(C`methods( \*(AqClass\*(Aq, \*(Aqexpanded\*(Aq )\*(C'\fR would look something like
the following.
.Sp
.Vb 5
\&  [
\&    [ \*(AqClass::method1\*(Aq,   \*(AqClass\*(Aq,   \*(Aqmethod1\*(Aq, \e&Class::method1   ],
\&    [ \*(AqAnother::method2\*(Aq, \*(AqAnother\*(Aq, \*(Aqmethod2\*(Aq, \e&Another::method2 ],
\&    [ \*(AqFoo::bar\*(Aq,         \*(AqFoo\*(Aq,     \*(Aqbar\*(Aq,     \e&Foo::bar         ],
\&  ]
.Ve
.ie n .SS "subclasses $class"
.el .SS "subclasses \f(CW$class\fP"
.IX Subsection "subclasses $class"
The \f(CW\*(C`subclasses\*(C'\fR static method will search then entire namespace (and thus
\&\fBall\fR currently loaded classes) to find all classes that are subclasses
of the class provided as a the parameter.
.PP
The actual test will be done by calling \f(CW\*(C`isa\*(C'\fR on the class as a static
method. (i.e. \f(CW\*(C`My::Class\->isa($class)\*(C'\fR.
.PP
Returns a reference to a list of the loaded classes that match the class
provided, or false is none match, or \f(CW\*(C`undef\*(C'\fR if the class name provided
is invalid.
.SH "SUPPORT"
.IX Header "SUPPORT"
Bugs should be reported via the \s-1CPAN\s0 bug tracker
.PP
<http://rt.cpan.org/NoAuth/ReportBug.html?Queue=Class\-Inspector>
.PP
For other issues, or commercial enhancement or support, contact the author.
.SH "AUTHOR"
.IX Header "AUTHOR"
Adam Kennedy <adamk@cpan.org>
.SH "SEE ALSO"
.IX Header "SEE ALSO"
<http://ali.as/>, Class::Handle
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright 2002 \- 2012 Adam Kennedy.
.PP
This program is free software; you can redistribute
it and/or modify it under the same terms as Perl itself.
.PP
The full text of the license can be found in the
\&\s-1LICENSE\s0 file included with this module.
