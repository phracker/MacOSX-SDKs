.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Struct 3"
.TH Struct 3 "2001-05-13" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Inline::Struct \-\- Manipulate C structures directly from Perl.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use Inline C => Config => Structs => [\*(AqFoo\*(Aq];
\&
\&  my $obj = Inline::Struct::Foo\->new;
\&  $obj\->num(10);
\&  $obj\->str("Hello");
\&
\&  myfunc($obj);
\&
\&  _\|_END_\|_
\&  _\|_C_\|_
\&  
\&  struct Foo {
\&    int num;
\&    char *str;
\&  };
\&
\&  void myfunc(Foo *f) {
\&    printf("myfunc: num=%i, str=\*(Aq%s\*(Aq\en", f\->num, f\->str);
\&  }
.Ve
.PP
This complete program prints:
.PP
.Vb 1
\&  myfunc: num=10, str=\*(AqHello\*(Aq
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Inline::Struct is not a new language. It's a language extension designed to 
be used by Inline::C. It parses struct definitions and creates
typemaps and \s-1XS\s0 code which bind each struct into a Perl class. This code is
passed to Inline::C, which compiles it in the normal way.
.PP
\&\s-1NOTE:\s0 Inline::Struct parses only C\-style structs. It doesn't know about any
\&\*(C+ extensions to structs like scopes, constructors or methods. If you want
such functionality you should use Inline::CPP to parse your structs.
.SH "Using Inline::Struct"
.IX Header "Using Inline::Struct"
Inline::Struct has a Parse::RecDescent grammar to parse C structs. If a struct
is recognized, it can be bound to Perl. If the struct's definition is not
recognized (usually because it has a member with no typemap), it will not be
bound to Perl, but will be available from other functions in C or \*(C+.
.PP
The following example shows how a simple struct might look to a Perl
programmer.
.PP
Example 1:
.PP
.Vb 6
\&  use Inline C => <<\*(AqEND\*(Aq, ENABLE => \*(AqSTRUCTS\*(Aq;
\&  struct Fraction {
\&    long numer;
\&    long denom; 
\&  };
\&  END
\&
\&  my $o = Inline::Struct::Fraction\->new(4, 3);
\&  print $o\->numer, $o\->denom, "\en";
\&  $o\->numer(4)\->denom(7);
.Ve
.PP
After the code above has been compiled, Perl's namespace looks a lot like
the following:
.PP
.Vb 8
\&  package Inline::Struct::Fraction;
\&  sub new { }
\&  sub DESTROY { }
\&  sub _KEYS { }
\&  sub _VALUES { }
\&  sub _HASH { }
\&  sub numer { }
\&  sub denom { }
.Ve
.PP
Note that these are actually \s-1XS\s0 subs written in C, not Perl subs. But that's 
what it looks like.
.SH "The Struct Interface"
.IX Header "The Struct Interface"
The following sections define the interface of each subroutine. \fBNote: this 
interface is likely to change in future versions of Inline::Struct\fR. Please
don't rely on Inline::Struct in production code quite yet.
.PP
When a struct is bound by Inline::Struct, a new namespace is created underneath
Inline::Struct. So if you have a struct named 'Foo', the package of the Perl
class will be 'Inline::Struct::Foo'.
.SS "new"
.IX Subsection "new"
If no arguments are provided, all fields are zeroed out. If you provide values,
they should be appropriate for the field type, and in the same order as they
are defined in the struct.
.SS "\s-1DESTROY\s0"
.IX Subsection "DESTROY"
The destructor. Should never be called by the programmer \*(-- this is called 
automatically when the Perl variable holding the struct is destroyed. Frees
the memory associated with the struct. If the struct holds pointers to malloc'd
memory, they will not be freed. If you run into such a situation, consider 
using \*(C+ and Inline::CPP instead.
.SS "_KEYS"
.IX Subsection "_KEYS"
A read-only method, this returns a reference to an array containing the names
of the fields in the struct. The fields are in the order they appear in the 
C source code.
.SS "_VALUES"
.IX Subsection "_VALUES"
A read-only method, this returns a reference to an array containing the values
of the fields in the struct. The values are returned in the same order as the
fields.
.SS "_HASH"
.IX Subsection "_HASH"
A read-only method, this returns a reference to a hash, mapping field names
to field values.
.SS "Accessors"
.IX Subsection "Accessors"
For each field in the struct, an accessor sub will be created which lets you 
get or set the value in the struct. If no arguments are provided, the sub
returns the value of that field. If any arguments are provided, the field is
set to the first argument, and the modified structure is returned. This makes
setting multiple fields easy:
.PP
.Vb 1
\&   $o\->field1(something)\->field2(somethingelse);
.Ve
.SH "C and \*(C+ Configuration Options"
.IX Header "C and Configuration Options"
Inline::Struct has no configuration options of its own, but it does provide
a new configuration option for C or \*(C+.
.SS "\s-1STRUCTS\s0"
.IX Subsection "STRUCTS"
Specifies that structs are to be bound to Perl. There are several meanings to
this option, so I'll explain with an example:
.PP
.Vb 1
\&   use Inline C => Config => STRUCTS => \*(AqFoo\*(Aq;
.Ve
.PP
Adds 'Foo' to the list of structs to bind to Perl.
.PP
.Vb 1
\&   use Inline C => Config => STRUCTS => [\*(AqFoo\*(Aq, \*(AqBar\*(Aq];
.Ve
.PP
Adds 'Foo' and 'Bar' to the list of structs to bind to Perl.
.PP
.Vb 1
\&   use Inline C => Config => STRUCTS => undef;
.Ve
.PP
Clears the list of structs to bind to Perl.
.PP
.Vb 3
\&   use Inline C => Config => ENABLE => \*(AqSTRUCTS\*(Aq;
\&or
\&   use Inline C => Config => STRUCTS => 1;
.Ve
.PP
Enable binding structs to Perl, without specifying any structs to search for. 
As shown, this would bind all structs to Perl.
.PP
.Vb 3
\&   use Inline C => Config => DISABLE => \*(AqSTRUCTS\*(Aq;
\&or
\&   use Inline C => Config => STRUCTS => 0;
.Ve
.PP
Disable binding structs to Perl.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
For more information about using C from Perl, see Inline::C. For more
information about using \*(C+ from Perl, see Inline::CPP.
.SH "AUTHOR"
.IX Header "AUTHOR"
Neil Watkiss (NEILW@cpan.org)
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (C) 2001, Neil Watkiss.
.PP
This module is free software. It may be used, redistributed and/or modified
under the same terms as Perl itself.
.PP
(see http://www.perl.com/perl/misc/Artistic.html)
