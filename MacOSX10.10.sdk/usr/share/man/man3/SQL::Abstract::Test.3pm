.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "SQL::Abstract::Test 3"
.TH SQL::Abstract::Test 3 "2014-01-16" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
SQL::Abstract::Test \- Helper function for testing SQL::Abstract
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 6
\&  use SQL::Abstract;
\&  use Test::More;
\&  use SQL::Abstract::Test import => [qw/
\&    is_same_sql_bind is_same_sql is_same_bind
\&    eq_sql_bind eq_sql eq_bind
\&  /];
\&
\&  my ($sql, @bind) = SQL::Abstract\->new\->select(%args);
\&
\&  is_same_sql_bind($given_sql,    \e@given_bind,
\&                   $expected_sql, \e@expected_bind, $test_msg);
\&
\&  is_same_sql($given_sql, $expected_sql, $test_msg);
\&  is_same_bind(\e@given_bind, \e@expected_bind, $test_msg);
\&
\&  my $is_same = eq_sql_bind($given_sql,    \e@given_bind,
\&                            $expected_sql, \e@expected_bind);
\&
\&  my $sql_same = eq_sql($given_sql, $expected_sql);
\&  my $bind_same = eq_bind(\e@given_bind, \e@expected_bind);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module is only intended for authors of tests on
SQL::Abstract and related modules;
it exports functions for comparing two \s-1SQL\s0 statements
and their bound values.
.PP
The \s-1SQL\s0 comparison is performed on \fIabstract syntax\fR,
ignoring differences in spaces or in levels of parentheses.
Therefore the tests will pass as long as the semantics
is preserved, even if the surface syntax has changed.
.PP
\&\fBDisclaimer\fR : the semantic equivalence handling is pretty limited.
A lot of effort goes into distinguishing significant from
non-significant parenthesis, including \s-1AND/OR\s0 operator associativity.
Currently this module does not support commutativity and more
intelligent transformations like Morgan laws, etc.
.PP
For a good overview of what this test framework is capable of refer
to \f(CW\*(C`t/10test.t\*(C'\fR
.SH "FUNCTIONS"
.IX Header "FUNCTIONS"
.SS "is_same_sql_bind"
.IX Subsection "is_same_sql_bind"
.Vb 2
\&  is_same_sql_bind($given_sql,    \e@given_bind,
\&                   $expected_sql, \e@expected_bind, $test_msg);
.Ve
.PP
Compares given and expected pairs of \f(CW\*(C`($sql, \e@bind)\*(C'\fR, and calls
\&\*(L"ok\*(R" in Test::Builder on the result, with \f(CW$test_msg\fR as message. If the test
fails, a detailed diagnostic is printed. For clients which use Test::More,
this is the one of the three functions (\*(L"is_same_sql_bind\*(R", \*(L"is_same_sql\*(R",
\&\*(L"is_same_bind\*(R") that needs to be imported.
.SS "is_same_sql"
.IX Subsection "is_same_sql"
.Vb 1
\&  is_same_sql($given_sql, $expected_sql, $test_msg);
.Ve
.PP
Compares given and expected \s-1SQL\s0 statements, and calls \*(L"ok\*(R" in Test::Builder on
the result, with \f(CW$test_msg\fR as message. If the test fails, a detailed
diagnostic is printed. For clients which use Test::More, this is the one of
the three functions (\*(L"is_same_sql_bind\*(R", \*(L"is_same_sql\*(R", \*(L"is_same_bind\*(R")
that needs to be imported.
.SS "is_same_bind"
.IX Subsection "is_same_bind"
.Vb 1
\&  is_same_bind(\e@given_bind, \e@expected_bind, $test_msg);
.Ve
.PP
Compares given and expected bind values, and calls \*(L"ok\*(R" in Test::Builder on the
result, with \f(CW$test_msg\fR as message. If the test fails, a detailed diagnostic
is printed. For clients which use Test::More, this is the one of the three
functions (\*(L"is_same_sql_bind\*(R", \*(L"is_same_sql\*(R", \*(L"is_same_bind\*(R") that needs
to be imported.
.SS "eq_sql_bind"
.IX Subsection "eq_sql_bind"
.Vb 2
\&  my $is_same = eq_sql_bind($given_sql,    \e@given_bind,
\&                            $expected_sql, \e@expected_bind);
.Ve
.PP
Compares given and expected pairs of \f(CW\*(C`($sql, \e@bind)\*(C'\fR. Similar to
\&\*(L"is_same_sql_bind\*(R", but it just returns a boolean value and does not print
diagnostics or talk to Test::Builder.
.SS "eq_sql"
.IX Subsection "eq_sql"
.Vb 1
\&  my $is_same = eq_sql($given_sql, $expected_sql);
.Ve
.PP
Compares the abstract syntax of two \s-1SQL\s0 statements. Similar to \*(L"is_same_sql\*(R",
but it just returns a boolean value and does not print diagnostics or talk to
Test::Builder. If the result is false, the global variable \*(L"$sql_differ\*(R"
will contain the \s-1SQL\s0 portion where a difference was encountered; this is useful
for printing diagnostics.
.SS "eq_bind"
.IX Subsection "eq_bind"
.Vb 1
\&  my $is_same = eq_sql(\e@given_bind, \e@expected_bind);
.Ve
.PP
Compares two lists of bind values, taking into account the fact that some of
the values may be arrayrefs (see \*(L"bindtype\*(R" in SQL::Abstract). Similar to
\&\*(L"is_same_bind\*(R", but it just returns a boolean value and does not print
diagnostics or talk to Test::Builder.
.SH "GLOBAL VARIABLES"
.IX Header "GLOBAL VARIABLES"
.ie n .SS "$case_sensitive"
.el .SS "\f(CW$case_sensitive\fP"
.IX Subsection "$case_sensitive"
If true, \s-1SQL\s0 comparisons will be case-sensitive. Default is false;
.ie n .SS "$parenthesis_significant"
.el .SS "\f(CW$parenthesis_significant\fP"
.IX Subsection "$parenthesis_significant"
If true, \s-1SQL\s0 comparison will preserve and report difference in nested
parenthesis. Useful while testing \f(CW\*(C`IN (( x ))\*(C'\fR vs \f(CW\*(C`IN ( x )\*(C'\fR.
Defaults to false;
.ie n .SS "$order_by_asc_significant"
.el .SS "\f(CW$order_by_asc_significant\fP"
.IX Subsection "$order_by_asc_significant"
If true \s-1SQL\s0 comparison will consider \f(CW\*(C`ORDER BY foo ASC\*(C'\fR and
\&\f(CW\*(C`ORDER BY foo\*(C'\fR to be different. Default is false;
.ie n .SS "$sql_differ"
.el .SS "\f(CW$sql_differ\fP"
.IX Subsection "$sql_differ"
When \*(L"eq_sql\*(R" returns false, the global variable
\&\f(CW$sql_differ\fR contains the \s-1SQL\s0 portion
where a difference was encountered.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
SQL::Abstract, Test::More, Test::Builder.
.SH "AUTHORS"
.IX Header "AUTHORS"
Laurent Dami, <laurent.dami \s-1AT\s0 etat  geneve  ch>
.PP
Norbert Buchmuller <norbi@nix.hu>
.PP
Peter Rabbitson <ribasushi@cpan.org>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright 2008 by Laurent Dami.
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.
