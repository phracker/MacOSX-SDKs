.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Moose::Cookbook::Basics::Genome_OverloadingSubtypesAndCoercion 3"
.TH Moose::Cookbook::Basics::Genome_OverloadingSubtypesAndCoercion 3 "2014-01-19" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Moose::Cookbook::Basics::Genome_OverloadingSubtypesAndCoercion \- Operator overloading, subtypes, and coercion
.SH "VERSION"
.IX Header "VERSION"
version 2.1202
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  package Human;
\&
\&  use Moose;
\&  use Moose::Util::TypeConstraints;
\&
\&  subtype \*(AqSex\*(Aq
\&      => as \*(AqStr\*(Aq
\&      => where { $_ =~ m{^[mf]$}s };
\&
\&  has \*(Aqsex\*(Aq    => ( is => \*(Aqro\*(Aq, isa => \*(AqSex\*(Aq, required => 1 );
\&
\&  has \*(Aqmother\*(Aq => ( is => \*(Aqro\*(Aq, isa => \*(AqHuman\*(Aq );
\&  has \*(Aqfather\*(Aq => ( is => \*(Aqro\*(Aq, isa => \*(AqHuman\*(Aq );
\&
\&  use overload \*(Aq+\*(Aq => \e&_overload_add, fallback => 1;
\&
\&  sub _overload_add {
\&      my ( $one, $two ) = @_;
\&
\&      die(\*(AqOnly male and female humans may create children\*(Aq)
\&          if ( $one\->sex() eq $two\->sex() );
\&
\&      my ( $mother, $father )
\&          = ( $one\->sex eq \*(Aqf\*(Aq ? ( $one, $two ) : ( $two, $one ) );
\&
\&      my $sex = \*(Aqf\*(Aq;
\&      $sex = \*(Aqm\*(Aq if ( rand() >= 0.5 );
\&
\&      return Human\->new(
\&          sex    => $sex,
\&          mother => $mother,
\&          father => $father,
\&      );
\&  }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This Moose cookbook recipe shows how operator overloading, coercion,
and subtypes can be used to mimic the human reproductive system
(well, the selection of genes at least).
.SH "INTRODUCTION"
.IX Header "INTRODUCTION"
Our \f(CW\*(C`Human\*(C'\fR class uses operator overloading to allow us to \*(L"add\*(R" two
humans together and produce a child. Our implementation does require
that the two objects be of opposite sex. Remember, we're talking
about biological reproduction, not marriage.
.PP
While this example works as-is, we can take it a lot further by adding
genes into the mix. We'll add the two genes that control eye color,
and use overloading to combine the genes from the parent to model the
biology.
.SS "What is Operator Overloading?"
.IX Subsection "What is Operator Overloading?"
Overloading is \fInot\fR a Moose-specific feature. It's a general \s-1OO\s0
concept that is implemented in Perl with the \f(CW\*(C`overload\*(C'\fR
pragma. Overloading lets objects do something sane when used with
Perl's built in operators, like addition (\f(CW\*(C`+\*(C'\fR) or when used as a
string.
.PP
In this example we overload addition so we can write code like
\&\f(CW\*(C`$child = $mother + $father\*(C'\fR.
.SH "GENES"
.IX Header "GENES"
There are many genes which affect eye color, but there are two which
are most important, \fIgey\fR and \fIbey2\fR. We will start by making a
class for each gene.
.SS "Human::Gene::bey2"
.IX Subsection "Human::Gene::bey2"
.Vb 1
\&  package Human::Gene::bey2;
\&
\&  use Moose;
\&  use Moose::Util::TypeConstraints;
\&
\&  type \*(Aqbey2_color\*(Aq => where { $_ =~ m{^(?:brown|blue)$} };
\&
\&  has \*(Aqcolor\*(Aq => ( is => \*(Aqro\*(Aq, isa => \*(Aqbey2_color\*(Aq );
.Ve
.PP
This class is trivial. We have a type constraint for the allowed
colors, and a \f(CW\*(C`color\*(C'\fR attribute.
.SS "Human::Gene::gey"
.IX Subsection "Human::Gene::gey"
.Vb 1
\&  package Human::Gene::gey;
\&
\&  use Moose;
\&  use Moose::Util::TypeConstraints;
\&
\&  type \*(Aqgey_color\*(Aq => where { $_ =~ m{^(?:green|blue)$} };
\&
\&  has \*(Aqcolor\*(Aq => ( is => \*(Aqro\*(Aq, isa => \*(Aqgey_color\*(Aq );
.Ve
.PP
This is nearly identical to the \f(CW\*(C`Humane::Gene::bey2\*(C'\fR class, except
that the \fIgey\fR gene allows for different colors.
.SH "EYE COLOR"
.IX Header "EYE COLOR"
We could just give four attributes (two of each gene) to the
\&\f(CW\*(C`Human\*(C'\fR class, but this is a bit messy. Instead, we'll abstract the
genes into a container class, \f(CW\*(C`Human::EyeColor\*(C'\fR. Then a \f(CW\*(C`Human\*(C'\fR can
have a single \f(CW\*(C`eye_color\*(C'\fR attribute.
.PP
.Vb 1
\&  package Human::EyeColor;
\&
\&  use Moose;
\&  use Moose::Util::TypeConstraints;
\&
\&  coerce \*(AqHuman::Gene::bey2\*(Aq
\&      => from \*(AqStr\*(Aq
\&          => via { Human::Gene::bey2\->new( color => $_ ) };
\&
\&  coerce \*(AqHuman::Gene::gey\*(Aq
\&      => from \*(AqStr\*(Aq
\&          => via { Human::Gene::gey\->new( color => $_ ) };
\&
\&  has [qw( bey2_1 bey2_2 )] =>
\&      ( is => \*(Aqro\*(Aq, isa => \*(AqHuman::Gene::bey2\*(Aq, coerce => 1 );
\&
\&  has [qw( gey_1 gey_2 )] =>
\&      ( is => \*(Aqro\*(Aq, isa => \*(AqHuman::Gene::gey\*(Aq, coerce => 1 );
.Ve
.PP
The eye color class has two of each type of gene. We've also created a
coercion for each class that coerces a string into a new object. Note
that a coercion will fail if it attempts to coerce a string like
\&\*(L"indigo\*(R", because that is not a valid color for either type of gene.
.PP
As an aside, you can see that we can define several identical
attributes at once by supplying an array reference of names as the first
argument to \f(CW\*(C`has\*(C'\fR.
.PP
We also need a method to calculate the actual eye color that results
from a set of genes. The \fIbey2\fR brown gene is dominant over both blue
and green. The \fIgey\fR green gene is dominant over blue.
.PP
.Vb 2
\&  sub color {
\&      my ($self) = @_;
\&
\&      return \*(Aqbrown\*(Aq
\&          if ( $self\->bey2_1\->color() eq \*(Aqbrown\*(Aq
\&          or $self\->bey2_2\->color() eq \*(Aqbrown\*(Aq );
\&
\&      return \*(Aqgreen\*(Aq
\&          if ( $self\->gey_1\->color() eq \*(Aqgreen\*(Aq
\&          or $self\->gey_2\->color() eq \*(Aqgreen\*(Aq );
\&
\&      return \*(Aqblue\*(Aq;
\&  }
.Ve
.PP
We'd like to be able to treat a \f(CW\*(C`Human::EyeColor\*(C'\fR object as a string,
so we define a string overloading for the class:
.PP
.Vb 1
\&  use overload \*(Aq""\*(Aq => \e&color, fallback => 1;
.Ve
.PP
Finally, we need to define overloading for addition. That way we can
add together two \f(CW\*(C`Human::EyeColor\*(C'\fR objects and get a new one with a
new (genetically correct) eye color.
.PP
.Vb 1
\&  use overload \*(Aq+\*(Aq => \e&_overload_add, fallback => 1;
\&
\&  sub _overload_add {
\&      my ( $one, $two ) = @_;
\&
\&      my $one_bey2 = \*(Aqbey2_\*(Aq . _rand2();
\&      my $two_bey2 = \*(Aqbey2_\*(Aq . _rand2();
\&
\&      my $one_gey = \*(Aqgey_\*(Aq . _rand2();
\&      my $two_gey = \*(Aqgey_\*(Aq . _rand2();
\&
\&      return Human::EyeColor\->new(
\&          bey2_1 => $one\->$one_bey2\->color(),
\&          bey2_2 => $two\->$two_bey2\->color(),
\&          gey_1  => $one\->$one_gey\->color(),
\&          gey_2  => $two\->$two_gey\->color(),
\&      );
\&  }
\&
\&  sub _rand2 {
\&      return 1 + int( rand(2) );
\&  }
.Ve
.PP
When two eye color objects are added together, the \f(CW\*(C`_overload_add()\*(C'\fR
method will be passed two \f(CW\*(C`Human::EyeColor\*(C'\fR objects. These are the
left and right side operands for the \f(CW\*(C`+\*(C'\fR operator. This method
returns a new \f(CW\*(C`Human::EyeColor\*(C'\fR object.
.ie n .SH "ADDING EYE COLOR TO ""Human""s"
.el .SH "ADDING EYE COLOR TO \f(CWHuman\fPs"
.IX Header "ADDING EYE COLOR TO Humans"
Our original \f(CW\*(C`Human\*(C'\fR class requires just a few changes to incorporate
our new \f(CW\*(C`Human::EyeColor\*(C'\fR class.
.PP
.Vb 1
\&  use List::MoreUtils qw( zip );
\&
\&  coerce \*(AqHuman::EyeColor\*(Aq
\&      => from \*(AqArrayRef\*(Aq
\&      => via { my @genes = qw( bey2_1 bey2_2 gey_1 gey_2 );
\&               return Human::EyeColor\->new( zip( @genes, @{$_} ) ); };
\&
\&  has \*(Aqeye_color\*(Aq => (
\&      is       => \*(Aqro\*(Aq,
\&      isa      => \*(AqHuman::EyeColor\*(Aq,
\&      coerce   => 1,
\&      required => 1,
\&  );
.Ve
.PP
We also need to modify \f(CW\*(C`_overload_add()\*(C'\fR in the \f(CW\*(C`Human\*(C'\fR class to
account for eye color:
.PP
.Vb 6
\&  return Human\->new(
\&      sex       => $sex,
\&      eye_color => ( $one\->eye_color() + $two\->eye_color() ),
\&      mother    => $mother,
\&      father    => $father,
\&  );
.Ve
.SH "CONCLUSION"
.IX Header "CONCLUSION"
The three techniques we used, overloading, subtypes, and coercion,
combine to provide a powerful interface.
.PP
If you'd like to learn more about overloading, please read the
documentation for the overload pragma.
.PP
To see all the code we created together, take a look at
\&\fIt/recipes/basics_recipe9.t\fR.
.SH "NEXT STEPS"
.IX Header "NEXT STEPS"
Had this been a real project we'd probably want:
.IP "Better Randomization with Crypt::Random" 4
.IX Item "Better Randomization with Crypt::Random"
.PD 0
.IP "Characteristic Base Class" 4
.IX Item "Characteristic Base Class"
.IP "Mutating Genes" 4
.IX Item "Mutating Genes"
.IP "More Characteristics" 4
.IX Item "More Characteristics"
.IP "Artificial Life" 4
.IX Item "Artificial Life"
.PD
.SH "LICENSE"
.IX Header "LICENSE"
This work is licensed under a Creative Commons Attribution 3.0 Unported License.
.PP
License details are at: <http://creativecommons.org/licenses/by/3.0/>
.SH "AUTHORS"
.IX Header "AUTHORS"
.IP "\(bu" 4
Stevan Little <stevan.little@iinteractive.com>
.IP "\(bu" 4
Dave Rolsky <autarch@urth.org>
.IP "\(bu" 4
Jesse Luehrs <doy@tozt.net>
.IP "\(bu" 4
Shawn M Moore <code@sartak.org>
.IP "\(bu" 4
\&\s-1XXXX XXX\s0'\s-1XX \s0(Yuval Kogman) <nothingmuch@woobling.org>
.IP "\(bu" 4
Karen Etheridge <ether@cpan.org>
.IP "\(bu" 4
Florian Ragwitz <rafl@debian.org>
.IP "\(bu" 4
Hans Dieter Pearcey <hdp@weftsoar.net>
.IP "\(bu" 4
Chris Prather <chris@prather.org>
.IP "\(bu" 4
Matt S Trout <mst@shadowcat.co.uk>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is copyright (c) 2006 by Infinity Interactive, Inc..
.PP
This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.
