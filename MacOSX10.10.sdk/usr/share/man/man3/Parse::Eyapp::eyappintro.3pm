.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Parse::Eyapp::eyappintro 3"
.TH Parse::Eyapp::eyappintro 3 "2012-03-23" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Parse::Eyapp::eyappintro \- An introduction to Parse::Eyapp
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 5
\&  # File \*(Aqcalc.eyp\*(Aq: translates infix expressions to postfix
\&  # Compile it with:  eyapp \-o calc.pl \-C Postfix.eyp
\&  # Execution:        ./calc.pl \-c \*(Aqa = 2*3+b\*(Aq
\&  %token NUM = /([0\-9]+(?:\e.[0\-9]+)?)/
\&  %token VAR = /([A\-Za\-z][A\-Za\-z0\-9_]*)/
\&
\&  %right  \*(Aq=\*(Aq
\&  %left   \*(Aq\-\*(Aq \*(Aq+\*(Aq
\&  %left   \*(Aq*\*(Aq \*(Aq/\*(Aq
\&  %left   NEG
\&
\&  %defaultaction { "$left $right $op"; }
\&
\&  %%
\&  line: $exp  { print "$exp\en" }
\&  ;
\&
\&  exp:        $NUM  { $NUM }            
\&          |   $VAR  { $VAR }            
\&          |   VAR.left \*(Aq=\*(Aq.op exp.right         
\&          |   exp.left \*(Aq+\*(Aq.op exp.right         
\&          |   exp.left \*(Aq\-\*(Aq.op exp.right        
\&          |   exp.left \*(Aq*\*(Aq.op exp.right       
\&          |   exp.left \*(Aq/\*(Aq.op exp.right      
\&          |   \*(Aq\-\*(Aq $exp %prec NEG { "$exp NEG" }
\&          |   \*(Aq(\*(Aq $exp \*(Aq)\*(Aq { $exp }      
\&  ;
\&
\&  %%
.Ve
.SH "INTRODUCTION TO PARSING WITH Parse::Eyapp"
.IX Header "INTRODUCTION TO PARSING WITH Parse::Eyapp"
.SS "Introduction"
.IX Subsection "Introduction"
Parsing is the activity of producing a syntax tree
from an input stream. The program example in the synopsis 
section shows an example of a translation scheme. 
It translates infix arithmetic expressions like
.PP
.Vb 1
\&   a = 2 * 3 + 4 * b
.Ve
.PP
into postfix expressions like
.PP
.Vb 1
\&   a 2 3 * 4 b * + =
.Ve
.PP
The program contains a context free eyapp grammar defining the language 
of arithmetic infix expressions. A context free grammar
is a mathematical device to define languages. To better see the grammar
for the example above we have to eliminate the semantic 
actions (We call semantic actions to the sections delimited by curly brackets
containing Perl code).
This can be done calling \f(CW\*(C`eyapp\*(C'\fR with options \f(CW\*(C`\-vc\*(C'\fR:
.PP
.Vb 7
\&  $ eyapp \-vc Postfix.eyp 
\&  %token NUM =/([0\-9]+(?:\e.[0\-9]+)?)/ 
\&  %token VAR =/([A\-Za\-z][A\-Za\-z0\-9_]*)/ 
\&  %right \*(Aq=\*(Aq 
\&  %left \*(Aq\-\*(Aq \*(Aq+\*(Aq 
\&  %left \*(Aq*\*(Aq \*(Aq/\*(Aq 
\&  %left NEG 
\&
\&  %%
\&
\&  line:
\&        exp 
\&  ;
\&  exp:
\&        NUM
\&      | VAR
\&      | VAR \*(Aq=\*(Aq exp
\&      | exp \*(Aq+\*(Aq exp
\&      | exp \*(Aq\-\*(Aq exp
\&      | exp \*(Aq*\*(Aq exp
\&      | exp \*(Aq/\*(Aq exp
\&      | \*(Aq\-\*(Aq exp %prec NEG
\&      | \*(Aq(\*(Aq exp \*(Aq)\*(Aq  
\&  ;
\&
\&  %%
.Ve
.PP
A grammar generates a language. A grammar is defined by a set of production rules. A production rule
has two components: a left hand side which is a \fIsyntactic variable\fR or \fInon terminal\fR and a right hand side
which is a phrase made of syntactic variables and terminals. The left hand side (\fIlhs\fR) and the right
hand side (\fIrhs\fR) are usually separated by an arrow like in:
.PP
.Vb 1
\&                                    exp \-> VAR = exp
.Ve
.PP
A note: when you see a production rule like:
.PP
.Vb 1
\&                        line: exp <+ \*(Aq;\*(Aq>
.Ve
.PP
is not really a production rule but an abbreviation for two productions. It stands for:
.PP
.Vb 3
\&                        line : exp
\&                             | line \*(Aq;\*(Aq exp
\&                        ;
.Ve
.PP
A \fIterminal\fR or \fItoken\fR never appears on the left hand side of a production rule.
.SS "Ambiguity"
.IX Subsection "Ambiguity"
The phrases of the language are those obtained 
successively applying the production rules of the grammar until no more rules can be applied.
The successive substitutions must start from the \f(CW\*(C`start\*(C'\fR symbol of the grammar (\f(CW\*(C`line\*(C'\fR in
the example). Such legal
sequence of substitutions is known as a \fIderivation\fR. The following is an example of a
legal derivation (the big arrow \f(CW\*(C`=>\*(C'\fR is read \fIderives\fR):
.PP
.Vb 1
\&  line => exp => VAR = exp => VAR = exp + exp => VAR = exp + NUM => VAR = VAR + NUM
.Ve
.PP
thus the phrase \f(CW\*(C`VAR = VAR + NUM\*(C'\fR belongs to the language generated by the former grammar.
A derivation like this can be seen as a tree. For instance, the former derivation is equivalent (has 
the same information) than the following tree:
.PP
.Vb 10
\&                             +\-\-\-\-+
\&                             |line|
\&                             +\-\-\-\-+
\&                                |
\&                              +\-\-\-+
\&                              |exp|
\&                              +\-\-\-+
\&                    .\-\-\-\-\-.\-\-\-\-\-^\-\-\-\-\-.
\&                  +\-\-\-+ +\-\-\-+        +\-\-\-+
\&                  |VAR| | = |        |exp|
\&                  +\-\-\-+ +\-\-\-+        +\-\-\-+
\&                                 .\-\-\-\-\-+\-\-\-\-\-.
\&                               +\-\-\-+ +\-\-\-+ +\-\-\-+
\&                               |exp| | + | |exp|
\&                               +\-\-\-+ +\-\-\-+ +\-\-\-+
\&                                 |           |
\&                               +\-\-\-+       +\-\-\-+
\&                               |VAR|       |NUM|
\&                               +\-\-\-+       +\-\-\-+
.Ve
.PP
which can be written more succinctly:
.PP
.Vb 1
\&                        line(exp(VAR, \*(Aq=\*(Aq, exp(exp(VAR), \*(Aq+\*(Aq,  exp(NUM))))
.Ve
.PP
or even more briefly:
.PP
.Vb 1
\&                                      VAR = (VAR + NUM)
.Ve
.PP
Such a tree is called a \fIsyntax tree\fR for the input \f(CW\*(C`VAR = VAR + NUM\*(C'\fR.
A grammar is said to be \fIambiguous\fR if there are phrases in the generated language that have
more than one syntax tree. The grammar in the synopsis example is ambiguous. Here is an alternative
tree for the same phrase \f(CW\*(C`VAR = VAR + NUM\*(C'\fR:
.PP
.Vb 10
\&                                    +\-\-\-\-+
\&                                    |line|
\&                                    +\-\-\-\-+
\&                                       |
\&                                     +\-\-\-+
\&                                     |exp|
\&                                     +\-\-\-+
\&                            .\-\-\-\-\-\-\-\-\-\-^\-\-\-\-\-.\-\-\-\-\-.
\&                          +\-\-\-+            +\-\-\-+  +\-\-\-+
\&                          |exp|            | + |  |exp|
\&                          +\-\-\-+            +\-\-\-+  +\-\-\-+
\&                      .\-\-\-\-\-+\-\-\-\-\-.                 |
\&                    +\-\-\-+ +\-\-\-+ +\-\-\-+             +\-\-\-+
\&                    |VAR| | = | |exp|             |NUM|
\&                    +\-\-\-+ +\-\-\-+ +\-\-\-+             +\-\-\-+
\&                                  |
\&                                +\-\-\-+
\&                                |VAR|
\&                                +\-\-\-+
.Ve
.PP
or
.PP
.Vb 1
\&                        line(exp(exp(VAR, \*(Aq=\*(Aq, exp(VAR)), \*(Aq+\*(Aq, exp(NUM)))
.Ve
.PP
or
.PP
.Vb 1
\&                                     (VAR = VAR) + NUM
.Ve
.SS "Semantic Actions and Attributes"
.IX Subsection "Semantic Actions and Attributes"
\&\f(CW\*(C`Parse::Eyapp\*(C'\fR analyzes your grammar and produce a \s-1LALR\s0 parser.
Actually the \s-1SYNOPSIS\s0 example is more than a context free grammar: 
is a \fItranslation scheme\fR. A \fItranslation scheme\fR 
scheme is a context free grammar where the right hand sides of the productions 
have been augmented with semantic actions (i.e. with chunks of Perl code):
.PP
.Vb 1
\&                                A \-> alpha { action(@_) } beta
.Ve
.PP
The analyzer generated by Eyapp executes \f(CW\*(C`{ action(@_) }\*(C'\fR after all the semantic actions
associated with \f(CW\*(C`alpha\*(C'\fR have been executed and before the execution of any of the semantic 
actions associated with \f(CW\*(C`beta\*(C'\fR.
.PP
In a translation scheme each symbol occurrence has an \fIassociated attribute\fR.
The embedded actions modify the attributes associated with the symbols of the grammar:
.PP
.Vb 1
\&                        A \-> alpha { action(@_) } beta
.Ve
.PP
\&\fIEach symbol on the right hand side
of a production rule has an associated scalar attribute\fR. 
In \f(CW\*(C`eyapp\*(C'\fR the attributes of the symbols
to the left of \f(CW\*(C`action\*(C'\fR are passed as arguments to \f(CW\*(C`action\*(C'\fR (in the example, those of \f(CW\*(C`alpha\*(C'\fR). 
These arguments are preceded by a reference to the syntax analyzer object.
Therefore, you can access to the attributes associated with the first, second, etc. symbols in the right
hand side using the notation:
.PP
.Vb 1
\&               $_[1], $_[2], ...
.Ve
.PP
However it is better to refer to the attributes by names. This is the purpose of the dot
and dollar notations as in:
.PP
.Vb 10
\&  exp:        $NUM  { $NUM }            
\&          |   $VAR  { $VAR }            
\&          |   VAR.left \*(Aq=\*(Aq.op exp.right         
\&          |   exp.left \*(Aq+\*(Aq.op exp.right         
\&          |   exp.left \*(Aq\-\*(Aq.op exp.right        
\&          |   exp.left \*(Aq*\*(Aq.op exp.right       
\&          |   exp.left \*(Aq/\*(Aq.op exp.right      
\&          |   \*(Aq\-\*(Aq $exp %prec NEG { "$exp NEG" }
\&          |   \*(Aq(\*(Aq $exp \*(Aq)\*(Aq { $exp }      
\&  ;
.Ve
.PP
By prefixing the symbol \f(CW\*(C`NUM\*(C'\fR by a \f(CW\*(C`$\*(C'\fR we can refer to the associated attribute inside the semantic action 
as \f(CW$NUM\fR:
.PP
.Vb 1
\&  exp:        $NUM  { $NUM }
.Ve
.PP
By postfixing the two appearances of \f(CW\*(C`expr\*(C'\fR with \f(CW\*(C`.left\*(C'\fR and \f(CW\*(C`.right\*(C'\fR and the appearance of
\&\f(CW\*(Aq+\*(Aq\fR with \f(CW\*(C`.op\*(C'\fR we can refer to the associates attributes as \f(CW$left\fR, \f(CW$right\fR and \f(CW$op\fR
instead of \f(CW$_[1]\fR, \f(CW$_[3]\fR and \f(CW$_[2]\fR:
.PP
.Vb 1
\&  %defaultaction { "$left $right $op"; }
.Ve
.PP
There is no way inside an ordinary \f(CW\*(C`eyapp\*(C'\fR program for an intermediate \f(CW\*(C`action\*(C'\fR to 
access the attributes of the symbols
on its right, i.e. those associated with the symbols of \f(CW\*(C`beta\*(C'\fR. This restriction is lifted 
if you  use the \f(CW%metatree\fR directive to build a \fIfull translation scheme\fR. 
See 
Parse::Eyapp::translationschemestut
to know more about full translation schemes.
.PP
Actions on the 
right hand side counts as symbols and so they can be referenced by its positional argument
in later actions in the same production rule. For intermediate actions, the value returned by the \f(CW\*(C`action\*(C'\fR is 
the attribute associated with such action. For an action at the end of the rule:
.PP
.Vb 1
\&                        A \-> alpha { lastaction(@_) }
.Ve
.PP
the returned value constitutes the attribute of the left hand side of the rule (the
attribute of \f(CW\*(C`A\*(C'\fR in this case). The action at the end of the right hand side is 
called the \fIaction associated with the production rule\fR. When no explicit action
has been associated with a production rule the \fIdefault action\fR applies. In \f(CW\*(C`Parse::Eyapp\*(C'\fR
the programmer can define what is the default action through the \f(CW%defaultaction\fR directive:
.PP
.Vb 1
\&                        %defaultaction { "$left $right $op"; }
.Ve
.PP
Actually, intermediate actions are implemented via a trick. When \f(CW\*(C`eyapp\*(C'\fR sees
an intermediate action like:
.PP
.Vb 1
\&                        A \-> alpha { action(@_) } beta
.Ve
.PP
it creates a new auxiliary syntactic variable \f(CW\*(C`Temp\*(C'\fR:
.PP
.Vb 1
\&                      Temp \-> /* empty */ { action(@_) }
.Ve
.SS "Solving Ambiguities via Precedence and Associativity Declarations"
.IX Subsection "Solving Ambiguities via Precedence and Associativity Declarations"
Notice that ambiguous grammars produce ambiguous translation schemes: 
since a phrase may have two syntactic
trees it will be more than one tree-traversing and consequently more than one 
way to execute the embedded semantic actions. Certainly different execution
orders will usually produce different results. Thus, syntactic ambiguities translate
onto semantic ambiguities. That is why it is so important to resolve all the 
ambiguities and conflicts that may arise in our grammars. This is the function 
of the \f(CW%left\fR and \f(CW%right\fR declarations on the header section:
.PP
.Vb 4
\&      %right  \*(Aq=\*(Aq     # Lowest precedence
\&      %left   \*(Aq\-\*(Aq \*(Aq+\*(Aq # + and \- have more precedence than = Disambiguate a\-b\-c as (a\-b)\-c
\&      %left   \*(Aq*\*(Aq \*(Aq/\*(Aq # * and / have more precedence than + Disambiguate a/b/c as (a/b)/c
\&      %left   NEG     # Disambiguate \-a\-b as (\-a)\-b and not as \-(a\-b)
.Ve
.PP
Priority can be assigned to tokens by using the \f(CW%left\fR and \f(CW%right\fR declarations. \fITokens in
lines below have more precedence than tokens in line above\fR. 
The idea  behind this notation is this: 
\&\fIAny ambiguity can be seen as a parenthesizing problem\fR. You can parenthesize left (in the jargon this
is called \fIreduce\fR) or parenthesize right (in the jargon, \fIshift\fR).
Recall the main points of yacc-like parsers related to priorities:
.IP "\(bu" 2
The directives
.Sp
.Vb 3
\&            %left
\&            %right
\&            %nonassoc
.Ve
.Sp
can be used in the head section to declare the priority of a token
.IP "\(bu" 2
The later the declaration line the higher the priority
.IP "\(bu" 2
Tokens in the same line have the same priority. Ties will be solved
using the token associativity (whether they were declared \f(CW%left\fR or \f(CW%right\fR)
.IP "\(bu" 2
The \fIprecedence of a production rule (right hand side) is the precedence
of the last token in the right hand side\fR
.IP "\(bu" 2
If the parser emits a warning announcing a shift-reduce conflict or a reduce-reduce
conflict in your grammar, it likely means that your grammar is ambiguous or not \s-1LALR.\s0
In such case, recompile the grammar with \f(CW\*(C`eyapp \-v\*(C'\fR and carefully study the \f(CW\*(C`.output\*(C'\fR file generated.
\&\fIDetect which token and which rules are involved in the conflict\fR.
.IP "\(bu" 2
In a shift-reduce conflict the default action is to shift (i.e. associate right). This action can be changed
if the production and the token involved have explicit priorities
.IP "\(bu" 2
Most of the time the presence of a reduce-reduce conflict 
means that your grammar is ambiguous. Rewrite your grammar. Alternatively, use the \f(CW%conflict\fR and \f(CW%PREC\fR directives
(see example \f(CW\*(C`debuggintut/pascalenumeratedvsrangesolvedviadyn.eyp\*(C'\fR). 
The default action is to reduce by the first production.
.IP "\(bu" 2
If the precedence of the production rule is higher the shift-reduce conflict is solved 
in favor of the reduction (i.e. associate left)
.IP "\(bu" 2
If the precedence of the token is higher the shift-reduce conflict is solved 
in favor of the shift (i.e. associate right).
.IP "\(bu" 2
If the precedence of the token is the same than the precedence of the rule, and is left 
the shift-reduce conflict is solved in favor of the reduction (i.e. associate left)
.IP "\(bu" 2
If the precedence of the token is the same than the precedence of the rule, and is right 
the shift-reduce conflict is solved in favor of the shift
.IP "\(bu" 2
If the precedence of the token is the same than the precedence of the rule, and is nonassoc 
the presence of a shift-reduce conflict means an error.
This is used to describe operators, like the operator \f(CW\*(C`.LT.\*(C'\fR in \s-1FORTRAN, \s0
that may not associate with themselves. That is, because
.Sp
.Vb 1
\&                             A .LT. B .LT. C
.Ve
.Sp
is invalid in \s-1FORTRAN, \s0\f(CW\*(C`.LT.\*(C'\fR would be described with the keyword \f(CW%nonassoc\fR in eyapp.
.IP "\(bu" 2
The default precedence of a production can be changed using the \f(CW\*(C`%prec TOKEN\*(C'\fR directive.
Now the rule has the precedence and \fIassociativity\fR of the specified \f(CW\*(C`TOKEN\*(C'\fR.
.SS "Examples"
.IX Subsection "Examples"
.IP "\(bu" 2
By giving token \f(CW\*(Aq+\*(Aq\fR more precedence than token \f(CW\*(Aq=\*(Aq\fR we solve the ambiguity in
\&\f(CW\*(C`VAR = VAR + NUM\*(C'\fR in favor of \f(CW\*(C` VAR = (VAR + NUM)\*(C'\fR. The conflict occurs between the productions
.Sp
.Vb 2
\&                            exp \-> exp . \*(Aq+\*(Aq exp 
\&                            exp \-> VAR \*(Aq=\*(Aq exp .
.Ve
.Sp
Where the dot means:
.Sp
\&\fIIf I have seen\fR \f(CW\*(C`VAR \*(Aq=\*(Aq exp\*(C'\fR 
\&\fIand I am in the presence of a token\fR \f(CW\*(Aq+\*(Aq\fR \fII can associate left, i.e. reduce\fR 
\&\f(CW\*(C`VAR \*(Aq=\*(Aq exp\*(C'\fR \fIto\fR \f(CW\*(C`exp\*(C'\fR 
\&\fIor to associate right,\fR 
\&\fIthat is, to shift to the right to reduce\fR \f(CW\*(C`exp \*(Aq+\*(Aq exp\*(C'\fR \fIto\fR \f(CW\*(C`exp\*(C'\fR \fIlater\fR.
.IP "\(bu" 2
How it works when two tokens are declared in the same line?
Consider the phrase \f(CW\*(C`NUM \- NUM \- NUM\*(C'\fR. It will be interpreted
as \f(CW\*(C`(NUM \- NUM) \- NUM\*(C'\fR if the token \f(CW\*(Aq\-\*(Aq\fR is declared \f(CW\*(C`%left \*(Aq\-\*(Aq\*(C'\fR and 
will be interpreted as \f(CW\*(C`NUM \- (NUM \- NUM)\*(C'\fR  if the token \f(CW\*(Aq\-\*(Aq\fR is declared \f(CW\*(C`%right \*(Aq\-\*(Aq\*(C'\fR.
By saying \f(CW\*(Aq\-\*(Aq\fR is left
we are saying we  prefer between the two trees in dispute the one
that deepens to the left:
.Sp
.Vb 10
\&                                       +\-\-\-+
\&                                       |exp|
\&                                       +\-\-\-+
\&                                .\-\-\-\-\-\-\-\-^\-\-.\-\-\-\-\-.
\&                              +\-\-\-+       +\-\-\-+ +\-\-\-+
\&                              |exp|       | \- | |exp|
\&                              +\-\-\-+       +\-\-\-+ +\-\-\-+
\&                          .\-\-\-\-\-+\-\-\-\-\-.           |
\&                        +\-\-\-+ +\-\-\-+ +\-\-\-+       +\-\-\-+
\&                        |exp| | \- | |exp|       |NUM|
\&                        +\-\-\-+ +\-\-\-+ +\-\-\-+       +\-\-\-+
\&                          |           |
\&                        +\-\-\-+       +\-\-\-+
\&                        |NUM|       |NUM|
\&                        +\-\-\-+       +\-\-\-+
.Ve
.Sp
By saying \f(CW\*(Aq\-\*(Aq\fR is right we are saying we  prefer between the two trees in dispute the one
that deepens to the right:
.Sp
.Vb 10
\&                                        +\-\-\-+
\&                                        |exp|
\&                                        +\-\-\-+
\&                              .\-\-\-\-\-.\-\-\-\-\-^\-\-\-\-\-.
\&                            +\-\-\-+ +\-\-\-+       +\-\-\-+
\&                            |exp| |MIN|       |exp|
\&                            +\-\-\-+ +\-\-\-+       +\-\-\-+
\&                              |           .\-\-\-\-\-+\-\-\-\-\-.
\&                            +\-\-\-+       +\-\-\-+ +\-\-\-+ +\-\-\-+
\&                            |NUM|       |exp| |MIN| |exp|
\&                            +\-\-\-+       +\-\-\-+ +\-\-\-+ +\-\-\-+
\&                                           |           |
\&                                         +\-\-\-+       +\-\-\-+
\&                                         |NUM|       |NUM|
\&                                         +\-\-\-+       +\-\-\-+
.Ve
.Sp
Since \fIpriority means earlier evaluation\fR
and the evaluation by eyapp of semantic actions is bottom up, \fIthe deeper the associated subtree the higher
the priority\fR.
.IP "\(bu" 2
Consider now the phrase \f(CW\*(C`\-NUM\-NUM\*(C'\fR. There are two interpretations:
one as \f(CW\*(C`\-(NUM\-NUM)\*(C'\fR and the other as \f(CW\*(C`(\-NUM)\-NUM\*(C'\fR. The conflict occurs between the productions
.Sp
.Vb 2
\&                            exp \-> exp . \*(Aq\-\*(Aq exp 
\&                            exp \-> \*(Aq\-\*(Aq exp.
.Ve
.Sp
Both productions have the precedence of the token \f(CW\*(Aq\-\*(Aq\fR. But we prefer the interpretation
\&\f(CW\*(C`(\-NUM)\-NUM\*(C'\fR to win. We do that by explicitly changing the precedence associated with
the unary minus production via the \f(CW%prec\fR directive.
.SS "Lexical Analysis"
.IX Subsection "Lexical Analysis"
Parsers created by \f(CW\*(C`eyapp\*(C'\fR do not deal directly with the input. Instead they expect the input
to be processed by a \fIlexical analyzer\fR. The lexical analyzer parses the input and produces
the next token. A \fItoken\fR is a pair. The first component is the name of the token (like \f(CW\*(C`NUM\*(C'\fR
or \f(CW\*(C`VAR\*(C'\fR) and the second is its attribute (i.e. the information associated with the token, like 
that the value is \f(CW4\fR for a \f(CW\*(C`NUM\*(C'\fR or the identifier is \f(CW\*(C`temperature\*(C'\fR for a
\&\f(CW\*(C`VAR\*(C'\fR). Tokens are usually defined using regular expressions. Thus the token 
\&\f(CW\*(C`NUM\*(C'\fR is characterized by \f(CW\*(C`/[0\-9]+(?:\e.[0\-9]+)?/\*(C'\fR and the token
\&\f(CW\*(C`VAR\*(C'\fR by \f(CW\*(C`/[A\-Za\-z][A\-Za\-z0\-9_]*/\*(C'\fR. The eyapp compiler 
automatically generates a lexical analyzer from
your token definitions. The tokens \f(CW\*(C`NUM\*(C'\fR and \f(CW\*(C`VAR\*(C'\fR were defined using the \f(CW%token\fR directives:
.PP
.Vb 2
\&  %token NUM = /([0\-9]+(?:\e.[0\-9]+)?)/
\&  %token VAR = /([A\-Za\-z][A\-Za\-z0\-9_]*)/
.Ve
.PP
The order in which the tokens are defined is important. The input will be matched 
against the regular expression for \f(CW\*(C`NUM\*(C'\fR before the regular expression for \f(CW\*(C`VAR\*(C'\fR
is tried, and all the literal tokens that appear between quotes inside the body of the grammar,
like \f(CW\*(Aq+\*(Aq\fR or \f(CW\*(C`\*(Aq\-\*(C'\fR, are tried before any explicitly defined token.
.PP
You can, alternatively, define the lexical analyzer explicitly. There are many ways to do it.
Here is an example of a 
definition of a lexical analyzer using the \f(CW%lexer\fR directive:
.PP
.Vb 7
\&  %lexer  {
\&    m{\eG[ \et]*}gc;
\&    m{\eG(\en)+}gc                    and $self\->tokenline($1 =~ tr/\en//);
\&    m{\eG([0\-9]+(?:\e.[0\-9]+)?)}gc    and return (\*(AqNUM\*(Aq,   $1);
\&    m{\eG([A\-Za\-z_][A\-Za\-z0\-9_]*)}gc and return (\*(AqVAR\*(Aq,   $1);
\&    m{\eG(.)}gc                      and return ($1,      $1);
\&  }
.Ve
.PP
The \f(CW%lexer\fR directive is followed by the code defining the lexical analyzer.
When called, the variable \f(CW$_\fR is an alias of the input. 
The input can also be set and accessed via the \f(CW\*(C`input\*(C'\fR method of the \f(CW$parser\fR object.
.PP
To catch the next pattern we use the anchor \f(CW\*(C`\eG\*(C'\fR.
The \f(CW\*(C`\eG\*(C'\fR anchor matches at the point where the previous \f(CW\*(C`/g\*(C'\fR match left off. 
Normally, when a scalar \f(CW\*(C`m{}g\*(C'\fR match fails, the match position is reset and
\&\f(CW\*(C`\eG\*(C'\fR will start matching at the beginning of the string.
The \f(CW\*(C`c\*(C'\fR option causes the match position to be retained following an unsuccessful match.
The couple \f(CW\*(C`(\*(Aq\*(Aq,undef)\*(C'\fR which signals the end of the input is automatically inserted by 
\&\f(CW\*(C`eyapp\*(C'\fR.
.PP
By default, the lexers generated by \f(CW\*(C`eyapp\*(C'\fR emit the end-of-input token \f(CW\*(C`(\*(Aq\*(Aq, undef)\*(C'\fR
when the end of the current string is reached. A \fIincremental lexer\fR differs from these behavior:
when the end is reached it reads more input from the current file, which was set by
.PP
.Vb 1
\&                 $parser\->YYInputFile
.Ve
.PP
See the following variant of the synopsis example:
.PP
.Vb 4
\&  ~/LEyapp/examples/eyappintro$ cat InputFromStream.eyp 
\&  %whites /([ \et]+)/
\&  %token NUM = /([0\-9]+(?:\e.[0\-9]+)?)/
\&  %token VAR = /([A\-Za\-z][A\-Za\-z0\-9_]*)/
\&
\&  %right \*(Aq=\*(Aq
\&  %left   \*(Aq\-\*(Aq \*(Aq+\*(Aq
\&  %left   \*(Aq*\*(Aq \*(Aq/\*(Aq
\&  %left   NEG
\&
\&  %defaultaction { "$_[1] $_[3] $_[2]" }
\&
\&  # example of incremental lexer
\&  %incremental lexer  \*(AqWrite an arithmetic expression: \*(Aq
\&
\&  %%
\&  input:                  {}
\&          |   input line  {}
\&  ;
\&
\&  line:     \*(Aq\en\*(Aq       {}
\&          | exp \*(Aq\en\*(Aq   { print "$_[1]\en" } 
\&          | error \*(Aq\en\*(Aq   {}
\&  ;
\&
\&  exp:        NUM                { $_[1] }
\&          |   VAR                { $_[1] }
\&          |   VAR \*(Aq=\*(Aq exp         
\&          |   exp \*(Aq+\*(Aq exp         
\&          |   exp \*(Aq\-\*(Aq exp        
\&          |   exp \*(Aq*\*(Aq exp       
\&          |   exp \*(Aq/\*(Aq exp      
\&          |   \*(Aq\-\*(Aq exp %prec NEG  { "$_[2] NEG" }
\&          |   \*(Aq(\*(Aq exp \*(Aq)\*(Aq        { $_[2] } 
\&  ;
\&
\&  %%
.Ve
.PP
Now, after the grammar is compiled
.PP
.Vb 1
\&  ~/LEyapp/examples/eyappintro$ eyapp \-C InputFromStream.eyp
.Ve
.PP
When the generated modulino is executed, each time the end of the input string is reached, it asks for more
input until we press the end-of-file (\f(CW\*(C`^D\*(C'\fR in Unix) key:
.PP
.Vb 7
\&  ~/LEyapp/examples/eyappintro$ ./InputFromStream.pm \-noslurp
\&  Write an arithmetic expression: a=2+3*b
\&  a 2 3 b * + =
\&  Write an arithmetic expression: a=\-b*2
\&  a b NEG 2 * =
\&  Write an arithmetic expression: ^D
\&  ~/LEyapp/examples/eyappintro$
.Ve
.ie n .SS "The ""main"" and ""error"" subroutines"
.el .SS "The \f(CWmain\fP and \f(CWerror\fP subroutines"
.IX Subsection "The main and error subroutines"
If you compile your grammar with option \f(CW\*(C`\-C\*(C'\fR, \f(CW\*(C`eyapp\*(C'\fR will insert 
a line like this as the first line of the generated \f(CW\*(C`.pm\*(C'\fR file:
.PP
.Vb 1
\&                #!/usr/bin/perl
.Ve
.PP
It will also append a line like this as the last line of the \f(CW\*(C`.pm\*(C'\fR file:
.PP
.Vb 1
\&          unless (caller) { exit !_\|_PACKAGE_\|_\->main(\*(Aq\*(Aq); }
.Ve
.PP
This allows the alternative use of the module as a script.
Unless a \f(CW\*(C`main\*(C'\fR subroutine was defined, the one provided
by Parse::Eyapp::Driver will be called. It also provides
a default subroutine for the handling of error messages.
.PP
The default main accepts a few arguments from the command line.
Here are some:
.IP "\(bu" 2
\&\f(CW\*(C`\-f filename\*(C'\fR input from \f(CW\*(C`filename\*(C'\fR
.IP "\(bu" 2
\&\f(CW\*(C`\-c \*(Aqstring\*(Aq\*(C'\fR input from \f(CW\*(Aqstring\*(Aq\fR
.IP "\(bu" 2
\&\f(CW\*(C`\-noslurp\*(C'\fR when input is from \f(CW\*(C`STDIN\*(C'\fR don't wait for end of file
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.IP "\(bu" 4
The project home is at <http://code.google.com/p/parse\-eyapp/>.
Use a subversion client to anonymously check out the latest project source code:
.Sp
.Vb 1
\&   svn checkout http://parse\-eyapp.googlecode.com/svn/trunk/ parse\-eyapp\-read\-only
.Ve
.IP "\(bu" 4
The tutorial \fIParsing Strings and Trees with\fR \f(CW\*(C`Parse::Eyapp\*(C'\fR
(An Introduction to Compiler Construction in seven pages) in
<http://nereida.deioc.ull.es/~pl/eyapsimple/>
.IP "\(bu" 4
Parse::Eyapp, 
Parse::Eyapp::eyapplanguageref, 
Parse::Eyapp::debuggingtut,
Parse::Eyapp::defaultactionsintro,
Parse::Eyapp::translationschemestut,
Parse::Eyapp::Driver,
Parse::Eyapp::Node,
Parse::Eyapp::YATW,
Parse::Eyapp::Treeregexp,
Parse::Eyapp::Scope,
Parse::Eyapp::Base,
Parse::Eyapp::datagenerationtut
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/languageintro.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/debuggingtut.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/eyapplanguageref.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/Treeregexp.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/Node.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/YATW.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/Eyapp.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/Base.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/translationschemestut.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/treematchingtut.pdf>
.IP "\(bu" 4
perldoc eyapp,
.IP "\(bu" 4
perldoc treereg,
.IP "\(bu" 4
perldoc vgg,
.IP "\(bu" 4
The Syntax Highlight file for vim at <http://www.vim.org/scripts/script.php?script_id=2453>
and <http://nereida.deioc.ull.es/~vim/>
.IP "\(bu" 4
\&\fIAnalisis Lexico y Sintactico\fR, (Notes for a course in compiler 
construction) by  Casiano Rodriguez-Leon. 
Available at  <http://nereida.deioc.ull.es/~pl/perlexamples/>
Is the more complete and reliable source for Parse::Eyapp. However is in Spanish.
.IP "\(bu" 4
Parse::Yapp,
.IP "\(bu" 4
Man pages of \fIyacc\fR\|(1) and
\&\fIbison\fR\|(1),
<http://www.delorie.com/gnu/docs/bison/bison.html>
.IP "\(bu" 4
Language::AttributeGrammar
.IP "\(bu" 4
Parse::RecDescent.
.IP "\(bu" 4
HOP::Parser
.IP "\(bu" 4
HOP::Lexer
.IP "\(bu" 4
ocamlyacc tutorial at 
<http://plus.kaist.ac.kr/~shoh/ocaml/ocamllex\-ocamlyacc/ocamlyacc\-tutorial/ocamlyacc\-tutorial.html>
.SH "REFERENCES"
.IX Header "REFERENCES"
.IP "\(bu" 4
The classic Dragon's book \fICompilers: Principles, Techniques, and Tools\fR 
by Alfred V. Aho, Ravi Sethi and
Jeffrey D. Ullman (Addison-Wesley 1986)
.IP "\(bu" 4
\&\fI\s-1CS2121:\s0 The Implementation and Power of Programming Languages\fR
(See <http://www.cs.man.ac.uk/~pjj>, <http://www.cs.man.ac.uk/~pjj/complang/g2lr.html> 
and <http://www.cs.man.ac.uk/~pjj/cs2121/ho/ho.html>) by 
Pete Jinks
.SH "CONTRIBUTORS"
.IX Header "CONTRIBUTORS"
.IP "\(bu" 2
Hal Finkel <http://www.halssoftware.com/>
.IP "\(bu" 2
G. Williams <http://kasei.us/>
.IP "\(bu" 2
Thomas L. Shinnick <http://search.cpan.org/~tshinnic/>
.IP "\(bu" 2
Frank Leray
.SH "AUTHOR"
.IX Header "AUTHOR"
Casiano Rodriguez-Leon (casiano@ull.es)
.SH "ACKNOWLEDGMENTS"
.IX Header "ACKNOWLEDGMENTS"
This work has been supported by \s-1CEE \s0(\s-1FEDER\s0) and the Spanish Ministry of
\&\fIEducacion y Ciencia\fR through \fIPlan Nacional I+D+I\fR number \s-1TIN2005\-08818\-C04\-04
\&\s0(\s-1ULL::OPLINK\s0 project <http://www.oplink.ull.es/>). 
Support from Gobierno de Canarias was through \s-1GC02210601
\&\s0(\fIGrupos Consolidados\fR).
The University of La Laguna has also supported my work in many ways
and for many years.
.PP
A large percentage of  code is verbatim taken from Parse::Yapp 1.05.
The author of Parse::Yapp is Francois Desarmenien.
.PP
I wish to thank Francois Desarmenien for his Parse::Yapp module, 
to my students at La Laguna and to the Perl Community. Thanks to 
the people who have contributed to improve the module (see \*(L"\s-1CONTRIBUTORS\*(R"\s0 in Parse::Eyapp).
Thanks to Larry Wall for giving us Perl.
Special thanks to Juana.
.SH "LICENCE AND COPYRIGHT"
.IX Header "LICENCE AND COPYRIGHT"
Copyright (c) 2006\-2008 Casiano Rodriguez-Leon (casiano@ull.es). All rights reserved.
.PP
Parse::Yapp copyright is of Francois Desarmenien, all rights reserved. 1998\-2001
.PP
These modules are free software; you can redistribute it and/or
modify it under the same terms as Perl itself. See perlartistic.
.PP
This program is distributed in the hope that it will be useful,
but \s-1WITHOUT ANY WARRANTY\s0; without even the implied warranty of
\&\s-1MERCHANTABILITY\s0 or \s-1FITNESS FOR A PARTICULAR PURPOSE. \s0
