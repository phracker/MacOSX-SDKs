.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "XML::NamespaceSupport 3"
.TH XML::NamespaceSupport 3 "2010-03-16" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
XML::NamespaceSupport \- a simple generic namespace support class
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&  use XML::NamespaceSupport;
\&  my $nsup = XML::NamespaceSupport\->new;
\&
\&  # add a new empty context
\&  $nsup\->push_context;
\&  # declare a few prefixes
\&  $nsup\->declare_prefix($prefix1, $uri1);
\&  $nsup\->declare_prefix($prefix2, $uri2);
\&  # the same shorter
\&  $nsup\->declare_prefixes($prefix1 => $uri1, $prefix2 => $uri2);
\&
\&  # get a single prefix for a URI (randomly)
\&  $prefix = $nsup\->get_prefix($uri);
\&  # get all prefixes for a URI (probably better)
\&  @prefixes = $nsup\->get_prefixes($uri);
\&  # get all prefixes in scope
\&  @prefixes = $nsup\->get_prefixes();
\&  # get all prefixes that were declared for the current scope
\&  @prefixes = $nsup\->get_declared_prefixes;
\&  # get a URI for a given prefix
\&  $uri = $nsup\->get_uri($prefix);
\&
\&  # get info on a qname (java\-ish way, it\*(Aqs a bit weird)
\&  ($ns_uri, $local_name, $qname) = $nsup\->process_name($qname, $is_attr);
\&  # the same, more perlish
\&  ($ns_uri, $prefix, $local_name) = $nsup\->process_element_name($qname);
\&  ($ns_uri, $prefix, $local_name) = $nsup\->process_attribute_name($qname);
\&
\&  # remove the current context
\&  $nsup\->pop_context;
\&
\&  # reset the object for reuse in another document
\&  $nsup\->reset;
\&
\&  # a simple helper to process Clarkian Notation
\&  my ($ns, $lname) = $nsup\->parse_jclark_notation(\*(Aq{http://foo}bar\*(Aq);
\&  # or (given that it doesn\*(Aqt care about the object
\&  my ($ns, $lname) = XML::NamespaceSupport\->parse_jclark_notation(\*(Aq{http://foo}bar\*(Aq);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module offers a simple to process namespaced \s-1XML\s0 names (unames)
from within any application that may need them. It also helps maintain
a prefix to namespace \s-1URI\s0 map, and provides a number of basic checks.
.PP
The model for this module is \s-1SAX2\s0's NamespaceSupport class, readable at
http://www.megginson.com/SAX/Java/javadoc/org/xml/sax/helpers/NamespaceSupport.html.
It adds a few perlisations where we thought it appropriate.
.SH "METHODS"
.IX Header "METHODS"
.IP "\(bu" 4
XML::NamespaceSupport\->new(\e%options)
.Sp
A simple constructor.
.Sp
The options are \f(CW\*(C`xmlns\*(C'\fR, \f(CW\*(C`fatal_errors\*(C'\fR, and \f(CW\*(C`auto_prefix\*(C'\fR
.Sp
If \f(CW\*(C`xmlns\*(C'\fR is turned on (it is off by default) the mapping from the
xmlns prefix to the \s-1URI\s0 defined for it in \s-1DOM\s0 level 2 is added to the
list of predefined mappings (which normally only contains the xml
prefix mapping).
.Sp
If \f(CW\*(C`fatal_errors\*(C'\fR is turned off (it is on by default) a number of
validity errors will simply be flagged as failures, instead of
\&\fIdie()\fRing.
.Sp
If \f(CW\*(C`auto_prefix\*(C'\fR is turned on (it is off by default) when one
provides a prefix of \f(CW\*(C`undef\*(C'\fR to \f(CW\*(C`declare_prefix\*(C'\fR it will generate a
random prefix mapped to that namespace. Otherwise an undef prefix will
trigger a warning (you should probably know what you're doing if you
turn this option on).
.Sp
If \f(CW\*(C`xmlns_11\*(C'\fR us turned off, it becomes illegal to undeclare namespace
prefixes. It is on by default. This behaviour is compliant with Namespaces
in \s-1XML 1.1,\s0 turning it off reverts you to version 1.0.
.IP "\(bu" 4
\&\f(CW$nsup\fR\->push_context
.Sp
Adds a new empty context to the stack. You can then populate it with
new prefixes defined at this level.
.IP "\(bu" 4
\&\f(CW$nsup\fR\->pop_context
.Sp
Removes the topmost context in the stack and reverts to the previous
one. It will \fIdie()\fR if you try to pop more than you have pushed.
.IP "\(bu" 4
\&\f(CW$nsup\fR\->declare_prefix($prefix, \f(CW$uri\fR)
.Sp
Declares a mapping of \f(CW$prefix\fR to \f(CW$uri\fR, at the current level.
.Sp
Note that with \f(CW\*(C`auto_prefix\*(C'\fR turned on, if you declare a prefix
mapping in which \f(CW$prefix\fR is \fIundef()\fR, you will get an automatic prefix
selected for you. If it is off you will get a warning.
.Sp
This is useful when you deal with code that hasn't kept prefixes around
and need to reserialize the nodes. It also means that if you want to
set the default namespace (ie with an empty prefix) you must use the
empty string instead of undef. This behaviour is consistent with the
\&\s-1SAX 2.0\s0 specification.
.IP "\(bu" 4
\&\f(CW$nsup\fR\->declare_prefixes(%prefixes2uris)
.Sp
Declares a mapping of several prefixes to URIs, at the current level.
.IP "\(bu" 4
\&\f(CW$nsup\fR\->get_prefix($uri)
.Sp
Returns a prefix given an \s-1URI.\s0 Note that as several prefixes may be
mapped to the same \s-1URI,\s0 it returns an arbitrary one. It'll return
undef on failure.
.IP "\(bu" 4
\&\f(CW$nsup\fR\->get_prefixes($uri)
.Sp
Returns an array of prefixes given an \s-1URI.\s0 It'll return all the
prefixes if the uri is undef.
.IP "\(bu" 4
\&\f(CW$nsup\fR\->get_declared_prefixes
.Sp
Returns an array of all the prefixes that have been declared within
this context, ie those that were declared on the last element, not
those that were declared above and are simply in scope.
.IP "\(bu" 4
\&\f(CW$nsup\fR\->get_uri($prefix)
.Sp
Returns a \s-1URI\s0 for a given prefix. Returns undef on failure.
.IP "\(bu" 4
\&\f(CW$nsup\fR\->process_name($qname, \f(CW$is_attr\fR)
.Sp
Given a qualified name and a boolean indicating whether this is an
attribute or another type of name (those are differently affected by
default namespaces), it returns a namespace \s-1URI,\s0 local name, qualified
name tuple. I know that that is a rather abnormal list to return, but
it is so for compatibility with the Java spec. See below for more
Perlish alternatives.
.Sp
If the prefix is not declared, or if the name is not valid, it'll
either die or return undef depending on the current setting of
\&\f(CW\*(C`fatal_errors\*(C'\fR.
.IP "\(bu" 4
\&\f(CW$nsup\fR\->undeclare_prefix($prefix);
.Sp
Removes a namespace prefix from the current context. This function may
be used in \s-1SAX\s0's end_prefix_mapping when there is fear that a namespace
declaration might be available outside their scope (which shouldn't
normally happen, but you never know ;). This may be needed in order to
properly support Namespace 1.1.
.IP "\(bu" 4
\&\f(CW$nsup\fR\->process_element_name($qname)
.Sp
Given a qualified name, it returns a namespace \s-1URI,\s0 prefix, and local
name tuple. This method applies to element names.
.Sp
If the prefix is not declared, or if the name is not valid, it'll
either die or return undef depending on the current setting of
\&\f(CW\*(C`fatal_errors\*(C'\fR.
.IP "\(bu" 4
\&\f(CW$nsup\fR\->process_attribute_name($qname)
.Sp
Given a qualified name, it returns a namespace \s-1URI,\s0 prefix, and local
name tuple. This method applies to attribute names.
.Sp
If the prefix is not declared, or if the name is not valid, it'll
either die or return undef depending on the current setting of
\&\f(CW\*(C`fatal_errors\*(C'\fR.
.IP "\(bu" 4
\&\f(CW$nsup\fR\->reset
.Sp
Resets the object so that it can be reused on another document.
.PP
All methods of the interface have an alias that is the name used in
the original Java specification. You can use either name
interchangeably. Here is the mapping:
.PP
.Vb 10
\&  Java name                 Perl name
\&  \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&  pushContext               push_context
\&  popContext                pop_context
\&  declarePrefix             declare_prefix
\&  declarePrefixes           declare_prefixes
\&  getPrefix                 get_prefix
\&  getPrefixes               get_prefixes
\&  getDeclaredPrefixes       get_declared_prefixes
\&  getURI                    get_uri
\&  processName               process_name
\&  processElementName        process_element_name
\&  processAttributeName      process_attribute_name
\&  parseJClarkNotation       parse_jclark_notation
\&  undeclarePrefix           undeclare_prefix
.Ve
.SH "VARIABLES"
.IX Header "VARIABLES"
Two global variables are made available to you. They used to be constants but
simple scalars are easier to use in a number of contexts. They are not
exported but can easily be accessed from any package, or copied into it.
.IP "\(bu" 4
\&\f(CW$NS_XMLNS\fR
.Sp
The namespace for xmlns prefixes, http://www.w3.org/2000/xmlns/.
.IP "\(bu" 4
\&\f(CW$NS_XML\fR
.Sp
The namespace for xml prefixes, http://www.w3.org/XML/1998/namespace.
.SH "TODO"
.IX Header "TODO"
.Vb 2
\& \- add more tests
\& \- optimise here and there
.Ve
.SH "AUTHOR"
.IX Header "AUTHOR"
Robin Berjon, robin@knowscape.com, with lots of it having been done
by Duncan Cameron, and a number of suggestions from the perl-xml
list.
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (c) 2001\-2005 Robin Berjon. All rights reserved. This program is
free software; you can redistribute it and/or modify it under the same terms
as Perl itself.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
XML::Parser::PerlSAX
