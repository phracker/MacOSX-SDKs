.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Class::C3::Componentised 3"
.TH Class::C3::Componentised 3 "2011-08-08" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Class::C3::Componentised
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Load mix-ins or components to your C3\-based class.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  package MyModule;
\&
\&  use strict;
\&  use warnings;
\&
\&  use base \*(AqClass::C3::Componentised\*(Aq;
\&
\&  sub component_base_class { "MyModule::Component" }
\&
\&  package main;
\&
\&  MyModule\->load_components( qw/Foo Bar/ ); 
\&  # Will load MyModule::Component::Foo and MyModule::Component::Bar
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This will inject base classes to your module using the Class::C3 method
resolution order.
.PP
Please note: these are not plugins that can take precedence over methods 
declared in MyModule. If you want something like that, consider
MooseX::Object::Pluggable.
.SH "METHODS"
.IX Header "METHODS"
.ie n .SS "load_components( @comps )"
.el .SS "load_components( \f(CW@comps\fP )"
.IX Subsection "load_components( @comps )"
Loads the given components into the current module. If a module begins with a 
\&\f(CW\*(C`+\*(C'\fR character, it is taken to be a fully qualified class name, otherwise
\&\f(CW\*(C`$class\->component_base_class\*(C'\fR is prepended to it.
.PP
Calling this will call \f(CW\*(C`Class::C3::reinitialize\*(C'\fR.
.ie n .SS "load_own_components( @comps )"
.el .SS "load_own_components( \f(CW@comps\fP )"
.IX Subsection "load_own_components( @comps )"
Similar to load_components, but assumes every class is \f(CW"$class::$comp"\fR.
.SS "load_optional_components"
.IX Subsection "load_optional_components"
As load_components, but will silently ignore any components that cannot be 
found.
.SS "ensure_class_loaded"
.IX Subsection "ensure_class_loaded"
Given a class name, tests to see if it is already loaded or otherwise
defined. If it is not yet loaded, the package is require'd, and an exception
is thrown if the class is still not loaded.
.PP
.Vb 2
\& BUG: For some reason, packages with syntax errors are added to %INC on
\&      require
.Ve
.SS "ensure_class_found"
.IX Subsection "ensure_class_found"
Returns true if the specified class is installed or already loaded, false
otherwise.
.PP
Note that the underlying mechanism (Class::Inspector\->\fIinstalled()\fR) used by this
sub will not, at the time of writing, correctly function when \f(CW@INC\fR includes
coderefs. Since \s-1PAR\s0 relies upon coderefs in \f(CW@INC\fR, this function should be
avoided in modules that are likely to be included within a \s-1PAR.\s0
.SS "inject_base"
.IX Subsection "inject_base"
Does the actual magic of adjusting \f(CW@ISA\fR on the target module.
.SS "load_optional_class"
.IX Subsection "load_optional_class"
Returns a true value if the specified class is installed and loaded
successfully, throws an exception if the class is found but not loaded
successfully, and false if the class is not installed
.SH "AUTHORS"
.IX Header "AUTHORS"
Matt S. Trout and the DBIx::Class team
.PP
Pulled out into seperate module by Ash Berlin \f(CW\*(C`<ash@cpan.org>\*(C'\fR
.PP
Optimizations and overall bolt-tightening by Peter \*(L"ribasushi\*(R" Rabbitson
\&\f(CW\*(C`<ribasushi@cpan.org>\*(C'\fR
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (c) 2006 \- 2011 the Class::C3::Componentised \*(L"\s-1AUTHORS\*(R"\s0 as listed
above.
.SH "LICENSE"
.IX Header "LICENSE"
You may distribute this code under the same terms as Perl itself.
