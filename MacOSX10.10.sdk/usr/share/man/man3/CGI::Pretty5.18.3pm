.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "CGI::Pretty 3pm"
.TH CGI::Pretty 3pm "2014-01-06" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
CGI::Pretty \- module to produce nicely formatted HTML code
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use CGI::Pretty qw( :html3 );
\&
\&    # Print a table with a single data element
\&    print table( TR( td( "foo" ) ) );
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
CGI::Pretty is a module that derives from \s-1CGI. \s0 It's sole function is to
allow users of \s-1CGI\s0 to output nicely formatted \s-1HTML\s0 code.
.PP
When using the \s-1CGI\s0 module, the following code:
    print table( \s-1TR\s0( td( \*(L"foo\*(R" ) ) );
.PP
produces the following output:
    <\s-1TABLE\s0><\s-1TR\s0><\s-1TD\s0>foo</TD></TR></TABLE>
.PP
If a user were to create a table consisting of many rows and many columns,
the resultant \s-1HTML\s0 code would be quite difficult to read since it has no
carriage returns or indentation.
.PP
CGI::Pretty fixes this problem.  What it does is add a carriage
return and indentation to the \s-1HTML\s0 code so that one can easily read
it.
.PP
.Vb 1
\&    print table( TR( td( "foo" ) ) );
.Ve
.PP
now produces the following output:
    <\s-1TABLE\s0>
       <\s-1TR\s0>
          <\s-1TD\s0>foo</TD>
       </TR>
    </TABLE>
.SS "Recommendation for when to use CGI::Pretty"
.IX Subsection "Recommendation for when to use CGI::Pretty"
CGI::Pretty is far slower than using \s-1CGI\s0.pm directly. A benchmark showed that
it could be about 10 times slower. Adding newlines and spaces may alter the
rendered appearance of \s-1HTML.\s0 Also, the extra newlines and spaces also make the
file size larger, making the files take longer to download.
.PP
With all those considerations, it is recommended that CGI::Pretty be used
primarily for debugging.
.SS "Tags that won't be formatted"
.IX Subsection "Tags that won't be formatted"
The following tags are not formatted: <a>, <pre>, <code>, <script>, <textarea>, and <td>.
If these tags were formatted, the
user would see the extra indentation on the web browser causing the page to
look different than what would be expected.  If you wish to add more tags to
the list of tags that are not to be touched, push them onto the \f(CW@AS_IS\fR array:
.PP
.Vb 1
\&    push @CGI::Pretty::AS_IS,qw(XMP);
.Ve
.SS "Customizing the Indenting"
.IX Subsection "Customizing the Indenting"
If you wish to have your own personal style of indenting, you can change the
\&\f(CW$INDENT\fR variable:
.PP
.Vb 1
\&    $CGI::Pretty::INDENT = "\et\et";
.Ve
.PP
would cause the indents to be two tabs.
.PP
Similarly, if you wish to have more space between lines, you may change the
\&\f(CW$LINEBREAK\fR variable:
.PP
.Vb 1
\&    $CGI::Pretty::LINEBREAK = "\en\en";
.Ve
.PP
would create two carriage returns between lines.
.PP
If you decide you want to use the regular \s-1CGI\s0 indenting, you can easily do 
the following:
.PP
.Vb 1
\&    $CGI::Pretty::INDENT = $CGI::Pretty::LINEBREAK = "";
.Ve
.SH "AUTHOR"
.IX Header "AUTHOR"
Brian Paulsen <Brian@ThePaulsens.com>, with minor modifications by
Lincoln Stein <lstein@cshl.org> for incorporation into the \s-1CGI\s0.pm
distribution.
.PP
Copyright 1999, Brian Paulsen.  All rights reserved.
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.
.PP
Bug reports and comments to Brian@ThePaulsens.com.  You can also write
to lstein@cshl.org, but this code looks pretty hairy to me and I'm not
sure I understand it!
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\s-1CGI\s0
