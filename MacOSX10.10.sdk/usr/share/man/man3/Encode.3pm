.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Encode 3pm"
.TH Encode 3pm "2014-01-06" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Encode \- character encodings in Perl
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 3
\&    use Encode qw(decode encode);
\&    $characters = decode(\*(AqUTF\-8\*(Aq, $octets,     Encode::FB_CROAK);
\&    $octets     = encode(\*(AqUTF\-8\*(Aq, $characters, Encode::FB_CROAK);
.Ve
.SS "Table of Contents"
.IX Subsection "Table of Contents"
Encode consists of a collection of modules whose details are too extensive
to fit in one document.  This one itself explains the top-level APIs
and general topics at a glance.  For other topics and more details,
see the documentation for these modules:
.IP "Encode::Alias \- Alias definitions to encodings" 2
.IX Item "Encode::Alias - Alias definitions to encodings"
.PD 0
.IP "Encode::Encoding \- Encode Implementation Base Class" 2
.IX Item "Encode::Encoding - Encode Implementation Base Class"
.IP "Encode::Supported \- List of Supported Encodings" 2
.IX Item "Encode::Supported - List of Supported Encodings"
.IP "Encode::CN \- Simplified Chinese Encodings" 2
.IX Item "Encode::CN - Simplified Chinese Encodings"
.IP "Encode::JP \- Japanese Encodings" 2
.IX Item "Encode::JP - Japanese Encodings"
.IP "Encode::KR \- Korean Encodings" 2
.IX Item "Encode::KR - Korean Encodings"
.IP "Encode::TW \- Traditional Chinese Encodings" 2
.IX Item "Encode::TW - Traditional Chinese Encodings"
.PD
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The \f(CW\*(C`Encode\*(C'\fR module provides the interface between Perl strings
and the rest of the system.  Perl strings are sequences of
\&\fIcharacters\fR.
.PP
The repertoire of characters that Perl can represent is a superset of those
defined by the Unicode Consortium. On most platforms the ordinal
values of a character as returned by \f(CW\*(C`ord(\f(CIS\f(CW)\*(C'\fR is the \fIUnicode
codepoint\fR for that character. The exceptions are platforms where
the legacy encoding is some variant of \s-1EBCDIC\s0 rather than a superset
of \s-1ASCII\s0; see perlebcdic.
.PP
During recent history, data is moved around a computer in 8\-bit chunks,
often called \*(L"bytes\*(R" but also known as \*(L"octets\*(R" in standards documents.
Perl is widely used to manipulate data of many types: not only strings of
characters representing human or computer languages, but also \*(L"binary\*(R"
data, being the machine's representation of numbers, pixels in an image, or
just about anything.
.PP
When Perl is processing \*(L"binary data\*(R", the programmer wants Perl to
process \*(L"sequences of bytes\*(R". This is not a problem for Perl: because a
byte has 256 possible values, it easily fits in Perl's much larger
\&\*(L"logical character\*(R".
.PP
This document mostly explains the \fIhow\fR. perlunitut and perlunifaq
explain the \fIwhy\fR.
.SS "\s-1TERMINOLOGY\s0"
.IX Subsection "TERMINOLOGY"
\fIcharacter\fR
.IX Subsection "character"
.PP
A character in the range 0 .. 2**32\-1 (or more);
what Perl's strings are made of.
.PP
\fIbyte\fR
.IX Subsection "byte"
.PP
A character in the range 0..255;
a special case of a Perl character.
.PP
\fIoctet\fR
.IX Subsection "octet"
.PP
8 bits of data, with ordinal values 0..255;
term for bytes passed to or from a non-Perl context, such as a disk file,
standard I/O stream, database, command-line argument, environment variable,
socket etc.
.SH "THE PERL ENCODING API"
.IX Header "THE PERL ENCODING API"
.SS "Basic methods"
.IX Subsection "Basic methods"
\fIencode\fR
.IX Subsection "encode"
.PP
.Vb 1
\&  $octets  = encode(ENCODING, STRING[, CHECK])
.Ve
.PP
Encodes the scalar value \fI\s-1STRING\s0\fR from Perl's internal form into
\&\fI\s-1ENCODING\s0\fR and returns a sequence of octets.  \fI\s-1ENCODING\s0\fR can be either a
canonical name or an alias.  For encoding names and aliases, see
\&\*(L"Defining Aliases\*(R".  For \s-1CHECK,\s0 see \*(L"Handling Malformed Data\*(R".
.PP
For example, to convert a string from Perl's internal format into
\&\s-1ISO\-8859\-1,\s0 also known as Latin1:
.PP
.Vb 1
\&  $octets = encode("iso\-8859\-1", $string);
.Ve
.PP
\&\fB\s-1CAVEAT\s0\fR: When you run \f(CW\*(C`$octets = encode("utf8", $string)\*(C'\fR, then
\&\f(CW$octets\fR \fImight not be equal to\fR \f(CW$string\fR.  Though both contain the
same data, the \s-1UTF8\s0 flag for \f(CW$octets\fR is \fIalways\fR off.  When you
encode anything, the \s-1UTF8\s0 flag on the result is always off, even when it
contains a completely valid utf8 string. See \*(L"The \s-1UTF8\s0 flag\*(R" below.
.PP
If the \f(CW$string\fR is \f(CW\*(C`undef\*(C'\fR, then \f(CW\*(C`undef\*(C'\fR is returned.
.PP
\fIdecode\fR
.IX Subsection "decode"
.PP
.Vb 1
\&  $string = decode(ENCODING, OCTETS[, CHECK])
.Ve
.PP
This function returns the string that results from decoding the scalar
value \fI\s-1OCTETS\s0\fR, assumed to be a sequence of octets in \fI\s-1ENCODING\s0\fR, into
Perl's internal form.  The returns the resulting string.  As with \fIencode()\fR,
\&\fI\s-1ENCODING\s0\fR can be either a canonical name or an alias. For encoding names
and aliases, see \*(L"Defining Aliases\*(R"; for \fI\s-1CHECK\s0\fR, see \*(L"Handling
Malformed Data\*(R".
.PP
For example, to convert \s-1ISO\-8859\-1\s0 data into a string in Perl's
internal format:
.PP
.Vb 1
\&  $string = decode("iso\-8859\-1", $octets);
.Ve
.PP
\&\fB\s-1CAVEAT\s0\fR: When you run \f(CW\*(C`$string = decode("utf8", $octets)\*(C'\fR, then \f(CW$string\fR
\&\fImight not be equal to\fR \f(CW$octets\fR.  Though both contain the same data, the
\&\s-1UTF8\s0 flag for \f(CW$string\fR is on unless \f(CW$octets\fR consists entirely of \s-1ASCII\s0 data
on \s-1ASCII\s0 machines or \s-1EBCDIC\s0 on \s-1EBCDIC\s0 machines.  See \*(L"The \s-1UTF8\s0 flag\*(R"
below.
.PP
If the \f(CW$string\fR is \f(CW\*(C`undef\*(C'\fR, then \f(CW\*(C`undef\*(C'\fR is returned.
.PP
\fIfind_encoding\fR
.IX Subsection "find_encoding"
.PP
.Vb 1
\&  [$obj =] find_encoding(ENCODING)
.Ve
.PP
Returns the \fIencoding object\fR corresponding to \fI\s-1ENCODING\s0\fR.  Returns
\&\f(CW\*(C`undef\*(C'\fR if no matching \fI\s-1ENCODING\s0\fR is find.  The returned object is
what does the actual encoding or decoding.
.PP
.Vb 1
\&  $utf8 = decode($name, $bytes);
.Ve
.PP
is in fact
.PP
.Vb 5
\&    $utf8 = do {
\&        $obj = find_encoding($name);
\&        croak qq(encoding "$name" not found) unless ref $obj;
\&        $obj\->decode($bytes);
\&    };
.Ve
.PP
with more error checking.
.PP
You can therefore save time by reusing this object as follows;
.PP
.Vb 5
\&    my $enc = find_encoding("iso\-8859\-1");
\&    while(<>) {
\&        my $utf8 = $enc\->decode($_);
\&        ... # now do something with $utf8;
\&    }
.Ve
.PP
Besides \*(L"decode\*(R" and \*(L"encode\*(R", other methods are
available as well.  For instance, \f(CW\*(C`name()\*(C'\fR returns the canonical
name of the encoding object.
.PP
.Vb 1
\&  find_encoding("latin1")\->name; # iso\-8859\-1
.Ve
.PP
See Encode::Encoding for details.
.PP
\fIfrom_to\fR
.IX Subsection "from_to"
.PP
.Vb 1
\&  [$length =] from_to($octets, FROM_ENC, TO_ENC [, CHECK])
.Ve
.PP
Converts \fIin-place\fR data between two encodings. The data in \f(CW$octets\fR
must be encoded as octets and \fInot\fR as characters in Perl's internal
format. For example, to convert \s-1ISO\-8859\-1\s0 data into Microsoft's \s-1CP1250\s0
encoding:
.PP
.Vb 1
\&  from_to($octets, "iso\-8859\-1", "cp1250");
.Ve
.PP
and to convert it back:
.PP
.Vb 1
\&  from_to($octets, "cp1250", "iso\-8859\-1");
.Ve
.PP
Because the conversion happens in place, the data to be
converted cannot be a string constant: it must be a scalar variable.
.PP
\&\f(CW\*(C`from_to()\*(C'\fR returns the length of the converted string in octets on success,
and \f(CW\*(C`undef\*(C'\fR on error.
.PP
\&\fB\s-1CAVEAT\s0\fR: The following operations may look the same, but are not:
.PP
.Vb 2
\&  from_to($data, "iso\-8859\-1", "utf8"); #1
\&  $data = decode("iso\-8859\-1", $data);  #2
.Ve
.PP
Both #1 and #2 make \f(CW$data\fR consist of a completely valid \s-1UTF\-8\s0 string,
but only #2 turns the \s-1UTF8\s0 flag on.  #1 is equivalent to:
.PP
.Vb 1
\&  $data = encode("utf8", decode("iso\-8859\-1", $data));
.Ve
.PP
See \*(L"The \s-1UTF8\s0 flag\*(R" below.
.PP
Also note that:
.PP
.Vb 1
\&  from_to($octets, $from, $to, $check);
.Ve
.PP
is equivalent t:o
.PP
.Vb 1
\&  $octets = encode($to, decode($from, $octets), $check);
.Ve
.PP
Yes, it does \fInot\fR respect the \f(CW$check\fR during decoding.  It is
deliberately done that way.  If you need minute control, use \f(CW\*(C`decode\*(C'\fR
followed by \f(CW\*(C`encode\*(C'\fR as follows:
.PP
.Vb 1
\&  $octets = encode($to, decode($from, $octets, $check_from), $check_to);
.Ve
.PP
\fIencode_utf8\fR
.IX Subsection "encode_utf8"
.PP
.Vb 1
\&  $octets = encode_utf8($string);
.Ve
.PP
Equivalent to \f(CW\*(C`$octets = encode("utf8", $string)\*(C'\fR.  The characters in
\&\f(CW$string\fR are encoded in Perl's internal format, and the result is returned
as a sequence of octets.  Because all possible characters in Perl have a
(loose, not strict) \s-1UTF\-8\s0 representation, this function cannot fail.
.PP
\fIdecode_utf8\fR
.IX Subsection "decode_utf8"
.PP
.Vb 1
\&  $string = decode_utf8($octets [, CHECK]);
.Ve
.PP
Equivalent to \f(CW\*(C`$string = decode("utf8", $octets [, CHECK])\*(C'\fR.
The sequence of octets represented by \f(CW$octets\fR is decoded
from \s-1UTF\-8\s0 into a sequence of logical characters.
Because not all sequences of octets are valid \s-1UTF\-8,\s0
it is quite possible for this function to fail.
For \s-1CHECK,\s0 see \*(L"Handling Malformed Data\*(R".
.SS "Listing available encodings"
.IX Subsection "Listing available encodings"
.Vb 2
\&  use Encode;
\&  @list = Encode\->encodings();
.Ve
.PP
Returns a list of canonical names of available encodings that have already
been loaded.  To get a list of all available encodings including those that
have not yet been loaded, say:
.PP
.Vb 1
\&  @all_encodings = Encode\->encodings(":all");
.Ve
.PP
Or you can give the name of a specific module:
.PP
.Vb 1
\&  @with_jp = Encode\->encodings("Encode::JP");
.Ve
.PP
When "\f(CW\*(C`::\*(C'\fR\*(L" is not in the name, \*(R"\f(CW\*(C`Encode::\*(C'\fR" is assumed.
.PP
.Vb 1
\&  @ebcdic = Encode\->encodings("EBCDIC");
.Ve
.PP
To find out in detail which encodings are supported by this package,
see Encode::Supported.
.SS "Defining Aliases"
.IX Subsection "Defining Aliases"
To add a new alias to a given encoding, use:
.PP
.Vb 3
\&  use Encode;
\&  use Encode::Alias;
\&  define_alias(NEWNAME => ENCODING);
.Ve
.PP
After that, \fI\s-1NEWNAME\s0\fR can be used as an alias for \fI\s-1ENCODING\s0\fR.
\&\fI\s-1ENCODING\s0\fR may be either the name of an encoding or an
\&\fIencoding object\fR.
.PP
Before you do that, first make sure the alias is nonexistent using
\&\f(CW\*(C`resolve_alias()\*(C'\fR, which returns the canonical name thereof.
For example:
.PP
.Vb 3
\&  Encode::resolve_alias("latin1") eq "iso\-8859\-1" # true
\&  Encode::resolve_alias("iso\-8859\-12")   # false; nonexistent
\&  Encode::resolve_alias($name) eq $name  # true if $name is canonical
.Ve
.PP
\&\f(CW\*(C`resolve_alias()\*(C'\fR does not need \f(CW\*(C`use Encode::Alias\*(C'\fR; it can be
imported via \f(CW\*(C`use Encode qw(resolve_alias)\*(C'\fR.
.PP
See Encode::Alias for details.
.SS "Finding \s-1IANA\s0 Character Set Registry names"
.IX Subsection "Finding IANA Character Set Registry names"
The canonical name of a given encoding does not necessarily agree with
\&\s-1IANA\s0 Character Set Registry, commonly seen as \f(CW\*(C`Content\-Type:
text/plain; charset=\f(CIWHATEVER\f(CW\*(C'\fR.  For most cases, the canonical name
works, but sometimes it does not, most notably with \*(L"utf\-8\-strict\*(R".
.PP
As of \f(CW\*(C`Encode\*(C'\fR version 2.21, a new method \f(CW\*(C`mime_name()\*(C'\fR is therefore added.
.PP
.Vb 4
\&  use Encode;
\&  my $enc = find_encoding("UTF\-8");
\&  warn $enc\->name;      # utf\-8\-strict
\&  warn $enc\->mime_name; # UTF\-8
.Ve
.PP
See also:  Encode::Encoding
.SH "Encoding via PerlIO"
.IX Header "Encoding via PerlIO"
If your perl supports \f(CW\*(C`PerlIO\*(C'\fR (which is the default), you can use a
\&\f(CW\*(C`PerlIO\*(C'\fR layer to decode and encode directly via a filehandle.  The
following two examples are fully identical in functionality:
.PP
.Vb 10
\&  ### Version 1 via PerlIO
\&    open(INPUT,  "< :encoding(shiftjis)", $infile)
\&        || die "Can\*(Aqt open < $infile for reading: $!";
\&    open(OUTPUT, "> :encoding(euc\-jp)",  $outfile)
\&        || die "Can\*(Aqt open > $output for writing: $!";
\&    while (<INPUT>) {   # auto decodes $_
\&        print OUTPUT;   # auto encodes $_
\&    }
\&    close(INPUT)   || die "can\*(Aqt close $infile: $!";
\&    close(OUTPUT)  || die "can\*(Aqt close $outfile: $!";
\&
\&  ### Version 2 via from_to()
\&    open(INPUT,  "< :raw", $infile)
\&        || die "Can\*(Aqt open < $infile for reading: $!";
\&    open(OUTPUT, "> :raw",  $outfile)
\&        || die "Can\*(Aqt open > $output for writing: $!";
\&
\&    while (<INPUT>) {
\&        from_to($_, "shiftjis", "euc\-jp", 1);  # switch encoding
\&        print OUTPUT;   # emit raw (but properly encoded) data
\&    }
\&    close(INPUT)   || die "can\*(Aqt close $infile: $!";
\&    close(OUTPUT)  || die "can\*(Aqt close $outfile: $!";
.Ve
.PP
In the first version above, you let the appropriate encoding layer
handle the conversion.  In the second, you explicitly translate
from one encoding to the other.
.PP
Unfortunately, it may be that encodings are \f(CW\*(C`PerlIO\*(C'\fR\-savvy.  You can check
to see whether your encoding is supported by \f(CW\*(C`PerlIO\*(C'\fR by invoking the
\&\f(CW\*(C`perlio_ok\*(C'\fR method on it:
.PP
.Vb 2
\&  Encode::perlio_ok("hz");             # false
\&  find_encoding("euc\-cn")\->perlio_ok;  # true wherever PerlIO is available
\&
\&  use Encode qw(perlio_ok);            # imported upon request
\&  perlio_ok("euc\-jp")
.Ve
.PP
Fortunately, all encodings that come with \f(CW\*(C`Encode\*(C'\fR core are \f(CW\*(C`PerlIO\*(C'\fR\-savvy
except for \f(CW\*(C`hz\*(C'\fR and \f(CW\*(C`ISO\-2022\-kr\*(C'\fR.  For the gory details, see
Encode::Encoding and Encode::PerlIO.
.SH "Handling Malformed Data"
.IX Header "Handling Malformed Data"
The optional \fI\s-1CHECK\s0\fR argument tells \f(CW\*(C`Encode\*(C'\fR what to do when
encountering malformed data.  Without \fI\s-1CHECK\s0\fR, \f(CW\*(C`Encode::FB_DEFAULT\*(C'\fR
(== 0) is assumed.
.PP
As of version 2.12, \f(CW\*(C`Encode\*(C'\fR supports coderef values for \f(CW\*(C`CHECK\*(C'\fR;
see below.
.PP
\&\fB\s-1NOTE:\s0\fR Not all encodings support this feature.
Some encodings ignore the \fI\s-1CHECK\s0\fR argument.  For example,
Encode::Unicode ignores \fI\s-1CHECK\s0\fR and it always croaks on error.
.SS "List of \fI\s-1CHECK\s0\fP values"
.IX Subsection "List of CHECK values"
\fI\s-1FB_DEFAULT\s0\fR
.IX Subsection "FB_DEFAULT"
.PP
.Vb 1
\&  I<CHECK> = Encode::FB_DEFAULT ( == 0)
.Ve
.PP
If \fI\s-1CHECK\s0\fR is 0, encoding and decoding replace any malformed character
with a \fIsubstitution character\fR.  When you encode, \fI\s-1SUBCHAR\s0\fR is used.
When you decode, the Unicode \s-1REPLACEMENT CHARACTER,\s0 code point U+FFFD, is
used.  If the data is supposed to be \s-1UTF\-8,\s0 an optional lexical warning of
warning category \f(CW"utf8"\fR is given.
.PP
\fI\s-1FB_CROAK\s0\fR
.IX Subsection "FB_CROAK"
.PP
.Vb 1
\&  I<CHECK> = Encode::FB_CROAK ( == 1)
.Ve
.PP
If \fI\s-1CHECK\s0\fR is 1, methods immediately die with an error
message.  Therefore, when \fI\s-1CHECK\s0\fR is 1, you should trap
exceptions with \f(CW\*(C`eval{}\*(C'\fR, unless you really want to let it \f(CW\*(C`die\*(C'\fR.
.PP
\fI\s-1FB_QUIET\s0\fR
.IX Subsection "FB_QUIET"
.PP
.Vb 1
\&  I<CHECK> = Encode::FB_QUIET
.Ve
.PP
If \fI\s-1CHECK\s0\fR is set to \f(CW\*(C`Encode::FB_QUIET\*(C'\fR, encoding and decoding immediately
return the portion of the data that has been processed so far when an
error occurs. The data argument is overwritten with everything
after that point; that is, the unprocessed portion of the data.  This is
handy when you have to call \f(CW\*(C`decode\*(C'\fR repeatedly in the case where your
source data may contain partial multi-byte character sequences,
(that is, you are reading with a fixed-width buffer). Here's some sample
code to do exactly that:
.PP
.Vb 5
\&    my($buffer, $string) = ("", "");
\&    while (read($fh, $buffer, 256, length($buffer))) {
\&        $string .= decode($encoding, $buffer, Encode::FB_QUIET);
\&        # $buffer now contains the unprocessed partial character
\&    }
.Ve
.PP
\fI\s-1FB_WARN\s0\fR
.IX Subsection "FB_WARN"
.PP
.Vb 1
\&  I<CHECK> = Encode::FB_WARN
.Ve
.PP
This is the same as \f(CW\*(C`FB_QUIET\*(C'\fR above, except that instead of being silent
on errors, it issues a warning.  This is handy for when you are debugging.
.PP
\fI\s-1FB_PERLQQ FB_HTMLCREF FB_XMLCREF\s0\fR
.IX Subsection "FB_PERLQQ FB_HTMLCREF FB_XMLCREF"
.IP "perlqq mode (\fI\s-1CHECK\s0\fR = Encode::FB_PERLQQ)" 2
.IX Item "perlqq mode (CHECK = Encode::FB_PERLQQ)"
.PD 0
.IP "\s-1HTML\s0 charref mode (\fI\s-1CHECK\s0\fR = Encode::FB_HTMLCREF)" 2
.IX Item "HTML charref mode (CHECK = Encode::FB_HTMLCREF)"
.IP "\s-1XML\s0 charref mode (\fI\s-1CHECK\s0\fR = Encode::FB_XMLCREF)" 2
.IX Item "XML charref mode (CHECK = Encode::FB_XMLCREF)"
.PD
.PP
For encodings that are implemented by the \f(CW\*(C`Encode::XS\*(C'\fR module, \f(CW\*(C`CHECK\*(C'\fR \f(CW\*(C`==\*(C'\fR
\&\f(CW\*(C`Encode::FB_PERLQQ\*(C'\fR puts \f(CW\*(C`encode\*(C'\fR and \f(CW\*(C`decode\*(C'\fR into \f(CW\*(C`perlqq\*(C'\fR fallback mode.
.PP
When you decode, \f(CW\*(C`\ex\f(CIHH\f(CW\*(C'\fR is inserted for a malformed character, where
\&\fI\s-1HH\s0\fR is the hex representation of the octet that could not be decoded to
utf8.  When you encode, \f(CW\*(C`\ex{\f(CIHHHH\f(CW}\*(C'\fR will be inserted, where \fI\s-1HHHH\s0\fR is
the Unicode code point (in any number of hex digits) of the character that
cannot be found in the character repertoire of the encoding.
.PP
The \s-1HTML/XML\s0 character reference modes are about the same. In place of
\&\f(CW\*(C`\ex{\f(CIHHHH\f(CW}\*(C'\fR, \s-1HTML\s0 uses \f(CW\*(C`&#\f(CINNN\f(CW;\*(C'\fR where \fI\s-1NNN\s0\fR is a decimal number, and
\&\s-1XML\s0 uses \f(CW\*(C`&#x\f(CIHHHH\f(CW;\*(C'\fR where \fI\s-1HHHH\s0\fR is the hexadecimal number.
.PP
In \f(CW\*(C`Encode\*(C'\fR 2.10 or later, \f(CW\*(C`LEAVE_SRC\*(C'\fR is also implied.
.PP
\fIThe bitmask\fR
.IX Subsection "The bitmask"
.PP
These modes are all actually set via a bitmask.  Here is how the \f(CW\*(C`FB_\f(CIXXX\f(CW\*(C'\fR
constants are laid out.  You can import the \f(CW\*(C`FB_\f(CIXXX\f(CW\*(C'\fR constants via
\&\f(CW\*(C`use Encode qw(:fallbacks)\*(C'\fR, and you can import the generic bitmask
constants via \f(CW\*(C`use Encode qw(:fallback_all)\*(C'\fR.
.PP
.Vb 8
\&                     FB_DEFAULT FB_CROAK FB_QUIET FB_WARN  FB_PERLQQ
\& DIE_ON_ERR    0x0001             X
\& WARN_ON_ERR   0x0002                               X
\& RETURN_ON_ERR 0x0004                      X        X
\& LEAVE_SRC     0x0008                                        X
\& PERLQQ        0x0100                                        X
\& HTMLCREF      0x0200
\& XMLCREF       0x0400
.Ve
.PP
\fI\s-1LEAVE_SRC\s0\fR
.IX Subsection "LEAVE_SRC"
.PP
.Vb 1
\&  Encode::LEAVE_SRC
.Ve
.PP
If the \f(CW\*(C`Encode::LEAVE_SRC\*(C'\fR bit is \fInot\fR set but \fI\s-1CHECK\s0\fR is set, then the
source string to \fIencode()\fR or \fIdecode()\fR will be overwritten in place.
If you're not interested in this, then bitwise-OR it with the bitmask.
.SS "coderef for \s-1CHECK\s0"
.IX Subsection "coderef for CHECK"
As of \f(CW\*(C`Encode\*(C'\fR 2.12, \f(CW\*(C`CHECK\*(C'\fR can also be a code reference which takes the
ordinal value of the unmapped character as an argument and returns a string
that represents the fallback character.  For instance:
.PP
.Vb 1
\&  $ascii = encode("ascii", $utf8, sub{ sprintf "<U+%04X>", shift });
.Ve
.PP
Acts like \f(CW\*(C`FB_PERLQQ\*(C'\fR but U+\fI\s-1XXXX\s0\fR is used instead of \f(CW\*(C`\ex{\f(CIXXXX\f(CW}\*(C'\fR.
.SH "Defining Encodings"
.IX Header "Defining Encodings"
To define a new encoding, use:
.PP
.Vb 2
\&    use Encode qw(define_encoding);
\&    define_encoding($object, CANONICAL_NAME [, alias...]);
.Ve
.PP
\&\fI\s-1CANONICAL_NAME\s0\fR will be associated with \fI\f(CI$object\fI\fR.  The object
should provide the interface described in Encode::Encoding.
If more than two arguments are provided, additional
arguments are considered aliases for \fI\f(CI$object\fI\fR.
.PP
See Encode::Encoding for details.
.SH "The UTF8 flag"
.IX Header "The UTF8 flag"
Before the introduction of Unicode support in Perl, The \f(CW\*(C`eq\*(C'\fR operator
just compared the strings represented by two scalars. Beginning with
Perl 5.8, \f(CW\*(C`eq\*(C'\fR compares two strings with simultaneous consideration of
\&\fIthe \s-1UTF8\s0 flag\fR. To explain why we made it so, I quote from page 402 of
\&\fIProgramming Perl, 3rd ed.\fR
.IP "Goal #1:" 2
.IX Item "Goal #1:"
Old byte-oriented programs should not spontaneously break on the old
byte-oriented data they used to work on.
.IP "Goal #2:" 2
.IX Item "Goal #2:"
Old byte-oriented programs should magically start working on the new
character-oriented data when appropriate.
.IP "Goal #3:" 2
.IX Item "Goal #3:"
Programs should run just as fast in the new character-oriented mode
as in the old byte-oriented mode.
.IP "Goal #4:" 2
.IX Item "Goal #4:"
Perl should remain one language, rather than forking into a
byte-oriented Perl and a character-oriented Perl.
.PP
When \fIProgramming Perl, 3rd ed.\fR was written, not even Perl 5.6.0 had been
born yet, many features documented in the book remained unimplemented for a
long time.  Perl 5.8 corrected much of this, and the introduction of the
\&\s-1UTF8\s0 flag is one of them.  You can think of there being two fundamentally
different kinds of strings and string-operations in Perl: one a
byte-oriented mode  for when the internal \s-1UTF8\s0 flag is off, and the other a
character-oriented mode for when the internal \s-1UTF8\s0 flag is on.
.PP
Here is how \f(CW\*(C`Encode\*(C'\fR handles the \s-1UTF8\s0 flag.
.IP "\(bu" 2
When you \fIencode\fR, the resulting \s-1UTF8\s0 flag is always \fBoff\fR.
.IP "\(bu" 2
When you \fIdecode\fR, the resulting \s-1UTF8\s0 flag is \fBon\fR\-\-\fIunless\fR you can
unambiguously represent data.  Here is what we mean by \*(L"unambiguously\*(R".
After \f(CW\*(C`$utf8 = decode("foo", $octet)\*(C'\fR,
.Sp
.Vb 6
\&  When $octet is...   The UTF8 flag in $utf8 is
\&  \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&  In ASCII only (or EBCDIC only)            OFF
\&  In ISO\-8859\-1                              ON
\&  In any other Encoding                      ON
\&  \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
.Ve
.Sp
As you see, there is one exception: in \s-1ASCII. \s0 That way you can assume
Goal #1.  And with \f(CW\*(C`Encode\*(C'\fR, Goal #2 is assumed but you still have to be
careful in the cases mentioned in the \fB\s-1CAVEAT\s0\fR paragraphs above.
.Sp
This \s-1UTF8\s0 flag is not visible in Perl scripts, exactly for the same reason
you cannot (or rather, you \fIdon't have to\fR) see whether a scalar contains
a string, an integer, or a floating-point number.   But you can still peek
and poke these if you will.  See the next section.
.SS "Messing with Perl's Internals"
.IX Subsection "Messing with Perl's Internals"
The following \s-1API\s0 uses parts of Perl's internals in the current
implementation.  As such, they are efficient but may change in a future
release.
.PP
\fIis_utf8\fR
.IX Subsection "is_utf8"
.PP
.Vb 1
\&  is_utf8(STRING [, CHECK])
.Ve
.PP
[\s-1INTERNAL\s0] Tests whether the \s-1UTF8\s0 flag is turned on in the \fI\s-1STRING\s0\fR.
If \fI\s-1CHECK\s0\fR is true, also checks whether \fI\s-1STRING\s0\fR contains well-formed
\&\s-1UTF\-8. \s0 Returns true if successful, false otherwise.
.PP
As of Perl 5.8.1, utf8 also has the \f(CW\*(C`utf8::is_utf8\*(C'\fR function.
.PP
\fI_utf8_on\fR
.IX Subsection "_utf8_on"
.PP
.Vb 1
\&  _utf8_on(STRING)
.Ve
.PP
[\s-1INTERNAL\s0] Turns the \fI\s-1STRING\s0\fR's internal \s-1UTF8\s0 flag \fBon\fR.  The \fI\s-1STRING\s0\fR
is \fInot\fR checked for containing only well-formed \s-1UTF\-8. \s0 Do not use this
unless you \fIknow with absolute certainty\fR that the \s-1STRING\s0 holds only
well-formed \s-1UTF\-8. \s0 Returns the previous state of the \s-1UTF8\s0 flag (so please
don't treat the return value as indicating success or failure), or \f(CW\*(C`undef\*(C'\fR
if \fI\s-1STRING\s0\fR is not a string.
.PP
\&\fB\s-1NOTE\s0\fR: For security reasons, this function does not work on tainted values.
.PP
\fI_utf8_off\fR
.IX Subsection "_utf8_off"
.PP
.Vb 1
\&  _utf8_off(STRING)
.Ve
.PP
[\s-1INTERNAL\s0] Turns the \fI\s-1STRING\s0\fR's internal \s-1UTF8\s0 flag \fBoff\fR.  Do not use
frivolously.  Returns the previous state of the \s-1UTF8\s0 flag, or \f(CW\*(C`undef\*(C'\fR if
\&\fI\s-1STRING\s0\fR is not a string.  Do not treat the return value as indicative of
success or failure, because that isn't what it means: it is only the
previous setting.
.PP
\&\fB\s-1NOTE\s0\fR: For security reasons, this function does not work on tainted values.
.SH "UTF\-8 vs. utf8 vs. UTF8"
.IX Header "UTF-8 vs. utf8 vs. UTF8"
.Vb 3
\&  ....We now view strings not as sequences of bytes, but as sequences
\&  of numbers in the range 0 .. 2**32\-1 (or in the case of 64\-bit
\&  computers, 0 .. 2**64\-1) \-\- Programming Perl, 3rd ed.
.Ve
.PP
That has historically been Perl's notion of \s-1UTF\-8,\s0 as that is how \s-1UTF\-8\s0 was
first conceived by Ken Thompson when he invented it. However, thanks to
later revisions to the applicable standards, official \s-1UTF\-8\s0 is now rather
stricter than that. For example, its range is much narrower (0 .. 0x10_FFFF
to cover only 21 bits instead of 32 or 64 bits) and some sequences
are not allowed, like those used in surrogate pairs, the 31 non-character
code points 0xFDD0 .. 0xFDEF, the last two code points in \fIany\fR plane
(0x\fI\s-1XX\s0\fR_FFFE and 0x\fI\s-1XX\s0\fR_FFFF), all non-shortest encodings, etc.
.PP
The former default in which Perl would always use a loose interpretation of
\&\s-1UTF\-8\s0 has now been overruled:
.PP
.Vb 5
\&  From: Larry Wall <larry@wall.org>
\&  Date: December 04, 2004 11:51:58 JST
\&  To: perl\-unicode@perl.org
\&  Subject: Re: Make Encode.pm support the real UTF\-8
\&  Message\-Id: <20041204025158.GA28754@wall.org>
\&
\&  On Fri, Dec 03, 2004 at 10:12:12PM +0000, Tim Bunce wrote:
\&  : I\*(Aqve no problem with \*(Aqutf8\*(Aq being perl\*(Aqs unrestricted uft8 encoding,
\&  : but "UTF\-8" is the name of the standard and should give the
\&  : corresponding behaviour.
\&
\&  For what it\*(Aqs worth, that\*(Aqs how I\*(Aqve always kept them straight in my
\&  head.
\&
\&  Also for what it\*(Aqs worth, Perl 6 will mostly default to strict but
\&  make it easy to switch back to lax.
\&
\&  Larry
.Ve
.PP
Got that?  As of Perl 5.8.7, \fB\*(L"\s-1UTF\-8\*(R"\s0\fR means \s-1UTF\-8\s0 in its current
sense, which is conservative and strict and security-conscious, whereas
\&\fB\*(L"utf8\*(R"\fR means \s-1UTF\-8\s0 in its former sense, which was liberal and loose and
lax.  \f(CW\*(C`Encode\*(C'\fR version 2.10 or later thus groks this subtle but critically
important distinction between \f(CW"UTF\-8"\fR and \f(CW"utf8"\fR.
.PP
.Vb 2
\&  encode("utf8",  "\ex{FFFF_FFFF}", 1); # okay
\&  encode("UTF\-8", "\ex{FFFF_FFFF}", 1); # croaks
.Ve
.PP
In the \f(CW\*(C`Encode\*(C'\fR module, \f(CW"UTF\-8"\fR is actually a canonical name for
\&\f(CW"utf\-8\-strict"\fR.  That hyphen between the \f(CW"UTF"\fR and the \f(CW"8"\fR is
critical; without it, \f(CW\*(C`Encode\*(C'\fR goes \*(L"liberal\*(R" and (perhaps overly\-)permissive:
.PP
.Vb 4
\&  find_encoding("UTF\-8")\->name # is \*(Aqutf\-8\-strict\*(Aq
\&  find_encoding("utf\-8")\->name # ditto. names are case insensitive
\&  find_encoding("utf_8")\->name # ditto. "_" are treated as "\-"
\&  find_encoding("UTF8")\->name  # is \*(Aqutf8\*(Aq.
.Ve
.PP
Perl's internal \s-1UTF8\s0 flag is called \*(L"\s-1UTF8\*(R",\s0 without a hyphen. It indicates
whether a string is internally encoded as \*(L"utf8\*(R", also without a hyphen.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Encode::Encoding,
Encode::Supported,
Encode::PerlIO,
encoding,
perlebcdic,
\&\*(L"open\*(R" in perlfunc,
perlunicode, perluniintro, perlunifaq, perlunitut
utf8,
the Perl Unicode Mailing List <http://lists.perl.org/list/perl\-unicode.html>
.SH "MAINTAINER"
.IX Header "MAINTAINER"
This project was originated by the late Nick Ing-Simmons and later
maintained by Dan Kogai \fI<dankogai@cpan.org>\fR.  See \s-1AUTHORS\s0
for a full list of people involved.  For any questions, send mail to
\&\fI<perl\-unicode@perl.org>\fR so that we can all share.
.PP
While Dan Kogai retains the copyright as a maintainer, credit
should go to all those involved.  See \s-1AUTHORS\s0 for a list of those
who submitted code to the project.
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright 2002\-2012 Dan Kogai \fI<dankogai@cpan.org>\fR.
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.
