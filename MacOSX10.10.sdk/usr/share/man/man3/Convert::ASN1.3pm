.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Convert::ASN1 3"
.TH Convert::ASN1 3 "2012-06-09" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Convert::ASN1 \- ASN.1 Encode/Decode library
.SH "VERSION"
.IX Header "VERSION"
version 0.26
.SH "SYNOPSYS"
.IX Header "SYNOPSYS"
.Vb 1
\&  use Convert::ASN1;
\&
\&  $asn = Convert::ASN1\->new;
\&  $asn\->prepare(q<
\&
\&    [APPLICATION 7] SEQUENCE {
\&      int INTEGER,
\&      str OCTET STRING
\&    }
\&
\&  >);
\&
\&  $pdu = $asn\->encode( int => 7, str => "string");
\&
\&  $out = $asn\->decode($pdu);
\&  print $out\->{int}," ",$out\->{str},"\en";
\&
\&  use Convert::ASN1 qw(:io);
\&
\&  $peer   = asn_recv($sock,$buffer,0);
\&  $nbytes = asn_read($fh, $buffer);
\&  $nbytes = asn_send($sock, $buffer, $peer);
\&  $nbytes = asn_send($sock, $buffer);
\&  $nbytes = asn_write($fh, $buffer);
\&  $buffer = asn_get($fh);
\&  $yes    = asn_ready($fh)
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Convert::ASN1 encodes and decodes \s-1ASN.1\s0 data structures using \s-1BER/DER\s0
rules.
.SH "METHODS"
.IX Header "METHODS"
.SS "new ( [\s-1OPTIONS\s0] )"
.IX Subsection "new ( [OPTIONS] )"
Contructor, creates a new object.
.PP
If given, \fB\s-1OPTIONS\s0\fR are the same ones as for \*(L"configure ( \s-1OPTIONS \s0)\*(R" below.
.SS "error ()"
.IX Subsection "error ()"
Returns the last error.
.SS "configure ( \s-1OPTIONS \s0)"
.IX Subsection "configure ( OPTIONS )"
Configure options to control how Convert::ASN1 will perform various tasks.
Options are passed as name-value pairs.
.IP "encode" 4
.IX Item "encode"
Reference to a hash which contains various encode options.
.IP "decode" 4
.IX Item "decode"
Reference to a hash which contains various decode options.
.IP "encoding" 4
.IX Item "encoding"
One of '\s-1BER\s0' or '\s-1DER\s0'. The default is '\s-1BER\s0'
.IP "tagdefault" 4
.IX Item "tagdefault"
One of '\s-1EXPLICIT\s0' or '\s-1IMPLICIT\s0'.
Default tagging conventions are normally given in the \s-1ASN.1\s0 module definition (not supported by the parser). The \s-1ASN.1\s0 spec states \s-1EXPLICIT\s0 tagging is the default, but this option has \s-1IMPLICIT\s0 tagging default for backward compatibility reasons.
.PP
Encode options
.IP "real" 4
.IX Item "real"
Which encoding to use for real's. One of 'binary', 'nr1', 'nr2', 'nr3'
.IP "time" 4
.IX Item "time"
This controls how UTCTime and GeneralizedTime elements are encoded. The default
is \f(CW\*(C`withzone\*(C'\fR.
.RS 4
.IP "utctime" 4
.IX Item "utctime"
The value passed will be encoded without a zone, ie a \s-1UTC\s0 value.
.IP "withzone" 4
.IX Item "withzone"
The value will be encoded with a zone. By default it will be encoded
using the local time offset. The offset may be set using the \f(CW\*(C`timezone\*(C'\fR
configure option.
.IP "raw" 4
.IX Item "raw"
The value passed should already be in the correct format and will be copied
into the \s-1PDU\s0 as-is.
.RE
.RS 4
.RE
.IP "timezone" 4
.IX Item "timezone"
By default UTCTime and GeneralizedTime will be encoded using the local
time offset from \s-1UTC.\s0 This will over-ride that. It is an offset from \s-1UTC\s0
in seconds.  This option can be overridden by passing a reference to a
list of two values as the time value. The list should contain the time
value and the offset from \s-1UTC\s0 in seconds.
.IP "bigint" 4
.IX Item "bigint"
If during encoding an value greater than 32 bits is discovered and
is not already a big integer object, then the value will first be
converted into a big integer object. This option controls the big
integer class into which the objects will be blessed. The default
is to use Math::BigInt
.PP
Decode options
.IP "time" 4
.IX Item "time"
This controls how a UTCTime or a GeneralizedTime element will be decoded. The default
is \f(CW\*(C`utctime\*(C'\fR.
.RS 4
.IP "utctime" 4
.IX Item "utctime"
The value returned will be a time value as returned by the \f(CW\*(C`time\*(C'\fR function.
.IP "withzone" 4
.IX Item "withzone"
The value returned will be a reference to an array of two values. The first is the
same as with \f(CW\*(C`utctime\*(C'\fR, the second is the timezone offset, in seconds, that was
used in the encoding.
.IP "raw" 4
.IX Item "raw"
The value returned will be the raw encoding as extracted from the \s-1PDU.\s0
.RE
.RS 4
.RE
.IP "bigint" 4
.IX Item "bigint"
If during decoding any big integers are discovered (integers greater
than 32 bits), they will be decoded into big integer objects. This option
controls the big integer class into which the objects will be blessed.
The default is to use Math::BigInt.
.IP "null" 4
.IX Item "null"
The value to decode \s-1ASN.1 NULL\s0 types into.
If not set, it defaults to \f(CW1\fR.
.SS "prepare ( \s-1ASN \s0)"
.IX Subsection "prepare ( ASN )"
Compile the given \s-1ASN.1\s0 descripton which can be passed as a string
or as a filehandle. The syntax used is very close to \s-1ASN.1,\s0 but has
a few differences. If the \s-1ASN\s0 decribes only one macro then encode/decode can be
called on this object. If \s-1ASN\s0 describes more than one \s-1ASN.1\s0 macro then \f(CW\*(C`find\*(C'\fR
must be called. The method returns undef on error.
.SS "prepare_file ( \s-1ASNPATH \s0)"
.IX Subsection "prepare_file ( ASNPATH )"
Compile the \s-1ASN.1\s0 description to be read from the specified pathname.
.SS "find ( \s-1MACRO \s0)"
.IX Subsection "find ( MACRO )"
Find a macro from a prepared \s-1ASN.1\s0 description. Returns an object which can
be used for encode/decode.
.SS "encode ( \s-1VARIABLES \s0)"
.IX Subsection "encode ( VARIABLES )"
Encode a \s-1PDU.\s0 Top-level variable are passed as name-value pairs, or as a reference
to a hash containing them. Returns the encoded \s-1PDU,\s0 or undef on error.
.SS "decode ( \s-1PDU \s0)"
.IX Subsection "decode ( PDU )"
Decode the \s-1PDU,\s0 returns a reference to a hash containg the values for the \s-1PDU.\s0 Returns
undef if there was an error.
.SS "registeroid ( \s-1OID, HANDLER \s0)"
.IX Subsection "registeroid ( OID, HANDLER )"
Register a handler for all \s-1ASN.1\s0 elements
that are \f(CW\*(C`DEFINED BY\*(C'\fR the given \s-1OID.\s0
.PP
\&\fB\s-1HANDLER\s0\fR must be a Convert::ASN1 object, e.g. as returned by \*(L"find ( \s-1MACRO \s0)\*(R".
.SS "registertype ( \s-1NAME, OID, HANDLER \s0)"
.IX Subsection "registertype ( NAME, OID, HANDLER )"
Register a handler for all \s-1ASN.1\s0 elements named \f(CW\*(C`NAME\*(C'\fR,
that are \f(CW\*(C`DEFINED BY\*(C'\fR the given \s-1OID.\s0
.PP
\&\fB\s-1HANDLER\s0\fR must be a Convert::ASN1 object, e.g. as returned by \*(L"find ( \s-1MACRO \s0)\*(R".
.SH "EXPORTS"
.IX Header "EXPORTS"
As well as providing an object interface for encoding/decoding PDUs Convert::ASN1
also provides the following functions.
.SS "\s-1IO\s0 Functions"
.IX Subsection "IO Functions"
.IP "asn_recv ( \s-1SOCK, BUFFER, FLAGS \s0)" 4
.IX Item "asn_recv ( SOCK, BUFFER, FLAGS )"
Will read a single element from the socket \s-1SOCK\s0 into \s-1BUFFER.  FLAGS\s0 may
be \s-1MSG_PEEK\s0 as exported by \f(CW\*(C`Socket\*(C'\fR. Returns the address of the sender,
or undef if there was an error. Some systems do not support the return
of the peer address when the socket is a connected socket, in these
cases the empty string will be returned. This is the same behaviour
as the \f(CW\*(C`recv\*(C'\fR function in perl itself.
.Sp
It is recommended that if the socket is of type \s-1SOCK_DGRAM\s0 then \f(CW\*(C`recv\*(C'\fR
be called directly instead of calling \f(CW\*(C`asn_recv\*(C'\fR.
.IP "asn_read ( \s-1FH, BUFFER, OFFSET \s0)" 4
.IX Item "asn_read ( FH, BUFFER, OFFSET )"
.PD 0
.IP "asn_read ( \s-1FH, BUFFER \s0)" 4
.IX Item "asn_read ( FH, BUFFER )"
.PD
Will read a single element from the filehandle \s-1FH\s0 into \s-1BUFFER.\s0 Returns the
number of bytes read if a complete element was read, \-1 if an incomplete
element was read or undef if there was an error. If \s-1OFFSET\s0 is specified
then it is assumed that \s-1BUFFER\s0 already contains an incomplete element
and new data will be appended starting at \s-1OFFSET.\s0
.Sp
If \s-1FH\s0 is a socket the asn_recv is used to read the element, so the same
restiction applies if \s-1FH\s0 is a socket of type \s-1SOCK_DGRAM.\s0
.IP "asn_send ( \s-1SOCK, BUFFER, FLAGS, TO \s0)" 4
.IX Item "asn_send ( SOCK, BUFFER, FLAGS, TO )"
.PD 0
.IP "asn_send ( \s-1SOCK, BUFFER, FLAGS \s0)" 4
.IX Item "asn_send ( SOCK, BUFFER, FLAGS )"
.PD
Identical to calling \f(CW\*(C`send\*(C'\fR, see perlfunc
.IP "asn_write ( \s-1FH, BUFFER \s0)" 4
.IX Item "asn_write ( FH, BUFFER )"
Identical to calling \f(CW\*(C`syswrite\*(C'\fR with 2 arguments, see perlfunc
.IP "asn_get ( \s-1FH \s0)" 4
.IX Item "asn_get ( FH )"
\&\f(CW\*(C`asn_get\*(C'\fR provides buffered \s-1IO.\s0 Because it needs a buffer \s-1FH\s0 must be a \s-1GLOB\s0
or a reference to a \s-1GLOB. \s0\f(CW\*(C`asn_get\*(C'\fR will use two entries in the hash element
of the \s-1GLOB\s0 to use as its buffer:
.Sp
.Vb 2
\&  asn_buffer \- input buffer
\&  asn_need   \- number of bytes needed for the next element, if known
.Ve
.Sp
Returns an element or undef if there was an error.
.IP "asn_ready ( \s-1FH \s0)" 4
.IX Item "asn_ready ( FH )"
\&\f(CW\*(C`asn_ready\*(C'\fR works with \f(CW\*(C`asn_get\*(C'\fR. It will return true if \f(CW\*(C`asn_get\*(C'\fR has already
read enough data into the buffer to return a complete element.
.SS "Encode/Decode Functions"
.IX Subsection "Encode/Decode Functions"
.IP "asn_tag ( \s-1CLASS, VALUE \s0)" 4
.IX Item "asn_tag ( CLASS, VALUE )"
Given \fB\s-1CLASS\s0\fR and a \fB\s-1VALUE\s0\fR, calculate an integer which when encoded
will become the tag.
.IP "asn_decode_tag ( \s-1TAG \s0)" 4
.IX Item "asn_decode_tag ( TAG )"
Decode the given \s-1ASN.1\s0 encoded \f(CW\*(C`TAG\*(C'\fR.
.IP "asn_encode_tag ( \s-1TAG \s0)" 4
.IX Item "asn_encode_tag ( TAG )"
Encode \fB\s-1TAG\s0\fR value for encoding.
We assume that the tag has been correctly generated with \*(L"asn_tag ( \s-1CLASS, VALUE \s0)\*(R".
.IP "asn_decode_length ( \s-1LEN \s0)" 4
.IX Item "asn_decode_length ( LEN )"
Decode the given \s-1ASN.1\s0 decoded \f(CW\*(C`LEN\*(C'\fR.
.IP "asn_encode_length ( \s-1LEN \s0)" 4
.IX Item "asn_encode_length ( LEN )"
Encode the given \f(CW\*(C`LEN\*(C'\fR to its \s-1ASN.1\s0 encoding.
.SS "Constants"
.IX Subsection "Constants"
.IP "\s-1ASN_BIT_STR\s0" 4
.IX Item "ASN_BIT_STR"
.PD 0
.IP "\s-1ASN_BOOLEAN\s0" 4
.IX Item "ASN_BOOLEAN"
.IP "\s-1ASN_ENUMERATED\s0" 4
.IX Item "ASN_ENUMERATED"
.IP "\s-1ASN_GENERAL_TIME\s0" 4
.IX Item "ASN_GENERAL_TIME"
.IP "\s-1ASN_IA5_STR\s0" 4
.IX Item "ASN_IA5_STR"
.IP "\s-1ASN_INTEGER\s0" 4
.IX Item "ASN_INTEGER"
.IP "\s-1ASN_NULL\s0" 4
.IX Item "ASN_NULL"
.IP "\s-1ASN_OBJECT_ID\s0" 4
.IX Item "ASN_OBJECT_ID"
.IP "\s-1ASN_OCTET_STR\s0" 4
.IX Item "ASN_OCTET_STR"
.IP "\s-1ASN_PRINT_STR\s0" 4
.IX Item "ASN_PRINT_STR"
.IP "\s-1ASN_REAL\s0" 4
.IX Item "ASN_REAL"
.IP "\s-1ASN_SEQUENCE\s0" 4
.IX Item "ASN_SEQUENCE"
.IP "\s-1ASN_SET\s0" 4
.IX Item "ASN_SET"
.IP "\s-1ASN_UTC_TIME\s0" 4
.IX Item "ASN_UTC_TIME"
.IP "\s-1ASN_APPLICATION\s0" 4
.IX Item "ASN_APPLICATION"
.IP "\s-1ASN_CONTEXT\s0" 4
.IX Item "ASN_CONTEXT"
.IP "\s-1ASN_PRIVATE\s0" 4
.IX Item "ASN_PRIVATE"
.IP "\s-1ASN_UNIVERSAL\s0" 4
.IX Item "ASN_UNIVERSAL"
.IP "\s-1ASN_PRIMITIVE\s0" 4
.IX Item "ASN_PRIMITIVE"
.IP "\s-1ASN_CONSTRUCTOR\s0" 4
.IX Item "ASN_CONSTRUCTOR"
.IP "\s-1ASN_LONG_LEN\s0" 4
.IX Item "ASN_LONG_LEN"
.IP "\s-1ASN_EXTENSION_ID\s0" 4
.IX Item "ASN_EXTENSION_ID"
.IP "\s-1ASN_BIT\s0" 4
.IX Item "ASN_BIT"
.PD
.SS "Debug Functions"
.IX Subsection "Debug Functions"
.IP "asn_dump ( [\s-1FH,\s0] \s-1BUFFER \s0)" 4
.IX Item "asn_dump ( [FH,] BUFFER )"
Try to decode the given buffer as \s-1ASN.1\s0 structure and dump it to the
given file handle, or \f(CW\*(C`STDERR\*(C'\fR if the handle is not given.
.IP "asn_hexdump ( \s-1FH, BUFFER \s0)" 4
.IX Item "asn_hexdump ( FH, BUFFER )"
.SH "EXPORT TAGS"
.IX Header "EXPORT TAGS"
.PD 0
.IP ":all" 4
.IX Item ":all"
.PD
All exported functions
.IP ":const" 4
.IX Item ":const"
\&\s-1ASN_BOOLEAN,     ASN_INTEGER,      ASN_BIT_STR,      ASN_OCTET_STR,
ASN_NULL,        ASN_OBJECT_ID,    ASN_REAL,         ASN_ENUMERATED,
ASN_SEQUENCE,    ASN_SET,          ASN_PRINT_STR,    ASN_IA5_STR,
ASN_UTC_TIME,    ASN_GENERAL_TIME,
ASN_UNIVERSAL,   ASN_APPLICATION,  ASN_CONTEXT,      ASN_PRIVATE,
ASN_PRIMITIVE,   ASN_CONSTRUCTOR,  ASN_LONG_LEN,     ASN_EXTENSION_ID, ASN_BIT\s0
.IP ":debug" 4
.IX Item ":debug"
asn_dump, asn_hexdump
.IP ":io" 4
.IX Item ":io"
asn_recv, asn_send, asn_read, asn_write, asn_get, asn_ready
.IP ":tag" 4
.IX Item ":tag"
asn_tag, asn_decode_tag, asn_encode_tag, asn_decode_length, asn_encode_length
.SH "MAPPING ASN.1 TO PERL"
.IX Header "MAPPING ASN.1 TO PERL"
Every element in the \s-1ASN.1\s0 definition has a name, in perl a hash is used
with these names as an index and the element value as the hash value.
.PP
.Vb 3
\&  # ASN.1
\&  int INTEGER,
\&  str OCTET STRING
\&
\&  # Perl
\&  { int => 5, str => "text" }
.Ve
.PP
In the case of a \s-1SEQUENCE, SET\s0 or \s-1CHOICE\s0 then the value in the namespace will
be a hash reference which will be the namespce for the elements with
that element.
.PP
.Vb 6
\&  # ASN.1
\&  int INTEGER,
\&  seq SEQUENCE {
\&    str OCTET STRING,
\&    bool BOOLEAN
\&  }
\&
\&  # Perl
\&  { int => 5, seq => { str => "text", bool => 1}}
.Ve
.PP
If the element is a \s-1SEQUENCE OF,\s0 or \s-1SET OF,\s0 then the value in the namespace
will be an array reference. The elements in the array will be of
the type expected by the type following the \s-1OF.\s0 For example
with \*(L"\s-1SEQUENCE OF STRING\*(R"\s0 the array would contain strings. With
\&\*(L"\s-1SEQUENCE OF SEQUENCE\s0 { ... }\*(R" the array will contain hash references
which will be used as namespaces
.PP
.Vb 3
\&  # ASN.1
\&  int INTEGER,
\&  str SEQUENCE OF OCTET STRING
\&
\&  # Perl
\&  { int => 5, str => [ "text1", "text2"]}
\&
\&  # ASN.1
\&  int INTEGER,
\&  str SEQUENCE OF SEQUENCE {
\&    type OCTET STRING,
\&    value INTEGER
\&  }
\&
\&  # Perl
\&  { int => 5, str => [
\&    { type => "abc", value => 4 },
\&    { type => "def", value => \-1 },
\&  ]}
.Ve
.PP
Finally, if you wish to pre-parse \s-1ASN.1\s0 and hold it to include
inline in your \s-1PDU,\s0 you can coerce it into the \s-1ASN.1\s0 spec by
defining the value as \s-1ANY\s0 in the schema, and then pass the pre
encoded value inline.
.PP
.Vb 4
\&  # ASN.1
\&  int INTEGER,
\&  str OCTET STRING,
\&  pre ANY
\&
\&  # Perl
\&  { int => 5, str => "text", pre=>"\ex03\ex03\ex00\ex0a\ex05" }
.Ve
.PP
passes a pre-encoded \s-1BIT STRING\s0 instance as hex text. \-But
it could be a previous run of \f(CW$obj\fR\->\fIencode()\fR from another run
held in some variable.
.SS "Exceptions"
.IX Subsection "Exceptions"
There are some exceptions where Convert::ASN1 does not require an element to be named.
These are \s-1SEQUENCE\s0 {...}, \s-1SET\s0 {...} and \s-1CHOICE.\s0 In each case if the element is not
given a name then the elements inside the {...} will share the same namespace as
the elements outside of the {...}.
.SH "TODO"
.IX Header "TODO"
.IP "\(bu" 4
\&\s-1XS\s0 implementation.
.IP "\(bu" 4
More documentation.
.IP "\(bu" 4
More tests.
.SH "AUTHOR"
.IX Header "AUTHOR"
Graham Barr <gbarr@cpan.org>
.SH "SUPPORT"
.IX Header "SUPPORT"
Report issues via github at https://github.com/gbarr/perl\-Convert\-ASN1/issues
.PP
To contribute I encourage you to create a git fork of the repository at
https://github.com/gbarr/perl\-Convert\-ASN1 do you work on a fresh branch
created from master and submit a pull request
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (c) 2000\-2012 Graham Barr <gbarr@cpan.org>. All rights reserved.
This program is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.
