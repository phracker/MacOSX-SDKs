.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Parse::Eyapp::datagenerationtut 3"
.TH Parse::Eyapp::datagenerationtut 3 "2012-03-23" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Parse::Eyapp::datagenerationtut \- Tutorial on Using Parse::Eyapp as a Data Generator for Testing
.SH "INTRODUCTION"
.IX Header "INTRODUCTION"
The examples for this tutorial can be found in the directory 
\&\f(CW\*(C`examples/generator\*(C'\fR in the distribution of \f(CW\*(C`Parse::Eyapp\*(C'\fR.
.PP
To understand the code you will need some familiarity with Test::LectroTest::Generator,
however, we will make an attempt to introduce the basics of Test::LectroTest::Generator
needed.
.PP
While parsing is the process of determining the membership of a string to a language, 
generation is the reverse problem. Using a context free grammar it is possible to generate 
strings belonging to the language described by that grammar.
.PP
Context free grammars can be used to generate tests. The programmer designs a grammar that
defines a set of inputs that will be able to find some set of bugs.
.PP
This tutorial shows how to use Parse::Eyapp to generate phrases belonging to the language
defined by a given grammar. We will generate inputs to test a simple calculator.
.SS "Compiling and Running the Example"
.IX Subsection "Compiling and Running the Example"
The grammar describing the language is in the file \f(CW\*(C`Generator.eyp\*(C'\fR.
Calling eyapp with option \f(CW\*(C`\-c\*(C'\fR will show the contents of the file 
without the semantic actions:
.PP
.Vb 11
\&  Parse\-Eyapp/examples/generator$ eyapp \-c Generator.eyp
\&  # file: Generator.eyp
\&  # compile with: eyapp \-b \*(Aq\*(Aq Generator.eyp
\&  # then run: ./Generator.pm
\&  %strict
\&  %token NUM VARDEF VAR
\&  %right \*(Aq=\*(Aq
\&  %left \*(Aq\-\*(Aq \*(Aq+\*(Aq
\&  %left \*(Aq*\*(Aq \*(Aq/\*(Aq
\&  %left NEG
\&  %right \*(Aq^\*(Aq
\&
\&  %%
\&
\&  stmts:
\&        stmt
\&      | stmts \*(Aq;\*(Aq  stmt
\&  ;
\&  stmt:
\&        VARDEF \*(Aq=\*(Aq exp
\&  ;
\&  exp:
\&        NUM
\&      | VAR
\&      | exp \*(Aq+\*(Aq exp
\&      | exp \*(Aq\-\*(Aq exp
\&      | exp \*(Aq*\*(Aq exp
\&      | exp \*(Aq/\*(Aq exp
\&      | \*(Aq\-\*(Aq  exp %prec NEG
\&      | exp \*(Aq^\*(Aq exp
\&      | \*(Aq(\*(Aq  exp \*(Aq)\*(Aq
\&  ;
\&
\&  %%
.Ve
.PP
This grammar defines  a language of sequences of semicolon separated assignments.
The right hand side of an assignment can be any valid arithmetic
expression including numbers and variables.
.PP
First we compile the grammar with option \f(CW\*(C`\-b \*(Aq\*(Aq\*(C'\fR to produce a \fImodulino\fR:
.PP
.Vb 1
\&  Parse\-Eyapp/examples/generator$ eyapp \-b \*(Aq\*(Aq Generator.eyp
.Ve
.PP
Now, the module has execution permits and its first line contains the \f(CW\*(C`#!\*(C'\fR header:
.PP
.Vb 4
\&  Parse\-Eyapp/examples/generator$ ls \-ltr | tail \-1
\&  \-rwxr\-xr\-x 1 lusasoft lusasoft 7844 2009\-01\-12 08:30 Generator.pm
\&  Parse\-Eyapp/examples/generator$ head \-1 Generator.pm
\&  #!/usr/bin/perl
.Ve
.PP
The use of option \f(CW\*(C`\-b \*(Aq\*(Aq\*(C'\fR combined with the fact that we have added these lines
.PP
.Vb 3
\&    67  unless (caller) {
\&    68    _\|_PACKAGE_\|_\->main(@ARGV);
\&    69  }
.Ve
.PP
at the end of the grammar file \f(CW\*(C`Generator.eyp\*(C'\fR provide the generated file
with a dual nature: it is a module and an executable at the same time. This is
what is know as a modulino (term coined by Brian d Foy).
.PP
Here follows the results of several executions. Each run produces
a set of assignments. The first output line reports the result 
of the randomly generated program.
.PP
.Vb 3
\&  Parse\-Eyapp/examples/generator$ ./Generator.pm
\&  # result: \-3
\&  SC=\-3
\&
\&  # result: error. Division by zero.
\&  M=(\-4/6+4)+9+2*8*9+4;
\&  XQ=8/3;
\&  EI=XQ*2/0/0;
\&  BL=5+EI+4/5/XQ
.Ve
.PP
As you can see in the former run, only variables that were defined
in previous assignments are used in later assignments. However, the 
generated source may produce run-time errors and exceptions (which
is good thing when testing a calculator).
.PP
.Vb 1
\&  Parse\-Eyapp/examples/generator$ ./Generator.pm
\&
\&  # result: 6
\&  CF=(6)
\&
\&  Parse\-Eyapp/examples/generator$ ./Generator.pm
\&
\&  # result: \-710.2
\&  I=(3*\-8+7/5);
\&  R=2+8*I*4+5*2+I/I
\&
\&  Parse\-Eyapp/examples/generator$ ./Generator.pm
\&
\&  # result: Calculator syntax differs from Perl... 
\&  RY=2\-\-2+(3+6)+(7*7*4^1+2*0/8*5/3)
.Ve
.SH "GENERATING PHRASES FROM A CONTEXT FREE GRAMMAR"
.IX Header "GENERATING PHRASES FROM A CONTEXT FREE GRAMMAR"
.ie n .SS "Using ""YYExpect"" and Test::LectroTest::Generator to generate tokens"
.el .SS "Using \f(CWYYExpect\fP and Test::LectroTest::Generator to generate tokens"
.IX Subsection "Using YYExpect and Test::LectroTest::Generator to generate tokens"
The basic idea of using Parse::Eyapp to generate phrases for the language
defined by a given context free grammar is simple: \fIchange the lexer by a token generator\fR. 
Instead of reading from some input, randomly generate one of the \fIvalid tokens\fR.
.PP
We can use the method \f(CW\*(C`YYExpect\*(C'\fR to know what tokens are valid. 
For versions 1.137 and later of Parse::Eyapp, the method \f(CW\*(C`YYExpect\*(C'\fR returns
the set of valid tokens at the time it is called.
For previous versions (and this is also true for Parse::Yapp), \f(CW\*(C`YYExpect\*(C'\fR only returns
a subset of the whole set of valid tokens.
.PP
In this example, the token
generator has been isolated in the sub \f(CW\*(C`gen_lexer\*(C'\fR in the file \f(CW\*(C`GenSupport.pm\*(C'\fR:
.PP
.Vb 9
\&    47  sub gen_lexer {
\&    48    my $parser = shift;
\&    49
\&    50    my $token = $parser\->generate_token;
\&    51    my $attr = $parser\->generate_attribute($token);
\&    52    #$attr = $WHITESPACES\->generate.$attr;
\&    53
\&    54    return ($token, $attr);
\&    55  }
.Ve
.PP
The token and its attribute are generated in lines 50 and 51.
The methods \f(CW\*(C`generate_token\*(C'\fR and \f(CW\*(C`generate_attribute\*(C'\fR are also
in the module \f(CW\*(C`GenSupport.pm\*(C'\fR. They are methods of the 
parser object since the grammar \f(CW\*(C`Generator.eyp\*(C'\fR not only uses but inherits
this module. See line 3 of \f(CW\*(C`Generator.eyp\*(C'\fR:
.PP
.Vb 7
\&  Parse\-Eyapp/examples/generator$ sed \-ne \*(Aq19,24p\*(Aq Generator.eyp | cat \-n
\&     1  %{
\&     2  use base q{Parse::Eyapp::TokenGen};
\&     3  use base q{GenSupport};
\&     4  %}
\&     5
\&     6  %%
.Ve
.PP
The method \f(CW\*(C`generate_token\*(C'\fR obtains the set of valid tokens using \f(CW\*(C`YYExpect\*(C'\fR (line 29).
Then uses the \f(CW\*(C`Frequency\*(C'\fR function in Test::LectroTest::Generator to produce 
a \f(CW\*(C`Test::LectroTest::Generator\*(C'\fR object (line 31). The method \f(CW\*(C`generate\*(C'\fR of such object
is used to generate the actual token (line 33).
.PP
.Vb 9
\&    26  sub generate_token {
\&    27    my $parser = shift;
\&    28
\&    29    my @token = $parser\->YYExpect;
\&    30
\&    31    my $tokengen = Frequency( map { [$parser\->token_weight($_), Unit($_)] } @token);
\&    32
\&    33    return $tokengen\->generate;
\&    34  }
.Ve
.PP
The Parse::Eyapp::TokenGen method \f(CW\*(C`token_weight\*(C'\fR returns the weight 
associated with a token, assuming it was previously set using one of
the Parse::Eyapp::TokenGen methods like \f(CW\*(C`set_tokenweightsandgenerators\*(C'\fR
or \f(CW\*(C`set_tokenweights\*(C'\fR. See the code of method \f(CW\*(C`main\*(C'\fR in \f(CW\*(C`GenSupport.pm\*(C'\fR:
.PP
.Vb 10
\&  examples/generator$ sed \-ne \*(Aq98,/^ *)/p\*(Aq GenSupport.pm | cat \-n
\&     1    my $parser = $package\->new();
\&     2
\&     3    $parser\->set_tokenweightsandgenerators(
\&     4      NUM => [ 2, Int(range=>[0, 9], sized=>0)],
\&     5      VAR => [
\&     6                0,  # At the beginning, no variables are defined
\&     7                Gen {
\&     8                  return  Elements(keys %st)\->generate if keys %st;
\&     9                  return Int(range=>[0, 9], sized=>0)\->generate;
\&    10                },
\&    11              ],
\&    12      VARDEF => [
\&    13                  2,
\&    14                  String( length=>[1,2], charset=>"A\-NP\-Z", size => 100 )
\&    15                ],
\&    16      \*(Aq=\*(Aq => 2, \*(Aq\-\*(Aq => 1, \*(Aq+\*(Aq => 2,
\&    17      \*(Aq*\*(Aq => 4, \*(Aq/\*(Aq => 2, \*(Aq^\*(Aq => 0.5,
\&    18      \*(Aq;\*(Aq => 1, \*(Aq(\*(Aq => 1, \*(Aq)\*(Aq => 2,
\&    19      \*(Aq\*(Aq  => 2, \*(Aqerror\*(Aq => 0,
\&    20    );
.Ve
.SS "A Brief Introduction to Test::LectroTest::Generator"
.IX Subsection "A Brief Introduction to Test::LectroTest::Generator"
The module \f(CW\*(C`GenSupport.pm\*(C'\fR uses Test::LectroTest::Generator to build generators
for the required tokens. Thus the call to
.PP
.Vb 1
\&                   Int(range=>[0, 9], sized=>0)
.Ve
.PP
builds a Test::LectroTest::Generator object that produces integers in the range 
[0,9]. Such objects have a method \f(CW\*(C`generate\*(C'\fR that produces the 
actual item. The following debugger session illustrates the way to use Test::LectroTest::Generator:
.PP
.Vb 8
\&  pl@europa:~/LEyapp$ perl \-wde 0
\&  main::(\-e:1):   0
\&    DB<1> use Test::LectroTest::Generator qw{:all}
\&    DB<2> $i = Int(range=>[0, 9], sized=>0)
\&    DB<3> p $i\->generate
\&  6
\&    DB<4> p $i\->generate
\&  9
.Ve
.PP
The \f(CW\*(C`String\*(C'\fR method builds a Test::LectroTest::Generator object that produces
strings:
.PP
.Vb 7
\&    DB<5> $v = String( length=>[1,2], charset=>"A\-NP\-Z", size => 100 )
\&    DB<6> p $v\->generate
\&  HM
\&    DB<7> p $v\->generate
\&  Y
\&    DB<8> p $v\->generate
\&  KE
.Ve
.PP
The \f(CW\*(C`Elements\*(C'\fR method builds a Test::LectroTest::Generator object that produces
one of a given list of elements:
.PP
.Vb 10
\&    DB<9> @a = map { $v\->generate } 1..10
\&    DB<10> x @a
\&  0  \*(AqUC\*(Aq
\&  1  \*(AqP\*(Aq
\&  2  \*(AqIF\*(Aq
\&  3  \*(AqEJ\*(Aq
\&  4  \*(AqH\*(Aq
\&  5  \*(AqVC\*(Aq
\&  6  \*(AqCF\*(Aq
\&  7  \*(AqK\*(Aq
\&  8  \*(AqT\*(Aq
\&  9  \*(AqIG\*(Aq
\&    DB<11> $x = Elements(@a)
\&    DB<12> p $x\->generate
\&  P
\&    DB<13> p $x\->generate
\&  P
\&    DB<14> p $x\->generate
\&  EJ
\&    DB<15> p $x\->generate
\&  VC
.Ve
.PP
Even more interesting for our purpose is the \f(CW\*(C`Frequency\*(C'\fR method, 
which produces one of a given list of elements with a given 
probability distribution.
.PP
The following example illustrates its use.
First we build a weight list where the odd elements
have weight 2 and the even elements have weight 1:
.PP
.Vb 10
\&  DB<16> @w = map { $_ % 2 ? 2 : 1 } 0..9
\&  DB<21> @w{@a} = @w
\&  DB<24>  x \e%w
\&    0  HASH(0xd3cc80)
\&       \*(AqCF\*(Aq => 1
\&       \*(AqEJ\*(Aq => 2
\&       \*(AqH\*(Aq => 1
\&       \*(AqIF\*(Aq => 1
\&       \*(AqIG\*(Aq => 2
\&       \*(AqK\*(Aq => 2
\&       \*(AqP\*(Aq => 2
\&       \*(AqT\*(Aq => 1
\&       \*(AqUC\*(Aq => 1
\&       \*(AqVC\*(Aq => 2
.Ve
.PP
We now use \f(CW\*(C`Frequency\*(C'\fR to build a  Test::LectroTest::Generator object that produces
one of the given list of elements \f(CW@a\fR according to the specified probability:
.PP
.Vb 1
\&  DB<29> $f = Frequency( map { [$w{$_}, Unit($_)] } @a)
.Ve
.PP
Let us generate 10 items. We see that odd elements appear more frequently than
even elements:
.PP
.Vb 3
\&  DB<30> @r = map { $f\->generate } 1..10
\&  DB<31> p "@r"
\&    VC UC K UC VC VC K EJ P P
.Ve
.SS "Generating Token Attributes"
.IX Subsection "Generating Token Attributes"
Once the token was generated through the call to \f(CW\*(C`generate_token\*(C'\fR
at line 50:
.PP
.Vb 11
\&    45  #my $WHITESPACES = String( length=>[0,1], charset=>" \et\en", size => 100 );
\&    46
\&    47  sub gen_lexer {
\&    48    my $parser = shift;
\&    49
\&    50    my $token = $parser\->generate_token;
\&    51    my $attr = $parser\->generate_attribute($token);
\&    52    #$attr = $WHITESPACES\->generate.$attr;
\&    53
\&    54    return ($token, $attr);
\&    55  }
.Ve
.PP
the associated attributed is generated via the \f(CW\*(C`generate_attribute\*(C'\fR
method in \f(CW\*(C`GenSupport.pm\*(C'\fR.  If needed, random combination of
white spaces can be added to the generated attribute
via an appropriate generator (line 52).
.PP
The \f(CW\*(C`generate_attribute\*(C'\fR method uses the method \f(CW\*(C`generate\*(C'\fR
of the generator associated with such token.
If no  generator object was set, the 
attribute returned is the token itself (line 42):
.PP
.Vb 8
\&    36  sub generate_attribute {
\&    37    my $parser = shift;
\&    38    my $token = shift;
\&    39
\&    40    my $gen = $parser\->token_generator($token);
\&    41    return $gen\->generate  if defined($gen);
\&    42    return $token;
\&    43  }
.Ve
.SS "Holding Semantic Constraints"
.IX Subsection "Holding Semantic Constraints"
The attribute generator associated with the token \f(CW\*(C`VAR\*(C'\fR is more complex
than the others. It was defined in the call to \f(CW\*(C`set_tokenweightsandgenerators\*(C'\fR:
.PP
.Vb 10
\&  examples/generator$ sed \-ne \*(Aq98,/^ *)/p\*(Aq GenSupport.pm | cat \-n
\&     1    my $parser = $package\->new();
\&     2
\&     3    $parser\->set_tokenweightsandgenerators(
\&     4      NUM => [ 2, Int(range=>[0, 9], sized=>0)],
\&     5      VAR => [
\&     6                0,  # At the beginning, no variables are defined
\&     7                Gen {
\&     8                  return  Elements(keys %st)\->generate if keys %st;
\&     9                  return Int(range=>[0, 9], sized=>0)\->generate;
\&    10                },
\&    11              ],
\&    12      VARDEF => [
\&    13                  2,
\&    14                  String( length=>[1,2], charset=>"A\-NP\-Z", size => 100 )
\&    15                ],
\&    16      \*(Aq=\*(Aq => 2, \*(Aq\-\*(Aq => 1, \*(Aq+\*(Aq => 2,
\&    17      \*(Aq*\*(Aq => 4, \*(Aq/\*(Aq => 2, \*(Aq^\*(Aq => 0.5,
\&    18      \*(Aq;\*(Aq => 1, \*(Aq(\*(Aq => 1, \*(Aq)\*(Aq => 2,
\&    19      \*(Aq\*(Aq  => 2, \*(Aqerror\*(Aq => 0,
\&    20    );
.Ve
.PP
The \f(CW\*(C`Gen\*(C'\fR function of Test::LectroTest::Generator creates a new generator 
from a given code. Since a variable can't be used unless it is defined,
we use a symbol table \f(CW%st\fR to keep record of the variables that were defined 
in previous assignments. If no defined variables exists, the defined generator 
returns a digit between 0 and 9.
.PP
Each time a new assignment to a variable occurs, such 
variable is added to the symbol table. This is achieved
through the semantic action associated with the assignment
production rule:
.PP
.Vb 8
\&  examples/generator$ sed \-ne \*(Aq35,41p\*(Aq Generator.eyp | cat \-n
\&     1  stmt:
\&     2      VARDEF \*(Aq=\*(Aq exp
\&     3        {
\&     4          my $parser = shift;
\&     5          $parser\->defined_variable($_[0]);
\&     6          "$_[0]=$_[2]";
\&     7        }
.Ve
.PP
The \f(CW\*(C`defined_variable\*(C'\fR method in \f(CW\*(C`GenSupport.pm\*(C'\fR simply sets the corresponding
entry in the symbol table:
.PP
.Vb 7
\&  examples/generator$ sed \-ne \*(Aq19,24p\*(Aq GenSupport.pm | cat \-n
\&     1  my %st; # Symbol Table
\&     2  sub defined_variable {
\&     3    my ($parser, $var) = @_;
\&     4
\&     5    $st{$var} = 1;
\&     6  }
.Ve
.PP
The semantic action associated with \f(CW\*(C`VARDEF \*(Aq=\*(Aq exp\*(C'\fR returns the string 
\&\f(CW "$_[0]=$_[2]"\fR containing the actual phrase. Since this  
is the semantic action required for most productions we make it
our default action:
.PP
.Vb 6
\&  examples/generator$ sed \-ne \*(Aq13,17p\*(Aq Generator.eyp | cat \-n
\&     1  %defaultaction {
\&     2    my $parser = shift;
\&     3
\&     4    return join \*(Aq\*(Aq, @_;
\&     5  }
.Ve
.PP
The syntactic variable \f(CW\*(C`stmts\*(C'\fR generates sequences of \f(CW\*(C`stmt\*(C'\fR separated by 
semicolons:
.PP
.Vb 9
\&  examples/generator$ sed \-ne \*(Aq26,33p\*(Aq Generator.eyp | cat \-n
\&     1  stmts:
\&     2      stmt
\&     3        {
\&     4          $_[0]\->deltaweight(VAR => +1); # At least one variable is defined now
\&     5          $_[1];
\&     6        }
\&     7    | stmts \*(Aq;\*(Aq { "\en" } stmt
\&     8  ;
.Ve
.PP
The second production is left recursive. As a consequence, the \f(CW\*(C`stmt\*(C'\fR in the first
production (line 2) is the first statement of the sequence. A small derivation can convince
you of this property:
.PP
.Vb 3
\&                                               stmts\-> stmt
\&   stmts => stmts\*(Aq;\*(Aq stmt => stmts\*(Aq;\*(Aq stmt \*(Aq;\*(Aq stmt => stmt \*(Aq;\*(Aq stmt \*(Aq;\*(Aq stmt 
\&                                                       \-\-\-\-
.Ve
.PP
Thus, when the reduction by the production \f(CW\*(C`stmts \-> stmt\*(C'\fR occurs, we are sure 
that the first statement has been processed. In such case we increase the weight
of token \f(CW\*(C`VAR\*(C'\fR one unit (which was initially zero, see the call 
to \f(CW\*(C`set_tokenweightsandgenerators\*(C'\fR),
.PP
.Vb 1
\&           $_[0]\->deltaweight(VAR => +1);
.Ve
.PP
The weight of \f(CW\*(C`VAR\*(C'\fR is now 1, giving chances for variables to appear
in the right hand side of an assignment. 
The Parse::Eyapp::Tokengen method \f(CW\*(C`deltaweight\*(C'\fR increases (decreases
if negative) the weight of the given tokens using the associated values.
.SS "Dynamically Changing the Probability Distribution"
.IX Subsection "Dynamically Changing the Probability Distribution"
The semantic actions for the productions
.PP
.Vb 1
\&               exp \-> \*(Aq(\*(Aq exp \*(Aq)\*(Aq
.Ve
.PP
and
.PP
.Vb 1
\&               exp \-> \*(Aq\-\*(Aq exp
.Ve
.PP
show a way to modify the weights associated with some tokens:
.PP
.Vb 10
\& 43 exp:
\& 44     NUM
\& 45   | VAR
\& 46   | exp \*(Aq+\*(Aq exp
\& 47   | exp \*(Aq\-\*(Aq exp
\& 48   | exp \*(Aq*\*(Aq exp
\& 49   | exp \*(Aq/\*(Aq exp
\& 50   | \*(Aq\-\*(Aq { $_[0]\->pushdeltaweight(\*(Aq\-\*(Aq => \-1) } exp %prec NEG
\& 51       {
\& 52         $_[0]\->popweight();
\& 53         "\-$_[3]"
\& 54       }
\& 55   | exp \*(Aq^\*(Aq exp
\& 56   | \*(Aq(\*(Aq   { $_[0]\->pushdeltaweight(\*(Aq(\*(Aq => \-1, \*(Aq)\*(Aq => +1, \*(Aq+\*(Aq => +1, ); }
\& 57       exp
\& 58     \*(Aq)\*(Aq
\& 59       {
\& 60          $_[0]\->popweight;
\& 61          "($_[3])"
\& 62       }
\& 63 ;
.Ve
.PP
After seeing a \f(CW\*(Aq(\*(Aq\fR we decrease by one the weight of \f(CW\*(Aq(\*(Aq\fR to avoid
expressions with nested parenthesis. We also increase the weight of token \f(CW\*(Aq+\*(Aq\fR,
since parenthesis are often used to give more priority to a sum over a multiplication
or division. This is achieved via the \f(CW\*(C`pushdeltaweight\*(C'\fR method. The old 
weight is recovered after the closing parenthesis is seen using the
\&\f(CW\*(C`popweight\*(C'\fR method.
.SS "Computing the Expected Result"
.IX Subsection "Computing the Expected Result"
Function \f(CW\*(C`evaluate_using_perl\*(C'\fR in \f(CW\*(C`GenSupport.pm\*(C'\fR
finds the expected value for the generated
expression. The calculator expression is roughly translated
to a Perl expression and evaluated using the Perl interpreter:
.PP
.Vb 10
\& 57 sub evaluate_using_perl { # if possible
\& 58   my $perlexp = shift;
\& 59
\& 60   $perlexp =~ s/\eb([a\-zA\-Z])/\e$$1/g; # substitute A by $A everywhere
\& 61   $perlexp =~ s/\e^/**/g;             # substitute power operator: ^ by **
\& 62
\& 63   my $res = eval "no warnings; no strict;$perlexp";
\& 64   if ($@ =~ /Illegal division/) {
\& 65     $res = "error. Division by zero.";
\& 66   }
\& 67   elsif ($@) { # Our calc notation is incompatible with perl in a few gotchas
\& 68     # Perl interprets \-\- in a different way
\& 69     $@ =~ m{(.*)}; # Show only the first line of error message
\& 70     $res = "Calculator syntax differs from Perl. Can\*(Aqt compute the result: $1";
\& 71   }
\& 72
\& 73   $res;
\& 74 }
.Ve
.PP
The calculator language differs from Perl. In the calculator, two consecutive minus 
like in \f(CW\*(C`2\-\-3\*(C'\fR are interpreted as \f(CW\*(C`2+3\*(C'\fR while for Perl the former expression is an error.
This limitation is here to illustrate a limitation of the approach: it gives 
a way to generate complex structured inputs but the programmer must find a 
way to compute what the expected value is.
.SH "APPENDIX: FILES"
.IX Header "APPENDIX: FILES"
.ie n .SS "File ""GenSupport.pm"""
.el .SS "File \f(CWGenSupport.pm\fP"
.IX Subsection "File GenSupport.pm"
.Vb 10
\&  Parse\-Eyapp/examples/generator$ cat \-n GenSupport.pm
\&     1  package GenSupport;
\&     2  use strict;
\&     3  use warnings;
\&     4
\&     5  use Getopt::Long;
\&     6  use Test::LectroTest::Generator qw(:all);
\&     7  use Parse::Eyapp::TokenGen;
\&     8
\&     9  sub _Error {
\&    10    my $parser = shift;
\&    11
\&    12    my $t = $parser\->YYCurval;
\&    13    my @e = $parser\->YYExpect();
\&    14    my $attr = $parser\->YYSemval(0);
\&    15    local $" = " ";
\&    16    warn "Error:\enCurrent attribute: <$attr>\enCurrent token: <$t>\enExpected: <@e>\en";
\&    17  }
\&    18
\&    19  my %st; # Symbol Table
\&    20  sub defined_variable {
\&    21    my ($parser, $var) = @_;
\&    22
\&    23    $st{$var} = 1;
\&    24  }
\&    25
\&    26  sub generate_token {
\&    27    my $parser = shift;
\&    28
\&    29    my @token = $parser\->YYExpect;
\&    30
\&    31    my $tokengen = Frequency( map { [$parser\->token_weight($_), Unit($_)] } @token);
\&    32
\&    33    return $tokengen\->generate;
\&    34  }
\&    35
\&    36  sub generate_attribute {
\&    37    my $parser = shift;
\&    38    my $token = shift;
\&    39
\&    40    my $gen = $parser\->token_generator($token);
\&    41    return $gen\->generate  if defined($gen);
\&    42    return $token;
\&    43  }
\&    44
\&    45  #my $WHITESPACES = String( length=>[0,1], charset=>" \et\en", size => 100 );
\&    46
\&    47  sub gen_lexer {
\&    48    my $parser = shift;
\&    49
\&    50    my $token = $parser\->generate_token;
\&    51    my $attr = $parser\->generate_attribute($token);
\&    52    #$attr = $WHITESPACES\->generate.$attr;
\&    53
\&    54    return ($token, $attr);
\&    55  }
\&    56
\&    57  sub evaluate_using_perl { # if possible
\&    58    my $perlexp = shift;
\&    59
\&    60    $perlexp =~ s/\eb([a\-zA\-Z])/\e$$1/g; # substitute A by $A everywhere
\&    61    $perlexp =~ s/\e^/**/g;             # substitute power operator: ^ by **
\&    62
\&    63    my $res = eval "no warnings; no strict;$perlexp";
\&    64    if ($@ =~ /Illegal division/) {
\&    65      $res = "error. Division by zero.";
\&    66    }
\&    67    elsif ($@) { # Our calc notation is incompatible with perl in a few gotchas
\&    68      # Perl interprets \-\- in a different way
\&    69      $@ =~ m{(.*)}; # Show only the first line of error message
\&    70      $res = "Calculator syntax differs from Perl. Can\*(Aqt compute the result: $1";
\&    71    }
\&    72
\&    73    $res;
\&    74  }
\&    75
\&    76
\&    77  sub Run {
\&    78      my($self)=shift;
\&    79      my $yydebug = shift || 0;
\&    80
\&    81      return $self\->YYParse(
\&    82        yylex => \e&gen_lexer,
\&    83        yyerror => \e&_Error,
\&    84        yydebug => $yydebug, # 0x1F
\&    85      );
\&    86  }
\&    87
\&    88  sub main {
\&    89    my $package = shift;
\&    90
\&    91    my $debug = shift || 0;
\&    92    my $result = GetOptions (
\&    93      "debug!" => \e$debug,
\&    94    );
\&    95
\&    96    $debug = 0x1F if $debug;
\&    97
\&    98    my $parser = $package\->new();
\&    99
\&   100    $parser\->set_tokenweightsandgenerators(
\&   101      NUM => [ 2, Int(range=>[0, 9], sized=>0)],
\&   102      VAR => [
\&   103                0,  # At the beginning, no variables are defined
\&   104                Gen {
\&   105                  return  Elements(keys %st)\->generate if keys %st;
\&   106                  return Int(range=>[0, 9], sized=>0)\->generate;
\&   107                },
\&   108              ],
\&   109      VARDEF => [
\&   110                  2,
\&   111                  String( length=>[1,2], charset=>"A\-NP\-Z", size => 100 )
\&   112                ],
\&   113      \*(Aq=\*(Aq => 2, \*(Aq\-\*(Aq => 1, \*(Aq+\*(Aq => 2,
\&   114      \*(Aq*\*(Aq => 4, \*(Aq/\*(Aq => 2, \*(Aq^\*(Aq => 0.5,
\&   115      \*(Aq;\*(Aq => 1, \*(Aq(\*(Aq => 1, \*(Aq)\*(Aq => 2,
\&   116      \*(Aq\*(Aq  => 2, \*(Aqerror\*(Aq => 0,
\&   117    );
\&   118
\&   119    my $exp = $parser\->Run( $debug );
\&   120
\&   121    my $res = evaluate_using_perl($exp);
\&   122
\&   123    print "\en# result: $res\en$exp\en";
\&   124  }
\&   125
\&   126  1;
.Ve
.ie n .SS "File ""Generator.eyp"""
.el .SS "File \f(CWGenerator.eyp\fP"
.IX Subsection "File Generator.eyp"
.Vb 10
\&  Parse\-Eyapp/examples/generator$ cat \-n Generator.eyp
\&     1  # file: Generator.eyp
\&     2  # compile with: eyapp \-b \*(Aq\*(Aq Generator.eyp
\&     3  # then run: ./Generator.pm
\&     4  %strict
\&     5  %token NUM VARDEF VAR
\&     6
\&     7  %right  \*(Aq=\*(Aq
\&     8  %left   \*(Aq\-\*(Aq \*(Aq+\*(Aq
\&     9  %left   \*(Aq*\*(Aq \*(Aq/\*(Aq
\&    10  %left   NEG
\&    11  %right  \*(Aq^\*(Aq
\&    12
\&    13  %defaultaction {
\&    14    my $parser = shift;
\&    15
\&    16    return join \*(Aq\*(Aq, @_;
\&    17  }
\&    18
\&    19  %{
\&    20  use base q{Parse::Eyapp::TokenGen};
\&    21  use base q{GenSupport};
\&    22  %}
\&    23
\&    24  %%
\&    25
\&    26  stmts:
\&    27      stmt
\&    28        {
\&    29          $_[0]\->deltaweight(VAR => +1); # At least one variable is defined now
\&    30          $_[1];
\&    31        }
\&    32    | stmts \*(Aq;\*(Aq { "\en" } stmt
\&    33  ;
\&    34
\&    35  stmt:
\&    36      VARDEF \*(Aq=\*(Aq exp
\&    37        {
\&    38          my $parser = shift;
\&    39          $parser\->defined_variable($_[0]);
\&    40          "$_[0]=$_[2]";
\&    41        }
\&    42  ;
\&    43  exp:
\&    44      NUM
\&    45    | VAR
\&    46    | exp \*(Aq+\*(Aq exp
\&    47    | exp \*(Aq\-\*(Aq exp
\&    48    | exp \*(Aq*\*(Aq exp
\&    49    | exp \*(Aq/\*(Aq exp
\&    50    | \*(Aq\-\*(Aq { $_[0]\->pushdeltaweight(\*(Aq\-\*(Aq => \-1) } exp %prec NEG
\&    51        {
\&    52          $_[0]\->popweight();
\&    53          "\-$_[3]"
\&    54        }
\&    55    | exp \*(Aq^\*(Aq exp
\&    56    | \*(Aq(\*(Aq   { $_[0]\->pushdeltaweight(\*(Aq(\*(Aq => \-1, \*(Aq)\*(Aq => +1, \*(Aq+\*(Aq => +1, ); }
\&    57        exp
\&    58      \*(Aq)\*(Aq
\&    59        {
\&    60           $_[0]\->popweight;
\&    61           "($_[3])"
\&    62        }
\&    63  ;
\&    64
\&    65  %%
\&    66
\&    67  unless (caller) {
\&    68    _\|_PACKAGE_\|_\->main(@ARGV);
\&    69  }
.Ve
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.IP "\(bu" 4
Parse::Eyapp::TokenGen
.IP "\(bu" 4
Test::LectroTest::Generator by Tom Moertel
.IP "\(bu" 4
The Design and Implementation of a Grammar-based Data Generator (1992) 
by Peter M. Maurer, Software Practice and Experience 
<http://www.cs.ubc.ca/local/reading/proceedings/spe91\-95/spe/./vol22/issue3/spe756pm.pdf>
.IP "\(bu" 4
yagg: an easy-to-use generator for structured test inputs
by David Coppit and Jiexin Lian.
\&\s-1ASE \s0'05: Proceedings of the 20th \s-1IEEE/ACM\s0 international Conference on Automated software engineering.
2005, pages 356\-359.
.RS 4
.IP "\(bu" 2
<http://search.cpan.org/perldoc?yagg::Tutorial>,
.IP "\(bu" 2
<http://www.cs.wm.edu/~coppit/wiki/images/4/4e/yagg_short.pdf>,
.IP "\(bu" 2
<http://www.cs.wm.edu/~coppit/wiki/images/6/69/wm\-cs\-2005\-13.pdf>
.RE
.RS 4
.RE
.IP "\(bu" 4
Writing Randomly by Randall Schwartz. 
Linux Magazine Column 04 (Sep 1999). 
<http://www.stonehenge.com/merlyn/LinuxMag/col04.html>
.IP "\(bu" 4
Generating Test Data with Enhanced Context Free Grammars by Peter M. Maurer
<http://cs.baylor.edu/~maurer/aida/dgl\-source/documentation/gen_tst.pdf>
.IP "\(bu" 4
Modules as Programs by Brian d Foy 
<http://www252.pair.com/comdog/mastering_perl/Chapters/18.modulinos.html>
.IP "\(bu" 4
How a Script Becomes a Module by Brian d Foy. On Perlmonks: 
<http://www.perlmonks.org/index.pl?node_id=396759>.
.SH "CONTRIBUTORS"
.IX Header "CONTRIBUTORS"
.IP "\(bu" 2
Hal Finkel <http://www.halssoftware.com/>
.IP "\(bu" 2
G. Williams <http://kasei.us/>
.IP "\(bu" 2
Thomas L. Shinnick <http://search.cpan.org/~tshinnic/>
.IP "\(bu" 2
Frank Leray
.SH "AUTHOR"
.IX Header "AUTHOR"
Casiano Rodriguez-Leon (casiano@ull.es)
.SH "ACKNOWLEDGMENTS"
.IX Header "ACKNOWLEDGMENTS"
This work has been supported by \s-1CEE \s0(\s-1FEDER\s0) and the Spanish Ministry of
\&\fIEducacion y Ciencia\fR through \fIPlan Nacional I+D+I\fR number \s-1TIN2005\-08818\-C04\-04
\&\s0(\s-1ULL::OPLINK\s0 project <http://www.oplink.ull.es/>). 
Support from Gobierno de Canarias was through \s-1GC02210601
\&\s0(\fIGrupos Consolidados\fR).
The University of La Laguna has also supported my work in many ways
and for many years.
.PP
A large percentage of  code is verbatim taken from Parse::Yapp 1.05.
The author of Parse::Yapp is Francois Desarmenien.
.PP
I wish to thank Francois Desarmenien for his Parse::Yapp module, 
to my students at La Laguna and to the Perl Community. Thanks to 
the people who have contributed to improve the module (see \*(L"\s-1CONTRIBUTORS\*(R"\s0 in Parse::Eyapp).
Thanks to Larry Wall for giving us Perl.
Special thanks to Juana.
.SH "LICENCE AND COPYRIGHT"
.IX Header "LICENCE AND COPYRIGHT"
Copyright (c) 2006\-2008 Casiano Rodriguez-Leon (casiano@ull.es). All rights reserved.
.PP
Parse::Yapp copyright is of Francois Desarmenien, all rights reserved. 1998\-2001
.PP
These modules are free software; you can redistribute it and/or
modify it under the same terms as Perl itself. See perlartistic.
.PP
This program is distributed in the hope that it will be useful,
but \s-1WITHOUT ANY WARRANTY\s0; without even the implied warranty of
\&\s-1MERCHANTABILITY\s0 or \s-1FITNESS FOR A PARTICULAR PURPOSE. \s0
