.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Module::Implementation 3"
.TH Module::Implementation 3 "2013-07-14" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Module::Implementation \- Loads one of several alternate underlying implementations for a module
.SH "VERSION"
.IX Header "VERSION"
version 0.07
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  package Foo::Bar;
\&
\&  use Module::Implementation;
\&
\&  BEGIN {
\&      my $loader = Module::Implementation::build_loader_sub(
\&          implementations => [ \*(AqXS\*(Aq,  \*(AqPurePerl\*(Aq ],
\&          symbols         => [ \*(Aqrun\*(Aq, \*(Aqcheck\*(Aq ],
\&      );
\&
\&      $loader\->();
\&  }
\&
\&  package Consumer;
\&
\&  # loads the first viable implementation
\&  use Foo::Bar;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module abstracts out the process of choosing one of several underlying
implementations for a module. This can be used to provide \s-1XS\s0 and pure Perl
implementations of a module, or it could be used to load an implementation for
a given \s-1OS\s0 or any other case of needing to provide multiple implementations.
.PP
This module is only useful when you know all the implementations ahead of
time. If you want to load arbitrary implementations then you probably want
something like a plugin system, not this module.
.SH "API"
.IX Header "API"
This module provides two subroutines, neither of which are exported.
.SS "Module::Implementation::build_loader_sub(...)"
.IX Subsection "Module::Implementation::build_loader_sub(...)"
This subroutine takes the following arguments.
.IP "\(bu" 4
implementations
.Sp
This should be an array reference of implementation names. Each name should
correspond to a module in the caller's namespace.
.Sp
In other words, using the example in the \*(L"\s-1SYNOPSIS\*(R"\s0, this module will look
for the \f(CW\*(C`Foo::Bar::XS\*(C'\fR and \f(CW\*(C`Foo::Bar::PurePerl\*(C'\fR modules.
.Sp
This argument is required.
.IP "\(bu" 4
symbols
.Sp
A list of symbols to copy from the implementation package to the calling
package.
.Sp
These can be prefixed with a variable type: \f(CW\*(C`$\*(C'\fR, \f(CW\*(C`@\*(C'\fR, \f(CW\*(C`%\*(C'\fR, \f(CW\*(C`&\*(C'\fR, or
\&\f(CW\*(C`*)\*(C'\fR. If no prefix is given, the symbol is assumed to be a subroutine.
.Sp
This argument is optional.
.PP
This subroutine \fIreturns\fR the implementation loader as a sub reference.
.PP
It is up to you to call this loader sub in your code.
.PP
I recommend that you \fIdo not\fR call this loader in an \f(CW\*(C`import()\*(C'\fR sub. If a
caller explicitly requests no imports, your \f(CW\*(C`import()\*(C'\fR sub will not be run at
all, which can cause weird breakage.
.SS "Module::Implementation::implementation_for($package)"
.IX Subsection "Module::Implementation::implementation_for($package)"
Given a package name, this subroutine returns the implementation that was
loaded for the package. This is not a full package name, just the suffix that
identifies the implementation. For the \*(L"\s-1SYNOPSIS\*(R"\s0 example, this subroutine
would be called as \f(CW\*(C`Module::Implementation::implementation_for(\*(AqFoo::Bar\*(Aq)\*(C'\fR,
and it would return \*(L"\s-1XS\*(R"\s0 or \*(L"PurePerl\*(R".
.SH "HOW THE IMPLEMENTATION LOADER WORKS"
.IX Header "HOW THE IMPLEMENTATION LOADER WORKS"
The implementation loader works like this ...
.PP
First, it checks for an \f(CW%ENV\fR var specifying the implementation to load. The
env var is based on the package name which loads the implementations. The
\&\f(CW\*(C`::\*(C'\fR package separator is replaced with \f(CW\*(C`_\*(C'\fR, and made entirely
upper-case. Finally, we append \*(L"_IMPLEMENTATION\*(R" to this name.
.PP
So in our \*(L"\s-1SYNOPSIS\*(R"\s0 example, the corresponding \f(CW%ENV\fR key would be
\&\f(CW\*(C`FOO_BAR_IMPLEMENTATION\*(C'\fR.
.PP
If this is set, then the loader will \fBonly\fR try to load this one
implementation.
.PP
If the env var requests an implementation which doesn't match one of the
implementations specified when the loader was created, an error is thrown.
.PP
If this one implementation fails to load then loader throws an error. This is
useful for testing. You can request a specific implementation in a test file
by writing something like this:
.PP
.Vb 2
\&  BEGIN { $ENV{FOO_BAR_IMPLEMENTATION} = \*(AqXS\*(Aq }
\&  use Foo::Bar;
.Ve
.PP
If the environment variable is \fInot\fR set, then the loader simply tries the
implementations originally passed to \f(CW\*(C`Module::Implementation\*(C'\fR. The
implementations are tried in the order in which they were originally passed.
.PP
The loader will use the first implementation that loads without an error. It
will copy any requested symbols from this implementation.
.PP
If none of the implementations can be loaded, then the loader throws an
exception.
.PP
The loader returns the name of the package it loaded.
.SH "AUTHOR"
.IX Header "AUTHOR"
Dave Rolsky <autarch@urth.org>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is Copyright (c) 2013 by Dave Rolsky.
.PP
This is free software, licensed under:
.PP
.Vb 1
\&  The Artistic License 2.0 (GPL Compatible)
.Ve
