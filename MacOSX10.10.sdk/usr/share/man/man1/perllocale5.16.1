.\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PERLLOCALE 1"
.TH PERLLOCALE 1 "2013-03-04" "perl v5.16.3" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
perllocale \- Perl locale handling (internationalization and localization)
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
In the beginning there was \s-1ASCII\s0, the \*(L"American Standard Code for
Information Interchange\*(R", which works quite well for Americans with
their English alphabet and dollar-denominated currency.  But it doesn't
work so well even for other English speakers, who may use different
currencies, such as the pound sterling (as the symbol for that currency
is not in \s-1ASCII\s0); and it's hopelessly inadequate for many of the
thousands of the world's other languages.
.PP
To address these deficiencies, the concept of locales was invented
(formally the \s-1ISO\s0 C, \s-1XPG4\s0, \s-1POSIX\s0 1.c \*(L"locale system\*(R").  And applications
were and are being written that use the locale mechanism.  The process of
making such an application take account of its users' preferences in
these kinds of matters is called \fBinternationalization\fR (often
abbreviated as \fBi18n\fR); telling such an application about a particular
set of preferences is known as \fBlocalization\fR (\fBl10n\fR).
.PP
Perl was extended, starting in 5.004, to support the locale system.  This
is controlled per application by using one pragma, one function call,
and several environment variables.
.PP
Unfortunately, there are quite a few deficiencies with the design (and
often, the implementations) of locales, and their use for character sets
has mostly been supplanted by Unicode (see perlunitut for an
introduction to that, and keep on reading here for how Unicode interacts
with locales in Perl).
.PP
Perl continues to support the old locale system, and starting in v5.16,
provides a hybrid way to use the Unicode character set, along with the
other portions of locales that may not be so problematic.
(Unicode is also creating \f(CW\*(C`CLDR\*(C'\fR, the \*(L"Common Locale Data Repository\*(R",
<http://cldr.unicode.org/> which includes more types of information than
are available in the \s-1POSIX\s0 locale system.  At the time of this writing,
there was no \s-1CPAN\s0 module that provides access to this XML-encoded data.
However, many of its locales have the POSIX-only data extracted, and are
available at <http://unicode.org/Public/cldr/latest/>.)
.SH "WHAT IS A LOCALE"
.IX Header "WHAT IS A LOCALE"
A locale is a set of data that describes various aspects of how various
communities in the world categorize their world.  These categories are
broken down into the following types (some of which include a brief
note here):
.IP "Category \s-1LC_NUMERIC:\s0 Numeric formatting" 4
.IX Item "Category LC_NUMERIC: Numeric formatting"
This indicates how numbers should be formatted for human readability,
for example the character used as the decimal point.
.IP "Category \s-1LC_MONETARY:\s0 Formatting of monetary amounts" 4
.IX Item "Category LC_MONETARY: Formatting of monetary amounts"
\&\ 
.IP "Category \s-1LC_TIME:\s0 Date/Time formatting" 4
.IX Item "Category LC_TIME: Date/Time formatting"
\&\ 
.IP "Category \s-1LC_MESSAGES:\s0 Error and other messages" 4
.IX Item "Category LC_MESSAGES: Error and other messages"
This for the most part is beyond the scope of Perl
.IP "Category \s-1LC_COLLATE:\s0 Collation" 4
.IX Item "Category LC_COLLATE: Collation"
This indicates the ordering of letters for comparision and sorting.
In Latin alphabets, for example, \*(L"b\*(R", generally follows \*(L"a\*(R".
.IP "Category \s-1LC_CTYPE:\s0 Character Types" 4
.IX Item "Category LC_CTYPE: Character Types"
This indicates, for example if a character is an uppercase letter.
.PP
More details on the categories are given below in \*(L"\s-1LOCALE\s0 \s-1CATEGORIES\s0\*(R".
.PP
Together, these categories go a long way towards being able to customize
a single program to run in many different locations.  But there are
deficiencies, so keep reading.
.SH "PREPARING TO USE LOCALES"
.IX Header "PREPARING TO USE LOCALES"
Perl will not use locales unless specifically requested to (see \*(L"\s-1NOTES\s0\*(R" below
for the partial exception of \f(CW\*(C`write()\*(C'\fR).  But even if there is such a
request, \fBall\fR of the following must be true for it to work properly:
.IP "\(bu" 4
\&\fBYour operating system must support the locale system\fR.  If it does,
you should find that the \fIsetlocale()\fR function is a documented part of
its C library.
.IP "\(bu" 4
\&\fBDefinitions for locales that you use must be installed\fR.  You, or
your system administrator, must make sure that this is the case. The
available locales, the location in which they are kept, and the manner
in which they are installed all vary from system to system.  Some systems
provide only a few, hard-wired locales and do not allow more to be
added.  Others allow you to add \*(L"canned\*(R" locales provided by the system
supplier.  Still others allow you or the system administrator to define
and add arbitrary locales.  (You may have to ask your supplier to
provide canned locales that are not delivered with your operating
system.)  Read your system documentation for further illumination.
.IP "\(bu" 4
\&\fBPerl must believe that the locale system is supported\fR.  If it does,
\&\f(CW\*(C`perl \-V:d_setlocale\*(C'\fR will say that the value for \f(CW\*(C`d_setlocale\*(C'\fR is
\&\f(CW\*(C`define\*(C'\fR.
.PP
If you want a Perl application to process and present your data
according to a particular locale, the application code should include
the \f(CW\*(C`use\ locale\*(C'\fR pragma (see \*(L"The use locale pragma\*(R") where
appropriate, and \fBat least one\fR of the following must be true:
.IP "1." 4
\&\fBThe locale-determining environment variables (see \*(L"\s-1ENVIRONMENT\s0\*(R")
must be correctly set up\fR at the time the application is started, either
by yourself or by whomever set up your system account; or
.IP "2." 4
\&\fBThe application must set its own locale\fR using the method described in
\&\*(L"The setlocale function\*(R".
.SH "USING LOCALES"
.IX Header "USING LOCALES"
.SS "The use locale pragma"
.IX Subsection "The use locale pragma"
By default, Perl ignores the current locale.  The \f(CW\*(C`use\ locale\*(C'\fR
pragma tells Perl to use the current locale for some operations.
Starting in v5.16, there is an optional parameter to this pragma:
.PP
.Vb 1
\&    use locale \*(Aq:not_characters\*(Aq;
.Ve
.PP
This parameter allows better mixing of locales and Unicode, and is
described fully in \*(L"Unicode and \s-1UTF\-8\s0\*(R", but briefly, it tells Perl to
not use the character portions of the locale definition, that is
the \f(CW\*(C`LC_CTYPE\*(C'\fR and \f(CW\*(C`LC_COLLATE\*(C'\fR categories.  Instead it will use the
native (extended by Unicode) character set.  When using this parameter,
you are responsible for getting the external character set translated
into the native/Unicode one (which it already will be if it is one of
the increasingly popular \s-1UTF\-8\s0 locales).  There are convenient ways of
doing this, as described in \*(L"Unicode and \s-1UTF\-8\s0\*(R".
.PP
The current locale is set at execution time by
\&\fIsetlocale()\fR described below.  If that function
hasn't yet been called in the course of the program's execution, the
current locale is that which was determined by the \*(L"\s-1ENVIRONMENT\s0\*(R" in
effect at the start of the program, except that
\&\f(CW\*(C`LC_NUMERIC\*(C'\fR is always
initialized to the C locale (mentioned under \*(L"Finding locales\*(R").
If there is no valid environment, the current locale is undefined.  It
is likely, but not necessarily, the \*(L"C\*(R" locale.
.PP
The operations that are affected by locale are:
.ie n .IP "\fBUnder \fB""use locale \*(Aq:not_characters\*(Aq;""\fB\fR" 4
.el .IP "\fBUnder \f(CBuse locale \*(Aq:not_characters\*(Aq;\fB\fR" 4
.IX Item "Under use locale :not_characters;"
.RS 4
.PD 0
.IP "\(bu" 4
.PD
\&\fBFormat declarations\fR (\fIformat()\fR) use \f(CW\*(C`LC_NUMERIC\*(C'\fR
.IP "\(bu" 4
\&\fBThe \s-1POSIX\s0 date formatting function\fR (\fIstrftime()\fR) uses \f(CW\*(C`LC_TIME\*(C'\fR.
.RE
.RS 4
.Sp
\&\ 
.RE
.ie n .IP "\fBUnder just plain \fB""use locale;""\fB\fR" 4
.el .IP "\fBUnder just plain \f(CBuse locale;\fB\fR" 4
.IX Item "Under just plain use locale;"
The above operations are affected, as well as the following:
.RS 4
.IP "\(bu" 4
\&\fBThe comparison operators\fR (\f(CW\*(C`lt\*(C'\fR, \f(CW\*(C`le\*(C'\fR, \f(CW\*(C`cmp\*(C'\fR, \f(CW\*(C`ge\*(C'\fR, and \f(CW\*(C`gt\*(C'\fR) and
the \s-1POSIX\s0 string collation functions \fIstrcoll()\fR and \fIstrxfrm()\fR use
\&\f(CW\*(C`LC_COLLATE\*(C'\fR.  \fIsort()\fR is also affected if used without an
explicit comparison function, because it uses \f(CW\*(C`cmp\*(C'\fR by default.
.Sp
\&\fBNote:\fR \f(CW\*(C`eq\*(C'\fR and \f(CW\*(C`ne\*(C'\fR are unaffected by locale: they always
perform a char-by-char comparison of their scalar operands.  What's
more, if \f(CW\*(C`cmp\*(C'\fR finds that its operands are equal according to the
collation sequence specified by the current locale, it goes on to
perform a char-by-char comparison, and only returns \fI0\fR (equal) if the
operands are char-for-char identical.  If you really want to know whether
two strings\*(--which \f(CW\*(C`eq\*(C'\fR and \f(CW\*(C`cmp\*(C'\fR may consider different\*(--are equal
as far as collation in the locale is concerned, see the discussion in
\&\*(L"Category \s-1LC_COLLATE:\s0 Collation\*(R".
.IP "\(bu" 4
\&\fBRegular expressions and case-modification functions\fR (\fIuc()\fR, \fIlc()\fR,
\&\fIucfirst()\fR, and \fIlcfirst()\fR) use \f(CW\*(C`LC_CTYPE\*(C'\fR
.RE
.RS 4
.RE
.PP
The default behavior is restored with the \f(CW\*(C`no\ locale\*(C'\fR pragma, or
upon reaching the end of the block enclosing \f(CW\*(C`use locale\*(C'\fR.
Note that \f(CW\*(C`use locale\*(C'\fR and \f(CW\*(C`use locale \*(Aq:not_characters\*(Aq\*(C'\fR may be
nested, and that what is in effect within an inner scope will revert to
the outer scope's rules at the end of the inner scope.
.PP
The string result of any operation that uses locale
information is tainted, as it is possible for a locale to be
untrustworthy.  See \*(L"\s-1SECURITY\s0\*(R".
.SS "The setlocale function"
.IX Subsection "The setlocale function"
You can switch locales as often as you wish at run time with the
\&\fIPOSIX::setlocale()\fR function:
.PP
.Vb 2
\&        # This functionality not usable prior to Perl 5.004
\&        require 5.004;
\&
\&        # Import locale\-handling tool set from POSIX module.
\&        # This example uses: setlocale \-\- the function call
\&        #                    LC_CTYPE \-\- explained below
\&        use POSIX qw(locale_h);
\&
\&        # query and save the old locale
\&        $old_locale = setlocale(LC_CTYPE);
\&
\&        setlocale(LC_CTYPE, "fr_CA.ISO8859\-1");
\&        # LC_CTYPE now in locale "French, Canada, codeset ISO 8859\-1"
\&
\&        setlocale(LC_CTYPE, "");
\&        # LC_CTYPE now reset to default defined by LC_ALL/LC_CTYPE/LANG
\&        # environment variables.  See below for documentation.
\&
\&        # restore the old locale
\&        setlocale(LC_CTYPE, $old_locale);
.Ve
.PP
The first argument of \fIsetlocale()\fR gives the \fBcategory\fR, the second the
\&\fBlocale\fR.  The category tells in what aspect of data processing you
want to apply locale-specific rules.  Category names are discussed in
\&\*(L"\s-1LOCALE\s0 \s-1CATEGORIES\s0\*(R" and \*(L"\s-1ENVIRONMENT\s0\*(R".  The locale is the name of a
collection of customization information corresponding to a particular
combination of language, country or territory, and codeset.  Read on for
hints on the naming of locales: not all systems name locales as in the
example.
.PP
If no second argument is provided and the category is something else
than \s-1LC_ALL\s0, the function returns a string naming the current locale
for the category.  You can use this value as the second argument in a
subsequent call to \fIsetlocale()\fR.
.PP
If no second argument is provided and the category is \s-1LC_ALL\s0, the
result is implementation-dependent.  It may be a string of
concatenated locale names (separator also implementation-dependent)
or a single locale name.  Please consult your \fIsetlocale\fR\|(3) man page for
details.
.PP
If a second argument is given and it corresponds to a valid locale,
the locale for the category is set to that value, and the function
returns the now-current locale value.  You can then use this in yet
another call to \fIsetlocale()\fR.  (In some implementations, the return
value may sometimes differ from the value you gave as the second
argument\*(--think of it as an alias for the value you gave.)
.PP
As the example shows, if the second argument is an empty string, the
category's locale is returned to the default specified by the
corresponding environment variables.  Generally, this results in a
return to the default that was in force when Perl started up: changes
to the environment made by the application after startup may or may not
be noticed, depending on your system's C library.
.PP
If the second argument does not correspond to a valid locale, the locale
for the category is not changed, and the function returns \fIundef\fR.
.PP
Note that Perl ignores the current \f(CW\*(C`LC_CTYPE\*(C'\fR and \f(CW\*(C`LC_COLLATE\*(C'\fR locales
within the scope of a \f(CW\*(C`use locale \*(Aq:not_characters\*(Aq\*(C'\fR.
.PP
For further information about the categories, consult \fIsetlocale\fR\|(3).
.SS "Finding locales"
.IX Subsection "Finding locales"
For locales available in your system, consult also \fIsetlocale\fR\|(3) to
see whether it leads to the list of available locales (search for the
\&\fI\s-1SEE\s0 \s-1ALSO\s0\fR section).  If that fails, try the following command lines:
.PP
.Vb 1
\&        locale \-a
\&
\&        nlsinfo
\&
\&        ls /usr/lib/nls/loc
\&
\&        ls /usr/lib/locale
\&
\&        ls /usr/lib/nls
\&
\&        ls /usr/share/locale
.Ve
.PP
and see whether they list something resembling these
.PP
.Vb 7
\&        en_US.ISO8859\-1     de_DE.ISO8859\-1     ru_RU.ISO8859\-5
\&        en_US.iso88591      de_DE.iso88591      ru_RU.iso88595
\&        en_US               de_DE               ru_RU
\&        en                  de                  ru
\&        english             german              russian
\&        english.iso88591    german.iso88591     russian.iso88595
\&        english.roman8                          russian.koi8r
.Ve
.PP
Sadly, even though the calling interface for \fIsetlocale()\fR has been
standardized, names of locales and the directories where the
configuration resides have not been.  The basic form of the name is
\&\fIlanguage_territory\fR\fB.\fR\fIcodeset\fR, but the latter parts after
\&\fIlanguage\fR are not always present.  The \fIlanguage\fR and \fIcountry\fR
are usually from the standards \fB\s-1ISO\s0 3166\fR and \fB\s-1ISO\s0 639\fR, the
two-letter abbreviations for the countries and the languages of the
world, respectively.  The \fIcodeset\fR part often mentions some \fB\s-1ISO\s0
8859\fR character set, the Latin codesets.  For example, \f(CW\*(C`ISO 8859\-1\*(C'\fR
is the so-called \*(L"Western European codeset\*(R" that can be used to encode
most Western European languages adequately.  Again, there are several
ways to write even the name of that one standard.  Lamentably.
.PP
Two special locales are worth particular mention: \*(L"C\*(R" and \*(L"\s-1POSIX\s0\*(R".
Currently these are effectively the same locale: the difference is
mainly that the first one is defined by the C standard, the second by
the \s-1POSIX\s0 standard.  They define the \fBdefault locale\fR in which
every program starts in the absence of locale information in its
environment.  (The \fIdefault\fR default locale, if you will.)  Its language
is (American) English and its character codeset \s-1ASCII\s0.
\&\fBWarning\fR. The C locale delivered by some vendors may not
actually exactly match what the C standard calls for.  So beware.
.PP
\&\fB\s-1NOTE\s0\fR: Not all systems have the \*(L"\s-1POSIX\s0\*(R" locale (not all systems are
POSIX-conformant), so use \*(L"C\*(R" when you need explicitly to specify this
default locale.
.SS "\s-1LOCALE\s0 \s-1PROBLEMS\s0"
.IX Subsection "LOCALE PROBLEMS"
You may encounter the following warning message at Perl startup:
.PP
.Vb 6
\&        perl: warning: Setting locale failed.
\&        perl: warning: Please check that your locale settings:
\&                LC_ALL = "En_US",
\&                LANG = (unset)
\&            are supported and installed on your system.
\&        perl: warning: Falling back to the standard locale ("C").
.Ve
.PP
This means that your locale settings had \s-1LC_ALL\s0 set to \*(L"En_US\*(R" and
\&\s-1LANG\s0 exists but has no value.  Perl tried to believe you but could not.
Instead, Perl gave up and fell back to the \*(L"C\*(R" locale, the default locale
that is supposed to work no matter what.  This usually means your locale
settings were wrong, they mention locales your system has never heard
of, or the locale installation in your system has problems (for example,
some system files are broken or missing).  There are quick and temporary
fixes to these problems, as well as more thorough and lasting fixes.
.SS "Temporarily fixing locale problems"
.IX Subsection "Temporarily fixing locale problems"
The two quickest fixes are either to render Perl silent about any
locale inconsistencies or to run Perl under the default locale \*(L"C\*(R".
.PP
Perl's moaning about locale problems can be silenced by setting the
environment variable \s-1PERL_BADLANG\s0 to a zero value, for example \*(L"0\*(R".
This method really just sweeps the problem under the carpet: you tell
Perl to shut up even when Perl sees that something is wrong.  Do not
be surprised if later something locale-dependent misbehaves.
.PP
Perl can be run under the \*(L"C\*(R" locale by setting the environment
variable \s-1LC_ALL\s0 to \*(L"C\*(R".  This method is perhaps a bit more civilized
than the \s-1PERL_BADLANG\s0 approach, but setting \s-1LC_ALL\s0 (or
other locale variables) may affect other programs as well, not just
Perl.  In particular, external programs run from within Perl will see
these changes.  If you make the new settings permanent (read on), all
programs you run see the changes.  See \*(L"\s-1ENVIRONMENT\s0\*(R" for
the full list of relevant environment variables and \*(L"\s-1USING\s0 \s-1LOCALES\s0\*(R"
for their effects in Perl.  Effects in other programs are
easily deducible.  For example, the variable \s-1LC_COLLATE\s0 may well affect
your \fBsort\fR program (or whatever the program that arranges \*(L"records\*(R"
alphabetically in your system is called).
.PP
You can test out changing these variables temporarily, and if the
new settings seem to help, put those settings into your shell startup
files.  Consult your local documentation for the exact details.  For in
Bourne-like shells (\fBsh\fR, \fBksh\fR, \fBbash\fR, \fBzsh\fR):
.PP
.Vb 2
\&        LC_ALL=en_US.ISO8859\-1
\&        export LC_ALL
.Ve
.PP
This assumes that we saw the locale \*(L"en_US.ISO8859\-1\*(R" using the commands
discussed above.  We decided to try that instead of the above faulty
locale \*(L"En_US\*(R"\-\-and in Cshish shells (\fBcsh\fR, \fBtcsh\fR)
.PP
.Vb 1
\&        setenv LC_ALL en_US.ISO8859\-1
.Ve
.PP
or if you have the \*(L"env\*(R" application you can do in any shell
.PP
.Vb 1
\&        env LC_ALL=en_US.ISO8859\-1 perl ...
.Ve
.PP
If you do not know what shell you have, consult your local
helpdesk or the equivalent.
.SS "Permanently fixing locale problems"
.IX Subsection "Permanently fixing locale problems"
The slower but superior fixes are when you may be able to yourself
fix the misconfiguration of your own environment variables.  The
mis(sing)configuration of the whole system's locales usually requires
the help of your friendly system administrator.
.PP
First, see earlier in this document about \*(L"Finding locales\*(R".  That tells
how to find which locales are really supported\*(--and more importantly,
installed\*(--on your system.  In our example error message, environment
variables affecting the locale are listed in the order of decreasing
importance (and unset variables do not matter).  Therefore, having
\&\s-1LC_ALL\s0 set to \*(L"En_US\*(R" must have been the bad choice, as shown by the
error message.  First try fixing locale settings listed first.
.PP
Second, if using the listed commands you see something \fBexactly\fR
(prefix matches do not count and case usually counts) like \*(L"En_US\*(R"
without the quotes, then you should be okay because you are using a
locale name that should be installed and available in your system.
In this case, see \*(L"Permanently fixing your system's locale configuration\*(R".
.SS "Permanently fixing your system's locale configuration"
.IX Subsection "Permanently fixing your system's locale configuration"
This is when you see something like:
.PP
.Vb 4
\&        perl: warning: Please check that your locale settings:
\&                LC_ALL = "En_US",
\&                LANG = (unset)
\&            are supported and installed on your system.
.Ve
.PP
but then cannot see that \*(L"En_US\*(R" listed by the above-mentioned
commands.  You may see things like \*(L"en_US.ISO8859\-1\*(R", but that isn't
the same.  In this case, try running under a locale
that you can list and which somehow matches what you tried.  The
rules for matching locale names are a bit vague because
standardization is weak in this area.  See again the
\&\*(L"Finding locales\*(R" about general rules.
.SS "Fixing system locale configuration"
.IX Subsection "Fixing system locale configuration"
Contact a system administrator (preferably your own) and report the exact
error message you get, and ask them to read this same documentation you
are now reading.  They should be able to check whether there is something
wrong with the locale configuration of the system.  The \*(L"Finding locales\*(R"
section is unfortunately a bit vague about the exact commands and places
because these things are not that standardized.
.SS "The localeconv function"
.IX Subsection "The localeconv function"
The \fIPOSIX::localeconv()\fR function allows you to get particulars of the
locale-dependent numeric formatting information specified by the current
\&\f(CW\*(C`LC_NUMERIC\*(C'\fR and \f(CW\*(C`LC_MONETARY\*(C'\fR locales.  (If you just want the name of
the current locale for a particular category, use \fIPOSIX::setlocale()\fR
with a single parameter\*(--see \*(L"The setlocale function\*(R".)
.PP
.Vb 1
\&        use POSIX qw(locale_h);
\&
\&        # Get a reference to a hash of locale\-dependent info
\&        $locale_values = localeconv();
\&
\&        # Output sorted list of the values
\&        for (sort keys %$locale_values) {
\&            printf "%\-20s = %s\en", $_, $locale_values\->{$_}
\&        }
.Ve
.PP
\&\fIlocaleconv()\fR takes no arguments, and returns \fBa reference to\fR a hash.
The keys of this hash are variable names for formatting, such as
\&\f(CW\*(C`decimal_point\*(C'\fR and \f(CW\*(C`thousands_sep\*(C'\fR.  The values are the
corresponding, er, values.  See \*(L"localeconv\*(R" in \s-1POSIX\s0 for a longer
example listing the categories an implementation might be expected to
provide; some provide more and others fewer.  You don't need an
explicit \f(CW\*(C`use locale\*(C'\fR, because \fIlocaleconv()\fR always observes the
current locale.
.PP
Here's a simple-minded example program that rewrites its command-line
parameters as integers correctly formatted in the current locale:
.PP
.Vb 3
\&    # See comments in previous example
\&    require 5.004;
\&    use POSIX qw(locale_h);
\&
\&    # Get some of locale\*(Aqs numeric formatting parameters
\&    my ($thousands_sep, $grouping) =
\&            @{localeconv()}{\*(Aqthousands_sep\*(Aq, \*(Aqgrouping\*(Aq};
\&
\&    # Apply defaults if values are missing
\&    $thousands_sep = \*(Aq,\*(Aq unless $thousands_sep;
\&
\&    # grouping and mon_grouping are packed lists
\&    # of small integers (characters) telling the
\&    # grouping (thousand_seps and mon_thousand_seps
\&    # being the group dividers) of numbers and
\&    # monetary quantities.  The integers\*(Aq meanings:
\&    # 255 means no more grouping, 0 means repeat
\&    # the previous grouping, 1\-254 means use that
\&    # as the current grouping.  Grouping goes from
\&    # right to left (low to high digits).  In the
\&    # below we cheat slightly by never using anything
\&    # else than the first grouping (whatever that is).
\&    if ($grouping) {
\&        @grouping = unpack("C*", $grouping);
\&    } else {
\&        @grouping = (3);
\&    }
\&
\&    # Format command line params for current locale
\&    for (@ARGV) {
\&        $_ = int;    # Chop non\-integer part
\&        1 while
\&        s/(\ed)(\ed{$grouping[0]}($|$thousands_sep))/$1$thousands_sep$2/;
\&        print "$_";
\&    }
\&    print "\en";
.Ve
.SS "I18N::Langinfo"
.IX Subsection "I18N::Langinfo"
Another interface for querying locale-dependent information is the
\&\fII18N::Langinfo::langinfo()\fR function, available at least in Unix-like
systems and \s-1VMS\s0.
.PP
The following example will import the \fIlanginfo()\fR function itself and
three constants to be used as arguments to \fIlanginfo()\fR: a constant for
the abbreviated first day of the week (the numbering starts from
Sunday = 1) and two more constants for the affirmative and negative
answers for a yes/no question in the current locale.
.PP
.Vb 1
\&    use I18N::Langinfo qw(langinfo ABDAY_1 YESSTR NOSTR);
\&
\&    my ($abday_1, $yesstr, $nostr)
\&                = map { langinfo } qw(ABDAY_1 YESSTR NOSTR);
\&
\&    print "$abday_1? [$yesstr/$nostr] ";
.Ve
.PP
In other words, in the \*(L"C\*(R" (or English) locale the above will probably
print something like:
.PP
.Vb 1
\&    Sun? [yes/no]
.Ve
.PP
See I18N::Langinfo for more information.
.SH "LOCALE CATEGORIES"
.IX Header "LOCALE CATEGORIES"
The following subsections describe basic locale categories.  Beyond these,
some combination categories allow manipulation of more than one
basic category at a time.  See \*(L"\s-1ENVIRONMENT\s0\*(R" for a discussion of these.
.SS "Category \s-1LC_COLLATE:\s0 Collation"
.IX Subsection "Category LC_COLLATE: Collation"
In the scope of \f(CW\*(C`use\ locale\*(C'\fR (but not a
\&\f(CW\*(C`use locale \*(Aq:not_characters\*(Aq\*(C'\fR), Perl looks to the \f(CW\*(C`LC_COLLATE\*(C'\fR
environment variable to determine the application's notions on collation
(ordering) of characters.  For example, \*(L"b\*(R" follows \*(L"a\*(R" in Latin
alphabets, but where do \*(L"a\*'\*(R" and \*(L"a\*o\*(R" belong?  And while
\&\*(L"color\*(R" follows \*(L"chocolate\*(R" in English, what about in Spanish?
.PP
The following collations all make sense and you may meet any of them
if you \*(L"use locale\*(R".
.PP
.Vb 4
\&        A B C D E a b c d e
\&        A a B b C c D d E e
\&        a A b B c C d D e E
\&        a b c d e A B C D E
.Ve
.PP
Here is a code snippet to tell what \*(L"word\*(R"
characters are in the current locale, in that locale's order:
.PP
.Vb 2
\&        use locale;
\&        print +(sort grep /\ew/, map { chr } 0..255), "\en";
.Ve
.PP
Compare this with the characters that you see and their order if you
state explicitly that the locale should be ignored:
.PP
.Vb 2
\&        no locale;
\&        print +(sort grep /\ew/, map { chr } 0..255), "\en";
.Ve
.PP
This machine-native collation (which is what you get unless \f(CW\*(C`use\ locale\*(C'\fR has appeared earlier in the same block) must be used for
sorting raw binary data, whereas the locale-dependent collation of the
first example is useful for natural text.
.PP
As noted in \*(L"\s-1USING\s0 \s-1LOCALES\s0\*(R", \f(CW\*(C`cmp\*(C'\fR compares according to the current
collation locale when \f(CW\*(C`use locale\*(C'\fR is in effect, but falls back to a
char-by-char comparison for strings that the locale says are equal. You
can use \fIPOSIX::strcoll()\fR if you don't want this fall-back:
.PP
.Vb 3
\&        use POSIX qw(strcoll);
\&        $equal_in_locale =
\&            !strcoll("space and case ignored", "SpaceAndCaseIgnored");
.Ve
.PP
\&\f(CW$equal_in_locale\fR will be true if the collation locale specifies a
dictionary-like ordering that ignores space characters completely and
which folds case.
.PP
If you have a single string that you want to check for \*(L"equality in
locale\*(R" against several others, you might think you could gain a little
efficiency by using \fIPOSIX::strxfrm()\fR in conjunction with \f(CW\*(C`eq\*(C'\fR:
.PP
.Vb 8
\&        use POSIX qw(strxfrm);
\&        $xfrm_string = strxfrm("Mixed\-case string");
\&        print "locale collation ignores spaces\en"
\&            if $xfrm_string eq strxfrm("Mixed\-casestring");
\&        print "locale collation ignores hyphens\en"
\&            if $xfrm_string eq strxfrm("Mixedcase string");
\&        print "locale collation ignores case\en"
\&            if $xfrm_string eq strxfrm("mixed\-case string");
.Ve
.PP
\&\fIstrxfrm()\fR takes a string and maps it into a transformed string for use
in char-by-char comparisons against other transformed strings during
collation.  \*(L"Under the hood\*(R", locale-affected Perl comparison operators
call \fIstrxfrm()\fR for both operands, then do a char-by-char
comparison of the transformed strings.  By calling \fIstrxfrm()\fR explicitly
and using a non locale-affected comparison, the example attempts to save
a couple of transformations.  But in fact, it doesn't save anything: Perl
magic (see \*(L"Magic Variables\*(R" in perlguts) creates the transformed version of a
string the first time it's needed in a comparison, then keeps this version around
in case it's needed again.  An example rewritten the easy way with
\&\f(CW\*(C`cmp\*(C'\fR runs just about as fast.  It also copes with null characters
embedded in strings; if you call \fIstrxfrm()\fR directly, it treats the first
null it finds as a terminator.  don't expect the transformed strings
it produces to be portable across systems\*(--or even from one revision
of your operating system to the next.  In short, don't call \fIstrxfrm()\fR
directly: let Perl do it for you.
.PP
Note: \f(CW\*(C`use locale\*(C'\fR isn't shown in some of these examples because it isn't
needed: \fIstrcoll()\fR and \fIstrxfrm()\fR exist only to generate locale-dependent
results, and so always obey the current \f(CW\*(C`LC_COLLATE\*(C'\fR locale.
.SS "Category \s-1LC_CTYPE:\s0 Character Types"
.IX Subsection "Category LC_CTYPE: Character Types"
In the scope of \f(CW\*(C`use\ locale\*(C'\fR (but not a
\&\f(CW\*(C`use locale \*(Aq:not_characters\*(Aq\*(C'\fR), Perl obeys the \f(CW\*(C`LC_CTYPE\*(C'\fR locale
setting.  This controls the application's notion of which characters are
alphabetic.  This affects Perl's \f(CW\*(C`\ew\*(C'\fR regular expression metanotation,
which stands for alphanumeric characters\*(--that is, alphabetic,
numeric, and including other special characters such as the underscore or
hyphen.  (Consult perlre for more information about
regular expressions.)  Thanks to \f(CW\*(C`LC_CTYPE\*(C'\fR, depending on your locale
setting, characters like \*(L"\*(ae\*(R", \*(L"\*(d-\*(R", \*(L"\*8\*(R", and
\&\*(L"o\*/\*(R" may be understood as \f(CW\*(C`\ew\*(C'\fR characters.
.PP
The \f(CW\*(C`LC_CTYPE\*(C'\fR locale also provides the map used in transliterating
characters between lower and uppercase.  This affects the case-mapping
functions\*(--\fIlc()\fR, lcfirst, \fIuc()\fR, and \fIucfirst()\fR; case-mapping
interpolation with \f(CW\*(C`\el\*(C'\fR, \f(CW\*(C`\eL\*(C'\fR, \f(CW\*(C`\eu\*(C'\fR, or \f(CW\*(C`\eU\*(C'\fR in double-quoted strings
and \f(CW\*(C`s///\*(C'\fR substitutions; and case-independent regular expression
pattern matching using the \f(CW\*(C`i\*(C'\fR modifier.
.PP
Finally, \f(CW\*(C`LC_CTYPE\*(C'\fR affects the \s-1POSIX\s0 character-class test
functions\*(--\fIisalpha()\fR, \fIislower()\fR, and so on.  For example, if you move
from the \*(L"C\*(R" locale to a 7\-bit Scandinavian one, you may find\*(--possibly
to your surprise\*(--that \*(L"|\*(R" moves from the \fIispunct()\fR class to \fIisalpha()\fR.
Unfortunately, this creates big problems for regular expressions. \*(L"|\*(R" still
means alternation even though it matches \f(CW\*(C`\ew\*(C'\fR.
.PP
\&\fBNote:\fR A broken or malicious \f(CW\*(C`LC_CTYPE\*(C'\fR locale definition may result
in clearly ineligible characters being considered to be alphanumeric by
your application.  For strict matching of (mundane) \s-1ASCII\s0 letters and
digits\*(--for example, in command strings\*(--locale\-aware applications
should use \f(CW\*(C`\ew\*(C'\fR with the \f(CW\*(C`/a\*(C'\fR regular expression modifier.  See \*(L"\s-1SECURITY\s0\*(R".
.SS "Category \s-1LC_NUMERIC:\s0 Numeric Formatting"
.IX Subsection "Category LC_NUMERIC: Numeric Formatting"
After a proper \fIPOSIX::setlocale()\fR call, Perl obeys the \f(CW\*(C`LC_NUMERIC\*(C'\fR
locale information, which controls an application's idea of how numbers
should be formatted for human readability by the \fIprintf()\fR, \fIsprintf()\fR, and
\&\fIwrite()\fR functions. String-to-numeric conversion by the \fIPOSIX::strtod()\fR
function is also affected.  In most implementations the only effect is to
change the character used for the decimal point\*(--perhaps from \*(L".\*(R"  to \*(L",\*(R".
These functions aren't aware of such niceties as thousands separation and
so on. (See \*(L"The localeconv function\*(R" if you care about these things.)
.PP
Output produced by \fIprint()\fR is also affected by the current locale: it
corresponds to what you'd get from \fIprintf()\fR in the \*(L"C\*(R" locale.  The
same is true for Perl's internal conversions between numeric and
string formats:
.PP
.Vb 1
\&        use POSIX qw(strtod setlocale LC_NUMERIC);
\&
\&        setlocale LC_NUMERIC, "";
\&
\&        $n = 5/2;   # Assign numeric 2.5 to $n
\&
\&        $a = " $n"; # Locale\-dependent conversion to string
\&
\&        print "half five is $n\en";       # Locale\-dependent output
\&
\&        printf "half five is %g\en", $n;  # Locale\-dependent output
\&
\&        print "DECIMAL POINT IS COMMA\en"
\&            if $n == (strtod("2,5"))[0]; # Locale\-dependent conversion
.Ve
.PP
See also I18N::Langinfo and \f(CW\*(C`RADIXCHAR\*(C'\fR.
.SS "Category \s-1LC_MONETARY:\s0 Formatting of monetary amounts"
.IX Subsection "Category LC_MONETARY: Formatting of monetary amounts"
The C standard defines the \f(CW\*(C`LC_MONETARY\*(C'\fR category, but not a function
that is affected by its contents.  (Those with experience of standards
committees will recognize that the working group decided to punt on the
issue.)  Consequently, Perl takes no notice of it.  If you really want
to use \f(CW\*(C`LC_MONETARY\*(C'\fR, you can query its contents\*(--see
\&\*(L"The localeconv function\*(R"\-\-and use the information that it returns in your
application's own formatting of currency amounts.  However, you may well
find that the information, voluminous and complex though it may be, still
does not quite meet your requirements: currency formatting is a hard nut
to crack.
.PP
See also I18N::Langinfo and \f(CW\*(C`CRNCYSTR\*(C'\fR.
.SS "\s-1LC_TIME\s0"
.IX Subsection "LC_TIME"
Output produced by \fIPOSIX::strftime()\fR, which builds a formatted
human-readable date/time string, is affected by the current \f(CW\*(C`LC_TIME\*(C'\fR
locale.  Thus, in a French locale, the output produced by the \f(CW%B\fR
format element (full month name) for the first month of the year would
be \*(L"janvier\*(R".  Here's how to get a list of long month names in the
current locale:
.PP
.Vb 5
\&        use POSIX qw(strftime);
\&        for (0..11) {
\&            $long_month_name[$_] =
\&                strftime("%B", 0, 0, 0, 1, $_, 96);
\&        }
.Ve
.PP
Note: \f(CW\*(C`use locale\*(C'\fR isn't needed in this example: as a function that
exists only to generate locale-dependent results, \fIstrftime()\fR always
obeys the current \f(CW\*(C`LC_TIME\*(C'\fR locale.
.PP
See also I18N::Langinfo and \f(CW\*(C`ABDAY_1\*(C'\fR..\f(CW\*(C`ABDAY_7\*(C'\fR, \f(CW\*(C`DAY_1\*(C'\fR..\f(CW\*(C`DAY_7\*(C'\fR,
\&\f(CW\*(C`ABMON_1\*(C'\fR..\f(CW\*(C`ABMON_12\*(C'\fR, and \f(CW\*(C`ABMON_1\*(C'\fR..\f(CW\*(C`ABMON_12\*(C'\fR.
.SS "Other categories"
.IX Subsection "Other categories"
The remaining locale category, \f(CW\*(C`LC_MESSAGES\*(C'\fR (possibly supplemented
by others in particular implementations) is not currently used by
Perl\*(--except possibly to affect the behavior of library functions
called by extensions outside the standard Perl distribution and by the
operating system and its utilities.  Note especially that the string
value of \f(CW$!\fR and the error messages given by external utilities may
be changed by \f(CW\*(C`LC_MESSAGES\*(C'\fR.  If you want to have portable error
codes, use \f(CW\*(C`%!\*(C'\fR.  See Errno.
.SH "SECURITY"
.IX Header "SECURITY"
Although the main discussion of Perl security issues can be found in
perlsec, a discussion of Perl's locale handling would be incomplete
if it did not draw your attention to locale-dependent security issues.
Locales\*(--particularly on systems that allow unprivileged users to
build their own locales\*(--are untrustworthy.  A malicious (or just plain
broken) locale can make a locale-aware application give unexpected
results.  Here are a few possibilities:
.IP "\(bu" 4
Regular expression checks for safe file names or mail addresses using
\&\f(CW\*(C`\ew\*(C'\fR may be spoofed by an \f(CW\*(C`LC_CTYPE\*(C'\fR locale that claims that
characters such as \*(L">\*(R" and \*(L"|\*(R" are alphanumeric.
.IP "\(bu" 4
String interpolation with case-mapping, as in, say, \f(CW\*(C`$dest =
"C:\eU$name.$ext"\*(C'\fR, may produce dangerous results if a bogus \s-1LC_CTYPE\s0
case-mapping table is in effect.
.IP "\(bu" 4
A sneaky \f(CW\*(C`LC_COLLATE\*(C'\fR locale could result in the names of students with
\&\*(L"D\*(R" grades appearing ahead of those with \*(L"A\*(R"s.
.IP "\(bu" 4
An application that takes the trouble to use information in
\&\f(CW\*(C`LC_MONETARY\*(C'\fR may format debits as if they were credits and vice versa
if that locale has been subverted.  Or it might make payments in \s-1US\s0
dollars instead of Hong Kong dollars.
.IP "\(bu" 4
The date and day names in dates formatted by \fIstrftime()\fR could be
manipulated to advantage by a malicious user able to subvert the
\&\f(CW\*(C`LC_DATE\*(C'\fR locale.  (\*(L"Look\*(--it says I wasn't in the building on
Sunday.\*(R")
.PP
Such dangers are not peculiar to the locale system: any aspect of an
application's environment which may be modified maliciously presents
similar challenges.  Similarly, they are not specific to Perl: any
programming language that allows you to write programs that take
account of their environment exposes you to these issues.
.PP
Perl cannot protect you from all possibilities shown in the
examples\*(--there is no substitute for your own vigilance\*(--but, when
\&\f(CW\*(C`use locale\*(C'\fR is in effect, Perl uses the tainting mechanism (see
perlsec) to mark string results that become locale-dependent, and
which may be untrustworthy in consequence.  Here is a summary of the
tainting behavior of operators and functions that may be affected by
the locale:
.IP "\(bu" 4
\&\fBComparison operators\fR (\f(CW\*(C`lt\*(C'\fR, \f(CW\*(C`le\*(C'\fR, \f(CW\*(C`ge\*(C'\fR, \f(CW\*(C`gt\*(C'\fR and \f(CW\*(C`cmp\*(C'\fR):
.Sp
Scalar true/false (or less/equal/greater) result is never tainted.
.IP "\(bu" 4
\&\fBCase-mapping interpolation\fR (with \f(CW\*(C`\el\*(C'\fR, \f(CW\*(C`\eL\*(C'\fR, \f(CW\*(C`\eu\*(C'\fR or \f(CW\*(C`\eU\*(C'\fR)
.Sp
Result string containing interpolated material is tainted if
\&\f(CW\*(C`use locale\*(C'\fR (but not \f(CW\*(C`use\ locale\ \*(Aq:not_characters\*(Aq\*(C'\fR) is in effect.
.IP "\(bu" 4
\&\fBMatching operator\fR (\f(CW\*(C`m//\*(C'\fR):
.Sp
Scalar true/false result never tainted.
.Sp
Subpatterns, either delivered as a list-context result or as \f(CW$1\fR etc.
are tainted if \f(CW\*(C`use locale\*(C'\fR (but not \f(CW\*(C`use\ locale\ \*(Aq:not_characters\*(Aq\*(C'\fR)
is in effect, and the subpattern regular
expression contains \f(CW\*(C`\ew\*(C'\fR (to match an alphanumeric character), \f(CW\*(C`\eW\*(C'\fR
(non-alphanumeric character), \f(CW\*(C`\es\*(C'\fR (whitespace character), or \f(CW\*(C`\eS\*(C'\fR
(non whitespace character).  The matched-pattern variable, $&, $`
(pre-match), $' (post-match), and $+ (last match) are also tainted if
\&\f(CW\*(C`use locale\*(C'\fR is in effect and the regular expression contains \f(CW\*(C`\ew\*(C'\fR,
\&\f(CW\*(C`\eW\*(C'\fR, \f(CW\*(C`\es\*(C'\fR, or \f(CW\*(C`\eS\*(C'\fR.
.IP "\(bu" 4
\&\fBSubstitution operator\fR (\f(CW\*(C`s///\*(C'\fR):
.Sp
Has the same behavior as the match operator.  Also, the left
operand of \f(CW\*(C`=~\*(C'\fR becomes tainted when \f(CW\*(C`use locale\*(C'\fR
(but not \f(CW\*(C`use\ locale\ \*(Aq:not_characters\*(Aq\*(C'\fR) is in effect if modified as
a result of a substitution based on a regular
expression match involving \f(CW\*(C`\ew\*(C'\fR, \f(CW\*(C`\eW\*(C'\fR, \f(CW\*(C`\es\*(C'\fR, or \f(CW\*(C`\eS\*(C'\fR; or of
case-mapping with \f(CW\*(C`\el\*(C'\fR, \f(CW\*(C`\eL\*(C'\fR,\f(CW\*(C`\eu\*(C'\fR or \f(CW\*(C`\eU\*(C'\fR.
.IP "\(bu" 4
\&\fBOutput formatting functions\fR (\fIprintf()\fR and \fIwrite()\fR):
.Sp
Results are never tainted because otherwise even output from print,
for example \f(CW\*(C`print(1/7)\*(C'\fR, should be tainted if \f(CW\*(C`use locale\*(C'\fR is in
effect.
.IP "\(bu" 4
\&\fBCase-mapping functions\fR (\fIlc()\fR, \fIlcfirst()\fR, \fIuc()\fR, \fIucfirst()\fR):
.Sp
Results are tainted if \f(CW\*(C`use locale\*(C'\fR (but not
\&\f(CW\*(C`use\ locale\ \*(Aq:not_characters\*(Aq\*(C'\fR) is in effect.
.IP "\(bu" 4
\&\fB\s-1POSIX\s0 locale-dependent functions\fR (\fIlocaleconv()\fR, \fIstrcoll()\fR,
\&\fIstrftime()\fR, \fIstrxfrm()\fR):
.Sp
Results are never tainted.
.IP "\(bu" 4
\&\fB\s-1POSIX\s0 character class tests\fR (\fIisalnum()\fR, \fIisalpha()\fR, \fIisdigit()\fR,
\&\fIisgraph()\fR, \fIislower()\fR, \fIisprint()\fR, \fIispunct()\fR, \fIisspace()\fR, \fIisupper()\fR,
\&\fIisxdigit()\fR):
.Sp
True/false results are never tainted.
.PP
Three examples illustrate locale-dependent tainting.
The first program, which ignores its locale, won't run: a value taken
directly from the command line may not be used to name an output file
when taint checks are enabled.
.PP
.Vb 2
\&        #/usr/local/bin/perl \-T
\&        # Run with taint checking
\&
\&        # Command line sanity check omitted...
\&        $tainted_output_file = shift;
\&
\&        open(F, ">$tainted_output_file")
\&            or warn "Open of $untainted_output_file failed: $!\en";
.Ve
.PP
The program can be made to run by \*(L"laundering\*(R" the tainted value through
a regular expression: the second example\*(--which still ignores locale
information\*(--runs, creating the file named on its command line
if it can.
.PP
.Vb 1
\&        #/usr/local/bin/perl \-T
\&
\&        $tainted_output_file = shift;
\&        $tainted_output_file =~ m%[\ew/]+%;
\&        $untainted_output_file = $&;
\&
\&        open(F, ">$untainted_output_file")
\&            or warn "Open of $untainted_output_file failed: $!\en";
.Ve
.PP
Compare this with a similar but locale-aware program:
.PP
.Vb 1
\&        #/usr/local/bin/perl \-T
\&
\&        $tainted_output_file = shift;
\&        use locale;
\&        $tainted_output_file =~ m%[\ew/]+%;
\&        $localized_output_file = $&;
\&
\&        open(F, ">$localized_output_file")
\&            or warn "Open of $localized_output_file failed: $!\en";
.Ve
.PP
This third program fails to run because $& is tainted: it is the result
of a match involving \f(CW\*(C`\ew\*(C'\fR while \f(CW\*(C`use locale\*(C'\fR is in effect.
.SH "ENVIRONMENT"
.IX Header "ENVIRONMENT"
.IP "\s-1PERL_BADLANG\s0" 12
.IX Item "PERL_BADLANG"
A string that can suppress Perl's warning about failed locale settings
at startup.  Failure can occur if the locale support in the operating
system is lacking (broken) in some way\*(--or if you mistyped the name of
a locale when you set up your environment.  If this environment
variable is absent, or has a value that does not evaluate to integer
zero\*(--that is, \*(L"0\*(R" or ""\-\- Perl will complain about locale setting
failures.
.Sp
\&\fB\s-1NOTE\s0\fR: \s-1PERL_BADLANG\s0 only gives you a way to hide the warning message.
The message tells about some problem in your system's locale support,
and you should investigate what the problem is.
.PP
The following environment variables are not specific to Perl: They are
part of the standardized (\s-1ISO\s0 C, \s-1XPG4\s0, \s-1POSIX\s0 1.c) \fIsetlocale()\fR method
for controlling an application's opinion on data.
.IP "\s-1LC_ALL\s0" 12
.IX Item "LC_ALL"
\&\f(CW\*(C`LC_ALL\*(C'\fR is the \*(L"override-all\*(R" locale environment variable. If
set, it overrides all the rest of the locale environment variables.
.IP "\s-1LANGUAGE\s0" 12
.IX Item "LANGUAGE"
\&\fB\s-1NOTE\s0\fR: \f(CW\*(C`LANGUAGE\*(C'\fR is a \s-1GNU\s0 extension, it affects you only if you
are using the \s-1GNU\s0 libc.  This is the case if you are using e.g. Linux.
If you are using \*(L"commercial\*(R" Unixes you are most probably \fInot\fR
using \s-1GNU\s0 libc and you can ignore \f(CW\*(C`LANGUAGE\*(C'\fR.
.Sp
However, in the case you are using \f(CW\*(C`LANGUAGE\*(C'\fR: it affects the
language of informational, warning, and error messages output by
commands (in other words, it's like \f(CW\*(C`LC_MESSAGES\*(C'\fR) but it has higher
priority than \f(CW\*(C`LC_ALL\*(C'\fR.  Moreover, it's not a single value but
instead a \*(L"path\*(R" (\*(L":\*(R"\-separated list) of \fIlanguages\fR (not locales).
See the \s-1GNU\s0 \f(CW\*(C`gettext\*(C'\fR library documentation for more information.
.IP "\s-1LC_CTYPE\s0" 12
.IX Item "LC_CTYPE"
In the absence of \f(CW\*(C`LC_ALL\*(C'\fR, \f(CW\*(C`LC_CTYPE\*(C'\fR chooses the character type
locale.  In the absence of both \f(CW\*(C`LC_ALL\*(C'\fR and \f(CW\*(C`LC_CTYPE\*(C'\fR, \f(CW\*(C`LANG\*(C'\fR
chooses the character type locale.
.IP "\s-1LC_COLLATE\s0" 12
.IX Item "LC_COLLATE"
In the absence of \f(CW\*(C`LC_ALL\*(C'\fR, \f(CW\*(C`LC_COLLATE\*(C'\fR chooses the collation
(sorting) locale.  In the absence of both \f(CW\*(C`LC_ALL\*(C'\fR and \f(CW\*(C`LC_COLLATE\*(C'\fR,
\&\f(CW\*(C`LANG\*(C'\fR chooses the collation locale.
.IP "\s-1LC_MONETARY\s0" 12
.IX Item "LC_MONETARY"
In the absence of \f(CW\*(C`LC_ALL\*(C'\fR, \f(CW\*(C`LC_MONETARY\*(C'\fR chooses the monetary
formatting locale.  In the absence of both \f(CW\*(C`LC_ALL\*(C'\fR and \f(CW\*(C`LC_MONETARY\*(C'\fR,
\&\f(CW\*(C`LANG\*(C'\fR chooses the monetary formatting locale.
.IP "\s-1LC_NUMERIC\s0" 12
.IX Item "LC_NUMERIC"
In the absence of \f(CW\*(C`LC_ALL\*(C'\fR, \f(CW\*(C`LC_NUMERIC\*(C'\fR chooses the numeric format
locale.  In the absence of both \f(CW\*(C`LC_ALL\*(C'\fR and \f(CW\*(C`LC_NUMERIC\*(C'\fR, \f(CW\*(C`LANG\*(C'\fR
chooses the numeric format.
.IP "\s-1LC_TIME\s0" 12
.IX Item "LC_TIME"
In the absence of \f(CW\*(C`LC_ALL\*(C'\fR, \f(CW\*(C`LC_TIME\*(C'\fR chooses the date and time
formatting locale.  In the absence of both \f(CW\*(C`LC_ALL\*(C'\fR and \f(CW\*(C`LC_TIME\*(C'\fR,
\&\f(CW\*(C`LANG\*(C'\fR chooses the date and time formatting locale.
.IP "\s-1LANG\s0" 12
.IX Item "LANG"
\&\f(CW\*(C`LANG\*(C'\fR is the \*(L"catch-all\*(R" locale environment variable. If it is set, it
is used as the last resort after the overall \f(CW\*(C`LC_ALL\*(C'\fR and the
category-specific \f(CW\*(C`LC_...\*(C'\fR.
.SS "Examples"
.IX Subsection "Examples"
The \s-1LC_NUMERIC\s0 controls the numeric output:
.PP
.Vb 4
\&   use locale;
\&   use POSIX qw(locale_h); # Imports setlocale() and the LC_ constants.
\&   setlocale(LC_NUMERIC, "fr_FR") or die "Pardon";
\&   printf "%g\en", 1.23; # If the "fr_FR" succeeded, probably shows 1,23.
.Ve
.PP
and also how strings are parsed by \fIPOSIX::strtod()\fR as numbers:
.PP
.Vb 5
\&   use locale;
\&   use POSIX qw(locale_h strtod);
\&   setlocale(LC_NUMERIC, "de_DE") or die "Entschuldigung";
\&   my $x = strtod("2,34") + 5;
\&   print $x, "\en"; # Probably shows 7,34.
.Ve
.SH "NOTES"
.IX Header "NOTES"
.SS "Backward compatibility"
.IX Subsection "Backward compatibility"
Versions of Perl prior to 5.004 \fBmostly\fR ignored locale information,
generally behaving as if something similar to the \f(CW"C"\fR locale were
always in force, even if the program environment suggested otherwise
(see \*(L"The setlocale function\*(R").  By default, Perl still behaves this
way for backward compatibility.  If you want a Perl application to pay
attention to locale information, you \fBmust\fR use the \f(CW\*(C`use\ locale\*(C'\fR
pragma (see \*(L"The use locale pragma\*(R") or, in the unlikely event
that you want to do so for just pattern matching, the
\&\f(CW\*(C`/l\*(C'\fR regular expression modifier (see \*(L"Character set
modifiers\*(R" in perlre) to instruct it to do so.
.PP
Versions of Perl from 5.002 to 5.003 did use the \f(CW\*(C`LC_CTYPE\*(C'\fR
information if available; that is, \f(CW\*(C`\ew\*(C'\fR did understand what
were the letters according to the locale environment variables.
The problem was that the user had no control over the feature:
if the C library supported locales, Perl used them.
.SS "I18N:Collate obsolete"
.IX Subsection "I18N:Collate obsolete"
In versions of Perl prior to 5.004, per-locale collation was possible
using the \f(CW\*(C`I18N::Collate\*(C'\fR library module.  This module is now mildly
obsolete and should be avoided in new applications.  The \f(CW\*(C`LC_COLLATE\*(C'\fR
functionality is now integrated into the Perl core language: One can
use locale-specific scalar data completely normally with \f(CW\*(C`use locale\*(C'\fR,
so there is no longer any need to juggle with the scalar references of
\&\f(CW\*(C`I18N::Collate\*(C'\fR.
.SS "Sort speed and memory use impacts"
.IX Subsection "Sort speed and memory use impacts"
Comparing and sorting by locale is usually slower than the default
sorting; slow-downs of two to four times have been observed.  It will
also consume more memory: once a Perl scalar variable has participated
in any string comparison or sorting operation obeying the locale
collation rules, it will take 3\-15 times more memory than before.  (The
exact multiplier depends on the string's contents, the operating system
and the locale.) These downsides are dictated more by the operating
system's implementation of the locale system than by Perl.
.SS "\fIwrite()\fP and \s-1LC_NUMERIC\s0"
.IX Subsection "write() and LC_NUMERIC"
If a program's environment specifies an \s-1LC_NUMERIC\s0 locale and \f(CW\*(C`use
locale\*(C'\fR is in effect when the format is declared, the locale is used
to specify the decimal point character in formatted output.  Formatted
output cannot be controlled by \f(CW\*(C`use locale\*(C'\fR at the time when \fIwrite()\fR
is called.
.SS "Freely available locale definitions"
.IX Subsection "Freely available locale definitions"
The Unicode \s-1CLDR\s0 project extracts the \s-1POSIX\s0 portion of many of its
locales, available at
.PP
.Vb 1
\&  http://unicode.org/Public/cldr/latest/
.Ve
.PP
There is a large collection of locale definitions at:
.PP
.Vb 1
\&  http://std.dkuug.dk/i18n/WG15\-collection/locales/
.Ve
.PP
You should be aware that it is
unsupported, and is not claimed to be fit for any purpose.  If your
system allows installation of arbitrary locales, you may find the
definitions useful as they are, or as a basis for the development of
your own locales.
.SS "I18n and l10n"
.IX Subsection "I18n and l10n"
\&\*(L"Internationalization\*(R" is often abbreviated as \fBi18n\fR because its first
and last letters are separated by eighteen others.  (You may guess why
the internalin ... internaliti ... i18n tends to get abbreviated.)  In
the same way, \*(L"localization\*(R" is often abbreviated to \fBl10n\fR.
.SS "An imperfect standard"
.IX Subsection "An imperfect standard"
Internationalization, as defined in the C and \s-1POSIX\s0 standards, can be
criticized as incomplete, ungainly, and having too large a granularity.
(Locales apply to a whole process, when it would arguably be more useful
to have them apply to a single thread, window group, or whatever.)  They
also have a tendency, like standards groups, to divide the world into
nations, when we all know that the world can equally well be divided
into bankers, bikers, gamers, and so on.
.SH "Unicode and UTF\-8"
.IX Header "Unicode and UTF-8"
The support of Unicode is new starting from Perl version v5.6, and more fully
implemented in version v5.8 and later.  See perluniintro.  It is
strongly recommended that when combining Unicode and locale (starting in
v5.16), you use
.PP
.Vb 1
\&    use locale \*(Aq:not_characters\*(Aq;
.Ve
.PP
When this form of the pragma is used, only the non-character portions of
locales are used by Perl, for example \f(CW\*(C`LC_NUMERIC\*(C'\fR.  Perl assumes that
you have translated all the characters it is to operate on into Unicode
(actually the platform's native character set (\s-1ASCII\s0 or \s-1EBCDIC\s0) plus
Unicode).  For data in files, this can conveniently be done by also
specifying
.PP
.Vb 1
\&    use open \*(Aq:locale\*(Aq;
.Ve
.PP
This pragma arranges for all inputs from files to be translated into
Unicode from the current locale as specified in the environment (see
\&\*(L"\s-1ENVIRONMENT\s0\*(R"), and all outputs to files to be translated back
into the locale.  (See open).  On a per-filehandle basis, you can
instead use the PerlIO::locale module, or the Encode::Locale
module, both available from \s-1CPAN\s0.  The latter module also has methods to
ease the handling of \f(CW\*(C`ARGV\*(C'\fR and environment variables, and can be used
on individual strings.  Also, if you know that all your locales will be
\&\s-1UTF\-8\s0, as many are these days, you can use the \fB\-C\fR
command line switch.
.PP
This form of the pragma allows essentially seamless handling of locales
with Unicode.  The collation order will be Unicode's.  It is strongly
recommended that when you need to order and sort strings that you use
the standard module Unicode::Collate which gives much better results
in many instances than you can get with the old-style locale handling.
.PP
For pre\-v5.16 Perls, or if you use the locale pragma without the
\&\f(CW\*(C`:not_characters\*(C'\fR parameter, Perl tries to work with both Unicode and
locales\*(--but there are problems.
.PP
Perl does not handle multi-byte locales in this case, such as have been
used for various
Asian languages, such as Big5 or Shift \s-1JIS\s0.  However, the increasingly
common multi-byte \s-1UTF\-8\s0 locales, if properly implemented, may work
reasonably well (depending on your C library implementation) in this
form of the locale pragma, simply because both
they and Perl store characters that take up multiple bytes the same way.
However, some, if not most, C library implementations may not process
the characters in the upper half of the Latin\-1 range (128 \- 255)
properly under \s-1LC_CTYPE\s0.  To see if a character is a particular type
under a locale, Perl uses the functions like \f(CW\*(C`isalnum()\*(C'\fR.  Your C
library may not work for \s-1UTF\-8\s0 locales with those functions, instead
only working under the newer wide library functions like \f(CW\*(C`iswalnum()\*(C'\fR.
.PP
Perl generally takes the tack to use locale rules on code points that can fit
in a single byte, and Unicode rules for those that can't (though this
isn't uniformly applied, see the note at the end of this section).  This
prevents many problems in locales that aren't \s-1UTF\-8\s0.  Suppose the locale
is \s-1ISO8859\-7\s0, Greek.  The character at 0xD7 there is a capital Chi. But
in the \s-1ISO8859\-1\s0 locale, Latin1, it is a multiplication sign.  The \s-1POSIX\s0
regular expression character class \f(CW\*(C`[[:alpha:]]\*(C'\fR will magically match
0xD7 in the Greek locale but not in the Latin one.
.PP
However, there are places where this breaks down.  Certain constructs are
for Unicode only, such as \f(CW\*(C`\ep{Alpha}\*(C'\fR.  They assume that 0xD7 always has its
Unicode meaning (or the equivalent on \s-1EBCDIC\s0 platforms).  Since Latin1 is a
subset of Unicode and 0xD7 is the multiplication sign in both Latin1 and
Unicode, \f(CW\*(C`\ep{Alpha}\*(C'\fR will never match it, regardless of locale.  A similar
issue occurs with \f(CW\*(C`\eN{...}\*(C'\fR.  It is therefore a bad idea to use \f(CW\*(C`\ep{}\*(C'\fR or
\&\f(CW\*(C`\eN{}\*(C'\fR under plain \f(CW\*(C`use locale\*(C'\fR\-\-\fIunless\fR you can guarantee that the
locale will be a \s-1ISO8859\-1\s0.  Use \s-1POSIX\s0 character classes instead.
.PP
Another problem with this approach is that operations that cross the
single byte/multiple byte boundary are not well-defined, and so are
disallowed.  (This boundary is between the codepoints at 255/256.).
For example, lower casing \s-1LATIN\s0 \s-1CAPITAL\s0 \s-1LETTER\s0 Y \s-1WITH\s0 \s-1DIAERESIS\s0 (U+0178)
should return \s-1LATIN\s0 \s-1SMALL\s0 \s-1LETTER\s0 Y \s-1WITH\s0 \s-1DIAERESIS\s0 (U+00FF).  But in the
Greek locale, for example, there is no character at 0xFF, and Perl
has no way of knowing what the character at 0xFF is really supposed to
represent.  Thus it disallows the operation.  In this mode, the
lowercase of U+0178 is itself.
.PP
The same problems ensue if you enable automatic UTF\-8\-ification of your
standard file handles, default \f(CW\*(C`open()\*(C'\fR layer, and \f(CW@ARGV\fR on non\-ISO8859\-1,
non\-UTF\-8 locales (by using either the \fB\-C\fR command line switch or the
\&\f(CW\*(C`PERL_UNICODE\*(C'\fR environment variable; see perlrun).
Things are read in as \s-1UTF\-8\s0, which would normally imply a Unicode
interpretation, but the presence of a locale causes them to be interpreted
in that locale instead.  For example, a 0xD7 code point in the Unicode
input, which should mean the multiplication sign, won't be interpreted by
Perl that way under the Greek locale.  This is not a problem
\&\fIprovided\fR you make certain that all locales will always and only be either
an \s-1ISO8859\-1\s0, or, if you don't have a deficient C library, a \s-1UTF\-8\s0 locale.
.PP
Vendor locales are notoriously buggy, and it is difficult for Perl to test
its locale-handling code because this interacts with code that Perl has no
control over; therefore the locale-handling code in Perl may be buggy as
well.  (However, the Unicode-supplied locales should be better, and
there is a feed back mechanism to correct any problems.  See
\&\*(L"Freely available locale definitions\*(R".)
.PP
If you have Perl v5.16, the problems mentioned above go away if you use
the \f(CW\*(C`:not_characters\*(C'\fR parameter to the locale pragma (except for vendor
bugs in the non-character portions).  If you don't have v5.16, and you
\&\fIdo\fR have locales that work, using them may be worthwhile for certain
specific purposes, as long as you keep in mind the gotchas already
mentioned.  For example, if the collation for your locales works, it
runs faster under locales than under Unicode::Collate; and you gain
access to such things as the local currency symbol and the names of the
months and days of the week.  (But to hammer home the point, in v5.16,
you get this access without the downsides of locales by using the
\&\f(CW\*(C`:not_characters\*(C'\fR form of the pragma.)
.PP
Note: The policy of using locale rules for code points that can fit in a
byte, and Unicode rules for those that can't is not uniformly applied.
Pre\-v5.12, it was somewhat haphazard; in v5.12 it was applied fairly
consistently to regular expression matching except for bracketed
character classes; in v5.14 it was extended to all regex matches; and in
v5.16 to the casing operations such as \f(CW"\eL"\fR and \f(CW\*(C`uc()\*(C'\fR.  For
collation, in all releases, the system's \f(CW\*(C`strxfrm()\*(C'\fR function is called,
and whatever it does is what you get.
.SH "BUGS"
.IX Header "BUGS"
.SS "Broken systems"
.IX Subsection "Broken systems"
In certain systems, the operating system's locale support
is broken and cannot be fixed or used by Perl.  Such deficiencies can
and will result in mysterious hangs and/or Perl core dumps when
\&\f(CW\*(C`use locale\*(C'\fR is in effect.  When confronted with such a system,
please report in excruciating detail to <\fIperlbug@perl.org\fR>, and
also contact your vendor: bug fixes may exist for these problems
in your operating system.  Sometimes such bug fixes are called an
operating system upgrade.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
I18N::Langinfo, perluniintro, perlunicode, open,
\&\*(L"isalnum\*(R" in \s-1POSIX\s0, \*(L"isalpha\*(R" in \s-1POSIX\s0,
\&\*(L"isdigit\*(R" in \s-1POSIX\s0, \*(L"isgraph\*(R" in \s-1POSIX\s0, \*(L"islower\*(R" in \s-1POSIX\s0,
\&\*(L"isprint\*(R" in \s-1POSIX\s0, \*(L"ispunct\*(R" in \s-1POSIX\s0, \*(L"isspace\*(R" in \s-1POSIX\s0,
\&\*(L"isupper\*(R" in \s-1POSIX\s0, \*(L"isxdigit\*(R" in \s-1POSIX\s0, \*(L"localeconv\*(R" in \s-1POSIX\s0,
\&\*(L"setlocale\*(R" in \s-1POSIX\s0, \*(L"strcoll\*(R" in \s-1POSIX\s0, \*(L"strftime\*(R" in \s-1POSIX\s0,
\&\*(L"strtod\*(R" in \s-1POSIX\s0, \*(L"strxfrm\*(R" in \s-1POSIX\s0.
.SH "HISTORY"
.IX Header "HISTORY"
Jarkko Hietaniemi's original \fIperli18n.pod\fR heavily hacked by Dominic
Dunlop, assisted by the perl5\-porters.  Prose worked over a bit by
Tom Christiansen, and updated by Perl 5 porters.
