// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 5.6 (swiftlang-5.6.0.323.32 clang-1316.0.20.8)
// swift-module-flags: -target arm64e-apple-macos12.3 -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -O -library-level api -enable-experimental-concurrency -module-name MusicKit
// swift-module-flags-ignorable: -user-module-version 4019.500.27
import Combine
import CoreGraphics
import Foundation
import Swift
import _Concurrency
@available(iOS 15.0, tvOS 15.0, *)
@available(macOS, unavailable)
@available(watchOS, unavailable)
extension MusicKit.MusicPlayer {
  public class Queue : Combine.ObservableObject, Swift.ExpressibleByArrayLiteral {
    required public init<S, PlayableMusicItemType>(for playableItems: S, startingAt startPlayableItem: S.Element? = nil) where S : Swift.Sequence, PlayableMusicItemType : MusicKit.PlayableMusicItem, PlayableMusicItemType == S.Element
    required public init<S>(_ entries: S, startingAt startEntry: S.Element? = nil) where S : Swift.Sequence, S.Element == MusicKit.MusicPlayer.Queue.Entry
    public var currentEntry: MusicKit.MusicPlayer.Queue.Entry? {
      get
      set
    }
    
    #if compiler(>=5.3) && $AsyncAwait
    public func insert<S, PlayableMusicItemType>(_ playableItems: S, position: MusicKit.MusicPlayer.Queue.EntryInsertionPosition) async throws where S : Swift.Sequence, PlayableMusicItemType : MusicKit.PlayableMusicItem, PlayableMusicItemType == S.Element
    #endif

    
    #if compiler(>=5.3) && $AsyncAwait
    public func insert<S>(_ entries: S, position: MusicKit.MusicPlayer.Queue.EntryInsertionPosition) async throws where S : Swift.Sequence, S.Element == MusicKit.MusicPlayer.Queue.Entry
    #endif

    
    #if compiler(>=5.3) && $AsyncAwait
    public func insert<PlayableMusicItemType>(_ playableItem: PlayableMusicItemType, position: MusicKit.MusicPlayer.Queue.EntryInsertionPosition) async throws where PlayableMusicItemType : MusicKit.PlayableMusicItem
    #endif

    
    #if compiler(>=5.3) && $AsyncAwait
    public func insert(_ entry: MusicKit.MusicPlayer.Queue.Entry, position: MusicKit.MusicPlayer.Queue.EntryInsertionPosition) async throws
    #endif

    public var objectWillChange: Combine.AnyPublisher<Swift.Void, Swift.Never> {
      get
    }
    convenience required public init(arrayLiteral elements: MusicKit.PlayableMusicItem...)
    public typealias ArrayLiteralElement = MusicKit.PlayableMusicItem
    public typealias ObjectWillChangePublisher = Combine.AnyPublisher<Swift.Void, Swift.Never>
    @objc deinit
  }
}
@available(iOS 15.0, tvOS 15.0, *)
@available(macOS, unavailable)
@available(watchOS, unavailable)
extension MusicKit.MusicPlayer.Queue : Swift.Equatable {
  public static func == (left: MusicKit.MusicPlayer.Queue, right: MusicKit.MusicPlayer.Queue) -> Swift.Bool
}
@available(iOS 15.0, tvOS 15.0, *)
@available(macOS, unavailable)
@available(watchOS, unavailable)
extension MusicKit.MusicPlayer.Queue : Swift.Hashable {
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@available(iOS 15.0, tvOS 15.0, *)
@available(macOS, unavailable)
@available(watchOS, unavailable)
extension MusicKit.MusicPlayer.Queue {
  public enum EntryInsertionPosition {
    case afterCurrentEntry
    case tail
    public static func == (a: MusicKit.MusicPlayer.Queue.EntryInsertionPosition, b: MusicKit.MusicPlayer.Queue.EntryInsertionPosition) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
public struct MusicCatalogResourceRequest<MusicItemType> where MusicItemType : MusicKit.MusicItem, MusicItemType : Swift.Decodable {
  public init<Value>(matching keyPath: Swift.KeyPath<MusicItemType.FilterType, Value>, equalTo value: Value) where MusicItemType : MusicKit.FilterableMusicItem
  public init<Value>(matching keyPath: Swift.KeyPath<MusicItemType.FilterType, Value>, memberOf values: [Value]) where MusicItemType : MusicKit.FilterableMusicItem
  public var limit: Swift.Int?
  public var properties: [MusicKit.PartialMusicAsyncProperty<MusicItemType>]
  
  #if compiler(>=5.3) && $AsyncAwait
  public func response() async throws -> MusicKit.MusicCatalogResourceResponse<MusicItemType>
  #endif

}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
extension MusicKit.MusicItem where Self : MusicKit.MusicPropertyContainer, Self : Swift.Decodable {
  
  #if compiler(>=5.3) && $AsyncAwait
  public func with(_ properties: [MusicKit.PartialMusicAsyncProperty<Self>]) async throws -> Self
  #endif

}
@available(iOS 15.4, macOS 12.3, tvOS 15.4, *)
@available(watchOS, unavailable)
public struct Curator : MusicKit.MusicItem, Swift.Equatable, Swift.Hashable, Swift.Identifiable {
  public let id: MusicKit.MusicItemID
  public var artwork: MusicKit.Artwork? {
    get
  }
  public var editorialNotes: MusicKit.EditorialNotes? {
    get
  }
  public var kind: MusicKit.Curator.Kind {
    get
  }
  public var name: Swift.String {
    get
  }
  public var url: Foundation.URL? {
    get
  }
  public var playlists: MusicKit.MusicItemCollection<MusicKit.Playlist>? {
    get
  }
  public static func == (a: MusicKit.Curator, b: MusicKit.Curator) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public typealias ID = MusicKit.MusicItemID
  public var hashValue: Swift.Int {
    get
  }
}
@available(iOS 15.4, macOS 12.3, tvOS 15.4, *)
@available(watchOS, unavailable)
extension MusicKit.Curator : MusicKit.MusicPropertyContainer {
  
  #if compiler(>=5.3) && $EffectfulProp
  @usableFromInline
  internal subscript<Value>(property property: MusicKit.MusicAttributeProperty<MusicKit.Curator, Value>) -> Value? where Value : Swift.Decodable {
    get throws
  }
  #endif

  
  #if compiler(>=5.3) && $EffectfulProp
  @usableFromInline
  internal subscript<Value>(property property: MusicKit.MusicExtendedAttributeProperty<MusicKit.Curator, Value>) -> Value? where Value : Swift.Decodable {
    get throws
  }
  #endif

  
  #if compiler(>=5.3) && $EffectfulProp
  @usableFromInline
  internal subscript<RelatedMusicItemType>(property property: MusicKit.MusicRelationshipProperty<MusicKit.Curator, RelatedMusicItemType>) -> MusicKit.MusicItemCollection<RelatedMusicItemType>? where RelatedMusicItemType : MusicKit.MusicItem, RelatedMusicItemType : Swift.Decodable {
    get throws
  }
  #endif

}
@available(iOS 15.4, macOS 12.3, tvOS 15.4, *)
@available(watchOS, unavailable)
extension MusicKit.PartialMusicProperty where Root == MusicKit.Curator {
  public static let playlists: MusicKit.MusicRelationshipProperty<MusicKit.Curator, MusicKit.Playlist>
}
@available(iOS 15.4, macOS 12.3, tvOS 15.4, *)
@available(watchOS, unavailable)
public protocol CuratorFilter {
  var id: MusicKit.MusicItemID { get }
}
@available(iOS 15.4, macOS 12.3, tvOS 15.4, *)
@available(watchOS, unavailable)
extension MusicKit.Curator : MusicKit.FilterableMusicItem {
  public typealias FilterType = MusicKit.CuratorFilter
}
@available(iOS 15.4, macOS 12.3, tvOS 15.4, *)
@available(watchOS, unavailable)
extension MusicKit.Curator : Swift.Codable {
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
@available(iOS 15.4, macOS 12.3, tvOS 15.4, *)
@available(watchOS, unavailable)
extension MusicKit.Curator : Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible {
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
}
@available(iOS 15.4, macOS 12.3, tvOS 15.4, *)
@available(watchOS, unavailable)
extension MusicKit.Curator {
  public enum Kind : Swift.Codable, Swift.Equatable, Swift.Hashable {
    case editorial
    case external
    public static func == (a: MusicKit.Curator.Kind, b: MusicKit.Curator.Kind) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public func encode(to encoder: Swift.Encoder) throws
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: Swift.Decoder) throws
  }
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
public protocol FilterableMusicItem : MusicKit.MusicItem {
  associatedtype FilterType
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
public struct MusicDataRequest : Swift.Equatable, Swift.Hashable {
  public init(urlRequest: Foundation.URLRequest)
  public let urlRequest: Foundation.URLRequest
  
  #if compiler(>=5.3) && $AsyncAwait
  public func response() async throws -> MusicKit.MusicDataResponse
  #endif

  
  #if compiler(>=5.3) && $EffectfulProp
  public static var currentCountryCode: Swift.String {
    get async throws
  }
  #endif

  public static func == (a: MusicKit.MusicDataRequest, b: MusicKit.MusicDataRequest) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
extension MusicKit.MusicDataRequest : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
@available(iOS 15.0, tvOS 15.0, *)
@available(macOS, unavailable)
@available(watchOS, unavailable)
extension MusicKit.MusicPlayer {
  public enum PlaybackStatus : Swift.Equatable, Swift.Hashable {
    case stopped
    case playing
    case paused
    case interrupted
    case seekingForward
    case seekingBackward
    public static func == (a: MusicKit.MusicPlayer.PlaybackStatus, b: MusicKit.MusicPlayer.PlaybackStatus) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
}
@available(iOS 15.0, tvOS 15.0, *)
@available(macOS, unavailable)
@available(watchOS, unavailable)
extension MusicKit.MusicPlayer {
  public enum RepeatMode {
    case none
    case one
    case all
    public static func == (a: MusicKit.MusicPlayer.RepeatMode, b: MusicKit.MusicPlayer.RepeatMode) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
}
@available(iOS 15.0, tvOS 15.0, *)
@available(macOS, unavailable)
@available(watchOS, unavailable)
extension MusicKit.MusicPlayer {
  public enum ShuffleMode {
    case off
    case songs
    public static func == (a: MusicKit.MusicPlayer.ShuffleMode, b: MusicKit.MusicPlayer.ShuffleMode) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
}
@available(iOS 15.0, tvOS 15.0, *)
@available(macOS, unavailable)
@available(watchOS, unavailable)
extension MusicKit.MusicPlayer {
  @_hasMissingDesignatedInitializers public class State : Combine.ObservableObject {
    public var playbackStatus: MusicKit.MusicPlayer.PlaybackStatus {
      get
    }
    public var playbackRate: Swift.Float {
      get
      set
    }
    public var repeatMode: MusicKit.MusicPlayer.RepeatMode? {
      get
      set
    }
    public var shuffleMode: MusicKit.MusicPlayer.ShuffleMode? {
      get
      set
    }
    public var objectWillChange: Combine.AnyPublisher<Swift.Void, Swift.Never> {
      get
    }
    public typealias ObjectWillChangePublisher = Combine.AnyPublisher<Swift.Void, Swift.Never>
    @objc deinit
  }
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
public struct Station : MusicKit.MusicItem, Swift.Equatable, Swift.Hashable, Swift.Identifiable {
  public let id: MusicKit.MusicItemID
  public var artwork: MusicKit.Artwork? {
    get
  }
  public var contentRating: MusicKit.ContentRating? {
    get
  }
  public var duration: Foundation.TimeInterval? {
    get
  }
  public var editorialNotes: MusicKit.EditorialNotes? {
    get
  }
  public var episodeNumber: Swift.Int? {
    get
  }
  public var isLive: Swift.Bool {
    get
  }
  public var name: Swift.String {
    get
  }
  public var playParameters: MusicKit.PlayParameters? {
    get
  }
  public var stationProviderName: Swift.String? {
    get
  }
  public var url: Foundation.URL? {
    get
  }
  public static func == (a: MusicKit.Station, b: MusicKit.Station) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public typealias ID = MusicKit.MusicItemID
  public var hashValue: Swift.Int {
    get
  }
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
extension MusicKit.Station : MusicKit.MusicPropertyContainer {
  
  #if compiler(>=5.3) && $EffectfulProp
  @usableFromInline
  internal subscript<Value>(property property: MusicKit.MusicAttributeProperty<MusicKit.Station, Value>) -> Value? where Value : Swift.Decodable {
    get throws
  }
  #endif

  
  #if compiler(>=5.3) && $EffectfulProp
  @usableFromInline
  internal subscript<Value>(property property: MusicKit.MusicExtendedAttributeProperty<MusicKit.Station, Value>) -> Value? where Value : Swift.Decodable {
    get throws
  }
  #endif

  
  #if compiler(>=5.3) && $EffectfulProp
  @usableFromInline
  internal subscript<RelatedMusicItemType>(property property: MusicKit.MusicRelationshipProperty<MusicKit.Station, RelatedMusicItemType>) -> MusicKit.MusicItemCollection<RelatedMusicItemType>? where RelatedMusicItemType : MusicKit.MusicItem, RelatedMusicItemType : Swift.Decodable {
    get throws
  }
  #endif

}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
public protocol StationFilter {
  var id: MusicKit.MusicItemID { get }
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
extension MusicKit.Station : MusicKit.FilterableMusicItem {
  public typealias FilterType = MusicKit.StationFilter
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
extension MusicKit.Station : Swift.Codable {
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
extension MusicKit.Station : Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible {
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
public struct RecordLabel : MusicKit.MusicItem, Swift.Equatable, Swift.Hashable, Swift.Identifiable {
  public let id: MusicKit.MusicItemID
  public var artwork: MusicKit.Artwork? {
    get
  }
  public var shortDescription: Swift.String? {
    get
  }
  public var standardDescription: Swift.String? {
    get
  }
  public var name: Swift.String {
    get
  }
  public var url: Foundation.URL? {
    get
  }
  public var latestReleases: MusicKit.MusicItemCollection<MusicKit.Album>? {
    get
  }
  public var topReleases: MusicKit.MusicItemCollection<MusicKit.Album>? {
    get
  }
  public static func == (a: MusicKit.RecordLabel, b: MusicKit.RecordLabel) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public typealias ID = MusicKit.MusicItemID
  public var hashValue: Swift.Int {
    get
  }
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
extension MusicKit.RecordLabel : MusicKit.MusicPropertyContainer {
  
  #if compiler(>=5.3) && $EffectfulProp
  @usableFromInline
  internal subscript<Value>(property property: MusicKit.MusicAttributeProperty<MusicKit.RecordLabel, Value>) -> Value? where Value : Swift.Decodable {
    get throws
  }
  #endif

  
  #if compiler(>=5.3) && $EffectfulProp
  @usableFromInline
  internal subscript<Value>(property property: MusicKit.MusicExtendedAttributeProperty<MusicKit.RecordLabel, Value>) -> Value? where Value : Swift.Decodable {
    get throws
  }
  #endif

  
  #if compiler(>=5.3) && $EffectfulProp
  @usableFromInline
  internal subscript<RelatedMusicItemType>(property property: MusicKit.MusicRelationshipProperty<MusicKit.RecordLabel, RelatedMusicItemType>) -> MusicKit.MusicItemCollection<RelatedMusicItemType>? where RelatedMusicItemType : MusicKit.MusicItem, RelatedMusicItemType : Swift.Decodable {
    get throws
  }
  #endif

}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
public protocol RecordLabelFilter {
  var id: MusicKit.MusicItemID { get }
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
extension MusicKit.RecordLabel : MusicKit.FilterableMusicItem {
  public typealias FilterType = MusicKit.RecordLabelFilter
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
extension MusicKit.RecordLabel : Swift.Codable {
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
extension MusicKit.RecordLabel : Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible {
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
public enum ContentRating : Swift.Codable, Swift.Equatable, Swift.Hashable {
  case clean
  case explicit
  public static func == (a: MusicKit.ContentRating, b: MusicKit.ContentRating) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public func encode(to encoder: Swift.Encoder) throws
  public var hashValue: Swift.Int {
    get
  }
  public init(from decoder: Swift.Decoder) throws
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
public protocol MusicItem {
  var id: MusicKit.MusicItemID { get }
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
public struct MusicAuthorization {
  public static var currentStatus: MusicKit.MusicAuthorization.Status {
    get
  }
  
  #if compiler(>=5.3) && $AsyncAwait
  public static func request() async -> MusicKit.MusicAuthorization.Status
  #endif

}
@_hasMissingDesignatedInitializers @available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
public class AnyMusicProperty : Swift.Equatable, Swift.Hashable {
  public static func == (left: MusicKit.AnyMusicProperty, right: MusicKit.AnyMusicProperty) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  @objc deinit
  public var hashValue: Swift.Int {
    get
  }
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers @available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
public class PartialMusicProperty<Root> : MusicKit.AnyMusicProperty {
  @objc deinit
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers @available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
public class PartialMusicAsyncProperty<Root> : MusicKit.PartialMusicProperty<Root> {
  @objc deinit
}
@_hasMissingDesignatedInitializers @available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
public class MusicAttributeProperty<Root, Value> : MusicKit.PartialMusicProperty<Root>, Swift.CustomStringConvertible where Value : Swift.Decodable {
  @usableFromInline
  internal init(_ name: Swift.String)
  public var description: Swift.String {
    get
  }
  @objc deinit
}
@_hasMissingDesignatedInitializers @available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
public class MusicExtendedAttributeProperty<Root, Value> : MusicKit.PartialMusicAsyncProperty<Root>, Swift.CustomStringConvertible where Value : Swift.Decodable {
  @usableFromInline
  internal init(_ name: Swift.String)
  public var description: Swift.String {
    get
  }
  @objc deinit
}
@_hasMissingDesignatedInitializers @available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
public class MusicRelationshipProperty<Root, RelatedMusicItemType> : MusicKit.PartialMusicAsyncProperty<Root>, Swift.CustomStringConvertible where RelatedMusicItemType : MusicKit.MusicItem, RelatedMusicItemType : Swift.Decodable {
  @usableFromInline
  internal init(_ name: Swift.String, kind: MusicKit.MusicRelationshipPropertyKind = .model)
  @usableFromInline
  final internal let kind: MusicKit.MusicRelationshipPropertyKind
  public var description: Swift.String {
    get
  }
  @objc deinit
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
@usableFromInline
internal enum MusicRelationshipPropertyKind {
  case model
  case association
  @usableFromInline
  internal static func == (a: MusicKit.MusicRelationshipPropertyKind, b: MusicKit.MusicRelationshipPropertyKind) -> Swift.Bool
  @usableFromInline
  internal func hash(into hasher: inout Swift.Hasher)
  @usableFromInline
  internal var hashValue: Swift.Int {
    @usableFromInline
    get
  }
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
public protocol MusicPropertyContainer {
  
  #if compiler(>=5.3) && $AsyncAwait
  func with(_ properties: [MusicKit.PartialMusicAsyncProperty<Self>]) async throws -> Self
  #endif

}
@available(iOS 15.0, tvOS 15.0, *)
@available(macOS, unavailable)
@available(watchOS, unavailable)
public protocol PlayableMusicItem : MusicKit.MusicItem {
  var playParameters: MusicKit.PlayParameters? { get }
}
@available(iOS 15.0, tvOS 15.0, *)
@available(macOS, unavailable)
@available(watchOS, unavailable)
extension MusicKit.Album : MusicKit.PlayableMusicItem {
}
@available(iOS 15.0, tvOS 15.0, *)
@available(macOS, unavailable)
@available(watchOS, unavailable)
extension MusicKit.Playlist : MusicKit.PlayableMusicItem {
}
@available(iOS 15.0, tvOS 15.0, *)
@available(macOS, unavailable)
@available(watchOS, unavailable)
extension MusicKit.Song : MusicKit.PlayableMusicItem {
}
@available(iOS 15.0, tvOS 15.0, *)
@available(macOS, unavailable)
@available(watchOS, unavailable)
extension MusicKit.Station : MusicKit.PlayableMusicItem {
}
@available(iOS 15.0, tvOS 15.0, *)
@available(macOS, unavailable)
@available(watchOS, unavailable)
extension MusicKit.Track : MusicKit.PlayableMusicItem {
}
@available(iOS 15.0, tvOS 15.0, *)
@available(macOS, unavailable)
@available(watchOS, unavailable)
extension MusicKit.MusicPlayer.Queue.Entry.Item : MusicKit.PlayableMusicItem {
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
extension MusicKit.MusicSubscription {
  
  #if compiler(>=5.3) && $RethrowsProtocol
  public struct Updates : _Concurrency.AsyncSequence {
    public struct Iterator : _Concurrency.AsyncIteratorProtocol {
      
      #if compiler(>=5.3) && $AsyncAwait
      public mutating func next() async -> MusicKit.MusicSubscription?
      #endif

      public typealias Element = MusicKit.MusicSubscription
    }
    public typealias Element = MusicKit.MusicSubscription
    public func makeAsyncIterator() -> MusicKit.MusicSubscription.Updates.Iterator
    public typealias AsyncIterator = MusicKit.MusicSubscription.Updates.Iterator
  }
  #endif

  
  #if compiler(>=5.3) && $RethrowsProtocol
  public static var subscriptionUpdates: MusicKit.MusicSubscription.Updates {
    get
  }
  #endif

}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
public struct MusicTokenRequestOptions : Swift.OptionSet {
  public init(rawValue: Swift.Int)
  public let rawValue: Swift.Int
  public static let ignoreCache: MusicKit.MusicTokenRequestOptions
  public typealias ArrayLiteralElement = MusicKit.MusicTokenRequestOptions
  public typealias Element = MusicKit.MusicTokenRequestOptions
  public typealias RawValue = Swift.Int
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
public protocol MusicDeveloperTokenProvider {
  
  #if compiler(>=5.3) && $AsyncAwait
  func developerToken(options: MusicKit.MusicTokenRequestOptions) async throws -> Swift.String
  #endif

}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
public typealias MusicTokenProvider = MusicKit.MusicUserTokenProvider & MusicKit.MusicDeveloperTokenProvider
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
extension MusicKit.MusicDataRequest {
  public static var tokenProvider: MusicKit.MusicTokenProvider
}
@available(iOS 15.4, macOS 12.3, tvOS 15.4, *)
@available(watchOS, unavailable)
public struct RadioShow : MusicKit.MusicItem, Swift.Equatable, Swift.Hashable, Swift.Identifiable {
  public let id: MusicKit.MusicItemID
  public var artwork: MusicKit.Artwork? {
    get
  }
  public var editorialNotes: MusicKit.EditorialNotes? {
    get
  }
  public var hostName: Swift.String? {
    get
  }
  public var name: Swift.String {
    get
  }
  public var url: Foundation.URL? {
    get
  }
  public var playlists: MusicKit.MusicItemCollection<MusicKit.Playlist>? {
    get
  }
  public static func == (a: MusicKit.RadioShow, b: MusicKit.RadioShow) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public typealias ID = MusicKit.MusicItemID
  public var hashValue: Swift.Int {
    get
  }
}
@available(iOS 15.4, macOS 12.3, tvOS 15.4, *)
@available(watchOS, unavailable)
extension MusicKit.RadioShow : MusicKit.MusicPropertyContainer {
  
  #if compiler(>=5.3) && $EffectfulProp
  @usableFromInline
  internal subscript<Value>(property property: MusicKit.MusicAttributeProperty<MusicKit.RadioShow, Value>) -> Value? where Value : Swift.Decodable {
    get throws
  }
  #endif

  
  #if compiler(>=5.3) && $EffectfulProp
  @usableFromInline
  internal subscript<Value>(property property: MusicKit.MusicExtendedAttributeProperty<MusicKit.RadioShow, Value>) -> Value? where Value : Swift.Decodable {
    get throws
  }
  #endif

  
  #if compiler(>=5.3) && $EffectfulProp
  @usableFromInline
  internal subscript<RelatedMusicItemType>(property property: MusicKit.MusicRelationshipProperty<MusicKit.RadioShow, RelatedMusicItemType>) -> MusicKit.MusicItemCollection<RelatedMusicItemType>? where RelatedMusicItemType : MusicKit.MusicItem, RelatedMusicItemType : Swift.Decodable {
    get throws
  }
  #endif

}
@available(iOS 15.4, macOS 12.3, tvOS 15.4, *)
@available(watchOS, unavailable)
extension MusicKit.PartialMusicProperty where Root == MusicKit.RadioShow {
  public static let playlists: MusicKit.MusicRelationshipProperty<MusicKit.RadioShow, MusicKit.Playlist>
}
@available(iOS 15.4, macOS 12.3, tvOS 15.4, *)
@available(watchOS, unavailable)
public protocol RadioShowFilter {
  var id: MusicKit.MusicItemID { get }
}
@available(iOS 15.4, macOS 12.3, tvOS 15.4, *)
@available(watchOS, unavailable)
extension MusicKit.RadioShow : MusicKit.FilterableMusicItem {
  public typealias FilterType = MusicKit.RadioShowFilter
}
@available(iOS 15.4, macOS 12.3, tvOS 15.4, *)
@available(watchOS, unavailable)
extension MusicKit.RadioShow : Swift.Codable {
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
@available(iOS 15.4, macOS 12.3, tvOS 15.4, *)
@available(watchOS, unavailable)
extension MusicKit.RadioShow : Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible {
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
extension MusicKit.MusicSubscription {
  public enum Error : Swift.String, Foundation.LocalizedError {
    case unknown
    case permissionDenied
    case privacyAcknowledgementRequired
    public var errorDescription: Swift.String? {
      get
    }
    public var failureReason: Swift.String? {
      get
    }
    public var recoverySuggestion: Swift.String? {
      get
    }
    public var helpAnchor: Swift.String? {
      get
    }
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
extension MusicKit.MusicSubscription.Error : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
open class MusicUserTokenProvider {
  public init()
  
  #if compiler(>=5.3) && $AsyncAwait
  public func userToken(for developerToken: Swift.String, options: MusicKit.MusicTokenRequestOptions) async throws -> Swift.String
  #endif

  @objc deinit
}
@_inheritsConvenienceInitializers @available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
public class DefaultMusicTokenProvider : MusicKit.MusicTokenProvider {
  
  #if compiler(>=5.3) && $AsyncAwait
  public func developerToken(options: MusicKit.MusicTokenRequestOptions) async throws -> Swift.String
  #endif

  override public init()
  @objc deinit
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
extension MusicKit.MusicAuthorization {
  public enum Status : Swift.String {
    case notDetermined
    case denied
    case restricted
    case authorized
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
extension MusicKit.MusicAuthorization.Status : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
public struct MusicDataResponse : Swift.Equatable, Swift.Hashable {
  public let data: Foundation.Data
  public let urlResponse: Foundation.HTTPURLResponse
  public static func == (a: MusicKit.MusicDataResponse, b: MusicKit.MusicDataResponse) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
extension MusicKit.MusicDataResponse : Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible {
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
}
@available(iOS 15.0, tvOS 15.0, *)
@available(macOS, unavailable)
@available(watchOS, unavailable)
extension MusicKit.MusicPlayer.Queue {
  public struct Entry : Swift.Equatable, Swift.Hashable, Swift.Identifiable, Swift.CustomStringConvertible {
    public init(_ playableMusicItem: MusicKit.PlayableMusicItem, startTime: Foundation.TimeInterval? = nil, endTime: Foundation.TimeInterval? = nil)
    public let id: Swift.String
    public var title: Swift.String {
      get
    }
    public var subtitle: Swift.String? {
      get
    }
    public var artwork: MusicKit.Artwork? {
      get
    }
    public var item: MusicKit.MusicPlayer.Queue.Entry.Item? {
      get
    }
    public var transientItem: MusicKit.PlayableMusicItem? {
      get
    }
    public var isTransient: Swift.Bool {
      get
    }
    public var startTime: Foundation.TimeInterval? {
      get
    }
    public var endTime: Foundation.TimeInterval? {
      get
    }
    public var description: Swift.String {
      get
    }
    public static func == (a: MusicKit.MusicPlayer.Queue.Entry, b: MusicKit.MusicPlayer.Queue.Entry) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public typealias ID = Swift.String
    public var hashValue: Swift.Int {
      get
    }
  }
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
public enum Track : MusicKit.MusicItem, Swift.Equatable, Swift.Hashable, Swift.Identifiable {
  case song(MusicKit.Song)
  case musicVideo(MusicKit.MusicVideo)
  public var id: MusicKit.MusicItemID {
    get
  }
  public var artwork: MusicKit.Artwork? {
    get
  }
  public var albumTitle: Swift.String? {
    get
  }
  public var artistName: Swift.String {
    get
  }
  public var artistURL: Foundation.URL? {
    get
  }
  public var contentRating: MusicKit.ContentRating? {
    get
  }
  public var duration: Foundation.TimeInterval? {
    get
  }
  public var editorialNotes: MusicKit.EditorialNotes? {
    get
  }
  public var genreNames: [Swift.String] {
    get
  }
  public var isrc: Swift.String? {
    get
  }
  public var playParameters: MusicKit.PlayParameters? {
    get
  }
  public var previewAssets: [MusicKit.PreviewAsset]? {
    get
  }
  public var releaseDate: Foundation.Date? {
    get
  }
  public var title: Swift.String {
    get
  }
  public var trackNumber: Swift.Int? {
    get
  }
  public var url: Foundation.URL? {
    get
  }
  public var workName: Swift.String? {
    get
  }
  public var albums: MusicKit.MusicItemCollection<MusicKit.Album>? {
    get
  }
  public var artists: MusicKit.MusicItemCollection<MusicKit.Artist>? {
    get
  }
  public var genres: MusicKit.MusicItemCollection<MusicKit.Genre>? {
    get
  }
  public static func == (a: MusicKit.Track, b: MusicKit.Track) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public typealias ID = MusicKit.MusicItemID
  public var hashValue: Swift.Int {
    get
  }
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
extension MusicKit.Track : MusicKit.MusicPropertyContainer {
  
  #if compiler(>=5.3) && $EffectfulProp
  @usableFromInline
  internal subscript<Value>(property property: MusicKit.MusicAttributeProperty<MusicKit.Track, Value>) -> Value? where Value : Swift.Decodable {
    get throws
  }
  #endif

  
  #if compiler(>=5.3) && $EffectfulProp
  @usableFromInline
  internal subscript<Value>(property property: MusicKit.MusicExtendedAttributeProperty<MusicKit.Track, Value>) -> Value? where Value : Swift.Decodable {
    get throws
  }
  #endif

  
  #if compiler(>=5.3) && $EffectfulProp
  @usableFromInline
  internal subscript<RelatedMusicItemType>(property property: MusicKit.MusicRelationshipProperty<MusicKit.Track, RelatedMusicItemType>) -> MusicKit.MusicItemCollection<RelatedMusicItemType>? where RelatedMusicItemType : MusicKit.MusicItem, RelatedMusicItemType : Swift.Decodable {
    get throws
  }
  #endif

}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
extension MusicKit.Track : Swift.Codable {
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
extension MusicKit.Track : Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible {
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
public struct Artwork : Swift.Equatable, Swift.Hashable {
  public let maximumWidth: Swift.Int
  public let maximumHeight: Swift.Int
  public let alternateText: Swift.String?
  public let backgroundColor: CoreGraphics.CGColor?
  public let primaryTextColor: CoreGraphics.CGColor?
  public let secondaryTextColor: CoreGraphics.CGColor?
  public let tertiaryTextColor: CoreGraphics.CGColor?
  public let quaternaryTextColor: CoreGraphics.CGColor?
  public func url(width: Swift.Int, height: Swift.Int) -> Foundation.URL?
  public static func == (a: MusicKit.Artwork, b: MusicKit.Artwork) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
extension MusicKit.Artwork : Swift.Codable {
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
extension MusicKit.Artwork : Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible {
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
public struct MusicCatalogSearchResponse : Swift.Equatable, Swift.Hashable {
  public let albums: MusicKit.MusicItemCollection<MusicKit.Album>
  public let artists: MusicKit.MusicItemCollection<MusicKit.Artist>
  @available(iOS 15.4, macOS 12.3, tvOS 15.4, *)
  @available(watchOS, unavailable)
  public let curators: MusicKit.MusicItemCollection<MusicKit.Curator>
  @available(iOS 15.4, macOS 12.3, tvOS 15.4, *)
  @available(watchOS, unavailable)
  public let musicVideos: MusicKit.MusicItemCollection<MusicKit.MusicVideo>
  public let playlists: MusicKit.MusicItemCollection<MusicKit.Playlist>
  @available(iOS 15.4, macOS 12.3, tvOS 15.4, *)
  @available(watchOS, unavailable)
  public let radioShows: MusicKit.MusicItemCollection<MusicKit.RadioShow>
  public let recordLabels: MusicKit.MusicItemCollection<MusicKit.RecordLabel>
  public let songs: MusicKit.MusicItemCollection<MusicKit.Song>
  public let stations: MusicKit.MusicItemCollection<MusicKit.Station>
  public static func == (a: MusicKit.MusicCatalogSearchResponse, b: MusicKit.MusicCatalogSearchResponse) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
extension MusicKit.MusicCatalogSearchResponse : Swift.Codable {
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
extension MusicKit.MusicCatalogSearchResponse : Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible {
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
public struct EditorialNotes : Swift.Equatable, Swift.Hashable {
  public let short: Swift.String?
  public let standard: Swift.String?
  public let name: Swift.String?
  public let tagline: Swift.String?
  public static func == (a: MusicKit.EditorialNotes, b: MusicKit.EditorialNotes) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
extension MusicKit.EditorialNotes : Swift.Codable {
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
extension MusicKit.EditorialNotes : Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible {
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers @available(iOS 15.0, tvOS 15.0, *)
@available(macOS, unavailable)
@available(watchOS, unavailable)
public class SystemMusicPlayer : MusicKit.MusicPlayer {
  public static let shared: MusicKit.SystemMusicPlayer
  public var queue: MusicKit.MusicPlayer.Queue {
    get
    set
  }
  @objc deinit
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
public struct PreviewAsset : Swift.Equatable, Swift.Hashable {
  public let artwork: MusicKit.Artwork?
  public let url: Foundation.URL?
  public let hlsURL: Foundation.URL?
  public static func == (a: MusicKit.PreviewAsset, b: MusicKit.PreviewAsset) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
extension MusicKit.PreviewAsset : Swift.Codable {
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
extension MusicKit.PreviewAsset : Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible {
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
}
@_hasMissingDesignatedInitializers @available(iOS 15.0, tvOS 15.0, *)
@available(macOS, unavailable)
@available(watchOS, unavailable)
public class MusicPlayer {
  final public let state: MusicKit.MusicPlayer.State
  public var isPreparedToPlay: Swift.Bool {
    get
  }
  
  #if compiler(>=5.3) && $AsyncAwait
  public func prepareToPlay() async throws
  #endif

  
  #if compiler(>=5.3) && $AsyncAwait
  public func play() async throws
  #endif

  public func pause()
  public func stop()
  public var playbackTime: Foundation.TimeInterval {
    get
    set
  }
  public func beginSeekingForward()
  public func beginSeekingBackward()
  public func endSeeking()
  
  #if compiler(>=5.3) && $AsyncAwait
  public func skipToNextEntry() async throws
  #endif

  public func restartCurrentEntry()
  
  #if compiler(>=5.3) && $AsyncAwait
  public func skipToPreviousEntry() async throws
  #endif

  @objc deinit
}
@available(iOS 15.0, tvOS 15.0, *)
@available(macOS, unavailable)
@available(watchOS, unavailable)
extension MusicKit.ApplicationMusicPlayer {
  @_inheritsConvenienceInitializers public class Queue : MusicKit.MusicPlayer.Queue {
    required public init<S, PlayableMusicItemType>(for playableItems: S, startingAt startPlayableItem: S.Element? = nil) where S : Swift.Sequence, PlayableMusicItemType : MusicKit.PlayableMusicItem, PlayableMusicItemType == S.Element
    required public init<S>(_ entries: S, startingAt startEntry: S.Element? = nil) where S : Swift.Sequence, S.Element == MusicKit.MusicPlayer.Queue.Entry
    required public init(arrayLiteral elements: MusicKit.PlayableMusicItem...)
    public var entries: MusicKit.ApplicationMusicPlayer.Queue.Entries {
      get
      set
    }
    public struct Entries : Swift.Equatable, Swift.Hashable, Swift.Sequence, Swift.Collection, Swift.BidirectionalCollection, Swift.RandomAccessCollection, Swift.MutableCollection, Swift.RangeReplaceableCollection, Swift.ExpressibleByArrayLiteral {
      public init()
      public static func == (left: MusicKit.ApplicationMusicPlayer.Queue.Entries, right: MusicKit.ApplicationMusicPlayer.Queue.Entries) -> Swift.Bool
      public func hash(into hasher: inout Swift.Hasher)
      public __consuming func makeIterator() -> MusicKit.ApplicationMusicPlayer.Queue.Entries.Iterator
      public typealias Element = MusicKit.MusicPlayer.Queue.Entry
      public typealias Iterator = Swift.Array<MusicKit.MusicPlayer.Queue.Entry>.Iterator
      public var startIndex: MusicKit.ApplicationMusicPlayer.Queue.Entries.Index {
        get
      }
      public var endIndex: MusicKit.ApplicationMusicPlayer.Queue.Entries.Index {
        get
      }
      public var indices: MusicKit.ApplicationMusicPlayer.Queue.Entries.Indices {
        get
      }
      public func index(_ i: MusicKit.ApplicationMusicPlayer.Queue.Entries.Index, offsetBy distance: Swift.Int) -> MusicKit.ApplicationMusicPlayer.Queue.Entries.Index
      public func index(_ i: MusicKit.ApplicationMusicPlayer.Queue.Entries.Index, offsetBy distance: Swift.Int, limitedBy limit: MusicKit.ApplicationMusicPlayer.Queue.Entries.Index) -> MusicKit.ApplicationMusicPlayer.Queue.Entries.Index?
      public func index(after i: MusicKit.ApplicationMusicPlayer.Queue.Entries.Index) -> MusicKit.ApplicationMusicPlayer.Queue.Entries.Index
      public func formIndex(after i: inout MusicKit.ApplicationMusicPlayer.Queue.Entries.Index)
      public func distance(from start: MusicKit.ApplicationMusicPlayer.Queue.Entries.Index, to end: MusicKit.ApplicationMusicPlayer.Queue.Entries.Index) -> Swift.Int
      public subscript(bounds: Swift.Range<MusicKit.ApplicationMusicPlayer.Queue.Entries.Index>) -> MusicKit.ApplicationMusicPlayer.Queue.Entries.SubSequence {
        get
        set
      }
      public subscript(position: MusicKit.ApplicationMusicPlayer.Queue.Entries.Index) -> MusicKit.ApplicationMusicPlayer.Queue.Entries.Element {
        get
        set
      }
      public typealias Index = Swift.Array<MusicKit.MusicPlayer.Queue.Entry>.Index
      public typealias Indices = Swift.Array<MusicKit.MusicPlayer.Queue.Entry>.Indices
      public typealias SubSequence = Swift.Array<MusicKit.MusicPlayer.Queue.Entry>.SubSequence
      public func index(before i: MusicKit.ApplicationMusicPlayer.Queue.Entries.Index) -> MusicKit.ApplicationMusicPlayer.Queue.Entries.Index
      public func formIndex(before i: inout MusicKit.ApplicationMusicPlayer.Queue.Entries.Index)
      public mutating func replaceSubrange<C>(_ subrange: Swift.Range<MusicKit.ApplicationMusicPlayer.Queue.Entries.Index>, with newElements: C) where C : Swift.Collection, C.Element == MusicKit.ApplicationMusicPlayer.Queue.Entries.Element
      public init(arrayLiteral elements: MusicKit.MusicPlayer.Queue.Entry...)
      public typealias ArrayLiteralElement = MusicKit.MusicPlayer.Queue.Entry
      public var hashValue: Swift.Int {
        get
      }
    }
    @objc deinit
  }
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers @available(iOS 15.0, tvOS 15.0, *)
@available(macOS, unavailable)
@available(watchOS, unavailable)
public class ApplicationMusicPlayer : MusicKit.MusicPlayer {
  public static let shared: MusicKit.ApplicationMusicPlayer
  public var queue: MusicKit.ApplicationMusicPlayer.Queue {
    get
    set
  }
  @objc deinit
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
@frozen public struct MusicItemID : Swift.Equatable, Swift.Hashable, Swift.RawRepresentable, Swift.ExpressibleByStringLiteral {
  public init(_ rawValue: Swift.String)
  public init(rawValue: Swift.String)
  public init(stringLiteral value: Swift.String)
  public let rawValue: Swift.String
  public typealias ExtendedGraphemeClusterLiteralType = Swift.String
  public typealias RawValue = Swift.String
  public typealias StringLiteralType = Swift.String
  public typealias UnicodeScalarLiteralType = Swift.String
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
extension MusicKit.MusicItemID : Swift.Codable {
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
extension MusicKit.MusicItemID : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
public enum MusicTokenRequestError : Swift.String, Foundation.LocalizedError, Swift.CustomStringConvertible {
  case unknown
  case permissionDenied
  case userTokenRevoked
  case userNotSignedIn
  case privacyAcknowledgementRequired
  case developerTokenRequestFailed
  case userTokenRequestFailed
  public var errorDescription: Swift.String? {
    get
  }
  public var failureReason: Swift.String? {
    get
  }
  public var recoverySuggestion: Swift.String? {
    get
  }
  public var helpAnchor: Swift.String? {
    get
  }
  public var description: Swift.String {
    get
  }
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
public struct MusicVideo : MusicKit.MusicItem, Swift.Equatable, Swift.Hashable, Swift.Identifiable {
  public let id: MusicKit.MusicItemID
  public var artwork: MusicKit.Artwork? {
    get
  }
  public var albumTitle: Swift.String? {
    get
  }
  public var artistName: Swift.String {
    get
  }
  public var artistURL: Foundation.URL? {
    get
  }
  public var contentRating: MusicKit.ContentRating? {
    get
  }
  public var duration: Foundation.TimeInterval? {
    get
  }
  public var editorialNotes: MusicKit.EditorialNotes? {
    get
  }
  public var genreNames: [Swift.String] {
    get
  }
  public var has4K: Swift.Bool? {
    get
  }
  public var hasHDR: Swift.Bool? {
    get
  }
  public var isPreview: Swift.Bool {
    get
  }
  public var isrc: Swift.String? {
    get
  }
  public var playParameters: MusicKit.PlayParameters? {
    get
  }
  public var previewAssets: [MusicKit.PreviewAsset]? {
    get
  }
  public var releaseDate: Foundation.Date? {
    get
  }
  public var title: Swift.String {
    get
  }
  public var trackNumber: Swift.Int? {
    get
  }
  public var url: Foundation.URL? {
    get
  }
  public var workName: Swift.String? {
    get
  }
  public var albums: MusicKit.MusicItemCollection<MusicKit.Album>? {
    get
  }
  public var artists: MusicKit.MusicItemCollection<MusicKit.Artist>? {
    get
  }
  public var genres: MusicKit.MusicItemCollection<MusicKit.Genre>? {
    get
  }
  public var songs: MusicKit.MusicItemCollection<MusicKit.Song>? {
    get
  }
  public var moreByArtist: MusicKit.MusicItemCollection<MusicKit.MusicVideo>? {
    get
  }
  public var moreInGenre: MusicKit.MusicItemCollection<MusicKit.MusicVideo>? {
    get
  }
  public static func == (a: MusicKit.MusicVideo, b: MusicKit.MusicVideo) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public typealias ID = MusicKit.MusicItemID
  public var hashValue: Swift.Int {
    get
  }
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
extension MusicKit.MusicVideo : MusicKit.MusicPropertyContainer {
  
  #if compiler(>=5.3) && $EffectfulProp
  @usableFromInline
  internal subscript<Value>(property property: MusicKit.MusicAttributeProperty<MusicKit.MusicVideo, Value>) -> Value? where Value : Swift.Decodable {
    get throws
  }
  #endif

  
  #if compiler(>=5.3) && $EffectfulProp
  @usableFromInline
  internal subscript<Value>(property property: MusicKit.MusicExtendedAttributeProperty<MusicKit.MusicVideo, Value>) -> Value? where Value : Swift.Decodable {
    get throws
  }
  #endif

  
  #if compiler(>=5.3) && $EffectfulProp
  @usableFromInline
  internal subscript<RelatedMusicItemType>(property property: MusicKit.MusicRelationshipProperty<MusicKit.MusicVideo, RelatedMusicItemType>) -> MusicKit.MusicItemCollection<RelatedMusicItemType>? where RelatedMusicItemType : MusicKit.MusicItem, RelatedMusicItemType : Swift.Decodable {
    get throws
  }
  #endif

}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
extension MusicKit.PartialMusicProperty where Root == MusicKit.MusicVideo {
  @_alwaysEmitIntoClient public static var artistURL: MusicKit.MusicExtendedAttributeProperty<MusicKit.MusicVideo, Foundation.URL> {
    get {
        MusicExtendedAttributeProperty("artistUrl")
    }
  }
  public static let albums: MusicKit.MusicRelationshipProperty<MusicKit.MusicVideo, MusicKit.Album>
  public static let artists: MusicKit.MusicRelationshipProperty<MusicKit.MusicVideo, MusicKit.Artist>
  public static let genres: MusicKit.MusicRelationshipProperty<MusicKit.MusicVideo, MusicKit.Genre>
  public static let songs: MusicKit.MusicRelationshipProperty<MusicKit.MusicVideo, MusicKit.Song>
  public static let moreByArtist: MusicKit.MusicRelationshipProperty<MusicKit.MusicVideo, MusicKit.MusicVideo>
  public static let moreInGenre: MusicKit.MusicRelationshipProperty<MusicKit.MusicVideo, MusicKit.MusicVideo>
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
public protocol MusicVideoFilter {
  var id: MusicKit.MusicItemID { get }
  var isrc: Swift.String? { get }
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
extension MusicKit.MusicVideo : MusicKit.FilterableMusicItem {
  public typealias FilterType = MusicKit.MusicVideoFilter
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
extension MusicKit.MusicVideo : Swift.Codable {
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
extension MusicKit.MusicVideo : Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible {
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
public struct Genre : MusicKit.MusicItem, Swift.Equatable, Swift.Hashable, Swift.Identifiable {
  public let id: MusicKit.MusicItemID
  public var name: Swift.String {
    get
  }
  public var parent: MusicKit.Genre? {
    get
  }
  public static func == (a: MusicKit.Genre, b: MusicKit.Genre) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public typealias ID = MusicKit.MusicItemID
  public var hashValue: Swift.Int {
    get
  }
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
extension MusicKit.Genre : MusicKit.MusicPropertyContainer {
  
  #if compiler(>=5.3) && $EffectfulProp
  @usableFromInline
  internal subscript<Value>(property property: MusicKit.MusicAttributeProperty<MusicKit.Genre, Value>) -> Value? where Value : Swift.Decodable {
    get throws
  }
  #endif

  
  #if compiler(>=5.3) && $EffectfulProp
  @usableFromInline
  internal subscript<Value>(property property: MusicKit.MusicExtendedAttributeProperty<MusicKit.Genre, Value>) -> Value? where Value : Swift.Decodable {
    get throws
  }
  #endif

  
  #if compiler(>=5.3) && $EffectfulProp
  @usableFromInline
  internal subscript<RelatedMusicItemType>(property property: MusicKit.MusicRelationshipProperty<MusicKit.Genre, RelatedMusicItemType>) -> MusicKit.MusicItemCollection<RelatedMusicItemType>? where RelatedMusicItemType : MusicKit.MusicItem, RelatedMusicItemType : Swift.Decodable {
    get throws
  }
  #endif

}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
public protocol GenreFilter {
  var id: MusicKit.MusicItemID { get }
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
extension MusicKit.Genre : MusicKit.FilterableMusicItem {
  public typealias FilterType = MusicKit.GenreFilter
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
extension MusicKit.Genre : Swift.Codable {
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
extension MusicKit.Genre : Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible {
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
public struct Artist : MusicKit.MusicItem, Swift.Equatable, Swift.Hashable, Swift.Identifiable {
  public let id: MusicKit.MusicItemID
  public var editorialNotes: MusicKit.EditorialNotes? {
    get
  }
  public var genreNames: [Swift.String]? {
    get
  }
  public var name: Swift.String {
    get
  }
  public var url: Foundation.URL? {
    get
  }
  public var albums: MusicKit.MusicItemCollection<MusicKit.Album>? {
    get
  }
  public var genres: MusicKit.MusicItemCollection<MusicKit.Genre>? {
    get
  }
  public var musicVideos: MusicKit.MusicItemCollection<MusicKit.MusicVideo>? {
    get
  }
  public var playlists: MusicKit.MusicItemCollection<MusicKit.Playlist>? {
    get
  }
  public var station: MusicKit.Station? {
    get
  }
  public var appearsOnAlbums: MusicKit.MusicItemCollection<MusicKit.Album>? {
    get
  }
  public var compilationAlbums: MusicKit.MusicItemCollection<MusicKit.Album>? {
    get
  }
  public var featuredAlbums: MusicKit.MusicItemCollection<MusicKit.Album>? {
    get
  }
  public var featuredPlaylists: MusicKit.MusicItemCollection<MusicKit.Playlist>? {
    get
  }
  public var fullAlbums: MusicKit.MusicItemCollection<MusicKit.Album>? {
    get
  }
  public var latestRelease: MusicKit.Album? {
    get
  }
  public var liveAlbums: MusicKit.MusicItemCollection<MusicKit.Album>? {
    get
  }
  public var similarArtists: MusicKit.MusicItemCollection<MusicKit.Artist>? {
    get
  }
  public var singles: MusicKit.MusicItemCollection<MusicKit.Album>? {
    get
  }
  public var topMusicVideos: MusicKit.MusicItemCollection<MusicKit.MusicVideo>? {
    get
  }
  public var topSongs: MusicKit.MusicItemCollection<MusicKit.Song>? {
    get
  }
  public static func == (a: MusicKit.Artist, b: MusicKit.Artist) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public typealias ID = MusicKit.MusicItemID
  public var hashValue: Swift.Int {
    get
  }
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
extension MusicKit.Artist : MusicKit.MusicPropertyContainer {
  
  #if compiler(>=5.3) && $EffectfulProp
  @usableFromInline
  internal subscript<Value>(property property: MusicKit.MusicAttributeProperty<MusicKit.Artist, Value>) -> Value? where Value : Swift.Decodable {
    get throws
  }
  #endif

  
  #if compiler(>=5.3) && $EffectfulProp
  @usableFromInline
  internal subscript<Value>(property property: MusicKit.MusicExtendedAttributeProperty<MusicKit.Artist, Value>) -> Value? where Value : Swift.Decodable {
    get throws
  }
  #endif

  
  #if compiler(>=5.3) && $EffectfulProp
  @usableFromInline
  internal subscript<RelatedMusicItemType>(property property: MusicKit.MusicRelationshipProperty<MusicKit.Artist, RelatedMusicItemType>) -> MusicKit.MusicItemCollection<RelatedMusicItemType>? where RelatedMusicItemType : MusicKit.MusicItem, RelatedMusicItemType : Swift.Decodable {
    get throws
  }
  #endif

}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
extension MusicKit.PartialMusicProperty where Root == MusicKit.Artist {
  public static let albums: MusicKit.MusicRelationshipProperty<MusicKit.Artist, MusicKit.Album>
  public static let genres: MusicKit.MusicRelationshipProperty<MusicKit.Artist, MusicKit.Genre>
  public static let musicVideos: MusicKit.MusicRelationshipProperty<MusicKit.Artist, MusicKit.MusicVideo>
  public static let playlists: MusicKit.MusicRelationshipProperty<MusicKit.Artist, MusicKit.Playlist>
  public static let station: MusicKit.MusicRelationshipProperty<MusicKit.Artist, MusicKit.Station>
  public static let appearsOnAlbums: MusicKit.MusicRelationshipProperty<MusicKit.Artist, MusicKit.Album>
  public static let compilationAlbums: MusicKit.MusicRelationshipProperty<MusicKit.Artist, MusicKit.Album>
  public static let featuredAlbums: MusicKit.MusicRelationshipProperty<MusicKit.Artist, MusicKit.Album>
  public static let featuredPlaylists: MusicKit.MusicRelationshipProperty<MusicKit.Artist, MusicKit.Playlist>
  public static let fullAlbums: MusicKit.MusicRelationshipProperty<MusicKit.Artist, MusicKit.Album>
  public static let latestRelease: MusicKit.MusicRelationshipProperty<MusicKit.Artist, MusicKit.Album>
  public static let liveAlbums: MusicKit.MusicRelationshipProperty<MusicKit.Artist, MusicKit.Album>
  public static let similarArtists: MusicKit.MusicRelationshipProperty<MusicKit.Artist, MusicKit.Artist>
  public static let singles: MusicKit.MusicRelationshipProperty<MusicKit.Artist, MusicKit.Album>
  public static let topMusicVideos: MusicKit.MusicRelationshipProperty<MusicKit.Artist, MusicKit.MusicVideo>
  public static let topSongs: MusicKit.MusicRelationshipProperty<MusicKit.Artist, MusicKit.Song>
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
public protocol ArtistFilter {
  var id: MusicKit.MusicItemID { get }
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
extension MusicKit.Artist : MusicKit.FilterableMusicItem {
  public typealias FilterType = MusicKit.ArtistFilter
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
extension MusicKit.Artist : Swift.Codable {
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
extension MusicKit.Artist : Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible {
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
public struct Playlist : MusicKit.MusicItem, Swift.Equatable, Swift.Hashable, Swift.Identifiable {
  public let id: MusicKit.MusicItemID
  public var artwork: MusicKit.Artwork? {
    get
  }
  public var curatorName: Swift.String? {
    get
  }
  public var isChart: Swift.Bool? {
    get
  }
  public var kind: MusicKit.Playlist.Kind? {
    get
  }
  public var lastModifiedDate: Foundation.Date? {
    get
  }
  public var name: Swift.String {
    get
  }
  public var playParameters: MusicKit.PlayParameters? {
    get
  }
  public var shortDescription: Swift.String? {
    get
  }
  public var standardDescription: Swift.String? {
    get
  }
  public var url: Foundation.URL? {
    get
  }
  public var tracks: MusicKit.MusicItemCollection<MusicKit.Track>? {
    get
  }
  public var featuredArtists: MusicKit.MusicItemCollection<MusicKit.Artist>? {
    get
  }
  public var moreByCurator: MusicKit.MusicItemCollection<MusicKit.Playlist>? {
    get
  }
  public static func == (a: MusicKit.Playlist, b: MusicKit.Playlist) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public typealias ID = MusicKit.MusicItemID
  public var hashValue: Swift.Int {
    get
  }
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
extension MusicKit.Playlist : MusicKit.MusicPropertyContainer {
  
  #if compiler(>=5.3) && $EffectfulProp
  @usableFromInline
  internal subscript<Value>(property property: MusicKit.MusicAttributeProperty<MusicKit.Playlist, Value>) -> Value? where Value : Swift.Decodable {
    get throws
  }
  #endif

  
  #if compiler(>=5.3) && $EffectfulProp
  @usableFromInline
  internal subscript<Value>(property property: MusicKit.MusicExtendedAttributeProperty<MusicKit.Playlist, Value>) -> Value? where Value : Swift.Decodable {
    get throws
  }
  #endif

  
  #if compiler(>=5.3) && $EffectfulProp
  @usableFromInline
  internal subscript<RelatedMusicItemType>(property property: MusicKit.MusicRelationshipProperty<MusicKit.Playlist, RelatedMusicItemType>) -> MusicKit.MusicItemCollection<RelatedMusicItemType>? where RelatedMusicItemType : MusicKit.MusicItem, RelatedMusicItemType : Swift.Decodable {
    get throws
  }
  #endif

}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
extension MusicKit.PartialMusicProperty where Root == MusicKit.Playlist {
  public static let tracks: MusicKit.MusicRelationshipProperty<MusicKit.Playlist, MusicKit.Track>
  public static let featuredArtists: MusicKit.MusicRelationshipProperty<MusicKit.Playlist, MusicKit.Artist>
  public static let moreByCurator: MusicKit.MusicRelationshipProperty<MusicKit.Playlist, MusicKit.Playlist>
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
public protocol PlaylistFilter {
  var id: MusicKit.MusicItemID { get }
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
extension MusicKit.Playlist : MusicKit.FilterableMusicItem {
  public typealias FilterType = MusicKit.PlaylistFilter
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
extension MusicKit.Playlist : Swift.Codable {
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
extension MusicKit.Playlist : Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible {
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
extension MusicKit.Playlist {
  public enum Kind : Swift.Codable, Swift.Equatable, Swift.Hashable {
    case editorial
    case external
    case personalMix
    case replay
    case userShared
    public static func == (a: MusicKit.Playlist.Kind, b: MusicKit.Playlist.Kind) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public func encode(to encoder: Swift.Encoder) throws
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: Swift.Decoder) throws
  }
}
@available(iOS 15.0, tvOS 15.0, *)
@available(macOS, unavailable)
@available(watchOS, unavailable)
extension MusicKit.MusicPlayer.Queue.Entry {
  public enum Item : MusicKit.MusicItem, Swift.Equatable, Swift.Hashable, Swift.Identifiable {
    case song(MusicKit.Song)
    case musicVideo(MusicKit.MusicVideo)
    public var id: MusicKit.MusicItemID {
      get
    }
    public var playParameters: MusicKit.PlayParameters? {
      get
    }
    public static func == (a: MusicKit.MusicPlayer.Queue.Entry.Item, b: MusicKit.MusicPlayer.Queue.Entry.Item) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public typealias ID = MusicKit.MusicItemID
    public var hashValue: Swift.Int {
      get
    }
  }
}
@available(iOS 15.0, tvOS 15.0, *)
@available(macOS, unavailable)
@available(watchOS, unavailable)
extension MusicKit.MusicPlayer.Queue.Entry.Item : MusicKit.MusicPropertyContainer {
  
  #if compiler(>=5.3) && $EffectfulProp
  @usableFromInline
  internal subscript<Value>(property property: MusicKit.MusicAttributeProperty<MusicKit.MusicPlayer.Queue.Entry.Item, Value>) -> Value? where Value : Swift.Decodable {
    get throws
  }
  #endif

  
  #if compiler(>=5.3) && $EffectfulProp
  @usableFromInline
  internal subscript<Value>(property property: MusicKit.MusicExtendedAttributeProperty<MusicKit.MusicPlayer.Queue.Entry.Item, Value>) -> Value? where Value : Swift.Decodable {
    get throws
  }
  #endif

  
  #if compiler(>=5.3) && $EffectfulProp
  @usableFromInline
  internal subscript<RelatedMusicItemType>(property property: MusicKit.MusicRelationshipProperty<MusicKit.MusicPlayer.Queue.Entry.Item, RelatedMusicItemType>) -> MusicKit.MusicItemCollection<RelatedMusicItemType>? where RelatedMusicItemType : MusicKit.MusicItem, RelatedMusicItemType : Swift.Decodable {
    get throws
  }
  #endif

}
@available(iOS 15.0, tvOS 15.0, *)
@available(macOS, unavailable)
@available(watchOS, unavailable)
extension MusicKit.MusicPlayer.Queue.Entry.Item : Swift.Codable {
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
@available(iOS 15.0, tvOS 15.0, *)
@available(macOS, unavailable)
@available(watchOS, unavailable)
extension MusicKit.MusicPlayer.Queue.Entry.Item : Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible {
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
public struct MusicCatalogSearchRequest {
  public init(term: Swift.String, types: [MusicKit.MusicCatalogSearchable.Type])
  public let term: Swift.String
  public var types: [MusicKit.MusicCatalogSearchable.Type] {
    get
  }
  public var limit: Swift.Int?
  public var offset: Swift.Int?
  
  #if compiler(>=5.3) && $AsyncAwait
  public func response() async throws -> MusicKit.MusicCatalogSearchResponse
  #endif

}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
public protocol MusicCatalogSearchable : MusicKit.MusicItem {
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
extension MusicKit.Album : MusicKit.MusicCatalogSearchable {
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
extension MusicKit.Artist : MusicKit.MusicCatalogSearchable {
}
@available(iOS 15.4, macOS 12.3, tvOS 15.4, *)
@available(watchOS, unavailable)
extension MusicKit.Curator : MusicKit.MusicCatalogSearchable {
}
@available(iOS 15.4, macOS 12.3, tvOS 15.4, *)
@available(watchOS, unavailable)
extension MusicKit.MusicVideo : MusicKit.MusicCatalogSearchable {
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
extension MusicKit.Playlist : MusicKit.MusicCatalogSearchable {
}
@available(iOS 15.4, macOS 12.3, tvOS 15.4, *)
@available(watchOS, unavailable)
extension MusicKit.RadioShow : MusicKit.MusicCatalogSearchable {
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
extension MusicKit.RecordLabel : MusicKit.MusicCatalogSearchable {
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
extension MusicKit.Song : MusicKit.MusicCatalogSearchable {
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
extension MusicKit.Station : MusicKit.MusicCatalogSearchable {
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
public struct MusicCatalogResourceResponse<MusicItemType> where MusicItemType : MusicKit.MusicItem {
  public let items: MusicKit.MusicItemCollection<MusicItemType>
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
extension MusicKit.MusicCatalogResourceResponse : Swift.Equatable where MusicItemType : Swift.Equatable {
  public static func == (a: MusicKit.MusicCatalogResourceResponse<MusicItemType>, b: MusicKit.MusicCatalogResourceResponse<MusicItemType>) -> Swift.Bool
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
extension MusicKit.MusicCatalogResourceResponse : Swift.Hashable where MusicItemType : Swift.Hashable {
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
extension MusicKit.MusicCatalogResourceResponse : Swift.Decodable where MusicItemType : Swift.Decodable {
  public init(from decoder: Swift.Decoder) throws
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
extension MusicKit.MusicCatalogResourceResponse : Swift.Encodable where MusicItemType : Swift.Encodable {
  public func encode(to encoder: Swift.Encoder) throws
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
extension MusicKit.MusicCatalogResourceResponse : Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible {
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
public struct MusicSubscription : Swift.Equatable, Swift.Hashable, Swift.CustomStringConvertible {
  public let canPlayCatalogContent: Swift.Bool
  public let canBecomeSubscriber: Swift.Bool
  public let hasCloudLibraryEnabled: Swift.Bool
  
  #if compiler(>=5.3) && $EffectfulProp
  public static var current: MusicKit.MusicSubscription {
    get async throws
  }
  #endif

  public var description: Swift.String {
    get
  }
  public static func == (a: MusicKit.MusicSubscription, b: MusicKit.MusicSubscription) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
public struct Song : MusicKit.MusicItem, Swift.Equatable, Swift.Hashable, Swift.Identifiable {
  public let id: MusicKit.MusicItemID
  public var artwork: MusicKit.Artwork? {
    get
  }
  public var albumTitle: Swift.String? {
    get
  }
  public var artistName: Swift.String {
    get
  }
  public var artistURL: Foundation.URL? {
    get
  }
  public var attribution: Swift.String? {
    get
  }
  public var composerName: Swift.String? {
    get
  }
  public var contentRating: MusicKit.ContentRating? {
    get
  }
  public var discNumber: Swift.Int? {
    get
  }
  public var duration: Foundation.TimeInterval? {
    get
  }
  public var editorialNotes: MusicKit.EditorialNotes? {
    get
  }
  public var genreNames: [Swift.String] {
    get
  }
  public var hasLyrics: Swift.Bool {
    get
  }
  public var isrc: Swift.String? {
    get
  }
  public var movementCount: Swift.Int? {
    get
  }
  public var movementName: Swift.String? {
    get
  }
  public var movementNumber: Swift.Int? {
    get
  }
  public var playParameters: MusicKit.PlayParameters? {
    get
  }
  public var previewAssets: [MusicKit.PreviewAsset]? {
    get
  }
  public var releaseDate: Foundation.Date? {
    get
  }
  public var title: Swift.String {
    get
  }
  public var trackNumber: Swift.Int? {
    get
  }
  public var url: Foundation.URL? {
    get
  }
  public var workName: Swift.String? {
    get
  }
  public var albums: MusicKit.MusicItemCollection<MusicKit.Album>? {
    get
  }
  public var artists: MusicKit.MusicItemCollection<MusicKit.Artist>? {
    get
  }
  public var genres: MusicKit.MusicItemCollection<MusicKit.Genre>? {
    get
  }
  public var station: MusicKit.Station? {
    get
  }
  public var composers: MusicKit.MusicItemCollection<MusicKit.Artist>? {
    get
  }
  public var musicVideos: MusicKit.MusicItemCollection<MusicKit.MusicVideo>? {
    get
  }
  public static func == (a: MusicKit.Song, b: MusicKit.Song) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public typealias ID = MusicKit.MusicItemID
  public var hashValue: Swift.Int {
    get
  }
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
extension MusicKit.Song : MusicKit.MusicPropertyContainer {
  
  #if compiler(>=5.3) && $EffectfulProp
  @usableFromInline
  internal subscript<Value>(property property: MusicKit.MusicAttributeProperty<MusicKit.Song, Value>) -> Value? where Value : Swift.Decodable {
    get throws
  }
  #endif

  
  #if compiler(>=5.3) && $EffectfulProp
  @usableFromInline
  internal subscript<Value>(property property: MusicKit.MusicExtendedAttributeProperty<MusicKit.Song, Value>) -> Value? where Value : Swift.Decodable {
    get throws
  }
  #endif

  
  #if compiler(>=5.3) && $EffectfulProp
  @usableFromInline
  internal subscript<RelatedMusicItemType>(property property: MusicKit.MusicRelationshipProperty<MusicKit.Song, RelatedMusicItemType>) -> MusicKit.MusicItemCollection<RelatedMusicItemType>? where RelatedMusicItemType : MusicKit.MusicItem, RelatedMusicItemType : Swift.Decodable {
    get throws
  }
  #endif

}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
extension MusicKit.PartialMusicProperty where Root == MusicKit.Song {
  @_alwaysEmitIntoClient public static var artistURL: MusicKit.MusicExtendedAttributeProperty<MusicKit.Song, Foundation.URL> {
    get {
        MusicExtendedAttributeProperty("artistUrl")
    }
  }
  public static let albums: MusicKit.MusicRelationshipProperty<MusicKit.Song, MusicKit.Album>
  public static let artists: MusicKit.MusicRelationshipProperty<MusicKit.Song, MusicKit.Artist>
  public static let genres: MusicKit.MusicRelationshipProperty<MusicKit.Song, MusicKit.Genre>
  public static let station: MusicKit.MusicRelationshipProperty<MusicKit.Song, MusicKit.Station>
  public static let composers: MusicKit.MusicRelationshipProperty<MusicKit.Song, MusicKit.Artist>
  public static let musicVideos: MusicKit.MusicRelationshipProperty<MusicKit.Song, MusicKit.MusicVideo>
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
public protocol SongFilter {
  var id: MusicKit.MusicItemID { get }
  var isrc: Swift.String? { get }
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
extension MusicKit.Song : MusicKit.FilterableMusicItem {
  public typealias FilterType = MusicKit.SongFilter
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
extension MusicKit.Song : Swift.Codable {
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
extension MusicKit.Song : Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible {
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
extension MusicKit.MusicDataRequest {
  public struct Error : Swift.Error {
    public let status: Swift.Int
    public let code: Swift.Int
    public let title: Swift.String
    public let detailText: Swift.String
    public let id: Swift.String
    public let source: MusicKit.MusicDataRequest.Error.Source?
    public let originalResponse: MusicKit.MusicDataResponse
    public enum Source : Swift.Equatable {
      case parameter(Swift.String)
      public static func == (a: MusicKit.MusicDataRequest.Error.Source, b: MusicKit.MusicDataRequest.Error.Source) -> Swift.Bool
    }
  }
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
extension MusicKit.MusicDataRequest.Error : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
extension MusicKit.MusicDataRequest.Error.Source : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
public struct Album : MusicKit.MusicItem, Swift.Equatable, Swift.Hashable, Swift.Identifiable {
  public let id: MusicKit.MusicItemID
  public var artwork: MusicKit.Artwork? {
    get
  }
  public var artistName: Swift.String {
    get
  }
  public var artistURL: Foundation.URL? {
    get
  }
  public var contentRating: MusicKit.ContentRating? {
    get
  }
  public var copyright: Swift.String? {
    get
  }
  public var editorialNotes: MusicKit.EditorialNotes? {
    get
  }
  public var genreNames: [Swift.String] {
    get
  }
  public var isCompilation: Swift.Bool? {
    get
  }
  public var isComplete: Swift.Bool? {
    get
  }
  public var isSingle: Swift.Bool? {
    get
  }
  public var playParameters: MusicKit.PlayParameters? {
    get
  }
  public var recordLabelName: Swift.String? {
    get
  }
  public var releaseDate: Foundation.Date? {
    get
  }
  public var title: Swift.String {
    get
  }
  public var trackCount: Swift.Int {
    get
  }
  public var upc: Swift.String? {
    get
  }
  public var url: Foundation.URL? {
    get
  }
  public var artists: MusicKit.MusicItemCollection<MusicKit.Artist>? {
    get
  }
  public var genres: MusicKit.MusicItemCollection<MusicKit.Genre>? {
    get
  }
  public var tracks: MusicKit.MusicItemCollection<MusicKit.Track>? {
    get
  }
  public var recordLabels: MusicKit.MusicItemCollection<MusicKit.RecordLabel>? {
    get
  }
  public var appearsOn: MusicKit.MusicItemCollection<MusicKit.Playlist>? {
    get
  }
  public var otherVersions: MusicKit.MusicItemCollection<MusicKit.Album>? {
    get
  }
  public var relatedAlbums: MusicKit.MusicItemCollection<MusicKit.Album>? {
    get
  }
  public var relatedVideos: MusicKit.MusicItemCollection<MusicKit.MusicVideo>? {
    get
  }
  public static func == (a: MusicKit.Album, b: MusicKit.Album) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public typealias ID = MusicKit.MusicItemID
  public var hashValue: Swift.Int {
    get
  }
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
extension MusicKit.Album : MusicKit.MusicPropertyContainer {
  
  #if compiler(>=5.3) && $EffectfulProp
  @usableFromInline
  internal subscript<Value>(property property: MusicKit.MusicAttributeProperty<MusicKit.Album, Value>) -> Value? where Value : Swift.Decodable {
    get throws
  }
  #endif

  
  #if compiler(>=5.3) && $EffectfulProp
  @usableFromInline
  internal subscript<Value>(property property: MusicKit.MusicExtendedAttributeProperty<MusicKit.Album, Value>) -> Value? where Value : Swift.Decodable {
    get throws
  }
  #endif

  
  #if compiler(>=5.3) && $EffectfulProp
  @usableFromInline
  internal subscript<RelatedMusicItemType>(property property: MusicKit.MusicRelationshipProperty<MusicKit.Album, RelatedMusicItemType>) -> MusicKit.MusicItemCollection<RelatedMusicItemType>? where RelatedMusicItemType : MusicKit.MusicItem, RelatedMusicItemType : Swift.Decodable {
    get throws
  }
  #endif

}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
extension MusicKit.PartialMusicProperty where Root == MusicKit.Album {
  @_alwaysEmitIntoClient public static var artistURL: MusicKit.MusicExtendedAttributeProperty<MusicKit.Album, Foundation.URL> {
    get {
        MusicExtendedAttributeProperty("artistUrl")
    }
  }
  public static let artists: MusicKit.MusicRelationshipProperty<MusicKit.Album, MusicKit.Artist>
  public static let genres: MusicKit.MusicRelationshipProperty<MusicKit.Album, MusicKit.Genre>
  public static let tracks: MusicKit.MusicRelationshipProperty<MusicKit.Album, MusicKit.Track>
  public static let recordLabels: MusicKit.MusicRelationshipProperty<MusicKit.Album, MusicKit.RecordLabel>
  public static let appearsOn: MusicKit.MusicRelationshipProperty<MusicKit.Album, MusicKit.Playlist>
  public static let otherVersions: MusicKit.MusicRelationshipProperty<MusicKit.Album, MusicKit.Album>
  public static let relatedAlbums: MusicKit.MusicRelationshipProperty<MusicKit.Album, MusicKit.Album>
  public static let relatedVideos: MusicKit.MusicRelationshipProperty<MusicKit.Album, MusicKit.MusicVideo>
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
public protocol AlbumFilter {
  var id: MusicKit.MusicItemID { get }
  var upc: Swift.String? { get }
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
extension MusicKit.Album : MusicKit.FilterableMusicItem {
  public typealias FilterType = MusicKit.AlbumFilter
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
extension MusicKit.Album : Swift.Codable {
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
extension MusicKit.Album : Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible {
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
public struct MusicItemCollection<MusicItemType> where MusicItemType : MusicKit.MusicItem {
  public var title: Swift.String? {
    get
  }
  public static func += (collection: inout MusicKit.MusicItemCollection<MusicItemType>, nextBatchCollection: MusicKit.MusicItemCollection<MusicItemType>)
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
extension MusicKit.MusicItemCollection {
  public var hasNextBatch: Swift.Bool {
    get
  }
  
  #if compiler(>=5.3) && $AsyncAwait
  public func nextBatch(limit: Swift.Int? = nil) async throws -> MusicKit.MusicItemCollection<MusicItemType>?
  #endif

  
  #if compiler(>=5.3) && $AsyncAwait
  public func nextBatch(limit: Swift.Int? = nil) async throws -> MusicKit.MusicItemCollection<MusicItemType>? where MusicItemType : Swift.Decodable
  #endif

}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
extension MusicKit.MusicItemCollection : Swift.ExpressibleByArrayLiteral {
  public init(arrayLiteral items: MusicItemType...)
  public typealias ArrayLiteralElement = MusicItemType
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
extension MusicKit.MusicItemCollection {
  public init<S>(_ elements: S) where MusicItemType == S.Element, S : Swift.Sequence
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
extension MusicKit.MusicItemCollection : Swift.RandomAccessCollection {
  public typealias Element = MusicItemType
  public typealias Index = Swift.Array<MusicItemType>.Index
  public typealias SubSequence = Swift.Array<MusicItemType>.SubSequence
  public typealias Indices = Swift.Array<MusicItemType>.Indices
  public var indices: MusicKit.MusicItemCollection<MusicItemType>.Indices {
    get
  }
  public subscript(bounds: Swift.Range<MusicKit.MusicItemCollection<MusicItemType>.Index>) -> MusicKit.MusicItemCollection<MusicItemType>.SubSequence {
    get
  }
  public subscript(position: MusicKit.MusicItemCollection<MusicItemType>.Index) -> MusicKit.MusicItemCollection<MusicItemType>.Element {
    get
  }
  public var startIndex: MusicKit.MusicItemCollection<MusicItemType>.Index {
    get
  }
  public var endIndex: MusicKit.MusicItemCollection<MusicItemType>.Index {
    get
  }
  public func index(before i: MusicKit.MusicItemCollection<MusicItemType>.Index) -> MusicKit.MusicItemCollection<MusicItemType>.Index
  public func formIndex(before i: inout MusicKit.MusicItemCollection<MusicItemType>.Index)
  public func index(after i: MusicKit.MusicItemCollection<MusicItemType>.Index) -> MusicKit.MusicItemCollection<MusicItemType>.Index
  public func formIndex(after i: inout MusicKit.MusicItemCollection<MusicItemType>.Index)
  public func index(_ i: MusicKit.MusicItemCollection<MusicItemType>.Index, offsetBy distance: Swift.Int) -> MusicKit.MusicItemCollection<MusicItemType>.Index
  public func index(_ i: MusicKit.MusicItemCollection<MusicItemType>.Index, offsetBy distance: Swift.Int, limitedBy limit: MusicKit.MusicItemCollection<MusicItemType>.Index) -> MusicKit.MusicItemCollection<MusicItemType>.Index?
  public func distance(from start: MusicKit.MusicItemCollection<MusicItemType>.Index, to end: MusicKit.MusicItemCollection<MusicItemType>.Index) -> Swift.Int
  public typealias Iterator = Swift.IndexingIterator<MusicKit.MusicItemCollection<MusicItemType>>
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
extension MusicKit.MusicItemCollection : Swift.Equatable where MusicItemType : Swift.Equatable {
  public static func == (left: MusicKit.MusicItemCollection<MusicItemType>, right: MusicKit.MusicItemCollection<MusicItemType>) -> Swift.Bool
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
extension MusicKit.MusicItemCollection : Swift.Hashable where MusicItemType : Swift.Hashable {
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
extension MusicKit.MusicItemCollection : Swift.Decodable where MusicItemType : Swift.Decodable {
  public init(from decoder: Swift.Decoder) throws
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
extension MusicKit.MusicItemCollection : Swift.Encodable where MusicItemType : Swift.Encodable {
  public func encode(to encoder: Swift.Encoder) throws
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
extension MusicKit.MusicItemCollection : Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible {
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
public struct PlayParameters : Swift.Equatable, Swift.Hashable {
  public static func == (a: MusicKit.PlayParameters, b: MusicKit.PlayParameters) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
extension MusicKit.PlayParameters : Swift.Codable {
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
@available(iOS 15.0, tvOS 15.0, *)
@available(macOS, unavailable)
@available(watchOS, unavailable)
extension MusicKit.MusicPlayer.Queue.EntryInsertionPosition : Swift.Equatable {}
@available(iOS 15.0, tvOS 15.0, *)
@available(macOS, unavailable)
@available(watchOS, unavailable)
extension MusicKit.MusicPlayer.Queue.EntryInsertionPosition : Swift.Hashable {}
@available(iOS 15.0, tvOS 15.0, *)
@available(macOS, unavailable)
@available(watchOS, unavailable)
extension MusicKit.MusicPlayer.RepeatMode : Swift.Equatable {}
@available(iOS 15.0, tvOS 15.0, *)
@available(macOS, unavailable)
@available(watchOS, unavailable)
extension MusicKit.MusicPlayer.RepeatMode : Swift.Hashable {}
@available(iOS 15.0, tvOS 15.0, *)
@available(macOS, unavailable)
@available(watchOS, unavailable)
extension MusicKit.MusicPlayer.ShuffleMode : Swift.Equatable {}
@available(iOS 15.0, tvOS 15.0, *)
@available(macOS, unavailable)
@available(watchOS, unavailable)
extension MusicKit.MusicPlayer.ShuffleMode : Swift.Hashable {}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
extension MusicKit.MusicRelationshipPropertyKind : Swift.Equatable {}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
extension MusicKit.MusicRelationshipPropertyKind : Swift.Hashable {}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
extension MusicKit.MusicSubscription.Error : Swift.Equatable {}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
extension MusicKit.MusicSubscription.Error : Swift.Hashable {}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
extension MusicKit.MusicSubscription.Error : Swift.RawRepresentable {}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
extension MusicKit.MusicTokenRequestError : Swift.Equatable {}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
extension MusicKit.MusicTokenRequestError : Swift.Hashable {}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
extension MusicKit.MusicTokenRequestError : Swift.RawRepresentable {}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
extension MusicKit.MusicAuthorization.Status : Swift.Equatable {}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
extension MusicKit.MusicAuthorization.Status : Swift.Hashable {}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
extension MusicKit.MusicAuthorization.Status : Swift.RawRepresentable {}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
extension MusicKit.MusicItemID : Swift.Sendable {}
