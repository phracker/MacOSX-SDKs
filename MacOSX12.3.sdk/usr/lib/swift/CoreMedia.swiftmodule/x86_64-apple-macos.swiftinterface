// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 5.6 (swiftlang-5.6.0.323.32 clang-1316.0.20.8)
// swift-module-flags: -target x86_64-apple-macos12.3 -enable-objc-interop -autolink-force-load -enable-library-evolution -module-link-name swiftCoreMedia -swift-version 5 -enforce-exclusivity=checked -O -library-level api -module-name CoreMedia
// swift-module-flags-ignorable: -user-module-version 2940.20.4.3
import CoreAudio
import CoreAudioTypes
import CoreFoundation
import CoreGraphics
@_exported import CoreMedia
import CoreVideo
import Darwin
import Dispatch
import Foundation
import Swift
import _Concurrency
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
public protocol _CMObjectiveCBridgeableWithRawValue : Swift.Hashable, Swift.RawRepresentable, Swift._ObjectiveCBridgeable {
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension CoreMedia._CMObjectiveCBridgeableWithRawValue where Self.RawValue : Swift.Hashable {
  public func hash(into hasher: inout Swift.Hasher)
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension CoreMedia._CMObjectiveCBridgeableWithRawValue where Self.RawValue == CoreFoundation.CFString, Self._ObjectiveCType == CoreFoundation.CFString {
  public func _bridgeToObjectiveC() -> Self._ObjectiveCType
  public static func _forceBridgeFromObjectiveC(_ source: Self._ObjectiveCType, result: inout Self?)
  public static func _conditionallyBridgeFromObjectiveC(_ source: Self._ObjectiveCType, result: inout Self?) -> Swift.Bool
  public static func _unconditionallyBridgeFromObjectiveC(_ source: Self._ObjectiveCType?) -> Self
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension CoreMedia._CMObjectiveCBridgeableWithRawValue where Self.RawValue : Swift._ObjectiveCBridgeable, Self._ObjectiveCType == Self.RawValue._ObjectiveCType {
  public func _bridgeToObjectiveC() -> Self._ObjectiveCType
  public static func _forceBridgeFromObjectiveC(_ source: Self._ObjectiveCType, result: inout Self?)
  public static func _conditionallyBridgeFromObjectiveC(_ source: Self._ObjectiveCType, result: inout Self?) -> Swift.Bool
  public static func _unconditionallyBridgeFromObjectiveC(_ source: Self._ObjectiveCType?) -> Self
}
@available(watchOS 6.0, *)
extension CoreMedia.CMClock {
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public struct Error {
    public static let missingRequiredParameter: Foundation.NSError
    public static let invalidParameter: Foundation.NSError
    public static let allocationFailed: Foundation.NSError
    public static let unsupportedOperation: Foundation.NSError
  }
}
@available(watchOS 6.0, *)
extension CoreMedia.CMTimebase {
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public struct Error {
    public static let missingRequiredParameter: Foundation.NSError
    public static let invalidParameter: Foundation.NSError
    public static let allocationFailed: Foundation.NSError
    public static let timerIntervalTooShort: Foundation.NSError
    public static let readOnly: Foundation.NSError
  }
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
public struct CMSync {
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension CoreMedia.CMSync {
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public struct Error {
    public static let missingRequiredParameter: Foundation.NSError
    public static let invalidParameter: Foundation.NSError
    public static let allocationFailed: Foundation.NSError
    public static let rateMustBeNonZero: Foundation.NSError
  }
}
@available(watchOS 6.0, *)
extension CoreMedia.CMClock {
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public static var typeID: CoreFoundation.CFTypeID {
    get
  }
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public static var hostTimeClock: CoreMedia.CMClock {
    get
  }
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public static func convertHostTimeToSystemUnits(_ hostTime: CoreMedia.CMTime) -> Swift.UInt64
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public static func convertSystemUnitsToHostTime(_ systemUnits: Swift.UInt64) -> CoreMedia.CMTime
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public var time: CoreMedia.CMTime {
    get
  }
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public func anchorTime() throws -> (anchorTime: CoreMedia.CMTime, referenceTime: CoreMedia.CMTime)
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public func mightDrift(relativeTo otherClock: CoreMedia.CMClock) -> Swift.Bool
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public func invalidate()
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
public protocol _CMTimebaseInitTrampoline {
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  init(referencing: CoreMedia.CMTimebase)
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension CoreMedia._CMTimebaseInitTrampoline {
  @available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
  public init(sourceClock: CoreMedia.CMClock) throws
  @available(macOS, introduced: 10.15, deprecated: 12.0, renamed: "init(sourceClock:)")
  @available(iOS, introduced: 13.0, deprecated: 15.0, renamed: "init(sourceClock:)")
  @available(tvOS, introduced: 13.0, deprecated: 15.0, renamed: "init(sourceClock:)")
  @available(watchOS, introduced: 6.0, deprecated: 8.0, renamed: "init(sourceClock:)")
  @available(*, deprecated, renamed: "init(sourceClock:)")
  public init(masterClock: CoreMedia.CMClock) throws
  @available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
  public init(sourceTimebase: CoreMedia.CMTimebase) throws
  @available(macOS, introduced: 10.15, deprecated: 12.0, renamed: "init(sourceTimebase:)")
  @available(iOS, introduced: 13.0, deprecated: 15.0, renamed: "init(sourceTimebase:)")
  @available(tvOS, introduced: 13.0, deprecated: 15.0, renamed: "init(sourceTimebase:)")
  @available(watchOS, introduced: 6.0, deprecated: 8.0, renamed: "init(sourceTimebase:)")
  @available(*, deprecated, renamed: "init(sourceTimebase:)")
  public init(masterTimebase: CoreMedia.CMTimebase) throws
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension CoreMedia.CMTimebase : CoreMedia._CMTimebaseInitTrampoline {
}
@available(watchOS 6.0, *)
extension CoreMedia.CMTimebase {
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public static var typeID: CoreFoundation.CFTypeID {
    get
  }
  @available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
  public var sourceTimebase: CoreMedia.CMTimebase? {
    get
  }
  @available(macOS, introduced: 10.15, deprecated: 12.0, renamed: "sourceTimebase")
  @available(iOS, introduced: 13.0, deprecated: 15.0, renamed: "sourceTimebase")
  @available(tvOS, introduced: 13.0, deprecated: 15.0, renamed: "sourceTimebase")
  @available(watchOS, introduced: 6.0, deprecated: 8.0, renamed: "sourceTimebase")
  @available(*, deprecated, renamed: "sourceTimebase")
  public var masterTimebase: CoreMedia.CMTimebase? {
    get
  }
  @available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
  public var sourceClock: CoreMedia.CMClock? {
    get
  }
  @available(macOS, introduced: 10.15, deprecated: 12.0, renamed: "sourceClock")
  @available(iOS, introduced: 13.0, deprecated: 15.0, renamed: "sourceClock")
  @available(tvOS, introduced: 13.0, deprecated: 15.0, renamed: "sourceClock")
  @available(watchOS, introduced: 6.0, deprecated: 8.0, renamed: "sourceClock")
  @available(*, deprecated, renamed: "sourceClock")
  public var masterClock: CoreMedia.CMClock? {
    get
  }
  @available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
  public var source: CoreMedia.CMSyncProtocol {
    get
    set
  }
  @available(macOS, introduced: 10.15, deprecated: 12.0, renamed: "source")
  @available(iOS, introduced: 13.0, deprecated: 15.0, renamed: "source")
  @available(tvOS, introduced: 13.0, deprecated: 15.0, renamed: "source")
  @available(watchOS, introduced: 6.0, deprecated: 8.0, renamed: "source")
  public var master: CoreMedia.CMSyncProtocol {
    get
    set
  }
  @available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
  public var ultimateSourceClock: CoreMedia.CMClock {
    get
  }
  @available(macOS, introduced: 10.15, deprecated: 12.0, renamed: "ultimateSourceClock")
  @available(iOS, introduced: 13.0, deprecated: 15.0, renamed: "ultimateSourceClock")
  @available(tvOS, introduced: 13.0, deprecated: 15.0, renamed: "ultimateSourceClock")
  @available(watchOS, introduced: 6.0, deprecated: 8.0, renamed: "ultimateSourceClock")
  @available(*, deprecated, renamed: "ultimateSourceClock")
  public var ultimateMasterClock: CoreMedia.CMClock {
    get
  }
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public var time: CoreMedia.CMTime {
    get
  }
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public func time(withTimescale timescale: CoreMedia.CMTimeScale, rounding: CoreMedia.CMTimeRoundingMethod = .`default`) -> CoreMedia.CMTime
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public func setTime(_ time: CoreMedia.CMTime) throws
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public func setAnchorTime(_ anchorTime: CoreMedia.CMTime, referenceTime: CoreMedia.CMTime) throws
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public var rate: Swift.Double {
    get
  }
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public var timeAndRate: (time: CoreMedia.CMTime, rate: Swift.Double) {
    get
  }
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public func setRate(_ rate: Swift.Double) throws
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public func setRateAndAnchorTime(rate: Swift.Double, anchorTime: CoreMedia.CMTime, referenceTime: CoreMedia.CMTime) throws
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public var effectiveRate: Swift.Double {
    get
  }
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public func addTimer(_ timer: Foundation.Timer, on runloop: Foundation.RunLoop) throws
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public static let veryLongTimeInterval: CoreFoundation.CFTimeInterval
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public static let farFuture: CoreFoundation.CFAbsoluteTime
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public func removeTimer(_ timer: Foundation.Timer) throws
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public func setTimerNextFireTime(_ timer: Foundation.Timer, fireTime: CoreMedia.CMTime) throws
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public func setTimerToFireImmediately(_ timer: Foundation.Timer) throws
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public func addTimer<T>(_ timer: T) throws where T : Dispatch.DispatchSourceTimer
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public func removeTimer<T>(_ timer: T) throws where T : Dispatch.DispatchSourceTimer
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public func setTimerNextFireTime<T>(_ timer: T, fireTime: CoreMedia.CMTime) throws where T : Dispatch.DispatchSourceTimer
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public func setTimerToFireImmediately<T>(_ timer: T) throws where T : Dispatch.DispatchSourceTimer
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public func notificationBarrier() throws
}
@available(*, deprecated, renamed: "CMTimebaseSetAnchorTime(_:timebaseTime:immediateSourceTime:)")
@_alwaysEmitIntoClient public func CMTimebaseSetAnchorTime(_ timebase: CoreMedia.CMTimebase, timebaseTime: CoreMedia.CMTime, immediateMasterTime: CoreMedia.CMTime) {
  CMTimebaseSetAnchorTime( timebase, timebaseTime:timebaseTime, immediateSourceTime:immediateMasterTime)
}
@available(*, deprecated, renamed: "CMTimebaseSetRateAndAnchorTime(_:rate:anchorTime:immediateSourceTime:)")
@_alwaysEmitIntoClient public func CMTimebaseSetRateAndAnchorTime(_ timebase: CoreMedia.CMTimebase, rate: Swift.Double, anchorTime: CoreMedia.CMTime, immediateMasterTime: CoreMedia.CMTime) {
  CMTimebaseSetRateAndAnchorTime( timebase, rate: rate, anchorTime:anchorTime, immediateSourceTime:immediateMasterTime)
}
@available(watchOS 6.0, *)
extension CoreMedia.CMTimebase {
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public static let effectiveRateChanged: Foundation.NSNotification.Name
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public static let timeJumped: Foundation.NSNotification.Name
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public struct NotificationKey : CoreMedia._CMObjectiveCBridgeableWithRawValue {
    public typealias RawValue = CoreFoundation.CFString
    public typealias _ObjectiveCType = CoreFoundation.CFString
    public var rawValue: CoreFoundation.CFString
    public init(rawValue: CoreFoundation.CFString)
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    public static let eventTime: CoreMedia.CMTimebase.NotificationKey
  }
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
public protocol CMSyncProtocol {
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  func rate<T>(relativeTo clockOrTimebase: T) -> Swift.Double where T : CoreMedia.CMSyncProtocol
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  func rateAndAnchorTime<T>(relativeTo clockOrTimebase: T) throws -> (rate: Swift.Double, anchorTime: CoreMedia.CMTime, referenceTime: CoreMedia.CMTime) where T : CoreMedia.CMSyncProtocol
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  func convertTime<T>(_ time: CoreMedia.CMTime, to clockOrTimebase: T) -> CoreMedia.CMTime where T : CoreMedia.CMSyncProtocol
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  func mightDrift<T>(relativeTo clockOrTimebase: T) -> Swift.Bool where T : CoreMedia.CMSyncProtocol
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  var time: CoreMedia.CMTime { get }
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension CoreMedia.CMTimebase : CoreMedia.CMSyncProtocol {
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public func rate<T>(relativeTo relativeToClockOrTimebase: T) -> Swift.Double where T : CoreMedia.CMSyncProtocol
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public func rateAndAnchorTime<T>(relativeTo clockOrTimebase: T) throws -> (rate: Swift.Double, anchorTime: CoreMedia.CMTime, referenceTime: CoreMedia.CMTime) where T : CoreMedia.CMSyncProtocol
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public func convertTime<T>(_ time: CoreMedia.CMTime, to clockOrTimebase: T) -> CoreMedia.CMTime where T : CoreMedia.CMSyncProtocol
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public func mightDrift<T>(relativeTo clockOrTimebase: T) -> Swift.Bool where T : CoreMedia.CMSyncProtocol
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension CoreMedia.CMClock : CoreMedia.CMSyncProtocol {
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public func rate<T>(relativeTo relativeToClockOrTimebase: T) -> Swift.Double where T : CoreMedia.CMSyncProtocol
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public func rateAndAnchorTime<T>(relativeTo clockOrTimebase: T) throws -> (rate: Swift.Double, anchorTime: CoreMedia.CMTime, referenceTime: CoreMedia.CMTime) where T : CoreMedia.CMSyncProtocol
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public func convertTime<T>(_ time: CoreMedia.CMTime, to clockOrTimebase: T) -> CoreMedia.CMTime where T : CoreMedia.CMSyncProtocol
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public func mightDrift<T>(relativeTo clockOrTimebase: T) -> Swift.Bool where T : CoreMedia.CMSyncProtocol
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
public protocol CMAttachmentBearerProtocol {
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  var attachments: CoreMedia.CMAttachmentBearerAttachments { get }
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  func propagateAttachments<T>(to destination: T) where T : CoreMedia.CMAttachmentBearerProtocol
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
public struct CMAttachmentBearerAttachments {
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public enum Value {
    case shouldNotPropagate(Any)
    case shouldPropagate(Any)
    public var value: Any {
      get
    }
    public var mode: CoreMedia.CMAttachmentBearerAttachments.Mode {
      get
    }
  }
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public enum Mode : CoreMedia.CMAttachmentMode {
    case shouldNotPropagate
    case shouldPropagate
    public init?(rawValue: CoreMedia.CMAttachmentMode)
    public typealias RawValue = CoreMedia.CMAttachmentMode
    public var rawValue: CoreMedia.CMAttachmentMode {
      get
    }
  }
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public subscript(key: Swift.String) -> CoreMedia.CMAttachmentBearerAttachments.Value? {
    get
    set(newValue)
  }
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public func removeAll()
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public var nonPropagated: [Swift.String : Any] {
    get
  }
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public var propagated: [Swift.String : Any] {
    get
  }
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public func merge(_ attachments: [Swift.String : Any], mode: CoreMedia.CMAttachmentBearerAttachments.Mode)
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension CoreMedia.CMBlockBuffer : CoreMedia.CMAttachmentBearerProtocol {
  public var attachments: CoreMedia.CMAttachmentBearerAttachments {
    get
    _modify
  }
  public func propagateAttachments<T>(to destination: T) where T : CoreMedia.CMAttachmentBearerProtocol
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension CoreMedia.CMSampleBuffer : CoreMedia.CMAttachmentBearerProtocol {
  public var attachments: CoreMedia.CMAttachmentBearerAttachments {
    get
    _modify
  }
  public func propagateAttachments<T>(to destination: T) where T : CoreMedia.CMAttachmentBearerProtocol
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension CoreVideo.CVBuffer : CoreMedia.CMAttachmentBearerProtocol {
  public var attachments: CoreMedia.CMAttachmentBearerAttachments {
    get
    _modify
  }
  public func propagateAttachments<T>(to destination: T) where T : CoreMedia.CMAttachmentBearerProtocol
}
@available(macOS 10.15, macCatalyst 13.0, *)
@available(iOS, unavailable)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
public protocol _CMAudioDeviceClockInitTrampoline {
  @available(macOS 10.15, macCatalyst 13.0, *)
  init(referencing: CoreMedia.CMClock)
}
@available(macOS 10.15, macCatalyst 13.0, *)
@available(iOS, unavailable)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension CoreMedia._CMAudioDeviceClockInitTrampoline {
  @available(macOS 10.15, macCatalyst 13.0, *)
  @available(iOS, unavailable)
  @available(tvOS, unavailable)
  @available(watchOS, unavailable)
  public init(audioDeviceUID: Swift.String?) throws
  @available(macOS 10.15, macCatalyst 13.0, *)
  @available(iOS, unavailable)
  @available(tvOS, unavailable)
  @available(watchOS, unavailable)
  public init(audioDeviceID: CoreAudio.AudioDeviceID) throws
}
@available(macOS 10.15, macCatalyst 13.0, *)
@available(iOS, unavailable)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension CoreMedia.CMClock : CoreMedia._CMAudioDeviceClockInitTrampoline {
}
extension CoreMedia.CMClock {
  @available(macOS 10.15, macCatalyst 13.0, *)
  @available(iOS, unavailable)
  @available(tvOS, unavailable)
  @available(watchOS, unavailable)
  public func setAudioDeviceUID(_ deviceUID: Swift.String?) throws
  @available(macOS 10.15, macCatalyst 13.0, *)
  @available(iOS, unavailable)
  @available(tvOS, unavailable)
  @available(watchOS, unavailable)
  public func setAudioDeviceID(_ deviceID: CoreAudio.AudioDeviceID) throws
  @available(macOS 10.15, macCatalyst 13.0, *)
  @available(iOS, unavailable)
  @available(tvOS, unavailable)
  @available(watchOS, unavailable)
  public func audioDevice() throws -> (deviceUID: Swift.String?, deviceID: CoreAudio.AudioDeviceID, trackingDefaultDevice: Swift.Bool)
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
public protocol _CMSimpleQueueInitTrampoline {
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  init(referencing: CoreMedia.CMSimpleQueue)
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension CoreMedia._CMSimpleQueueInitTrampoline {
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public init(capacity: Swift.Int) throws
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension CoreMedia.CMSimpleQueue : CoreMedia._CMSimpleQueueInitTrampoline {
}
@available(watchOS 6.0, *)
extension CoreMedia.CMSimpleQueue {
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public struct Error {
    public static let allocationFailed: Foundation.NSError
    public static let requiredParameterMissing: Foundation.NSError
    public static let parameterOutOfRange: Foundation.NSError
    public static let queueIsFull: Foundation.NSError
  }
}
@available(watchOS 6.0, *)
extension CoreMedia.CMSimpleQueue {
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public static var typeID: CoreFoundation.CFTypeID {
    get
  }
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public func enqueue(_ element: Swift.UnsafeRawPointer) throws
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public func dequeue() -> Swift.UnsafeRawPointer?
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public var head: Swift.UnsafeRawPointer? {
    get
  }
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public func reset() throws
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public var capacity: Swift.Int {
    get
  }
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public var count: Swift.Int {
    get
  }
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public var fullness: Swift.Float {
    get
  }
}
@available(watchOS 6.0, *)
extension CoreMedia.CMTimeRange {
  @available(watchOS 6.0, *)
  public init(start: CoreMedia.CMTime, end: CoreMedia.CMTime)
  @available(watchOS 6.0, *)
  public var isValid: Swift.Bool {
    get
  }
  @available(watchOS 6.0, *)
  public var isIndefinite: Swift.Bool {
    get
  }
  @available(watchOS 6.0, *)
  public var isEmpty: Swift.Bool {
    get
  }
  @available(watchOS 6.0, *)
  public var end: CoreMedia.CMTime {
    get
  }
  @available(watchOS 6.0, *)
  public func union(_ otherRange: CoreMedia.CMTimeRange) -> CoreMedia.CMTimeRange
  @available(watchOS 6.0, *)
  public func intersection(_ otherRange: CoreMedia.CMTimeRange) -> CoreMedia.CMTimeRange
  @available(watchOS 6.0, *)
  public func containsTime(_ time: CoreMedia.CMTime) -> Swift.Bool
  @available(watchOS 6.0, *)
  public func containsTimeRange(_ range: CoreMedia.CMTimeRange) -> Swift.Bool
}
@available(watchOS 6.0, *)
public func CMTIMERANGE_IS_VALID(_ range: CoreMedia.CMTimeRange) -> Swift.Bool
@available(watchOS 6.0, *)
public func CMTIMERANGE_IS_INVALID(_ range: CoreMedia.CMTimeRange) -> Swift.Bool
@available(watchOS 6.0, *)
public func CMTIMERANGE_IS_INDEFINITE(_ range: CoreMedia.CMTimeRange) -> Swift.Bool
@available(watchOS 6.0, *)
public func CMTIMERANGE_IS_EMPTY(_ range: CoreMedia.CMTimeRange) -> Swift.Bool
@available(watchOS 6.0, *)
extension CoreMedia.CMTimeRange : Swift.Equatable {
  @available(watchOS 6.0, *)
  public static func == (range1: CoreMedia.CMTimeRange, range2: CoreMedia.CMTimeRange) -> Swift.Bool
  @available(watchOS 6.0, *)
  public static func != (range1: CoreMedia.CMTimeRange, range2: CoreMedia.CMTimeRange) -> Swift.Bool
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
public protocol _CMSampleBufferInitTrampoline {
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  init(referencing: CoreMedia.CMSampleBuffer)
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension CoreMedia._CMSampleBufferInitTrampoline {
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public init(dataBuffer: CoreMedia.CMBlockBuffer?, formatDescription: CoreMedia.CMFormatDescription?, numSamples: CoreMedia.CMItemCount, sampleTimings: [CoreMedia.CMSampleTimingInfo], sampleSizes: [Swift.Int]) throws
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public init(dataBuffer: CoreMedia.CMBlockBuffer?, dataReady: Swift.Bool = false, formatDescription: CoreMedia.CMFormatDescription?, numSamples: CoreMedia.CMItemCount, sampleTimings: [CoreMedia.CMSampleTimingInfo], sampleSizes: [Swift.Int], makeDataReadyHandler: @escaping CoreMedia.CMSampleBufferMakeDataReadyHandler) throws
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public init(dataBuffer: CoreMedia.CMBlockBuffer?, formatDescription: CoreMedia.CMFormatDescription, numSamples: CoreMedia.CMItemCount, presentationTimeStamp: CoreMedia.CMTime, packetDescriptions: [CoreAudioTypes.AudioStreamPacketDescription]) throws
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public init(dataBuffer: CoreMedia.CMBlockBuffer?, dataReady: Swift.Bool = false, formatDescription: CoreMedia.CMFormatDescription, numSamples: CoreMedia.CMItemCount, presentationTimeStamp: CoreMedia.CMTime, packetDescriptions: [CoreAudioTypes.AudioStreamPacketDescription], makeDataReadyHandler: @escaping CoreMedia.CMSampleBufferMakeDataReadyHandler) throws
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public init(imageBuffer: CoreVideo.CVImageBuffer, formatDescription: CoreMedia.CMVideoFormatDescription, sampleTiming: CoreMedia.CMSampleTimingInfo) throws
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public init(imageBuffer: CoreVideo.CVImageBuffer, dataReady: Swift.Bool = false, formatDescription: CoreMedia.CMVideoFormatDescription, sampleTiming: CoreMedia.CMSampleTimingInfo, makeDataReadyHandler: @escaping CoreMedia.CMSampleBufferMakeDataReadyHandler) throws
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public init(copying sampleBuffer: CoreMedia.CMSampleBuffer) throws
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public init(copying sampleBuffer: CoreMedia.CMSampleBuffer, withNewTiming sampleTimings: [CoreMedia.CMSampleTimingInfo]) throws
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public init(copying sampleBuffer: CoreMedia.CMSampleBuffer, forRange range: Swift.Range<Swift.Int>) throws
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension CoreMedia.CMSampleBuffer : CoreMedia._CMSampleBufferInitTrampoline {
}
@available(watchOS 6.0, *)
extension CoreMedia.CMSampleBuffer {
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public struct Error {
    public static let allocationFailed: Foundation.NSError
    public static let requiredParameterMissing: Foundation.NSError
    public static let alreadyHasDataBuffer: Foundation.NSError
    public static let bufferNotReady: Foundation.NSError
    public static let sampleIndexOutOfRange: Foundation.NSError
    public static let bufferHasNoSampleSizes: Foundation.NSError
    public static let bufferHasNoSampleTimingInfo: Foundation.NSError
    public static let arrayTooSmall: Foundation.NSError
    public static let invalidEntryCount: Foundation.NSError
    public static let cannotSubdivide: Foundation.NSError
    public static let sampleTimingInfoInvalid: Foundation.NSError
    public static let invalidMediaTypeForOperation: Foundation.NSError
    public static let invalidSampleData: Foundation.NSError
    public static let invalidMediaFormat: Foundation.NSError
    public static let invalidated: Foundation.NSError
    public static let dataFailed: Foundation.NSError
    public static let dataCanceled: Foundation.NSError
  }
}
@available(watchOS 6.0, *)
extension CoreMedia.CMSampleBuffer {
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public struct Flags : Swift.OptionSet {
    public let rawValue: Swift.UInt32
    public init(rawValue: Swift.UInt32)
    public static let audioBufferListAssure16ByteAlignment: CoreMedia.CMSampleBuffer.Flags
    public typealias ArrayLiteralElement = CoreMedia.CMSampleBuffer.Flags
    public typealias Element = CoreMedia.CMSampleBuffer.Flags
    public typealias RawValue = Swift.UInt32
  }
}
@available(watchOS 6.0, *)
extension CoreMedia.CMSampleBuffer {
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public static var typeID: CoreFoundation.CFTypeID {
    get
  }
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public func setDataBuffer(_ dataBuffer: CoreMedia.CMBlockBuffer) throws
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public var dataBuffer: CoreMedia.CMBlockBuffer? {
    get
  }
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public var imageBuffer: CoreVideo.CVImageBuffer? {
    get
  }
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public func setDataBuffer(fromAudioBufferList bufferList: Swift.UnsafePointer<CoreAudioTypes.AudioBufferList>, blockBufferMemoryAllocator: CoreFoundation.CFAllocator? = kCFAllocatorDefault, flags: CoreMedia.CMSampleBuffer.Flags = []) throws
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public func withAudioBufferList<R>(blockBufferMemoryAllocator: CoreFoundation.CFAllocator? = kCFAllocatorDefault, flags: CoreMedia.CMSampleBuffer.Flags = [], body: (CoreAudio.UnsafeMutableAudioBufferListPointer, CoreMedia.CMBlockBuffer) throws -> R) throws -> R
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public func audioStreamPacketDescriptions() throws -> [CoreAudioTypes.AudioStreamPacketDescription]
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public func withUnsafeAudioStreamPacketDescriptions<R>(_ body: (Swift.UnsafeBufferPointer<CoreAudioTypes.AudioStreamPacketDescription>) throws -> R) throws -> R
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public func copyPCMData(fromRange range: Swift.Range<Swift.Int>, into bufferList: Swift.UnsafeMutablePointer<CoreAudioTypes.AudioBufferList>) throws
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public enum DataReadiness : Swift.Hashable {
    case notReady
    case ready
    case failed(Darwin.OSStatus)
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: CoreMedia.CMSampleBuffer.DataReadiness, b: CoreMedia.CMSampleBuffer.DataReadiness) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
  }
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public var dataReadiness: CoreMedia.CMSampleBuffer.DataReadiness {
    get
  }
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public func setDataReadiness(_ newValue: CoreMedia.CMSampleBuffer.DataReadiness) throws
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public func makeDataReady() throws
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public func trackDataReadiness(_ sampleBufferToTrack: CoreMedia.CMSampleBuffer) throws
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public func invalidate() throws
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public func setInvalidateHandler(_ body: @escaping (CoreMedia.CMSampleBuffer) throws -> Swift.Void) throws
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public var isValid: Swift.Bool {
    get
  }
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public var numSamples: Swift.Int {
    get
  }
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public var duration: CoreMedia.CMTime {
    get
  }
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public var presentationTimeStamp: CoreMedia.CMTime {
    get
  }
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public var decodeTimeStamp: CoreMedia.CMTime {
    get
  }
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public var outputDuration: CoreMedia.CMTime {
    get
  }
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public var outputPresentationTimeStamp: CoreMedia.CMTime {
    get
  }
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public func setOutputPresentationTimeStamp(_ pts: CoreMedia.CMTime) throws
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public var outputDecodeTimeStamp: CoreMedia.CMTime {
    get
  }
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public func sampleTimingInfos() throws -> [CoreMedia.CMSampleTimingInfo]
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public func outputSampleTimingInfos() throws -> [CoreMedia.CMSampleTimingInfo]
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public func sampleTimingInfo(at sampleIndex: CoreMedia.CMItemIndex) throws -> CoreMedia.CMSampleTimingInfo
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public func sampleSizes() throws -> [Swift.Int]
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public func sampleSize(at sampleIndex: Swift.Int) -> Swift.Int
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public var totalSampleSize: Swift.Int {
    get
  }
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public var formatDescription: CoreMedia.CMFormatDescription? {
    get
  }
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public struct PerSampleAttachmentsDictionary : Swift.Sequence {
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    public struct Key : CoreMedia._CMObjectiveCBridgeableWithRawValue {
      public typealias _ObjectiveCType = CoreFoundation.CFString
      public typealias RawValue = CoreFoundation.CFString
      public var rawValue: CoreFoundation.CFString
      public init(rawValue: CoreFoundation.CFString)
      public static let notSync: CoreMedia.CMSampleBuffer.PerSampleAttachmentsDictionary.Key
      public static let partialSync: CoreMedia.CMSampleBuffer.PerSampleAttachmentsDictionary.Key
      public static let hasRedundantCoding: CoreMedia.CMSampleBuffer.PerSampleAttachmentsDictionary.Key
      public static let isDependedOnByOthers: CoreMedia.CMSampleBuffer.PerSampleAttachmentsDictionary.Key
      public static let dependsOnOthers: CoreMedia.CMSampleBuffer.PerSampleAttachmentsDictionary.Key
      public static let earlierDisplayTimesAllowed: CoreMedia.CMSampleBuffer.PerSampleAttachmentsDictionary.Key
      public static let displayImmediately: CoreMedia.CMSampleBuffer.PerSampleAttachmentsDictionary.Key
      public static let doNotDisplay: CoreMedia.CMSampleBuffer.PerSampleAttachmentsDictionary.Key
      public static let hevcTemporalLevelInfo: CoreMedia.CMSampleBuffer.PerSampleAttachmentsDictionary.Key
      public static let hevcTemporalSubLayerAccess: CoreMedia.CMSampleBuffer.PerSampleAttachmentsDictionary.Key
      public static let hevcStepwiseTemporalSubLayerAccess: CoreMedia.CMSampleBuffer.PerSampleAttachmentsDictionary.Key
      public static let hevcSyncSampleNALUnitType: CoreMedia.CMSampleBuffer.PerSampleAttachmentsDictionary.Key
      public static let audioIndependentSampleDecoderRefreshCount: CoreMedia.CMSampleBuffer.PerSampleAttachmentsDictionary.Key
    }
    public typealias Element = (key: CoreMedia.CMSampleBuffer.PerSampleAttachmentsDictionary.Key, value: Any)
    public struct Iterator : Swift.IteratorProtocol {
      public mutating func next() -> (key: CoreMedia.CMSampleBuffer.PerSampleAttachmentsDictionary.Key, value: Any)?
      public typealias Element = (key: CoreMedia.CMSampleBuffer.PerSampleAttachmentsDictionary.Key, value: Any)
    }
    public func makeIterator() -> CoreMedia.CMSampleBuffer.PerSampleAttachmentsDictionary.Iterator
    public subscript(key: CoreMedia.CMSampleBuffer.PerSampleAttachmentsDictionary.Key) -> Any? {
      get
      set
    }
  }
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public struct SampleAttachmentsArray : Swift.Collection {
    public func index(after i: Swift.Int) -> Swift.Int
    public var startIndex: Swift.Int
    public var endIndex: Swift.Int
    public typealias Index = Swift.Int
    public subscript(sample: Swift.Int) -> CoreMedia.CMSampleBuffer.PerSampleAttachmentsDictionary {
      get
      _modify
    }
    public typealias Element = CoreMedia.CMSampleBuffer.PerSampleAttachmentsDictionary
    public typealias Indices = Swift.DefaultIndices<CoreMedia.CMSampleBuffer.SampleAttachmentsArray>
    public typealias Iterator = Swift.IndexingIterator<CoreMedia.CMSampleBuffer.SampleAttachmentsArray>
    public typealias SubSequence = Swift.Slice<CoreMedia.CMSampleBuffer.SampleAttachmentsArray>
  }
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public var sampleAttachments: CoreMedia.CMSampleBuffer.SampleAttachmentsArray {
    get
    _modify
  }
}
@available(watchOS 6.0, *)
extension CoreMedia.CMSampleBuffer {
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public struct SingleSampleBuffers : Swift.Sequence {
    public typealias Element = CoreMedia.CMSampleBuffer
    public struct Iterator : Swift.IteratorProtocol {
      public mutating func next() -> CoreMedia.CMSampleBuffer?
      public typealias Element = CoreMedia.CMSampleBuffer
    }
    public func makeIterator() -> CoreMedia.CMSampleBuffer.SingleSampleBuffers.Iterator
  }
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public func singleSampleBuffers() throws -> CoreMedia.CMSampleBuffer.SingleSampleBuffers
}
@available(watchOS 6.0, *)
extension CoreMedia.CMSampleBuffer {
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public struct AttachmentKey : CoreMedia._CMObjectiveCBridgeableWithRawValue {
    public typealias RawValue = CoreFoundation.CFString
    public typealias _ObjectiveCType = CoreFoundation.CFString
    public var rawValue: CoreFoundation.CFString
    public init(rawValue: CoreFoundation.CFString)
    public static let resetDecoderBeforeDecoding: CoreMedia.CMSampleBuffer.AttachmentKey
    public static let drainAfterDecoding: CoreMedia.CMSampleBuffer.AttachmentKey
    public static let postNotificationWhenConsumed: CoreMedia.CMSampleBuffer.AttachmentKey
    public static let resumeOutput: CoreMedia.CMSampleBuffer.AttachmentKey
    public static let transitionID: CoreMedia.CMSampleBuffer.AttachmentKey
    public static let trimDurationAtStart: CoreMedia.CMSampleBuffer.AttachmentKey
    public static let trimDurationAtEnd: CoreMedia.CMSampleBuffer.AttachmentKey
    public static let speedMultiplier: CoreMedia.CMSampleBuffer.AttachmentKey
    public static let reverse: CoreMedia.CMSampleBuffer.AttachmentKey
    public static let fillDiscontinuitiesWithSilence: CoreMedia.CMSampleBuffer.AttachmentKey
    public static let emptyMedia: CoreMedia.CMSampleBuffer.AttachmentKey
    public static let permanentEmptyMedia: CoreMedia.CMSampleBuffer.AttachmentKey
    public static let displayEmptyMediaImmediately: CoreMedia.CMSampleBuffer.AttachmentKey
    public static let endsPreviousSampleDuration: CoreMedia.CMSampleBuffer.AttachmentKey
    public static let sampleReferenceURL: CoreMedia.CMSampleBuffer.AttachmentKey
    public static let sampleReferenceByteOffset: CoreMedia.CMSampleBuffer.AttachmentKey
    public static let gradualDecoderRefresh: CoreMedia.CMSampleBuffer.AttachmentKey
    public static let droppedFrameReason: CoreMedia.CMSampleBuffer.AttachmentKey
    public static let droppedFrameReasonInfo: CoreMedia.CMSampleBuffer.AttachmentKey
    public static let stillImageLensStabilizationInfo: CoreMedia.CMSampleBuffer.AttachmentKey
    public static let cameraIntrinsicMatrix: CoreMedia.CMSampleBuffer.AttachmentKey
    public static let forceKeyFrame: CoreMedia.CMSampleBuffer.AttachmentKey
  }
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension CoreMedia.CMAttachmentBearerAttachments {
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public subscript(key: CoreMedia.CMSampleBuffer.AttachmentKey) -> CoreMedia.CMAttachmentBearerAttachments.Value? {
    get
    set(newValue)
  }
}
@available(watchOS 6.0, *)
extension CoreMedia.CMSampleBuffer {
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public static let dataBecameReady: Foundation.NSNotification.Name
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public static let dataFailed: Foundation.NSNotification.Name
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public struct NotificationKey : CoreMedia._CMObjectiveCBridgeableWithRawValue {
    public typealias RawValue = CoreFoundation.CFString
    public typealias _ObjectiveCType = CoreFoundation.CFString
    public var rawValue: CoreFoundation.CFString
    public init(rawValue: CoreFoundation.CFString)
    public static let status: CoreMedia.CMSampleBuffer.NotificationKey
  }
}
@available(watchOS 6.0, *)
extension CoreMedia.CMBufferQueue {
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public struct Handlers {
    public let getDecodeTimeStamp: CoreMedia.CMBufferGetTimeHandler?
    public let getPresentationTimeStamp: CoreMedia.CMBufferGetTimeHandler?
    public let getDuration: CoreMedia.CMBufferGetTimeHandler
    public let isDataReady: CoreMedia.CMBufferGetBooleanHandler?
    public let compare: CoreMedia.CMBufferCompareHandler?
    public let dataBecameReadyNotification: Swift.String?
    public let getSize: CoreMedia.CMBufferGetSizeHandler?
    public struct Builder {
      public var dataBecameReadyNotification: Swift.String?
      public mutating func getDecodeTimeStamp(_ body: @escaping CoreMedia.CMBufferGetTimeHandler)
      public mutating func getPresentationTimeStamp(_ body: @escaping CoreMedia.CMBufferGetTimeHandler)
      public mutating func getDuration(_ body: @escaping CoreMedia.CMBufferGetTimeHandler)
      public mutating func isDataReady(_ body: @escaping CoreMedia.CMBufferGetBooleanHandler)
      public mutating func compare(_ body: @escaping CoreMedia.CMBufferCompareHandler)
      public mutating func getSize(_ body: @escaping CoreMedia.CMBufferGetSizeHandler)
    }
    public init(withHandlers body: (inout CoreMedia.CMBufferQueue.Handlers.Builder) -> Swift.Void)
    public func withHandlers(_ body: (inout CoreMedia.CMBufferQueue.Handlers.Builder) -> Swift.Void) -> CoreMedia.CMBufferQueue.Handlers
    public static let unsortedSampleBuffers: CoreMedia.CMBufferQueue.Handlers
    public static let outputPTSSortedSampleBuffers: CoreMedia.CMBufferQueue.Handlers
  }
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
public protocol _CMBufferQueueInitTrampoline {
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  init(referencing: CoreMedia.CMBufferQueue)
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension CoreMedia._CMBufferQueueInitTrampoline {
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public init(capacity: CoreMedia.CMItemCount, handlers: CoreMedia.CMBufferQueue.Handlers) throws
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension CoreMedia.CMBufferQueue : CoreMedia._CMBufferQueueInitTrampoline {
}
@available(watchOS 6.0, *)
extension CoreMedia.CMBufferQueue {
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public struct Error {
    public static let allocationFailed: Foundation.NSError
    public static let requiredParameterMissing: Foundation.NSError
    public static let invalidCMBufferCallbacksStruct: Foundation.NSError
    public static let enqueueAfterEndOfData: Foundation.NSError
    public static let queueIsFull: Foundation.NSError
    public static let badTriggerDuration: Foundation.NSError
    public static let cannotModifyQueueFromTriggerCallback: Foundation.NSError
    public static let invalidTriggerCondition: Foundation.NSError
    public static let invalidTriggerToken: Foundation.NSError
    public static let invalidBuffer: Foundation.NSError
  }
}
@available(watchOS 6.0, *)
extension CoreMedia.CMBufferQueue {
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public typealias TriggerToken = CoreMedia.CMBufferQueueTriggerToken
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public enum TriggerCondition {
    case whenDurationBecomesLessThan(CoreMedia.CMTime)
    case whenDurationBecomesLessThanOrEqualTo(CoreMedia.CMTime)
    case whenDurationBecomesGreaterThan(CoreMedia.CMTime)
    case whenDurationBecomesGreaterThanOrEqualTo(CoreMedia.CMTime)
    case whenMinPresentationTimeStampChanges
    case whenMaxPresentationTimeStampChanges
    case whenDataBecomesReady
    case whenEndOfDataReached
    case whenReset
    case whenBufferCountBecomesLessThan(CoreMedia.CMItemCount)
    case whenBufferCountBecomesGreaterThan(CoreMedia.CMItemCount)
  }
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public func enqueue(_ buffer: CoreMedia.CMBuffer) throws
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public func dequeue() -> CoreMedia.CMBuffer?
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public func dequeueIfDataReady() -> CoreMedia.CMBuffer?
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public var head: CoreMedia.CMBuffer? {
    get
  }
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public var isEmpty: Swift.Bool {
    get
  }
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public func markEndOfData() throws
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public var containsEndOfData: Swift.Bool {
    get
  }
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public var isAtEndOfData: Swift.Bool {
    get
  }
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public func reset() throws
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public func reset(_ body: (CoreMedia.CMBuffer) throws -> ()) throws
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public var bufferCount: CoreMedia.CMItemCount {
    get
  }
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public var duration: CoreMedia.CMTime {
    get
  }
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public var minDecodeTimeStamp: CoreMedia.CMTime {
    get
  }
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public var firstDecodeTimeStamp: CoreMedia.CMTime {
    get
  }
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public var minPresentationTimeStamp: CoreMedia.CMTime {
    get
  }
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public var firstPresentationTimeStamp: CoreMedia.CMTime {
    get
  }
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public var maxPresentationTimeStamp: CoreMedia.CMTime {
    get
  }
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public var endPresentationTimeStamp: CoreMedia.CMTime {
    get
  }
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public var totalSize: Swift.Int {
    get
  }
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public func installTrigger(condition: CoreMedia.CMBufferQueue.TriggerCondition, _ body: CoreMedia.CMBufferQueueTriggerHandler? = nil) throws -> CoreMedia.CMBufferQueue.TriggerToken
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public func removeTrigger(_ triggerToken: CoreMedia.CMBufferQueue.TriggerToken) throws
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public func testTrigger(_ triggerToken: CoreMedia.CMBufferQueue.TriggerToken) -> Swift.Bool
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public struct Buffers : Swift.Sequence {
    public typealias Element = CoreMedia.CMBuffer
    public struct Iterator : Swift.IteratorProtocol {
      public mutating func next() -> CoreMedia.CMBuffer?
      public typealias Element = AnyObject
    }
    public func makeIterator() -> CoreMedia.CMBufferQueue.Buffers.Iterator
  }
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public var buffers: CoreMedia.CMBufferQueue.Buffers {
    get
  }
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public func setValidationHandler(_ body: @escaping (CoreMedia.CMBufferQueue, CoreMedia.CMBuffer) throws -> Swift.Void)
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public class var typeID: CoreFoundation.CFTypeID {
    get
  }
}
@available(watchOS 6.0, *)
extension CoreMedia.CMFormatDescription {
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public struct Extensions {
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    public struct Key : CoreMedia._CMObjectiveCBridgeableWithRawValue {
      public typealias RawValue = CoreFoundation.CFString
      public typealias _ObjectiveCType = CoreFoundation.CFString
      public var rawValue: CoreFoundation.CFString
      public init(rawValue: CoreFoundation.CFString)
      public static let originalCompressionSettings: CoreMedia.CMFormatDescription.Extensions.Key
      public static let sampleDescriptionExtensionAtoms: CoreMedia.CMFormatDescription.Extensions.Key
      public static let verbatimSampleDescription: CoreMedia.CMFormatDescription.Extensions.Key
      public static let verbatimISOSampleEntry: CoreMedia.CMFormatDescription.Extensions.Key
      public static let formatName: CoreMedia.CMFormatDescription.Extensions.Key
      public static let depth: CoreMedia.CMFormatDescription.Extensions.Key
      public static let cleanAperture: CoreMedia.CMFormatDescription.Extensions.Key
      public static let fieldCount: CoreMedia.CMFormatDescription.Extensions.Key
      public static let fieldDetail: CoreMedia.CMFormatDescription.Extensions.Key
      public static let pixelAspectRatio: CoreMedia.CMFormatDescription.Extensions.Key
      public static let colorPrimaries: CoreMedia.CMFormatDescription.Extensions.Key
      public static let transferFunction: CoreMedia.CMFormatDescription.Extensions.Key
      public static let gammaLevel: CoreMedia.CMFormatDescription.Extensions.Key
      public static let yCbCrMatrix: CoreMedia.CMFormatDescription.Extensions.Key
      public static let fullRangeVideo: CoreMedia.CMFormatDescription.Extensions.Key
      public static let iccProfile: CoreMedia.CMFormatDescription.Extensions.Key
      public static let bytesPerRow: CoreMedia.CMFormatDescription.Extensions.Key
      public static let chromaLocationTopField: CoreMedia.CMFormatDescription.Extensions.Key
      public static let chromaLocationBottomField: CoreMedia.CMFormatDescription.Extensions.Key
      public static let conformsToMPEG2VideoProfile: CoreMedia.CMFormatDescription.Extensions.Key
      public static let temporalQuality: CoreMedia.CMFormatDescription.Extensions.Key
      public static let spatialQuality: CoreMedia.CMFormatDescription.Extensions.Key
      public static let version: CoreMedia.CMFormatDescription.Extensions.Key
      public static let revisionLevel: CoreMedia.CMFormatDescription.Extensions.Key
      public static let vendor: CoreMedia.CMFormatDescription.Extensions.Key
      public static let masteringDisplayColorVolume: CoreMedia.CMFormatDescription.Extensions.Key
      public static let contentLightLevelInfo: CoreMedia.CMFormatDescription.Extensions.Key
      public static let alternativeTransferCharacteristics: CoreMedia.CMFormatDescription.Extensions.Key
      public static let auxiliaryTypeInfo: CoreMedia.CMFormatDescription.Extensions.Key
      public static let alphaChannelMode: CoreMedia.CMFormatDescription.Extensions.Key
      public static let containsAlphaChannel: CoreMedia.CMFormatDescription.Extensions.Key
      public static let displayFlags: CoreMedia.CMFormatDescription.Extensions.Key
      public static let backgroundColor: CoreMedia.CMFormatDescription.Extensions.Key
      public static let defaultTextBox: CoreMedia.CMFormatDescription.Extensions.Key
      public static let defaultStyle: CoreMedia.CMFormatDescription.Extensions.Key
      public static let horizontalJustification: CoreMedia.CMFormatDescription.Extensions.Key
      public static let verticalJustification: CoreMedia.CMFormatDescription.Extensions.Key
      public static let fontTable: CoreMedia.CMFormatDescription.Extensions.Key
      public static let textJustification: CoreMedia.CMFormatDescription.Extensions.Key
      public static let defaultFontName: CoreMedia.CMFormatDescription.Extensions.Key
      public static let sourceReferenceName: CoreMedia.CMFormatDescription.Extensions.Key
      public static let metadataKeyTable: CoreMedia.CMFormatDescription.Extensions.Key
      @available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
      public static let ambientViewingEnvironment: CoreMedia.CMFormatDescription.Extensions.Key
      @available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
      public static let bitsPerComponent: CoreMedia.CMFormatDescription.Extensions.Key
    }
    public struct Value {
      public var propertyListRepresentation: CoreFoundation.CFPropertyList
      public init(_ plist: CoreFoundation.CFPropertyList)
      public static func number<T>(_ value: T) -> CoreMedia.CMFormatDescription.Extensions.Value where T : Swift.Numeric
      public static func string(_ value: Swift.String) -> CoreMedia.CMFormatDescription.Extensions.Value
      public static func string(_ value: CoreFoundation.CFString) -> CoreMedia.CMFormatDescription.Extensions.Value
      @available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
      public static func data(_ value: CoreFoundation.CFData) -> CoreMedia.CMFormatDescription.Extensions.Value
      public static func cleanAperture<Width, Height, Horizontal, Vertical>(width: Width, height: Height, horizontalOffet: Horizontal, verticalOffset: Vertical) -> CoreMedia.CMFormatDescription.Extensions.Value where Width : Swift.Numeric, Height : Swift.Numeric, Horizontal : Swift.Numeric, Vertical : Swift.Numeric
      public static func cleanAperture(width: (numerator: Swift.Int, denominator: Swift.Int), height: (numerator: Swift.Int, denominator: Swift.Int), horizontalOffet: (numerator: Swift.Int, denominator: Swift.Int), verticalOffset: (numerator: Swift.Int, denominator: Swift.Int)) -> CoreMedia.CMFormatDescription.Extensions.Value
      public struct FieldDetail : CoreMedia._CMObjectiveCBridgeableWithRawValue {
        public typealias RawValue = CoreFoundation.CFString
        public typealias _ObjectiveCType = CoreFoundation.CFString
        public var rawValue: CoreFoundation.CFString
        public init(rawValue: CoreFoundation.CFString)
        public static let temporalTopFirst: CoreMedia.CMFormatDescription.Extensions.Value.FieldDetail
        public static let temporalBottomFirst: CoreMedia.CMFormatDescription.Extensions.Value.FieldDetail
        public static let spatialFirstLineEarly: CoreMedia.CMFormatDescription.Extensions.Value.FieldDetail
        public static let spatialFirstLineLate: CoreMedia.CMFormatDescription.Extensions.Value.FieldDetail
      }
      public static func fieldDetail(_ fieldDetail: CoreMedia.CMFormatDescription.Extensions.Value.FieldDetail) -> CoreMedia.CMFormatDescription.Extensions.Value
      public static func pixelAspectRatio<Horizontal, Vertical>(horizontalSpacing: Horizontal, verticalSpacing: Vertical) -> CoreMedia.CMFormatDescription.Extensions.Value where Horizontal : Swift.Numeric, Vertical : Swift.Numeric
      public struct ColorPrimaries : CoreMedia._CMObjectiveCBridgeableWithRawValue {
        public typealias RawValue = CoreFoundation.CFString
        public typealias _ObjectiveCType = CoreFoundation.CFString
        public var rawValue: CoreFoundation.CFString
        public init(rawValue: CoreFoundation.CFString)
        public static let itu_R_709_2: CoreMedia.CMFormatDescription.Extensions.Value.ColorPrimaries
        public static let ebu_3213: CoreMedia.CMFormatDescription.Extensions.Value.ColorPrimaries
        public static let smpte_C: CoreMedia.CMFormatDescription.Extensions.Value.ColorPrimaries
        public static let dci_P3: CoreMedia.CMFormatDescription.Extensions.Value.ColorPrimaries
        public static let p3_D65: CoreMedia.CMFormatDescription.Extensions.Value.ColorPrimaries
        public static let itu_R_2020: CoreMedia.CMFormatDescription.Extensions.Value.ColorPrimaries
        public static let p22: CoreMedia.CMFormatDescription.Extensions.Value.ColorPrimaries
      }
      public static func colorPrimaries(_ colorPrimaries: CoreMedia.CMFormatDescription.Extensions.Value.ColorPrimaries) -> CoreMedia.CMFormatDescription.Extensions.Value
      public struct TransferFunction : CoreMedia._CMObjectiveCBridgeableWithRawValue {
        public typealias RawValue = CoreFoundation.CFString
        public typealias _ObjectiveCType = CoreFoundation.CFString
        public var rawValue: CoreFoundation.CFString
        public init(rawValue: CoreFoundation.CFString)
        public static let itu_R_709_2: CoreMedia.CMFormatDescription.Extensions.Value.TransferFunction
        public static let smpte_240M_1995: CoreMedia.CMFormatDescription.Extensions.Value.TransferFunction
        public static let useGamma: CoreMedia.CMFormatDescription.Extensions.Value.TransferFunction
        public static let itu_R_2020: CoreMedia.CMFormatDescription.Extensions.Value.TransferFunction
        public static let smpte_ST_428_1: CoreMedia.CMFormatDescription.Extensions.Value.TransferFunction
        public static let smpte_ST_2084_PQ: CoreMedia.CMFormatDescription.Extensions.Value.TransferFunction
        public static let itu_R_2100_HLG: CoreMedia.CMFormatDescription.Extensions.Value.TransferFunction
        public static let linear: CoreMedia.CMFormatDescription.Extensions.Value.TransferFunction
        public static let sRGB: CoreMedia.CMFormatDescription.Extensions.Value.TransferFunction
      }
      public static func transferFunction(_ transferFunction: CoreMedia.CMFormatDescription.Extensions.Value.TransferFunction) -> CoreMedia.CMFormatDescription.Extensions.Value
      public struct YCbCrMatrix : CoreMedia._CMObjectiveCBridgeableWithRawValue {
        public typealias RawValue = CoreFoundation.CFString
        public typealias _ObjectiveCType = CoreFoundation.CFString
        public var rawValue: CoreFoundation.CFString
        public init(rawValue: CoreFoundation.CFString)
        public static let itu_R_709_2: CoreMedia.CMFormatDescription.Extensions.Value.YCbCrMatrix
        public static let itu_R_601_4: CoreMedia.CMFormatDescription.Extensions.Value.YCbCrMatrix
        public static let smpted_240M_1995: CoreMedia.CMFormatDescription.Extensions.Value.YCbCrMatrix
        public static let itu_R_2020: CoreMedia.CMFormatDescription.Extensions.Value.YCbCrMatrix
      }
      public static func yCbCrMatrix(_ yCbCrMatrix: CoreMedia.CMFormatDescription.Extensions.Value.YCbCrMatrix) -> CoreMedia.CMFormatDescription.Extensions.Value
      public struct ChromaLocation : CoreMedia._CMObjectiveCBridgeableWithRawValue {
        public typealias RawValue = CoreFoundation.CFString
        public typealias _ObjectiveCType = CoreFoundation.CFString
        public var rawValue: CoreFoundation.CFString
        public init(rawValue: CoreFoundation.CFString)
        public static let left: CoreMedia.CMFormatDescription.Extensions.Value.ChromaLocation
        public static let center: CoreMedia.CMFormatDescription.Extensions.Value.ChromaLocation
        public static let topLeft: CoreMedia.CMFormatDescription.Extensions.Value.ChromaLocation
        public static let top: CoreMedia.CMFormatDescription.Extensions.Value.ChromaLocation
        public static let bottomLeft: CoreMedia.CMFormatDescription.Extensions.Value.ChromaLocation
        public static let bottom: CoreMedia.CMFormatDescription.Extensions.Value.ChromaLocation
        public static let dv420: CoreMedia.CMFormatDescription.Extensions.Value.ChromaLocation
      }
      public static func chromaLocation(_ chromaLocation: CoreMedia.CMFormatDescription.Extensions.Value.ChromaLocation) -> CoreMedia.CMFormatDescription.Extensions.Value
      public struct MPEG2VideoProfile : CoreMedia._CMFormatDescriptionFourCCConvertible {
        public var rawValue: Darwin.FourCharCode
        @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
        public init(rawValue: Darwin.FourCharCode)
        @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
        public init(rawValue: Swift.Int32)
        public static let hdv_720p30: CoreMedia.CMFormatDescription.Extensions.Value.MPEG2VideoProfile
        public static let hdv_1080i60: CoreMedia.CMFormatDescription.Extensions.Value.MPEG2VideoProfile
        public static let hdv_1080i50: CoreMedia.CMFormatDescription.Extensions.Value.MPEG2VideoProfile
        public static let hdv_720p24: CoreMedia.CMFormatDescription.Extensions.Value.MPEG2VideoProfile
        public static let hdv_720p25: CoreMedia.CMFormatDescription.Extensions.Value.MPEG2VideoProfile
        public static let hdv_1080p24: CoreMedia.CMFormatDescription.Extensions.Value.MPEG2VideoProfile
        public static let hdv_1080p25: CoreMedia.CMFormatDescription.Extensions.Value.MPEG2VideoProfile
        public static let hdv_1080p30: CoreMedia.CMFormatDescription.Extensions.Value.MPEG2VideoProfile
        public static let hdv_720p60: CoreMedia.CMFormatDescription.Extensions.Value.MPEG2VideoProfile
        public static let hdv_720p50: CoreMedia.CMFormatDescription.Extensions.Value.MPEG2VideoProfile
        public static let xdcam_HD_1080i60_VBR35: CoreMedia.CMFormatDescription.Extensions.Value.MPEG2VideoProfile
        public static let xdcam_HD_1080i50_VBR35: CoreMedia.CMFormatDescription.Extensions.Value.MPEG2VideoProfile
        public static let xdcam_HD_1080p24_VBR35: CoreMedia.CMFormatDescription.Extensions.Value.MPEG2VideoProfile
        public static let xdcam_HD_1080p25_VBR35: CoreMedia.CMFormatDescription.Extensions.Value.MPEG2VideoProfile
        public static let xdcam_HD_1080p30_VBR35: CoreMedia.CMFormatDescription.Extensions.Value.MPEG2VideoProfile
        public static let xdcam_EX_720p24_VBR35: CoreMedia.CMFormatDescription.Extensions.Value.MPEG2VideoProfile
        public static let xdcam_EX_720p25_VBR35: CoreMedia.CMFormatDescription.Extensions.Value.MPEG2VideoProfile
        public static let xdcam_EX_720p30_VBR35: CoreMedia.CMFormatDescription.Extensions.Value.MPEG2VideoProfile
        public static let xdcam_EX_720p50_VBR35: CoreMedia.CMFormatDescription.Extensions.Value.MPEG2VideoProfile
        public static let xdcam_EX_720p60_VBR35: CoreMedia.CMFormatDescription.Extensions.Value.MPEG2VideoProfile
        public static let xdcam_EX_1080i60_VBR35: CoreMedia.CMFormatDescription.Extensions.Value.MPEG2VideoProfile
        public static let xdcam_EX_1080i50_VBR35: CoreMedia.CMFormatDescription.Extensions.Value.MPEG2VideoProfile
        public static let xdcam_EX_1080p24_VBR35: CoreMedia.CMFormatDescription.Extensions.Value.MPEG2VideoProfile
        public static let xdcam_EX_1080p25_VBR35: CoreMedia.CMFormatDescription.Extensions.Value.MPEG2VideoProfile
        public static let xdcam_EX_1080p30_VBR35: CoreMedia.CMFormatDescription.Extensions.Value.MPEG2VideoProfile
        public static let xdcam_HD422_720p50_CBR50: CoreMedia.CMFormatDescription.Extensions.Value.MPEG2VideoProfile
        public static let xdcam_HD422_720p60_CBR50: CoreMedia.CMFormatDescription.Extensions.Value.MPEG2VideoProfile
        public static let xdcam_HD422_1080i60_CBR50: CoreMedia.CMFormatDescription.Extensions.Value.MPEG2VideoProfile
        public static let xdcam_HD422_1080i50_CBR50: CoreMedia.CMFormatDescription.Extensions.Value.MPEG2VideoProfile
        public static let xdcam_HD422_1080p24_CBR50: CoreMedia.CMFormatDescription.Extensions.Value.MPEG2VideoProfile
        public static let xdcam_HD422_1080p25_CBR50: CoreMedia.CMFormatDescription.Extensions.Value.MPEG2VideoProfile
        public static let xdcam_HD422_1080p30_CBR50: CoreMedia.CMFormatDescription.Extensions.Value.MPEG2VideoProfile
        public static let xdcam_HD_540p: CoreMedia.CMFormatDescription.Extensions.Value.MPEG2VideoProfile
        public static let xdcam_HD422_540p: CoreMedia.CMFormatDescription.Extensions.Value.MPEG2VideoProfile
        public static let xdcam_HD422_720p24_CBR50: CoreMedia.CMFormatDescription.Extensions.Value.MPEG2VideoProfile
        public static let xdcam_HD422_720p25_CBR50: CoreMedia.CMFormatDescription.Extensions.Value.MPEG2VideoProfile
        public static let xdcam_HD422_720p30_CBR50: CoreMedia.CMFormatDescription.Extensions.Value.MPEG2VideoProfile
        public static let xf: CoreMedia.CMFormatDescription.Extensions.Value.MPEG2VideoProfile
        public typealias RawValue = Darwin.FourCharCode
        public typealias _ObjectiveCType = Foundation.NSNumber
      }
      public static func mpeg2VideoProfile(_ mpeg2VideoProfile: CoreMedia.CMFormatDescription.Extensions.Value.MPEG2VideoProfile) -> CoreMedia.CMFormatDescription.Extensions.Value
      public struct Vendor : CoreMedia._CMObjectiveCBridgeableWithRawValue {
        public var rawValue: CoreFoundation.CFString
        public typealias _ObjectiveCType = CoreFoundation.CFString
        @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
        public init(rawValue: CoreFoundation.CFString)
        public static let apple: CoreMedia.CMFormatDescription.Extensions.Value.Vendor
        public typealias RawValue = CoreFoundation.CFString
      }
      public static func vendor(_ vendor: CoreMedia.CMFormatDescription.Extensions.Value.Vendor) -> CoreMedia.CMFormatDescription.Extensions.Value
      public static func vendor(_ fourCC: Swift.String) -> CoreMedia.CMFormatDescription.Extensions.Value
      public struct AlphaChannelMode : CoreMedia._CMObjectiveCBridgeableWithRawValue {
        public typealias RawValue = CoreFoundation.CFString
        public typealias _ObjectiveCType = CoreFoundation.CFString
        public var rawValue: CoreFoundation.CFString
        public init(rawValue: CoreFoundation.CFString)
        public static let straightAlpha: CoreMedia.CMFormatDescription.Extensions.Value.AlphaChannelMode
        public static let premultipliedAlpha: CoreMedia.CMFormatDescription.Extensions.Value.AlphaChannelMode
      }
      public static func alphaChannelMode(_ alphaChannelMode: CoreMedia.CMFormatDescription.Extensions.Value.AlphaChannelMode) -> CoreMedia.CMFormatDescription.Extensions.Value
      public static func qtTextColor(red: CoreGraphics.CGFloat, green: CoreGraphics.CGFloat, blue: CoreGraphics.CGFloat, alpha: CoreGraphics.CGFloat) -> CoreMedia.CMFormatDescription.Extensions.Value
      public static func mobile3GPPTextColor(red: CoreGraphics.CGFloat, green: CoreGraphics.CGFloat, blue: CoreGraphics.CGFloat, alpha: CoreGraphics.CGFloat) -> CoreMedia.CMFormatDescription.Extensions.Value
      public static func fontTable(_ fontTable: [Swift.Int : Swift.String]) -> CoreMedia.CMFormatDescription.Extensions.Value
      public struct FontFace : Swift.OptionSet, CoreMedia._CMObjectiveCBridgeableWithRawValue {
        public typealias RawValue = Swift.UInt8
        public typealias _ObjectiveCType = Foundation.NSNumber
        public var rawValue: Swift.UInt8
        public init(rawValue: Swift.UInt8)
        public static let bold: CoreMedia.CMFormatDescription.Extensions.Value.FontFace
        public static let italic: CoreMedia.CMFormatDescription.Extensions.Value.FontFace
        public static let underline: CoreMedia.CMFormatDescription.Extensions.Value.FontFace
        public static let all: CoreMedia.CMFormatDescription.Extensions.Value.FontFace
        public typealias ArrayLiteralElement = CoreMedia.CMFormatDescription.Extensions.Value.FontFace
        public typealias Element = CoreMedia.CMFormatDescription.Extensions.Value.FontFace
      }
      public static func qtTextDefaultStyle(startChar: Swift.Int, height: Swift.Int, ascent: Swift.Int, localFontID: Swift.Int, fontFace: CoreMedia.CMFormatDescription.Extensions.Value.FontFace, fontSize: Swift.Int, foregroundColor: CoreMedia.CMFormatDescription.Extensions.Value, defaultFontName: Swift.String?) -> CoreMedia.CMFormatDescription.Extensions.Value
      public static func mobile3GPPTextDefaultStyle(startChar: Swift.Int, endChar: Swift.Int, localFontID: Swift.Int, fontFace: CoreMedia.CMFormatDescription.Extensions.Value.FontFace, fontSize: Swift.Int, foregroundColor: CoreMedia.CMFormatDescription.Extensions.Value) -> CoreMedia.CMFormatDescription.Extensions.Value
      public static func textRect(top: Swift.Int, left: Swift.Int, bottom: Swift.Int, right: Swift.Int) -> CoreMedia.CMFormatDescription.Extensions.Value
      public struct TextDisplayFlags : CoreMedia._CMObjectiveCBridgeableWithRawValue {
        public typealias RawValue = CoreMedia.CMTextDisplayFlags
        public typealias _ObjectiveCType = Foundation.NSNumber
        public var rawValue: CoreMedia.CMTextDisplayFlags
        public init(rawValue: CoreMedia.CMTextDisplayFlags)
        public static let scrollIn: CoreMedia.CMFormatDescription.Extensions.Value.TextDisplayFlags
        public static let scrollOut: CoreMedia.CMFormatDescription.Extensions.Value.TextDisplayFlags
        public static let scrollDirectionMask: CoreMedia.CMFormatDescription.Extensions.Value.TextDisplayFlags
        public static let scrollDirection_bottomToTop: CoreMedia.CMFormatDescription.Extensions.Value.TextDisplayFlags
        public static let scrollDirection_rightToLeft: CoreMedia.CMFormatDescription.Extensions.Value.TextDisplayFlags
        public static let scrollDirection_topToBottom: CoreMedia.CMFormatDescription.Extensions.Value.TextDisplayFlags
        public static let scrollDirection_leftToRight: CoreMedia.CMFormatDescription.Extensions.Value.TextDisplayFlags
        public static let continuousKaraoke: CoreMedia.CMFormatDescription.Extensions.Value.TextDisplayFlags
        public static let writeTextVertically: CoreMedia.CMFormatDescription.Extensions.Value.TextDisplayFlags
        public static let fillTextRegion: CoreMedia.CMFormatDescription.Extensions.Value.TextDisplayFlags
        public static let obeySubtitleFormatting: CoreMedia.CMFormatDescription.Extensions.Value.TextDisplayFlags
        public static let forcedSubtitlesPresent: CoreMedia.CMFormatDescription.Extensions.Value.TextDisplayFlags
        public static let allSubtitlesForced: CoreMedia.CMFormatDescription.Extensions.Value.TextDisplayFlags
        public var scrollDirection: CoreMedia.CMFormatDescription.Extensions.Value.TextDisplayFlags {
          get
        }
      }
      public static func textDisplayFlags(_ textDisplayFlags: Swift.Set<CoreMedia.CMFormatDescription.Extensions.Value.TextDisplayFlags>) -> CoreMedia.CMFormatDescription.Extensions.Value
      public struct TextJustification : CoreMedia._CMObjectiveCBridgeableWithRawValue {
        public typealias RawValue = Swift.Int8
        public typealias _ObjectiveCType = Foundation.NSNumber
        public var rawValue: Swift.Int8
        public init(rawValue: Swift.Int8)
        public static let left: CoreMedia.CMFormatDescription.Extensions.Value.TextJustification
        public static let top: CoreMedia.CMFormatDescription.Extensions.Value.TextJustification
        public static let centered: CoreMedia.CMFormatDescription.Extensions.Value.TextJustification
        public static let bottom: CoreMedia.CMFormatDescription.Extensions.Value.TextJustification
        public static let right: CoreMedia.CMFormatDescription.Extensions.Value.TextJustification
      }
      public static func textJustification(_ textJustification: CoreMedia.CMFormatDescription.Extensions.Value.TextJustification) -> CoreMedia.CMFormatDescription.Extensions.Value
      public static func sourceReferenceName(value: Swift.String, langCode: Swift.Int) -> CoreMedia.CMFormatDescription.Extensions.Value
    }
    public init()
    public init(base: [CoreFoundation.CFString : CoreFoundation.CFPropertyList]?)
    public subscript(key: CoreMedia.CMFormatDescription.Extensions.Key) -> CoreMedia.CMFormatDescription.Extensions.Value? {
      get
      set
    }
    public subscript(key: CoreFoundation.CFString) -> CoreFoundation.CFPropertyList? {
      get
      set
    }
  }
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension CoreMedia.CMFormatDescription.Extensions.Value : Swift.Hashable {
  public static func == (lhs: CoreMedia.CMFormatDescription.Extensions.Value, rhs: CoreMedia.CMFormatDescription.Extensions.Value) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension CoreMedia.CMFormatDescription.Extensions : Swift.Collection {
  public struct Index {
  }
  public var startIndex: CoreMedia.CMFormatDescription.Extensions.Index {
    get
  }
  public var endIndex: CoreMedia.CMFormatDescription.Extensions.Index {
    get
  }
  public subscript(position: CoreMedia.CMFormatDescription.Extensions.Index) -> (key: CoreFoundation.CFString, value: CoreFoundation.CFPropertyList) {
    get
  }
  public func index(after i: CoreMedia.CMFormatDescription.Extensions.Index) -> CoreMedia.CMFormatDescription.Extensions.Index
  public typealias Element = (key: CoreFoundation.CFString, value: CoreFoundation.CFPropertyList)
  public typealias Indices = Swift.DefaultIndices<CoreMedia.CMFormatDescription.Extensions>
  public typealias Iterator = Swift.IndexingIterator<CoreMedia.CMFormatDescription.Extensions>
  public typealias SubSequence = Swift.Slice<CoreMedia.CMFormatDescription.Extensions>
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension CoreMedia.CMFormatDescription.Extensions.Index : Swift.Equatable {
  public static func == (lhs: CoreMedia.CMFormatDescription.Extensions.Index, rhs: CoreMedia.CMFormatDescription.Extensions.Index) -> Swift.Bool
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension CoreMedia.CMFormatDescription.Extensions.Index : Swift.Comparable {
  public static func < (lhs: CoreMedia.CMFormatDescription.Extensions.Index, rhs: CoreMedia.CMFormatDescription.Extensions.Index) -> Swift.Bool
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension CoreMedia.CMFormatDescription.Extensions.Index : Swift.Hashable {
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension CoreMedia.CMFormatDescription.Extensions : Swift.Equatable {
  public static func == (lhs: CoreMedia.CMFormatDescription.Extensions, rhs: CoreMedia.CMFormatDescription.Extensions) -> Swift.Bool
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension CoreMedia.CMFormatDescription.Extensions : Swift.Hashable {
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
public protocol _CMFormatDescriptionInitTrampoline {
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  init(referencing: CoreMedia.CMFormatDescription)
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension CoreMedia._CMFormatDescriptionInitTrampoline {
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public init(mediaType: CoreMedia.CMFormatDescription.MediaType, mediaSubType: CoreMedia.CMFormatDescription.MediaSubType, extensions: CoreMedia.CMFormatDescription.Extensions? = nil) throws
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension CoreMedia._CMFormatDescriptionInitTrampoline {
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public init(audioStreamBasicDescription: CoreAudioTypes.AudioStreamBasicDescription, layoutSize: Swift.Int, layout: Swift.UnsafePointer<CoreAudioTypes.AudioChannelLayout>?, magicCookie: Foundation.Data?, extensions: CoreMedia.CMFormatDescription.Extensions? = nil) throws
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public init(audioStreamBasicDescription: CoreAudioTypes.AudioStreamBasicDescription, layout: CoreAudio.ManagedAudioChannelLayout? = nil, magicCookie: Foundation.Data? = nil, extensions: CoreMedia.CMFormatDescription.Extensions? = nil) throws
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public init(audioFormatDescriptionArray: [CoreMedia.CMAudioFormatDescription]) throws
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension CoreMedia._CMFormatDescriptionInitTrampoline {
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public init(videoCodecType: CoreMedia.CMFormatDescription.MediaSubType, width: Swift.Int, height: Swift.Int, extensions: CoreMedia.CMFormatDescription.Extensions? = nil) throws
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public init(imageBuffer: CoreVideo.CVImageBuffer) throws
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public init(h264ParameterSets: [Foundation.Data], nalUnitHeaderLength: Swift.Int = 4) throws
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public init(hevcParameterSets: [Foundation.Data], nalUnitHeaderLength: Swift.Int = 4, extensions: CoreMedia.CMFormatDescription.Extensions? = nil) throws
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension CoreMedia._CMFormatDescriptionInitTrampoline {
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public init(muxedStreamType: CoreMedia.CMFormatDescription.MediaSubType, extensions: CoreMedia.CMFormatDescription.Extensions? = nil) throws
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension CoreMedia._CMFormatDescriptionInitTrampoline {
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public init(timeCodeFormatType: CoreMedia.CMFormatDescription.MediaSubType, frameDuration: CoreMedia.CMTime, frameQuanta: Swift.Int, flags: CoreMedia.CMTimeCodeFormatDescription.TimeCode.Flag, extensions: CoreMedia.CMFormatDescription.Extensions? = nil) throws
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension CoreMedia._CMFormatDescriptionInitTrampoline {
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public init(metadataFormatType: CoreMedia.CMFormatDescription.MediaSubType) throws
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public init(boxedMetadataKeys: [[Swift.String : CoreFoundation.CFPropertyList]]) throws
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public init(boxedMetadataSpecifications: [[Swift.String : CoreFoundation.CFPropertyList]]) throws
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public init(sourceMetadata: CoreMedia.CMMetadataFormatDescription, specifications: [[Swift.String : CoreFoundation.CFPropertyList]]) throws
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public init(sourceMetadata: CoreMedia.CMMetadataFormatDescription, otherSourceDescription: CoreMedia.CMMetadataFormatDescription) throws
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension CoreMedia.CMFormatDescription : CoreMedia._CMFormatDescriptionInitTrampoline {
}
@available(watchOS 6.0, *)
extension CoreMedia.CMFormatDescription {
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public struct Error {
    public static let invalidParameter: Foundation.NSError
    public static let allocationFailed: Foundation.NSError
    public static let valueNotAvailable: Foundation.NSError
  }
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
public protocol _CMFormatDescriptionFourCCConvertible : CoreMedia._CMObjectiveCBridgeableWithRawValue, Swift.CustomStringConvertible where Self.RawValue == Darwin.FourCharCode, Self._ObjectiveCType == Foundation.NSNumber {
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension CoreMedia._CMFormatDescriptionFourCCConvertible {
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public var description: Swift.String {
    get
  }
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public init(string: Swift.String)
}
@available(watchOS 6.0, *)
extension CoreMedia.CMFormatDescription {
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public struct MediaType : CoreMedia._CMFormatDescriptionFourCCConvertible {
    public var rawValue: CoreMedia.CMMediaType
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    public init(rawValue: CoreMedia.CMMediaType)
    public static let video: CoreMedia.CMFormatDescription.MediaType
    public static let audio: CoreMedia.CMFormatDescription.MediaType
    public static let muxed: CoreMedia.CMFormatDescription.MediaType
    public static let text: CoreMedia.CMFormatDescription.MediaType
    public static let closedCaption: CoreMedia.CMFormatDescription.MediaType
    public static let subtitle: CoreMedia.CMFormatDescription.MediaType
    public static let timeCode: CoreMedia.CMFormatDescription.MediaType
    public static let metadata: CoreMedia.CMFormatDescription.MediaType
    public typealias RawValue = CoreMedia.CMMediaType
    public typealias _ObjectiveCType = Foundation.NSNumber
  }
}
@available(watchOS 6.0, *)
extension CoreMedia.CMFormatDescription {
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public struct MediaSubType : CoreMedia._CMFormatDescriptionFourCCConvertible {
    public var rawValue: Darwin.FourCharCode
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    public init(rawValue: Darwin.FourCharCode)
    public static let linearPCM: CoreMedia.CMFormatDescription.MediaSubType
    public static let ac3: CoreMedia.CMFormatDescription.MediaSubType
    public static let iec60958AC3: CoreMedia.CMFormatDescription.MediaSubType
    public static let appleIMA4: CoreMedia.CMFormatDescription.MediaSubType
    public static let mpeg4AAC: CoreMedia.CMFormatDescription.MediaSubType
    public static let mpeg4CELP: CoreMedia.CMFormatDescription.MediaSubType
    public static let mpeg4HVXC: CoreMedia.CMFormatDescription.MediaSubType
    public static let mpeg4TwinVQ: CoreMedia.CMFormatDescription.MediaSubType
    public static let mace3: CoreMedia.CMFormatDescription.MediaSubType
    public static let mace6: CoreMedia.CMFormatDescription.MediaSubType
    public static let uLaw: CoreMedia.CMFormatDescription.MediaSubType
    public static let aLaw: CoreMedia.CMFormatDescription.MediaSubType
    public static let qDesign: CoreMedia.CMFormatDescription.MediaSubType
    public static let qDesign2: CoreMedia.CMFormatDescription.MediaSubType
    public static let qualcomm: CoreMedia.CMFormatDescription.MediaSubType
    public static let mpegLayer1: CoreMedia.CMFormatDescription.MediaSubType
    public static let mpegLayer2: CoreMedia.CMFormatDescription.MediaSubType
    public static let mpegLayer3: CoreMedia.CMFormatDescription.MediaSubType
    public static let timeCode: CoreMedia.CMFormatDescription.MediaSubType
    public static let midiStream: CoreMedia.CMFormatDescription.MediaSubType
    public static let parameterValueStream: CoreMedia.CMFormatDescription.MediaSubType
    public static let appleLossless: CoreMedia.CMFormatDescription.MediaSubType
    public static let mpeg4AAC_HE: CoreMedia.CMFormatDescription.MediaSubType
    public static let mpeg4AAC_LD: CoreMedia.CMFormatDescription.MediaSubType
    public static let mpeg4AAC_ELD: CoreMedia.CMFormatDescription.MediaSubType
    public static let mpeg4AAC_ELD_SBR: CoreMedia.CMFormatDescription.MediaSubType
    public static let mpeg4AAC_ELD_V2: CoreMedia.CMFormatDescription.MediaSubType
    public static let mpeg4AAC_HE_V2: CoreMedia.CMFormatDescription.MediaSubType
    public static let mpeg4AAC_Spatial: CoreMedia.CMFormatDescription.MediaSubType
    public static let mpegD_USAC: CoreMedia.CMFormatDescription.MediaSubType
    public static let amr: CoreMedia.CMFormatDescription.MediaSubType
    public static let amr_WB: CoreMedia.CMFormatDescription.MediaSubType
    public static let audible: CoreMedia.CMFormatDescription.MediaSubType
    public static let iLBC: CoreMedia.CMFormatDescription.MediaSubType
    public static let dviIntelIMA: CoreMedia.CMFormatDescription.MediaSubType
    public static let microsoftGSM: CoreMedia.CMFormatDescription.MediaSubType
    public static let aes3: CoreMedia.CMFormatDescription.MediaSubType
    public static let enhancedAC3: CoreMedia.CMFormatDescription.MediaSubType
    public static let flac: CoreMedia.CMFormatDescription.MediaSubType
    public static let opus: CoreMedia.CMFormatDescription.MediaSubType
    public static let aacLCProtected: CoreMedia.CMFormatDescription.MediaSubType
    public static let aacAudibleProtected: CoreMedia.CMFormatDescription.MediaSubType
    public static let pixelFormat_32ARGB: CoreMedia.CMFormatDescription.MediaSubType
    public static let pixelFormat_32BGRA: CoreMedia.CMFormatDescription.MediaSubType
    public static let pixelFormat_24RGB: CoreMedia.CMFormatDescription.MediaSubType
    public static let pixelFormat_16BE555: CoreMedia.CMFormatDescription.MediaSubType
    public static let pixelFormat_16BE565: CoreMedia.CMFormatDescription.MediaSubType
    public static let pixelFormat_16LE555: CoreMedia.CMFormatDescription.MediaSubType
    public static let pixelFormat_16LE565: CoreMedia.CMFormatDescription.MediaSubType
    public static let pixelFormat_16LE5551: CoreMedia.CMFormatDescription.MediaSubType
    public static let pixelFormat_422YpCbCr8: CoreMedia.CMFormatDescription.MediaSubType
    public static let pixelFormat_422YpCbCr8_yuvs: CoreMedia.CMFormatDescription.MediaSubType
    public static let pixelFormat_444YpCbCr8: CoreMedia.CMFormatDescription.MediaSubType
    public static let pixelFormat_4444YpCbCrA8: CoreMedia.CMFormatDescription.MediaSubType
    public static let pixelFormat_422YpCbCr16: CoreMedia.CMFormatDescription.MediaSubType
    public static let pixelFormat_422YpCbCr10: CoreMedia.CMFormatDescription.MediaSubType
    public static let pixelFormat_444YpCbCr10: CoreMedia.CMFormatDescription.MediaSubType
    public static let pixelFormat_8IndexedGray_WhiteIsZero: CoreMedia.CMFormatDescription.MediaSubType
    public static let animation: CoreMedia.CMFormatDescription.MediaSubType
    public static let cinepak: CoreMedia.CMFormatDescription.MediaSubType
    public static let jpeg: CoreMedia.CMFormatDescription.MediaSubType
    public static let jpeg_OpenDML: CoreMedia.CMFormatDescription.MediaSubType
    public static let sorensonVideo: CoreMedia.CMFormatDescription.MediaSubType
    public static let sorensonVideo3: CoreMedia.CMFormatDescription.MediaSubType
    public static let h263: CoreMedia.CMFormatDescription.MediaSubType
    public static let h264: CoreMedia.CMFormatDescription.MediaSubType
    public static let hevc: CoreMedia.CMFormatDescription.MediaSubType
    public static let hevcWithAlpha: CoreMedia.CMFormatDescription.MediaSubType
    public static let mpeg4Video: CoreMedia.CMFormatDescription.MediaSubType
    public static let mpeg2Video: CoreMedia.CMFormatDescription.MediaSubType
    public static let mpeg1Video: CoreMedia.CMFormatDescription.MediaSubType
    public static let dvcNTSC: CoreMedia.CMFormatDescription.MediaSubType
    public static let dvcPAL: CoreMedia.CMFormatDescription.MediaSubType
    public static let dvcProPAL: CoreMedia.CMFormatDescription.MediaSubType
    public static let dvcPro50NTSC: CoreMedia.CMFormatDescription.MediaSubType
    public static let dvcPro50PAL: CoreMedia.CMFormatDescription.MediaSubType
    public static let dvcPROHD720p60: CoreMedia.CMFormatDescription.MediaSubType
    public static let dvcPROHD720p50: CoreMedia.CMFormatDescription.MediaSubType
    public static let dvcPROHD1080i60: CoreMedia.CMFormatDescription.MediaSubType
    public static let dvcPROHD1080i50: CoreMedia.CMFormatDescription.MediaSubType
    public static let dvcPROHD1080p30: CoreMedia.CMFormatDescription.MediaSubType
    public static let dvcPROHD1080p25: CoreMedia.CMFormatDescription.MediaSubType
    public static let proRes4444XQ: CoreMedia.CMFormatDescription.MediaSubType
    public static let proRes4444: CoreMedia.CMFormatDescription.MediaSubType
    public static let proRes422HQ: CoreMedia.CMFormatDescription.MediaSubType
    public static let proRes422: CoreMedia.CMFormatDescription.MediaSubType
    public static let proRes422LT: CoreMedia.CMFormatDescription.MediaSubType
    public static let proRes422Proxy: CoreMedia.CMFormatDescription.MediaSubType
    public static let proResRAW: CoreMedia.CMFormatDescription.MediaSubType
    public static let proResRAWHQ: CoreMedia.CMFormatDescription.MediaSubType
    public static let mpeg1System: CoreMedia.CMFormatDescription.MediaSubType
    public static let mpeg2Transport: CoreMedia.CMFormatDescription.MediaSubType
    public static let mpeg2Program: CoreMedia.CMFormatDescription.MediaSubType
    public static let dv: CoreMedia.CMFormatDescription.MediaSubType
    public static let cea608: CoreMedia.CMFormatDescription.MediaSubType
    public static let cea708: CoreMedia.CMFormatDescription.MediaSubType
    public static let atsc: CoreMedia.CMFormatDescription.MediaSubType
    public static let qt: CoreMedia.CMFormatDescription.MediaSubType
    public static let mobile3GPP: CoreMedia.CMFormatDescription.MediaSubType
    public static let webVTT: CoreMedia.CMFormatDescription.MediaSubType
    public static let timeCode32: CoreMedia.CMFormatDescription.MediaSubType
    public static let timeCode64: CoreMedia.CMFormatDescription.MediaSubType
    public static let counter32: CoreMedia.CMFormatDescription.MediaSubType
    public static let counter64: CoreMedia.CMFormatDescription.MediaSubType
    public static let icy: CoreMedia.CMFormatDescription.MediaSubType
    public static let id3: CoreMedia.CMFormatDescription.MediaSubType
    public static let boxed: CoreMedia.CMFormatDescription.MediaSubType
    public static let emsg: CoreMedia.CMFormatDescription.MediaSubType
    public typealias RawValue = Darwin.FourCharCode
    public typealias _ObjectiveCType = Foundation.NSNumber
  }
}
@available(watchOS 6.0, *)
extension CoreMedia.CMFormatDescription {
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public static var typeID: CoreFoundation.CFTypeID {
    get
  }
}
@available(watchOS 6.0, *)
extension CoreMedia.CMFormatDescription {
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public func equalTo(_ otherFormatDescription: CoreMedia.CMFormatDescription, extensionKeysToIgnore: [CoreMedia.CMFormatDescription.Extensions.Key] = [], sampleDescriptionExtensionAtomKeysToIgnore: [Swift.String] = []) -> Swift.Bool
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public var mediaType: CoreMedia.CMFormatDescription.MediaType {
    get
  }
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public var mediaSubType: CoreMedia.CMFormatDescription.MediaSubType {
    get
  }
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public var extensions: CoreMedia.CMFormatDescription.Extensions {
    get
  }
}
@available(watchOS 6.0, *)
extension CoreMedia.CMFormatDescription {
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public static func == (lhs: CoreMedia.CMFormatDescription, rhs: CoreMedia.CMFormatDescription) -> Swift.Bool
}
@available(watchOS 6.0, *)
extension CoreMedia.CMFormatDescription {
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public var audioStreamBasicDescription: CoreAudioTypes.AudioStreamBasicDescription? {
    get
  }
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public func withMagicCookie<R>(_ body: (Swift.UnsafeRawBufferPointer?) throws -> R) rethrows -> R
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public var magicCookie: Foundation.Data? {
    get
  }
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public var audioChannelLayout: CoreAudio.ManagedAudioChannelLayout? {
    get
  }
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public var audioFormatList: [CoreAudioTypes.AudioFormatListItem] {
    get
  }
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public var richestDecodableFormat: CoreAudioTypes.AudioFormatListItem? {
    get
  }
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public var mostCompatibleFormat: CoreAudioTypes.AudioFormatListItem? {
    get
  }
}
@available(watchOS 6.0, *)
extension CoreMedia.CMFormatDescription {
  public struct EqualityMask : Swift.OptionSet {
    public let rawValue: CoreMedia.CMAudioFormatDescriptionMask
    public init(rawValue: CoreMedia.CMAudioFormatDescriptionMask)
    public static let streamBasicDescription: CoreMedia.CMFormatDescription.EqualityMask
    public static let magicCookie: CoreMedia.CMFormatDescription.EqualityMask
    public static let channelLayout: CoreMedia.CMFormatDescription.EqualityMask
    public static let extensions: CoreMedia.CMFormatDescription.EqualityMask
    public static let all: CoreMedia.CMFormatDescription.EqualityMask
    public typealias ArrayLiteralElement = CoreMedia.CMFormatDescription.EqualityMask
    public typealias Element = CoreMedia.CMFormatDescription.EqualityMask
    public typealias RawValue = CoreMedia.CMAudioFormatDescriptionMask
  }
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public func equalTo(_ otherFormatDescription: CoreMedia.CMAudioFormatDescription, equalityMask: CoreMedia.CMFormatDescription.EqualityMask = .all) -> (Swift.Bool, equalityMask: CoreMedia.CMFormatDescription.EqualityMask)
}
@available(watchOS 6.0, *)
extension CoreMedia.CMFormatDescription {
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public struct ParameterSetCollection : Swift.RandomAccessCollection {
    public typealias Element = Foundation.Data
    public typealias Index = Swift.Int
    public var startIndex: Swift.Int {
      get
    }
    public var endIndex: Swift.Int {
      get
    }
    public subscript(position: Swift.Int) -> Foundation.Data {
      get
    }
    public typealias Indices = Swift.Range<CoreMedia.CMFormatDescription.ParameterSetCollection.Index>
    public typealias Iterator = Swift.IndexingIterator<CoreMedia.CMFormatDescription.ParameterSetCollection>
    public typealias SubSequence = Swift.Slice<CoreMedia.CMFormatDescription.ParameterSetCollection>
  }
}
@available(watchOS 6.0, *)
extension CoreMedia.CMFormatDescription {
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public var nalUnitHeaderLength: Swift.Int? {
    get
  }
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public var parameterSets: CoreMedia.CMFormatDescription.ParameterSetCollection {
    get
  }
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public var dimensions: CoreMedia.CMVideoDimensions {
    get
  }
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public func presentationDimensions(usePixelAspectRatio: Swift.Bool = true, useCleanAperture: Swift.Bool = true) -> CoreGraphics.CGSize
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public func cleanAperture(originIsAtTopLeft: Swift.Bool) -> CoreGraphics.CGRect
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public static var extensionKeysCommonWithImageBuffers: [CoreMedia.CMFormatDescription.Extensions.Key] {
    get
  }
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public func matchesImageBuffer(_ imageBuffer: CoreVideo.CVImageBuffer) -> Swift.Bool
}
@available(watchOS 6.0, *)
extension CoreMedia.CMFormatDescription {
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public func displayFlags() throws -> CoreMedia.CMFormatDescription.Extensions.Value.TextDisplayFlags
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public func justification() throws -> (horizontal: CoreMedia.CMFormatDescription.Extensions.Value.TextJustification, vertical: CoreMedia.CMFormatDescription.Extensions.Value.TextJustification)
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public func defaultTextBox(originIsAtTopLeft: Swift.Bool, heightOfTextTrack: CoreGraphics.CGFloat) throws -> CoreGraphics.CGRect
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public func defaultStyle() throws -> (localFontID: Swift.Int, bold: Swift.Bool, italic: Swift.Bool, underline: Swift.Bool, fontSize: CoreGraphics.CGFloat, colorComponents: [CoreGraphics.CGFloat])
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public func fontName(localFontID: Swift.Int) throws -> Swift.String
}
@available(watchOS 6.0, *)
extension CoreMedia.CMFormatDescription {
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public struct TimeCode {
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    public struct Flag : Swift.OptionSet {
      public let rawValue: Swift.UInt32
      public init(rawValue: Swift.UInt32)
      public static let dropFrame: CoreMedia.CMFormatDescription.TimeCode.Flag
      public static let twentyFourHourMax: CoreMedia.CMFormatDescription.TimeCode.Flag
      public static let negTimesOK: CoreMedia.CMFormatDescription.TimeCode.Flag
      public typealias ArrayLiteralElement = CoreMedia.CMFormatDescription.TimeCode.Flag
      public typealias Element = CoreMedia.CMFormatDescription.TimeCode.Flag
      public typealias RawValue = Swift.UInt32
    }
  }
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public var frameDuration: CoreMedia.CMTime {
    get
  }
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public var frameQuanta: Swift.UInt32 {
    get
  }
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public var timeCodeFlags: CoreMedia.CMFormatDescription.TimeCode.Flag {
    get
  }
}
@available(watchOS 6.0, *)
extension CoreMedia.CMFormatDescription {
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public func keyWithLocalID(_ localKeyID: Darwin.OSType) -> [Swift.String : CoreFoundation.CFPropertyList]?
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public var identifiers: [Swift.String] {
    get
  }
}
@available(watchOS 6.0, *)
extension CoreMedia.CMTime {
  @available(watchOS 6.0, *)
  public init(seconds: Swift.Double, preferredTimescale: CoreMedia.CMTimeScale)
  @available(watchOS 6.0, *)
  public init(value: CoreMedia.CMTimeValue, timescale: CoreMedia.CMTimeScale)
}
@available(watchOS 6.0, *)
extension CoreMedia.CMTime {
  @available(watchOS 6.0, *)
  public var isValid: Swift.Bool {
    get
  }
  @available(watchOS 6.0, *)
  public var isPositiveInfinity: Swift.Bool {
    get
  }
  @available(watchOS 6.0, *)
  public var isNegativeInfinity: Swift.Bool {
    get
  }
  @available(watchOS 6.0, *)
  public var isIndefinite: Swift.Bool {
    get
  }
  @available(watchOS 6.0, *)
  public var isNumeric: Swift.Bool {
    get
  }
  @available(watchOS 6.0, *)
  public var hasBeenRounded: Swift.Bool {
    get
  }
  @available(watchOS 6.0, *)
  public var seconds: Swift.Double {
    get
  }
  @available(watchOS 6.0, *)
  public func convertScale(_ newTimescale: Swift.Int32, method: CoreMedia.CMTimeRoundingMethod) -> CoreMedia.CMTime
}
@available(watchOS 6.0, *)
public func CMTIME_IS_VALID(_ time: CoreMedia.CMTime) -> Swift.Bool
@available(watchOS 6.0, *)
public func CMTIME_IS_INVALID(_ time: CoreMedia.CMTime) -> Swift.Bool
@available(watchOS 6.0, *)
public func CMTIME_IS_POSITIVEINFINITY(_ time: CoreMedia.CMTime) -> Swift.Bool
@available(watchOS 6.0, *)
public func CMTIME_IS_NEGATIVEINFINITY(_ time: CoreMedia.CMTime) -> Swift.Bool
@available(watchOS 6.0, *)
public func CMTIME_IS_INDEFINITE(_ time: CoreMedia.CMTime) -> Swift.Bool
@available(watchOS 6.0, *)
public func CMTIME_IS_NUMERIC(_ time: CoreMedia.CMTime) -> Swift.Bool
@available(watchOS 6.0, *)
public func CMTIME_HAS_BEEN_ROUNDED(_ time: CoreMedia.CMTime) -> Swift.Bool
@available(watchOS 6.0, *)
extension CoreMedia.CMTime {
  @available(watchOS 6.0, *)
  public static func + (addend1: CoreMedia.CMTime, addend2: CoreMedia.CMTime) -> CoreMedia.CMTime
  @available(watchOS 6.0, *)
  public static func - (minuend: CoreMedia.CMTime, subtrahend: CoreMedia.CMTime) -> CoreMedia.CMTime
}
@available(watchOS 6.0, *)
extension CoreMedia.CMTime : Swift.Equatable, Swift.Comparable {
  @available(watchOS 6.0, *)
  public static func < (time1: CoreMedia.CMTime, time2: CoreMedia.CMTime) -> Swift.Bool
  @available(watchOS 6.0, *)
  public static func <= (time1: CoreMedia.CMTime, time2: CoreMedia.CMTime) -> Swift.Bool
  @available(watchOS 6.0, *)
  public static func > (time1: CoreMedia.CMTime, time2: CoreMedia.CMTime) -> Swift.Bool
  @available(watchOS 6.0, *)
  public static func >= (time1: CoreMedia.CMTime, time2: CoreMedia.CMTime) -> Swift.Bool
  @available(watchOS 6.0, *)
  public static func == (time1: CoreMedia.CMTime, time2: CoreMedia.CMTime) -> Swift.Bool
  @available(watchOS 6.0, *)
  public static func != (time1: CoreMedia.CMTime, time2: CoreMedia.CMTime) -> Swift.Bool
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
public protocol CMBlockBufferProtocol {
  var owner: CoreMedia.CMBlockBuffer { get }
  var startIndex: Swift.Int { get }
  var endIndex: Swift.Int { get }
}
@available(watchOS 6.0, *)
extension CoreMedia.CMBlockBuffer {
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public struct Slice {
  }
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension CoreMedia.CMBlockBuffer.Slice : CoreMedia.CMBlockBufferProtocol {
  public var owner: CoreMedia.CMBlockBuffer {
    get
  }
  public var startIndex: Swift.Int {
    get
  }
  public var endIndex: Swift.Int {
    get
  }
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension CoreMedia.CMBlockBuffer : CoreMedia.CMBlockBufferProtocol {
  public var owner: CoreMedia.CMBlockBuffer {
    get
  }
  public var startIndex: Swift.Int {
    get
  }
  public var endIndex: Swift.Int {
    get
  }
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension CoreMedia.CMBlockBufferProtocol {
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public subscript(bounds: Swift.ClosedRange<Swift.Int>) -> CoreMedia.CMBlockBuffer.Slice {
    get
  }
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public subscript(bounds: Swift.Range<Swift.Int>) -> CoreMedia.CMBlockBuffer.Slice {
    get
  }
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public subscript(bounds: Swift.PartialRangeUpTo<Swift.Int>) -> CoreMedia.CMBlockBuffer.Slice {
    get
  }
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public subscript(bounds: Swift.PartialRangeThrough<Swift.Int>) -> CoreMedia.CMBlockBuffer.Slice {
    get
  }
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public subscript(bounds: Swift.PartialRangeFrom<Swift.Int>) -> CoreMedia.CMBlockBuffer.Slice {
    get
  }
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public subscript(bounds: (Swift.UnboundedRange_) -> ()) -> CoreMedia.CMBlockBuffer.Slice {
    get
  }
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
public protocol _CMBlockBufferInitTrampoline {
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  init(referencing: CoreMedia.CMBlockBuffer)
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension CoreMedia.CMBlockBuffer {
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public typealias CustomBlockAllocator = (Swift.Int) -> Swift.UnsafeMutableRawPointer?
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public typealias CustomBlockDeallocator = (Swift.UnsafeMutableRawPointer, Swift.Int) -> Swift.Void
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension CoreMedia._CMBlockBufferInitTrampoline {
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public init(capacity: Swift.Int = 0, flags: CoreMedia.CMBlockBuffer.Flags = []) throws
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public init(buffer: Swift.UnsafeMutableRawBufferPointer, allocator: CoreFoundation.CFAllocator? = kCFAllocatorDefault, flags: CoreMedia.CMBlockBuffer.Flags = []) throws
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public init(buffer: Swift.Slice<Swift.UnsafeMutableRawBufferPointer>, allocator: CoreFoundation.CFAllocator? = kCFAllocatorDefault, flags: CoreMedia.CMBlockBuffer.Flags = []) throws
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public init(length: Swift.Int, allocator: CoreFoundation.CFAllocator? = kCFAllocatorDefault, range: Swift.Range<Swift.Int>? = nil, flags: CoreMedia.CMBlockBuffer.Flags = []) throws
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public init(buffer: Swift.UnsafeMutableRawBufferPointer, deallocator: @escaping CoreMedia.CMBlockBuffer.CustomBlockDeallocator, flags: CoreMedia.CMBlockBuffer.Flags = []) throws
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public init(buffer: Swift.Slice<Swift.UnsafeMutableRawBufferPointer>, deallocator: @escaping CoreMedia.CMBlockBuffer.CustomBlockDeallocator, flags: CoreMedia.CMBlockBuffer.Flags = []) throws
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public init(length: Swift.Int, allocator: @escaping CoreMedia.CMBlockBuffer.CustomBlockAllocator, deallocator: @escaping CoreMedia.CMBlockBuffer.CustomBlockDeallocator, range: Swift.Range<Swift.Int>? = nil, flags: CoreMedia.CMBlockBuffer.Flags = []) throws
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public init<T>(bufferReference: T, flags: CoreMedia.CMBlockBuffer.Flags = []) throws where T : CoreMedia.CMBlockBufferProtocol
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension CoreMedia.CMBlockBuffer : CoreMedia._CMBlockBufferInitTrampoline {
}
@available(watchOS 6.0, *)
extension CoreMedia.CMBlockBuffer {
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public struct Error {
    public static let structureAllocationFailed: Foundation.NSError
    public static let blockAllocationFailed: Foundation.NSError
    public static let badCustomBlockSource: Foundation.NSError
    public static let badOffsetParameter: Foundation.NSError
    public static let badLengthParameter: Foundation.NSError
    public static let badPointerParameter: Foundation.NSError
    public static let emptyBlockBuffer: Foundation.NSError
    public static let unallocatedBlock: Foundation.NSError
    public static let insufficientSpace: Foundation.NSError
  }
}
@available(watchOS 6.0, *)
extension CoreMedia.CMBlockBuffer {
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public struct Flags : Swift.OptionSet {
    public let rawValue: Swift.UInt32
    public init(rawValue: Swift.UInt32)
    public static let assureMemoryNow: CoreMedia.CMBlockBuffer.Flags
    public static let alwaysCopyData: CoreMedia.CMBlockBuffer.Flags
    public static let dontOptimizeDepth: CoreMedia.CMBlockBuffer.Flags
    public static let permitEmptyReference: CoreMedia.CMBlockBuffer.Flags
    public typealias ArrayLiteralElement = CoreMedia.CMBlockBuffer.Flags
    public typealias Element = CoreMedia.CMBlockBuffer.Flags
    public typealias RawValue = Swift.UInt32
  }
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension CoreMedia.CMBlockBufferProtocol {
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public func makeContiguous(allocator: CoreFoundation.CFAllocator? = kCFAllocatorDefault, flags: CoreMedia.CMBlockBuffer.Flags = []) throws -> CoreMedia.CMBlockBuffer
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public func makeContiguous(allocator: @escaping CoreMedia.CMBlockBuffer.CustomBlockAllocator, deallocator: @escaping CoreMedia.CMBlockBuffer.CustomBlockDeallocator, flags: CoreMedia.CMBlockBuffer.Flags = []) throws -> CoreMedia.CMBlockBuffer
}
@available(watchOS 6.0, *)
extension CoreMedia.CMBlockBuffer {
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public func append(length: Swift.Int, allocator: CoreFoundation.CFAllocator? = kCFAllocatorDefault, range: Swift.Range<Swift.Int>? = nil, flags: CoreMedia.CMBlockBuffer.Flags = []) throws
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public func append(buffer: Swift.UnsafeMutableRawBufferPointer, allocator: CoreFoundation.CFAllocator? = kCFAllocatorDefault, flags: CoreMedia.CMBlockBuffer.Flags = []) throws
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public func append(buffer: Swift.Slice<Swift.UnsafeMutableRawBufferPointer>, allocator: CoreFoundation.CFAllocator? = kCFAllocatorDefault, flags: CoreMedia.CMBlockBuffer.Flags = []) throws
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public func append(length: Swift.Int, allocator: @escaping CoreMedia.CMBlockBuffer.CustomBlockAllocator, deallocator: @escaping CoreMedia.CMBlockBuffer.CustomBlockDeallocator, range: Swift.Range<Swift.Int>? = nil, flags: CoreMedia.CMBlockBuffer.Flags = []) throws
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public func append(buffer: Swift.UnsafeMutableRawBufferPointer, deallocator: @escaping CoreMedia.CMBlockBuffer.CustomBlockDeallocator, flags: CoreMedia.CMBlockBuffer.Flags = []) throws
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public func append(buffer: Swift.Slice<Swift.UnsafeMutableRawBufferPointer>, deallocator: @escaping CoreMedia.CMBlockBuffer.CustomBlockDeallocator, flags: CoreMedia.CMBlockBuffer.Flags = []) throws
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public func append<T>(bufferReference: T, flags: CoreMedia.CMBlockBuffer.Flags = []) throws where T : CoreMedia.CMBlockBufferProtocol
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public func assureBlockMemory() throws
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension CoreMedia.CMBlockBufferProtocol {
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public func withContiguousStorage<R>(_ body: (Swift.UnsafeRawBufferPointer) throws -> R) throws -> R
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public func dataBytes() throws -> Foundation.Data
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public func copyDataBytes(to destination: Swift.UnsafeMutableRawBufferPointer) throws
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public func replaceDataBytes(with sourceBytes: Swift.UnsafeRawBufferPointer) throws
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public func fillDataBytes(with fillByte: Swift.UInt8) throws
}
@available(watchOS 6.0, *)
extension CoreMedia.CMBlockBuffer {
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public func withUnsafeMutableBytes<R>(atOffset offset: Swift.Int = 0, _ body: (Swift.UnsafeMutableRawBufferPointer) throws -> R) throws -> R
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension CoreMedia.CMBlockBufferProtocol {
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public var dataLength: Swift.Int {
    get
  }
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public var isContiguous: Swift.Bool {
    get
  }
}
@available(watchOS 6.0, *)
extension CoreMedia.CMBlockBuffer {
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public var isEmpty: Swift.Bool {
    get
  }
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public class var typeID: CoreFoundation.CFTypeID {
    get
  }
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension CoreMedia.CMAttachmentBearerAttachments.Mode : Swift.Equatable {}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension CoreMedia.CMAttachmentBearerAttachments.Mode : Swift.Hashable {}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension CoreMedia.CMAttachmentBearerAttachments.Mode : Swift.RawRepresentable {}
