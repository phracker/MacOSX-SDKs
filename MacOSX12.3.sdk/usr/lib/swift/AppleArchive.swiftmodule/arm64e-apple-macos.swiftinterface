// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 5.6 (swiftlang-5.6.0.323.32 clang-1316.0.20.8)
// swift-module-flags: -target arm64e-apple-macos12.3 -enable-objc-interop -autolink-force-load -enable-library-evolution -module-link-name swiftAppleArchive -swift-version 5 -enforce-exclusivity=checked -O -library-level api -module-name AppleArchive
// swift-module-flags-ignorable: -user-module-version 280.100.14
@_exported import AppleArchive
import Compression
import CryptoKit
import Foundation
import Swift
import System
import _Concurrency
@available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
public struct _AAHeaderTraits : AppleArchive._AAObjectTraits {
  public typealias AAType = AppleArchive.__AAHeader
  public static func aaDestroy(_ object: AppleArchive._AAHeaderTraits.AAType?)
}
@_hasMissingDesignatedInitializers @available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
public class ArchiveHeader : AppleArchive._AAObjectWrapper<AppleArchive._AAHeaderTraits>, AppleArchive._AAEncodableProtocol {
  required public init()
  public init?(keySet: AppleArchive.ArchiveHeader.FieldKeySet, directory: System.FilePath, path: System.FilePath, flags: AppleArchive.ArchiveFlags)
  public init(copying s: AppleArchive.ArchiveHeader)
  public func field(forKey key: AppleArchive.ArchiveHeader.FieldKey) -> AppleArchive.ArchiveHeader.Field?
  required public init?(withAAEncodedData data: Swift.UnsafeBufferPointer<Swift.UInt8>)
  public func withAAEncodedData<R>(_ body: (Swift.UnsafeBufferPointer<Swift.UInt8>) throws -> R) rethrows -> R
  @objc deinit
}
extension AppleArchive.ArchiveHeader : Swift.RandomAccessCollection, Swift.MutableCollection {
  @available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
  public var startIndex: Swift.Int {
    get
  }
  @available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
  public var endIndex: Swift.Int {
    get
  }
  @available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
  public subscript(i: Swift.Int) -> AppleArchive.ArchiveHeader.Field {
    get
    set
  }
  @available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
  public func removeAll()
  @available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
  public func remove(at i: Swift.Int) -> AppleArchive.ArchiveHeader.Field
  @available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
  public func append(_ newElement: AppleArchive.ArchiveHeader.Field)
  public typealias Element = AppleArchive.ArchiveHeader.Field
  public typealias Index = Swift.Int
  public typealias Indices = Swift.Range<Swift.Int>
  public typealias Iterator = Swift.IndexingIterator<AppleArchive.ArchiveHeader>
  public typealias SubSequence = Swift.Slice<AppleArchive.ArchiveHeader>
}
extension AppleArchive.ArchiveHeader {
  @available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
  public struct _FieldTypes : Swift.RandomAccessCollection {
    public let base: AppleArchive.ArchiveHeader
    public var startIndex: Swift.Int {
      get
    }
    public var endIndex: Swift.Int {
      get
    }
    public subscript(i: Swift.Int) -> AppleArchive.ArchiveHeader.FieldType {
      get
    }
    public typealias Element = AppleArchive.ArchiveHeader.FieldType
    public typealias Index = Swift.Int
    public typealias Indices = Swift.Range<Swift.Int>
    public typealias Iterator = Swift.IndexingIterator<AppleArchive.ArchiveHeader._FieldTypes>
    public typealias SubSequence = Swift.Slice<AppleArchive.ArchiveHeader._FieldTypes>
  }
  @available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
  public struct _FieldKeys : Swift.RandomAccessCollection {
    public let base: AppleArchive.ArchiveHeader
    public var startIndex: Swift.Int {
      get
    }
    public var endIndex: Swift.Int {
      get
    }
    public subscript(i: Swift.Int) -> AppleArchive.ArchiveHeader.FieldKey {
      get
    }
    public func _customIndexOfEquatableElement(_ element: AppleArchive.ArchiveHeader.FieldKey) -> Swift.Int??
    public typealias Element = AppleArchive.ArchiveHeader.FieldKey
    public typealias Index = Swift.Int
    public typealias Indices = Swift.Range<Swift.Int>
    public typealias Iterator = Swift.IndexingIterator<AppleArchive.ArchiveHeader._FieldKeys>
    public typealias SubSequence = Swift.Slice<AppleArchive.ArchiveHeader._FieldKeys>
  }
  @available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
  public var fieldType: AppleArchive.ArchiveHeader._FieldTypes {
    get
  }
  @available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
  public var fieldKey: AppleArchive.ArchiveHeader._FieldKeys {
    get
  }
}
extension AppleArchive.ArchiveHeader {
  @available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
  public var entryType: AppleArchive.ArchiveHeader.EntryType? {
    get
  }
  @available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
  public var entryPath: System.FilePath? {
    get
  }
}
@available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
public enum ArchiveError : Swift.Hashable, Swift.Error {
  case ioError
  case invalidValue
  public static func == (a: AppleArchive.ArchiveError, b: AppleArchive.ArchiveError) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
extension AppleArchive.ArchiveHeader {
  public struct EntryMessage : Swift.Equatable, Swift.Hashable, Swift.RawRepresentable, Swift.CustomStringConvertible {
    public static let searchPruneDirectory: AppleArchive.ArchiveHeader.EntryMessage
    public static let searchExclude: AppleArchive.ArchiveHeader.EntryMessage
    public static let searchFail: AppleArchive.ArchiveHeader.EntryMessage
    public static let extractBegin: AppleArchive.ArchiveHeader.EntryMessage
    public static let extractEnd: AppleArchive.ArchiveHeader.EntryMessage
    public static let extractFail: AppleArchive.ArchiveHeader.EntryMessage
    public static let extractAttributes: AppleArchive.ArchiveHeader.EntryMessage
    public static let extractXAT: AppleArchive.ArchiveHeader.EntryMessage
    public static let extractACL: AppleArchive.ArchiveHeader.EntryMessage
    public static let convertExclude: AppleArchive.ArchiveHeader.EntryMessage
    public static let encodeScanning: AppleArchive.ArchiveHeader.EntryMessage
    public static let encodeWriting: AppleArchive.ArchiveHeader.EntryMessage
    public static let decodeReading: AppleArchive.ArchiveHeader.EntryMessage
    public static let processExclude: AppleArchive.ArchiveHeader.EntryMessage
    public var rawValue: Swift.UInt32
    public init(rawValue: Swift.UInt32)
    public var description: Swift.String {
      get
    }
    public typealias RawValue = Swift.UInt32
  }
}
@available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
extension AppleArchive.ArchiveHeader {
  public enum Field {
    case flag(key: AppleArchive.ArchiveHeader.FieldKey)
    case uint(key: AppleArchive.ArchiveHeader.FieldKey, value: Swift.UInt64)
    case string(key: AppleArchive.ArchiveHeader.FieldKey, value: Swift.String)
    case hash(key: AppleArchive.ArchiveHeader.FieldKey, hashFunction: AppleArchive.ArchiveHash, value: Swift.ContiguousArray<Swift.UInt8>)
    case timespec(key: AppleArchive.ArchiveHeader.FieldKey, value: Darwin.timespec)
    case blob(key: AppleArchive.ArchiveHeader.FieldKey, size: Swift.UInt64, offset: Swift.UInt64 = 0)
    public var type: AppleArchive.ArchiveHeader.FieldType {
      get
    }
    public var key: AppleArchive.ArchiveHeader.FieldKey {
      get
    }
  }
}
@available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
public protocol ArchiveStreamProtocol {
  func writeHeader(_ header: AppleArchive.ArchiveHeader) throws
  func writeBlob(key: AppleArchive.ArchiveHeader.FieldKey, from buffer: Swift.UnsafeRawBufferPointer) throws
  func readHeader() throws -> AppleArchive.ArchiveHeader?
  func readBlob(key: AppleArchive.ArchiveHeader.FieldKey, into buffer: Swift.UnsafeMutableRawBufferPointer) throws
  func cancel()
  func close() throws
}
@available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
extension AppleArchive.ArchiveHeader {
  @_hasMissingDesignatedInitializers public class EntryAttributes {
    public var uid: Swift.UInt32? {
      get
      set
    }
    public var gid: Swift.UInt32? {
      get
      set
    }
    public var flg: Swift.UInt32? {
      get
      set
    }
    public var mod: Swift.UInt32? {
      get
      set
    }
    public var mtm: Darwin.timespec? {
      get
      set
    }
    public var ctm: Darwin.timespec? {
      get
      set
    }
    public var btm: Darwin.timespec? {
      get
      set
    }
    @objc deinit
  }
}
@available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
extension AppleArchive.ArchiveHeader {
  public enum EntryFilterData {
    case header(AppleArchive.ArchiveHeader)
    case entryAttributes(AppleArchive.ArchiveHeader.EntryAttributes)
    case entryXAT(AppleArchive.ArchiveHeader.EntryXATBlob)
  }
  public typealias EntryFilter = (AppleArchive.ArchiveHeader.EntryMessage, System.FilePath, AppleArchive.ArchiveHeader.EntryFilterData?) -> AppleArchive.ArchiveHeader.EntryMessageStatus
  @_hasMissingDesignatedInitializers public class _EntryFilterWrapper {
    @objc deinit
  }
}
@available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
public struct ArchiveHash : Swift.Equatable, Swift.Hashable, Swift.RawRepresentable, Swift.CustomStringConvertible {
  public static let crc32: AppleArchive.ArchiveHash
  public static let sha1: AppleArchive.ArchiveHash
  public static let sha256: AppleArchive.ArchiveHash
  public static let sha384: AppleArchive.ArchiveHash
  public static let sha512: AppleArchive.ArchiveHash
  public var rawValue: Swift.UInt32
  public init(rawValue: Swift.UInt32)
  public var size: Swift.Int {
    get
  }
  public static let maxSize: Swift.Int
  public var description: Swift.String {
    get
  }
  public typealias RawValue = Swift.UInt32
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension AppleArchive.ArchiveEncryptionContext {
  public struct EncryptionMode : Swift.Equatable, Swift.Hashable, Swift.RawRepresentable, Swift.CustomStringConvertible {
    public static let none: AppleArchive.ArchiveEncryptionContext.EncryptionMode
    public static let symmetric: AppleArchive.ArchiveEncryptionContext.EncryptionMode
    public static let ecdhe_p256: AppleArchive.ArchiveEncryptionContext.EncryptionMode
    public static let scrypt: AppleArchive.ArchiveEncryptionContext.EncryptionMode
    public var rawValue: Swift.UInt32
    public init(rawValue: Swift.UInt32)
    public var description: Swift.String {
      get
    }
    public typealias RawValue = Swift.UInt32
  }
}
@available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
extension AppleArchive.ArchiveHeader {
  public struct EntryMessageStatus : Swift.Equatable, Swift.Hashable, Swift.RawRepresentable, Swift.CustomStringConvertible {
    public static let ok: AppleArchive.ArchiveHeader.EntryMessageStatus
    public static let skip: AppleArchive.ArchiveHeader.EntryMessageStatus
    public static let cancel: AppleArchive.ArchiveHeader.EntryMessageStatus
    public var rawValue: Swift.Int32
    public init(rawValue: Swift.Int32)
    public var description: Swift.String {
      get
    }
    public typealias RawValue = Swift.Int32
  }
}
extension AppleArchive.ArchiveStream {
  @available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
  public static func withEncodeStream<E>(writingTo stream: AppleArchive.ArchiveByteStream, selectUsing filter: AppleArchive.ArchiveHeader.EntryFilter? = nil, flags: AppleArchive.ArchiveFlags = [], threadCount: Swift.Int = 0, _ body: (AppleArchive.ArchiveStream) throws -> E) throws -> E
  @available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
  public static func withDecodeStream<E>(readingFrom stream: AppleArchive.ArchiveByteStream, selectUsing filter: AppleArchive.ArchiveHeader.EntryFilter? = nil, flags: AppleArchive.ArchiveFlags = [], threadCount: Swift.Int = 0, _ body: (AppleArchive.ArchiveStream) throws -> E) throws -> E
  @available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
  public static func withExtractStream<E>(extractingTo directory: System.FilePath, selectUsing filter: AppleArchive.ArchiveHeader.EntryFilter? = nil, flags: AppleArchive.ArchiveFlags = [], threadCount: Swift.Int = 0, _ body: (AppleArchive.ArchiveStream) throws -> E) throws -> E
  @available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
  public static func withConvertStream<E>(writingTo stream: AppleArchive.ArchiveStream, insertKeySet: AppleArchive.ArchiveHeader.FieldKeySet, removeKeySet: AppleArchive.ArchiveHeader.FieldKeySet, selectUsing filter: AppleArchive.ArchiveHeader.EntryFilter? = nil, flags: AppleArchive.ArchiveFlags = [], threadCount: Swift.Int = 0, _ body: (AppleArchive.ArchiveStream) throws -> E) throws -> E
  @available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
  public static func withStream<C, E>(wrapping instance: C, _ body: (AppleArchive.ArchiveStream) throws -> E) throws -> E where C : AnyObject, C : AppleArchive.ArchiveStreamProtocol
}
@available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
public struct ArchiveCompression : Swift.Equatable, Swift.Hashable, Swift.RawRepresentable, Swift.CustomStringConvertible {
  public static let none: AppleArchive.ArchiveCompression
  public static let lz4: AppleArchive.ArchiveCompression
  public static let zlib: AppleArchive.ArchiveCompression
  public static let lzma: AppleArchive.ArchiveCompression
  public static let lzfse: AppleArchive.ArchiveCompression
  public init(rawValue: Swift.UInt32)
  public init(algo: Compression.Algorithm)
  public typealias RawValue = Swift.UInt32
  public var rawValue: AppleArchive.ArchiveCompression.RawValue
  public var description: Swift.String {
    get
  }
}
@available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
extension AppleArchive.ArchiveHeader {
  public struct EntryType : Swift.Equatable, Swift.Hashable, Swift.RawRepresentable, Swift.CustomStringConvertible {
    public static let regularFile: AppleArchive.ArchiveHeader.EntryType
    public static let directory: AppleArchive.ArchiveHeader.EntryType
    public static let link: AppleArchive.ArchiveHeader.EntryType
    public static let fifo: AppleArchive.ArchiveHeader.EntryType
    public static let characterSpecial: AppleArchive.ArchiveHeader.EntryType
    public static let blockSpecial: AppleArchive.ArchiveHeader.EntryType
    public static let socket: AppleArchive.ArchiveHeader.EntryType
    public static let whiteout: AppleArchive.ArchiveHeader.EntryType
    public static let door: AppleArchive.ArchiveHeader.EntryType
    public static let port: AppleArchive.ArchiveHeader.EntryType
    public static let metadata: AppleArchive.ArchiveHeader.EntryType
    public var rawValue: Swift.UInt32
    public init(rawValue: Swift.UInt32)
    public var description: Swift.String {
      get
    }
    public typealias RawValue = Swift.UInt32
  }
}
@available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
public struct _AAEntryXATBlobTraits : AppleArchive._AAObjectTraits {
  public typealias AAType = AppleArchive.__AAEntryXATBlob
  public static func aaDestroy(_ object: AppleArchive._AAEntryXATBlobTraits.AAType?)
}
@available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
extension AppleArchive.ArchiveHeader {
  @_hasMissingDesignatedInitializers public class EntryXATBlob : AppleArchive._AAObjectWrapper<AppleArchive._AAEntryXATBlobTraits>, AppleArchive._AAEncodableProtocol {
    public struct ExtendedAttribute : Swift.CustomStringConvertible, Swift.Equatable, Swift.Hashable {
      public var description: Swift.String {
        get
      }
      public init(key: Swift.String, data: Swift.ContiguousArray<Swift.UInt8>)
      public static func == (a: AppleArchive.ArchiveHeader.EntryXATBlob.ExtendedAttribute, b: AppleArchive.ArchiveHeader.EntryXATBlob.ExtendedAttribute) -> Swift.Bool
      public func hash(into hasher: inout Swift.Hasher)
      public var hashValue: Swift.Int {
        get
      }
    }
    required public init()
    public init?(directory: System.FilePath, path: System.FilePath, flags: AppleArchive.ArchiveFlags)
    public func apply(directory: System.FilePath, path: System.FilePath, flags: AppleArchive.ArchiveFlags = []) throws
    required public init?(withAAEncodedData data: Swift.UnsafeBufferPointer<Swift.UInt8>)
    public func withAAEncodedData<R>(_ body: (Swift.UnsafeBufferPointer<Swift.UInt8>) throws -> R) rethrows -> R
    @objc deinit
  }
}
@available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
extension AppleArchive.ArchiveHeader.EntryXATBlob : Swift.RandomAccessCollection, Swift.MutableCollection {
  public var startIndex: Swift.Int {
    get
  }
  public var endIndex: Swift.Int {
    get
  }
  public subscript(i: Swift.Int) -> AppleArchive.ArchiveHeader.EntryXATBlob.ExtendedAttribute {
    get
    set
  }
  public func removeAll()
  public func remove(at i: Swift.Int) -> AppleArchive.ArchiveHeader.EntryXATBlob.ExtendedAttribute
  public func append(_ newElement: AppleArchive.ArchiveHeader.EntryXATBlob.ExtendedAttribute)
  public typealias Element = AppleArchive.ArchiveHeader.EntryXATBlob.ExtendedAttribute
  public typealias Index = Swift.Int
  public typealias Indices = Swift.Range<Swift.Int>
  public typealias Iterator = Swift.IndexingIterator<AppleArchive.ArchiveHeader.EntryXATBlob>
  public typealias SubSequence = Swift.Slice<AppleArchive.ArchiveHeader.EntryXATBlob>
}
@available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
public struct _AAByteStreamTraits : AppleArchive._AAObjectTraits {
  public typealias AAType = AppleArchive.__AAByteStream
  public static func aaDestroy(_ object: AppleArchive._AAByteStreamTraits.AAType?)
}
@_inheritsConvenienceInitializers @available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
public class ArchiveByteStream : AppleArchive._AAOptionalObjectWrapper<AppleArchive._AAByteStreamTraits>, AppleArchive.ArchiveByteStreamProtocol {
  public func read(into buffer: Swift.UnsafeMutableRawBufferPointer) throws -> Swift.Int
  public func read(into buffer: Swift.UnsafeMutableRawBufferPointer, atOffset offset: Swift.Int64) throws -> Swift.Int
  public func write(from buffer: Swift.UnsafeRawBufferPointer) throws -> Swift.Int
  public func write(from buffer: Swift.UnsafeRawBufferPointer, atOffset offset: Swift.Int64) throws -> Swift.Int
  public func seek(toOffset offset: Swift.Int64, relativeTo origin: System.FileDescriptor.SeekOrigin) throws -> Swift.Int64
  public func cancel()
  public func close() throws
  override public init(object aaObject: AppleArchive._AAOptionalObjectWrapper<AppleArchive._AAByteStreamTraits>.AAType?, owned aaObjectOwned: Swift.Bool)
  @objc deinit
}
extension AppleArchive.ArchiveByteStream {
  @available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
  public static func fileStream(path: System.FilePath, mode: System.FileDescriptor.AccessMode, options: System.FileDescriptor.OpenOptions, permissions: System.FilePermissions) -> AppleArchive.ArchiveByteStream?
  @available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
  public static func fileStream(fd: System.FileDescriptor, automaticClose: Swift.Bool = true) -> AppleArchive.ArchiveByteStream?
  @available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
  public static func temporaryFileStream() -> AppleArchive.ArchiveByteStream?
  @available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
  public static func compressionStream(using compressionAlgorithm: AppleArchive.ArchiveCompression, writingTo compressedStream: AppleArchive.ArchiveByteStream, blockSize: Swift.Int = (1<<20), flags: AppleArchive.ArchiveFlags = [], threadCount: Swift.Int = 0) -> AppleArchive.ArchiveByteStream?
  @available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
  public static func compressionStream(appendingTo compressedStream: AppleArchive.ArchiveByteStream, flags: AppleArchive.ArchiveFlags = [], threadCount: Swift.Int = 0) -> AppleArchive.ArchiveByteStream?
  @available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
  public static func decompressionStream(readingFrom compressedStream: AppleArchive.ArchiveByteStream, flags: AppleArchive.ArchiveFlags = [], threadCount: Swift.Int = 0) -> AppleArchive.ArchiveByteStream?
  @available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
  public static func randomAccessDecompressionStream(readingFrom compressedStream: AppleArchive.ArchiveByteStream, allocationLimit: Swift.Int = Int.max, flags: AppleArchive.ArchiveFlags = [], threadCount: Swift.Int = 0) -> AppleArchive.ArchiveByteStream?
  @available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
  public static func sharedBufferPipe(capacity: Swift.Int) -> (output: AppleArchive.ArchiveByteStream, input: AppleArchive.ArchiveByteStream)?
}
extension AppleArchive.ArchiveByteStream {
  @available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
  public static func process(readingFrom input: AppleArchive.ArchiveByteStream, writingTo output: AppleArchive.ArchiveByteStream) throws -> Swift.Int64
}
@available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
extension AppleArchive.ArchiveHeader {
  public struct FieldType : Swift.Equatable, Swift.Hashable, Swift.RawRepresentable, Swift.CustomStringConvertible {
    public static let flag: AppleArchive.ArchiveHeader.FieldType
    public static let uint: AppleArchive.ArchiveHeader.FieldType
    public static let string: AppleArchive.ArchiveHeader.FieldType
    public static let hash: AppleArchive.ArchiveHeader.FieldType
    public static let timespec: AppleArchive.ArchiveHeader.FieldType
    public static let blob: AppleArchive.ArchiveHeader.FieldType
    public var rawValue: Swift.UInt32
    public init(rawValue: Swift.UInt32)
    public var description: Swift.String {
      get
    }
    public typealias RawValue = Swift.UInt32
  }
}
@available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
public protocol _AAEncodableProtocol {
  init?(withAAEncodedData data: Swift.UnsafeBufferPointer<Swift.UInt8>)
  func withAAEncodedData<R>(_ body: (Swift.UnsafeBufferPointer<Swift.UInt8>) throws -> R) rethrows -> R
}
@available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
public protocol _AAObjectTraits {
  associatedtype AAType
  static func aaDestroy(_: Self.AAType?)
}
@available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
public class _AAObjectWrapper<T> where T : AppleArchive._AAObjectTraits {
  public init(object aaObject: AppleArchive._AAObjectWrapper<T>.AAType, owned aaObjectOwned: Swift.Bool)
  @objc deinit
  public typealias AAType = T.AAType
}
@available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
public class _AAOptionalObjectWrapper<T> where T : AppleArchive._AAObjectTraits {
  public init(object aaObject: AppleArchive._AAOptionalObjectWrapper<T>.AAType?, owned aaObjectOwned: Swift.Bool)
  @objc deinit
  public typealias AAType = T.AAType
}
@available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
public class _AAOptionalObjectWrapperWithFilter<T> where T : AppleArchive._AAObjectTraits {
  public init(object aaObject: AppleArchive._AAOptionalObjectWrapperWithFilter<T>.AAType?, owned aaObjectOwned: Swift.Bool, messageProc filter: AppleArchive.ArchiveHeader._EntryFilterWrapper? = nil)
  @objc deinit
  public typealias AAType = T.AAType
}
@available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
public struct ArchiveFlags : Swift.Hashable, Swift.OptionSet {
  public static let ignoreOperationNotPermitted: AppleArchive.ArchiveFlags
  public static let archiveDeduplicateData: AppleArchive.ArchiveFlags
  public static let replaceAttributes: AppleArchive.ArchiveFlags
  public static let extractNoAutoDeduplicate: AppleArchive.ArchiveFlags
  public static let extractNoAutoSparse: AppleArchive.ArchiveFlags
  public static func verbosity(level: Swift.Int) -> AppleArchive.ArchiveFlags
  public var rawValue: Swift.UInt64
  public init()
  public init(rawValue: Swift.UInt64)
  public typealias ArrayLiteralElement = AppleArchive.ArchiveFlags
  public typealias Element = AppleArchive.ArchiveFlags
  public typealias RawValue = Swift.UInt64
}
@available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
public struct _AAArchiveStreamTraits : AppleArchive._AAObjectTraits {
  public typealias AAType = AppleArchive.__AAArchiveStream
  public static func aaDestroy(_ object: AppleArchive._AAArchiveStreamTraits.AAType?)
}
@_inheritsConvenienceInitializers @available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
public class ArchiveStream : AppleArchive._AAOptionalObjectWrapperWithFilter<AppleArchive._AAArchiveStreamTraits>, AppleArchive.ArchiveStreamProtocol {
  public func writeHeader(_ header: AppleArchive.ArchiveHeader) throws
  public func writeBlob(key: AppleArchive.ArchiveHeader.FieldKey, from buffer: Swift.UnsafeRawBufferPointer) throws
  public func readHeader() throws -> AppleArchive.ArchiveHeader?
  public func readBlob(key: AppleArchive.ArchiveHeader.FieldKey, into buffer: Swift.UnsafeMutableRawBufferPointer) throws
  public func cancel()
  public func close() throws
  override public init(object aaObject: AppleArchive._AAOptionalObjectWrapperWithFilter<AppleArchive._AAArchiveStreamTraits>.AAType?, owned aaObjectOwned: Swift.Bool, messageProc filter: AppleArchive.ArchiveHeader._EntryFilterWrapper? = nil)
  @objc deinit
}
extension AppleArchive.ArchiveStream {
  @available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
  public func writeDirectoryContents(archiveFrom directory: System.FilePath, path: System.FilePath? = nil, keySet: AppleArchive.ArchiveHeader.FieldKeySet, selectUsing filter: AppleArchive.ArchiveHeader.EntryFilter? = nil, flags: AppleArchive.ArchiveFlags = [], threadCount: Swift.Int = 0) throws
}
extension AppleArchive.ArchiveStream {
  @available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
  public static func process(readingFrom input: AppleArchive.ArchiveStream, writingTo output: AppleArchive.ArchiveStream, selectUsing filter: AppleArchive.ArchiveHeader.EntryFilter? = nil, flags: AppleArchive.ArchiveFlags = [], threadCount: Swift.Int = 0) throws -> Swift.Int
}
extension AppleArchive.ArchiveStream {
  @available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
  public static func encodeStream(writingTo stream: AppleArchive.ArchiveByteStream, selectUsing filter: AppleArchive.ArchiveHeader.EntryFilter? = nil, flags: AppleArchive.ArchiveFlags = [], threadCount: Swift.Int = 0) -> AppleArchive.ArchiveStream?
  @available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
  public static func decodeStream(readingFrom stream: AppleArchive.ArchiveByteStream, selectUsing filter: AppleArchive.ArchiveHeader.EntryFilter? = nil, flags: AppleArchive.ArchiveFlags = [], threadCount: Swift.Int = 0) -> AppleArchive.ArchiveStream?
  @available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
  public static func extractStream(extractingTo directory: System.FilePath, selectUsing filter: AppleArchive.ArchiveHeader.EntryFilter? = nil, flags: AppleArchive.ArchiveFlags = [], threadCount: Swift.Int = 0) -> AppleArchive.ArchiveStream?
  @available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
  public static func convertStream(writingTo stream: AppleArchive.ArchiveStream, insertKeySet: AppleArchive.ArchiveHeader.FieldKeySet, removeKeySet: AppleArchive.ArchiveHeader.FieldKeySet, selectUsing filter: AppleArchive.ArchiveHeader.EntryFilter? = nil, flags: AppleArchive.ArchiveFlags = [], threadCount: Swift.Int = 0) -> AppleArchive.ArchiveStream?
}
extension AppleArchive.ArchiveStream {
  @available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
  public static func customStream<C>(instance: C) -> AppleArchive.ArchiveStream? where C : AnyObject, C : AppleArchive.ArchiveStreamProtocol
}
extension AppleArchive.ArchiveByteStream {
  @available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
  public static func customStream<C>(instance: C) -> AppleArchive.ArchiveByteStream? where C : AnyObject, C : AppleArchive.ArchiveByteStreamProtocol
}
extension AppleArchive.ArchiveByteStream {
  @available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
  public static func withFileStream<E>(path: System.FilePath, mode: System.FileDescriptor.AccessMode, options: System.FileDescriptor.OpenOptions, permissions: System.FilePermissions, _ body: (AppleArchive.ArchiveByteStream) throws -> E) throws -> E
  @available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
  public static func withFileStream<E>(fd: System.FileDescriptor, automaticClose: Swift.Bool = true, _ body: (AppleArchive.ArchiveByteStream) throws -> E) throws -> E
  @available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
  public static func withTemporaryFileStream<E>(_ body: (AppleArchive.ArchiveByteStream) throws -> E) throws -> E
  @available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
  public static func withCompressionStream<E>(using compressionAlgorithm: AppleArchive.ArchiveCompression, writingTo compressedStream: AppleArchive.ArchiveByteStream, blockSize: Swift.Int = (1<<20), flags: AppleArchive.ArchiveFlags = [], threadCount: Swift.Int = 0, _ body: (AppleArchive.ArchiveByteStream) throws -> E) throws -> E
  @available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
  public static func withCompressionStream<E>(appendingTo compressedStream: AppleArchive.ArchiveByteStream, flags: AppleArchive.ArchiveFlags = [], threadCount: Swift.Int = 0, _ body: (AppleArchive.ArchiveByteStream) throws -> E) throws -> E
  @available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
  public static func withDecompressionStream<E>(readingFrom compressedStream: AppleArchive.ArchiveByteStream, flags: AppleArchive.ArchiveFlags = [], threadCount: Swift.Int = 0, _ body: (AppleArchive.ArchiveByteStream) throws -> E) throws -> E
  @available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
  public static func withRandomAccessDecompressionStream<E>(readingFrom compressedStream: AppleArchive.ArchiveByteStream, allocationLimit: Swift.Int = Int.max, flags: AppleArchive.ArchiveFlags = [], threadCount: Swift.Int = 0, _ body: (AppleArchive.ArchiveByteStream) throws -> E) throws -> E
  @available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
  public static func withStream<C, E>(wrapping instance: C, _ body: (AppleArchive.ArchiveByteStream) throws -> E) throws -> E where C : AnyObject, C : AppleArchive.ArchiveByteStreamProtocol
}
@available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
extension AppleArchive.ArchiveHeader {
  public struct FieldKey : Swift.Equatable, Swift.Hashable, Swift.CustomStringConvertible {
    public init(_ key: Swift.String)
    public var description: Swift.String {
      get
    }
    public static func == (lhs: AppleArchive.ArchiveHeader.FieldKey, rhs: AppleArchive.ArchiveHeader.FieldKey) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension AppleArchive.ArchiveEncryptionContext {
  public struct ChecksumMode : Swift.Equatable, Swift.Hashable, Swift.RawRepresentable, Swift.CustomStringConvertible {
    public static let none: AppleArchive.ArchiveEncryptionContext.ChecksumMode
    public static let murmurhash64: AppleArchive.ArchiveEncryptionContext.ChecksumMode
    public static let sha256: AppleArchive.ArchiveEncryptionContext.ChecksumMode
    public var rawValue: Swift.UInt32
    public init(rawValue: Swift.UInt32)
    public var description: Swift.String {
      get
    }
    public typealias RawValue = Swift.UInt32
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension AppleArchive.ArchiveEncryptionContext {
  public struct SignatureMode : Swift.Equatable, Swift.Hashable, Swift.RawRepresentable, Swift.CustomStringConvertible {
    public static let none: AppleArchive.ArchiveEncryptionContext.SignatureMode
    public static let ecdsa_p256: AppleArchive.ArchiveEncryptionContext.SignatureMode
    public var rawValue: Swift.UInt32
    public init(rawValue: Swift.UInt32)
    public var description: Swift.String {
      get
    }
    public typealias RawValue = Swift.UInt32
  }
}
@available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
public protocol ArchiveByteStreamProtocol {
  func read(into buffer: Swift.UnsafeMutableRawBufferPointer) throws -> Swift.Int
  func read(into buffer: Swift.UnsafeMutableRawBufferPointer, atOffset offset: Swift.Int64) throws -> Swift.Int
  func write(from buffer: Swift.UnsafeRawBufferPointer) throws -> Swift.Int
  func write(from buffer: Swift.UnsafeRawBufferPointer, atOffset offset: Swift.Int64) throws -> Swift.Int
  func seek(toOffset offset: Swift.Int64, relativeTo origin: System.FileDescriptor.SeekOrigin) throws -> Swift.Int64
  func cancel()
  func close() throws
}
@available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
public struct _AAFieldKeySetTraits : AppleArchive._AAObjectTraits {
  public typealias AAType = AppleArchive.__AAFieldKeySet
  public static func aaDestroy(_ object: AppleArchive._AAFieldKeySetTraits.AAType?)
}
@available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
extension AppleArchive.ArchiveHeader {
  @_hasMissingDesignatedInitializers final public class FieldKeySet : AppleArchive._AAObjectWrapper<AppleArchive._AAFieldKeySetTraits> {
    required public init()
    public init?(_ s: Swift.String)
    public init(copying s: AppleArchive.ArchiveHeader.FieldKeySet)
    public static var defaultForArchive: AppleArchive.ArchiveHeader.FieldKeySet {
      get
    }
    public static var defaultForManifest: AppleArchive.ArchiveHeader.FieldKeySet {
      get
    }
    @objc deinit
  }
}
@available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
extension AppleArchive.ArchiveHeader.FieldKeySet : Swift.CustomStringConvertible, Swift.RandomAccessCollection, Swift.SetAlgebra {
  public typealias Index = Swift.Int
  public typealias Element = AppleArchive.ArchiveHeader.FieldKey
  @discardableResult
  final public func insert(_ newMember: __owned AppleArchive.ArchiveHeader.FieldKey) -> (inserted: Swift.Bool, memberAfterInsert: AppleArchive.ArchiveHeader.FieldKey)
  @discardableResult
  final public func remove(_ member: AppleArchive.ArchiveHeader.FieldKey) -> AppleArchive.ArchiveHeader.FieldKey?
  @discardableResult
  final public func update(with newMember: __owned AppleArchive.ArchiveHeader.FieldKey) -> AppleArchive.ArchiveHeader.FieldKey?
  final public func formUnion(_ other: AppleArchive.ArchiveHeader.FieldKeySet)
  final public func formIntersection(_ other: AppleArchive.ArchiveHeader.FieldKeySet)
  final public func formSymmetricDifference(_ other: __owned AppleArchive.ArchiveHeader.FieldKeySet)
  final public func union(_ other: AppleArchive.ArchiveHeader.FieldKeySet) -> AppleArchive.ArchiveHeader.FieldKeySet
  final public func intersection(_ other: AppleArchive.ArchiveHeader.FieldKeySet) -> AppleArchive.ArchiveHeader.FieldKeySet
  final public __consuming func symmetricDifference(_ other: __owned AppleArchive.ArchiveHeader.FieldKeySet) -> AppleArchive.ArchiveHeader.FieldKeySet
  final public var isEmpty: Swift.Bool {
    get
  }
  final public var startIndex: Swift.Int {
    get
  }
  final public var endIndex: Swift.Int {
    get
  }
  final public subscript(i: Swift.Int) -> AppleArchive.ArchiveHeader.FieldKey {
    get
  }
  final public func contains(_ member: AppleArchive.ArchiveHeader.FieldKey) -> Swift.Bool
  public static func == (lhs: AppleArchive.ArchiveHeader.FieldKeySet, rhs: AppleArchive.ArchiveHeader.FieldKeySet) -> Swift.Bool
  final public var description: Swift.String {
    get
  }
  public typealias ArrayLiteralElement = AppleArchive.ArchiveHeader.FieldKeySet.Element
  public typealias Indices = Swift.Range<AppleArchive.ArchiveHeader.FieldKeySet.Index>
  public typealias Iterator = Swift.IndexingIterator<AppleArchive.ArchiveHeader.FieldKeySet>
  public typealias SubSequence = Swift.Slice<AppleArchive.ArchiveHeader.FieldKeySet>
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
public struct AEAContextTraits : AppleArchive._AAObjectTraits {
  public typealias AAType = AppleArchive.__AEAContext
  public static func aaDestroy(_ object: AppleArchive.AEAContextTraits.AAType?)
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
public class ArchiveEncryptionContext : AppleArchive._AAObjectWrapper<AppleArchive.AEAContextTraits> {
  public init(profile: AppleArchive.ArchiveEncryptionContext.Profile, compressionAlgorithm: AppleArchive.ArchiveCompression, compressionBlockSize: Swift.Int = 1<<20)
  public init?(from stream: AppleArchive.ArchiveByteStream)
  public var profile: AppleArchive.ArchiveEncryptionContext.Profile {
    get
  }
  public var signatureMode: AppleArchive.ArchiveEncryptionContext.SignatureMode {
    get
  }
  public var encryptionMode: AppleArchive.ArchiveEncryptionContext.EncryptionMode {
    get
  }
  public var paddingSize: Swift.Int {
    get
    set(value)
  }
  public var checksumMode: AppleArchive.ArchiveEncryptionContext.ChecksumMode {
    get
    set(value)
  }
  public var compressionAlgorithm: AppleArchive.ArchiveCompression {
    get
    set(value)
  }
  public var compressionBlockSize: Swift.Int {
    get
    set(value)
  }
  public var rawSize: Swift.Int {
    get
  }
  public var containerSize: Swift.Int {
    get
  }
  public var symmetricKey: CryptoKit.SymmetricKey? {
    get
    set(key)
  }
  public var password: Swift.String? {
    get
    set(s)
  }
  public func generateSymmetricKey() throws -> CryptoKit.SymmetricKey
  public func generatePassword() throws -> Swift.String
  public func setSymmetricKey(_ key: CryptoKit.SymmetricKey) throws
  public func setPassword(_ password: Swift.String) throws
  public func setSigningPublicKey(_ key: CryptoKit.P256.Signing.PublicKey) throws
  public func setSigningPrivateKey(_ key: CryptoKit.P256.Signing.PrivateKey) throws
  public func setRecipientPublicKey(_ key: CryptoKit.P256.KeyAgreement.PublicKey) throws
  public func setRecipientPrivateKey(_ key: CryptoKit.P256.KeyAgreement.PrivateKey) throws
  public var authData: Foundation.Data? {
    get
    set(data)
  }
  public var archiveIdentifier: Foundation.Data? {
    get
  }
  public var signatureEncryptionKey: CryptoKit.SymmetricKey? {
    get
    set(key)
  }
  public var mainKey: CryptoKit.SymmetricKey? {
    get
    set(key)
  }
  @objc deinit
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension AppleArchive.ArchiveEncryptionContext {
  public static func sign(encryptedStream: AppleArchive.ArchiveByteStream, encryptionContext context: AppleArchive.ArchiveEncryptionContext) throws
}
extension AppleArchive.ArchiveByteStream {
  @available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
  public static func encryptionStream(writingTo encryptedStream: AppleArchive.ArchiveByteStream, encryptionContext context: AppleArchive.ArchiveEncryptionContext, flags: AppleArchive.ArchiveFlags = [], threadCount: Swift.Int = 0) -> AppleArchive.ArchiveByteStream?
  @available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
  public static func encryptionStream(appendingTo encryptedStream: AppleArchive.ArchiveByteStream, encryptionContext context: AppleArchive.ArchiveEncryptionContext, flags: AppleArchive.ArchiveFlags = [], threadCount: Swift.Int = 0) -> AppleArchive.ArchiveByteStream?
  @available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
  public static func decryptionStream(readingFrom encryptedStream: AppleArchive.ArchiveByteStream, encryptionContext context: AppleArchive.ArchiveEncryptionContext, flags: AppleArchive.ArchiveFlags = [], threadCount: Swift.Int = 0) -> AppleArchive.ArchiveByteStream?
  @available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
  public static func randomAccessDecryptionStream(readingFrom encryptedStream: AppleArchive.ArchiveByteStream, encryptionContext context: AppleArchive.ArchiveEncryptionContext, allocationLimit: Swift.Int = Int.max, flags: AppleArchive.ArchiveFlags = [], threadCount: Swift.Int = 0) -> AppleArchive.ArchiveByteStream?
}
extension AppleArchive.ArchiveByteStream {
  @available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
  public func close(updatingContext context: AppleArchive.ArchiveEncryptionContext) throws
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension AppleArchive.ArchiveEncryptionContext {
  public struct Profile : Swift.Equatable, Swift.Hashable, Swift.RawRepresentable, Swift.CustomStringConvertible {
    public static let hkdf_sha256_hmac__none__ecdsa_p256: AppleArchive.ArchiveEncryptionContext.Profile
    public static let hkdf_sha256_aesctr_hmac__symmetric__none: AppleArchive.ArchiveEncryptionContext.Profile
    public static let hkdf_sha256_aesctr_hmac__symmetric__ecdsa_p256: AppleArchive.ArchiveEncryptionContext.Profile
    public static let hkdf_sha256_aesctr_hmac__ecdhe_p256__none: AppleArchive.ArchiveEncryptionContext.Profile
    public static let hkdf_sha256_aesctr_hmac__ecdhe_p256__ecdsa_p256: AppleArchive.ArchiveEncryptionContext.Profile
    public static let hkdf_sha256_aesctr_hmac__scrypt__none: AppleArchive.ArchiveEncryptionContext.Profile
    public var rawValue: Swift.UInt32
    public init(rawValue: Swift.UInt32)
    public var description: Swift.String {
      get
    }
    public typealias RawValue = Swift.UInt32
  }
}
