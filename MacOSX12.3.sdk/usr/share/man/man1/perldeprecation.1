.\" Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PERLDEPRECATION 1"
.TH PERLDEPRECATION 1 "2019-10-21" "perl v5.30.3" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
perldeprecation \- list Perl deprecations
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The purpose of this document is to document what has been deprecated
in Perl, and by which version the deprecated feature will disappear,
or, for already removed features, when it was removed.
.PP
This document will try to discuss what alternatives for the deprecated
features are available.
.PP
The deprecated features will be grouped by the version of Perl in
which they will be removed.
.SS "Perl 5.32"
.IX Subsection "Perl 5.32"
\fIConstants from lexical variables potentially modified elsewhere\fR
.IX Subsection "Constants from lexical variables potentially modified elsewhere"
.PP
You wrote something like
.PP
.Vb 2
\&    my $var;
\&    $sub = sub () { $var };
.Ve
.PP
but \f(CW$var\fR is referenced elsewhere and could be modified after the \f(CW\*(C`sub\*(C'\fR
expression is evaluated.  Either it is explicitly modified elsewhere
(\f(CW\*(C`$var = 3\*(C'\fR) or it is passed to a subroutine or to an operator like
\&\f(CW\*(C`printf\*(C'\fR or \f(CW\*(C`map\*(C'\fR, which may or may not modify the variable.
.PP
Traditionally, Perl has captured the value of the variable at that
point and turned the subroutine into a constant eligible for inlining.
In those cases where the variable can be modified elsewhere, this
breaks the behavior of closures, in which the subroutine captures
the variable itself, rather than its value, so future changes to the
variable are reflected in the subroutine's return value.
.PP
If you intended for the subroutine to be eligible for inlining, then
make sure the variable is not referenced elsewhere, possibly by
copying it:
.PP
.Vb 2
\&    my $var2 = $var;
\&    $sub = sub () { $var2 };
.Ve
.PP
If you do want this subroutine to be a closure that reflects future
changes to the variable that it closes over, add an explicit \f(CW\*(C`return\*(C'\fR:
.PP
.Vb 2
\&    my $var;
\&    $sub = sub () { return $var };
.Ve
.PP
This usage has been deprecated, and will no longer be allowed in Perl 5.32.
.PP
\fIUse of strings with code points over 0xFF as arguments to \f(CI\*(C`vec\*(C'\fI\fR
.IX Subsection "Use of strings with code points over 0xFF as arguments to vec"
.PP
\&\f(CW\*(C`vec\*(C'\fR views its string argument as a sequence of bits.  A string
containing a code point over 0xFF is nonsensical.  This usage is
deprecated in Perl 5.28, and will be removed in Perl 5.32.
.PP
\fIUse of code points over 0xFF in string bitwise operators\fR
.IX Subsection "Use of code points over 0xFF in string bitwise operators"
.PP
The string bitwise operators, \f(CW\*(C`&\*(C'\fR, \f(CW\*(C`|\*(C'\fR, \f(CW\*(C`^\*(C'\fR, and \f(CW\*(C`~\*(C'\fR, treat their
operands as strings of bytes. As such, values above 0xFF are
nonsensical. Some instances of these have been deprecated since Perl
5.24, and were made fatal in 5.28, but it turns out that in cases where
the wide characters did not affect the end result, no deprecation
notice was raised, and so remain legal.  Now, all occurrences either are
fatal or raise a deprecation warning, so that the remaining legal
occurrences will be fatal in 5.32.
.PP
An example of this is
.PP
.Vb 1
\& "" & "\ex{100}"
.Ve
.PP
The wide character is not used in the \f(CW\*(C`&\*(C'\fR operation because the left
operand is shorter.  This now warns anyway.
.PP
\fI\f(BIhostname()\fI doesn't accept any arguments\fR
.IX Subsection "hostname() doesn't accept any arguments"
.PP
The function \f(CW\*(C`hostname()\*(C'\fR in the Sys::Hostname module has always
been documented to be called with no arguments.  Historically it has not
enforced this, and has actually accepted and ignored any arguments.  As a
result, some users have got the mistaken impression that an argument does
something useful.  To avoid these bugs, the function is being made strict.
Passing arguments was deprecated in Perl 5.28, and will become fatal in
Perl 5.32.
.PP
\fIUnescaped left braces in regular expressions\fR
.IX Subsection "Unescaped left braces in regular expressions"
.PP
The simple rule to remember, if you want to match a literal \f(CW\*(C`{\*(C'\fR
character (U+007B \f(CW\*(C`LEFT CURLY BRACKET\*(C'\fR) in a regular expression
pattern, is to escape each literal instance of it in some way.
Generally easiest is to precede it with a backslash, like \f(CW\*(C`\e{\*(C'\fR
or enclose it in square brackets (\f(CW\*(C`[{]\*(C'\fR).  If the pattern
delimiters are also braces, any matching right brace (\f(CW\*(C`}\*(C'\fR) should
also be escaped to avoid confusing the parser, for example,
.PP
.Vb 1
\& qr{abc\e{def\e}ghi}
.Ve
.PP
Forcing literal \f(CW\*(C`{\*(C'\fR characters to be escaped will enable the Perl
language to be extended in various ways in future releases.  To avoid
needlessly breaking existing code, the restriction is is not enforced in
contexts where there are unlikely to ever be extensions that could
conflict with the use there of \f(CW\*(C`{\*(C'\fR as a literal.  A non-deprecation
warning that the left brace is being taken literally is raised in
contexts where there could be confusion about it.
.PP
Literal uses of \f(CW\*(C`{\*(C'\fR were deprecated in Perl 5.20, and some uses of it
started to give deprecation warnings since. These cases were made fatal
in Perl 5.26. Due to an oversight, not all cases of a use of a literal
\&\f(CW\*(C`{\*(C'\fR got a deprecation warning.  Some cases started warning in Perl 5.26,
and were made fatal in Perl 5.30.  Other cases started in Perl 5.28,
and will be made fatal in 5.32.
.PP
\fIIn \s-1XS\s0 code, use of various macros dealing with \s-1UTF\-8.\s0\fR
.IX Subsection "In XS code, use of various macros dealing with UTF-8."
.PP
These macros will require an extra parameter in Perl 5.32:
\&\f(CW\*(C`isALPHANUMERIC_utf8\*(C'\fR,
\&\f(CW\*(C`isASCII_utf8\*(C'\fR,
\&\f(CW\*(C`isBLANK_utf8\*(C'\fR,
\&\f(CW\*(C`isCNTRL_utf8\*(C'\fR,
\&\f(CW\*(C`isDIGIT_utf8\*(C'\fR,
\&\f(CW\*(C`isIDFIRST_utf8\*(C'\fR,
\&\f(CW\*(C`isPSXSPC_utf8\*(C'\fR,
\&\f(CW\*(C`isSPACE_utf8\*(C'\fR,
\&\f(CW\*(C`isVERTWS_utf8\*(C'\fR,
\&\f(CW\*(C`isWORDCHAR_utf8\*(C'\fR,
\&\f(CW\*(C`isXDIGIT_utf8\*(C'\fR,
\&\f(CW\*(C`isALPHANUMERIC_LC_utf8\*(C'\fR,
\&\f(CW\*(C`isALPHA_LC_utf8\*(C'\fR,
\&\f(CW\*(C`isASCII_LC_utf8\*(C'\fR,
\&\f(CW\*(C`isBLANK_LC_utf8\*(C'\fR,
\&\f(CW\*(C`isCNTRL_LC_utf8\*(C'\fR,
\&\f(CW\*(C`isDIGIT_LC_utf8\*(C'\fR,
\&\f(CW\*(C`isGRAPH_LC_utf8\*(C'\fR,
\&\f(CW\*(C`isIDCONT_LC_utf8\*(C'\fR,
\&\f(CW\*(C`isIDFIRST_LC_utf8\*(C'\fR,
\&\f(CW\*(C`isLOWER_LC_utf8\*(C'\fR,
\&\f(CW\*(C`isPRINT_LC_utf8\*(C'\fR,
\&\f(CW\*(C`isPSXSPC_LC_utf8\*(C'\fR,
\&\f(CW\*(C`isPUNCT_LC_utf8\*(C'\fR,
\&\f(CW\*(C`isSPACE_LC_utf8\*(C'\fR,
\&\f(CW\*(C`isUPPER_LC_utf8\*(C'\fR,
\&\f(CW\*(C`isWORDCHAR_LC_utf8\*(C'\fR,
\&\f(CW\*(C`isXDIGIT_LC_utf8\*(C'\fR,
\&\f(CW\*(C`toFOLD_utf8\*(C'\fR,
\&\f(CW\*(C`toLOWER_utf8\*(C'\fR,
\&\f(CW\*(C`toTITLE_utf8\*(C'\fR,
and
\&\f(CW\*(C`toUPPER_utf8\*(C'\fR.
.PP
There is now a macro that corresponds to each one of these, simply by
appending \f(CW\*(C`_safe\*(C'\fR to the name.  It takes the extra parameter.
For example, \f(CW\*(C`isDIGIT_utf8_safe\*(C'\fR corresponds to \f(CW\*(C`isDIGIT_utf8\*(C'\fR, but
takes the extra parameter, and its use doesn't generate a deprecation
warning.  All are documented in \*(L"Character case changing\*(R" in perlapi and
\&\*(L"Character classification\*(R" in perlapi.
.PP
You can change to use these versions at any time, or, if you can live
with the deprecation messages, wait until 5.32 and add the parameter to
the existing calls, without changing the names.
.PP
This change was originally scheduled for 5.30, but was delayed.
.SS "Perl 5.30"
.IX Subsection "Perl 5.30"
\fI\f(CI$*\fI is no longer supported\fR
.IX Subsection "$* is no longer supported"
.PP
Before Perl 5.10, setting \f(CW$*\fR to a true value globally enabled
multi-line matching within a string. This relique from the past lost
its special meaning in 5.10. Use of this variable will be a fatal error
in Perl 5.30, freeing the variable up for a future special meaning.
.PP
To enable multiline matching one should use the \f(CW\*(C`/m\*(C'\fR regexp
modifier (possibly in combination with \f(CW\*(C`/s\*(C'\fR). This can be set
on a per match bases, or can be enabled per lexical scope (including
a whole file) with \f(CW\*(C`use re \*(Aq/m\*(Aq\*(C'\fR.
.PP
\fI\f(CI$#\fI is no longer supported\fR
.IX Subsection "$# is no longer supported"
.PP
This variable used to have a special meaning \*(-- it could be used
to control how numbers were formatted when printed. This seldom
used functionality was removed in Perl 5.10. In order to free up
the variable for a future special meaning, its use will be a fatal
error in Perl 5.30.
.PP
To specify how numbers are formatted when printed, one is advised
to use \f(CW\*(C`printf\*(C'\fR or \f(CW\*(C`sprintf\*(C'\fR instead.
.PP
\fIAssigning non-zero to \f(CI$[\fI is fatal\fR
.IX Subsection "Assigning non-zero to $[ is fatal"
.PP
This variable (and the corresponding \f(CW\*(C`array_base\*(C'\fR feature and
arybase module) allowed changing the base for array and string
indexing operations.
.PP
Setting this to a non-zero value has been deprecated since Perl 5.12 and
throws a fatal error as of Perl 5.30.
.PP
\fI\f(CI\*(C`File::Glob::glob()\*(C'\fI will disappear\fR
.IX Subsection "File::Glob::glob() will disappear"
.PP
\&\f(CW\*(C`File::Glob\*(C'\fR has a function called \f(CW\*(C`glob\*(C'\fR, which just calls
\&\f(CW\*(C`bsd_glob\*(C'\fR. However, its prototype is different from the prototype
of \f(CW\*(C`CORE::glob\*(C'\fR, and hence, \f(CW\*(C`File::Glob::glob\*(C'\fR should not
be used.
.PP
\&\f(CW\*(C`File::Glob::glob()\*(C'\fR was deprecated in Perl 5.8. A deprecation
message was issued from Perl 5.26 onwards, and the function will
disappear in Perl 5.30.
.PP
Code using \f(CW\*(C`File::Glob::glob()\*(C'\fR should call
\&\f(CW\*(C`File::Glob::bsd_glob()\*(C'\fR instead.
.PP
\fIUnescaped left braces in regular expressions (for 5.30)\fR
.IX Subsection "Unescaped left braces in regular expressions (for 5.30)"
.PP
See \*(L"Unescaped left braces in regular expressions\*(R" above.
.PP
\fIUnqualified \f(CI\*(C`dump()\*(C'\fI\fR
.IX Subsection "Unqualified dump()"
.PP
Use of \f(CW\*(C`dump()\*(C'\fR instead of \f(CW\*(C`CORE::dump()\*(C'\fR was deprecated in Perl 5.8,
and an unqualified \f(CW\*(C`dump()\*(C'\fR will no longer be available in Perl 5.30.
.PP
See \*(L"dump\*(R" in perlfunc.
.PP
\fIUsing \f(BImy()\fI in false conditional.\fR
.IX Subsection "Using my() in false conditional."
.PP
There has been a long-standing bug in Perl that causes a lexical variable
not to be cleared at scope exit when its declaration includes a false
conditional.  Some people have exploited this bug to achieve a kind of
static variable.  Since we intend to fix this bug, we don't want people
relying on this behavior.
.PP
Instead, it's recommended one uses \f(CW\*(C`state\*(C'\fR variables to achieve the
same effect:
.PP
.Vb 4
\&    use 5.10.0;
\&    sub count {state $counter; return ++ $counter}
\&    say count ();    # Prints 1
\&    say count ();    # Prints 2
.Ve
.PP
\&\f(CW\*(C`state\*(C'\fR variables were introduced in Perl 5.10.
.PP
Alternatively, you can achieve a similar static effect by
declaring the variable in a separate block outside the function, eg
.PP
.Vb 1
\&    sub f { my $x if 0; return $x++ }
.Ve
.PP
becomes
.PP
.Vb 1
\&    { my $x; sub f { return $x++ } }
.Ve
.PP
The use of \f(CW\*(C`my()\*(C'\fR in a false conditional has been deprecated in
Perl 5.10, and it will become a fatal error in Perl 5.30.
.PP
\fIReading/writing bytes from/to :utf8 handles.\fR
.IX Subsection "Reading/writing bytes from/to :utf8 handles."
.PP
The \fBsysread()\fR, \fBrecv()\fR, \fBsyswrite()\fR and \fBsend()\fR operators are
deprecated on handles that have the \f(CW\*(C`:utf8\*(C'\fR layer, either explicitly, or
implicitly, eg., with the \f(CW\*(C`:encoding(UTF\-16LE)\*(C'\fR layer.
.PP
Both \fBsysread()\fR and \fBrecv()\fR currently use only the \f(CW\*(C`:utf8\*(C'\fR flag for the stream,
ignoring the actual layers.  Since \fBsysread()\fR and \fBrecv()\fR do no \s-1UTF\-8\s0
validation they can end up creating invalidly encoded scalars.
.PP
Similarly, \fBsyswrite()\fR and \fBsend()\fR use only the \f(CW\*(C`:utf8\*(C'\fR flag, otherwise ignoring
any layers.  If the flag is set, both write the value \s-1UTF\-8\s0 encoded, even if
the layer is some different encoding, such as the example above.
.PP
Ideally, all of these operators would completely ignore the \f(CW\*(C`:utf8\*(C'\fR state,
working only with bytes, but this would result in silently breaking existing
code.  To avoid this a future version of perl will throw an exception when
any of \fBsysread()\fR, \fBrecv()\fR, \fBsyswrite()\fR or \fBsend()\fR are called on handle with the
\&\f(CW\*(C`:utf8\*(C'\fR layer.
.PP
In Perl 5.30, it will no longer be possible to use \fBsysread()\fR, \fBrecv()\fR,
\&\fBsyswrite()\fR or \fBsend()\fR to read or send bytes from/to :utf8 handles.
.PP
\fIUse of unassigned code point or non-standalone grapheme for a delimiter.\fR
.IX Subsection "Use of unassigned code point or non-standalone grapheme for a delimiter."
.PP
A grapheme is what appears to a native-speaker of a language to be a
character.  In Unicode (and hence Perl) a grapheme may actually be
several adjacent characters that together form a complete grapheme.  For
example, there can be a base character, like \*(L"R\*(R" and an accent, like a
circumflex \*(L"^\*(R", that appear to be a single character when displayed,
with the circumflex hovering over the \*(L"R\*(R".
.PP
As of Perl 5.30, use of delimiters which are non-standalone graphemes is
fatal, in order to move the language to be able to accept
multi-character graphemes as delimiters.
.PP
Also, as of Perl 5.30, delimiters which are unassigned code points
but that may someday become assigned are prohibited.  Otherwise, code
that works today would fail to compile if the currently unassigned
delimiter ends up being something that isn't a stand-alone grapheme.
Because Unicode is never going to assign non-character code
points, nor code points that are
above the legal Unicode maximum, those can be delimiters.
.SS "Perl 5.28"
.IX Subsection "Perl 5.28"
\fIAttributes \f(CI\*(C`:locked\*(C'\fI and \f(CI\*(C`:unique\*(C'\fI\fR
.IX Subsection "Attributes :locked and :unique"
.PP
The attributes \f(CW\*(C`:locked\*(C'\fR (on code references) and \f(CW\*(C`:unique\*(C'\fR
(on array, hash and scalar references) have had no effect since 
Perl 5.005 and Perl 5.8.8 respectively. Their use has been deprecated
since.
.PP
As of Perl 5.28, these attributes are syntax errors. Since the
attributes do not do anything, removing them from your code fixes
the syntax error; and removing them will not influence the behaviour
of your code.
.PP
\fIBare here-document terminators\fR
.IX Subsection "Bare here-document terminators"
.PP
Perl has allowed you to use a bare here-document terminator to have the
here-document end at the first empty line. This practise was deprecated
in Perl 5.000; as of Perl 5.28, using a bare here-document terminator
throws a fatal error.
.PP
You are encouraged to use the explicitly quoted form if you wish to
use an empty line as the terminator of the here-document:
.PP
.Vb 2
\&  print <<"";
\&    Print this line.
\&
\&  # Previous blank line ends the here\-document.
.Ve
.PP
\fISetting $/ to a reference to a non-positive integer\fR
.IX Subsection "Setting $/ to a reference to a non-positive integer"
.PP
You assigned a reference to a scalar to \f(CW$/\fR where the
referenced item is not a positive integer.  In older perls this \fBappeared\fR
to work the same as setting it to \f(CW\*(C`undef\*(C'\fR but was in fact internally
different, less efficient and with very bad luck could have resulted in
your file being split by a stringified form of the reference.
.PP
In Perl 5.20.0 this was changed so that it would be \fBexactly\fR the same as
setting \f(CW$/\fR to undef, with the exception that this warning would be
thrown.
.PP
As of Perl 5.28, setting \f(CW$/\fR to a reference of a non-positive
integer throws a fatal error.
.PP
You are recommended to change your code to set \f(CW$/\fR to \f(CW\*(C`undef\*(C'\fR explicitly
if you wish to slurp the file.
.PP
\fILimit on the value of Unicode code points.\fR
.IX Subsection "Limit on the value of Unicode code points."
.PP
Unicode only allows code points up to 0x10FFFF, but Perl allows
much larger ones. Up till Perl 5.28, it was allowed to use code
points exceeding the maximum value of an integer (\f(CW\*(C`IV_MAX\*(C'\fR).
However, that did break the perl interpreter in some constructs,
including causing it to hang in a few cases.  The known problem
areas were in \f(CW\*(C`tr///\*(C'\fR, regular expression pattern matching using
quantifiers, as quote delimiters in \f(CW\*(C`q\f(CIX\f(CW...\f(CIX\f(CW\*(C'\fR (where \fIX\fR is
the \f(CW\*(C`chr()\*(C'\fR of a large code point), and as the upper limits in
loops.
.PP
The use of out of range code points was deprecated in Perl 5.24; as of
Perl 5.28 using a code point exceeding \f(CW\*(C`IV_MAX\*(C'\fR throws a fatal error.
.PP
If your code is to run on various platforms, keep in mind that the upper
limit depends on the platform. It is much larger on 64\-bit word sizes
than 32\-bit ones. For 32\-bit integers, \f(CW\*(C`IV_MAX\*(C'\fR equals \f(CW0x7FFFFFFF\fR,
for 64\-bit integers, \f(CW\*(C`IV_MAX\*(C'\fR equals \f(CW0x7FFFFFFFFFFFFFFF\fR.
.PP
\fIUse of comma-less variable list in formats.\fR
.IX Subsection "Use of comma-less variable list in formats."
.PP
It was allowed to use a list of variables in a format, without
separating them with commas. This usage has been deprecated
for a long time, and as of Perl 5.28, this throws a fatal error.
.PP
\fIUse of \f(CI\*(C`\eN{}\*(C'\fI\fR
.IX Subsection "Use of N{}"
.PP
Use of \f(CW\*(C`\eN{}\*(C'\fR with nothing between the braces was deprecated in
Perl 5.24, and throws a fatal error as of Perl 5.28.
.PP
Since such a construct is equivalent to using an empty string,
you are recommended to remove such \f(CW\*(C`\eN{}\*(C'\fR constructs.
.PP
\fIUsing the same symbol to open a filehandle and a dirhandle\fR
.IX Subsection "Using the same symbol to open a filehandle and a dirhandle"
.PP
It used to be legal to use \f(CW\*(C`open()\*(C'\fR to associate both a
filehandle and a dirhandle to the same symbol (glob or scalar).
This idiom is likely to be confusing, and it was deprecated in
Perl 5.10.
.PP
Using the same symbol to \f(CW\*(C`open()\*(C'\fR a filehandle and a dirhandle
throws a fatal error as of Perl 5.28.
.PP
You should be using two different symbols instead.
.PP
\fI${^ENCODING} is no longer supported.\fR
.IX Subsection "${^ENCODING} is no longer supported."
.PP
The special variable \f(CW\*(C`${^ENCODING}\*(C'\fR was used to implement
the \f(CW\*(C`encoding\*(C'\fR pragma. Setting this variable to anything other
than \f(CW\*(C`undef\*(C'\fR was deprecated in Perl 5.22. Full deprecation
of the variable happened in Perl 5.25.3.
.PP
Setting this variable to anything other than an undefined value
throws a fatal error as of Perl 5.28.
.PP
\fI\f(CI\*(C`B::OP::terse\*(C'\fI\fR
.IX Subsection "B::OP::terse"
.PP
This method, which just calls \f(CW\*(C`B::Concise::b_terse\*(C'\fR, has been
deprecated, and disappeared in Perl 5.28. Please use 
\&\f(CW\*(C`B::Concise\*(C'\fR instead.
.PP
\fIUse of inherited \s-1AUTOLOAD\s0 for non-method \f(CI%s::\fI%s() is no longer allowed\fR
.IX Subsection "Use of inherited AUTOLOAD for non-method %s::%s() is no longer allowed"
.PP
As an (ahem) accidental feature, \f(CW\*(C`AUTOLOAD\*(C'\fR subroutines were looked
up as methods (using the \f(CW@ISA\fR hierarchy) even when the subroutines
to be autoloaded were called as plain functions (e.g. \f(CW\*(C`Foo::bar()\*(C'\fR),
not as methods (e.g. \f(CW\*(C`Foo\->bar()\*(C'\fR or \f(CW\*(C`$obj\->bar()\*(C'\fR).
.PP
This bug was deprecated in Perl 5.004, has been rectified in Perl 5.28
by using method lookup only for methods' \f(CW\*(C`AUTOLOAD\*(C'\fRs.
.PP
The simple rule is:  Inheritance will not work when autoloading
non-methods.  The simple fix for old code is:  In any module that used
to depend on inheriting \f(CW\*(C`AUTOLOAD\*(C'\fR for non-methods from a base class
named \f(CW\*(C`BaseClass\*(C'\fR, execute \f(CW\*(C`*AUTOLOAD = \e&BaseClass::AUTOLOAD\*(C'\fR during
startup.
.PP
In code that currently says \f(CW\*(C`use AutoLoader; @ISA = qw(AutoLoader);\*(C'\fR
you should remove AutoLoader from \f(CW@ISA\fR and change \f(CW\*(C`use AutoLoader;\*(C'\fR to
\&\f(CW\*(C`use AutoLoader \*(AqAUTOLOAD\*(Aq;\*(C'\fR.
.PP
\fIUse of code points over 0xFF in string bitwise operators\fR
.IX Subsection "Use of code points over 0xFF in string bitwise operators"
.PP
The string bitwise operators, \f(CW\*(C`&\*(C'\fR, \f(CW\*(C`|\*(C'\fR, \f(CW\*(C`^\*(C'\fR, and \f(CW\*(C`~\*(C'\fR, treat
their operands as strings of bytes. As such, values above 0xFF 
are nonsensical. Using such code points with these operators
was deprecated in Perl 5.24, and is fatal as of Perl 5.28.
.PP
\fIIn \s-1XS\s0 code, use of \f(CI\*(C`to_utf8_case()\*(C'\fI\fR
.IX Subsection "In XS code, use of to_utf8_case()"
.PP
This function has been removed as of Perl 5.28; instead convert to call
the appropriate one of:
\&\f(CW\*(C`toFOLD_utf8_safe\*(C'\fR.
\&\f(CW\*(C`toLOWER_utf8_safe\*(C'\fR,
\&\f(CW\*(C`toTITLE_utf8_safe\*(C'\fR,
or
\&\f(CW\*(C`toUPPER_utf8_safe\*(C'\fR.
.SS "Perl 5.26"
.IX Subsection "Perl 5.26"
\fI\f(CI\*(C`\-\-libpods\*(C'\fI in \f(CI\*(C`Pod::Html\*(C'\fI\fR
.IX Subsection "--libpods in Pod::Html"
.PP
Since Perl 5.18, the option \f(CW\*(C`\-\-libpods\*(C'\fR has been deprecated, and
using this option did not do anything other than producing a warning.
.PP
The \f(CW\*(C`\-\-libpods\*(C'\fR option is no longer recognized as of Perl 5.26.
.PP
\fIThe utilities \f(CI\*(C`c2ph\*(C'\fI and \f(CI\*(C`pstruct\*(C'\fI\fR
.IX Subsection "The utilities c2ph and pstruct"
.PP
These old, perl3\-era utilities have been deprecated in favour of
\&\f(CW\*(C`h2xs\*(C'\fR for a long time. As of Perl 5.26, they have been removed.
.PP
\fITrapping \f(CI\*(C`$SIG {_\|_DIE_\|_}\*(C'\fI other than during program exit.\fR
.IX Subsection "Trapping $SIG {__DIE__} other than during program exit."
.PP
The \f(CW$SIG{_\|_DIE_\|_}\fR hook is called even inside an \f(CW\*(C`eval()\*(C'\fR. It was
never intended to happen this way, but an implementation glitch made
this possible. This used to be deprecated, as it allowed strange action
at a distance like rewriting a pending exception in \f(CW$@\fR. Plans to
rectify this have been scrapped, as users found that rewriting a
pending exception is actually a useful feature, and not a bug.
.PP
Perl never issued a deprecation warning for this; the deprecation
was by documentation policy only. But this deprecation has been 
lifted as of Perl 5.26.
.PP
\fIMalformed \s-1UTF\-8\s0 string in \*(L"%s\*(R"\fR
.IX Subsection "Malformed UTF-8 string in %s"
.PP
This message indicates a bug either in the Perl core or in \s-1XS\s0
code. Such code was trying to find out if a character, allegedly
stored internally encoded as \s-1UTF\-8,\s0 was of a given type, such as
being punctuation or a digit.  But the character was not encoded
in legal \s-1UTF\-8.\s0  The \f(CW%s\fR is replaced by a string that can be used
by knowledgeable people to determine what the type being checked
against was.
.PP
Passing malformed strings was deprecated in Perl 5.18, and
became fatal in Perl 5.26.
.SS "Perl 5.24"
.IX Subsection "Perl 5.24"
\fIUse of \f(CI*glob{FILEHANDLE}\fI\fR
.IX Subsection "Use of *glob{FILEHANDLE}"
.PP
The use of \f(CW*glob{FILEHANDLE}\fR was deprecated in Perl 5.8.
The intention was to use \f(CW*glob{IO}\fR instead, for which 
\&\f(CW*glob{FILEHANDLE}\fR is an alias.
.PP
However, this feature was undeprecated in Perl 5.24.
.PP
\fICalling POSIX::%s() is deprecated\fR
.IX Subsection "Calling POSIX::%s() is deprecated"
.PP
The following functions in the \f(CW\*(C`POSIX\*(C'\fR module are no longer available:
\&\f(CW\*(C`isalnum\*(C'\fR, \f(CW\*(C`isalpha\*(C'\fR, \f(CW\*(C`iscntrl\*(C'\fR, \f(CW\*(C`isdigit\*(C'\fR, \f(CW\*(C`isgraph\*(C'\fR, \f(CW\*(C`islower\*(C'\fR,  
\&\f(CW\*(C`isprint\*(C'\fR, \f(CW\*(C`ispunct\*(C'\fR, \f(CW\*(C`isspace\*(C'\fR, \f(CW\*(C`isupper\*(C'\fR, and \f(CW\*(C`isxdigit\*(C'\fR.  The 
functions are buggy and don't work on \s-1UTF\-8\s0 encoded strings.  See their
entries in \s-1POSIX\s0 for more information.
.PP
The functions were deprecated in Perl 5.20, and removed in Perl 5.24.
.SS "Perl 5.16"
.IX Subsection "Perl 5.16"
\fIUse of \f(CI%s\fI on a handle without * is deprecated\fR
.IX Subsection "Use of %s on a handle without * is deprecated"
.PP
It used to be possible to use \f(CW\*(C`tie\*(C'\fR, \f(CW\*(C`tied\*(C'\fR or \f(CW\*(C`untie\*(C'\fR on a scalar
while the scalar holds a typeglob. This caused its filehandle to be
tied. It left no way to tie the scalar itself when it held a typeglob,
and no way to untie a scalar that had had a typeglob assigned to it.
.PP
This was deprecated in Perl 5.14, and the bug was fixed in Perl 5.16.
.PP
So now \f(CW\*(C`tie $scalar\*(C'\fR will always tie the scalar, not the handle it holds.
To tie the handle, use \f(CW\*(C`tie *$scalar\*(C'\fR (with an explicit asterisk).  The same
applies to \f(CW\*(C`tied *$scalar\*(C'\fR and \f(CW\*(C`untie *$scalar\*(C'\fR.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
warnings, diagnostics.
