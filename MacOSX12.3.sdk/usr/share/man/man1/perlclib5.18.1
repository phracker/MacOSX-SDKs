.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PERLCLIB 1"
.TH PERLCLIB 1 "2014-09-30" "perl v5.18.4" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
perlclib \- Internal replacements for standard C library functions
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
One thing Perl porters should note is that \fIperl\fR doesn't tend to use that
much of the C standard library internally; you'll see very little use of, 
for example, the \fIctype.h\fR functions in there. This is because Perl
tends to reimplement or abstract standard library functions, so that we
know exactly how they're going to operate.
.PP
This is a reference card for people who are familiar with the C library
and who want to do things the Perl way; to tell them which functions
they ought to use instead of the more normal C functions.
.SS "Conventions"
.IX Subsection "Conventions"
In the following tables:
.ie n .IP """t""" 3
.el .IP "\f(CWt\fR" 3
.IX Item "t"
is a type.
.ie n .IP """p""" 3
.el .IP "\f(CWp\fR" 3
.IX Item "p"
is a pointer.
.ie n .IP """n""" 3
.el .IP "\f(CWn\fR" 3
.IX Item "n"
is a number.
.ie n .IP """s""" 3
.el .IP "\f(CWs\fR" 3
.IX Item "s"
is a string.
.PP
\&\f(CW\*(C`sv\*(C'\fR, \f(CW\*(C`av\*(C'\fR, \f(CW\*(C`hv\*(C'\fR, etc. represent variables of their respective types.
.SS "File Operations"
.IX Subsection "File Operations"
Instead of the \fIstdio.h\fR functions, you should use the Perl abstraction
layer. Instead of \f(CW\*(C`FILE*\*(C'\fR types, you need to be handling \f(CW\*(C`PerlIO*\*(C'\fR
types.  Don't forget that with the new PerlIO layered I/O abstraction 
\&\f(CW\*(C`FILE*\*(C'\fR types may not even be available. See also the \f(CW\*(C`perlapio\*(C'\fR
documentation for more information about the following functions:
.PP
.Vb 1
\&    Instead Of:                 Use:
\&
\&    stdin                       PerlIO_stdin()
\&    stdout                      PerlIO_stdout()
\&    stderr                      PerlIO_stderr()
\&
\&    fopen(fn, mode)             PerlIO_open(fn, mode)
\&    freopen(fn, mode, stream)   PerlIO_reopen(fn, mode, perlio) (Deprecated)
\&    fflush(stream)              PerlIO_flush(perlio)
\&    fclose(stream)              PerlIO_close(perlio)
.Ve
.SS "File Input and Output"
.IX Subsection "File Input and Output"
.Vb 1
\&    Instead Of:                 Use:
\&
\&    fprintf(stream, fmt, ...)   PerlIO_printf(perlio, fmt, ...)
\&
\&    [f]getc(stream)             PerlIO_getc(perlio)
\&    [f]putc(stream, n)          PerlIO_putc(perlio, n)
\&    ungetc(n, stream)           PerlIO_ungetc(perlio, n)
.Ve
.PP
Note that the PerlIO equivalents of \f(CW\*(C`fread\*(C'\fR and \f(CW\*(C`fwrite\*(C'\fR are slightly
different from their C library counterparts:
.PP
.Vb 2
\&    fread(p, size, n, stream)   PerlIO_read(perlio, buf, numbytes)
\&    fwrite(p, size, n, stream)  PerlIO_write(perlio, buf, numbytes)
\&
\&    fputs(s, stream)            PerlIO_puts(perlio, s)
.Ve
.PP
There is no equivalent to \f(CW\*(C`fgets\*(C'\fR; one should use \f(CW\*(C`sv_gets\*(C'\fR instead:
.PP
.Vb 1
\&    fgets(s, n, stream)         sv_gets(sv, perlio, append)
.Ve
.SS "File Positioning"
.IX Subsection "File Positioning"
.Vb 1
\&    Instead Of:                 Use:
\&
\&    feof(stream)                PerlIO_eof(perlio)
\&    fseek(stream, n, whence)    PerlIO_seek(perlio, n, whence)
\&    rewind(stream)              PerlIO_rewind(perlio)
\&
\&    fgetpos(stream, p)          PerlIO_getpos(perlio, sv)
\&    fsetpos(stream, p)          PerlIO_setpos(perlio, sv)
\&
\&    ferror(stream)              PerlIO_error(perlio)
\&    clearerr(stream)            PerlIO_clearerr(perlio)
.Ve
.SS "Memory Management and String Handling"
.IX Subsection "Memory Management and String Handling"
.Vb 1
\&    Instead Of:                         Use:
\&
\&    t* p = malloc(n)                    Newx(p, n, t)
\&    t* p = calloc(n, s)                 Newxz(p, n, t)
\&    p = realloc(p, n)                   Renew(p, n, t)
\&    memcpy(dst, src, n)                 Copy(src, dst, n, t)
\&    memmove(dst, src, n)                Move(src, dst, n, t)
\&    memcpy(dst, src, sizeof(t))         StructCopy(src, dst, t)
\&    memset(dst, 0, n * sizeof(t))       Zero(dst, n, t)
\&    memzero(dst, 0)                     Zero(dst, n, char)
\&    free(p)                             Safefree(p)
\&
\&    strdup(p)                   savepv(p)
\&    strndup(p, n)               savepvn(p, n) (Hey, strndup doesn\*(Aqt exist!)
\&
\&    strstr(big, little)         instr(big, little)
\&    strcmp(s1, s2)              strLE(s1, s2) / strEQ(s1, s2) / strGT(s1,s2)
\&    strncmp(s1, s2, n)          strnNE(s1, s2, n) / strnEQ(s1, s2, n)
.Ve
.PP
Notice the different order of arguments to \f(CW\*(C`Copy\*(C'\fR and \f(CW\*(C`Move\*(C'\fR than used
in \f(CW\*(C`memcpy\*(C'\fR and \f(CW\*(C`memmove\*(C'\fR.
.PP
Most of the time, though, you'll want to be dealing with SVs internally
instead of raw \f(CW\*(C`char *\*(C'\fR strings:
.PP
.Vb 6
\&    strlen(s)                   sv_len(sv)
\&    strcpy(dt, src)             sv_setpv(sv, s)
\&    strncpy(dt, src, n)         sv_setpvn(sv, s, n)
\&    strcat(dt, src)             sv_catpv(sv, s)
\&    strncat(dt, src)            sv_catpvn(sv, s)
\&    sprintf(s, fmt, ...)        sv_setpvf(sv, fmt, ...)
.Ve
.PP
Note also the existence of \f(CW\*(C`sv_catpvf\*(C'\fR and \f(CW\*(C`sv_vcatpvfn\*(C'\fR, combining
concatenation with formatting.
.PP
Sometimes instead of zeroing the allocated heap by using \fINewxz()\fR you
should consider \*(L"poisoning\*(R" the data.  This means writing a bit
pattern into it that should be illegal as pointers (and floating point
numbers), and also hopefully surprising enough as integers, so that
any code attempting to use the data without forethought will break
sooner rather than later.  Poisoning can be done using the \fIPoison()\fR
macros, which have similar arguments to \fIZero()\fR:
.PP
.Vb 4
\&    PoisonWith(dst, n, t, b)    scribble memory with byte b
\&    PoisonNew(dst, n, t)        equal to PoisonWith(dst, n, t, 0xAB)
\&    PoisonFree(dst, n, t)       equal to PoisonWith(dst, n, t, 0xEF)
\&    Poison(dst, n, t)           equal to PoisonFree(dst, n, t)
.Ve
.SS "Character Class Tests"
.IX Subsection "Character Class Tests"
There are two types of character class tests that Perl implements: one
type deals in \f(CW\*(C`char\*(C'\fRs and are thus \fBnot\fR Unicode aware (and hence
deprecated unless you \fBknow\fR you should use them) and the other type
deal in \f(CW\*(C`UV\*(C'\fRs and know about Unicode properties. In the following
table, \f(CW\*(C`c\*(C'\fR is a \f(CW\*(C`char\*(C'\fR, and \f(CW\*(C`u\*(C'\fR is a Unicode codepoint.
.PP
.Vb 1
\&    Instead Of:                 Use:            But better use:
\&
\&    isalnum(c)                  isALNUM(c)      isALNUM_uni(u)
\&    isalpha(c)                  isALPHA(c)      isALPHA_uni(u)
\&    iscntrl(c)                  isCNTRL(c)      isCNTRL_uni(u)
\&    isdigit(c)                  isDIGIT(c)      isDIGIT_uni(u)
\&    isgraph(c)                  isGRAPH(c)      isGRAPH_uni(u)
\&    islower(c)                  isLOWER(c)      isLOWER_uni(u)
\&    isprint(c)                  isPRINT(c)      isPRINT_uni(u)
\&    ispunct(c)                  isPUNCT(c)      isPUNCT_uni(u)
\&    isspace(c)                  isSPACE(c)      isSPACE_uni(u)
\&    isupper(c)                  isUPPER(c)      isUPPER_uni(u)
\&    isxdigit(c)                 isXDIGIT(c)     isXDIGIT_uni(u)
\&
\&    tolower(c)                  toLOWER(c)      toLOWER_uni(u)
\&    toupper(c)                  toUPPER(c)      toUPPER_uni(u)
.Ve
.SS "\fIstdlib.h\fP functions"
.IX Subsection "stdlib.h functions"
.Vb 1
\&    Instead Of:                 Use: 
\&
\&    atof(s)                     Atof(s)
\&    atol(s)                     Atol(s)
\&    strtod(s, &p)               Nothing.  Just don\*(Aqt use it.
\&    strtol(s, &p, n)            Strtol(s, &p, n)
\&    strtoul(s, &p, n)           Strtoul(s, &p, n)
.Ve
.PP
Notice also the \f(CW\*(C`grok_bin\*(C'\fR, \f(CW\*(C`grok_hex\*(C'\fR, and \f(CW\*(C`grok_oct\*(C'\fR functions in
\&\fInumeric.c\fR for converting strings representing numbers in the respective
bases into \f(CW\*(C`NV\*(C'\fRs.
.PP
In theory \f(CW\*(C`Strtol\*(C'\fR and \f(CW\*(C`Strtoul\*(C'\fR may not be defined if the machine perl is
built on doesn't actually have strtol and strtoul. But as those 2
functions are part of the 1989 \s-1ANSI C\s0 spec we suspect you'll find them
everywhere by now.
.PP
.Vb 3
\&    int rand()                  double Drand01()
\&    srand(n)                    { seedDrand01((Rand_seed_t)n); 
\&                                  PL_srand_called = TRUE; }
\&
\&    exit(n)                     my_exit(n)
\&    system(s)                   Don\*(Aqt. Look at pp_system or use my_popen
\&
\&    getenv(s)                   PerlEnv_getenv(s)
\&    setenv(s, val)              my_putenv(s, val)
.Ve
.SS "Miscellaneous functions"
.IX Subsection "Miscellaneous functions"
You should not even \fBwant\fR to use \fIsetjmp.h\fR functions, but if you
think you do, use the \f(CW\*(C`JMPENV\*(C'\fR stack in \fIscope.h\fR instead.
.PP
For \f(CW\*(C`signal\*(C'\fR/\f(CW\*(C`sigaction\*(C'\fR, use \f(CW\*(C`rsignal(signo, handler)\*(C'\fR.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
perlapi, perlapio, perlguts
