.\" Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "namespace::autoclean 3"
.TH namespace::autoclean 3 "2019-08-24" "perl v5.30.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
namespace::autoclean \- Keep imports out of your namespace
.SH "VERSION"
.IX Header "VERSION"
version 0.29
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 3
\&    package Foo;
\&    use namespace::autoclean;
\&    use Some::Package qw/imported_function/;
\&
\&    sub bar { imported_function(\*(Aqstuff\*(Aq) }
\&
\&    # later on:
\&    Foo\->bar;               # works
\&    Foo\->imported_function; # will fail. imported_function got cleaned after compilation
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
When you import a function into a Perl package, it will naturally also be
available as a method.
.PP
The \f(CW\*(C`namespace::autoclean\*(C'\fR pragma will remove all imported symbols at the end
of the current package's compile cycle. Functions called in the package itself
will still be bound by their name, but they won't show up as methods on your
class or instances.
.PP
This module is very similar to namespace::clean, except it
will clean all imported functions, no matter if you imported them before or
after you \f(CW\*(C`use\*(C'\fRd the pragma. It will also not touch anything that looks like a
method.
.PP
If you're writing an exporter and you want to clean up after yourself (and your
peers), you can use the \f(CW\*(C`\-cleanee\*(C'\fR switch to specify what package to clean:
.PP
.Vb 2
\&  package My::MooseX::namespace::autoclean;
\&  use strict;
\&
\&  use namespace::autoclean (); # no cleanup, just load
\&
\&  sub import {
\&      namespace::autoclean\->import(
\&        \-cleanee => scalar(caller),
\&      );
\&  }
.Ve
.SH "WHAT IS AND ISN'T CLEANED"
.IX Header "WHAT IS AND ISN'T CLEANED"
\&\f(CW\*(C`namespace::autoclean\*(C'\fR will leave behind anything that it deems a method.  For
Moose classes, this the based on the \f(CW\*(C`get_method_list\*(C'\fR method
on from the Class::MOP::Class.  For non-Moose classes, anything
defined within the package will be identified as a method.  This should match
Moose's definition of a method.  Additionally, the magic subs installed by
overload will not be cleaned.
.SH "PARAMETERS"
.IX Header "PARAMETERS"
.SS "\-also => [ \s-1ITEM\s0 | \s-1REGEX\s0 | \s-1SUB, ..\s0 ]"
.IX Subsection "-also => [ ITEM | REGEX | SUB, .. ]"
.SS "\-also => \s-1ITEM\s0"
.IX Subsection "-also => ITEM"
.SS "\-also => \s-1REGEX\s0"
.IX Subsection "-also => REGEX"
.SS "\-also => \s-1SUB\s0"
.IX Subsection "-also => SUB"
Sometimes you don't want to clean imports only, but also helper functions
you're using in your methods. The \f(CW\*(C`\-also\*(C'\fR switch can be used to declare a list
of functions that should be removed additional to any imports:
.PP
.Vb 1
\&    use namespace::autoclean \-also => [\*(Aqsome_function\*(Aq, \*(Aqanother_function\*(Aq];
.Ve
.PP
If only one function needs to be additionally cleaned the \f(CW\*(C`\-also\*(C'\fR switch also
accepts a plain string:
.PP
.Vb 1
\&    use namespace::autoclean \-also => \*(Aqsome_function\*(Aq;
.Ve
.PP
In some situations, you may wish for a more \fIpowerful\fR cleaning solution.
.PP
The \f(CW\*(C`\-also\*(C'\fR switch can take a Regex or a CodeRef to match against local
function names to clean.
.PP
.Vb 1
\&    use namespace::autoclean \-also => qr/^_/
\&
\&    use namespace::autoclean \-also => sub { $_ =~ m{^_} };
\&
\&    use namespace::autoclean \-also => [qr/^_/ , qr/^hidden_/ ];
\&
\&    use namespace::autoclean \-also => [sub { $_ =~ m/^_/ or $_ =~ m/^hidden/ }, sub { uc($_) == $_ } ];
.Ve
.SS "\-except => [ \s-1ITEM\s0 | \s-1REGEX\s0 | \s-1SUB, ..\s0 ]"
.IX Subsection "-except => [ ITEM | REGEX | SUB, .. ]"
.SS "\-except => \s-1ITEM\s0"
.IX Subsection "-except => ITEM"
.SS "\-except => \s-1REGEX\s0"
.IX Subsection "-except => REGEX"
.SS "\-except => \s-1SUB\s0"
.IX Subsection "-except => SUB"
This takes exactly the same options as \f(CW\*(C`\-also\*(C'\fR except that anything this
matches will \fInot\fR be cleaned.
.SH "CAVEATS"
.IX Header "CAVEATS"
When used with Moo classes, the heuristic used to check for methods won't
work correctly for methods from roles consumed at compile time.
.PP
.Vb 3
\&  package My::Class;
\&  use Moo;
\&  use namespace::autoclean;
\&
\&  # Bad, any consumed methods will be cleaned
\&  BEGIN { with \*(AqSome::Role\*(Aq }
\&
\&  # Good, methods from role will be maintained
\&  with \*(AqSome::Role\*(Aq;
.Ve
.PP
Additionally, method detection may not work properly in Mouse classes in
perls earlier than 5.10.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.IP "\(bu" 4
namespace::clean
.IP "\(bu" 4
B::Hooks::EndOfScope
.IP "\(bu" 4
namespace::sweep
.IP "\(bu" 4
Sub::Exporter::ForMethods
.IP "\(bu" 4
Sub::Name
.IP "\(bu" 4
Sub::Install
.IP "\(bu" 4
Test::CleanNamespaces
.IP "\(bu" 4
Dist::Zilla::Plugin::Test::CleanNamespaces
.SH "SUPPORT"
.IX Header "SUPPORT"
Bugs may be submitted through the \s-1RT\s0 bug tracker <https://rt.cpan.org/Public/Dist/Display.html?Name=namespace-autoclean>
(or bug\-namespace\-autoclean@rt.cpan.org <mailto:bug-namespace-autoclean@rt.cpan.org>).
.PP
There is also a mailing list available for users of this distribution, at
<http://lists.perl.org/list/moose.html>.
.PP
There is also an irc channel available for users of this distribution, at
\&\f(CW\*(C`#moose\*(C'\fR on \f(CW\*(C`irc.perl.org\*(C'\fR <irc://irc.perl.org/#moose>.
.SH "AUTHOR"
.IX Header "AUTHOR"
Florian Ragwitz <rafl@debian.org>
.SH "CONTRIBUTORS"
.IX Header "CONTRIBUTORS"
.IP "\(bu" 4
Karen Etheridge <ether@cpan.org>
.IP "\(bu" 4
Graham Knop <haarg@haarg.org>
.IP "\(bu" 4
Dave Rolsky <autarch@urth.org>
.IP "\(bu" 4
Kent Fredric <kentfredric@gmail.com>
.IP "\(bu" 4
Tomas Doran <bobtfish@bobtfish.net>
.IP "\(bu" 4
Shawn M Moore <cpan@sartak.org>
.IP "\(bu" 4
Felix Ostmann <sadrak@cpan.org>
.IP "\(bu" 4
Chris Prather <chris@prather.org>
.IP "\(bu" 4
Andrew Rodland <arodland@cpan.org>
.SH "COPYRIGHT AND LICENCE"
.IX Header "COPYRIGHT AND LICENCE"
This software is copyright (c) 2009 by Florian Ragwitz.
.PP
This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.
