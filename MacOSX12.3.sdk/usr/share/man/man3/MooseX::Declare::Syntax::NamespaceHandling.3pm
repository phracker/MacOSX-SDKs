.\" Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "MooseX::Declare::Syntax::NamespaceHandling 3pm"
.TH MooseX::Declare::Syntax::NamespaceHandling 3pm "2015-08-16" "perl v5.30.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
MooseX::Declare::Syntax::NamespaceHandling \- Handle namespaced blocks
.SH "VERSION"
.IX Header "VERSION"
version 0.43
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Allows the implementation of namespaced blocks like the
role and
class keyword handlers.
.PP
Namespaces are automatically nested. Meaning that, for example, a \f(CW\*(C`class Bar\*(C'\fR
declaration inside another \f(CW\*(C`class Foo\*(C'\fR block gives the inner one actually the
name \f(CW\*(C`Foo::Bar\*(C'\fR.
.SH "METHODS"
.IX Header "METHODS"
.SS "parse"
.IX Subsection "parse"
.Vb 1
\&  Any Object\->parse (Object $context)
.Ve
.PP
This is the main handling routine for namespaces. It will remove the namespace
name and its options. If the handler was invoked without a name, options or
a following block, it is assumed that this is an instance of an autoquoted
bareword like \f(CW\*(C`class => "Foo"\*(C'\fR.
.PP
The return value of the \f(CW\*(C`parse\*(C'\fR method is also the value that is returned
to the user of the keyword.
.SH "CONSUMES"
.IX Header "CONSUMES"
.IP "\(bu" 4
MooseX::Declare::Syntax::KeywordHandling
.IP "\(bu" 4
MooseX::Declare::Syntax::InnerSyntaxHandling
.SH "REQUIRED METHODS"
.IX Header "REQUIRED METHODS"
.SS "handle_missing_block"
.IX Subsection "handle_missing_block"
.Vb 1
\&  Object\->handle_missing_block (Object $context, Str $body, %args)
.Ve
.PP
This must be implemented to decide what to do in case the statement is
terminated rather than followed by a block. It will receive the context
object, the produced code that needs to be injected, and all the arguments
that were passed to the call to \*(L"inject_code_parts\*(R" in MooseX::Declare::Context.
.PP
The return value will be ignored.
.SH "EXTENDABLE STUB METHODS"
.IX Header "EXTENDABLE STUB METHODS"
.SS "add_namespace_customizations"
.IX Subsection "add_namespace_customizations"
.SS "add_optional_customizations"
.IX Subsection "add_optional_customizations"
.Vb 2
\&  Object\->add_namespace_customizations (Object $context, Str $package, HashRef $options)
\&  Object\->add_optional_customizations  (Object $context, Str $package, HashRef $options)
.Ve
.PP
These will be called (in this order) by the \*(L"parse\*(R" method. They allow specific hooks
to attach before/after/around the customizations for the namespace and the provided
options that are not attached to the namespace directly.
.PP
While this distinction might seem superficial, we advise library developers facilitating
this role to follow the precedent. This ensures that when another component needs to
tie between the namespace and any additional customizations everything will run in the
correct order. An example of this separation would be
.PP
.Vb 1
\&  class Foo is mutable ...
.Ve
.PP
being an option of the namespace generation, while
.PP
.Vb 1
\&  class Foo with Bar ...
.Ve
.PP
is an additional optional customization.
.SS "handle_post_parsing"
.IX Subsection "handle_post_parsing"
.Vb 1
\&  Object\->handle_post_parsing (Object $context, Str $package, Str | Object $name)
.Ve
.PP
Allows for additional modifications to the namespace after everything else has been
done. It will receive the context, the fully qualified package name, and either a
string with the name that was specified (might not be fully qualified, since
namespaces can be nested) or the anonymous metaclass instance if no name was
specified.
.PP
The return value of this method will be the value returned to the user of the
keyword. If you always return the \f(CW$package\fR argument like this:
.PP
.Vb 4
\&  sub handle_post_parsing {
\&      my ($self, $context, $package, $name) = @_;
\&      return $package;
\&  }
.Ve
.PP
and set this up in a \f(CW\*(C`foo\*(C'\fR keyword handler, you can use it like this:
.PP
.Vb 1
\&  foo Cthulhu {
\&
\&      my $fhtagn = foo Fhtagn { }
\&      my $anon   = foo { };
\&
\&      say $fhtagn;  # Cthulhu::Fhtagn
\&      say $anon;    # some autogenerated package name
\&  }
.Ve
.SS "make_anon_metaclass"
.IX Subsection "make_anon_metaclass"
.Vb 1
\&  Class::MOP::Class Object\->make_anon_metaclass ()
.Ve
.PP
This method should be overridden if you want to provide anonymous namespaces.
.PP
It does not receive any arguments for customization of the metaclass, because
the configuration and customization will be done by MooseX::Declare in the
package of the generated class in the same way as in those that have specified
names. This way ensures that anonymous and named namespaces are always handled
equally.
.PP
If you do not extend this method (it will return nothing by default), an error
will be thrown when a user attempts to declare an anonymous namespace.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.IP "\(bu" 4
MooseX::Declare
.IP "\(bu" 4
MooseX::Declare::Syntax::MooseSetup
.SH "AUTHOR"
.IX Header "AUTHOR"
Florian Ragwitz <rafl@debian.org>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is copyright (c) 2008 by Florian Ragwitz.
.PP
This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.
