.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Encode::Unicode 3pm"
.TH Encode::Unicode 3pm "2014-09-30" "perl v5.18.4" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Encode::Unicode \-\- Various Unicode Transformation Formats
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 3
\&    use Encode qw/encode decode/;
\&    $ucs2 = encode("UCS\-2BE", $utf8);
\&    $utf8 = decode("UCS\-2BE", $ucs2);
.Ve
.SH "ABSTRACT"
.IX Header "ABSTRACT"
This module implements all Character Encoding Schemes of Unicode that
are officially documented by Unicode Consortium (except, of course,
for \s-1UTF\-8,\s0 which is a native format in perl).
.IP "<http://www.unicode.org/glossary/> says:" 4
.IX Item "<http://www.unicode.org/glossary/> says:"
\&\fICharacter Encoding Scheme\fR A character encoding form plus byte
serialization. There are Seven character encoding schemes in Unicode:
\&\s-1UTF\-8, UTF\-16, UTF\-16BE, UTF\-16LE, UTF\-32 \s0(\s-1UCS\-4\s0), \s-1UTF\-32BE \s0(\s-1UCS\-4BE\s0) and
\&\s-1UTF\-32LE \s0(\s-1UCS\-4LE\s0), and \s-1UTF\-7.\s0
.Sp
Since \s-1UTF\-7\s0 is a 7\-bit (re)encoded version of \s-1UTF\-16BE,\s0 It is not part of
Unicode's Character Encoding Scheme.  It is separately implemented in
Encode::Unicode::UTF7.  For details see Encode::Unicode::UTF7.
.IP "Quick Reference" 4
.IX Item "Quick Reference"
.Vb 10
\&                Decodes from ord(N)           Encodes chr(N) to...
\&       octet/char BOM S.P d800\-dfff  ord > 0xffff     \ex{1abcd} ==
\&  \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&  UCS\-2BE       2   N   N  is bogus                  Not Available
\&  UCS\-2LE       2   N   N     bogus                  Not Available
\&  UTF\-16      2/4   Y   Y  is   S.P           S.P            BE/LE
\&  UTF\-16BE    2/4   N   Y       S.P           S.P    0xd82a,0xdfcd
\&  UTF\-16LE    2/4   N   Y       S.P           S.P    0x2ad8,0xcddf
\&  UTF\-32        4   Y   \-  is bogus         As is            BE/LE
\&  UTF\-32BE      4   N   \-     bogus         As is       0x0001abcd
\&  UTF\-32LE      4   N   \-     bogus         As is       0xcdab0100
\&  UTF\-8       1\-4   \-   \-     bogus   >= 4 octets   \exf0\ex9a\eaf\e8d
\&  \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
.Ve
.SH "Size, Endianness, and BOM"
.IX Header "Size, Endianness, and BOM"
You can categorize these \s-1CES\s0 by 3 criteria:  size of each character,
endianness, and Byte Order Mark.
.SS "by size"
.IX Subsection "by size"
\&\s-1UCS\-2\s0 is a fixed-length encoding with each character taking 16 bits.
It \fBdoes not\fR support \fIsurrogate pairs\fR.  When a surrogate pair
is encountered during \fIdecode()\fR, its place is filled with \ex{\s-1FFFD\s0}
if \fI\s-1CHECK\s0\fR is 0, or the routine croaks if \fI\s-1CHECK\s0\fR is 1.  When a
character whose ord value is larger than 0xFFFF is encountered,
its place is filled with \ex{\s-1FFFD\s0} if \fI\s-1CHECK\s0\fR is 0, or the routine
croaks if \fI\s-1CHECK\s0\fR is 1.
.PP
\&\s-1UTF\-16\s0 is almost the same as \s-1UCS\-2\s0 but it supports \fIsurrogate pairs\fR.
When it encounters a high surrogate (0xD800\-0xDBFF), it fetches the
following low surrogate (0xDC00\-0xDFFF) and \f(CW\*(C`desurrogate\*(C'\fRs them to
form a character.  Bogus surrogates result in death.  When \ex{10000}
or above is encountered during \fIencode()\fR, it \f(CW\*(C`ensurrogate\*(C'\fRs them and
pushes the surrogate pair to the output stream.
.PP
\&\s-1UTF\-32 \s0(\s-1UCS\-4\s0) is a fixed-length encoding with each character taking 32 bits.
Since it is 32\-bit, there is no need for \fIsurrogate pairs\fR.
.SS "by endianness"
.IX Subsection "by endianness"
The first (and now failed) goal of Unicode was to map all character
repertoires into a fixed-length integer so that programmers are happy.
Since each character is either a \fIshort\fR or \fIlong\fR in C, you have to
pay attention to the endianness of each platform when you pass data
to one another.
.PP
Anything marked as \s-1BE\s0 is Big Endian (or network byte order) and \s-1LE\s0 is
Little Endian (aka \s-1VAX\s0 byte order).  For anything not marked either
\&\s-1BE\s0 or \s-1LE,\s0 a character called Byte Order Mark (\s-1BOM\s0) indicating the
endianness is prepended to the string.
.PP
\&\s-1CAVEAT:\s0 Though \s-1BOM\s0 in utf8 (\exEF\exBB\exBF) is valid, it is meaningless
and as of this writing Encode suite just leave it as is (\ex{FeFF}).
.IP "\s-1BOM\s0 as integer when fetched in network byte order" 4
.IX Item "BOM as integer when fetched in network byte order"
.Vb 5
\&              16         32 bits/char
\&  \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&  BE      0xFeFF 0x0000FeFF
\&  LE      0xFFFe 0xFFFe0000
\&  \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
.Ve
.PP
This modules handles the \s-1BOM\s0 as follows.
.IP "\(bu" 4
When \s-1BE\s0 or \s-1LE\s0 is explicitly stated as the name of encoding, \s-1BOM\s0 is
simply treated as a normal character (\s-1ZERO WIDTH\s0 NO-BREAK \s-1SPACE\s0).
.IP "\(bu" 4
When \s-1BE\s0 or \s-1LE\s0 is omitted during \fIdecode()\fR, it checks if \s-1BOM\s0 is at the
beginning of the string; if one is found, the endianness is set to
what the \s-1BOM\s0 says.  If no \s-1BOM\s0 is found, the routine dies.
.IP "\(bu" 4
When \s-1BE\s0 or \s-1LE\s0 is omitted during \fIencode()\fR, it returns a BE-encoded
string with \s-1BOM\s0 prepended.  So when you want to encode a whole text
file, make sure you \fIencode()\fR the whole text at once, not line by line
or each line, not file, will have a \s-1BOM\s0 prepended.
.IP "\(bu" 4
\&\f(CW\*(C`UCS\-2\*(C'\fR is an exception.  Unlike others, this is an alias of \s-1UCS\-2BE.
UCS\-2\s0 is already registered by \s-1IANA\s0 and others that way.
.SH "Surrogate Pairs"
.IX Header "Surrogate Pairs"
To say the least, surrogate pairs were the biggest mistake of the
Unicode Consortium.  But according to the late Douglas Adams in \fIThe
Hitchhiker's Guide to the Galaxy\fR Trilogy, \f(CW\*(C`In the beginning the
Universe was created. This has made a lot of people very angry and
been widely regarded as a bad move\*(C'\fR.  Their mistake was not of this
magnitude so let's forgive them.
.PP
(I don't dare make any comparison with Unicode Consortium and the
Vogons here ;)  Or, comparing Encode to Babel Fish is completely
appropriate \*(-- if you can only stick this into your ear :)
.PP
Surrogate pairs were born when the Unicode Consortium finally
admitted that 16 bits were not big enough to hold all the world's
character repertoires.  But they already made \s-1UCS\-2\s0 16\-bit.  What
do we do?
.PP
Back then, the range 0xD800\-0xDFFF was not allocated.  Let's split
that range in half and use the first half to represent the \f(CW\*(C`upper
half of a character\*(C'\fR and the second half to represent the \f(CW\*(C`lower
half of a character\*(C'\fR.  That way, you can represent 1024 * 1024 =
1048576 more characters.  Now we can store character ranges up to
\&\ex{10ffff} even with 16\-bit encodings.  This pair of half-character is
now called a \fIsurrogate pair\fR and \s-1UTF\-16\s0 is the name of the encoding
that embraces them.
.PP
Here is a formula to ensurrogate a Unicode character \ex{10000} and
above;
.PP
.Vb 2
\&  $hi = ($uni \- 0x10000) / 0x400 + 0xD800;
\&  $lo = ($uni \- 0x10000) % 0x400 + 0xDC00;
.Ve
.PP
And to desurrogate;
.PP
.Vb 1
\& $uni = 0x10000 + ($hi \- 0xD800) * 0x400 + ($lo \- 0xDC00);
.Ve
.PP
Note this move has made \ex{D800}\-\ex{\s-1DFFF\s0} into a forbidden zone but
perl does not prohibit the use of characters within this range.  To perl,
every one of \ex{0000_0000} up to \ex{ffff_ffff} (*) is \fIa character\fR.
.PP
.Vb 2
\&  (*) or \ex{ffff_ffff_ffff_ffff} if your perl is compiled with 64\-bit
\&  integer support!
.Ve
.SH "Error Checking"
.IX Header "Error Checking"
Unlike most encodings which accept various ways to handle errors,
Unicode encodings simply croaks.
.PP
.Vb 6
\&  % perl \-MEncode \-e\*(Aq$_ = "\exfe\exff\exd8\exd9\exda\exdb\e0\en"\*(Aq \e
\&         \-e\*(AqEncode::from_to($_, "utf16","shift_jis", 0); print\*(Aq
\&  UTF\-16:Malformed LO surrogate d8d9 at /path/to/Encode.pm line 184.
\&  % perl \-MEncode \-e\*(Aq$a = "BOM missing"\*(Aq \e
\&         \-e\*(Aq Encode::from_to($a, "utf16", "shift_jis", 0); print\*(Aq
\&  UTF\-16:Unrecognised BOM 424f at /path/to/Encode.pm line 184.
.Ve
.PP
Unlike other encodings where mappings are not one-to-one against
Unicode, UTFs are supposed to map 100% against one another.  So Encode
is more strict on UTFs.
.PP
Consider that \*(L"division by zero\*(R" of Encode :)
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Encode, Encode::Unicode::UTF7, <http://www.unicode.org/glossary/>,
<http://www.unicode.org/unicode/faq/utf_bom.html>,
.PP
\&\s-1RFC 2781 \s0<http://www.ietf.org/rfc/rfc2781.txt>,
.PP
The whole Unicode standard <http://www.unicode.org/unicode/uni2book/u2.html>
.PP
Ch. 15, pp. 403 of \f(CW\*(C`Programming Perl (3rd Edition)\*(C'\fR
by Larry Wall, Tom Christiansen, Jon Orwant;
O'Reilly & Associates; \s-1ISBN 0\-596\-00027\-8\s0
