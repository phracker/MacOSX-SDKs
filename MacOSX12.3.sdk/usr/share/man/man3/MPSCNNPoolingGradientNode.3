.TH "MPSCNNPoolingGradientNode" 3 "Mon Jul 9 2018" "Version MetalPerformanceShaders-119.3" "MetalPerformanceShaders.framework" \" -*- nroff -*-
.ad l
.nh
.SH NAME
MPSCNNPoolingGradientNode
.SH SYNOPSIS
.br
.PP
.PP
\fC#import <MPSNNGraphNodes\&.h>\fP
.PP
Inherits \fBMPSNNGradientFilterNode\fP\&.
.PP
Inherited by \fBMPSCNNDilatedPoolingMaxGradientNode\fP, \fBMPSCNNPoolingAverageGradientNode\fP, \fBMPSCNNPoolingL2NormGradientNode\fP, and \fBMPSCNNPoolingMaxGradientNode\fP\&.
.SS "Instance Methods"

.in +1c
.ti -1c
.RI "(nonnull instancetype) \- \fBinitWithSourceGradient:sourceImage:gradientState:kernelWidth:kernelHeight:strideInPixelsX:strideInPixelsY:paddingPolicy:\fP"
.br
.in -1c
.SS "Class Methods"

.in +1c
.ti -1c
.RI "(nonnull instancetype) + \fBnodeWithSourceGradient:sourceImage:gradientState:kernelWidth:kernelHeight:strideInPixelsX:strideInPixelsY:paddingPolicy:\fP"
.br
.in -1c
.SS "Properties"

.in +1c
.ti -1c
.RI "NSUInteger \fBkernelWidth\fP"
.br
.ti -1c
.RI "NSUInteger \fBkernelHeight\fP"
.br
.ti -1c
.RI "NSUInteger \fBstrideInPixelsX\fP"
.br
.ti -1c
.RI "NSUInteger \fBstrideInPixelsY\fP"
.br
.in -1c
.SH "Method Documentation"
.PP 
.SS "\- (nonnull instancetype) initWithSourceGradient: (\fBMPSNNImageNode\fP *__nonnull) sourceGradient(\fBMPSNNImageNode\fP *__nonnull) sourceImage(\fBMPSNNGradientStateNode\fP *__nonnull) gradientState(NSUInteger) kernelWidth(NSUInteger) kernelHeight(NSUInteger) strideInPixelsX(NSUInteger) strideInPixelsY(nullable id< \fBMPSNNPadding\fP >) paddingPolicy"
make a pooling gradient node  It would be much easier to use [inferencePoolingNode gradientNodeForSourceGradient:] instead\&. 
.PP
\fBParameters:\fP
.RS 4
\fIsourceGradient\fP The gradient from the downstream gradient filter\&. 
.br
\fIsourceImage\fP The input image to the inference pooling filter 
.br
\fIgradientState\fP The gradient state produced by the inference poolin filter 
.br
\fIkernelWidth\fP The kernel width of the inference filter 
.br
\fIkernelHeight\fP The kernel height of the inference filter 
.br
\fIstrideInPixelsX\fP The X stride from the inference filter 
.br
\fIstrideInPixelsY\fP The Y stride from the inference filter 
.RE
.PP

.SS "+ (nonnull instancetype) nodeWithSourceGradient: (\fBMPSNNImageNode\fP *__nonnull) sourceGradient(\fBMPSNNImageNode\fP *__nonnull) sourceImage(\fBMPSNNGradientStateNode\fP *__nonnull) gradientState(NSUInteger) kernelWidth(NSUInteger) kernelHeight(NSUInteger) strideInPixelsX(NSUInteger) strideInPixelsY(nullable id< \fBMPSNNPadding\fP >) paddingPolicy"
make a pooling gradient node  It would be much easier to use [inferencePoolingNode gradientNodeForSourceGradient:] instead\&. 
.PP
\fBParameters:\fP
.RS 4
\fIsourceGradient\fP The gradient from the downstream gradient filter\&. 
.br
\fIsourceImage\fP The input image to the inference pooling filter 
.br
\fIgradientState\fP The gradient state produced by the inference poolin filter 
.br
\fIkernelWidth\fP The kernel width of the inference filter 
.br
\fIkernelHeight\fP The kernel height of the inference filter 
.br
\fIstrideInPixelsX\fP The X stride from the inference filter 
.br
\fIstrideInPixelsY\fP The Y stride from the inference filter 
.RE
.PP

.SH "Property Documentation"
.PP 
.SS "\- (NSUInteger) kernelHeight\fC [read]\fP, \fC [nonatomic]\fP, \fC [assign]\fP"

.SS "\- (NSUInteger) kernelWidth\fC [read]\fP, \fC [nonatomic]\fP, \fC [assign]\fP"

.SS "\- (NSUInteger) strideInPixelsX\fC [read]\fP, \fC [nonatomic]\fP, \fC [assign]\fP"

.SS "\- (NSUInteger) strideInPixelsY\fC [read]\fP, \fC [nonatomic]\fP, \fC [assign]\fP"


.SH "Author"
.PP 
Generated automatically by Doxygen for MetalPerformanceShaders\&.framework from the source code\&.
