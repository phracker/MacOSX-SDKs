.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Thread::Queue 3pm"
.TH Thread::Queue 3pm "2014-09-30" "perl v5.18.4" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Thread::Queue \- Thread\-safe queues
.SH "VERSION"
.IX Header "VERSION"
This document describes Thread::Queue version 3.02
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&    use strict;
\&    use warnings;
\&
\&    use threads;
\&    use Thread::Queue;
\&
\&    my $q = Thread::Queue\->new();    # A new empty queue
\&
\&    # Worker thread
\&    my $thr = threads\->create(
\&        sub {
\&            # Thread will loop until no more work
\&            while (defined(my $item = $q\->dequeue())) {
\&                # Do work on $item
\&                ...
\&            }
\&        }
\&    );
\&
\&    # Send work to the thread
\&    $q\->enqueue($item1, ...);
\&    # Signal that there is no more work to be sent
\&    $q\->end();
\&    # Join up with the thread when it finishes
\&    $thr\->join();
\&
\&    ...
\&
\&    # Count of items in the queue
\&    my $left = $q\->pending();
\&
\&    # Non\-blocking dequeue
\&    if (defined(my $item = $q\->dequeue_nb())) {
\&        # Work on $item
\&    }
\&
\&    # Blocking dequeue with 5\-second timeout
\&    if (defined(my $item = $q\->dequeue_timed(5))) {
\&        # Work on $item
\&    }
\&
\&    # Get the second item in the queue without dequeuing anything
\&    my $item = $q\->peek(1);
\&
\&    # Insert two items into the queue just behind the head
\&    $q\->insert(1, $item1, $item2);
\&
\&    # Extract the last two items on the queue
\&    my ($item1, $item2) = $q\->extract(\-2, 2);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module provides thread-safe \s-1FIFO\s0 queues that can be accessed safely by
any number of threads.
.PP
Any data types supported by threads::shared can be passed via queues:
.IP "Ordinary scalars" 4
.IX Item "Ordinary scalars"
.PD 0
.IP "Array refs" 4
.IX Item "Array refs"
.IP "Hash refs" 4
.IX Item "Hash refs"
.IP "Scalar refs" 4
.IX Item "Scalar refs"
.IP "Objects based on the above" 4
.IX Item "Objects based on the above"
.PD
.PP
Ordinary scalars are added to queues as they are.
.PP
If not already thread-shared, the other complex data types will be cloned
(recursively, if needed, and including any \f(CW\*(C`bless\*(C'\fRings and read-only
settings) into thread-shared structures before being placed onto a queue.
.PP
For example, the following would cause Thread::Queue to create a empty,
shared array reference via \f(CW\*(C`&shared([])\*(C'\fR, copy the elements 'foo', 'bar'
and 'baz' from \f(CW@ary\fR into it, and then place that shared reference onto
the queue:
.PP
.Vb 2
\&    my @ary = qw/foo bar baz/;
\&    $q\->enqueue(\e@ary);
.Ve
.PP
However, for the following, the items are already shared, so their references
are added directly to the queue, and no cloning takes place:
.PP
.Vb 2
\&    my @ary :shared = qw/foo bar baz/;
\&    $q\->enqueue(\e@ary);
\&
\&    my $obj = &shared({});
\&    $$obj{\*(Aqfoo\*(Aq} = \*(Aqbar\*(Aq;
\&    $$obj{\*(Aqqux\*(Aq} = 99;
\&    bless($obj, \*(AqMy::Class\*(Aq);
\&    $q\->enqueue($obj);
.Ve
.PP
See \*(L"\s-1LIMITATIONS\*(R"\s0 for caveats related to passing objects via queues.
.SH "QUEUE CREATION"
.IX Header "QUEUE CREATION"
.IP "\->\fInew()\fR" 4
.IX Item "->new()"
Creates a new empty queue.
.IP "\->new(\s-1LIST\s0)" 4
.IX Item "->new(LIST)"
Creates a new queue pre-populated with the provided list of items.
.SH "BASIC METHODS"
.IX Header "BASIC METHODS"
The following methods deal with queues on a \s-1FIFO\s0 basis.
.IP "\->enqueue(\s-1LIST\s0)" 4
.IX Item "->enqueue(LIST)"
Adds a list of items onto the end of the queue.
.IP "\->\fIdequeue()\fR" 4
.IX Item "->dequeue()"
.PD 0
.IP "\->dequeue(\s-1COUNT\s0)" 4
.IX Item "->dequeue(COUNT)"
.PD
Removes the requested number of items (default is 1) from the head of the
queue, and returns them.  If the queue contains fewer than the requested
number of items, then the thread will be blocked until the requisite number
of items are available (i.e., until other threads <enqueue> more items).
.IP "\->\fIdequeue_nb()\fR" 4
.IX Item "->dequeue_nb()"
.PD 0
.IP "\->dequeue_nb(\s-1COUNT\s0)" 4
.IX Item "->dequeue_nb(COUNT)"
.PD
Removes the requested number of items (default is 1) from the head of the
queue, and returns them.  If the queue contains fewer than the requested
number of items, then it immediately (i.e., non-blocking) returns whatever
items there are on the queue.  If the queue is empty, then \f(CW\*(C`undef\*(C'\fR is
returned.
.IP "\->dequeue_timed(\s-1TIMEOUT\s0)" 4
.IX Item "->dequeue_timed(TIMEOUT)"
.PD 0
.IP "\->dequeue_timed(\s-1TIMEOUT, COUNT\s0)" 4
.IX Item "->dequeue_timed(TIMEOUT, COUNT)"
.PD
Removes the requested number of items (default is 1) from the head of the
queue, and returns them.  If the queue contains fewer than the requested
number of items, then the thread will be blocked until the requisite number of
items are available, or until the timeout is reached.  If the timeout is
reached, it returns whatever items there are on the queue, or \f(CW\*(C`undef\*(C'\fR if the
queue is empty.
.Sp
The timeout may be a number of seconds relative to the current time (e.g., 5
seconds from when the call is made), or may be an absolute timeout in \fIepoch\fR
seconds the same as would be used with
\&\fIcond_timedwait()\fR.
Fractional seconds (e.g., 2.5 seconds) are also supported (to the extent of
the underlying implementation).
.Sp
If \f(CW\*(C`TIMEOUT\*(C'\fR is missing, c<undef>, or less than or equal to 0, then this call
behaves the same as \f(CW\*(C`dequeue_nb\*(C'\fR.
.IP "\->\fIpending()\fR" 4
.IX Item "->pending()"
Returns the number of items still in the queue.  Returns \f(CW\*(C`undef\*(C'\fR if the queue
has been ended (see below), and there are no more items in the queue.
.IP "\->\fIend()\fR" 4
.IX Item "->end()"
Declares that no more items will be added to the queue.
.Sp
All threads blocking on \f(CW\*(C`dequeue()\*(C'\fR calls will be unblocked with any
remaining items in the queue and/or \f(CW\*(C`undef\*(C'\fR being returned.  Any subsequent
calls to \f(CW\*(C`dequeue()\*(C'\fR will behave like \f(CW\*(C`dequeue_nb()\*(C'\fR.
.Sp
Once ended, no more items may be placed in the queue.
.SH "ADVANCED METHODS"
.IX Header "ADVANCED METHODS"
The following methods can be used to manipulate items anywhere in a queue.
.PP
To prevent the contents of a queue from being modified by another thread
while it is being examined and/or changed, lock the queue inside a local block:
.PP
.Vb 8
\&    {
\&        lock($q);   # Keep other threads from changing the queue\*(Aqs contents
\&        my $item = $q\->peek();
\&        if ($item ...) {
\&            ...
\&        }
\&    }
\&    # Queue is now unlocked
.Ve
.IP "\->\fIpeek()\fR" 4
.IX Item "->peek()"
.PD 0
.IP "\->peek(\s-1INDEX\s0)" 4
.IX Item "->peek(INDEX)"
.PD
Returns an item from the queue without dequeuing anything.  Defaults to the
the head of queue (at index position 0) if no index is specified.  Negative
index values are supported as with arrays (i.e., \-1
is the end of the queue, \-2 is next to last, and so on).
.Sp
If no items exists at the specified index (i.e., the queue is empty, or the
index is beyond the number of items on the queue), then \f(CW\*(C`undef\*(C'\fR is returned.
.Sp
Remember, the returned item is not removed from the queue, so manipulating a
\&\f(CW\*(C`peek\*(C'\fRed at reference affects the item on the queue.
.IP "\->insert(\s-1INDEX, LIST\s0)" 4
.IX Item "->insert(INDEX, LIST)"
Adds the list of items to the queue at the specified index position (0
is the head of the list).  Any existing items at and beyond that position are
pushed back past the newly added items:
.Sp
.Vb 3
\&    $q\->enqueue(1, 2, 3, 4);
\&    $q\->insert(1, qw/foo bar/);
\&    # Queue now contains:  1, foo, bar, 2, 3, 4
.Ve
.Sp
Specifying an index position greater than the number of items in the queue
just adds the list to the end.
.Sp
Negative index positions are supported:
.Sp
.Vb 3
\&    $q\->enqueue(1, 2, 3, 4);
\&    $q\->insert(\-2, qw/foo bar/);
\&    # Queue now contains:  1, 2, foo, bar, 3, 4
.Ve
.Sp
Specifying a negative index position greater than the number of items in the
queue adds the list to the head of the queue.
.IP "\->\fIextract()\fR" 4
.IX Item "->extract()"
.PD 0
.IP "\->extract(\s-1INDEX\s0)" 4
.IX Item "->extract(INDEX)"
.IP "\->extract(\s-1INDEX, COUNT\s0)" 4
.IX Item "->extract(INDEX, COUNT)"
.PD
Removes and returns the specified number of items (defaults to 1) from the
specified index position in the queue (0 is the head of the queue).  When
called with no arguments, \f(CW\*(C`extract\*(C'\fR operates the same as \f(CW\*(C`dequeue_nb\*(C'\fR.
.Sp
This method is non-blocking, and will return only as many items as are
available to fulfill the request:
.Sp
.Vb 5
\&    $q\->enqueue(1, 2, 3, 4);
\&    my $item  = $q\->extract(2)     # Returns 3
\&                                   # Queue now contains:  1, 2, 4
\&    my @items = $q\->extract(1, 3)  # Returns (2, 4)
\&                                   # Queue now contains:  1
.Ve
.Sp
Specifying an index position greater than the number of items in the
queue results in \f(CW\*(C`undef\*(C'\fR or an empty list being returned.
.Sp
.Vb 3
\&    $q\->enqueue(\*(Aqfoo\*(Aq);
\&    my $nada = $q\->extract(3)      # Returns undef
\&    my @nada = $q\->extract(1, 3)   # Returns ()
.Ve
.Sp
Negative index positions are supported.  Specifying a negative index position
greater than the number of items in the queue may return items from the head
of the queue (similar to \f(CW\*(C`dequeue_nb\*(C'\fR) if the count overlaps the head of the
queue from the specified position (i.e. if queue size + index + count is
greater than zero):
.Sp
.Vb 5
\&    $q\->enqueue(qw/foo bar baz/);
\&    my @nada = $q\->extract(\-6, 2);   # Returns ()         \- (3+(\-6)+2) <= 0
\&    my @some = $q\->extract(\-6, 4);   # Returns (foo)      \- (3+(\-6)+4) > 0
\&                                     # Queue now contains:  bar, baz
\&    my @rest = $q\->extract(\-3, 4);   # Returns (bar, baz) \- (2+(\-3)+4) > 0
.Ve
.SH "NOTES"
.IX Header "NOTES"
Queues created by Thread::Queue can be used in both threaded and
non-threaded applications.
.SH "LIMITATIONS"
.IX Header "LIMITATIONS"
Passing objects on queues may not work if the objects' classes do not support
sharing.  See \*(L"\s-1BUGS AND LIMITATIONS\*(R"\s0 in threads::shared for more.
.PP
Passing array/hash refs that contain objects may not work for Perl prior to
5.10.0.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Thread::Queue Discussion Forum on \s-1CPAN:
\&\s0<http://www.cpanforum.com/dist/Thread\-Queue>
.PP
threads, threads::shared
.PP
Sample code in the \fIexamples\fR directory of this distribution on \s-1CPAN.\s0
.SH "MAINTAINER"
.IX Header "MAINTAINER"
Jerry D. Hedden, <jdhedden\ \s-1AT\s0\ cpan\ \s-1DOT\s0\ org>
.SH "LICENSE"
.IX Header "LICENSE"
This program is free software; you can redistribute it and/or modify it under
the same terms as Perl itself.
