.\" Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "XML::SAX::ParserFactory 3"
.TH XML::SAX::ParserFactory 3 "2019-06-14" "perl v5.30.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
XML::SAX::ParserFactory \- Obtain a SAX parser
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 6
\&  use XML::SAX::ParserFactory;
\&  use XML::SAX::XYZHandler;
\&  my $handler = XML::SAX::XYZHandler\->new();
\&  my $p = XML::SAX::ParserFactory\->parser(Handler => $handler);
\&  $p\->parse_uri("foo.xml");
\&  # or $p\->parse_string("<foo/>") or $p\->parse_file($fh);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
XML::SAX::ParserFactory is a factory class for providing an application
with a Perl \s-1SAX2 XML\s0 parser. It is akin to \s-1DBI\s0 \- a front end for other
parser classes. Each new \s-1SAX2\s0 parser installed will register itself
with \s-1XML::SAX,\s0 and then it will become available to all applications
that use XML::SAX::ParserFactory to obtain a \s-1SAX\s0 parser.
.PP
Unlike \s-1DBI\s0 however, \s-1XML/SAX\s0 parsers almost all work alike (especially
if they subclass XML::SAX::Base, as they should), so rather than
specifying the parser you want in the call to \f(CW\*(C`parser()\*(C'\fR, \s-1XML::SAX\s0
has several ways to automatically choose which parser to use:
.IP "\(bu" 4
\&\f(CW$XML::SAX::ParserPackage\fR
.Sp
If this package variable is set, then this package is \f(CW\*(C`require()\*(C'\fRd
and an instance of this package is returned by calling the \f(CW\*(C`new()\*(C'\fR
class method in that package. If it cannot be loaded or there is
an error, an exception will be thrown. The variable can also contain
a version number:
.Sp
.Vb 1
\&  $XML::SAX::ParserPackage = "XML::SAX::Expat (0.72)";
.Ve
.Sp
And the number will be treated as a minimum version number.
.IP "\(bu" 4
Required features
.Sp
It is possible to require features from the parsers. For example, you
may wish for a parser that supports validation via a \s-1DTD.\s0 To do that,
use the following code:
.Sp
.Vb 4
\&  use XML::SAX::ParserFactory;
\&  my $factory = XML::SAX::ParserFactory\->new();
\&  $factory\->require_feature(\*(Aqhttp://xml.org/sax/features/validation\*(Aq);
\&  my $parser = $factory\->parser(...);
.Ve
.Sp
Alternatively, specify the required features in the call to the
ParserFactory constructor:
.Sp
.Vb 5
\&  my $factory = XML::SAX::ParserFactory\->new(
\&          RequiredFeatures => {
\&               \*(Aqhttp://xml.org/sax/features/validation\*(Aq => 1,
\&               }
\&          );
.Ve
.Sp
If the features you have asked for are unavailable (for example the
user might not have a validating parser installed), then an
exception will be thrown.
.Sp
The list of known parsers is searched in reverse order, so it will
always return the last installed parser that supports all of your
requested features (Note: this is subject to change if someone
comes up with a better way of making this work).
.IP "\(bu" 4
\&\s-1SAX\s0.ini
.Sp
ParserFactory will search \f(CW@INC\fR for a file called \s-1SAX\s0.ini, which
is in a simple format:
.Sp
.Vb 3
\&  # a comment looks like this,
\&  ; or like this, and are stripped anywhere in the file
\&  key = value # SAX.in contains key/value pairs.
.Ve
.Sp
All whitespace is non-significant.
.Sp
This file can contain either a line:
.Sp
.Vb 1
\&  ParserPackage = MyParserModule (1.02)
.Ve
.Sp
Where MyParserModule is the module to load and use for the parser,
and the number in brackets is a minimum version to load.
.Sp
Or you can list required features:
.Sp
.Vb 1
\&  http://xml.org/sax/features/validation = 1
.Ve
.Sp
And each feature with a true value will be required.
.IP "\(bu" 4
Fallback
.Sp
If none of the above works, the last parser installed on the user's
system will be used. The \s-1XML::SAX\s0 package ships with a pure perl
\&\s-1XML\s0 parser, XML::SAX::PurePerl, so that there will always be a
fallback parser.
.SH "AUTHOR"
.IX Header "AUTHOR"
Matt Sergeant, matt@sergeant.org
.SH "LICENSE"
.IX Header "LICENSE"
This is free software, you may use it and distribute it under the same
terms as Perl itself.
