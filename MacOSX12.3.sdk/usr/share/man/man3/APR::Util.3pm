.\" Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "install::TempContent::Objects::mod_perl-2.0.9::docs::api::APR::Util 3"
.TH install::TempContent::Objects::mod_perl-2.0.9::docs::api::APR::Util 3 "2015-06-18" "perl v5.30.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
APR::Util \- Perl API for Various APR Utilities
.SH "Synopsis"
.IX Header "Synopsis"
.Vb 1
\&  use APR::Util ();
\&  
\&  $ok = password_validate($passwd, $hash);
.Ve
.SH "Description"
.IX Header "Description"
Various \s-1APR\s0 utilities that don't fit into any other group.
.SH "API"
.IX Header "API"
\&\f(CW\*(C`APR::Util\*(C'\fR provides the following functions and/or methods:
.ie n .SS """password_validate"""
.el .SS "\f(CWpassword_validate\fP"
.IX Subsection "password_validate"
Validate an encrypted password hash against a plain text password
(with lots of restrictions and peculiarities).
.PP
.Vb 1
\&  $ok = password_validate($passwd, $hash);
.Ve
.ie n .IP "arg1: $passwd ( string )" 4
.el .IP "arg1: \f(CW$passwd\fR ( string )" 4
.IX Item "arg1: $passwd ( string )"
Plain text password string
.ie n .IP "arg2: $hash ( string )" 4
.el .IP "arg2: \f(CW$hash\fR ( string )" 4
.IX Item "arg2: $hash ( string )"
Encrypted or encoded hash. See below for supported hash formats.
.ie n .IP "ret: $ok ( boolean )" 4
.el .IP "ret: \f(CW$ok\fR ( boolean )" 4
.IX Item "ret: $ok ( boolean )"
The password either matches or not.
.IP "since: 2.0.00" 4
.IX Item "since: 2.0.00"
.PP
The function handles the output of the following functions (it knows
to tell md5 and sha1 from the others, since they are have a special
pattern recognized by apr):
.IP "\(bu" 4
md5
.Sp
generated by \f(CW\*(C`apr_md5_encode()\*(C'\fR (for which at the moment we have no
perl glue, ask if you need it).
.IP "\(bu" 4
sha1
.Sp
generated by \f(CW\*(C`apr_sha1_base64()\*(C'\fR (for which at the moment we have no
perl glue, ask if you need it).
.Sp
and it's available only since Apache 2.0.50
.IP "\(bu" 4
crypt
.Sp
On all but the following platforms: MSWin32, beos and
NetWare. Therefore you probably don't want to use that feature, unless
you know that your code will never end up running on those listed
platforms.
.Sp
Moreover on these three platforms if that function sees that the hash
is not of md5 and sha1 formats, it'll do a clear to clear text
matching, always returning success, no matter what the hashed value
is.
.PP
Warning: double check that you understand what this function does and
does not before using it.
.SH "Unsupported API"
.IX Header "Unsupported API"
\&\f(CW\*(C`APR::Socket\*(C'\fR also provides auto-generated Perl interface for a few
other methods which aren't tested at the moment and therefore their
\&\s-1API\s0 is a subject to change. These methods will be finalized later as a
need arises. If you want to rely on any of the following methods
please contact the the mod_perl development mailing
list so we can help each other take the steps necessary
to shift the method to an officially supported \s-1API.\s0
.ie n .SS """filepath_name_get"""
.el .SS "\f(CWfilepath_name_get\fP"
.IX Subsection "filepath_name_get"
\&\s-1META:\s0 Autogenerated \- needs to be reviewed/completed
.PP
[We have File::Spec and File::Basename for this purpose, I can't see
why this api is needed]
.PP
return the final element of the pathname
.PP
.Vb 1
\&  $ret = filepath_name_get($pathname);
.Ve
.ie n .IP "arg1: $pathname ( string )" 4
.el .IP "arg1: \f(CW$pathname\fR ( string )" 4
.IX Item "arg1: $pathname ( string )"
The path to get the final element of
.ie n .IP "ret: $ret ( string )" 4
.el .IP "ret: \f(CW$ret\fR ( string )" 4
.IX Item "ret: $ret ( string )"
the final element of the path
.Sp
For example:
.Sp
.Vb 4
\&  "/foo/bar/gum"    => "gum"
\&  "/foo/bar/gum/"   => ""
\&  "gum"             => "gum"
\&  "bs\e\epath\e\estuff" => "stuff"
.Ve
.IP "since: subject to change" 4
.IX Item "since: subject to change"
.ie n .SS """password_get"""
.el .SS "\f(CWpassword_get\fP"
.IX Subsection "password_get"
\&\s-1META:\s0 Autogenerated \- needs to be reviewed/completed
.PP
Display a prompt and read in the password from stdin.
.PP
.Vb 1
\&  $ret = password_get($prompt, $pwbuf, $bufsize);
.Ve
.ie n .IP "arg1: $prompt ( string )" 4
.el .IP "arg1: \f(CW$prompt\fR ( string )" 4
.IX Item "arg1: $prompt ( string )"
The prompt to display
.ie n .IP "arg2: $pwbuf ( string )" 4
.el .IP "arg2: \f(CW$pwbuf\fR ( string )" 4
.IX Item "arg2: $pwbuf ( string )"
Buffer to store the password
.ie n .IP "arg3: $bufsize (number)" 4
.el .IP "arg3: \f(CW$bufsize\fR (number)" 4
.IX Item "arg3: $bufsize (number)"
The length of the password buffer.
.ie n .IP "ret: $ret (integer)" 4
.el .IP "ret: \f(CW$ret\fR (integer)" 4
.IX Item "ret: $ret (integer)"
.PD 0
.IP "since: subject to change" 4
.IX Item "since: subject to change"
.PD
.SH "See Also"
.IX Header "See Also"
mod_perl 2.0 documentation.
.SH "Copyright"
.IX Header "Copyright"
mod_perl 2.0 and its core modules are copyrighted under
The Apache Software License, Version 2.0.
.SH "Authors"
.IX Header "Authors"
The mod_perl development team and numerous
contributors.
