.\" Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Type::Tiny::Manual::UsingWithOther 3"
.TH Type::Tiny::Manual::UsingWithOther 3 "2020-10-28" "perl v5.30.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Type::Tiny::Manual::UsingWithOther \- using Type::Tiny with Class::InsideOut, Params::Check, and Object::Accessor.
.SH "MANUAL"
.IX Header "MANUAL"
The antlers crew aren't the only object-oriented programming toolkits in
Perl town. Although Type::Tiny might have been built with Moose, Mouse,
and Moo in mind, it can be used with other toolkits.
.PP
These toolkits are... well... hmm... okay... they exist.
.PP
If you are starting a new project, there's very little reason not to use
Class::Tiny, Moo, or Moose. So you're probably okay to skip this part of
the fine manual and go straight to Type::Tiny::Manual::UsingWithTestMore.
.SS "Class::InsideOut"
.IX Subsection "Class::InsideOut"
You want Class::InsideOut 1.13 or above, which has support for blessed
and overloaded objects (including Type::Tiny type constraints) for the
\&\f(CW\*(C`get_hook\*(C'\fR and \f(CW\*(C`set_hook\*(C'\fR options.
.PP
.Vb 5
\&  package Person {
\&    use Class::InsideOut qw( public );
\&    use Types::Standard qw( Str Int );
\&    use Types::Common::Numeric qw( PositiveInt );
\&    use Type::Params qw( compile );
\&    
\&    # Type checks are really easy.
\&    # Just supply the type as a set hook.
\&    public name => my %_name, {
\&      set_hook => Str,
\&    };
\&    
\&    # Define a type that silently coerces negative values
\&    # to positive. It\*(Aqs silly, but it works as an example!
\&    my $Years = PositiveInt\->plus_coercions(Int, q{ abs($_) });
\&    
\&    # Coercions are more annoying, but possible.
\&    public age => my %_age, {
\&      set_hook => sub { $_ = $Years\->assert_coerce($_) },
\&    };
\&    
\&    # Parameter checking for methods is as expected.
\&    sub get_older {
\&      state $check = compile( $Years );
\&      my $self = shift;
\&      my ($years) = $check\->(@_);
\&      $self\->_set_age($self\->age + $years);
\&    }
\&  }
.Ve
.SS "Params::Check and Object::Accessor"
.IX Subsection "Params::Check and Object::Accessor"
The Params::Check \f(CW\*(C`allow()\*(C'\fR function, the \f(CW\*(C`allow\*(C'\fR option for the
Params::Check \f(CW\*(C`check()\*(C'\fR function, and the input validation mechanism
for Object::Accessor all work in the same way, which is basically a
limited pure-Perl implementation of the smart match operator. While this
doesn't directly support Type::Tiny constraints, it does support coderefs.
You can use Type::Tiny's \f(CW\*(C`compiled_check\*(C'\fR method to obtain a suitable
coderef.
.PP
Param::Check example:
.PP
.Vb 6
\&  my $tmpl = {
\&    name => { allow => Str\->compiled_check },
\&    age  => { allow => Int\->compiled_check },
\&  };
\&  check($tmpl, { name => "Bob", age => 32 })
\&    or die Params::Check::last_error();
.Ve
.PP
Object::Accessor example:
.PP
.Vb 5
\&  my $obj = Object::Accessor\->new;
\&  $obj\->mk_accessors(
\&    { name => Str\->compiled_check },
\&    { age  => Int\->compiled_check },
\&  );
.Ve
.PP
\&\fICaveat:\fR Object::Accessor doesn't die when a value fails to meet its
type constraint; instead it outputs a warning to \s-1STDERR.\s0 This behaviour can
be changed by setting \f(CW\*(C`$Object::Accessor::FATAL = 1\*(C'\fR.
.SS "Class::Struct"
.IX Subsection "Class::Struct"
This is proof-of-concept of how Type::Tiny can be used to constrain
attributes for Class::Struct. It's probably not a good idea to use this
in production as it slows down \f(CW\*(C`UNIVERSAL::isa\*(C'\fR globally.
.PP
.Vb 2
\&  use Types::Standard \-types;
\&  use Class::Struct;
\&
\&  {
\&    my %MAP;
\&    my $orig_isa = \e&UNIVERSAL::isa;
\&    *UNIVERSAL::isa = sub {
\&      return $MAP{$1}\->check($_[0])
\&        if $_[1] =~ /^CLASSSTRUCT::TYPETINY::(.+)$/ && exists $MAP{$1};
\&      goto $orig;
\&    };
\&    my $orig_dn = \e&Type::Tiny::display_name;
\&    *Type::Tiny::display_name = sub {
\&      if (caller(1) eq \*(AqClass::Struct\*(Aq) {
\&        $MAP{$_[0]{uniq}} = $_[0];
\&        return "CLASSSTRUCT::TYPETINY::".$_[0]{uniq};
\&      }
\&      goto $orig_dn;
\&    };
\&  }
\&
\&  struct Person => [ name => Str, age => Int ];
\&
\&  my $bob = Person\->new(
\&    name => "Bob",
\&    age  => 21,
\&  );
\&
\&  $bob\->name("Robert");   # okay
\&  $bob\->name([]);         # dies
.Ve
.SH "NEXT STEPS"
.IX Header "NEXT STEPS"
Here's your next step:
.IP "\(bu" 4
Type::Tiny::Manual::UsingWithTestMore
.Sp
Type::Tiny for test suites.
.SH "AUTHOR"
.IX Header "AUTHOR"
Toby Inkster <tobyink@cpan.org>.
.SH "COPYRIGHT AND LICENCE"
.IX Header "COPYRIGHT AND LICENCE"
This software is copyright (c) 2013\-2014, 2017\-2020 by Toby Inkster.
.PP
This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.
.SH "DISCLAIMER OF WARRANTIES"
.IX Header "DISCLAIMER OF WARRANTIES"
\&\s-1THIS PACKAGE IS PROVIDED \*(L"AS IS\*(R" AND WITHOUT ANY EXPRESS OR IMPLIED
WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.\s0
