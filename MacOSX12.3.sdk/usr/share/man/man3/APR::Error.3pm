.\" Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "install::TempContent::Objects::mod_perl-2.0.9::docs::api::APR::Error 3"
.TH install::TempContent::Objects::mod_perl-2.0.9::docs::api::APR::Error 3 "2015-06-18" "perl v5.30.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
APR::Error \- Perl API for APR/Apache/mod_perl exceptions
.SH "Synopsis"
.IX Header "Synopsis"
.Vb 7
\&  eval { $obj\->mp_method() };
\&  if ($@ && $ref $@ eq \*(AqAPR::Error\*(Aq && $@ == $some_code) {
\&      # handle the exception
\&  }
\&  else {
\&      die $@; # rethrow it
\&  }
.Ve
.SH "Description"
.IX Header "Description"
\&\f(CW\*(C`APR::Error\*(C'\fR handles APR/Apache/mod_perl exceptions for you, while
leaving you in control.
.PP
Apache and \s-1APR API\s0 return a status code for almost all methods, so if
you didn't check the return code and handled any possible problems,
you may have silent failures which may cause all kind of obscure
problems. On the other hand checking the status code after each call
is just too much of a kludge and makes quick prototyping/development
almost impossible, not talking about the code readability. Having
methods return status codes, also complicates the \s-1API\s0 if you need to
return other values.
.PP
Therefore to keep things nice and make the \s-1API\s0 readable we decided to
not return status codes, but instead throw exceptions with
\&\f(CW\*(C`APR::Error\*(C'\fR objects for each method that fails. If you don't catch
those exceptions, everything works transparently \- perl will intercept
the exception object and \f(CW\*(C`die()\*(C'\fR with a proper error message. So you
get all the errors logged without doing any work.
.PP
Now, in certain cases you don't want to just die, but instead the
error needs to be trapped and handled. For example if some \s-1IO\s0
operation times out, may be it is \s-1OK\s0 to trap that and try again. If we
were to die with an error message, you would have had to match the
error message, which is ugly, inefficient and may not work at all if
locale error strings are involved. Therefore you need to be able to
get the original status code that Apache or \s-1APR\s0 has generated. And the
exception objects give you that if you want to. Moreover the objects
contain additional information, such as the function name (in case you
were eval'ing several commands in one block), file and line number
where that function was invoked from. More attributes could be added
in the future.
.PP
\&\f(CW\*(C`APR::Error\*(C'\fR uses Perl operator overloading, such that in boolean and
numerical contexts, the object returns the status code; in the string
context the full error message is returned.
.PP
When intercepting exceptions you need to check whether \f(CW$@\fR is an
object (reference). If your application uses other exception objects
you additionally need to check whether this is a an \f(CW\*(C`APR::Error\*(C'\fR
object. Therefore most of the time this is enough:
.PP
.Vb 4
\&  eval { $obj\->mp_method() };
\&  if ($@ && $ref $@ && $@ == $some_code)
\&      warn "handled exception: $@";
\&  }
.Ve
.PP
But with other, non\-mod_perl, exception objects you need to do:
.PP
.Vb 4
\&  eval { $obj\->mp_method() };
\&  if ($@ && $ref $@ eq \*(AqAPR::Error\*(Aq && $@ == $some_code)
\&      warn "handled exception: $@";
\&  }
.Ve
.PP
In theory you could even do:
.PP
.Vb 4
\&  eval { $obj\->mp_method() };
\&  if ($@ && $@ == $some_code)
\&      warn "handled exception: $@";
\&  }
.Ve
.PP
but it's possible that the method will die with a plain string and not
an object, in which case \f(CW\*(C`$@ == $some_code\*(C'\fR won't quite
work. Remember that mod_perl throws exception objects only when Apache
and \s-1APR\s0 fail, and in a few other special cases of its own (like
\&\f(CW\*(C`exit\*(C'\fR).
.PP
.Vb 1
\&  warn "handled exception: $@" if $@ && $ref $@;
.Ve
.PP
There are two ways to figure out whether an error fits your case. In
most cases you just compare \f(CW$@\fR with an the error constant. For
example if a socket has a timeout set and the data wasn't read within
the timeout limit a
\&\f(CW\*(C`APR::Const::TIMEUP\*(C'\fR)
.PP
.Vb 5
\&  use APR::Const \-compile => qw(TIMEUP);
\&  $sock\->timeout_set(1_000_000); # 1 sec
\&  my $buff;
\&  eval { $sock\->recv($buff, BUFF_LEN) };
\&  if ($@ && ref $@ && $@ == APR::Const::TIMEUP) {
\&
\&  }
.Ve
.PP
However there are situations, where on different Operating Systems a
different error code will be returned. In which case to simplify the
code you should use the special subroutines provided by the
\&\f(CW\*(C`APR::Status\*(C'\fR class. One such
condition is socket \f(CW\*(C`recv()\*(C'\fR timeout, which on Unix throws the
\&\f(CW\*(C`EAGAIN\*(C'\fR error, but on other system it throws a different error. In
this case
\&\f(CW\*(C`APR::Status::is_EAGAIN\*(C'\fR
should be used.
.PP
Let's look at a complete example. Here is a code that performs a
socket read:
.PP
.Vb 2
\&  my $rlen = $sock\->recv(my $buff, 1024);
\&  warn "read $rlen bytes\en";
.Ve
.PP
and in certain cases it times out. The code will die and log the
reason for the failure, which is fine, but later on you may decide
that you want to have another attempt to read before dying and add
some fine grained sleep time between attempts, which can be achieved
with \f(CW\*(C`select\*(C'\fR. Which gives us:
.PP
.Vb 10
\&  use APR::Status ();
\&  # ....
\&  my $tries = 0;
\&  my $buffer;
\&  RETRY: my $rlen = eval { $sock\->recv($buffer, SIZE) };
\&  if ($@)
\&      die $@ unless ref $@ && APR::Status::is_EAGAIN($@);
\&      if ($tries++ < 3) {
\&          # sleep 250msec
\&          select undef, undef, undef, 0.25;
\&          goto RETRY;
\&      }
\&      else {
\&          # do something else
\&      }
\&  }
\&  warn "read $rlen bytes\en"
.Ve
.PP
Notice that we handle non-object and non\-\f(CW\*(C`APR::Error\*(C'\fR exceptions as
well, by simply re-throwing them.
.PP
Finally, the class is called \f(CW\*(C`APR::Error\*(C'\fR because it needs to be used
outside mod_perl as well, when called from
\&\f(CW\*(C`APR\*(C'\fR applications written in Perl.
.SH "API"
.IX Header "API"
.ie n .SS """cluck"""
.el .SS "\f(CWcluck\fP"
.IX Subsection "cluck"
\&\f(CW\*(C`cluck\*(C'\fR is an equivalent of \f(CW\*(C`Carp::cluck\*(C'\fR that works with
\&\f(CW\*(C`APR::Error\*(C'\fR exception objects.
.ie n .SS """confess"""
.el .SS "\f(CWconfess\fP"
.IX Subsection "confess"
\&\f(CW\*(C`confess\*(C'\fR is an equivalent of \f(CW\*(C`Carp::confess\*(C'\fR that works with
\&\f(CW\*(C`APR::Error\*(C'\fR exception objects.
.ie n .SS """strerror"""
.el .SS "\f(CWstrerror\fP"
.IX Subsection "strerror"
Convert \s-1APR\s0 error code to its string representation.
.PP
.Vb 1
\&  $error_str = APR::Error::strerror($rc);
.Ve
.ie n .IP "ret: $rc ( ""APR::Const status constant"" )" 4
.el .IP "ret: \f(CW$rc\fR ( \f(CWAPR::Const status constant\fR )" 4
.IX Item "ret: $rc ( APR::Const status constant )"
The numerical value for the return (error) code
.ie n .IP "ret: $error_str ( string )" 4
.el .IP "ret: \f(CW$error_str\fR ( string )" 4
.IX Item "ret: $error_str ( string )"
The string error message corresponding to the numerical value inside
\&\f(CW$rc\fR.  (Similar to the C function \f(CWstrerror(3)\fR)
.IP "since: 2.0.00" 4
.IX Item "since: 2.0.00"
.PP
Example:
.PP
Try to retrieve the bucket brigade, and if the return value doesn't
indicate success or end of file (usually in protocol handlers) die,
but give the user the human-readable version of the error and not just
the code.
.PP
.Vb 6
\&  my $rc = $c\->input_filters\->get_brigade($bb_in,
\&                                          Apache2::Const::MODE_GETLINE);
\&  if ($rc != APR::Const::SUCCESS && $rc != APR::Const::EOF) {
\&      my $error = APR::Error::strerror($rc);
\&      die "get_brigade error: $rc: $error\en";
\&  }
.Ve
.PP
It's probably a good idea not to omit the numerical value in the error
message, in case the error string is generated with non-English
locale.
.SH "See Also"
.IX Header "See Also"
mod_perl 2.0 documentation.
.SH "Copyright"
.IX Header "Copyright"
mod_perl 2.0 and its core modules are copyrighted under
The Apache Software License, Version 2.0.
.SH "Authors"
.IX Header "Authors"
The mod_perl development team and numerous
contributors.
