.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "FreezeThaw 3"
.TH FreezeThaw 3 "2010-04-03" "perl v5.18.4" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
FreezeThaw \- converting Perl structures to strings and back.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 5
\&  use FreezeThaw qw(freeze thaw cmpStr safeFreeze cmpStrHard);
\&  $string = freeze $data1, $data2, $data3;
\&  ...
\&  ($olddata1, $olddata2, $olddata3) = thaw $string;
\&  if (cmpStr($olddata2,$data2) == 0) {print "OK!"}
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Converts data to/from stringified form, appropriate for
saving\-to/reading\-from permanent storage.
.PP
Deals with objects, circular lists, repeated appearence of the same
refence. Does not deal with overloaded \fIstringify\fR operator yet.
.SH "EXPORT"
.IX Header "EXPORT"
.IP "Default" 12
.IX Item "Default"
None.
.IP "Exportable" 12
.IX Item "Exportable"
\&\f(CW\*(C`freeze thaw cmpStr cmpStrHard safeFreeze\*(C'\fR.
.SH "User API"
.IX Header "User API"
.ie n .IP """cmpStr""" 12
.el .IP "\f(CWcmpStr\fR" 12
.IX Item "cmpStr"
analogue of \f(CW\*(C`cmp\*(C'\fR for data. Takes two arguments and compares them as
separate entities.
.ie n .IP """cmpStrHard""" 12
.el .IP "\f(CWcmpStrHard\fR" 12
.IX Item "cmpStrHard"
analogue of \f(CW\*(C`cmp\*(C'\fR for data. Takes two arguments and compares them
considered as a group.
.ie n .IP """freeze""" 12
.el .IP "\f(CWfreeze\fR" 12
.IX Item "freeze"
returns a string that encupsulates its arguments (considered as a
group). \f(CW\*(C`thaw\*(C'\fRing this string leads to a fatal error if arguments to
\&\f(CW\*(C`freeze\*(C'\fR contained references to \f(CW\*(C`GLOB\*(C'\fRs and \f(CW\*(C`CODE\*(C'\fRs.
.ie n .IP """safeFreeze""" 12
.el .IP "\f(CWsafeFreeze\fR" 12
.IX Item "safeFreeze"
returns a string that encupsulates its arguments (considered as a
group). The result is \f(CW\*(C`thaw\*(C'\fRable in the same process. \f(CW\*(C`thaw\*(C'\fRing the
result in a different process should result in a fatal error if
arguments to \f(CW\*(C`safeFreeze\*(C'\fR contained references to \f(CW\*(C`GLOB\*(C'\fRs and
\&\f(CW\*(C`CODE\*(C'\fRs.
.ie n .IP """thaw""" 12
.el .IP "\f(CWthaw\fR" 12
.IX Item "thaw"
takes one string argument and returns an array. The elements of the
array are \*(L"equivalent\*(R" to arguments of the \f(CW\*(C`freeze\*(C'\fR command that
created the string. Can result in a fatal error (see above).
.SH "Developer API"
.IX Header "Developer API"
\&\f(CW\*(C`FreezeThaw\*(C'\fR \f(CW\*(C`freeze\*(C'\fRs and \f(CW\*(C`thaw\*(C'\fRs data blessed in some package by
calling methods \f(CW\*(C`Freeze\*(C'\fR and \f(CW\*(C`Thaw\*(C'\fR in the package. The fallback
methods are provided by the \f(CW\*(C`FreezeThaw\*(C'\fR itself. The fallback
\&\f(CW\*(C`Freeze\*(C'\fR freezes the \*(L"content\*(R" of blessed object (from Perl point of
view). The fallback \f(CW\*(C`Thaw\*(C'\fR blesses the \f(CW\*(C`thaw\*(C'\fRed data back into the package.
.PP
So the package needs to define its own methods only if the fallback
methods will fail (for example, for a lot of data the \*(L"content\*(R" of an
object is an address of some \fBC\fR data). The methods are called like
.PP
.Vb 2
\&  $newcooky = $obj\->Freeze($cooky);
\&  $obj = Package\->Thaw($content,$cooky);
.Ve
.PP
To save and restore the data the following method are applicable:
.PP
.Vb 1
\&  $cooky\->FreezeScalar($data,$ignorePackage,$noduplicate);
.Ve
.PP
during \fIFreeze()\fRing, and
.PP
.Vb 1
\&  $data = $cooky\->ThawScalar;
.Ve
.PP
Two optional arguments \f(CW$ignorePackage\fR and \f(CW$noduplicate\fR regulate
whether the freezing should not call the methods even if \f(CW$data\fR is a
reference to a blessed object, and whether the data should not be
marked as seen already even if it was seen before. The default methods
.PP
.Vb 4
\&  sub UNIVERSAL::Freeze {
\&    my ($obj, $cooky) = (shift, shift);
\&    $cooky\->FreezeScalar($obj,1,1);
\&  }
\&
\&  sub UNIVERSAL::Thaw {
\&    my ($package, $cooky) = (shift, shift);
\&    my $obj = $cooky\->ThawScalar;
\&    bless $obj, $package;
\&  }
.Ve
.PP
call the \f(CW\*(C`FreezeScalar\*(C'\fR method of the \f(CW$cooky\fR since the freezing
engine will see the data the second time during this call. Indeed, it
is the freezing engine who calls \fIUNIVERSAL::Freeze()\fR, and it calls it
because it needs to freeze \f(CW$obj\fR. The above call to
\&\f(CW$cooky\fR\->\fIFreezeScalar()\fR handles the same data back to engine, but
because flags are different, the code does not cycle.
.PP
Freezing and thawing \f(CW$cooky\fR also allows the following additional methods:
.PP
.Vb 1
\&  $cooky\->isSafe;
.Ve
.PP
to find out whether the current freeze was initiated by \f(CW\*(C`freeze\*(C'\fR or
\&\f(CW\*(C`safeFreeze\*(C'\fR command. Analogous method for thaw \f(CW$cooky\fR returns
whether the current thaw operation is considered safe (i.e., either
does not contain cached elsewhere data, or comes from the same
application). You can use
.PP
.Vb 1
\&  $cooky\->makeSafe;
.Ve
.PP
to prohibit cached data for the duration of the rest of freezing or
thawing of current object.
.PP
Two methods
.PP
.Vb 2
\&  $value = $cooky\->repeatedOK;
\&  $cooky\->noRepeated;           # Now repeated are prohibited
.Ve
.PP
allow to find out/change the current setting for allowing repeated
references.
.PP
If you want to flush the cache of saved objects you can use
.PP
.Vb 1
\&  FreezeThaw\->flushCache;
.Ve
.PP
this can invalidate some frozen string, so that thawing them will
result in fatal error.
.SS "Instantiating"
.IX Subsection "Instantiating"
Sometimes, when an object from a package is recreated in presense of
repeated references, it is not safe to recreate the internal structure
of an object in one step. In such a situation recreation of an object
is carried out in two steps: in the first the object is \f(CW\*(C`allocate\*(C'\fRd,
in the second it is \f(CW\*(C`instantiate\*(C'\fRd.
.PP
The restriction is that during the \fIallocation\fR step you cannot use any
reference to any Perl object that can be referenced from any other
place. This restriction is applied since that object may not exist yet.
.PP
Correspondingly, during \fIinstantiation\fR step the previosly \fIallocated\fR
object should be \f(CW\*(C`filled\*(C'\fR, i.e., it can be changed in any way such
that the references to this object remain valid.
.PP
The methods are called like this:
.PP
.Vb 4
\&  $pre_object_ref = Package\->Allocate($pre_pre_object_ref);
\&        # Returns reference
\&  Package\->Instantiate($pre_object_ref,$cooky);
\&        # Converts into reference to blessed object
.Ve
.PP
The reverse operations are
.PP
.Vb 2
\&  $object_ref\->FreezeEmpty($cooky);
\&  $object_ref\->FreezeInstance($cooky);
.Ve
.PP
during these calls object can \f(CW\*(C`freezeScalar\*(C'\fR some information (in a
usual way) that will be used during \f(CW\*(C`Allocate\*(C'\fR and \f(CW\*(C`Instantiate\*(C'\fR
calls (via \f(CW\*(C`thawScalar\*(C'\fR). Note that the return value of
\&\f(CW\*(C`FreezeEmpty\*(C'\fR is cached during the phase of creation of uninialized
objects. This \fBmust\fR be used like this: the return value is the
reference to the created object, so it is not destructed until other
objects are created, thus the frozen values of the different objects
will not share the same references. Example of bad result:
.PP
.Vb 1
\&  $o1\->FreezeEmpty($cooky)
.Ve
.PP
freezes \f(CW\*(C`{}\*(C'\fR, and \f(CW\*(C`$o2\->FreezeEmpty($cooky)\*(C'\fR makes the same. Now
nobody guaranties that that these two copies of \f(CW\*(C`{}\*(C'\fR are different,
unless a reference to the first one is preserved during the call to
\&\f(CW\*(C`$o2\->FreezeEmpty($cooky)\*(C'\fR. If \f(CW\*(C`$o1\->FreezeEmpty($cooky)\*(C'\fR
returns the value of \f(CW\*(C`{}\*(C'\fR it uses, it will be preserved by the
engine.
.PP
The helper function \f(CW\*(C`FreezeThaw::copyContents\*(C'\fR is provided for
simplification of instantiation. The syntax is
.PP
.Vb 1
\&  FreezeThaw::copyContents $to, $from;
.Ve
.PP
The function copies contents the object \f(CW$from\fR point to into what the
object \f(CW$to\fR points to (including package for blessed references). Both
arguments should be references.
.PP
The default methods are provided. They do the following:
.ie n .IP """FreezeEmpty""" 12
.el .IP "\f(CWFreezeEmpty\fR" 12
.IX Item "FreezeEmpty"
Freezes an \fIempty\fR object of underlying type.
.ie n .IP """FreezeInstance""" 12
.el .IP "\f(CWFreezeInstance\fR" 12
.IX Item "FreezeInstance"
Calls \f(CW\*(C`Freeze\*(C'\fR.
.ie n .IP """Allocate""" 12
.el .IP "\f(CWAllocate\fR" 12
.IX Item "Allocate"
Thaws what was frozen by \f(CW\*(C`FreezeEmpty\*(C'\fR.
.ie n .IP """Instantiate""" 12
.el .IP "\f(CWInstantiate\fR" 12
.IX Item "Instantiate"
Thaws what was frozen by \f(CW\*(C`FreezeInstance\*(C'\fR, uses \f(CW\*(C`copyContents\*(C'\fR to
transfer this to the \f(CW$pre_object\fR.
.SH "BUGS and LIMITATIONS"
.IX Header "BUGS and LIMITATIONS"
A lot of objects are blessed in some obscure packages by \s-1XSUB\s0
typemaps. It is not clear how to (automatically) prevent the
\&\f(CW\*(C`UNIVERSAL\*(C'\fR methods to be called for objects in these packages.
.PP
The objects which can survive \fIfreeze()\fR/\fIthaw()\fR cycle must also survive a
change of a \*(L"member\*(R" to an equal member.  Say, after
.PP
.Vb 2
\&  $a = [a => 3];
\&  $a\->{b} = \e $a\->{a};
.Ve
.PP
\&\f(CW$a\fR satisfies
.PP
.Vb 1
\&  $a\->{b} == \e $a\->{a}
.Ve
.PP
This property will be broken by \fIfreeze()\fR/\fIthaw()\fR, but it is also broken by
.PP
.Vb 1
\&  $a\->{a} = delete $a\->{a};
.Ve
