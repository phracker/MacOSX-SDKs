.\" Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "install::TempContent::Objects::mod_perl-2.0.9::docs::api::APR::Pool 3"
.TH install::TempContent::Objects::mod_perl-2.0.9::docs::api::APR::Pool 3 "2015-06-18" "perl v5.30.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
APR::Pool \- Perl API for APR pools
.SH "Synopsis"
.IX Header "Synopsis"
.Vb 1
\&  use APR::Pool ();
\&  
\&  my $sp = $r\->pool\->new;
\&  my $sp2 = APR::Pool\->new;
\&  
\&  # $sp3 is a subpool of $sp,
\&  # which in turn is a subpool of $r\->pool
\&  $sp3 = $sp\->new;
\&  print \*(Aq$r\->pool is an ancestor of $sp3\*(Aq
\&      if $r\->pool\->is_ancestor($sp3);
\&  # but sp2 is not a sub\-pool of $r\->pool
\&  print \*(Aq$r\->pool is not an ancestor of $sp2\*(Aq
\&      unless $r\->pool\->is_ancestor($sp2);
\&  
\&  # $sp4 and $sp are the same pool (though you can\*(Aqt
\&  # compare the handle as variables)
\&  my $sp4 = $sp3\->parent_get;
\&  
\&
\&  # register a dummy cleanup function
\&  # that just prints the passed args
\&  $sp\->cleanup_register(sub { print @{ $_[0] || [] } }, [1..3]);
\&  
\&  # tag the pool
\&  $sp\->tag("My very best pool");
\&  
\&  # clear the pool
\&  $sp\->clear();
\&  
\&  # destroy sub pool
\&  $sp2\->destroy;
.Ve
.SH "Description"
.IX Header "Description"
\&\f(CW\*(C`APR::Pool\*(C'\fR provides an access to \s-1APR\s0 pools, which are used for an
easy memory management.
.PP
Different pools have different life scopes and therefore one doesn't
need to free allocated memory explicitly, but instead it's done when
the pool's life is getting to an end. For example a request pool is
created at the beginning of a request and destroyed at the end of it,
and all the memory allocated during the request processing using the
request pool is freed at once at the end of the request.
.PP
Most of the time you will just pass various pool objects to the
methods that require them. And you must understand the scoping of the
pools, since if you pass a long lived server pool to a method that
needs the memory only for a short scoped request, you are going to
leak memory. A request pool should be used in such a case. And vice
versa, if you need to allocate some memory for a scope longer than a
single request, then a request pool is inappropriate, since when the
request will be over, the memory will be freed and bad things may
happen.
.PP
If you need to create a new pool, you can always do that via the
\&\f(CW\*(C`new()\*(C'\fR method.
.SH "API"
.IX Header "API"
\&\f(CW\*(C`APR::Pool\*(C'\fR provides the following functions and/or methods:
.ie n .SS """cleanup_register"""
.el .SS "\f(CWcleanup_register\fP"
.IX Subsection "cleanup_register"
Register cleanup callback to run
.PP
.Vb 2
\&  $pool\->cleanup_register($callback);
\&  $pool\->cleanup_register($callback, $arg);
.Ve
.ie n .IP "obj: $pool ( ""APR::Pool object"" )" 4
.el .IP "obj: \f(CW$pool\fR ( \f(CWAPR::Pool object\fR )" 4
.IX Item "obj: $pool ( APR::Pool object )"
The pool object to register the cleanup callback for
.ie n .IP "arg1: $callback ( \s-1CODE\s0 ref or sub name )" 4
.el .IP "arg1: \f(CW$callback\fR ( \s-1CODE\s0 ref or sub name )" 4
.IX Item "arg1: $callback ( CODE ref or sub name )"
a cleanup callback \s-1CODE\s0 reference or just a name of the subroutine
(fully qualified unless defined in the current package).
.ie n .IP "opt arg2: $arg ( \s-1SCALAR\s0 )" 4
.el .IP "opt arg2: \f(CW$arg\fR ( \s-1SCALAR\s0 )" 4
.IX Item "opt arg2: $arg ( SCALAR )"
If this optional argument is passed, the \f(CW$callback\fR function will
receive it as the first and only argument when executed.
.Sp
To pass more than one argument, use an \s-1ARRAY\s0 or a \s-1HASH\s0 reference
.IP "ret: no return value" 4
.IX Item "ret: no return value"
.PD 0
.IP "excpt:" 4
.IX Item "excpt:"
.PD
If a registered callback dies or throws an exception \f(CW$@\fR is stringified
and passed to \f(CW\*(C`warn()\*(C'\fR. Usually, this results in printing it to the
\&\fIerror_log\fR. However, a \f(CW$SIG{_\|_WARN_\|_}\fR handler can be used to catch
them.
.Sp
.Vb 7
\&  $pool\->cleanup_register(sub {die "message1\en"});
\&  $pool\->cleanup_register(sub {die "message2\en"});
\&  my @warnings;
\&  {
\&      local $SIG{_\|_WARN_\|_}=sub {push @warnings, @_};
\&      $pool\->destroy;       # or simply undef $pool
\&  }
.Ve
.Sp
Both of the cleanups above are executed at the time \f(CW\*(C`$pool\->destroy\*(C'\fR
is called. \f(CW@warnings\fR contains \f(CW\*(C`message2\en\*(C'\fR and \f(CW\*(C`message1\en\*(C'\fR afterwards.
\&\f(CW\*(C`$pool\->destroy\*(C'\fR itself does not throw an exception. Any value of \f(CW$@\fR
is preserved.
.IP "since: 2.0.00" 4
.IX Item "since: 2.0.00"
.PP
If there is more than one callback registered (when
\&\f(CW\*(C`cleanup_register\*(C'\fR is called more than once on the same pool object),
the last registered callback will be executed first (\s-1LIFO\s0).
.PP
Examples:
.PP
No arguments, using anon sub as a cleanup callback:
.PP
.Vb 1
\&  $r\->pool\->cleanup_register(sub { warn "running cleanup" });
.Ve
.PP
One or more arguments using a cleanup code reference:
.PP
.Vb 7
\&  $r\->pool\->cleanup_register(\e&cleanup, $r);
\&  $r\->pool\->cleanup_register(\e&cleanup, [$r, $foo]);
\&  sub cleanup {
\&      my @args = (@_ && ref $_[0] eq ARRAY) ? @{ +shift } : shift;
\&      my $r = shift @args;
\&      warn "cleaning up";
\&  }
.Ve
.PP
No arguments, using a function name as a cleanup callback:
.PP
.Vb 1
\&  $r\->pool\->cleanup_register(\*(Aqfoo\*(Aq);
.Ve
.ie n .SS """clear"""
.el .SS "\f(CWclear\fP"
.IX Subsection "clear"
Clear all memory in the pool and run all the registered cleanups. This
also destroys all sub-pools.
.PP
.Vb 1
\&  $pool\->clear();
.Ve
.ie n .IP "obj: $pool ( ""APR::Pool object"" )" 4
.el .IP "obj: \f(CW$pool\fR ( \f(CWAPR::Pool object\fR )" 4
.IX Item "obj: $pool ( APR::Pool object )"
The pool to clear
.IP "ret: no return value" 4
.IX Item "ret: no return value"
.PD 0
.IP "since: 2.0.00" 4
.IX Item "since: 2.0.00"
.PD
.PP
This method differs from \f(CW\*(C`destroy()\*(C'\fR in that it is not
freeing the previously allocated, but allows the pool to re-use it for
the future memory allocations.
.ie n .SS """DESTROY"""
.el .SS "\f(CWDESTROY\fP"
.IX Subsection "DESTROY"
\&\f(CW\*(C`DESTROY\*(C'\fR is an alias to \f(CW\*(C`destroy\*(C'\fR. It's there so
that custom \f(CW\*(C`APR::Pool\*(C'\fR objects will get properly cleaned up, when
the pool object goes out of scope. If you ever want to destroy an
\&\f(CW\*(C`APR::Pool\*(C'\fR object before it goes out of scope, use
\&\f(CW\*(C`destroy\*(C'\fR.
.IP "since: 2.0.00" 4
.IX Item "since: 2.0.00"
.ie n .SS """destroy"""
.el .SS "\f(CWdestroy\fP"
.IX Subsection "destroy"
Destroy the pool.
.PP
.Vb 1
\&  $pool\->destroy();
.Ve
.ie n .IP "obj: $pool ( ""APR::Pool object"" )" 4
.el .IP "obj: \f(CW$pool\fR ( \f(CWAPR::Pool object\fR )" 4
.IX Item "obj: $pool ( APR::Pool object )"
The pool to destroy
.IP "ret: no return value" 4
.IX Item "ret: no return value"
.PD 0
.IP "since: 2.0.00" 4
.IX Item "since: 2.0.00"
.PD
.PP
This method takes a similar action to \f(CW\*(C`clear()\*(C'\fR and then
frees all the memory.
.ie n .SS """is_ancestor"""
.el .SS "\f(CWis_ancestor\fP"
.IX Subsection "is_ancestor"
Determine if pool a is an ancestor of pool b
.PP
.Vb 1
\&  $ret = $pool_a\->is_ancestor($pool_b);
.Ve
.ie n .IP "obj: $pool_a ( ""APR::Pool object"" )" 4
.el .IP "obj: \f(CW$pool_a\fR ( \f(CWAPR::Pool object\fR )" 4
.IX Item "obj: $pool_a ( APR::Pool object )"
The pool to search
.ie n .IP "arg1: $pool_b ( ""APR::Pool object"" )" 4
.el .IP "arg1: \f(CW$pool_b\fR ( \f(CWAPR::Pool object\fR )" 4
.IX Item "arg1: $pool_b ( APR::Pool object )"
The pool to search for
.ie n .IP "ret: $ret ( integer )" 4
.el .IP "ret: \f(CW$ret\fR ( integer )" 4
.IX Item "ret: $ret ( integer )"
True if \f(CW$pool_a\fR is an ancestor of \f(CW$pool_b\fR.
.IP "since: 2.0.00" 4
.IX Item "since: 2.0.00"
.PP
For example create a sub-pool of a given pool and check that the pool
is an ancestor of that sub-pool:
.PP
.Vb 4
\&  use APR::Pool ();
\&  my $pp = $r\->pool;
\&  my $sp = $pp\->new();
\&  $pp\->is_ancestor($sp) or die "Don\*(Aqt mess with genes!";
.Ve
.ie n .SS """new"""
.el .SS "\f(CWnew\fP"
.IX Subsection "new"
Create a new sub-pool
.PP
.Vb 2
\&  my $pool_child = $pool_parent\->new;
\&  my $pool_child = APR::Pool\->new;
.Ve
.ie n .IP "obj: $pool_parent ( ""APR::Pool object"" )" 4
.el .IP "obj: \f(CW$pool_parent\fR ( \f(CWAPR::Pool object\fR )" 4
.IX Item "obj: $pool_parent ( APR::Pool object )"
The parent pool.
.Sp
If you don't have a parent pool to create the sub-pool from, you can
use this object method as a class method, in which case the sub-pool
will be created from the global pool:
.Sp
.Vb 1
\&  my $pool_child = APR::Pool\->new;
.Ve
.ie n .IP "ret: $pool_child ( ""APR::Pool object"" )" 4
.el .IP "ret: \f(CW$pool_child\fR ( \f(CWAPR::Pool object\fR )" 4
.IX Item "ret: $pool_child ( APR::Pool object )"
The child sub-pool
.IP "since: 2.0.00" 4
.IX Item "since: 2.0.00"
.ie n .SS """parent_get"""
.el .SS "\f(CWparent_get\fP"
.IX Subsection "parent_get"
Get the parent pool
.PP
.Vb 1
\&  $parent_pool = $child_pool\->parent_get();
.Ve
.ie n .IP "obj: $child_pool ( ""APR::Pool object"" )" 4
.el .IP "obj: \f(CW$child_pool\fR ( \f(CWAPR::Pool object\fR )" 4
.IX Item "obj: $child_pool ( APR::Pool object )"
the child pool
.ie n .IP "ret: $parent_pool ( ""APR::Pool object"" )" 4
.el .IP "ret: \f(CW$parent_pool\fR ( \f(CWAPR::Pool object\fR )" 4
.IX Item "ret: $parent_pool ( APR::Pool object )"
the parent pool. \f(CW\*(C`undef\*(C'\fR if there is no parent pool (which is the
case for the top-most global pool).
.IP "since: 2.0.00" 4
.IX Item "since: 2.0.00"
.PP
Example: Calculate how big is the pool's ancestry:
.PP
.Vb 10
\&  use APR::Pool ();
\&  sub ancestry_count {
\&      my $child = shift;
\&      my $gen = 0;
\&      while (my $parent = $child\->parent_get) {
\&          $gen++;
\&          $child = $parent;
\&      }
\&      return $gen;
\&  }
.Ve
.ie n .SS """tag"""
.el .SS "\f(CWtag\fP"
.IX Subsection "tag"
Tag a pool (give it a name)
.PP
.Vb 1
\&  $pool\->tag($tag);
.Ve
.ie n .IP "obj: $pool ( ""APR::Pool object"" )" 4
.el .IP "obj: \f(CW$pool\fR ( \f(CWAPR::Pool object\fR )" 4
.IX Item "obj: $pool ( APR::Pool object )"
The pool to tag
.ie n .IP "arg1: $tag ( string )" 4
.el .IP "arg1: \f(CW$tag\fR ( string )" 4
.IX Item "arg1: $tag ( string )"
The tag (some unique string)
.IP "ret: no return value" 4
.IX Item "ret: no return value"
.PD 0
.IP "since: 2.0.00" 4
.IX Item "since: 2.0.00"
.PD
.PP
Each pool can be tagged with a unique label. This can prove useful
when doing low level apr_pool C tracing (when apr is compiled with
\&\f(CW\*(C`\-DAPR_POOL_DEBUG\*(C'\fR). It allows you to \fBgrep\fR\|(1) for the tag you have
set, to single out the traces relevant to you.
.PP
Though there is no way to get read the tag value, since \s-1APR\s0 doesn't
provide such an accessor method.
.SH "Unsupported API"
.IX Header "Unsupported API"
\&\f(CW\*(C`APR::Pool\*(C'\fR also provides auto-generated Perl interface for a few
other methods which aren't tested at the moment and therefore their
\&\s-1API\s0 is a subject to change. These methods will be finalized later as a
need arises. If you want to rely on any of the following methods
please contact the the mod_perl development mailing
list so we can help each other take the steps necessary
to shift the method to an officially supported \s-1API.\s0
.ie n .SS """cleanup_for_exec"""
.el .SS "\f(CWcleanup_for_exec\fP"
.IX Subsection "cleanup_for_exec"
\&\s-1META:\s0 Autogenerated \- needs to be reviewed/completed
.PP
Preparing for \fBexec()\fR \-\-\- close files, etc., but *don't* flush I/O
buffers, *don't* wait for subprocesses, and *don't* free any memory.
Run all of the child_cleanups, so that any unnecessary files are
closed because we are about to exec a new program
.IP "ret: no return value" 4
.IX Item "ret: no return value"
.PD 0
.IP "since: subject to change" 4
.IX Item "since: subject to change"
.PD
.SH "See Also"
.IX Header "See Also"
mod_perl 2.0 documentation.
.SH "Copyright"
.IX Header "Copyright"
mod_perl 2.0 and its core modules are copyrighted under
The Apache Software License, Version 2.0.
.SH "Authors"
.IX Header "Authors"
The mod_perl development team and numerous
contributors.
