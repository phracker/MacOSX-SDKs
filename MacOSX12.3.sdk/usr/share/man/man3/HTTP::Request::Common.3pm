.\" Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "HTTP::Request::Common 3"
.TH HTTP::Request::Common 3 "2020-02-24" "perl v5.30.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
HTTP::Request::Common \- Construct common HTTP::Request objects
.SH "VERSION"
.IX Header "VERSION"
version 6.22
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 7
\&  use HTTP::Request::Common;
\&  $ua = LWP::UserAgent\->new;
\&  $ua\->request(GET \*(Aqhttp://www.sn.no/\*(Aq);
\&  $ua\->request(POST \*(Aqhttp://somewhere/foo\*(Aq, [foo => bar, bar => foo]);
\&  $ua\->request(PATCH \*(Aqhttp://somewhere/foo\*(Aq, [foo => bar, bar => foo]);
\&  $ua\->request(PUT \*(Aqhttp://somewhere/foo\*(Aq, [foo => bar, bar => foo]);
\&  $ua\->request(OPTIONS \*(Aqhttp://somewhere/foo\*(Aq, [foo => bar, bar => foo]);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module provides functions that return newly created \f(CW\*(C`HTTP::Request\*(C'\fR
objects.  These functions are usually more convenient to use than the
standard \f(CW\*(C`HTTP::Request\*(C'\fR constructor for the most common requests.
.PP
Note that LWP::UserAgent has several convenience methods, including
\&\f(CW\*(C`get\*(C'\fR, \f(CW\*(C`head\*(C'\fR, \f(CW\*(C`delete\*(C'\fR, \f(CW\*(C`post\*(C'\fR and \f(CW\*(C`put\*(C'\fR.
.PP
The following functions are provided:
.ie n .IP "\s-1GET\s0 $url" 4
.el .IP "\s-1GET\s0 \f(CW$url\fR" 4
.IX Item "GET $url"
.PD 0
.ie n .IP "\s-1GET\s0 $url, Header => Value,..." 4
.el .IP "\s-1GET\s0 \f(CW$url\fR, Header => Value,..." 4
.IX Item "GET $url, Header => Value,..."
.PD
The \f(CW\*(C`GET\*(C'\fR function returns an HTTP::Request object initialized with
the \*(L"\s-1GET\*(R"\s0 method and the specified \s-1URL.\s0  It is roughly equivalent to the
following call
.Sp
.Vb 4
\&  HTTP::Request\->new(
\&     GET => $url,
\&     HTTP::Headers\->new(Header => Value,...),
\&  )
.Ve
.Sp
but is less cluttered.  What is different is that a header named
\&\f(CW\*(C`Content\*(C'\fR will initialize the content part of the request instead of
setting a header field.  Note that \s-1GET\s0 requests should normally not
have a content, so this hack makes more sense for the \f(CW\*(C`PUT\*(C'\fR, \f(CW\*(C`PATCH\*(C'\fR
 and \f(CW\*(C`POST\*(C'\fR functions described below.
.Sp
The \f(CW\*(C`get(...)\*(C'\fR method of LWP::UserAgent exists as a shortcut for
\&\f(CW\*(C`$ua\->request(GET ...)\*(C'\fR.
.ie n .IP "\s-1HEAD\s0 $url" 4
.el .IP "\s-1HEAD\s0 \f(CW$url\fR" 4
.IX Item "HEAD $url"
.PD 0
.ie n .IP "\s-1HEAD\s0 $url, Header => Value,..." 4
.el .IP "\s-1HEAD\s0 \f(CW$url\fR, Header => Value,..." 4
.IX Item "HEAD $url, Header => Value,..."
.PD
Like \s-1\fBGET\s0()\fR but the method in the request is \*(L"\s-1HEAD\*(R".\s0
.Sp
The \f(CW\*(C`head(...)\*(C'\fR  method of LWP::UserAgent exists as a shortcut for
\&\f(CW\*(C`$ua\->request(HEAD ...)\*(C'\fR.
.ie n .IP "\s-1DELETE\s0 $url" 4
.el .IP "\s-1DELETE\s0 \f(CW$url\fR" 4
.IX Item "DELETE $url"
.PD 0
.ie n .IP "\s-1DELETE\s0 $url, Header => Value,..." 4
.el .IP "\s-1DELETE\s0 \f(CW$url\fR, Header => Value,..." 4
.IX Item "DELETE $url, Header => Value,..."
.PD
Like \f(CW\*(C`GET\*(C'\fR but the method in the request is \f(CW\*(C`DELETE\*(C'\fR.  This function
is not exported by default.
.ie n .IP "\s-1PATCH\s0 $url" 4
.el .IP "\s-1PATCH\s0 \f(CW$url\fR" 4
.IX Item "PATCH $url"
.PD 0
.ie n .IP "\s-1PATCH\s0 $url, Header => Value,..." 4
.el .IP "\s-1PATCH\s0 \f(CW$url\fR, Header => Value,..." 4
.IX Item "PATCH $url, Header => Value,..."
.ie n .IP "\s-1PATCH\s0 $url, $form_ref, Header => Value,..." 4
.el .IP "\s-1PATCH\s0 \f(CW$url\fR, \f(CW$form_ref\fR, Header => Value,..." 4
.IX Item "PATCH $url, $form_ref, Header => Value,..."
.ie n .IP "\s-1PATCH\s0 $url, Header => Value,..., Content => $form_ref" 4
.el .IP "\s-1PATCH\s0 \f(CW$url\fR, Header => Value,..., Content => \f(CW$form_ref\fR" 4
.IX Item "PATCH $url, Header => Value,..., Content => $form_ref"
.ie n .IP "\s-1PATCH\s0 $url, Header => Value,..., Content => $content" 4
.el .IP "\s-1PATCH\s0 \f(CW$url\fR, Header => Value,..., Content => \f(CW$content\fR" 4
.IX Item "PATCH $url, Header => Value,..., Content => $content"
.PD
The same as \f(CW\*(C`POST\*(C'\fR below, but the method in the request is \f(CW\*(C`PATCH\*(C'\fR.
.ie n .IP "\s-1PUT\s0 $url" 4
.el .IP "\s-1PUT\s0 \f(CW$url\fR" 4
.IX Item "PUT $url"
.PD 0
.ie n .IP "\s-1PUT\s0 $url, Header => Value,..." 4
.el .IP "\s-1PUT\s0 \f(CW$url\fR, Header => Value,..." 4
.IX Item "PUT $url, Header => Value,..."
.ie n .IP "\s-1PUT\s0 $url, $form_ref, Header => Value,..." 4
.el .IP "\s-1PUT\s0 \f(CW$url\fR, \f(CW$form_ref\fR, Header => Value,..." 4
.IX Item "PUT $url, $form_ref, Header => Value,..."
.ie n .IP "\s-1PUT\s0 $url, Header => Value,..., Content => $form_ref" 4
.el .IP "\s-1PUT\s0 \f(CW$url\fR, Header => Value,..., Content => \f(CW$form_ref\fR" 4
.IX Item "PUT $url, Header => Value,..., Content => $form_ref"
.ie n .IP "\s-1PUT\s0 $url, Header => Value,..., Content => $content" 4
.el .IP "\s-1PUT\s0 \f(CW$url\fR, Header => Value,..., Content => \f(CW$content\fR" 4
.IX Item "PUT $url, Header => Value,..., Content => $content"
.PD
The same as \f(CW\*(C`POST\*(C'\fR below, but the method in the request is \f(CW\*(C`PUT\*(C'\fR
.ie n .IP "\s-1OPTIONS\s0 $url" 4
.el .IP "\s-1OPTIONS\s0 \f(CW$url\fR" 4
.IX Item "OPTIONS $url"
.PD 0
.ie n .IP "\s-1OPTIONS\s0 $url, Header => Value,..." 4
.el .IP "\s-1OPTIONS\s0 \f(CW$url\fR, Header => Value,..." 4
.IX Item "OPTIONS $url, Header => Value,..."
.ie n .IP "\s-1OPTIONS\s0 $url, $form_ref, Header => Value,..." 4
.el .IP "\s-1OPTIONS\s0 \f(CW$url\fR, \f(CW$form_ref\fR, Header => Value,..." 4
.IX Item "OPTIONS $url, $form_ref, Header => Value,..."
.ie n .IP "\s-1OPTIONS\s0 $url, Header => Value,..., Content => $form_ref" 4
.el .IP "\s-1OPTIONS\s0 \f(CW$url\fR, Header => Value,..., Content => \f(CW$form_ref\fR" 4
.IX Item "OPTIONS $url, Header => Value,..., Content => $form_ref"
.ie n .IP "\s-1OPTIONS\s0 $url, Header => Value,..., Content => $content" 4
.el .IP "\s-1OPTIONS\s0 \f(CW$url\fR, Header => Value,..., Content => \f(CW$content\fR" 4
.IX Item "OPTIONS $url, Header => Value,..., Content => $content"
.PD
The same as \f(CW\*(C`POST\*(C'\fR below, but the method in the request is \f(CW\*(C`OPTIONS\*(C'\fR
.ie n .IP "\s-1POST\s0 $url" 4
.el .IP "\s-1POST\s0 \f(CW$url\fR" 4
.IX Item "POST $url"
.PD 0
.ie n .IP "\s-1POST\s0 $url, Header => Value,..." 4
.el .IP "\s-1POST\s0 \f(CW$url\fR, Header => Value,..." 4
.IX Item "POST $url, Header => Value,..."
.ie n .IP "\s-1POST\s0 $url, $form_ref, Header => Value,..." 4
.el .IP "\s-1POST\s0 \f(CW$url\fR, \f(CW$form_ref\fR, Header => Value,..." 4
.IX Item "POST $url, $form_ref, Header => Value,..."
.ie n .IP "\s-1POST\s0 $url, Header => Value,..., Content => $form_ref" 4
.el .IP "\s-1POST\s0 \f(CW$url\fR, Header => Value,..., Content => \f(CW$form_ref\fR" 4
.IX Item "POST $url, Header => Value,..., Content => $form_ref"
.ie n .IP "\s-1POST\s0 $url, Header => Value,..., Content => $content" 4
.el .IP "\s-1POST\s0 \f(CW$url\fR, Header => Value,..., Content => \f(CW$content\fR" 4
.IX Item "POST $url, Header => Value,..., Content => $content"
.PD
\&\f(CW\*(C`POST\*(C'\fR, \f(CW\*(C`PATCH\*(C'\fR and \f(CW\*(C`PUT\*(C'\fR all work with the same parameters.
.Sp
.Vb 4
\&  %data = ( title => \*(Aqsomething\*(Aq, body => something else\*(Aq );
\&  $ua = LWP::UserAgent\->new();
\&  $request = HTTP::Request::Common::POST( $url, [ %data ] );
\&  $response = $ua\->request($request);
.Ve
.Sp
They take a second optional array or hash reference
parameter \f(CW$form_ref\fR.  The content can also be specified
directly using the \f(CW\*(C`Content\*(C'\fR pseudo-header, and you may also provide
the \f(CW$form_ref\fR this way.
.Sp
The \f(CW\*(C`Content\*(C'\fR pseudo-header steals a bit of the header field namespace as
there is no way to directly specify a header that is actually called
\&\*(L"Content\*(R".  If you really need this you must update the request
returned in a separate statement.
.Sp
The \f(CW$form_ref\fR argument can be used to pass key/value pairs for the
form content.  By default we will initialize a request using the
\&\f(CW\*(C`application/x\-www\-form\-urlencoded\*(C'\fR content type.  This means that
you can emulate an \s-1HTML\s0 <form> POSTing like this:
.Sp
.Vb 7
\&  POST \*(Aqhttp://www.perl.org/survey.cgi\*(Aq,
\&       [ name   => \*(AqGisle Aas\*(Aq,
\&         email  => \*(Aqgisle@aas.no\*(Aq,
\&         gender => \*(AqM\*(Aq,
\&         born   => \*(Aq1964\*(Aq,
\&         perc   => \*(Aq3%\*(Aq,
\&       ];
.Ve
.Sp
This will create an HTTP::Request object that looks like this:
.Sp
.Vb 3
\&  POST http://www.perl.org/survey.cgi
\&  Content\-Length: 66
\&  Content\-Type: application/x\-www\-form\-urlencoded
\&
\&  name=Gisle%20Aas&email=gisle%40aas.no&gender=M&born=1964&perc=3%25
.Ve
.Sp
Multivalued form fields can be specified by either repeating the field
name or by passing the value as an array reference.
.Sp
The \s-1POST\s0 method also supports the \f(CW\*(C`multipart/form\-data\*(C'\fR content used
for \fIForm-based File Upload\fR as specified in \s-1RFC 1867.\s0  You trigger
this content format by specifying a content type of \f(CW\*(Aqform\-data\*(Aq\fR as
one of the request headers.  If one of the values in the \f(CW$form_ref\fR is
an array reference, then it is treated as a file part specification
with the following interpretation:
.Sp
.Vb 2
\&  [ $file, $filename, Header => Value... ]
\&  [ undef, $filename, Header => Value,..., Content => $content ]
.Ve
.Sp
The first value in the array ($file) is the name of a file to open.
This file will be read and its content placed in the request.  The
routine will croak if the file can't be opened.  Use an \f(CW\*(C`undef\*(C'\fR as
\&\f(CW$file\fR value if you want to specify the content directly with a
\&\f(CW\*(C`Content\*(C'\fR header.  The \f(CW$filename\fR is the filename to report in the
request.  If this value is undefined, then the basename of the \f(CW$file\fR
will be used.  You can specify an empty string as \f(CW$filename\fR if you
want to suppress sending the filename when you provide a \f(CW$file\fR value.
.Sp
If a \f(CW$file\fR is provided by no \f(CW\*(C`Content\-Type\*(C'\fR header, then \f(CW\*(C`Content\-Type\*(C'\fR
and \f(CW\*(C`Content\-Encoding\*(C'\fR will be filled in automatically with the values
returned by \f(CW\*(C`LWP::MediaTypes::guess_media_type()\*(C'\fR
.Sp
Sending my \fI~/.profile\fR to the survey used as example above can be
achieved by this:
.Sp
.Vb 8
\&  POST \*(Aqhttp://www.perl.org/survey.cgi\*(Aq,
\&       Content_Type => \*(Aqform\-data\*(Aq,
\&       Content      => [ name  => \*(AqGisle Aas\*(Aq,
\&                         email => \*(Aqgisle@aas.no\*(Aq,
\&                         gender => \*(AqM\*(Aq,
\&                         born   => \*(Aq1964\*(Aq,
\&                         init   => ["$ENV{HOME}/.profile"],
\&                       ]
.Ve
.Sp
This will create an HTTP::Request object that almost looks this (the
boundary and the content of your \fI~/.profile\fR is likely to be
different):
.Sp
.Vb 3
\&  POST http://www.perl.org/survey.cgi
\&  Content\-Length: 388
\&  Content\-Type: multipart/form\-data; boundary="6G+f"
\&
\&  \-\-6G+f
\&  Content\-Disposition: form\-data; name="name"
\&
\&  Gisle Aas
\&  \-\-6G+f
\&  Content\-Disposition: form\-data; name="email"
\&
\&  gisle@aas.no
\&  \-\-6G+f
\&  Content\-Disposition: form\-data; name="gender"
\&
\&  M
\&  \-\-6G+f
\&  Content\-Disposition: form\-data; name="born"
\&
\&  1964
\&  \-\-6G+f
\&  Content\-Disposition: form\-data; name="init"; filename=".profile"
\&  Content\-Type: text/plain
\&
\&  PATH=/local/perl/bin:$PATH
\&  export PATH
\&
\&  \-\-6G+f\-\-
.Ve
.Sp
If you set the \f(CW$DYNAMIC_FILE_UPLOAD\fR variable (exportable) to some \s-1TRUE\s0
value, then you get back a request object with a subroutine closure as
the content attribute.  This subroutine will read the content of any
files on demand and return it in suitable chunks.  This allow you to
upload arbitrary big files without using lots of memory.  You can even
upload infinite files like \fI/dev/audio\fR if you wish; however, if
the file is not a plain file, there will be no \f(CW\*(C`Content\-Length\*(C'\fR header
defined for the request.  Not all servers (or server
applications) like this.  Also, if the file(s) change in size between
the time the \f(CW\*(C`Content\-Length\*(C'\fR is calculated and the time that the last
chunk is delivered, the subroutine will \f(CW\*(C`Croak\*(C'\fR.
.Sp
The \f(CW\*(C`post(...)\*(C'\fR  method of LWP::UserAgent exists as a shortcut for
\&\f(CW\*(C`$ua\->request(POST ...)\*(C'\fR.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
HTTP::Request, LWP::UserAgent
.PP
Also, there are some examples in \*(L"\s-1EXAMPLES\*(R"\s0 in HTTP::Request that you might
find useful. For example, batch requests are explained there.
.SH "AUTHOR"
.IX Header "AUTHOR"
Gisle Aas <gisle@activestate.com>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is copyright (c) 1994\-2017 by Gisle Aas.
.PP
This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.
