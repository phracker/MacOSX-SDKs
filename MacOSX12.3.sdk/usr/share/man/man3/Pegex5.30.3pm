.\" Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Pegex 3"
.TH Pegex 3 "2020-02-13" "perl v5.30.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Pegex \- Acmeist PEG Parser Framework
.SH "VERSION"
.IX Header "VERSION"
This document describes Pegex version \fB0.75\fR.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&    use Pegex;
\&    my $result = pegex($grammar)\->parse($input);
.Ve
.PP
or with options:
.PP
.Vb 4
\&    use Pegex;
\&    use ReceiverClass;
\&    my $parser = pegex($grammar, \*(AqReceiverClass\*(Aq);
\&    my $result = $parser\->parse($input);
.Ve
.PP
or more explicitly:
.PP
.Vb 9
\&    use Pegex::Parser;
\&    use Pegex::Grammar;
\&    my $pegex_grammar = Pegex::Grammar\->new(
\&        text => $grammar,
\&    );
\&    my $parser = Pegex::Parser\->new(
\&        grammar => $pegex_grammar,
\&    );
\&    my $result = $parser\->parse($input);
.Ve
.PP
or customized explicitly:
.PP
.Vb 10
\&    {
\&        package MyGrammar;
\&        use Pegex::Base;
\&        extends \*(AqPegex::Grammar\*(Aq;
\&        has text => "your grammar definition text goes here";
\&        has receiver => "MyReceiver";
\&    }
\&    {
\&        package MyReceiver;
\&        use base \*(AqPegex::Receiver\*(Aq;
\&        got_some_rule { ... }
\&        got_other_rule { ... }
\&    }
\&    use Pegex::Parser;
\&    my $parser = Pegex::Parser\->new(
\&        grammar => MyGrammar\->new,
\&        receiver => MyReceiver\->new,
\&    );
\&    $parser\->parse($input);
\&    my $result = $parser\->receiver\->data;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Pegex is an Acmeist parser framework. It allows you to easily create parsers
that will work equivalently in lots of programming languages! The inspiration
for Pegex comes from the parsing engine upon which the postmodern programming
language \fBPerl 6\fR is based on. Pegex brings this beauty to the other
\&\fIjust\fRmodern languages that have a normal regular expression engine
available.
.PP
Pegex gets it name by combining Parsing Expression Grammars (\s-1PEG\s0), with
Regular Expressions (Regex). That's actually what Pegex does.
.PP
\&\s-1PEG\s0 is the cool new way to elegantly specify recursive descent grammars. The
Perl 6 language is defined in terms of a self modifying \s-1PEG\s0 language called
\&\fBPerl 6 Rules\fR. Regexes are familiar to programmers of most modern
programming languages. Pegex defines a simple \s-1PEG\s0 syntax, where all the
terminals are regexes. This means that Pegex can be quite fast and powerful.
.PP
Pegex attempts to be the simplest way to define new (or old) Domain Specific
Languages (DSLs) that need to be used in several programming languages and
environments. Things like \s-1JSON, YAML,\s0 Markdown etc. It also great for writing
parsers/compilers that only need to work in one language.
.SH "USAGE"
.IX Header "USAGE"
The \f(CW\*(C`Pegex.pm\*(C'\fR module itself (this module) is just a trivial way to use the
Pegex framework. It is only intended for the simplest of uses.
.PP
This module exports a single function, \f(CW\*(C`pegex\*(C'\fR, which takes a Pegex grammar
string as input. You may also pass a receiver class name after the grammar.
.PP
.Vb 1
\&    my $parser = pegex($grammar, \*(AqMyReceiver\*(Aq);
.Ve
.PP
The \f(CW\*(C`pegex\*(C'\fR function returns a Pegex::Parser object, on which you would
typically call the \f(CW\*(C`parse()\*(C'\fR method, which (on success) will return a data
structure of the parsed data.
.PP
See Pegex::API for more details.
.SH "PEGEX DEBUGGING"
.IX Header "PEGEX DEBUGGING"
Pegex (Pegex::Parser) has many easy to use methods of debugging. See the
\&\*(L"Debugging\*(R" section of Pegex::Parser for details.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.IP "\(bu" 4
Pegex::Overview
.IP "\(bu" 4
Pegex::API
.IP "\(bu" 4
Pegex::Syntax
.IP "\(bu" 4
Pegex::Tutorial
.IP "\(bu" 4
Pegex::Resources
.IP "\(bu" 4
Pegex::Parser
.IP "\(bu" 4
<http://github.com/ingydotnet/pegex\-pm>
.IP "\(bu" 4
<irc://freenode.net#pegex>
.SH "AUTHOR"
.IX Header "AUTHOR"
Ingy döt Net <ingy@cpan.org>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright 2010\-2020. Ingy döt Net.
.PP
This program is free software; you can redistribute it and/or modify it under
the same terms as Perl itself.
.PP
See <http://www.perl.com/perl/misc/Artistic.html>
