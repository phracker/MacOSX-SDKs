.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "CPANPLUS::Module 3pm"
.TH CPANPLUS::Module 3pm "2014-09-30" "perl v5.18.4" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
CPANPLUS::Module \- CPAN module objects for CPANPLUS
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&    ### get a module object from the CPANPLUS::Backend object
\&    my $mod = $cb\->module_tree(\*(AqSome::Module\*(Aq);
\&
\&    ### accessors
\&    $mod\->version;
\&    $mod\->package;
\&
\&    ### methods
\&    $mod\->fetch;
\&    $mod\->extract;
\&    $mod\->install;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\f(CW\*(C`CPANPLUS::Module\*(C'\fR creates objects from the information in the
source files. These can then be used to query and perform actions
on, like fetching or installing.
.PP
These objects should only be created internally. For \f(CW\*(C`fake\*(C'\fR objects,
there's the \f(CW\*(C`CPANPLUS::Module::Fake\*(C'\fR class. To obtain a module object
consult the \f(CW\*(C`CPANPLUS::Backend\*(C'\fR documentation.
.SH "CLASS METHODS"
.IX Header "CLASS METHODS"
.SS "accessors ()"
.IX Subsection "accessors ()"
Returns a list of all accessor methods to the object
.SH "ACCESSORS"
.IX Header "ACCESSORS"
An objects of this class has the following accessors:
.IP "name" 4
.IX Item "name"
Name of the module.
.IP "module" 4
.IX Item "module"
Name of the module.
.IP "version" 4
.IX Item "version"
Version of the module. Defaults to '0.0' if none was provided.
.IP "path" 4
.IX Item "path"
Extended path on the mirror.
.IP "comment" 4
.IX Item "comment"
Any comment about the module \*(-- largely unused.
.IP "package" 4
.IX Item "package"
The name of the package.
.IP "description" 4
.IX Item "description"
Description of the module \*(-- only registered modules have this.
.IP "dslip" 4
.IX Item "dslip"
The five character dslip string, that represents meta-data of the
module \*(-- again, only registered modules have this.
.IP "status" 4
.IX Item "status"
The \f(CW\*(C`CPANPLUS::Module::Status\*(C'\fR object associated with this object.
(see below).
.IP "author" 4
.IX Item "author"
The \f(CW\*(C`CPANPLUS::Module::Author\*(C'\fR object associated with this object.
.IP "parent" 4
.IX Item "parent"
The \f(CW\*(C`CPANPLUS::Internals\*(C'\fR object that spawned this module object.
.SH "STATUS ACCESSORS"
.IX Header "STATUS ACCESSORS"
\&\f(CW\*(C`CPANPLUS\*(C'\fR caches a lot of results from method calls and saves data
it collected along the road for later reuse.
.PP
\&\f(CW\*(C`CPANPLUS\*(C'\fR uses this internally, but it is also available for the end
user. You can get a status object by calling:
.PP
.Vb 1
\&    $modobj\->status
.Ve
.PP
You can then query the object as follows:
.IP "installer_type" 4
.IX Item "installer_type"
The installer type used for this distribution. Will be one of
\&'makemaker' or 'build'. This determines whether \f(CW\*(C`CPANPLUS::Dist::MM\*(C'\fR
or \f(CW\*(C`CPANPLUS::Dist::Build\*(C'\fR will be used to build this distribution.
.IP "dist_cpan" 4
.IX Item "dist_cpan"
The dist object used to do the CPAN-side of the installation. Either
a \f(CW\*(C`CPANPLUS::Dist::MM\*(C'\fR or \f(CW\*(C`CPANPLUS::Dist::Build\*(C'\fR object.
.IP "dist" 4
.IX Item "dist"
The custom dist object used to do the operating specific side of the
installation, if you've chosen to use this. For example, if you've
chosen to install using the \f(CW\*(C`ports\*(C'\fR format, this may be a
\&\f(CW\*(C`CPANPLUS::Dist::Ports\*(C'\fR object.
.Sp
Undefined if you didn't specify a separate format to install through.
.IP "prereqs | requires" 4
.IX Item "prereqs | requires"
A hashref of prereqs this distribution was found to have. Will look
something like this:
.Sp
.Vb 1
\&    { Carp  => 0.01, strict => 0 }
.Ve
.Sp
Might be undefined if the distribution didn't have any prerequisites.
.IP "configure_requires" 4
.IX Item "configure_requires"
Like prereqs, but these are necessary to be installed before the
build process can even begin.
.IP "signature" 4
.IX Item "signature"
Flag indicating, if a signature check was done, whether it was \s-1OK\s0 or
not.
.IP "extract" 4
.IX Item "extract"
The directory this distribution was extracted to.
.IP "fetch" 4
.IX Item "fetch"
The location this distribution was fetched to.
.IP "readme" 4
.IX Item "readme"
The text of this distributions \s-1README\s0 file.
.IP "uninstall" 4
.IX Item "uninstall"
Flag indicating if an uninstall call was done successfully.
.IP "created" 4
.IX Item "created"
Flag indicating if the \f(CW\*(C`create\*(C'\fR call to your dist object was done
successfully.
.IP "installed" 4
.IX Item "installed"
Flag indicating if the \f(CW\*(C`install\*(C'\fR call to your dist object was done
successfully.
.IP "checksums" 4
.IX Item "checksums"
The location of this distributions \s-1CHECKSUMS\s0 file.
.IP "checksum_ok" 4
.IX Item "checksum_ok"
Flag indicating if the checksums check was done successfully.
.IP "checksum_value" 4
.IX Item "checksum_value"
The checksum value this distribution is expected to have
.SH "METHODS"
.IX Header "METHODS"
.ie n .SS "$self = CPANPLUS::Module\->new( \s-1OPTIONS \s0)"
.el .SS "\f(CW$self\fP = CPANPLUS::Module\->new( \s-1OPTIONS \s0)"
.IX Subsection "$self = CPANPLUS::Module->new( OPTIONS )"
This method returns a \f(CW\*(C`CPANPLUS::Module\*(C'\fR object. Normal users
should never call this method directly, but instead use the
\&\f(CW\*(C`CPANPLUS::Backend\*(C'\fR to obtain module objects.
.PP
This example illustrates a \f(CW\*(C`new()\*(C'\fR call with all required arguments:
.PP
.Vb 7
\&        CPANPLUS::Module\->new(
\&            module  => \*(AqFoo\*(Aq,
\&            path    => \*(Aqauthors/id/A/AA/AAA\*(Aq,
\&            package => \*(AqFoo\-1.0.tgz\*(Aq,
\&            author  => $author_object,
\&            _id     => INTERNALS_OBJECT_ID,
\&        );
.Ve
.PP
Every accessor is also a valid option to pass to \f(CW\*(C`new\*(C'\fR.
.PP
Returns a module object on success and false on failure.
.ie n .SS "$mod\->package_name( [$package_string] )"
.el .SS "\f(CW$mod\fP\->package_name( [$package_string] )"
.IX Subsection "$mod->package_name( [$package_string] )"
Returns the name of the package a module is in. For \f(CW\*(C`Acme::Bleach\*(C'\fR
that might be \f(CW\*(C`Acme\-Bleach\*(C'\fR.
.ie n .SS "$mod\->package_version( [$package_string] )"
.el .SS "\f(CW$mod\fP\->package_version( [$package_string] )"
.IX Subsection "$mod->package_version( [$package_string] )"
Returns the version of the package a module is in. For a module
in the package \f(CW\*(C`Acme\-Bleach\-1.1.tar.gz\*(C'\fR this would be \f(CW1.1\fR.
.ie n .SS "$mod\->package_extension( [$package_string] )"
.el .SS "\f(CW$mod\fP\->package_extension( [$package_string] )"
.IX Subsection "$mod->package_extension( [$package_string] )"
Returns the suffix added by the compression method of a package a
certain module is in. For a module in \f(CW\*(C`Acme\-Bleach\-1.1.tar.gz\*(C'\fR, this
would be \f(CW\*(C`tar.gz\*(C'\fR.
.ie n .SS "$mod\->package_is_perl_core"
.el .SS "\f(CW$mod\fP\->package_is_perl_core"
.IX Subsection "$mod->package_is_perl_core"
Returns a boolean indicating of the package a particular module is in,
is actually a core perl distribution.
.ie n .SS "$mod\->module_is_supplied_with_perl_core( [version => $]] )"
.el .SS "\f(CW$mod\fP\->module_is_supplied_with_perl_core( [version => $]] )"
.IX Subsection "$mod->module_is_supplied_with_perl_core( [version => $]] )"
Returns a boolean indicating whether \f(CW\*(C`ANY VERSION\*(C'\fR of this module
was supplied with the current running perl's core package.
.ie n .SS "$mod\->is_bundle"
.el .SS "\f(CW$mod\fP\->is_bundle"
.IX Subsection "$mod->is_bundle"
Returns a boolean indicating if the module you are looking at, is
actually a bundle. Bundles are identified as modules whose name starts
with \f(CW\*(C`Bundle::\*(C'\fR.
.ie n .SS "$mod\->is_autobundle;"
.el .SS "\f(CW$mod\fP\->is_autobundle;"
.IX Subsection "$mod->is_autobundle;"
Returns a boolean indicating if the module you are looking at, is
actually an autobundle as generated by \f(CW\*(C`$cb\->autobundle\*(C'\fR.
.ie n .SS "$mod\->is_third_party"
.el .SS "\f(CW$mod\fP\->is_third_party"
.IX Subsection "$mod->is_third_party"
Returns a boolean indicating whether the package is a known third-party
module (i.e. it's not provided by the standard Perl distribution and
is not available on the \s-1CPAN,\s0 but on a third party software provider).
See Module::ThirdParty for more details.
.ie n .SS "$mod\->third_party_information"
.el .SS "\f(CW$mod\fP\->third_party_information"
.IX Subsection "$mod->third_party_information"
Returns a reference to a hash with more information about a third-party
module. See the documentation about \f(CW\*(C`module_information()\*(C'\fR in
Module::ThirdParty for more details.
.ie n .SS "$clone = $self\->clone"
.el .SS "\f(CW$clone\fP = \f(CW$self\fP\->clone"
.IX Subsection "$clone = $self->clone"
Clones the current module object for tinkering with.
It will have a clean \f(CW\*(C`CPANPLUS::Module::Status\*(C'\fR object, as well as
a fake \f(CW\*(C`CPANPLUS::Module::Author\*(C'\fR object.
.ie n .SS "$where = $self\->fetch"
.el .SS "\f(CW$where\fP = \f(CW$self\fP\->fetch"
.IX Subsection "$where = $self->fetch"
Fetches the module from a \s-1CPAN\s0 mirror.
Look at \fICPANPLUS::Internals::Fetch::_fetch()\fR for details on the
options you can pass.
.ie n .SS "$path = $self\->extract"
.el .SS "\f(CW$path\fP = \f(CW$self\fP\->extract"
.IX Subsection "$path = $self->extract"
Extracts the fetched module.
Look at \fICPANPLUS::Internals::Extract::_extract()\fR for details on
the options you can pass.
.ie n .SS "$type = $self\->get_installer_type([prefer_makefile => \s-1BOOL\s0])"
.el .SS "\f(CW$type\fP = \f(CW$self\fP\->get_installer_type([prefer_makefile => \s-1BOOL\s0])"
.IX Subsection "$type = $self->get_installer_type([prefer_makefile => BOOL])"
Gets the installer type for this module. This may either be \f(CW\*(C`build\*(C'\fR or
\&\f(CW\*(C`makemaker\*(C'\fR. If \f(CW\*(C`Module::Build\*(C'\fR is unavailable or no installer type
is available, it will fall back to \f(CW\*(C`makemaker\*(C'\fR. If both are available,
it will pick the one indicated by your config, or by the
\&\f(CW\*(C`prefer_makefile\*(C'\fR option you can pass to this function.
.PP
Returns the installer type on success, and false on error.
.ie n .SS "$dist = $self\->dist([target => 'prepare|create', format => \s-1DISTRIBUTION_TYPE,\s0 args => {key => val}]);"
.el .SS "\f(CW$dist\fP = \f(CW$self\fP\->dist([target => 'prepare|create', format => \s-1DISTRIBUTION_TYPE,\s0 args => {key => val}]);"
.IX Subsection "$dist = $self->dist([target => 'prepare|create', format => DISTRIBUTION_TYPE, args => {key => val}]);"
Create a distribution object, ready to be installed.
Distribution type defaults to your config settings
.PP
The optional \f(CW\*(C`args\*(C'\fR hashref is passed on to the specific distribution
types' \f(CW\*(C`create\*(C'\fR method after being dereferenced.
.PP
Returns a distribution object on success, false on failure.
.PP
See \f(CW\*(C`CPANPLUS::Dist\*(C'\fR for details.
.ie n .SS "$bool = $mod\->prepare( )"
.el .SS "\f(CW$bool\fP = \f(CW$mod\fP\->prepare( )"
.IX Subsection "$bool = $mod->prepare( )"
Convenience method around \f(CW\*(C`install()\*(C'\fR that prepares a module
without actually building it. This is equivalent to invoking \f(CW\*(C`install\*(C'\fR
with \f(CW\*(C`target\*(C'\fR set to \f(CW\*(C`prepare\*(C'\fR
.PP
Returns true on success, false on failure.
.ie n .SS "$bool = $mod\->create( )"
.el .SS "\f(CW$bool\fP = \f(CW$mod\fP\->create( )"
.IX Subsection "$bool = $mod->create( )"
Convenience method around \f(CW\*(C`install()\*(C'\fR that creates a module.
This is equivalent to invoking \f(CW\*(C`install\*(C'\fR with \f(CW\*(C`target\*(C'\fR set to
\&\f(CW\*(C`create\*(C'\fR
.PP
Returns true on success, false on failure.
.ie n .SS "$bool = $mod\->test( )"
.el .SS "\f(CW$bool\fP = \f(CW$mod\fP\->test( )"
.IX Subsection "$bool = $mod->test( )"
Convenience wrapper around \f(CW\*(C`install()\*(C'\fR that tests a module, without
installing it.
It's the equivalent to invoking \f(CW\*(C`install()\*(C'\fR with \f(CW\*(C`target\*(C'\fR set to
\&\f(CW\*(C`create\*(C'\fR and \f(CW\*(C`skiptest\*(C'\fR set to \f(CW0\fR.
.PP
Returns true on success, false on failure.
.ie n .SS "$bool = $self\->install([ target => 'init|prepare|create|install', format => \s-1FORMAT_TYPE,\s0 extractdir => \s-1DIRECTORY,\s0 fetchdir => \s-1DIRECTORY,\s0 prefer_bin => \s-1BOOL,\s0 force => \s-1BOOL,\s0 verbose => \s-1BOOL, ..... \s0]);"
.el .SS "\f(CW$bool\fP = \f(CW$self\fP\->install([ target => 'init|prepare|create|install', format => \s-1FORMAT_TYPE,\s0 extractdir => \s-1DIRECTORY,\s0 fetchdir => \s-1DIRECTORY,\s0 prefer_bin => \s-1BOOL,\s0 force => \s-1BOOL,\s0 verbose => \s-1BOOL, ..... \s0]);"
.IX Subsection "$bool = $self->install([ target => 'init|prepare|create|install', format => FORMAT_TYPE, extractdir => DIRECTORY, fetchdir => DIRECTORY, prefer_bin => BOOL, force => BOOL, verbose => BOOL, ..... ]);"
Installs the current module. This includes fetching it and extracting
it, if this hasn't been done yet, as well as creating a distribution
object for it.
.PP
This means you can pass it more arguments than described above, which
will be passed on to the relevant methods as they are called.
.PP
See \f(CW\*(C`CPANPLUS::Internals::Fetch\*(C'\fR, \f(CW\*(C`CPANPLUS::Internals::Extract\*(C'\fR and
\&\f(CW\*(C`CPANPLUS::Dist\*(C'\fR for details.
.PP
Returns true on success, false on failure.
.PP
Returns a list of module objects the Bundle specifies.
.PP
This requires you to have extracted the bundle already, using the
\&\f(CW\*(C`extract()\*(C'\fR method.
.PP
Returns false on error.
.ie n .SS "$text = $self\->readme"
.el .SS "\f(CW$text\fP = \f(CW$self\fP\->readme"
.IX Subsection "$text = $self->readme"
Fetches the readme belonging to this module and stores it under
\&\f(CW\*(C`$obj\->status\->readme\*(C'\fR. Returns the readme as a string on
success and returns false on failure.
.ie n .SS "$version = $self\->\fIinstalled_version()\fP"
.el .SS "\f(CW$version\fP = \f(CW$self\fP\->\fIinstalled_version()\fP"
.IX Subsection "$version = $self->installed_version()"
Returns the currently installed version of this module, if any.
.ie n .SS "$where = $self\->\fIinstalled_file()\fP"
.el .SS "\f(CW$where\fP = \f(CW$self\fP\->\fIinstalled_file()\fP"
.IX Subsection "$where = $self->installed_file()"
Returns the location of the currently installed file of this module,
if any.
.ie n .SS "$dir = $self\->\fIinstalled_dir()\fP"
.el .SS "\f(CW$dir\fP = \f(CW$self\fP\->\fIinstalled_dir()\fP"
.IX Subsection "$dir = $self->installed_dir()"
Returns the directory (or more accurately, the \f(CW@INC\fR handle) from
which this module was loaded, if any.
.ie n .SS "$bool = $self\->is_uptodate([version => \s-1VERSION_NUMBER\s0])"
.el .SS "\f(CW$bool\fP = \f(CW$self\fP\->is_uptodate([version => \s-1VERSION_NUMBER\s0])"
.IX Subsection "$bool = $self->is_uptodate([version => VERSION_NUMBER])"
Returns a boolean indicating if this module is uptodate or not.
.ie n .SS "$href = $self\->\fIdetails()\fP"
.el .SS "\f(CW$href\fP = \f(CW$self\fP\->\fIdetails()\fP"
.IX Subsection "$href = $self->details()"
Returns a hashref with key/value pairs offering more information about
a particular module. For example, for \f(CW\*(C`Time::HiRes\*(C'\fR it might look like
this:
.PP
.Vb 11
\&    Author                  Jarkko Hietaniemi (jhi@iki.fi)
\&    Description             High resolution time, sleep, and alarm
\&    Development Stage       Released
\&    Installed File          /usr/local/perl/lib/Time/Hires.pm
\&    Interface Style         plain Functions, no references used
\&    Language Used           C and perl, a C compiler will be needed
\&    Package                 Time\-HiRes\-1.65.tar.gz
\&    Public License          Unknown
\&    Support Level           Developer
\&    Version Installed       1.52
\&    Version on CPAN         1.65
.Ve
.ie n .SS "@list = $self\->\fIcontains()\fP"
.el .SS "\f(CW@list\fP = \f(CW$self\fP\->\fIcontains()\fP"
.IX Subsection "@list = $self->contains()"
Returns a list of module objects that represent the modules also
present in the package of this module.
.PP
For example, for \f(CW\*(C`Archive::Tar\*(C'\fR this might return:
.PP
.Vb 3
\&    Archive::Tar
\&    Archive::Tar::Constant
\&    Archive::Tar::File
.Ve
.ie n .SS "@list_of_hrefs = $self\->\fIfetch_report()\fP"
.el .SS "\f(CW@list_of_hrefs\fP = \f(CW$self\fP\->\fIfetch_report()\fP"
.IX Subsection "@list_of_hrefs = $self->fetch_report()"
This function queries the \s-1CPAN\s0 testers database at
\&\fIhttp://testers.cpan.org/\fR for test results of specified module
objects, module names or distributions.
.PP
Look at \fICPANPLUS::Internals::Report::_query_report()\fR for details on
the options you can pass and the return value to expect.
.ie n .SS "$bool = $self\->uninstall([type => [all|man|prog])"
.el .SS "\f(CW$bool\fP = \f(CW$self\fP\->uninstall([type => [all|man|prog])"
.IX Subsection "$bool = $self->uninstall([type => [all|man|prog])"
This function uninstalls the specified module object.
.PP
You can install 2 types of files, either \f(CW\*(C`man\*(C'\fR pages or \f(CW\*(C`prog\*(C'\fRram
files. Alternately you can specify \f(CW\*(C`all\*(C'\fR to uninstall both (which
is the default).
.PP
Returns true on success and false on failure.
.PP
Do note that this does an uninstall via the so-called \f(CW\*(C`.packlist\*(C'\fR,
so if you used a module installer like say, \f(CW\*(C`ports\*(C'\fR or \f(CW\*(C`apt\*(C'\fR, you
should not use this, but use your package manager instead.
.ie n .SS "@modobj = $self\->\fIdistributions()\fP"
.el .SS "\f(CW@modobj\fP = \f(CW$self\fP\->\fIdistributions()\fP"
.IX Subsection "@modobj = $self->distributions()"
Returns a list of module objects representing all releases for this
module on success, false on failure.
.ie n .SS "@list = $self\->files ()"
.el .SS "\f(CW@list\fP = \f(CW$self\fP\->files ()"
.IX Subsection "@list = $self->files ()"
Returns a list of files used by this module, if it is installed.
.ie n .SS "@list = $self\->directory_tree ()"
.el .SS "\f(CW@list\fP = \f(CW$self\fP\->directory_tree ()"
.IX Subsection "@list = $self->directory_tree ()"
Returns a list of directories used by this module.
.ie n .SS "@list = $self\->packlist ()"
.el .SS "\f(CW@list\fP = \f(CW$self\fP\->packlist ()"
.IX Subsection "@list = $self->packlist ()"
Returns the \f(CW\*(C`ExtUtils::Packlist\*(C'\fR object for this module.
.ie n .SS "@list = $self\->validate ()"
.el .SS "\f(CW@list\fP = \f(CW$self\fP\->validate ()"
.IX Subsection "@list = $self->validate ()"
Returns a list of files that are missing for this modules, but
are present in the .packlist file.
.ie n .SS "$bool = $self\->add_to_includepath;"
.el .SS "\f(CW$bool\fP = \f(CW$self\fP\->add_to_includepath;"
.IX Subsection "$bool = $self->add_to_includepath;"
Adds the current modules path to \f(CW@INC\fR and \f(CW$PERL5LIB\fR. This allows
you to add the module from its build dir to your path.
.PP
It also adds the current modules \f(CW\*(C`bin\*(C'\fR and/or \f(CW\*(C`script\*(C'\fR paths to
the \s-1PATH.\s0
.PP
You can reset \f(CW$PATH\fR, \f(CW@INC\fR and \f(CW$PERL5LIB\fR to their original state when you
started the program, by calling:
.PP
.Vb 1
\&    $self\->parent\->flush(\*(Aqlib\*(Aq);
.Ve
.ie n .SS "$path = $self\->\fIbest_path_to_module_build()\fP;"
.el .SS "\f(CW$path\fP = \f(CW$self\fP\->\fIbest_path_to_module_build()\fP;"
.IX Subsection "$path = $self->best_path_to_module_build();"
\&\fB\s-1OBSOLETE\s0\fR
.PP
If a newer version of Module::Build is found in your path, it will
return this \f(CW\*(C`special\*(C'\fR path. If the newest version of \f(CW\*(C`Module::Build\*(C'\fR
is found in your regular \f(CW@INC\fR, the method will return false. This
indicates you do not need to add a special directory to your \f(CW@INC\fR.
.PP
Note that this is only relevant if you're building your own
\&\f(CW\*(C`CPANPLUS::Dist::*\*(C'\fR plugin \*(-- the built-in dist types already have
this taken care of.
.SH "BUG REPORTS"
.IX Header "BUG REPORTS"
Please report bugs or other issues to <bug\-cpanplus@rt.cpan.org<gt>.
.SH "AUTHOR"
.IX Header "AUTHOR"
This module by Jos Boumans <kane@cpan.org>.
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
The \s-1CPAN++\s0 interface (of which this module is a part of) is copyright (c)
2001 \- 2007, Jos Boumans <kane@cpan.org>. All rights reserved.
.PP
This library is free software; you may redistribute and/or modify it
under the same terms as Perl itself.
