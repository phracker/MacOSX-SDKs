.\" Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Syntax::Keyword::Junction 3"
.TH Syntax::Keyword::Junction 3 "2014-07-07" "perl v5.30.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Syntax::Keyword::Junction \- Perl6 style Junction operators in Perl5
.SH "VERSION"
.IX Header "VERSION"
version 0.003008
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use Syntax::Keyword::Junction qw/ all any none one /;
\&
\&  if (any(@grant) eq \*(Aqsu\*(Aq) {
\&    ...
\&  }
\&
\&  if (all($foo, $bar) >= 10) {
\&    ...
\&  }
\&
\&  if (qr/^\ed+$/ == all(@answers)) {
\&    ...
\&  }
\&
\&  if (all(@input) <= @limits) {
\&    ...
\&  }
\&
\&  if (none(@pass) eq \*(Aqpassword\*(Aq) {
\&    ...
\&  }
\&
\&  if (one(@answer) == 42) {
\&    ...
\&  }
.Ve
.PP
or if you want to rename an export, use Sub::Exporter options:
.PP
.Vb 1
\&  use Syntax::Keyword::Junction any => { \-as => \*(Aqrobot_any\*(Aq };
\&
\&  if (robot_any(@grant) eq \*(Aqsu\*(Aq) {
\&    ...
\&  }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This is a lightweight module which provides 'Junction' operators, the most
commonly used being \f(CW\*(C`any\*(C'\fR and \f(CW\*(C`all\*(C'\fR.
.PP
Inspired by the Perl6 design docs,
<http://dev.perl.org/perl6/doc/design/exe/E06.html>.
.PP
Provides a limited subset of the functionality of Quantum::Superpositions,
see \*(L"\s-1SEE ALSO\*(R"\s0 for comment.
.PP
Notice in the \*(L"\s-1SYNOPSIS\*(R"\s0 above, that if you want to match against a
regular expression, you must use \f(CW\*(C`==\*(C'\fR or \f(CW\*(C`!=\*(C'\fR. \fBNot\fR \f(CW\*(C`=~\*(C'\fR or \f(CW\*(C`!~\*(C'\fR. You
must also use a regex object, such as \f(CW\*(C`qr/\ed/\*(C'\fR, not a plain regex such as
\&\f(CW\*(C`/\ed/\*(C'\fR.
.SH "SUBROUTINES"
.IX Header "SUBROUTINES"
.SS "\fBall()\fP"
.IX Subsection "all()"
Returns an object which overloads the following operators:
.PP
.Vb 3
\&  \*(Aq<\*(Aq,  \*(Aq<=\*(Aq, \*(Aq>\*(Aq,  \*(Aq>=\*(Aq, \*(Aq==\*(Aq, \*(Aq!=\*(Aq,
\&  \*(Aqlt\*(Aq, \*(Aqle\*(Aq, \*(Aqgt\*(Aq, \*(Aqge\*(Aq, \*(Aqeq\*(Aq, \*(Aqne\*(Aq,
\&  \*(Aq~~\*(Aq
.Ve
.PP
Returns true only if \fBall\fR arguments test true according to the operator
used.
.SS "\fBany()\fP"
.IX Subsection "any()"
Returns an object which overloads the following operators:
.PP
.Vb 3
\&  \*(Aq<\*(Aq,  \*(Aq<=\*(Aq, \*(Aq>\*(Aq,  \*(Aq>=\*(Aq, \*(Aq==\*(Aq, \*(Aq!=\*(Aq,
\&  \*(Aqlt\*(Aq, \*(Aqle\*(Aq, \*(Aqgt\*(Aq, \*(Aqge\*(Aq, \*(Aqeq\*(Aq, \*(Aqne\*(Aq,
\&  \*(Aq~~\*(Aq
.Ve
.PP
Returns true if \fBany\fR argument tests true according to the operator used.
.SS "\fBnone()\fP"
.IX Subsection "none()"
Returns an object which overloads the following operators:
.PP
.Vb 3
\&  \*(Aq<\*(Aq,  \*(Aq<=\*(Aq, \*(Aq>\*(Aq,  \*(Aq>=\*(Aq, \*(Aq==\*(Aq, \*(Aq!=\*(Aq,
\&  \*(Aqlt\*(Aq, \*(Aqle\*(Aq, \*(Aqgt\*(Aq, \*(Aqge\*(Aq, \*(Aqeq\*(Aq, \*(Aqne\*(Aq,
\&  \*(Aq~~\*(Aq
.Ve
.PP
Returns true only if \fBno\fR argument tests true according to the operator
used.
.SS "\fBone()\fP"
.IX Subsection "one()"
Returns an object which overloads the following operators:
.PP
.Vb 3
\&  \*(Aq<\*(Aq,  \*(Aq<=\*(Aq, \*(Aq>\*(Aq,  \*(Aq>=\*(Aq, \*(Aq==\*(Aq, \*(Aq!=\*(Aq,
\&  \*(Aqlt\*(Aq, \*(Aqle\*(Aq, \*(Aqgt\*(Aq, \*(Aqge\*(Aq, \*(Aqeq\*(Aq, \*(Aqne\*(Aq,
\&  \*(Aq~~\*(Aq
.Ve
.PP
Returns true only if \fBone and only one\fR argument tests true according to
the operator used.
.SH "ALTERING JUNCTIONS"
.IX Header "ALTERING JUNCTIONS"
You cannot alter junctions.  Instead, you can create new junctions out of old
junctions.  You can do this by calling the \f(CW\*(C`values\*(C'\fR method on a junction.
.PP
.Vb 2
\& my $numbers = any(qw/1 2 3 4 5/);
\& print $numbers == 3 ? \*(AqYes\*(Aq : \*(AqNo\*(Aq;   # Yes
\&
\& $numbers = any( grep { $_ != 3 } $numbers\->values );
\& print $numbers == 3 ? \*(AqYes\*(Aq : \*(AqNo\*(Aq;   # No
.Ve
.PP
You can also use the \f(CW\*(C`map\*(C'\fR method:
.PP
.Vb 2
\& my $numbers = any(qw/1 2 3 4 5/);
\& my $prime   = $numbers\->map( \e&is_prime );
\&
\& say for $prime\->values; # prints 0, 1, 1, 0, 1
.Ve
.SH "EXPORT"
.IX Header "EXPORT"
\&'all', 'any', 'none', 'one', as requested.
.PP
All subroutines can be called by its fully qualified name, if you don't
want to export them.
.PP
.Vb 1
\&  use Syntax::Keyword::Junction;
\&
\&  if (Syntax::Keyword::Junction::any( @questions )) {
\&    ...
\&  }
.Ve
.SH "WARNING"
.IX Header "WARNING"
When comparing against a regular expression, you must remember to use a
regular expression object: \f(CW\*(C`qr/\ed/\*(C'\fR \fBNot\fR \f(CW\*(C`/d/\*(C'\fR. You must also use either
\&\f(CW\*(C`==\*(C'\fR or \f(CW\*(C`!=\*(C'\fR. This is because \f(CW\*(C`=~\*(C'\fR and \f(CW\*(C`!~\*(C'\fR cannot be overridden.
.SH "TO DO"
.IX Header "TO DO"
Add overloading for arithmetic operators, such that this works:
.PP
.Vb 1
\&  $result = any(2,3,4) * 2;
\&
\&  if ($result == 8) {...}
.Ve
.SH "SEE ALSO"
.IX Header "SEE ALSO"
This module is actually a fork of Perl6::Junction with very few
(initial) changes.  The reason being that we want to avoid the
incendiary name containing Perl6.
.PP
Quantum::Superpositions provides the same functionality as this, and
more. However, this module provides this limited functionality at a much
greater runtime speed, with my benchmarks showing between 500% and 6000%
improvement.
.PP
<http://dev.perl.org/perl6/doc/design/exe/E06.html> \- \*(L"The Wonderful World
of Junctions\*(R".
.SH "AUTHORS"
.IX Header "AUTHORS"
.IP "\(bu" 4
Arthur Axel \*(L"fREW\*(R" Schmidt <frioux+cpan@gmail.com>
.IP "\(bu" 4
Carl Franks
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is copyright (c) 2014 by Arthur Axel \*(L"fREW\*(R" Schmidt.
.PP
This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.
