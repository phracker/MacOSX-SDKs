.\" Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "PPI::Element 3"
.TH PPI::Element 3 "2019-07-09" "perl v5.30.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
PPI::Element \- The abstract Element class, a base for all source objects
.SH "INHERITANCE"
.IX Header "INHERITANCE"
.Vb 1
\&  PPI::Element is the root of the PDOM tree
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The abstract \f(CW\*(C`PPI::Element\*(C'\fR serves as a base class for all source-related
objects, from a single whitespace token to an entire document. It provides
a basic set of methods to provide a common interface and basic
implementations.
.SH "METHODS"
.IX Header "METHODS"
.SS "significant"
.IX Subsection "significant"
Because we treat whitespace and other non-code items as Tokens (in order to
be able to \*(L"round trip\*(R" the PPI::Document back to a file) the
\&\f(CW\*(C`significant\*(C'\fR method allows us to distinguish between tokens that form a
part of the code, and tokens that aren't significant, such as whitespace,
\&\s-1POD,\s0 or the portion of a file after (and including) the \f(CW\*(C`_\|_END_\|_\*(C'\fR token.
.PP
Returns true if the Element is significant, or false it not.
.SS "class"
.IX Subsection "class"
The \f(CW\*(C`class\*(C'\fR method is provided as a convenience, and really does nothing
more than returning \f(CW\*(C`ref($self)\*(C'\fR. However, some people have found that
they appreciate the laziness of \f(CW\*(C`$Foo\->class eq \*(Aqwhatever\*(Aq\*(C'\fR, so I
have caved to popular demand and included it.
.PP
Returns the class of the Element as a string
.SS "tokens"
.IX Subsection "tokens"
The \f(CW\*(C`tokens\*(C'\fR method returns a list of PPI::Token objects for the
Element, essentially getting back that part of the document as if it had
not been lexed.
.PP
This also means there are no Statements and no Structures in the list,
just the Token classes.
.SS "content"
.IX Subsection "content"
For \fBany\fR \f(CW\*(C`PPI::Element\*(C'\fR, the \f(CW\*(C`content\*(C'\fR method will reconstitute the
base code for it as a single string. This method is also the method used
for overloading stringification. When an Element is used in a double-quoted
string for example, this is the method that is called.
.PP
\&\fB\s-1WARNING:\s0\fR
.PP
You should be aware that because of the way that here-docs are handled, any
here-doc content is not included in \f(CW\*(C`content\*(C'\fR, and as such you should
\&\fBnot\fR eval or execute the result if it contains any PPI::Token::HereDoc.
.PP
The PPI::Document method \f(CW\*(C`serialize\*(C'\fR should be used to stringify a \s-1PDOM\s0
document into something that can be executed as expected.
.PP
Returns the basic code as a string (excluding here-doc content).
.SS "parent"
.IX Subsection "parent"
Elements themselves are not intended to contain other Elements, that is
left to the PPI::Node abstract class, a subclass of \f(CW\*(C`PPI::Element\*(C'\fR.
However, all Elements can be contained \fBwithin\fR a parent Node.
.PP
If an Element is within a parent Node, the \f(CW\*(C`parent\*(C'\fR method returns the
Node.
.ie n .SS "descendant_of $element"
.el .SS "descendant_of \f(CW$element\fP"
.IX Subsection "descendant_of $element"
Answers whether a \f(CW\*(C`PPI::Element\*(C'\fR is contained within another one.
.PP
\&\f(CW\*(C`PPI::Element\*(C'\fRs are considered to be descendants of themselves.
.ie n .SS "ancestor_of $element"
.el .SS "ancestor_of \f(CW$element\fP"
.IX Subsection "ancestor_of $element"
Answers whether a \f(CW\*(C`PPI::Element\*(C'\fR is contains another one.
.PP
\&\f(CW\*(C`PPI::Element\*(C'\fRs are considered to be ancestors of themselves.
.SS "statement"
.IX Subsection "statement"
For a \f(CW\*(C`PPI::Element\*(C'\fR that is contained (at some depth) within a
PPI::Statement, the \f(CW\*(C`statement\*(C'\fR method will return the first parent
Statement object lexically 'above' the Element.
.PP
Returns a PPI::Statement object, which may be the same Element if the
Element is itself a PPI::Statement object.
.PP
Returns false if the Element is not within a Statement and is not itself
a Statement.
.SS "top"
.IX Subsection "top"
For a \f(CW\*(C`PPI::Element\*(C'\fR that is contained within a \s-1PDOM\s0 tree, the \f(CW\*(C`top\*(C'\fR method
will return the top-level Node in the tree. Most of the time this should be
a PPI::Document object, however this will not always be so. For example,
if a subroutine has been removed from its Document, to be moved to another
Document.
.PP
Returns the top-most \s-1PDOM\s0 object, which may be the same Element, if it is
not within any parent \s-1PDOM\s0 object.
.SS "document"
.IX Subsection "document"
For an Element that is contained within a PPI::Document object,
the \f(CW\*(C`document\*(C'\fR method will return the top-level Document for the Element.
.PP
Returns the PPI::Document for this Element, or false if the Element is not
contained within a Document.
.SS "next_sibling"
.IX Subsection "next_sibling"
All PPI::Node objects (specifically, our parent Node) contain a number of
\&\f(CW\*(C`PPI::Element\*(C'\fR objects. The \f(CW\*(C`next_sibling\*(C'\fR method returns the \f(CW\*(C`PPI::Element\*(C'\fR
immediately after the current one, or false if there is no next sibling.
.SS "snext_sibling"
.IX Subsection "snext_sibling"
As per the other 's' methods, the \f(CW\*(C`snext_sibling\*(C'\fR method returns the next
\&\fBsignificant\fR sibling of the \f(CW\*(C`PPI::Element\*(C'\fR object.
.PP
Returns a \f(CW\*(C`PPI::Element\*(C'\fR object, or false if there is no 'next' significant
sibling.
.SS "previous_sibling"
.IX Subsection "previous_sibling"
All PPI::Node objects (specifically, our parent Node) contain a number of
\&\f(CW\*(C`PPI::Element\*(C'\fR objects. The \f(CW\*(C`previous_sibling\*(C'\fR method returns the Element
immediately before the current one, or false if there is no 'previous'
\&\f(CW\*(C`PPI::Element\*(C'\fR object.
.SS "sprevious_sibling"
.IX Subsection "sprevious_sibling"
As per the other 's' methods, the \f(CW\*(C`sprevious_sibling\*(C'\fR method returns
the previous \fBsignificant\fR sibling of the \f(CW\*(C`PPI::Element\*(C'\fR object.
.PP
Returns a \f(CW\*(C`PPI::Element\*(C'\fR object, or false if there is no 'previous' significant
sibling.
.SS "first_token"
.IX Subsection "first_token"
As a support method for higher-order algorithms that deal specifically with
tokens and actual Perl content, the \f(CW\*(C`first_token\*(C'\fR method finds the first
PPI::Token object within or equal to this one.
.PP
That is, if called on a PPI::Node subclass, it will descend until it
finds a PPI::Token. If called on a PPI::Token object, it will return
the same object.
.PP
Returns a PPI::Token object, or dies on error (which should be extremely
rare and only occur if an illegal empty PPI::Statement exists below the
current Element somewhere.)
.SS "last_token"
.IX Subsection "last_token"
As a support method for higher-order algorithms that deal specifically with
tokens and actual Perl content, the \f(CW\*(C`last_token\*(C'\fR method finds the last
PPI::Token object within or equal to this one.
.PP
That is, if called on a PPI::Node subclass, it will descend until it
finds a PPI::Token. If called on a PPI::Token object, it will return
the itself.
.PP
Returns a PPI::Token object, or dies on error (which should be extremely
rare and only occur if an illegal empty PPI::Statement exists below the
current Element somewhere.)
.SS "next_token"
.IX Subsection "next_token"
As a support method for higher-order algorithms that deal specifically with
tokens and actual Perl content, the \f(CW\*(C`next_token\*(C'\fR method finds the
PPI::Token object that is immediately after the current Element, even if
it is not within the same parent PPI::Node as the one for which the
method is being called.
.PP
Note that this is \fBnot\fR defined as a PPI::Token\-specific method,
because it can be useful to find the next token that is after, say, a
PPI::Statement, although obviously it would be useless to want the
next token after a PPI::Document.
.PP
Returns a PPI::Token object, or false if there are no more tokens after
the Element.
.SS "previous_token"
.IX Subsection "previous_token"
As a support method for higher-order algorithms that deal specifically with
tokens and actual Perl content, the \f(CW\*(C`previous_token\*(C'\fR method finds the
PPI::Token object that is immediately before the current Element, even
if it is not within the same parent PPI::Node as this one.
.PP
Note that this is not defined as a PPI::Token\-only method, because it can
be useful to find the token is before, say, a PPI::Statement, although
obviously it would be useless to want the next token before a
PPI::Document.
.PP
Returns a PPI::Token object, or false if there are no more tokens before
the \f(CW\*(C`Element\*(C'\fR.
.SS "clone"
.IX Subsection "clone"
As per the Clone module, the \f(CW\*(C`clone\*(C'\fR method makes a perfect copy of
an Element object. In the generic case, the implementation is done using
the Clone module's mechanism itself. In higher-order cases, such as for
Nodes, there is more work involved to keep the parent-child links intact.
.ie n .SS "insert_before @Elements"
.el .SS "insert_before \f(CW@Elements\fP"
.IX Subsection "insert_before @Elements"
The \f(CW\*(C`insert_before\*(C'\fR method allows you to insert lexical perl content, in
the form of \f(CW\*(C`PPI::Element\*(C'\fR objects, before the calling \f(CW\*(C`Element\*(C'\fR. You
need to be very careful when modifying perl code, as it's easy to break
things.
.PP
In its initial incarnation, this method allows you to insert a single
Element, and will perform some basic checking to prevent you inserting
something that would be structurally wrong (in \s-1PDOM\s0 terms).
.PP
In future, this method may be enhanced to allow the insertion of multiple
Elements, inline-parsed code strings or PPI::Document::Fragment objects.
.PP
Returns true if the Element was inserted, false if it can not be inserted,
or \f(CW\*(C`undef\*(C'\fR if you do not provide a \f(CW\*(C`PPI::Element\*(C'\fR object as a parameter.
.ie n .SS "insert_after @Elements"
.el .SS "insert_after \f(CW@Elements\fP"
.IX Subsection "insert_after @Elements"
The \f(CW\*(C`insert_after\*(C'\fR method allows you to insert lexical perl content, in
the form of \f(CW\*(C`PPI::Element\*(C'\fR objects, after the calling \f(CW\*(C`Element\*(C'\fR. You need
to be very careful when modifying perl code, as it's easy to break things.
.PP
In its initial incarnation, this method allows you to insert a single
Element, and will perform some basic checking to prevent you inserting
something that would be structurally wrong (in \s-1PDOM\s0 terms).
.PP
In future, this method may be enhanced to allow the insertion of multiple
Elements, inline-parsed code strings or PPI::Document::Fragment objects.
.PP
Returns true if the Element was inserted, false if it can not be inserted,
or \f(CW\*(C`undef\*(C'\fR if you do not provide a \f(CW\*(C`PPI::Element\*(C'\fR object as a parameter.
.SS "remove"
.IX Subsection "remove"
For a given \f(CW\*(C`PPI::Element\*(C'\fR, the \f(CW\*(C`remove\*(C'\fR method will remove it from its
parent \fBintact\fR, along with all of its children.
.PP
Returns the \f(CW\*(C`Element\*(C'\fR itself as a convenience, or \f(CW\*(C`undef\*(C'\fR if an error
occurs while trying to remove the \f(CW\*(C`Element\*(C'\fR.
.SS "delete"
.IX Subsection "delete"
For a given \f(CW\*(C`PPI::Element\*(C'\fR, the \f(CW\*(C`delete\*(C'\fR method will remove it from its
parent, immediately deleting the \f(CW\*(C`Element\*(C'\fR and all of its children (if it
has any).
.PP
Returns true if the \f(CW\*(C`Element\*(C'\fR was successfully deleted, or \f(CW\*(C`undef\*(C'\fR if
an error occurs while trying to remove the \f(CW\*(C`Element\*(C'\fR.
.ie n .SS "replace $Element"
.el .SS "replace \f(CW$Element\fP"
.IX Subsection "replace $Element"
Although some higher level class support more exotic forms of replace,
at the basic level the \f(CW\*(C`replace\*(C'\fR method takes a single \f(CW\*(C`Element\*(C'\fR as
an argument and replaces the current \f(CW\*(C`Element\*(C'\fR with it.
.PP
To prevent accidental damage to code, in this initial implementation the
replacement element \fBmust\fR be of the same class (or a subclass) as the
one being replaced.
.SS "location"
.IX Subsection "location"
If the Element exists within a PPI::Document that has
indexed the Element locations using \f(CW\*(C`PPI::Document::index_locations\*(C'\fR, the
\&\f(CW\*(C`location\*(C'\fR method will return the location of the first character of the
Element within the Document.
.PP
Returns the location as a reference to a five-element array in the form \f(CW\*(C`[
$line, $rowchar, $col, $logical_line, $logical_file_name ]\*(C'\fR. The values are in
a human format, with the first character of the file located at \f(CW\*(C`[ 1, 1, 1, ?,
\&\*(Aqsomething\*(Aq ]\*(C'\fR.
.PP
The second and third numbers are similar, except that the second is the
literal horizontal character, and the third is the visual column, taking
into account tabbing (see \*(L"tab_width [ \f(CW$width\fR ]\*(R" in PPI::Document).
.PP
The fourth number is the line number, taking into account any \f(CW\*(C`#line\*(C'\fR
directives.  The fifth element is the name of the file that the element was
found in, if available, taking into account any \f(CW\*(C`#line\*(C'\fR directives.
.PP
Returns \f(CW\*(C`undef\*(C'\fR on error, or if the PPI::Document object has not been
indexed.
.SS "line_number"
.IX Subsection "line_number"
If the Element exists within a PPI::Document that has indexed the Element
locations using \f(CW\*(C`PPI::Document::index_locations\*(C'\fR, the \f(CW\*(C`line_number\*(C'\fR method
will return the line number of the first character of the Element within the
Document.
.PP
Returns \f(CW\*(C`undef\*(C'\fR on error, or if the PPI::Document object has not been
indexed.
.SS "column_number"
.IX Subsection "column_number"
If the Element exists within a PPI::Document that has indexed the Element
locations using \f(CW\*(C`PPI::Document::index_locations\*(C'\fR, the \f(CW\*(C`column_number\*(C'\fR method
will return the column number of the first character of the Element within the
Document.
.PP
Returns \f(CW\*(C`undef\*(C'\fR on error, or if the PPI::Document object has not been
indexed.
.SS "visual_column_number"
.IX Subsection "visual_column_number"
If the Element exists within a PPI::Document that has indexed the Element
locations using \f(CW\*(C`PPI::Document::index_locations\*(C'\fR, the \f(CW\*(C`visual_column_number\*(C'\fR
method will return the visual column number of the first character of the
Element within the Document, according to the value of
\&\*(L"tab_width [ \f(CW$width\fR ]\*(R" in PPI::Document.
.PP
Returns \f(CW\*(C`undef\*(C'\fR on error, or if the PPI::Document object has not been
indexed.
.SS "logical_line_number"
.IX Subsection "logical_line_number"
If the Element exists within a PPI::Document that has indexed the Element
locations using \f(CW\*(C`PPI::Document::index_locations\*(C'\fR, the \f(CW\*(C`logical_line_number\*(C'\fR
method will return the line number of the first character of the Element within
the Document, taking into account any \f(CW\*(C`#line\*(C'\fR directives.
.PP
Returns \f(CW\*(C`undef\*(C'\fR on error, or if the PPI::Document object has not been
indexed.
.SS "logical_filename"
.IX Subsection "logical_filename"
If the Element exists within a PPI::Document that has indexed the Element
locations using \f(CW\*(C`PPI::Document::index_locations\*(C'\fR, the \f(CW\*(C`logical_filename\*(C'\fR
method will return the logical file name containing the first character of the
Element within the Document, taking into account any \f(CW\*(C`#line\*(C'\fR directives.
.PP
Returns \f(CW\*(C`undef\*(C'\fR on error, or if the PPI::Document object has not been
indexed.
.SH "TO DO"
.IX Header "TO DO"
It would be nice if \f(CW\*(C`location\*(C'\fR could be used in an ad-hoc manner. That is,
if called on an Element within a Document that has not been indexed, it will
do a one-off calculation to find the location. It might be very painful if
someone started using it a lot, without remembering to index the document,
but it would be handy for things that are only likely to use it once, such
as error handlers.
.SH "SUPPORT"
.IX Header "SUPPORT"
See the support section in the main module.
.SH "AUTHOR"
.IX Header "AUTHOR"
Adam Kennedy <adamk@cpan.org>
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright 2001 \- 2011 Adam Kennedy.
.PP
This program is free software; you can redistribute
it and/or modify it under the same terms as Perl itself.
.PP
The full text of the license can be found in the
\&\s-1LICENSE\s0 file included with this module.
