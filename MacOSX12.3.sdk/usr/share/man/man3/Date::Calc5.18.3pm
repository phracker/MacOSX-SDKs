.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Date::Calc 3"
.TH Date::Calc 3 "2009-10-30" "perl v5.18.4" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Date::Calc \- Gregorian calendar date calculations
.SH "MOTTO"
.IX Header "MOTTO"
Keep it small, fast and simple
.SH "PREFACE"
.IX Header "PREFACE"
This package consists of a C library and a Perl module (which uses
the C library, internally) for all kinds of date calculations based
on the Gregorian calendar (the one used in all western countries today),
thereby complying with all relevant norms and standards: \s-1ISO/R\s0\ 2015\-1971,
\&\s-1DIN\s0\ 1355 and, to some extent, \s-1ISO\s0\ 8601 (where applicable).
.PP
(See also http://www.engelschall.com/u/sb/download/Date\-Calc/DIN1355/
for a scan of part of the \*(L"\s-1DIN\s0\ 1355\*(R" document (in German)).
.PP
The module of course handles year numbers of 2000 and above correctly
(\*(L"Year 2000\*(R" or \*(L"Y2K\*(R" compliance) \*(-- actually all year numbers from 1
to the largest positive integer representable on your system (which
is at least 32767) can be dealt with.
.PP
This is not true, however, for the import/export functions in this
package which are an interface to the internal \s-1POSIX\s0 date and time
functions of your system, which can only cover dates in the following
ranges:
.PP
.Vb 3
\& 01\-Jan\-1970 00:00:00 GMT .. 19\-Jan\-2038 03:14:07 GMT [Unix etc.]
\& 01\-Jan\-1904 00:00:00 LT  .. 06\-Feb\-2040 06:28:15 LT  [MacOS Classic]
\& (LT = local time)
.Ve
.PP
Note that this package projects the Gregorian calendar back until the
year 1\ A.D. \*(-- even though the Gregorian calendar was only adopted
in 1582, mostly by the Catholic European countries, in obedience to the
corresponding decree of Pope Gregory\ \s-1XIII\s0 in that year.
.PP
Some (mainly protestant) countries continued to use the Julian calendar
(used until then) until as late as the beginning of the 20th century.
.PP
Finally, note that this package is not intended to do everything you could
ever imagine automagically for you; it is rather intended to serve as a
toolbox (in the best of \s-1UNIX\s0 spirit and traditions) which should, however,
always get you where you want to go.
.PP
See the section \*(L"\s-1RECIPES\*(R"\s0 at the bottom of this document for solutions
to common problems!
.PP
If nevertheless you can't figure out how to solve a particular problem,
please let me know! (See e\-mail address at the end of this document.)
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 10
\&  use Date::Calc qw(
\&      Days_in_Year
\&      Days_in_Month
\&      Weeks_in_Year
\&      leap_year
\&      check_date
\&      check_time
\&      check_business_date
\&      Day_of_Year
\&      Date_to_Days
\&      Day_of_Week
\&      Week_Number
\&      Week_of_Year
\&      Monday_of_Week
\&      Nth_Weekday_of_Month_Year
\&      Standard_to_Business
\&      Business_to_Standard
\&      Delta_Days
\&      Delta_DHMS
\&      Delta_YMD
\&      Delta_YMDHMS
\&      N_Delta_YMD
\&      N_Delta_YMDHMS
\&      Normalize_DHMS
\&      Add_Delta_Days
\&      Add_Delta_DHMS
\&      Add_Delta_YM
\&      Add_Delta_YMD
\&      Add_Delta_YMDHMS
\&      Add_N_Delta_YMD
\&      Add_N_Delta_YMDHMS
\&      System_Clock
\&      Today
\&      Now
\&      Today_and_Now
\&      This_Year
\&      Gmtime
\&      Localtime
\&      Mktime
\&      Timezone
\&      Date_to_Time
\&      Time_to_Date
\&      Easter_Sunday
\&      Decode_Month
\&      Decode_Day_of_Week
\&      Decode_Language
\&      Decode_Date_EU
\&      Decode_Date_US
\&      Fixed_Window
\&      Moving_Window
\&      Compress
\&      Uncompress
\&      check_compressed
\&      Compressed_to_Text
\&      Date_to_Text
\&      Date_to_Text_Long
\&      English_Ordinal
\&      Calendar
\&      Month_to_Text
\&      Day_of_Week_to_Text
\&      Day_of_Week_Abbreviation
\&      Language_to_Text
\&      Language
\&      Languages
\&      Decode_Date_EU2
\&      Decode_Date_US2
\&      Parse_Date
\&      ISO_LC
\&      ISO_UC
\&  );
\&
\&  use Date::Calc qw(:all);
\&
\&  Days_in_Year
\&      $days = Days_in_Year($year,$month);
\&
\&  Days_in_Month
\&      $days = Days_in_Month($year,$month);
\&
\&  Weeks_in_Year
\&      $weeks = Weeks_in_Year($year);
\&
\&  leap_year
\&      if (leap_year($year))
\&
\&  check_date
\&      if (check_date($year,$month,$day))
\&
\&  check_time
\&      if (check_time($hour,$min,$sec))
\&
\&  check_business_date
\&      if (check_business_date($year,$week,$dow))
\&
\&  Day_of_Year
\&      $doy = Day_of_Year($year,$month,$day);
\&
\&  Date_to_Days
\&      $days = Date_to_Days($year,$month,$day);
\&
\&  Day_of_Week
\&      $dow = Day_of_Week($year,$month,$day);
\&
\&  Week_Number
\&      $week = Week_Number($year,$month,$day);          # DEPRECATED
\&
\&  Week_of_Year
\&      ($week,$year) = Week_of_Year($year,$month,$day); # RECOMMENDED
\&      $week = Week_of_Year($year,$month,$day);         # DANGEROUS
\&
\&  Monday_of_Week
\&      ($year,$month,$day) = Monday_of_Week($week,$year);
\&
\&  Nth_Weekday_of_Month_Year
\&      if (($year,$month,$day) =
\&      Nth_Weekday_of_Month_Year($year,$month,$dow,$n))
\&
\&  Standard_to_Business
\&      ($year,$week,$dow) =
\&      Standard_to_Business($year,$month,$day);
\&
\&  Business_to_Standard
\&      ($year,$month,$day) =
\&      Business_to_Standard($year,$week,$dow);
\&
\&  Delta_Days
\&      $Dd = Delta_Days($year1,$month1,$day1,
\&                       $year2,$month2,$day2);
\&
\&  Delta_DHMS
\&      ($Dd,$Dh,$Dm,$Ds) =
\&      Delta_DHMS($year1,$month1,$day1, $hour1,$min1,$sec1,
\&                 $year2,$month2,$day2, $hour2,$min2,$sec2);
\&
\&  Delta_YMD
\&      ($Dy,$Dm,$Dd) =
\&      Delta_YMD($year1,$month1,$day1,
\&                $year2,$month2,$day2);
\&
\&  Delta_YMDHMS
\&      ($D_y,$D_m,$D_d, $Dh,$Dm,$Ds) =
\&      Delta_YMDHMS($year1,$month1,$day1, $hour1,$min1,$sec1,
\&                   $year2,$month2,$day2, $hour2,$min2,$sec2);
\&
\&  N_Delta_YMD
\&      ($Dy,$Dm,$Dd) =
\&      N_Delta_YMD($year1,$month1,$day1,
\&                  $year2,$month2,$day2);
\&
\&  N_Delta_YMDHMS
\&      ($D_y,$D_m,$D_d, $Dhh,$Dmm,$Dss) =
\&      N_Delta_YMDHMS($year1,$month1,$day1, $hour1,$min1,$sec1,
\&                     $year2,$month2,$day2, $hour2,$min2,$sec2);
\&
\&  Normalize_DHMS
\&      ($Dd,$Dh,$Dm,$Ds) =
\&      Normalize_DHMS($Dd,$Dh,$Dm,$Ds);
\&
\&  Add_Delta_Days
\&      ($year,$month,$day) =
\&      Add_Delta_Days($year,$month,$day,
\&                     $Dd);
\&
\&  Add_Delta_DHMS
\&      ($year,$month,$day, $hour,$min,$sec) =
\&      Add_Delta_DHMS($year,$month,$day, $hour,$min,$sec,
\&                     $Dd,$Dh,$Dm,$Ds);
\&
\&  Add_Delta_YM
\&      ($year,$month,$day) =
\&      Add_Delta_YM($year,$month,$day,
\&                   $Dy,$Dm);
\&
\&  Add_Delta_YMD
\&      ($year,$month,$day) =
\&      Add_Delta_YMD($year,$month,$day,
\&                    $Dy,$Dm,$Dd);
\&
\&  Add_Delta_YMDHMS
\&      ($year,$month,$day, $hour,$min,$sec) =
\&      Add_Delta_YMDHMS($year,$month,$day, $hour,$min,$sec,
\&                       $D_y,$D_m,$D_d, $Dh,$Dm,$Ds);
\&
\&  Add_N_Delta_YMD
\&      ($year,$month,$day) =
\&      Add_N_Delta_YMD($year,$month,$day,
\&                      $Dy,$Dm,$Dd);
\&
\&  Add_N_Delta_YMDHMS
\&      ($year,$month,$day, $hour,$min,$sec) =
\&      Add_N_Delta_YMDHMS($year,$month,$day, $hour,$min,$sec,
\&                         $D_y,$D_m,$D_d, $Dhh,$Dmm,$Dss);
\&
\&  System_Clock
\&      ($year,$month,$day, $hour,$min,$sec, $doy,$dow,$dst) =
\&      System_Clock([$gmt]);
\&
\&  Today
\&      ($year,$month,$day) = Today([$gmt]);
\&
\&  Now
\&      ($hour,$min,$sec) = Now([$gmt]);
\&
\&  Today_and_Now
\&      ($year,$month,$day, $hour,$min,$sec) = Today_and_Now([$gmt]);
\&
\&  This_Year
\&      $year = This_Year([$gmt]);
\&
\&  Gmtime
\&      ($year,$month,$day, $hour,$min,$sec, $doy,$dow,$dst) =
\&      Gmtime([time]);
\&
\&  Localtime
\&      ($year,$month,$day, $hour,$min,$sec, $doy,$dow,$dst) =
\&      Localtime([time]);
\&
\&  Mktime
\&      $time = Mktime($year,$month,$day, $hour,$min,$sec);
\&
\&  Timezone
\&      ($D_y,$D_m,$D_d, $Dh,$Dm,$Ds, $dst) = Timezone([time]);
\&
\&  Date_to_Time
\&      $time = Date_to_Time($year,$month,$day, $hour,$min,$sec);
\&
\&  Time_to_Date
\&      ($year,$month,$day, $hour,$min,$sec) = Time_to_Date([time]);
\&
\&  Easter_Sunday
\&      ($year,$month,$day) = Easter_Sunday($year);
\&
\&  Decode_Month
\&      if ($month = Decode_Month($string[,$lang]))
\&
\&  Decode_Day_of_Week
\&      if ($dow = Decode_Day_of_Week($string[,$lang]))
\&
\&  Decode_Language
\&      if ($lang = Decode_Language($string))
\&
\&  Decode_Date_EU
\&      if (($year,$month,$day) = Decode_Date_EU($string[,$lang]))
\&
\&  Decode_Date_US
\&      if (($year,$month,$day) = Decode_Date_US($string[,$lang]))
\&
\&  Fixed_Window
\&      $year = Fixed_Window($yy);
\&
\&  Moving_Window
\&      $year = Moving_Window($yy);
\&
\&  Compress
\&      $date = Compress($year,$month,$day);
\&
\&  Uncompress
\&      if (($century,$year,$month,$day) = Uncompress($date))
\&
\&  check_compressed
\&      if (check_compressed($date))
\&
\&  Compressed_to_Text
\&      $string = Compressed_to_Text($date[,$lang]);
\&
\&  Date_to_Text
\&      $string = Date_to_Text($year,$month,$day[,$lang]);
\&
\&  Date_to_Text_Long
\&      $string = Date_to_Text_Long($year,$month,$day[,$lang]);
\&
\&  English_Ordinal
\&      $string = English_Ordinal($number);
\&
\&  Calendar
\&      $string = Calendar($year,$month[,$orthodox[,$lang]]);
\&
\&  Month_to_Text
\&      $string = Month_to_Text($month[,$lang]);
\&
\&  Day_of_Week_to_Text
\&      $string = Day_of_Week_to_Text($dow[,$lang]);
\&
\&  Day_of_Week_Abbreviation
\&      $string = Day_of_Week_Abbreviation($dow[,$lang]);
\&
\&  Language_to_Text
\&      $string = Language_to_Text($lang);
\&
\&  Language
\&      $lang = Language();
\&      Language($lang);               # DEPRECATED
\&      $oldlang = Language($newlang); # DEPRECATED
\&
\&  Languages
\&      $max_lang = Languages();
\&
\&  Decode_Date_EU2
\&      if (($year,$month,$day) = Decode_Date_EU2($string[,$lang]))
\&
\&  Decode_Date_US2
\&      if (($year,$month,$day) = Decode_Date_US2($string[,$lang]))
\&
\&  Parse_Date
\&      if (($year,$month,$day) = Parse_Date($string[,$lang]))
\&
\&  ISO_LC
\&      $lower = ISO_LC($string);
\&
\&  ISO_UC
\&      $upper = ISO_UC($string);
\&
\&  Version
\&      $string = Date::Calc::Version();
.Ve
.SH "IMPORTANT NOTES"
.IX Header "IMPORTANT NOTES"
(See the section \*(L"\s-1RECIPES\*(R"\s0 at the bottom of this document for
solutions to common problems!)
.IP "\(bu" 2
\&\*(L"Year 2000\*(R" (\*(L"Y2K\*(R") compliance
.Sp
The upper limit for any year number in this module is only given
by the size of the largest positive integer that can be represented
in a variable of the C type \*(L"int\*(R" on your system, which is at least
32767, according to the \s-1ANSI C\s0 standard (exceptions see below).
.Sp
In order to simplify calculations, this module projects the gregorian
calendar back until the year 1\ A.D. \*(-- i.e., back \fB\s-1BEYOND\s0\fR the
year 1582 when this calendar was first decreed by the Catholic Pope
Gregory\ \s-1XIII\s0!
.Sp
Therefore, \fB\s-1BE SURE TO ALWAYS SPECIFY \*(L"1998\*(R" WHEN YOU MEAN \*(L"1998\*(R"\s0\fR,
for instance, and \fB\s-1DO NOT WRITE \*(L"98\*(R" INSTEAD\s0\fR, because this will
in fact perform a calculation based on the year \*(L"98\*(R" A.D. and
\&\fB\s-1NOT\s0\fR \*(L"1998\*(R"!
.Sp
An exception from this rule are the functions which contain the
word \*(L"compress\*(R" in their names (which can only handle years between
1970 and 2069 and also accept the abbreviations \*(L"00\*(R" to \*(L"99\*(R"), and
the functions whose names begin with \*(L"Decode_Date_\*(R" (which translate
year numbers below 100 using a technique known as \*(L"moving window\*(R").
.Sp
If you want to convert a two-digit year number into a full-fledged,
four-digit (at least for some years to come \f(CW\*(C`;\-)\*(C'\fR) year number,
use the two functions \*(L"\fIFixed_Window()\fR\*(R" and \*(L"\fIMoving_Window()\fR\*(R"
(see their description further below).
.Sp
Note also that the following import/export functions (which are
interfaces to the \s-1POSIX\s0 functions \*(L"\fItime()\fR\*(R", \*(L"\fIgmtime()\fR\*(R", \*(L"\fIlocaltime()\fR\*(R"
and \*(L"\fImktime()\fR\*(R" or (the last two) substitutes for the \s-1BSD\s0 function
\&\*(L"\fItimegm()\fR\*(R" and the \s-1POSIX\s0 function \*(L"\fIgmtime()\fR\*(R") have a very limited
range of representable dates (in contrast to all other functions
in this package, which cover virtually any date including and
after January\ 1st\ 1\ A.D.):
.Sp
.Vb 11
\&              System_Clock()
\&              Today()
\&              Now()
\&              Today_and_Now()
\&              This_Year()
\&              Gmtime()
\&              Localtime()
\&              Mktime()
\&              Timezone()
\&              Date_to_Time()
\&              Time_to_Date()
.Ve
.Sp
These functions can only deal with dates in the range from
01\-Jan\-1970\ 00:00:00\ \s-1GMT\s0 to 19\-Jan\-2038\ 03:14:07\ \s-1GMT
\&\s0(the latter limit is only authoritative on 32\ bit systems,
however, and can (in principle, through a few code changes)
be extended somewhat \f(CW\*(C`:\-)\*(C'\fR on 64\ bit systems).
.Sp
On MacOS Classic, the valid range of dates is between
(both included) 01\-Jan\-1904\ 00:00:00 (local time)
to 06\-Feb\-2040\ 06:28:15 (local time).
.Sp
Note further that the function \*(L"\fIEaster_Sunday()\fR\*(R" can only
be used for years in the range 1583 to 2299.
.IP "\(bu" 2
\&\s-1POSIX\s0 functions
.Sp
Note that the following functions
.Sp
.Vb 4
\&              Gmtime()
\&              Localtime()
\&              Mktime()
\&              Timezone()
.Ve
.Sp
are actually wrappers around or based upon the corresponding
\&\s-1POSIX\s0 functions \*(L"\fItime()\fR\*(R", \*(L"\fIgmtime()\fR\*(R", \*(L"\fIlocaltime()\fR\*(R" and \*(L"\fImktime()\fR\*(R".
.Sp
As such, they depend on local settings of the underlying machine
such as e.g. the system clock, the time zone and the locale.
.Sp
Their results can therefore sometimes be unexpected or counter-intuitive.
.Sp
Therefore, no support can be provided for these functions.
.Sp
They are supplied \*(L"as is\*(R", purely for the sake of interoperability.
.Sp
Use at your own risk. (You have been warned!)
.IP "\(bu" 2
First index
.Sp
\&\fB\s-1ALL\s0\fR ranges in this module start with "\f(CW1\fR", \fB\s-1NOT\s0\fR "\f(CW0\fR"!
.Sp
I.e., the day of month, day of week, day of year, month of year,
week of year, first valid year number and language \fB\s-1ALL\s0\fR start
counting at one, \fB\s-1NOT\s0\fR zero!
.Sp
The only exception is the function "\f(CW\*(C`Week_Number()\*(C'\fR\*(L", which may
in fact return \*(R"\f(CW0\fR" when the given date actually lies in the
last week of the \fB\s-1PREVIOUS\s0\fR year, and of course the numbers for
hours (\f(CW0..23\fR), minutes (\f(CW0..59\fR) and seconds (\f(CW0..59\fR).
.IP "\(bu" 2
Function naming conventions
.Sp
Function names completely in lower case indicate a boolean return value.
.IP "\(bu" 2
Boolean values
.Sp
Boolean values returned from functions in this module are always a
numeric zero ("\f(CW0\fR\*(L") for \*(R"false\*(L" and a numeric one (\*(R"\f(CW1\fR\*(L") for \*(R"true".
.IP "\(bu" 2
Exception handling
.Sp
The functions in this module will usually die with a corresponding error
message if their input parameters, intermediate results or output values
are out of range.
.Sp
The following functions handle errors differently:
.Sp
.Vb 4
\&  \-  check_date()
\&  \-  check_time()
\&  \-  check_business_date()
\&  \-  check_compressed()
.Ve
.Sp
(which return a \*(L"false\*(R" return value when the given input does not represent
a valid date or time),
.Sp
.Vb 1
\&  \-  Nth_Weekday_of_Month_Year()
.Ve
.Sp
(which returns an empty list if the requested 5th day of week does not exist),
.Sp
.Vb 6
\&  \-  Decode_Month()
\&  \-  Decode_Day_of_Week()
\&  \-  Decode_Language()
\&  \-  Fixed_Window()
\&  \-  Moving_Window()
\&  \-  Compress()
.Ve
.Sp
(which return "\f(CW0\fR" upon failure or invalid input), and
.Sp
.Vb 6
\&  \-  Decode_Date_EU()
\&  \-  Decode_Date_US()
\&  \-  Decode_Date_EU2()
\&  \-  Decode_Date_US2()
\&  \-  Parse_Date()
\&  \-  Uncompress()
.Ve
.Sp
(which return an empty list upon failure or invalid input).
.Sp
Note that you can always catch an exception thrown by any of the functions
in this module and handle it yourself by enclosing the function call in an
"\f(CW\*(C`eval\*(C'\fR\*(L" with curly brackets and checking the special variable \*(R"\f(CW$@\fR"
(see \*(L"eval\*(R" in \fIperlfunc\fR\|(1) for details).
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
.IP "\(bu" 2
\&\f(CW\*(C`use Date::Calc qw( Days_in_Year Days_in_Month ... );\*(C'\fR
.IP "\(bu" 2
\&\f(CW\*(C`use Date::Calc qw(:all);\*(C'\fR
.Sp
You can either specify the functions you want to import explicitly by
enumerating them between the parentheses of the "\f(CW\*(C`qw()\*(C'\fR\*(L" operator, or
you can use the \*(R"\f(CW\*(C`:all\*(C'\fR" tag instead to import \fB\s-1ALL\s0\fR available functions.
.IP "\(bu" 2
\&\f(CW\*(C`$days = Days_in_Year($year,$month);\*(C'\fR
.Sp
This function returns the sum of the number of days in the months starting
with January up to and including "\f(CW$month\fR\*(L" in the given year \*(R"\f(CW$year\fR".
.Sp
I.e., "\f(CW\*(C`Days_in_Year(1998,1)\*(C'\fR\*(L" returns \*(R"\f(CW31\fR\*(L", \*(R"\f(CW\*(C`Days_in_Year(1998,2)\*(C'\fR\*(L"
returns \*(R"\f(CW59\fR\*(L", \*(R"\f(CW\*(C`Days_in_Year(1998,3)\*(C'\fR\*(L" returns \*(R"\f(CW90\fR", and so on.
.Sp
Note that "\f(CW\*(C`Days_in_Year($year,12)\*(C'\fR\*(L" returns the number of days in the
given year \*(R"\f(CW$year\fR\*(L", i.e., either \*(R"\f(CW365\fR\*(L" or \*(R"\f(CW366\fR".
.IP "\(bu" 2
\&\f(CW\*(C`$days = Days_in_Month($year,$month);\*(C'\fR
.Sp
This function returns the number of days in the given month "\f(CW$month\fR\*(L" of
the given year \*(R"\f(CW$year\fR".
.Sp
The year must always be supplied, even though it is only needed when the
month is February, in order to determine whether it is a leap year or not.
.Sp
I.e., "\f(CW\*(C`Days_in_Month(1998,1)\*(C'\fR\*(L" returns \*(R"\f(CW31\fR\*(L", \*(R"\f(CW\*(C`Days_in_Month(1998,2)\*(C'\fR\*(L"
returns \*(R"\f(CW28\fR\*(L", \*(R"\f(CW\*(C`Days_in_Month(2000,2)\*(C'\fR\*(L" returns \*(R"\f(CW29\fR\*(L",
\&\*(R"\f(CW\*(C`Days_in_Month(1998,3)\*(C'\fR\*(L" returns \*(R"\f(CW31\fR", and so on.
.IP "\(bu" 2
\&\f(CW\*(C`$weeks = Weeks_in_Year($year);\*(C'\fR
.Sp
This function returns the number of weeks in the given year "\f(CW$year\fR\*(L",
i.e., either \*(R"\f(CW52\fR\*(L" or \*(R"\f(CW53\fR".
.IP "\(bu" 2
\&\f(CW\*(C`if (leap_year($year))\*(C'\fR
.Sp
This function returns \*(L"true\*(R" ("\f(CW1\fR\*(L") if the given year \*(R"\f(CW$year\fR\*(L" is
a leap year and \*(R"false\*(L" (\*(R"\f(CW0\fR") otherwise.
.IP "\(bu" 2
\&\f(CW\*(C`if (check_date($year,$month,$day))\*(C'\fR
.Sp
This function returns \*(L"true\*(R" ("\f(CW1\fR\*(L") if the given three numerical
values \*(R"\f(CW$year\fR\*(L", \*(R"\f(CW$month\fR\*(L" and \*(R"\f(CW$day\fR\*(L" constitute a valid date,
and \*(R"false\*(L" (\*(R"\f(CW0\fR") otherwise.
.IP "\(bu" 2
\&\f(CW\*(C`if (check_time($hour,$min,$sec))\*(C'\fR
.Sp
This function returns \*(L"true\*(R" ("\f(CW1\fR\*(L") if the given three numerical
values \*(R"\f(CW$hour\fR\*(L", \*(R"\f(CW$min\fR\*(L" and \*(R"\f(CW$sec\fR" constitute a valid time
(\f(CW\*(C`0 <= $hour < 24\*(C'\fR, \f(CW\*(C`0 <= $min < 60\*(C'\fR and
\&\f(CW\*(C`0 <= $sec < 60\*(C'\fR), and \*(L"false\*(R" ("\f(CW0\fR") otherwise.
.IP "\(bu" 2
\&\f(CW\*(C`if (check_business_date($year,$week,$dow))\*(C'\fR
.Sp
This function returns \*(L"true\*(R" ("\f(CW1\fR\*(L") if the given three numerical
values \*(R"\f(CW$year\fR\*(L", \*(R"\f(CW$week\fR\*(L" and \*(R"\f(CW$dow\fR\*(L" constitute a valid date
in business format, and \*(R"false\*(L" (\*(R"\f(CW0\fR") otherwise.
.Sp
\&\fBBeware\fR that this function does \fB\s-1NOT\s0\fR compute whether a given date
is a business day (i.e., Monday to Friday)!
.Sp
To do so, use "\f(CW\*(C`(Day_of_Week($year,$month,$day) < 6)\*(C'\fR" instead.
.IP "\(bu" 2
\&\f(CW\*(C`$doy = Day_of_Year($year,$month,$day);\*(C'\fR
.Sp
This function returns the (relative) number of the day of the given date
in the given year.
.Sp
E.g., "\f(CW\*(C`Day_of_Year($year,1,1)\*(C'\fR\*(L" returns \*(R"\f(CW1\fR\*(L",
\&\*(R"\f(CW\*(C`Day_of_Year($year,2,1)\*(C'\fR\*(L" returns \*(R"\f(CW32\fR\*(L", and
\&\*(R"\f(CW\*(C`Day_of_Year($year,12,31)\*(C'\fR\*(L" returns either \*(R"\f(CW365\fR\*(L" or \*(R"\f(CW366\fR".
.Sp
The day of year is sometimes also referred to as the Julian day (or date),
although it has nothing to do with the Julian calendar, the calendar which
was used before the Gregorian calendar.
.Sp
In order to convert the number returned by this function back into a
date, use the function "\f(CW\*(C`Add_Delta_Days()\*(C'\fR" (described further below),
as follows:
.Sp
.Vb 2
\&  $doy = Day_of_Year($year,$month,$day);
\&  ($year,$month,$day) = Add_Delta_Days($year,1,1, $doy \- 1);
.Ve
.IP "\(bu" 2
\&\f(CW\*(C`$days = Date_to_Days($year,$month,$day);\*(C'\fR
.Sp
This function returns the (absolute) number of the day of the given date,
where counting starts at the 1st of January of the year 1\ A.D.
.Sp
I.e., "\f(CW\*(C`Date_to_Days(1,1,1)\*(C'\fR\*(L" returns \*(R"\f(CW1\fR\*(L", \*(R"\f(CW\*(C`Date_to_Days(1,12,31)\*(C'\fR\*(L"
returns \*(R"\f(CW365\fR\*(L", \*(R"\f(CW\*(C`Date_to_Days(2,1,1)\*(C'\fR\*(L" returns \*(R"\f(CW366\fR\*(L",
\&\*(R"\f(CW\*(C`Date_to_Days(1998,5,1)\*(C'\fR\*(L" returns \*(R"\f(CW729510\fR", and so on.
.Sp
This is sometimes also referred to (not quite correctly) as the Julian
date (or day). This may cause confusion, because also the number of the
day in a year (from 1 to 365 or 366) is frequently called the \*(L"Julian day\*(R".
.Sp
More confusing still, this has nothing to do with the Julian calendar,
which was used \fB\s-1BEFORE\s0\fR the Gregorian calendar.
.Sp
The Julian calendar was named after famous Julius Caesar, who had
instituted it in Roman times. The Julian calendar is less precise than
the Gregorian calendar because it has too many leap years compared to
the true mean length of a year (but the Gregorian calendar also still
has one day too much every 5000 years). Anyway, the Julian calendar was
better than what existed before, because rulers had often changed the
calendar used until then in arbitrary ways, in order to lengthen their
own reign, for instance.
.Sp
In order to convert the number returned by this function back into
a date, use the function "\f(CW\*(C`Add_Delta_Days()\*(C'\fR" (described further
below), as follows:
.Sp
.Vb 2
\&  $days = Date_to_Days($year,$month,$day);
\&  ($year,$month,$day) = Add_Delta_Days(1,1,1, $days \- 1);
.Ve
.IP "\(bu" 2
\&\f(CW\*(C`$dow = Day_of_Week($year,$month,$day);\*(C'\fR
.Sp
This function returns the number of the day of week of the given date.
.Sp
The function returns "\f(CW1\fR\*(L" for Monday, \*(R"\f(CW2\fR\*(L" for Tuesday and so on
until \*(R"\f(CW7\fR" for Sunday.
.Sp
Note that in the Hebrew calendar (on which the Christian calendar is based),
the week starts with Sunday and ends with the Sabbath or Saturday (where
according to the Genesis (as described in the Bible) the Lord rested from
creating the world).
.Sp
In medieval times, Catholic Popes have decreed the Sunday to be the official
day of rest, in order to dissociate the Christian from the Hebrew belief.
.Sp
It appears that this actually happened with the Emperor Constantin, who
converted to Christianity but still worshipped the Sun god and therefore
moved the Christian sabbath to the day of the Sun.
.Sp
Nowadays, the Sunday \fB\s-1AND\s0\fR the Saturday are commonly considered (and
used as) days of rest, usually referred to as the \*(L"week-end\*(R".
.Sp
Consistent with this practice, current norms and standards (such as
\&\s-1ISO/R\s0\ 2015\-1971, \s-1DIN\s0\ 1355 and \s-1ISO\s0\ 8601) define the Monday
as the first day of the week.
.IP "\(bu" 2
\&\f(CW\*(C`$week = Week_Number($year,$month,$day);\*(C'\fR
.Sp
This function returns the number of the week the given date lies in.
.Sp
If the given date lies in the \fB\s-1LAST\s0\fR week of the \fB\s-1PREVIOUS\s0\fR year,
"\f(CW0\fR" is returned.
.Sp
If the given date lies in the \fB\s-1FIRST\s0\fR week of the \fB\s-1NEXT\s0\fR year,
"\f(CW\*(C`Weeks_in_Year($year) + 1\*(C'\fR" is returned.
.IP "\(bu" 2
\&\f(CW\*(C`($week,$year) = Week_of_Year($year,$month,$day);\*(C'\fR
.Sp
This function returns the number of the week the given date lies in,
as well as the year that week belongs to.
.Sp
I.e., if the given date lies in the \fB\s-1LAST\s0\fR week of the \fB\s-1PREVIOUS\s0\fR year,
"\f(CW\*(C`(Weeks_in_Year($year\-1), $year\-1)\*(C'\fR" is returned.
.Sp
If the given date lies in the \fB\s-1FIRST\s0\fR week of the \fB\s-1NEXT\s0\fR year,
"\f(CW\*(C`(1, $year+1)\*(C'\fR" is returned.
.Sp
Otherwise, "\f(CW\*(C`(Week_Number($year,$month,$day), $year)\*(C'\fR" is returned.
.IP "\(bu" 2
\&\f(CW\*(C`$week = Week_of_Year($year,$month,$day);\*(C'\fR
.Sp
In scalar context, this function returns just the week number. This
allows you to write "\f(CW\*(C`$week = Week_of_Year($year,$month,$day);\*(C'\fR\*(L"
instead of \*(R"\f(CW\*(C`($week) = Week_of_Year($year,$month,$day);\*(C'\fR\*(L" (note
the parentheses around \*(R"\f(CW$week\fR").
.Sp
If the given date lies in the \fB\s-1LAST\s0\fR week of the \fB\s-1PREVIOUS\s0\fR year,
"\f(CW\*(C`Weeks_in_Year($year\-1)\*(C'\fR" is returned.
.Sp
If the given date lies in the \fB\s-1FIRST\s0\fR week of the \fB\s-1NEXT\s0\fR year,
"\f(CW1\fR" is returned.
.Sp
Otherwise the return value is identical with that of
"\f(CW\*(C`Week_Number($year,$month,$day)\*(C'\fR".
.Sp
\&\fB\s-1BEWARE\s0\fR that using this function in scalar context is a \fB\s-1DANGEROUS\s0\fR
feature, because without knowing which year the week belongs to, you
might inadvertently assume the wrong one!
.Sp
If for instance you are iterating through an interval of dates, you might
assume that the week always belongs to the same year as the given date,
which unfortunately is \fB\s-1WRONG\s0\fR in some cases!
.Sp
In many years, the 31st of December for instance belongs to week number
one of the \fB\s-1FOLLOWING\s0\fR year. Assuming that the year is the same as your
date (31st of December, in this example), sends you back to the first week
of the \fB\s-1CURRENT\s0\fR year \- the Monday of which, by the way, in case of bad
luck, might actually lie in the year \fB\s-1BEFORE\s0\fR the current year!
.Sp
This actually happens in 2002, for example.
.Sp
So you always need to provide the correct corresponding year number
by other means, keeping track of it yourself.
.Sp
In case you do not understand this, never mind, but then simply
\&\fB\s-1DO NOT USE\s0\fR this function in scalar context!
.IP "\(bu" 2
\&\f(CW\*(C`($year,$month,$day) = Monday_of_Week($week,$year);\*(C'\fR
.Sp
This function returns the date of the first day of the given week, i.e.,
the Monday.
.Sp
"\f(CW$year\fR\*(L" must be greater than or equal to \*(R"\f(CW1\fR\*(L", and \*(R"\f(CW$week\fR\*(L" must
lie in the range \*(R"\f(CW1\fR\*(L" to \*(R"\f(CW\*(C`Weeks_in_Year($year)\*(C'\fR".
.Sp
Note that you can write
"\f(CW\*(C`($year,$month,$day) = Monday_of_Week(Week_of_Year($year,$month,$day));\*(C'\fR"
in order to calculate the date of the Monday of the same week as the
given date.
.Sp
If you want to calculate any other day of week in the same week as a
given date, use
.Sp
.Vb 1
\&  @date = Add_Delta_Days(Monday_of_Week(Week_of_Year(@date)),$offset);
.Ve
.Sp
where \f(CW\*(C`$offset = 1\*(C'\fR for Tuesday, \f(CW2\fR for Wednesday etc.
.IP "\(bu" 2
\&\f(CW\*(C`if (($year,$month,$day) = Nth_Weekday_of_Month_Year($year,$month,$dow,$n))\*(C'\fR
.Sp
This function calculates the date of the "\f(CW$n\fR\*(L"th day of week \*(R"\f(CW$dow\fR\*(L"
in the given month \*(R"\f(CW$month\fR\*(L" and year \*(R"\f(CW$year\fR"; such as, for example,
the 3rd Thursday of a given month and year.
.Sp
This can be used to send a notification mail to the members of a group
which meets regularly on every 3rd Thursday of a month, for instance.
.Sp
(See the section \*(L"\s-1RECIPES\*(R"\s0 near the end of this document for a code
snippet to actually do so.)
.Sp
"\f(CW$year\fR\*(L" must be greater than or equal to \*(R"\f(CW1\fR\*(L", \*(R"\f(CW$month\fR\*(L" must lie
in the range \*(R"\f(CW1\fR\*(L" to \*(R"\f(CW12\fR\*(L", \*(R"\f(CW$dow\fR\*(L" must lie in the range \*(R"\f(CW1\fR\*(L"
to \*(R"\f(CW7\fR\*(L" and \*(R"\f(CW$n\fR\*(L" must lie in the range \*(R"\f(CW1\fR\*(L" to \*(R"\f(CW5\fR", or a fatal
error (with appropriate error message) occurs.
.Sp
The function returns an empty list when the 5th of a given day of week
does not exist in the given month and year.
.IP "\(bu" 2
\&\f(CW\*(C`($year,$week,$dow) = Standard_to_Business($year,$month,$day);\*(C'\fR
.Sp
This function converts a given date from standard notation (year,
month, day (of month)) to business notation (year, week, day of week).
.IP "\(bu" 2
\&\f(CW\*(C`($year,$month,$day) = Business_to_Standard($year,$week,$dow);\*(C'\fR
.Sp
This function converts a given date from business notation (year,
week, day of week) to standard notation (year, month, day (of month)).
.IP "\(bu" 2
\&\f(CW\*(C`$Dd = Delta_Days($year1,$month1,$day1, $year2,$month2,$day2);\*(C'\fR
.Sp
This function returns the difference in days between the two given
dates.
.Sp
The result is positive if the two dates are in chronological order,
i.e., if date #1 comes chronologically \fB\s-1BEFORE\s0\fR date #2, and negative
if the order of the two dates is reversed.
.Sp
The result is zero if the two dates are identical.
.IP "\(bu" 2
\&\f(CW\*(C`($Dd,$Dh,$Dm,$Ds) = Delta_DHMS($year1,$month1,$day1, $hour1,$min1,$sec1, $year2,$month2,$day2, $hour2,$min2,$sec2);\*(C'\fR
.Sp
This function returns the difference in days, hours, minutes and seconds
between the two given dates with times.
.Sp
All four return values will be positive if the two dates are in chronological
order, i.e., if date #1 comes chronologically \fB\s-1BEFORE\s0\fR date #2, and negative
(in all four return values!) if the order of the two dates is reversed.
.Sp
This is so that the two functions "\f(CW\*(C`Delta_DHMS()\*(C'\fR\*(L" and \*(R"\f(CW\*(C`Add_Delta_DHMS()\*(C'\fR"
(description see further below) are complementary, i.e., mutually inverse:
.Sp
.Vb 1
\&  Add_Delta_DHMS(@date1,@time1, Delta_DHMS(@date1,@time1, @date2,@time2))
.Ve
.Sp
yields "\f(CW\*(C`(@date2,@time2)\*(C'\fR" again, whereas
.Sp
.Vb 2
\&  Add_Delta_DHMS(@date2,@time2,
\&      map(\-$_, Delta_DHMS(@date1,@time1, @date2,@time2)))
.Ve
.Sp
yields "\f(CW\*(C`(@date1,@time1)\*(C'\fR", and
.Sp
.Vb 1
\&  Delta_DHMS(@date1,@time1, Add_Delta_DHMS(@date1,@time1, @delta))
.Ve
.Sp
yields "\f(CW@delta\fR" again.
.Sp
The result is zero (in all four return values) if the two dates and times
are identical.
.IP "\(bu" 2
\&\f(CW\*(C`($Dy,$Dm,$Dd) = Delta_YMD($year1,$month1,$day1, $year2,$month2,$day2);\*(C'\fR
.Sp
This function returns the vector
.Sp
.Vb 1
\&    ( $year2 \- $year1, $month2 \- $month1, $day2 \- $day1 )
.Ve
.Sp
This is called the \*(L"one-by-one\*(R" semantics.
.Sp
Adding the result of this function to the first date always yields the
second date again, and adding the negative result (where the signs of
all elements of the result vector have been flipped) to the second
date gives the first date. See also the description of the function
\&\*(L"\fIAdd_Delta_YMD()\fR\*(R" further below.
.Sp
Example:
.Sp
.Vb 1
\&  (6,2,\-30) == Delta_YMD(1996,1,31, 2002,3,1]);
\&
\&  [1996,1,31] + ( 6, 2,\-30) = [2002,3, 1]
\&  [2002,3, 1] + (\-6,\-2, 30) = [1996,1,31]
.Ve
.Sp
An error occurs if any of the two given dates is invalid.
.IP "\(bu" 2
\&\f(CW\*(C`($D_y,$D_m,$D_d, $Dh,$Dm,$Ds) = Delta_YMDHMS($year1,$month1,$day1, $hour1,$min1,$sec1, $year2,$month2,$day2, $hour2,$min2,$sec2);\*(C'\fR
.Sp
This function is based on the function \*(L"\fIDelta_YMD()\fR\*(R" above but additionally
calculates the time difference. When a carry over from the time difference
occurs, the value of "\f(CW$D_d\fR" is adjusted accordingly, thus giving the
correct total date/time difference.
.Sp
Arguments are expected to be in chronological order to yield a (usually)
positive result.
.Sp
In any case, adding the result of this function to the first date/time value
(\f(CW\*(C`$year1,$month1,$day1,\*(C'\fR \f(CW\*(C`$hour1,$min1,$sec1\*(C'\fR) always gives the second
date/time value (\f(CW\*(C`$year2,$month2,$day2,\*(C'\fR \f(CW\*(C`$hour2,$min2,$sec2\*(C'\fR) again,
and adding the negative result (with the signs of all elements of the result
vector flipped) to the second date/time value gives the first date/time value.
.Sp
See the function \*(L"\fIAdd_Delta_YMDHMS()\fR\*(R" further below for adding a date/time
value and a date/time difference.
.Sp
An error occurs if any of the given two date/time values is invalid.
.IP "\(bu" 2
\&\f(CW\*(C`($Dy,$Dm,$Dd) = N_Delta_YMD($year1,$month1,$day1, $year2,$month2,$day2);\*(C'\fR
.Sp
This function returns the difference between the two given dates in a
more intuitive way (as far as possible \- more on that see a bit further
below) than the function \*(L"\fIDelta_YMD()\fR\*(R" described above.
.Sp
The \*(L"N\*(R" which precedes its name is meant to signify \*(L"new\*(R" or \*(L"normalized\*(R".
.Sp
This function is loosely based on recipe #17 b) (see the section \*(L"\s-1RECIPES\*(R"\s0
below near the end of this document).
.Sp
However, the code of recipe #17 b) actually does not treat positive and
negative values symmetrically and consistently.
.Sp
This new routine does.
.Sp
The return values of this function are guaranteed to all have the same
sign (or to be zero). This is why this function is called \*(L"normalized\*(R".
.Sp
Moreover, the results are guaranteed to be \*(L"minimal\*(R", in the sense that
\&\f(CW\*(C`|$Dm| < 12\*(C'\fR and \f(CW\*(C`|$Dd| < 31\*(C'\fR (which is equivalent to \f(CW$Dm\fR
lying in the range \f(CW\*(C`[\-11..+11]\*(C'\fR and \f(CW$Dd\fR lying in the range \f(CW\*(C`[\-30..+30]\*(C'\fR).
.Sp
When the results are applied (i.e., added) to the first given date in a
left-to-right order, the second given date is guaranteed to be obtained,
provided that intermediary results are truncated, as done by the function
\&\*(L"\fIAdd_Delta_YM()\fR\*(R" (see further below), i.e., that invalid intermediate dates
such as e.g. [2009,2,31] will automatically be transformed into [2009,2,28]
(and not \*(L"wrapped\*(R" into the next month, e.g. to [2009,3,3]).
.Sp
This is called the \*(L"left-to-right with truncation\*(R" semantics.
.Sp
Note that reversing the order of the given dates and reversing the sign of
each of the result values will not always add up.
.Sp
Consider the dates [2008,2,29] and [2009,2,1]: their difference is (0,11,3)
([2008,2,29] plus 11 months is [2009,1,29], which plus 3 days is [2009,2,1]),
but the difference between [2009,2,1] and [2008,2,29] is (0,\-11,\-1), and
not (0,\-11,\-3) ([2009,2,1] minus 11 months is [2008,3,1], which minus one
day is [2008,2,29]).
.Sp
Another example: The difference between [1996,2,29] and [1997,2,28] is (1,0,0)
(observe the truncation of the invalid date [1997,2,29] to [1997,2,28] here!),
whereas the difference between [1997,2,28] and [1996,2,29] is (0,\-11,\-28)
([1997,2,28] minus 11 months is [1996,3,28], which minus 28 days is not
[1996,3,0] but of course [1996,2,29]).
.Sp
\&\*(L"Benign\*(R" examples such as for instance the difference between [1964,1,3]
and [2009,9,10] are completely symmetrical: The difference in this example
is (45,8,7), whereas the difference between [2009,9,10] and [1964,1,3] is
(\-45,\-8,\-7), as would normally be expected. In this example, the result
is also the same as the one returned by \*(L"\fIDelta_YMD()\fR\*(R".
.Sp
All these counter-intuitive effects are due to the fact that months
(and due to leap years, also years) do not correspond to a fixed number
of days, so the semantics of \*(L"plus one month\*(R" or \*(L"plus one year\*(R" are in
fact undefined.
.Sp
The present function is an attempt to provide a definition which is
intuitive most of the time, and at least consistent the rest of the
time.
.Sp
Other definitions are of course possible, but most often lead to
contradictions (e.g., the results and the given first date do not
add up to the second given date).
.Sp
See the file \*(L"datecalc.pl\*(R" in the \*(L"examples\*(R" subdirectory of this
distribution for a way to play around with this function, or go to
http://www.engelschall.com/u/sb/datecalc/ for the online version.
.Sp
An error occurs if any of the two given dates is invalid, or if any
intermediate result leads to an invalid date (this does not apply
to truncation, however, as explained above).
.IP "\(bu" 2
\&\f(CW\*(C`($D_y,$D_m,$D_d, $Dhh,$Dmm,$Dss) = N_Delta_YMDHMS($year1,$month1,$day1, $hour1,$min1,$sec1, $year2,$month2,$day2, $hour2,$min2,$sec2);\*(C'\fR
.Sp
This function essentially does the same as the function \*(L"\fIN_Delta_YMD()\fR\*(R"
described immediately above, except that also the difference in hours,
minutes and seconds is taken into account.
.Sp
This function is loosely based on recipe #17 a) (see the section \*(L"\s-1RECIPES\*(R"\s0
below near the end of this document).
.Sp
However, the code of recipe #17 a) actually does not treat positive and
negative values symmetrically and consistently.
.Sp
This new routine does.
.Sp
The return values of this function (including the time differences)
are guaranteed to all have the same sign (or to be zero). This is the
reason for the \*(L"N\*(R" that precedes the name of this function, which
is intended to mean \*(L"normalized\*(R" (or \*(L"new\*(R").
.Sp
Moreover, the results are guaranteed to be \*(L"minimal\*(R", in the sense that
\&\f(CW\*(C`|$D_m| < 12\*(C'\fR, \f(CW\*(C`|$D_d| < 31\*(C'\fR, \f(CW\*(C`|$Dhh| < 24\*(C'\fR, \f(CW\*(C`|$Dmm| < 60\*(C'\fR
and \f(CW\*(C`|$Dss| < 60\*(C'\fR (which is equivalent to \f(CW$D_m\fR lying in the range
\&\f(CW\*(C`[\-11..+11]\*(C'\fR, \f(CW$D_d\fR lying in the range \f(CW\*(C`[\-30..+30]\*(C'\fR, \f(CW$Dhh\fR lying in the
range \f(CW\*(C`[\-23..+23]\*(C'\fR, and \f(CW$Dmm\fR and \f(CW$Dss\fR both lying in the range \f(CW\*(C`[\-59..+59]\*(C'\fR).
.IP "\(bu" 2
\&\f(CW\*(C`($Dd,$Dh,$Dm,$Ds) = Normalize_DHMS($Dd,$Dh,$Dm,$Ds);\*(C'\fR
.Sp
This function takes four arbitrary values for days, hours, minutes
and seconds (which may have different signs) and renormalizes them
so that the values for hours, minutes and seconds will lie in the
ranges \f(CW\*(C`[\-23..23]\*(C'\fR, \f(CW\*(C`[\-59..59]\*(C'\fR and \f(CW\*(C`[\-59..59]\*(C'\fR, respectively,
and so that all four values have the same sign (or are zero).
.Sp
The given values are left untouched, i.e., unchanged.
.IP "\(bu" 2
\&\f(CW\*(C`($year,$month,$day) = Add_Delta_Days($year,$month,$day, $Dd);\*(C'\fR
.Sp
This function has two principal uses:
.Sp
First, it can be used to calculate a new date, given an initial date and
an offset (which may be positive or negative) in days, in order to answer
questions like \*(L"today plus 90 days \*(-- which date gives that?\*(R".
.Sp
(In order to add a weeks offset, simply multiply the weeks offset with
"\f(CW7\fR" and use that as your days offset.)
.Sp
Second, it can be used to convert the canonical representation of a date,
i.e., the number of that day (where counting starts at the 1st of January
in 1\ A.D.), back into a date given as year, month and day.
.Sp
Because counting starts at "\f(CW1\fR\*(L", you will actually have to subtract \*(R"\f(CW1\fR"
from the canonical date in order to get back the original date:
.Sp
.Vb 1
\&  $canonical = Date_to_Days($year,$month,$day);
\&
\&  ($year,$month,$day) = Add_Delta_Days(1,1,1, $canonical \- 1);
.Ve
.Sp
Moreover, this function is the inverse of the function "\f(CW\*(C`Delta_Days()\*(C'\fR":
.Sp
.Vb 1
\&  Add_Delta_Days(@date1, Delta_Days(@date1, @date2))
.Ve
.Sp
yields "\f(CW@date2\fR" again, whereas
.Sp
.Vb 1
\&  Add_Delta_Days(@date2, \-Delta_Days(@date1, @date2))
.Ve
.Sp
yields "\f(CW@date1\fR", and
.Sp
.Vb 1
\&  Delta_Days(@date1, Add_Delta_Days(@date1, $delta))
.Ve
.Sp
yields "\f(CW$delta\fR" again.
.IP "\(bu" 2
\&\f(CW\*(C`($year,$month,$day, $hour,$min,$sec) = Add_Delta_DHMS($year,$month,$day, $hour,$min,$sec, $Dd,$Dh,$Dm,$Ds);\*(C'\fR
.Sp
This function serves to add a days, hours, minutes and seconds offset to a
given date and time, in order to answer questions like \*(L"today and now plus
7 days but minus 5 hours and then plus 30 minutes, what date and time gives
that?\*(R":
.Sp
.Vb 1
\&  ($y,$m,$d,$H,$M,$S) = Add_Delta_DHMS(Today_and_Now(), +7,\-5,+30,0);
.Ve
.IP "\(bu" 2
\&\f(CW\*(C`($year,$month,$day) = Add_Delta_YM($year,$month,$day, $Dy,$Dm);\*(C'\fR
.Sp
This function can be used to add a year and/or month offset to a given
date.
.Sp
In contrast to the function described immediately below
("\f(CW\*(C`Add_Delta_YMD()\*(C'\fR\*(L"), this function does no \*(R"wrapping" into
the next month if the day happens to lie outside the valid range
for the resulting year and month (after adding the year and month
offsets). Instead, it simply truncates the day to the last possible
day of the resulting month.
.Sp
Examples:
.Sp
Adding an offset of 0 years, 1 month to the date [1999,1,31] would result
in the (invalid) date [1999,2,31]. The function replaces this result by
the (valid) date [1999,2,28].
.Sp
Adding an offset of 1 year, 1 month to the same date [1999,1,31] as above
would result in the (still invalid) date [2000,2,31]. The function replaces
this result by the valid date [2000,2,29] (because 2000 is a leap year).
.Sp
Note that the year and month offsets can be negative, and that they can
have different signs.
.Sp
If you want to additionally add a days offset, use the function
"\f(CW\*(C`Add_Delta_Days()\*(C'\fR\*(L" before or after calling \*(R"\f(CW\*(C`Add_Delta_YM()\*(C'\fR":
.Sp
.Vb 2
\&  @date2 = Add_Delta_Days( Add_Delta_YM(@date1, $Dy,$Dm), $Dd );
\&  @date2 = Add_Delta_YM( Add_Delta_Days(@date1, $Dd), $Dy,$Dm );
.Ve
.Sp
Note that your result may depend on the order in which you call
these two functions!
.Sp
Consider the date [1999,2,28] and the offsets 0 years, 1 month
and 1 day:
.Sp
[1999,2,28] plus one month is [1999,3,28], plus one day is
[1999,3,29]. [1999,2,28] plus one day is [1999,3,1], plus
one month is [1999,4,1].
.Sp
(Which is also the reason why the "\f(CW\*(C`Add_Delta_YM()\*(C'\fR" function
does not allow to add a days offset, because this would actually
require \s-1TWO\s0 functions: One for adding the days offset \s-1BEFORE\s0 and
one for adding it \s-1AFTER\s0 applying the year/month offsets.)
.Sp
An error occurs if the initial date is not valid.
.Sp
Note that "\f(CW\*(C`Add_Delta_YM( Add_Delta_YM(@date, $Dy,$Dm), \-$Dy,\-$Dm );\*(C'\fR\*(L"
will not, in general, return the original date \*(R"\f(CW@date\fR" (consider
the examples given above!).
.IP "\(bu" 2
\&\f(CW\*(C`($year,$month,$day) = Add_Delta_YMD($year,$month,$day, $Dy,$Dm,$Dd);\*(C'\fR
.Sp
This function serves to add a years, months and days offset to a given date.
.Sp
(In order to add a weeks offset, simply multiply the weeks offset with "\f(CW7\fR"
and add this number to your days offset.)
.Sp
Note that the three offsets for years, months and days are applied
independently from each other. This also allows them to have
different signs.
.Sp
The years and months offsets are applied first, and the days offset
is applied last.
.Sp
If the resulting date happens to fall on a day after the end of the
resulting month, like the 32nd of April or the 30th of February, then
the date is simply counted forward into the next month (possibly also
into the next year) by the number of excessive days (e.g., the 32nd of
April will become the 2nd of May).
.Sp
\&\fB\s-1BEWARE\s0\fR that this behaviour differs from that of previous versions
of this module! In previous versions, the day was simply truncated to
the maximum number of days in the resulting month.
.Sp
If you want the previous behaviour, use the new function "\f(CW\*(C`Add_Delta_YM()\*(C'\fR\*(L"
(described immediately above) plus the function \*(R"\f(CW\*(C`Add_Delta_Days()\*(C'\fR"
instead.
.Sp
\&\fB\s-1BEWARE\s0\fR also that because a year and a month offset is not equivalent
to a fixed number of days, the transformation performed by this function
is \fB\s-1NOT ALWAYS REVERSIBLE\s0\fR!
.Sp
This is in contrast to the functions "\f(CW\*(C`Add_Delta_Days()\*(C'\fR\*(L" and
\&\*(R"\f(CW\*(C`Add_Delta_DHMS()\*(C'\fR\*(L", which are fully and truly reversible (with
the help of the functions \*(R"\f(CW\*(C`Delta_Days()\*(C'\fR\*(L" and \*(R"\f(CW\*(C`Delta_DHMS()\*(C'\fR",
for instance).
.Sp
Note that for this same reason,
.Sp
.Vb 2
\&  @date = Add_Delta_YMD(
\&          Add_Delta_YMD(@date, $Dy,$Dm,$Dd), \-$Dy,\-$Dm,\-$Dd);
.Ve
.Sp
will in general \fB\s-1NOT\s0\fR return the initial date "\f(CW@date\fR", even
though
.Sp
.Vb 1
\&  @date2 = Add_Delta_YMD( @date1, Delta_YMD(@date1, @date2) );
.Ve
.Sp
will always return the second date "\f(CW@date2\fR", and
.Sp
.Vb 1
\&  @date1 = Add_Delta_YMD( @date2, map(\-$_, Delta_YMD(@date1, @date2)) );
.Ve
.Sp
which is the same as
.Sp
.Vb 1
\&  @date1 = Add_Delta_YMD( @date2, Delta_YMD(@date2, @date1) );
.Ve
.Sp
will always return the first date "\f(CW@date1\fR".
.Sp
Examples:
.Sp
.Vb 2
\&  [1996,1,31] + ( 6, 1,\-2) = [2002,3,1]
\&  [2002,3, 1] + (\-6,\-1, 2) = [1996,2,3] # EXPECTED: [1996,1,31]
\&
\&  (6,2,\-30) == Delta_YMD(1996,1,31, 2002,3,1);
\&
\&  [1996,1,31] + ( 6, 2,\-30) = [2002,3, 1]
\&  [2002,3, 1] + (\-6,\-2, 30) = [1996,1,31] # OK
\&
\&  (6,1,\-2) == Delta_YMD(1996,2,3, 2002,3,1);
\&
\&  [1996,2,3] + ( 6, 1,\-2) = [2002,3,1]
\&  [2002,3,1] + (\-6,\-1, 2) = [1996,2,3] # OK
.Ve
.Sp
Note that this is \fB\s-1NOT\s0\fR a program bug but \fB\s-1NECESSARILY\s0\fR so,
because of the variable lengths of years and months, and hence
because of the ambiguity of the difference between two dates
in terms of years, months and days, i.e., the fact that the
difference between two dates can be expressed in more than
one way:
.Sp
.Vb 2
\&  [1996,1,31] + (6,1, \-2) = [2002,3,1]
\&  [1996,1,31] + (6,2,\-30) = [2002,3,1]
.Ve
.IP "\(bu" 2
\&\f(CW\*(C`($year,$month,$day, $hour,$min,$sec) = Add_Delta_YMDHMS($year,$month,$day, $hour,$min,$sec, $D_y,$D_m,$D_d, $Dh,$Dm,$Ds);\*(C'\fR
.Sp
Same as the function above, except that a time offset may be given in
addition to the year, month and day offset.
.IP "\(bu" 2
\&\f(CW\*(C`($year,$month,$day) = Add_N_Delta_YMD($year,$month,$day, $Dy,$Dm,$Dd);\*(C'\fR
.Sp
This function is actually a shortcut for applying the function \*(L"\fIAdd_Delta_YM()\fR\*(R"
first, followed by the function \*(L"\fIAdd_Delta_Days()\fR\*(R", i.e., this function does
exactly the same as
.Sp
.Vb 1
\& ($year,$month,$day) = Add_Delta_Days( Add_Delta_YM($year,$month,$day,$Dy,$Dm), $Dd );
.Ve
.Sp
Beware that, if necessary, the function \*(L"\fIAdd_Delta_YM()\fR\*(R" truncates the
resulting day of the month to the largest allowable value for that month,
i.e., the (invalid) result [2009,2,31] is automatically transformed into
[2009,2,28].
.Sp
For more details on this truncation, see the description of the function
\&\*(L"\fIAdd_Delta_YM()\fR\*(R" further above.
.Sp
This function is meant to be complementary with the function \*(L"\fIN_Delta_YMD()\fR\*(R"
described further above.
.Sp
This means that it is guaranteed that the result returned by
.Sp
.Vb 1
\&  Add_N_Delta_YMD( @date1, N_Delta_YMD(@date1, @date2) );
.Ve
.Sp
is always identical with the given date "\f(CW@date2\fR".
.Sp
Note however that unlike with function \*(L"\fIAdd_Delta_YMD()\fR\*(R",
the reverse is not true here, i.e.,
.Sp
.Vb 2
\&  ($Dy,$Dm,$Dd) = N_Delta_YMD(@date1,@date2);
\&  @date = Add_N_Delta_YMD(@date2, \-$Dy,\-$Dm,\-$Dd);
.Ve
.Sp
will \fB\s-1NOT\s0\fR always return the initial date "\f(CW@date1\fR".
.Sp
Example:
.Sp
.Vb 1
\&  (0,11,3) == N_Delta_YMD(2008,2,29, 2009,2,1);
\&
\&  [2008,2,29] + (0, 11, 3) = [2009,2, 1]
\&  [2009,2, 1] + (0,\-11,\-3) = [2008,2,27] # EXPECTED: [2008,2,29]
.Ve
.IP "\(bu" 2
\&\f(CW\*(C`($year,$month,$day, $hour,$min,$sec) = Add_N_Delta_YMDHMS($year,$month,$day, $hour,$min,$sec, $D_y,$D_m,$D_d, $Dhh,$Dmm,$Dss);\*(C'\fR
.Sp
This function essentially does the same as the function \*(L"\fIAdd_N_Delta_YMD()\fR\*(R"
described immediately above, except that also the difference in hours,
minutes and seconds is taken into account.
.IP "\(bu" 2
\&\f(CW\*(C`($year,$month,$day, $hour,$min,$sec, $doy,$dow,$dst) = System_Clock([$gmt]);\*(C'\fR
.Sp
If your operating system supports the corresponding system calls
("\f(CW\*(C`time()\*(C'\fR\*(L" and \*(R"\f(CW\*(C`localtime()\*(C'\fR\*(L" or \*(R"\f(CW\*(C`gmtime()\*(C'\fR"), this function
will return the information provided by your system clock, i.e.,
the current date and time, the number of the day of year, the number
of the day of week and a flag signaling whether daylight savings time
is currently in effect or not.
.Sp
The ranges of values returned (and their meanings) are as follows:
.Sp
.Vb 2
\&        $year   :   1970..2038 (or more)  [Unix etc.]
\&        $year   :   1904..2040            [MacOS Classic]
\&
\&        $month  :   1..12
\&        $day    :   1..31
\&        $hour   :   0..23
\&        $min    :   0..59
\&        $sec    :   0..59    (0..61 on some systems)
\&        $doy    :   1..366
\&        $dow    :   1..7
\&        $dst    :  \-1..1
.Ve
.Sp
"\f(CW$doy\fR\*(L" is the day of year, sometimes also referred to as the
\&\*(R"julian date\*(L", which starts at \*(R"\f(CW1\fR" and goes up to the number
of days in that year.
.Sp
The day of week ("\f(CW$dow\fR\*(L") will be \*(R"\f(CW1\fR\*(L" for Monday, \*(R"\f(CW2\fR\*(L" for
Tuesday and so on until \*(R"\f(CW7\fR" for Sunday.
.Sp
The daylight savings time flag ("\f(CW$dst\fR\*(L") will be \*(R"\f(CW\*(C`\-1\*(C'\fR\*(L" if this
information is not available on your system, \*(R"\f(CW0\fR\*(L" for no daylight
savings time (i.e., winter time) and \*(R"\f(CW1\fR" when daylight savings
time is in effect.
.Sp
If your operating system does not provide the necessary system calls,
calling this function will result in a fatal \*(L"not available on this
system\*(R" error message.
.Sp
If you want to handle this exception yourself, use "\f(CW\*(C`eval\*(C'\fR" as follows:
.Sp
.Vb 2
\&  eval { ($year,$month,$day, $hour,$min,$sec, $doy,$dow,$dst) =
\&    System_Clock(); };
\&
\&  if ($@)
\&  {
\&      # Handle missing system clock
\&      # (For instance, ask user to enter this information manually)
\&  }
.Ve
.Sp
Note that curlies (\*(L"{\*(R" and \*(L"}\*(R") are used here to delimit the statement to
be \*(L"eval\*(R"ed (which is the way to catch exceptions in Perl), and not quotes
(which is a way to evaluate Perl expressions at runtime).
.Sp
If the optional (boolean) input parameter "\f(CW$gmt\fR\*(L" is given, a \*(R"true\*(L"
value (\*(R"\f(CW1\fR\*(L") will cause \*(R"\f(CW\*(C`gmtime()\*(C'\fR\*(L" to be used instead of \*(R"\f(CW\*(C`localtime()\*(C'\fR",
internally, thus returning Greenwich Mean Time (\s-1GMT,\s0 or \s-1UTC\s0) instead of
local time.
.IP "\(bu" 2
\&\f(CW\*(C`($year,$month,$day) = Today([$gmt]);\*(C'\fR
.Sp
This function returns a subset of the values returned by the function
"\f(CW\*(C`System_Clock()\*(C'\fR" (see above for details), namely the current year,
month and day.
.Sp
A fatal \*(L"not available on this system\*(R" error message will appear if the
corresponding system calls are not supported by your current operating
system.
.Sp
If the optional (boolean) input parameter "\f(CW$gmt\fR\*(L" is given, a \*(R"true\*(L"
value (\*(R"\f(CW1\fR\*(L") will cause \*(R"\f(CW\*(C`gmtime()\*(C'\fR\*(L" to be used instead of \*(R"\f(CW\*(C`localtime()\*(C'\fR",
internally, thus returning Greenwich Mean Time (\s-1GMT,\s0 or \s-1UTC\s0) instead of
local time.
.IP "\(bu" 2
\&\f(CW\*(C`($hour,$min,$sec) = Now([$gmt]);\*(C'\fR
.Sp
This function returns a subset of the values returned by the function
"\f(CW\*(C`System_Clock()\*(C'\fR" (see above for details), namely the current time
(hours, minutes and full seconds).
.Sp
A fatal \*(L"not available on this system\*(R" error message will appear if the
corresponding system calls are not supported by your current operating
system.
.Sp
If the optional (boolean) input parameter "\f(CW$gmt\fR\*(L" is given, a \*(R"true\*(L"
value (\*(R"\f(CW1\fR\*(L") will cause \*(R"\f(CW\*(C`gmtime()\*(C'\fR\*(L" to be used instead of \*(R"\f(CW\*(C`localtime()\*(C'\fR",
internally, thus returning Greenwich Mean Time (\s-1GMT,\s0 or \s-1UTC\s0) instead of
local time.
.IP "\(bu" 2
\&\f(CW\*(C`($year,$month,$day, $hour,$min,$sec) = Today_and_Now([$gmt]);\*(C'\fR
.Sp
This function returns a subset of the values returned by the function
"\f(CW\*(C`System_Clock()\*(C'\fR" (see above for details), namely the current date
(year, month, day) and time (hours, minutes and full seconds).
.Sp
A fatal \*(L"not available on this system\*(R" error message will appear if the
corresponding system calls are not supported by your current operating
system.
.Sp
If the optional (boolean) input parameter "\f(CW$gmt\fR\*(L" is given, a \*(R"true\*(L"
value (\*(R"\f(CW1\fR\*(L") will cause \*(R"\f(CW\*(C`gmtime()\*(C'\fR\*(L" to be used instead of \*(R"\f(CW\*(C`localtime()\*(C'\fR",
internally, thus returning Greenwich Mean Time (\s-1GMT,\s0 or \s-1UTC\s0) instead of
local time.
.IP "\(bu" 2
\&\f(CW\*(C`$year = This_Year([$gmt]);\*(C'\fR
.Sp
This function returns the current year, according to local time.
.Sp
A fatal \*(L"not available on this system\*(R" error message will appear if the
corresponding system calls are not supported by your current operating
system.
.Sp
If the optional (boolean) input parameter "\f(CW$gmt\fR\*(L" is given, a \*(R"true\*(L"
value (\*(R"\f(CW1\fR\*(L") will cause \*(R"\f(CW\*(C`gmtime()\*(C'\fR\*(L" to be used instead of \*(R"\f(CW\*(C`localtime()\*(C'\fR",
internally, thus returning Greenwich Mean Time (\s-1GMT,\s0 or \s-1UTC\s0) instead of
local time. However, this will only make a difference within a few hours
around New Year (unless you are on a Pacific island, where this can
be almost 24 hours).
.IP "\(bu" 2
\&\f(CW\*(C`($year,$month,$day, $hour,$min,$sec, $doy,$dow,$dst) = Gmtime([time]);\*(C'\fR
.Sp
This is Date::Calc's equivalent of Perl's built-in \*(L"\fIgmtime()\fR\*(R" function.
See also \*(L"gmtime\*(R" in \fIperlfunc\fR\|(1).
.Sp
With the optional argument \*(L"time\*(R" (i.e., seconds since the epoch),
this function will return the corresponding values for that particular
time (instead of the current time when this parameter is omitted).
.Sp
The ranges of values returned (and their meanings) are as follows:
.Sp
.Vb 2
\&        $year   :   1970..2038 (or more)  [Unix etc.]
\&        $year   :   1904..2040            [MacOS Classic]
\&
\&        $month  :   1..12
\&        $day    :   1..31
\&        $hour   :   0..23
\&        $min    :   0..59
\&        $sec    :   0..59
\&        $doy    :   1..366
\&        $dow    :   1..7
\&        $dst    :  \-1..1
.Ve
.Sp
"\f(CW$doy\fR\*(L" is the day of year, sometimes also referred to as the
\&\*(R"julian date\*(L", which starts at \*(R"\f(CW1\fR" and goes up to the number
of days in that year.
.Sp
The day of week ("\f(CW$dow\fR\*(L") will be \*(R"\f(CW1\fR\*(L" for Monday, \*(R"\f(CW2\fR\*(L" for
Tuesday and so on until \*(R"\f(CW7\fR" for Sunday.
.Sp
The daylight savings time flag ("\f(CW$dst\fR\*(L") will be \*(R"\f(CW\*(C`\-1\*(C'\fR\*(L" if this
information is not available on your system, \*(R"\f(CW0\fR\*(L" for no daylight
savings time (i.e., winter time) and \*(R"\f(CW1\fR" when daylight savings
time is in effect.
.Sp
A fatal \*(L"time out of range\*(R" error will occur if the given time value
is out of range \f(CW\*(C`[0..(~0>>1)]\*(C'\fR.
.Sp
If the time value is omitted, the \*(L"\fItime()\fR\*(R" function is called instead,
internally.
.IP "\(bu" 2
\&\f(CW\*(C`($year,$month,$day, $hour,$min,$sec, $doy,$dow,$dst) = Localtime([time]);\*(C'\fR
.Sp
This is Date::Calc's equivalent of Perl's built-in \*(L"\fIlocaltime()\fR\*(R" function.
See also \*(L"localtime\*(R" in \fIperlfunc\fR\|(1).
.Sp
The ranges of values returned (and their meanings) are as follows:
.Sp
.Vb 2
\&        $year   :   1970..2038 (or more)  [Unix etc.]
\&        $year   :   1904..2040            [MacOS Classic]
\&
\&        $month  :   1..12
\&        $day    :   1..31
\&        $hour   :   0..23
\&        $min    :   0..59
\&        $sec    :   0..59
\&        $doy    :   1..366
\&        $dow    :   1..7
\&        $dst    :  \-1..1
.Ve
.Sp
"\f(CW$doy\fR\*(L" is the day of year, sometimes also referred to as the
\&\*(R"julian date\*(L", which starts at \*(R"\f(CW1\fR" and goes up to the number
of days in that year.
.Sp
The day of week ("\f(CW$dow\fR\*(L") will be \*(R"\f(CW1\fR\*(L" for Monday, \*(R"\f(CW2\fR\*(L" for
Tuesday and so on until \*(R"\f(CW7\fR" for Sunday.
.Sp
The daylight savings time flag ("\f(CW$dst\fR\*(L") will be \*(R"\f(CW\*(C`\-1\*(C'\fR\*(L" if this
information is not available on your system, \*(R"\f(CW0\fR\*(L" for no daylight
savings time (i.e., winter time) and \*(R"\f(CW1\fR" when daylight savings
time is in effect.
.Sp
A fatal \*(L"time out of range\*(R" error will occur if the given time value is
out of range \f(CW\*(C`[0..(~0>>1)]\*(C'\fR.
.Sp
If the time value is omitted, the \*(L"\fItime()\fR\*(R" function is called instead,
internally.
.IP "\(bu" 2
\&\f(CW\*(C`$time = Mktime($year,$month,$day, $hour,$min,$sec);\*(C'\fR
.Sp
This function converts a date into a time value, i.e., into the number
of seconds since whatever moment in time your system considers to be
the \*(L"epoch\*(R". On Unix and most other systems this is the number of seconds
since January 1st 1970 at midnight (\s-1GMT\s0). On MacOS Classic this is the
number of seconds since January 1st 1904 at midnight (local time).
.Sp
The function is similar to the \*(L"\fIPOSIX::mktime()\fR\*(R" function (see \*(L"mktime\*(R" in \s-1\fIPOSIX\s0\fR\|(1)
for more details), but in contrast to the latter, it expects dates in the
usual ranges used throughout this module: The year 2001 stays year 2001,
and months are numbered from 1 to 12.
.Sp
A fatal \*(L"date out of range\*(R" error will occur if the given date cannot
be expressed in terms of seconds since the epoch (this happens for
instance when the date lies before the epoch, or if it is later than
19\-Jan\-2038\ 03:14:07\ \s-1GMT\s0 on 32\ bit Unix systems, or later than
06\-Feb\-2040\ 06:28:15 (local time) on a Macintosh with MacOS Classic).
.Sp
Just like the \*(L"\fIPOSIX::mktime()\fR\*(R" function, this function uses the
\&\*(L"\fImktime()\fR\*(R" system call, internally.
.Sp
This means that the given date and time is considered to be in local time,
and that the value returned by this function will depend on your machine's
local settings such as the time zone, whether daylight savings time is
(or was, at the time) in effect, and the system clock itself.
.Sp
\&\fB\s-1BEWARE\s0\fR that \*(L"\fImktime()\fR\*(R" does not always return the same time value
as fed into \*(L"\fIlocaltime()\fR\*(R", when you feed the output of \*(L"\fIlocaltime()\fR\*(R"
back into \*(L"\fImktime()\fR\*(R", on some systems!
.Sp
I.e., "\f(CW\*(C`Mktime((Localtime($time))[0..5])\*(C'\fR\*(L" will not always return
the same value as given in \*(R"\f(CW$time\fR"!
.IP "\(bu" 2
\&\f(CW\*(C`($D_y,$D_m,$D_d, $Dh,$Dm,$Ds, $dst) = Timezone([time]);\*(C'\fR
.Sp
This function returns the difference between "\f(CW\*(C`localtime(time)\*(C'\fR\*(L" and
\&\*(R"\f(CW\*(C`gmtime(time)\*(C'\fR\*(L", which is the timezone offset in effect for the current
location and the given \*(R"\f(CW\*(C`time\*(C'\fR".
.Sp
This offset is positive if you are located to the east of Greenwich,
and is usually negative (except during daylight savings time, in some
locations) if you are located to the west of Greenwich.
.Sp
Note that this offset is influenced by all of the relevant system
settings and parameters on your machine; such as locales, environment
variables (e.g. "\f(CW\*(C`TZ\*(C'\fR") and the system clock itself. See the
relevant documentation on your system for more details.
.Sp
If the "\f(CW\*(C`time\*(C'\fR\*(L" is omitted, the \*(R"\f(CW\*(C`time()\*(C'\fR\*(L" function will
be called automatically, internally (similar to the built-in
functions \*(R"\f(CW\*(C`localtime()\*(C'\fR\*(L" and \*(R"\f(CW\*(C`gmtime()\*(C'\fR" in Perl).
.Sp
A fatal \*(L"time out of range\*(R" error will occur if the given time value
is out of range \f(CW\*(C`[0..(~0>>1)]\*(C'\fR.
.Sp
The last item of the returned list is a flag which indicates whether
daylight savings time is currently in effect. This flag is negative
(\-1) if this information is not available on your system. It is zero
(0) when daylight savings time is off, and positive (+1) when daylight
savings time is on.
.Sp
Thus you can check very quickly whether daylight savings time is
currently in effect by evaluating this function in scalar context
(in scalar context, Perl returns the last item of a list):
.Sp
.Vb 1
\&  if (scalar Timezone > 0) { # yes, daylight savings time
.Ve
.Sp
However, a slightly more efficient way would be this:
.Sp
.Vb 1
\&  if (scalar System_Clock > 0) { # yes, daylight savings time
.Ve
.IP "\(bu" 2
\&\f(CW\*(C`$time = Date_to_Time($year,$month,$day, $hour,$min,$sec);\*(C'\fR
.Sp
This function is a replacement for the \s-1BSD\s0 function \*(L"\fItimegm()\fR\*(R"
(which is not available on all Unix systems), which converts
a given date and time into a time value, i.e., into the number
of seconds since whatever moment in time your system considers to be
the \*(L"epoch\*(R". On Unix and most other systems this is the number of seconds
since January 1st 1970 at midnight (\s-1GMT\s0). On MacOS Classic this is the
number of seconds since January 1st 1904 at midnight (local time).
.Sp
Under Unix, the date and time are considered to be in \s-1UTC
\&\s0(\*(L"Universal Time Coordinated\*(R", and so is the resulting time value.
.Sp
\&\s-1UTC\s0 is almost the same as \s-1GMT \s0(or \*(L"Greenwich Mean Time\*(R"), except
that \s-1UTC\s0 has leap seconds (in order to account for small variations
in the rotation of the earth, for instance), whereas \s-1GMT\s0 does not.
.Sp
Under MacOS Classic, however, both input and output are
considered to be in local time.
.Sp
The ranges of year and month follow the same rules as throughout
the rest of this module (and not the contorted rules of its Unix
equivalent), i.e., the year \*(L"2001\*(R" stays \*(L"2001\*(R" and the month
ranges from 1 to 12.
.Sp
A fatal \*(L"date out of range\*(R" error will occur if the given date cannot
be expressed in terms of seconds since the epoch (this happens for
instance when the date lies before the epoch, or if it is later than
19\-Jan\-2038\ 03:14:07\ \s-1GMT\s0 on 32\ bit Unix systems, or later than
06\-Feb\-2040\ 06:28:15 (local time) on a Macintosh with MacOS Classic).
.Sp
This function should be very fast, because it is implemented in
a very straightforward manner and doesn't use any internal system
calls.
.Sp
Moreover, the functions \*(L"\fIDate_to_Time()\fR\*(R" and \*(L"\fITime_to_Date()\fR\*(R"
are guaranteed to be complementary, i.e., that
"\f(CW\*(C`Date_to_Time(Time_to_Date($time))\*(C'\fR\*(L" and
\&\*(R"\f(CW\*(C`Time_to_Date(Date_to_Time($year,$month,$day, $hour,$min,$sec))\*(C'\fR"
will always return the initial values.
.IP "\(bu" 2
\&\f(CW\*(C`($year,$month,$day, $hour,$min,$sec) = Time_to_Date([time]);\*(C'\fR
.Sp
This function is an alternative to the \s-1POSIX \s0\*(L"\fIgmtime()\fR\*(R" function
(and its built-in Perl equivalent), which converts a given time
value into the corresponding date and time. The given time value
must be the number of seconds since whatever moment in time your
system considers to be the \*(L"epoch\*(R". On Unix and most other systems
this is the number of seconds since January 1st 1970 at midnight
(\s-1GMT\s0). On MacOS Classic this is the number of seconds since
January 1st 1904 at midnight (local time).
.Sp
Under Unix, the given time value is considered to be in \s-1UTC
\&\s0(\*(L"Universal Time Coordinated\*(R", and so is the resulting date
and time.
.Sp
\&\s-1UTC\s0 is almost the same as \s-1GMT \s0(or \*(L"Greenwich Mean Time\*(R"), except
that \s-1UTC\s0 has leap seconds (in order to account for small variations
in the rotation of the earth, for instance), whereas \s-1GMT\s0 does not.
.Sp
Under MacOS Classic, however, both input and output
are considered to be in local time.
.Sp
If the input value "\f(CW\*(C`time\*(C'\fR\*(L" is omitted, the \*(R"\f(CW\*(C`time()\*(C'\fR\*(L" function
will be called automatically, internally (similar to the built-in
functions \*(R"\f(CW\*(C`localtime()\*(C'\fR\*(L" and \*(R"\f(CW\*(C`gmtime()\*(C'\fR" in Perl).
.Sp
A fatal \*(L"time out of range\*(R" error will occur if the given time
value is negative.
.Sp
This function should be very fast, because it is implemented in
a very straightforward manner and doesn't use any internal system
calls (except for \*(L"\fItime()\fR\*(R", if the input value is omitted).
.Sp
Moreover, the functions \*(L"\fIDate_to_Time()\fR\*(R" and \*(L"\fITime_to_Date()\fR\*(R"
are guaranteed to be complementary, i.e., that
"\f(CW\*(C`Date_to_Time(Time_to_Date($time))\*(C'\fR\*(L" and
\&\*(R"\f(CW\*(C`Time_to_Date(Date_to_Time($year,$month,$day, $hour,$min,$sec))\*(C'\fR"
will always return the initial values.
.IP "\(bu" 2
\&\f(CW\*(C`($year,$month,$day) = Easter_Sunday($year);\*(C'\fR
.Sp
This function calculates the date of Easter Sunday for all years in the
range from 1583 to 2299 (all other year numbers will result in a fatal
\&\*(L"year out of range\*(R" error message) using the method known as the \*(L"Gaussian
Rule\*(R".
.Sp
Some related christian feast days which depend on the date of Easter Sunday:
.Sp
.Vb 11
\&  Carnival Monday / Rosenmontag / Veille du Mardi Gras   =  \-48 days
\&  Mardi Gras / Karnevalsdienstag / Mardi Gras            =  \-47 days
\&  Ash Wednesday / Aschermittwoch / Mercredi des Cendres  =  \-46 days
\&  Palm Sunday / Palmsonntag / Dimanche des Rameaux       =   \-7 days
\&  Easter Friday / Karfreitag / Vendredi Saint            =   \-2 days
\&  Easter Saturday / Ostersamstag / Samedi de Paques      =   \-1 day
\&  Easter Monday / Ostermontag / Lundi de Paques          =   +1 day
\&  Ascension of Christ / Christi Himmelfahrt / Ascension  =  +39 days
\&  Whitsunday / Pfingstsonntag / Dimanche de Pentecote    =  +49 days
\&  Whitmonday / Pfingstmontag / Lundi de Pentecote        =  +50 days
\&  Feast of Corpus Christi / Fronleichnam / Fete\-Dieu     =  +60 days
.Ve
.Sp
Use the offsets shown above to calculate the date of the corresponding
feast day as follows:
.Sp
.Vb 1
\&  ($year,$month,$day) = Add_Delta_Days(Easter_Sunday($year), $offset));
.Ve
.IP "\(bu" 2
\&\f(CW\*(C`if ($month = Decode_Month($string[,$lang]))\*(C'\fR
.Sp
This function takes a string as its argument, which should contain the
name of a month in the given or currently selected language (see further below
for details about the multi-language support of this package), or any uniquely
identifying abbreviation of a month's name (i.e., the first few letters),
and returns the corresponding number (1..12) upon a successful match, or
"\f(CW0\fR\*(L" otherwise (therefore, the return value can also be used as the
conditional expression in an \*(R"if" statement).
.Sp
Note that the input string may not contain any other characters which do not
pertain to the month's name, especially no leading or trailing whitespace.
.Sp
Note also that matching is performed in a case-insensitive manner (this may
depend on the \*(L"locale\*(R" setting on your current system, though!)
.Sp
With \*(L"1\*(R" (\*(L"English\*(R") as the given language, the following examples will
all return the value "\f(CW9\fR":
.Sp
.Vb 4
\&  $month = Decode_Month("s",1);
\&  $month = Decode_Month("Sep",1);
\&  $month = Decode_Month("septemb",1);
\&  $month = Decode_Month("September",1);
.Ve
.IP "\(bu" 2
\&\f(CW\*(C`if ($dow = Decode_Day_of_Week($string[,$lang]))\*(C'\fR
.Sp
This function takes a string as its argument, which should contain the
name of a day of week in the given or currently selected language (see further
below for details about the multi-language support of this package), or any
uniquely identifying abbreviation of the name of a day of week (i.e., the
first few letters), and returns the corresponding number (1..7) upon a
successful match, or "\f(CW0\fR\*(L" otherwise (therefore, the return value can
also be used as the conditional expression in an \*(R"if" statement).
.Sp
Note that the input string may not contain any other characters which
do not pertain to the name of the day of week, especially no leading
or trailing whitespace.
.Sp
Note also that matching is performed in a case-insensitive manner (this may
depend on the \*(L"locale\*(R" setting on your current system, though!)
.Sp
With \*(L"1\*(R" (\*(L"English\*(R") as the given language, the following examples will
all return the value "\f(CW3\fR":
.Sp
.Vb 4
\&  $dow = Decode_Day_of_Week("w",1);
\&  $dow = Decode_Day_of_Week("Wed",1);
\&  $dow = Decode_Day_of_Week("wednes",1);
\&  $dow = Decode_Day_of_Week("Wednesday",1);
.Ve
.IP "\(bu" 2
\&\f(CW\*(C`if ($lang = Decode_Language($string))\*(C'\fR
.Sp
This function takes a string as its argument, which should contain the
name of one of the languages supported by this package (\fB\s-1IN THIS VERY
LANGUAGE ITSELF\s0\fR), or any uniquely identifying abbreviation of the name
of a language (i.e., the first few letters), and returns its corresponding
internal number (1..14 in the original distribution) upon a successful match,
or "\f(CW0\fR\*(L" otherwise (therefore, the return value can also be used as the
conditional expression in an \*(R"if" statement).
.Sp
Note that the input string may not contain any other characters which do
not pertain to the name of a language, especially no leading or trailing
whitespace.
.Sp
Note also that matching is performed in a case-insensitive manner (this may
depend on the \*(L"locale\*(R" setting on your current system, though!)
.Sp
The original distribution supports the following fourteen languages:
.Sp
.Vb 10
\&            English                    ==>    1    (default)
\&            Franc\*,ais    (French)       ==>    2
\&            Deutsch     (German)       ==>    3
\&            Espan\*~ol     (Spanish)      ==>    4
\&            Portugue\*^s   (Portuguese)   ==>    5
\&            Nederlands  (Dutch)        ==>    6
\&            Italiano    (Italian)      ==>    7
\&            Norsk       (Norwegian)    ==>    8
\&            Svenska     (Swedish)      ==>    9
\&            Dansk       (Danish)       ==>   10
\&            suomi       (Finnish)      ==>   11
\&            Magyar      (Hungarian)    ==>   12
\&            polski      (Polish)       ==>   13
\&            Romaneste   (Romanian)     ==>   14
.Ve
.Sp
See the section \*(L"How to install additional languages\*(R" in the file
\&\*(L"\s-1INSTALL\s0.txt\*(R" in this distribution for how to add more languages
to this package.
.Sp
In the original distribution (no other languages installed),
the following examples will all return the value "\f(CW3\fR":
.Sp
.Vb 3
\&  $lang = Decode_Language("d");
\&  $lang = Decode_Language("de");
\&  $lang = Decode_Language("Deutsch");
.Ve
.Sp
Note that you may not be able to enter the special international characters
in some of the languages' names over the keyboard directly on some systems.
.Sp
This should never be a problem, though; just enter an abbreviation of the
name of the language consisting of the first few letters up to the character
before the first special international character.
.IP "\(bu" 2
\&\f(CW\*(C`if (($year,$month,$day) = Decode_Date_EU($string[,$lang]))\*(C'\fR
.Sp
This function scans a given string and tries to parse any date
which might be embedded in it.
.Sp
The function returns an empty list if it can't successfully
extract a valid date from its input string, or else it returns
the date found.
.Sp
The function accepts almost any format, as long as the date is
given in the european order (hence its name) day-month-year.
.Sp
Thereby, zero or more \fBNON-NUMERIC\fR characters may \fB\s-1PRECEDE\s0\fR
the day and \fB\s-1FOLLOW\s0\fR the year.
.Sp
Moreover, zero or more \fBNON-ALPHANUMERIC\fR characters are permitted
\&\fB\s-1BETWEEN\s0\fR these three items (i.e., between day and month and between
month and year).
.Sp
The month may be given either numerically (i.e., a number from "\f(CW1\fR\*(L"
to \*(R"\f(CW12\fR"), or alphanumerically, i.e., as the name of the month in
the given or currently selected language, or any uniquely identifying
abbreviation thereof.
.Sp
(See further below for details about the multi-language support of this
package!)
.Sp
If the year is given as one or two digits only (i.e., if the year is less
than 100), it is mapped to a \*(L"window\*(R" of +/\- 50 years around the current
year, as described by the \*(L"\fIMoving_Window()\fR\*(R" function (see further below).
.Sp
If the day, month and year are all given numerically but \fB\s-1WITHOUT\s0\fR any
delimiting characters between them, this string of digits will be mapped
to the day, month and year as follows:
.Sp
.Vb 7
\&                Length:        Mapping:
\&                  3              dmy
\&                  4              dmyy
\&                  5              dmmyy
\&                  6              ddmmyy
\&                  7              dmmyyyy
\&                  8              ddmmyyyy
.Ve
.Sp
(Where \*(L"d\*(R" stands for \*(L"day\*(R", \*(L"m\*(R" stands for \*(L"month\*(R" and \*(L"y\*(R" stands for
\&\*(L"year\*(R".)
.Sp
All other strings consisting purely of digits (without any intervening
delimiters) are rejected, i.e., not recognized.
.Sp
Examples:
.Sp
.Vb 12
\&  "3.1.64"
\&  "3 1 64"
\&  "03.01.64"
\&  "03/01/64"
\&  "3. Jan 1964"
\&  "Birthday: 3. Jan \*(Aq64 in Backnang/Germany"
\&  "03\-Jan\-64"
\&  "3.Jan1964"
\&  "3Jan64"
\&  "030164"
\&  "3ja64"
\&  "3164"
.Ve
.Sp
Experiment! (See the corresponding example applications in the
\&\*(L"examples\*(R" subdirectory of this distribution in order to do so.)
.IP "\(bu" 2
\&\f(CW\*(C`if (($year,$month,$day) = Decode_Date_US($string[,$lang]))\*(C'\fR
.Sp
This function scans a given string and tries to parse any date
which might be embedded in it.
.Sp
The function returns an empty list if it can't successfully
extract a valid date from its input string, or else it returns
the date found.
.Sp
The function accepts almost any format, as long as the date is
given in the U.S. american order (hence its name) month-day-year.
.Sp
Thereby, zero or more \fBNON-ALPHANUMERIC\fR characters may \fB\s-1PRECEDE\s0\fR
and \fB\s-1FOLLOW\s0\fR the month (i.e., precede the month and separate it from
the day which follows behind).
.Sp
Moreover, zero or more \fBNON-NUMERIC\fR characters are permitted
\&\fB\s-1BETWEEN\s0\fR the day and the year, as well as \fB\s-1AFTER\s0\fR the year.
.Sp
The month may be given either numerically (i.e., a number from "\f(CW1\fR\*(L"
to \*(R"\f(CW12\fR"), or alphanumerically, i.e., as the name of the month in
the given or currently selected language, or any uniquely identifying
abbreviation thereof.
.Sp
(See further below for details about the multi-language support of this
package!)
.Sp
If the year is given as one or two digits only (i.e., if the year is less
than 100), it is mapped to a \*(L"window\*(R" of +/\- 50 years around the current
year, as described by the \*(L"\fIMoving_Window()\fR\*(R" function (see further below).
.Sp
If the month, day and year are all given numerically but \fB\s-1WITHOUT\s0\fR any
delimiting characters between them, this string of digits will be mapped
to the month, day and year as follows:
.Sp
.Vb 7
\&                Length:        Mapping:
\&                  3              mdy
\&                  4              mdyy
\&                  5              mddyy
\&                  6              mmddyy
\&                  7              mddyyyy
\&                  8              mmddyyyy
.Ve
.Sp
(Where \*(L"m\*(R" stands for \*(L"month\*(R", \*(L"d\*(R" stands for \*(L"day\*(R" and \*(L"y\*(R" stands for
\&\*(L"year\*(R".)
.Sp
All other strings consisting purely of digits (without any intervening
delimiters) are rejected, i.e., not recognized.
.Sp
If only the day and the year form a contiguous string of digits, they
will be mapped as follows:
.Sp
.Vb 6
\&                Length:        Mapping:
\&                  2              dy
\&                  3              dyy
\&                  4              ddyy
\&                  5              dyyyy
\&                  6              ddyyyy
.Ve
.Sp
(Where \*(L"d\*(R" stands for \*(L"day\*(R" and \*(L"y\*(R" stands for \*(L"year\*(R".)
.Sp
Examples:
.Sp
.Vb 9
\&  "1 3 64"
\&  "01/03/64"
\&  "Jan 3 \*(Aq64"
\&  "Jan 3 1964"
\&  "===> January 3rd 1964 (birthday)"
\&  "Jan31964"
\&  "Jan364"
\&  "ja364"
\&  "1364"
.Ve
.Sp
Experiment! (See the corresponding example applications in the
\&\*(L"examples\*(R" subdirectory of this distribution in order to do so.)
.IP "\(bu" 2
\&\f(CW\*(C`$year = Fixed_Window($yy);\*(C'\fR
.Sp
This function applies a \*(L"fixed window\*(R" strategy to two-digit year
numbers in order to convert them into four-digit year numbers.
.Sp
All other year numbers are passed through unchanged, except for
negative year numbers, which cause the function to return zero
("\f(CW0\fR") instead.
.Sp
Two-digit year numbers "\f(CW\*(C`yy\*(C'\fR\*(L" below 70 are converted to \*(R"\f(CW\*(C`20yy\*(C'\fR\*(L",
whereas year numbers equal to or greater than 70 (but less than 100)
are converted to \*(R"\f(CW\*(C`19yy\*(C'\fR".
.Sp
In the original distribution of this package, the base century is
set to \*(L"1900\*(R" and the base year to \*(L"70\*(R" (which is a standard on \s-1UNIX\s0
systems), but these constants (also called the \*(L"epoch\*(R") can actually
be chosen at will (in the files \*(L"DateCalc.c\*(R" and \*(L"DateCalc.h\*(R") at
compile time of this module.
.IP "\(bu" 2
\&\f(CW\*(C`$year = Moving_Window($yy);\*(C'\fR
.Sp
This function applies a \*(L"moving window\*(R" strategy to two-digit year
numbers in order to convert them into four-digit year numbers, provided
the necessary system calls (system clock) are available. Otherwise the
function falls back to the \*(L"fixed window\*(R" strategy described in the
function above.
.Sp
All other year numbers are passed through unchanged, except for
negative year numbers, which cause the function to return zero
("\f(CW0\fR") instead.
.Sp
Two-digit year numbers are mapped according to a \*(L"window\*(R" of 50 years
in both directions (past and future) around the current year.
.Sp
That is, two-digit year numbers are first mapped to the same century
as the current year. If the resulting year is smaller than the current
year minus 50, then one more century is added to the result. If the
resulting year is equal to or greater than the current year plus 50,
then a century is subtracted from the result.
.IP "\(bu" 2
\&\f(CW\*(C`$date = Compress($year,$month,$day);\*(C'\fR
.Sp
\&\s-1WARNING:\s0 This function is legacy code, its use is deprecated!
.Sp
This function encodes a date in 16 bits, which is the value being returned.
.Sp
The encoding scheme is as follows:
.Sp
.Vb 2
\&            Bit number:    FEDCBA9 8765 43210
\&            Contents:      yyyyyyy mmmm ddddd
.Ve
.Sp
(Where the \*(L"yyyyyyy\*(R" contain the number of the year, \*(L"mmmm\*(R" the number of
the month and \*(L"ddddd\*(R" the number of the day.)
.Sp
The function returns "\f(CW0\fR\*(L" if the given input values do not represent a
valid date. Therefore, the return value of this function can also be used
as the conditional expression in an \*(R"if" statement, in order to check
whether the given input values constitute a valid date).
.Sp
Through this special encoding scheme, it is possible to \fB\s-1COMPARE\s0\fR
compressed dates for equality and order (less than/greater than)
\&\fB\s-1WITHOUT\s0\fR any previous \fB\s-1DECODING\s0\fR!
.Sp
Note however that contiguous dates do \fB\s-1NOT\s0\fR necessarily have contiguous
compressed representations!
.Sp
I.e., incrementing the compressed representation of a date \fB\s-1MAY OR MAY NOT\s0\fR
yield a valid new date!
.Sp
Note also that this function can only handle dates within one century.
.Sp
This century can be chosen at will (at compile time of this module)
by defining a base century and year (also called the \*(L"epoch\*(R"). In the
original distribution of this package, the base century is set to
\&\*(L"1900\*(R" and the base year to \*(L"70\*(R" (which is standard on \s-1UNIX\s0 systems).
.Sp
This allows this function to handle dates from \*(L"1970\*(R" up to \*(L"2069\*(R".
.Sp
If the given year is equal to, say, \*(L"95\*(R", this package will automatically
assume that you really meant \*(L"1995\*(R" instead. However, if you specify a year
number which is \fB\s-1SMALLER\s0\fR than 70, like \*(L"64\*(R", for instance, this package
will assume that you really meant \*(L"2064\*(R".
.Sp
You are not confined to two-digit (abbreviated) year numbers, though.
.Sp
The function also accepts \*(L"full-length\*(R" year numbers, provided that they
lie in the supported range (i.e., from \*(L"1970\*(R" to \*(L"2069\*(R", in the original
configuration of this package).
.Sp
Note that this function is maintained mainly for backward compatibility,
and that its use is not recommended.
.IP "\(bu" 2
\&\f(CW\*(C`if (($century,$year,$month,$day) = Uncompress($date))\*(C'\fR
.Sp
\&\s-1WARNING:\s0 This function is legacy code, its use is deprecated!
.Sp
This function decodes dates that were encoded previously using the function
"\f(CW\*(C`Compress()\*(C'\fR".
.Sp
It returns the century, year, month and day of the date encoded in "\f(CW$date\fR\*(L"
if \*(R"\f(CW$date\fR" represents a valid date, or an empty list otherwise.
.Sp
The year returned in "\f(CW$year\fR\*(L" is actually a two-digit year number
(i.e., the year number taken modulo 100), and only the expression
\&\*(R"\f(CW\*(C`$century + $year\*(C'\fR\*(L" yields the \*(R"full-length" year number
(for example, \f(CW\*(C`1900 + 95 = 1995\*(C'\fR).
.Sp
Note that this function is maintained mainly for backward compatibility,
and that its use is not recommended.
.IP "\(bu" 2
\&\f(CW\*(C`if (check_compressed($date))\*(C'\fR
.Sp
\&\s-1WARNING:\s0 This function is legacy code, its use is deprecated!
.Sp
This function returns \*(L"true\*(R" ("\f(CW1\fR\*(L") if the given input value
constitutes a valid compressed date, and \*(R"false\*(L" (\*(R"\f(CW0\fR") otherwise.
.Sp
Note that this function is maintained mainly for backward compatibility,
and that its use is not recommended.
.IP "\(bu" 2
\&\f(CW\*(C`$string = Compressed_to_Text($date[,$lang]);\*(C'\fR
.Sp
\&\s-1WARNING:\s0 This function is legacy code, its use is deprecated!
.Sp
This function returns a string of fixed length (always 9 characters long)
containing a textual representation of the compressed date encoded in
"\f(CW$date\fR".
.Sp
This string has the form \*(L"dd-Mmm-yy\*(R", where \*(L"dd\*(R" is the two-digit number
of the day, \*(L"Mmm\*(R" are the first three letters of the name of the month
in the given or currently selected language (see further below for details
about the multi-language support of this package), and \*(L"yy\*(R" is the two-digit
year number (i.e., the year number taken modulo 100).
.Sp
If "\f(CW$date\fR\*(L" does not represent a valid date, the string \*(R"??\-???\-??" is
returned instead.
.Sp
Note that this function is maintained mainly for backward compatibility,
and that its use is not recommended.
.IP "\(bu" 2
\&\f(CW\*(C`$string = Date_to_Text($year,$month,$day[,$lang]);\*(C'\fR
.Sp
This function returns a string containing a textual representation of the
given date of the form \*(L"www dd-Mmm-yyyy\*(R", where \*(L"www\*(R" are the first three
letters of the name of the day of week in the given or currently selected
language, or a special abbreviation, if special abbreviations have been
defined for the given or currently selected language (see further below for
details about the multi-language support of this package), \*(L"dd\*(R" is the day
(one or two digits), \*(L"Mmm\*(R" are the first three letters of the name of the
month in the given or currently selected language, and \*(L"yyyy\*(R" is the number
of the year in full length.
.Sp
If the given input values do not constitute a valid date, a fatal \*(L"not a
valid date\*(R" error occurs.
.Sp
(See the section \*(L"\s-1RECIPES\*(R"\s0 near the end of this document for a code snippet
for how to print dates in any format you like.)
.IP "\(bu" 2
\&\f(CW\*(C`$string = Date_to_Text_Long($year,$month,$day[,$lang]);\*(C'\fR
.Sp
This function returns a string containing a textual representation of the
given date roughly of the form \*(L"Wwwwww, dd Mmmmmm yyyy\*(R", where \*(L"Wwwwww\*(R"
is the name of the day of week in the given or currently selected language
(see further below for details about the multi-language support of this package),
\&\*(L"dd\*(R" is the day (one or two digits), \*(L"Mmmmmm\*(R" is the name of the month
in the given or currently selected language, and \*(L"yyyy\*(R" is the number of
the year in full length.
.Sp
The exact format of the output string depends on the given or currently
selected language. In the original distribution of this package, these
formats are defined as follows:
.Sp
.Vb 10
\&  1  English    :  "Wwwwww, Mmmmmm ddth yyyy"
\&  2  French     :  "Wwwwww dd mmmmmm yyyy"
\&  3  German     :  "Wwwwww, den dd. Mmmmmm yyyy"
\&  4  Spanish    :  "Wwwwww, dd de mmmmmm de yyyy"
\&  5  Portuguese :  "Wwwwww, dia dd de mmmmmm de yyyy"
\&  6  Dutch      :  "Wwwwww, dd mmmmmm yyyy"
\&  7  Italian    :  "Wwwwww, dd Mmmmmm yyyy"
\&  8  Norwegian  :  "wwwwww, dd. mmmmmm yyyy"
\&  9  Swedish    :  "wwwwww, dd mmmmmm yyyy"
\& 10  Danish     :  "wwwwww, dd. mmmmmm yyyy"
\& 11  Finnish    :  "wwwwww, dd. mmmmmmta yyyy"
\& 12  Hungarian  :  "dd. Mmmmmm yyyy., wwwwww"
\& 13  Polish     :  "Wwwwww, dd Mmmmmm yyyy"
\& 14  Romanian   :  "Wwwwww dd Mmmmmm yyyy"
.Ve
.Sp
(You can change these formats in the file \*(L"DateCalc.c\*(R" before
building this module in order to suit your personal preferences.)
.Sp
If the given input values do not constitute a valid date, a fatal
\&\*(L"not a valid date\*(R" error occurs.
.Sp
In order to capitalize the day of week at the beginning of the string
in Norwegian, use "\f(CW\*(C`ucfirst(Date_to_Text_Long($year,$month,$day,8));\*(C'\fR".
.Sp
(See the section \*(L"\s-1RECIPES\*(R"\s0 near the end of this document for
an example on how to print dates in any format you like.)
.IP "\(bu" 2
\&\f(CW\*(C`$string = English_Ordinal($number);\*(C'\fR
.Sp
This function returns a string containing the (english) abbreviation
of the ordinal number for the given (cardinal) number "\f(CW$number\fR".
.Sp
I.e.,
.Sp
.Vb 10
\&    0  =>  \*(Aq0th\*(Aq    10  =>  \*(Aq10th\*(Aq    20  =>  \*(Aq20th\*(Aq
\&    1  =>  \*(Aq1st\*(Aq    11  =>  \*(Aq11th\*(Aq    21  =>  \*(Aq21st\*(Aq
\&    2  =>  \*(Aq2nd\*(Aq    12  =>  \*(Aq12th\*(Aq    22  =>  \*(Aq22nd\*(Aq
\&    3  =>  \*(Aq3rd\*(Aq    13  =>  \*(Aq13th\*(Aq    23  =>  \*(Aq23rd\*(Aq
\&    4  =>  \*(Aq4th\*(Aq    14  =>  \*(Aq14th\*(Aq    24  =>  \*(Aq24th\*(Aq
\&    5  =>  \*(Aq5th\*(Aq    15  =>  \*(Aq15th\*(Aq    25  =>  \*(Aq25th\*(Aq
\&    6  =>  \*(Aq6th\*(Aq    16  =>  \*(Aq16th\*(Aq    26  =>  \*(Aq26th\*(Aq
\&    7  =>  \*(Aq7th\*(Aq    17  =>  \*(Aq17th\*(Aq    27  =>  \*(Aq27th\*(Aq
\&    8  =>  \*(Aq8th\*(Aq    18  =>  \*(Aq18th\*(Aq    28  =>  \*(Aq28th\*(Aq
\&    9  =>  \*(Aq9th\*(Aq    19  =>  \*(Aq19th\*(Aq    29  =>  \*(Aq29th\*(Aq
.Ve
.Sp
etc.
.IP "\(bu" 2
\&\f(CW\*(C`$string = Calendar($year,$month[,$orthodox[,$lang]]);\*(C'\fR
.Sp
This function returns a calendar of the given month in the given year
(somewhat similar to the \s-1UNIX "\s0\f(CW\*(C`cal\*(C'\fR" command), in the given or currently
selected language (see further below for details about the multi-language
support of this package).
.Sp
Example:
.Sp
.Vb 1
\&  print Calendar(1998,5);
.Ve
.Sp
This will print:
.Sp
.Vb 7
\&           May 1998
\&  Mon Tue Wed Thu Fri Sat Sun
\&                    1   2   3
\&    4   5   6   7   8   9  10
\&   11  12  13  14  15  16  17
\&   18  19  20  21  22  23  24
\&   25  26  27  28  29  30  31
.Ve
.Sp
If the optional boolean parameter "\f(CW$orthodox\fR" is given and true,
the calendar starts on Sunday instead of Monday.
.IP "\(bu" 2
\&\f(CW\*(C`$string = Month_to_Text($month[,$lang]);\*(C'\fR
.Sp
This function returns the name of the given month in the given or currently
selected language (see further below for details about the multi-language
support of this package).
.Sp
If the given month lies outside of the valid range from "\f(CW1\fR\*(L" to \*(R"\f(CW12\fR\*(L",
a fatal \*(R"month out of range" error will occur.
.IP "\(bu" 2
\&\f(CW\*(C`$string = Day_of_Week_to_Text($dow[,$lang]);\*(C'\fR
.Sp
This function returns the name of the given day of week in the given or
currently selected language (see further below for details about the
multi-language support of this package).
.Sp
If the given day of week lies outside of the valid range from "\f(CW1\fR\*(L" to \*(R"\f(CW7\fR\*(L",
a fatal \*(R"day of week out of range" error will occur.
.IP "\(bu" 2
\&\f(CW\*(C`$string = Day_of_Week_Abbreviation($dow[,$lang]);\*(C'\fR
.Sp
This function returns the special abbreviation of the name of the given
day of week, \fB\s-1IF\s0\fR such special abbreviations have been defined for the
given or currently selected language (see further below for details
about the multi-language support of this package).
.Sp
(In the original distribution of this package, this was only true for
Portuguese. Starting with version 5.1, abbreviations for Polish have
also been introduced. Starting with version 5.7, the abbreviations for
Portuguese have been disabled. So Polish is currently the only language
to define such special abbreviations.)
.Sp
If not, the first three letters of the name of the day of week in the
given or currently selected language are returned instead.
.Sp
If the given day of week lies outside of the valid range from "\f(CW1\fR\*(L"
to \*(R"\f(CW7\fR\*(L", a fatal \*(R"day of week out of range" error will occur.
.Sp
Currently, this table of special abbreviations is only used by the
functions "\f(CW\*(C`Date_to_Text()\*(C'\fR\*(L" and \*(R"\f(CW\*(C`Calendar()\*(C'\fR", internally.
.IP "\(bu" 2
\&\f(CW\*(C`$string = Language_to_Text($lang);\*(C'\fR
.Sp
This function returns the name of any language supported by this package
when the internal number representing that language is given as input.
.Sp
The original distribution supports the following fourteen languages:
.Sp
.Vb 10
\&            1   ==>   English                     (default)
\&            2   ==>   Franc\*,ais    (French)
\&            3   ==>   Deutsch     (German)
\&            4   ==>   Espan\*~ol     (Spanish)
\&            5   ==>   Portugue\*^s   (Portuguese)
\&            6   ==>   Nederlands  (Dutch)
\&            7   ==>   Italiano    (Italian)
\&            8   ==>   Norsk       (Norwegian)
\&            9   ==>   Svenska     (Swedish)
\&           10   ==>   Dansk       (Danish)
\&           11   ==>   suomi       (Finnish)
\&           12   ==>   Magyar      (Hungarian)
\&           13   ==>   polski      (Polish)
\&           14   ==>   Romaneste   (Romanian)
.Ve
.Sp
See the section \*(L"How to install additional languages\*(R" in the file
\&\*(L"\s-1INSTALL\s0.txt\*(R" in this distribution for how to add more languages
to this package.
.Sp
See the description of the function "\f(CW\*(C`Languages()\*(C'\fR" further below
to determine how many languages are actually available in a given
installation of this package.
.IP "\(bu" 2
\&\f(CW\*(C`$lang = Language();\*(C'\fR
.IP "\(bu" 2
\&\f(CW\*(C`Language($lang); # DEPRECATED\*(C'\fR
.IP "\(bu" 2
\&\f(CW\*(C`$oldlang = Language($newlang); # DEPRECATED\*(C'\fR
.Sp
This function can be used to determine which language is currently selected,
and to change the selected language (this latter use is deprecated, because
this global setting may cause conflicts between threads or modules running
concurrently).
.Sp
Thereby, each language has a unique internal number.
.Sp
The original distribution contains the following fourteen languages:
.Sp
.Vb 10
\&            1   ==>   English                     (default)
\&            2   ==>   Franc\*,ais    (French)
\&            3   ==>   Deutsch     (German)
\&            4   ==>   Espan\*~ol     (Spanish)
\&            5   ==>   Portugue\*^s   (Portuguese)
\&            6   ==>   Nederlands  (Dutch)
\&            7   ==>   Italiano    (Italian)
\&            8   ==>   Norsk       (Norwegian)
\&            9   ==>   Svenska     (Swedish)
\&           10   ==>   Dansk       (Danish)
\&           11   ==>   suomi       (Finnish)
\&           12   ==>   Magyar      (Hungarian)
\&           13   ==>   polski      (Polish)
\&           14   ==>   Romaneste   (Romanian)
.Ve
.Sp
See the section \*(L"How to install additional languages\*(R" in the file
\&\*(L"\s-1INSTALL\s0.txt\*(R" in this distribution for how to add more languages
to this package.
.Sp
See the description of the function "\f(CW\*(C`Languages()\*(C'\fR" further below
to determine how many languages are actually available in a given
installation of this package.
.Sp
\&\fB\s-1BEWARE\s0\fR that in order for your programs to be portable, you should \fB\s-1NEVER\s0\fR
actually use the internal number of a language in this package \fB\s-1EXPLICITLY\s0\fR,
because the same number could mean different languages on different systems,
depending on what languages have been added to any given installation of this
package.
.Sp
Therefore, you should always use a statement such as
.Sp
.Vb 1
\&  Language(Decode_Language("Name_of_Language")); # DEPRECATED
.Ve
.Sp
or
.Sp
.Vb 1
\&  DateCalc_Function(@parameters,Decode_Language("Name_of_Language")); # RECOMMENDED
.Ve
.Sp
to select the desired language, and
.Sp
.Vb 1
\&  $language = Language_to_Text(Language());
.Ve
.Sp
or
.Sp
.Vb 1
\&  $old_language = Language_to_Text(Language("Name_of_new_Language")); # DEPRECATED
.Ve
.Sp
to determine the (previously) selected language.
.Sp
If the so chosen language is not available in the current installation,
this will result in an appropriate error message, instead of silently
using the wrong (a random) language (which just happens to have the
same internal number in the other installation).
.Sp
\&\fB\s-1BEWARE\s0\fR that when using the function "\f(CW\*(C`Language()\*(C'\fR", the selected
language is a global setting, shared by all threads or modules you
might be running concurrently, thus possibly causing conflicts between
them.
.Sp
In order to avoid these conflicts, you should \fB\s-1NEVER\s0\fR use the function
"\f(CW\*(C`Language()\*(C'\fR", but should \fB\s-1ALWAYS\s0\fR pass a language number (as returned
by the function "\f(CW\*(C`Decode_Language()\*(C'\fR") to the functions which are
language-dependent, which are:
.Sp
\&\*(L"\fIDecode_Month()\fR\*(R", \*(L"\fIDecode_Day_of_Week()\fR\*(R", \*(L"\fICompressed_to_Text()\fR\*(R",
\&\*(L"\fIDate_to_Text()\fR\*(R", \*(L"\fIDate_to_Text_Long()\fR\*(R", \*(L"\fICalendar()\fR\*(R",
\&\*(L"\fIMonth_to_Text()\fR\*(R", \*(L"\fIDay_of_Week_to_Text()\fR\*(R", \*(L"\fIDay_of_Week_Abbreviation()\fR\*(R",
\&\*(L"\fIDecode_Date_EU()\fR\*(R", \*(L"\fIDecode_Date_US()\fR\*(R", \*(L"\fIDecode_Date_EU2()\fR\*(R",
\&\*(L"\fIDecode_Date_US2()\fR\*(R", \*(L"\fIParse_Date()\fR\*(R".
.Sp
Note that when you pass an invalid number, such as e.g. zero, or no
language parameter at all, these functions will revert to their behaviour
in the versions of this module prior to 6.0, which means that the global
setting (as set by "\f(CW\*(C`Language()\*(C'\fR") becomes active again (only in case
of an invalid or missing language parameter!).
.Sp
In the C library \*(L"DateCalc.c\*(R", where omitting a parameter is not an option,
passing a zero for the language is therefore the recommended way to guarantee
backward compatibility.
.IP "\(bu" 2
\&\f(CW\*(C`$max_lang = Languages();\*(C'\fR
.Sp
This function returns the (maximum) number of languages which are
currently available in your installation of this package.
.Sp
(This may vary from installation to installation.)
.Sp
See the section \*(L"How to install additional languages\*(R" in the file
\&\*(L"\s-1INSTALL\s0.txt\*(R" in this distribution for how to add more languages
to this package.
.Sp
In the original distribution of this package there are fourteen built-in
languages, therefore the value returned by this function will be "\f(CW14\fR"
if no other languages have been added to your particular installation.
.IP "\(bu" 2
\&\f(CW\*(C`if (($year,$month,$day) = Decode_Date_EU2($string[,$lang))\*(C'\fR
.Sp
This function is the Perl equivalent of the function "\f(CW\*(C`Decode_Date_EU()\*(C'\fR"
(implemented in C), included here merely as an example to demonstrate how
easy it is to write your own routine in Perl (using regular expressions)
adapted to your own special needs, should the necessity arise, and intended
primarily as a basis for your own development.
.Sp
In one particular case this Perl version is actually slightly more permissive
than its C equivalent, as far as the class of permitted intervening (i.e.,
delimiting) characters is concerned.
.Sp
(Can you tell the subtle, almost insignificant difference by looking at
the code? Or by experimenting? Hint: Try the string \*(L"a3b1c64d\*(R" with both
functions.)
.IP "\(bu" 2
\&\f(CW\*(C`if (($year,$month,$day) = Decode_Date_US2($string[,$lang))\*(C'\fR
.Sp
This function is the Perl equivalent of the function "\f(CW\*(C`Decode_Date_US()\*(C'\fR"
(implemented in C), included here merely as an example to demonstrate how
easy it is to write your own routine in Perl (using regular expressions)
adapted to your own special needs, should the necessity arise, and intended
primarily as a basis for your own development.
.Sp
In one particular case this Perl version is actually slightly more permissive
than its C equivalent.
.Sp
(Hint: This is the same difference as with the "\f(CW\*(C`Decode_Date_EU()\*(C'\fR\*(L" and
\&\*(R"\f(CW\*(C`Decode_Date_EU2()\*(C'\fR" pair of functions.)
.Sp
In a different case, the C version is a little bit more permissive than its
Perl equivalent.
.Sp
(Can you tell the difference by looking at the code? Or by experimenting?
Hint: Try the string \*(L"(1/364)\*(R" with both functions.)
.IP "\(bu" 2
\&\f(CW\*(C`if (($year,$month,$day) = Parse_Date($string[,$lang))\*(C'\fR
.Sp
This function is useful for parsing dates as returned by the \s-1UNIX "\s0\f(CW\*(C`date\*(C'\fR"
command or as found in the headers of e\-mail (in order to determine the
date at which some e\-mail has been sent or received, for instance).
.Sp
Example #1:
.Sp
.Vb 1
\&  ($year,$month,$day) = Parse_Date(\`/bin/date\`);
.Ve
.Sp
Example #2:
.Sp
.Vb 9
\&  while (<MAIL>)
\&  {
\&      if (/^From \eS/)
\&      {
\&          ($year,$month,$day) = Parse_Date($_);
\&          ...
\&      }
\&      ...
\&  }
.Ve
.Sp
The function returns an empty list if it can't extract a valid date from
the input string.
.IP "\(bu" 2
\&\f(CW\*(C`$lower = ISO_LC($string);\*(C'\fR
.Sp
Returns a copy of the given string where all letters of the ISO\-Latin\-1
character set have been replaced by their lower case equivalents.
.Sp
Similar to Perl's built-in function "\f(CW\*(C`lc()\*(C'\fR" (see \*(L"lc\*(R" in \fIperlfunc\fR\|(1)) but
for the whole ISO\-Latin\-1 character set, not just plain \s-1ASCII.\s0
.IP "\(bu" 2
\&\f(CW\*(C`$upper = ISO_UC($string);\*(C'\fR
.Sp
Returns a copy of the given string where all letters of the ISO\-Latin\-1
character set have been replaced by their upper case equivalents.
.Sp
Similar to Perl's built-in function "\f(CW\*(C`uc()\*(C'\fR" (see \*(L"uc\*(R" in \fIperlfunc\fR\|(1)) but
for the whole ISO\-Latin\-1 character set, not just plain \s-1ASCII.\s0
.IP "\(bu" 2
\&\f(CW\*(C`$string = Date::Calc::Version();\*(C'\fR
.Sp
This function returns a string with the (numeric) version number of the
C\ library (\*(L"DateCalc.c\*(R") at the core of this package (which is also
(automatically) the version number of the \*(L"Calc.xs\*(R" file).
.Sp
Note that under all normal circumstances, this version number should be
identical with the one found in the Perl variable "\f(CW$Date::Calc::VERSION\fR\*(L"
(the version number of the \*(R"Calc.pm" file).
.Sp
Since this function is not exported, you always have to qualify it explicitly,
i.e., "\f(CW\*(C`Date::Calc::Version()\*(C'\fR".
.Sp
This is to avoid possible name space conflicts with version functions from
other modules.
.SH "RECIPES"
.IX Header "RECIPES"
.IP "1)" 4
.IX Item "1)"
How do I compare two dates?
.Sp
Solution #1:
.Sp
.Vb 1
\&  use Date::Calc qw( Date_to_Days );
\&
\&  if (Date_to_Days($year1,$month1,$day1)  <
\&      Date_to_Days($year2,$month2,$day2))
\&
\&  if (Date_to_Days($year1,$month1,$day1)  <=
\&      Date_to_Days($year2,$month2,$day2))
\&
\&  if (Date_to_Days($year1,$month1,$day1)  >
\&      Date_to_Days($year2,$month2,$day2))
\&
\&  if (Date_to_Days($year1,$month1,$day1)  >=
\&      Date_to_Days($year2,$month2,$day2))
\&
\&  if (Date_to_Days($year1,$month1,$day1)  ==
\&      Date_to_Days($year2,$month2,$day2))
\&
\&  if (Date_to_Days($year1,$month1,$day1)  !=
\&      Date_to_Days($year2,$month2,$day2))
\&
\&  $cmp = (Date_to_Days($year1,$month1,$day1)  <=>
\&          Date_to_Days($year2,$month2,$day2));
.Ve
.Sp
Solution #2:
.Sp
.Vb 1
\&  use Date::Calc qw( Delta_Days );
\&
\&  if (Delta_Days($year1,$month1,$day1,
\&                 $year2,$month2,$day2) > 0)
\&
\&  if (Delta_Days($year1,$month1,$day1,
\&                 $year2,$month2,$day2) >= 0)
\&
\&  if (Delta_Days($year1,$month1,$day1,
\&                 $year2,$month2,$day2) < 0)
\&
\&  if (Delta_Days($year1,$month1,$day1,
\&                 $year2,$month2,$day2) <= 0)
\&
\&  if (Delta_Days($year1,$month1,$day1,
\&                 $year2,$month2,$day2) == 0)
\&
\&  if (Delta_Days($year1,$month1,$day1,
\&                 $year2,$month2,$day2) != 0)
.Ve
.IP "2)" 4
.IX Item "2)"
How do I check whether a given date lies within a certain range of dates?
.Sp
.Vb 1
\&  use Date::Calc qw( Date_to_Days );
\&
\&  $lower = Date_to_Days($year1,$month1,$day1);
\&  $upper = Date_to_Days($year2,$month2,$day2);
\&
\&  $date = Date_to_Days($year,$month,$day);
\&
\&  if (($date >= $lower) && ($date <= $upper))
\&  {
\&      # ok
\&  }
\&  else
\&  {
\&      # not ok
\&  }
.Ve
.IP "3)" 4
.IX Item "3)"
How do I compare two dates with times? How do I check whether two dates
and times lie more or less than a given time interval apart?
.Sp
Solution #1:
.Sp
.Vb 1
\&  use Date::Calc qw( Add_Delta_DHMS Date_to_Days );
\&
\&  @date1 = (2002,8,31,23,59,1);
\&  @date2 = (2002,9,1,11,30,59); # ==> less than 12 hours
\&
\&  #@date1 = (2002,8,31,22,59,1);
\&  #@date2 = (2002,9,1,11,30,59); # ==> more than 12 hours
\&
\&  # Omit the next line if you just want to compare the two dates
\&  # (and change @date3 and @d3 to @date1 and @d1, respectively):
\&
\&  @date3 = Add_Delta_DHMS(@date1, 0,12,0,0); # ==> is the difference within 12 hours?
\&
\&  @d2 = ( Date_to_Days(@date2[0..2]), ($date2[3]*60+$date2[4])*60+$date2[5] );
\&  @d3 = ( Date_to_Days(@date3[0..2]), ($date3[3]*60+$date3[4])*60+$date3[5] );
\&
\&  @diff = ( $d2[0]\-$d3[0], $d2[1]\-$d3[1] );
\&
\&  if ($diff[0] > 0 and $diff[1] < 0) { $diff[0]\-\-; $diff[1] += 86400; }
\&  if ($diff[0] < 0 and $diff[1] > 0) { $diff[0]++; $diff[1] \-= 86400; }
\&
\&  if (($diff[0] || $diff[1]) >= 0) { print "More than 12 hours.\en"; }
\&  else                             { print "Less than 12 hours.\en"; }
.Ve
.Sp
Solution #2:
.Sp
This solution is only feasible if your dates are guaranteed to lie
within the range given by your system's epoch and overflow date and
time!
.Sp
.Vb 2
\&     Unix:    1\-Jan\-1970 00:00:00  to  19\-Jan\-2038 03:14:07
\&     MacOS:   1\-Jan\-1904 00:00:00  to   6\-Feb\-2040 06:28:15
\&
\&  use Date::Calc qw( Date_to_Time );
\&
\&  @date1 = (2002,8,31,23,59,1);
\&  @date2 = (2002,9,1,11,30,59); # ==> less than 12 hours
\&
\&  #@date1 = (2002,8,31,22,59,1);
\&  #@date2 = (2002,9,1,11,30,59); # ==> more than 12 hours
\&
\&  $d1 = Date_to_Time(@date1);
\&  $d2 = Date_to_Time(@date2);
\&
\&  if ($d1 <= $d2) { print "The two dates are in chronological order.\en"; }
\&  else            { print "The two dates are in reversed order.\en"; }
\&
\&  if ($d1 + 12*60*60 <= $d2) { print "More than 12 hours.\en"; }
\&  else                       { print "Less than 12 hours.\en"; }
.Ve
.IP "4)" 4
.IX Item "4)"
How do I verify whether someone has a certain age?
.Sp
.Vb 1
\&  use Date::Calc qw( Decode_Date_EU Today leap_year Delta_Days );
\&
\&  $date = <STDIN>; # get birthday
\&
\&  ($year1,$month1,$day1) = Decode_Date_EU($date);
\&
\&  ($year2,$month2,$day2) = Today();
\&
\&  if (($day1 == 29) && ($month1 == 2) && !leap_year($year2))
\&      { $day1\-\-; }
\&
\&  if ( (($year2 \- $year1) >  18) ||
\&     ( (($year2 \- $year1) == 18) &&
\&     (Delta_Days($year2,$month1,$day1, $year2,$month2,$day2) >= 0) ) )
\&  {
\&      print "Ok \- you are over 18.\en";
\&  }
\&  else
\&  {
\&      print "Sorry \- you aren\*(Aqt 18 yet!\en";
\&  }
\&
\&  Or, alternatively (substituting the last "if" statement above):
\&
\&  if (($year1+18 <=> $year2 || $month1 <=> $month2 || $day1 <=> $day2) <= 0)
\&      { print "Ok \- you are over 18.\en"; }
\&  else
\&      { print "Sorry \- you aren\*(Aqt 18 yet!\en"; }
.Ve
.IP "5)" 4
.IX Item "5)"
How do I calculate the number of the week of month
the current date lies in?
.Sp
For example:
.Sp
.Vb 7
\&            April 1998
\&    Mon Tue Wed Thu Fri Sat Sun
\&              1   2   3   4   5  =  week #1
\&      6   7   8   9  10  11  12  =  week #2
\&     13  14  15  16  17  18  19  =  week #3
\&     20  21  22  23  24  25  26  =  week #4
\&     27  28  29  30              =  week #5
.Ve
.Sp
Solution:
.Sp
.Vb 1
\&  use Date::Calc qw( Today Day_of_Week );
\&
\&  ($year,$month,$day) = Today();
\&
\&  $week = int(($day + Day_of_Week($year,$month,1) \- 2) / 7) + 1;
.Ve
.IP "6)" 4
.IX Item "6)"
How do I calculate whether a given date is the 1st, 2nd, 3rd, 4th or 5th
of that day of week in the given month?
.Sp
For example:
.Sp
.Vb 8
\&           October 2000
\&    Mon Tue Wed Thu Fri Sat Sun
\&                              1
\&      2   3   4   5   6   7   8
\&      9  10  11  12  13  14  15
\&     16  17  18  19  20  21  22
\&     23  24  25  26  27  28  29
\&     30  31
.Ve
.Sp
Is Sunday, the 15th of October 2000, the 1st, 2nd, 3rd, 4th or 5th
Sunday of that month?
.Sp
Solution:
.Sp
.Vb 4
\&  use Date::Calc qw( Day_of_Week Delta_Days
\&                     Nth_Weekday_of_Month_Year
\&                     Date_to_Text_Long English_Ordinal
\&                     Day_of_Week_to_Text Month_to_Text );
\&
\&  ($year,$month,$day) = (2000,10,15);
\&
\&  $dow = Day_of_Week($year,$month,$day);
\&
\&  $n = int( Delta_Days(
\&            Nth_Weekday_of_Month_Year($year,$month,$dow,1),
\&            $year,$month,$day)
\&            / 7) + 1;
\&
\&  printf("%s is the %s %s in %s %d.\en",
\&      Date_to_Text_Long($year,$month,$day),
\&      English_Ordinal($n),
\&      Day_of_Week_to_Text($dow),
\&      Month_to_Text($month),
\&      $year);
.Ve
.Sp
This prints:
.Sp
.Vb 1
\&  Sunday, October 15th 2000 is the 3rd Sunday in October 2000.
.Ve
.IP "7)" 4
.IX Item "7)"
How do I calculate the date of the Wednesday of the same week as
the current date?
.Sp
Solution #1:
.Sp
.Vb 1
\&  use Date::Calc qw( Today Day_of_Week Add_Delta_Days );
\&
\&  $searching_dow = 3; # 3 = Wednesday
\&
\&  @today = Today();
\&
\&  $current_dow = Day_of_Week(@today);
\&
\&  @date = Add_Delta_Days(@today, $searching_dow \- $current_dow);
.Ve
.Sp
Solution #2:
.Sp
.Vb 2
\&  use Date::Calc qw( Today Add_Delta_Days
\&                     Monday_of_Week Week_of_Year );
\&
\&  $searching_dow = 3; # 3 = Wednesday
\&
\&  @today = Today();
\&
\&  @date = Add_Delta_Days( Monday_of_Week( Week_of_Year(@today) ),
\&                          $searching_dow \- 1 );
.Ve
.Sp
Solution #3:
.Sp
.Vb 2
\&  use Date::Calc qw( Standard_to_Business Today
\&                     Business_to_Standard );
\&
\&  @business = Standard_to_Business(Today());
\&
\&  $business[2] = 3; # 3 = Wednesday
\&
\&  @date = Business_to_Standard(@business);
.Ve
.IP "8)" 4
.IX Item "8)"
How can I add a week offset to a business date (including across
year boundaries)?
.Sp
.Vb 2
\&  use Date::Calc qw( Business_to_Standard Add_Delta_Days
\&                     Standard_to_Business );
\&
\&  @temp = Business_to_Standard($year,$week,$dow);
\&
\&  @temp = Add_Delta_Days(@temp, $week_offset * 7);
\&
\&  ($year,$week,$dow) = Standard_to_Business(@temp);
.Ve
.IP "9)" 4
.IX Item "9)"
How do I calculate the last and the next Saturday for any
given date?
.Sp
.Vb 2
\&  use Date::Calc qw( Today Day_of_Week Add_Delta_Days
\&                     Day_of_Week_to_Text Date_to_Text );
\&
\&  $searching_dow = 6; # 6 = Saturday
\&
\&  @today = Today();
\&
\&  $current_dow = Day_of_Week(@today);
\&
\&  if ($searching_dow == $current_dow)
\&  {
\&      @prev = Add_Delta_Days(@today,\-7);
\&      @next = Add_Delta_Days(@today,+7);
\&  }
\&  else
\&  {
\&      if ($searching_dow > $current_dow)
\&      {
\&          @next = Add_Delta_Days(@today,
\&                    $searching_dow \- $current_dow);
\&          @prev = Add_Delta_Days(@next,\-7);
\&      }
\&      else
\&      {
\&          @prev = Add_Delta_Days(@today,
\&                    $searching_dow \- $current_dow);
\&          @next = Add_Delta_Days(@prev,+7);
\&      }
\&  }
\&
\&  $dow = Day_of_Week_to_Text($searching_dow);
\&
\&  print "Today is:      ", \*(Aq \*(Aq x length($dow),
\&                               Date_to_Text(@today), "\en";
\&  print "Last $dow was:     ", Date_to_Text(@prev),  "\en";
\&  print "Next $dow will be: ", Date_to_Text(@next),  "\en";
.Ve
.Sp
This will print something like:
.Sp
.Vb 3
\&  Today is:              Sun 12\-Apr\-1998
\&  Last Saturday was:     Sat 11\-Apr\-1998
\&  Next Saturday will be: Sat 18\-Apr\-1998
.Ve
.IP "10)" 4
.IX Item "10)"
How can I calculate the last business day (payday!) of a month?
.Sp
Solution #1 (holidays \fB\s-1NOT\s0\fR taken into account):
.Sp
.Vb 1
\&  use Date::Calc qw( Days_in_Month Day_of_Week Add_Delta_Days );
\&
\&  $day = Days_in_Month($year,$month);
\&  $dow = Day_of_Week($year,$month,$day);
\&  if ($dow > 5)
\&  {
\&      ($year,$month,$day) =
\&          Add_Delta_Days($year,$month,$day, 5\-$dow);
\&  }
.Ve
.Sp
Solution #2 (holidays taken into account):
.Sp
This solution expects a multi-dimensional array "\f(CW@holiday\fR\*(L", which
contains all holidays, as follows: \*(R"\f(CW\*(C`$holiday[$year][$month][$day] = 1;\*(C'\fR".
.Sp
(See the description of the function "\f(CW\*(C`Easter_Sunday()\*(C'\fR" further above for
how to calculate the moving (variable) christian feast days!)
.Sp
Days which are not holidays remain undefined or should have a value of zero
in this array.
.Sp
.Vb 1
\&  use Date::Calc qw( Days_in_Month Add_Delta_Days Day_of_Week );
\&
\&  $day = Days_in_Month($year,$month);
\&  while (1)
\&  {
\&      while ($holiday[$year][$month][$day])
\&      {
\&          ($year,$month,$day) =
\&              Add_Delta_Days($year,$month,$day, \-1);
\&      }
\&      $dow = Day_of_Week($year,$month,$day);
\&      if ($dow > 5)
\&      {
\&          ($year,$month,$day) =
\&              Add_Delta_Days($year,$month,$day, 5\-$dow);
\&      }
\&      else { last; }
\&  }
.Ve
.Sp
Solution #3 (holidays taken into account, more comfortable,
but requires \fIDate::Calendar\fR\|(3) and \fIDate::Calc::Object\fR\|(3)):
.Sp
.Vb 3
\&  use Date::Calc::Object qw( Today Add_Delta_YM Date_to_Text_Long );
\&  use Date::Calendar::Profiles qw($Profiles);
\&  use Date::Calendar;
\&
\&  $calendar = Date::Calendar\->new( $Profiles\->{\*(AqDE\-BW\*(Aq} );
\&
\&  @today = Today();
\&  @nextmonth = Add_Delta_YM(@today[0,1],1, 0,1);
\&
\&  $workaround = $calendar\->add_delta_workdays(@nextmonth,+1);
\&  $payday     = $calendar\->add_delta_workdays($workaround,\-2);
\&
\&  print "Pay day = ", Date_to_Text_Long($payday\->date()), "\en";
.Ve
.Sp
The \*(L"workaround\*(R" is necessary due to a bug in the method
\&\*(L"\fIadd_delta_workdays()\fR\*(R" when adding a negative number of
workdays.
.IP "11)" 4
.IX Item "11)"
How do I convert a \s-1MS\s0 Visual Basic \*(L"\s-1DATETIME\*(R"\s0 value into its date
and time constituents?
.Sp
.Vb 1
\&  use Date::Calc qw( Add_Delta_DHMS Date_to_Text );
\&
\&  $datetime = "35883.121653";
\&
\&  ($Dd,$Dh,$Dm,$Ds) = ($datetime =~ /^(\ed+)\e.(\ed\ed)(\ed\ed)(\ed\ed)$/);
\&
\&  ($year,$month,$day, $hour,$min,$sec) =
\&      Add_Delta_DHMS(1900,1,1, 0,0,0, $Dd,$Dh,$Dm,$Ds);
\&
\&  printf("The given date is %s %02d:%02d:%02d\en",
\&      Date_to_Text($year,$month,$day), $hour, $min, $sec);
.Ve
.Sp
This prints:
.Sp
.Vb 1
\&  The given date is Tue 31\-Mar\-1998 12:16:53
.Ve
.Sp
Since I do not have or use Visual Basic, I can't guarantee that
the number format assumed here is really the one used by Visual
Basic \- but you get the general idea. \f(CW\*(C`:\-)\*(C'\fR
.Sp
Moreover, consider the following:
.Sp
Morten Sickel <Morten.Sickel@nrpa.no> wrote:
.Sp
I discovered a bug in Excel (2000): Excel thinks that 1900 was
a leap year. Users should use 31\-Dec\-1899 as the date to add
an Excel date value to in order to get the correct date.
.Sp
I found out on the web that this bug originated in Lotus 123,
which made 29\-Feb\-1900 an \*(L"industrial standard\*(R". \s-1MS\s0 chose to
keep the bug in order to be compatible with Lotus 123. But
they have not mentioned anything about it in the help files.
.IP "12)" 4
.IX Item "12)"
How can I send a reminder to members of a group on the day
before a meeting which occurs every first Friday of a month?
.Sp
.Vb 2
\&  use Date::Calc qw( Today Date_to_Days Add_Delta_YMD
\&                     Nth_Weekday_of_Month_Year );
\&
\&  ($year,$month,$day) = Today();
\&
\&  $tomorrow = Date_to_Days($year,$month,$day) + 1;
\&
\&  $dow = 5; # 5 = Friday
\&  $n   = 1; # 1 = First of that day of week
\&
\&  $meeting_this_month = Date_to_Days(
\&      Nth_Weekday_of_Month_Year($year,$month,$dow,$n) );
\&
\&  ($year,$month,$day) = Add_Delta_YMD($year,$month,$day, 0,1,0);
\&
\&  $meeting_next_month = Date_to_Days(
\&      Nth_Weekday_of_Month_Year($year,$month,$dow,$n) );
\&
\&  if (($tomorrow == $meeting_this_month) ||
\&      ($tomorrow == $meeting_next_month))
\&  {
\&      # Send reminder e\-mail!
\&  }
.Ve
.IP "13)" 4
.IX Item "13)"
How can I print a date in a different format than provided by
the functions "\f(CW\*(C`Date_to_Text()\*(C'\fR\*(L", \*(R"\f(CW\*(C`Date_to_Text_Long()\*(C'\fR\*(L" or
\&\*(R"\f(CW\*(C`Compressed_to_Text()\*(C'\fR"?
.Sp
.Vb 3
\&  use Date::Calc qw( Today Day_of_Week_to_Text
\&                     Day_of_Week Month_to_Text
\&                     English_Ordinal );
\&
\&  ($year,$month,$day) = Today();
.Ve
.Sp
For example with leading zeros for the day: \*(L"Fri\ 03\-Jan\-1964\*(R"
.Sp
.Vb 5
\&  printf("%.3s %02d\-%.3s\-%d\en",
\&      Day_of_Week_to_Text(Day_of_Week($year,$month,$day)),
\&      $day,
\&      Month_to_Text($month),
\&      $year);
.Ve
.Sp
For example in U.S. american format: \*(L"April\ 12th,\ 1998\*(R"
.Sp
.Vb 4
\&  $string = sprintf("%s %s, %d",
\&                Month_to_Text($month),
\&                English_Ordinal($day),
\&                $year);
.Ve
.Sp
For example in one of the possible formats as specified by \s-1ISO\s0\ 8601:
.Sp
.Vb 2
\&  @date = ($year,$month,$day,$hour,$min,$sec);
\&  $date = sprintf("%d\-%02d\-%02d %02d:%02d:%02d", @date);
.Ve
.Sp
(See also \*(L"printf\*(R" in \fIperlfunc\fR\|(1) and/or \*(L"sprintf\*(R" in \fIperlfunc\fR\|(1)!)
.IP "14)" 4
.IX Item "14)"
How can I iterate through a range of dates?
.Sp
.Vb 1
\&  use Date::Calc qw( Delta_Days Add_Delta_Days );
\&
\&  @start = (1999,5,27);
\&  @stop  = (1999,6,1);
\&
\&  $j = Delta_Days(@start,@stop);
\&
\&  for ( $i = 0; $i <= $j; $i++ )
\&  {
\&      @date = Add_Delta_Days(@start,$i);
\&      printf("%4d/%02d/%02d\en", @date);
\&  }
.Ve
.Sp
Note that the loop can be improved; see also the recipe below.
.IP "15)" 4
.IX Item "15)"
How can I create a (Perl) list of dates in a certain range?
.Sp
.Vb 1
\&  use Date::Calc qw( Delta_Days Add_Delta_Days Date_to_Text );
\&
\&  sub date_range
\&  {
\&      my(@date) = (@_)[0,1,2];
\&      my(@list);
\&      my($i);
\&
\&      $i = Delta_Days(@_);
\&      while ($i\-\- >= 0)
\&      {
\&          push( @list, [ @date ] );
\&          @date = Add_Delta_Days(@date, 1) if ($i >= 0);
\&      }
\&      return(@list);
\&  }
\&
\&  @range = &date_range(1999,11,3, 1999,12,24); # in chronological order
\&
\&  foreach $date (@range)
\&  {
\&      print Date_to_Text(@{$date}), "\en";
\&  }
.Ve
.Sp
Note that you probably shouldn't use this one, because it is much
more efficient to iterate through all the dates (as shown in the
recipe immediately above) than to construct such an array and then
to loop through it. Also, it is much more space-efficient not to
create this array.
.IP "16)" 4
.IX Item "16)"
How can I calculate the difference in days between dates,
but without counting Saturdays and Sundays?
.Sp
.Vb 5
\&  sub Delta_Business_Days
\&  {
\&      my(@date1) = (@_)[0,1,2];
\&      my(@date2) = (@_)[3,4,5];
\&      my($minus,$result,$dow1,$dow2,$diff,$temp);
\&
\&      $minus  = 0;
\&      $result = Delta_Days(@date1,@date2);
\&      if ($result != 0)
\&      {
\&          if ($result < 0)
\&          {
\&              $minus = 1;
\&              $result = \-$result;
\&              $dow1 = Day_of_Week(@date2);
\&              $dow2 = Day_of_Week(@date1);
\&          }
\&          else
\&          {
\&              $dow1 = Day_of_Week(@date1);
\&              $dow2 = Day_of_Week(@date2);
\&          }
\&          $diff = $dow2 \- $dow1;
\&          $temp = $result;
\&          if ($diff != 0)
\&          {
\&              if ($diff < 0)
\&              {
\&                  $diff += 7;
\&              }
\&              $temp \-= $diff;
\&              $dow1 += $diff;
\&              if ($dow1 > 6)
\&              {
\&                  $result\-\-;
\&                  if ($dow1 > 7)
\&                  {
\&                      $result\-\-;
\&                  }
\&              }
\&          }
\&          if ($temp != 0)
\&          {
\&              $temp /= 7;
\&              $result \-= ($temp << 1);
\&          }
\&      }
\&      if ($minus) { return \-$result; }
\&      else        { return  $result; }
\&  }
.Ve
.Sp
This solution is probably of little practical value, however,
because it doesn't take legal holidays into account.
.Sp
See \fIDate::Calendar\fR\|(3) for how to do that.
.IP "17)" 4
.IX Item "17)"
How can I \*(L"normalize\*(R" the output of the \*(L"\fIDelta_YMDHMS()\fR\*(R" (or \*(L"\fIDelta_YMD()\fR\*(R")
function so that it contains only positive values?
.Sp
I.e., how can I show a difference in date (and time) in a more human-readable
form, for example in order to show how much time until (or since) the expiration
of something (e.g. an account, a domain, a credit card, etc.) is left (has passed)?
.Sp
Correct solution: Use the functions \*(L"\fIN_Delta_YMDHMS()\fR\*(R" and \*(L"\fIN_Delta_YMD()\fR\*(R" instead!
.Sp
The following gives a rudimentary sketch of a (much inferior) solution,
which is maintained here only for historical reasons of this module:
.Sp
a) \fIDelta_YMDHMS()\fR:
.Sp
.Vb 3
\&  #!perl
\&  use strict;
\&  use Date::Calc qw(Today_and_Now Delta_YMDHMS Add_Delta_YMDHMS Delta_DHMS Date_to_Text);
\&
\&  my $today = [Today_and_Now()];
\&  my $target = [2005,1,1,0,0,0];
\&
\&  my $sign = "until";
\&  my $delta = Normalize_Delta_YMDHMS($today,$target);
\&  if ($delta\->[0] < 0)
\&  {
\&      $sign = "since";
\&      $delta = Normalize_Delta_YMDHMS($target,$today);
\&  }
\&  printf("Today is %s %02d:%02d:%02d\en", Date_to_Text(@{$today}[0..2]), @{$today}[3..5]);
\&  printf
\&  (
\&      "%d year%s, %d month%s, %d day%s, %d hour%s, %d minute%s, %d second%s %s %s %02d:%02d:%02d\en",
\&      $delta\->[0], (($delta\->[0]==1)?\*(Aq\*(Aq:\*(Aqs\*(Aq),
\&      $delta\->[1], (($delta\->[1]==1)?\*(Aq\*(Aq:\*(Aqs\*(Aq),
\&      $delta\->[2], (($delta\->[2]==1)?\*(Aq\*(Aq:\*(Aqs\*(Aq),
\&      $delta\->[3], (($delta\->[3]==1)?\*(Aq\*(Aq:\*(Aqs\*(Aq),
\&      $delta\->[4], (($delta\->[4]==1)?\*(Aq\*(Aq:\*(Aqs\*(Aq),
\&      $delta\->[5], (($delta\->[5]==1)?\*(Aq\*(Aq:\*(Aqs\*(Aq),
\&      $sign,
\&      Date_to_Text(@{$target}[0..2]),
\&      @{$target}[3..5]
\&  );
\&
\&  sub Normalize_Delta_YMDHMS
\&  {
\&      my($date1,$date2) = @_;
\&      my(@delta);
\&
\&      @delta = Delta_YMDHMS(@$date1,@$date2);
\&      while ($delta[1] < 0 or
\&             $delta[2] < 0 or
\&             $delta[3] < 0 or
\&             $delta[4] < 0 or
\&             $delta[5] < 0)
\&      {
\&          if ($delta[1] < 0) { $delta[0]\-\-; $delta[1] += 12; }
\&          if ($delta[2] < 0)
\&          {
\&              $delta[1]\-\-;
\&              @delta[2..5] = (0,0,0,0);
\&              @delta[2..5] = Delta_DHMS(Add_Delta_YMDHMS(@$date1,@delta),@$date2);
\&          }
\&          if ($delta[3] < 0) { $delta[2]\-\-; $delta[3] += 24; }
\&          if ($delta[4] < 0) { $delta[3]\-\-; $delta[4] += 60; }
\&          if ($delta[5] < 0) { $delta[4]\-\-; $delta[5] += 60; }
\&      }
\&      return \e@delta;
\&  }
.Ve
.Sp
b) \fIDelta_YMD()\fR:
.Sp
.Vb 3
\&  #!perl
\&  use strict;
\&  use Date::Calc qw(Today Delta_YMD Add_Delta_YM Delta_Days Date_to_Text);
\&
\&  my($sign,$delta);
\&  my $today = [Today()];
\&  my $target = [2005,1,1];
\&
\&  if (Delta_Days(@$today,@$target) < 0)
\&  {
\&      $sign = "since";
\&      $delta = Normalize_Delta_YMD($target,$today);
\&  }
\&  else
\&  {
\&      $sign = "until";
\&      $delta = Normalize_Delta_YMD($today,$target);
\&  }
\&  print "Today is ", Date_to_Text(@$today), "\en";
\&  printf
\&  (
\&      "%d year%s, %d month%s, %d day%s %s %s\en",
\&      $delta\->[0], (($delta\->[0]==1)?\*(Aq\*(Aq:\*(Aqs\*(Aq),
\&      $delta\->[1], (($delta\->[1]==1)?\*(Aq\*(Aq:\*(Aqs\*(Aq),
\&      $delta\->[2], (($delta\->[2]==1)?\*(Aq\*(Aq:\*(Aqs\*(Aq),
\&      $sign,
\&      Date_to_Text(@$target)
\&  );
\&
\&  sub Normalize_Delta_YMD
\&  {
\&      my($date1,$date2) = @_;
\&      my(@delta);
\&
\&      @delta = Delta_YMD(@$date1,@$date2);
\&      while ($delta[1] < 0 or $delta[2] < 0)
\&      {
\&          if ($delta[1] < 0) { $delta[0]\-\-; $delta[1] += 12; }
\&          if ($delta[2] < 0)
\&          {
\&              $delta[1]\-\-;
\&              $delta[2] = Delta_Days(Add_Delta_YM(@$date1,@delta[0,1]),@$date2);
\&          }
\&      }
\&      return \e@delta;
\&  }
.Ve
.Sp
Note that for normalizing just a time vector, you can use the built-in
function \*(L"\fINormalize_DHMS()\fR\*(R". However, this will yield either all positive
\&\fB\s-1OR\s0\fR all negative values, \fB\s-1NOT\s0\fR all positive values as above.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fIDate::Calc::Util\fR\|(3), \fIDate::Calc::Object\fR\|(3),
\&\fIDate::Calendar\fR\|(3), \fIDate::Calendar::Year\fR\|(3),
\&\fIDate::Calendar::Profiles\fR\|(3).
.PP
.Vb 3
\&  "The Calendar FAQ":
\&  http://www.tondering.dk/claus/calendar.html
\&  by Claus Tondering <claus@tondering.dk>
.Ve
.SH "BEWARE"
.IX Header "BEWARE"
When you are using the (deprecated) function \*(L"\fILanguage()\fR\*(R", the language
setting is stored in a global variable.
.PP
This may cause conflicts between threads or modules running concurrently.
.PP
Therefore, in order to avoid such conflicts, \s-1NEVER\s0 use the function
\&\*(L"\fILanguage()\fR\*(R", but \s-1ALWAYS\s0 pass a language parameter to the functions
which are language-dependent.
.SH "VERSION"
.IX Header "VERSION"
This man page documents \*(L"Date::Calc\*(R" version 6.3.
.SH "AUTHOR"
.IX Header "AUTHOR"
.Vb 3
\&  Steffen Beyer
\&  mailto:STBEY@cpan.org
\&  http://www.engelschall.com/u/sb/download/
.Ve
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (c) 1995 \- 2009 by Steffen Beyer. All rights reserved.
.SH "LICENSE"
.IX Header "LICENSE"
This package is free software; you can use, modify and redistribute
it under the same terms as Perl itself, i.e., at your option, under
the terms either of the \*(L"Artistic License\*(R" or the \*(L"\s-1GNU\s0 General Public
License\*(R".
.PP
The C library at the core of the module \*(L"Date::Calc::XS\*(R" can, at your
discretion, also be used, modified and redistributed under the terms
of the \*(L"\s-1GNU\s0 Library General Public License\*(R".
.PP
Please refer to the files \*(L"Artistic.txt\*(R", \*(L"\s-1GNU_GPL\s0.txt\*(R" and
\&\*(L"\s-1GNU_LGPL\s0.txt\*(R" in the \*(L"license\*(R" subdirectory of this distribution
for any details!
.SH "DISCLAIMER"
.IX Header "DISCLAIMER"
This package is distributed in the hope that it will be useful,
but \s-1WITHOUT ANY WARRANTY\s0; without even the implied warranty of
\&\s-1MERCHANTABILITY\s0 or \s-1FITNESS FOR A PARTICULAR PURPOSE.\s0
.PP
See the \*(L"\s-1GNU\s0 General Public License\*(R" for more details.
.SH "POD ERRORS"
.IX Header "POD ERRORS"
Hey! \fBThe above document had some coding errors, which are explained below:\fR
.IP "Around line 1761:" 4
.IX Item "Around line 1761:"
Non-ASCII character seen before =encoding in 'Franc\*,ais'. Assuming \s-1ISO8859\-1\s0
