.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "IP 3"
.TH IP 3 "2014-01-27" "perl v5.18.4" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
NetAddr::IP \- Manages IPv4 and IPv6 addresses and subnets
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 10
\&  use NetAddr::IP qw(
\&        Compact
\&        Coalesce
\&        Zeros
\&        Ones
\&        V4mask
\&        V4net
\&        netlimit
\&        :aton           DEPRECATED
\&        :lower
\&        :upper
\&        :old_storable
\&        :old_nth
\&        :rfc3021
\&  );
\&
\&  NOTE: NetAddr::IP::Util has a full complement of network address
\&        utilities to convert back and forth between binary and text.
\&
\&        inet_aton, inet_ntoa, ipv6_aton, ipv6_ntoa 
\&        ipv6_n2x, ipv6_n2d inet_any2d, inet_n2dx, 
\&        inet_n2ad, inetanyto6, ipv6to4
.Ve
.PP
See NetAddr::IP::Util
.PP
.Vb 7
\&  my $ip = new NetAddr::IP \*(Aq127.0.0.1\*(Aq;
\&         or if you prefer
\&  my $ip = NetAddr::IP\->new(\*(Aq127.0.0.1);
\&        or from a packed IPv4 address
\&  my $ip = new_from_aton NetAddr::IP (inet_aton(\*(Aq127.0.0.1\*(Aq));
\&        or from an octal filtered IPv4 address
\&  my $ip = new_no NetAddr::IP \*(Aq127.012.0.0\*(Aq;
\&
\&  print "The address is ", $ip\->addr, " with mask ", $ip\->mask, "\en" ;
\&
\&  if ($ip\->within(new NetAddr::IP "127.0.0.0", "255.0.0.0")) {
\&      print "Is a loopback address\en";
\&  }
\&
\&                                # This prints 127.0.0.1/32
\&  print "You can also say $ip...\en";
.Ve
.PP
* The following four functions return ipV6 representations of:
.PP
.Vb 4
\&  ::                                       = Zeros();
\&  FFFF:FFFF:FFFF:FFFF:FFFF:FFFF:FFFF:FFFF  = Ones();
\&  FFFF:FFFF:FFFF:FFFF:FFFF:FFFF::          = V4mask();
\&  ::FFFF:FFFF                              = V4net();
.Ve
.PP
###### \s-1DEPRECATED,\s0 will be remove in version 5 ############
.PP
.Vb 2
\&  * To accept addresses in the format as returned by
\&  inet_aton, invoke the module as:
\&
\&  use NetAddr::IP qw(:aton);
.Ve
.PP
###### \s-1USE\s0 new_from_aton instead ##########################
.PP
* To enable usage of legacy data files containing NetAddr::IP
objects stored using the Storable module.
.PP
.Vb 1
\&  use NetAddr::IP qw(:old_storable);
.Ve
.PP
* To compact many smaller subnets (see: \f(CW\*(C`$me\->compact($addr1,$addr2,...)\*(C'\fR
.PP
.Vb 1
\&  @compacted_object_list = Compact(@object_list)
.Ve
.PP
* Return a reference to list of \f(CW\*(C`NetAddr::IP\*(C'\fR subnets of
\&\f(CW$masklen\fR mask length, when \f(CW$number\fR or more addresses from
\&\f(CW@list_of_subnets\fR are found to be contained in said subnet.
.PP
.Vb 1
\&  $arrayref = Coalesce($masklen, $number, @list_of_subnets)
.Ve
.PP
* By default \fBNetAddr::IP\fR functions and methods return string IPv6
addresses in uppercase.  To change that to lowercase:
.PP
\&\s-1NOTE:\s0 the \s-1AUGUST 2010 RFC5952\s0 states:
.PP
.Vb 1
\&    4.3. Lowercase
\&
\&      The characters "a", "b", "c", "d", "e", and "f" in an IPv6
\&      address MUST be represented in lowercase.
.Ve
.PP
It is recommended that all \s-1NEW\s0 applications using NetAddr::IP be
invoked as shown on the next line.
.PP
.Vb 1
\&  use NetAddr::IP qw(:lower);
.Ve
.PP
* To ensure the current IPv6 string case behavior even if the default changes:
.PP
.Vb 1
\&  use NetAddr::IP qw(:upper);
.Ve
.PP
* To set a limit on the size of \fBnets\fR processed or returned by NetAddr::IP.
.PP
Set the maximum number of nets beyond which NetAddr::IP will return
an error as a power of 2 (default 16 or 65536 nets). Each 2**16
consumes approximately 4 megs of memory. A 2**20 consumes 64 megs of
memory, A 2**24 consumes 1 gigabyte of memory.
.PP
.Vb 2
\&  use NetAddr::IP qw(netlimit);
\&  netlimit 20;
.Ve
.PP
The maximum \fBnetlimit\fR allowed is 2**24. Attempts to set limits below
the default of 16 or above the maximum of 24 are ignored.
.PP
Returns true on success, otherwise \f(CW\*(C`undef\*(C'\fR.
.SH "INSTALLATION"
.IX Header "INSTALLATION"
Un-tar the distribution in an appropriate directory and type:
.PP
.Vb 4
\&        perl Makefile.PL
\&        make
\&        make test
\&        make install
.Ve
.PP
\&\fBNetAddr::IP\fR depends on \fBNetAddr::IP::Util\fR which installs by
default with its primary functions compiled using Perl's \s-1XS\s0 extensions
to build a C library. If you do not have a C complier available or
would like the slower Pure Perl version for some other reason, then
type:
.PP
.Vb 4
\&        perl Makefile.PL \-noxs
\&        make
\&        make test
\&        make install
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module provides an object-oriented abstraction on top of \s-1IP\s0
addresses or \s-1IP\s0 subnets that allows for easy manipulations.  Version
4.xx of NetAddr::IP will work with older versions of Perl and is
compatible with Math::BigInt.
.PP
The internal representation of all \s-1IP\s0 objects is in 128 bit IPv6 notation.
IPv4 and IPv6 objects may be freely mixed.
.SS "Overloaded Operators"
.IX Subsection "Overloaded Operators"
Many operators have been overloaded, as described below:
.ie n .IP "\fBAssignment (\fB""=""\fB)\fR" 4
.el .IP "\fBAssignment (\f(CB=\fB)\fR" 4
.IX Item "Assignment (=)"
Has been optimized to copy one NetAddr::IP object to another very quickly.
.ie n .IP "\fB\fB""\->copy()""\fB\fR" 4
.el .IP "\fB\f(CB\->copy()\fB\fR" 4
.IX Item "->copy()"
The \fBassignment (\f(CB\*(C`=\*(C'\fB)\fR operation is only put in to operation when the
copied object is further mutated by another overloaded operation. See
overload \fB\s-1SPECIAL SYMBOLS FOR \s0\*(L"use overload\*(R"\fR for details.
.Sp
\&\fB\f(CB\*(C`\->copy()\*(C'\fB\fR actually creates a new object when called.
.IP "\fBStringification\fR" 4
.IX Item "Stringification"
An object can be used just as a string. For instance, the following code
.Sp
.Vb 2
\&        my $ip = new NetAddr::IP \*(Aq192.168.1.123\*(Aq;
\&        print "$ip\en";
.Ve
.Sp
Will print the string 192.168.1.123/32.
.IP "\fBEquality\fR" 4
.IX Item "Equality"
You can test for equality with either \f(CW\*(C`eq\*(C'\fR or \f(CW\*(C`==\*(C'\fR. \f(CW\*(C`eq\*(C'\fR allows
comparison with arbitrary strings as well as NetAddr::IP objects. The
following example:
.Sp
.Vb 2
\&    if (NetAddr::IP\->new(\*(Aq127.0.0.1\*(Aq,\*(Aq255.0.0.0\*(Aq) eq \*(Aq127.0.0.1/8\*(Aq)
\&       { print "Yes\en"; }
.Ve
.Sp
will print out \*(L"Yes\*(R".
.Sp
Comparison with \f(CW\*(C`==\*(C'\fR requires both operands to be NetAddr::IP objects.
.Sp
In both cases, a true value is returned if the \s-1CIDR\s0 representation of
the operands is equal.
.ie n .IP "\fBComparison via >, <, >=, <=, <=> and \fB""cmp""\fB\fR" 4
.el .IP "\fBComparison via >, <, >=, <=, <=> and \f(CBcmp\fB\fR" 4
.IX Item "Comparison via >, <, >=, <=, <=> and cmp"
Internally, all network objects are represented in 128 bit format.
The numeric representation of the network is compared through the
corresponding operation. Comparisons are tried first on the address portion
of the object and if that is equal then the \s-1NUMERIC\s0 cidr portion of the
masks are compared. This leads to the counterintuitive result that
.Sp
.Vb 1
\&        /24 > /16
.Ve
.Sp
Comparison should not be done on netaddr objects with different \s-1CIDR\s0 as
this may produce indeterminate \- unexpected results,
rather the determination of which netblock is larger or smaller should be
done by comparing
.Sp
.Vb 1
\&        $ip1\->masklen <=> $ip2\->masklen
.Ve
.ie n .IP "\fBAddition of a constant (\fB""+""\fB)\fR" 4
.el .IP "\fBAddition of a constant (\f(CB+\fB)\fR" 4
.IX Item "Addition of a constant (+)"
Add a 32 bit signed constant to the address part of a NetAddr object.
This operation changes the address part to point so many hosts above the
current objects start address. For instance, this code:
.Sp
.Vb 1
\&    print NetAddr::IP\->new(\*(Aq127.0.0.1/8\*(Aq) + 5;
.Ve
.Sp
will output 127.0.0.6/8. The address will wrap around at the broadcast
back to the network address. This code:
.Sp
.Vb 1
\&    print NetAddr::IP\->new(\*(Aq10.0.0.1/24\*(Aq) + 255;
\&
\&    outputs 10.0.0.0/24.
.Ve
.Sp
Returns the the unchanged object when the constant is missing or out of
range.
.Sp
.Vb 1
\&    2147483647 <= constant >= \-2147483648
.Ve
.ie n .IP "\fBSubtraction of a constant (\fB""\-""\fB)\fR" 4
.el .IP "\fBSubtraction of a constant (\f(CB\-\fB)\fR" 4
.IX Item "Subtraction of a constant (-)"
The complement of the addition of a constant.
.ie n .IP "\fBDifference (\fB""\-""\fB)\fR" 4
.el .IP "\fBDifference (\f(CB\-\fB)\fR" 4
.IX Item "Difference (-)"
Returns the difference between the address parts of two NetAddr::IP
objects address parts as a 32 bit signed number.
.Sp
Returns \fBundef\fR if the difference is out of range.
.Sp
(See range restrictions on Addition above)
.IP "\fBAuto-increment\fR" 4
.IX Item "Auto-increment"
Auto-incrementing a NetAddr::IP object causes the address part to be
adjusted to the next host address within the subnet. It will wrap at
the broadcast address and start again from the network address.
.IP "\fBAuto-decrement\fR" 4
.IX Item "Auto-decrement"
Auto-decrementing a NetAddr::IP object performs exactly the opposite
of auto-incrementing it, as you would expect.
.SS "Serializing and Deserializing"
.IX Subsection "Serializing and Deserializing"
This module defines hooks to collaborate with Storable for
serializing \f(CW\*(C`NetAddr::IP\*(C'\fR objects, through compact and human readable
strings. You can revert to the old format by invoking this module as
.PP
.Vb 1
\&  use NetAddr::IP \*(Aq:old_storable\*(Aq;
.Ve
.PP
You must do this if you have legacy data files containing NetAddr::IP
objects stored using the Storable module.
.SS "Methods"
.IX Subsection "Methods"
.ie n .IP """\->new([$addr, [ $mask|IPv6 ]])""" 4
.el .IP "\f(CW\->new([$addr, [ $mask|IPv6 ]])\fR" 4
.IX Item "->new([$addr, [ $mask|IPv6 ]])"
.PD 0
.ie n .IP """\->new6([$addr, [ $mask]])""" 4
.el .IP "\f(CW\->new6([$addr, [ $mask]])\fR" 4
.IX Item "->new6([$addr, [ $mask]])"
.ie n .IP """\->new_no([$addr, [ $mask]])""" 4
.el .IP "\f(CW\->new_no([$addr, [ $mask]])\fR" 4
.IX Item "->new_no([$addr, [ $mask]])"
.ie n .IP """\->new_from_aton($netaddr)""" 4
.el .IP "\f(CW\->new_from_aton($netaddr)\fR" 4
.IX Item "->new_from_aton($netaddr)"
.IP "new_cis and new_cis6 are \s-1DEPRECATED \s0" 4
.IX Item "new_cis and new_cis6 are DEPRECATED "
.ie n .IP """\->new_cis(""$addr $mask)""" 4
.el .IP "\f(CW\->new_cis(""$addr $mask)\fR" 4
.IX Item "->new_cis(""$addr $mask)"
.ie n .IP """\->new_cis6(""$addr $mask)""" 4
.el .IP "\f(CW\->new_cis6(""$addr $mask)\fR" 4
.IX Item "->new_cis6(""$addr $mask)"
.PD
The first two methods create a new address with the supplied address in
\&\f(CW$addr\fR and an optional netmask \f(CW$mask\fR, which can be omitted to get 
a /32 or /128 netmask for IPv4 / IPv6 addresses respectively.
.Sp
The third method \f(CW\*(C`new_no\*(C'\fR is exclusively for IPv4 addresses and filters
improperly formatted
dot quad strings for leading 0's that would normally be interpreted as octal
format by NetAddr per the specifications for inet_aton.
.Sp
\&\fBnew_from_aton\fR takes a packed IPv4 address and assumes a /32 mask. This
function replaces the \s-1DEPRECATED\s0 :aton functionality which is fundamentally
broken.
.Sp
The last two methods \fBnew_cis\fR and \fBnew_cis6\fR differ from \fBnew\fR and
\&\fBnew6\fR only in that they except the common Cisco address notation for
address/mask pairs with a \fBspace\fR as a separator instead of a slash (/)
.Sp
These methods are \s-1DEPRECATED\s0 because the functionality is now included
in the other \*(L"new\*(R" methods
.Sp
.Vb 3
\&  i.e.  \->new_cis(\*(Aq1.2.3.0 24\*(Aq)
\&        or
\&        \->new_cis6(\*(Aq::1.2.3.0 120\*(Aq)
.Ve
.Sp
\&\f(CW\*(C`\->new6\*(C'\fR and
\&\f(CW\*(C`\->new_cis6\*(C'\fR mark the address as being in ipV6 address space even
if the format would suggest otherwise.
.Sp
.Vb 1
\&  i.e.  \->new6(\*(Aq1.2.3.4\*(Aq) will result in ::102:304
\&
\&  addresses submitted to \->new in ipV6 notation will
\&  remain in that notation permanently. i.e.
\&        \->new(\*(Aq::1.2.3.4\*(Aq) will result in ::102:304
\&  whereas new(\*(Aq1.2.3.4\*(Aq) would print out as 1.2.3.4
\&
\&  See "STRINGIFICATION" below.
.Ve
.Sp
\&\f(CW$addr\fR can be almost anything that can be resolved to an \s-1IP\s0 address
in all the notations I have seen over time. It can optionally contain
the mask in \s-1CIDR\s0 notation.
.Sp
\&\fBprefix\fR notation is understood, with the limitation that the range
specified by the prefix must match with a valid subnet.
.Sp
Addresses in the same format returned by \f(CW\*(C`inet_aton\*(C'\fR or
\&\f(CW\*(C`gethostbyname\*(C'\fR can also be understood, although no mask can be
specified for them. The default is to not attempt to recognize this
format, as it seems to be seldom used.
.Sp
To accept addresses in that format, invoke the module as in
.Sp
.Vb 1
\&  use NetAddr::IP \*(Aq:aton\*(Aq
.Ve
.Sp
If called with no arguments, 'default' is assumed.
.Sp
If called with an empty string as the argument, returns 'undef'
.Sp
\&\f(CW$addr\fR can be any of the following and possibly more...
.Sp
.Vb 11
\&  n.n
\&  n.n/mm
\&  n.n.n
\&  n.n.n/mm
\&  n.n.n.n
\&  n.n.n.n/mm            32 bit cidr notation
\&  n.n.n.n/m.m.m.m
\&  loopback, localhost, broadcast, any, default
\&  x.x.x.x/host
\&  0xABCDEF, 0b111111000101011110, (a bcd number)
\&  a netaddr as returned by \*(Aqinet_aton\*(Aq
.Ve
.Sp
Any \s-1RFC1884\s0 notation
.Sp
.Vb 10
\&  ::n.n.n.n
\&  ::n.n.n.n/mmm         128 bit cidr notation
\&  ::n.n.n.n/::m.m.m.m
\&  ::x:x
\&  ::x:x/mmm
\&  x:x:x:x:x:x:x:x
\&  x:x:x:x:x:x:x:x/mmm
\&  x:x:x:x:x:x:x:x/m:m:m:m:m:m:m:m any RFC1884 notation
\&  loopback, localhost, unspecified, any, default
\&  ::x:x/host
\&  0xABCDEF, 0b111111000101011110 within the limits
\&  of perl\*(Aqs number resolution
\&  123456789012  a \*(Aqbig\*(Aq bcd number (bigger than perl likes)
\&  and Math::BigInt
.Ve
.Sp
If called with no arguments, 'default' is assumed.
.Sp
If called with an empty string as the argument, returns 'undef'
.ie n .IP """\->broadcast()""" 4
.el .IP "\f(CW\->broadcast()\fR" 4
.IX Item "->broadcast()"
Returns a new object referring to the broadcast address of a given
subnet. The broadcast address has all ones in all the bit positions
where the netmask has zero bits. This is normally used to address all
the hosts in a given subnet.
.ie n .IP """\->network()""" 4
.el .IP "\f(CW\->network()\fR" 4
.IX Item "->network()"
Returns a new object referring to the network address of a given
subnet. A network address has all zero bits where the bits of the
netmask are zero. Normally this is used to refer to a subnet.
.ie n .IP """\->addr()""" 4
.el .IP "\f(CW\->addr()\fR" 4
.IX Item "->addr()"
Returns a scalar with the address part of the object as an IPv4 or IPv6 text
string as appropriate. This is useful for printing or for passing the
address part of the NetAddr::IP object to other components that expect an \s-1IP\s0
address. If the object is an ipV6 address or was created using \->new6($ip)
it will be reported in ipV6 hex format otherwise it will be reported in dot
quad format only if it resides in ipV4 address space.
.ie n .IP """\->mask()""" 4
.el .IP "\f(CW\->mask()\fR" 4
.IX Item "->mask()"
Returns a scalar with the mask as an IPv4 or IPv6 text string as
described above.
.ie n .IP """\->masklen()""" 4
.el .IP "\f(CW\->masklen()\fR" 4
.IX Item "->masklen()"
Returns a scalar the number of one bits in the mask.
.ie n .IP """\->bits()""" 4
.el .IP "\f(CW\->bits()\fR" 4
.IX Item "->bits()"
Returns the width of the address in bits. Normally 32 for v4 and 128 for v6.
.ie n .IP """\->version()""" 4
.el .IP "\f(CW\->version()\fR" 4
.IX Item "->version()"
Returns the version of the address or subnet. Currently this can be
either 4 or 6.
.ie n .IP """\->cidr()""" 4
.el .IP "\f(CW\->cidr()\fR" 4
.IX Item "->cidr()"
Returns a scalar with the address and mask in \s-1CIDR\s0 notation. A
NetAddr::IP object \fIstringifies\fR to the result of this function.
(see comments about \->\fInew6()\fR and \->\fIaddr()\fR for output formats)
.ie n .IP """\->aton()""" 4
.el .IP "\f(CW\->aton()\fR" 4
.IX Item "->aton()"
Returns the address part of the NetAddr::IP object in the same format
as the \f(CW\*(C`inet_aton()\*(C'\fR or \f(CW\*(C`ipv6_aton\*(C'\fR function respectively. If the object
was created using \->new6($ip), the address returned will always be in ipV6
format, even for addresses in ipV4 address space.
.ie n .IP """\->range()""" 4
.el .IP "\f(CW\->range()\fR" 4
.IX Item "->range()"
Returns a scalar with the base address and the broadcast address
separated by a dash and spaces. This is called range notation.
.ie n .IP """\->prefix()""" 4
.el .IP "\f(CW\->prefix()\fR" 4
.IX Item "->prefix()"
Returns a scalar with the address and mask in ipV4 prefix
representation. This is useful for some programs, which expect its
input to be in this format. This method will include the broadcast
address in the encoding.
.ie n .IP """\->nprefix()""" 4
.el .IP "\f(CW\->nprefix()\fR" 4
.IX Item "->nprefix()"
Just as \f(CW\*(C`\->prefix()\*(C'\fR, but does not include the broadcast address.
.ie n .IP """\->numeric()""" 4
.el .IP "\f(CW\->numeric()\fR" 4
.IX Item "->numeric()"
When called in a scalar context, will return a numeric representation
of the address part of the \s-1IP\s0 address. When called in an array
contest, it returns a list of two elements. The first element is as
described, the second element is the numeric representation of the
netmask.
.Sp
This method is essential for serializing the representation of a
subnet.
.ie n .IP """\->bigint()""" 4
.el .IP "\f(CW\->bigint()\fR" 4
.IX Item "->bigint()"
When called in scalar context, will return a Math::BigInt
representation of the address part of the \s-1IP\s0 address. When called in
an array context, it returns a list of two elements, The first
element is as described, the second element is the Math::BigInt
representation of the netmask.
.ie n .IP """\->wildcard()""" 4
.el .IP "\f(CW\->wildcard()\fR" 4
.IX Item "->wildcard()"
When called in a scalar context, returns the wildcard bits
corresponding to the mask, in dotted-quad or ipV6 format as applicable.
.Sp
When called in an array context, returns a two-element array. The
first element, is the address part. The second element, is the
wildcard translation of the mask.
.ie n .IP """\->short()""" 4
.el .IP "\f(CW\->short()\fR" 4
.IX Item "->short()"
Returns the address part in a short or compact notation.
.Sp
.Vb 1
\&  (ie, 127.0.0.1 becomes 127.1).
.Ve
.Sp
Works with both, V4 and V6.
.ie n .IP """\->canon()""" 4
.el .IP "\f(CW\->canon()\fR" 4
.IX Item "->canon()"
Returns the address part in canonical notation as a string.  For
ipV4, this is dotted quad, and is the same as the return value from 
\&\*(L"\->\fIaddr()\fR\*(R".  For ipV6 it is as per \s-1RFC5952,\s0 and is the same as the \s-1LOWER CASE\s0 value
returned by \*(L"\->\fIshort()\fR\*(R".
.ie n .IP """\->full()""" 4
.el .IP "\f(CW\->full()\fR" 4
.IX Item "->full()"
Returns the address part in \s-1FULL\s0 notation for
ipV4 and ipV6 respectively.
.Sp
.Vb 2
\&  i.e. for ipV4
\&    0000:0000:0000:0000:0000:0000:127.0.0.1
\&
\&       for ipV6
\&    0000:0000:0000:0000:0000:0000:0000:0000
.Ve
.Sp
To force ipV4 addresses into full ipV6 format use:
.ie n .IP """\->full6()""" 4
.el .IP "\f(CW\->full6()\fR" 4
.IX Item "->full6()"
Returns the address part in \s-1FULL\s0 ipV6 notation
.ie n .IP """$me\->contains($other)""" 4
.el .IP "\f(CW$me\->contains($other)\fR" 4
.IX Item "$me->contains($other)"
Returns true when \f(CW$me\fR completely contains \f(CW$other\fR. False is
returned otherwise and \f(CW\*(C`undef\*(C'\fR is returned if \f(CW$me\fR and \f(CW$other\fR
are not both \f(CW\*(C`NetAddr::IP\*(C'\fR objects.
.ie n .IP """$me\->within($other)""" 4
.el .IP "\f(CW$me\->within($other)\fR" 4
.IX Item "$me->within($other)"
The complement of \f(CW\*(C`\->contains()\*(C'\fR. Returns true when \f(CW$me\fR is
completely contained within \f(CW$other\fR.
.Sp
Note that \f(CW$me\fR and \f(CW$other\fR must be \f(CW\*(C`NetAddr::IP\*(C'\fR objects.
.IP "C\->\fIis_rfc1918()\fR>" 4
.IX Item "C->is_rfc1918()>"
Returns true when \f(CW$me\fR is an \s-1RFC 1918\s0 address.
.Sp
.Vb 3
\&  10.0.0.0      \-   10.255.255.255  (10/8 prefix)
\&  172.16.0.0    \-   172.31.255.255  (172.16/12 prefix)
\&  192.168.0.0   \-   192.168.255.255 (192.168/16 prefix)
.Ve
.ie n .IP """\->splitref($bits,[optional $bits1,$bits2,...])""" 4
.el .IP "\f(CW\->splitref($bits,[optional $bits1,$bits2,...])\fR" 4
.IX Item "->splitref($bits,[optional $bits1,$bits2,...])"
Returns a reference to a list of objects, representing subnets of \f(CW\*(C`bits\*(C'\fR mask
produced by splitting the original object, which is left
unchanged. Note that \f(CW$bits\fR must be longer than the original
mask in order for it to be splittable.
.Sp
\&\s-1ERROR\s0 conditions:
.Sp
.Vb 3
\&  \->splitref will DIE with the message \*(Aqnetlimit exceeded\*(Aq
\&    if the number of return objects exceeds \*(Aqnetlimit\*(Aq.
\&    See function \*(Aqnetlimit\*(Aq above (default 2**16 or 65536 nets).
\&
\&  \->splitref returns undef when C<bits> or the (bits list)
\&    will not fit within the original object.
\&
\&  \->splitref returns undef if a supplied ipV4, ipV6, or NetAddr
\&    mask in inappropriately formatted,
.Ve
.Sp
\&\fBbits\fR may be a \s-1CIDR\s0 mask, a dot quad or ipV6 string or a NetAddr::IP object.
If \f(CW\*(C`bits\*(C'\fR is missing, the object is split for into all available addresses
within the ipV4 or ipV6 object ( auto-mask of \s-1CIDR 32, 128\s0 respectively ).
.Sp
With optional additional \f(CW\*(C`bits\*(C'\fR list, the original object is split into
parts sized based on the list. \s-1NOTE:\s0 a short list will replicate the last
item. If the last item is too large to for what remains of the object after
splitting off the first parts of the list, a \*(L"best fits\*(R" list of remaining
objects will be returned based on an increasing sort of the \s-1CIDR\s0 values of
the \f(CW\*(C`bits\*(C'\fR list.
.Sp
.Vb 2
\&  i.e.  my $ip = new NetAddr::IP(\*(Aq192.168.0.0/24\*(Aq);
\&        my $objptr = $ip\->split(28, 29, 28, 29, 26);
\&
\&   has split plan 28 29 28 29 26 26 26 28
\&   and returns this list of objects
\&
\&        192.168.0.0/28
\&        192.168.0.16/29
\&        192.168.0.24/28
\&        192.168.0.40/29
\&        192.168.0.48/26
\&        192.168.0.112/26
\&        192.168.0.176/26
\&        192.168.0.240/28
.Ve
.Sp
\&\s-1NOTE:\s0 that /26 replicates twice beyond the original request and /28 fills
the remaining return object requirement.
.ie n .IP """\->rsplitref($bits,[optional $bits1,$bits2,...])""" 4
.el .IP "\f(CW\->rsplitref($bits,[optional $bits1,$bits2,...])\fR" 4
.IX Item "->rsplitref($bits,[optional $bits1,$bits2,...])"
\&\f(CW\*(C`\->rsplitref\*(C'\fR is the same as \f(CW\*(C`\->splitref\*(C'\fR above except that the split plan is
applied to the original object in reverse order.
.Sp
.Vb 2
\&  i.e.  my $ip = new NetAddr::IP(\*(Aq192.168.0.0/24\*(Aq);
\&        my @objects = $ip\->split(28, 29, 28, 29, 26);
\&
\&   has split plan 28 26 26 26 29 28 29 28
\&   and returns this list of objects
\&
\&        192.168.0.0/28
\&        192.168.0.16/26
\&        192.168.0.80/26
\&        192.168.0.144/26
\&        192.168.0.208/29
\&        192.168.0.216/28
\&        192.168.0.232/29
\&        192.168.0.240/28
.Ve
.ie n .IP """\->split($bits,[optional $bits1,$bits2,...])""" 4
.el .IP "\f(CW\->split($bits,[optional $bits1,$bits2,...])\fR" 4
.IX Item "->split($bits,[optional $bits1,$bits2,...])"
Similar to \f(CW\*(C`\->splitref\*(C'\fR above but returns the list rather than a list
reference. You may not want to use this if a large number of objects is
expected.
.ie n .IP """\->rsplit($bits,[optional $bits1,$bits2,...])""" 4
.el .IP "\f(CW\->rsplit($bits,[optional $bits1,$bits2,...])\fR" 4
.IX Item "->rsplit($bits,[optional $bits1,$bits2,...])"
Similar to \f(CW\*(C`\->rsplitref\*(C'\fR above but returns the list rather than a list
reference. You may not want to use this if a large number of objects is
expected.
.ie n .IP """\->hostenum()""" 4
.el .IP "\f(CW\->hostenum()\fR" 4
.IX Item "->hostenum()"
Returns the list of hosts within a subnet.
.Sp
\&\s-1ERROR\s0 conditions:
.Sp
.Vb 3
\&  \->hostenum will DIE with the message \*(Aqnetlimit exceeded\*(Aq
\&    if the number of return objects exceeds \*(Aqnetlimit\*(Aq.
\&    See function \*(Aqnetlimit\*(Aq above (default 2**16 or 65536 nets).
.Ve
.ie n .IP """\->hostenumref()""" 4
.el .IP "\f(CW\->hostenumref()\fR" 4
.IX Item "->hostenumref()"
Faster version of \f(CW\*(C`\->hostenum()\*(C'\fR, returning a reference to a list.
.Sp
\&\s-1NOTE:\s0 hostenum and hostenumref report zero (0) useable hosts in a /31
network. This is the behavior expected prior to \s-1RFC 3021.\s0 To report 2
useable hosts for use in point-to-point networks, use \fB:rfc3021\fR tag.
.Sp
.Vb 1
\&        use NetAddr::IP qw(:rfc3021);
.Ve
.Sp
This will cause hostenum and hostenumref to return two (2) useable hosts in
a /31 network.
.ie n .IP """$me\->compact($addr1, $addr2, ...)""" 4
.el .IP "\f(CW$me\->compact($addr1, $addr2, ...)\fR" 4
.IX Item "$me->compact($addr1, $addr2, ...)"
.PD 0
.ie n .IP """@compacted_object_list = Compact(@object_list)""" 4
.el .IP "\f(CW@compacted_object_list = Compact(@object_list)\fR" 4
.IX Item "@compacted_object_list = Compact(@object_list)"
.PD
Given a list of objects (including \f(CW$me\fR), this method will compact
all the addresses and subnets into the largest (ie, least specific)
subnets possible that contain exactly all of the given objects.
.Sp
Note that in versions prior to 3.02, if fed with the same \s-1IP\s0 subnets
multiple times, these subnets would be returned. From 3.02 on, a more
\&\*(L"correct\*(R" approach has been adopted and only one address would be
returned.
.Sp
Note that \f(CW$me\fR and all \f(CW$addr\fR's must be \f(CW\*(C`NetAddr::IP\*(C'\fR objects.
.ie n .IP """$me\->compactref(\e@list)""" 4
.el .IP "\f(CW$me\->compactref(\e@list)\fR" 4
.IX Item "$me->compactref(@list)"
.PD 0
.ie n .IP """$compacted_object_list = Compact(\e@list)""" 4
.el .IP "\f(CW$compacted_object_list = Compact(\e@list)\fR" 4
.IX Item "$compacted_object_list = Compact(@list)"
.PD
As usual, a faster version of \f(CW\*(C`\->compact()\*(C'\fR that returns a
reference to a list. Note that this method takes a reference to a list
instead.
.Sp
Note that \f(CW$me\fR must be a \f(CW\*(C`NetAddr::IP\*(C'\fR object.
.ie n .IP """$me\->coalesce($masklen, $number, @list_of_subnets)""" 4
.el .IP "\f(CW$me\->coalesce($masklen, $number, @list_of_subnets)\fR" 4
.IX Item "$me->coalesce($masklen, $number, @list_of_subnets)"
.PD 0
.ie n .IP """$arrayref = Coalesce($masklen,$number,@list_of_subnets)""" 4
.el .IP "\f(CW$arrayref = Coalesce($masklen,$number,@list_of_subnets)\fR" 4
.IX Item "$arrayref = Coalesce($masklen,$number,@list_of_subnets)"
.PD
Will return a reference to list of \f(CW\*(C`NetAddr::IP\*(C'\fR subnets of
\&\f(CW$masklen\fR mask length, when \f(CW$number\fR or more addresses from
\&\f(CW@list_of_subnets\fR are found to be contained in said subnet.
.Sp
Subnets from \f(CW@list_of_subnets\fR with a mask shorter than \f(CW$masklen\fR
are passed \*(L"as is\*(R" to the return list.
.Sp
Subnets from \f(CW@list_of_subnets\fR with a mask longer than \f(CW$masklen\fR
will be counted (actually, the number of \s-1IP\s0 addresses is counted)
towards \f(CW$number\fR.
.Sp
Called as a method, the array will include \f(CW$me\fR.
.Sp
\&\s-1WARNING:\s0 the list of subnet must be the same type. i.e ipV4 or ipV6
.ie n .IP """\->first()""" 4
.el .IP "\f(CW\->first()\fR" 4
.IX Item "->first()"
Returns a new object representing the first usable \s-1IP\s0 address within
the subnet (ie, the first host address).
.ie n .IP """\->last()""" 4
.el .IP "\f(CW\->last()\fR" 4
.IX Item "->last()"
Returns a new object representing the last usable \s-1IP\s0 address within
the subnet (ie, one less than the broadcast address).
.ie n .IP """\->nth($index)""" 4
.el .IP "\f(CW\->nth($index)\fR" 4
.IX Item "->nth($index)"
Returns a new object representing the \fIn\fR\-th usable \s-1IP\s0 address within
the subnet (ie, the \fIn\fR\-th host address).  If no address is available
(for example, when the network is too small for \f(CW$index\fR hosts),
\&\f(CW\*(C`undef\*(C'\fR is returned.
.Sp
Version 4.00 of NetAddr::IP and version 1.00 of NetAddr::IP::Lite implements
\&\f(CW\*(C`\->nth($index)\*(C'\fR and \f(CW\*(C`\->num()\*(C'\fR exactly as the documentation states.
Previous versions behaved slightly differently and not in a consistent
manner. See the \s-1README\s0 file for details.
.Sp
To use the old behavior for \f(CW\*(C`\->nth($index)\*(C'\fR and \f(CW\*(C`\->num()\*(C'\fR:
.Sp
.Vb 1
\&  use NetAddr::IP::Lite qw(:old_nth);
\&
\&  old behavior:
\&  NetAddr::IP\->new(\*(Aq10/32\*(Aq)\->nth(0) == undef
\&  NetAddr::IP\->new(\*(Aq10/32\*(Aq)\->nth(1) == undef
\&  NetAddr::IP\->new(\*(Aq10/31\*(Aq)\->nth(0) == undef
\&  NetAddr::IP\->new(\*(Aq10/31\*(Aq)\->nth(1) == 10.0.0.1/31
\&  NetAddr::IP\->new(\*(Aq10/30\*(Aq)\->nth(0) == undef
\&  NetAddr::IP\->new(\*(Aq10/30\*(Aq)\->nth(1) == 10.0.0.1/30
\&  NetAddr::IP\->new(\*(Aq10/30\*(Aq)\->nth(2) == 10.0.0.2/30
\&  NetAddr::IP\->new(\*(Aq10/30\*(Aq)\->nth(3) == 10.0.0.3/30
.Ve
.Sp
Note that in each case, the broadcast address is represented in the
output set and that the 'zero'th index is alway undef except for   
a point-to-point /31 or /127 network where there are exactly two   
addresses in the network.
.Sp
.Vb 8
\&  new behavior:
\&  NetAddr::IP\->new(\*(Aq10/32\*(Aq)\->nth(0)  == 10.0.0.0/32
\&  NetAddr::IP\->new(\*(Aq10.1/32\*(Aq\->nth(0) == 10.0.0.1/32
\&  NetAddr::IP\->new(\*(Aq10/31\*(Aq)\->nth(0)  == 10.0.0.0/31
\&  NetAddr::IP\->new(\*(Aq10/31\*(Aq)\->nth(1)  == 10.0.0.1/31
\&  NetAddr::IP\->new(\*(Aq10/30\*(Aq)\->nth(0) == 10.0.0.1/30 
\&  NetAddr::IP\->new(\*(Aq10/30\*(Aq)\->nth(1) == 10.0.0.2/30 
\&  NetAddr::IP\->new(\*(Aq10/30\*(Aq)\->nth(2) == undef
.Ve
.Sp
Note that a /32 net always has 1 usable address while a /31 has exactly 
two usable addresses for point-to-point addressing. The first
index (0) returns the address immediately following the network address
except for a /31 or /127 when it return the network address.
.ie n .IP """\->num()""" 4
.el .IP "\f(CW\->num()\fR" 4
.IX Item "->num()"
As of version 4.42 of NetAddr::IP and version 1.27 of NetAddr::IP::Lite
a /31 and /127 with return a net \fBnum\fR value of 2 instead of 0 (zero) 
for point-to-point networks.
.Sp
Version 4.00 of NetAddr::IP and version 1.00 of NetAddr::IP::Lite
return the number of usable \s-1IP\s0 addresses within the subnet, 
not counting the broadcast or network address.
.Sp
Previous versions worked only for ipV4 addresses, returned a
maximum span of 2**32 and returned the number of \s-1IP\s0 addresses
not counting the broadcast address.
        (one greater than the new behavior)
.Sp
To use the old behavior for \f(CW\*(C`\->nth($index)\*(C'\fR and \f(CW\*(C`\->num()\*(C'\fR:
.Sp
.Vb 1
\&  use NetAddr::IP::Lite qw(:old_nth);
.Ve
.Sp
\&\s-1WARNING:\s0
.Sp
NetAddr::IP will calculate and return a numeric string for network
ranges as large as 2**128. These values are \s-1TEXT\s0 strings and perl 
can treat them as integers for numeric calculations.
.Sp
Perl on 32 bit platforms only handles integer numbers up to 2**32
and on 64 bit platforms to 2**64.
.Sp
If you wish to manipulate numeric strings returned by NetAddr::IP
that are larger than 2**32 or 2**64, respectively,  you must load
additional modules such as Math::BigInt, bignum or some similar  
package to do the integer math.
.ie n .IP """\->re()""" 4
.el .IP "\f(CW\->re()\fR" 4
.IX Item "->re()"
Returns a Perl regular expression that will match an \s-1IP\s0 address within
the given subnet. Defaults to ipV4 notation. Will return an ipV6 regex
if the address in not in ipV4 space.
.ie n .IP """\->re6()""" 4
.el .IP "\f(CW\->re6()\fR" 4
.IX Item "->re6()"
Returns a Perl regular expression that will match an \s-1IP\s0 address within
the given subnet. Always returns an ipV6 regex.
.SH "EXPORT_OK"
.IX Header "EXPORT_OK"
.Vb 7
\&        Compact
\&        Coalesce
\&        Zeros
\&        Ones
\&        V4mask
\&        V4net
\&        netlimit
.Ve
.SH "NOTES / BUGS ... FEATURES"
.IX Header "NOTES / BUGS ... FEATURES"
NetAddr::IP only runs in Pure Perl mode on Windows boxes because I don't
have the resources or know how to get the \*(L"configure\*(R" stuff working in the
Windows environment. Volunteers \s-1WELCOME\s0 to port the \*(L"C\*(R" portion of this
module to Windows.
.SH "HISTORY"
.IX Header "HISTORY"
.RS 4
See the Changes file
.RE
.SH "AUTHORS"
.IX Header "AUTHORS"
Luis E. Mun\*~oz <luismunoz@cpan.org>,
Michael Robinton <michael@bizsystems.com>
.SH "WARRANTY"
.IX Header "WARRANTY"
This software comes with the same warranty as Perl itself (ie, none),
so by using it you accept any and all the liability.
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
This software is (c) Luis E. Mun\*~oz, 1999 \- 2007, and (c) Michael
Robinton, 2006 \- 2014.
.PP
All rights reserved.
.PP
This program is free software; you can redistribute it and/or modify
it under the terms of either:
.PP
.Vb 3
\&  a) the GNU General Public License as published by the Free
\&  Software Foundation; either version 2, or (at your option) any
\&  later version, or
\&
\&  b) the "Artistic License" which comes with this distribution.
.Ve
.PP
This program is distributed in the hope that it will be useful,
but \s-1WITHOUT ANY WARRANTY\s0; without even the implied warranty of
\&\s-1MERCHANTABILITY\s0 or \s-1FITNESS FOR A PARTICULAR PURPOSE. \s0 See either
the \s-1GNU\s0 General Public License or the Artistic License for more details.
.PP
You should have received a copy of the Artistic License with this
distribution, in the file named \*(L"Artistic\*(R".  If not, I'll be glad to provide
one.
.PP
You should also have received a copy of the \s-1GNU\s0 General Public License
along with this program in the file named \*(L"Copying\*(R". If not, write to the
.PP
.Vb 3
\&        Free Software Foundation, Inc.
\&        51 Franklin Street, Fifth Floor
\&        Boston, MA 02110\-1301 USA.
.Ve
.PP
or visit their web page on the internet at:
.PP
.Vb 1
\&        http://www.gnu.org/copyleft/gpl.html.
.Ve
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.Vb 2
\&  perl(1) L<NetAddr::IP::Lite>, L<NetAddr::IP::Util>,
\&L<NetAddr::IP::InetBase>
.Ve
