.\" Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Sub::Uplevel 3"
.TH Sub::Uplevel 3 "2017-04-01" "perl v5.30.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Sub::Uplevel \- apparently run a function in a higher stack frame
.SH "VERSION"
.IX Header "VERSION"
version 0.2800
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use Sub::Uplevel;
\&
\&  sub foo {
\&      print join " \- ", caller;
\&  }
\&
\&  sub bar {
\&      uplevel 1, \e&foo;
\&  }
\&
\&  #line 11
\&  bar();    # main \- foo.plx \- 11
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Like Tcl's \fBuplevel()\fR function, but not quite so dangerous.  The idea
is just to fool \fBcaller()\fR.  All the really naughty bits of Tcl's
\&\fBuplevel()\fR are avoided.
.PP
\&\fB\s-1THIS IS NOT THE SORT OF THING YOU WANT TO DO EVERYDAY\s0\fR
.IP "\fBuplevel\fR" 4
.IX Item "uplevel"
.Vb 1
\&  uplevel $num_frames, \e&func, @args;
.Ve
.Sp
Makes the given function think it's being executed \f(CW$num_frames\fR higher
than the current stack level.  So when they use caller($frames) it
will actually give caller($frames + \f(CW$num_frames\fR) for them.
.Sp
\&\f(CW\*(C`uplevel(1, \e&some_func, @_)\*(C'\fR is effectively \f(CW\*(C`goto &some_func\*(C'\fR but
you don't immediately exit the current subroutine.  So while you can't
do this:
.Sp
.Vb 5
\&    sub wrapper {
\&        print "Before\en";
\&        goto &some_func;
\&        print "After\en";
\&    }
.Ve
.Sp
you can do this:
.Sp
.Vb 6
\&    sub wrapper {
\&        print "Before\en";
\&        my @out = uplevel 1, &some_func;
\&        print "After\en";
\&        return @out;
\&    }
.Ve
.Sp
\&\f(CW\*(C`uplevel\*(C'\fR has the ability to issue a warning if \f(CW$num_frames\fR is more than
the current call stack depth, although this warning is disabled and compiled
out by default as the check is relatively expensive.
.Sp
To enable the check for debugging or testing, you should set the global
\&\f(CW$Sub::Uplevel::CHECK_FRAMES\fR to true before loading Sub::Uplevel for the
first time as follows:
.Sp
.Vb 1
\&    #!/usr/bin/perl
\&    
\&    BEGIN {
\&        $Sub::Uplevel::CHECK_FRAMES = 1;
\&    }
\&    use Sub::Uplevel;
.Ve
.Sp
Setting or changing the global after the module has been loaded will have
no effect.
.SH "EXAMPLE"
.IX Header "EXAMPLE"
The main reason I wrote this module is so I could write wrappers
around functions and they wouldn't be aware they've been wrapped.
.PP
.Vb 1
\&    use Sub::Uplevel;
\&
\&    my $original_foo = \e&foo;
\&
\&    *foo = sub {
\&        my @output = uplevel 1, $original_foo;
\&        print "foo() returned:  @output";
\&        return @output;
\&    };
.Ve
.PP
If this code frightens you \fByou should not use this module.\fR
.SH "BUGS and CAVEATS"
.IX Header "BUGS and CAVEATS"
Well, the bad news is \fBuplevel()\fR is about 5 times slower than a normal
function call.  \s-1XS\s0 implementation anyone?  It also slows down every invocation
of \fBcaller()\fR, regardless of whether \fBuplevel()\fR is in effect.
.PP
Sub::Uplevel overrides CORE::GLOBAL::caller temporarily for the scope of
each uplevel call.  It does its best to work with any previously existing
CORE::GLOBAL::caller (both when Sub::Uplevel is first loaded and within 
each uplevel call) such as from Contextual::Return or Hook::LexWrap.
.PP
However, if you are routinely using multiple modules that override 
CORE::GLOBAL::caller, you are probably asking for trouble.
.PP
You \fBshould\fR load Sub::Uplevel as early as possible within your program.  As
with all \s-1CORE::GLOBAL\s0 overloading, the overload will not affect modules that
have already been compiled prior to the overload.  One module that often is
unavoidably loaded prior to Sub::Uplevel is Exporter.  To forcibly recompile
Exporter (and Exporter::Heavy) after loading Sub::Uplevel, use it with the
\&\*(L":aggressive\*(R" tag:
.PP
.Vb 1
\&    use Sub::Uplevel qw/:aggressive/;
.Ve
.PP
The private function \f(CW\*(C`Sub::Uplevel::_force_reload()\*(C'\fR may be passed a list of
additional modules to reload if \*(L":aggressive\*(R" is not aggressive enough.  
Reloading modules may break things, so only use this as a last resort.
.PP
As of version 0.20, Sub::Uplevel requires Perl 5.6 or greater.
.SH "HISTORY"
.IX Header "HISTORY"
Those who do not learn from \s-1HISTORY\s0 are doomed to repeat it.
.PP
The lesson here is simple:  Don't sit next to a Tcl programmer at the
dinner table.
.SH "THANKS"
.IX Header "THANKS"
Thanks to Brent Welch, Damian Conway and Robin Houston.
.PP
See http://www.perl.com/perl/misc/Artistic.html
.SH "SEE ALSO"
.IX Header "SEE ALSO"
PadWalker (for the similar idea with lexicals), Hook::LexWrap, 
Tcl's \fBuplevel()\fR at http://www.scriptics.com/man/tcl8.4/TclCmd/uplevel.htm
.SH "SUPPORT"
.IX Header "SUPPORT"
.SS "Bugs / Feature Requests"
.IX Subsection "Bugs / Feature Requests"
Please report any bugs or feature requests through the issue tracker
at <https://github.com/Perl\-Toolchain\-Gang/Sub\-Uplevel/issues>.
You will be notified automatically of any progress on your issue.
.SS "Source Code"
.IX Subsection "Source Code"
This is open source software.  The code repository is available for
public review and contribution under the terms of the license.
.PP
<https://github.com/Perl\-Toolchain\-Gang/Sub\-Uplevel>
.PP
.Vb 1
\&  git clone https://github.com/Perl\-Toolchain\-Gang/Sub\-Uplevel.git
.Ve
.SH "AUTHORS"
.IX Header "AUTHORS"
.IP "\(bu" 4
Michael Schwern <mschwern@cpan.org>
.IP "\(bu" 4
David Golden <dagolden@cpan.org>
.SH "CONTRIBUTORS"
.IX Header "CONTRIBUTORS"
.IP "\(bu" 4
Adam Kennedy <adamk@cpan.org>
.IP "\(bu" 4
Alexandr Ciornii <alexchorny@gmail.com>
.IP "\(bu" 4
David Golden <xdg@xdg.me>
.IP "\(bu" 4
Graham Ollis <plicease@cpan.org>
.IP "\(bu" 4
J. Nick Koston <nick@cpanel.net>
.IP "\(bu" 4
Michael Gray <mg13@sanger.ac.uk>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is copyright (c) 2017 by Michael Schwern and David Golden.
.PP
This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.
