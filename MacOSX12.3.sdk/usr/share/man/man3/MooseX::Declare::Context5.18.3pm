.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "MooseX::Declare::Context 3pm"
.TH MooseX::Declare::Context 3pm "2013-12-14" "perl v5.18.4" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
MooseX::Declare::Context \- Per\-keyword declaration context
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This is not a subclass of Devel::Declare::Context::Simple, but it will
delegate all default methods and extend it with some attributes and methods
of its own.
.PP
A context object will be instanciated for every keyword that is handled by
MooseX::Declare. If handlers want to communicate with other handlers (for
example handlers that will only be setup inside a namespace block) it must
do this via the generated code.
.PP
In addition to all the methods documented here, all methods from
Devel::Declare::Context::Simple are available and will be delegated to an
internally stored instance of it.
.SH "ATTRIBUTES"
.IX Header "ATTRIBUTES"
.SS "caller_file"
.IX Subsection "caller_file"
A required \f(CW\*(C`Str\*(C'\fR containing the file the keyword was encountered in.
.SS "preamble_code_parts"
.IX Subsection "preamble_code_parts"
An \f(CW\*(C`ArrayRef\*(C'\fR of \*(L"CodePart\*(R"s that will be used as preamble. A preamble in
this context means the beginning of the generated code.
.SS "scope_code_parts"
.IX Subsection "scope_code_parts"
These parts will come before the actual body and after the
\&\*(L"preamble_code_parts\*(R". It is an \f(CW\*(C`ArrayRef\*(C'\fR of \*(L"CodePart\*(R"s.
.SS "cleanup_code_parts"
.IX Subsection "cleanup_code_parts"
An \f(CW\*(C`ArrayRef\*(C'\fR of \*(L"CodePart\*(R"s that will not be directly inserted
into the code, but instead be installed in a handler that will run at
the end of the scope so you can do namespace cleanups and such.
.SS "stack"
.IX Subsection "stack"
An \f(CW\*(C`ArrayRef\*(C'\fR that contains the stack of handlers. A keyword that was
only setup inside a scoped block will have the blockhandler be put in
the stack.
.SH "METHODS"
.IX Header "METHODS"
.ie n .SS "add_preamble_code_parts(CodePart @parts)"
.el .SS "add_preamble_code_parts(CodePart \f(CW@parts\fP)"
.IX Subsection "add_preamble_code_parts(CodePart @parts)"
.Vb 1
\&  Object\->add_preamble_code_parts (CodeRef @parts)
.Ve
.PP
See \*(L"add_cleanup_code_parts\*(R".
.ie n .SS "add_scope_code_parts(CodePart @parts)"
.el .SS "add_scope_code_parts(CodePart \f(CW@parts\fP)"
.IX Subsection "add_scope_code_parts(CodePart @parts)"
.Vb 1
\&  Object\->add_scope_code_parts    (CodeRef @parts)
.Ve
.PP
See \*(L"add_cleanup_code_parts\*(R".
.ie n .SS "add_cleanup_code_parts(CodePart @parts)"
.el .SS "add_cleanup_code_parts(CodePart \f(CW@parts\fP)"
.IX Subsection "add_cleanup_code_parts(CodePart @parts)"
.Vb 1
\&  Object\->add_cleanup_code_parts  (CodeRef @parts)
.Ve
.PP
For these three methods please look at the corresponding \f(CW*_code_parts\fR
attribute in the list above. These methods are merely convenience methods
that allow adding entries to the code part containers.
.SS "inject_code_parts_here"
.IX Subsection "inject_code_parts_here"
.Vb 1
\&  True Object\->inject_code_parts_here (CodePart @parts)
.Ve
.PP
Will inject the passed \*(L"CodePart\*(R"s at the current position in the code.
.SS "peek_next_char"
.IX Subsection "peek_next_char"
.Vb 1
\&  Str Object\->peek_next_char ()
.Ve
.PP
Will return the next char without stripping it from the stream.
.SS "inject_code_parts"
.IX Subsection "inject_code_parts"
.Vb 4
\&  Object\->inject_code_parts (
\&      Bool    :$inject_cleanup_code_parts,
\&      CodeRef :$missing_block_handler
\&  )
.Ve
.PP
This will inject the code parts from the attributes above at the current
position. The preamble and scope code parts will be inserted first. Then
then call to the cleanup code will be injected, unless the options
contain a key named \f(CW\*(C`inject_cleanup_code_parts\*(C'\fR with a false value.
.PP
The \f(CW\*(C`inject_if_block\*(C'\fR method will be called if the next char is a \f(CW\*(C`{\*(C'\fR
indicating a following block.
.PP
If it is not a block, but a semi-colon is found and the options
contained a \f(CW\*(C`missing_block_handler\*(C'\fR key was passed, it will be called
as method on the context object with the code to inject and the
options as arguments. All options that are not recognized are passed
through to the \f(CW\*(C`missing_block_handler\*(C'\fR. You are well advised to prefix
option names in your extensions.
.SH "TYPES"
.IX Header "TYPES"
.SS "BlockCodePart"
.IX Subsection "BlockCodePart"
An \f(CW\*(C`ArrayRef\*(C'\fR with at least one element that stringifies to either \f(CW\*(C`BEGIN\*(C'\fR
or \f(CW\*(C`END\*(C'\fR. The other parts will be stringified and used as the body for the
generated block. An example would be this compiletime role composition:
.PP
.Vb 1
\&  [\*(AqBEGIN\*(Aq, \*(Aqwith q{ MyRole }\*(Aq]
.Ve
.SS "CodePart"
.IX Subsection "CodePart"
A part of code represented by either a \f(CW\*(C`Str\*(C'\fR or a \*(L"BlockCodePart\*(R".
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.IP "\(bu" 4
MooseX::Declare
.IP "\(bu" 4
Devel::Declare
.IP "\(bu" 4
Devel::Declare::Context::Simple
.SH "AUTHOR"
.IX Header "AUTHOR"
Florian Ragwitz <rafl@debian.org>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is copyright (c) 2008 by Florian Ragwitz.
.PP
This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.
