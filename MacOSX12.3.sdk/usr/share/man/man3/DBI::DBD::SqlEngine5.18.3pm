.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "DBI::DBD::SqlEngine 3"
.TH DBI::DBD::SqlEngine 3 "2013-06-24" "perl v5.18.4" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
DBI::DBD::SqlEngine \- Base class for DBI drivers without their own SQL engine
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    package DBD::myDriver;
\&
\&    use base qw(DBI::DBD::SqlEngine);
\&
\&    sub driver
\&    {
\&        ...
\&        my $drh = $proto\->SUPER::driver($attr);
\&        ...
\&        return $drh\->{class};
\&        }
\&
\&    package DBD::myDriver::dr;
\&
\&    @ISA = qw(DBI::DBD::SqlEngine::dr);
\&
\&    sub data_sources { ... }
\&    ...
\&
\&    package DBD::myDriver::db;
\&
\&    @ISA = qw(DBI::DBD::SqlEngine::db);
\&
\&    sub init_valid_attributes { ... }
\&    sub init_default_attributes { ... }
\&    sub set_versions { ... }
\&    sub validate_STORE_attr { my ($dbh, $attrib, $value) = @_; ... }
\&    sub validate_FETCH_attr { my ($dbh, $attrib) = @_; ... }
\&    sub get_myd_versions { ... }
\&    sub get_avail_tables { ... }
\&
\&    package DBD::myDriver::st;
\&
\&    @ISA = qw(DBI::DBD::SqlEngine::st);
\&
\&    sub FETCH { ... }
\&    sub STORE { ... }
\&
\&    package DBD::myDriver::Statement;
\&
\&    @ISA = qw(DBI::DBD::SqlEngine::Statement);
\&
\&    sub open_table { ... }
\&
\&    package DBD::myDriver::Table;
\&
\&    @ISA = qw(DBI::DBD::SqlEngine::Table);
\&
\&    sub new { ... }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
DBI::DBD::SqlEngine abstracts the usage of \s-1SQL\s0 engines from the
\&\s-1DBD. DBD\s0 authors can concentrate on the data retrieval they want to
provide.
.PP
It is strongly recommended that you read DBD::File::Developers and
DBD::File::Roadmap, because many of the DBD::File \s-1API\s0 is provided
by DBI::DBD::SqlEngine.
.PP
Currently the \s-1API\s0 of DBI::DBD::SqlEngine is experimental and will
likely change in the near future to provide the table meta data basics
like DBD::File.
.SS "Metadata"
.IX Subsection "Metadata"
The following attributes are handled by \s-1DBI\s0 itself and not by
DBI::DBD::SqlEngine, thus they all work as expected:
.PP
.Vb 10
\&    Active
\&    ActiveKids
\&    CachedKids
\&    CompatMode             (Not used)
\&    InactiveDestroy
\&    AutoInactiveDestroy
\&    Kids
\&    PrintError
\&    RaiseError
\&    Warn                   (Not used)
.Ve
.PP
\fIThe following \s-1DBI\s0 attributes are handled by DBI::DBD::SqlEngine:\fR
.IX Subsection "The following DBI attributes are handled by DBI::DBD::SqlEngine:"
.PP
AutoCommit
.IX Subsection "AutoCommit"
.PP
Always on.
.PP
ChopBlanks
.IX Subsection "ChopBlanks"
.PP
Works.
.PP
\s-1NUM_OF_FIELDS\s0
.IX Subsection "NUM_OF_FIELDS"
.PP
Valid after \f(CW\*(C`$sth\->execute\*(C'\fR.
.PP
\s-1NUM_OF_PARAMS\s0
.IX Subsection "NUM_OF_PARAMS"
.PP
Valid after \f(CW\*(C`$sth\->prepare\*(C'\fR.
.PP
\s-1NAME\s0
.IX Subsection "NAME"
.PP
Valid after \f(CW\*(C`$sth\->execute\*(C'\fR; probably undef for Non-Select statements.
.PP
\s-1NULLABLE\s0
.IX Subsection "NULLABLE"
.PP
Not really working, always returns an array ref of ones, as \s-1DBD::CSV\s0
does not verify input data. Valid after \f(CW\*(C`$sth\->execute\*(C'\fR; undef for
non-select statements.
.PP
\fIThe following \s-1DBI\s0 attributes and methods are not supported:\fR
.IX Subsection "The following DBI attributes and methods are not supported:"
.IP "bind_param_inout" 4
.IX Item "bind_param_inout"
.PD 0
.IP "CursorName" 4
.IX Item "CursorName"
.IP "LongReadLen" 4
.IX Item "LongReadLen"
.IP "LongTruncOk" 4
.IX Item "LongTruncOk"
.PD
.PP
\fIDBI::DBD::SqlEngine specific attributes\fR
.IX Subsection "DBI::DBD::SqlEngine specific attributes"
.PP
In addition to the \s-1DBI\s0 attributes, you can use the following dbh
attributes:
.PP
sql_engine_version
.IX Subsection "sql_engine_version"
.PP
Contains the module version of this driver (\fBreadonly\fR)
.PP
sql_nano_version
.IX Subsection "sql_nano_version"
.PP
Contains the module version of DBI::SQL::Nano (\fBreadonly\fR)
.PP
sql_statement_version
.IX Subsection "sql_statement_version"
.PP
Contains the module version of SQL::Statement, if available (\fBreadonly\fR)
.PP
sql_handler
.IX Subsection "sql_handler"
.PP
Contains the \s-1SQL\s0 Statement engine, either DBI::SQL::Nano or SQL::Statement
(\fBreadonly\fR).
.PP
sql_parser_object
.IX Subsection "sql_parser_object"
.PP
Contains an instantiated instance of SQL::Parser (\fBreadonly\fR).
This is filled when used first time (only when used with SQL::Statement).
.PP
sql_sponge_driver
.IX Subsection "sql_sponge_driver"
.PP
Contains an internally used DBD::Sponge handle (\fBreadonly\fR).
.PP
sql_valid_attrs
.IX Subsection "sql_valid_attrs"
.PP
Contains the list of valid attributes for each DBI::DBD::SqlEngine based
driver (\fBreadonly\fR).
.PP
sql_readonly_attrs
.IX Subsection "sql_readonly_attrs"
.PP
Contains the list of those attributes which are readonly (\fBreadonly\fR).
.PP
sql_identifier_case
.IX Subsection "sql_identifier_case"
.PP
Contains how DBI::DBD::SqlEngine deals with non-quoted \s-1SQL\s0 identifiers:
.PP
.Vb 5
\&  * SQL_IC_UPPER (1) means all identifiers are internally converted
\&    into upper\-cased pendants
\&  * SQL_IC_LOWER (2) means all identifiers are internally converted
\&    into lower\-cased pendants
\&  * SQL_IC_MIXED (4) means all identifiers are taken as they are
.Ve
.PP
These conversions happen if (and only if) no existing identifier matches.
Once existing identifier is used as known.
.PP
The \s-1SQL\s0 statement execution classes doesn't have to care, so don't expect
\&\f(CW\*(C`sql_identifier_case\*(C'\fR affects column names in statements like
.PP
.Vb 1
\&  SELECT * FROM foo
.Ve
.PP
sql_quoted_identifier_case
.IX Subsection "sql_quoted_identifier_case"
.PP
Contains how DBI::DBD::SqlEngine deals with quoted \s-1SQL\s0 identifiers
(\fBreadonly\fR). It's fixated to \s-1SQL_IC_SENSITIVE \\fIs0\fR\|(3), which is interpreted
as \s-1SQL_IC_MIXED.\s0
.PP
sql_flags
.IX Subsection "sql_flags"
.PP
Contains additional flags to instantiate an SQL::Parser. Because an
SQL::Parser is instantiated only once, it's recommended to set this flag
before any statement is executed.
.PP
sql_dialect
.IX Subsection "sql_dialect"
.PP
Controls the dialect understood by SQL::Parser. Possible values (delivery
state of SQL::Statement):
.PP
.Vb 3
\&  * ANSI
\&  * CSV
\&  * AnyData
.Ve
.PP
Defaults to \*(L"\s-1CSV\*(R". \s0 Because an SQL::Parser is instantiated only once and
SQL::Parser doesn't allow to modify the dialect once instantiated,
it's strongly recommended to set this flag before any statement is
executed (best place is connect attribute hash).
.PP
sql_engine_in_gofer
.IX Subsection "sql_engine_in_gofer"
.PP
This value has a true value in case of this driver is operated via
DBD::Gofer. The impact of being operated via Gofer is a read-only
driver (not read-only databases!), so you cannot modify any attributes
later \- neither any table settings. \fBBut\fR you won't get an error in
cases you modify table attributes, so please carefully watch
\&\f(CW\*(C`sql_engine_in_gofer\*(C'\fR.
.PP
sql_meta
.IX Subsection "sql_meta"
.PP
Private data area which contains information about the tables this
module handles. Table meta data might not be available until the
table has been accessed for the first time e.g., by issuing a select
on it however it is possible to pre-initialize attributes for each table
you use.
.PP
DBI::DBD::SqlEngine recognizes the (public) attributes \f(CW\*(C`col_names\*(C'\fR,
\&\f(CW\*(C`table_name\*(C'\fR, \f(CW\*(C`readonly\*(C'\fR, \f(CW\*(C`sql_data_source\*(C'\fR and \f(CW\*(C`sql_identifier_case\*(C'\fR.
Be very careful when modifying attributes you do not know, the consequence
might be a destroyed or corrupted table.
.PP
While \f(CW\*(C`sql_meta\*(C'\fR is a private and readonly attribute (which means, you
cannot modify it's values), derived drivers might provide restricted
write access through another attribute. Well known accessors are
\&\f(CW\*(C`csv_tables\*(C'\fR for \s-1DBD::CSV\s0, \f(CW\*(C`ad_tables\*(C'\fR for DBD::AnyData and
\&\f(CW\*(C`dbm_tables\*(C'\fR for \s-1DBD::DBM\s0.
.PP
sql_table_source
.IX Subsection "sql_table_source"
.PP
Controls the class which will be used for fetching available tables.
.PP
See \*(L"DBI::DBD::SqlEngine::TableSource\*(R" for details.
.PP
sql_data_source
.IX Subsection "sql_data_source"
.PP
Contains the class name to be used for opening tables.
.PP
See \*(L"DBI::DBD::SqlEngine::DataSource\*(R" for details.
.SS "Driver private methods"
.IX Subsection "Driver private methods"
\fIDefault \s-1DBI\s0 methods\fR
.IX Subsection "Default DBI methods"
.PP
data_sources
.IX Subsection "data_sources"
.PP
The \f(CW\*(C`data_sources\*(C'\fR method returns a list of subdirectories of the current
directory in the form \*(L"dbi:CSV:f_dir=$dirname\*(R".
.PP
If you want to read the subdirectories of another directory, use
.PP
.Vb 2
\&    my ($drh)  = DBI\->install_driver ("CSV");
\&    my (@list) = $drh\->data_sources (f_dir => "/usr/local/csv_data");
.Ve
.PP
list_tables
.IX Subsection "list_tables"
.PP
This method returns a list of file names inside \f(CW$dbh\fR\->{f_dir}.
Example:
.PP
.Vb 2
\&    my ($dbh)  = DBI\->connect ("dbi:CSV:f_dir=/usr/local/csv_data");
\&    my (@list) = $dbh\->func ("list_tables");
.Ve
.PP
Note that the list includes all files contained in the directory, even
those that have non-valid table names, from the view of \s-1SQL.\s0
.PP
\fIAdditional methods\fR
.IX Subsection "Additional methods"
.PP
The following methods are only available via their documented name when
DBI::DBD::SQlEngine is used directly. Because this is only reasonable for
testing purposes, the real names must be used instead. Those names can be
computed by replacing the \f(CW\*(C`sql_\*(C'\fR in the method name with the driver prefix.
.PP
sql_versions
.IX Subsection "sql_versions"
.PP
Signature:
.PP
.Vb 5
\&  sub sql_versions (;$) {
\&    my ($table_name) = @_;
\&    $table_name ||= ".";
\&    ...
\&    }
.Ve
.PP
Returns the versions of the driver, including the \s-1DBI\s0 version, the Perl
version, DBI::PurePerl version (if DBI::PurePerl is active) and the version
of the \s-1SQL\s0 engine in use.
.PP
.Vb 8
\&    my $dbh = DBI\->connect ("dbi:File:");
\&    my $sql_versions = $dbh\->func( "sql_versions" );
\&    print "$sql_versions\en";
\&    _\|_END_\|_
\&    # DBI::DBD::SqlEngine  0.05 using SQL::Statement 1.402
\&    # DBI                  1.623
\&    # OS                   netbsd (6.99.12)
\&    # Perl                 5.016002 (x86_64\-netbsd\-thread\-multi)
.Ve
.PP
Called in list context, sql_versions will return an array containing each
line as single entry.
.PP
Some drivers might use the optional (table name) argument and modify
version information related to the table (e.g. \s-1DBD::DBM\s0 provides storage
backend information for the requested table, when it has a table name).
.PP
sql_get_meta
.IX Subsection "sql_get_meta"
.PP
Signature:
.PP
.Vb 5
\&    sub sql_get_meta ($$)
\&    {
\&        my ($table_name, $attrib) = @_;
\&        ...
\&    }
.Ve
.PP
Returns the value of a meta attribute set for a specific table, if any.
See sql_meta for the possible attributes.
.PP
A table name of \f(CW"."\fR (single dot) is interpreted as the default table.
This will retrieve the appropriate attribute globally from the dbh.
This has the same restrictions as \f(CW\*(C`$dbh\->{$attrib}\*(C'\fR.
.PP
sql_set_meta
.IX Subsection "sql_set_meta"
.PP
Signature:
.PP
.Vb 5
\&    sub sql_set_meta ($$$)
\&    {
\&        my ($table_name, $attrib, $value) = @_;
\&        ...
\&    }
.Ve
.PP
Sets the value of a meta attribute set for a specific table.
See sql_meta for the possible attributes.
.PP
A table name of \f(CW"."\fR (single dot) is interpreted as the default table
which will set the specified attribute globally for the dbh.
This has the same restrictions as \f(CW\*(C`$dbh\->{$attrib} = $value\*(C'\fR.
.PP
sql_clear_meta
.IX Subsection "sql_clear_meta"
.PP
Signature:
.PP
.Vb 5
\&    sub sql_clear_meta ($)
\&    {
\&        my ($table_name) = @_;
\&        ...
\&    }
.Ve
.PP
Clears the table specific meta information in the private storage of the
dbh.
.SS "Extensibility"
.IX Subsection "Extensibility"
\fIDBI::DBD::SqlEngine::TableSource\fR
.IX Subsection "DBI::DBD::SqlEngine::TableSource"
.PP
Provides data sources and table information on database driver and database
handle level.
.PP
.Vb 1
\&  package DBI::DBD::SqlEngine::TableSource;
\&
\&  sub data_sources ($;$)
\&  {
\&    my ( $class, $drh, $attrs ) = @_;
\&    ...
\&  }
\&
\&  sub avail_tables
\&  {
\&    my ( $class, $drh ) = @_;
\&    ...
\&  }
.Ve
.PP
The \f(CW\*(C`data_sources\*(C'\fR method is called when the user invokes any of the
following:
.PP
.Vb 2
\&  @ary = DBI\->data_sources($driver);
\&  @ary = DBI\->data_sources($driver, \e%attr);
\&  
\&  @ary = $dbh\->data_sources();
\&  @ary = $dbh\->data_sources(\e%attr);
.Ve
.PP
The \f(CW\*(C`avail_tables\*(C'\fR method is called when the user invokes any of the
following:
.PP
.Vb 1
\&  @names = $dbh\->tables( $catalog, $schema, $table, $type );
\&  
\&  $sth = $dbh\->table_info( $catalog, $schema, $table, $type );
\&  $sth = $dbh\->table_info( $catalog, $schema, $table, $type, \e%attr );
\&
\&  $dbh\->func( "list_tables" );
.Ve
.PP
Every time where an \f(CW\*(C`\e%attr\*(C'\fR argument can be specified, this \f(CW\*(C`\e%attr\*(C'\fR
object's \f(CW\*(C`sql_table_source\*(C'\fR attribute is preferred over the \f(CW$dbh\fR
attribute or the driver default, eg.
.PP
.Vb 6
\&  @ary = DBI\->data_sources("dbi:CSV:", {
\&    f_dir => "/your/csv/tables",
\&    # note: this class doesn\*(Aqt comes with DBI
\&    sql_table_source => "DBD::File::Archive::Tar::TableSource",
\&    # scan tarballs instead of directories
\&  });
.Ve
.PP
When you're going to implement such a DBD::File::Archive::Tar::TableSource
class, remember to add correct attributes (including \f(CW\*(C`sql_table_source\*(C'\fR
and \f(CW\*(C`sql_data_source\*(C'\fR) to the returned \s-1DSN\s0's.
.PP
\fIDBI::DBD::SqlEngine::DataSource\fR
.IX Subsection "DBI::DBD::SqlEngine::DataSource"
.PP
Provides base functionality for dealing with tables. It is primarily
designed for allowing transparent access to files on disk or already
opened (file\-)streams (eg. for \s-1DBD::CSV\s0).
.PP
Derived classes shall be restricted to similar functionality, too (eg.
opening streams from an archive, transparently compress/uncompress
log files before parsing them,
.PP
.Vb 1
\&  package DBI::DBD::SqlEngine::DataSource;
\&
\&  sub complete_table_name ($$;$)
\&  {
\&    my ( $self, $meta, $table, $respect_case ) = @_;
\&    ...
\&  }
.Ve
.PP
The method \f(CW\*(C`complete_table_name\*(C'\fR is called when first setting up the
\&\fImeta information\fR for a table:
.PP
.Vb 1
\&  "SELECT user.id, user.name, user.shell FROM user WHERE ..."
.Ve
.PP
results in opening the table \f(CW\*(C`user\*(C'\fR. First step of the table open
process is completing the name. Let's imagine you're having a \s-1DBD::CSV\s0
handle with following settings:
.PP
.Vb 3
\&  $dbh\->{sql_identifier_case} = SQL_IC_LOWER;
\&  $dbh\->{f_ext} = \*(Aq.lst\*(Aq;
\&  $dbh\->{f_dir} = \*(Aq/data/web/adrmgr\*(Aq;
.Ve
.PP
Those settings will result in looking for files matching
\&\f(CW\*(C`[Uu][Ss][Ee][Rr](\e.lst)?$\*(C'\fR in \f(CW\*(C`/data/web/adrmgr/\*(C'\fR. The scanning of the
directory \f(CW\*(C`/data/web/adrmgr/\*(C'\fR and the pattern match check will be done
in \f(CW\*(C`DBD::File::DataSource::File\*(C'\fR by the \f(CW\*(C`complete_table_name\*(C'\fR method.
.PP
If you intend to provide other sources of data streams than files, in
addition to provide an appropriate \f(CW\*(C`complete_table_name\*(C'\fR method, a method
to open the resource is required:
.PP
.Vb 1
\&  package DBI::DBD::SqlEngine::DataSource;
\&
\&  sub open_data ($)
\&  {
\&    my ( $self, $meta, $attrs, $flags ) = @_;
\&    ...
\&  }
.Ve
.PP
After the method \f(CW\*(C`open_data\*(C'\fR has been run successfully, the table's meta
information are in a state which allowes the table's data accessor methods
will be able to fetch/store row information. Implementation details heavily
depends on the table implementation, whereby the most famous is surely
DBD::File::Table.
.SH "SQL ENGINES"
.IX Header "SQL ENGINES"
DBI::DBD::SqlEngine currently supports two \s-1SQL\s0 engines:
SQL::Statement and
DBI::SQL::Nano::Statement_. DBI::SQL::Nano supports a
\&\fIvery\fR limited subset of \s-1SQL\s0 statements, but it might be faster for some
very simple tasks. SQL::Statement in contrast supports a much larger subset
of \s-1ANSI SQL.\s0
.PP
To use SQL::Statement, you need at least version 1.401 of
SQL::Statement and the environment variable \f(CW\*(C`DBI_SQL_NANO\*(C'\fR must not
be set to a true value.
.SH "SUPPORT"
.IX Header "SUPPORT"
You can find documentation for this module with the perldoc command.
.PP
.Vb 1
\&    perldoc DBI::DBD::SqlEngine
.Ve
.PP
You can also look for information at:
.IP "\(bu" 4
\&\s-1RT: CPAN\s0's request tracker
.Sp
<http://rt.cpan.org/NoAuth/Bugs.html?Dist=DBI>
<http://rt.cpan.org/NoAuth/Bugs.html?Dist=SQL\-Statement>
.IP "\(bu" 4
AnnoCPAN: Annotated \s-1CPAN\s0 documentation
.Sp
<http://annocpan.org/dist/DBI>
<http://annocpan.org/dist/SQL\-Statement>
.IP "\(bu" 4
\&\s-1CPAN\s0 Ratings
.Sp
<http://cpanratings.perl.org/d/DBI>
.IP "\(bu" 4
Search \s-1CPAN\s0
.Sp
<http://search.cpan.org/dist/DBI/>
.SS "Where can I go for more help?"
.IX Subsection "Where can I go for more help?"
For questions about installation or usage, please ask on the
dbi\-dev@perl.org mailing list.
.PP
If you have a bug report, patch or suggestion, please open
a new report ticket on \s-1CPAN,\s0 if there is not already one for
the issue you want to report. Of course, you can mail any of the
module maintainers, but it is less likely to be missed if
it is reported on \s-1RT.\s0
.PP
Report tickets should contain a detailed description of the bug or
enhancement request you want to report and at least an easy way to
verify/reproduce the issue and any supplied fix. Patches are always
welcome, too.
.SH "ACKNOWLEDGEMENTS"
.IX Header "ACKNOWLEDGEMENTS"
Thanks to Tim Bunce, Martin Evans and H.Merijn Brand for their continued
support while developing DBD::File, \s-1DBD::DBM\s0 and DBD::AnyData.
Their support, hints and feedback helped to design and implement this
module.
.SH "AUTHOR"
.IX Header "AUTHOR"
This module is currently maintained by
.PP
H.Merijn Brand < h.m.brand at xs4all.nl > and
Jens Rehsack  < rehsack at googlemail.com >
.PP
The original authors are Jochen Wiedmann and Jeff Zucker.
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
.Vb 3
\& Copyright (C) 2009\-2013 by H.Merijn Brand & Jens Rehsack
\& Copyright (C) 2004\-2009 by Jeff Zucker
\& Copyright (C) 1998\-2004 by Jochen Wiedmann
.Ve
.PP
All rights reserved.
.PP
You may freely distribute and/or modify this module under the terms of
either the \s-1GNU\s0 General Public License (\s-1GPL\s0) or the Artistic License, as
specified in the Perl \s-1README\s0 file.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\s-1DBI\s0, DBD::File, DBD::AnyData and DBD::Sys.
