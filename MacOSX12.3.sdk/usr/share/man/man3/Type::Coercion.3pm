.\" Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Type::Coercion 3"
.TH Type::Coercion 3 "2020-10-28" "perl v5.30.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Type::Coercion \- a set of coercions to a particular target type constraint
.SH "STATUS"
.IX Header "STATUS"
This module is covered by the
Type-Tiny stability policy.
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
.SS "Constructors"
.IX Subsection "Constructors"
.ie n .IP """new(%attributes)""" 4
.el .IP "\f(CWnew(%attributes)\fR" 4
.IX Item "new(%attributes)"
Moose-style constructor function.
.ie n .IP """add($c1, $c2)""" 4
.el .IP "\f(CWadd($c1, $c2)\fR" 4
.IX Item "add($c1, $c2)"
Create a Type::Coercion from two existing Type::Coercion objects.
.SS "Attributes"
.IX Subsection "Attributes"
Attributes are named values that may be passed to the constructor. For
each attribute, there is a corresponding reader method. For example:
.PP
.Vb 2
\&   my $c = Type::Coercion\->new( type_constraint => Int );
\&   my $t = $c\->type_constraint;  # Int
.Ve
.PP
\fIImportant attributes\fR
.IX Subsection "Important attributes"
.PP
These are the attributes you are likely to be most interested in
providing when creating your own type coercions, and most interested
in reading when dealing with coercion objects.
.ie n .IP """type_constraint""" 4
.el .IP "\f(CWtype_constraint\fR" 4
.IX Item "type_constraint"
Weak reference to the target type constraint (i.e. the type constraint which
the output of coercion coderefs is expected to conform to).
.ie n .IP """type_coercion_map""" 4
.el .IP "\f(CWtype_coercion_map\fR" 4
.IX Item "type_coercion_map"
Arrayref of source\-type/code pairs.
.ie n .IP """frozen""" 4
.el .IP "\f(CWfrozen\fR" 4
.IX Item "frozen"
Boolean; default false. A frozen coercion cannot have \f(CW\*(C`add_type_coercions\*(C'\fR
called upon it.
.ie n .IP """name""" 4
.el .IP "\f(CWname\fR" 4
.IX Item "name"
A name for the coercion. These need to conform to certain naming
rules (they must begin with an uppercase letter and continue using only
letters, digits 0\-9 and underscores).
.Sp
Optional; if not supplied will be an anonymous coercion.
.ie n .IP """display_name""" 4
.el .IP "\f(CWdisplay_name\fR" 4
.IX Item "display_name"
A name to display for the coercion when stringified. These don't have
to conform to any naming rules. Optional; a default name will be
calculated from the \f(CW\*(C`name\*(C'\fR.
.ie n .IP """library""" 4
.el .IP "\f(CWlibrary\fR" 4
.IX Item "library"
The package name of the type library this coercion is associated with.
Optional. Informational only: setting this attribute does not install
the coercion into the package.
.PP
\fIAttributes related to parameterizable and parameterized coercions\fR
.IX Subsection "Attributes related to parameterizable and parameterized coercions"
.PP
The following attributes are used for parameterized coercions, but are not
fully documented because they may change in the near future:
.ie n .IP """coercion_generator""" 4
.el .IP "\f(CWcoercion_generator\fR" 4
.IX Item "coercion_generator"
.PD 0
.ie n .IP """parameters""" 4
.el .IP "\f(CWparameters\fR" 4
.IX Item "parameters"
.ie n .IP """parameterized_from""" 4
.el .IP "\f(CWparameterized_from\fR" 4
.IX Item "parameterized_from"
.PD
.PP
\fILazy generated attributes\fR
.IX Subsection "Lazy generated attributes"
.PP
The following attributes should not be usually passed to the constructor;
unless you're doing something especially unusual, you should rely on the
default lazily-built return values.
.ie n .IP """compiled_coercion""" 4
.el .IP "\f(CWcompiled_coercion\fR" 4
.IX Item "compiled_coercion"
Coderef to coerce a value (\f(CW$_[0]\fR).
.Sp
The general point of this attribute is that you should not set it, but
rely on the lazily-built default. Type::Coerce will usually generate a
pretty fast coderef, inlining all type constraint checks, etc.
.ie n .IP """moose_coercion""" 4
.el .IP "\f(CWmoose_coercion\fR" 4
.IX Item "moose_coercion"
A Moose::Meta::TypeCoercion object equivalent to this one. Don't set this
manually; rely on the default built one.
.SS "Methods"
.IX Subsection "Methods"
\fIPredicate methods\fR
.IX Subsection "Predicate methods"
.PP
These methods return booleans indicating information about the coercion.
They are each tightly associated with a particular attribute.
(See \*(L"Attributes\*(R".)
.ie n .IP """has_type_constraint"", ""has_library""" 4
.el .IP "\f(CWhas_type_constraint\fR, \f(CWhas_library\fR" 4
.IX Item "has_type_constraint, has_library"
Simple Moose-style predicate methods indicating the presence or
absence of an attribute.
.ie n .IP """is_anon""" 4
.el .IP "\f(CWis_anon\fR" 4
.IX Item "is_anon"
Returns true iff the coercion does not have a \f(CW\*(C`name\*(C'\fR.
.PP
The following predicates are used for parameterized coercions, but are not
fully documented because they may change in the near future:
.ie n .IP """has_coercion_generator""" 4
.el .IP "\f(CWhas_coercion_generator\fR" 4
.IX Item "has_coercion_generator"
.PD 0
.ie n .IP """has_parameters""" 4
.el .IP "\f(CWhas_parameters\fR" 4
.IX Item "has_parameters"
.ie n .IP """is_parameterizable""" 4
.el .IP "\f(CWis_parameterizable\fR" 4
.IX Item "is_parameterizable"
.ie n .IP """is_parameterized""" 4
.el .IP "\f(CWis_parameterized\fR" 4
.IX Item "is_parameterized"
.PD
.PP
\fICoercion\fR
.IX Subsection "Coercion"
.PP
The following methods are used for coercing values to a type constraint:
.ie n .IP """coerce($value)""" 4
.el .IP "\f(CWcoerce($value)\fR" 4
.IX Item "coerce($value)"
Coerce the value to the target type.
.Sp
Returns the coerced value, or the original value if no coercion was
possible.
.ie n .IP """assert_coerce($value)""" 4
.el .IP "\f(CWassert_coerce($value)\fR" 4
.IX Item "assert_coerce($value)"
Coerce the value to the target type, and throw an exception if the result
does not validate against the target type constraint.
.Sp
Returns the coerced value.
.PP
\fICoercion code definition methods\fR
.IX Subsection "Coercion code definition methods"
.PP
These methods all return \f(CW$self\fR so are suitable for chaining.
.ie n .IP """add_type_coercions($type1, $code1, ...)""" 4
.el .IP "\f(CWadd_type_coercions($type1, $code1, ...)\fR" 4
.IX Item "add_type_coercions($type1, $code1, ...)"
Takes one or more pairs of Type::Tiny constraints and coercion code,
creating an ordered list of source types and coercion codes.
.Sp
Coercion codes can be expressed as either a string of Perl code (this
includes objects which overload stringification), or a coderef (or object
that overloads coderefification). In either case, the value to be coerced
is \f(CW$_\fR.
.Sp
\&\f(CW\*(C`add_type_coercions($coercion_object)\*(C'\fR also works, and can be used
to copy coercions from another type constraint:
.Sp
.Vb 1
\&   $type\->coercion\->add_type_coercions($othertype\->coercion)\->freeze;
.Ve
.ie n .IP """freeze""" 4
.el .IP "\f(CWfreeze\fR" 4
.IX Item "freeze"
Sets the \f(CW\*(C`frozen\*(C'\fR attribute to true. Called automatically by Type::Tiny
sometimes.
.ie n .IP """i_really_want_to_unfreeze""" 4
.el .IP "\f(CWi_really_want_to_unfreeze\fR" 4
.IX Item "i_really_want_to_unfreeze"
If you really want to unfreeze a coercion, call this method.
.Sp
Don't call this method. It will potentially lead to subtle bugs.
.Sp
This method is considered unstable; future versions of Type::Tiny may
alter its behaviour (e.g. to throw an exception if it has been detected
that unfreezing this particular coercion will cause bugs).
.PP
\fIParameterization\fR
.IX Subsection "Parameterization"
.PP
The following method is used for parameterized coercions, but is not
fully documented because it may change in the near future:
.ie n .IP """parameterize(@params)""" 4
.el .IP "\f(CWparameterize(@params)\fR" 4
.IX Item "parameterize(@params)"
.PP
\fIType coercion introspection methods\fR
.IX Subsection "Type coercion introspection methods"
.PP
These methods allow you to determine a coercion's relationship to type
constraints:
.ie n .IP """has_coercion_for_type($source_type)""" 4
.el .IP "\f(CWhas_coercion_for_type($source_type)\fR" 4
.IX Item "has_coercion_for_type($source_type)"
Returns true iff this coercion has a coercion from the source type.
.Sp
Returns the special string \f(CW"0 but true"\fR if no coercion should
actually be necessary for this type. (For example, if a coercion coerces
to a theoretical \*(L"Number\*(R" type, there is probably no coercion necessary
for values that already conform to the \*(L"Integer\*(R" type.)
.ie n .IP """has_coercion_for_value($value)""" 4
.el .IP "\f(CWhas_coercion_for_value($value)\fR" 4
.IX Item "has_coercion_for_value($value)"
Returns true iff the value could be coerced by this coercion.
.Sp
Returns the special string \f(CW"0 but true"\fR if no coercion would be
actually be necessary for this value (due to it already meeting the target
type constraint).
.PP
The \f(CW\*(C`type_constraint\*(C'\fR attribute provides a type constraint object for the
target type constraint of the coercion. See \*(L"Attributes\*(R".
.PP
\fIInlining methods\fR
.IX Subsection "Inlining methods"
.PP
The following methods are used to generate strings of Perl code which
may be pasted into stringy \f(CW\*(C`eval\*(C'\fRuated subs to perform type coercions:
.ie n .IP """can_be_inlined""" 4
.el .IP "\f(CWcan_be_inlined\fR" 4
.IX Item "can_be_inlined"
Returns true iff the coercion can be inlined.
.ie n .IP """inline_coercion($varname)""" 4
.el .IP "\f(CWinline_coercion($varname)\fR" 4
.IX Item "inline_coercion($varname)"
Much like \f(CW\*(C`inline_coerce\*(C'\fR from Type::Tiny.
.PP
\fIOther methods\fR
.IX Subsection "Other methods"
.ie n .IP """qualified_name""" 4
.el .IP "\f(CWqualified_name\fR" 4
.IX Item "qualified_name"
For non-anonymous coercions that have a library, returns a qualified
\&\f(CW"MyLib::MyCoercion"\fR sort of name. Otherwise, returns the same
as \f(CW\*(C`name\*(C'\fR.
.ie n .IP """isa($class)"", ""can($method)"", ""AUTOLOAD(@args)""" 4
.el .IP "\f(CWisa($class)\fR, \f(CWcan($method)\fR, \f(CWAUTOLOAD(@args)\fR" 4
.IX Item "isa($class), can($method), AUTOLOAD(@args)"
If Moose is loaded, then the combination of these methods is used to mock
a Moose::Meta::TypeCoercion.
.PP
The following methods exist for Moose/Mouse compatibility, but do not do
anything useful.
.ie n .IP """compile_type_coercion""" 4
.el .IP "\f(CWcompile_type_coercion\fR" 4
.IX Item "compile_type_coercion"
.PD 0
.ie n .IP """meta""" 4
.el .IP "\f(CWmeta\fR" 4
.IX Item "meta"
.PD
.SS "Overloading"
.IX Subsection "Overloading"
.IP "\(bu" 4
Boolification is overloaded to always return true.
.IP "\(bu" 4
Coderefification is overloaded to call \f(CW\*(C`coerce\*(C'\fR.
.IP "\(bu" 4
On Perl 5.10.1 and above, smart match is overloaded to call \f(CW\*(C`has_coercion_for_value\*(C'\fR.
.PP
Previous versions of Type::Coercion would overload the \f(CW\*(C`+\*(C'\fR operator
to call \f(CW\*(C`add\*(C'\fR. Support for this was dropped after 0.040.
.SH "DIAGNOSTICS"
.IX Header "DIAGNOSTICS"
.IP "\fIAttempt to add coercion code to a Type::Coercion which has been frozen\fR" 4
.IX Item "Attempt to add coercion code to a Type::Coercion which has been frozen"
Type::Tiny type constraints are designed as immutable objects. Once you've
created a constraint, rather than modifying it you generally create child
constraints to do what you need.
.Sp
Type::Coercion objects, on the other hand, are mutable. Coercion routines
can be added at any time during the object's lifetime.
.Sp
Sometimes Type::Tiny needs to freeze a Type::Coercion object to prevent this.
In Moose and Mouse code this is likely to happen as soon as you use a
type constraint in an attribute.
.Sp
Workarounds:
.RS 4
.IP "\(bu" 4
Define as many of your coercions as possible within type libraries, not
within the code that uses the type libraries. The type library will be
evaluated relatively early, likely before there is any reason to freeze
a coercion.
.IP "\(bu" 4
If you do need to add coercions to a type within application code outside
the type library, instead create a subtype and add coercions to that. The
\&\f(CW\*(C`plus_coercions\*(C'\fR method provided by Type::Tiny should make this simple.
.RE
.RS 4
.RE
.SH "BUGS"
.IX Header "BUGS"
Please report any bugs to
<http://rt.cpan.org/Dist/Display.html?Queue=Type\-Tiny>.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Type::Tiny::Manual.
.PP
Type::Tiny, Type::Library, Type::Utils, Types::Standard.
.PP
Type::Coercion::Union.
.PP
Moose::Meta::TypeCoercion.
.SH "AUTHOR"
.IX Header "AUTHOR"
Toby Inkster <tobyink@cpan.org>.
.SH "COPYRIGHT AND LICENCE"
.IX Header "COPYRIGHT AND LICENCE"
This software is copyright (c) 2013\-2014, 2017\-2020 by Toby Inkster.
.PP
This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.
.SH "DISCLAIMER OF WARRANTIES"
.IX Header "DISCLAIMER OF WARRANTIES"
\&\s-1THIS PACKAGE IS PROVIDED \*(L"AS IS\*(R" AND WITHOUT ANY EXPRESS OR IMPLIED
WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.\s0
