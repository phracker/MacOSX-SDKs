.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Reliable 3"
.TH Reliable 3 "2003-11-23" "perl v5.18.4" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Proc::Reliable \-\- Run external processes reliably with many options.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
use Proc::Reliable;
.PP
Create a new process object
.PP
.Vb 1
\&   $myproc = Proc::Reliable\->new();
.Ve
.PP
Run a subprocess and collect its output
.PP
.Vb 1
\&   $output = $myproc\->run("/bin/ls \-l");
.Ve
.PP
Check for problems
.PP
.Vb 3
\&   if($myproc\->status()) {
\&     print("problem!\en");
\&   }
.Ve
.PP
Run another subprocess, keeping stdout and stderr separated.
Also, send the subprocess some data on stdin.
.PP
.Vb 6
\&   $msg = "Hello World\en");
\&   $p\->want_single_list(0);
\&   $stdout = $p\->run("/usr/bin/fastmail \- foo@bar.com", $msg);
\&   if($p\->status()) {
\&     print("problem: ", $p\->stderr(), "\en");
\&   }
.Ve
.PP
Another way to get output
.PP
.Vb 1
\&   ($stdout, $stderr, $status, $msg) = $p\->run("/bin/ls \-l");
.Ve
.SH "OPTIONS"
.IX Header "OPTIONS"
Run Modes
.PP
.Vb 5
\& $p\->run("shell\-command\-line");  # Launch a shell process
\& $p\->run("cmdline", "data");     # Launch a shell process with stdin data
\& $p\->run(["cmd", "arg1", ...]);  # Bypass shell processing of arguments
\& $p\->run(sub { ... });           # Launch a perl subroutine
\& $p\->run(\e&subroutine);          # Launch a perl subroutine
.Ve
.PP
Option settings below represent defaults
.PP
.Vb 10
\& $p\->num_tries(1);           # execute the program only once
\& $p\->time_per_try(60);       # time per try 60 sec
\& $p\->maxtime(60);            # set overall timeout
\& $p\->time_btw_tries(5);      # time between tries 5 sec
\& $p\->want_single_list();     # return STDOUT and STDERR together
\& $p\->accept_no_error();      # Re\-try if any STDERR output
\& $p\->pattern_stdout($pat);   # require STDOUT to match regex $pat
\& $p\->pattern_stderr($pat);   # require STDERR to match regex $pat
\& $p\->allow_shell(1);         # allowed to use shell for operation
\& $p\->child_exit_time(1.0);   # timeout for child to exit after it closes stdout
\& $p\->sigterm_exit_time(0.5); # timeout for child to exit after sigterm
\& $p\->sigkill_exit_time(0.5); # timeout for child to exit after sigkill
\& $p\->input_chunking(0);      # feed stdin data line\-by\-line to subprocess
\& $p\->stdin_error_ok(0);      # ok if child exits without reading all stdin
\& $p\->stdout_cb(undef);       # callback function for line\-by\-line stdout
\& $p\->stderr_cb(undef);       # callback function for line\-by\-line stderr
.Ve
.PP
Getting output
.PP
.Vb 4
\& $out = $p\->stdout();        # stdout produced by last run()
\& $err = $p\->stderr();        # stderr produced by last run()
\& $stat = $p\->status();       # exit code produced by last run()
\& $msg = $p\->msg();           # module messages produced by last run()
.Ve
.PP
Debug
.PP
Proc::Reliable::debug($level);         # Turn debug on
.SH "OVERVIEW"
.IX Header "OVERVIEW"
Proc::Reliable is a class for simple, reliable and
configurable subprocess execution in perl.  In particular, it is
especially useful for managing the execution of 'problem' programs
which are likely to fail, hang, or otherwise behave in an unruly manner.
.PP
Proc::Reliable includes all the
functionality of the backticks operator and \fIsystem()\fR functions, plus
many common uses of \fIfork()\fR and \fIexec()\fR, \fIopen2()\fR and \fIopen3()\fR.
Proc::Reliable incorporates a number of options, including 
sending data to the subprocess on \s-1STDIN,\s0 collecting \s-1STDOUT\s0 and \s-1STDERR\s0
separately or together, killing hung processes, timouts and automatic retries.
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
A new process object is created by
.PP
.Vb 1
\&   $myproc = Proc::Reliable\->new();
.Ve
.PP
The default will run a subprocess only once with a 60\-second timeout.
Either shell-like command lines or references 
to perl subroutines can be specified for launching a process in 
background.  A simple list process, for example, can be started 
via the shell as
.PP
.Vb 1
\&   $out = $myproc\->run("ls");
.Ve
.PP
To separate stdout, stderr, and exit status:
.PP
.Vb 1
\&   ($out, $err, $status, $msg) = $myproc\->run("ls");
.Ve
.PP
The output data is also stored within the \f(CW$myproc\fR object for later
retrieval.  You can also run a perl subroutine in a subprocess, with
.PP
.Vb 1
\&   $myproc\->run(sub { return <*>; });
.Ve
.PP
The \fIrun\fR Method will try to run the named process.  If the 
process times out (after \fItime_per_try\fR seconds) or has an
error defined as unacceptable and you would like to re-run it,
you can use the \fInum_tries\fR option.  Use the \fItime_btw_tries\fR
option to set the number of seconds between runs.  This can repeat
until \fImaxtime\fR seconds have elapsed.
.PP
When using \fInum_tries\fR, the user can specify what constitutes an
unacceptable error of \s-1STDOUT\s0 or \s-1STDERR\s0 output \*(-- i.e. demanding a retry.
One common shorthand is to have the \fIrun\fR method retry if there
is any return from \s-1STDERR.  \s0
.PP
.Vb 3
\&   $myproc\->accept_no_error();    # Re\-try if any STDERR
\&   $myproc\->pattern_stdout($pat); # require STDOUT to match regex $pat
\&   $myproc\->pattern_stderr($pat); # require STDERR to match regex $pat
.Ve
.PP
Subprocess completion is detected when the process closes all filehandles.
The process must then exit before child_exit_time expires, or it will be
killed.  If the subprocess does not exit, it is sent a \s-1TERM\s0 signal unless
sigterm_exit_time is 0.  then if it does not exit before sigterm_exit_time
expires, it is sent a \s-1KILL\s0 signal unless sigkill_exit_time is 0.  then if
it does not exit before sigkill_exit_time expires an error is generated.
waiting is done in 0.01 second increments.
.PP
Proc::Reliable is not MT-Safe due to signals usage.
.SH "METHODS"
.IX Header "METHODS"
The following methods are available:
.IP "new (Constructor)" 4
.IX Item "new (Constructor)"
Create a new instance of this class by writing either
.Sp
.Vb 1
\&    $proc = new Proc::Reliable;   or   $proc = Proc::Reliable\->new();
.Ve
.Sp
The \fInew\fR method accepts any valid configuration options:
.Sp
.Vb 1
\&    $proc = Proc::Reliable\->new(\*(Aqmaxtime\*(Aq => 200, \*(Aqnum_tries\*(Aq => 3);
.Ve
.IP "run" 4
.IX Item "run"
Run a new process and collect the standard output and standard 
error via separate pipes.
.Sp
.Vb 2
\&  $out = $proc\->run("program\-name");
\& ($out, $err, $status, $msg) = $proc\->run("program\-name");
.Ve
.Sp
by default with a single return value, stdout and stderr are combined
to a single stream and returned.  with 4 return values, stdout and
stderr are separated, and the program exit status is also returned.
\&\f(CW$msg\fR contains messages from Proc::Reliable when errors occur.
Set \fIwant_single_list\fR\|(1) to force stdout and stderr to be combined,
and \fIwant_single_list\fR\|(0) to force them separated.  The results from
\&\fIrun()\fR are stored as member data also:
.Sp
.Vb 9
\&  $proc\->want_single_list(0);
\&  $proc\->run("program");
\&  if($proc\->status) {
\&    print($proc\->stderr);
\&    exit;
\&  }
\&  else {
\&    print($proc\->stdout);
\&  }
.Ve
.Sp
Program exit status is returned in the same format as \fIexec()\fR:
bits 0\-7 set if program exited from a signal, bits 8\-15 are the exit status
on a normal program exit.
.Sp
You can also set up callbacks to run a function of your choice as
each line of stdout and stderr is produced by the child process
using the stdout_cb and stderr_cb options.
.Sp
There are a number of other options.
You can also feed the forked program data on stdin via a second argument to \fIrun()\fR:
.Sp
.Vb 2
\& $myinput = "hello\entest\en";
\& $output = $proc\->run("program\-name", $myinput);
.Ve
.Sp
The first option to \fIrun()\fR supports three forms:
1) string containing command string to execute.  this incurs shell parsing.
2) arrayref containing split command string to execute.  this bypasses shell parsing.
3) coderef to perl function.
The first two options are executed via \fIexec()\fR, so the specifics of incurring shell
parsing are the same.
.Sp
The second option to \fIrun()\fR supports two forms:
1) string containing data to feed on stdin
2) stringref pointing to data to feed on stdin
.Sp
You can start execution of an 
independent Perl function (like \*(L"eval\*(R" except with timeout, 
retries, etc.).  Simply provide the function reference like
.Sp
.Vb 1
\& $output = $proc\->run(\e&perl_function);
.Ve
.Sp
or supply an unnamed subroutine:
.Sp
.Vb 1
\& $output = $proc\->run( sub { sleep(1) } );
.Ve
.Sp
The \fIrun\fR Method returns after the the function finishes, 
one way or another.
.IP "debug" 4
.IX Item "debug"
Switches debug messages on and off \*(-- \fIProc::Reliable::debug\fR\|(1) switches
them on, \fIProc::Reliable::debug\fR\|(0) keeps Proc::Reliable quiet.
.IP "maxtime" 4
.IX Item "maxtime"
Return or set the maximum time in seconds per \fIrun\fR method call.  
Default is 300 seconds (i.e. 5 minutes).
.IP "num_tries" 4
.IX Item "num_tries"
Return or set the maximum number of tries the \fIrun\fR method will 
attempt an operation if there are unallowed errors.  Default is 5.
.IP "time_per_try" 4
.IX Item "time_per_try"
Return or set the maximum time in seconds for each attempt which 
\&\fIrun\fR makes of an operation.  Multiple tries in case of error 
can go longer than this.  Default is 30 seconds.
.IP "time_btw_tries" 4
.IX Item "time_btw_tries"
Return or set the time in seconds between attempted operations 
in case of unacceptable error.  Default is 5 seconds.
.IP "child_exit_time" 4
.IX Item "child_exit_time"
When the subprocess closes stdout, it is assumed to have completed
normal operation.  It is expected to exit within the amount of time
specified.  If it does not exit, it will be killed (with \s-1SIGTERM\s0).
This option can be disabled by setting to '0'.
Values are in seconds, with a resolution of 0.01.
.IP "sigterm_exit_time" 4
.IX Item "sigterm_exit_time"
If the \fItime_per_try\fR or \fImax_time\fR has been exceeded, or if
\&\fIchild_exit_time\fR action has not succeeded, the subprocess will be
killed with \s-1SIGTERM. \s0 This option specifies the amount of time to allow
the process to exit after closing stdout.
This option can be disabled by setting to '0'.
Values are in seconds, with a resolution of 0.01.
.IP "sigkill_exit_time" 4
.IX Item "sigkill_exit_time"
Similar to \fIsigterm_exit_time\fR, but a \s-1SIGKILL\s0 is sent instead of a
\&\s-1SIGTERM. \s0 When both options are enabled, the \s-1SIGTERM\s0 is sent first
and \s-1SIGKILL\s0 is then sent after the specified time only if the
subprocess is still alive.
This option can be disabled by setting to '0'.
Values are in seconds, with a resolution of 0.01.
.IP "input_chunking" 4
.IX Item "input_chunking"
If data is being written to the subprocess on stdin, this option will
cause the module to \fIsplit()\fR the input data at linefeeds, and only feed
the subprocess a line at a time.  This option typically would be used
when the subprocess is an application with a command prompt and does
not work properly when all the data is fed on stdin at once.
The module will feed the subprocess one line of data on stdin, and
will then wait until some data is produced by the subprocess on stdout
or stderr.  It will then feed the next line of data on stdin.
.IP "stdout_cb" 4
.IX Item "stdout_cb"
Set up a callback function to get stdout data from the child line-by-line.
The function you supply will be called whenever the child prints a line
onto stdout.  This is the only way to get output from the child while it
is still running, the normal method will give you all the output at once
after the child exits.
.IP "stderr_cb" 4
.IX Item "stderr_cb"
Similar to stdout_cb for stderr data.
.SH "REQUIREMENTS"
.IX Header "REQUIREMENTS"
I recommend using at least perl 5.003.
.SH "AUTHORS"
.IX Header "AUTHORS"
Proc::Reliable by Dan Goldwater <dgold at zblob dot com>
.PP
Based on Proc::Short, written by John Hanju Kim <jhkim@fnal.gov>.
.PP
Contributions by Stephen Cope and Jason Robertson.
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright 2001 by Dan Goldwater, all rights reserved.
Copyright 1999 by John Hanju Kim, all rights reserved.
.PP
This program is free software, you can redistribute it and/or 
modify it under the same terms as Perl itself.
.SH "POD ERRORS"
.IX Header "POD ERRORS"
Hey! \fBThe above document had some coding errors, which are explained below:\fR
.IP "Around line 907:" 4
.IX Item "Around line 907:"
You forgot a '=back' before '=head1'
