.\" Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Socket6 3"
.TH Socket6 3 "2018-09-30" "perl v5.30.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Socket6 \- IPv6 related part of the C socket.h defines and structure manipulators
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&    use Socket;
\&    use Socket6;
\&
\&    @res = getaddrinfo(\*(Aqhishost.com\*(Aq, \*(Aqdaytime\*(Aq, AF_UNSPEC, SOCK_STREAM);
\&    $family = \-1;
\&    while (scalar(@res) >= 5) {
\&        ($family, $socktype, $proto, $saddr, $canonname, @res) = @res;
\&
\&        ($host, $port) = getnameinfo($saddr, NI_NUMERICHOST | NI_NUMERICSERV);
\&        print STDERR "Trying to connect to $host port $port...\en";
\&
\&        socket(Socket_Handle, $family, $socktype, $proto) || next;
\&        connect(Socket_Handle, $saddr) && last;
\&
\&        close(Socket_Handle);
\&        $family = \-1;
\&    }
\&
\&    if ($family != \-1) {
\&        print STDERR "connected to $host port $port\en";
\&    } else {
\&        die "connect attempt failed\en";
\&    }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module provides glue routines to the various IPv6 functions.
.PP
If you use the Socket6 module,
be sure to specify \*(L"use Socket\*(R" as well as \*(L"use Socket6\*(R".
.PP
Functions supplied are:
.IP "inet_pton \s-1FAMILY, TEXT_ADDRESS\s0" 4
.IX Item "inet_pton FAMILY, TEXT_ADDRESS"
.Vb 4
\&    This function takes an IP address in presentation (or string) format
\&    and converts it into numeric (or binary) format.
\&    The type of IP address conversion (IPv4 versus IPv6) is controlled
\&    by the FAMILY argument.
.Ve
.IP "inet_ntop \s-1FAMILY, BINARY_ADDRESS\s0" 4
.IX Item "inet_ntop FAMILY, BINARY_ADDRESS"
.Vb 4
\&    This function takes an IP address in numeric (or binary) format
\&    and converts it into presentation (or string) format
\&    The type of IP address conversion (IPv4 versus IPv6) is controlled
\&    by the FAMILY argument.
.Ve
.IP "pack_sockaddr_in6 \s-1PORT, ADDR\s0" 4
.IX Item "pack_sockaddr_in6 PORT, ADDR"
.Vb 5
\&    This function takes two arguments: a port number, and a 16\-octet
\&    IPv6 address structure (as returned by inet_pton()).
\&    It returns the sockaddr_in6 structure with these arguments packed
\&    into their correct fields, as well as the AF_INET6 family.
\&    The other fields are not set and their values should not be relied upon.
.Ve
.IP "pack_sockaddr_in6_all \s-1PORT, FLOWINFO, ADDR, SCOPEID\s0" 4
.IX Item "pack_sockaddr_in6_all PORT, FLOWINFO, ADDR, SCOPEID"
.Vb 5
\&    This function takes four arguments: a port number, a 16\-octet
\&    IPv6 address structure (as returned by inet_pton), any
\&    special flow information, and any specific scope information.
\&    It returns a complete sockaddr_in6 structure with these arguments packed
\&    into their correct fields, as well as the AF_INET6 family.
.Ve
.IP "unpack_sockaddr_in6 \s-1NAME\s0" 4
.IX Item "unpack_sockaddr_in6 NAME"
.Vb 5
\&    This function takes a sockaddr_in6 structure (as returned by
\&    pack_sockaddr_in6()) and returns a list of two elements:
\&    the port number and the 16\-octet IP address.
\&    This function will croak if it determines it has not been
\&    passed an IPv6 structure.
.Ve
.IP "unpack_sockaddr_in6_all \s-1NAME\s0" 4
.IX Item "unpack_sockaddr_in6_all NAME"
.Vb 6
\&    This function takes a sockaddr_in6 structure (as returned by
\&    pack_sockaddr_in6()) and returns a list of four elements:
\&    the port number, the flow information, the 16\-octet IP address,
\&    and the scope information.
\&    This function will croak if it determines it has not been
\&    passed an IPv6 structure.
.Ve
.IP "gethostbyname2 \s-1HOSTNAME, FAMILY\s0" 4
.IX Item "gethostbyname2 HOSTNAME, FAMILY"
.PD 0
.IP "getaddrinfo \s-1NODENAME, SERVICENAME,\s0 [\s-1FAMILY, SOCKTYPE, PROTOCOL, FLAGS\s0]" 4
.IX Item "getaddrinfo NODENAME, SERVICENAME, [FAMILY, SOCKTYPE, PROTOCOL, FLAGS]"
.PD
.Vb 6
\&    This function converts node names to addresses and service names
\&    to port numbers.
\&    If the NODENAME argument is not a false value,
\&    then a nodename to address lookup is performed;
\&    otherwise a service name to port number lookup is performed.
\&    At least one of NODENAME and SERVICENAME must have a true value.
\&
\&    If the lookup is successful, a list consisting of multiples of
\&    five elements is returned.
\&    Each group of five elements consists of the address family,
\&    socket type, protocol, 16\-octet IP address, and the canonical
\&    name (undef if the node name passed is already the canonical name).
\&
\&    The arguments FAMILY, SOCKTYPE, PROTOCOL, and FLAGS are all optional.
\&
\&    This function will croak if it determines it has not been
\&    passed an IPv6 structure.
\&
\&    If the lookup is unsuccessful, the function returns a single scalar.
\&    This will contain the string version of that error in string context,
\&    and the numeric value in numeric context.
.Ve
.IP "getnameinfo \s-1NAME,\s0 [\s-1FLAGS\s0]" 4
.IX Item "getnameinfo NAME, [FLAGS]"
.Vb 2
\&    This function takes a socket address structure. If successful, it returns
\&    two strings containing the node name and service name.
\&
\&    The optional FLAGS argument controls what kind of lookup is performed.
\&
\&    If the lookup is unsuccessful, the function returns a single scalar.
\&    This will contain the string version of that error in string context,
\&    and the numeric value in numeric context.
.Ve
.IP "getipnodebyname \s-1HOST,\s0 [\s-1FAMILY, FLAGS\s0]" 4
.IX Item "getipnodebyname HOST, [FAMILY, FLAGS]"
.Vb 6
\&    This function takes either a node name or an IP address string
\&    and performs a lookup on that name (or conversion of the string).
\&    It returns a list of five elements: the canonical host name,
\&    the address family, the length in octets of the IP addresses
\&    returned, a reference to a list of IP address structures, and
\&    a reference to a list of aliases for the host name.
\&
\&    The arguments FAMILY and FLAGS are optional.
\&    Note: This function does not handle IPv6 scope identifiers,
\&    and should be used with care.
\&    And, this function was deprecated in RFC3493.
\&    The getnameinfo function should be used instead.
.Ve
.IP "getipnodebyaddr \s-1FAMILY, ADDRESS\s0" 4
.IX Item "getipnodebyaddr FAMILY, ADDRESS"
.Vb 6
\&    This function takes an IP address family and an IP address structure
\&    and performs a reverse lookup on that address.
\&    It returns a list of five elements: the canonical host name,
\&    the address family, the length in octets of the IP addresses
\&    returned, a reference to a list of IP address structures, and
\&    a reference to a list of aliases for the host name.
\&
\&    Note: This function does not handle IPv6 scope identifiers,
\&    and should be used with care.
\&    And, this function was deprecated in RFC3493.
\&    The getaddrinfo function should be used instead.
.Ve
.IP "gai_strerror \s-1ERROR_NUMBER\s0" 4
.IX Item "gai_strerror ERROR_NUMBER"
.Vb 2
\&    This function returns a string corresponding to the error number
\&    passed in as an argument.
.Ve
.IP "in6addr_any" 4
.IX Item "in6addr_any"
.Vb 1
\&    This function returns the 16\-octet wildcard address.
.Ve
.IP "in6addr_loopback" 4
.IX Item "in6addr_loopback"
.Vb 1
\&    This function returns the 16\-octet loopback address.
.Ve
