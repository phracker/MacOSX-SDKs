.\" Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Test2::Bundle::Extended 3"
.TH Test2::Bundle::Extended 3 "2020-10-22" "perl v5.30.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Test2::Bundle::Extended \- Old name for Test2::V0
.SH "*** DEPRECATED ***"
.IX Header "*** DEPRECATED ***"
This bundle has been renamed to Test2::V0, in which the \f(CW\*(Aq:v1\*(Aq\fR tag has
been removed as unnecessary.
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This is the big-daddy bundle. This bundle includes nearly every tool, and
several plugins, that the Test2 author uses. This bundle is used
extensively to test Test2::Suite itself.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use Test2::Bundle::Extended \*(Aq:v1\*(Aq;
\&
\&    ok(1, "pass");
\&
\&    ...
\&
\&    done_testing;
.Ve
.SH "RESOLVING CONFLICTS WITH MOOSE"
.IX Header "RESOLVING CONFLICTS WITH MOOSE"
.Vb 1
\&    use Test2::Bundle::Extended \*(Aq!meta\*(Aq;
.Ve
.PP
Moose and Test2::Bundle::Extended both export very different \f(CW\*(C`meta()\*(C'\fR
subs. Adding \f(CW\*(Aq!meta\*(Aq\fR to the import args will prevent the sub from being
imported. This bundle also exports the sub under the name \f(CW\*(C`meta_check()\*(C'\fR so
you can use that spelling as an alternative.
.SS "\s-1TAGS\s0"
.IX Subsection "TAGS"
.IP ":v1" 4
.IX Item ":v1"
.PD 0
.IP ":DEFAULT" 4
.IX Item ":DEFAULT"
.PD
The following are all identical:
.Sp
.Vb 1
\&    use Test2::Bundle::Extended;
\&
\&    use Test2::Bundle::Extended \*(Aq:v1\*(Aq;
\&
\&    use Test2::Bundle::Extended \*(Aq:DEFAULT\*(Aq;
.Ve
.SS "\s-1RENAMING ON IMPORT\s0"
.IX Subsection "RENAMING ON IMPORT"
.Vb 1
\&    use Test2::Bundle::Extended \*(Aq:v1\*(Aq, \*(Aq!ok\*(Aq, ok => {\-as => \*(Aqmy_ok\*(Aq};
.Ve
.PP
This bundle uses Importer for exporting, as such you can use any arguments
it accepts.
.PP
Explanation:
.IP "':v1'" 4
.IX Item "':v1'"
Use the default tag, all default exports.
.IP "'!ok'" 4
.IX Item "'!ok'"
Do not export \f(CW\*(C`ok()\*(C'\fR
.IP "ok => {\-as => 'my_ok'}" 4
.IX Item "ok => {-as => 'my_ok'}"
Actually, go ahead and import \f(CW\*(C`ok()\*(C'\fR but under the name \f(CW\*(C`my_ok()\*(C'\fR.
.PP
If you did not add the \f(CW\*(Aq!ok\*(Aq\fR argument then you would have both \f(CW\*(C`ok()\*(C'\fR and
\&\f(CW\*(C`my_ok()\*(C'\fR
.SH "PRAGMAS"
.IX Header "PRAGMAS"
All of these can be disabled via individual import arguments, or by the
\&\f(CW\*(C`\-no_pragmas\*(C'\fR argument.
.PP
.Vb 1
\&    use Test2::Bundle::Extended \-no_pragmas => 1;
.Ve
.SS "\s-1STRICT\s0"
.IX Subsection "STRICT"
strict is turned on for you. You can disable this with the \f(CW\*(C`\-no_strict\*(C'\fR or
\&\f(CW\*(C`\-no_pragmas\*(C'\fR import arguments:
.PP
.Vb 1
\&    use Test2::Bundle::Extended \-no_strict => 1;
.Ve
.SS "\s-1WARNINGS\s0"
.IX Subsection "WARNINGS"
warnings are turned on for you. You can disable this with the
\&\f(CW\*(C`\-no_warnings\*(C'\fR or \f(CW\*(C`\-no_pragmas\*(C'\fR import arguments:
.PP
.Vb 1
\&    use Test2::Bundle::Extended \-no_warnings => 1;
.Ve
.SS "\s-1UTF8\s0"
.IX Subsection "UTF8"
This is actually done via the Test2::Plugin::UTF8 plugin, see the
\&\*(L"\s-1PLUGINS\*(R"\s0 section for details.
.PP
\&\fBNote:\fR \f(CW\*(C`\-no_pragmas => 1\*(C'\fR will turn off the entire plugin.
.SH "PLUGINS"
.IX Header "PLUGINS"
.SS "\s-1SRAND\s0"
.IX Subsection "SRAND"
See Test2::Plugin::SRand.
.PP
This will set the random seed to today's date. You can provide an alternate seed
with the \f(CW\*(C`\-srand\*(C'\fR import option:
.PP
.Vb 1
\&    use Test2::Bundle::Extended \-srand => 1234;
.Ve
.SS "\s-1UTF8\s0"
.IX Subsection "UTF8"
See Test2::Plugin::UTF8.
.PP
This will set the file, and all output handles (including formatter handles), to
utf8. This will turn on the utf8 pragma for the current scope.
.PP
This can be disabled using the \f(CW\*(C`\-no_utf8 => 1\*(C'\fR or \f(CW\*(C`\-no_pragmas => 1\*(C'\fR
import arguments.
.PP
.Vb 1
\&    use Test2::Bundle::Extended \-no_utf8 => 1;
.Ve
.SS "\s-1EXIT SUMMARY\s0"
.IX Subsection "EXIT SUMMARY"
See Test2::Plugin::ExitSummary.
.PP
This plugin has no configuration.
.SH "API FUNCTIONS"
.IX Header "API FUNCTIONS"
See Test2::API for these
.ie n .IP "$ctx = \fBcontext()\fR" 4
.el .IP "\f(CW$ctx\fR = \fBcontext()\fR" 4
.IX Item "$ctx = context()"
.PD 0
.ie n .IP "$events = intercept { ... }" 4
.el .IP "\f(CW$events\fR = intercept { ... }" 4
.IX Item "$events = intercept { ... }"
.PD
.SH "TOOLS"
.IX Header "TOOLS"
.SS "\s-1TARGET\s0"
.IX Subsection "TARGET"
See Test2::Tools::Target.
.PP
You can specify a target class with the \f(CW\*(C`\-target\*(C'\fR import argument. If you do
not provide a target then \f(CW$CLASS\fR and \f(CW\*(C`CLASS()\*(C'\fR will not be imported.
.PP
.Vb 1
\&    use Test2::Bundle::Extended \-target => \*(AqMy::Class\*(Aq;
\&
\&    print $CLASS;  # My::Class
\&    print CLASS(); # My::Class
.Ve
.PP
Or you can specify names:
.PP
.Vb 1
\&    use Test2::Bundle::Extended \-target => { pkg => \*(AqSome::Package\*(Aq };
\&
\&    pkg()\->xxx; # Call \*(Aqxxx\*(Aq on Some::Package
\&    $pkg\->xxx;  # Same
.Ve
.ie n .IP "$CLASS" 4
.el .IP "\f(CW$CLASS\fR" 4
.IX Item "$CLASS"
Package variable that contains the target class name.
.ie n .IP "$class = \s-1\fBCLASS\s0()\fR" 4
.el .IP "\f(CW$class\fR = \s-1\fBCLASS\s0()\fR" 4
.IX Item "$class = CLASS()"
Constant function that returns the target class name.
.SS "\s-1DEFER\s0"
.IX Subsection "DEFER"
See Test2::Tools::Defer.
.ie n .IP "def $func => @args;" 4
.el .IP "def \f(CW$func\fR => \f(CW@args\fR;" 4
.IX Item "def $func => @args;"
.PD 0
.IP "\fBdo_def()\fR" 4
.IX Item "do_def()"
.PD
.SS "\s-1BASIC\s0"
.IX Subsection "BASIC"
See Test2::Tools::Basic.
.ie n .IP "ok($bool, $name)" 4
.el .IP "ok($bool, \f(CW$name\fR)" 4
.IX Item "ok($bool, $name)"
.PD 0
.IP "pass($name)" 4
.IX Item "pass($name)"
.IP "fail($name)" 4
.IX Item "fail($name)"
.IP "diag($message)" 4
.IX Item "diag($message)"
.IP "note($message)" 4
.IX Item "note($message)"
.ie n .IP "$todo = todo($reason)" 4
.el .IP "\f(CW$todo\fR = todo($reason)" 4
.IX Item "$todo = todo($reason)"
.ie n .IP "todo $reason => sub { ... }" 4
.el .IP "todo \f(CW$reason\fR => sub { ... }" 4
.IX Item "todo $reason => sub { ... }"
.ie n .IP "skip($reason, $count)" 4
.el .IP "skip($reason, \f(CW$count\fR)" 4
.IX Item "skip($reason, $count)"
.IP "plan($count)" 4
.IX Item "plan($count)"
.IP "skip_all($reason)" 4
.IX Item "skip_all($reason)"
.IP "\fBdone_testing()\fR" 4
.IX Item "done_testing()"
.IP "bail_out($reason)" 4
.IX Item "bail_out($reason)"
.PD
.SS "\s-1COMPARE\s0"
.IX Subsection "COMPARE"
See Test2::Tools::Compare.
.ie n .IP "is($got, $want, $name)" 4
.el .IP "is($got, \f(CW$want\fR, \f(CW$name\fR)" 4
.IX Item "is($got, $want, $name)"
.PD 0
.ie n .IP "isnt($got, $do_not_want, $name)" 4
.el .IP "isnt($got, \f(CW$do_not_want\fR, \f(CW$name\fR)" 4
.IX Item "isnt($got, $do_not_want, $name)"
.ie n .IP "like($got, qr/match/, $name)" 4
.el .IP "like($got, qr/match/, \f(CW$name\fR)" 4
.IX Item "like($got, qr/match/, $name)"
.ie n .IP "unlike($got, qr/mismatch/, $name)" 4
.el .IP "unlike($got, qr/mismatch/, \f(CW$name\fR)" 4
.IX Item "unlike($got, qr/mismatch/, $name)"
.ie n .IP "$check = match(qr/pattern/)" 4
.el .IP "\f(CW$check\fR = match(qr/pattern/)" 4
.IX Item "$check = match(qr/pattern/)"
.ie n .IP "$check = mismatch(qr/pattern/)" 4
.el .IP "\f(CW$check\fR = mismatch(qr/pattern/)" 4
.IX Item "$check = mismatch(qr/pattern/)"
.ie n .IP "$check = validator(sub { return $bool })" 4
.el .IP "\f(CW$check\fR = validator(sub { return \f(CW$bool\fR })" 4
.IX Item "$check = validator(sub { return $bool })"
.ie n .IP "$check = hash { ... }" 4
.el .IP "\f(CW$check\fR = hash { ... }" 4
.IX Item "$check = hash { ... }"
.ie n .IP "$check = array { ... }" 4
.el .IP "\f(CW$check\fR = array { ... }" 4
.IX Item "$check = array { ... }"
.ie n .IP "$check = bag { ... }" 4
.el .IP "\f(CW$check\fR = bag { ... }" 4
.IX Item "$check = bag { ... }"
.ie n .IP "$check = object { ... }" 4
.el .IP "\f(CW$check\fR = object { ... }" 4
.IX Item "$check = object { ... }"
.ie n .IP "$check = meta { ... }" 4
.el .IP "\f(CW$check\fR = meta { ... }" 4
.IX Item "$check = meta { ... }"
.ie n .IP "$check = number($num)" 4
.el .IP "\f(CW$check\fR = number($num)" 4
.IX Item "$check = number($num)"
.ie n .IP "$check = string($str)" 4
.el .IP "\f(CW$check\fR = string($str)" 4
.IX Item "$check = string($str)"
.ie n .IP "$check = in_set(@things)" 4
.el .IP "\f(CW$check\fR = in_set(@things)" 4
.IX Item "$check = in_set(@things)"
.ie n .IP "$check = not_in_set(@things)" 4
.el .IP "\f(CW$check\fR = not_in_set(@things)" 4
.IX Item "$check = not_in_set(@things)"
.ie n .IP "$check = check_set(@things)" 4
.el .IP "\f(CW$check\fR = check_set(@things)" 4
.IX Item "$check = check_set(@things)"
.ie n .IP "$check = item($thing)" 4
.el .IP "\f(CW$check\fR = item($thing)" 4
.IX Item "$check = item($thing)"
.ie n .IP "$check = item($idx => $thing)" 4
.el .IP "\f(CW$check\fR = item($idx => \f(CW$thing\fR)" 4
.IX Item "$check = item($idx => $thing)"
.ie n .IP "$check = field($name => $val)" 4
.el .IP "\f(CW$check\fR = field($name => \f(CW$val\fR)" 4
.IX Item "$check = field($name => $val)"
.ie n .IP "$check = call($method => $expect)" 4
.el .IP "\f(CW$check\fR = call($method => \f(CW$expect\fR)" 4
.IX Item "$check = call($method => $expect)"
.ie n .IP "$check = call_list($method => $expect)" 4
.el .IP "\f(CW$check\fR = call_list($method => \f(CW$expect\fR)" 4
.IX Item "$check = call_list($method => $expect)"
.ie n .IP "$check = call_hash($method => $expect)" 4
.el .IP "\f(CW$check\fR = call_hash($method => \f(CW$expect\fR)" 4
.IX Item "$check = call_hash($method => $expect)"
.ie n .IP "$check = prop($name => $expect)" 4
.el .IP "\f(CW$check\fR = prop($name => \f(CW$expect\fR)" 4
.IX Item "$check = prop($name => $expect)"
.ie n .IP "$check = check($thing)" 4
.el .IP "\f(CW$check\fR = check($thing)" 4
.IX Item "$check = check($thing)"
.ie n .IP "$check = T()" 4
.el .IP "\f(CW$check\fR = T()" 4
.IX Item "$check = T()"
.ie n .IP "$check = F()" 4
.el .IP "\f(CW$check\fR = F()" 4
.IX Item "$check = F()"
.ie n .IP "$check = D()" 4
.el .IP "\f(CW$check\fR = D()" 4
.IX Item "$check = D()"
.ie n .IP "$check = \s-1\fBDF\s0()\fR" 4
.el .IP "\f(CW$check\fR = \s-1\fBDF\s0()\fR" 4
.IX Item "$check = DF()"
.ie n .IP "$check = \s-1\fBDNE\s0()\fR" 4
.el .IP "\f(CW$check\fR = \s-1\fBDNE\s0()\fR" 4
.IX Item "$check = DNE()"
.ie n .IP "$check = \s-1\fBFDNE\s0()\fR" 4
.el .IP "\f(CW$check\fR = \s-1\fBFDNE\s0()\fR" 4
.IX Item "$check = FDNE()"
.ie n .IP "$check = exact_ref($ref)" 4
.el .IP "\f(CW$check\fR = exact_ref($ref)" 4
.IX Item "$check = exact_ref($ref)"
.IP "\fBend()\fR" 4
.IX Item "end()"
.IP "\fBetc()\fR" 4
.IX Item "etc()"
.ie n .IP "filter_items { grep { ... } @_ }" 4
.el .IP "filter_items { grep { ... } \f(CW@_\fR }" 4
.IX Item "filter_items { grep { ... } @_ }"
.ie n .IP "$check = event $type => ..." 4
.el .IP "\f(CW$check\fR = event \f(CW$type\fR => ..." 4
.IX Item "$check = event $type => ..."
.ie n .IP "@checks = fail_events $type => ..." 4
.el .IP "\f(CW@checks\fR = fail_events \f(CW$type\fR => ..." 4
.IX Item "@checks = fail_events $type => ..."
.PD
.SS "\s-1CLASSIC COMPARE\s0"
.IX Subsection "CLASSIC COMPARE"
See Test2::Tools::ClassicCompare.
.ie n .IP "cmp_ok($got, $op, $want, $name)" 4
.el .IP "cmp_ok($got, \f(CW$op\fR, \f(CW$want\fR, \f(CW$name\fR)" 4
.IX Item "cmp_ok($got, $op, $want, $name)"
.SS "\s-1SUBTEST\s0"
.IX Subsection "SUBTEST"
See Test2::Tools::Subtest.
.ie n .IP "subtest $name => sub { ... }" 4
.el .IP "subtest \f(CW$name\fR => sub { ... }" 4
.IX Item "subtest $name => sub { ... }"
(Note: This is called \f(CW\*(C`subtest_buffered()\*(C'\fR in the Tools module.)
.SS "\s-1CLASS\s0"
.IX Subsection "CLASS"
See Test2::Tools::Class.
.ie n .IP "can_ok($thing, @methods)" 4
.el .IP "can_ok($thing, \f(CW@methods\fR)" 4
.IX Item "can_ok($thing, @methods)"
.PD 0
.ie n .IP "isa_ok($thing, @classes)" 4
.el .IP "isa_ok($thing, \f(CW@classes\fR)" 4
.IX Item "isa_ok($thing, @classes)"
.ie n .IP "DOES_ok($thing, @roles)" 4
.el .IP "DOES_ok($thing, \f(CW@roles\fR)" 4
.IX Item "DOES_ok($thing, @roles)"
.PD
.SS "\s-1ENCODING\s0"
.IX Subsection "ENCODING"
See Test2::Tools::Encoding.
.IP "set_encoding($encoding)" 4
.IX Item "set_encoding($encoding)"
.SS "\s-1EXPORTS\s0"
.IX Subsection "EXPORTS"
See Test2::Tools::Exports.
.IP "imported_ok('function', '$scalar', ...)" 4
.IX Item "imported_ok('function', '$scalar', ...)"
.PD 0
.IP "not_imported_ok('function', '$scalar', ...)" 4
.IX Item "not_imported_ok('function', '$scalar', ...)"
.PD
.SS "\s-1REF\s0"
.IX Subsection "REF"
See Test2::Tools::Ref.
.ie n .IP "ref_ok($ref, $type)" 4
.el .IP "ref_ok($ref, \f(CW$type\fR)" 4
.IX Item "ref_ok($ref, $type)"
.PD 0
.ie n .IP "ref_is($got, $want)" 4
.el .IP "ref_is($got, \f(CW$want\fR)" 4
.IX Item "ref_is($got, $want)"
.ie n .IP "ref_is_not($got, $do_not_want)" 4
.el .IP "ref_is_not($got, \f(CW$do_not_want\fR)" 4
.IX Item "ref_is_not($got, $do_not_want)"
.PD
.SS "\s-1MOCK\s0"
.IX Subsection "MOCK"
See Test2::Tools::Mock.
.ie n .IP "$control = mock ..." 4
.el .IP "\f(CW$control\fR = mock ..." 4
.IX Item "$control = mock ..."
.PD 0
.ie n .IP "$bool = mocked($thing)" 4
.el .IP "\f(CW$bool\fR = mocked($thing)" 4
.IX Item "$bool = mocked($thing)"
.PD
.SS "\s-1EXCEPTION\s0"
.IX Subsection "EXCEPTION"
See Test2::Tools::Exception.
.ie n .IP "$exception = dies { ... }" 4
.el .IP "\f(CW$exception\fR = dies { ... }" 4
.IX Item "$exception = dies { ... }"
.PD 0
.ie n .IP "$bool = lives { ... }" 4
.el .IP "\f(CW$bool\fR = lives { ... }" 4
.IX Item "$bool = lives { ... }"
.ie n .IP "$bool = try_ok { ... }" 4
.el .IP "\f(CW$bool\fR = try_ok { ... }" 4
.IX Item "$bool = try_ok { ... }"
.PD
.SS "\s-1WARNINGS\s0"
.IX Subsection "WARNINGS"
See Test2::Tools::Warnings.
.ie n .IP "$count = warns { ... }" 4
.el .IP "\f(CW$count\fR = warns { ... }" 4
.IX Item "$count = warns { ... }"
.PD 0
.ie n .IP "$warning = warning { ... }" 4
.el .IP "\f(CW$warning\fR = warning { ... }" 4
.IX Item "$warning = warning { ... }"
.ie n .IP "$warnings_ref = warnings { ... }" 4
.el .IP "\f(CW$warnings_ref\fR = warnings { ... }" 4
.IX Item "$warnings_ref = warnings { ... }"
.ie n .IP "$bool = no_warnings { ... }" 4
.el .IP "\f(CW$bool\fR = no_warnings { ... }" 4
.IX Item "$bool = no_warnings { ... }"
.PD
.SH "SOURCE"
.IX Header "SOURCE"
The source code repository for Test2\-Suite can be found at
\&\fIhttps://github.com/Test\-More/Test2\-Suite/\fR.
.SH "MAINTAINERS"
.IX Header "MAINTAINERS"
.IP "Chad Granum <exodist@cpan.org>" 4
.IX Item "Chad Granum <exodist@cpan.org>"
.SH "AUTHORS"
.IX Header "AUTHORS"
.PD 0
.IP "Chad Granum <exodist@cpan.org>" 4
.IX Item "Chad Granum <exodist@cpan.org>"
.PD
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright 2018 Chad Granum <exodist@cpan.org>.
.PP
This program is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.
.PP
See \fIhttp://dev.perl.org/licenses/\fR
