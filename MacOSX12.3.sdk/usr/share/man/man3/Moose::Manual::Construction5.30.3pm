.\" Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Moose::Manual::Construction 3"
.TH Moose::Manual::Construction 3 "2019-11-22" "perl v5.30.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Moose::Manual::Construction \- Object construction (and destruction) with Moose
.SH "VERSION"
.IX Header "VERSION"
version 2.2012
.SH "WHERE'S THE CONSTRUCTOR?"
.IX Header "WHERE'S THE CONSTRUCTOR?"
\&\fBDo not define a \f(CB\*(C`new()\*(C'\fB method for your classes!\fR
.PP
When you \f(CW\*(C`use Moose\*(C'\fR in your class, your class becomes a subclass of
Moose::Object. The Moose::Object provides a \f(CW\*(C`new()\*(C'\fR method for your
class. If you follow our recommendations in Moose::Manual::BestPractices
and make your class immutable, then you actually get a class-specific \f(CW\*(C`new()\*(C'\fR
method \*(L"inlined\*(R" in your class.
.SH "OBJECT CONSTRUCTION AND ATTRIBUTES"
.IX Header "OBJECT CONSTRUCTION AND ATTRIBUTES"
The Moose-provided constructor accepts a hash or hash reference of
named parameters matching your attributes (actually, matching their
\&\f(CW\*(C`init_arg\*(C'\fRs). This is just another way in which Moose keeps you from
worrying \fIhow\fR classes are implemented. Simply define a class and
you're ready to start creating objects!
.SH "OBJECT CONSTRUCTION HOOKS"
.IX Header "OBJECT CONSTRUCTION HOOKS"
Moose lets you hook into object construction. You can validate an
object's state, do logging, customize construction from parameters which
do not match your attributes, or maybe allow non\-hash(ref) constructor
arguments. You can do this by creating \f(CW\*(C`BUILD\*(C'\fR and/or \f(CW\*(C`BUILDARGS\*(C'\fR
methods.
.PP
If these methods exist in your class, Moose will arrange for them to
be called as part of the object construction process.
.SS "\s-1BUILDARGS\s0"
.IX Subsection "BUILDARGS"
The \f(CW\*(C`BUILDARGS\*(C'\fR method is called as a class method \fIbefore\fR an
object is created. It will receive all of the arguments that were
passed to \f(CW\*(C`new()\*(C'\fR \fIas-is\fR, and is expected to return a hash
reference. This hash reference will be used to construct the object,
so it should contain keys matching your attributes' names (well,
\&\f(CW\*(C`init_arg\*(C'\fRs).
.PP
One common use for \f(CW\*(C`BUILDARGS\*(C'\fR is to accommodate a non\-hash(ref)
calling style. For example, we might want to allow our Person class to
be called with a single argument of a social security number, \f(CW\*(C`Person\->new($ssn)\*(C'\fR.
.PP
Without a \f(CW\*(C`BUILDARGS\*(C'\fR method, Moose will complain, because it expects
a hash or hash reference. We can use the \f(CW\*(C`BUILDARGS\*(C'\fR method to
accommodate this calling style:
.PP
.Vb 3
\&  around BUILDARGS => sub {
\&      my $orig  = shift;
\&      my $class = shift;
\&
\&      if ( @_ == 1 && !ref $_[0] ) {
\&          return $class\->$orig( ssn => $_[0] );
\&      }
\&      else {
\&          return $class\->$orig(@_);
\&      }
\&  };
.Ve
.PP
Note the call to \f(CW\*(C`$class\->$orig\*(C'\fR. This will call the default \f(CW\*(C`BUILDARGS\*(C'\fR
in Moose::Object. This method takes care of distinguishing between a hash
reference and a plain hash for you.
.SS "\s-1BUILD\s0"
.IX Subsection "BUILD"
The \f(CW\*(C`BUILD\*(C'\fR method is called \fIafter\fR an object is created. There are
several reasons to use a \f(CW\*(C`BUILD\*(C'\fR method. One of the most common is to
check that the object state is valid. While we can validate individual
attributes through the use of types, we can't validate the state of a
whole object that way.
.PP
.Vb 2
\&  sub BUILD {
\&      my $self = shift;
\&
\&      if ( $self\->country_of_residence eq \*(AqUSA\*(Aq ) {
\&          die \*(AqAll US residents must have an SSN\*(Aq
\&              unless $self\->has_ssn;
\&      }
\&  }
.Ve
.PP
Another use of a \f(CW\*(C`BUILD\*(C'\fR method could be for logging or tracking
object creation.
.PP
.Vb 2
\&  sub BUILD {
\&      my $self = shift;
\&
\&      debug( \*(AqMade a new person \- SSN = \*(Aq, $self\->ssn, );
\&  }
.Ve
.PP
The \f(CW\*(C`BUILD\*(C'\fR method is called with the hash reference of the parameters passed
to the constructor (after munging by \f(CW\*(C`BUILDARGS\*(C'\fR). This gives you a chance to
do something with parameters that do not represent object attributes.
.PP
.Vb 3
\&  sub BUILD {
\&      my $self = shift;
\&      my $args = shift;
\&
\&      $self\->add_friend(
\&          My::User\->new(
\&              user_id => $args\->{user_id},
\&          )
\&      );
\&  }
.Ve
.PP
\fI\s-1BUILD\s0 and parent classes\fR
.IX Subsection "BUILD and parent classes"
.PP
The interaction between multiple \f(CW\*(C`BUILD\*(C'\fR methods in an inheritance hierarchy
is different from normal Perl methods. \fBYou should never call \f(CB\*(C`$self\->SUPER::BUILD\*(C'\fB\fR, nor should you ever apply a method modifier to
\&\f(CW\*(C`BUILD\*(C'\fR. Roles are an exception to this rule, though: it's completely
acceptable to apply a method modifier to \f(CW\*(C`BUILD\*(C'\fR in a role; you can
even provide an empty \f(CW\*(C`BUILD\*(C'\fR subroutine in a role so the role is applicable
even to classes without their own \f(CW\*(C`BUILD\*(C'\fR.
.PP
Moose arranges to have all of the \f(CW\*(C`BUILD\*(C'\fR methods in a hierarchy
called when an object is constructed, \fIfrom parents to
children\fR. This might be surprising at first, because it reverses the
normal order of method inheritance.
.PP
The theory behind this is that \f(CW\*(C`BUILD\*(C'\fR methods can only be used for
increasing specialization of a class's constraints, so it makes sense
to call the least specific \f(CW\*(C`BUILD\*(C'\fR method first. Also, this is how
Perl 6 does it.
.SH "OBJECT DESTRUCTION"
.IX Header "OBJECT DESTRUCTION"
Moose provides a hook for object destruction with the \f(CW\*(C`DEMOLISH\*(C'\fR
method. As with \f(CW\*(C`BUILD\*(C'\fR, you should never explicitly call \f(CW\*(C`$self\->SUPER::DEMOLISH\*(C'\fR. Moose will arrange for all of the
\&\f(CW\*(C`DEMOLISH\*(C'\fR methods in your hierarchy to be called, from most to least
specific.
.PP
Each \f(CW\*(C`DEMOLISH\*(C'\fR method is called with a single argument. This is a boolean
value indicating whether or not this method was called as part of the global
destruction process (when the Perl interpreter exits).
.PP
In most cases, Perl's built-in garbage collection is sufficient, and
you won't need to provide a \f(CW\*(C`DEMOLISH\*(C'\fR method.
.SS "Error Handling During Destruction"
.IX Subsection "Error Handling During Destruction"
The interaction of object destruction and Perl's global \f(CW$@\fR and \f(CW$?\fR
variables can be very confusing.
.PP
Moose always localizes \f(CW$?\fR when an object is being destroyed. This means
that if you explicitly call \f(CW\*(C`exit\*(C'\fR, that exit code will be preserved even if
an object's destructor makes a system call.
.PP
Moose also preserves \f(CW$@\fR against any \f(CW\*(C`eval\*(C'\fR calls that may happen during
object destruction. However, if an object's \f(CW\*(C`DEMOLISH\*(C'\fR method actually dies,
Moose explicitly rethrows that error.
.PP
If you do not like this behavior, you will have to provide your own \f(CW\*(C`DESTROY\*(C'\fR
method and use that instead of the one provided by Moose::Object. You can
do this to preserve \f(CW$@\fR \fIand\fR capture any errors from object destruction by
creating an error stack.
.SH "AUTHORS"
.IX Header "AUTHORS"
.IP "\(bu" 4
Stevan Little <stevan.little@iinteractive.com>
.IP "\(bu" 4
Dave Rolsky <autarch@urth.org>
.IP "\(bu" 4
Jesse Luehrs <doy@tozt.net>
.IP "\(bu" 4
Shawn M Moore <code@sartak.org>
.IP "\(bu" 4
יובל קוג'מן (Yuval Kogman) <nothingmuch@woobling.org>
.IP "\(bu" 4
Karen Etheridge <ether@cpan.org>
.IP "\(bu" 4
Florian Ragwitz <rafl@debian.org>
.IP "\(bu" 4
Hans Dieter Pearcey <hdp@weftsoar.net>
.IP "\(bu" 4
Chris Prather <chris@prather.org>
.IP "\(bu" 4
Matt S Trout <mst@shadowcat.co.uk>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is copyright (c) 2006 by Infinity Interactive, Inc.
.PP
This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.
