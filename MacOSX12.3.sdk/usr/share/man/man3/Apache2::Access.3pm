.\" Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "install::TempContent::Objects::mod_perl-2.0.9::docs::api::Apache2::Access 3"
.TH install::TempContent::Objects::mod_perl-2.0.9::docs::api::Apache2::Access 3 "2015-06-18" "perl v5.30.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Apache2::Access \- A Perl API for Apache request object: Access,
Authentication and Authorization.
.SH "Synopsis"
.IX Header "Synopsis"
.Vb 1
\&  use Apache2::Access ();
\&  
\&  # allow only GET method
\&  $r\->allow_methods(1, qw(GET));
\&  
\&  # Apache Options value
\&  $options = $r\->allow_options();
\&  
\&  # Apache AllowOverride value
\&  $allow_override = $r\->allow_overrides();
\&  
\&  # which Options are allowed by AllowOverride (since Apache 2.2)
\&  $allow_override_opts = $r\->allow_override_opts();
\&  
\&  # auth name ("foo bar")
\&  $auth_name = $r\->auth_name();
\&  
\&  # auth type
\&  $auth_type = $r\->auth_type();
\&  $r\->auth_type("Digest");
\&  
\&  # Basic authentication process
\&  my ($rc, $passwd) = $r\->get_basic_auth_pw();
\&  
\&  # the login name of the remote user (RFC1413)
\&  $remote_logname = $r\->get_remote_logname();
\&  
\&  # dynamically figure out which auth has failed
\&  $r\->note_auth_failure();
\&  
\&  # note Basic auth failure
\&  $r\->note_basic_auth_failure();
\&  
\&  # note Digest auth failure
\&  $r\->note_digest_auth_failure();
\&  
\&  # Apache Request value(s)
\&  $requires = $r\->requires();
\&  
\&  # Apache Satisfy value (as a number)
\&  $satisfy = $r\->satisfies();
\&  
\&  # check whether some auth is configured
\&  $need_auth = $r\->some_auth_required();
.Ve
.SH "Description"
.IX Header "Description"
The \s-1API\s0 provided by this module deals with access, authentication and
authorization phases.
.PP
\&\f(CW\*(C`Apache2::Access\*(C'\fR extends
\&\f(CW\*(C`Apache2::RequestRec\*(C'\fR.
.SH "API"
.IX Header "API"
\&\f(CW\*(C`Apache2::Access\*(C'\fR provides the following functions and/or methods:
.ie n .SS """allow_methods"""
.el .SS "\f(CWallow_methods\fP"
.IX Subsection "allow_methods"
Specify which \s-1HTTP\s0 methods are allowed
.PP
.Vb 2
\&  $r\->allow_methods($reset);
\&  $r\->allow_methods($reset, @methods);
.Ve
.ie n .IP "obj: $r ( ""Apache2::RequestRec object"" )" 4
.el .IP "obj: \f(CW$r\fR ( \f(CWApache2::RequestRec object\fR )" 4
.IX Item "obj: $r ( Apache2::RequestRec object )"
The current request
.ie n .IP "arg1: $reset ( boolean )" 4
.el .IP "arg1: \f(CW$reset\fR ( boolean )" 4
.IX Item "arg1: $reset ( boolean )"
If a true value is passed all the previously allowed methods are
removed. Otherwise the list is left intact.
.ie n .IP "opt arg2: @methods ( array of strings )" 4
.el .IP "opt arg2: \f(CW@methods\fR ( array of strings )" 4
.IX Item "opt arg2: @methods ( array of strings )"
a list of \s-1HTTP\s0 methods to be allowed (e.g. \f(CW\*(C`GET\*(C'\fR and \f(CW\*(C`POST\*(C'\fR)
.IP "ret: no return value" 4
.IX Item "ret: no return value"
.PD 0
.IP "since: 2.0.00" 4
.IX Item "since: 2.0.00"
.PD
.PP
For example: here is how to allow only \f(CW\*(C`GET\*(C'\fR and \f(CW\*(C`POST\*(C'\fR methods,
regardless to what was the previous setting:
.PP
.Vb 1
\&  $r\->allow_methods(1, qw(GET POST));
.Ve
.ie n .SS """allow_options"""
.el .SS "\f(CWallow_options\fP"
.IX Subsection "allow_options"
Retrieve the value of \f(CW\*(C`Options\*(C'\fR for this request
.PP
.Vb 1
\&  $options = $r\->allow_options();
.Ve
.ie n .IP "obj: $r ( ""Apache2::RequestRec object"" )" 4
.el .IP "obj: \f(CW$r\fR ( \f(CWApache2::RequestRec object\fR )" 4
.IX Item "obj: $r ( Apache2::RequestRec object )"
The current request
.ie n .IP "ret: $options ( integer )" 4
.el .IP "ret: \f(CW$options\fR ( integer )" 4
.IX Item "ret: $options ( integer )"
the \f(CW\*(C`Options\*(C'\fR bitmask. Normally used with bitlogic operators against
\&\f(CW\*(C`Apache2::Const :options
constants\*(C'\fR.
.IP "since: 2.0.00" 4
.IX Item "since: 2.0.00"
.PP
For example if the configuration for the current request was:
.PP
.Vb 2
\&  Options None
\&  Options Indexes FollowSymLinks
.Ve
.PP
The following applies:
.PP
.Vb 4
\&  use Apache2::Const \-compile => qw(:options);
\&  $r\->allow_options & Apache2::Const::OPT_INDEXES;   # TRUE
\&  $r\->allow_options & Apache2::Const::OPT_SYM_LINKS; # TRUE
\&  $r\->allow_options & Apache2::Const::OPT_EXECCGI;   # FALSE
.Ve
.ie n .SS """allow_overrides"""
.el .SS "\f(CWallow_overrides\fP"
.IX Subsection "allow_overrides"
Retrieve the value of \f(CW\*(C`AllowOverride\*(C'\fR for this request
.PP
.Vb 1
\&  $allow_override = $r\->allow_overrides();
.Ve
.ie n .IP "obj: $r ( ""Apache2::RequestRec object"" )" 4
.el .IP "obj: \f(CW$r\fR ( \f(CWApache2::RequestRec object\fR )" 4
.IX Item "obj: $r ( Apache2::RequestRec object )"
The current request
.ie n .IP "ret: $allow_override ( integer )" 4
.el .IP "ret: \f(CW$allow_override\fR ( integer )" 4
.IX Item "ret: $allow_override ( integer )"
the \f(CW\*(C`AllowOverride\*(C'\fR bitmask. Normally used with bitlogic operators
against \f(CW\*(C`Apache2::Const :override
constants\*(C'\fR.
.IP "since: 2.0.00" 4
.IX Item "since: 2.0.00"
.PP
For example if the configuration for the current request was:
.PP
.Vb 1
\&  AllowOverride AuthConfig
.Ve
.PP
The following applies:
.PP
.Vb 3
\&  use Apache2::Const \-compile => qw(:override);
\&  $r\->allow_overrides & Apache2::Const::OR_AUTHCFG; # TRUE
\&  $r\->allow_overrides & Apache2::Const::OR_LIMIT; # FALSE
.Ve
.ie n .SS """allow_override_opts"""
.el .SS "\f(CWallow_override_opts\fP"
.IX Subsection "allow_override_opts"
Retrieve the bitmask of allowed \f(CW\*(C`Options\*(C'\fR set by \f(CW\*(C`AllowOverride Options=...\*(C'\fR
for this request
.PP
.Vb 1
\&  $override_opts = $r\->allow_override_opts();
.Ve
.PP
Enabling single options was introduced in Apache 2.2. For Apache 2.0 this
function returns
\&\f(CW\*(C`Apache2::Const::OPT_UNSET\*(C'\fR |
\&\f(CW\*(C`Apache2::Const::OPT_ALL\*(C'\fR |
\&\f(CW\*(C`Apache2::Const::OPT_INCNOEXEC\*(C'\fR |
\&\f(CW\*(C`Apache2::Const::OPT_SYM_OWNER\*(C'\fR |
\&\f(CW\*(C`Apache2::Const::OPT_MULTI\*(C'\fR,
which corresponds to the default value (if not set) for Apache 2.2.
.ie n .IP "obj: $r ( ""Apache2::RequestRec object"" )" 4
.el .IP "obj: \f(CW$r\fR ( \f(CWApache2::RequestRec object\fR )" 4
.IX Item "obj: $r ( Apache2::RequestRec object )"
The current request
.ie n .IP "ret: $override_opts ( integer )" 4
.el .IP "ret: \f(CW$override_opts\fR ( integer )" 4
.IX Item "ret: $override_opts ( integer )"
the override options bitmask. Normally used with bitlogic operators
against \f(CW\*(C`Apache2::Const :options
constants\*(C'\fR.
.IP "since: 2.0.3" 4
.IX Item "since: 2.0.3"
.PP
For example if the configuration for the current request was:
.PP
.Vb 1
\&  AllowOverride Options=Indexes,ExecCGI
.Ve
.PP
The following applies:
.PP
.Vb 3
\&  use Apache2::Const \-compile => qw(:options);
\&  $r\->allow_override_opts & Apache2::Const::OPT_EXECCGI; # TRUE
\&  $r\->allow_override_opts & Apache2::Const::OPT_SYM_LINKS; # FALSE
.Ve
.ie n .SS """auth_name"""
.el .SS "\f(CWauth_name\fP"
.IX Subsection "auth_name"
Get/set the current Authorization realm (the per directory
configuration directive \f(CW\*(C`AuthName\*(C'\fR):
.PP
.Vb 2
\&  $auth_name = $r\->auth_name();
\&  $auth_name = $r\->auth_name($new_auth_name);
.Ve
.ie n .IP "obj: $r ( ""Apache2::RequestRec object"" )" 4
.el .IP "obj: \f(CW$r\fR ( \f(CWApache2::RequestRec object\fR )" 4
.IX Item "obj: $r ( Apache2::RequestRec object )"
The current request
.ie n .IP "opt arg1: $new_auth_name ( string )" 4
.el .IP "opt arg1: \f(CW$new_auth_name\fR ( string )" 4
.IX Item "opt arg1: $new_auth_name ( string )"
If \f(CW$new_auth_name\fR is passed a new \f(CW\*(C`AuthName\*(C'\fR value is set
.ie n .IP "ret: ""$"" ( integer )" 4
.el .IP "ret: \f(CW$\fR ( integer )" 4
.IX Item "ret: $ ( integer )"
The current value of \f(CW\*(C`AuthName\*(C'\fR
.IP "since: 2.0.00" 4
.IX Item "since: 2.0.00"
.PP
The \f(CW\*(C`AuthName\*(C'\fR directive creates protection realm within the server
document space. To quote \s-1RFC 1945\s0 \*(L"These realms allow the protected
resources on a server to be partitioned into a set of protection
spaces, each with its own authentication scheme and/or authorization
database.\*(R" The client uses the root \s-1URL\s0 of the server to determine
which authentication credentials to send with each \s-1HTTP\s0 request. These
credentials are tagged with the name of the authentication realm that
created them.  Then during the authentication stage the server uses
the current authentication realm, from \f(CW\*(C`$r\->auth_name\*(C'\fR, to
determine which set of credentials to authenticate.
.ie n .SS """auth_type"""
.el .SS "\f(CWauth_type\fP"
.IX Subsection "auth_type"
Get/set the type of authorization required for this request (the per
directory configuration directive \f(CW\*(C`AuthType\*(C'\fR):
.PP
.Vb 2
\&  $auth_type = $r\->auth_type();
\&  $auth_type = $r\->auth_type($new_auth_type);
.Ve
.ie n .IP "obj: $r ( ""Apache2::RequestRec object"" )" 4
.el .IP "obj: \f(CW$r\fR ( \f(CWApache2::RequestRec object\fR )" 4
.IX Item "obj: $r ( Apache2::RequestRec object )"
The current request
.ie n .IP "opt arg1: $new_auth_type ( string )" 4
.el .IP "opt arg1: \f(CW$new_auth_type\fR ( string )" 4
.IX Item "opt arg1: $new_auth_type ( string )"
If \f(CW$new_auth_type\fR is passed a new \f(CW\*(C`AuthType\*(C'\fR value is set
.ie n .IP "ret: ""$"" ( integer )" 4
.el .IP "ret: \f(CW$\fR ( integer )" 4
.IX Item "ret: $ ( integer )"
The current value of \f(CW\*(C`AuthType\*(C'\fR
.IP "since: 2.0.00" 4
.IX Item "since: 2.0.00"
.PP
Normally \f(CW\*(C`AuthType\*(C'\fR would be set to \f(CW\*(C`Basic\*(C'\fR to use the basic
authentication scheme defined in \s-1RFC 1945,\s0 \fIHypertext Transfer
Protocol \*(-- \s-1HTTP/1.0\s0\fR. However, you could set to something else and
implement your own authentication scheme.
.ie n .SS """get_basic_auth_pw"""
.el .SS "\f(CWget_basic_auth_pw\fP"
.IX Subsection "get_basic_auth_pw"
Get the password from the request headers
.PP
.Vb 1
\&  my ($rc, $passwd) = $r\->get_basic_auth_pw();
.Ve
.ie n .IP "obj: $r ( ""Apache2::RequestRec object"" )" 4
.el .IP "obj: \f(CW$r\fR ( \f(CWApache2::RequestRec object\fR )" 4
.IX Item "obj: $r ( Apache2::RequestRec object )"
The current request
.ie n .IP "ret1: $rc ( ""Apache2::Const constant"" )" 4
.el .IP "ret1: \f(CW$rc\fR ( \f(CWApache2::Const constant\fR )" 4
.IX Item "ret1: $rc ( Apache2::Const constant )"
\&\f(CW\*(C`Apache2::Const::OK\*(C'\fR if the \f(CW$passwd\fR value is set (and assured a correct
value in
\&\f(CW\*(C`$r\->user\*(C'\fR);
otherwise it returns an error code, either
\&\f(CW\*(C`Apache2::Const::HTTP_INTERNAL_SERVER_ERROR\*(C'\fR if things are really confused,
\&\f(CW\*(C`Apache2::Const::HTTP_UNAUTHORIZED\*(C'\fR if no authentication at all seemed to be
in use, or \f(CW\*(C`Apache2::Const::DECLINED\*(C'\fR if there was authentication, but it
wasn't \f(CW\*(C`Basic\*(C'\fR (in which case, the caller should presumably decline
as well).
.ie n .IP "ret2: $ret (string)" 4
.el .IP "ret2: \f(CW$ret\fR (string)" 4
.IX Item "ret2: $ret (string)"
The password as set in the headers (decoded)
.IP "since: 2.0.00" 4
.IX Item "since: 2.0.00"
.PP
If \f(CW\*(C`AuthType\*(C'\fR is not set, this handler first sets it
to \f(CW\*(C`Basic\*(C'\fR.
.ie n .SS """get_remote_logname"""
.el .SS "\f(CWget_remote_logname\fP"
.IX Subsection "get_remote_logname"
Retrieve the login name of the remote user (\s-1RFC1413\s0)
.PP
.Vb 1
\&  $remote_logname = $r\->get_remote_logname();
.Ve
.ie n .IP "obj: $r ( ""Apache2::RequestRec object"" )" 4
.el .IP "obj: \f(CW$r\fR ( \f(CWApache2::RequestRec object\fR )" 4
.IX Item "obj: $r ( Apache2::RequestRec object )"
The current request
.ie n .IP "ret: $remote_logname ( string )" 4
.el .IP "ret: \f(CW$remote_logname\fR ( string )" 4
.IX Item "ret: $remote_logname ( string )"
The username of the user logged in to the client machine, or an empty
string if it could not be determined via \s-1RFC1413,\s0 which involves
querying the client's identd or auth daemon.
.IP "since: 2.0.00" 4
.IX Item "since: 2.0.00"
.PP
Do not confuse this method with
\&\f(CW\*(C`$r\->user\*(C'\fR, which
provides the username provided by the user during the server
authentication.
.ie n .SS """note_auth_failure"""
.el .SS "\f(CWnote_auth_failure\fP"
.IX Subsection "note_auth_failure"
Setup the output headers so that the client knows how to authenticate
itself the next time, if an authentication request failed.  This
function works for both basic and digest authentication
.PP
.Vb 1
\&  $r\->note_auth_failure();
.Ve
.ie n .IP "obj: $r ( ""Apache2::RequestRec object"" )" 4
.el .IP "obj: \f(CW$r\fR ( \f(CWApache2::RequestRec object\fR )" 4
.IX Item "obj: $r ( Apache2::RequestRec object )"
The current request
.IP "ret: no return value" 4
.IX Item "ret: no return value"
.PD 0
.IP "since: 2.0.00" 4
.IX Item "since: 2.0.00"
.PD
.PP
This method requires \f(CW\*(C`AuthType\*(C'\fR to be set to \f(CW\*(C`Basic\*(C'\fR or
\&\f(CW\*(C`Digest\*(C'\fR. Depending on the setting it'll call either
\&\f(CW\*(C`$r\->note_basic_auth_failure\*(C'\fR or
\&\f(CW\*(C`$r\->note_digest_auth_failure\*(C'\fR.
.ie n .SS """note_basic_auth_failure"""
.el .SS "\f(CWnote_basic_auth_failure\fP"
.IX Subsection "note_basic_auth_failure"
Setup the output headers so that the client knows how to authenticate
itself the next time, if an authentication request failed.  This
function works only for basic authentication
.PP
.Vb 1
\&  $r\->note_basic_auth_failure();
.Ve
.ie n .IP "obj: $r ( ""Apache2::RequestRec object"" )" 4
.el .IP "obj: \f(CW$r\fR ( \f(CWApache2::RequestRec object\fR )" 4
.IX Item "obj: $r ( Apache2::RequestRec object )"
The current request
.IP "ret: no return value" 4
.IX Item "ret: no return value"
.PD 0
.IP "since: 2.0.00" 4
.IX Item "since: 2.0.00"
.PD
.ie n .SS """note_digest_auth_failure"""
.el .SS "\f(CWnote_digest_auth_failure\fP"
.IX Subsection "note_digest_auth_failure"
Setup the output headers so that the client knows how to authenticate
itself the next time, if an authentication request failed.  This
function works only for digest authentication.
.PP
.Vb 1
\&  $r\->note_digest_auth_failure();
.Ve
.ie n .IP "obj: $r ( ""Apache2::RequestRec object"" )" 4
.el .IP "obj: \f(CW$r\fR ( \f(CWApache2::RequestRec object\fR )" 4
.IX Item "obj: $r ( Apache2::RequestRec object )"
The current request
.IP "ret: no return value" 4
.IX Item "ret: no return value"
.PD 0
.IP "since: 2.0.00" 4
.IX Item "since: 2.0.00"
.PD
.ie n .SS """requires"""
.el .SS "\f(CWrequires\fP"
.IX Subsection "requires"
Retrieve information about all of the requires directives for this request
.PP
.Vb 1
\&  $requires = $r\->requires
.Ve
.ie n .IP "obj: $r ( ""Apache2::RequestRec object"" )" 4
.el .IP "obj: \f(CW$r\fR ( \f(CWApache2::RequestRec object\fR )" 4
.IX Item "obj: $r ( Apache2::RequestRec object )"
The current request
.ie n .IP "ret: $requires ( \s-1ARRAY\s0 ref )" 4
.el .IP "ret: \f(CW$requires\fR ( \s-1ARRAY\s0 ref )" 4
.IX Item "ret: $requires ( ARRAY ref )"
Returns an array reference of hash references, containing information
related to the \f(CW\*(C`require\*(C'\fR directive.
.IP "since: 2.0.00" 4
.IX Item "since: 2.0.00"
.PP
This is normally used for access control.
.PP
For example if the configuration had the following require directives:
.PP
.Vb 2
\&    Require user  goo bar
\&    Require group bar tar
.Ve
.PP
this method will return the following datastructure:
.PP
.Vb 10
\&  [
\&    {
\&      \*(Aqmethod_mask\*(Aq => \-1,
\&      \*(Aqrequirement\*(Aq => \*(Aquser goo bar\*(Aq
\&    },
\&    {
\&      \*(Aqmethod_mask\*(Aq => \-1,
\&      \*(Aqrequirement\*(Aq => \*(Aqgroup bar tar\*(Aq
\&    }
\&  ];
.Ve
.PP
The \fIrequirement\fR field is what was passed to the \f(CW\*(C`Require\*(C'\fR
directive.  The \fImethod_mask\fR field is a bitmask which can be
modified by the \f(CW\*(C`Limit\*(C'\fR directive, but normally it can be safely
ignored as it's mostly used internally. For example if the
configuration was:
.PP
.Vb 5
\&    Require user goo bar
\&    Require group bar tar
\&    <Limit POST>
\&       Require valid\-user
\&    </Limit>
.Ve
.PP
and the request method was \f(CW\*(C`POST\*(C'\fR, \f(CW\*(C`$r\->requires\*(C'\fR will return:
.PP
.Vb 10
\&  [
\&    {
\&      \*(Aqmethod_mask\*(Aq => \-1,
\&      \*(Aqrequirement\*(Aq => \*(Aquser goo bar\*(Aq
\&    },
\&    {
\&      \*(Aqmethod_mask\*(Aq => \-1,
\&      \*(Aqrequirement\*(Aq => \*(Aqgroup bar tar\*(Aq
\&    }
\&    {
\&      \*(Aqmethod_mask\*(Aq => 4,
\&      \*(Aqrequirement\*(Aq => \*(Aqvalid\-user\*(Aq
\&    }
\&  ];
.Ve
.PP
But if the request method was \f(CW\*(C`GET\*(C'\fR, it will return only:
.PP
.Vb 10
\&  [
\&    {
\&      \*(Aqmethod_mask\*(Aq => \-1,
\&      \*(Aqrequirement\*(Aq => \*(Aquser goo bar\*(Aq
\&    },
\&    {
\&      \*(Aqmethod_mask\*(Aq => \-1,
\&      \*(Aqrequirement\*(Aq => \*(Aqgroup bar tar\*(Aq
\&    }
\&  ];
.Ve
.PP
As you can see Apache gives you the requirements relevant for the
current request, so the \fImethod_mask\fR is irrelevant.
.PP
It is also a good time to remind that in the general case, access
control directives should not be placed within a <Limit>
section.  Refer to the Apache documentation for more information.
.PP
Using the same configuration and assuming that the request was of type
\&\s-1POST,\s0 the following code inside an Auth handler:
.PP
.Vb 3
\&  my %require =
\&      map { my ($k, $v) = split /\es+/, $_\->{requirement}, 2; ($k, $v||\*(Aq\*(Aq) }
\&      @{ $r\->requires };
.Ve
.PP
will populate \f(CW%require\fR with the following pairs:
.PP
.Vb 3
\&  \*(Aqgroup\*(Aq => \*(Aqbar tar\*(Aq,
\&  \*(Aquser\*(Aq => \*(Aqgoo bar\*(Aq,
\&  \*(Aqvalid\-user\*(Aq => \*(Aq\*(Aq,
.Ve
.ie n .SS """satisfies"""
.el .SS "\f(CWsatisfies\fP"
.IX Subsection "satisfies"
How the requires lines must be met. What's the applicable value of the
\&\f(CW\*(C`Satisfy\*(C'\fR directive:
.PP
.Vb 1
\&  $satisfy = $r\->satisfies();
.Ve
.ie n .IP "obj: $r ( ""Apache2::RequestRec object"" )" 4
.el .IP "obj: \f(CW$r\fR ( \f(CWApache2::RequestRec object\fR )" 4
.IX Item "obj: $r ( Apache2::RequestRec object )"
The current request
.ie n .IP "ret: $satisfy ( integer )" 4
.el .IP "ret: \f(CW$satisfy\fR ( integer )" 4
.IX Item "ret: $satisfy ( integer )"
How the requirements must be met.  One of the \f(CW\*(C`Apache2::Const
:satisfy constants\*(C'\fR:
.Sp
\&\f(CW\*(C`Apache2::Const::SATISFY_ANY\*(C'\fR,
\&\f(CW\*(C`Apache2::Const::SATISFY_ALL\*(C'\fR
and
\&\f(CW\*(C`Apache2::Const::SATISFY_NOSPEC\*(C'\fR.
.IP "since: 2.0.00" 4
.IX Item "since: 2.0.00"
.PP
See the documentation for the \f(CW\*(C`Satisfy\*(C'\fR directive in the Apache
documentation.
.ie n .SS """some_auth_required"""
.el .SS "\f(CWsome_auth_required\fP"
.IX Subsection "some_auth_required"
Can be used within any handler to determine if any authentication is
required for the current request:
.PP
.Vb 1
\&  $need_auth = $r\->some_auth_required();
.Ve
.ie n .IP "obj: $r ( ""Apache2::RequestRec object"" )" 4
.el .IP "obj: \f(CW$r\fR ( \f(CWApache2::RequestRec object\fR )" 4
.IX Item "obj: $r ( Apache2::RequestRec object )"
The current request
.ie n .IP "ret: $need_auth ( boolean )" 4
.el .IP "ret: \f(CW$need_auth\fR ( boolean )" 4
.IX Item "ret: $need_auth ( boolean )"
\&\s-1TRUE\s0 if authentication is required, \s-1FALSE\s0 otherwise
.IP "since: 2.0.00" 4
.IX Item "since: 2.0.00"
.SH "See Also"
.IX Header "See Also"
mod_perl 2.0 documentation.
.SH "Copyright"
.IX Header "Copyright"
mod_perl 2.0 and its core modules are copyrighted under
The Apache Software License, Version 2.0.
.SH "Authors"
.IX Header "Authors"
The mod_perl development team and numerous
contributors.
