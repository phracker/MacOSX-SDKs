.\" Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Import::Into 3"
.TH Import::Into 3 "2015-08-28" "perl v5.30.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Import::Into \- Import packages into other packages
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  package My::MultiExporter;
\&
\&  use Import::Into;
\&
\&  # simple
\&  sub import {
\&    Thing1\->import::into(scalar caller);
\&  }
\&
\&  # multiple
\&  sub import {
\&    my $target = caller;
\&    Thing1\->import::into($target);
\&    Thing2\->import::into($target, qw(import arguments));
\&  }
\&
\&  # by level
\&  sub import {
\&    Thing1\->import::into(1);
\&  }
\&
\&  # with exporter
\&  use base qw(Exporter);
\&  sub import {
\&    shift\->export_to_level(1);
\&    Thing1\->import::into(1);
\&  }
\&
\&  # no My::MultiExporter == no Thing1
\&  sub unimport {
\&    Thing1\->unimport::out_of(scalar caller);
\&  }
.Ve
.PP
People wanting to re-export your module should also be using Import::Into.
Any exporter or pragma will work seamlessly.
.PP
Note: You do \fBnot\fR need to make any changes to Thing1 to be able to call
\&\f(CW\*(C`import::into\*(C'\fR on it. This is a global method, and is callable on any
package (and in fact on any object as well, although it's rarer that you'd
want to do that).
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Writing exporters is a pain. Some use Exporter, some use Sub::Exporter,
some use Moose::Exporter, some use Exporter::Declare ... and some things
are pragmas.
.PP
Exporting on someone else's behalf is harder.  The exporters don't provide a
consistent \s-1API\s0 for this, and pragmas need to have their import method called
directly, since they effect the current unit of compilation.
.PP
\&\f(CW\*(C`Import::Into\*(C'\fR provides global methods to make this painless.
.SH "METHODS"
.IX Header "METHODS"
.ie n .SS "$package\->import::into( $target, @arguments );"
.el .SS "\f(CW$package\fP\->import::into( \f(CW$target\fP, \f(CW@arguments\fP );"
.IX Subsection "$package->import::into( $target, @arguments );"
A global method, callable on any package.  Loads and imports the given package
into \f(CW$target\fR.  \f(CW@arguments\fR are passed along to the package's import method.
.PP
\&\f(CW$target\fR can be an package name to export to, an integer for the
caller level to export to, or a hashref with the following options:
.IP "package" 4
.IX Item "package"
The target package to export to.
.IP "filename" 4
.IX Item "filename"
The apparent filename to export to.  Some exporting modules, such as
autodie or strictures, care about the filename they are being imported
to.
.IP "line" 4
.IX Item "line"
The apparent line number to export to.  To be combined with the \f(CW\*(C`filename\*(C'\fR
option.
.IP "level" 4
.IX Item "level"
The caller level to export to.  This will automatically populate the
\&\f(CW\*(C`package\*(C'\fR, \f(CW\*(C`filename\*(C'\fR, and \f(CW\*(C`line\*(C'\fR options, making it the easiest most
constent option.
.IP "version" 4
.IX Item "version"
A version number to check for the module.  The equivalent of specifying the
version number on a \f(CW\*(C`use\*(C'\fR line.
.ie n .SS "$package\->unimport::out_of( $target, @arguments );"
.el .SS "\f(CW$package\fP\->unimport::out_of( \f(CW$target\fP, \f(CW@arguments\fP );"
.IX Subsection "$package->unimport::out_of( $target, @arguments );"
Equivalent to \f(CW\*(C`import::into\*(C'\fR, but dispatches to \f(CW$package\fR's \f(CW\*(C`unimport\*(C'\fR
method instead of \f(CW\*(C`import\*(C'\fR.
.SH "WHY USE THIS MODULE"
.IX Header "WHY USE THIS MODULE"
The APIs for exporting modules aren't consistent.  Exporter subclasses
provide export_to_level, but if they overrode their import method all bets
are off.  Sub::Exporter provides an into parameter but figuring out
something used it isn't trivial. Pragmas need to have their \f(CW\*(C`import\*(C'\fR method
called directly since they affect the current unit of compilation.
.PP
It's ... annoying.
.PP
However, there is an approach that actually works for all of these types.
.PP
.Vb 1
\&  eval "package $target; use $thing;"
.Ve
.PP
will work for anything checking caller, which is everything except pragmas.
But it doesn't work for pragmas \- pragmas need:
.PP
.Vb 1
\&  $thing\->import;
.Ve
.PP
because they're designed to affect the code currently being compiled \- so
within an eval, that's the scope of the eval itself, not the module that
just \f(CW\*(C`use\*(C'\fRd you \- so
.PP
.Vb 3
\&  sub import {
\&    eval "use strict;"
\&  }
.Ve
.PP
doesn't do what you wanted, but
.PP
.Vb 3
\&  sub import {
\&    strict\->import;
\&  }
.Ve
.PP
will apply strict to the calling file correctly.
.PP
Of course, now you have two new problems \- first, that you still need to
know if something's a pragma, and second that you can't use either of
these approaches alone on something like Moose or Moo that's both
an exporter and a pragma.
.PP
So, a solution for that is:
.PP
.Vb 3
\&  use Module::Runtime;
\&  my $sub = eval "package $target; sub { use_module(shift)\->import(\e@_) }";
\&  $sub\->($thing, @import_args);
.Ve
.PP
which means that import is called from the right place for pragmas to take
effect, and from the right package for caller checking to work \- and so
behaves correctly for all types of exporter, for pragmas, and for hybrids.
.PP
Additionally, some import routines check the filename they are being imported
to.  This can be dealt with by generating a #line directive in the eval, which will change what \f(CW\*(C`caller\*(C'\fR reports for
the filename when called in the importer. The filename and line number to use
in the directive then need to be fetched using \f(CW\*(C`caller\*(C'\fR:
.PP
.Vb 7
\&  my ($target, $file, $line) = caller(1);
\&  my $sub = eval qq{
\&    package $target;
\&  #line $line "$file"
\&    sub { use_module(shift)\->import(\e@_) }
\&  };
\&  $sub\->($thing, @import_args);
.Ve
.PP
And you need to switch between these implementations depending on if you are
targeting a specific package, or something in your call stack.
.PP
Remembering all this, however, is excessively irritating. So I wrote a module
so I didn't have to anymore. Loading Import::Into creates a global method
\&\f(CW\*(C`import::into\*(C'\fR which you can call on any package to import it into another
package. So now you can simply write:
.PP
.Vb 1
\&  use Import::Into;
\&
\&  $thing\->import::into($target, @import_args);
.Ve
.PP
This works because of how perl resolves method calls \- a call to a simple
method name is resolved against the package of the class or object, so
.PP
.Vb 1
\&  $thing\->method_name(@args);
.Ve
.PP
is roughly equivalent to:
.PP
.Vb 2
\&  my $code_ref = $thing\->can(\*(Aqmethod_name\*(Aq);
\&  $code_ref\->($thing, @args);
.Ve
.PP
while if a \f(CW\*(C`::\*(C'\fR is found, the lookup is made relative to the package name
(i.e. everything before the last \f(CW\*(C`::\*(C'\fR) so
.PP
.Vb 1
\&  $thing\->Package::Name::method_name(@args);
.Ve
.PP
is roughly equivalent to:
.PP
.Vb 2
\&  my $code_ref = Package::Name\->can(\*(Aqmethod_name\*(Aq);
\&  $code_ref\->($thing, @args);
.Ve
.PP
So since Import::Into defines a method \f(CW\*(C`into\*(C'\fR in package \f(CW\*(C`import\*(C'\fR
the syntax reliably calls that.
.PP
For more craziness of this order, have a look at the article I wrote at
<http://shadow.cat/blog/matt\-s\-trout/madness\-with\-methods> which covers
coderef abuse and the \f(CW\*(C`${\e...}\*(C'\fR syntax.
.PP
And that's it.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
I gave a lightning talk on this module (and curry and Safe::Isa) at
\&\s-1YAPC::NA 2013\s0 <https://www.youtube.com/watch?v=wFXWV2yY7gE&t=46m05s>.
.SH "ACKNOWLEDGEMENTS"
.IX Header "ACKNOWLEDGEMENTS"
Thanks to Getty for asking "how can I get \f(CW\*(C`use strict; use warnings;\*(C'\fR
turned on for all consumers of my code?\*(L" and then \*(R"why is this not a
module?!".
.SH "AUTHOR"
.IX Header "AUTHOR"
mst \- Matt S. Trout (cpan:MSTROUT) <mst@shadowcat.co.uk>
.SH "CONTRIBUTORS"
.IX Header "CONTRIBUTORS"
haarg \- Graham Knop (cpan:HAARG) <haarg@haarg.org>
.PP
Mithaldu \- Christian Walde (cpan:MITHALDU) <walde.christian@gmail.com>
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (c) 2012 the Import::Into \*(L"\s-1AUTHOR\*(R"\s0 and \*(L"\s-1CONTRIBUTORS\*(R"\s0
as listed above.
.SH "LICENSE"
.IX Header "LICENSE"
This library is free software and may be distributed under the same terms
as perl itself.
