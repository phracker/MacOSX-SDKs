.\" Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Math::BigInt::Lib 3pm"
.TH Math::BigInt::Lib 3pm "2019-10-21" "perl v5.30.3" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Math::BigInt::Lib \- virtual parent class for Math::BigInt libraries
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    # In the backend library for Math::BigInt et al.
\&
\&    package Math::BigInt::MyBackend;
\&
\&    use Math::BigInt::lib;
\&    our @ISA = qw< Math::BigInt::lib >;
\&
\&    sub _new { ... }
\&    sub _str { ... }
\&    sub _add { ... }
\&    str _sub { ... }
\&    ...
\&
\&    # In your main program.
\&
\&    use Math::BigInt lib => \*(AqMyBackend\*(Aq;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module provides support for big integer calculations. It is not intended
to be used directly, but rather as a parent class for backend libraries used by
Math::BigInt, Math::BigFloat, Math::BigRat, and related modules.
.PP
Other backend libraries include Math::BigInt::Calc, Math::BigInt::FastCalc,
Math::BigInt::GMP, and Math::BigInt::Pari.
.PP
In order to allow for multiple big integer libraries, Math::BigInt was
rewritten to use a plug-in library for core math routines. Any module which
conforms to the \s-1API\s0 can be used by Math::BigInt by using this in your program:
.PP
.Vb 1
\&        use Math::BigInt lib => \*(Aqlibname\*(Aq;
.Ve
.PP
\&'libname' is either the long name, like 'Math::BigInt::Pari', or only the short
version, like 'Pari'.
.SS "General Notes"
.IX Subsection "General Notes"
A library only needs to deal with unsigned big integers. Testing of input
parameter validity is done by the caller, so there is no need to worry about
underflow (e.g., in \f(CW\*(C`_sub()\*(C'\fR and \f(CW\*(C`_dec()\*(C'\fR) or about division by zero (e.g.,
in \f(CW\*(C`_div()\*(C'\fR and \f(CW\*(C`_mod()\*(C'\fR)) or similar cases.
.PP
Some libraries use methods that don't modify their argument, and some libraries
don't even use objects, but rather unblessed references. Because of this,
liberary methods are always called as class methods, not instance methods:
.PP
.Vb 3
\&    $x = Class \-> method($x, $y);     # like this
\&    $x = $x \-> method($y);            # not like this ...
\&    $x \-> method($y);                 # ... or like this
.Ve
.PP
And with boolean methods
.PP
.Vb 2
\&    $bool = Class \-> method($x, $y);  # like this
\&    $bool = $x \-> method($y);         # not like this
.Ve
.PP
Return values are always objects, strings, Perl scalars, or true/false for
comparison routines.
.PP
\fI\s-1API\s0 version\fR
.IX Subsection "API version"
.IP "\s-1CLASS\-\s0>\fBapi_version()\fR" 4
.IX Item "CLASS->api_version()"
Return \s-1API\s0 version as a Perl scalar, 1 for Math::BigInt v1.70, 2 for
Math::BigInt v1.83.
.Sp
This method is no longer used. Methods that are not implemented by a subclass
will be inherited from this class.
.PP
\fIConstructors\fR
.IX Subsection "Constructors"
.PP
The following methods are mandatory: \fB_new()\fR, \fB_str()\fR, \fB_add()\fR, and \fB_sub()\fR.
However, computations will be very slow without \fB_mul()\fR and \fB_div()\fR.
.IP "\s-1CLASS\-\s0>_new(\s-1STR\s0)" 4
.IX Item "CLASS->_new(STR)"
Convert a string representing an unsigned decimal number to an object
representing the same number. The input is normalized, i.e., it matches
\&\f(CW\*(C`^(0|[1\-9]\ed*)$\*(C'\fR.
.IP "\s-1CLASS\-\s0>\fB_zero()\fR" 4
.IX Item "CLASS->_zero()"
Return an object representing the number zero.
.IP "\s-1CLASS\-\s0>\fB_one()\fR" 4
.IX Item "CLASS->_one()"
Return an object representing the number one.
.IP "\s-1CLASS\-\s0>\fB_two()\fR" 4
.IX Item "CLASS->_two()"
Return an object representing the number two.
.IP "\s-1CLASS\-\s0>\fB_ten()\fR" 4
.IX Item "CLASS->_ten()"
Return an object representing the number ten.
.IP "\s-1CLASS\-\s0>_from_bin(\s-1STR\s0)" 4
.IX Item "CLASS->_from_bin(STR)"
Return an object given a string representing a binary number. The input has a
\&'0b' prefix and matches the regular expression \f(CW\*(C`^0[bB](0|1[01]*)$\*(C'\fR.
.IP "\s-1CLASS\-\s0>_from_oct(\s-1STR\s0)" 4
.IX Item "CLASS->_from_oct(STR)"
Return an object given a string representing an octal number. The input has a
\&'0' prefix and matches the regular expression \f(CW\*(C`^0[1\-7]*$\*(C'\fR.
.IP "\s-1CLASS\-\s0>_from_hex(\s-1STR\s0)" 4
.IX Item "CLASS->_from_hex(STR)"
Return an object given a string representing a hexadecimal number. The input
has a '0x' prefix and matches the regular expression
\&\f(CW\*(C`^0x(0|[1\-9a\-fA\-F][\eda\-fA\-F]*)$\*(C'\fR.
.IP "\s-1CLASS\-\s0>_from_bytes(\s-1STR\s0)" 4
.IX Item "CLASS->_from_bytes(STR)"
Returns an object given a byte string representing the number. The byte string
is in big endian byte order, so the two-byte input string \*(L"\ex01\ex00\*(R" should
give an output value representing the number 256.
.IP "\s-1CLASS\-\s0>_from_base(\s-1STR, BASE, COLLSEQ\s0)" 4
.IX Item "CLASS->_from_base(STR, BASE, COLLSEQ)"
Returns an object given a string \s-1STR,\s0 a base \s-1BASE,\s0 and a collation sequence
\&\s-1COLLSEQ.\s0 Each character in \s-1STR\s0 represents a numerical value identical to the
character's position in \s-1COLLSEQ.\s0 All characters in \s-1STR\s0 must be present in
\&\s-1COLLSEQ.\s0
.Sp
If \s-1BASE\s0 is less than or equal to 62, and a collation sequence is not specified,
a default collation sequence consisting of the 62 characters 0..9, A..Z, and
a..z is used. If the default collation sequence is used, and the \s-1BASE\s0 is less
than or equal to 36, the letter case in \s-1STR\s0 is ignored.
.Sp
For instance, with base 3 and collation sequence \*(L"\-/|\*(R", the character \*(L"\-\*(R"
represents 0, \*(L"/\*(R" represents 1, and \*(L"|\*(R" represents 2. So if \s-1STR\s0 is \*(L"/|\-\*(R", the
output is 1 * 3**2 + 2 * 3**1 + 0 * 3**0 = 15.
.Sp
The following examples show standard binary, octal, decimal, and hexadecimal
conversion. All examples return 250.
.Sp
.Vb 4
\&    $x = $class \-> _from_base("11111010", 2)
\&    $x = $class \-> _from_base("372", 8)
\&    $x = $class \-> _from_base("250", 10)
\&    $x = $class \-> _from_base("FA", 16)
.Ve
.Sp
Some more examples, all returning 250:
.Sp
.Vb 4
\&    $x = $class \-> _from_base("100021", 3, "012")
\&    $x = $class \-> _from_base("3322", 4, "0123")
\&    $x = $class \-> _from_base("2000", 5, "01234")
\&    $x = $class \-> _from_base("caaa", 5, "abcde")
.Ve
.PP
\fIMathematical functions\fR
.IX Subsection "Mathematical functions"
.IP "\s-1CLASS\-\s0>_add(\s-1OBJ1, OBJ2\s0)" 4
.IX Item "CLASS->_add(OBJ1, OBJ2)"
Returns the result of adding \s-1OBJ2\s0 to \s-1OBJ1.\s0
.IP "\s-1CLASS\-\s0>_mul(\s-1OBJ1, OBJ2\s0)" 4
.IX Item "CLASS->_mul(OBJ1, OBJ2)"
Returns the result of multiplying \s-1OBJ2\s0 and \s-1OBJ1.\s0
.IP "\s-1CLASS\-\s0>_div(\s-1OBJ1, OBJ2\s0)" 4
.IX Item "CLASS->_div(OBJ1, OBJ2)"
In scalar context, returns the quotient after dividing \s-1OBJ1\s0 by \s-1OBJ2\s0 and
truncating the result to an integer. In list context, return the quotient and
the remainder.
.IP "\s-1CLASS\-\s0>_sub(\s-1OBJ1, OBJ2, FLAG\s0)" 4
.IX Item "CLASS->_sub(OBJ1, OBJ2, FLAG)"
.PD 0
.IP "\s-1CLASS\-\s0>_sub(\s-1OBJ1, OBJ2\s0)" 4
.IX Item "CLASS->_sub(OBJ1, OBJ2)"
.PD
Returns the result of subtracting \s-1OBJ2\s0 by \s-1OBJ1.\s0 If \f(CW\*(C`flag\*(C'\fR is false or omitted,
\&\s-1OBJ1\s0 might be modified. If \f(CW\*(C`flag\*(C'\fR is true, \s-1OBJ2\s0 might be modified.
.IP "\s-1CLASS\-\s0>_dec(\s-1OBJ\s0)" 4
.IX Item "CLASS->_dec(OBJ)"
Returns the result after decrementing \s-1OBJ\s0 by one.
.IP "\s-1CLASS\-\s0>_inc(\s-1OBJ\s0)" 4
.IX Item "CLASS->_inc(OBJ)"
Returns the result after incrementing \s-1OBJ\s0 by one.
.IP "\s-1CLASS\-\s0>_mod(\s-1OBJ1, OBJ2\s0)" 4
.IX Item "CLASS->_mod(OBJ1, OBJ2)"
Returns \s-1OBJ1\s0 modulo \s-1OBJ2,\s0 i.e., the remainder after dividing \s-1OBJ1\s0 by \s-1OBJ2.\s0
.IP "\s-1CLASS\-\s0>_sqrt(\s-1OBJ\s0)" 4
.IX Item "CLASS->_sqrt(OBJ)"
Returns the square root of \s-1OBJ,\s0 truncated to an integer.
.IP "\s-1CLASS\-\s0>_root(\s-1OBJ, N\s0)" 4
.IX Item "CLASS->_root(OBJ, N)"
Returns the Nth root of \s-1OBJ,\s0 truncated to an integer.
.IP "\s-1CLASS\-\s0>_fac(\s-1OBJ\s0)" 4
.IX Item "CLASS->_fac(OBJ)"
Returns the factorial of \s-1OBJ,\s0 i.e., the product of all positive integers up to
and including \s-1OBJ.\s0
.IP "\s-1CLASS\-\s0>_dfac(\s-1OBJ\s0)" 4
.IX Item "CLASS->_dfac(OBJ)"
Returns the double factorial of \s-1OBJ.\s0 If \s-1OBJ\s0 is an even integer, returns the
product of all positive, even integers up to and including \s-1OBJ,\s0 i.e.,
2*4*6*...*OBJ. If \s-1OBJ\s0 is an odd integer, returns the product of all positive,
odd integers, i.e., 1*3*5*...*OBJ.
.IP "\s-1CLASS\-\s0>_pow(\s-1OBJ1, OBJ2\s0)" 4
.IX Item "CLASS->_pow(OBJ1, OBJ2)"
Returns \s-1OBJ1\s0 raised to the power of \s-1OBJ2.\s0 By convention, 0**0 = 1.
.IP "\s-1CLASS\-\s0>_modinv(\s-1OBJ1, OBJ2\s0)" 4
.IX Item "CLASS->_modinv(OBJ1, OBJ2)"
Returns the modular multiplicative inverse, i.e., return \s-1OBJ3\s0 so that
.Sp
.Vb 1
\&    (OBJ3 * OBJ1) % OBJ2 = 1 % OBJ2
.Ve
.Sp
The result is returned as two arguments. If the modular multiplicative inverse
does not exist, both arguments are undefined. Otherwise, the arguments are a
number (object) and its sign (\*(L"+\*(R" or \*(L"\-\*(R").
.Sp
The output value, with its sign, must either be a positive value in the range
1,2,...,OBJ2\-1 or the same value subtracted \s-1OBJ2.\s0 For instance, if the input
arguments are objects representing the numbers 7 and 5, the method must either
return an object representing the number 3 and a \*(L"+\*(R" sign, since (3*7) % 5 = 1
% 5, or an object representing the number 2 and a \*(L"\-\*(R" sign, since (\-2*7) % 5 = 1
% 5.
.IP "\s-1CLASS\-\s0>_modpow(\s-1OBJ1, OBJ2, OBJ3\s0)" 4
.IX Item "CLASS->_modpow(OBJ1, OBJ2, OBJ3)"
Returns the modular exponentiation, i.e., (\s-1OBJ1\s0 ** \s-1OBJ2\s0) % \s-1OBJ3.\s0
.IP "\s-1CLASS\-\s0>_rsft(\s-1OBJ, N, B\s0)" 4
.IX Item "CLASS->_rsft(OBJ, N, B)"
Returns the result after shifting \s-1OBJ N\s0 digits to thee right in base B. This is
equivalent to performing integer division by B**N and discarding the remainder,
except that it might be much faster.
.Sp
For instance, if the object \f(CW$obj\fR represents the hexadecimal number 0xabcde,
then \f(CW\*(C`_rsft($obj, 2, 16)\*(C'\fR returns an object representing the number 0xabc. The
\&\*(L"remainer\*(R", 0xde, is discarded and not returned.
.IP "\s-1CLASS\-\s0>_lsft(\s-1OBJ, N, B\s0)" 4
.IX Item "CLASS->_lsft(OBJ, N, B)"
Returns the result after shifting \s-1OBJ N\s0 digits to the left in base B. This is
equivalent to multiplying by B**N, except that it might be much faster.
.IP "\s-1CLASS\-\s0>_log_int(\s-1OBJ, B\s0)" 4
.IX Item "CLASS->_log_int(OBJ, B)"
Returns the logarithm of \s-1OBJ\s0 to base \s-1BASE\s0 truncted to an integer. This method
has two output arguments, the \s-1OBJECT\s0 and a \s-1STATUS.\s0 The \s-1STATUS\s0 is Perl scalar;
it is 1 if \s-1OBJ\s0 is the exact result, 0 if the result was truncted to give \s-1OBJ,\s0
and undef if it is unknown whether \s-1OBJ\s0 is the exact result.
.IP "\s-1CLASS\-\s0>_gcd(\s-1OBJ1, OBJ2\s0)" 4
.IX Item "CLASS->_gcd(OBJ1, OBJ2)"
Returns the greatest common divisor of \s-1OBJ1\s0 and \s-1OBJ2.\s0
.IP "\s-1CLASS\-\s0>_lcm(\s-1OBJ1, OBJ2\s0)" 4
.IX Item "CLASS->_lcm(OBJ1, OBJ2)"
Return the least common multiple of \s-1OBJ1\s0 and \s-1OBJ2.\s0
.IP "\s-1CLASS\-\s0>_fib(\s-1OBJ\s0)" 4
.IX Item "CLASS->_fib(OBJ)"
In scalar context, returns the nth Fibonacci number: \fB_fib\fR\|(0) returns 0, \fB_fib\fR\|(1)
returns 1, \fB_fib\fR\|(2) returns 1, \fB_fib\fR\|(3) returns 2 etc. In list context, returns
the Fibonacci numbers from F(0) to F(n): 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, ...
.IP "\s-1CLASS\-\s0>_lucas(\s-1OBJ\s0)" 4
.IX Item "CLASS->_lucas(OBJ)"
In scalar context, returns the nth Lucas number: \fB_lucas\fR\|(0) returns 2, \fB_lucas\fR\|(1)
returns 1, \fB_lucas\fR\|(2) returns 3, etc. In list context, returns the Lucas numbers
from L(0) to L(n): 2, 1, 3, 4, 7, 11, 18, 29,47, 76, ...
.PP
\fIBitwise operators\fR
.IX Subsection "Bitwise operators"
.IP "\s-1CLASS\-\s0>_and(\s-1OBJ1, OBJ2\s0)" 4
.IX Item "CLASS->_and(OBJ1, OBJ2)"
Returns bitwise and.
.IP "\s-1CLASS\-\s0>_or(\s-1OBJ1, OBJ2\s0)" 4
.IX Item "CLASS->_or(OBJ1, OBJ2)"
Returns bitwise or.
.IP "\s-1CLASS\-\s0>_xor(\s-1OBJ1, OBJ2\s0)" 4
.IX Item "CLASS->_xor(OBJ1, OBJ2)"
Returns bitwise exclusive or.
.IP "\s-1CLASS\-\s0>_sand(\s-1OBJ1, OBJ2, SIGN1, SIGN2\s0)" 4
.IX Item "CLASS->_sand(OBJ1, OBJ2, SIGN1, SIGN2)"
Returns bitwise signed and.
.IP "\s-1CLASS\-\s0>_sor(\s-1OBJ1, OBJ2, SIGN1, SIGN2\s0)" 4
.IX Item "CLASS->_sor(OBJ1, OBJ2, SIGN1, SIGN2)"
Returns bitwise signed or.
.IP "\s-1CLASS\-\s0>_sxor(\s-1OBJ1, OBJ2, SIGN1, SIGN2\s0)" 4
.IX Item "CLASS->_sxor(OBJ1, OBJ2, SIGN1, SIGN2)"
Returns bitwise signed exclusive or.
.PP
\fIBoolean operators\fR
.IX Subsection "Boolean operators"
.IP "\s-1CLASS\-\s0>_is_zero(\s-1OBJ\s0)" 4
.IX Item "CLASS->_is_zero(OBJ)"
Returns a true value if \s-1OBJ\s0 is zero, and false value otherwise.
.IP "\s-1CLASS\-\s0>_is_one(\s-1OBJ\s0)" 4
.IX Item "CLASS->_is_one(OBJ)"
Returns a true value if \s-1OBJ\s0 is one, and false value otherwise.
.IP "\s-1CLASS\-\s0>_is_two(\s-1OBJ\s0)" 4
.IX Item "CLASS->_is_two(OBJ)"
Returns a true value if \s-1OBJ\s0 is two, and false value otherwise.
.IP "\s-1CLASS\-\s0>_is_ten(\s-1OBJ\s0)" 4
.IX Item "CLASS->_is_ten(OBJ)"
Returns a true value if \s-1OBJ\s0 is ten, and false value otherwise.
.IP "\s-1CLASS\-\s0>_is_even(\s-1OBJ\s0)" 4
.IX Item "CLASS->_is_even(OBJ)"
Return a true value if \s-1OBJ\s0 is an even integer, and a false value otherwise.
.IP "\s-1CLASS\-\s0>_is_odd(\s-1OBJ\s0)" 4
.IX Item "CLASS->_is_odd(OBJ)"
Return a true value if \s-1OBJ\s0 is an even integer, and a false value otherwise.
.IP "\s-1CLASS\-\s0>_acmp(\s-1OBJ1, OBJ2\s0)" 4
.IX Item "CLASS->_acmp(OBJ1, OBJ2)"
Compare \s-1OBJ1\s0 and \s-1OBJ2\s0 and return \-1, 0, or 1, if \s-1OBJ1\s0 is numerically less than,
equal to, or larger than \s-1OBJ2,\s0 respectively.
.PP
\fIString conversion\fR
.IX Subsection "String conversion"
.IP "\s-1CLASS\-\s0>_str(\s-1OBJ\s0)" 4
.IX Item "CLASS->_str(OBJ)"
Returns a string representing \s-1OBJ\s0 in decimal notation. The returned string
should have no leading zeros, i.e., it should match \f(CW\*(C`^(0|[1\-9]\ed*)$\*(C'\fR.
.IP "\s-1CLASS\-\s0>_to_bin(\s-1OBJ\s0)" 4
.IX Item "CLASS->_to_bin(OBJ)"
Returns the binary string representation of \s-1OBJ.\s0
.IP "\s-1CLASS\-\s0>_to_oct(\s-1OBJ\s0)" 4
.IX Item "CLASS->_to_oct(OBJ)"
Returns the octal string representation of the number.
.IP "\s-1CLASS\-\s0>_to_hex(\s-1OBJ\s0)" 4
.IX Item "CLASS->_to_hex(OBJ)"
Returns the hexadecimal string representation of the number.
.IP "\s-1CLASS\-\s0>_to_bytes(\s-1OBJ\s0)" 4
.IX Item "CLASS->_to_bytes(OBJ)"
Returns a byte string representation of \s-1OBJ.\s0 The byte string is in big endian
byte order, so if \s-1OBJ\s0 represents the number 256, the output should be the
two-byte string \*(L"\ex01\ex00\*(R".
.IP "\s-1CLASS\-\s0>_to_base(\s-1OBJ, BASE, COLLSEQ\s0)" 4
.IX Item "CLASS->_to_base(OBJ, BASE, COLLSEQ)"
Returns a string representation of \s-1OBJ\s0 in base \s-1BASE\s0 with collation sequence
\&\s-1COLLSEQ.\s0
.Sp
.Vb 2
\&    $val = $class \-> _new("210");
\&    $str = $class \-> _to_base($val, 10, "xyz")  # $str is "zyx"
\&
\&    $val = $class \-> _new("32");
\&    $str = $class \-> _to_base($val, 2, "\-|")  # $str is "|\-\-\-\-\-"
.Ve
.Sp
See \fB_from_base()\fR for more information.
.IP "\s-1CLASS\-\s0>_as_bin(\s-1OBJ\s0)" 4
.IX Item "CLASS->_as_bin(OBJ)"
Like \f(CW\*(C`_to_bin()\*(C'\fR but with a '0b' prefix.
.IP "\s-1CLASS\-\s0>_as_oct(\s-1OBJ\s0)" 4
.IX Item "CLASS->_as_oct(OBJ)"
Like \f(CW\*(C`_to_oct()\*(C'\fR but with a '0' prefix.
.IP "\s-1CLASS\-\s0>_as_hex(\s-1OBJ\s0)" 4
.IX Item "CLASS->_as_hex(OBJ)"
Like \f(CW\*(C`_to_hex()\*(C'\fR but with a '0x' prefix.
.IP "\s-1CLASS\-\s0>_as_bytes(\s-1OBJ\s0)" 4
.IX Item "CLASS->_as_bytes(OBJ)"
This is an alias to \f(CW\*(C`_to_bytes()\*(C'\fR.
.PP
\fINumeric conversion\fR
.IX Subsection "Numeric conversion"
.IP "\s-1CLASS\-\s0>_num(\s-1OBJ\s0)" 4
.IX Item "CLASS->_num(OBJ)"
Returns a Perl scalar number representing the number \s-1OBJ\s0 as close as
possible. Since Perl scalars have limited precision, the returned value might
not be exactly the same as \s-1OBJ.\s0
.PP
\fIMiscellaneous\fR
.IX Subsection "Miscellaneous"
.IP "\s-1CLASS\-\s0>_copy(\s-1OBJ\s0)" 4
.IX Item "CLASS->_copy(OBJ)"
Returns a true copy \s-1OBJ.\s0
.IP "\s-1CLASS\-\s0>_len(\s-1OBJ\s0)" 4
.IX Item "CLASS->_len(OBJ)"
Returns the number of the decimal digits in \s-1OBJ.\s0 The output is a Perl scalar.
.IP "\s-1CLASS\-\s0>_zeros(\s-1OBJ\s0)" 4
.IX Item "CLASS->_zeros(OBJ)"
Returns the number of trailing decimal zeros. The output is a Perl scalar. The
number zero has no trailing decimal zeros.
.IP "\s-1CLASS\-\s0>_digit(\s-1OBJ, N\s0)" 4
.IX Item "CLASS->_digit(OBJ, N)"
Returns the Nth digit in \s-1OBJ\s0 as a Perl scalar. N is a Perl scalar, where zero
refers to the rightmost (least significant) digit, and negative values count
from the left (most significant digit). If \f(CW$obj\fR represents the number 123, then
.Sp
.Vb 4
\&    CLASS\->_digit($obj,  0)     # returns 3
\&    CLASS\->_digit($obj,  1)     # returns 2
\&    CLASS\->_digit($obj,  2)     # returns 1
\&    CLASS\->_digit($obj, \-1)     # returns 1
.Ve
.IP "\s-1CLASS\-\s0>_check(\s-1OBJ\s0)" 4
.IX Item "CLASS->_check(OBJ)"
Returns true if the object is invalid and false otherwise. Preferably, the true
value is a string describing the problem with the object. This is a check
routine to test the internal state of the object for corruption.
.IP "\s-1CLASS\-\s0>_set(\s-1OBJ\s0)" 4
.IX Item "CLASS->_set(OBJ)"
xxx
.SS "\s-1API\s0 version 2"
.IX Subsection "API version 2"
The following methods are required for an \s-1API\s0 version of 2 or greater.
.PP
\fIConstructors\fR
.IX Subsection "Constructors"
.IP "\s-1CLASS\-\s0>_1ex(N)" 4
.IX Item "CLASS->_1ex(N)"
Return an object representing the number 10**N where N >= 0 is a Perl
scalar.
.PP
\fIMathematical functions\fR
.IX Subsection "Mathematical functions"
.IP "\s-1CLASS\-\s0>_nok(\s-1OBJ1, OBJ2\s0)" 4
.IX Item "CLASS->_nok(OBJ1, OBJ2)"
Return the binomial coefficient \s-1OBJ1\s0 over \s-1OBJ1.\s0
.PP
\fIMiscellaneous\fR
.IX Subsection "Miscellaneous"
.IP "\s-1CLASS\-\s0>_alen(\s-1OBJ\s0)" 4
.IX Item "CLASS->_alen(OBJ)"
Return the approximate number of decimal digits of the object. The output is a
Perl scalar.
.SH "WRAP YOUR OWN"
.IX Header "WRAP YOUR OWN"
If you want to port your own favourite C library for big numbers to the
Math::BigInt interface, you can take any of the already existing modules as a
rough guideline. You should really wrap up the latest Math::BigInt and
Math::BigFloat testsuites with your module, and replace in them any of the
following:
.PP
.Vb 1
\&        use Math::BigInt;
.Ve
.PP
by this:
.PP
.Vb 1
\&        use Math::BigInt lib => \*(Aqyourlib\*(Aq;
.Ve
.PP
This way you ensure that your library really works 100% within Math::BigInt.
.SH "BUGS"
.IX Header "BUGS"
Please report any bugs or feature requests to
\&\f(CW\*(C`bug\-math\-bigint at rt.cpan.org\*(C'\fR, or through the web interface at
<https://rt.cpan.org/Ticket/Create.html?Queue=Math\-BigInt>
(requires login).
We will be notified, and then you'll automatically be notified of progress on
your bug as I make changes.
.SH "SUPPORT"
.IX Header "SUPPORT"
You can find documentation for this module with the perldoc command.
.PP
.Vb 1
\&    perldoc Math::BigInt::Calc
.Ve
.PP
You can also look for information at:
.IP "\(bu" 4
\&\s-1RT: CPAN\s0's request tracker
.Sp
<https://rt.cpan.org/Public/Dist/Display.html?Name=Math\-BigInt>
.IP "\(bu" 4
AnnoCPAN: Annotated \s-1CPAN\s0 documentation
.Sp
<http://annocpan.org/dist/Math\-BigInt>
.IP "\(bu" 4
\&\s-1CPAN\s0 Ratings
.Sp
<http://cpanratings.perl.org/dist/Math\-BigInt>
.IP "\(bu" 4
Search \s-1CPAN\s0
.Sp
<http://search.cpan.org/dist/Math\-BigInt/>
.IP "\(bu" 4
\&\s-1CPAN\s0 Testers Matrix
.Sp
<http://matrix.cpantesters.org/?dist=Math\-BigInt>
.IP "\(bu" 4
The Bignum mailing list
.RS 4
.IP "\(bu" 4
Post to mailing list
.Sp
\&\f(CW\*(C`bignum at lists.scsys.co.uk\*(C'\fR
.IP "\(bu" 4
View mailing list
.Sp
<http://lists.scsys.co.uk/pipermail/bignum/>
.IP "\(bu" 4
Subscribe/Unsubscribe
.Sp
<http://lists.scsys.co.uk/cgi\-bin/mailman/listinfo/bignum>
.RE
.RS 4
.RE
.SH "LICENSE"
.IX Header "LICENSE"
This program is free software; you may redistribute it and/or modify it under
the same terms as Perl itself.
.SH "AUTHOR"
.IX Header "AUTHOR"
Peter John Acklam, <pjacklam@online.no>
.PP
Code and documentation based on the Math::BigInt::Calc module by Tels
<nospam\-abuse@bloodgate.com>
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Math::BigInt, Math::BigInt::Calc, Math::BigInt::GMP,
Math::BigInt::FastCalc and Math::BigInt::Pari.
