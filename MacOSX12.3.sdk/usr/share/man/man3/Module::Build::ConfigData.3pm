.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Module::Build::ConfigData 3pm"
.TH Module::Build::ConfigData 3pm "2014-09-30" "perl v5.18.4" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Module::Build::ConfigData \- Configuration for Module::Build
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 3
\&  use Module::Build::ConfigData;
\&  $value = Module::Build::ConfigData\->config(\*(Aqfoo\*(Aq);
\&  $value = Module::Build::ConfigData\->feature(\*(Aqbar\*(Aq);
\&
\&  @names = Module::Build::ConfigData\->config_names;
\&  @names = Module::Build::ConfigData\->feature_names;
\&
\&  Module::Build::ConfigData\->set_config(foo => $new_value);
\&  Module::Build::ConfigData\->set_feature(bar => $new_value);
\&  Module::Build::ConfigData\->write;  # Save changes
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module holds the configuration data for the \f(CW\*(C`Module::Build\*(C'\fR
module.  It also provides a programmatic interface for getting or
setting that configuration data.  Note that in order to actually make
changes, you'll have to have write access to the \f(CW\*(C`Module::Build::ConfigData\*(C'\fR
module, and you should attempt to understand the repercussions of your
actions.
.SH "METHODS"
.IX Header "METHODS"
.IP "config($name)" 4
.IX Item "config($name)"
Given a string argument, returns the value of the configuration item
by that name, or \f(CW\*(C`undef\*(C'\fR if no such item exists.
.IP "feature($name)" 4
.IX Item "feature($name)"
Given a string argument, returns the value of the feature by that
name, or \f(CW\*(C`undef\*(C'\fR if no such feature exists.
.ie n .IP "set_config($name, $value)" 4
.el .IP "set_config($name, \f(CW$value\fR)" 4
.IX Item "set_config($name, $value)"
Sets the configuration item with the given name to the given value.
The value may be any Perl scalar that will serialize correctly using
\&\f(CW\*(C`Data::Dumper\*(C'\fR.  This includes references, objects (usually), and
complex data structures.  It probably does not include transient
things like filehandles or sockets.
.ie n .IP "set_feature($name, $value)" 4
.el .IP "set_feature($name, \f(CW$value\fR)" 4
.IX Item "set_feature($name, $value)"
Sets the feature with the given name to the given boolean value.  The
value will be converted to 0 or 1 automatically.
.IP "\fIconfig_names()\fR" 4
.IX Item "config_names()"
Returns a list of all the names of config items currently defined in
\&\f(CW\*(C`Module::Build::ConfigData\*(C'\fR, or in scalar context the number of items.
.IP "\fIfeature_names()\fR" 4
.IX Item "feature_names()"
Returns a list of all the names of features currently defined in
\&\f(CW\*(C`Module::Build::ConfigData\*(C'\fR, or in scalar context the number of features.
.IP "\fIauto_feature_names()\fR" 4
.IX Item "auto_feature_names()"
Returns a list of all the names of features whose availability is
dynamically determined, or in scalar context the number of such
features.  Does not include such features that have later been set to
a fixed value.
.IP "\fIwrite()\fR" 4
.IX Item "write()"
Commits any changes from \f(CW\*(C`set_config()\*(C'\fR and \f(CW\*(C`set_feature()\*(C'\fR to disk.
Requires write access to the \f(CW\*(C`Module::Build::ConfigData\*(C'\fR module.
.SH "AUTHOR"
.IX Header "AUTHOR"
\&\f(CW\*(C`Module::Build::ConfigData\*(C'\fR was automatically created using \f(CW\*(C`Module::Build\*(C'\fR.
\&\f(CW\*(C`Module::Build\*(C'\fR was written by Ken Williams, but he holds no
authorship claim or copyright claim to the contents of \f(CW\*(C`Module::Build::ConfigData\*(C'\fR.
