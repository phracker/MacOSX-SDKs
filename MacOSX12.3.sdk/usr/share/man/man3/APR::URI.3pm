.\" Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "install::TempContent::Objects::mod_perl-2.0.9::docs::api::APR::URI 3"
.TH install::TempContent::Objects::mod_perl-2.0.9::docs::api::APR::URI 3 "2015-06-18" "perl v5.30.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
APR::URI \- Perl API for URI manipulations
.SH "Synopsis"
.IX Header "Synopsis"
.Vb 1
\&  use APR::URI ();
\&  
\&  my $url = \*(Aqhttp://user:pass@example.com:80/foo?bar#item5\*(Aq;
\&  
\&  # parse and break the url into components
\&  my $parsed = APR::URI\->parse($r\->pool, $url);
\&  print $parsed\->scheme;
\&  print $parsed\->user;
\&  print $parsed\->password;
\&  print $parsed\->hostname;
\&  print $parsed\->port;
\&  print $parsed\->path;
\&  print $parsed\->rpath;
\&  print $parsed\->query;
\&  print $parsed\->fragment;
\&  
\&  # reconstruct the url, after changing some components and completely
\&  # removing other
\&  $parsed\->scheme($new_scheme);
\&  $parsed\->user(undef);
\&  $parsed\->password(undef);
\&  $parsed\->hostname($new_hostname);
\&  $parsed\->port($new_port);
\&  $parsed\->path($new_path);
\&  $parsed\->query(undef);
\&  $parsed\->fragment(undef);
\&  print $parsed\->unparse;
\&  
\&  # get the password field too (by default it\*(Aqs not revealed)
\&  use APR::Const \-compile => qw(URI_UNP_REVEALPASSWORD);
\&  print $parsed\->unparse(APR::Const::URI_UNP_REVEALPASSWORD);
\&  
\&  # what the default port for the ftp protocol?
\&  my $ftp_port = APR::URI::port_of_scheme("ftp");
.Ve
.SH "Description"
.IX Header "Description"
\&\f(CW\*(C`APR::URI\*(C'\fR allows you to parse \s-1URI\s0 strings, manipulate each of the
\&\s-1URI\s0 elements and deparse them back into URIs.
.PP
All \f(CW\*(C`APR::URI\*(C'\fR object accessors accept a string or an \f(CW\*(C`undef\*(C'\fR value
as an argument. Same goes for return value. It's important to
distinguish between an empty string and \f(CW\*(C`undef\*(C'\fR. For example let's
say your code was:
.PP
.Vb 2
\&  my $uri = \*(Aqhttp://example.com/foo?bar#item5\*(Aq;
\&  my $parsed = APR::URI\->parse($r\->pool, $uri);
.Ve
.PP
Now you no longer want to the query and fragment components in the
final url. If you do:
.PP
.Vb 2
\&  $parsed\->fragment(\*(Aq\*(Aq);
\&  $parsed\->query(\*(Aq\*(Aq);
.Ve
.PP
followed by:
.PP
.Vb 1
\&  my $new_uri = parsed\->unparse;
.Ve
.PP
the resulting \s-1URI\s0 will be:
.PP
.Vb 1
\&  http://example.com/foo?#
.Ve
.PP
which is probably not something that you've expected. In order to get
rid of the separators, you must completely unset the fields you don't
want to see. So, if you do:
.PP
.Vb 2
\&  $parsed\->fragment(undef);
\&  $parsed\->query(undef);
.Ve
.PP
followed by:
.PP
.Vb 1
\&  my $new_uri = parsed\->unparse;
.Ve
.PP
the resulting \s-1URI\s0 will be:
.PP
.Vb 1
\&   http://example.com/foo
.Ve
.PP
As mentioned earlier the same goes for return values, so continuing
this example:
.PP
.Vb 2
\&  my $new_fragment = $parsed\->fragment();
\&  my $new_query    = $parsed\->query();
.Ve
.PP
Both values now contain \f(CW\*(C`undef\*(C'\fR, therefore you must be careful when
using the return values, when you use them, as you may get warnings.
.PP
Also make sure you read through \f(CW\*(C`the unparse()
section\*(C'\fR as various optional flags affect how the
deparsed \s-1URI\s0 is rendered.
.SH "API"
.IX Header "API"
\&\f(CW\*(C`APR::URI\*(C'\fR provides the following functions and/or methods:
.ie n .SS """fragment"""
.el .SS "\f(CWfragment\fP"
.IX Subsection "fragment"
Get/set trailing \*(L"#fragment\*(R" string
.PP
.Vb 1
\&  $oldval = $parsed\->fragment($newval);
.Ve
.ie n .IP "obj: $parsed ( ""APR::URI object"" )" 4
.el .IP "obj: \f(CW$parsed\fR ( \f(CWAPR::URI object\fR )" 4
.IX Item "obj: $parsed ( APR::URI object )"
.PD 0
.ie n .IP "opt arg1: $newval ( string or undef )" 4
.el .IP "opt arg1: \f(CW$newval\fR ( string or undef )" 4
.IX Item "opt arg1: $newval ( string or undef )"
.ie n .IP "ret: $oldval ( string or undef )" 4
.el .IP "ret: \f(CW$oldval\fR ( string or undef )" 4
.IX Item "ret: $oldval ( string or undef )"
.IP "since: 2.0.00" 4
.IX Item "since: 2.0.00"
.PD
.ie n .SS """hostinfo"""
.el .SS "\f(CWhostinfo\fP"
.IX Subsection "hostinfo"
Get/set combined \f(CW\*(C`[user[:password]@]host[:port]\*(C'\fR
.PP
.Vb 1
\&  $oldval = $parsed\->hostinfo($newval);
.Ve
.ie n .IP "obj: $parsed ( ""APR::URI object"" )" 4
.el .IP "obj: \f(CW$parsed\fR ( \f(CWAPR::URI object\fR )" 4
.IX Item "obj: $parsed ( APR::URI object )"
.PD 0
.ie n .IP "opt arg1: $newval ( string or undef )" 4
.el .IP "opt arg1: \f(CW$newval\fR ( string or undef )" 4
.IX Item "opt arg1: $newval ( string or undef )"
.ie n .IP "ret: $oldval ( string or undef )" 4
.el .IP "ret: \f(CW$oldval\fR ( string or undef )" 4
.IX Item "ret: $oldval ( string or undef )"
.IP "since: 2.0.00" 4
.IX Item "since: 2.0.00"
.PD
.PP
The \f(CW\*(C`hostinfo\*(C'\fR value is set automatically when
\&\f(CW\*(C`parse()\*(C'\fR is called.
.PP
It's not updated if any of the individual fields is modified.
.PP
It's not used when \f(CW\*(C`unparse()\*(C'\fR is called.
.ie n .SS """hostname"""
.el .SS "\f(CWhostname\fP"
.IX Subsection "hostname"
Get/set hostname
.PP
.Vb 1
\&  $oldval = $parsed\->hostname($newval);
.Ve
.ie n .IP "obj: $parsed ( ""APR::URI object"" )" 4
.el .IP "obj: \f(CW$parsed\fR ( \f(CWAPR::URI object\fR )" 4
.IX Item "obj: $parsed ( APR::URI object )"
.PD 0
.ie n .IP "opt arg1: $newval ( string or undef )" 4
.el .IP "opt arg1: \f(CW$newval\fR ( string or undef )" 4
.IX Item "opt arg1: $newval ( string or undef )"
.ie n .IP "ret: $oldval ( string or undef )" 4
.el .IP "ret: \f(CW$oldval\fR ( string or undef )" 4
.IX Item "ret: $oldval ( string or undef )"
.IP "since: 2.0.00" 4
.IX Item "since: 2.0.00"
.PD
.ie n .SS """password"""
.el .SS "\f(CWpassword\fP"
.IX Subsection "password"
Get/set password (as in http://user:password@host:port/)
.PP
.Vb 1
\&  $oldval = $parsed\->password($newval);
.Ve
.ie n .IP "obj: $parsed ( ""APR::URI object"" )" 4
.el .IP "obj: \f(CW$parsed\fR ( \f(CWAPR::URI object\fR )" 4
.IX Item "obj: $parsed ( APR::URI object )"
.PD 0
.ie n .IP "opt arg1: $newval ( string or undef )" 4
.el .IP "opt arg1: \f(CW$newval\fR ( string or undef )" 4
.IX Item "opt arg1: $newval ( string or undef )"
.ie n .IP "ret: $oldval ( string or undef )" 4
.el .IP "ret: \f(CW$oldval\fR ( string or undef )" 4
.IX Item "ret: $oldval ( string or undef )"
.IP "since: 2.0.00" 4
.IX Item "since: 2.0.00"
.PD
.ie n .SS """parse"""
.el .SS "\f(CWparse\fP"
.IX Subsection "parse"
Parse the \s-1URI\s0 string into \s-1URI\s0 components
.PP
.Vb 1
\&  $parsed = APR::URI\->parse($pool, $uri);
.Ve
.ie n .IP "obj: $parsed ( ""APR::URI object or class"" )" 4
.el .IP "obj: \f(CW$parsed\fR ( \f(CWAPR::URI object or class\fR )" 4
.IX Item "obj: $parsed ( APR::URI object or class )"
.PD 0
.ie n .IP "arg1: $pool ( string ) ( ""APR::Pool object"" )" 4
.el .IP "arg1: \f(CW$pool\fR ( string ) ( \f(CWAPR::Pool object\fR )" 4
.IX Item "arg1: $pool ( string ) ( APR::Pool object )"
.ie n .IP "arg2: $uri ( string )" 4
.el .IP "arg2: \f(CW$uri\fR ( string )" 4
.IX Item "arg2: $uri ( string )"
.PD
The \s-1URI\s0 to parse
.ie n .IP "ret: $parsed ( ""APR::URI object or class"" )" 4
.el .IP "ret: \f(CW$parsed\fR ( \f(CWAPR::URI object or class\fR )" 4
.IX Item "ret: $parsed ( APR::URI object or class )"
The parsed \s-1URI\s0 object
.IP "since: 2.0.00" 4
.IX Item "since: 2.0.00"
.PP
After parsing, if a component existed but was an empty string
(e.g. empty query \fIhttp://hostname/path?\fR) \*(-- the corresponding
accessor will return an empty string. If a component didn't exist
(e.g. no query part \fIhttp://hostname/path\fR) \*(-- the corresponding
accessor will return \f(CW\*(C`undef\*(C'\fR.
.ie n .SS """path"""
.el .SS "\f(CWpath\fP"
.IX Subsection "path"
Get/set the request path
.PP
.Vb 1
\&  $oldval = $parsed\->path($newval);
.Ve
.ie n .IP "obj: $parsed ( ""APR::URI object"" )" 4
.el .IP "obj: \f(CW$parsed\fR ( \f(CWAPR::URI object\fR )" 4
.IX Item "obj: $parsed ( APR::URI object )"
.PD 0
.ie n .IP "opt arg1: $newval ( string or undef )" 4
.el .IP "opt arg1: \f(CW$newval\fR ( string or undef )" 4
.IX Item "opt arg1: $newval ( string or undef )"
.ie n .IP "ret: $oldval ( string or undef )" 4
.el .IP "ret: \f(CW$oldval\fR ( string or undef )" 4
.IX Item "ret: $oldval ( string or undef )"
.PD
\&\f(CW"/"\fR if only \f(CW\*(C`scheme://host\*(C'\fR
.IP "since: 2.0.00" 4
.IX Item "since: 2.0.00"
.ie n .SS """rpath"""
.el .SS "\f(CWrpath\fP"
.IX Subsection "rpath"
Gets the \f(CW\*(C`path\*(C'\fR minus the 
\&\f(CW\*(C`path_info\*(C'\fR
.PP
.Vb 1
\&  $rpath =  $parsed\->rpath();
.Ve
.ie n .IP "obj: $parsed ( ""APR::URI object"" )" 4
.el .IP "obj: \f(CW$parsed\fR ( \f(CWAPR::URI object\fR )" 4
.IX Item "obj: $parsed ( APR::URI object )"
.PD 0
.ie n .IP "opt arg1: $newval ( string or undef )" 4
.el .IP "opt arg1: \f(CW$newval\fR ( string or undef )" 4
.IX Item "opt arg1: $newval ( string or undef )"
.ie n .IP "ret: $oldval ( string or undef )" 4
.el .IP "ret: \f(CW$oldval\fR ( string or undef )" 4
.IX Item "ret: $oldval ( string or undef )"
.PD
The path minus the \fIpath_info\fR
.IP "since: 2.0.00" 4
.IX Item "since: 2.0.00"
.ie n .SS """port"""
.el .SS "\f(CWport\fP"
.IX Subsection "port"
Get/set port number
.PP
.Vb 1
\&  $oldval = $parsed\->port($newval);
.Ve
.ie n .IP "obj: $parsed ( ""APR::URI object"" )" 4
.el .IP "obj: \f(CW$parsed\fR ( \f(CWAPR::URI object\fR )" 4
.IX Item "obj: $parsed ( APR::URI object )"
.PD 0
.ie n .IP "opt arg1: $newval ( number or string or undef )" 4
.el .IP "opt arg1: \f(CW$newval\fR ( number or string or undef )" 4
.IX Item "opt arg1: $newval ( number or string or undef )"
.ie n .IP "ret: $oldval ( string or undef )" 4
.el .IP "ret: \f(CW$oldval\fR ( string or undef )" 4
.IX Item "ret: $oldval ( string or undef )"
.PD
If the port component didn't appear in the parsed \s-1URI, APR\s0 internally
calls \f(CW\*(C`port_of_scheme()\*(C'\fR to find out the port
number for the given \f(CW\*(C`scheme()\*(C'\fR.
.IP "since: 2.0.00" 4
.IX Item "since: 2.0.00"
.ie n .SS """port_of_scheme"""
.el .SS "\f(CWport_of_scheme\fP"
.IX Subsection "port_of_scheme"
Return the default port for a given scheme.  The recognized schemes
are http, ftp, https, gopher, wais, nntp, snews and prospero.
.PP
.Vb 1
\&  $port = APR::URI::port_of_scheme($scheme);
.Ve
.ie n .IP "obj: $scheme ( string )" 4
.el .IP "obj: \f(CW$scheme\fR ( string )" 4
.IX Item "obj: $scheme ( string )"
The scheme string
.ie n .IP "ret: $port (integer)" 4
.el .IP "ret: \f(CW$port\fR (integer)" 4
.IX Item "ret: $port (integer)"
The default port for this scheme
.IP "since: 2.0.00" 4
.IX Item "since: 2.0.00"
.ie n .SS """query"""
.el .SS "\f(CWquery\fP"
.IX Subsection "query"
Get/set the query string (the part starting after \f(CW\*(Aq?\*(Aq\fR and all the
way till the end or the \f(CW\*(Aq#fragment\*(Aq\fR part if the latter exists).
.PP
.Vb 1
\&  $oldval = $parsed\->query($newval);
.Ve
.ie n .IP "obj: $parsed ( ""APR::URI object"" )" 4
.el .IP "obj: \f(CW$parsed\fR ( \f(CWAPR::URI object\fR )" 4
.IX Item "obj: $parsed ( APR::URI object )"
.PD 0
.ie n .IP "opt arg1: $newval ( string or undef )" 4
.el .IP "opt arg1: \f(CW$newval\fR ( string or undef )" 4
.IX Item "opt arg1: $newval ( string or undef )"
.ie n .IP "ret: $oldval ( string or undef )" 4
.el .IP "ret: \f(CW$oldval\fR ( string or undef )" 4
.IX Item "ret: $oldval ( string or undef )"
.IP "since: 2.0.00" 4
.IX Item "since: 2.0.00"
.PD
.ie n .SS """scheme"""
.el .SS "\f(CWscheme\fP"
.IX Subsection "scheme"
Get/set the protocol scheme (\*(L"http\*(R", \*(L"ftp\*(R", ...)
.PP
.Vb 1
\&  $oldval = $parsed\->scheme($newval);
.Ve
.ie n .IP "obj: $parsed ( ""APR::URI object"" )" 4
.el .IP "obj: \f(CW$parsed\fR ( \f(CWAPR::URI object\fR )" 4
.IX Item "obj: $parsed ( APR::URI object )"
.PD 0
.ie n .IP "opt arg1: $newval ( string or undef )" 4
.el .IP "opt arg1: \f(CW$newval\fR ( string or undef )" 4
.IX Item "opt arg1: $newval ( string or undef )"
.ie n .IP "ret: $oldval ( string or undef )" 4
.el .IP "ret: \f(CW$oldval\fR ( string or undef )" 4
.IX Item "ret: $oldval ( string or undef )"
.IP "since: 2.0.00" 4
.IX Item "since: 2.0.00"
.PD
.ie n .SS """user"""
.el .SS "\f(CWuser\fP"
.IX Subsection "user"
Get/set user name (as in http://user:password@host:port/)
.PP
.Vb 1
\&  $oldval = $parsed\->user($newval);
.Ve
.ie n .IP "obj: $parsed ( ""APR::URI object"" )" 4
.el .IP "obj: \f(CW$parsed\fR ( \f(CWAPR::URI object\fR )" 4
.IX Item "obj: $parsed ( APR::URI object )"
.PD 0
.ie n .IP "opt arg1: $newval ( string or undef )" 4
.el .IP "opt arg1: \f(CW$newval\fR ( string or undef )" 4
.IX Item "opt arg1: $newval ( string or undef )"
.ie n .IP "ret: $oldval ( string or undef )" 4
.el .IP "ret: \f(CW$oldval\fR ( string or undef )" 4
.IX Item "ret: $oldval ( string or undef )"
.IP "since: 2.0.00" 4
.IX Item "since: 2.0.00"
.PD
.ie n .SS """unparse"""
.el .SS "\f(CWunparse\fP"
.IX Subsection "unparse"
Unparse the \s-1URI\s0 components back into a \s-1URI\s0 string
.PP
.Vb 2
\&  $new_uri = $parsed\->unparse();
\&  $new_uri = $parsed\->unparse($flags);
.Ve
.ie n .IP "obj: $parsed ( ""APR::URI object"" )" 4
.el .IP "obj: \f(CW$parsed\fR ( \f(CWAPR::URI object\fR )" 4
.IX Item "obj: $parsed ( APR::URI object )"
.PD 0
.ie n .IP "opt arg1: $flags ( the APR::Const :uri constants )" 4
.el .IP "opt arg1: \f(CW$flags\fR ( the APR::Const :uri constants )" 4
.IX Item "opt arg1: $flags ( the APR::Const :uri constants )"
.PD
By default the constant \f(CW\*(C`APR::Const::URI_UNP_OMITPASSWORD\*(C'\fR is passed.
.Sp
If you need to pass more than one flag use unary \f(CW\*(C`|\*(C'\fR, e.g.:
.Sp
.Vb 1
\&  $flags = APR::Const::URI_UNP_OMITUSER|APR::Const::URI_UNP_OMITPASSWORD;
.Ve
.Sp
The valid \f(CW\*(C`flags\*(C'\fR constants are listed next
.ie n .IP "ret: $new_uri ( string )" 4
.el .IP "ret: \f(CW$new_uri\fR ( string )" 4
.IX Item "ret: $new_uri ( string )"
.PD 0
.IP "since: 2.0.00" 4
.IX Item "since: 2.0.00"
.PD
.PP
Valid \f(CW\*(C`flags\*(C'\fR constants:
.PP
To import all \s-1URI\s0 constants you could do:
.PP
.Vb 1
\&  use APR::Const \-compile => qw(:uri);
.Ve
.PP
but there is a significant amount of them, most irrelevant to this
method. Therefore you probably don't want to do that. Instead specify
explicitly the ones that you need. All the relevant to this method
constants start with \f(CW\*(C`APR::URI_UNP_\*(C'\fR.
.PP
And the available constants are:
.ie n .IP """APR::Const::URI_UNP_OMITSITEPART""" 4
.el .IP "\f(CWAPR::Const::URI_UNP_OMITSITEPART\fR" 4
.IX Item "APR::Const::URI_UNP_OMITSITEPART"
Don't show \f(CW\*(C`scheme\*(C'\fR, \f(CW\*(C`user\*(C'\fR,
\&\f(CW\*(C`password\*(C'\fR, \f(CW\*(C`hostname\*(C'\fR and
\&\f(CW\*(C`port\*(C'\fR components (i.e. if you want only the relative
\&\s-1URI\s0)
.ie n .IP """APR::Const::URI_UNP_OMITUSER""" 4
.el .IP "\f(CWAPR::Const::URI_UNP_OMITUSER\fR" 4
.IX Item "APR::Const::URI_UNP_OMITUSER"
Hide the \f(CW\*(C`user\*(C'\fR component
.ie n .IP """APR::Const::URI_UNP_OMITPASSWORD""" 4
.el .IP "\f(CWAPR::Const::URI_UNP_OMITPASSWORD\fR" 4
.IX Item "APR::Const::URI_UNP_OMITPASSWORD"
Hide the \f(CW\*(C`password\*(C'\fR component (the default)
.ie n .IP """APR::Const::URI_UNP_REVEALPASSWORD""" 4
.el .IP "\f(CWAPR::Const::URI_UNP_REVEALPASSWORD\fR" 4
.IX Item "APR::Const::URI_UNP_REVEALPASSWORD"
Reveal the \f(CW\*(C`password\*(C'\fR component
.ie n .IP """APR::Const::URI_UNP_OMITPATHINFO""" 4
.el .IP "\f(CWAPR::Const::URI_UNP_OMITPATHINFO\fR" 4
.IX Item "APR::Const::URI_UNP_OMITPATHINFO"
Don't show \f(CW\*(C`path\*(C'\fR, \f(CW\*(C`query\*(C'\fR and
\&\f(CW\*(C`fragment\*(C'\fR components
.ie n .IP """APR::Const::URI_UNP_OMITQUERY""" 4
.el .IP "\f(CWAPR::Const::URI_UNP_OMITQUERY\fR" 4
.IX Item "APR::Const::URI_UNP_OMITQUERY"
Don't show \f(CW\*(C`query\*(C'\fR and \f(CW\*(C`fragment\*(C'\fR
components
.PP
Notice that some flags overlap.
.PP
If the optional \f(CW$flags\fR argument is passed and contains no
\&\f(CW\*(C`APR::Const::URI_UNP_OMITPASSWORD\*(C'\fR and no \f(CW\*(C`APR::Const::URI_UNP_REVEALPASSWORD\*(C'\fR \*(--
the \f(CW\*(C`password\*(C'\fR part will be rendered as a literal
\&\f(CW"XXXXXXXX"\fR string.
.PP
If the \f(CW\*(C`port\*(C'\fR number matches the
\&\f(CW\*(C`port_of_scheme()\*(C'\fR, the unparsed \s-1URI\s0 won't
include it and there is no flag to force that \f(CW\*(C`port\*(C'\fR to
appear. If the \f(CW\*(C`port\*(C'\fR number is non-standard it will show
up in the unparsed string.
.PP
Examples:
.PP
Starting with the parsed \s-1URL:\s0
.PP
.Vb 3
\&  use APR::URI ();
\&  my $url = \*(Aqhttp://user:pass@example.com:80/foo?bar#item5\*(Aq;
\&  my $parsed = APR::URI\->parse($r\->pool, $url);
.Ve
.PP
deparse it back including and excluding parts, using different values
for the optional \f(CW\*(C`flags\*(C'\fR argument:
.IP "\(bu" 4
Show all but the \f(CW\*(C`password\*(C'\fR fields:
.Sp
.Vb 1
\&  print $parsed\->unparse;
.Ve
.Sp
Prints:
.Sp
.Vb 1
\&  http://user@example.com/foo?bar#item5
.Ve
.Sp
Notice that the \f(CW\*(C`port\*(C'\fR field is gone too, since it was a
default \f(CW\*(C`port\*(C'\fR for \f(CW\*(C`scheme\*(C'\fR
\&\f(CW\*(C`http://\*(C'\fR.
.IP "\(bu" 4
Include the \f(CW\*(C`password\*(C'\fR field (by default it's not revealed)
.Sp
.Vb 2
\&  use APR::Const \-compile => qw(URI_UNP_REVEALPASSWORD);
\&  print $parsed\->unparse(APR::Const::URI_UNP_REVEALPASSWORD);
.Ve
.Sp
Prints:
.Sp
.Vb 1
\&  http://user:pass@example.com/foo?bar#item5
.Ve
.IP "\(bu" 4
Show all fields but the last three, \f(CW\*(C`path\*(C'\fR,
\&\f(CW\*(C`query\*(C'\fR and \f(CW\*(C`fragment\*(C'\fR:
.Sp
.Vb 4
\&  use APR::Const \-compile => qw(URI_UNP_REVEALPASSWORD
\&                                APR::Const::URI_UNP_OMITPATHINFO);
\&  print $parsed\->unparse(
\&      APR::Const::URI_UNP_REVEALPASSWORD|URI_UNP_OMITPATHINFO);
.Ve
.Sp
Prints:
.Sp
.Vb 1
\&  http://user:pass@example.com
.Ve
.SH "See Also"
.IX Header "See Also"
\&\f(CW\*(C`Apache2::URI\*(C'\fR, mod_perl 2.0
documentation.
.SH "Copyright"
.IX Header "Copyright"
mod_perl 2.0 and its core modules are copyrighted under
The Apache Software License, Version 2.0.
.SH "Authors"
.IX Header "Authors"
The mod_perl development team and numerous
contributors.
