.\" Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Compress::Bzip2 3"
.TH Compress::Bzip2 3 "2017-04-10" "perl v5.30.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Compress::Bzip2 \- Interface to Bzip2 compression library
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use Compress::Bzip2 qw(:all :constant :utilities :gzip);
\&
\&    ($bz, $status) = bzdeflateInit( [PARAMS] );
\&    ($out, $status) = $bz\->bzdeflate($buffer) ; # compress
\&
\&    ($bz, $status) = bzinflateInit( [PARAMS] );
\&    ($out, $status) = $bz\->bzinflate($buffer);  # uncompress
\&
\&    ($out, $status) = $bz\->bzflush() ;
\&    ($out, $status) = $bz\->bzclose() ;
\&
\&    $dest = memBzip($source);
\&        alias compress
\&    $dest = memBunzip($source);
\&        alias decompress
\&
\&    $bz = Compress::Bzip2\->new( [PARAMS] );
\&
\&    $bz = bzopen($filename or filehandle, $mode);
\&        alternate, with $bz created by new():
\&    $bz\->bzopen($filename or filehandle, $mode);
\&
\&    $bytesread = $bz\->bzread($buffer [,$size]) ;
\&    $bytesread = $bz\->bzreadline($line);
\&    $byteswritten = $bz\->bzwrite($buffer [,$limit]);
\&    $errstring = $bz\->bzerror();
\&    $status = $bz\->bzeof();
\&    $status = $bz\->bzflush();
\&    $status = $bz\->bzclose() ;
\&
\&    $status = $bz\->bzsetparams( $param => $setting );
\&
\&    $bz\->total_in() ;
\&    $bz\->total_out() ;
\&
\&    $verstring = $bz\->bzversion();
\&
\&    $Compress::Bzip2::bzerrno
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The \fICompress::Bzip2\fR module provides a Perl interface to the \fBbzip2\fR
compression library (see \*(L"\s-1AUTHOR\*(R"\s0 for details about where to get
\&\fIBzip2\fR). A relevant subset of the functionality provided by \fIbzip2\fR
is available in \fICompress::Bzip2\fR.
.PP
All string parameters can either be a scalar or a scalar reference.
.PP
The module can be split into two general areas of functionality, namely
in-memory compression/decompression and read/write access to \fIbzip2\fR
files. Each of these areas will be discussed separately below.
.PP
\&\fB\s-1NOTE\s0\fR
.PP
\&\fICompress::Bzip2\fR is just a simple \fIbzip2\fR binding, comparable to the
old Compress::Zlib library. It is not well integrated into PerlIO,
use the preferred IO::Compress::Bzip2 instead.
.SH "FILE READ/WRITE INTERFACE"
.IX Header "FILE READ/WRITE INTERFACE"
A number of functions are supplied in \fIbzlib\fR for reading and writing
\&\fIbzip2\fR files. Unfortunately, most of them are not suitable.  So, this
module provides another interface, built over top of the low level bzlib
methods.
.SS "\fB\fP\f(CB$bz\fP\fB = bzopen(filename or filehandle, mode)\fP"
.IX Subsection "$bz = bzopen(filename or filehandle, mode)"
This function returns an object which is used to access the other
\&\fIbzip2\fR methods.
.PP
The \fBmode\fR parameter is used to specify both whether the file is
opened for reading or writing, with \*(L"r\*(R" or \*(L"w\*(R" respectively.
.PP
If a reference to an open filehandle is passed in place of the
filename, it better be positioned to the start of a
compression/decompression sequence.
.PP
\&\s-1WARNING:\s0 With Perl 5.6 you cannot use a filehandle because of
\&\s-1SEGV\s0 in destruction with bzclose or an implicit close.
.SS "\fB\fP\f(CB$bz\fP\fB = Compress::Bzip2\->new( [\s-1PARAMS\s0] )\fP"
.IX Subsection "$bz = Compress::Bzip2->new( [PARAMS] )"
Create a Compress::Bzip2 object.  Optionally, provide
compression/decompression parameters as a keyword => setting list.
See \fI\f(BIbzsetparams()\fI\fR for a description of the parameters.
.SS "\fB\fP\f(CB$bz\fP\fB\->bzopen(filename or filehandle, mode)\fP"
.IX Subsection "$bz->bzopen(filename or filehandle, mode)"
This is bzopen, but it uses an object previously created by the new
method.  Other than that, it is identical to the above bzopen.
.SS "\fB\fP\f(CB$bytesread\fP\fB = \fP\f(CB$bz\fP\fB\->bzread($buffer [, \fP\f(CB$size\fP\fB]) ;\fP"
.IX Subsection "$bytesread = $bz->bzread($buffer [, $size]) ;"
Reads \fB\f(CB$size\fB\fR bytes from the compressed file into \fB\f(CB$buffer\fB\fR. If
\&\fB\f(CB$size\fB\fR is not specified, it will default to 4096. If the scalar
\&\fB\f(CB$buffer\fB\fR is not large enough, it will be extended automatically.
.PP
Returns the number of bytes actually read. On \s-1EOF\s0 it returns 0 and in
the case of an error, \-1.
.SS "\fB\fP\f(CB$bytesread\fP\fB = \fP\f(CB$bz\fP\fB\->bzreadline($line) ;\fP"
.IX Subsection "$bytesread = $bz->bzreadline($line) ;"
Reads the next line from the compressed file into \fB\f(CB$line\fB\fR.
.PP
Returns the number of bytes actually read. On \s-1EOF\s0 it returns 0 and in
the case of an error, \-1.
.PP
It \s-1IS\s0 legal to intermix calls to \fBbzread\fR and \fBbzreadline\fR.
.PP
At this time \fBbzreadline\fR ignores the variable \f(CW$/\fR
(\f(CW$INPUT_RECORD_SEPARATOR\fR or \f(CW$RS\fR when \f(CW\*(C`English\*(C'\fR is in use). The
end of a line is denoted by the C character \f(CW\*(Aq\en\*(Aq\fR.
.SS "\fB\fP\f(CB$byteswritten\fP\fB = \fP\f(CB$bz\fP\fB\->bzwrite($buffer [, \fP\f(CB$limit\fP\fB]) ;\fP"
.IX Subsection "$byteswritten = $bz->bzwrite($buffer [, $limit]) ;"
Writes the contents of \fB\f(CB$buffer\fB\fR to the compressed file. Returns the
number of bytes actually written, or 0 on error.
.PP
If \f(CW$limit\fR is given and non-zero, then only that many bytes from
\&\f(CW$buffer\fR will be written.
.SS "\fB\fP\f(CB$status\fP\fB = \fP\f(CB$bz\fP\fB\->bzflush($flush) ;\fP"
.IX Subsection "$status = $bz->bzflush($flush) ;"
Flushes all pending output to the compressed file.
Works identically to the \fIzlib\fR function it interfaces to. Note that
the use of \fBbzflush\fR can degrade compression.
.PP
Returns \f(CW\*(C`BZ_OK\*(C'\fR if \fB\f(CB$flush\fB\fR is \f(CW\*(C`BZ_FINISH\*(C'\fR and all output could be
flushed. Otherwise the bzlib error code is returned.
.PP
Refer to the \fIbzlib\fR documentation for the valid values of \fB\f(CB$flush\fB\fR.
.SS "\fB\fP\f(CB$status\fP\fB = \fP\f(CB$bz\fP\fB\->bzeof() ;\fP"
.IX Subsection "$status = $bz->bzeof() ;"
Returns 1 if the end of file has been detected while reading the input
file, otherwise returns 0.
.SS "\fB\fP\f(CB$bz\fP\fB\->bzclose\fP"
.IX Subsection "$bz->bzclose"
Closes the compressed file. Any pending data is flushed to the file
before it is closed.
.SS "\fB\fP\f(CB$bz\fP\fB\->bzsetparams( [\s-1PARAMS\s0] );\fP"
.IX Subsection "$bz->bzsetparams( [PARAMS] );"
Change settings for the deflate stream \f(CW$bz\fR.
.PP
The list of the valid options is shown below. Options not specified
will remain unchanged.
.IP "\fB\-verbosity\fR" 5
.IX Item "-verbosity"
Defines the verbosity level. Valid values are 0 through 4,
.Sp
The default is \f(CW\*(C`\-verbosity => 0\*(C'\fR.
.IP "\fB\-blockSize100k\fR" 5
.IX Item "-blockSize100k"
For bzip object opened for stream deflation or write.
.Sp
Defines the buffering factor of compression method.  The algorithm
buffers all data until the buffer is full, then it flushes all the
data out.  Use \-blockSize100k to specify the size of the buffer.
.Sp
Valid settings are 1 through 9, representing a blocking in multiples
of 100k.
.Sp
Note that each such block has an overhead of leading and trailing
synchronization bytes.  bzip2 recovery uses this information to
pull useable data out of a corrupted file.
.Sp
A streaming application would probably want to set the blocking low.
.IP "\fB\-workFactor\fR" 5
.IX Item "-workFactor"
For bzip object opened for stream deflation or write.
.Sp
The workFactor setting tells the deflation algorithm how much work
to invest to compensate for repetitive data.
.Sp
workFactor may be a number from 0 to 250 inclusive.  The default setting
is 30.
.Sp
See the bzip documentation for more information.
.IP "\fB\-small\fR" 5
.IX Item "-small"
For bzip object opened for stream inflation or read.
.Sp
\&\fBsmall\fR may be 0 or 1.  Set \f(CW\*(C`small\*(C'\fR to one to use a slower, less
memory intensive algorithm.
.SS "\fB\fP\f(CB$bz\fP\fB\->bzerror\fP"
.IX Subsection "$bz->bzerror"
Returns the \fIbzlib\fR error message or number for the last operation
associated with \fB\f(CB$bz\fB\fR. The return value will be the \fIbzlib\fR error
number when used in a numeric context and the \fIbzlib\fR error message
when used in a string context. The \fIbzlib\fR error number constants,
shown below, are available for use.
.PP
.Vb 10
\&  BZ_CONFIG_ERROR
\&  BZ_DATA_ERROR
\&  BZ_DATA_ERROR_MAGIC
\&  BZ_FINISH
\&  BZ_FINISH_OK
\&  BZ_FLUSH
\&  BZ_FLUSH_OK
\&  BZ_IO_ERROR
\&  BZ_MAX_UNUSED
\&  BZ_MEM_ERROR
\&  BZ_OK
\&  BZ_OUTBUFF_FULL
\&  BZ_PARAM_ERROR
\&  BZ_RUN
\&  BZ_RUN_OK
\&  BZ_SEQUENCE_ERROR
\&  BZ_STREAM_END
\&  BZ_UNEXPECTED_EOF
.Ve
.SS "\fB\fP\f(CB$bz\fP\fB\->bzclearerr\fP"
.IX Subsection "$bz->bzclearerr"
.SS "\fB\fP\f(CB$bzerrno\fP\fB\fP"
.IX Subsection "$bzerrno"
The \fB\f(CB$bzerrno\fB\fR scalar holds the error code associated with the most
recent \fIbzip2\fR routine. Note that unlike \fB\fBbzerror()\fB\fR, the error is
\&\fInot\fR associated with a particular file.
.PP
As with \fB\fBbzerror()\fB\fR it returns an error number in numeric context and
an error message in string context. Unlike \fB\fBbzerror()\fB\fR though, the
error message will correspond to the \fIbzlib\fR message when the error is
associated with \fIbzlib\fR itself, or the \s-1UNIX\s0 error message when it is
not (i.e. \fIbzlib\fR returned \f(CW\*(C`Z_ERRORNO\*(C'\fR).
.PP
As there is an overlap between the error numbers used by \fIbzlib\fR and
\&\s-1UNIX,\s0 \fB\f(CB$bzerrno\fB\fR should only be used to check for the presence of
\&\fIan\fR error in numeric context. Use \fB\fBbzerror()\fB\fR to check for specific
\&\fIbzlib\fR errors. The \fIbzcat\fR example below shows how the variable can
be used safely.
.SS "\fB\fP\f(CB$bz\fP\fB\->prefix\fP"
.IX Subsection "$bz->prefix"
Returns the additional 5 byte header which is prepended to the bzip2
header  starting with \f(CW\*(C`BZh\*(C'\fR when using memBzip/compress.
.SH "Compress::Bzip2 Utilities"
.IX Header "Compress::Bzip2 Utilities"
Options: \-d \-c \-z \-f \-v \-k \-s \-1..9
.SS "bzip2( [\s-1OPTS\s0], filename)"
.IX Subsection "bzip2( [OPTS], filename)"
.SS "bunzip2(filename)"
.IX Subsection "bunzip2(filename)"
.SS "bzcat(filenames...)"
.IX Subsection "bzcat(filenames...)"
.SS "\fBbzlibversion()\fP"
.IX Subsection "bzlibversion()"
.SS "bzinflateInit( opts... )"
.IX Subsection "bzinflateInit( opts... )"
.SH "Internal Utilties"
.IX Header "Internal Utilties"
.ie n .SS "bz_seterror(errno, msg) =head2 $bz\->\fBis_read()\fP =head2 $bz\->\fBis_stream()\fP =head2 $bz\->\fBis_write()\fP =head2 $bz\->\fBtotal_in()\fP =head2 $bz\->\fBtotal_out()\fP =head2 \fBversion()\fP"
.el .SS "bz_seterror(errno, msg) =head2 \f(CW$bz\fP\->\fBis_read()\fP =head2 \f(CW$bz\fP\->\fBis_stream()\fP =head2 \f(CW$bz\fP\->\fBis_write()\fP =head2 \f(CW$bz\fP\->\fBtotal_in()\fP =head2 \f(CW$bz\fP\->\fBtotal_out()\fP =head2 \fBversion()\fP"
.IX Subsection "bz_seterror(errno, msg) =head2 $bz->is_read() =head2 $bz->is_stream() =head2 $bz->is_write() =head2 $bz->total_in() =head2 $bz->total_out() =head2 version()"
.SH "Compress::Bzip2 1.03 COMPATIBILITY"
.IX Header "Compress::Bzip2 1.03 COMPATIBILITY"
While the 2.x thread forked off of 1.00, another line of development
came to a head at 1.03.  The 1.03 version worked with bzlib 1.0.2, had
improvements to the error handling, single buffer inflate/deflate, a
streaming interface to inflate/deflate, and a cpan style test suite.
.SS "\fB\fP\f(CB$dest\fP\fB = compress( \fP\f(CB$string\fP\fB, [$level] )\fP"
.IX Subsection "$dest = compress( $string, [$level] )"
Alias to memBzip, this compresses string, using the optional
compression level, 1 through 9, the default being 6.  Returns a string
containing the compressed data.
.PP
On error \fIundef\fR is returned.
.SS "\fB\fP\f(CB$dest\fP\fB = decompress($string, [$level])\fP"
.IX Subsection "$dest = decompress($string, [$level])"
Alias to memBunzip, this decompresses the data in string, returning a
string containing the decompressed data.
.PP
On error \fIundef\fR is returned.
.SS "uncompress($string, [$level])"
.IX Subsection "uncompress($string, [$level])"
Another alias to memBunzip
.SS "\fB\fP\f(CB$stream\fP\fB = compress_init( [\s-1PARAMS\s0] )\fP"
.IX Subsection "$stream = compress_init( [PARAMS] )"
Alias to bzdeflateInit.  In addition to the named parameters
documented for bzdeflateInit, the following are accepted:
.PP
.Vb 2
\&   \-level, alias to \-blockSize100k
\&   \-buffer, to set the buffer size.
.Ve
.PP
The \-buffer option is ignored.  The intermediate buffer size is not
changeable.
.SS "\fB\fP\f(CB$stream\fP\fB = decompress_init( [\s-1PARAMS\s0] )\fP"
.IX Subsection "$stream = decompress_init( [PARAMS] )"
Alias to bzinflateInit.  See bzinflateInit for a description of the parameters.
The option \*(L"\-buffer\*(R" is accepted, but ignored.
.SS "\fB\fP\f(CB$output\fP\fB = \fP\f(CB$stream\fP\fB\->add( \fP\f(CB$string\fP\fB )\fP"
.IX Subsection "$output = $stream->add( $string )"
Add data to be compressed/decompressed.  Returns whatever output is available
(possibly none, if it's still buffering it), or undef on error.
.SS "\fB\fP\f(CB$output\fP\fB = \fP\f(CB$stream\fP\fB\->finish( [$string] )\fP"
.IX Subsection "$output = $stream->finish( [$string] )"
Finish the operation; takes an optional final data string.  Whatever is
returned completes the output; returns undef on error.
.SS "\fB\fP\f(CB$stream\fP\fB\->error\fP"
.IX Subsection "$stream->error"
Like the function, but applies to the current object only.  Note that errors
in a stream object are also returned by the function.
.SS "\fB\fP\f(CB$stream\fP\fB\->input_size\fP"
.IX Subsection "$stream->input_size"
Alias to total_in.  Total bytes passed to the stream.
.SS "\fB\fP\f(CB$stream\fP\fB\->output_size\fP"
.IX Subsection "$stream->output_size"
Alias to total_out.  Total bytes received from the stream.
.SH "GZIP COMPATIBILITY INTERFACE"
.IX Header "GZIP COMPATIBILITY INTERFACE"
Except for the exact state and error numbers, this package presents an
interface very much like that given by the Compress::Zlib package.
Mostly, if you take the method name, state or error number from
Compress::Zlib and replace the \*(L"g\*(R" with a \*(L"b\*(R", your code should work.
.PP
To make the interoperability even easier, all the Compress::Zlib method
names have been used as aliases or cover functions for the bzip2 methods.
.PP
Therefore, most code that uses Compress::Zlib should be able to use
this package, with a one line change.
.PP
Simply change
.PP
.Vb 1
\&   $gz = Compress::Zlib::gzopen( "filename", "w" );
.Ve
.PP
to
.PP
.Vb 1
\&   $gz = Compress::Bzip2::gzopen( "filename", "w" );
.Ve
.PP
Some of the Compress::Zlib aliases don't return anything useful, like
crc32 or adler32, cause bzip2 doesn't do that sort of thing.
.SS "\fB \fP\f(CB$gz\fP\fB = gzopen( \fP\f(CB$filename\fP\fB, \fP\f(CB$mode\fP\fB ) \fP"
.IX Subsection " $gz = gzopen( $filename, $mode ) "
Alias for bzopen.
.SS "\fB \fP\f(CB$gz\fP\fB\->gzread( \fP\f(CB$buffer\fP\fB, [ \fP\f(CB$length\fP\fB ] ) \fP"
.IX Subsection " $gz->gzread( $buffer, [ $length ] ) "
Alias for bzread.
.SS "\fB \fP\f(CB$gz\fP\fB\->gzreadline( \fP\f(CB$buffer\fP\fB ) \fP"
.IX Subsection " $gz->gzreadline( $buffer ) "
Alias for bzreadline.
.SS "\fB \fP\f(CB$gz\fP\fB\->gzwrite( \fP\f(CB$buffer\fP\fB ) \fP"
.IX Subsection " $gz->gzwrite( $buffer ) "
Alias for bzwrite.
.SS "\fB \fP\f(CB$gz\fP\fB\->gzflush( [$flushtype] ) \fP"
.IX Subsection " $gz->gzflush( [$flushtype] ) "
Alias for bzflush, with return code translation.
.SS "\fB \fP\f(CB$gz\fP\fB\->gzclose( ) \fP"
.IX Subsection " $gz->gzclose( ) "
Alias for bzclose.
.SS "\fB \fP\f(CB$gz\fP\fB\->gzeof( ) \fP"
.IX Subsection " $gz->gzeof( ) "
Alias for bzeof.
.SS "\fB \fP\f(CB$gz\fP\fB\->gzerror( ) \fP"
.IX Subsection " $gz->gzerror( ) "
Alias for bzerror.
.SS "\fB \fP\f(CB$gz\fP\fB\->gzsetparams( \fP\f(CB$level\fP\fB, \fP\f(CB$strategy\fP\fB ) \fP"
.IX Subsection " $gz->gzsetparams( $level, $strategy ) "
This is a no-op.
.SS "\fB \fP\f(CB$d\fP\fB = deflateInit( [\s-1OPTS\s0] ) \fP"
.IX Subsection " $d = deflateInit( [OPTS] ) "
Alias for bzdeflateInit, with return code translation.
.PP
All \s-1OPTS\s0 are ignored.
.SS "\fB \fP\f(CB$d\fP\fB\->deflate( \fP\f(CB$buffer\fP\fB ) \fP"
.IX Subsection " $d->deflate( $buffer ) "
Alias for bzdeflate, with return code translation.
.SS "\fB \fP\f(CB$d\fP\fB\->deflateParams( [\s-1OPTS\s0] ) \fP"
.IX Subsection " $d->deflateParams( [OPTS] ) "
This is a no-op.
.SS "\fB \fP\f(CB$d\fP\fB\->flush( [$flushtype] ) \fP"
.IX Subsection " $d->flush( [$flushtype] ) "
Cover function for bzflush or bzclose, depending on \f(CW$flushtype\fR.
.PP
See the Compress::Zlib documentation for more information.
.SS "\fB \fP\f(CB$d\fP\fB\->dict_adler( ) \fP"
.IX Subsection " $d->dict_adler( ) "
This is a no-op.
.SS "\fB \fP\f(CB$d\fP\fB\->msg( ) \fP"
.IX Subsection " $d->msg( ) "
This is a no-op.
.SS "\fB \fP\f(CB$d\fP\fB = inflateInit( [\s-1OPTS\s0] ) \fP"
.IX Subsection " $d = inflateInit( [OPTS] ) "
Alias for bzinflateInit, with return code translation.
.PP
All \s-1OPTS\s0 are ignored.
.SS "\fB \fP\f(CB$d\fP\fB\->inflate( ) \fP"
.IX Subsection " $d->inflate( ) "
Alias for bzinflate, with return code translation.
.SS "\fB \fP\f(CB$d\fP\fB\->inflateSync( ) \fP"
.IX Subsection " $d->inflateSync( ) "
This is a no-op.
.SS "\fB \fP\f(CB$d\fP\fB\->adler32( \fP\f(CB$crc\fP\fB ) \fP"
.IX Subsection " $d->adler32( $crc ) "
This is a no-op.
.SS "\fB \fP\f(CB$d\fP\fB\->crc32( \fP\f(CB$crc\fP\fB ) \fP"
.IX Subsection " $d->crc32( $crc ) "
This is a no-op.
.SS "\fB \fP\f(CB$buffer\fP\fB = memGzip( \fP\f(CB$buffer\fP\fB ) \fP"
.IX Subsection " $buffer = memGzip( $buffer ) "
Alias for memBzip.
.SS "\fB \fP\f(CB$buffer\fP\fB = memGunzip( \fP\f(CB$buffer\fP\fB ) \fP"
.IX Subsection " $buffer = memGunzip( $buffer ) "
Alias for memBunzip.
.SH "IN-MEMORY COMPRESS/UNCOMPRESS"
.IX Header "IN-MEMORY COMPRESS/UNCOMPRESS"
Two high-level functions are provided by \fIbzlib\fR to perform in-memory
compression. They are \fBmemBzip\fR and \fBmemBunzip\fR. Two Perl subs are
provided which provide similar functionality.
.SS "\fB\fP\f(CB$compressed\fP\fB = memBzip($buffer);\fP"
.IX Subsection "$compressed = memBzip($buffer);"
Compresses \fB\f(CB$buffer\fB\fR. If successful it returns the compressed
data. Otherwise it returns \fIundef\fR.
.PP
The buffer parameter can either be a scalar or a scalar reference.
.PP
Essentially, an in-memory bzip file is created. It creates a minimal
bzip header, which adds 5 bytes before the bzip2 specific BZh header.
.SS "\fB\fP\f(CB$uncompressed\fP\fB = memBunzip($buffer);\fP"
.IX Subsection "$uncompressed = memBunzip($buffer);"
Uncompresses \fB\f(CB$buffer\fB\fR. If successful it returns the uncompressed
data. Otherwise it returns \fIundef\fR.
.PP
The source buffer can either be a scalar or a scalar reference.
.PP
The buffer parameter can either be a scalar or a scalar reference. The
contents of the buffer parameter are destroyed after calling this
function.
.SH "STREAM DEFLATE (= COMPRESS)"
.IX Header "STREAM DEFLATE (= COMPRESS)"
The Perl interface will \fIalways\fR consume the complete input buffer
before returning. Also the output buffer returned will be
automatically grown to fit the amount of output available.
.PP
Here is a definition of the interface available:
.SS "\fB($d, \fP\f(CB$status\fP\fB) = bzdeflateInit( [\s-1PARAMS\s0] )\fP"
.IX Subsection "($d, $status) = bzdeflateInit( [PARAMS] )"
Initialises a deflation stream.
.PP
If successful, it will return the initialised deflation stream, \fB\f(CB$d\fB\fR
and \fB\f(CB$status\fB\fR of \f(CW\*(C`BZ_OK\*(C'\fR in a list context. In scalar context it
returns the deflation stream, \fB\f(CB$d\fB\fR, only.
.PP
If not successful, the returned deflation stream (\fB\f(CB$d\fB\fR) will be
\&\fIundef\fR and \fB\f(CB$status\fB\fR will hold the exact \fIbzip2\fR error code.
.PP
The function optionally takes a number of named options specified as
\&\f(CW\*(C`\-Name=>value\*(C'\fR pairs. This allows individual options to be
tailored without having to specify them all in the parameter list.
.PP
Here is a list of the valid options:
.IP "\fB\-verbosity\fR" 5
.IX Item "-verbosity"
Defines the verbosity level. Valid values are 0 through 4,
.Sp
The default is \f(CW\*(C`\-verbosity => 0\*(C'\fR.
.IP "\fB\-blockSize100k\fR" 5
.IX Item "-blockSize100k"
Defines the buffering factor of compression method.  The algorithm
buffers all data until the buffer is full, then it flushes all the
data out.  Use \-blockSize100k to specify the size of the buffer.
.Sp
Valid settings are 1 through 9, representing a blocking in multiples
of 100k.
.Sp
Note that each such block has an overhead of leading and trailing
synchronization bytes.  bzip2 recovery uses this information to
pull useable data out of a corrupted file.
.Sp
A streaming application would probably want to set the blocking low.
.IP "\fB\-workFactor\fR" 5
.IX Item "-workFactor"
The workFactor setting tells the deflation algorithm how much work
to invest to compensate for repetitive data.
.Sp
workFactor may be a number from 0 to 250 inclusive.  The default setting
is 30.
.Sp
See the bzip documentation for more information.
.PP
Here is an example of using the \fBdeflateInit\fR optional parameter list
to override the default buffer size and compression level. All other
options will take their default values.
.PP
.Vb 1
\&    bzdeflateInit( \-blockSize100k => 1, \-verbosity => 1 );
.Ve
.SS "\fB($out, \fP\f(CB$status\fP\fB) = \fP\f(CB$d\fP\fB\->bzdeflate($buffer)\fP"
.IX Subsection "($out, $status) = $d->bzdeflate($buffer)"
Deflates the contents of \fB\f(CB$buffer\fB\fR. The buffer can either be a scalar
or a scalar reference.  When finished, \fB\f(CB$buffer\fB\fR will be
completely processed (assuming there were no errors). If the deflation
was successful it returns deflated output, \fB\f(CB$out\fB\fR, and a status
value, \fB\f(CB$status\fB\fR, of \f(CW\*(C`Z_OK\*(C'\fR.
.PP
On error, \fB\f(CB$out\fB\fR will be \fIundef\fR and \fB\f(CB$status\fB\fR will contain the
\&\fIzlib\fR error code.
.PP
In a scalar context \fBbzdeflate\fR will return \fB\f(CB$out\fB\fR only.
.PP
As with the internal buffering of the \fIdeflate\fR function in \fIbzip2\fR,
it is not necessarily the case that any output will be produced by
this method. So don't rely on the fact that \fB\f(CB$out\fB\fR is empty for an
error test.  In fact, given the size of bzdeflates internal buffer,
with most files it's likely you won't see any output at all until
flush or close.
.SS "\fB($out, \fP\f(CB$status\fP\fB) = \fP\f(CB$d\fP\fB\->bzflush([flush_type])\fP"
.IX Subsection "($out, $status) = $d->bzflush([flush_type])"
Typically used to finish the deflation. Any pending output will be
returned via \fB\f(CB$out\fB\fR.  \fB\f(CB$status\fB\fR will have a value \f(CW\*(C`BZ_OK\*(C'\fR if
successful.
.PP
In a scalar context \fBbzflush\fR will return \fB\f(CB$out\fB\fR only.
.PP
Note that flushing can seriously degrade the compression ratio, so it
should only be used to terminate a decompression (using \f(CW\*(C`BZ_FLUSH\*(C'\fR) or
when you want to create a \fIfull flush point\fR (using \f(CW\*(C`BZ_FINISH\*(C'\fR).
.PP
The allowable values for \f(CW\*(C`flush_type\*(C'\fR are \f(CW\*(C`BZ_FLUSH\*(C'\fR and \f(CW\*(C`BZ_FINISH\*(C'\fR.
.PP
For a handle opened for \*(L"w\*(R" (bzwrite), the default is \f(CW\*(C`BZ_FLUSH\*(C'\fR.
For a stream, the default for \f(CW\*(C`flush_type\*(C'\fR is \f(CW\*(C`BZ_FINISH\*(C'\fR (which is
essentially a close and reopen).
.PP
It is strongly recommended that you only set the \f(CW\*(C`flush_type\*(C'\fR
parameter if you fully understand the implications of what it
does. See the \f(CW\*(C`bzip2\*(C'\fR documentation for details.
.SS "Example"
.IX Subsection "Example"
Here is a trivial example of using \fBbzdeflate\fR. It simply reads standard
input, deflates it and writes it to standard output.
.PP
.Vb 2
\&    use strict ;
\&    use warnings ;
\&
\&    use Compress::Bzip2 ;
\&
\&    binmode STDIN;
\&    binmode STDOUT;
\&    my $x = bzdeflateInit()
\&       or die "Cannot create a deflation stream\en" ;
\&
\&    my ($output, $status) ;
\&    while (<>)
\&    {
\&        ($output, $status) = $x\->bzdeflate($_) ;
\&
\&        $status == BZ_OK
\&            or die "deflation failed\en" ;
\&
\&        print $output ;
\&    }
\&
\&    ($output, $status) = $x\->bzclose() ;
\&
\&    $status == BZ_OK
\&        or die "deflation failed\en" ;
\&
\&    print $output ;
.Ve
.SH "STREAM INFLATE"
.IX Header "STREAM INFLATE"
Here is a definition of the interface:
.SS "\fB($i, \fP\f(CB$status\fP\fB) = inflateInit()\fP"
.IX Subsection "($i, $status) = inflateInit()"
Initialises an inflation stream.
.PP
In a list context it returns the inflation stream, \fB\f(CB$i\fB\fR, and the
\&\fIzlib\fR status code (\fB\f(CB$status\fB\fR). In a scalar context it returns the
inflation stream only.
.PP
If successful, \fB\f(CB$i\fB\fR will hold the inflation stream and \fB\f(CB$status\fB\fR will
be \f(CW\*(C`BZ_OK\*(C'\fR.
.PP
If not successful, \fB\f(CB$i\fB\fR will be \fIundef\fR and \fB\f(CB$status\fB\fR will hold the
\&\fIbzlib.h\fR error code.
.PP
The function optionally takes a number of named options specified as
\&\f(CW\*(C`\-Name=>value\*(C'\fR pairs. This allows individual options to be
tailored without having to specify them all in the parameter list.
.PP
For backward compatibility, it is also possible to pass the parameters
as a reference to a hash containing the name=>value pairs.
.PP
The function takes one optional parameter, a reference to a hash.  The
contents of the hash allow the deflation interface to be tailored.
.PP
Here is a list of the valid options:
.IP "\fB\-small\fR" 5
.IX Item "-small"
\&\fBsmall\fR may be 0 or 1.  Set \f(CW\*(C`small\*(C'\fR to one to use a slower, less
memory intensive algorithm.
.IP "\fB\-verbosity\fR" 5
.IX Item "-verbosity"
Defines the verbosity level. Valid values are 0 through 4,
.Sp
The default is \f(CW\*(C`\-verbosity => 0\*(C'\fR.
.PP
Here is an example of using the \fBbzinflateInit\fR optional parameter.
.PP
.Vb 1
\&    bzinflateInit( \-small => 1, \-verbosity => 1 );
.Ve
.SS "\fB($out, \fP\f(CB$status\fP\fB) = \fP\f(CB$i\fP\fB\->bzinflate($buffer)\fP"
.IX Subsection "($out, $status) = $i->bzinflate($buffer)"
Inflates the complete contents of \fB\f(CB$buffer\fB\fR. The buffer can either be
a scalar or a scalar reference.
.PP
Returns \f(CW\*(C`BZ_OK\*(C'\fR if successful and \f(CW\*(C`BZ_STREAM_END\*(C'\fR if the end of the
compressed data has been successfully reached.  If not successful,
\&\fB\f(CB$out\fB\fR will be \fIundef\fR and \fB\f(CB$status\fB\fR will hold the \fIbzlib\fR error
code.
.PP
The \f(CW$buffer\fR parameter is modified by \f(CW\*(C`bzinflate\*(C'\fR. On completion it
will contain what remains of the input buffer after inflation. This
means that \f(CW$buffer\fR will be an empty string when the return status
is \f(CW\*(C`BZ_OK\*(C'\fR. When the return status is \f(CW\*(C`BZ_STREAM_END\*(C'\fR the \f(CW$buffer\fR
parameter will contains what (if anything) was stored in the input
buffer after the deflated data stream.
.PP
This feature is useful when processing a file format that encapsulates
a compressed data stream.
.SS "Example"
.IX Subsection "Example"
Here is an example of using \fBbzinflate\fR.
.PP
.Vb 2
\&    use strict ;
\&    use warnings ;
\&
\&    use Compress::Bzip2;
\&
\&    my $x = bzinflateInit()
\&       or die "Cannot create a inflation stream\en" ;
\&
\&    my $input = \*(Aq\*(Aq ;
\&    binmode STDIN;
\&    binmode STDOUT;
\&
\&    my ($output, $status) ;
\&    while (read(STDIN, $input, 4096))
\&    {
\&        ($output, $status) = $x\->bzinflate(\e$input) ;
\&
\&        print $output
\&            if $status == BZ_OK or $status == BZ_STREAM_END ;
\&
\&        last if $status != BZ_OK ;
\&    }
\&
\&    die "inflation failed\en"
\&        unless $status == BZ_STREAM_END ;
.Ve
.SH "EXAMPLES"
.IX Header "EXAMPLES"
Here are some example scripts of using the interface.
.SS "\fBA bzcat function\fP"
.IX Subsection "A bzcat function"
.Vb 2
\&  use strict ;
\&  use warnings ;
\&
\&  use Compress::Bzip2 ;
\&
\&  die "Usage: bzcat file...\en" unless @ARGV ;
\&
\&  my $file ;
\&
\&  foreach $file (@ARGV) {
\&    my $buffer ;
\&
\&    my $bz = bzopen($file, "rb")
\&       or die "Cannot open $file: $bzerrno\en" ;
\&
\&    print $buffer while $bz\->bzread($buffer) > 0 ;
\&
\&    die "Error reading from $file: $bzerrno" . ($bzerrno+0) . "\en"
\&       if $bzerrno != BZ_STREAM_END ;
\&
\&    $bz\->bzclose() ;
\&  }
.Ve
.SS "\fBA grep using bzreadline\fP"
.IX Subsection "A grep using bzreadline"
.Vb 2
\&  use strict ;
\&  use warnings ;
\&
\&  use Compress::Bzip2 ;
\&
\&  die "Usage: bzgrep pattern file...\en" unless @ARGV >= 2;
\&
\&  my $pattern = shift ;
\&
\&  my $file ;
\&
\&  foreach $file (@ARGV) {
\&    my $bz = bzopen($file, "rb")
\&       or die "Cannot open $file: $bzerrno\en" ;
\&
\&    while ($bz\->bzreadline($_) > 0) {
\&      print if /$pattern/ ;
\&    }
\&
\&    die "Error reading from $file: $bzerrno\en"
\&      if $bzerrno != Z_STREAM_END ;
\&
\&    $bz\->bzclose() ;
\&  }
.Ve
.SS "\fBStreaming Compression\fP"
.IX Subsection "Streaming Compression"
This script, \fIbzstream\fR, does the opposite of the \fIbzcat\fR script
above. It reads from standard input and writes a bzip file to standard
output.
.PP
.Vb 2
\&  use strict ;
\&  use warnings ;
\&
\&  use Compress::Bzip2 ;
\&
\&  binmode STDOUT;       # bzopen only sets it on the fd
\&
\&  my $bz = bzopen(\e*STDOUT, "wb")
\&     or die "Cannot open stdout: $bzerrno\en" ;
\&
\&  while (<>) {
\&    $bz\->bzwrite($_) or die "error writing: $bzerrno\en" ;
\&  }
\&
\&  $bz\->bzclose ;
.Ve
.SH "EXPORT"
.IX Header "EXPORT"
Use the tags :all, :utilities, :constants, :bzip1 and :gzip.
.SS "Export tag :all"
.IX Subsection "Export tag :all"
This exports all the exportable methods.
.SS "Export tag :constants"
.IX Subsection "Export tag :constants"
This exports only the BZ_* constants.
.SS "Export tag :bzip1"
.IX Subsection "Export tag :bzip1"
This exports the Compress::Bzip2 1.x functions, for compatibility.
.PP
.Vb 5
\&   compress
\&   decompress
\&   compress_init
\&   decompress_init
\&   version
.Ve
.PP
These are actually aliases to memBzip and memBunzip.
.SS "Export tag :utilities"
.IX Subsection "Export tag :utilities"
This gives an interface to the bzip2 methods.
.PP
.Vb 10
\&    bzopen
\&    bzinflateInit
\&    bzdeflateInit
\&    memBzip
\&    memBunzip
\&    bzip2
\&    bunzip2
\&    bzcat
\&    bzlibversion
\&    $bzerrno
.Ve
.SS "Export tag :gzip"
.IX Subsection "Export tag :gzip"
This gives compatibility with Compress::Zlib.
.PP
.Vb 6
\&    gzopen
\&    gzinflateInit
\&    gzdeflateInit
\&    memGzip
\&    memGunzip
\&    $gzerrno
.Ve
.SH "Exportable constants"
.IX Header "Exportable constants"
All the \fIbzlib\fR constants are automatically imported when you make use
of \fICompress::Bzip2\fR.
.PP
.Vb 10
\&  BZ_CONFIG_ERROR
\&  BZ_DATA_ERROR
\&  BZ_DATA_ERROR_MAGIC
\&  BZ_FINISH
\&  BZ_FINISH_OK
\&  BZ_FLUSH
\&  BZ_FLUSH_OK
\&  BZ_IO_ERROR
\&  BZ_MAX_UNUSED
\&  BZ_MEM_ERROR
\&  BZ_OK
\&  BZ_OUTBUFF_FULL
\&  BZ_PARAM_ERROR
\&  BZ_RUN
\&  BZ_RUN_OK
\&  BZ_SEQUENCE_ERROR
\&  BZ_STREAM_END
\&  BZ_UNEXPECTED_EOF
.Ve
.SH "SEE ALSO"
.IX Header "SEE ALSO"
The documentation for zlib, bzip2 and Compress::Zlib.
.SH "AUTHOR"
.IX Header "AUTHOR"
Rob Janes, <arjay at cpan.org>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright (C) 2005 by Rob Janes
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself, either Perl version 5.8.3 or,
at your option, any later version of Perl 5 you may have available.
.SH "AUTHOR"
.IX Header "AUTHOR"
The \fICompress::Bzip2\fR module was originally written by Gawdi Azem
\&\fIazemgi@rupert.informatik.uni\-stuttgart.de\fR.
.PP
The first \fICompress::Bzip2\fR module was written by Gawdi Azem
\&\fIazemgi@rupert.informatik.uni\-stuttgart.de\fR.  It provided an
interface to the in memory inflate and deflate routines.
.PP
\&\fICompress::Bzip2\fR was subsequently passed on to Marco Carnut
\&\fIkiko@tempest.com.br\fR who shepherded it through to version 1.03, a
set of changes which included upgrades to handle bzlib 1.0.2, and
improvements to the in memory inflate and deflate routines.  The
streaming interface and error information were added by David Robins
\&\fIdbrobins@davidrobins.net\fR.
.PP
Version 2 of \fICompress::Bzip2\fR is due to Rob Janes, of
arjay@cpan.org.  This release is intended to give an interface
close to that of Compress::Zlib.  It's development forks from 1.00,
not 1.03, so the streaming interface is not the same as that in 1.03,
although apparently compatible as it passes the 1.03 test suite.
.PP
Minor subsequent fixes and releases were done by Reini Urban,
rurban@cpan.org.
.SH "MODIFICATION HISTORY"
.IX Header "MODIFICATION HISTORY"
See the Changes file.
.PP
2.00 Second public release of \fICompress::Bzip2\fR.
