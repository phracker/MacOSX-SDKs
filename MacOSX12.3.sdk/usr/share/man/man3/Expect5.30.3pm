.\" Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Expect 3"
.TH Expect 3 "2017-05-18" "perl v5.30.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Expect \- automate interactions with command line programs that expose a text terminal interface.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use Expect;
\&
\&  # create an Expect object by spawning another process
\&  my $exp = Expect\->spawn($command, @params)
\&    or die "Cannot spawn $command: $!\en";
\&
\&  # or by using an already opened filehandle (e.g. from Net::Telnet)
\&  my $exp = Expect\->exp_init(\e*FILEHANDLE);
\&
\&  # if you prefer the OO mindset:
\&  my $exp = Expect\->new;
\&  $exp\->raw_pty(1);
\&  $exp\->spawn($command, @parameters)
\&    or die "Cannot spawn $command: $!\en";
\&
\&  # send some string there:
\&  $exp\->send("string\en");
\&
\&  # or, for the filehandle mindset:
\&  print $exp "string\en";
\&
\&  # then do some pattern matching with either the simple interface
\&  $patidx = $exp\->expect($timeout, @match_patterns);
\&
\&  # or multi\-match on several spawned commands with callbacks,
\&  # just like the Tcl version
\&  $exp\->expect($timeout,
\&             [ qr/regex1/ => sub { my $exp = shift;
\&                       $exp\->send("response\en");
\&                       exp_continue; } ],
\&             [ "regexp2" , \e&callback, @cbparms ],
\&            );
\&
\&  # if no longer needed, do a soft_close to nicely shut down the command
\&  $exp\->soft_close();
\&
\&  # or be less patient with
\&  $exp\->hard_close();
.Ve
.PP
Expect.pm is built to either spawn a process or take an existing filehandle
and interact with it such that normally interactive tasks can be done
without operator assistance. This concept makes more sense if you are
already familiar with the versatile Tcl version of Expect.
The public functions that make up Expect.pm are:
.PP
.Vb 10
\&  Expect\->new()
\&  Expect::interconnect(@objects_to_be_read_from)
\&  Expect::test_handles($timeout, @objects_to_test)
\&  Expect::version($version_requested | undef);
\&  $object\->spawn(@command)
\&  $object\->clear_accum()
\&  $object\->set_accum($value)
\&  $object\->debug($debug_level)
\&  $object\->exp_internal(0 | 1)
\&  $object\->notransfer(0 | 1)
\&  $object\->raw_pty(0 | 1)
\&  $object\->stty(@stty_modes) # See the IO::Stty docs
\&  $object\->slave()
\&  $object\->before();
\&  $object\->match();
\&  $object\->after();
\&  $object\->matchlist();
\&  $object\->match_number();
\&  $object\->error();
\&  $object\->command();
\&  $object\->exitstatus();
\&  $object\->pty_handle();
\&  $object\->do_soft_close();
\&  $object\->restart_timeout_upon_receive(0 | 1);
\&  $object\->interact($other_object, $escape_sequence)
\&  $object\->log_group(0 | 1 | undef)
\&  $object\->log_user(0 | 1 | undef)
\&  $object\->log_file("filename" | $filehandle | \e&coderef | undef)
\&  $object\->manual_stty(0 | 1 | undef)
\&  $object\->match_max($max_buffersize or undef)
\&  $object\->pid();
\&  $object\->send_slow($delay, @strings_to_send)
\&  $object\->set_group(@listen_group_objects | undef)
\&  $object\->set_seq($sequence,\e&function,\e@parameters);
.Ve
.PP
There are several configurable package variables that affect the behavior of Expect. They are:
.PP
.Vb 8
\&  $Expect::Debug;
\&  $Expect::Exp_Internal;
\&  $Expect::IgnoreEintr;
\&  $Expect::Log_Group;
\&  $Expect::Log_Stdout;
\&  $Expect::Manual_Stty;
\&  $Expect::Multiline_Matching;
\&  $Expect::Do_Soft_Close;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
See an explanation of What is Expect <http://code-maven.com/expect>
.PP
The Expect module is a successor of Comm.pl and a descendent of Chat.pl. It
more closely resembles the Tcl Expect language than its predecessors. It
does not contain any of the networking code found in Comm.pl. I suspect this
would be obsolete anyway given the advent of IO::Socket and external tools
such as netcat.
.PP
Expect.pm is an attempt to have more of a \fBswitch()\fR & case feeling to make
decision processing more fluid.  Three separate types of debugging have
been implemented to make code production easier.
.PP
It is possible to interconnect multiple file handles (and processes) much
like Tcl's Expect. An attempt was made to enable all the features of Tcl's
Expect without forcing Tcl on the victim programmer :\-) .
.PP
Please, before you consider using Expect, read the FAQs about
\&\*(L"I want to automate password entry for su/ssh/scp/rsh/...\*(R" and
\&\*(L"I want to use Expect to automate [anything with a buzzword]...\*(R"
.SH "USAGE"
.IX Header "USAGE"
.IP "new" 4
.IX Item "new"
Creates a new Expect object, i.e. a pty.  You can change parameters on
it before actually spawning a command.  This is important if you want
to modify the terminal settings for the slave.  See \fBslave()\fR below.
The object returned is actually a reblessed IO::Pty filehandle, so see
there for additional methods.
.IP "Expect\->exp_init(\e*FILEHANDLE) \fIor\fR" 4
.IX Item "Expect->exp_init(*FILEHANDLE) or"
.PD 0
.IP "Expect\->init(\e*FILEHANDLE)" 4
.IX Item "Expect->init(*FILEHANDLE)"
.PD
Initializes \f(CW$new_handle_object\fR for use with other Expect functions. It must
be passed a \fB_reference_\fR to \s-1FILEHANDLE\s0 if you want it to work properly.
IO::File objects are preferable. Returns a reference to the newly created
object.
.Sp
You can use only real filehandles, certain tied filehandles
(e.g. Net::SSH2) that lack a \fBfileno()\fR will not work. Net::Telnet
objects can be used but have been reported to work only for certain
hosts. \s-1YMMV.\s0
.ie n .IP "Expect\->spawn($command, @parameters) \fIor\fR" 4
.el .IP "Expect\->spawn($command, \f(CW@parameters\fR) \fIor\fR" 4
.IX Item "Expect->spawn($command, @parameters) or"
.PD 0
.ie n .IP "$object\->spawn($command, @parameters) \fIor\fR" 4
.el .IP "\f(CW$object\fR\->spawn($command, \f(CW@parameters\fR) \fIor\fR" 4
.IX Item "$object->spawn($command, @parameters) or"
.ie n .IP "Expect\->new($command, @parameters)" 4
.el .IP "Expect\->new($command, \f(CW@parameters\fR)" 4
.IX Item "Expect->new($command, @parameters)"
.PD
Forks and execs \f(CW$command\fR. Returns an Expect object upon success or
\&\f(CW\*(C`undef\*(C'\fR if the fork was unsuccessful or the command could not be
found.  \fBspawn()\fR passes its parameters unchanged to Perls \fBexec()\fR, so
look there for detailed semantics.
.Sp
Note that if spawn cannot \fBexec()\fR the given command, the Expect object
is still valid and the next \fBexpect()\fR will see \*(L"Cannot exec\*(R", so you
can use that for error handling.
.Sp
Also note that you cannot reuse an object with an already spawned
command, even if that command has exited.  Sorry, but you have to
allocate a new object...
.ie n .IP "$object\->debug(0 | 1 | 2 | 3 | undef)" 4
.el .IP "\f(CW$object\fR\->debug(0 | 1 | 2 | 3 | undef)" 4
.IX Item "$object->debug(0 | 1 | 2 | 3 | undef)"
Sets debug level for \f(CW$object\fR. 1 refers to general debugging
information, 2 refers to verbose debugging and 0 refers to no
debugging. If you call \fBdebug()\fR with no parameters it will return the
current debugging level.  When the object is created the debugging
level will match that \f(CW$Expect::Debug\fR, normally 0.
.Sp
The '3' setting is new with 1.05, and adds the additional
functionality of having the _full_ accumulated buffer printed every
time data is read from an Expect object. This was implemented by
request. I recommend against using this unless you think you need it
as it can create quite a quantity of output under some circumstances..
.ie n .IP "$object\->exp_internal(1 | 0)" 4
.el .IP "\f(CW$object\fR\->exp_internal(1 | 0)" 4
.IX Item "$object->exp_internal(1 | 0)"
Sets/unsets 'exp_internal' debugging. This is similar in nature to its Tcl
counterpart. It is extremely valuable when debugging \fBexpect()\fR sequences.
When the object is created the exp_internal setting will match the value of
\&\f(CW$Expect::Exp_Internal\fR, normally 0. Returns the current setting if called
without parameters. It is highly recommended that you make use of the
debugging features lest you have angry code.
.ie n .IP "$object\->raw_pty(1 | 0)" 4
.el .IP "\f(CW$object\fR\->raw_pty(1 | 0)" 4
.IX Item "$object->raw_pty(1 | 0)"
Set pty to raw mode before spawning.  This disables echoing, \s-1CR\-\s0>\s-1LF\s0
translation and an ugly hack for broken Solaris TTYs (which send
<space><backspace> to slow things down) and thus gives a more
pipe-like behaviour (which is important if you want to transfer binary
content).  Note that this must be set \fIbefore\fR spawning the program.
.ie n .IP "$object\->stty(qw(mode1 mode2...))" 4
.el .IP "\f(CW$object\fR\->stty(qw(mode1 mode2...))" 4
.IX Item "$object->stty(qw(mode1 mode2...))"
Sets the tty mode for \f(CW$object\fR's associated terminal to the given
modes.  Note that on many systems the master side of the pty is not a
tty, so you have to modify the slave pty instead, see next item.  This
needs IO::Stty installed, which is no longer required.
.ie n .IP "$object\->\fBslave()\fR" 4
.el .IP "\f(CW$object\fR\->\fBslave()\fR" 4
.IX Item "$object->slave()"
Returns a filehandle to the slave part of the pty.  Very useful in modifying
the terminal settings:
.Sp
.Vb 1
\&  $object\->slave\->stty(qw(raw \-echo));
.Ve
.Sp
Typical values are 'sane', 'raw', and 'raw \-echo'.  Note that I
recommend setting the terminal to 'raw' or 'raw \-echo', as this avoids
a lot of hassle and gives pipe-like (i.e. transparent) behaviour
(without the buffering issue).
.ie n .IP "$object\->print(@strings) \fIor\fR" 4
.el .IP "\f(CW$object\fR\->print(@strings) \fIor\fR" 4
.IX Item "$object->print(@strings) or"
.PD 0
.ie n .IP "$object\->send(@strings)" 4
.el .IP "\f(CW$object\fR\->send(@strings)" 4
.IX Item "$object->send(@strings)"
.PD
Sends the given strings to the spawned command.  Note that the strings
are not logged in the logfile (see print_log_file) but will probably
be echoed back by the pty, depending on pty settings (default is echo)
and thus end up there anyway.  This must also be taken into account
when \fBexpect()\fRing for an answer: the next string will be the command
just sent.  I suggest setting the pty to raw, which disables echo and
makes the pty transparently act like a bidirectional pipe.
.ie n .IP "$object\->expect($timeout, @match_patterns)" 4
.el .IP "\f(CW$object\fR\->expect($timeout, \f(CW@match_patterns\fR)" 4
.IX Item "$object->expect($timeout, @match_patterns)"
.RS 4
.PD 0
.IP "Simple interface" 4
.IX Item "Simple interface"
.PD
Given \f(CW$timeout\fR in seconds Expect will wait for \f(CW$object\fR's handle to produce
one of the match_patterns, which are matched exactly by default. If you
want a regexp match, prefix the pattern with '\-re'.
.Sp
.Vb 1
\&  $object\->expect(15, \*(Aqmatch me exactly\*(Aq,\*(Aq\-re\*(Aq,\*(Aqmatch\es+me\es+exactly\*(Aq);
.Ve
.Sp
Due to o/s limitations \f(CW$timeout\fR should be a round number. If \f(CW$timeout\fR
is 0 Expect will check one time to see if \f(CW$object\fR's handle contains
any of the match_patterns. If \f(CW$timeout\fR is undef Expect
will wait forever for a pattern to match.
.Sp
If called in a scalar context, \fBexpect()\fR will return the position of
the matched pattern within \f(CW@matched_patterns\fR, or undef if no pattern was
matched. This is a position starting from 1, so if you want to know
which of an array of \f(CW@matched_patterns\fR matched you should subtract one
from the return value.
.Sp
If called in an array context \fBexpect()\fR will return
($matched_pattern_position, \f(CW$error\fR, \f(CW$successfully_matching_string\fR,
\&\f(CW$before_match\fR, and \f(CW$after_match\fR).
.Sp
\&\f(CW$matched_pattern_position\fR will contain the value that would have been
returned if \fBexpect()\fR had been called in a scalar context.
.Sp
\&\f(CW$error\fR is
the error that occurred that caused \fBexpect()\fR to return. \f(CW$error\fR will
contain a number followed by a string equivalent expressing the nature
of the error. Possible values are undef, indicating no error,
\&'1:TIMEOUT' indicating that \f(CW$timeout\fR seconds had elapsed without a
match, '2:EOF' indicating an eof was read from \f(CW$object\fR, '3: spawn
id($fileno) died' indicating that the process exited before matching
and '4:$!' indicating whatever error was set in \f(CW$ERRNO\fR during the last
read on \f(CW$object\fR's handle or during \fBselect()\fR. All handles indicated by
set_group plus \s-1STDOUT\s0 will have all data to come out of \f(CW$object\fR
printed to them during \fBexpect()\fR if log_group and log_stdout are set.
.Sp
\&\f(CW$successfully_matching_string\fR
\&\f(CW$before_match\fR
\&\f(CW$after_match\fR
.Sp
Changed from older versions is the regular expression handling. By
default now all strings passed to \fBexpect()\fR are treated as literals. To
match a regular expression pass '\-re' as a parameter in front of the
pattern you want to match as a regexp.
.Sp
This change makes it possible to match literals and regular expressions
in the same \fBexpect()\fR call.
.Sp
Also new is multiline matching. ^ will now match the beginning of
lines. Unfortunately, because perl doesn't use $/ in determining where
lines break using $ to find the end of a line frequently doesn't work. This
is because your terminal is returning \*(L"\er\en\*(R" at the end of every line. One
way to check for a pattern at the end of a line would be to use \er?$ instead
of $.
.Sp
Example: Spawning telnet to a host, you might look for the escape
character.  telnet would return to you \*(L"\er\enEscape character is
\&'^]'.\er\en\*(R". To find this you might use \f(CW$match\fR='^Escape char.*\e.\er?$';
.Sp
.Vb 1
\&  $telnet\->expect(10,\*(Aq\-re\*(Aq,$match);
.Ve
.IP "New more Tcl/Expect\-like interface" 4
.IX Item "New more Tcl/Expect-like interface"
.Vb 11
\&  expect($timeout,
\&       \*(Aq\-i\*(Aq, [ $obj1, $obj2, ... ],
\&             [ $re_pattern, sub { ...; exp_continue; }, @subparms, ],
\&             [ \*(Aqeof\*(Aq, sub { ... } ],
\&             [ \*(Aqtimeout\*(Aq, sub { ... }, \e$subparm1 ],
\&       \*(Aq\-i\*(Aq, [ $objn, ...],
\&       \*(Aq\-ex\*(Aq, $exact_pattern, sub { ... },
\&              $exact_pattern, sub { ...; exp_continue_timeout; },
\&       \*(Aq\-re\*(Aq, $re_pattern, sub { ... },
\&       \*(Aq\-i\*(Aq, \e@object_list, @pattern_list,
\&       ...);
.Ve
.Sp
It's now possible to expect on more than one connection at a time by
specifying '\f(CW\*(C`\-i\*(C'\fR' and a single Expect object or a ref to an array
containing Expect objects, e.g.
.Sp
.Vb 4
\& expect($timeout,
\&        \*(Aq\-i\*(Aq, $exp1, @patterns_1,
\&        \*(Aq\-i\*(Aq, [ $exp2, $exp3 ], @patterns_2_3,
\&       )
.Ve
.Sp
Furthermore, patterns can now be specified as array refs containing
[$regexp, sub { ...}, \f(CW@optional_subprams\fR] . When the pattern matches,
the subroutine is called with parameters ($matched_expect_obj,
\&\f(CW@optional_subparms\fR). The subroutine can return the symbol
`exp_continue' to continue the expect matching with timeout starting
anew or return the symbol `exp_continue_timeout' for continuing expect
without resetting the timeout count.
.Sp
.Vb 8
\& $exp\->expect($timeout,
\&              [ qr/username: /i, sub { my $self = shift;
\&                                       $self\->send("$username\en");
\&                                       exp_continue; }],
\&              [ qr/password: /i, sub { my $self = shift;
\&                                       $self\->send("$password\en");
\&                                       exp_continue; }],
\&             $shell_prompt);
.Ve
.Sp
`expect' is now exported by default.
.RE
.RS 4
.RE
.ie n .IP "$object\->\fBexp_before()\fR \fIor\fR" 4
.el .IP "\f(CW$object\fR\->\fBexp_before()\fR \fIor\fR" 4
.IX Item "$object->exp_before() or"
.PD 0
.ie n .IP "$object\->\fBbefore()\fR" 4
.el .IP "\f(CW$object\fR\->\fBbefore()\fR" 4
.IX Item "$object->before()"
.PD
\&\fBbefore()\fR returns the 'before' part of the last \fBexpect()\fR call. If the last
\&\fBexpect()\fR call didn't match anything, \fBexp_before()\fR will return the entire
output of the object accumulated before the \fBexpect()\fR call finished.
.Sp
Note that this is something different than Tcl Expects \fBbefore()\fR!!
.ie n .IP "$object\->\fBexp_after()\fR \fIor\fR" 4
.el .IP "\f(CW$object\fR\->\fBexp_after()\fR \fIor\fR" 4
.IX Item "$object->exp_after() or"
.PD 0
.ie n .IP "$object\->\fBafter()\fR" 4
.el .IP "\f(CW$object\fR\->\fBafter()\fR" 4
.IX Item "$object->after()"
.PD
returns the 'after' part of the last \fBexpect()\fR call. If the last
\&\fBexpect()\fR call didn't match anything, \fBexp_after()\fR will return \fBundef()\fR.
.ie n .IP "$object\->\fBexp_match()\fR \fIor\fR" 4
.el .IP "\f(CW$object\fR\->\fBexp_match()\fR \fIor\fR" 4
.IX Item "$object->exp_match() or"
.PD 0
.ie n .IP "$object\->\fBmatch()\fR" 4
.el .IP "\f(CW$object\fR\->\fBmatch()\fR" 4
.IX Item "$object->match()"
.PD
returns the string matched by the last \fBexpect()\fR call, undef if
no string was matched.
.ie n .IP "$object\->\fBexp_match_number()\fR \fIor\fR" 4
.el .IP "\f(CW$object\fR\->\fBexp_match_number()\fR \fIor\fR" 4
.IX Item "$object->exp_match_number() or"
.PD 0
.ie n .IP "$object\->\fBmatch_number()\fR" 4
.el .IP "\f(CW$object\fR\->\fBmatch_number()\fR" 4
.IX Item "$object->match_number()"
.PD
\&\fBexp_match_number()\fR returns the number of the pattern matched by the last
\&\fBexpect()\fR call. Keep in mind that the first pattern in a list of patterns is 1,
not 0. Returns undef if no pattern was matched.
.ie n .IP "$object\->\fBexp_matchlist()\fR \fIor\fR" 4
.el .IP "\f(CW$object\fR\->\fBexp_matchlist()\fR \fIor\fR" 4
.IX Item "$object->exp_matchlist() or"
.PD 0
.ie n .IP "$object\->\fBmatchlist()\fR" 4
.el .IP "\f(CW$object\fR\->\fBmatchlist()\fR" 4
.IX Item "$object->matchlist()"
.PD
\&\fBexp_matchlist()\fR returns a list of matched substrings from the brackets
() inside the regexp that last matched. ($object\->matchlist)[0]
thus corresponds to \f(CW$1\fR, ($object\->matchlist)[1] to \f(CW$2\fR, etc.
.ie n .IP "$object\->\fBexp_error()\fR \fIor\fR" 4
.el .IP "\f(CW$object\fR\->\fBexp_error()\fR \fIor\fR" 4
.IX Item "$object->exp_error() or"
.PD 0
.ie n .IP "$object\->\fBerror()\fR" 4
.el .IP "\f(CW$object\fR\->\fBerror()\fR" 4
.IX Item "$object->error()"
.PD
\&\fBexp_error()\fR returns the error generated by the last \fBexpect()\fR call if
no pattern was matched. It is typically useful to examine the value returned by
\&\fBbefore()\fR to find out what the output of the object was in determining
why it didn't match any of the patterns.
.ie n .IP "$object\->\fBclear_accum()\fR" 4
.el .IP "\f(CW$object\fR\->\fBclear_accum()\fR" 4
.IX Item "$object->clear_accum()"
Clear the contents of the accumulator for \f(CW$object\fR. This gets rid of
any residual contents of a handle after \fBexpect()\fR or \fBsend_slow()\fR such
that the next \fBexpect()\fR call will only see new data from \f(CW$object\fR. The
contents of the accumulator are returned.
.ie n .IP "$object\->set_accum($value)" 4
.el .IP "\f(CW$object\fR\->set_accum($value)" 4
.IX Item "$object->set_accum($value)"
Sets the content of the accumulator for \f(CW$object\fR to \f(CW$value\fR. The
previous content of the accumulator is returned.
.ie n .IP "$object\->\fBexp_command()\fR \fIor\fR" 4
.el .IP "\f(CW$object\fR\->\fBexp_command()\fR \fIor\fR" 4
.IX Item "$object->exp_command() or"
.PD 0
.ie n .IP "$object\->\fBcommand()\fR" 4
.el .IP "\f(CW$object\fR\->\fBcommand()\fR" 4
.IX Item "$object->command()"
.PD
\&\fBexp_command()\fR returns the string that was used to spawn the command. Helpful
for debugging and for reused patternmatch subroutines.
.ie n .IP "$object\->\fBexp_exitstatus()\fR \fIor\fR" 4
.el .IP "\f(CW$object\fR\->\fBexp_exitstatus()\fR \fIor\fR" 4
.IX Item "$object->exp_exitstatus() or"
.PD 0
.ie n .IP "$object\->\fBexitstatus()\fR" 4
.el .IP "\f(CW$object\fR\->\fBexitstatus()\fR" 4
.IX Item "$object->exitstatus()"
.PD
Returns the exit status of \f(CW$object\fR (if it already exited).
.ie n .IP "$object\->\fBexp_pty_handle()\fR \fIor\fR" 4
.el .IP "\f(CW$object\fR\->\fBexp_pty_handle()\fR \fIor\fR" 4
.IX Item "$object->exp_pty_handle() or"
.PD 0
.ie n .IP "$object\->\fBpty_handle()\fR" 4
.el .IP "\f(CW$object\fR\->\fBpty_handle()\fR" 4
.IX Item "$object->pty_handle()"
.PD
Returns a string representation of the attached pty, for example:
`spawn \fBid\fR\|(5)' (pty has fileno 5), `handle \fBid\fR\|(7)' (pty was initialized
from fileno 7) or `\s-1STDIN\s0'. Useful for debugging.
.ie n .IP "$object\->restart_timeout_upon_receive(0 | 1)" 4
.el .IP "\f(CW$object\fR\->restart_timeout_upon_receive(0 | 1)" 4
.IX Item "$object->restart_timeout_upon_receive(0 | 1)"
If this is set to 1, the expect timeout is retriggered whenever something
is received from the spawned command.  This allows to perform some
aliveness testing and still expect for patterns.
.Sp
.Vb 5
\&    $exp\->restart_timeout_upon_receive(1);
\&    $exp\->expect($timeout,
\&                 [ timeout => \e&report_timeout ],
\&                 [ qr/pattern/ => \e&handle_pattern],
\&                );
.Ve
.Sp
Now the timeout isn't triggered if the command produces any kind of output,
i.e. is still alive, but you can act upon patterns in the output.
.ie n .IP "$object\->notransfer(1 | 0)" 4
.el .IP "\f(CW$object\fR\->notransfer(1 | 0)" 4
.IX Item "$object->notransfer(1 | 0)"
Do not truncate the content of the accumulator after a match.
Normally, the accumulator is set to the remains that come after the
matched string.  Note that this setting is per object and not per
pattern, so if you want to have normal acting patterns that truncate
the accumulator, you have to add a
.Sp
.Vb 1
\&    $exp\->set_accum($exp\->after);
.Ve
.Sp
to their callback, e.g.
.Sp
.Vb 12
\&    $exp\->notransfer(1);
\&    $exp\->expect($timeout,
\&                 # accumulator not truncated, pattern1 will match again
\&                 [ "pattern1" => sub { my $self = shift;
\&                                       ...
\&                                     } ],
\&                 # accumulator truncated, pattern2 will not match again
\&                 [ "pattern2" => sub { my $self = shift;
\&                                       ...
\&                                       $self\->set_accum($self\->after());
\&                                     } ],
\&                );
.Ve
.Sp
This is only a temporary fix until I can rewrite the pattern matching
part so it can take that additional \-notransfer argument.
.IP "Expect::interconnect(@objects);" 4
.IX Item "Expect::interconnect(@objects);"
Read from \f(CW@objects\fR and print to their \f(CW@listen_groups\fR until an escape sequence
is matched from one of \f(CW@objects\fR and the associated function returns 0 or undef.
The special escape sequence '\s-1EOF\s0' is matched when an object's handle returns
an end of file. Note that it is not necessary to include objects that only
accept data in \f(CW@objects\fR since the escape sequence is _read_ from an object.
Further note that the listen_group for a write-only object is always empty.
Why would you want to have objects listening to \s-1STDOUT\s0 (for example)?
By default every member of \f(CW@objects\fR _as well as every member of its listen
group_ will be set to 'raw \-echo' for the duration of interconnection.
Setting \f(CW$object\fR\->\fBmanual_stty()\fR will stop this behavior per object.
The original tty settings will be restored as interconnect exits.
.Sp
For a generic way to interconnect processes, take a look at IPC::Run.
.IP "Expect::test_handles(@objects)" 4
.IX Item "Expect::test_handles(@objects)"
Given a set of objects determines which objects' handles have data ready
to be read. \fBReturns an array\fR who's members are positions in \f(CW@objects\fR that
have ready handles. Returns undef if there are no such handles ready.
.IP "Expect::version($version_requested or undef);" 4
.IX Item "Expect::version($version_requested or undef);"
Returns current version of Expect. As of .99 earlier versions are not
supported. Too many things were changed to make versioning possible.
.ie n .IP "$object\->interact( ""\e*FILEHANDLE, $escape_sequence"")" 4
.el .IP "\f(CW$object\fR\->interact( \f(CW\e*FILEHANDLE, $escape_sequence\fR)" 4
.IX Item "$object->interact( *FILEHANDLE, $escape_sequence)"
\&\fBinteract()\fR is essentially a macro for calling \fBinterconnect()\fR for
connecting 2 processes together. \e*FILEHANDLE defaults to \e*STDIN and
\&\f(CW$escape_sequence\fR defaults to undef. Interaction ceases when \f(CW$escape_sequence\fR
is read from \fB\s-1FILEHANDLE\s0\fR, not \f(CW$object\fR. \f(CW$object\fR's listen group will
consist solely of \e*FILEHANDLE for the duration of the interaction.
\&\e*FILEHANDLE will not be echoed on \s-1STDOUT.\s0
.ie n .IP "$object\->log_group(0 | 1 | undef)" 4
.el .IP "\f(CW$object\fR\->log_group(0 | 1 | undef)" 4
.IX Item "$object->log_group(0 | 1 | undef)"
Set/unset logging of \f(CW$object\fR to its 'listen group'. If set all objects
in the listen group will have output from \f(CW$object\fR printed to them during
\&\f(CW$object\fR\->\fBexpect()\fR, \f(CW$object\fR\->\fBsend_slow()\fR, and \f(CW\*(C`Expect::interconnect($object
, ...)\*(C'\fR. Default value is on. During creation of \f(CW$object\fR the setting will
match the value of \f(CW$Expect::Log_Group\fR, normally 1.
.ie n .IP "$object\->log_user(0 | 1 | undef) \fIor\fR" 4
.el .IP "\f(CW$object\fR\->log_user(0 | 1 | undef) \fIor\fR" 4
.IX Item "$object->log_user(0 | 1 | undef) or"
.PD 0
.ie n .IP "$object\->log_stdout(0 | 1 | undef)" 4
.el .IP "\f(CW$object\fR\->log_stdout(0 | 1 | undef)" 4
.IX Item "$object->log_stdout(0 | 1 | undef)"
.PD
Set/unset logging of object's handle to \s-1STDOUT.\s0 This corresponds to Tcl's
log_user variable. Returns current setting if called without parameters.
Default setting is off for initialized handles.  When a process object is
created (not a filehandle initialized with exp_init) the log_stdout setting
will match the value of \f(CW$Expect::Log_Stdout\fR variable, normally 1.
If/when you initialize \s-1STDIN\s0 it is usually associated with a tty which
will by default echo to \s-1STDOUT\s0 anyway, so be careful or you will have
multiple echoes.
.ie n .IP "$object\->log_file(""filename"" | $filehandle | \e&coderef | undef)" 4
.el .IP "\f(CW$object\fR\->log_file(``filename'' | \f(CW$filehandle\fR | \e&coderef | undef)" 4
.IX Item "$object->log_file(filename | $filehandle | &coderef | undef)"
Log session to a file.  All characters send to or received from the
spawned process are written to the file.  Normally appends to the
logfile, but you can pass an additional mode of \*(L"w\*(R" to truncate the
file upon \fBopen()\fR:
.Sp
.Vb 1
\&  $object\->log_file("filename", "w");
.Ve
.Sp
Returns the logfilehandle.
.Sp
If called with an undef value, stops logging and closes logfile:
.Sp
.Vb 1
\&  $object\->log_file(undef);
.Ve
.Sp
If called without argument, returns the logfilehandle:
.Sp
.Vb 1
\&  $fh = $object\->log_file();
.Ve
.Sp
Can be set to a code ref, which will be called instead of printing
to the logfile:
.Sp
.Vb 1
\&  $object\->log_file(\e&myloggerfunc);
.Ve
.ie n .IP "$object\->print_log_file(@strings)" 4
.el .IP "\f(CW$object\fR\->print_log_file(@strings)" 4
.IX Item "$object->print_log_file(@strings)"
Prints to logfile (if opened) or calls the logfile hook function.
This allows the user to add arbitrary text to the logfile.  Note that
this could also be done as \f(CW$object\fR\->log_file\->\fBprint()\fR but would only
work for log files, not code hooks.
.ie n .IP "$object\->set_seq($sequence, \e&function, \e@function_parameters)" 4
.el .IP "\f(CW$object\fR\->set_seq($sequence, \e&function, \e@function_parameters)" 4
.IX Item "$object->set_seq($sequence, &function, @function_parameters)"
During Expect\->\fBinterconnect()\fR if \f(CW$sequence\fR is read from \f(CW$object\fR &function
will be executed with parameters \f(CW@function_parameters\fR. It is \fB_highly
recommended_\fR that the escape sequence be a single character since the
likelihood is great that the sequence will be broken into to separate reads
from the \f(CW$object\fR's handle, making it impossible to strip \f(CW$sequence\fR from
getting printed to \f(CW$object\fR's listen group. \e&function should be something
like 'main::control_w_function' and \f(CW@function_parameters\fR should be an
array defined by the caller, passed by reference to \fBset_seq()\fR.
Your function should return a non-zero value if execution of \fBinterconnect()\fR
is to resume after the function returns, zero or undefined if \fBinterconnect()\fR
should return after your function returns.
The special sequence '\s-1EOF\s0' matches the end of file being reached by \f(CW$object\fR.
See \fBinterconnect()\fR for details.
.ie n .IP "$object\->set_group(@listener_objects)" 4
.el .IP "\f(CW$object\fR\->set_group(@listener_objects)" 4
.IX Item "$object->set_group(@listener_objects)"
\&\f(CW@listener_objects\fR is the list of objects that should have their handles
printed to by \f(CW$object\fR when Expect::interconnect, \f(CW$object\fR\->\fBexpect()\fR or
\&\f(CW$object\fR\->\fBsend_slow()\fR are called. Calling w/out parameters will return
the current list of the listener objects.
.ie n .IP "$object\->manual_stty(0 | 1 | undef)" 4
.el .IP "\f(CW$object\fR\->manual_stty(0 | 1 | undef)" 4
.IX Item "$object->manual_stty(0 | 1 | undef)"
Sets/unsets whether or not Expect should make reasonable guesses as to
when and how to set tty parameters for \f(CW$object\fR. Will match
\&\f(CW$Expect::Manual_Stty\fR value (normally 0) when \f(CW$object\fR is created. If called
without parameters \fBmanual_stty()\fR will return the current manual_stty setting.
.ie n .IP "$object\->match_max($maximum_buffer_length | undef) \fIor\fR" 4
.el .IP "\f(CW$object\fR\->match_max($maximum_buffer_length | undef) \fIor\fR" 4
.IX Item "$object->match_max($maximum_buffer_length | undef) or"
.PD 0
.ie n .IP "$object\->max_accum($maximum_buffer_length | undef)" 4
.el .IP "\f(CW$object\fR\->max_accum($maximum_buffer_length | undef)" 4
.IX Item "$object->max_accum($maximum_buffer_length | undef)"
.PD
Set the maximum accumulator size for object. This is useful if you think
that the accumulator will grow out of hand during \fBexpect()\fR calls. Since
the buffer will be matched by every match_pattern it may get slow if the
buffer gets too large. Returns current value if called without parameters.
Not defined by default.
.ie n .IP "$object\->notransfer(0 | 1)" 4
.el .IP "\f(CW$object\fR\->notransfer(0 | 1)" 4
.IX Item "$object->notransfer(0 | 1)"
If set, matched strings will not be deleted from the accumulator.
Returns current value if called without parameters.  False by default.
.ie n .IP "$object\->\fBexp_pid()\fR \fIor\fR" 4
.el .IP "\f(CW$object\fR\->\fBexp_pid()\fR \fIor\fR" 4
.IX Item "$object->exp_pid() or"
.PD 0
.ie n .IP "$object\->\fBpid()\fR" 4
.el .IP "\f(CW$object\fR\->\fBpid()\fR" 4
.IX Item "$object->pid()"
.PD
Return pid of \f(CW$object\fR, if one exists. Initialized filehandles will not have
pids (of course).
.ie n .IP "$object\->send_slow($delay, @strings);" 4
.el .IP "\f(CW$object\fR\->send_slow($delay, \f(CW@strings\fR);" 4
.IX Item "$object->send_slow($delay, @strings);"
print each character from each string of \f(CW@strings\fR one at a time with \f(CW$delay\fR
seconds before each character. This is handy for devices such as modems
that can be annoying if you send them data too fast. After each character
\&\f(CW$object\fR will be checked to determine whether or not it has any new data ready
and if so update the accumulator for future \fBexpect()\fR calls and print the
output to \s-1STDOUT\s0 and \f(CW@listen_group\fR if log_stdout and log_group are
appropriately set.
.SS "Configurable Package Variables:"
.IX Subsection "Configurable Package Variables:"
.ie n .IP "$Expect::Debug" 4
.el .IP "\f(CW$Expect::Debug\fR" 4
.IX Item "$Expect::Debug"
Defaults to 0. Newly created objects have a \f(CW$object\fR\->\fBdebug()\fR value
of \f(CW$Expect::Debug\fR. See \f(CW$object\fR\->\fBdebug()\fR;
.ie n .IP "$Expect::Do_Soft_Close" 4
.el .IP "\f(CW$Expect::Do_Soft_Close\fR" 4
.IX Item "$Expect::Do_Soft_Close"
Defaults to 0. When destroying objects, soft_close may take up to half
a minute to shut everything down.  From now on, only hard_close will
be called, which is less polite but still gives the process a chance
to terminate properly.  Set this to '1' for old behaviour.
.ie n .IP "$Expect::Exp_Internal" 4
.el .IP "\f(CW$Expect::Exp_Internal\fR" 4
.IX Item "$Expect::Exp_Internal"
Defaults to 0. Newly created objects have a \f(CW$object\fR\->\fBexp_internal()\fR
value of \f(CW$Expect::Exp_Internal\fR. See \f(CW$object\fR\->\fBexp_internal()\fR.
.ie n .IP "$Expect::IgnoreEintr" 4
.el .IP "\f(CW$Expect::IgnoreEintr\fR" 4
.IX Item "$Expect::IgnoreEintr"
Defaults to 0. If set to 1, when waiting for new data, Expect will
ignore \s-1EINTR\s0 errors and restart the \fBselect()\fR call instead.
.ie n .IP "$Expect::Log_Group" 4
.el .IP "\f(CW$Expect::Log_Group\fR" 4
.IX Item "$Expect::Log_Group"
Defaults to 1. Newly created objects have a \f(CW$object\fR\->\fBlog_group()\fR
value of \f(CW$Expect::Log_Group\fR. See \f(CW$object\fR\->\fBlog_group()\fR.
.ie n .IP "$Expect::Log_Stdout" 4
.el .IP "\f(CW$Expect::Log_Stdout\fR" 4
.IX Item "$Expect::Log_Stdout"
Defaults to 1 for spawned commands, 0 for file handles
attached with \fBexp_init()\fR. Newly created objects have a
\&\f(CW$object\fR\->\fBlog_stdout()\fR value of \f(CW$Expect::Log_Stdout\fR. See
\&\f(CW$object\fR\->\fBlog_stdout()\fR.
.ie n .IP "$Expect::Manual_Stty" 4
.el .IP "\f(CW$Expect::Manual_Stty\fR" 4
.IX Item "$Expect::Manual_Stty"
Defaults to 0. Newly created objects have a \f(CW$object\fR\->\fBmanual_stty()\fR
value of \f(CW$Expect::Manual_Stty\fR. See \f(CW$object\fR\->\fBmanual_stty()\fR.
.ie n .IP "$Expect::Multiline_Matching" 4
.el .IP "\f(CW$Expect::Multiline_Matching\fR" 4
.IX Item "$Expect::Multiline_Matching"
Defaults to 1. Affects whether or not \fBexpect()\fR uses the /m flag for
doing regular expression matching. If set to 1 /m is used.
.Sp
This makes a difference when you are trying to match ^ and $. If
you have this on you can match lines in the middle of a page of output
using ^ and $ instead of it matching the beginning and end of the entire
expression. I think this is handy.
.Sp
The \f(CW$Expect::Multiline_Matching\fR turns on and off Expect's multi-line
matching mode. But this only has an effect if you pass in a string, and
then use '\-re' mode. If you pass in a regular expression value (via
qr//), then the qr//'s own flags are preserved irrespective of what it
gets interpolated into. There was a bug in Perl 5.8.x where interpolating
a regex without /m into a match with /m would incorrectly apply the /m
to the inner regex too, but this was fixed in Perl 5.10. The correct
behavior, as seen in Perl 5.10, is that if you pass in a regex (via
qr//), then \f(CW$Expect::Multiline_Matching\fR has no effect. 
So if you pass in a regex, then you must use the qr's flags
to control whether it is multiline (which by default it is not, opposite
of the default behavior of Expect).
.SH "CONTRIBUTIONS"
.IX Header "CONTRIBUTIONS"
Lee Eakin <leakin@japh.itg.ti.com> has ported the kibitz script
from Tcl/Expect to Perl/Expect.
.PP
Jeff Carr <jcarr@linuxmachines.com> provided a simple example of how
handle terminal window resize events (transmitted via the \s-1WINCH\s0
signal) in a ssh session.
.PP
You can find both scripts in the examples/ subdir.  Thanks to both!
.PP
Historical notes:
.PP
There are still a few lines of code dating back to the inspirational
Comm.pl and Chat.pl modules without which this would not have been possible.
Kudos to Eric Arnold <Eric.Arnold@Sun.com> and Randal 'Nuke your \s-1NT\s0 box with
one line of perl code' Schwartz<merlyn@stonehenge.com> for making these
available to the perl public.
.PP
As of .98 I think all the old code is toast. No way could this have been done
without it though. Special thanks to Graham Barr for helping make sense of
the IO::Handle stuff as well as providing the highly recommended IO::Tty
module.
.SH "REFERENCES"
.IX Header "REFERENCES"
Mark Rogaski <rogaski@att.com> wrote:
.PP
\&\*(L"I figured that you'd like to know that Expect.pm has been very
useful to \s-1AT&T\s0 Labs over the past couple of years (since I first talked to
Austin about design decisions). We use Expect.pm for managing
the switches in our network via the telnet interface, and such automation
has significantly increased our reliability. So, you can honestly say that
one of the largest digital networks in existence (\s-1AT&T\s0 Frame Relay) uses
Expect.pm quite extensively.\*(R"
.SH "FAQ \- Frequently Asked Questions"
.IX Header "FAQ - Frequently Asked Questions"
This is a growing collection of things that might help.
Please send you questions that are not answered here to
RGiersig@cpan.org
.SS "What systems does Expect run on?"
.IX Subsection "What systems does Expect run on?"
Expect itself doesn't have real system dependencies, but the underlying
IO::Tty needs pseudoterminals. IO::Stty uses \s-1POSIX\s0.pm and Fcntl.pm.
.PP
I have used it on Solaris, Linux and \s-1AIX,\s0 others report *BSD and \s-1OSF\s0
as working.  Generally, any modern \s-1POSIX\s0 Unix should do, but there
are exceptions to every rule.  Feedback is appreciated.
.PP
See IO::Tty for a list of verified systems.
.SS "Can I use this module with ActivePerl on Windows?"
.IX Subsection "Can I use this module with ActivePerl on Windows?"
Up to now, the answer was 'No', but this has changed.
.PP
You still cannot use ActivePerl, but if you use the Cygwin environment
(http://sources.redhat.com), which brings its own perl, and have
the latest IO::Tty (v0.05 or later) installed, it should work (feedback
appreciated).
.SS "The examples in the tutorial don't work!"
.IX Subsection "The examples in the tutorial don't work!"
The tutorial is hopelessly out of date and needs a serious overhaul.
I apologize for this, I have concentrated my efforts mainly on the
functionality.  Volunteers welcomed.
.SS "How can I find out what Expect is doing?"
.IX Subsection "How can I find out what Expect is doing?"
If you set
.PP
.Vb 1
\&  $Expect::Exp_Internal = 1;
.Ve
.PP
Expect will tell you very verbosely what it is receiving and sending,
what matching it is trying and what it found.  You can do this on a
per-command base with
.PP
.Vb 1
\&  $exp\->exp_internal(1);
.Ve
.PP
You can also set
.PP
.Vb 1
\&  $Expect::Debug = 1;  # or 2, 3 for more verbose output
.Ve
.PP
or
.PP
.Vb 1
\&  $exp\->debug(1);
.Ve
.PP
which gives you even more output.
.SS "I am seeing the output of the command I spawned.  Can I turn that off?"
.IX Subsection "I am seeing the output of the command I spawned. Can I turn that off?"
Yes, just set
.PP
.Vb 1
\&  $Expect::Log_Stdout = 0;
.Ve
.PP
to globally disable it or
.PP
.Vb 1
\&   $exp\->log_stdout(0);
.Ve
.PP
for just that command.  'log_user' is provided as an alias so
Tcl/Expect user get a \s-1DWIM\s0 experience... :\-)
.SS "No, I mean that when I send some text to the spawned process, it gets echoed back and I have to deal with it in the next expect."
.IX Subsection "No, I mean that when I send some text to the spawned process, it gets echoed back and I have to deal with it in the next expect."
This is caused by the pty, which has probably 'echo' enabled.  A
solution would be to set the pty to raw mode, which in general is
cleaner for communication between two programs (no more unexpected
character translations).  Unfortunately this would break a lot of old
code that sends \*(L"\er\*(R" to the program instead of \*(L"\en\*(R" (translating this
is also handled by the pty), so I won't add this to Expect just like that.
But feel free to experiment with \f(CW\*(C`$exp\->raw_pty(1)\*(C'\fR.
.SS "How do I send control characters to a process?"
.IX Subsection "How do I send control characters to a process?"
A: You can send any characters to a process with the print command. To
represent a control character in Perl, use \ec followed by the letter. For
example, control-G can be represented with \*(L"\ecG\*(R" . Note that this will not
work if you single-quote your string. So, to send control-C to a process in
\&\f(CW$exp\fR, do:
.PP
.Vb 1
\&  print $exp "\ecC";
.Ve
.PP
Or, if you prefer:
.PP
.Vb 1
\&  $exp\->send("\ecC");
.Ve
.PP
The ability to include control characters in a string like this is provided
by Perl, not by Expect.pm . Trying to learn Expect.pm without a thorough
grounding in Perl can be very daunting. We suggest you look into some of
the excellent Perl learning material, such as the books _Programming Perl_
and _Learning Perl_ by O'Reilly, as well as the extensive online Perl
documentation available through the perldoc command.
.SS "My script fails from time to time without any obvious reason.  It seems that I am sometimes loosing output from the spawned program."
.IX Subsection "My script fails from time to time without any obvious reason. It seems that I am sometimes loosing output from the spawned program."
You could be exiting too fast without giving the spawned program
enough time to finish.  Try adding \f(CW$exp\fR\->\fBsoft_close()\fR to terminate the
program gracefully or do an \fBexpect()\fR for 'eof'.
.PP
Alternatively, try adding a 'sleep 1' after you \fBspawn()\fR the program.
It could be that pty creation on your system is just slow (but this is
rather improbable if you are using the latest IO-Tty).
.SS "I want to automate password entry for su/ssh/scp/rsh/..."
.IX Subsection "I want to automate password entry for su/ssh/scp/rsh/..."
You shouldn't use Expect for this.  Putting passwords, especially
root passwords, into scripts in clear text can mean severe security
problems.  I strongly recommend using other means.  For 'su', consider
switching to 'sudo', which gives you root access on a per-command and
per-user basis without the need to enter passwords.  'ssh'/'scp' can be
set up with \s-1RSA\s0 authentication without passwords.  'rsh' can use
the .rhost mechanism, but I'd strongly suggest to switch to 'ssh'; to
mention 'rsh' and 'security' in the same sentence makes an oxymoron.
.PP
It will work for 'telnet', though, and there are valid uses for it,
but you still might want to consider using 'ssh', as keeping cleartext
passwords around is very insecure.
.SS "I want to use Expect to automate [anything with a buzzword]..."
.IX Subsection "I want to use Expect to automate [anything with a buzzword]..."
Are you sure there is no other, easier way?  As a rule of thumb,
Expect is useful for automating things that expect to talk to a human,
where no formal standard applies.  For other tasks that do follow a
well-defined protocol, there are often better-suited modules that
already can handle those protocols.  Don't try to do \s-1HTTP\s0 requests by
spawning telnet to port 80, use \s-1LWP\s0 instead.  To automate \s-1FTP,\s0 take a
look at Net::FTP or \f(CW\*(C`ncftp\*(C'\fR (http://www.ncftp.org).  You don't use
a screwdriver to hammer in your nails either, or do you?
.SS "Is it possible to use threads with Expect?"
.IX Subsection "Is it possible to use threads with Expect?"
Basically yes, with one restriction: you must \fBspawn()\fR your programs in
the main thread and then pass the Expect objects to the handling
threads. The reason is that \fBspawn()\fR uses \fBfork()\fR, and perlthrtut:
.PP
.Vb 1
\&  "Thinking of mixing fork() and threads?  Please lie down and wait until the feeling passes."
.Ve
.SS "I want to log the whole session to a file."
.IX Subsection "I want to log the whole session to a file."
Use
.PP
.Vb 1
\&  $exp\->log_file("filename");
.Ve
.PP
or
.PP
.Vb 1
\&  $exp\->log_file($filehandle);
.Ve
.PP
or even
.PP
.Vb 1
\&  $exp\->log_file(\e&log_procedure);
.Ve
.PP
for maximum flexibility.
.PP
Note that the logfile is appended to by default, but you can
specify an optional mode \*(L"w\*(R" to truncate the logfile:
.PP
.Vb 1
\&  $exp\->log_file("filename", "w");
.Ve
.PP
To stop logging, just call it with a false argument:
.PP
.Vb 1
\&  $exp\->log_file(undef);
.Ve
.SS "How can I turn off multi-line matching for my regexps?"
.IX Subsection "How can I turn off multi-line matching for my regexps?"
To globally unset multi-line matching for all regexps:
.PP
.Vb 1
\&  $Expect::Multiline_Matching = 0;
.Ve
.PP
You can do that on a per-regexp basis by stating \f(CW\*(C`(?\-m)\*(C'\fR inside the regexp
(you need perl5.00503 or later for that).
.SS "How can I expect on multiple spawned commands?"
.IX Subsection "How can I expect on multiple spawned commands?"
You can use the \fB\-i\fR parameter to specify a single object or a list
of Expect objects.  All following patterns will be evaluated against
that list.
.PP
You can specify \fB\-i\fR multiple times to create groups of objects
and patterns to match against within the same expect statement.
.PP
This works just like in Tcl/Expect.
.PP
See the source example below.
.SS "I seem to have problems with ptys!"
.IX Subsection "I seem to have problems with ptys!"
Well, pty handling is really a black magic, as it is extremely system
dependent.  I have extensively revised IO-Tty, so these problems
should be gone.
.PP
If your system is listed in the \*(L"verified\*(R" list of IO::Tty, you
probably have some non-standard setup, e.g. you compiled your
Linux-kernel yourself and disabled ptys.  Please ask your friendly
sysadmin for help.
.PP
If your system is not listed, unpack the latest version of IO::Tty,
do a 'perl Makefile.PL; make; make test; uname \f(CW\*(C`\-a\*(C'\fR' and send me the
results and I'll see what I can deduce from that.
.SS "I just want to read the output of a process without \fBexpect()\fPing anything. How can I do this?"
.IX Subsection "I just want to read the output of a process without expect()ing anything. How can I do this?"
[ Are you sure you need Expect for this?  How about \fBqx()\fR or open(\*(L"prog|\*(R")? ]
.PP
By using expect without any patterns to match.
.PP
.Vb 3
\&  $process\->expect(undef); # Forever until EOF
\&  $process\->expect($timeout); # For a few seconds
\&  $process\->expect(0); # Is there anything ready on the handle now?
.Ve
.SS "Ok, so now how do I get what was read on the handle?"
.IX Subsection "Ok, so now how do I get what was read on the handle?"
.Vb 1
\&  $read = $process\->before();
.Ve
.SS "Where's IO::Pty?"
.IX Subsection "Where's IO::Pty?"
Find it on \s-1CPAN\s0 as IO-Tty, which provides both.
.SS "How come when I automate the passwd program to change passwords for me passwd dies before changing the password sometimes/every time?"
.IX Subsection "How come when I automate the passwd program to change passwords for me passwd dies before changing the password sometimes/every time?"
What's happening is you are closing the handle before passwd exits.
When you close the handle to a process, it is sent a signal (\s-1SIGPIPE\s0?)
telling it that \s-1STDOUT\s0 has gone away. The default behavior for
processes is to die in this circumstance. Two ways you can make this
not happen are:
.PP
.Vb 1
\&  $process\->soft_close();
.Ve
.PP
This will wait 15 seconds for a process to come up with an \s-1EOF\s0 by
itself before killing it.
.PP
.Vb 1
\&  $process\->expect(undef);
.Ve
.PP
This will wait forever for the process to match an empty set of
patterns. It will return when the process hits an \s-1EOF.\s0
.PP
As a rule, you should always \fBexpect()\fR the result of your transaction
before you continue with processing.
.SS "How come when I try to make a logfile with \fBlog_file()\fP or \fBset_group()\fP it doesn't print anything after the last time I run \fBexpect()\fP?"
.IX Subsection "How come when I try to make a logfile with log_file() or set_group() it doesn't print anything after the last time I run expect()?"
Output is only printed to the logfile/group when Expect reads from the
process, during \fBexpect()\fR, \fBsend_slow()\fR and \fBinterconnect()\fR.
One way you can force this is to make use of
.PP
.Vb 1
\&  $process\->expect(undef);
.Ve
.PP
and
.PP
.Vb 1
\&  $process\->expect(0);
.Ve
.PP
which will make \fBexpect()\fR run with an empty pattern set forever or just
for an instant to capture the output of \f(CW$process\fR. The output is
available in the accumulator, so you can grab it using
\&\f(CW$process\fR\->\fBbefore()\fR.
.SS "I seem to have problems with terminal settings, double echoing, etc."
.IX Subsection "I seem to have problems with terminal settings, double echoing, etc."
Tty settings are a major pain to keep track of. If you find unexpected
behavior such as double-echoing or a frozen session, doublecheck the
documentation for default settings. When in doubt, handle them
yourself using \f(CW$exp\fR\->\fBstty()\fR and \fBmanual_stty()\fR functions.  As of .98
you shouldn't have to worry about stty settings getting fouled unless
you use interconnect or intentionally change them (like doing \-echo to
get a password).
.PP
If you foul up your terminal's tty settings, kill any hung processes
and enter 'stty sane' at a shell prompt. This should make your
terminal manageable again.
.PP
Note that IO::Tty returns ptys with your systems default setting
regarding echoing, \s-1CRLF\s0 translation etc. and Expect does not change
them.  I have considered setting the ptys to 'raw' without any
translation whatsoever, but this would break a lot of existing things,
as '\er' translation would not work anymore.  On the other hand, a raw
pty works much like a pipe and is more \s-1WYGIWYE\s0 (what you get is what
you expect), so I suggest you set it to 'raw' by yourself:
.PP
.Vb 3
\&  $exp = Expect\->new;
\&  $exp\->raw_pty(1);
\&  $exp\->spawn(...);
.Ve
.PP
To disable echo:
.PP
.Vb 1
\&  $exp\->slave\->stty(qw(\-echo));
.Ve
.SS "I'm spawning a telnet/ssh session and then let the user interact with it.  But screen-oriented applications on the other side don't work properly."
.IX Subsection "I'm spawning a telnet/ssh session and then let the user interact with it. But screen-oriented applications on the other side don't work properly."
You have to set the terminal screen size for that.  Luckily, IO::Pty
already has a method for that, so modify your code to look like this:
.PP
.Vb 3
\&  my $exp = Expect\->new;
\&  $exp\->slave\->clone_winsize_from(\e*STDIN);
\&  $exp\->spawn("telnet somehost);
.Ve
.PP
Also, some applications need the \s-1TERM\s0 shell variable set so they know
how to move the cursor across the screen.  When logging in, the remote
shell sends a query (Ctrl-Z I think) and expects the terminal to
answer with a string, e.g. 'xterm'.  If you really want to go that way
(be aware, madness lies at its end), you can handle that and send back
the value in \f(CW$ENV\fR{\s-1TERM\s0}.  This is only a hand-waving explanation,
please figure out the details by yourself.
.SS "I set the terminal size as explained above, but if I resize the window, the application does not notice this."
.IX Subsection "I set the terminal size as explained above, but if I resize the window, the application does not notice this."
You have to catch the signal \s-1WINCH\s0 (\*(L"window size changed\*(R"), change the
terminal size and propagate the signal to the spawned application:
.PP
.Vb 4
\&  my $exp = Expect\->new;
\&  $exp\->slave\->clone_winsize_from(\e*STDIN);
\&  $exp\->spawn("ssh somehost);
\&  $SIG{WINCH} = \e&winch;
\&
\&  sub winch {
\&    $exp\->slave\->clone_winsize_from(\e*STDIN);
\&    kill WINCH => $exp\->pid if $exp\->pid;
\&    $SIG{WINCH} = \e&winch;
\&  }
\&
\&  $exp\->interact();
.Ve
.PP
There is an example file ssh.pl in the examples/ subdir that shows how
this works with ssh. Please note that I do strongly object against
using Expect to automate ssh login, as there are better way to do that
(see ssh-keygen).
.SS "I noticed that the test uses a string that resembles, but not exactly matches, a well-known sentence that contains every character.  What does that mean?"
.IX Subsection "I noticed that the test uses a string that resembles, but not exactly matches, a well-known sentence that contains every character. What does that mean?"
That means you are anal-retentive. :\-)  [Gotcha there!]
.ie n .SS "I get a ""Could not assign a pty"" error when running as a non-root user on an \s-1IRIX\s0 box?"
.el .SS "I get a ``Could not assign a pty'' error when running as a non-root user on an \s-1IRIX\s0 box?"
.IX Subsection "I get a Could not assign a pty error when running as a non-root user on an IRIX box?"
The \s-1OS\s0 may not be configured to grant additional pty's (pseudo terminals)
to non-root users.  /usr/sbin/mkpts should be 4755, not 700 for this
to work.  I don't know about security implications if you do this.
.SS "How come I don't notice when the spawned process closes its stdin/out/err??"
.IX Subsection "How come I don't notice when the spawned process closes its stdin/out/err??"
You are probably on one of the systems where the master doesn't get an
\&\s-1EOF\s0 when the slave closes stdin/out/err.
.PP
One possible solution is when you spawn a process, follow it with a
unique string that would indicate the process is finished.
.PP
.Vb 1
\&  $process = Expect\->spawn(\*(Aqtelnet somehost; echo _\|_\|_\|_END_\|_\|_\|_\*(Aq);
.Ve
.PP
And then \f(CW$process\fR\->expect($timeout,'_\|_\|_\|_END_\|_\|_\|_','other','patterns');
.SH "Source Examples"
.IX Header "Source Examples"
.SS "How to automate login"
.IX Subsection "How to automate login"
.Vb 3
\&  my $telnet = Net::Telnet\->new("remotehost") # see Net::Telnet
\&    or die "Cannot telnet to remotehost: $!\en";;
\&  my $exp = Expect\->exp_init($telnet);
\&
\&  # deprecated use of spawned telnet command
\&  # my $exp = Expect\->spawn("telnet localhost")
\&  #   or die "Cannot spawn telnet: $!\en";;
\&
\&  my $spawn_ok;
\&  $exp\->expect($timeout,
\&           [
\&        qr\*(Aqlogin: $\*(Aq,
\&        sub {
\&                  $spawn_ok = 1;
\&          my $fh = shift;
\&          $fh\->send("$username\en");
\&                  exp_continue;
\&        }
\&           ],
\&           [
\&        \*(AqPassword: $\*(Aq,
\&        sub {
\&          my $fh = shift;
\&          print $fh "$password\en";
\&                  exp_continue;
\&        }
\&           ],
\&           [
\&        eof =>
\&        sub {
\&                  if ($spawn_ok) {
\&            die "ERROR: premature EOF in login.\en";
\&                  } else {
\&            die "ERROR: could not spawn telnet.\en";
\&                  }
\&        }
\&           ],
\&           [
\&        timeout =>
\&        sub {
\&          die "No login.\en";
\&        }
\&           ],
\&           \*(Aq\-re\*(Aq, qr\*(Aq[#>:] $\*(Aq, #\*(Aq wait for shell prompt, then exit expect
\&          );
.Ve
.SS "How to expect on multiple spawned commands"
.IX Subsection "How to expect on multiple spawned commands"
.Vb 3
\&  foreach my $cmd (@list_of_commands) {
\&    push @commands, Expect\->spawn($cmd);
\&  }
\&
\&  expect($timeout,
\&     \*(Aq\-i\*(Aq, \e@commands,
\&     [
\&      qr"pattern",        # find this pattern in output of all commands
\&      sub {
\&        my $obj = shift;    # object that matched
\&        print $obj "something\en";
\&        exp_continue;    # we don\*(Aqt want to terminate the expect call
\&      }
\&     ],
\&     \*(Aq\-i\*(Aq, $some_other_command,
\&     [
\&      "some other pattern",
\&      sub {
\&        my ($obj, $parmref) = @_;
\&        # ...
\&
\&        # now we exit the expect command
\&      },
\&      \e$parm
\&     ],
\&    );
.Ve
.SS "How to propagate terminal sizes"
.IX Subsection "How to propagate terminal sizes"
.Vb 4
\&  my $exp = Expect\->new;
\&  $exp\->slave\->clone_winsize_from(\e*STDIN);
\&  $exp\->spawn("ssh somehost);
\&  $SIG{WINCH} = \e&winch;
\&
\&  sub winch {
\&    $exp\->slave\->clone_winsize_from(\e*STDIN);
\&    kill WINCH => $exp\->pid if $exp\->pid;
\&    $SIG{WINCH} = \e&winch;
\&  }
\&
\&  $exp\->interact();
.Ve
.SH "HOMEPAGE"
.IX Header "HOMEPAGE"
<http://sourceforge.net/projects/expectperl/> though the source code is now in GitHub: <https://github.com/jacoby/expect.pm>
.SH "MAILING LISTS"
.IX Header "MAILING LISTS"
There are two mailing lists available, expectperl-announce and
expectperl-discuss, at
.PP
.Vb 1
\&  http://lists.sourceforge.net/lists/listinfo/expectperl\-announce
.Ve
.PP
and
.PP
.Vb 1
\&  http://lists.sourceforge.net/lists/listinfo/expectperl\-discuss
.Ve
.SH "BUG TRACKING"
.IX Header "BUG TRACKING"
You can use the \s-1CPAN\s0 Request Tracker http://rt.cpan.org/ and submit
new bugs under
.PP
.Vb 1
\&  http://rt.cpan.org/Ticket/Create.html?Queue=Expect
.Ve
.SH "AUTHORS"
.IX Header "AUTHORS"
(c) 1997 Austin Schutz <\fIASchutz@users.sourceforge.net\fR> (retired)
.PP
\&\fBexpect()\fR interface & functionality enhancements (c) 1999\-2006 Roland Giersig.
.PP
This module is now maintained by Dave Jacoby <\fIjacoby@cpan.org\fR>
.SH "LICENSE"
.IX Header "LICENSE"
This module can be used under the same terms as Perl.
.SH "DISCLAIMER"
.IX Header "DISCLAIMER"
\&\s-1THIS SOFTWARE IS PROVIDED\s0 ``\s-1AS IS\s0'' \s-1AND ANY EXPRESS OR IMPLIED
WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY DIRECT, INDIRECT,
INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\s0 (\s-1INCLUDING,
BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES\s0; \s-1LOSS
OF USE, DATA, OR PROFITS\s0; \s-1OR BUSINESS INTERRUPTION\s0) \s-1HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
TORT\s0 (\s-1INCLUDING NEGLIGENCE OR OTHERWISE\s0) \s-1ARISING IN ANY WAY OUT OF THE
USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
DAMAGE.\s0
.PP
In other words: Use at your own risk.  Provided as is.  Your mileage
may vary.  Read the source, Luke!
.PP
And finally, just to be sure:
.PP
Any Use of This Product, in Any Manner Whatsoever, Will Increase the
Amount of Disorder in the Universe. Although No Liability Is Implied
Herein, the Consumer Is Warned That This Process Will Ultimately Lead
to the Heat Death of the Universe.
