.\" Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Class::Accessor::Grouped 3"
.TH Class::Accessor::Grouped 3 "2018-07-01" "perl v5.30.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Class::Accessor::Grouped \- Lets you build groups of accessors
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& use base \*(AqClass::Accessor::Grouped\*(Aq;
\&
\& # make basic accessors for objects
\& _\|_PACKAGE_\|_\->mk_group_accessors(simple => qw(id name email));
\&
\& # make accessor that works for objects and classes
\& _\|_PACKAGE_\|_\->mk_group_accessors(inherited => \*(Aqawesome_level\*(Aq);
\&
\& # make an accessor which calls a custom pair of getters/setters
\& sub get_column { ... this will be called when you do $obj\->name() ... }
\& sub set_column { ... this will be called when you do $obj\->name(\*(Aqfoo\*(Aq) ... }
\& _\|_PACKAGE_\|_\->mk_group_accessors(column => \*(Aqname\*(Aq);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This class lets you build groups of accessors that will call different
getters and setters. The documentation of this module still requires a lot
of work (\fBvolunteers welcome >.>\fR), but in the meantime you can refer to
this post <http://lo-f.at/glahn/2009/08/WritingPowerfulAccessorsForPerlClasses.html>
for more information.
.SS "Notes on accessor names"
.IX Subsection "Notes on accessor names"
In general method names in Perl are considered identifiers, and as such need to
conform to the identifier specification of \f(CW\*(C`qr/\eA[A\-Z_a\-z][0\-9A\-Z_a\-z]*\ez/\*(C'\fR.
While it is rather easy to invoke methods with non-standard names
(\f(CW\*(C`$obj\->${\e"anything goes"}\*(C'\fR), it is not possible to properly declare such
methods without the use of Sub::Name. Since this module must be able to
function identically with and without its optional dependencies, starting with
version \f(CW0.10008\fR attempting to declare an accessor with a non-standard name
is a fatal error (such operations would silently succeed since version
\&\f(CW0.08004\fR, as long as Sub::Name is present, or otherwise would result in a
syntax error during a string eval).
.PP
Unfortunately in the years since \f(CW0.08004\fR a rather large body of code
accumulated in the wild that does attempt to declare accessors with funny
names. One notable perpetrator is DBIx::Class::Schema::Loader, which under
certain conditions could create accessors of the \f(CW\*(C`column\*(C'\fR group which start
with numbers and/or some other punctuation (the proper way would be to declare
columns with the \f(CW\*(C`accessor\*(C'\fR attribute set to \f(CW\*(C`undef\*(C'\fR).
.PP
Therefore an escape mechanism is provided via the environment variable
\&\f(CW\*(C`CAG_ILLEGAL_ACCESSOR_NAME_OK\*(C'\fR. When set to a true value, one warning is
issued \fBper class\fR on attempts to declare an accessor with a non-conforming
name, and as long as Sub::Name is available all accessors will be properly
created. Regardless of this setting, accessor names containing nulls \f(CW"\e0"\fR
are disallowed, due to various deficiencies in perl itself.
.PP
If your code base has too many instances of illegal accessor declarations, and
a fix is not feasible due to time constraints, it is possible to disable the
warnings altogether by setting \f(CW$ENV{CAG_ILLEGAL_ACCESSOR_NAME_OK}\fR to
\&\f(CW\*(C`DO_NOT_WARN\*(C'\fR (observe capitalization).
.SH "METHODS"
.IX Header "METHODS"
.SS "mk_group_accessors"
.IX Subsection "mk_group_accessors"
.Vb 1
\& _\|_PACKAGE_\|_\->mk_group_accessors(simple => \*(Aqhair_length\*(Aq, [ hair_color => \*(Aqhc\*(Aq ]);
.Ve
.ie n .IP "Arguments: $group, @fieldspec" 4
.el .IP "Arguments: \f(CW$group\fR, \f(CW@fieldspec\fR" 4
.IX Item "Arguments: $group, @fieldspec"
Returns: none
.PP
Creates a set of accessors in a given group.
.PP
\&\f(CW$group\fR is the name of the accessor group for the generated accessors; they
will call get_$group($field) on get and set_$group($field, \f(CW$value\fR) on set.
.PP
If you want to mimic Class::Accessor's mk_accessors \f(CW$group\fR has to be 'simple'
to tell Class::Accessor::Grouped to use its own get_simple and set_simple
methods.
.PP
\&\f(CW@fieldspec\fR is a list of field/accessor names; if a fieldspec is a scalar
this is used as both field and accessor name, if a listref it is expected to
be of the form [ \f(CW$accessor\fR, \f(CW$field\fR ].
.SS "mk_group_ro_accessors"
.IX Subsection "mk_group_ro_accessors"
.Vb 1
\& _\|_PACKAGE_\|_\->mk_group_ro_accessors(simple => \*(Aqbirthdate\*(Aq, [ social_security_number => \*(Aqssn\*(Aq ]);
.Ve
.ie n .IP "Arguments: $group, @fieldspec" 4
.el .IP "Arguments: \f(CW$group\fR, \f(CW@fieldspec\fR" 4
.IX Item "Arguments: $group, @fieldspec"
Returns: none
.PP
Creates a set of read only accessors in a given group. Identical to
\&\*(L"mk_group_accessors\*(R" but accessors will throw an error if passed a value
rather than setting the value.
.SS "mk_group_wo_accessors"
.IX Subsection "mk_group_wo_accessors"
.Vb 1
\& _\|_PACKAGE_\|_\->mk_group_wo_accessors(simple => \*(Aqlie\*(Aq, [ subject => \*(Aqsubj\*(Aq ]);
.Ve
.ie n .IP "Arguments: $group, @fieldspec" 4
.el .IP "Arguments: \f(CW$group\fR, \f(CW@fieldspec\fR" 4
.IX Item "Arguments: $group, @fieldspec"
Returns: none
.PP
Creates a set of write only accessors in a given group. Identical to
\&\*(L"mk_group_accessors\*(R" but accessors will throw an error if not passed a
value rather than getting the value.
.SS "get_simple"
.IX Subsection "get_simple"
.ie n .IP "Arguments: $field" 4
.el .IP "Arguments: \f(CW$field\fR" 4
.IX Item "Arguments: $field"
Returns: \f(CW$value\fR
.PP
Simple getter for hash-based objects which returns the value for the field
name passed as an argument.
.SS "set_simple"
.IX Subsection "set_simple"
.ie n .IP "Arguments: $field, $new_value" 4
.el .IP "Arguments: \f(CW$field\fR, \f(CW$new_value\fR" 4
.IX Item "Arguments: $field, $new_value"
Returns: \f(CW$new_value\fR
.PP
Simple setter for hash-based objects which sets and then returns the value
for the field name passed as an argument.
.SS "get_inherited"
.IX Subsection "get_inherited"
.ie n .IP "Arguments: $field" 4
.el .IP "Arguments: \f(CW$field\fR" 4
.IX Item "Arguments: $field"
Returns: \f(CW$value\fR
.PP
Simple getter for Classes and hash-based objects which returns the value for
the field name passed as an argument. This behaves much like
Class::Data::Accessor where the field can be set in a base class,
inherited and changed in subclasses, and inherited and changed for object
instances.
.SS "set_inherited"
.IX Subsection "set_inherited"
.ie n .IP "Arguments: $field, $new_value" 4
.el .IP "Arguments: \f(CW$field\fR, \f(CW$new_value\fR" 4
.IX Item "Arguments: $field, $new_value"
Returns: \f(CW$new_value\fR
.PP
Simple setter for Classes and hash-based objects which sets and then returns
the value for the field name passed as an argument. When called on a hash-based
object it will set the appropriate hash key value. When called on a class, it
will set a class level variable.
.PP
\&\fBNote:\fR: This method will die if you try to set an object variable on a non
hash-based object.
.SS "get_component_class"
.IX Subsection "get_component_class"
.ie n .IP "Arguments: $field" 4
.el .IP "Arguments: \f(CW$field\fR" 4
.IX Item "Arguments: $field"
Returns: \f(CW$value\fR
.PP
Gets the value of the specified component class.
.PP
.Vb 1
\& _\|_PACKAGE_\|_\->mk_group_accessors(\*(Aqcomponent_class\*(Aq => \*(Aqresult_class\*(Aq);
\&
\& $self\->result_class\->method();
\&
\& ## same as
\& $self\->get_component_class(\*(Aqresult_class\*(Aq)\->method();
.Ve
.SS "set_component_class"
.IX Subsection "set_component_class"
.ie n .IP "Arguments: $field, $class" 4
.el .IP "Arguments: \f(CW$field\fR, \f(CW$class\fR" 4
.IX Item "Arguments: $field, $class"
Returns: \f(CW$new_value\fR
.PP
Inherited accessor that automatically loads the specified class before setting
it. This method will die if the specified class could not be loaded.
.PP
.Vb 2
\& _\|_PACKAGE_\|_\->mk_group_accessors(\*(Aqcomponent_class\*(Aq => \*(Aqresult_class\*(Aq);
\& _\|_PACKAGE_\|_\->result_class(\*(AqMyClass\*(Aq);
\&
\& $self\->result_class\->method();
.Ve
.SH "INTERNAL METHODS"
.IX Header "INTERNAL METHODS"
These methods are documented for clarity, but are never meant to be called
directly, and are not really meant for overriding either.
.SS "get_super_paths"
.IX Subsection "get_super_paths"
Returns a list of 'parent' or 'super' class names that the current class
inherited from. This is what drives the traversal done by \*(L"get_inherited\*(R".
.SS "make_group_accessor"
.IX Subsection "make_group_accessor"
.Vb 2
\& _\|_PACKAGE_\|_\->make_group_accessor(\*(Aqsimple\*(Aq, \*(Aqhair_length\*(Aq, \*(Aqhair_length\*(Aq);
\& _\|_PACKAGE_\|_\->make_group_accessor(\*(Aqsimple\*(Aq, \*(Aqhc\*(Aq, \*(Aqhair_color\*(Aq);
.Ve
.ie n .IP "Arguments: $group, $field, $accessor" 4
.el .IP "Arguments: \f(CW$group\fR, \f(CW$field\fR, \f(CW$accessor\fR" 4
.IX Item "Arguments: $group, $field, $accessor"
Returns: \e&accessor_coderef ?
.PP
Called by mk_group_accessors for each entry in \f(CW@fieldspec\fR. Either returns
a coderef which will be installed at \f(CW\*(C`&_\|_PACKAGE_\|_::$accessor\*(C'\fR, or returns
\&\f(CW\*(C`undef\*(C'\fR if it elects to install the coderef on its own.
.SS "make_group_ro_accessor"
.IX Subsection "make_group_ro_accessor"
.Vb 2
\& _\|_PACKAGE_\|_\->make_group_ro_accessor(\*(Aqsimple\*(Aq, \*(Aqbirthdate\*(Aq, \*(Aqbirthdate\*(Aq);
\& _\|_PACKAGE_\|_\->make_group_ro_accessor(\*(Aqsimple\*(Aq, \*(Aqssn\*(Aq, \*(Aqsocial_security_number\*(Aq);
.Ve
.ie n .IP "Arguments: $group, $field, $accessor" 4
.el .IP "Arguments: \f(CW$group\fR, \f(CW$field\fR, \f(CW$accessor\fR" 4
.IX Item "Arguments: $group, $field, $accessor"
Returns: \e&accessor_coderef ?
.PP
Called by mk_group_ro_accessors for each entry in \f(CW@fieldspec\fR. Either returns
a coderef which will be installed at \f(CW\*(C`&_\|_PACKAGE_\|_::$accessor\*(C'\fR, or returns
\&\f(CW\*(C`undef\*(C'\fR if it elects to install the coderef on its own.
.SS "make_group_wo_accessor"
.IX Subsection "make_group_wo_accessor"
.Vb 2
\& _\|_PACKAGE_\|_\->make_group_wo_accessor(\*(Aqsimple\*(Aq, \*(Aqlie\*(Aq, \*(Aqlie\*(Aq);
\& _\|_PACKAGE_\|_\->make_group_wo_accessor(\*(Aqsimple\*(Aq, \*(Aqsubj\*(Aq, \*(Aqsubject\*(Aq);
.Ve
.ie n .IP "Arguments: $group, $field, $accessor" 4
.el .IP "Arguments: \f(CW$group\fR, \f(CW$field\fR, \f(CW$accessor\fR" 4
.IX Item "Arguments: $group, $field, $accessor"
Returns: \e&accessor_coderef ?
.PP
Called by mk_group_wo_accessors for each entry in \f(CW@fieldspec\fR. Either returns
a coderef which will be installed at \f(CW\*(C`&_\|_PACKAGE_\|_::$accessor\*(C'\fR, or returns
\&\f(CW\*(C`undef\*(C'\fR if it elects to install the coderef on its own.
.SH "PERFORMANCE"
.IX Header "PERFORMANCE"
To provide total flexibility Class::Accessor::Grouped calls methods
internally while performing get/set actions, which makes it noticeably
slower than similar modules. To compensate, this module will automatically
use the insanely fast Class::XSAccessor to generate the \f(CW\*(C`simple\*(C'\fR\-group
accessors if this module is available on your system.
.SS "Benchmark"
.IX Subsection "Benchmark"
This is the benchmark of 200 get/get/set/get/set cycles on perl 5.16.2 with
thread support, showcasing how this modules simple (\s-1CAG_S\s0),
inherited (\s-1CAG_INH\s0) and inherited with parent-class data
(\s-1CAG_INHP\s0) accessors stack up against most popular accessor 
builders:  Moose, Moo, Mo, Mouse (both pure-perl and \s-1XS\s0 variant),
Object::Tiny::RW (\s-1OTRW\s0),
Class::Accessor (\s-1CA\s0),
Class::Accessor::Lite (\s-1CAL\s0),
Class::Accessor::Fast (\s-1CAF\s0),
Class::Accessor::Fast::XS (\s-1CAF_XS\s0)
and Class::XSAccessor (\s-1XSA\s0)
.PP
.Vb 1
\&                      Rate CAG_INHP CAG_INH     CA  CAG_S    CAF  moOse   OTRW    CAL     mo  moUse HANDMADE    moo CAF_XS moUse_XS    XSA
\&
\& CAG_INHP  287.021+\-0.02/s       \-\-   \-0.3% \-10.0% \-37.1% \-53.1% \-53.6% \-53.7% \-54.1% \-56.9% \-59.0%   \-59.6% \-59.8% \-78.7%   \-81.9% \-83.5%
\&
\& CAG_INH  288.025+\-0.031/s     0.3%      \-\-  \-9.7% \-36.9% \-52.9% \-53.5% \-53.5% \-53.9% \-56.7% \-58.8%   \-59.5% \-59.7% \-78.6%   \-81.9% \-83.5%
\&
\& CA       318.967+\-0.047/s    11.1%   10.7%     \-\- \-30.1% \-47.9% \-48.5% \-48.5% \-49.0% \-52.1% \-54.4%   \-55.1% \-55.3% \-76.3%   \-79.9% \-81.7%
\&
\& CAG_S    456.107+\-0.054/s    58.9%   58.4%  43.0%     \-\- \-25.4% \-26.3% \-26.4% \-27.0% \-31.5% \-34.8%   \-35.8% \-36.1% \-66.1%   \-71.3% \-73.9%
\&
\& CAF      611.745+\-0.099/s   113.1%  112.4%  91.8%  34.1%     \-\-  \-1.2%  \-1.2%  \-2.1%  \-8.1% \-12.6%   \-14.0% \-14.3% \-54.5%   \-61.5% \-64.9%
\&
\& moOse    619.051+\-0.059/s   115.7%  114.9%  94.1%  35.7%   1.2%     \-\-  \-0.1%  \-1.0%  \-7.0% \-11.6%   \-12.9% \-13.3% \-54.0%   \-61.0% \-64.5%
\&
\& OTRW       619.475+\-0.1/s   115.8%  115.1%  94.2%  35.8%   1.3%   0.1%     \-\-  \-0.9%  \-6.9% \-11.5%   \-12.9% \-13.2% \-54.0%   \-61.0% \-64.5%
\&
\& CAL      625.106+\-0.085/s   117.8%  117.0%  96.0%  37.1%   2.2%   1.0%   0.9%     \-\-  \-6.1% \-10.7%   \-12.1% \-12.5% \-53.5%   \-60.6% \-64.2%
\&
\& mo         665.44+\-0.12/s   131.8%  131.0% 108.6%  45.9%   8.8%   7.5%   7.4%   6.5%     \-\-  \-4.9%    \-6.4%  \-6.8% \-50.5%   \-58.1% \-61.9%
\&
\& moUse       699.9+\-0.15/s   143.9%  143.0% 119.4%  53.5%  14.4%  13.1%  13.0%  12.0%   5.2%     \-\-    \-1.6%  \-2.0% \-48.0%   \-55.9% \-59.9%
\&
\& HANDMADE   710.98+\-0.16/s   147.7%  146.8% 122.9%  55.9%  16.2%  14.9%  14.8%  13.7%   6.8%   1.6%       \-\-  \-0.4% \-47.2%   \-55.2% \-59.2%
\&
\& moo        714.04+\-0.13/s   148.8%  147.9% 123.9%  56.6%  16.7%  15.3%  15.3%  14.2%   7.3%   2.0%     0.4%     \-\- \-46.9%   \-55.0% \-59.1%
\&
\& CAF_XS   1345.55+\-0.051/s   368.8%  367.2% 321.8% 195.0% 120.0% 117.4% 117.2% 115.3% 102.2%  92.2%    89.3%  88.4%     \-\-   \-15.3% \-22.9%
\&
\& moUse_XS    1588+\-0.036/s   453.3%  451.3% 397.9% 248.2% 159.6% 156.5% 156.3% 154.0% 138.6% 126.9%   123.4% 122.4%  18.0%       \-\-  \-9.0%
\&
\& XSA      1744.67+\-0.052/s   507.9%  505.7% 447.0% 282.5% 185.2% 181.8% 181.6% 179.1% 162.2% 149.3%   145.4% 144.3%  29.7%     9.9%     \-\-
.Ve
.PP
Benchmarking program is available in the root of the
repository <http://search.cpan.org/dist/Class-Accessor-Grouped/>:
.SS "Notes on Class::XSAccessor"
.IX Subsection "Notes on Class::XSAccessor"
You can force (or disable) the use of Class::XSAccessor before creating a
particular \f(CW\*(C`simple\*(C'\fR accessor by either manipulating the global variable
\&\f(CW$Class::Accessor::Grouped::USE_XS\fR to true or false (preferably with
localization, or you can do so before runtime via the
\&\f(CW\*(C`CAG_USE_XS\*(C'\fR environment variable.
.PP
Since Class::XSAccessor has no knowledge of \*(L"get_simple\*(R" and
\&\*(L"set_simple\*(R" this module does its best to detect if you are overriding
one of these methods and will fall back to using the perl version of the
accessor in order to maintain consistency. However be aware that if you
enable use of \f(CW\*(C`Class::XSAccessor\*(C'\fR (automatically or explicitly), create
an object, invoke a simple accessor on that object, and \fBthen\fR manipulate
the symbol table to install a \f(CW\*(C`get/set_simple\*(C'\fR override \- you get to keep
all the pieces.
.SH "AUTHORS"
.IX Header "AUTHORS"
Matt S. Trout <mst@shadowcatsystems.co.uk>
.PP
Christopher H. Laco <claco@chrislaco.com>
.SH "CONTRIBUTORS"
.IX Header "CONTRIBUTORS"
Caelum: Rafael Kitover <rkitover@cpan.org>
.PP
frew: Arthur Axel \*(L"fREW\*(R" Schmidt <frioux@gmail.com>
.PP
groditi: Guillermo Roditi <groditi@cpan.org>
.PP
Jason Plum <jason.plum@bmmsi.com>
.PP
ribasushi: Peter Rabbitson <ribasushi@cpan.org>
.SH "COPYRIGHT & LICENSE"
.IX Header "COPYRIGHT & LICENSE"
Copyright (c) 2006\-2010 Matt S. Trout <mst@shadowcatsystems.co.uk>
.PP
This program is free software; you can redistribute it and/or modify
it under the same terms as perl itself.
