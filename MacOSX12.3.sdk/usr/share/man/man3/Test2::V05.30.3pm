.\" Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Test2::V0 3"
.TH Test2::V0 3 "2020-10-22" "perl v5.30.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Test2::V0 \- 0Th edition of the Test2 recommended bundle.
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This is the big-daddy bundle. This bundle includes nearly every tool, and
several plugins, that the Test2 author uses. This bundle is used
extensively to test Test2::Suite itself.
.SH "NAMING, USING, DEPENDING"
.IX Header "NAMING, USING, DEPENDING"
This bundle should not change in a \fIseverely\fR incompatible way. Some minor
breaking changes, specially bugfixes, may be allowed. If breaking changes are
needed then a new \f(CW\*(C`Test2::V#\*(C'\fR module should be released instead.
.PP
As new \f(CW\*(C`V#\*(C'\fR modules are released old ones \fImay\fR be moved to different cpan
distributions. You should always use a specific bundle version and list that
version in your distributions testing requirements. You should never simply
list Test2::Suite as your modules dep, instead list the specific bundle, or
tools and plugins you use directly in your metadata.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use Test2::V0;
\&
\&    ok(1, "pass");
\&
\&    ...
\&
\&    done_testing;
.Ve
.SH "RESOLVING CONFLICTS WITH MOOSE"
.IX Header "RESOLVING CONFLICTS WITH MOOSE"
.Vb 1
\&    use Test2::V0 \*(Aq!meta\*(Aq;
.Ve
.PP
Moose and Test2::V0 both export very different \f(CW\*(C`meta()\*(C'\fR
subs. Adding \f(CW\*(Aq!meta\*(Aq\fR to the import args will prevent the sub from being
imported. This bundle also exports the sub under the name \f(CW\*(C`meta_check()\*(C'\fR so
you can use that spelling as an alternative.
.SS "\s-1TAGS\s0"
.IX Subsection "TAGS"
.IP ":DEFAULT" 4
.IX Item ":DEFAULT"
The following are both identical:
.Sp
.Vb 1
\&    use Test2::V0;
\&
\&    use Test2::V0 \*(Aq:DEFAULT\*(Aq;
.Ve
.SS "\s-1RENAMING ON IMPORT\s0"
.IX Subsection "RENAMING ON IMPORT"
.Vb 1
\&    use Test2::V0 \*(Aq:DEFAULT\*(Aq, \*(Aq!ok\*(Aq, ok => {\-as => \*(Aqmy_ok\*(Aq};
.Ve
.PP
This bundle uses Importer for exporting, as such you can use any arguments
it accepts.
.PP
Explanation:
.IP "'!ok'" 4
.IX Item "'!ok'"
Do not export \f(CW\*(C`ok()\*(C'\fR
.IP "ok => {\-as => 'my_ok'}" 4
.IX Item "ok => {-as => 'my_ok'}"
Actually, go ahead and import \f(CW\*(C`ok()\*(C'\fR but under the name \f(CW\*(C`my_ok()\*(C'\fR.
.PP
If you did not add the \f(CW\*(Aq!ok\*(Aq\fR argument then you would have both \f(CW\*(C`ok()\*(C'\fR and
\&\f(CW\*(C`my_ok()\*(C'\fR
.SH "PRAGMAS"
.IX Header "PRAGMAS"
All of these can be disabled via individual import arguments, or by the
\&\f(CW\*(C`\-no_pragmas\*(C'\fR argument.
.PP
.Vb 1
\&    use Test2::V0 \-no_pragmas => 1;
.Ve
.SS "\s-1STRICT\s0"
.IX Subsection "STRICT"
strict is turned on for you. You can disable this with the \f(CW\*(C`\-no_strict\*(C'\fR or
\&\f(CW\*(C`\-no_pragmas\*(C'\fR import arguments:
.PP
.Vb 1
\&    use Test2::V0 \-no_strict => 1;
.Ve
.SS "\s-1WARNINGS\s0"
.IX Subsection "WARNINGS"
warnings are turned on for you. You can disable this with the
\&\f(CW\*(C`\-no_warnings\*(C'\fR or \f(CW\*(C`\-no_pragmas\*(C'\fR import arguments:
.PP
.Vb 1
\&    use Test2::V0 \-no_warnings => 1;
.Ve
.SS "\s-1UTF8\s0"
.IX Subsection "UTF8"
This is actually done via the Test2::Plugin::UTF8 plugin, see the
\&\*(L"\s-1PLUGINS\*(R"\s0 section for details.
.PP
\&\fBNote:\fR \f(CW\*(C`\-no_pragmas => 1\*(C'\fR will turn off the entire plugin.
.SH "PLUGINS"
.IX Header "PLUGINS"
.SS "\s-1SRAND\s0"
.IX Subsection "SRAND"
See Test2::Plugin::SRand.
.PP
This will set the random seed to today's date. You can provide an alternate seed
with the \f(CW\*(C`\-srand\*(C'\fR import option:
.PP
.Vb 1
\&    use Test2::V0 \-srand => 1234;
.Ve
.SS "\s-1UTF8\s0"
.IX Subsection "UTF8"
See Test2::Plugin::UTF8.
.PP
This will set the file, and all output handles (including formatter handles), to
utf8. This will turn on the utf8 pragma for the current scope.
.PP
This can be disabled using the \f(CW\*(C`\-no_utf8 => 1\*(C'\fR or \f(CW\*(C`\-no_pragmas => 1\*(C'\fR
import arguments.
.PP
.Vb 1
\&    use Test2::V0 \-no_utf8 => 1;
.Ve
.SS "\s-1EXIT SUMMARY\s0"
.IX Subsection "EXIT SUMMARY"
See Test2::Plugin::ExitSummary.
.PP
This plugin has no configuration.
.SH "API FUNCTIONS"
.IX Header "API FUNCTIONS"
See Test2::API for these
.ie n .IP "$ctx = \fBcontext()\fR" 4
.el .IP "\f(CW$ctx\fR = \fBcontext()\fR" 4
.IX Item "$ctx = context()"
.PD 0
.ie n .IP "$events = intercept { ... }" 4
.el .IP "\f(CW$events\fR = intercept { ... }" 4
.IX Item "$events = intercept { ... }"
.PD
.SH "TOOLS"
.IX Header "TOOLS"
.SS "\s-1TARGET\s0"
.IX Subsection "TARGET"
See Test2::Tools::Target.
.PP
You can specify a target class with the \f(CW\*(C`\-target\*(C'\fR import argument. If you do
not provide a target then \f(CW$CLASS\fR and \f(CW\*(C`CLASS()\*(C'\fR will not be imported.
.PP
.Vb 1
\&    use Test2::V0 \-target => \*(AqMy::Class\*(Aq;
\&
\&    print $CLASS;  # My::Class
\&    print CLASS(); # My::Class
.Ve
.PP
Or you can specify names:
.PP
.Vb 1
\&    use Test2::V0 \-target => { pkg => \*(AqSome::Package\*(Aq };
\&
\&    pkg()\->xxx; # Call \*(Aqxxx\*(Aq on Some::Package
\&    $pkg\->xxx;  # Same
.Ve
.ie n .IP "$CLASS" 4
.el .IP "\f(CW$CLASS\fR" 4
.IX Item "$CLASS"
Package variable that contains the target class name.
.ie n .IP "$class = \s-1\fBCLASS\s0()\fR" 4
.el .IP "\f(CW$class\fR = \s-1\fBCLASS\s0()\fR" 4
.IX Item "$class = CLASS()"
Constant function that returns the target class name.
.SS "\s-1DEFER\s0"
.IX Subsection "DEFER"
See Test2::Tools::Defer.
.ie n .IP "def $func => @args;" 4
.el .IP "def \f(CW$func\fR => \f(CW@args\fR;" 4
.IX Item "def $func => @args;"
.PD 0
.IP "\fBdo_def()\fR" 4
.IX Item "do_def()"
.PD
.SS "\s-1BASIC\s0"
.IX Subsection "BASIC"
See Test2::Tools::Basic.
.ie n .IP "ok($bool, $name)" 4
.el .IP "ok($bool, \f(CW$name\fR)" 4
.IX Item "ok($bool, $name)"
.PD 0
.ie n .IP "ok($bool, $name, @diag)" 4
.el .IP "ok($bool, \f(CW$name\fR, \f(CW@diag\fR)" 4
.IX Item "ok($bool, $name, @diag)"
.IP "pass($name)" 4
.IX Item "pass($name)"
.ie n .IP "pass($name, @diag)" 4
.el .IP "pass($name, \f(CW@diag\fR)" 4
.IX Item "pass($name, @diag)"
.IP "fail($name)" 4
.IX Item "fail($name)"
.ie n .IP "fail($name, @diag)" 4
.el .IP "fail($name, \f(CW@diag\fR)" 4
.IX Item "fail($name, @diag)"
.IP "diag($message)" 4
.IX Item "diag($message)"
.IP "note($message)" 4
.IX Item "note($message)"
.ie n .IP "$todo = todo($reason)" 4
.el .IP "\f(CW$todo\fR = todo($reason)" 4
.IX Item "$todo = todo($reason)"
.ie n .IP "todo $reason => sub { ... }" 4
.el .IP "todo \f(CW$reason\fR => sub { ... }" 4
.IX Item "todo $reason => sub { ... }"
.ie n .IP "skip($reason, $count)" 4
.el .IP "skip($reason, \f(CW$count\fR)" 4
.IX Item "skip($reason, $count)"
.IP "plan($count)" 4
.IX Item "plan($count)"
.IP "skip_all($reason)" 4
.IX Item "skip_all($reason)"
.IP "\fBdone_testing()\fR" 4
.IX Item "done_testing()"
.IP "bail_out($reason)" 4
.IX Item "bail_out($reason)"
.PD
.SS "\s-1COMPARE\s0"
.IX Subsection "COMPARE"
See Test2::Tools::Compare.
.ie n .IP "is($got, $want, $name)" 4
.el .IP "is($got, \f(CW$want\fR, \f(CW$name\fR)" 4
.IX Item "is($got, $want, $name)"
.PD 0
.ie n .IP "isnt($got, $do_not_want, $name)" 4
.el .IP "isnt($got, \f(CW$do_not_want\fR, \f(CW$name\fR)" 4
.IX Item "isnt($got, $do_not_want, $name)"
.ie n .IP "like($got, qr/match/, $name)" 4
.el .IP "like($got, qr/match/, \f(CW$name\fR)" 4
.IX Item "like($got, qr/match/, $name)"
.ie n .IP "unlike($got, qr/mismatch/, $name)" 4
.el .IP "unlike($got, qr/mismatch/, \f(CW$name\fR)" 4
.IX Item "unlike($got, qr/mismatch/, $name)"
.ie n .IP "$check = match(qr/pattern/)" 4
.el .IP "\f(CW$check\fR = match(qr/pattern/)" 4
.IX Item "$check = match(qr/pattern/)"
.ie n .IP "$check = mismatch(qr/pattern/)" 4
.el .IP "\f(CW$check\fR = mismatch(qr/pattern/)" 4
.IX Item "$check = mismatch(qr/pattern/)"
.ie n .IP "$check = validator(sub { return $bool })" 4
.el .IP "\f(CW$check\fR = validator(sub { return \f(CW$bool\fR })" 4
.IX Item "$check = validator(sub { return $bool })"
.ie n .IP "$check = hash { ... }" 4
.el .IP "\f(CW$check\fR = hash { ... }" 4
.IX Item "$check = hash { ... }"
.ie n .IP "$check = array { ... }" 4
.el .IP "\f(CW$check\fR = array { ... }" 4
.IX Item "$check = array { ... }"
.ie n .IP "$check = bag { ... }" 4
.el .IP "\f(CW$check\fR = bag { ... }" 4
.IX Item "$check = bag { ... }"
.ie n .IP "$check = object { ... }" 4
.el .IP "\f(CW$check\fR = object { ... }" 4
.IX Item "$check = object { ... }"
.ie n .IP "$check = meta { ... }" 4
.el .IP "\f(CW$check\fR = meta { ... }" 4
.IX Item "$check = meta { ... }"
.ie n .IP "$check = number($num)" 4
.el .IP "\f(CW$check\fR = number($num)" 4
.IX Item "$check = number($num)"
.ie n .IP "$check = string($str)" 4
.el .IP "\f(CW$check\fR = string($str)" 4
.IX Item "$check = string($str)"
.ie n .IP "$check = in_set(@things)" 4
.el .IP "\f(CW$check\fR = in_set(@things)" 4
.IX Item "$check = in_set(@things)"
.ie n .IP "$check = not_in_set(@things)" 4
.el .IP "\f(CW$check\fR = not_in_set(@things)" 4
.IX Item "$check = not_in_set(@things)"
.ie n .IP "$check = check_set(@things)" 4
.el .IP "\f(CW$check\fR = check_set(@things)" 4
.IX Item "$check = check_set(@things)"
.ie n .IP "$check = item($thing)" 4
.el .IP "\f(CW$check\fR = item($thing)" 4
.IX Item "$check = item($thing)"
.ie n .IP "$check = item($idx => $thing)" 4
.el .IP "\f(CW$check\fR = item($idx => \f(CW$thing\fR)" 4
.IX Item "$check = item($idx => $thing)"
.ie n .IP "$check = field($name => $val)" 4
.el .IP "\f(CW$check\fR = field($name => \f(CW$val\fR)" 4
.IX Item "$check = field($name => $val)"
.ie n .IP "$check = call($method => $expect)" 4
.el .IP "\f(CW$check\fR = call($method => \f(CW$expect\fR)" 4
.IX Item "$check = call($method => $expect)"
.ie n .IP "$check = call_list($method => $expect)" 4
.el .IP "\f(CW$check\fR = call_list($method => \f(CW$expect\fR)" 4
.IX Item "$check = call_list($method => $expect)"
.ie n .IP "$check = call_hash($method => $expect)" 4
.el .IP "\f(CW$check\fR = call_hash($method => \f(CW$expect\fR)" 4
.IX Item "$check = call_hash($method => $expect)"
.ie n .IP "$check = prop($name => $expect)" 4
.el .IP "\f(CW$check\fR = prop($name => \f(CW$expect\fR)" 4
.IX Item "$check = prop($name => $expect)"
.ie n .IP "$check = check($thing)" 4
.el .IP "\f(CW$check\fR = check($thing)" 4
.IX Item "$check = check($thing)"
.ie n .IP "$check = T()" 4
.el .IP "\f(CW$check\fR = T()" 4
.IX Item "$check = T()"
.ie n .IP "$check = F()" 4
.el .IP "\f(CW$check\fR = F()" 4
.IX Item "$check = F()"
.ie n .IP "$check = D()" 4
.el .IP "\f(CW$check\fR = D()" 4
.IX Item "$check = D()"
.ie n .IP "$check = \s-1\fBDF\s0()\fR" 4
.el .IP "\f(CW$check\fR = \s-1\fBDF\s0()\fR" 4
.IX Item "$check = DF()"
.ie n .IP "$check = \s-1\fBDNE\s0()\fR" 4
.el .IP "\f(CW$check\fR = \s-1\fBDNE\s0()\fR" 4
.IX Item "$check = DNE()"
.ie n .IP "$check = \s-1\fBFDNE\s0()\fR" 4
.el .IP "\f(CW$check\fR = \s-1\fBFDNE\s0()\fR" 4
.IX Item "$check = FDNE()"
.ie n .IP "$check = exact_ref($ref)" 4
.el .IP "\f(CW$check\fR = exact_ref($ref)" 4
.IX Item "$check = exact_ref($ref)"
.IP "\fBend()\fR" 4
.IX Item "end()"
.IP "\fBetc()\fR" 4
.IX Item "etc()"
.ie n .IP "filter_items { grep { ... } @_ }" 4
.el .IP "filter_items { grep { ... } \f(CW@_\fR }" 4
.IX Item "filter_items { grep { ... } @_ }"
.ie n .IP "$check = event $type => ..." 4
.el .IP "\f(CW$check\fR = event \f(CW$type\fR => ..." 4
.IX Item "$check = event $type => ..."
.ie n .IP "@checks = fail_events $type => ..." 4
.el .IP "\f(CW@checks\fR = fail_events \f(CW$type\fR => ..." 4
.IX Item "@checks = fail_events $type => ..."
.PD
.SS "\s-1CLASSIC COMPARE\s0"
.IX Subsection "CLASSIC COMPARE"
See Test2::Tools::ClassicCompare.
.ie n .IP "cmp_ok($got, $op, $want, $name)" 4
.el .IP "cmp_ok($got, \f(CW$op\fR, \f(CW$want\fR, \f(CW$name\fR)" 4
.IX Item "cmp_ok($got, $op, $want, $name)"
.SS "\s-1SUBTEST\s0"
.IX Subsection "SUBTEST"
See Test2::Tools::Subtest.
.ie n .IP "subtest $name => sub { ... };" 4
.el .IP "subtest \f(CW$name\fR => sub { ... };" 4
.IX Item "subtest $name => sub { ... };"
(Note: This is called \f(CW\*(C`subtest_buffered()\*(C'\fR in the Tools module.)
.SS "\s-1CLASS\s0"
.IX Subsection "CLASS"
See Test2::Tools::Class.
.ie n .IP "can_ok($thing, @methods)" 4
.el .IP "can_ok($thing, \f(CW@methods\fR)" 4
.IX Item "can_ok($thing, @methods)"
.PD 0
.ie n .IP "isa_ok($thing, @classes)" 4
.el .IP "isa_ok($thing, \f(CW@classes\fR)" 4
.IX Item "isa_ok($thing, @classes)"
.ie n .IP "DOES_ok($thing, @roles)" 4
.el .IP "DOES_ok($thing, \f(CW@roles\fR)" 4
.IX Item "DOES_ok($thing, @roles)"
.PD
.SS "\s-1ENCODING\s0"
.IX Subsection "ENCODING"
See Test2::Tools::Encoding.
.IP "set_encoding($encoding)" 4
.IX Item "set_encoding($encoding)"
.SS "\s-1EXPORTS\s0"
.IX Subsection "EXPORTS"
See Test2::Tools::Exports.
.IP "imported_ok('function', '$scalar', ...)" 4
.IX Item "imported_ok('function', '$scalar', ...)"
.PD 0
.IP "not_imported_ok('function', '$scalar', ...)" 4
.IX Item "not_imported_ok('function', '$scalar', ...)"
.PD
.SS "\s-1REF\s0"
.IX Subsection "REF"
See Test2::Tools::Ref.
.ie n .IP "ref_ok($ref, $type)" 4
.el .IP "ref_ok($ref, \f(CW$type\fR)" 4
.IX Item "ref_ok($ref, $type)"
.PD 0
.ie n .IP "ref_is($got, $want)" 4
.el .IP "ref_is($got, \f(CW$want\fR)" 4
.IX Item "ref_is($got, $want)"
.ie n .IP "ref_is_not($got, $do_not_want)" 4
.el .IP "ref_is_not($got, \f(CW$do_not_want\fR)" 4
.IX Item "ref_is_not($got, $do_not_want)"
.PD
.SS "\s-1MOCK\s0"
.IX Subsection "MOCK"
See Test2::Tools::Mock.
.ie n .IP "$control = mock ..." 4
.el .IP "\f(CW$control\fR = mock ..." 4
.IX Item "$control = mock ..."
.PD 0
.ie n .IP "$bool = mocked($thing)" 4
.el .IP "\f(CW$bool\fR = mocked($thing)" 4
.IX Item "$bool = mocked($thing)"
.PD
.SS "\s-1EXCEPTION\s0"
.IX Subsection "EXCEPTION"
See Test2::Tools::Exception.
.ie n .IP "$exception = dies { ... }" 4
.el .IP "\f(CW$exception\fR = dies { ... }" 4
.IX Item "$exception = dies { ... }"
.PD 0
.ie n .IP "$bool = lives { ... }" 4
.el .IP "\f(CW$bool\fR = lives { ... }" 4
.IX Item "$bool = lives { ... }"
.ie n .IP "$bool = try_ok { ... }" 4
.el .IP "\f(CW$bool\fR = try_ok { ... }" 4
.IX Item "$bool = try_ok { ... }"
.PD
.SS "\s-1WARNINGS\s0"
.IX Subsection "WARNINGS"
See Test2::Tools::Warnings.
.ie n .IP "$count = warns { ... }" 4
.el .IP "\f(CW$count\fR = warns { ... }" 4
.IX Item "$count = warns { ... }"
.PD 0
.ie n .IP "$warning = warning { ... }" 4
.el .IP "\f(CW$warning\fR = warning { ... }" 4
.IX Item "$warning = warning { ... }"
.ie n .IP "$warnings_ref = warnings { ... }" 4
.el .IP "\f(CW$warnings_ref\fR = warnings { ... }" 4
.IX Item "$warnings_ref = warnings { ... }"
.ie n .IP "$bool = no_warnings { ... }" 4
.el .IP "\f(CW$bool\fR = no_warnings { ... }" 4
.IX Item "$bool = no_warnings { ... }"
.PD
.SH "SOURCE"
.IX Header "SOURCE"
The source code repository for Test2\-Suite can be found at
\&\fIhttps://github.com/Test\-More/Test2\-Suite/\fR.
.SH "MAINTAINERS"
.IX Header "MAINTAINERS"
.IP "Chad Granum <exodist@cpan.org>" 4
.IX Item "Chad Granum <exodist@cpan.org>"
.SH "AUTHORS"
.IX Header "AUTHORS"
.PD 0
.IP "Chad Granum <exodist@cpan.org>" 4
.IX Item "Chad Granum <exodist@cpan.org>"
.PD
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright 2018 Chad Granum <exodist@cpan.org>.
.PP
This program is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.
.PP
See \fIhttp://dev.perl.org/licenses/\fR
