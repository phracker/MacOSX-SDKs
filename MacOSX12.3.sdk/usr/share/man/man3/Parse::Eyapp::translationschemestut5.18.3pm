.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Parse::Eyapp::translationschemestut 3"
.TH Parse::Eyapp::translationschemestut 3 "2012-03-23" "perl v5.18.4" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Parse::Eyapp::translationschemestut \- Introduction to Translation Schemes in Eyapp
.SH "INTRODUCTION"
.IX Header "INTRODUCTION"
A \fItranslation scheme\fR 
scheme is a context free grammar where the right hand sides of the productions 
have been augmented with semantic actions (i.e. with chunks of Perl code):
.PP
.Vb 1
\&                                A \-> alpha { action(@_) } beta
.Ve
.PP
The analyzer generated by \f(CW\*(C`Parse::Eyapp\*(C'\fR executes \f(CW\*(C`action()\*(C'\fR after all the semantic actions
associated with \f(CW\*(C`alpha\*(C'\fR have been executed and before the execution of any of the semantic 
actions associated with \f(CW\*(C`beta\*(C'\fR.
.PP
In a translation scheme the embedded actions modify the attributes
associated with the symbols of the grammar.
.PP
.Vb 1
\&                                A \-> alpha { action(@_) } beta
.Ve
.PP
\&\fIeach symbol on the right hand side
of a production rule has an associated scalar attribute\fR. In ordinary \f(CW\*(C`eyapp\*(C'\fR 
programs the attributes of the symbol
to the left of \f(CW\*(C`action\*(C'\fR are passed as arguments to \f(CW\*(C`action\*(C'\fR (in the example, those of \f(CW\*(C`alpha\*(C'\fR). 
These arguments are preceded by a reference to the syntax analyzer object.
There is no way inside an ordinary \f(CW\*(C`eyapp\*(C'\fR program for an intermediate \f(CW\*(C`action\*(C'\fR to 
access the attributes of the symbols
on its right, i.e. those associated with the symbols of \f(CW\*(C`beta\*(C'\fR. This restriction is lifted 
if you  use the \f(CW%metatree\fR directive.
.PP
Eyapp allows through the \f(CW%metatree\fR directive
the creation of \fITranslation Schemes\fR where the actions have access to 
almost any node of the syntax tree.
.PP
When using the \f(CW%metatree\fR directive semantic actions aren't immediately executed. Instead they are 
inserted as nodes of the syntax tree. The main difference with ordinary nodes
being that the attribute of such a \f(CW\*(C`CODE\*(C'\fR node is a reference to the anonymous 
subroutine representing the semantic action.
The tree is later traversed in depth-first order using the \f(CW\*(C`$t\->translation_scheme\*(C'\fR
method: each time a \f(CW\*(C`CODE\*(C'\fR node
is visited  the action is executed.
.PP
The following example parses a tiny subset of a typical
\&\fItyped language\fR and decorates the syntax tree with a new 
attribute \f(CW\*(C`t\*(C'\fR holding the type of each declared variable:
.PP
.Vb 4
\& use strict; # File examples/trans_scheme_simple_decls4.pl
\& use Data::Dumper;
\& use Parse::Eyapp;
\& our %s; # symbol table
\&
\& my $ts = q{ 
\&   %token FLOAT INTEGER NAME
\&
\&   %{
\&   our %s;
\&   %}
\&
\&   %metatree
\&
\&   %%
\&   Dl:  D <* \*(Aq;\*(Aq>
\&   ;
\&
\&   D : $T { $L\->{t} = $T\->{t} } $L
\&   ;
\&
\&   T : FLOAT    { $lhs\->{t} = "FLOAT" }
\&     | INTEGER  { $lhs\->{t} = "INTEGER" }
\&   ;
\&
\&   L : $NAME
\&         { $NAME\->{t} = $lhs\->{t}; $s{$NAME\->{attr}} = $NAME }
\&     | $NAME { $NAME\->{t} = $lhs\->{t}; $L\->{t} = $lhs\->{t} } \*(Aq,\*(Aq $L
\&         { $s{$NAME\->{attr}} = $NAME }
\&   ;
\&   %%
\& }; # end $ts
\&
\& sub Error { die "Error sinta\*'ctico\en"; }
\&
\& { # Closure of $input, %reserved_words and $validchars
\&   my $input = "";
\&   my %reserved_words = ();
\&   my $validchars = "";
\&
\&   sub parametrize_\|_scanner {
\&     $input = shift;
\&     %reserved_words = %{shift()};
\&     $validchars = shift;
\&   }
\&
\&   sub scanner {
\&     $input =~ m{\eG\es+}gc;                     # skip whites
\&     if ($input =~ m{\eG([a\-z_A_Z]\ew*)\eb}gc) {
\&       my $w = uc($1);                 # upper case the word
\&       return ($w, $w) if exists $reserved_words{$w};
\&       return (\*(AqNAME\*(Aq, $1);            # not a reserved word
\&     }
\&     return ($1, $1) if ($input =~ m/\eG([$validchars])/gc);
\&     die "Not valid token: $1\en" if ($input =~ m/\eG(\eS)/gc);
\&     return (\*(Aq\*(Aq, undef); # end of file
\&   }
\& } # end closure
\&
\& Parse::Eyapp\->new_grammar(input=>$ts,classname=>\*(Aqmain\*(Aq,outputfile=>\*(AqTypes.pm\*(Aq);
\& my $parser = main\->new(yylex => \e&scanner, yyerror => \e&Error); 
\&
\& parametrize_\|_scanner(
\&   "float x,y;\eninteger a,b\en",
\&   { INTEGER => \*(AqINTEGER\*(Aq, FLOAT => \*(AqFLOAT\*(Aq},
\&   ",;"
\& );
\&
\& my $t = $parser\->YYParse() or die "Syntax Error analyzing input";
\&
\& $t\->translation_scheme;
\&
\& $Data::Dumper::Indent = 1;
\& $Data::Dumper::Terse = 1;
\& $Data::Dumper::Deepcopy  = 1;
\& $Data::Dumper::Deparse = 1;
\& print Dumper($t);
\& print Dumper(\e%s);
.Ve
.PP
Inside a Translation Scheme the lexical variable \f(CW$lhs\fR refers to the attribute
of the father.
.SH "EXECUTION STAGES OF A TRANSLATION SCHEME"
.IX Header "EXECUTION STAGES OF A TRANSLATION SCHEME"
The execution of a Translation Scheme can be divided in the following stages:
.IP "1. During the first stage the grammar is analyzed and the parser is built:" 4
.IX Item "1. During the first stage the grammar is analyzed and the parser is built:"
.Vb 1
\& Parse::Eyapp\->new_grammar(input=>$ts,classname=>\*(Aqmain\*(Aq,outputfile=>\*(AqTypes.pm\*(Aq);
.Ve
.Sp
This stage is called \fIClass Construction Time\fR
.IP "2. A parser conforming to the generated grammar is built" 4
.IX Item "2. A parser conforming to the generated grammar is built"
.Vb 1
\&  my $parser = main\->new(yylex => \e&scanner, yyerror => \e&Error);
.Ve
.Sp
This stage is called  \fIParser Construction Time\fR
.IP "3. The next phase is \fITree construction time\fR. The input is set and the tree is built:" 4
.IX Item "3. The next phase is Tree construction time. The input is set and the tree is built:"
.Vb 5
\& parametrize_\|_scanner(
\&    "float x,y;\eninteger a,b\en",
\&    { INTEGER => \*(AqINTEGER\*(Aq, FLOAT => \*(AqFLOAT\*(Aq},
\&    ",;"
\&  );
\&
\&  my $t = $parser\->YYParse() or die "Syntax Error analyzing input";
.Ve
.ie n .IP "4. The last stage is \fIExecution Time\fR. The tree is traversed in depth first order and the ""CODE"" nodes are executed." 4
.el .IP "4. The last stage is \fIExecution Time\fR. The tree is traversed in depth first order and the \f(CWCODE\fR nodes are executed." 4
.IX Item "4. The last stage is Execution Time. The tree is traversed in depth first order and the CODE nodes are executed."
.Vb 1
\&                           $t\->translation_scheme;
.Ve
.PP
This combination of bottom-up parsing with depth first traversing
leads to a semantic behavior similar to recursive top-down parsers
but with two advantages:
.IP "\(bu" 4
The grammar can be left-recursive
.IP "\(bu" 4
At the time of executing the action the syntax tree is already built, therefore we can refer
to nodes on the right side of the action like in:
.Sp
.Vb 1
\&                      D : $T { $L\->{t} = $T\->{t} } $L
.Ve
.ie n .SH "THE %begin DIRECTIVE"
.el .SH "THE \f(CW%begin\fP DIRECTIVE"
.IX Header "THE %begin DIRECTIVE"
The \f(CW\*(C`%begin { code }\*(C'\fR directive  can be used when
building a translation scheme, i.e. when under the 
control of the \f(CW%metatree\fR directive.
It indicates that such \f(CW\*(C`{ code }\*(C'\fR will be executed at \fItree
construction time\fR. Therefore the code receives as arguments
the references to the nodes of the branch than is being built.
Usually \fIbegin code\fR assist in the construction of the tree.
Line 39 of the following code shows an example.
The action \f(CW\*(C`{ $exp }\*(C'\fR simplifies the syntax tree
bypassing the parenthesis node. The example also illustrates
the combined use of default actions and 
translation schemes.
.PP
.Vb 10
\&  pl@nereida:~/LEyapp/examples$ cat \-n trans_scheme_default_action.pl
\&     1  #!/usr/bin/perl \-w
\&     2  use strict;
\&     3  use Data::Dumper;
\&     4  use Parse::Eyapp;
\&     5  use IO::Interactive qw(is_interactive);
\&     6
\&     7  my $translationscheme = q{
\&     8  %{
\&     9  # head code is available at tree construction time
\&    10  use Data::Dumper;
\&    11  our %sym; # symbol table
\&    12  %}
\&    13
\&    14  %defaultaction {
\&    15     $lhs\->{n} = eval " $left\->{n} $_[2]\->{attr} $right\->{n} "
\&    16  }
\&    17
\&    18  %metatree
\&    19
\&    20  %right   \*(Aq=\*(Aq
\&    21  %left   \*(Aq\-\*(Aq \*(Aq+\*(Aq
\&    22  %left   \*(Aq*\*(Aq \*(Aq/\*(Aq
\&    23
\&    24  %%
\&    25  line:       %name EXP
\&    26                exp <+ \*(Aq;\*(Aq> /* Expressions separated by semicolons */
\&    27                  { $lhs\->{n} = $_[1]\->Last_child\->{n} }
\&    28  ;
\&    29
\&    30  exp:
\&    31              %name PLUS
\&    32                exp.left \*(Aq+\*(Aq exp.right
\&    33          |   %name MINUS
\&    34                exp.left \*(Aq\-\*(Aq exp.right
\&    35          |   %name TIMES
\&    36                exp.left \*(Aq*\*(Aq exp.right
\&    37          |   %name DIV
\&    38                exp.left \*(Aq/\*(Aq exp.right
\&    39          |   %name NUM
\&    40                $NUM
\&    41                  { $lhs\->{n} = $NUM\->{attr} }
\&    42          |   \*(Aq(\*(Aq $exp \*(Aq)\*(Aq  %begin { $exp }
\&    43          |   %name VAR
\&    44                $VAR
\&    45                  { $lhs\->{n} = $sym{$VAR\->{attr}}\->{n} }
\&    46          |   %name ASSIGN
\&    47                $VAR \*(Aq=\*(Aq $exp
\&    48                  { $lhs\->{n} = $sym{$VAR\->{attr}}\->{n} = $exp\->{n} }
\&    49
\&    50  ;
\&    51
\&    52  %%
\&    53  # tail code is available at tree construction time
\&    54  sub _Error {
\&    55    die "Syntax error.\en";
\&    56  }
\&    57
\&    58  sub _Lexer {
\&    59      my($parser)=shift;
\&    60
\&    61      for ($parser\->YYData\->{INPUT}) {
\&    62          s/^\es+//;
\&    63          $_ or  return(\*(Aq\*(Aq,undef);
\&    64          s/^([0\-9]+(?:\e.[0\-9]+)?)// and return(\*(AqNUM\*(Aq,$1);
\&    65          s/^([A\-Za\-z][A\-Za\-z0\-9_]*)// and return(\*(AqVAR\*(Aq,$1);
\&    66          s/^(.)// and return($1,$1);
\&    67      }
\&    68      return(\*(Aq\*(Aq,undef);
\&    69  }
\&    70
\&    71  sub Run {
\&    72      my($self)=shift;
\&    73      return $self\->YYParse( yylex => \e&_Lexer, yyerror => \e&_Error );
\&    74  }
\&    75  }; # end translation scheme
\&    76
\&    77  sub TERMINAL::info { $_[0]\->attr }
\&    78
\&    79  my $p = Parse::Eyapp\->new_grammar(
\&    80    input=>$translationscheme,
\&    81    classname=>\*(Aqmain\*(Aq,
\&    82    firstline => 6,
\&    83    outputfile => \*(Aqmain.pm\*(Aq);
\&    84  die $p\->qtables() if $p\->Warnings;
\&    85  my $parser = main\->new();
\&    86  print "Write a sequence of arithmetic expressions: " if is_interactive();
\&    87  $parser\->YYData\->{INPUT} = <>;
\&    88  my $t = $parser\->Run() or die "Syntax Error analyzing input";
\&    89  $t\->translation_scheme;
\&    90
\&    91  $Parse::Eyapp::Node::INDENT = 2;
\&    92  my $treestring = $t\->str;
\&    93
\&    94  $Data::Dumper::Indent = 1;
\&    95  $Data::Dumper::Terse = 1;
\&    96  $Data::Dumper::Deepcopy  = 1;
\&    97  our %sym;
\&    98  my $symboltable = Dumper(\e%sym);
\&    99
\&   100  print <<"EOR";
\&   101  ***********Tree*************
\&   102  $treestring
\&   103  ******Symbol table**********
\&   104  $symboltable
\&   105  ************Result**********
\&   106  $t\->{n}
\&   107
\&   108  EOR
.Ve
.PP
When executed with input \f(CW\*(C`a=2*3;b=a*a\*(C'\fR
the program produces an output similar to this:
.PP
.Vb 3
\&  pl@nereida:~/LEyapp/examples$ trans_scheme_default_action.pl
\&  Write a sequence of arithmetic expressions: a=2*3;b=a*a
\&  ***********Tree*************
\&
\&  EXP(
\&    _PLUS_LIST(
\&      ASSIGN(
\&        TERMINAL[a],
\&        TERMINAL[=],
\&        TIMES(
\&          NUM(TERMINAL[2], CODE),
\&          TERMINAL[*],
\&          NUM(TERMINAL[3], CODE),
\&          CODE
\&        ) # TIMES,
\&        CODE
\&      ) # ASSIGN,
\&      ASSIGN(
\&        TERMINAL[b],
\&        TERMINAL[=],
\&        TIMES(
\&          VAR(TERMINAL[a], CODE),
\&          TERMINAL[*],
\&          VAR(TERMINAL[a], CODE),
\&          CODE
\&        ) # TIMES,
\&        CODE
\&      ) # ASSIGN
\&    ) # _PLUS_LIST,
\&    CODE
\&  ) # EXP
\&  ******Symbol table**********
\&  {
\&    \*(Aqa\*(Aq => {
\&      \*(Aqn\*(Aq => 6
\&    },
\&    \*(Aqb\*(Aq => {
\&      \*(Aqn\*(Aq => 36
\&    }
\&  }
\&
\&  ************Result**********
\&  36
.Ve
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.IP "\(bu" 4
The project home is at <http://code.google.com/p/parse\-eyapp/>.
Use a subversion client to anonymously check out the latest project source code:
.Sp
.Vb 1
\&   svn checkout http://parse\-eyapp.googlecode.com/svn/trunk/ parse\-eyapp\-read\-only
.Ve
.IP "\(bu" 4
The tutorial \fIParsing Strings and Trees with\fR \f(CW\*(C`Parse::Eyapp\*(C'\fR
(An Introduction to Compiler Construction in seven pages) in
<http://nereida.deioc.ull.es/~pl/eyapsimple/>
.IP "\(bu" 4
Parse::Eyapp, 
Parse::Eyapp::eyapplanguageref, 
Parse::Eyapp::debuggingtut,
Parse::Eyapp::defaultactionsintro,
Parse::Eyapp::translationschemestut,
Parse::Eyapp::Driver,
Parse::Eyapp::Node,
Parse::Eyapp::YATW,
Parse::Eyapp::Treeregexp,
Parse::Eyapp::Scope,
Parse::Eyapp::Base,
Parse::Eyapp::datagenerationtut
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/languageintro.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/debuggingtut.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/eyapplanguageref.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/Treeregexp.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/Node.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/YATW.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/Eyapp.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/Base.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/translationschemestut.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/treematchingtut.pdf>
.IP "\(bu" 4
perldoc eyapp,
.IP "\(bu" 4
perldoc treereg,
.IP "\(bu" 4
perldoc vgg,
.IP "\(bu" 4
The Syntax Highlight file for vim at <http://www.vim.org/scripts/script.php?script_id=2453>
and <http://nereida.deioc.ull.es/~vim/>
.IP "\(bu" 4
\&\fIAnalisis Lexico y Sintactico\fR, (Notes for a course in compiler 
construction) by  Casiano Rodriguez-Leon. 
Available at  <http://nereida.deioc.ull.es/~pl/perlexamples/>
Is the more complete and reliable source for Parse::Eyapp. However is in Spanish.
.IP "\(bu" 4
Parse::Yapp,
.IP "\(bu" 4
Man pages of \fIyacc\fR\|(1) and
\&\fIbison\fR\|(1),
<http://www.delorie.com/gnu/docs/bison/bison.html>
.IP "\(bu" 4
Language::AttributeGrammar
.IP "\(bu" 4
Parse::RecDescent.
.IP "\(bu" 4
HOP::Parser
.IP "\(bu" 4
HOP::Lexer
.IP "\(bu" 4
ocamlyacc tutorial at 
<http://plus.kaist.ac.kr/~shoh/ocaml/ocamllex\-ocamlyacc/ocamlyacc\-tutorial/ocamlyacc\-tutorial.html>
.SH "REFERENCES"
.IX Header "REFERENCES"
.IP "\(bu" 4
The classic Dragon's book \fICompilers: Principles, Techniques, and Tools\fR 
by Alfred V. Aho, Ravi Sethi and
Jeffrey D. Ullman (Addison-Wesley 1986)
.IP "\(bu" 4
\&\fI\s-1CS2121:\s0 The Implementation and Power of Programming Languages\fR
(See <http://www.cs.man.ac.uk/~pjj>, <http://www.cs.man.ac.uk/~pjj/complang/g2lr.html> 
and <http://www.cs.man.ac.uk/~pjj/cs2121/ho/ho.html>) by 
Pete Jinks
.SH "CONTRIBUTORS"
.IX Header "CONTRIBUTORS"
.IP "\(bu" 2
Hal Finkel <http://www.halssoftware.com/>
.IP "\(bu" 2
G. Williams <http://kasei.us/>
.IP "\(bu" 2
Thomas L. Shinnick <http://search.cpan.org/~tshinnic/>
.IP "\(bu" 2
Frank Leray
.SH "AUTHOR"
.IX Header "AUTHOR"
Casiano Rodriguez-Leon (casiano@ull.es)
.SH "ACKNOWLEDGMENTS"
.IX Header "ACKNOWLEDGMENTS"
This work has been supported by \s-1CEE \s0(\s-1FEDER\s0) and the Spanish Ministry of
\&\fIEducacion y Ciencia\fR through \fIPlan Nacional I+D+I\fR number \s-1TIN2005\-08818\-C04\-04
\&\s0(\s-1ULL::OPLINK\s0 project <http://www.oplink.ull.es/>). 
Support from Gobierno de Canarias was through \s-1GC02210601
\&\s0(\fIGrupos Consolidados\fR).
The University of La Laguna has also supported my work in many ways
and for many years.
.PP
A large percentage of  code is verbatim taken from Parse::Yapp 1.05.
The author of Parse::Yapp is Francois Desarmenien.
.PP
I wish to thank Francois Desarmenien for his Parse::Yapp module, 
to my students at La Laguna and to the Perl Community. Thanks to 
the people who have contributed to improve the module (see \*(L"\s-1CONTRIBUTORS\*(R"\s0 in Parse::Eyapp).
Thanks to Larry Wall for giving us Perl.
Special thanks to Juana.
.SH "LICENCE AND COPYRIGHT"
.IX Header "LICENCE AND COPYRIGHT"
Copyright (c) 2006\-2008 Casiano Rodriguez-Leon (casiano@ull.es). All rights reserved.
.PP
Parse::Yapp copyright is of Francois Desarmenien, all rights reserved. 1998\-2001
.PP
These modules are free software; you can redistribute it and/or
modify it under the same terms as Perl itself. See perlartistic.
.PP
This program is distributed in the hope that it will be useful,
but \s-1WITHOUT ANY WARRANTY\s0; without even the implied warranty of
\&\s-1MERCHANTABILITY\s0 or \s-1FITNESS FOR A PARTICULAR PURPOSE. \s0
.SH "POD ERRORS"
.IX Header "POD ERRORS"
Hey! \fBThe above document had some coding errors, which are explained below:\fR
.IP "Around line 81:" 4
.IX Item "Around line 81:"
Non-ASCII character seen before =encoding in 'sinta\*'ctico\en";'. Assuming \s-1UTF\-8\s0
