.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Role::Tiny 3"
.TH Role::Tiny 3 "2013-09-04" "perl v5.18.4" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Role::Tiny \- Roles. Like a nouvelle cuisine portion size slice of Moose.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& package Some::Role;
\&
\& use Role::Tiny;
\&
\& sub foo { ... }
\&
\& sub bar { ... }
\&
\& around baz => sub { ... }
\&
\& 1;
.Ve
.PP
else where
.PP
.Vb 1
\& package Some::Class;
\&
\& use Role::Tiny::With;
\&
\& # bar gets imported, but not foo
\& with \*(AqSome::Role\*(Aq;
\&
\& sub foo { ... }
\&
\& # baz is wrapped in the around modifier by Class::Method::Modifiers
\& sub baz { ... }
\&
\& 1;
.Ve
.PP
If you wanted attributes as well, look at Moo::Role.
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\f(CW\*(C`Role::Tiny\*(C'\fR is a minimalist role composition tool.
.SH "ROLE COMPOSITION"
.IX Header "ROLE COMPOSITION"
Role composition can be thought of as much more clever and meaningful multiple
inheritance.  The basics of this implementation of roles is:
.IP "\(bu" 2
If a method is already defined on a class, that method will not be composed in
from the role.
.IP "\(bu" 2
If a method that the role \*(L"requires\*(R" to be implemented is not implemented,
role application will fail loudly.
.PP
Unlike Class::C3, where the \fBlast\fR class inherited from \*(L"wins,\*(R" role
composition is the other way around, where the class wins. If multiple roles
are applied in a single call (single with statement), then if any of their
provided methods clash, an exception is raised unless the class provides
a method since this conflict indicates a potential problem.
.SH "IMPORTED SUBROUTINES"
.IX Header "IMPORTED SUBROUTINES"
.SS "requires"
.IX Subsection "requires"
.Vb 1
\& requires qw(foo bar);
.Ve
.PP
Declares a list of methods that must be defined to compose role.
.SS "with"
.IX Subsection "with"
.Vb 1
\& with \*(AqSome::Role1\*(Aq;
\&
\& with \*(AqSome::Role1\*(Aq, \*(AqSome::Role2\*(Aq;
.Ve
.PP
Composes another role into the current role (or class via Role::Tiny::With).
.PP
If you have conflicts and want to resolve them in favour of Some::Role1 you
can instead write:
.PP
.Vb 2
\& with \*(AqSome::Role1\*(Aq;
\& with \*(AqSome::Role2\*(Aq;
.Ve
.PP
If you have conflicts and want to resolve different conflicts in favour of
different roles, please refactor your codebase.
.SS "before"
.IX Subsection "before"
.Vb 1
\& before foo => sub { ... };
.Ve
.PP
See \*(L"before method(s) => sub { ... }\*(R" in Class::Method::Modifiers for full
documentation.
.PP
Note that since you are not required to use method modifiers,
Class::Method::Modifiers is lazily loaded and we do not declare it as
a dependency. If your Role::Tiny role uses modifiers you must depend on
both Class::Method::Modifiers and Role::Tiny.
.SS "around"
.IX Subsection "around"
.Vb 1
\& around foo => sub { ... };
.Ve
.PP
See \*(L"around method(s) => sub { ... }\*(R" in Class::Method::Modifiers for full
documentation.
.PP
Note that since you are not required to use method modifiers,
Class::Method::Modifiers is lazily loaded and we do not declare it as
a dependency. If your Role::Tiny role uses modifiers you must depend on
both Class::Method::Modifiers and Role::Tiny.
.SS "after"
.IX Subsection "after"
.Vb 1
\& after foo => sub { ... };
.Ve
.PP
See \*(L"after method(s) => sub { ... }\*(R" in Class::Method::Modifiers for full
documentation.
.PP
Note that since you are not required to use method modifiers,
Class::Method::Modifiers is lazily loaded and we do not declare it as
a dependency. If your Role::Tiny role uses modifiers you must depend on
both Class::Method::Modifiers and Role::Tiny.
.SH "SUBROUTINES"
.IX Header "SUBROUTINES"
.SS "does_role"
.IX Subsection "does_role"
.Vb 3
\& if (Role::Tiny::does_role($foo, \*(AqSome::Role\*(Aq)) {
\&   ...
\& }
.Ve
.PP
Returns true if class has been composed with role.
.PP
This subroutine is also installed as \->does on any class a Role::Tiny is
composed into unless that class already has an \->does method, so
.PP
.Vb 3
\&  if ($foo\->does(\*(AqSome::Role\*(Aq)) {
\&    ...
\&  }
.Ve
.PP
will work for classes but to test a role, one must use ::does_role directly.
.PP
Additionally, Role::Tiny will override the standard Perl \f(CW\*(C`DOES\*(C'\fR method
for your class. However, if \f(CW\*(C`any\*(C'\fR class in your class' inheritance
hierarchy provides \f(CW\*(C`DOES\*(C'\fR, then Role::Tiny will not override it.
.SH "METHODS"
.IX Header "METHODS"
.SS "apply_roles_to_package"
.IX Subsection "apply_roles_to_package"
.Vb 3
\& Role::Tiny\->apply_roles_to_package(
\&   \*(AqSome::Package\*(Aq, \*(AqSome::Role\*(Aq, \*(AqSome::Other::Role\*(Aq
\& );
.Ve
.PP
Composes role with package.  See also Role::Tiny::With.
.SS "apply_roles_to_object"
.IX Subsection "apply_roles_to_object"
.Vb 1
\& Role::Tiny\->apply_roles_to_object($foo, qw(Some::Role1 Some::Role2));
.Ve
.PP
Composes roles in order into object directly.  Object is reblessed into the
resulting class.
.SS "create_class_with_roles"
.IX Subsection "create_class_with_roles"
.Vb 1
\& Role::Tiny\->create_class_with_roles(\*(AqSome::Base\*(Aq, qw(Some::Role1 Some::Role2));
.Ve
.PP
Creates a new class based on base, with the roles composed into it in order.
New class is returned.
.SS "is_role"
.IX Subsection "is_role"
.Vb 1
\& Role::Tiny\->is_role(\*(AqSome::Role1\*(Aq)
.Ve
.PP
Returns true if the given package is a role.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Role::Tiny is the attribute-less subset of Moo::Role; Moo::Role is
a meta-protocol-less subset of the king of role systems, Moose::Role.
.PP
If you don't want method modifiers and do want to be forcibly restricted
to a single role application per class, Ovid's Role::Basic exists. But
Stevan Little (the Moose author) and I don't find the additional
restrictions to be amazingly helpful in most cases; Role::Basic's choices
are more a guide to what you should prefer doing, to our mind, rather than
something that needs to be enforced.
.SH "AUTHOR"
.IX Header "AUTHOR"
mst \- Matt S. Trout (cpan:MSTROUT) <mst@shadowcat.co.uk>
.SH "CONTRIBUTORS"
.IX Header "CONTRIBUTORS"
dg \- David Leadbeater (cpan:DGL) <dgl@dgl.cx>
.PP
frew \- Arthur Axel \*(L"fREW\*(R" Schmidt (cpan:FREW) <frioux@gmail.com>
.PP
hobbs \- Andrew Rodland (cpan:ARODLAND) <arodland@cpan.org>
.PP
jnap \- John Napiorkowski (cpan:JJNAPIORK) <jjn1056@yahoo.com>
.PP
ribasushi \- Peter Rabbitson (cpan:RIBASUSHI) <ribasushi@cpan.org>
.PP
chip \- Chip Salzenberg (cpan:CHIPS) <chip@pobox.com>
.PP
ajgb \- Alex J. G. BurzyXski (cpan:AJGB) <ajgb@cpan.org>
.PP
doy \- Jesse Luehrs (cpan:DOY) <doy at tozt dot net>
.PP
perigrin \- Chris Prather (cpan:PERIGRIN) <chris@prather.org>
.PP
Mithaldu \- Christian Walde (cpan:MITHALDU) <walde.christian@googlemail.com>
.PP
ilmari \- Dagfinn Ilmari Mannsa\*oker (cpan:ILMARI) <ilmari@ilmari.org>
.PP
tobyink \- Toby Inkster (cpan:TOBYINK) <tobyink@cpan.org>
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (c) 2010\-2012 the Role::Tiny \*(L"\s-1AUTHOR\*(R"\s0 and \*(L"\s-1CONTRIBUTORS\*(R"\s0
as listed above.
.SH "LICENSE"
.IX Header "LICENSE"
This library is free software and may be distributed under the same terms
as perl itself.
