.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "XML::LibXML::Reader 3"
.TH XML::LibXML::Reader 3 "2014-02-01" "perl v5.18.4" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
XML::LibXML::Reader \- XML::LibXML::Reader \- interface to libxml2 pull parser
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use XML::LibXML::Reader;
\&
\&
\&
\&  my $reader = XML::LibXML::Reader\->new(location => "file.xml")
\&         or die "cannot read file.xml\en";
\&  while ($reader\->read) {
\&    processNode($reader);
\&  }
\&
\&
\&
\&  sub processNode {
\&      my $reader = shift;
\&      printf "%d %d %s %d\en", ($reader\->depth,
\&                               $reader\->nodeType,
\&                               $reader\->name,
\&                               $reader\->isEmptyElement);
\&  }
.Ve
.PP
or
.PP
.Vb 5
\&  my $reader = XML::LibXML::Reader\->new(location => "file.xml")
\&         or die "cannot read file.xml\en";
\&    $reader\->preservePattern(\*(Aq//table/tr\*(Aq);
\&    $reader\->finish;
\&    print $reader\->document\->toString(1);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This is a perl interface to libxml2's pull-parser implementation xmlTextReader \fIhttp://xmlsoft.org/html/libxml\-xmlreader.html\fR. This feature requires at least libxml2\-2.6.21. Pull-parsers (such as StAX in
Java, or XmlReader in C#) use an iterator approach to parse \s-1XML\s0 documents. They
are easier to program than event-based parser (\s-1SAX\s0) and much more lightweight
than tree-based parser (\s-1DOM\s0), which load the complete tree into memory.
.PP
The Reader acts as a cursor going forward on the document stream and stopping
at each node in the way. At every point DOM-like methods of the Reader object
allow to examine the current node (name, namespace, attributes, etc.)
.PP
The user's code keeps control of the progress and simply calls the \f(CW\*(C`read()\*(C'\fR function repeatedly to progress to the next node in the document order. Other
functions provide means for skipping complete sub-trees, or nodes until a
specific element, etc.
.PP
At every time, only a very limited portion of the document is kept in the
memory, which makes the \s-1API\s0 more memory-efficient than using \s-1DOM.\s0 However, it
is also possible to mix Reader with \s-1DOM.\s0 At every point the user may copy the
current node (optionally expanded into a complete sub-tree) from the processed
document to another \s-1DOM\s0 tree, or to instruct the Reader to collect sub-document
in form of a \s-1DOM\s0 tree consisting of selected nodes.
.PP
Reader \s-1API\s0 also supports namespaces, xml:base, entity handling, and \s-1DTD\s0
validation. Schema and RelaxNG validation support will probably be added in
some later revision of the Perl interface.
.PP
The naming of methods compared to libxml2 and C# XmlTextReader has been changed
slightly to match the conventions of XML::LibXML. Some functions have been
changed or added with respect to the C interface.
.SH "CONSTRUCTOR"
.IX Header "CONSTRUCTOR"
Depending on the \s-1XML\s0 source, the Reader object can be created with either of:
.PP
.Vb 5
\&  my $reader = XML::LibXML::Reader\->new( location => "file.xml", ... );
\&    my $reader = XML::LibXML::Reader\->new( string => $xml_string, ... );
\&    my $reader = XML::LibXML::Reader\->new( IO => $file_handle, ... );
\&    my $reader = XML::LibXML::Reader\->new( FD => fileno(STDIN), ... );
\&    my $reader = XML::LibXML::Reader\->new( DOM => $dom, ... );
.Ve
.PP
where ... are (optional) reader options described below in \*(L"Reader options\*(R" or various parser options described in XML::LibXML::Parser. The constructor recognizes the following \s-1XML\s0 sources:
.SS "Source specification"
.IX Subsection "Source specification"
.IP "location" 4
.IX Item "location"
Read \s-1XML\s0 from a local file or \s-1URL.\s0
.IP "string" 4
.IX Item "string"
Read \s-1XML\s0 from a string.
.IP "\s-1IO\s0" 4
.IX Item "IO"
Read \s-1XML\s0 a Perl \s-1IO\s0 filehandle.
.IP "\s-1FD\s0" 4
.IX Item "FD"
Read \s-1XML\s0 from a file descriptor (bypasses Perl I/O layer, only applicable to
filehandles for regular files or pipes). Possibly faster than \s-1IO.\s0
.IP "\s-1DOM\s0" 4
.IX Item "DOM"
Use reader \s-1API\s0 to walk through a pre-parsed XML::LibXML::Document.
.SS "Reader options"
.IX Subsection "Reader options"
.ie n .IP "encoding => $encoding" 4
.el .IP "encoding => \f(CW$encoding\fR" 4
.IX Item "encoding => $encoding"
override document encoding.
.ie n .IP "RelaxNG => $rng_schema" 4
.el .IP "RelaxNG => \f(CW$rng_schema\fR" 4
.IX Item "RelaxNG => $rng_schema"
can be used to pass either a XML::LibXML::RelaxNG object or a filename or \s-1URL\s0 of a RelaxNG schema to the constructor. The schema
is then used to validate the document as it is processed.
.ie n .IP "Schema => $xsd_schema" 4
.el .IP "Schema => \f(CW$xsd_schema\fR" 4
.IX Item "Schema => $xsd_schema"
can be used to pass either a XML::LibXML::Schema object or a filename or \s-1URL\s0 of a W3C \s-1XSD\s0 schema to the constructor. The schema
is then used to validate the document as it is processed.
.IP "..." 4
the reader further supports various parser options described in XML::LibXML::Parser (specifically those labeled by /reader/).
.SH "METHODS CONTROLLING PARSING PROGRESS"
.IX Header "METHODS CONTROLLING PARSING PROGRESS"
.IP "read ()" 4
.IX Item "read ()"
Moves the position to the next node in the stream, exposing its properties.
.Sp
Returns 1 if the node was read successfully, 0 if there is no more nodes to
read, or \-1 in case of error
.IP "readAttributeValue ()" 4
.IX Item "readAttributeValue ()"
Parses an attribute value into one or more Text and EntityReference nodes.
.Sp
Returns 1 in case of success, 0 if the reader was not positioned on an
attribute node or all the attribute values have been read, or \-1 in case of
error.
.IP "readState ()" 4
.IX Item "readState ()"
Gets the read state of the reader. Returns the state value, or \-1 in case of
error. The module exports constants for the Reader states, see \s-1STATES\s0 below.
.IP "depth ()" 4
.IX Item "depth ()"
The depth of the node in the tree, starts at 0 for the root node.
.IP "next ()" 4
.IX Item "next ()"
Skip to the node following the current one in the document order while avoiding
the sub-tree if any. Returns 1 if the node was read successfully, 0 if there is
no more nodes to read, or \-1 in case of error.
.IP "nextElement (localname?,nsURI?)" 4
.IX Item "nextElement (localname?,nsURI?)"
Skip nodes following the current one in the document order until a specific
element is reached. The element's name must be equal to a given localname if
defined, and its namespace must equal to a given nsURI if defined. Either of
the arguments can be undefined (or omitted, in case of the latter or both).
.Sp
Returns 1 if the element was found, 0 if there is no more nodes to read, or \-1
in case of error.
.IP "nextPatternMatch (compiled_pattern)" 4
.IX Item "nextPatternMatch (compiled_pattern)"
Skip nodes following the current one in the document order until an element
matching a given compiled pattern is reached. See XML::LibXML::Pattern for information on compiled patterns. See also the \f(CW\*(C`matchesPattern\*(C'\fR method.
.Sp
Returns 1 if the element was found, 0 if there is no more nodes to read, or \-1
in case of error.
.IP "skipSiblings ()" 4
.IX Item "skipSiblings ()"
Skip all nodes on the same or lower level until the first node on a higher
level is reached. In particular, if the current node occurs in an element, the
reader stops at the end tag of the parent element, otherwise it stops at a node
immediately following the parent node.
.Sp
Returns 1 if successful, 0 if end of the document is reached, or \-1 in case of
error.
.IP "nextSibling ()" 4
.IX Item "nextSibling ()"
It skips to the node following the current one in the document order while
avoiding the sub-tree if any.
.Sp
Returns 1 if the node was read successfully, 0 if there is no more nodes to
read, or \-1 in case of error
.IP "nextSiblingElement (name?,nsURI?)" 4
.IX Item "nextSiblingElement (name?,nsURI?)"
Like nextElement but only processes sibling elements of the current node
(moving forward using \f(CW\*(C`nextSibling ()\*(C'\fR rather than \f(CW\*(C`read ()\*(C'\fR, internally).
.Sp
Returns 1 if the element was found, 0 if there is no more sibling nodes, or \-1
in case of error.
.IP "finish ()" 4
.IX Item "finish ()"
Skip all remaining nodes in the document, reaching end of the document.
.Sp
Returns 1 if successful, 0 in case of error.
.IP "close ()" 4
.IX Item "close ()"
This method releases any resources allocated by the current instance and closes
any underlying input. It returns 0 on failure and 1 on success. This method is
automatically called by the destructor when the reader is forgotten, therefore
you do not have to call it directly.
.SH "METHODS EXTRACTING INFORMATION"
.IX Header "METHODS EXTRACTING INFORMATION"
.IP "name ()" 4
.IX Item "name ()"
Returns the qualified name of the current node, equal to (Prefix:)LocalName.
.IP "nodeType ()" 4
.IX Item "nodeType ()"
Returns the type of the current node. See \s-1NODE TYPES\s0 below.
.IP "localName ()" 4
.IX Item "localName ()"
Returns the local name of the node.
.IP "prefix ()" 4
.IX Item "prefix ()"
Returns the prefix of the namespace associated with the node.
.IP "namespaceURI ()" 4
.IX Item "namespaceURI ()"
Returns the \s-1URI\s0 defining the namespace associated with the node.
.IP "isEmptyElement ()" 4
.IX Item "isEmptyElement ()"
Check if the current node is empty, this is a bit bizarre in the sense that
<a/> will be considered empty while <a></a> will not.
.IP "hasValue ()" 4
.IX Item "hasValue ()"
Returns true if the node can have a text value.
.IP "value ()" 4
.IX Item "value ()"
Provides the text value of the node if present or undef if not available.
.IP "readInnerXml ()" 4
.IX Item "readInnerXml ()"
Reads the contents of the current node, including child nodes and markup.
Returns a string containing the \s-1XML\s0 of the node's content, or undef if the
current node is neither an element nor attribute, or has no child nodes.
.IP "readOuterXml ()" 4
.IX Item "readOuterXml ()"
Reads the contents of the current node, including child nodes and markup.
.Sp
Returns a string containing the \s-1XML\s0 of the node including its content, or undef
if the current node is neither an element nor attribute.
.IP "\fInodePath()\fR" 4
.IX Item "nodePath()"
Returns a canonical location path to the current element from the root node to
the current node. Namespaced elements are matched by '*', because there is no
way to declare prefixes within XPath patterns. Unlike \f(CW\*(C`XML::LibXML::Node::nodePath()\*(C'\fR, this function does not provide sibling counts (i.e. instead of e.g. '/a/b[1]'
and '/a/b[2]' you get '/a/b' for both matches).
.IP "matchesPattern(compiled_pattern)" 4
.IX Item "matchesPattern(compiled_pattern)"
Returns a true value if the current node matches a compiled pattern. See XML::LibXML::Pattern for information on compiled patterns. See also the \f(CW\*(C`nextPatternMatch\*(C'\fR method.
.SH "METHODS EXTRACTING DOM NODES"
.IX Header "METHODS EXTRACTING DOM NODES"
.IP "document ()" 4
.IX Item "document ()"
Provides access to the document tree built by the reader. This function can be
used to collect the preserved nodes (see \f(CW\*(C`preserveNode()\*(C'\fR and preservePattern).
.Sp
\&\s-1CAUTION:\s0 Never use this function to modify the tree unless reading of the whole
document is completed!
.IP "copyCurrentNode (deep)" 4
.IX Item "copyCurrentNode (deep)"
This function is similar a \s-1DOM\s0 function \f(CW\*(C`copyNode()\*(C'\fR. It returns a copy of the currently processed node as a corresponding \s-1DOM\s0
object. Use deep = 1 to obtain the full sub-tree.
.IP "preserveNode ()" 4
.IX Item "preserveNode ()"
This tells the \s-1XML\s0 Reader to preserve the current node in the document tree. A
document tree consisting of the preserved nodes and their content can be
obtained using the method \f(CW\*(C`document()\*(C'\fR once parsing is finished.
.Sp
Returns the node or \s-1NULL\s0 in case of error.
.IP "preservePattern (pattern,\e%ns_map)" 4
.IX Item "preservePattern (pattern,%ns_map)"
This tells the \s-1XML\s0 Reader to preserve all nodes matched by the pattern (which
is a streaming XPath subset). A document tree consisting of the preserved nodes
and their content can be obtained using the method \f(CW\*(C`document()\*(C'\fR once parsing is finished.
.Sp
An optional second argument can be used to provide a \s-1HASH\s0 reference mapping
prefixes used by the XPath to namespace URIs.
.Sp
The XPath subset available with this function is described at
.Sp
.Vb 1
\&  http://www.w3.org/TR/xmlschema\-1/#Selector
.Ve
.Sp
and matches the production
.Sp
.Vb 1
\&  Path ::= (\*(Aq.//\*(Aq)? ( Step \*(Aq/\*(Aq )* ( Step | \*(Aq@\*(Aq NameTest )
.Ve
.Sp
Returns a positive number in case of success and \-1 in case of error
.SH "METHODS PROCESSING ATTRIBUTES"
.IX Header "METHODS PROCESSING ATTRIBUTES"
.IP "attributeCount ()" 4
.IX Item "attributeCount ()"
Provides the number of attributes of the current node.
.IP "hasAttributes ()" 4
.IX Item "hasAttributes ()"
Whether the node has attributes.
.IP "getAttribute (name)" 4
.IX Item "getAttribute (name)"
Provides the value of the attribute with the specified qualified name.
.Sp
Returns a string containing the value of the specified attribute, or undef in
case of error.
.IP "getAttributeNs (localName, namespaceURI)" 4
.IX Item "getAttributeNs (localName, namespaceURI)"
Provides the value of the specified attribute.
.Sp
Returns a string containing the value of the specified attribute, or undef in
case of error.
.IP "getAttributeNo (no)" 4
.IX Item "getAttributeNo (no)"
Provides the value of the attribute with the specified index relative to the
containing element.
.Sp
Returns a string containing the value of the specified attribute, or undef in
case of error.
.IP "isDefault ()" 4
.IX Item "isDefault ()"
Returns true if the current attribute node was generated from the default value
defined in the \s-1DTD.\s0
.IP "moveToAttribute (name)" 4
.IX Item "moveToAttribute (name)"
Moves the position to the attribute with the specified local name and namespace
\&\s-1URI.\s0
.Sp
Returns 1 in case of success, \-1 in case of error, 0 if not found
.IP "moveToAttributeNo (no)" 4
.IX Item "moveToAttributeNo (no)"
Moves the position to the attribute with the specified index relative to the
containing element.
.Sp
Returns 1 in case of success, \-1 in case of error, 0 if not found
.IP "moveToAttributeNs (localName,namespaceURI)" 4
.IX Item "moveToAttributeNs (localName,namespaceURI)"
Moves the position to the attribute with the specified local name and namespace
\&\s-1URI.\s0
.Sp
Returns 1 in case of success, \-1 in case of error, 0 if not found
.IP "moveToFirstAttribute ()" 4
.IX Item "moveToFirstAttribute ()"
Moves the position to the first attribute associated with the current node.
.Sp
Returns 1 in case of success, \-1 in case of error, 0 if not found
.IP "moveToNextAttribute ()" 4
.IX Item "moveToNextAttribute ()"
Moves the position to the next attribute associated with the current node.
.Sp
Returns 1 in case of success, \-1 in case of error, 0 if not found
.IP "moveToElement ()" 4
.IX Item "moveToElement ()"
Moves the position to the node that contains the current attribute node.
.Sp
Returns 1 in case of success, \-1 in case of error, 0 if not moved
.IP "isNamespaceDecl ()" 4
.IX Item "isNamespaceDecl ()"
Determine whether the current node is a namespace declaration rather than a
regular attribute.
.Sp
Returns 1 if the current node is a namespace declaration, 0 if it is a regular
attribute or other type of node, or \-1 in case of error.
.SH "OTHER METHODS"
.IX Header "OTHER METHODS"
.IP "lookupNamespace (prefix)" 4
.IX Item "lookupNamespace (prefix)"
Resolves a namespace prefix in the scope of the current element.
.Sp
Returns a string containing the namespace \s-1URI\s0 to which the prefix maps or undef
in case of error.
.IP "encoding ()" 4
.IX Item "encoding ()"
Returns a string containing the encoding of the document or undef in case of
error.
.IP "standalone ()" 4
.IX Item "standalone ()"
Determine the standalone status of the document being read. Returns 1 if the
document was declared to be standalone, 0 if it was declared to be not
standalone, or \-1 if the document did not specify its standalone status or in
case of error.
.IP "xmlVersion ()" 4
.IX Item "xmlVersion ()"
Determine the \s-1XML\s0 version of the document being read. Returns a string
containing the \s-1XML\s0 version of the document or undef in case of error.
.IP "baseURI ()" 4
.IX Item "baseURI ()"
Returns the base \s-1URI\s0 of a given node.
.IP "isValid ()" 4
.IX Item "isValid ()"
Retrieve the validity status from the parser.
.Sp
Returns 1 if valid, 0 if no, and \-1 in case of error.
.IP "xmlLang ()" 4
.IX Item "xmlLang ()"
The xml:lang scope within which the node resides.
.IP "lineNumber ()" 4
.IX Item "lineNumber ()"
Provide the line number of the current parsing point.
.IP "columnNumber ()" 4
.IX Item "columnNumber ()"
Provide the column number of the current parsing point.
.IP "byteConsumed ()" 4
.IX Item "byteConsumed ()"
This function provides the current index of the parser relative to the start of
the current entity. This function is computed in bytes from the beginning
starting at zero and finishing at the size in bytes of the file if parsing a
file. The function is of constant cost if the input is \s-1UTF\-8\s0 but can be costly
if run on non\-UTF\-8 input.
.IP "setParserProp (prop => value, ...)" 4
.IX Item "setParserProp (prop => value, ...)"
Change the parser processing behaviour by changing some of its internal
properties. The following properties are available with this function:
``load_ext_dtd'', ``complete_attributes'', ``validation'', ``expand_entities''.
.Sp
Since some of the properties can only be changed before any read has been done,
it is best to set the parsing properties at the constructor.
.Sp
Returns 0 if the call was successful, or \-1 in case of error
.IP "getParserProp (prop)" 4
.IX Item "getParserProp (prop)"
Get value of an parser internal property. The following property names can be
used: ``load_ext_dtd'', ``complete_attributes'', ``validation'',
``expand_entities''.
.Sp
Returns the value, usually 0 or 1, or \-1 in case of error.
.SH "DESTRUCTION"
.IX Header "DESTRUCTION"
XML::LibXML takes care of the reader object destruction when the last reference
to the reader object goes out of scope. The document tree is preserved, though,
if either of \f(CW$reader\fR\->document or \f(CW$reader\fR\->preserveNode was used and references
to the document tree exist.
.SH "NODE TYPES"
.IX Header "NODE TYPES"
The reader interface provides the following constants for node types (the
constant symbols are exported by default or if tag \f(CW\*(C`:types\*(C'\fR is used).
.PP
.Vb 10
\&  XML_READER_TYPE_NONE                    => 0
\&  XML_READER_TYPE_ELEMENT                 => 1
\&  XML_READER_TYPE_ATTRIBUTE               => 2
\&  XML_READER_TYPE_TEXT                    => 3
\&  XML_READER_TYPE_CDATA                   => 4
\&  XML_READER_TYPE_ENTITY_REFERENCE        => 5
\&  XML_READER_TYPE_ENTITY                  => 6
\&  XML_READER_TYPE_PROCESSING_INSTRUCTION  => 7
\&  XML_READER_TYPE_COMMENT                 => 8
\&  XML_READER_TYPE_DOCUMENT                => 9
\&  XML_READER_TYPE_DOCUMENT_TYPE           => 10
\&  XML_READER_TYPE_DOCUMENT_FRAGMENT       => 11
\&  XML_READER_TYPE_NOTATION                => 12
\&  XML_READER_TYPE_WHITESPACE              => 13
\&  XML_READER_TYPE_SIGNIFICANT_WHITESPACE  => 14
\&  XML_READER_TYPE_END_ELEMENT             => 15
\&  XML_READER_TYPE_END_ENTITY              => 16
\&  XML_READER_TYPE_XML_DECLARATION         => 17
.Ve
.SH "STATES"
.IX Header "STATES"
The following constants represent the values returned by \f(CW\*(C`readState()\*(C'\fR. They are exported by default, or if tag \f(CW\*(C`:states\*(C'\fR is used:
.PP
.Vb 8
\&  XML_READER_NONE      => \-1
\&  XML_READER_START     =>  0
\&  XML_READER_ELEMENT   =>  1
\&  XML_READER_END       =>  2
\&  XML_READER_EMPTY     =>  3
\&  XML_READER_BACKTRACK =>  4
\&  XML_READER_DONE      =>  5
\&  XML_READER_ERROR     =>  6
.Ve
.SH "SEE ALSO"
.IX Header "SEE ALSO"
XML::LibXML::Pattern for information about compiled patterns.
.PP
http://xmlsoft.org/html/libxml\-xmlreader.html
.PP
http://dotgnu.org/pnetlib\-doc/System/Xml/XmlTextReader.html
.SH "ORIGINAL IMPLEMENTATION"
.IX Header "ORIGINAL IMPLEMENTATION"
Heiko Klein, <H.Klein@gmx.net<gt> and Petr Pajas
.SH "AUTHORS"
.IX Header "AUTHORS"
Matt Sergeant,
Christian Glahn,
Petr Pajas
.SH "VERSION"
.IX Header "VERSION"
2.0110
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
2001\-2007, AxKit.com Ltd.
.PP
2002\-2006, Christian Glahn.
.PP
2006\-2009, Petr Pajas.
.SH "LICENSE"
.IX Header "LICENSE"
This program is free software; you can redistribute it and/or modify it under
the same terms as Perl itself.
