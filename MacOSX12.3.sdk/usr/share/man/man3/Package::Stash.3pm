.\" Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Package::Stash 3"
.TH Package::Stash 3 "2018-12-31" "perl v5.30.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Package::Stash \- routines for manipulating stashes
.SH "VERSION"
.IX Header "VERSION"
version 0.38
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 6
\&  my $stash = Package::Stash\->new(\*(AqFoo\*(Aq);
\&  $stash\->add_symbol(\*(Aq%foo\*(Aq, {bar => 1});
\&  # $Foo::foo{bar} == 1
\&  $stash\->has_symbol(\*(Aq$foo\*(Aq) # false
\&  my $namespace = $stash\->namespace;
\&  *{ $namespace\->{foo} }{HASH} # {bar => 1}
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Manipulating stashes (Perl's symbol tables) is occasionally necessary, but
incredibly messy, and easy to get wrong. This module hides all of that behind a
simple \s-1API.\s0
.PP
\&\s-1NOTE:\s0 Most methods in this class require a variable specification that includes
a sigil. If this sigil is absent, it is assumed to represent the \s-1IO\s0 slot.
.PP
Due to limitations in the typeglob \s-1API\s0 available to perl code, and to typeglob
manipulation in perl being quite slow, this module provides two
implementations \- one in pure perl, and one using \s-1XS.\s0 The \s-1XS\s0 implementation is
to be preferred for most usages; the pure perl one is provided for cases where
\&\s-1XS\s0 modules are not a possibility. The current implementation in use can be set
by setting \f(CW$ENV{PACKAGE_STASH_IMPLEMENTATION}\fR or
\&\f(CW$Package::Stash::IMPLEMENTATION\fR before loading Package::Stash (with the
environment variable taking precedence), otherwise, it will use the \s-1XS\s0
implementation if possible, falling back to the pure perl one.
.SH "METHODS"
.IX Header "METHODS"
.ie n .SS "new $package_name"
.el .SS "new \f(CW$package_name\fP"
.IX Subsection "new $package_name"
Creates a new \f(CW\*(C`Package::Stash\*(C'\fR object, for the package given as the only
argument.
.SS "name"
.IX Subsection "name"
Returns the name of the package that this object represents.
.SS "namespace"
.IX Subsection "namespace"
Returns the raw stash itself.
.ie n .SS "add_symbol $variable $value %opts"
.el .SS "add_symbol \f(CW$variable\fP \f(CW$value\fP \f(CW%opts\fP"
.IX Subsection "add_symbol $variable $value %opts"
Adds a new package symbol, for the symbol given as \f(CW$variable\fR, and optionally
gives it an initial value of \f(CW$value\fR. \f(CW$variable\fR should be the name of
variable including the sigil, so
.PP
.Vb 1
\&  Package::Stash\->new(\*(AqFoo\*(Aq)\->add_symbol(\*(Aq%foo\*(Aq)
.Ve
.PP
will create \f(CW%Foo::foo\fR.
.PP
Valid options (all optional) are \f(CW\*(C`filename\*(C'\fR, \f(CW\*(C`first_line_num\*(C'\fR, and
\&\f(CW\*(C`last_line_num\*(C'\fR.
.PP
\&\f(CW$opts{filename}\fR, \f(CW$opts{first_line_num}\fR, and \f(CW$opts{last_line_num}\fR can
be used to indicate where the symbol should be regarded as having been defined.
Currently these values are only used if the symbol is a subroutine ('\f(CW\*(C`&\*(C'\fR'
sigil) and only if \f(CW\*(C`$^P & 0x10\*(C'\fR is true, in which case the special \f(CW%DB::sub\fR
hash is updated to record the values of \f(CW\*(C`filename\*(C'\fR, \f(CW\*(C`first_line_num\*(C'\fR, and
\&\f(CW\*(C`last_line_num\*(C'\fR for the subroutine. If these are not passed, their values are
inferred (as much as possible) from \f(CW\*(C`caller\*(C'\fR information.
.PP
This is especially useful for debuggers and profilers, which use \f(CW%DB::sub\fR to
determine where the source code for a subroutine can be found.  See
<http://perldoc.perl.org/perldebguts.html#Debugger\-Internals> for more
information about \f(CW%DB::sub\fR.
.ie n .SS "remove_glob $name"
.el .SS "remove_glob \f(CW$name\fP"
.IX Subsection "remove_glob $name"
Removes all package variables with the given name, regardless of sigil.
.ie n .SS "has_symbol $variable"
.el .SS "has_symbol \f(CW$variable\fP"
.IX Subsection "has_symbol $variable"
Returns whether or not the given package variable (including sigil) exists.
.ie n .SS "get_symbol $variable"
.el .SS "get_symbol \f(CW$variable\fP"
.IX Subsection "get_symbol $variable"
Returns the value of the given package variable (including sigil).
.ie n .SS "get_or_add_symbol $variable"
.el .SS "get_or_add_symbol \f(CW$variable\fP"
.IX Subsection "get_or_add_symbol $variable"
Like \f(CW\*(C`get_symbol\*(C'\fR, except that it will return an empty hashref or
arrayref if the variable doesn't exist.
.ie n .SS "remove_symbol $variable"
.el .SS "remove_symbol \f(CW$variable\fP"
.IX Subsection "remove_symbol $variable"
Removes the package variable described by \f(CW$variable\fR (which includes the
sigil); other variables with the same name but different sigils will be
untouched.
.ie n .SS "list_all_symbols $type_filter"
.el .SS "list_all_symbols \f(CW$type_filter\fP"
.IX Subsection "list_all_symbols $type_filter"
Returns a list of package variable names in the package, without sigils. If a
\&\f(CW\*(C`type_filter\*(C'\fR is passed, it is used to select package variables of a given
type, where valid types are the slots of a typeglob ('\s-1SCALAR\s0', '\s-1CODE\s0', '\s-1HASH\s0',
etc). Note that if the package contained any \f(CW\*(C`BEGIN\*(C'\fR blocks, perl will leave
an empty typeglob in the \f(CW\*(C`BEGIN\*(C'\fR slot, so this will show up if no filter is
used (and similarly for \f(CW\*(C`INIT\*(C'\fR, \f(CW\*(C`END\*(C'\fR, etc).
.ie n .SS "get_all_symbols $type_filter"
.el .SS "get_all_symbols \f(CW$type_filter\fP"
.IX Subsection "get_all_symbols $type_filter"
Returns a hashref, keyed by the variable names in the package. If
\&\f(CW$type_filter\fR is passed, the hash will contain every variable of that type in
the package as values, otherwise, it will contain the typeglobs corresponding
to the variable names (basically, a clone of the stash).
.SH "WORKING WITH VARIABLES"
.IX Header "WORKING WITH VARIABLES"
It is important to note, that when working with scalar variables, the default
behavior is to \fBcopy\fR values.
.PP
.Vb 6
\&  my $stash = Package::Stash\->new(\*(AqSome::Namespace\*(Aq);
\&  my $variable = 1;
\&  # $Some::Namespace::name is a copy of $variable
\&  $stash\->add_symbol(\*(Aq$name\*(Aq, $variable);
\&  $variable++
\&  # $Some::Namespace::name == 1 , $variable == 2
.Ve
.PP
This will likely confuse people who expect it to work the same as typeglob
assignment, which simply creates new references to existing variables.
.PP
.Vb 7
\&  my $variable = 1;
\&  {
\&      no strict \*(Aqrefs\*(Aq;
\&      # assign $Package::Stash::name = $variable
\&      *{\*(AqPackage::Stash::name\*(Aq} = \e$variable;
\&  }
\&  $variable++ # affects both names
.Ve
.PP
If this behaviour is desired when working with Package::Stash, simply pass
Package::Stash a scalar ref:
.PP
.Vb 6
\&  my $stash = Package::Stash\->new(\*(AqSome::Namespace\*(Aq);
\&  my $variable = 1;
\&  # $Some::Namespace::name is now $variable
\&  $stash\->add_symbol(\*(Aq$name\*(Aq, \e$variable);
\&  $variable++
\&  # $Some::Namespace::name == 2 , $variable == 2
.Ve
.PP
This will be what you want as well if you're ever working with Readonly
variables:
.PP
.Vb 2
\&  use Readonly;
\&  Readonly my $value, \*(Aqhello\*(Aq;
\&
\&  $stash\->add_symbol(\*(Aq$name\*(Aq, \e$value); # reference
\&  print $Some::Namespace::name; # hello
\&  # Tries to modify the read\-only \*(Aqhello\*(Aq and dies.
\&  $Some::Namespace::name .= " world";
\&
\&  $stash\->add_symbol(\*(Aq$name\*(Aq, $value); # copy
\&  print $Some::Namespace::name; # hello
\&  # No problem, modifying a copy, not the original
\&  $Some::Namespace::name .= " world";
.Ve
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.IP "\(bu" 4
Class::MOP::Package
.Sp
This module is a factoring out of code that used to live here
.SH "SUPPORT"
.IX Header "SUPPORT"
You can find this documentation for this module with the perldoc command.
.PP
.Vb 1
\&    perldoc Package::Stash
.Ve
.PP
You can also look for information at:
.IP "\(bu" 4
MetaCPAN
.Sp
<https://metacpan.org/release/Package\-Stash>
.IP "\(bu" 4
Github
.Sp
<https://github.com/moose/Package\-Stash>
.IP "\(bu" 4
\&\s-1RT: CPAN\s0's request tracker
.Sp
<http://rt.cpan.org/NoAuth/Bugs.html?Dist=Package\-Stash>
.IP "\(bu" 4
\&\s-1CPAN\s0 Ratings
.Sp
<http://cpanratings.perl.org/d/Package\-Stash>
.SH "HISTORY"
.IX Header "HISTORY"
Based on code from Class::MOP::Package, by Stevan Little and the Moose
Cabal.
.SH "BUGS / CAVEATS"
.IX Header "BUGS / CAVEATS"
.IP "\(bu" 4
Prior to perl 5.10, scalar slots are only considered to exist if they are defined
.Sp
This is due to a shortcoming within perl itself. See
\&\*(L"Making References\*(R" in perlref point 7 for more information.
.IP "\(bu" 4
\&\s-1GLOB\s0 and \s-1FORMAT\s0 variables are not (yet) accessible through this module.
.IP "\(bu" 4
Also, see the \s-1BUGS\s0 section for the specific backends (Package::Stash::XS and Package::Stash::PP)
.PP
Bugs may be submitted through the \s-1RT\s0 bug tracker <https://rt.cpan.org/Public/Dist/Display.html?Name=Package-Stash>
(or bug\-Package\-Stash@rt.cpan.org <mailto:bug-Package-Stash@rt.cpan.org>).
.SH "AUTHOR"
.IX Header "AUTHOR"
Jesse Luehrs <doy@tozt.net>
.SH "CONTRIBUTORS"
.IX Header "CONTRIBUTORS"
.IP "\(bu" 4
Karen Etheridge <ether@cpan.org>
.IP "\(bu" 4
Carlos Lima <carlos@multi>
.IP "\(bu" 4
Kent Fredric <kentfredric@gmail.com>
.IP "\(bu" 4
Justin Hunter <justin.d.hunter@gmail.com>
.IP "\(bu" 4
Christian Walde <walde.christian@googlemail.com>
.IP "\(bu" 4
Dave Rolsky <autarch@urth.org>
.IP "\(bu" 4
Niko Tyni <ntyni@debian.org>
.IP "\(bu" 4
Renee <reb@perl\-services.de>
.IP "\(bu" 4
Tim Bunce <Tim.Bunce@pobox.com>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is copyright (c) 2018 by Jesse Luehrs.
.PP
This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.
