.\" Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Pegex::Syntax 3"
.TH Pegex::Syntax 3 "2020-02-13" "perl v5.30.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "Pegex Syntax"
.IX Header "Pegex Syntax"
The term \*(L"Pegex\*(R" can be used to mean both the Pegex Parser Framework and also
the Pegex Grammar Language Syntax that is used to write Pegex grammar files.
This document details the Pegex Syntax.
.PP
Pegex is a self-hosting language. That means that the grammar for defining the
Pegex Language is written in the Pegex Language itself. You can see it for
yourself here:
<https://github.com/ingydotnet/pegex\-pgx/blob/master/pegex.pgx>.
.PP
I encourage you to take a quick look at that link even now. A Pegex grammar
(like this one) is made up of 2 parts: a meta section and a rule section.
.PP
The meta section just contains keyword/value meta attributes about the
grammar. Things like the grammar's name and version.
.PP
The real meat of a Pegex grammar is in its rules. The very first rule of the
grammar above is (basically):
.PP
.Vb 1
\&    grammar: meta_section rule_section
.Ve
.PP
Which says, a \fBgrammar\fR \fI\s-1IS\s0\fR a \fBmeta_section\fR \fIfollowed by\fR a
\&\fBrule_section\fR. But hey, we already knew that!
.SH "Meta Section"
.IX Header "Meta Section"
The meta statements ate the top of a grammar file look like this:
.PP
.Vb 1
\&    %pegexKeyword value
.Ve
.PP
Let's look at the top the the pegex.pgx grammar:
.PP
.Vb 3
\&    # This is the Pegex grammar for Pegex grammars!
\&    %grammar pegex
\&    %version 0.1.0
.Ve
.PP
This defines two meta values: \f(CW\*(C`grammar\*(C'\fR and \f(CW\*(C`version\*(C'\fR, which specify the
name and the version of the grammar, respectively.
.PP
You'll also notice that the first line is a comment. Comments start with a
\&\f(CW\*(C`#\*(C'\fR and go until the end of the line. Comments are allowed almost anywhere in
the grammar, both on their own lines, after statements, and even within regex
definitions as we will see later.
.PP
The Pegex Meta Section ends when the Pegex Rule Section begins (with the first
rule definition).
.SH "Rule Section"
.IX Header "Rule Section"
The remainder of a Pegex grammar is a set of named rules. Each rule is a rule
name, followed by a ':', followed by the definition of the rule, followed by a
\&';' or a newline.
.PP
Here are a couple rules from the pegex.pgx grammar. (These are the rules that
start to define a rule!).
.PP
.Vb 4
\&    rule_definition:
\&        rule_start
\&        rule_group
\&        ending
\&
\&    rule_start: /
\&        ( rule_name )     # Capture the rule_name
\&        BLANK*
\&        COLON \-
\&    /
.Ve
.PP
Rule definitions are infix expressions. They consist of tokens separated by
operators, with parentheses to disambiguate binding precedence. There are 3
distinct tokens and 3 operators.
.PP
The 3 token types are: rule-reference, regex and error-message. The 3
operators are \s-1AND\s0 (' '), \s-1OR\s0 ('|') and \s-1ALT\s0 ('%', '%%').
.PP
Here's an example from a Pegex grammar for parsing \s-1JSON:\s0
.PP
.Vb 3
\&    json: hash | array
\&    array: / LSQUARE / ( node* % / COMMA / ) (
\&        / RSQUARE / | \`missing \*(Aq]\*(Aq\` )
.Ve
.PP
This is saying: \*(L"json is either a hash or array. array is '[', zero or more
nodes separated by commas, and a ']'. error if no ']'\*(R".
.PP
\&\f(CW\*(C`hash\*(C'\fR, \f(CW\*(C`array\*(C'\fR and \f(CW\*(C`node\*(C'\fR are rule references, meaning that they refer to
named rules within the grammar that must match at that point. Text surrounded
by a pair of '/' chars forms a regex. Text surrounding by backticks is an
error message.
.PP
\&\f(CW\*(C`LSQUARE\*(C'\fR, \f(CW\*(C`RSQUARE\*(C'\fR and \f(CW\*(C`COMMA\*(C'\fR are also rule references. Rules may be
referred to inside of regexes, as long as they refer to regexes themselves. In
this way big regexes can be assembled from smaller ones, thus leading to reuse
and readability. Finally, the '*' after \f(CW\*(C`node\*(C'\fR is called a \*(L"quantifier\*(R". More
about those later.
.SS "Rule References"
.IX Subsection "Rule References"
A rule reference is the name of a rule inside angle brackets. The brackets are
usually optional. Inside a regex, a rule reference without \f(CW\*(C`<>\*(C'\fR must be
preceded by a whitespace character.
.PP
.Vb 2
\&    <sub_rule_name>
\&    sub_rule_name
.Ve
.PP
When used outside a regex, a reference can have a number of prefix modifiers.
Note the the angle brackets are not required here, but add to readability.
.PP
.Vb 5
\&    =rule  # Zero\-width positive assertion (look\-ahead)
\&    !rule  # Zero\-width negative assertion (look\-ahead)
\&    .rule  # Skip (ie: parse but don\*(Aqt capture a subpattern)
\&    \-rule  # Flat (flatten the array captures)
\&    +rule  # Always wrap
.Ve
.PP
(Skipping and wrapping are explained in [Return Values].)
.PP
A reference can also have a number of suffixed quantifiers. Similar to regular
expression syntax, a quantifier indicates how many times a rule (reference)
should match.
.PP
.Vb 7
\&    rule?      # optional
\&    rule*      # 0 or more times
\&    rule+      # 1 or more times
\&    <rule>8    # exactly 8 times
\&    <rule>2+   # 2 or more times
\&    <rule>2\-3  # 2 or 3 times
\&    <rule>0\-6  # 0 to 6 times
.Ve
.PP
Note that you must use angle brackets if you are using a numbered modifier:
.PP
.Vb 3
\&    rule8    # WRONG!  This would match rule "rule8".
\&    rule2+   # WRONG!  This would match rule "rule2", 1 or more times.
\&    rule2\-3  # WRONG!  Pegex syntax error
.Ve
.PP
There is a special set of predefined "Atoms" that
refer to regular expression fragments. Atoms exist for every punctuation
character and for characters commonly found in regular expressions. Atoms
enhance readability in grammar texts, and allow special characters (like slash
or hash) to be used as Pegex syntax.
.PP
For example, a regex to match a comment might be '#' followed by anything,
followed by a newline. In Pegex, you would write:
.PP
.Vb 1
\&    comment: / HASH ANY* EOL /
.Ve
.PP
instead of:
.PP
.Vb 1
\&    comment: /#.*\er?\en/
.Ve
.PP
Pegex would compile the former into the latter.
.PP
Here are some atoms:
.PP
.Vb 11
\&    DASH    # \-
\&    PLUS    # +
\&    TILDE   # ~
\&    SLASH   # /
\&    HASH    # # (literal)
\&    QMARK   # ? (literal)
\&    STAR    # * (literal)
\&    LPAREN  # ( (literal)
\&    RPAREN  # ) (literal)
\&    WORD    # \ew
\&    WS      # \es
.Ve
.PP
The full list can be found in the [Atoms source
code|<https://metacpan.org/source/Pegex::Grammar::Atoms].>
.SS "Regexes"
.IX Subsection "Regexes"
In Pegex we call the syntax for a regular expression a \*(L"regex\*(R". ie When the
term \*(L"regex\*(R" is used, it is referring to Pegex syntax, and when the term
\&\*(L"regular expression\*(R" is used it refers to the actual regular expression that
the regex is compiled into.
.PP
A regex is a string inside forward slashes.
.PP
.Vb 1
\&    /regex/
.Ve
.PP
The regex syntax mostly follows Perl, with the following exceptions:
.PP
.Vb 2
\&    # Any rules in angle brackets are referenced in the regex
\&    / ( <rule1> | \*(Aqnon_rule\*(Aq ) /  # "non_rule" is interpreted literally
\&
\&    # The syntax implies a /x modifier, so whitespace and comments are
\&    # ignored.
\&    / (
\&        rule1+   # Match rule1 one or more times
\&        |
\&        rule2
\&    ) /
\&
\&    # Whitespace is declared with dash and plus.
\&    / \- rule3 + /  # \- = \es*, + = \es+, etc.
\&
\&    # Any (?XX ) syntax can have the question mark removed
\&    / (: a | b ) /  # same as / (?: a | b ) /
.Ve
.SS "Error Message"
.IX Subsection "Error Message"
An error message is a string inside backticks. If the parser gets to an error
message in the grammar, it throws a parse error with that message.
.PP
.Vb 1
\&    \`error message\`
.Ve
.SS "Operators"
.IX Subsection "Operators"
The Pegex operators in descending precedence order are: \s-1ALT, AND,\s0 and \s-1OR.\s0
.PP
\&\s-1AND\s0 and \s-1OR\s0 are the most common operators. \s-1AND\s0 is represented by the absence of
an operator. Like in these rules:
.PP
.Vb 2
\&    r1: <a><b>
\&    r2: a b
.Ve
.PP
Those are both the same. They mean rule \f(CW\*(C`a\*(C'\fR \s-1AND\s0 (followed immediately by)
rule \f(CW\*(C`b\*(C'\fR.
.PP
\&\s-1OR\s0 means match one or the other.
.PP
.Vb 1
\&    r: a | b | c
.Ve
.PP
means match rule \f(CW\*(C`a\*(C'\fR \s-1OR\s0 rule \f(CW\*(C`b\*(C'\fR \s-1OR\s0 rule \f(CW\*(C`c\*(C'\fR. The rules are checked in
order and if one matches, the others are skipped.
.PP
\&\s-1ALT\s0 means alternation. It's a way to specify a separator in a list.
.PP
.Vb 1
\&    r: a+ % b
.Ve
.PP
would match these:
.PP
.Vb 3
\&    a
\&    aba
\&    ababa
.Ve
.PP
\&\f(CW\*(C`%%\*(C'\fR means that a trailing separator is optional.
.PP
.Vb 1
\&    r: a+ %% b
.Ve
.PP
would match these:
.PP
.Vb 4
\&    a
\&    ab
\&    aba
\&    abab
.Ve
.PP
\&\s-1ANY\s0 operators take precedence over everything else, similar to other parsers.
These rules have the same binding precedence:
.PP
.Vb 2
\&    r1: a b | c % d
\&    r2: (a b) | (c % d)
.Ve
.PP
Parens are not only used for indicating binding precedence; they also can
create quantifiable groups:
.PP
.Vb 1
\&    r1: (a b)+ c
.Ve
.PP
would match:
.PP
.Vb 1
\&    abababac
.Ve
.SH "Return Values"
.IX Header "Return Values"
All return values are based on the capture groups (\f(CW\*(C`$1/$2/$3/etc.\*(C'\fR type
variables) of parsed \s-1RE\s0 statements. The exact structure of the result tree
depends on the type of Receiver used. For example, Pegex::Tree will return:
.PP
.Vb 2
\&    $1              # single capture group
\&    [ @+[1..$#+] ]  # multiple capture groups
.Ve
.PP
This would be a match directly from the \s-1RE\s0 rule. As rules go further
back, things are put into arrays, but only if there is more than one
result. For example:
.PP
.Vb 3
\&    r: (a b)+ % +
\&    a: /( ALPHA+ )/
\&    b: /( DIGIT+ )( PLUS )/
\&
\&    # input = foobar123+
\&    # output (using Pegex::Tree) = [
\&    #     \*(Aqfoobar\*(Aq, [ \*(Aq123\*(Aq, \*(Aq+\*(Aq ]
\&    # ]
\&    #
\&    # input = foobar123+ boofar789+
\&    # output (using Pegex::Tree) = [
\&    #     [ \*(Aqfoobar\*(Aq, [ \*(Aq123\*(Aq, \*(Aq+\*(Aq ] ],
\&    #     [ \*(Aqboofar\*(Aq, [ \*(Aq789\*(Aq, \*(Aq+\*(Aq ] ],
\&    # ]
.Ve
.SS "Skipping"
.IX Subsection "Skipping"
Any rule can use the skip modifier (\s-1DOT\s0) to completely skip the return from
that rule (and any children below it). The rule is still processed, but
nothing is put into the tree. (This is different from, say, putting \f(CW\*(C`undef\*(C'\fR
into the return.) This can also affect the number of values returned, and
thus, whether a value comes as an array:
.PP
.Vb 3
\&    r: (a .b)+ % +
\&    a: /( ALPHA+ )/
\&    b: /( DIGIT+ )( PLUS )/
\&
\&    # input = foobar123+ boofar789+
\&    # output (using Pegex::Tree) = [
\&    #     \*(Aqfoobar\*(Aq,
\&    #     \*(Aqboofar\*(Aq,
\&    # ]
.Ve
.PP
The skip modifier can also be used with groups. (This is the only group
modifier allowed so far.)
.PP
.Vb 3
\&    r: .(a b)+ % +
\&    a: /( ALPHA+ )/
\&    b: /( DIGIT+ )( PLUS )/
\&
\&    # output (using Pegex::Tree) = []
.Ve
.SS "Wrapping"
.IX Subsection "Wrapping"
You can also turn on \*(L"wrapping\*(R" with the Pegex::Tree::Wrap receiver. This
will wrap all match values in a hash with the rule name, like so:
.PP
.Vb 2
\&    { rule_A => $match }
\&    { rule_B => [ @matches ] }
.Ve
.PP
Note that this behavior can be \*(L"hard set\*(R" with the \f(CW\*(C`+/\-\*(C'\fR rule modifiers:
.PP
.Vb 2
\&    \-rule  # Flatten array captures
\&    +rule  # Always wrap (even if using Pegex::Tree)
.Ve
.PP
This is simply a check in the \f(CW\*(C`gotrule\*(C'\fR for the receiver. So, any specific
\&\f(CW\*(C`got_*\*(C'\fR receiver methods will override even these settings, and choose to
pass the match as-is. In this case, the \f(CW\*(C`got_*\*(C'\fR sub return value dictates
what ultimately gets put into the tree object:
.PP
.Vb 1
\&    +rule_A   # in this case, the + is useless here
\&
\&    sub got_rule_A {
\&        my ($self, $matches_arrayref) = @_;
\&        return $matches_arrayref;
\&        # will be received as [ @matches ]
\&    }
.Ve
.PP
You can \*(L"correct\*(R" this behavior by passing it back to \f(CW\*(C`gotrule\*(C'\fR:
.PP
.Vb 1
\&    +rule_A   # now + is honored
\&
\&    sub got_rule_A {
\&        my ($self, $matches_arrayref) = @_;
\&        return $self\->gotrule($matches_arrayref);
\&        # will be received as { rule_A => [ @matches ] }
\&    }
.Ve
.SH "See Also"
.IX Header "See Also"
.IP "\(bu" 4
Pegex::API
.IP "\(bu" 4
Pegex::Tutorial
.IP "\(bu" 4
Pegex::Resources
