.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "IPC::Open3 3pm"
.TH IPC::Open3 3pm "2014-09-30" "perl v5.18.4" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
IPC::Open3 \- open a process for reading, writing, and error handling using open3()
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&    $pid = open3(\e*CHLD_IN, \e*CHLD_OUT, \e*CHLD_ERR,
\&                    \*(Aqsome cmd and args\*(Aq, \*(Aqoptarg\*(Aq, ...);
\&
\&    my($wtr, $rdr, $err);
\&    use Symbol \*(Aqgensym\*(Aq; $err = gensym;
\&    $pid = open3($wtr, $rdr, $err,
\&                    \*(Aqsome cmd and args\*(Aq, \*(Aqoptarg\*(Aq, ...);
\&
\&    waitpid( $pid, 0 );
\&    my $child_exit_status = $? >> 8;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Extremely similar to \fIopen2()\fR, \fIopen3()\fR spawns the given \f(CW$cmd\fR and
connects \s-1CHLD_OUT\s0 for reading from the child, \s-1CHLD_IN\s0 for writing to
the child, and \s-1CHLD_ERR\s0 for errors.  If \s-1CHLD_ERR\s0 is false, or the
same file descriptor as \s-1CHLD_OUT,\s0 then \s-1STDOUT\s0 and \s-1STDERR\s0 of the child
are on the same filehandle (this means that an autovivified lexical
cannot be used for the \s-1STDERR\s0 filehandle, see \s-1SYNOPSIS\s0).  The \s-1CHLD_IN\s0
will have autoflush turned on.
.PP
If \s-1CHLD_IN\s0 begins with \f(CW\*(C`<&\*(C'\fR, then \s-1CHLD_IN\s0 will be closed in the
parent, and the child will read from it directly.  If \s-1CHLD_OUT\s0 or
\&\s-1CHLD_ERR\s0 begins with \f(CW\*(C`>&\*(C'\fR, then the child will send output
directly to that filehandle.  In both cases, there will be a \fIdup\fR\|(2)
instead of a \fIpipe\fR\|(2) made.
.PP
If either reader or writer is the null string, this will be replaced
by an autogenerated filehandle.  If so, you must pass a valid lvalue
in the parameter slot so it can be overwritten in the caller, or
an exception will be raised.
.PP
The filehandles may also be integers, in which case they are understood
as file descriptors.
.PP
\&\fIopen3()\fR returns the process \s-1ID\s0 of the child process.  It doesn't return on
failure: it just raises an exception matching \f(CW\*(C`/^open3:/\*(C'\fR.  However,
\&\f(CW\*(C`exec\*(C'\fR failures in the child (such as no such file or permission denied),
are just reported to \s-1CHLD_ERR,\s0 as it is not possible to trap them.
.PP
If the child process dies for any reason, the next write to \s-1CHLD_IN\s0 is
likely to generate a \s-1SIGPIPE\s0 in the parent, which is fatal by default.
So you may wish to handle this signal.
.PP
Note if you specify \f(CW\*(C`\-\*(C'\fR as the command, in an analogous fashion to
\&\f(CW\*(C`open(FOO, "\-|")\*(C'\fR the child process will just be the forked Perl
process rather than an external command.  This feature isn't yet
supported on Win32 platforms.
.PP
\&\fIopen3()\fR does not wait for and reap the child process after it exits.
Except for short programs where it's acceptable to let the operating system
take care of this, you need to do this yourself.  This is normally as
simple as calling \f(CW\*(C`waitpid $pid, 0\*(C'\fR when you're done with the process.
Failing to do this can result in an accumulation of defunct or \*(L"zombie\*(R"
processes.  See \*(L"waitpid\*(R" in perlfunc for more information.
.PP
If you try to read from the child's stdout writer and their stderr
writer, you'll have problems with blocking, which means you'll want
to use \fIselect()\fR or the IO::Select, which means you'd best use
\&\fIsysread()\fR instead of \fIreadline()\fR for normal stuff.
.PP
This is very dangerous, as you may block forever.  It assumes it's
going to talk to something like \fBbc\fR, both writing to it and reading
from it.  This is presumably safe because you \*(L"know\*(R" that commands
like \fBbc\fR will read a line at a time and output a line at a time.
Programs like \fBsort\fR that read their entire input stream first,
however, are quite apt to cause deadlock.
.PP
The big problem with this approach is that if you don't have control
over source code being run in the child process, you can't control
what it does with pipe buffering.  Thus you can't just open a pipe to
\&\f(CW\*(C`cat \-v\*(C'\fR and continually read and write a line from it.
.SH "See Also"
.IX Header "See Also"
.IP "IPC::Open2" 4
.IX Item "IPC::Open2"
Like Open3 but without \s-1STDERR\s0 catpure.
.IP "IPC::Run" 4
.IX Item "IPC::Run"
This is a \s-1CPAN\s0 module that has better error handling and more facilities
than Open3.
.SH "WARNING"
.IX Header "WARNING"
The order of arguments differs from that of \fIopen2()\fR.
