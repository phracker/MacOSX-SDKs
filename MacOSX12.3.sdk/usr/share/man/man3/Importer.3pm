.\" Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Importer 3"
.TH Importer 3 "2020-08-16" "perl v5.30.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Importer \- Alternative but compatible interface to modules that export symbols.
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module acts as a layer between Exporter and modules which consume
exports. It is feature-compatible with Exporter, plus some much needed
extras. You can use this to import symbols from any exporter that follows
Exporters specification. The exporter modules themselves do not need to use
or inherit from the Exporter module, they just need to set \f(CW@EXPORT\fR and/or
other variables.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&    # Import defaults
\&    use Importer \*(AqSome::Module\*(Aq;
\&
\&    # Import a list
\&    use Importer \*(AqAnother::Module\*(Aq => qw/foo bar baz/;
\&
\&    # Import a specific version:
\&    use Importer \*(AqThat::Module\*(Aq => \*(Aq1.00\*(Aq;
\&
\&    # Require a sepcific version of Importer
\&    use Importer 0.001, \*(AqFoo::Bar\*(Aq => qw/a b c/;
\&
\&    foo()
\&    bar()
\&    baz()
\&
\&    # Remove all subroutines imported by Importer
\&    no Importer;
\&
\&    # Import symbols into variables
\&    my $croak = Importer\->get_one(Carp => qw/croak/);
\&    $croak\->("This will croak");
\&
\&    my $CARP = Importer\->get(Carp => qw/croak confess cluck/);
\&    $CARP\->{croak}\->("This will croak");
\&    $CARP\->{cluck}\->("This will cluck");
\&    $CARP\->{confess}\->("This will confess");
.Ve
.SH "WHY?"
.IX Header "WHY?"
There was recently a discussion on p5p about adding features to Exporter.
This conversation raised some significant concerns, those are listed here, in
addition to others.
.IP "The burden is on export consumers to specify a version of Exporter" 4
.IX Item "The burden is on export consumers to specify a version of Exporter"
Adding a feature to Exporter means that any consumer module that relies on
the new features must depend on a specific version of Exporter. This seems
somewhat backwards since Exporter is used by the module you are importing
from.
.IP "Exporter.pm is really old/crazy code" 4
.IX Item "Exporter.pm is really old/crazy code"
Not much more to say here. It is very old, it is very crazy, and if you break
it you break \s-1EVERYTHING.\s0
.IP "Using a modules \fBimport()\fR for exporting makes it hard to give it other purposes" 4
.IX Item "Using a modules import() for exporting makes it hard to give it other purposes"
It is not unusual for a module to want to export symbols and provide import
behaviors. It is also not unusual for a consumer to only want 1 or the other.
Using this module you can import symbols without also getting the \f(CW\*(C`import()\*(C'\fR
side effects.
.Sp
In addition, moving forward, modules can specify exports and have a custom
\&\f(CW\*(C`import()\*(C'\fR without conflating the two. A module can tell you to use Importer
to get the symbols, and to use the module directly for behaviors. A module
could also use Importer within its own \f(CW\*(C`import()\*(C'\fR method without the need to
subclass Exporter, or bring in its \f(CW\*(C`import()\*(C'\fR method.
.IP "There are other exporter modules on cpan" 4
.IX Item "There are other exporter modules on cpan"
This module normally assumes an exporter uses Exporter, so it looks for the
variables and methods Exporter expects. However, other exporters on cpan can
override this using the \f(CW\*(C`IMPORTER_MENU()\*(C'\fR hook.
.SH "COMPATIBILITY"
.IX Header "COMPATIBILITY"
This module aims for 100% compatibility with every feature of Exporter, plus
added features such as import renaming.
.PP
If you find something that works differently, or not at all when compared to
Exporter please report it as a bug, unless it is noted as an intentional
feature (like import renaming).
.SH "IMPORT PARAMETERS"
.IX Header "IMPORT PARAMETERS"
.Vb 1
\&    use Importer $IMPORTER_VERSION, $FROM_MODULE, $FROM_MODULE_VERSION, \e&SET_SYMBOL, @SYMBOLS;
.Ve
.ie n .IP "$IMPORTER_VERSION (optional)" 4
.el .IP "\f(CW$IMPORTER_VERSION\fR (optional)" 4
.IX Item "$IMPORTER_VERSION (optional)"
If you provide a numeric argument as the first argument it will be treated as a
version number. Importer will do a version check to make sure it is at least at
the requested version.
.ie n .IP "$FROM_MODULE (required)" 4
.el .IP "\f(CW$FROM_MODULE\fR (required)" 4
.IX Item "$FROM_MODULE (required)"
This is the only required argument. This is the name of the module to import
symbols from.
.ie n .IP "$FROM_MODULE_VERSION (optional)" 4
.el .IP "\f(CW$FROM_MODULE_VERSION\fR (optional)" 4
.IX Item "$FROM_MODULE_VERSION (optional)"
Any numeric argument following the \f(CW$FROM_MODULE\fR will be treated as a version
check against \f(CW$FROM_MODULE\fR.
.IP "\e&SET_SYMBOL (optional)" 4
.IX Item "&SET_SYMBOL (optional)"
Normally Importer will put the exports into your namespace. This is usually
done via a more complex form of \f(CW\*(C`*name = $ref\*(C'\fR. If you do \s-1NOT\s0 want this to
happen then you can provide a custom sub to handle the assignment.
.Sp
This is an example that uses this feature to put all the exports into a lexical
hash instead of modifying the namespace (This is how the \f(CW\*(C`get()\*(C'\fR method is
implemented).
.Sp
.Vb 5
\&    my %CARP;
\&    use Importer Carp => sub {
\&        my ($name, $ref) = @_;
\&        $CARP{$name} = $ref;
\&    };
\&
\&    $CARP{cluck}\->("This will cluck");
\&    $CARP{croak}\->("This will croak");
.Ve
.Sp
The first two arguments to the custom sub are the name (no sigil), and the
reference. The additional arguments are key/value pairs:
.Sp
.Vb 3
\&    sub set_symbol {
\&        my ($name, $ref, %info) = @_;
\&    }
.Ve
.RS 4
.ie n .IP "$info{from}" 4
.el .IP "\f(CW$info\fR{from}" 4
.IX Item "$info{from}"
Package the symbol comes from.
.ie n .IP "$info{into}" 4
.el .IP "\f(CW$info\fR{into}" 4
.IX Item "$info{into}"
Package to which the symbol should be added.
.ie n .IP "$info{sig}" 4
.el .IP "\f(CW$info\fR{sig}" 4
.IX Item "$info{sig}"
The sigil that should be used.
.ie n .IP "$info{spec}" 4
.el .IP "\f(CW$info\fR{spec}" 4
.IX Item "$info{spec}"
Extra details.
.ie n .IP "$info{symbol}" 4
.el .IP "\f(CW$info\fR{symbol}" 4
.IX Item "$info{symbol}"
The original symbol name (with sigil) from the original package.
.RE
.RS 4
.RE
.ie n .IP "@SYMBOLS (optional)" 4
.el .IP "\f(CW@SYMBOLS\fR (optional)" 4
.IX Item "@SYMBOLS (optional)"
Symbols you wish to import. If no symbols are specified then the defaults will
be used. You may also specify tags using the ':' prefix.
.SH "SUPPORTED FEATURES"
.IX Header "SUPPORTED FEATURES"
.SS "\s-1TAGS\s0"
.IX Subsection "TAGS"
You can define/import subsets of symbols using predefined tags.
.PP
.Vb 1
\&    use Importer \*(AqSome::Thing\*(Aq => \*(Aq:tag\*(Aq;
.Ve
.PP
Importer will automatically populate the \f(CW\*(C`:DEFAULT\*(C'\fR tag for you.
Importer will also give you an \f(CW\*(C`:ALL\*(C'\fR tag with \s-1ALL\s0 exports so long as the
exporter does not define a \f(CW\*(C`:ALL\*(C'\fR tag already.
.SS "/PATTERN/ or qr/PATTERN/"
.IX Subsection "/PATTERN/ or qr/PATTERN/"
You can import all symbols that match a pattern. The pattern can be supplied a
string starting and ending with '/', or you can provide a \f(CW\*(C`qr/../\*(C'\fR reference.
.PP
.Vb 1
\&    use Importer \*(AqSome::Thing\*(Aq => \*(Aq/oo/\*(Aq;
\&
\&    use Importer \*(AqSome::Thing\*(Aq => qr/oo/;
.Ve
.SS "\s-1EXCLUDING SYMBOLS\s0"
.IX Subsection "EXCLUDING SYMBOLS"
You can exclude symbols by prefixing them with '!'.
.PP
.Vb 5
\&    use Importer \*(AqSome::Thing\*(Aq
\&        \*(Aq!foo\*(Aq,         # Exclude one specific symbol
\&        \*(Aq!/pattern/\*(Aq,   # Exclude all matching symbols
\&        \*(Aq!\*(Aq => qr/oo/,  # Exclude all that match the following arg
\&        \*(Aq!:tag\*(Aq;        # Exclude all in tag
.Ve
.SS "\s-1RENAMING SYMBOLS AT IMPORT\s0"
.IX Subsection "RENAMING SYMBOLS AT IMPORT"
\&\fIThis is a new feature,\fR Exporter \fIdoes not support this on its own.\fR
.PP
You can rename symbols at import time using a specification hash following the
import name:
.PP
.Vb 3
\&    use Importer \*(AqSome::Thing\*(Aq => (
\&        foo => { \-as => \*(Aqmy_foo\*(Aq },
\&    );
.Ve
.PP
You can also add a prefix and/or postfix:
.PP
.Vb 3
\&    use Importer \*(AqSome::Thing\*(Aq => (
\&        foo => { \-prefix => \*(Aqmy_\*(Aq },
\&    );
.Ve
.PP
Using this syntax to set prefix and/or postfix also works on tags and patterns
that are specified for import, in which case the prefix/postfix is applied to
all symbols from the tag/patterm.
.SS "\s-1CUSTOM EXPORT ASSIGNMENT\s0"
.IX Subsection "CUSTOM EXPORT ASSIGNMENT"
This lets you provide an alternative to the \f(CW\*(C`*name = $ref\*(C'\fR export assignment.
See the list of parameters to \f(CW\*(C`import()\*(C'\fR
.SS "\s-1UNIMPORTING\s0"
.IX Subsection "UNIMPORTING"
See \*(L"\s-1UNIMPORT PARAMETERS\*(R"\s0.
.SS "\s-1ANONYMOUS EXPORTS\s0"
.IX Subsection "ANONYMOUS EXPORTS"
See \*(L"%EXPORT_ANON\*(R".
.SS "\s-1GENERATED EXPORTS\s0"
.IX Subsection "GENERATED EXPORTS"
See \*(L"%EXPORT_GEN\*(R".
.SH "UNIMPORT PARAMETERS"
.IX Header "UNIMPORT PARAMETERS"
.Vb 1
\&    no Importer;    # Remove all subs brought in with Importer
\&
\&    no Importer qw/foo bar/;    # Remove only the specified subs
.Ve
.PP
\&\fBOnly subs can be unimported\fR.
.PP
\&\fBYou can only unimport subs imported using Importer\fR.
.SH "SUPPORTED VARIABLES"
.IX Header "SUPPORTED VARIABLES"
.ie n .SS "@EXPORT"
.el .SS "\f(CW@EXPORT\fP"
.IX Subsection "@EXPORT"
This is used exactly the way Exporter uses it.
.PP
List of symbols to export. Sigil is optional for subs. Symbols listed here are
exported by default. If possible you should put symbols in \f(CW@EXPORT_OK\fR
instead.
.PP
.Vb 1
\&    our @EXPORT = qw/foo bar &baz $BAT/;
.Ve
.ie n .SS "@EXPORT_OK"
.el .SS "\f(CW@EXPORT_OK\fP"
.IX Subsection "@EXPORT_OK"
This is used exactly the way Exporter uses it.
.PP
List of symbols that can be imported. Sigil is optional for subs. Symbols
listed here are not exported by default. This is preferred over \f(CW@EXPORT\fR.
.PP
.Vb 1
\&    our @EXPORT_OK = qw/foo bar &baz $BAT/;
.Ve
.ie n .SS "%EXPORT_TAGS"
.el .SS "\f(CW%EXPORT_TAGS\fP"
.IX Subsection "%EXPORT_TAGS"
This module supports tags exactly the way Exporter does.
.PP
.Vb 1
\&    use Importer \*(AqSome::Thing\*(Aq  => \*(Aq:DEFAULT\*(Aq;
\&
\&    use Importer \*(AqOther::Thing\*(Aq => \*(Aq:some_tag\*(Aq;
.Ve
.PP
Tags can be specified this way:
.PP
.Vb 4
\&    our %EXPORT_TAGS = (
\&        oos => [qw/foo boo zoo/],
\&        ees => [qw/fee bee zee/],
\&    );
.Ve
.ie n .SS "@EXPORT_FAIL"
.el .SS "\f(CW@EXPORT_FAIL\fP"
.IX Subsection "@EXPORT_FAIL"
This is used exactly the way Exporter uses it.
.PP
Use this to list subs that are not available on all platforms. If someone tries
to import one of these, Importer will hit your \f(CW\*(C`$from\->export_fail(@items)\*(C'\fR
callback to try to resolve the issue. See Exporter for documentation of
this feature.
.PP
.Vb 1
\&    our @EXPORT_FAIL = qw/maybe_bad/;
.Ve
.ie n .SS "%EXPORT_ANON"
.el .SS "\f(CW%EXPORT_ANON\fP"
.IX Subsection "%EXPORT_ANON"
This is new to this module, Exporter does not support it.
.PP
This allows you to export symbols that are not actually in your package symbol
table. The keys should be the symbol names, the values are the references for
the symbols.
.PP
.Vb 5
\&    our %EXPORT_ANON = (
\&        \*(Aq&foo\*(Aq => sub { \*(Aqfoo\*(Aq }
\&        \*(Aq$foo\*(Aq => \e$foo,
\&        ...
\&    );
.Ve
.ie n .SS "%EXPORT_GEN"
.el .SS "\f(CW%EXPORT_GEN\fP"
.IX Subsection "%EXPORT_GEN"
This is new to this module, Exporter does not support it.
.PP
This allows you to export symbols that are generated on export. The key should
be the name of a symbol. The value should be a coderef that produces a
reference that will be exported.
.PP
When the generators are called they will receive 2 arguments, the package the
symbol is being exported into, and the symbol being imported (name may or may
not include sigil for subs).
.PP
.Vb 9
\&    our %EXPORT_GEN = (
\&        \*(Aq&foo\*(Aq => sub {
\&            my $from_package = shift;
\&            my ($into_package, $symbol_name) = @_;
\&            ...
\&            return sub { ... };
\&        },
\&        ...
\&    );
.Ve
.ie n .SS "%EXPORT_MAGIC"
.el .SS "\f(CW%EXPORT_MAGIC\fP"
.IX Subsection "%EXPORT_MAGIC"
This is new to this module. Exporter does not support it.
.PP
This allows you to define custom actions to run \s-1AFTER\s0 an export has been
injected into the consumers namespace. This is a good place to enable parser
hooks like with Devel::Declare. These will \s-1NOT\s0 be run if a consumer uses a
custom assignment callback.
.PP
.Vb 4
\&    our %EXPORT_MAGIC = (
\&        foo => sub {
\&            my $from = shift;    # Should be the package doing the exporting
\&            my %args = @_;
\&
\&            my $into      = $args{into};         # Package symbol was exported into
\&            my $orig_name = $args{orig_name};    # Original name of the export (in the exporter)
\&            my $new_name  = $args{new_name};     # Name the symbol was imported as
\&            my $ref       = $args{ref};          # The reference to the symbol
\&
\&            ...; # whatever you want, return is ignored.
\&        },
\&    );
.Ve
.SH "CLASS METHODS"
.IX Header "CLASS METHODS"
.IP "Importer\->import($from)" 4
.IX Item "Importer->import($from)"
.PD 0
.ie n .IP "Importer\->import($from, $version)" 4
.el .IP "Importer\->import($from, \f(CW$version\fR)" 4
.IX Item "Importer->import($from, $version)"
.ie n .IP "Importer\->import($from, @imports)" 4
.el .IP "Importer\->import($from, \f(CW@imports\fR)" 4
.IX Item "Importer->import($from, @imports)"
.ie n .IP "Importer\->import($from, $from_version, @imports)" 4
.el .IP "Importer\->import($from, \f(CW$from_version\fR, \f(CW@imports\fR)" 4
.IX Item "Importer->import($from, $from_version, @imports)"
.ie n .IP "Importer\->import($importer_version, $from, ...)" 4
.el .IP "Importer\->import($importer_version, \f(CW$from\fR, ...)" 4
.IX Item "Importer->import($importer_version, $from, ...)"
.PD
This is the magic behind \f(CW\*(C`use Importer ...\*(C'\fR.
.ie n .IP "Importer\->import_into($from, $into, @imports)" 4
.el .IP "Importer\->import_into($from, \f(CW$into\fR, \f(CW@imports\fR)" 4
.IX Item "Importer->import_into($from, $into, @imports)"
.PD 0
.ie n .IP "Importer\->import_into($from, $level, @imports)" 4
.el .IP "Importer\->import_into($from, \f(CW$level\fR, \f(CW@imports\fR)" 4
.IX Item "Importer->import_into($from, $level, @imports)"
.PD
You can use this to import symbols from \f(CW$from\fR into \f(CW$into\fR. \f(CW$into\fR may
either be a package name, or a caller level to get the name from.
.IP "Importer\->\fBunimport()\fR" 4
.IX Item "Importer->unimport()"
.PD 0
.IP "Importer\->unimport(@sub_name)" 4
.IX Item "Importer->unimport(@sub_name)"
.PD
This is the magic behind \f(CW\*(C`no Importer ...\*(C'\fR.
.ie n .IP "Importer\->unimport_from($from, @sub_names)" 4
.el .IP "Importer\->unimport_from($from, \f(CW@sub_names\fR)" 4
.IX Item "Importer->unimport_from($from, @sub_names)"
.PD 0
.ie n .IP "Importer\->unimport_from($level, @sub_names)" 4
.el .IP "Importer\->unimport_from($level, \f(CW@sub_names\fR)" 4
.IX Item "Importer->unimport_from($level, @sub_names)"
.PD
This lets you remove imported symbols from \f(CW$from\fR. \f(CW$from\fR my be a package
name, or a caller level.
.ie n .IP "my $exports = Importer\->get($from, @imports)" 4
.el .IP "my \f(CW$exports\fR = Importer\->get($from, \f(CW@imports\fR)" 4
.IX Item "my $exports = Importer->get($from, @imports)"
This returns hashref of \f(CW\*(C`{ $name => $ref }\*(C'\fR for all the specified imports.
.Sp
\&\f(CW$from\fR should be the package from which to get the exports.
.ie n .IP "my @export_refs = Importer\->get_list($from, @imports)" 4
.el .IP "my \f(CW@export_refs\fR = Importer\->get_list($from, \f(CW@imports\fR)" 4
.IX Item "my @export_refs = Importer->get_list($from, @imports)"
This returns a list of references for each import specified. Only the export
references are returned, the names are not.
.Sp
\&\f(CW$from\fR should be the package from which to get the exports.
.ie n .IP "$export_ref = Importer\->get_one($from, $import)" 4
.el .IP "\f(CW$export_ref\fR = Importer\->get_one($from, \f(CW$import\fR)" 4
.IX Item "$export_ref = Importer->get_one($from, $import)"
This returns a single reference to a single export. If you provide multiple
imports then only the \s-1LAST\s0 one will be used.
.Sp
\&\f(CW$from\fR should be the package from which to get the exports.
.SH "USING WITH OTHER EXPORTER IMPLEMENTATIONS"
.IX Header "USING WITH OTHER EXPORTER IMPLEMENTATIONS"
If you want your module to work with Importer, but you use something other than
Exporter to define your exports, you can make it work be defining the
\&\f(CW\*(C`IMPORTER_MENU\*(C'\fR method in your package. As well other exporters can be updated
to support Importer by putting this sub in your package.
\&\fB\s-1\fBIMPORTER_MENU\s0()\fB must be defined in your package, not a base class!\fR
.PP
.Vb 3
\&    sub IMPORTER_MENU {
\&        my $class = shift;
\&        my ($into, $caller) = @_;
\&
\&        return (
\&            export       => \e@EXPORT,          # Default exports
\&            export_ok    => \e@EXPORT_OK,       # Other allowed exports
\&            export_tags  => \e%EXPORT_TAGS,     # Define tags
\&            export_fail  => \e@EXPORT_FAIL,     # For subs that may not always be available
\&            export_anon  => \e%EXPORT_ANON,     # Anonymous symbols to export
\&            export_magic => \e%EXPORT_MAGIC,    # Magic to apply after a symbol is exported
\&
\&            generate   => \e&GENERATE,          # Sub to generate dynamic exports
\&                                               # OR
\&            export_gen => \e%EXPORT_GEN,        # Hash of builders, key is symbol
\&                                               # name, value is sub that generates
\&                                               # the symbol ref.
\&        );
\&    }
\&
\&    sub GENERATE {
\&        my ($symbol) = @_;
\&
\&        ...
\&
\&        return $ref;
\&    }
.Ve
.PP
All exports must be listed in either \f(CW@EXPORT\fR or \f(CW@EXPORT_OK\fR, or be keys in
\&\f(CW%EXPORT_GEN\fR or \f(CW%EXPORT_ANON\fR to be allowed. 'export_tags', 'export_fail',
\&'export_anon', 'export_gen', and 'generate' are optional. You cannot combine
\&'generate' and 'export_gen'.
.PP
\&\fBNote:\fR If your \s-1GENERATE\s0 sub needs the \f(CW$class\fR, \f(CW$into\fR, or \f(CW$caller\fR then
your \f(CW\*(C`IMPORTER_MENU()\*(C'\fR method will need to build an anonymous sub that closes
over them:
.PP
.Vb 3
\&    sub IMPORTER_MENU {
\&        my $class = shift;
\&        my ($into, $caller) = @_;
\&
\&        return (
\&            ...
\&            generate => sub { $class\->GENERATE($into, $caller, @_) },
\&        );
\&    }
.Ve
.SH "OO Interface"
.IX Header "OO Interface"
.Vb 1
\&    use Importer;
\&
\&    my $imp = Importer\->new(from => \*(AqSome::Exporter\*(Aq);
\&
\&    $imp\->do_import(\*(AqDestination::Package\*(Aq);
\&    $imp\->do_import(\*(AqAnother::Destination\*(Aq, @symbols);
.Ve
.PP
Or, maybe more useful:
.PP
.Vb 3
\&    my $imp = Importer\->new(from => \*(AqCarp\*(Aq);
\&    my $croak = $imp\->get_one(\*(Aqcroak\*(Aq);
\&    $croak\->("This will croak");
.Ve
.SS "\s-1OBJECT CONSTRUCTION\s0"
.IX Subsection "OBJECT CONSTRUCTION"
.ie n .IP "$imp = Importer\->new(from => 'Some::Exporter')" 4
.el .IP "\f(CW$imp\fR = Importer\->new(from => 'Some::Exporter')" 4
.IX Item "$imp = Importer->new(from => 'Some::Exporter')"
.PD 0
.ie n .IP "$imp = Importer\->new(from => 'Some::Exporter', caller => [$package, $file, $line])" 4
.el .IP "\f(CW$imp\fR = Importer\->new(from => 'Some::Exporter', caller => [$package, \f(CW$file\fR, \f(CW$line\fR])" 4
.IX Item "$imp = Importer->new(from => 'Some::Exporter', caller => [$package, $file, $line])"
.PD
This is how you create a new Importer instance. \f(CW\*(C`from => \*(AqSome::Exporter\*(Aq\*(C'\fR
is the only required argument. You may also specify the \f(CW\*(C`caller => [...]\*(C'\fR
arrayref, which will be used only for error reporting. If you do not specify a
caller then Importer will attempt to find the caller dynamically every time it
needs it (this is slow and expensive, but necessary if you intend to re-use the
object.)
.SS "\s-1OBJECT METHODS\s0"
.IX Subsection "OBJECT METHODS"
.ie n .IP "$imp\->do_import($into)" 4
.el .IP "\f(CW$imp\fR\->do_import($into)" 4
.IX Item "$imp->do_import($into)"
.PD 0
.ie n .IP "$imp\->do_import($into, @symbols)" 4
.el .IP "\f(CW$imp\fR\->do_import($into, \f(CW@symbols\fR)" 4
.IX Item "$imp->do_import($into, @symbols)"
.PD
This will import from the objects \f(CW\*(C`from\*(C'\fR package into the \f(CW$into\fR package.
You can provide a list of \f(CW@symbols\fR, or you can leave it empty for the
defaults.
.ie n .IP "$imp\->\fBdo_unimport()\fR" 4
.el .IP "\f(CW$imp\fR\->\fBdo_unimport()\fR" 4
.IX Item "$imp->do_unimport()"
.PD 0
.ie n .IP "$imp\->do_unimport(@symbols)" 4
.el .IP "\f(CW$imp\fR\->do_unimport(@symbols)" 4
.IX Item "$imp->do_unimport(@symbols)"
.PD
This will remove imported symbols from the objects \f(CW\*(C`from\*(C'\fR package. If you
specify a list of \f(CW@symbols\fR then only the specified symbols will be removed,
otherwise all symbols imported using Importer will be removed.
.Sp
\&\fBNote:\fR Please be aware of the difference between \f(CW\*(C`do_import()\*(C'\fR and
\&\f(CW\*(C`do_unimport()\*(C'\fR. For import 'from' us used as the origin, in unimport it is
used as the target. This means you cannot re-use an instance to import and then
unimport.
.ie n .IP "($into, $versions, $exclude, $symbols, $set) = $imp\->parse_args('Dest::Package')" 4
.el .IP "($into, \f(CW$versions\fR, \f(CW$exclude\fR, \f(CW$symbols\fR, \f(CW$set\fR) = \f(CW$imp\fR\->parse_args('Dest::Package')" 4
.IX Item "($into, $versions, $exclude, $symbols, $set) = $imp->parse_args('Dest::Package')"
.PD 0
.ie n .IP "($into, $versions, $exclude, $symbols, $set) = $imp\->parse_args('Dest::Package', @symbols)" 4
.el .IP "($into, \f(CW$versions\fR, \f(CW$exclude\fR, \f(CW$symbols\fR, \f(CW$set\fR) = \f(CW$imp\fR\->parse_args('Dest::Package', \f(CW@symbols\fR)" 4
.IX Item "($into, $versions, $exclude, $symbols, $set) = $imp->parse_args('Dest::Package', @symbols)"
.PD
This parses arguments. The first argument must be the destination package.
Other arguments can be a mix of symbol names, tags, patterns, version numbers,
and exclusions.
.ie n .IP "$caller_ref = $imp\->\fBget_caller()\fR" 4
.el .IP "\f(CW$caller_ref\fR = \f(CW$imp\fR\->\fBget_caller()\fR" 4
.IX Item "$caller_ref = $imp->get_caller()"
This will find the caller. This is mainly used for error reporting. \s-1IF\s0 the
object was constructed with a caller then that is what is returned, otherwise
this will scan the stack looking for the first call that does not originate
from a package that \s-1ISA\s0 Importer.
.ie n .IP "$imp\->carp($warning)" 4
.el .IP "\f(CW$imp\fR\->carp($warning)" 4
.IX Item "$imp->carp($warning)"
Warn at the callers level.
.ie n .IP "$imp\->croak($exception)" 4
.el .IP "\f(CW$imp\fR\->croak($exception)" 4
.IX Item "$imp->croak($exception)"
Die at the callers level.
.ie n .IP "$from_package = $imp\->\fBfrom()\fR" 4
.el .IP "\f(CW$from_package\fR = \f(CW$imp\fR\->\fBfrom()\fR" 4
.IX Item "$from_package = $imp->from()"
Get the \f(CW\*(C`from\*(C'\fR package that was specified at construction.
.ie n .IP "$file = $imp\->\fBfrom_file()\fR" 4
.el .IP "\f(CW$file\fR = \f(CW$imp\fR\->\fBfrom_file()\fR" 4
.IX Item "$file = $imp->from_file()"
Get the filename for the \f(CW\*(C`from\*(C'\fR package.
.ie n .IP "$imp\->\fBload_from()\fR" 4
.el .IP "\f(CW$imp\fR\->\fBload_from()\fR" 4
.IX Item "$imp->load_from()"
This will load the \f(CW\*(C`from\*(C'\fR package if it has not been loaded already. This uses
some magic to ensure errors in the load process are reported to the \f(CW\*(C`caller\*(C'\fR.
.ie n .IP "$menu_hr = $imp\->menu($into)" 4
.el .IP "\f(CW$menu_hr\fR = \f(CW$imp\fR\->menu($into)" 4
.IX Item "$menu_hr = $imp->menu($into)"
Get the export menu built from, or provided by the \f(CW\*(C`from\*(C'\fR package. This is
cached after the first time it is called. Use \f(CW\*(C`$imp\->reload_menu()\*(C'\fR to
refresh it.
.Sp
The menu structure looks like this:
.Sp
.Vb 4
\&    $menu = {
\&        # every valid export has a key in the lookup hashref, value is always
\&        # 1, key always includes the sigil
\&        lookup => {\*(Aq&symbol_a\*(Aq => 1, \*(Aq$symbol_b\*(Aq => 1, ...},
\&
\&        # most exports are listed here, symbol name with sigil is key, value is
\&        # a reference to the symbol. If a symbol is missing it may be generated.
\&        exports => {\*(Aq&symbol_a\*(Aq => \e&symbol_a, \*(Aq$symbol_b\*(Aq => \e$symbol_b, ...},
\&
\&        # Hashref of tags, tag name (without \*(Aq:\*(Aq prefix) is key, value is an
\&        # arrayref of symbol names, subs may have a sigil, but are not required
\&        # to.
\&        tags => { DEFAULT => [...], foo => [...], ... },
\&
\&        # Magic to apply
\&        magic => { foo => sub { ... }, ... },
\&
\&        # This is a hashref just like \*(Aqlookup\*(Aq. Keys are symbols which may not
\&        # always be available. If there are no symbols in this category then
\&        # the value of the \*(Aqfail\*(Aq key will be undef instead of a hashref.
\&        fail => { \*(Aq&iffy_symbol\*(Aq => 1, \*(Aq\e&only_on_linux\*(Aq => 1 },
\&        # OR fail => undef,
\&
\&        # If present, this subroutine knows how to generate references for the
\&        # symbols listed in \*(Aqlookup\*(Aq, but missing from \*(Aqexports\*(Aq. References
\&        # this returns are NEVER cached.
\&        generate => sub { my $sym_name = shift; ...; return $symbol_ref },
\&    };
.Ve
.ie n .IP "$imp\->reload_menu($into)" 4
.el .IP "\f(CW$imp\fR\->reload_menu($into)" 4
.IX Item "$imp->reload_menu($into)"
This will reload the export menu from the \f(CW\*(C`from\*(C'\fR package.
.ie n .IP "my $exports = $imp\->get(@imports)" 4
.el .IP "my \f(CW$exports\fR = \f(CW$imp\fR\->get(@imports)" 4
.IX Item "my $exports = $imp->get(@imports)"
This returns hashref of \f(CW\*(C`{ $name => $ref }\*(C'\fR for all the specified imports.
.ie n .IP "my @export_refs = $imp\->get_list(@imports)" 4
.el .IP "my \f(CW@export_refs\fR = \f(CW$imp\fR\->get_list(@imports)" 4
.IX Item "my @export_refs = $imp->get_list(@imports)"
This returns a list of references for each import specified. Only the export
references are returned, the names are not.
.ie n .IP "$export_ref = $imp\->get_one($import)" 4
.el .IP "\f(CW$export_ref\fR = \f(CW$imp\fR\->get_one($import)" 4
.IX Item "$export_ref = $imp->get_one($import)"
This returns a single reference to a single export. If you provide multiple
imports then only the \s-1LAST\s0 one will be used.
.SH "FUNCTIONS"
.IX Header "FUNCTIONS"
These can be imported:
.PP
.Vb 1
\&    use Importer \*(AqImporter\*(Aq => qw/import optimal_import/;
.Ve
.ie n .IP "$bool = optimal_import($from, $into, \e@caller, @imports)" 4
.el .IP "\f(CW$bool\fR = optimal_import($from, \f(CW$into\fR, \e@caller, \f(CW@imports\fR)" 4
.IX Item "$bool = optimal_import($from, $into, @caller, @imports)"
This function will attempt to import \f(CW@imports\fR from the \f(CW$from\fR package into
the \f(CW$into\fR package. \f(CW@caller\fR needs to have a package name, filename, and
line number. If this function fails then no exporting will actually happen.
.Sp
If the import is successful this will return true.
.Sp
If the import is unsuccessful this will return false, and no modifications to
the symbol table will occur.
.ie n .IP "$class\->import(@imports)" 4
.el .IP "\f(CW$class\fR\->import(@imports)" 4
.IX Item "$class->import(@imports)"
If you write class intended to be used with Importer, but also need to
provide a legacy \f(CW\*(C`import()\*(C'\fR method for direct consumers of your class, you can
import this \f(CW\*(C`import()\*(C'\fR method.
.Sp
.Vb 1
\&    package My::Exporter;
\&
\&    # This will give you \*(Aqimport()\*(Aq much like \*(Aquse base "Exporter";\*(Aq
\&    use Importer \*(AqImporter\*(Aq => qw/import/;
\&
\&    ...
.Ve
.SH "SOURCE"
.IX Header "SOURCE"
The source code repository for Importer can be found at
<http://github.com/exodist/Importer>.
.SH "MAINTAINERS"
.IX Header "MAINTAINERS"
.IP "Chad Granum <exodist@cpan.org>" 4
.IX Item "Chad Granum <exodist@cpan.org>"
.SH "AUTHORS"
.IX Header "AUTHORS"
.PD 0
.IP "Chad Granum <exodist@cpan.org>" 4
.IX Item "Chad Granum <exodist@cpan.org>"
.PD
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright 2015 Chad Granum <exodist7@gmail.com>.
.PP
This program is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.
.PP
See <http://dev.perl.org/licenses/>
