.\" Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "install::TempContent::Objects::mod_perl-2.0.9::docs::api::APR::Table 3"
.TH install::TempContent::Objects::mod_perl-2.0.9::docs::api::APR::Table 3 "2015-06-18" "perl v5.30.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
APR::Table \- Perl API for manipulating APR opaque string\-content tables
.SH "Synopsis"
.IX Header "Synopsis"
.Vb 1
\&  use APR::Table ();
\&  
\&  $table = APR::Table::make($pool, $nelts);
\&  $table_copy = $table\->copy($pool);
\&  
\&  $table\->clear();
\&  
\&  $table\->set($key => $val);
\&  $table\->unset($key);
\&  $table\->add($key, $val);
\&  
\&  $val = $table\->get($key);
\&  @val = $table\->get($key);
\&  
\&  $table\->merge($key => $val);
\&  
\&  use APR::Const \-compile qw(:table);
\&  $table_overlay = $table_base\->overlay($table_overlay, $pool);
\&  $table_overlay\->compress(APR::Const::OVERLAP_TABLES_MERGE);
\&  
\&  $table_a\->overlap($table_b, APR::Const::OVERLAP_TABLES_SET);
\&  
\&  $table\->do(sub {print "key $_[0], value $_[1]\en"}, @valid_keys);
\&  
\&  #Tied Interface
\&  $value = $table\->{$key};
\&  $table\->{$key} = $value;
\&  print "got it" if exists $table\->{$key};
\&  
\&  foreach my $key (keys %{$table}) {
\&      print "$key = $table\->{$key}\en";
\&  }
.Ve
.SH "Description"
.IX Header "Description"
\&\f(CW\*(C`APR::Table\*(C'\fR allows its users to manipulate opaque string-content
tables.
.PP
On the C level the \*(L"opaque string-content\*(R" means: you can put in
\&'\e0'\-terminated strings and whatever you put in your get out.
.PP
On the Perl level that means that we convert scalars into strings and
store those strings. Any special information that was in the Perl
scalar is not stored. So for example if a scalar was marked as utf8,
tainted or tied, that information is not stored. When you get the data
back as a Perl scalar you get only the string.
.PP
The table's structure is somewhat similar to the Perl's hash
structure, but allows multiple values for the same key.  An access to
the records stored in the table always requires a key.
.PP
The key-value pairs are stored in the order they are added.
.PP
The keys are case-insensitive.
.PP
However as of the current implementation if more than value for the
same key is requested, the whole table is lineary searched, which is
very inefficient unless the table is very small.
.PP
\&\f(CW\*(C`APR::Table\*(C'\fR provides a \s-1TIE\s0 Interface.
.PP
See \fIapr/include/apr_tables.h\fR in \s-1ASF\s0's \fIapr\fR project for low level
details.
.SH "API"
.IX Header "API"
\&\f(CW\*(C`APR::Table\*(C'\fR provides the following functions and/or methods:
.ie n .SS """add"""
.el .SS "\f(CWadd\fP"
.IX Subsection "add"
Add data to a table, regardless of whether there is another element
with the same key.
.PP
.Vb 1
\&  $table\->add($key, $val);
.Ve
.ie n .IP "obj: $table ( ""APR::Table object"" )" 4
.el .IP "obj: \f(CW$table\fR ( \f(CWAPR::Table object\fR )" 4
.IX Item "obj: $table ( APR::Table object )"
The table to add to.
.ie n .IP "arg1: $key ( string )" 4
.el .IP "arg1: \f(CW$key\fR ( string )" 4
.IX Item "arg1: $key ( string )"
The key to use.
.ie n .IP "arg2: $val ( string )" 4
.el .IP "arg2: \f(CW$val\fR ( string )" 4
.IX Item "arg2: $val ( string )"
The value to add.
.IP "ret: no return value" 4
.IX Item "ret: no return value"
.PD 0
.IP "since: 2.0.00" 4
.IX Item "since: 2.0.00"
.PD
.PP
When adding data, this function makes a copy of both the key and the
value.
.ie n .SS """clear"""
.el .SS "\f(CWclear\fP"
.IX Subsection "clear"
Delete all of the elements from a table.
.PP
.Vb 1
\&  $table\->clear();
.Ve
.ie n .IP "obj: $table ( ""APR::Table object"" )" 4
.el .IP "obj: \f(CW$table\fR ( \f(CWAPR::Table object\fR )" 4
.IX Item "obj: $table ( APR::Table object )"
The table to clear.
.IP "ret: no return value" 4
.IX Item "ret: no return value"
.PD 0
.IP "since: 2.0.00" 4
.IX Item "since: 2.0.00"
.PD
.ie n .SS """compress"""
.el .SS "\f(CWcompress\fP"
.IX Subsection "compress"
Eliminate redundant entries in a table by either overwriting or
merging duplicates:
.PP
.Vb 1
\&  $table\->compress($flags);
.Ve
.ie n .IP "obj: $table ( ""APR::Table object"" )" 4
.el .IP "obj: \f(CW$table\fR ( \f(CWAPR::Table object\fR )" 4
.IX Item "obj: $table ( APR::Table object )"
The table to compress.
.ie n .IP "arg1: $flags (""APR::Const constant"")" 4
.el .IP "arg1: \f(CW$flags\fR (\f(CWAPR::Const constant\fR)" 4
.IX Item "arg1: $flags (APR::Const constant)"
.Vb 2
\&  APR::Const::OVERLAP_TABLES_MERGE \-\- to merge
\&  APR::Const::OVERLAP_TABLES_SET   \-\- to overwrite
.Ve
.IP "ret: no return value" 4
.IX Item "ret: no return value"
.PD 0
.IP "since: 2.0.00" 4
.IX Item "since: 2.0.00"
.PD
.PP
Converts multi-valued keys in \f(CW$table\fR into single-valued keys.  This
function takes duplicate table entries and flattens them into a single
entry.  The flattening behavior is controlled by the (mandatory)
\&\f(CW$flags\fR argument.
.PP
When \f(CW$flags\fR == \f(CW\*(C`APR::Const::OVERLAP_TABLES_SET\*(C'\fR, each key will be set to
the last value seen for that key.  For example, given key/value pairs
\&'foo => bar' and 'foo => baz', 'foo' would have a final value
of 'baz' after compression \*(-- the 'bar' value would be lost.
.PP
When \f(CW$flags\fR == \f(CW\*(C`APR::Const::OVERLAP_TABLES_MERGE\*(C'\fR, multiple values for
the same key are flattened into a comma-separated list.  Given
key/value pairs 'foo => bar' and 'foo => baz', 'foo' would
have a final value of 'bar, baz' after compression.
.PP
Access the constants via:
.PP
.Vb 1
\&  use APR::Const \-compile qw(:table);
.Ve
.PP
or an explicit:
.PP
.Vb 1
\&  use APR::Const \-compile qw(OVERLAP_TABLES_SET OVERLAP_TABLES_MERGE);
.Ve
.PP
\&\f(CW\*(C`compress()\*(C'\fR combined with \f(CW\*(C`overlay()\*(C'\fR does the same
thing as \f(CW\*(C`overlap()\*(C'\fR.
.PP
Examples:
.IP "\(bu" 4
\&\f(CW\*(C`APR::Const::OVERLAP_TABLES_SET\*(C'\fR
.Sp
Start with table \f(CW$table\fR:
.Sp
.Vb 4
\&  foo => "one"
\&  foo => "two"
\&  foo => "three"
\&  bar => "beer"
.Ve
.Sp
which is done by:
.Sp
.Vb 2
\&  use APR::Const    \-compile => \*(Aq:table\*(Aq;
\&  my $table = APR::Table::make($r\->pool, TABLE_SIZE);
\&  
\&  $table\->set(bar => \*(Aqbeer\*(Aq);
\&  $table\->set(foo => \*(Aqone\*(Aq);
\&  $table\->add(foo => \*(Aqtwo\*(Aq);
\&  $table\->add(foo => \*(Aqthree\*(Aq);
.Ve
.Sp
Now compress it using \f(CW\*(C`APR::Const::OVERLAP_TABLES_SET\*(C'\fR:
.Sp
.Vb 1
\&  $table\->compress(APR::Const::OVERLAP_TABLES_SET);
.Ve
.Sp
Now table \f(CW$table\fR contains:
.Sp
.Vb 2
\&  foo => "three"
\&  bar => "beer"
.Ve
.Sp
The value \fIthree\fR for the key \fIfoo\fR, that was added last, took over
the other values.
.IP "\(bu" 4
\&\f(CW\*(C`APR::Const::OVERLAP_TABLES_MERGE\*(C'\fR
.Sp
Start with table \f(CW$table\fR:
.Sp
.Vb 4
\&  foo => "one"
\&  foo => "two"
\&  foo => "three"
\&  bar => "beer"
.Ve
.Sp
as in the previous example, now compress it using
\&\f(CW\*(C`APR::Const::OVERLAP_TABLES_MERGE\*(C'\fR:
.Sp
.Vb 1
\&  $table\->compress(APR::Const::OVERLAP_TABLES_MERGE);
.Ve
.Sp
Now table \f(CW$table\fR contains:
.Sp
.Vb 2
\&  foo => "one, two, three"
\&  bar => "beer"
.Ve
.Sp
All the values for the same key were merged into one value.
.ie n .SS """copy"""
.el .SS "\f(CWcopy\fP"
.IX Subsection "copy"
Create a new table and copy another table into it.
.PP
.Vb 1
\&  $table_copy = $table\->copy($p);
.Ve
.ie n .IP "obj: $table ( ""APR::Table object"" )" 4
.el .IP "obj: \f(CW$table\fR ( \f(CWAPR::Table object\fR )" 4
.IX Item "obj: $table ( APR::Table object )"
The table to copy.
.ie n .IP "arg1: $p ( ""APR::Pool object"" )" 4
.el .IP "arg1: \f(CW$p\fR ( \f(CWAPR::Pool object\fR )" 4
.IX Item "arg1: $p ( APR::Pool object )"
The pool to allocate the new table out of.
.ie n .IP "ret: $table_copy ( ""APR::Table object"" )" 4
.el .IP "ret: \f(CW$table_copy\fR ( \f(CWAPR::Table object\fR )" 4
.IX Item "ret: $table_copy ( APR::Table object )"
A copy of the table passed in.
.IP "since: 2.0.00" 4
.IX Item "since: 2.0.00"
.ie n .SS """do"""
.el .SS "\f(CWdo\fP"
.IX Subsection "do"
Iterate over all the elements of the table, invoking provided
subroutine for each element.  The subroutine gets passed as argument,
a key-value pair.
.PP
.Vb 1
\&  $table\->do(sub {...}, @filter);
.Ve
.ie n .IP "obj: $table ( ""APR::Table object"" )" 4
.el .IP "obj: \f(CW$table\fR ( \f(CWAPR::Table object\fR )" 4
.IX Item "obj: $table ( APR::Table object )"
The table to operate on.
.ie n .IP "arg1: $sub ( \s-1CODE\s0 ref/string )" 4
.el .IP "arg1: \f(CW$sub\fR ( \s-1CODE\s0 ref/string )" 4
.IX Item "arg1: $sub ( CODE ref/string )"
A subroutine reference or name to be called on each item in the table.
The subroutine can abort the iteration by returning 0 and should
always return 1 otherwise.
.ie n .IP "opt arg3: @filter ( \s-1ARRAY\s0 )" 4
.el .IP "opt arg3: \f(CW@filter\fR ( \s-1ARRAY\s0 )" 4
.IX Item "opt arg3: @filter ( ARRAY )"
If passed, only keys matching one of the entries in f\f(CW@filter\fR will be
processed.
.IP "ret: no return value" 4
.IX Item "ret: no return value"
.PD 0
.IP "since: 2.0.00" 4
.IX Item "since: 2.0.00"
.PD
.PP
Examples:
.IP "\(bu" 4
This filter simply prints out the key/value pairs and counts how many
pairs did it see.
.Sp
.Vb 3
\&  use constant TABLE_SIZE => 20;
\&  our $filter_count;
\&  my $table = APR::Table::make($r\->pool, TABLE_SIZE);
\&  
\&  # populate the table with ascii data
\&  for (1..TABLE_SIZE) {
\&      $table\->set(chr($_+97), $_);
\&  }
\&  
\&  $filter_count = 0;
\&  $table\->do("my_filter");
\&  print "Counted $filter_count elements";
\&  
\&  sub my_filter {
\&      my ($key, $value) = @_;
\&      warn "$key => $value\en";
\&      $filter_count++;
\&      return 1;
\&  }
.Ve
.Sp
Notice that \f(CW\*(C`my_filter\*(C'\fR always returns 1, ensuring that \f(CW\*(C`do()\*(C'\fR will
pass all the key/value pairs.
.IP "\(bu" 4
This filter is similar to the one from the previous example, but this
time it decides to abort the filtering after seeing half of the table,
by returning 0 when this happens.
.Sp
.Vb 5
\&  sub my_filter {
\&      my ($key, $value) = @_;
\&      $filter_count++;
\&      return $filter_count == int(TABLE_SIZE)/2 ? 0 : 1;
\&  }
.Ve
.ie n .SS """get"""
.el .SS "\f(CWget\fP"
.IX Subsection "get"
Get the value(s) associated with a given key.  After this call, the
data is still in the table.
.PP
.Vb 2
\&  $val = $table\->get($key);
\&  @val = $table\->get($key);
.Ve
.ie n .IP "obj: $table ( ""APR::Table object"" )" 4
.el .IP "obj: \f(CW$table\fR ( \f(CWAPR::Table object\fR )" 4
.IX Item "obj: $table ( APR::Table object )"
The table to search for the key.
.ie n .IP "arg1: $key ( string )" 4
.el .IP "arg1: \f(CW$key\fR ( string )" 4
.IX Item "arg1: $key ( string )"
The key to search for.
.ie n .IP "ret: $val or @val" 4
.el .IP "ret: \f(CW$val\fR or \f(CW@val\fR" 4
.IX Item "ret: $val or @val"
In the scalar context the first matching value returned (the oldest in
the table, if there is more than one value). If nothing matches
\&\f(CW\*(C`undef\*(C'\fR is returned.
.Sp
In the list context the whole table is traversed and all matching
values are returned. An empty list is returned if nothing matches.
.IP "since: 2.0.00" 4
.IX Item "since: 2.0.00"
.ie n .SS """make"""
.el .SS "\f(CWmake\fP"
.IX Subsection "make"
Make a new table.
.PP
.Vb 1
\&  $table = APR::Table::make($p, $nelts);
.Ve
.ie n .IP "obj: $p ( ""APR::Pool object"" )" 4
.el .IP "obj: \f(CW$p\fR ( \f(CWAPR::Pool object\fR )" 4
.IX Item "obj: $p ( APR::Pool object )"
The pool to allocate the pool out of.
.ie n .IP "arg1: $nelts ( integer )" 4
.el .IP "arg1: \f(CW$nelts\fR ( integer )" 4
.IX Item "arg1: $nelts ( integer )"
The number of elements in the initial table. At least 1 or more. If 0
is passed \s-1APR\s0 will still allocate 1.
.ie n .IP "ret: $table ( ""APR::Table object"" )" 4
.el .IP "ret: \f(CW$table\fR ( \f(CWAPR::Table object\fR )" 4
.IX Item "ret: $table ( APR::Table object )"
The new table.
.IP "since: 2.0.00" 4
.IX Item "since: 2.0.00"
.PP
This table can only store text data.
.ie n .SS """merge"""
.el .SS "\f(CWmerge\fP"
.IX Subsection "merge"
Add data to a table by merging the value with data that has already
been stored using \*(L", \*(R" as a separator:
.PP
.Vb 1
\&  $table\->merge($key, $val);
.Ve
.ie n .IP "obj: $table ( ""APR::Table object"" )" 4
.el .IP "obj: \f(CW$table\fR ( \f(CWAPR::Table object\fR )" 4
.IX Item "obj: $table ( APR::Table object )"
The table to search for the data.
.ie n .IP "arg1: $key ( string )" 4
.el .IP "arg1: \f(CW$key\fR ( string )" 4
.IX Item "arg1: $key ( string )"
The key to merge data for.
.ie n .IP "arg2: $val ( string )" 4
.el .IP "arg2: \f(CW$val\fR ( string )" 4
.IX Item "arg2: $val ( string )"
The data to add.
.IP "ret: no return value" 4
.IX Item "ret: no return value"
.PD 0
.IP "since: 2.0.00" 4
.IX Item "since: 2.0.00"
.PD
.PP
If the key is not found, then this function acts like
\&\f(CW\*(C`add()\*(C'\fR.
.PP
If there is more than one value for the same key, only the first (the
oldest) value gets merged.
.PP
Examples:
.IP "\(bu" 4
Start with a pair:
.Sp
.Vb 1
\&  merge => "1"
.Ve
.Sp
and merge \*(L"a\*(R" to the value:
.Sp
.Vb 3
\&  $table\->set(  merge => \*(Aq1\*(Aq);
\&  $table\->merge(merge => \*(Aqa\*(Aq);
\&  $val = $table\->get(\*(Aqmerge\*(Aq);
.Ve
.Sp
Result:
.Sp
.Vb 1
\&  $val == "1, a";
.Ve
.IP "\(bu" 4
Start with a multivalued pair:
.Sp
.Vb 2
\&  merge => "1"
\&  merge => "2"
.Ve
.Sp
and merge \*(L"a\*(R" to the first value;
.Sp
.Vb 4
\&  $table\->set(  merge => \*(Aq1\*(Aq);
\&  $table\->add(  merge => \*(Aq2\*(Aq);
\&  $table\->merge(merge => \*(Aqa\*(Aq);
\&  @val = $table\->get(\*(Aqmerge\*(Aq);
.Ve
.Sp
Result:
.Sp
.Vb 2
\&  $val[0] == "1, a";
\&  $val[1] == "2";
.Ve
.Sp
Only the first value for the same key is affected.
.IP "\(bu" 4
Have no entry and merge \*(L"a\*(R";
.Sp
.Vb 2
\&  $table\->merge(miss => \*(Aqa\*(Aq);
\&  $val = $table\->get(\*(Aqmiss\*(Aq);
.Ve
.Sp
Result:
.Sp
.Vb 1
\&  $val == "a";
.Ve
.ie n .SS """overlap"""
.el .SS "\f(CWoverlap\fP"
.IX Subsection "overlap"
For each key/value pair in \f(CW$table_b\fR, add the data to
\&\f(CW$table_a\fR. The definition of \f(CW$flags\fR explains how \f(CW$flags\fR define
the overlapping method.
.PP
.Vb 1
\&  $table_a\->overlap($table_b, $flags);
.Ve
.ie n .IP "obj: $table_a ( ""APR::Table object"" )" 4
.el .IP "obj: \f(CW$table_a\fR ( \f(CWAPR::Table object\fR )" 4
.IX Item "obj: $table_a ( APR::Table object )"
The table to add the data to.
.ie n .IP "arg1: $table_b ( ""APR::Table object"" )" 4
.el .IP "arg1: \f(CW$table_b\fR ( \f(CWAPR::Table object\fR )" 4
.IX Item "arg1: $table_b ( APR::Table object )"
The table to iterate over, adding its data to table \f(CW$table_a\fR
.ie n .IP "arg2: $flags ( integer )" 4
.el .IP "arg2: \f(CW$flags\fR ( integer )" 4
.IX Item "arg2: $flags ( integer )"
How to add the table to table \f(CW$table_a\fR.
.Sp
When \f(CW$flags\fR == \f(CW\*(C`APR::Const::OVERLAP_TABLES_SET\*(C'\fR, if another element
already exists with the same key, this will over-write the old data.
.Sp
When \f(CW$flags\fR == \f(CW\*(C`APR::Const::OVERLAP_TABLES_MERGE\*(C'\fR, the key/value pair
from \f(CW$table_b\fR is added, regardless of whether there is another
element with the same key in \f(CW$table_a\fR.
.IP "ret: no return value" 4
.IX Item "ret: no return value"
.PD 0
.IP "since: 2.0.00" 4
.IX Item "since: 2.0.00"
.PD
.PP
Access the constants via:
.PP
.Vb 1
\&  use APR::Const \-compile qw(:table);
.Ve
.PP
or an explicit:
.PP
.Vb 1
\&  use APR::Const \-compile qw(OVERLAP_TABLES_SET OVERLAP_TABLES_MERGE);
.Ve
.PP
This function is highly optimized, and uses less memory and \s-1CPU\s0 cycles
than a function that just loops through table \f(CW$table_b\fR calling
other functions.
.PP
Conceptually, \f(CW\*(C`overlap()\*(C'\fR does this:
.PP
.Vb 3
\&  apr_array_header_t *barr = apr_table_elts(b);
\&  apr_table_entry_t *belt = (apr_table_entry_t *)barr\-E<gt>elts;
\&  int i;
\&  
\&  for (i = 0; i < barr\->nelts; ++i) {
\&      if (flags & APR_OVERLAP_TABLES_MERGE) {
\&          apr_table_mergen(a, belt[i].key, belt[i].val);
\&      }
\&      else {
\&          apr_table_setn(a, belt[i].key, belt[i].val);
\&      }
\&  }
.Ve
.PP
Except that it is more efficient (less space and cpu-time) especially
when \f(CW$table_b\fR has many elements.
.PP
Notice the assumptions on the keys and values in \f(CW$table_b\fR \*(-- they
must be in an ancestor of \f(CW$table_a\fR's pool.  In practice \f(CW$table_b\fR
and \f(CW$table_a\fR are usually from the same pool.
.PP
Examples:
.IP "\(bu" 4
\&\f(CW\*(C`APR::Const::OVERLAP_TABLES_SET\*(C'\fR
.Sp
Start with table \f(CW$base\fR:
.Sp
.Vb 3
\&  foo => "one"
\&  foo => "two"
\&  bar => "beer"
.Ve
.Sp
and table \f(CW$add\fR:
.Sp
.Vb 1
\&  foo => "three"
.Ve
.Sp
which is done by:
.Sp
.Vb 3
\&  use APR::Const    \-compile => \*(Aq:table\*(Aq;
\&  my $base = APR::Table::make($r\->pool, TABLE_SIZE);
\&  my $add  = APR::Table::make($r\->pool, TABLE_SIZE);
\&  
\&  $base\->set(bar => \*(Aqbeer\*(Aq);
\&  $base\->set(foo => \*(Aqone\*(Aq);
\&  $base\->add(foo => \*(Aqtwo\*(Aq);
\&  
\&  $add\->set(foo => \*(Aqthree\*(Aq);
.Ve
.Sp
Now overlap using \f(CW\*(C`APR::Const::OVERLAP_TABLES_SET\*(C'\fR:
.Sp
.Vb 1
\&  $base\->overlap($add, APR::Const::OVERLAP_TABLES_SET);
.Ve
.Sp
Now table \f(CW$add\fR is unmodified and table \f(CW$base\fR contains:
.Sp
.Vb 2
\&  foo => "three"
\&  bar => "beer"
.Ve
.Sp
The value from table \f(CW\*(C`add\*(C'\fR has overwritten all previous values for
the same key both had (\fIfoo\fR).  This is the same as doing
\&\f(CW\*(C`overlay()\*(C'\fR followed by \f(CW\*(C`compress()\*(C'\fR
with \f(CW\*(C`APR::Const::OVERLAP_TABLES_SET\*(C'\fR.
.IP "\(bu" 4
\&\f(CW\*(C`APR::Const::OVERLAP_TABLES_MERGE\*(C'\fR
.Sp
Start with table \f(CW$base\fR:
.Sp
.Vb 2
\&  foo => "one"
\&  foo => "two"
.Ve
.Sp
and table \f(CW$add\fR:
.Sp
.Vb 2
\&  foo => "three"
\&  bar => "beer"
.Ve
.Sp
which is done by:
.Sp
.Vb 3
\&  use APR::Const    \-compile => \*(Aq:table\*(Aq;
\&  my $base = APR::Table::make($r\->pool, TABLE_SIZE);
\&  my $add  = APR::Table::make($r\->pool, TABLE_SIZE);
\&  
\&  $base\->set(foo => \*(Aqone\*(Aq);
\&  $base\->add(foo => \*(Aqtwo\*(Aq);
\&  
\&  $add\->set(foo => \*(Aqthree\*(Aq);
\&  $add\->set(bar => \*(Aqbeer\*(Aq);
.Ve
.Sp
Now overlap using \f(CW\*(C`APR::Const::OVERLAP_TABLES_MERGE\*(C'\fR:
.Sp
.Vb 1
\&  $base\->overlap($add, APR::Const::OVERLAP_TABLES_MERGE);
.Ve
.Sp
Now table \f(CW$add\fR is unmodified and table \f(CW$base\fR contains:
.Sp
.Vb 2
\&  foo => "one, two, three"
\&  bar => "beer"
.Ve
.Sp
Values from both tables for the same key were merged into one
value. This is the same as doing \f(CW\*(C`overlay()\*(C'\fR followed
by \f(CW\*(C`compress()\*(C'\fR with \f(CW\*(C`APR::Const::OVERLAP_TABLES_MERGE\*(C'\fR.
.ie n .SS """overlay"""
.el .SS "\f(CWoverlay\fP"
.IX Subsection "overlay"
Merge two tables into one new table. The resulting table may have more
than one value for the same key.
.PP
.Vb 1
\&  $table = $table_base\->overlay($table_overlay, $p);
.Ve
.ie n .IP "obj: $table_base ( ""APR::Table object"" )" 4
.el .IP "obj: \f(CW$table_base\fR ( \f(CWAPR::Table object\fR )" 4
.IX Item "obj: $table_base ( APR::Table object )"
The table to add at the end of the new table.
.ie n .IP "arg1: $table_overlay ( ""APR::Table object"" )" 4
.el .IP "arg1: \f(CW$table_overlay\fR ( \f(CWAPR::Table object\fR )" 4
.IX Item "arg1: $table_overlay ( APR::Table object )"
The first table to put in the new table.
.ie n .IP "arg2: $p ( ""APR::Pool object"" )" 4
.el .IP "arg2: \f(CW$p\fR ( \f(CWAPR::Pool object\fR )" 4
.IX Item "arg2: $p ( APR::Pool object )"
The pool to use for the new table.
.ie n .IP "ret: $table ( ""APR::Table object"" )" 4
.el .IP "ret: \f(CW$table\fR ( \f(CWAPR::Table object\fR )" 4
.IX Item "ret: $table ( APR::Table object )"
A new table containing all of the data from the two passed in.
.IP "since: 2.0.00" 4
.IX Item "since: 2.0.00"
.PP
Examples:
.IP "\(bu" 4
Start with table \f(CW$base\fR:
.Sp
.Vb 3
\&  foo => "one"
\&  foo => "two"
\&  bar => "beer"
.Ve
.Sp
and table \f(CW$add\fR:
.Sp
.Vb 1
\&  foo => "three"
.Ve
.Sp
which is done by:
.Sp
.Vb 3
\&  use APR::Const    \-compile => \*(Aq:table\*(Aq;
\&  my $base = APR::Table::make($r\->pool, TABLE_SIZE);
\&  my $add  = APR::Table::make($r\->pool, TABLE_SIZE);
\&  
\&  $base\->set(bar => \*(Aqbeer\*(Aq);
\&  $base\->set(foo => \*(Aqone\*(Aq);
\&  $base\->add(foo => \*(Aqtwo\*(Aq);
\&  
\&  $add\->set(foo => \*(Aqthree\*(Aq);
.Ve
.Sp
Now overlay using \f(CW\*(C`APR::Const::OVERLAP_TABLES_SET\*(C'\fR:
.Sp
.Vb 1
\&  my $overlay = $base\->overlay($add, APR::Const::OVERLAP_TABLES_SET);
.Ve
.Sp
That resulted in a new table \f(CW$overlay\fR (tables \f(CW\*(C`add\*(C'\fR and \f(CW$base\fR
are unmodified) which contains:
.Sp
.Vb 4
\&  foo => "one"
\&  foo => "two"
\&  foo => "three"
\&  bar => "beer"
.Ve
.ie n .SS """set"""
.el .SS "\f(CWset\fP"
.IX Subsection "set"
Add a key/value pair to a table, if another element already exists
with the same key, this will over-write the old data.
.PP
.Vb 1
\&  $table\->set($key, $val);
.Ve
.ie n .IP "obj: $table ( ""APR::Table object"" )" 4
.el .IP "obj: \f(CW$table\fR ( \f(CWAPR::Table object\fR )" 4
.IX Item "obj: $table ( APR::Table object )"
The table to add the data to.
.ie n .IP "arg1: $key ( string )" 4
.el .IP "arg1: \f(CW$key\fR ( string )" 4
.IX Item "arg1: $key ( string )"
The key to use.
.ie n .IP "arg2: $val ( string )" 4
.el .IP "arg2: \f(CW$val\fR ( string )" 4
.IX Item "arg2: $val ( string )"
The value to add.
.IP "ret: no return value" 4
.IX Item "ret: no return value"
.PD 0
.IP "since: 2.0.00" 4
.IX Item "since: 2.0.00"
.PD
.PP
When adding data, this function makes a copy of both the key and the
value.
.ie n .SS """unset"""
.el .SS "\f(CWunset\fP"
.IX Subsection "unset"
Remove data from the table.
.PP
.Vb 1
\&  $table\->unset($key);
.Ve
.ie n .IP "obj: $table ( ""APR::Table object"" )" 4
.el .IP "obj: \f(CW$table\fR ( \f(CWAPR::Table object\fR )" 4
.IX Item "obj: $table ( APR::Table object )"
The table to remove data from.
.ie n .IP "arg1: $key ( string )" 4
.el .IP "arg1: \f(CW$key\fR ( string )" 4
.IX Item "arg1: $key ( string )"
The key of the data being removed.
.IP "ret: no return value" 4
.IX Item "ret: no return value"
.PD 0
.IP "since: 2.0.00" 4
.IX Item "since: 2.0.00"
.PD
.SH "TIE Interface"
.IX Header "TIE Interface"
\&\f(CW\*(C`APR::Table\*(C'\fR also implements a tied interface, so you can work with the
\&\f(CW$table\fR object as a hash reference.
.PP
The following tied-hash function are supported: \f(CW\*(C`FETCH\*(C'\fR, \f(CW\*(C`STORE\*(C'\fR,
\&\f(CW\*(C`DELETE\*(C'\fR, \f(CW\*(C`CLEAR\*(C'\fR, \f(CW\*(C`EXISTS\*(C'\fR, \f(CW\*(C`FIRSTKEY\*(C'\fR, \f(CW\*(C`NEXTKEY\*(C'\fR and
\&\f(CW\*(C`DESTROY\*(C'\fR.
.PP
Note regarding the use of \f(CW\*(C`values()\*(C'\fR. \f(CW\*(C`APR::Table\*(C'\fR can hold more
than one key-value pair sharing the same key, so when using a table
through the tied interface, the first entry found with the right key
will be used, completely disregarding possible other entries with the
same key.  With Perl 5.8.0 and higher \f(CW\*(C`values()\*(C'\fR will correctly list
values the corresponding to the list generated by \f(CW\*(C`keys()\*(C'\fR. That
doesn't work with Perl 5.6. Therefore to portably iterate over the
key-value pairs, use \f(CW\*(C`each()\*(C'\fR (which fully supports multivalued
keys), or \f(CW\*(C`APR::Table::do\*(C'\fR.
.ie n .SS """EXISTS"""
.el .SS "\f(CWEXISTS\fP"
.IX Subsection "EXISTS"
.Vb 1
\&  $ret = $table\->EXISTS($key);
.Ve
.ie n .IP "obj: $table ( ""APR::Table object"" )" 4
.el .IP "obj: \f(CW$table\fR ( \f(CWAPR::Table object\fR )" 4
.IX Item "obj: $table ( APR::Table object )"
.PD 0
.ie n .IP "arg1: $key ( string )" 4
.el .IP "arg1: \f(CW$key\fR ( string )" 4
.IX Item "arg1: $key ( string )"
.ie n .IP "ret: $ret ( integer )" 4
.el .IP "ret: \f(CW$ret\fR ( integer )" 4
.IX Item "ret: $ret ( integer )"
.PD
true or false
.IP "since: 2.0.00" 4
.IX Item "since: 2.0.00"
.ie n .SS """CLEAR"""
.el .SS "\f(CWCLEAR\fP"
.IX Subsection "CLEAR"
.Vb 1
\&  $table\->CLEAR();
.Ve
.ie n .IP "obj: $table ( ""APR::Table object"" )" 4
.el .IP "obj: \f(CW$table\fR ( \f(CWAPR::Table object\fR )" 4
.IX Item "obj: $table ( APR::Table object )"
.PD 0
.IP "ret: no return value" 4
.IX Item "ret: no return value"
.IP "since: 2.0.00" 4
.IX Item "since: 2.0.00"
.PD
.ie n .SS """STORE"""
.el .SS "\f(CWSTORE\fP"
.IX Subsection "STORE"
.Vb 1
\&  $table\->STORE($key, $val);
.Ve
.ie n .IP "obj: $table ( ""APR::Table object"" )" 4
.el .IP "obj: \f(CW$table\fR ( \f(CWAPR::Table object\fR )" 4
.IX Item "obj: $table ( APR::Table object )"
.PD 0
.ie n .IP "arg1: $key ( string )" 4
.el .IP "arg1: \f(CW$key\fR ( string )" 4
.IX Item "arg1: $key ( string )"
.ie n .IP "arg2: $val ( string )" 4
.el .IP "arg2: \f(CW$val\fR ( string )" 4
.IX Item "arg2: $val ( string )"
.IP "ret: no return value" 4
.IX Item "ret: no return value"
.IP "since: 2.0.00" 4
.IX Item "since: 2.0.00"
.PD
.ie n .SS """DELETE"""
.el .SS "\f(CWDELETE\fP"
.IX Subsection "DELETE"
.Vb 1
\&  $table\->DELETE($key);
.Ve
.ie n .IP "obj: $table ( ""APR::Table object"" )" 4
.el .IP "obj: \f(CW$table\fR ( \f(CWAPR::Table object\fR )" 4
.IX Item "obj: $table ( APR::Table object )"
.PD 0
.ie n .IP "arg1: $key ( string )" 4
.el .IP "arg1: \f(CW$key\fR ( string )" 4
.IX Item "arg1: $key ( string )"
.IP "ret: no return value" 4
.IX Item "ret: no return value"
.IP "since: 2.0.00" 4
.IX Item "since: 2.0.00"
.PD
.ie n .SS """FETCH"""
.el .SS "\f(CWFETCH\fP"
.IX Subsection "FETCH"
.Vb 1
\&  $ret = $table\->FETCH($key);
.Ve
.ie n .IP "obj: $table ( ""APR::Table object"" )" 4
.el .IP "obj: \f(CW$table\fR ( \f(CWAPR::Table object\fR )" 4
.IX Item "obj: $table ( APR::Table object )"
.PD 0
.ie n .IP "arg1: $key ( string )" 4
.el .IP "arg1: \f(CW$key\fR ( string )" 4
.IX Item "arg1: $key ( string )"
.ie n .IP "ret: $ret ( string )" 4
.el .IP "ret: \f(CW$ret\fR ( string )" 4
.IX Item "ret: $ret ( string )"
.IP "since: 2.0.00" 4
.IX Item "since: 2.0.00"
.PD
.PP
When iterating through the table's entries with \f(CW\*(C`each()\*(C'\fR, \f(CW\*(C`FETCH\*(C'\fR
will return the current value of a multivalued key.  For example:
.PP
.Vb 3
\&  $table\->add("a" => 1);
\&  $table\->add("b" => 2);
\&  $table\->add("a" => 3);
\&  
\&  ($k, $v) = each %$table; # (a, 1)
\&  print $table\->{a};       # prints 1
\&  
\&  ($k, $v) = each %$table; # (b, 2)
\&  print $table\->{a};       # prints 1
\&  
\&  ($k, $v) = each %$table; # (a, 3)
\&  print $table\->{a};       # prints 3 !!!
\&  
\&  ($k, $v) = each %$table; # (undef, undef)
\&  print $table\->{a};       # prints 1
.Ve
.SH "See Also"
.IX Header "See Also"
mod_perl 2.0 documentation.
.SH "Copyright"
.IX Header "Copyright"
mod_perl 2.0 and its core modules are copyrighted under
The Apache Software License, Version 2.0.
.SH "Authors"
.IX Header "Authors"
The mod_perl development team and numerous
contributors.
