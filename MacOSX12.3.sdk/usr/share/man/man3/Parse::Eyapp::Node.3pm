.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Parse::Eyapp::Node 3"
.TH Parse::Eyapp::Node 3 "2012-03-23" "perl v5.18.4" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Parse::Eyapp::Node \- The nodes of the Syntax Trees
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&  use Parse::Eyapp;
\&  use Parse::Eyapp::Treeregexp;
\&
\&  sub TERMINAL::info {
\&    $_[0]{attr}
\&  }
\&
\&  my $grammar = q{
\&    %right  \*(Aq=\*(Aq     # Lowest precedence
\&    %left   \*(Aq\-\*(Aq \*(Aq+\*(Aq # + and \- have more precedence than = Disambiguate a\-b\-c as (a\-b)\-c
\&    %left   \*(Aq*\*(Aq \*(Aq/\*(Aq # * and / have more precedence than + Disambiguate a/b/c as (a/b)/c
\&    %left   NEG     # Disambiguate \-a\-b as (\-a)\-b and not as \-(a\-b)
\&    %tree           # Let us build an abstract syntax tree ...
\&
\&    %%
\&    line:
\&        exp <%name EXPRESSION_LIST + \*(Aq;\*(Aq>
\&          { $_[1] } /* list of expressions separated by \*(Aq;\*(Aq */
\&    ;
\&
\&    /* The %name directive defines the name of the class to 
\&       which the node being built belongs */
\&    exp:
\&        %name NUM
\&        NUM
\&      | %name VAR
\&        VAR
\&      | %name ASSIGN
\&        VAR \*(Aq=\*(Aq exp
\&      | %name PLUS
\&        exp \*(Aq+\*(Aq exp
\&      | %name MINUS
\&        exp \*(Aq\-\*(Aq exp
\&      | %name TIMES
\&        exp \*(Aq*\*(Aq exp
\&      | %name DIV
\&        exp \*(Aq/\*(Aq exp
\&      | %name UMINUS
\&        \*(Aq\-\*(Aq exp %prec NEG
\&      | \*(Aq(\*(Aq exp \*(Aq)\*(Aq
\&          { $_[2] }  /* Let us simplify a bit the tree */
\&    ;
\&
\&    %%
\&    sub _Error { die "Syntax error near ".($_[0]\->YYCurval?$_[0]\->YYCurval:"end of file")."\en" }
\&
\&    sub _Lexer {
\&      my($parser)=shift; # The parser object
\&
\&      for ($parser\->YYData\->{INPUT}) { # Topicalize
\&        m{\eG\es+}gc;
\&        $_ eq \*(Aq\*(Aq and return(\*(Aq\*(Aq,undef);
\&        m{\eG([0\-9]+(?:\e.[0\-9]+)?)}gc and return(\*(AqNUM\*(Aq,$1);
\&        m{\eG([A\-Za\-z][A\-Za\-z0\-9_]*)}gc and return(\*(AqVAR\*(Aq,$1);
\&        m{\eG(.)}gcs and return($1,$1);
\&      }
\&      return(\*(Aq\*(Aq,undef);
\&    }
\&
\&    sub Run {
\&        my($self)=shift;
\&        $self\->YYParse( yylex => \e&_Lexer, yyerror => \e&_Error, );
\&    }
\&  }; # end grammar
\&
\&  our (@all, $uminus);
\&
\&  Parse::Eyapp\->new_grammar( # Create the parser package/class
\&    input=>$grammar,
\&    classname=>\*(AqCalc\*(Aq, # The name of the package containing the parser
\&    firstline=>7       # String $grammar starts at line 7 (for error diagnostics)
\&  );
\&  my $parser = Calc\->new();                # Create a parser
\&  $parser\->YYData\->{INPUT} = "2*\-3+b*0;\-\-2\en"; # Set the input
\&  my $t = $parser\->Run;                    # Parse it!
\&  local $Parse::Eyapp::Node::INDENT=2;
\&  print "Syntax Tree:",$t\->str;
\&
\&  # Let us transform the tree. Define the tree\-regular expressions ..
\&  my $p = Parse::Eyapp::Treeregexp\->new( STRING => q{
\&      { #  Example of support code
\&        my %Op = (PLUS=>\*(Aq+\*(Aq, MINUS => \*(Aq\-\*(Aq, TIMES=>\*(Aq*\*(Aq, DIV => \*(Aq/\*(Aq);
\&      }
\&      constantfold: /TIMES|PLUS|DIV|MINUS/:bin(NUM($x), NUM($y))
\&        => {
\&          my $op = $Op{ref($bin)};
\&          $x\->{attr} = eval  "$x\->{attr} $op $y\->{attr}";
\&          $_[0] = $NUM[0];
\&        }
\&      uminus: UMINUS(NUM($x)) => { $x\->{attr} = \-$x\->{attr}; $_[0] = $NUM }
\&      zero_times_whatever: TIMES(NUM($x), .) and { $x\->{attr} == 0 } => { $_[0] = $NUM }
\&      whatever_times_zero: TIMES(., NUM($x)) and { $x\->{attr} == 0 } => { $_[0] = $NUM }
\&    },
\&    OUTPUTFILE=> \*(Aqmain.pm\*(Aq
\&  );
\&  $p\->generate(); # Create the tranformations
\&
\&  $t\->s($uminus); # Transform UMINUS nodes
\&  $t\->s(@all);    # constant folding and mult. by zero
\&
\&  local $Parse::Eyapp::Node::INDENT=0;
\&  print "\enSyntax Tree after transformations:\en",$t\->str,"\en";
.Ve
.SH "METHODS"
.IX Header "METHODS"
The \f(CW\*(C`Parse::Eyapp::Node\*(C'\fR objects represent the nodes of the syntax
tree. 
All the node classes build by \f(CW%tree\fR and \f(CW%metatree\fR directives
inherit from \f(CW\*(C`Parse::Eyapp::Node\*(C'\fR and consequently have
acces to the methods provided in such module.
.PP
The examples used in this document can be found in the directory
\&\f(CW\*(C`examples/Node\*(C'\fR accompanying the distribution of Parse::Eyapp.
.SS "Parse::Eyapp::Node\->new"
.IX Subsection "Parse::Eyapp::Node->new"
Nodes are usually created from a Eyapp grammar 
using the \f(CW%tree\fR or \f(CW%metatree\fR
directives. The \f(CW\*(C`Parse::Eyapp::Node\*(C'\fR constructor \f(CW\*(C`new\*(C'\fR
offers an alternative way to create forests.
.PP
This class method can be used to build multiple nodes on a row.
It receives a string describing the tree and optionally a
reference to a subroutine. Such subroutine (called the attribute
handler) is in charge to initialize
the attributes of the just created nodes.
The attribute handler is called with the array of references to the
nodes as they appear in the string from left to right.
.PP
\&\f(CW\*(C`Parse::Eyapp::Node\->new\*(C'\fR returns an array of pointers to the nodes created
as they appear in the input string from left to right.
In scalar context returns a pointer to the first of these trees.
.PP
The following example (see file \f(CW\*(C`examples/Node/28foldwithnewwithvars.pl\*(C'\fR) of
a treeregexp transformation creates a new \f(CW\*(C`NUM(TERMINAL)\*(C'\fR node
using \f(CW\*(C`Parse::Eyapp::Node\->new\*(C'\fR:
.PP
.Vb 7
\& my $p = Parse::Eyapp::Treeregexp\->new( STRING => q{
\&   {
\&     my %Op = (PLUS=>\*(Aq+\*(Aq, MINUS => \*(Aq\-\*(Aq, TIMES=>\*(Aq*\*(Aq, DIV => \*(Aq/\*(Aq);
\&   }
\&   constantfold: /TIMES|PLUS|MINUS|DIV/(NUM($x), NUM($y))
\&      => {
\&     my $op = $Op{ref($_[0])};
\&
\&     my $res = Parse::Eyapp::Node\->new(
\&       q{NUM(TERMINAL)},
\&       sub {
\&         my ($NUM, $TERMINAL) = @_;
\&         $TERMINAL\->{attr} = eval "$x\->{attr} $op $y\->{attr}";
\&         $TERMINAL\->{token} = \*(AqNUM\*(Aq;
\&       },
\&     );
\&     $_[0] = $res;
\&   }
\&   },
\& );
.Ve
.PP
The call to \f(CW\*(C`Parse::Eyapp::Node\->new\*(C'\fR creates a tree \f(CW\*(C`NUM(TERMINAL)\*(C'\fR
and decorates the \f(CW\*(C`TERMINAL\*(C'\fR leaf with attributes \f(CW\*(C`attr\*(C'\fR
and \f(CW\*(C`token\*(C'\fR. The \f(CW\*(C`constantfold\*(C'\fR transformation substitutes
all the binary operation trees whose children are numbers
for a \f(CW\*(C`NUM(TERMINAL)\*(C'\fR tree holding as attribute the 
number resulting of operating the two numbers.
.PP
The input string can describe more than one tree. Different trees 
are separated by white spaces. Consider the following example
(in \f(CW\*(C`examples/Node/builder.pl\*(C'\fR):
.PP
.Vb 10
\&  $ cat \-n builder.pl
\&     1  #!/usr/bin/perl \-w
\&     2  use strict;
\&     3  use Parse::Eyapp::Node;
\&     4
\&     5  use Data::Dumper;
\&     6  $Data::Dumper::Indent = 1;
\&     7  $Data::Dumper::Purity = 1;
\&     8
\&     9  my $string = shift || \*(AqASSIGN(VAR(TERMINAL), TIMES(NUM(TERMINAL),NUM(TERMINAL)))  \*(Aq;
\&    10  my @t = Parse::Eyapp::Node\->new(
\&    11             $string,
\&    12             sub { my $i = 0; $_\->{n} = $i++ for @_ }
\&    13          );
\&    14
\&    15  print "****************\en";
\&    16  print Dumper(\e@t);
.Ve
.PP
When feed with input \f(CW\*(AqA(C,D) E(F)\*(Aq\fR 
the following forest is built:
.PP
.Vb 10
\&  $ builder.pl \*(AqA(C,D) E(F)\*(Aq
\&  ****************
\&  $VAR1 = [
\&    bless( {
\&      \*(Aqn\*(Aq => 0,
\&      \*(Aqchildren\*(Aq => [
\&        bless( { \*(Aqn\*(Aq => 1, \*(Aqchildren\*(Aq => [] }, \*(AqC\*(Aq ),
\&        bless( { \*(Aqn\*(Aq => 2, \*(Aqchildren\*(Aq => [] }, \*(AqD\*(Aq )
\&      ]
\&    }, \*(AqA\*(Aq ),
\&    {},
\&    {},
\&    bless( {
\&      \*(Aqn\*(Aq => 3,
\&      \*(Aqchildren\*(Aq => [
\&        bless( { \*(Aqn\*(Aq => 4, \*(Aqchildren\*(Aq => [] }, \*(AqF\*(Aq )
\&      ]
\&    }, \*(AqE\*(Aq ),
\&    {}
\&  ];
\&  $VAR1\->[1] = $VAR1\->[0]{\*(Aqchildren\*(Aq}[0];
\&  $VAR1\->[2] = $VAR1\->[0]{\*(Aqchildren\*(Aq}[1];
\&  $VAR1\->[4] = $VAR1\->[3]{\*(Aqchildren\*(Aq}[0];
.Ve
.PP
Thusm, the forest \f(CW@t\fR contains 5 subtrees 
\&\f(CW\*(C`A(C,D), C, D, E(F)\*(C'\fR and \f(CW\*(C`F\*(C'\fR.
.ie n .SS "Directed Acyclic Graphs with ""Parse::Eyapp::Node\->hnew"""
.el .SS "Directed Acyclic Graphs with \f(CWParse::Eyapp::Node\->hnew\fP"
.IX Subsection "Directed Acyclic Graphs with Parse::Eyapp::Node->hnew"
\&\f(CW\*(C`Parse::Eyapp\*(C'\fR provides the method \f(CW\*(C`Parse::Eyapp::Node\->hnew\*(C'\fR
to build \fIDirected Acyclic Graphs\fR (DAGs) instead of trees. They are built using 
\&\fIhashed consing\fR, i.e. \fImemoizing\fR the creation of nodes.
.PP
The method \f(CW\*(C`Parse::Eyapp::Node\->hnew\*(C'\fR works very much like \f(CW\*(C`Parse::Eyapp::Node\->new\*(C'\fR
but if one of the implied trees was previously built, \f(CW\*(C`hnew\*(C'\fR 
returns a reference to the existing one.
.PP
See the following debugger session where several DAGs describing
\&\fItype expressions\fR are built:
.PP
.Vb 10
\&  DB<2> x $a = Parse::Eyapp::Node\->hnew(\*(AqF(X_3(A_3(A_5(INT)), CHAR, A_5(INT)),CHAR)\*(Aq)
\& 0  F=HASH(0x85f6a20)
\&    \*(Aqchildren\*(Aq => ARRAY(0x85e92e4)
\&    |\- 0  X_3=HASH(0x83f55fc)
\&    |     \*(Aqchildren\*(Aq => ARRAY(0x83f5608)
\&    |     |\- 0  A_3=HASH(0x85a0488)
\&    |     |     \*(Aqchildren\*(Aq => ARRAY(0x859fad4)
\&    |     |        0  A_5=HASH(0x85e5d3c)
\&    |     |           \*(Aqchildren\*(Aq => ARRAY(0x83f4120)
\&    |     |              0  INT=HASH(0x83f5200)
\&    |     |                 \*(Aqchildren\*(Aq => ARRAY(0x852ccb4)
\&    |     |                      empty array
\&    |     |\- 1  CHAR=HASH(0x8513564)
\&    |     |     \*(Aqchildren\*(Aq => ARRAY(0x852cad4)
\&    |     |          empty array
\&    |     \`\- 2  A_5=HASH(0x85e5d3c)
\&    |           \-> REUSED_ADDRESS
\&    \`\- 1  CHAR=HASH(0x8513564)
\&          \-> REUSED_ADDRESS
\&  DB<3> x $a\->str
\& 0  \*(AqF(X_3(A_3(A_5(INT)),CHAR,A_5(INT)),CHAR)\*(Aq
.Ve
.PP
The second occurrence of \f(CW\*(C`A_5(INT)\*(C'\fR is labelled \f(CW\*(C`REUSED_ADDRESS\*(C'\fR. The
same occurs with the second instance  of \f(CW\*(C`CHAR\*(C'\fR.
.PP
\&\f(CW\*(C`Parse::Eyapp::Node\->hnew\*(C'\fR
can be more convenient than \f(CW\*(C`new\*(C'\fR 
in some compiler phases and tasks like 
detecting \fIcommon subexpressions\fR
or during \fItype checking\fR. 
See file \f(CW\*(C`Types.eyp\*(C'\fR in \f(CW\*(C`examples/typechecking/Simple\-Types\-XXX.tar.gz\*(C'\fR
for a more comprehensive example.
.ie n .SS "Expanding Directed Acyclic Graphs with ""Parse::Eyapp::Node\->hexpand"""
.el .SS "Expanding Directed Acyclic Graphs with \f(CWParse::Eyapp::Node\->hexpand\fP"
.IX Subsection "Expanding Directed Acyclic Graphs with Parse::Eyapp::Node->hexpand"
Calls to \f(CW\*(C`Parse::Eyapp::Node\->hexpand\*(C'\fR have the syntax
.PP
.Vb 1
\&    $z = Parse::Eyapp::Node\->hexpand(\*(AqCLASS\*(Aq, @children, \e&handler)
.Ve
.PP
Creates a dag of type \f(CW\*(AqCLASS\*(Aq\fR with children \f(CW@children\fR in a way compatible with
\&\f(CW\*(C`hnew\*(C'\fR. The last 
optional argument can be a reference to a sub.  Such sub will be called after the
creation of the \s-1DAG\s0 with a reference to the root of the \s-1DAG\s0 as single argument.
The following session with the debugger illustrates the use of
 \f(CW\*(C`Parse::Eyapp::Node\->hexpand\*(C'\fR. First we create a \s-1DAG\s0 using \f(CW\*(C`hnew\*(C'\fR:
.PP
.Vb 10
\&  pl@nereida:~/Lbook/code/Simple\-Types/script$ perl \-MParse::Eyapp::Node \-wde 0
\&  main::(\-e:1):   0
\&    DB<1> $x = Parse::Eyapp::Node\->hnew(\*(AqA(C(B),C(B))\*(Aq)
\&    DB<2> x $x
\&  0  A=HASH(0x850c850)
\&     \*(Aqchildren\*(Aq => ARRAY(0x850ca30)
\&        0  C=HASH(0x850c928)
\&           \*(Aqchildren\*(Aq => ARRAY(0x850c9e8)
\&              0  B=HASH(0x850c9a0)
\&                 \*(Aqchildren\*(Aq => ARRAY(0x83268c8)
\&                      empty array
\&        1  C=HASH(0x850c928)
\&           \-> REUSED_ADDRESS
.Ve
.PP
We obtain the \f(CW\*(C`REUSED_ADDRESS\*(C'\fR for the second child since
the \f(CWC(B)\fR subtree appears twice.
Now, suppose we want to expand the exsting tree/DAG \f(CWC(B)\fR to \f(CW\*(C`A(C(B))\*(C'\fR. We can do
that using \f(CW\*(C`hexpand\*(C'\fR:
.PP
.Vb 12
\&    DB<3> $y = Parse::Eyapp::Node\->hexpand(\*(AqA\*(Aq, $x\->child(0))
\&    DB<4> x $y
\&  0  A=HASH(0x8592558)
\&     \*(Aqchildren\*(Aq => ARRAY(0x832613c)
\&        0  C=HASH(0x850c928)
\&           \*(Aqchildren\*(Aq => ARRAY(0x850c9e8)
\&              0  B=HASH(0x850c9a0)
\&                 \*(Aqchildren\*(Aq => ARRAY(0x83268c8)
\&                      empty array
\&We get new memory for C<$y>: C<HASH(0x8592558)> is anew address.
\&Assume we want to expand the tree/DAG C<C(B)> to C<A(C(B),C(B))>.
\&We can do it this way:
\&
\&    DB<5> $z = Parse::Eyapp::Node\->hexpand(\*(AqA\*(Aq, $x\->children)
\&    DB<6> x $z
\&  0  A=HASH(0x850c850)
\&     \*(Aqchildren\*(Aq => ARRAY(0x850ca30)
\&        0  C=HASH(0x850c928)
\&           \*(Aqchildren\*(Aq => ARRAY(0x850c9e8)
\&              0  B=HASH(0x850c9a0)
\&                 \*(Aqchildren\*(Aq => ARRAY(0x83268c8)
\&                      empty array
\&        1  C=HASH(0x850c928)
\&           \-> REUSED_ADDRESS
.Ve
.PP
Notice that the address c<0x850c850> for \f(CW$z\fR is the same than the address for \f(CW$x\fR.
No new memory has been allocated for \f(CW$z\fR.
.PP
The following command illustrates the use of \f(CW\*(C`hexpand\*(C'\fR
with a handler:
.PP
.Vb 12
\&    DB<7> $z = Parse::Eyapp::Node\->hexpand(\*(AqA\*(Aq, $x\->children, sub { $_[0]\->{t} = "X" })
\&    DB<8> x $z
\&  0  A=HASH(0x850c850)
\&     \*(Aqchildren\*(Aq => ARRAY(0x850ca30)
\&        0  C=HASH(0x850c928)
\&           \*(Aqchildren\*(Aq => ARRAY(0x850c9e8)
\&              0  B=HASH(0x850c9a0)
\&                 \*(Aqchildren\*(Aq => ARRAY(0x83268c8)
\&                      empty array
\&        1  C=HASH(0x850c928)
\&           \-> REUSED_ADDRESS
\&     \*(Aqt\*(Aq => \*(AqX\*(Aq
.Ve
.ie n .SS "$node\->type"
.el .SS "\f(CW$node\fP\->type"
.IX Subsection "$node->type"
Returns (or sets) the type (class) of the node.
It can be called as a subroutine when \f(CW$node\fR is not
a \f(CW\*(C`Parse::Eyapp::Node\*(C'\fR like this:
.PP
.Vb 1
\&                     Parse::Eyapp::Node::type($scalar)
.Ve
.PP
This is the case when visiting \f(CW\*(C`CODE\*(C'\fR nodes.
.PP
The following session with the debugger illustrates how it works:
.PP
.Vb 10
\&  > perl \-MParse::Eyapp::Node \-de0
\&  DB<1> @t = Parse::Eyapp::Node\->new("A(B,C)") # Creates a tree
\&  DB<2> x map { $_\->type } @t # Get the types of the three nodes
\&  0  \*(AqA\*(Aq
\&  1  \*(AqB\*(Aq
\&  2  \*(AqC\*(Aq
\&  DB<3> x Parse::Eyapp::Node::type(sub {})
\&  0  \*(AqCODE\*(Aq
\&  DB<4> x Parse::Eyapp::Node::type("hola")
\&  0  \*(AqParse::Eyapp::Node::STRING\*(Aq
\&  DB<5> x Parse::Eyapp::Node::type({ a=> 1})
\&  0  \*(AqHASH\*(Aq
\&  DB<6> x Parse::Eyapp::Node::type([ a, 1 ])
\&  0  \*(AqARRAY\*(Aq
.Ve
.PP
As it is shown in the example it can be called as a subroutine with 
a (\s-1CODE/HASH/ARRAY\s0) reference or an ordinary scalar.
.PP
The words \s-1HASH, CODE, ARRAY\s0 and \s-1STRING\s0 are reserved for 
ordinary Perl references. Avoid naming a \s-1AST\s0 node with one of those words.
.PP
To be used as a setter, be sure Parse::Eyapp::Driver
is loaded:
.PP
.Vb 10
\&  $ perl \-MParse::Eyapp::Driver \-MParse::Eyapp::Node \-wde0
\&  main::(\-e:1):   0
\&    DB<1> x $t = Parse::Eyapp::Node\->new("A(B,C)") # Creates a tree
\&  0  A=HASH(0x8557bdc)
\&     \*(Aqchildren\*(Aq => ARRAY(0x8557c90)
\&        0  B=HASH(0x8557cf0)
\&           \*(Aqchildren\*(Aq => ARRAY(0x8325804)
\&                empty array
\&        1  C=HASH(0x8557c6c)
\&           \*(Aqchildren\*(Aq => ARRAY(0x8557d5c)
\&                empty array
\&    DB<2> x $t\->type(\*(AqFUN\*(Aq) # Change the type of $t to \*(AqFUN\*(Aq
\&  0  \*(AqFUN\*(Aq
\&    DB<3> x $t
\&  0  FUN=HASH(0x8557bdc)
\&     \*(Aqchildren\*(Aq => ARRAY(0x8557c90)
\&        0  B=HASH(0x8557cf0)
\&           \*(Aqchildren\*(Aq => ARRAY(0x8325804)
\&                empty array
\&        1  C=HASH(0x8557c6c)
\&           \*(Aqchildren\*(Aq => ARRAY(0x8557d5c)
\&                empty array
\&    DB<4> x $t\->isa(\*(AqParse::Eyapp::Node\*(Aq)
\&  0  1
.Ve
.ie n .SS "$node\->child"
.el .SS "\f(CW$node\fP\->child"
.IX Subsection "$node->child"
Setter-getter to modify a specific child of a node.
It is called like:
.PP
.Vb 1
\&                   $node\->child($i)
.Ve
.PP
Returns the child with index \f(CW$i\fR. Returns \f(CW\*(C`undef\*(C'\fR if the child does not exists.
It has two obligatory parameters: the node (since it is a method)
and the index of the child. Sets the new value if called
.PP
.Vb 1
\&                    $node\->child($i, $tree)
.Ve
.PP
The method will croak if the obligatory parameters are not provided.
.PP
In the files \f(CW\*(C`examples/Node/TSwithtreetransformations2.eyp\*(C'\fR and 
\&\f(CW\*(C`examples/node/usetswithtreetransformations2.pl\*(C'\fR) you can find a 
somewhat complicated example of call to \f(CW\*(C`child\*(C'\fR as a setter. It is inside a transformation
that swaps the children of a \f(CW\*(C`PLUS\*(C'\fR node (remember that the tree
is a concrete tree including code since it is a translation scheme
built under the directive \f(CW%metatree\fR):
.PP
.Vb 2
\&  my $transform = Parse::Eyapp::Treeregexp\->new( STRING => q{
\&     ........................................................
\&
\&     commutative_add: PLUS($x, ., $y, .) # 1st dot correspond to \*(Aq+\*(Aq 2nd dot to CODE
\&       => { my $t = $x; $_[0]\->child(0, $y); $_[0]\->child(2, $t)}
\&
\&     ........................................................
\&  }
.Ve
.ie n .SS "Child Access Through ""%tree alias"""
.el .SS "Child Access Through \f(CW%tree alias\fP"
.IX Subsection "Child Access Through %tree alias"
Remember that when the \f(CW\*(C`Eyapp\*(C'\fR program runs 
under the \f(CW\*(C`%tree alias\*(C'\fR directive 
The \fIdot and dollar notations\fR can be used 
to generate named getter-setters to access the children:
.PP
.Vb 10
\&  examples/Node$ cat \-n alias_and_yyprefix.pl
\&     1  #!/usr/local/bin/perl
\&     2  use warnings;
\&     3  use strict;
\&     4  use Parse::Eyapp;
\&     5
\&     6  my $grammar = q{
\&     7    %prefix R::S::
\&     8
\&     9    %right  \*(Aq=\*(Aq
\&    10    %left   \*(Aq\-\*(Aq \*(Aq+\*(Aq
\&    11    %left   \*(Aq*\*(Aq \*(Aq/\*(Aq
\&    12    %left   NEG
\&    13    %tree bypass alias
\&    14
\&    15    %%
\&    16    line: $exp  { $_[1] }
\&    17    ;
\&    18
\&    19    exp:
\&    20        %name NUM
\&    21              $NUM
\&    22      | %name VAR
\&    23              $VAR
\&    24      | %name ASSIGN
\&    25              $VAR \*(Aq=\*(Aq $exp
\&    26      | %name PLUS
\&    27              exp.left \*(Aq+\*(Aq exp.right
\&    28      | %name MINUS
\&    29              exp.left \*(Aq\-\*(Aq exp.right
\&    30      | %name TIMES
\&    31              exp.left \*(Aq*\*(Aq exp.right
\&    32      | %name DIV
\&    33              exp.left \*(Aq/\*(Aq exp.right
\&    34      | %no bypass UMINUS
\&    35              \*(Aq\-\*(Aq $exp %prec NEG
\&    36      |   \*(Aq(\*(Aq exp \*(Aq)\*(Aq  { $_[2] } /* Let us simplify a bit the tree */
\&    37    ;
\&    38
\&    39    %%
\&    40
\&    .............................
\&    76  }; # end grammar
\&    77
\&    78
\&    79  Parse::Eyapp\->new_grammar(
\&    80    input=>$grammar,
\&    81    classname=>\*(AqAlias\*(Aq,
\&    82    firstline =>7,
\&    83    outputfile => \*(Aqmain\*(Aq,
\&    84  );
\&    85  my $parser = Alias\->new();
\&    86  $parser\->YYData\->{INPUT} = "a = \-(2*3+5\-1)\en";
\&    87  my $t = $parser\->Run;
\&    88  $Parse::Eyapp::Node::INDENT=0;
\&    89  print $t\->VAR\->str."\en";             # a
\&    90  print "***************\en";
\&    91  print $t\->exp\->exp\->left\->str."\en";  # 2*3+5
\&    92  print "***************\en";
\&    93  print $t\->exp\->exp\->right\->str."\en"; # 1
.Ve
.PP
Here methods with names \f(CW\*(C`left\*(C'\fR and \f(CW\*(C`right\*(C'\fR will be created
inside the class \f(CW\*(C`R::S\*(C'\fR (see the use of the \f(CW%prefix\fR directive
in line 7) to access the corresponding children associated with the 
two instances of \f(CW\*(C`exp\*(C'\fR in the right hand side of
the production rule. when executed, teh former program produces this
output:
.PP
.Vb 6
\&  examples/Node$ alias_and_yyprefix.pl
\&  R::S::TERMINAL
\&  ***************
\&  R::S::PLUS(R::S::TIMES(R::S::NUM,R::S::NUM),R::S::NUM)
\&  ***************
\&  R::S::NUM
.Ve
.ie n .SS "$node\->children"
.el .SS "\f(CW$node\fP\->children"
.IX Subsection "$node->children"
Returns the array of children of the node. When the tree is a
translation scheme the \s-1CODE\s0 references are also included.
See \f(CW\*(C`examples/Node/TSPostfix3.eyp\*(C'\fR for an example of use
inside a Translation Scheme:
.PP
.Vb 2
\&  examples/Node$ cat TSPostfix3.eyp
\&  ...................... # precedence declarations
\&
\&  %metatree
\&
\&  %defaultaction {
\&    if (@_==2) {  # NUM and VAR
\&      $lhs\->{t} = $_[1]\->{attr};
\&      return
\&    }
\&    if (@_==4) { # binary operations
\&      $lhs\->{t} = "$_[1]\->{t} $_[3]\->{t} $_[2]\->{attr}";
\&      return
\&    }
\&    die "Fatal Error. Unexpected input. Numargs = ".scalar(@_)."\en".Parse::Eyapp::Node\->str(@_);
\&  }
\&
\&  %%
\&  line: %name PROG
\&         exp <%name EXP + \*(Aq;\*(Aq>
\&           { @{$lhs\->{t}} = map { $_\->{t}} ($_[1]\->children()); }
\&
\&  ;
\&
\&  exp:        %name NUM NUM
\&          |   %name VAR VAR
\&          |   %name ASSIGN VAR \*(Aq=\*(Aq exp  {  $lhs\->{t} = "$_[1]\->{attr} $_[3]\->{t} ="; }
\&          |   %name PLUS   exp \*(Aq+\*(Aq exp
\&          |   %name MINUS  exp \*(Aq\-\*(Aq exp
\&          |   %name TIMES  exp \*(Aq*\*(Aq exp
\&          |   %name DIV    exp \*(Aq/\*(Aq exp
\&          |   %name NEG    \*(Aq\-\*(Aq exp %prec NEG { $_[0]\->{t} = "$_[2]\->{t} NEG" }
\&          |   \*(Aq(\*(Aq exp \*(Aq)\*(Aq %begin { $_[2] }
\&  ;
\&
\&  %%
\&
\&  ........................
.Ve
.PP
The tree in a Translation Scheme contains the references to
the \f(CW\*(C`CODE\*(C'\fR implementing the semantic actions.
For example,  the syntax tree built by 
the parser for the input \f(CW\*(C`a=\-b*3\*(C'\fR in \f(CW\*(C`TSPostfix3.eyp\*(C'\fR is:
.PP
.Vb 10
\& PROG(EXP(
\&     ASSIGN(
\&       TERMINAL[a],
\&       TERMINAL[=],
\&       TIMES(
\&         NEG(TERMINAL[\-], VAR(TERMINAL[b], CODE), CODE),
\&         TERMINAL[*],
\&         NUM(TERMINAL[3], CODE),
\&         CODE
\&       ) # TIMES,
\&       CODE
\&     ) # ASSIGN
\&   ) # EXP,
\&   CODE
\& ) # PROG
.Ve
.PP
\&\f(CW\*(C`$node\->children\*(C'\fR can also be used as a setter.
.ie n .SS "$node\->Children"
.el .SS "\f(CW$node\fP\->Children"
.IX Subsection "$node->Children"
Returns the array of children of the node.
When dealing with a translation scheme,
the  \f(CW\*(C`$node\->Children\*(C'\fR method 
(Notice the case difference with \f(CW\*(C`$node\->children\*(C'\fR, first in uppercase) 
returns the non \f(CW\*(C`CODE\*(C'\fR children of the node.
The following execution with the debugger
of the example in \f(CW\*(C`examples/Node/ts_with_ast.pl\*(C'\fR
illustrates the difference:
.PP
.Vb 3
\&  examples/Node$ perl \-wd ts_with_ast.pl
\&  main::(ts_with_ast.pl:6):       my $translationscheme = q{
\&  main::(ts_with_ast.pl:7):       %{
.Ve
.PP
The \f(CW$translationscheme\fR variable contains the code
of a small calculator:
.PP
.Vb 1
\&  %metatree
\&
\&  %left   \*(Aq\-\*(Aq \*(Aq+\*(Aq
\&  %left   \*(Aq*\*(Aq
\&  %left   NEG
\&
\&  %%
\&  line:       %name EXP
\&                $exp  { $lhs\->{n} = $exp\->{n} }
\&  ;
\&
\&  exp:
\&              %name PLUS
\&                exp.left \*(Aq+\*(Aq  exp.right
\&                  { $lhs\->{n} .= $left\->{n} + $right\->{n} }
\&          |   %name TIMES
\&                exp.left \*(Aq*\*(Aq exp.right
\&                  { $lhs\->{n} = $left\->{n} * $right\->{n} }
\&          |   %name NUM   $NUM
\&                  { $lhs\->{n} = $NUM\->{attr} }
\&          |   \*(Aq(\*(Aq $exp \*(Aq)\*(Aq  %begin { $exp }
\&          |   exp.left \*(Aq\-\*(Aq exp.right
\&                  { $lhs\->{n} = $left\->{n} \- $right\->{n} }
\&
\&          |   \*(Aq\-\*(Aq $exp %prec NEG
\&                  { $lhs\->{n} = \-$exp\->{n} }
\&  ;
.Ve
.PP
We run the program with input \f(CW\*(C`2+(3)\*(C'\fR and stop
it at line 88, just after the augmented \s-1AST \s0(\f(CW\*(C`CODE\*(C'\fR node included)
has been built:
.PP
.Vb 2
\&    DB<1> c 88
\&  main::(ts_with_ast.pl:88):      $t\->translation_scheme;
.Ve
.PP
Now, let us see the difference between the methods \f(CW\*(C`children\*(C'\fR
and \f(CW\*(C`Children\*(C'\fR:
.PP
.Vb 7
\&    DB<2> @a = $t\->children; @b = $t\->Children
\&    DB<3> print Parse::Eyapp::Node::str($_)."\en" for @a
\&  PLUS(NUM(TERMINAL,CODE),TERMINAL,NUM(TERMINAL,CODE),CODE)
\&  CODE
\&    DB<4> print $_\->str."\en" for @b
\&  PLUS(NUM(TERMINAL,CODE),TERMINAL,NUM(TERMINAL,CODE),CODE)
\&    DB<5>
.Ve
.ie n .SS "$node\->last_child"
.el .SS "\f(CW$node\fP\->last_child"
.IX Subsection "$node->last_child"
Return the last child of the node. When dealing with translation
schemes, the last can be a \f(CW\*(C`CODE\*(C'\fR node.
.ie n .SS "$node\->Last_child"
.el .SS "\f(CW$node\fP\->Last_child"
.IX Subsection "$node->Last_child"
The \f(CW\*(C`$node\->Last_child\*(C'\fR method returns the last non \s-1CODE\s0 child of the node.
See an example:
.PP
.Vb 10
\&  examples/Node$ cat \-n trans_scheme_default_action.pl
\&     1  #!/usr/bin/perl \-w
\&     2  use strict;
\&     3  use Data::Dumper;
\&     4  use Parse::Eyapp;
\&     5  use IO::Interactive qw(is_interactive);
\&     6
\&     7  my $translationscheme = q{
\&     8  %{
\&     9  # head code is available at tree construction time
\&    10  use Data::Dumper;
\&    11  our %sym; # symbol table
\&    12  %}
\&    13
\&    14  %prefix Calc::
\&    15
\&    16  %defaultaction {
\&    17     $lhs\->{n} = eval " $left\->{n} $_[2]\->{attr} $right\->{n} "
\&    18  }
\&    19
\&    20  %metatree
\&    21
\&    22  %right   \*(Aq=\*(Aq
\&    23  %left   \*(Aq\-\*(Aq \*(Aq+\*(Aq
\&    24  %left   \*(Aq*\*(Aq \*(Aq/\*(Aq
\&    25
\&    26  %%
\&    27  line:       %name EXP
\&    28                exp <+ \*(Aq;\*(Aq> /* Expressions separated by semicolons */
\&    29                  { $lhs\->{n} = $_[1]\->Last_child\->{n} }
\&    30  ;
\&    31
\&    32  exp:
\&    33              %name PLUS
\&    34                exp.left \*(Aq+\*(Aq exp.right
\&    35          |   %name MINUS
\&    36                exp.left \*(Aq\-\*(Aq exp.right
\&    37          |   %name TIMES
\&    38                exp.left \*(Aq*\*(Aq exp.right
\&    39          |   %name DIV
\&    40                exp.left \*(Aq/\*(Aq exp.right
\&    41          |   %name NUM
\&    42                $NUM
\&    43                  { $lhs\->{n} = $NUM\->{attr} }
\&    44          |   \*(Aq(\*(Aq $exp \*(Aq)\*(Aq  %begin { $exp }
\&    45          |   %name VAR
\&    46                $VAR
\&    47                  { $lhs\->{n} = $sym{$VAR\->{attr}}\->{n} }
\&    48          |   %name ASSIGN
\&    49                $VAR \*(Aq=\*(Aq $exp
\&    50                  { $lhs\->{n} = $sym{$VAR\->{attr}}\->{n} = $exp\->{n} }
\&    51
\&    52  ;
\&    53
\&    54  %%
\&    55  # tail code is available at tree construction time
\&    ......................................................
\&    77  }; # end translation scheme
\&    78
\&    ......................................................
.Ve
.PP
The node associated with \f(CW$_[1]\fR in
.PP
.Vb 3
\&    27  line:       %name EXP
\&    28                exp <+ \*(Aq;\*(Aq> /* Expressions separated by semicolons */
\&    29                  { $lhs\->{n} = $_[1]\->Last_child\->{n} }
.Ve
.PP
is associated with the whole expression
.PP
.Vb 1
\&                               exp <+ \*(Aq;\*(Aq>
.Ve
.PP
and is a \f(CW\*(C`Calc::_PLUS_LIST\*(C'\fR node. 
When feed with input \f(CW\*(C`a=3;b=4\*(C'\fR the children are
the two \f(CW\*(C`Calc::ASSIGN\*(C'\fR subtrees associated with
\&\f(CW\*(C`a=3\*(C'\fR and \f(CW\*(C`b=4\*(C'\fR and the \f(CW\*(C`CODE\*(C'\fR associated with the
semantic action:
.PP
.Vb 1
\&            { $lhs\->{n} = $_[1]\->Last_child\->{n} }
.Ve
.PP
Using \f(CW\*(C`Last_child\*(C'\fR we are avoiding the last \f(CW\*(C`CODE\*(C'\fR
child and setting the \f(CW\*(C`n\*(C'\fR(umeric) attribute
of the \f(CW\*(C`EXP\*(C'\fR node to the one associated with \f(CW\*(C`b=4\*(C'\fR (i.e. \f(CW4\fR).
.PP
.Vb 3
\&  examples/Node$ trans_scheme_default_action.pl
\&  Write a sequence of arithmetic expressions: a=3;b=4
\&  ***********Tree*************
\&
\&  Calc::EXP(
\&    Calc::_PLUS_LIST(
\&      Calc::ASSIGN(
\&        Calc::TERMINAL,
\&        Calc::TERMINAL,
\&        Calc::NUM(
\&          Calc::TERMINAL,
\&          CODE
\&        ),
\&        CODE
\&      ) # Calc::ASSIGN,
\&      Calc::ASSIGN(
\&        Calc::TERMINAL,
\&        Calc::TERMINAL,
\&        Calc::NUM(
\&          Calc::TERMINAL,
\&          CODE
\&        ),
\&        CODE
\&      ) # Calc::ASSIGN
\&    ) # Calc::_PLUS_LIST,
\&    CODE
\&  ) # Calc::EXP
\&  ******Symbol table**********
\&  {
\&    \*(Aqa\*(Aq => { \*(Aqn\*(Aq => \*(Aq3\*(Aq },
\&    \*(Aqb\*(Aq => { \*(Aqn\*(Aq => \*(Aq4\*(Aq }
\&  }
\&
\&  ************Result**********
\&  4
.Ve
.ie n .SS "$node\->descendant"
.el .SS "\f(CW$node\fP\->descendant"
.IX Subsection "$node->descendant"
The \f(CW\*(C` descendant\*(C'\fR method 
returns the descendant of a node given its \fIcoordinates\fR. 
The coordinates of a node \f(CW$s\fR relative to a tree \f(CW$t\fR
to which it belongs is a string of numbers
separated by dots like  \f(CW".1.3.2"\fR which
denotes the \fIchild path\fR from \f(CW$t\fR to \f(CW$s\fR, i.e.
\&\f(CW\*(C`$s == $t\->child(1)\->child(3)\->child(2)\*(C'\fR.
.PP
See a session
with the debugger:
.PP
.Vb 9
\&   DB<7> x $t\->child(0)\->child(0)\->child(1)\->child(0)\->child(2)\->child(1)\->str
\& 0  \*(Aq
\& BLOCK[8:4:test]^{0}(
\&   CONTINUE[10,10]
\& )
\&   DB<8> x $t\->descendant(\*(Aq.0.0.1.0.2.1\*(Aq)\->str
\& 0  \*(Aq
\& BLOCK[8:4:test]^{0}(
\&   CONTINUE[10,10]
.Ve
.ie n .SS "$node\->str"
.el .SS "\f(CW$node\fP\->str"
.IX Subsection "$node->str"
The \f(CW\*(C`str\*(C'\fR method returns a string representation of the tree. 
The \fIstr\fR method traverses the syntax tree dumping the type
of the node being visited in a string. To be specific
the value returned by the function referenced by \f(CW$CLASS_HANDLER\fR 
will be dumped. The default value fo such function is to return the type
of the node.
If the node being visited
has a method \f(CW\*(C`info\*(C'\fR it will
be executed and its result inserted between \f(CW$DELIMITER\fRs
into the string. Thus, in the \*(L"\s-1SYNOPSIS\*(R"\s0
example, by adding the \f(CW\*(C`info\*(C'\fR method to the class \f(CW\*(C`TERMINAL\*(C'\fR:
.PP
.Vb 3
\& sub TERMINAL::info {
\&   $_[0]{attr}
\& }
.Ve
.PP
we achieve the insertion of attributes in the string being built 
by \f(CW\*(C`str\*(C'\fR.
.PP
The existence of some methods (like \f(CW\*(C`footnote\*(C'\fR) and
the values of some package variables
influence the behavior of \f(CW\*(C`str\*(C'\fR. Among the most
important are:
.PP
.Vb 12
\&  @PREFIXES = qw(Parse::Eyapp::Node::);                                # Prefixes to suppress 
\&  $INDENT = 0; # \-1 compact, no info, no footnotes 
\&               # 0 = compact, 1 = indent, 2 = indent and include Types in closing parenthesis
\&  $STRSEP = \*(Aq,\*(Aq;                                # Separator between nodes, by default a comma
\&  $DELIMITER = \*(Aq[\*(Aq;                         # The string returned by C<info> will be enclosed 
\&  $FOOTNOTE_HEADER = "\en\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\en"; 
\&  $FOOTNOTE_SEP = ")\en"; 
\&  $FOOTNOTE_LEFT = \*(Aq^{\*(Aq;                               # Left delimiter for a footnote number
\&  $FOOTNOTE_RIGHT = \*(Aq}\*(Aq;                              # Right delimiter for a footnote number
\&  $LINESEP = 4;                             # When indent=2 the enclosing parenthesis will be
\&                                            # commented if more than $LINESEP apart
\&  $CLASS_HANDLER = sub { type($_[0]) }; # What to print to identify the node
.Ve
.PP
Footnotes and attribute info will not be inserted when \f(CW$INDENT\fR 
is \-1. A compact representation will be obtained. Such representation 
can be feed to \f(CW\*(C`new\*(C'\fR or \f(CW\*(C`hnew\*(C'\fR to obtain a copy of the tree. 
See the following session with the debugger:
.PP
.Vb 10
\&  pl@nereida:~/LEyapp$ perl \-MParse::Eyapp::Node \-wde 0
\&  main::(\-e:1):   0
\&    DB<1> $x = Parse::Eyapp::Node\->new(\*(AqA(B(C,D),D)\*(Aq, sub { $_\->{order} = $i++ for @_; })
\&    DB<2> *A::info = *B::info = *C::info = *D::info = sub { shift()\->{order} }
\&    DB<3> p $x\->str
\&  A[0](B[1](C[2],D[3]),D[4])
\&    DB<4> $Parse::Eyapp::Node::INDENT=\-1
\&    DB<5> p $x\->str
\&  A(B(C,D),D)
\&    DB<6> x Parse::Eyapp::Node\->hnew($x\->str)
\&  0  A=HASH(0x8574704)
\&     \*(Aqchildren\*(Aq => ARRAY(0x85745d8)
\&        0  B=HASH(0x857468c)
\&           \*(Aqchildren\*(Aq => ARRAY(0x8574608)
\&              0  C=HASH(0x85745b4)
\&                 \*(Aqchildren\*(Aq => ARRAY(0x8509670)
\&                      empty array
\&              1  D=HASH(0x8574638)
\&                 \*(Aqchildren\*(Aq => ARRAY(0x857450c)
\&                      empty array
\&        1  D=HASH(0x8574638)
\&           \-> REUSED_ADDRESS
\&  1  B=HASH(0x857468c)
\&     \-> REUSED_ADDRESS
\&  2  C=HASH(0x85745b4)
\&     \-> REUSED_ADDRESS
\&  3  D=HASH(0x8574638)
\&     \-> REUSED_ADDRESS
\&  4  D=HASH(0x8574638)
\&     \-> REUSED_ADDRESS
.Ve
.PP
The following list defines the \f(CW$DELIMITER\fRs you can choose for 
attribute representation:
.PP
.Vb 1
\&          \*(Aq[\*(Aq => \*(Aq]\*(Aq, \*(Aq{\*(Aq => \*(Aq}\*(Aq, \*(Aq(\*(Aq => \*(Aq)\*(Aq, \*(Aq<\*(Aq => \*(Aq>\*(Aq
.Ve
.PP
If the node being visited has a method  \f(CW\*(C`footnote\*(C'\fR, the string
returned by the method will be concatenated at the end of the 
string as a footnote. The variables \f(CW$FOOTNOTE_LEFT\fR and
\&\f(CW$FOOTNOTE_RIGHT\fR govern the displaying of footnote numbers.
.PP
Follows an example of output using \f(CW\*(C`footnotes\*(C'\fR.
.PP
.Vb 10
\& nereida:~/doc/casiano/PLBOOK/PLBOOK/code/Simple\-Types/script> \e
\&                                          usetypes.pl prueba24.c
\& PROGRAM^{0}(FUNCTION[f]^{1}(RETURNINT(TIMES(INUM(TERMINAL[2:2]),VAR(TERMINAL[a:2])))))
\& \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\& 0)
\& Types:
\& $VAR1 = {
\&   \*(AqCHAR\*(Aq => bless( {
\&     \*(Aqchildren\*(Aq => []
\&   }, \*(AqCHAR\*(Aq ),
\&   \*(AqVOID\*(Aq => bless( {
\&     \*(Aqchildren\*(Aq => []
\&   }, \*(AqVOID\*(Aq ),
\&   \*(AqINT\*(Aq => bless( {
\&     \*(Aqchildren\*(Aq => []
\&   }, \*(AqINT\*(Aq ),
\&   \*(AqF(X_1(INT),INT)\*(Aq => bless( {
\&     \*(Aqchildren\*(Aq => [
\&       bless( {
\&         \*(Aqchildren\*(Aq => [
\&           $VAR1\->{\*(AqINT\*(Aq}
\&         ]
\&       }, \*(AqX_1\*(Aq ),
\&       $VAR1\->{\*(AqINT\*(Aq}
\&     ]
\&   }, \*(AqF\*(Aq )
\& };
\& Symbol Table:
\& $VAR1 = {
\&   \*(Aqf\*(Aq => {
\&     \*(Aqtype\*(Aq => \*(AqF(X_1(INT),INT)\*(Aq,
\&     \*(Aqline\*(Aq => 1
\&   }
\& };
\&
\& \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\& 1)
\& $VAR1 = {
\&   \*(Aqa\*(Aq => {
\&     \*(Aqtype\*(Aq => \*(AqINT\*(Aq,
\&     \*(Aqparam\*(Aq => 1,
\&     \*(Aqline\*(Aq => 1
\&   }
\& };
.Ve
.PP
The first footnote was due to a call to \f(CW\*(C`PROGRAM:footnote\*(C'\fR.
The \f(CW\*(C`footnote\*(C'\fR method for the \f(CW\*(C`PROGRAM\*(C'\fR node was defined as:
.PP
.Vb 8
\& nereida:~/doc/casiano/PLBOOK/PLBOOK/code/Simple\-Types/lib/Simple> \e
\&                             sed \-n \-e \*(Aq691,696p\*(Aq Types.eyp | cat \-n
\&     1  sub PROGRAM::footnote {
\&     2    return "Types:\en"
\&     3           .Dumper($_[0]\->{types}).
\&     4           "Symbol Table:\en"
\&     5           .Dumper($_[0]\->{symboltable})
\&     6  }
.Ve
.PP
The second footnote was produced by the existence of a
\&\f(CW\*(C`FUNCTION::footnote\*(C'\fR method:
.PP
.Vb 5
\& nereida:~/doc/casiano/PLBOOK/PLBOOK/code/Simple\-Types/lib/Simple> \e
\&                            sed \-n \-e \*(Aq702,704p\*(Aq Types.eyp | cat \-n
\& 1  sub FUNCTION::footnote {
\& 2    return Dumper($_[0]\->{symboltable})
\& 3  }
.Ve
.PP
The source program for the example was:
.PP
.Vb 3
\&     1  int f(int a) {
\&     2    return 2*a;
\&     3  }
.Ve
.ie n .SS "$node\->equal"
.el .SS "\f(CW$node\fP\->equal"
.IX Subsection "$node->equal"
A call  \f(CW\*(C`$tree1\->equal($tree2)\*(C'\fR  
compare the two trees \f(CW$tree1\fR and \f(CW$tree2\fR. 
Two trees are considered equal if their root nodes belong to the same class,
they have the same number of children and the children are (recursively) equal.
.PP
In Addition to the two trees the programmer can specify
pairs \f(CW\*(C`attribute_key => equality_handler\*(C'\fR:
.PP
.Vb 1
\&  $tree1\->equal($tree2, attr1 => \e&handler1, attr2 => \e&handler2, ...)
.Ve
.PP
In such case 
the definition of equality is more restrictive:
Two trees are considered equal if
.IP "\(bu" 2
Their root nodes belong to the same class,
.IP "\(bu" 2
They have the same number of children
.IP "\(bu" 2
For each of the specified attributes occur
that for both nodes the existence and definition of the key
is the same
.IP "\(bu" 2
Assuming the key exists and is defined for both 
nodes, the equality handlers return
true for each of its attributes and
.IP "\(bu" 2
The respective children are (recursively) equal.
.PP
An attribute handler receives as arguments the values of the attributes
of the two nodes being compared and must return true if, and only if,
these two attributes are considered equal. Follows an example:
.PP
.Vb 10
\&  examples/Node$ cat \-n equal.pl
\&     1  #!/usr/bin/perl \-w
\&     2  use strict;
\&     3  use Parse::Eyapp::Node;
\&     4
\&     5  my $string1 = shift || \*(AqASSIGN(VAR(TERMINAL))\*(Aq;
\&     6  my $string2 = shift || \*(AqASSIGN(VAR(TERMINAL))\*(Aq;
\&     7  my $t1 = Parse::Eyapp::Node\->new($string1, sub { my $i = 0; $_\->{n} = $i++ for @_ });
\&     8  my $t2 = Parse::Eyapp::Node\->new($string2);
\&     9
\&    10  # Without attributes
\&    11  if ($t1\->equal($t2)) {
\&    12    print "\enNot considering attributes: Equal\en";
\&    13  }
\&    14  else {
\&    15    print "\enNot considering attributes: Not Equal\en";
\&    16  }
\&    17
\&    18  # Equality with attributes
\&    19  if ($t1\->equal($t2, n => sub { return $_[0] == $_[1] })) {
\&    20    print "\enConsidering attributes: Equal\en";
\&    21  }
\&    22  else {
\&    23    print "\enConsidering attributes: Not Equal\en";
\&    24  }
.Ve
.PP
When the former program is run without arguments produces the following
output:
.PP
.Vb 1
\&  examples/Node$ equal.pl
\&
\&  Not considering attributes: Equal
\&
\&  Considering attributes: Not Equal
.Ve
.ie n .SS "Using ""equal"" During Testing"
.el .SS "Using \f(CWequal\fP During Testing"
.IX Subsection "Using equal During Testing"
During the development of your compiler you add new stages
to the existing ones. The consequence is that the \s-1AST\s0 is decorated
with new attributes. Unfortunately, this implies that tests you wrote using 
\&\f(CW\*(C`is_deeply\*(C'\fR and comparisons against formerly correct abstract syntax trees are no longer valid.
This is due to the fact that \f(CW\*(C`is_deeply\*(C'\fR requires both tree structures to be
equivalent in every detail and that our new code produces a tree with new attributes.
.PP
Instead of \f(CW\*(C`is_deeply\*(C'\fR use the \f(CW\*(C`equal\*(C'\fR method to check for partial equivalence between
abstract syntax trees. You can follow these steps:
.IP "\(bu" 2
Dump the tree for the source inserting \f(CW\*(C`Data::Dumper\*(C'\fR statements
.IP "\(bu" 2
Carefully check that the tree is really correct
.IP "\(bu" 2
Decide which attributes will be used for comparison
.IP "\(bu" 2
Write the code for the expected value
editing the output produced by \f(CW\*(C`Data::Dumper\*(C'\fR
.IP "\(bu" 2
Write the handlers for the attributes you decided.
Write the comparison using \f(CW\*(C`equal\*(C'\fR.
.PP
Tests using this methodology will not fail even if later code decorating 
the \s-1AST\s0 with new attributes is introduced.
.PP
See an example that checks an abstract syntax tree produced
by the simple compiler (see  \f(CW\*(C`examples/typechecking/Simple\-Types\-XXX.tar.gz\*(C'\fR) 
for a really simple source:
.PP
.Vb 3
\&  Simple\-Types/script$ cat prueba27.c
\&  int f() {
\&  }
.Ve
.PP
The first thing is to obtain a description of the tree,
that can be done executing the compiler under the control of
the Perl debugger, stopping just after the 
tree has been built and dumping the tree
with Data::Dumper:
.PP
.Vb 11
\&  pl@nereida:~/Lbook/code/Simple\-Types/script$ perl \-wd usetypes.pl prueba27.c
\&  main::(usetypes.pl:5):  my $filename = shift || die "Usage:\en$0 file.c\en";
\&    DB<1> c 12
\&  main::(usetypes.pl:12): Simple::Types::show_trees($t, $debug);
\&    DB<2> use Data::Dumper
\&    DB<3> $Data::Dumper::Purity = 1
\&    DB<4> p Dumper($t)
\&  $VAR1 = bless( {
\&                   ..............................................
\&                 }, \*(AqPROGRAM\*(Aq );
\&  ...............................................................
.Ve
.PP
Once we have the shape of a correct tree we can write
our tests:
.PP
.Vb 10
\&  examples/Node$ cat \-n testequal.pl
\&     1  #!/usr/bin/perl \-w
\&     2  use strict;
\&     3  use Parse::Eyapp::Node;
\&     4  use Data::Dumper;
\&     5  use Data::Compare;
\&     6
\&     7  my $debugging = 0;
\&     8
\&     9  my $handler = sub {
\&    10    print Dumper($_[0], $_[1]) if $debugging;
\&    11    Compare($_[0], $_[1])
\&    12  };
\&    13
\&    14  my $t1 = bless( {
\&    15                   \*(Aqtypes\*(Aq => {
\&    16                                \*(AqCHAR\*(Aq => bless( { \*(Aqchildren\*(Aq => [] }, \*(AqCHAR\*(Aq ),
\&    17                                \*(AqVOID\*(Aq => bless( { \*(Aqchildren\*(Aq => [] }, \*(AqVOID\*(Aq ),
\&    18                                \*(AqINT\*(Aq => bless( { \*(Aqchildren\*(Aq => [] }, \*(AqINT\*(Aq ),
\&    19                                \*(AqF(X_0(),INT)\*(Aq => bless( {
\&    20                                   \*(Aqchildren\*(Aq => [
\&    21                                      bless( { \*(Aqchildren\*(Aq => [] }, \*(AqX_0\*(Aq ),
\&    22                                      bless( { \*(Aqchildren\*(Aq => [] }, \*(AqINT\*(Aq ) ]
\&    23                                 }, \*(AqF\*(Aq )
\&    24                              },
\&    25                   \*(Aqsymboltable\*(Aq => { \*(Aqf\*(Aq => { \*(Aqtype\*(Aq => \*(AqF(X_0(),INT)\*(Aq, \*(Aqline\*(Aq => 1 } },
\&    26                   \*(Aqlines\*(Aq => 2,
\&    27                   \*(Aqchildren\*(Aq => [
\&    28                                   bless( {
\&    29                                            \*(Aqsymboltable\*(Aq => {},
\&    30                                            \*(Aqfatherblock\*(Aq => {},
\&    31                                            \*(Aqchildren\*(Aq => [],
\&    32                                            \*(Aqdepth\*(Aq => 1,
\&    33                                            \*(Aqparameters\*(Aq => [],
\&    34                                            \*(Aqfunction_name\*(Aq => [ \*(Aqf\*(Aq, 1 ],
\&    35                                            \*(AqsymboltableLabel\*(Aq => {},
\&    36                                            \*(Aqline\*(Aq => 1
\&    37                                          }, \*(AqFUNCTION\*(Aq )
\&    38                                 ],
\&    39                   \*(Aqdepth\*(Aq => 0,
\&    40                   \*(Aqline\*(Aq => 1
\&    41                 }, \*(AqPROGRAM\*(Aq );
\&    42  $t1\->{\*(Aqchildren\*(Aq}[0]{\*(Aqfatherblock\*(Aq} = $t1;
\&    43
\&    44  # Tree similar to $t1 but without some attributes (line, depth, etc.)
\&    45  my $t2 = bless( {
\&    46                   \*(Aqtypes\*(Aq => {
\&    47                                \*(AqCHAR\*(Aq => bless( { \*(Aqchildren\*(Aq => [] }, \*(AqCHAR\*(Aq ),
\&    48                                \*(AqVOID\*(Aq => bless( { \*(Aqchildren\*(Aq => [] }, \*(AqVOID\*(Aq ),
\&    49                                \*(AqINT\*(Aq => bless( { \*(Aqchildren\*(Aq => [] }, \*(AqINT\*(Aq ),
\&    50                                \*(AqF(X_0(),INT)\*(Aq => bless( {
\&    51                                   \*(Aqchildren\*(Aq => [
\&    52                                      bless( { \*(Aqchildren\*(Aq => [] }, \*(AqX_0\*(Aq ),
\&    53                                      bless( { \*(Aqchildren\*(Aq => [] }, \*(AqINT\*(Aq ) ]
\&    54                                 }, \*(AqF\*(Aq )
\&    55                              },
\&    56                   \*(Aqsymboltable\*(Aq => { \*(Aqf\*(Aq => { \*(Aqtype\*(Aq => \*(AqF(X_0(),INT)\*(Aq, \*(Aqline\*(Aq => 1 } },
\&    57                   \*(Aqchildren\*(Aq => [
\&    58                                   bless( {
\&    59                                            \*(Aqsymboltable\*(Aq => {},
\&    60                                            \*(Aqfatherblock\*(Aq => {},
\&    61                                            \*(Aqchildren\*(Aq => [],
\&    62                                            \*(Aqparameters\*(Aq => [],
\&    63                                            \*(Aqfunction_name\*(Aq => [ \*(Aqf\*(Aq, 1 ],
\&    64                                          }, \*(AqFUNCTION\*(Aq )
\&    65                                 ],
\&    66                 }, \*(AqPROGRAM\*(Aq );
\&    67  $t2\->{\*(Aqchildren\*(Aq}[0]{\*(Aqfatherblock\*(Aq} = $t2;
\&    68
\&    69  # Tree similar to $t1 but without some attributes (line, depth, etc.)
\&    70  # and without the symboltable and types attributes used in the comparison
\&    71  my $t3 = bless( {
\&    72                   \*(Aqtypes\*(Aq => {
\&    73                                \*(AqCHAR\*(Aq => bless( { \*(Aqchildren\*(Aq => [] }, \*(AqCHAR\*(Aq ),
\&    74                                \*(AqVOID\*(Aq => bless( { \*(Aqchildren\*(Aq => [] }, \*(AqVOID\*(Aq ),
\&    75                                \*(AqINT\*(Aq => bless( { \*(Aqchildren\*(Aq => [] }, \*(AqINT\*(Aq ),
\&    76                                \*(AqF(X_0(),INT)\*(Aq => bless( {
\&    77                                   \*(Aqchildren\*(Aq => [
\&    78                                      bless( { \*(Aqchildren\*(Aq => [] }, \*(AqX_0\*(Aq ),
\&    79                                      bless( { \*(Aqchildren\*(Aq => [] }, \*(AqINT\*(Aq ) ]
\&    80                                 }, \*(AqF\*(Aq )
\&    81                              },
\&    82                   \*(Aqchildren\*(Aq => [
\&    83                                   bless( {
\&    84                                            \*(Aqsymboltable\*(Aq => {},
\&    85                                            \*(Aqfatherblock\*(Aq => {},
\&    86                                            \*(Aqchildren\*(Aq => [],
\&    87                                            \*(Aqparameters\*(Aq => [],
\&    88                                            \*(Aqfunction_name\*(Aq => [ \*(Aqf\*(Aq, 1 ],
\&    89                                          }, \*(AqFUNCTION\*(Aq )
\&    90                                 ],
\&    91                 }, \*(AqPROGRAM\*(Aq );
\&    92
\&    93  $t3\->{\*(Aqchildren\*(Aq}[0]{\*(Aqfatherblock\*(Aq} = $t2;
\&    94
\&    95  # Without attributes
\&    96  if (Parse::Eyapp::Node::equal($t1, $t2)) {
\&    97    print "\enNot considering attributes: Equal\en";
\&    98  }
\&    99  else {
\&   100    print "\enNot considering attributes: Not Equal\en";
\&   101  }
\&   102
\&   103  # Equality with attributes
\&   104  if (Parse::Eyapp::Node::equal(
\&   105        $t1, $t2,
\&   106        symboltable => $handler,
\&   107        types => $handler,
\&   108      )
\&   109     ) {
\&   110        print "\enConsidering attributes: Equal\en";
\&   111  }
\&   112  else {
\&   113    print "\enConsidering attributes: Not Equal\en";
\&   114  }
\&   115
\&   116  # Equality with attributes
\&   117  if (Parse::Eyapp::Node::equal(
\&   118        $t1, $t3,
\&   119        symboltable => $handler,
\&   120        types => $handler,
\&   121      )
\&   122     ) {
\&   123        print "\enConsidering attributes: Equal\en";
\&   124  }
\&   125  else {
\&   126    print "\enConsidering attributes: Not Equal\en";
\&   127  }
.Ve
.PP
The code defining tree \f(CW$t1\fR was obtained from an output using \f(CW\*(C`Data::Dumper\*(C'\fR.
The code for trees \f(CW$t2\fR and \f(CW$t3\fR was written using cut-and-paste from \f(CW$t1\fR.
They have the same shape than \f(CW$t1\fR but differ in their attributes. Tree \f(CW$t2\fR
shares with \f(CW$t1\fR the attributes \f(CW\*(C`symboltable\*(C'\fR and \f(CW\*(C`types\*(C'\fR used in the comparison
and so \f(CW\*(C`equal\*(C'\fR returns \f(CW\*(C`true\*(C'\fR when compared. Since \f(CW$t3\fR differs from \f(CW$t1\fR
in the attributes \f(CW\*(C`symboltable\*(C'\fR and \f(CW\*(C`types\*(C'\fR the call to \f(CW\*(C`equal\*(C'\fR returns \f(CW\*(C`false\*(C'\fR.
.ie n .SS "$node\->delete"
.el .SS "\f(CW$node\fP\->delete"
.IX Subsection "$node->delete"
The \f(CW\*(C`$node\->delete($child)\*(C'\fR method is used to delete the specified child of \f(CW$node\fR.
The child to delete can be specified using the index or a
reference. It returns the deleted child.
.PP
Throws an exception if the object can't do \f(CW\*(C`children\*(C'\fR or has no \f(CW\*(C`children\*(C'\fR.
See also the delete method of treeregexes 
(\f(CW\*(C`Parse::Eyapp:YATW\*(C'\fR objects)
to delete the node being visited.
.PP
The following example moves out of a loop an assignment statement
assuming is an invariant of the loop. To do it, it uses
the \f(CW\*(C`delete\*(C'\fR and \f(CW\*(C`insert_before\*(C'\fR methods:
.PP
.Vb 10
\&  nereida:~/src/perl/YappWithDefaultAction/examples> \e
\&              sed \-ne \*(Aq98,113p\*(Aq moveinvariantoutofloopcomplexformula.pl
\&  my $p = Parse::Eyapp::Treeregexp\->new( STRING => q{
\&    moveinvariant: BLOCK(
\&                     @prests,
\&                     WHILE(VAR($b), BLOCK(@a, ASSIGN($x, NUM($e)), @c)),
\&                     @possts
\&                   )
\&      => {
\&           my $assign = $ASSIGN;
\&           $BLOCK[1]\->delete($ASSIGN);
\&           $BLOCK[0]\->insert_before($WHILE, $assign);
\&         }
\&    },
\&    FIRSTLINE => 99,
\&  );
\&  $p\->generate();
\&  $moveinvariant\->s($t);
.Ve
.PP
The example below deletes \s-1CODE\s0 nodes
from the tree build for a translation scheme:
.PP
.Vb 5
\&  my $transform = Parse::Eyapp::Treeregexp\->new( 
\&    STRING=>q{
\&      delete_code: CODE => { Parse::Eyapp::Node::delete($CODE) }
\&    },
\&  )
.Ve
.PP
Observe how delete is called as a subroutine.
.ie n .SS "$node\->unshift($newchild)"
.el .SS "\f(CW$node\fP\->unshift($newchild)"
.IX Subsection "$node->unshift($newchild)"
Inserts \f(CW$newchild\fR at the beginning of the list of children of \f(CW$node\fR.
See also the unshift method 
for \f(CW\*(C`Parse::Eyapp:YATW\*(C'\fR treeregexp transformation objects
.ie n .SS "$node\->push($newchild)"
.el .SS "\f(CW$node\fP\->push($newchild)"
.IX Subsection "$node->push($newchild)"
Inserts \f(CW$newchild\fR at the end of the list of children of \f(CW$node\fR.
.ie n .SS "$node\->insert_before($position, $new_child)"
.el .SS "\f(CW$node\fP\->insert_before($position, \f(CW$new_child\fP)"
.IX Subsection "$node->insert_before($position, $new_child)"
Inserts \f(CW$newchild\fR before \f(CW$position\fR in the list of children of \f(CW$node\fR.
Variable \f(CW$position\fR can be an index or a reference.
.PP
The method throws an exception if \f(CW$position\fR is an index
and is not in range. Also if \f(CW$node\fR has no children.
.PP
The method throws a warning if \f(CW$position\fR is a reference and does not define
an actual child. In such case \f(CW$new_child\fR is not inserted.
.PP
See also the insert_before 
method for \f(CW\*(C`Parse::Eyapp:YATW\*(C'\fR treeregexp transformation objects
.ie n .SS "$node\->insert_after($position, $new_child)"
.el .SS "\f(CW$node\fP\->insert_after($position, \f(CW$new_child\fP)"
.IX Subsection "$node->insert_after($position, $new_child)"
Inserts \f(CW$newchild\fR after \f(CW$position\fR in the list of children of \f(CW$node\fR.
Variable \f(CW$position\fR can be an index or a reference.
.PP
The method throws an exception if \f(CW$position\fR is an index and is not
in the range of \f(CW\*(C`$node\-\*(C'\fRchildren>.
.PP
The method throws a warning if \f(CW$position\fR is a reference and does not exists
in the list of children. In such case \f(CW$new_child\fR is not inserted.
.ie n .SS "$node\->translation_scheme"
.el .SS "\f(CW$node\fP\->translation_scheme"
.IX Subsection "$node->translation_scheme"
Traverses \f(CW$node\fR. Each time a \s-1CODE\s0 node is visited the subroutine referenced
is called with arguments the node and its children. Usually the code will decorate
the nodes with new attributes or will update existing ones. Obviously this method
does nothing for an ordinary \s-1AST.\s0 It is used after compiling
an Eyapp program that makes use of the \f(CW%metatree\fR directive. (See
\&\f(CW\*(C`examples/Node/TSPostfix3.eyp\*(C'\fR for an example).
.ie n .SS "$node\->bud(@transformations)"
.el .SS "\f(CW$node\fP\->bud(@transformations)"
.IX Subsection "$node->bud(@transformations)"
Bottom-up decorator. The tree is traversed bottom-up. The set of
transformations in \f(CW@transformations\fR
is applied to each node in the tree referenced by \f(CW$node\fR
in the order
supplied by the user. \fIAs soon as one succeeds
no more transformations are applied\fR.
.PP
For an example  see the files \f(CW\*(C`lib/Simple/Types.eyp\*(C'\fR 
and \f(CW\*(C`lib/Simple/Trans.trg\*(C'\fR in \f(CW\*(C`examples/typechecking/Simple\-Types\-XXX.tar.gz\*(C'\fR
shows an extract of the type-checking phase of a toy-example compiler:
.PP
.Vb 10
\&  examples/typechecking/Simple\-Types\-0.4/lib/Simple$  sed \-ne \*(Aq600,613p\*(Aq Types.eyp
\&   my @typecheck = (     # Check typing transformations for
\&     our $inum,          # \- Numerical constantss
\&     our $charconstant,  # \- Character constants
\&     our $bin,           # \- Binary Operations
\&     our $arrays,        # \- Arrays
\&     our $assign,        # \- Assignments
\&     our $control,       # \- Flow control sentences
\&     our $functioncall,  # \- Function calls
\&     our $statements,    # \- Those nodes with void type
\&                         #   (STATEMENTS, PROGRAM, etc.)
\&     our $returntype,    # \- Return
\&   );
\&
\&   $t\->bud(@typecheck);
.Ve
.PP
You can find another example of use of \f(CW\*(C`bud\*(C'\fR
in the file \f(CW\*(C`examples/ParsingStringsAndTrees/infix2pir.pl\*(C'\fR
.SH "Parse::Eyapp:YATW  Methods"
.IX Header "Parse::Eyapp:YATW Methods"
\&\f(CW\*(C`Parse::Eyapp:YATW\*(C'\fR objects represent tree transformations.
They carry the information of what nodes match and how to modify
them.
.SS "Parse::Eyapp::YATW\->new"
.IX Subsection "Parse::Eyapp::YATW->new"
Builds a treeregexp transformation object.
Though usually you build a transformation by means of Treeregexp programs
you can directly invoke the method to build a tree transformation.
A transformation object can be built from a function 
that conforms to the \s-1YATW\s0 tree transformation call protocol
(see the section \*(L"The \s-1YATW\s0 Tree Transformation Call Protocol\*(R").
Follows an example (file \f(CW\*(C`examples/12ts_simplify_with_s.pl\*(C'\fR):
.PP
.Vb 10
\& nereida:~/src/perl/YappWithDefaultAction/examples> \e
\&        sed \-ne \*(Aq68,$p\*(Aq 12ts_simplify_with_s.pl | cat \-n
\&  1  sub is_code {
\&  2    my $self = shift; # tree
\&  3
\&  4    # After the shift $_[0] is the father, $_[1] the index
\&  5    if ((ref($self) eq \*(AqCODE\*(Aq)) {
\&  6      splice(@{$_[0]\->{children}}, $_[1], 1);
\&  7      return 1;
\&  8    }
\&  9    return 0;
\& 10  }
\& 11
\& 12  Parse::Eyapp\->new_grammar(
\& 13    input=>$translationscheme,
\& 14    classname=>\*(AqCalc\*(Aq,
\& 15    firstline =>7,
\& 16  );
\& 17  my $parser = Calc\->new();                # Create the parser
\& 18
\& 19  $parser\->YYData\->{INPUT} = "2*\-3\en";  print "2*\-3\en"; # Set the input
\& 20  my $t = $parser\->Run;                    # Parse it
\& 21  print $t\->str."\en";
\& 22  my $p = Parse::Eyapp::YATW\->new(PATTERN => \e&is_code);
\& 23  $p\->s($t);
\& 24  { no warnings; # make attr info available only for this display
\& 25    local *TERMINAL::info = sub { $_[0]{attr} };
\& 26    print $t\->str."\en";
\& 27  }
.Ve
.PP
After the \f(CW\*(C`Parse::Eyapp::YATW\*(C'\fR object \f(CW$p\fR is built at line 22
the call to method \f(CW\*(C`$p\->s($t)\*(C'\fR applies  the 
transformation \f(CW\*(C`is_code\*(C'\fR using a bottom-up traversing of the tree \f(CW$t\fR.
The achieved effect is the elimination of \f(CW\*(C`CODE\*(C'\fR references
in the translation scheme tree.
When executed the former code produces:
.PP
.Vb 4
\& nereida:~/src/perl/YappWithDefaultAction/examples> 12ts_simplify_with_s.pl
\& 2*\-3
\& EXP(TIMES(NUM(TERMINAL,CODE),TERMINAL,UMINUS(TERMINAL,NUM(TERMINAL,CODE),CODE),CODE),CODE)
\& EXP(TIMES(NUM(TERMINAL[2]),TERMINAL[*],UMINUS(TERMINAL[\-],NUM(TERMINAL[3]))))
.Ve
.PP
The file \f(CW\*(C`foldrule6.pl\*(C'\fR in the \f(CW\*(C`examples/\*(C'\fR distribution directory
gives you another example:
.PP
.Vb 10
\& nereida:~/src/perl/YappWithDefaultAction/examples> cat \-n foldrule6.pl
\&   1  #!/usr/bin/perl \-w
\&   2  use strict;
\&   3  use Rule6;
\&   4  use Parse::Eyapp::YATW;
\&   5
\&   6  my %BinaryOperation = (PLUS=>\*(Aq+\*(Aq, MINUS => \*(Aq\-\*(Aq, TIMES=>\*(Aq*\*(Aq, DIV => \*(Aq/\*(Aq);
\&   7
\&   8  sub set_terminfo {
\&   9    no warnings;
\&  10    *TERMINAL::info = sub { $_[0]{attr} };
\&  11  }
\&  12  sub is_foldable {
\&  13    my ($op, $left, $right);
\&  14    return 0 unless defined($op = $BinaryOperation{ref($_[0])});
\&  15    return 0 unless ($left = $_[0]\->child(0), $left\->isa(\*(AqNUM\*(Aq));
\&  16    return 0 unless ($right = $_[0]\->child(1), $right\->isa(\*(AqNUM\*(Aq));
\&  17
\&  18    my $leftnum = $left\->child(0)\->{attr};
\&  19    my $rightnum = $right\->child(0)\->{attr};
\&  20    $left\->child(0)\->{attr} = eval "$leftnum $op $rightnum";
\&  21    $_[0] = $left;
\&  22  }
\&  23
\&  24  my $parser = new Rule6();
\&  25  $parser\->YYData\->{INPUT} = "2*3";
\&  26  my $t = $parser\->Run;
\&  27  &set_terminfo;
\&  28  print "\en***** Before ******\en";
\&  29  print $t\->str;
\&  30  my $p = Parse::Eyapp::YATW\->new(PATTERN => \e&is_foldable);
\&  31  $p\->s($t);
\&  32  print "\en***** After ******\en";
\&  33  print $t\->str."\en";
.Ve
.PP
when executed produces:
.PP
.Vb 1
\& nereida:~/src/perl/YappWithDefaultAction/examples> foldrule6.pl
\&
\& ***** Before ******
\& TIMES(NUM(TERMINAL[2]),NUM(TERMINAL[3]))
\& ***** After ******
\& NUM(TERMINAL[6])
.Ve
.SS "The \s-1YATW\s0 Tree Transformation Call Protocol"
.IX Subsection "The YATW Tree Transformation Call Protocol"
For a subroutine  \f(CW\*(C`pattern_sub\*(C'\fR to work as a \s-1YATW\s0 tree transformation
\&\- as subroutines \f(CW\*(C`is_foldable\*(C'\fR and  \f(CW\*(C`is_code\*(C'\fR above \- has to conform to the following
call description:
.PP
.Vb 6
\&  pattern_sub(
\&      $_[0],  # Node being visited
\&      $_[1],  # Father of this node
\&      $index, # Index of this node in @Father\->children
\&      $self,  # The YATW pattern object
\&  );
.Ve
.PP
The \f(CW\*(C`pattern_sub\*(C'\fR must return \s-1TRUE\s0 if matched 
and \s-1FALSE\s0 otherwise.
.PP
The protocol may change in the near future. 
Avoid using other information than the fact that 
the first argument 
is the node being visited.
.SS "Parse::Eyapp::YATW\->buildpatterns"
.IX Subsection "Parse::Eyapp::YATW->buildpatterns"
Works as \f(CW\*(C`Parse::Eyapp\->new\*(C'\fR but receives an array of subs 
conforming to the \s-1YATW\s0 Tree Transformation Call Protocol.
.PP
.Vb 1
\&  our @all = Parse::Eyapp::YATW\->buildpatt(\e&delete_code, \e&delete_tokens);
.Ve
.ie n .SS "$yatw\->delete"
.el .SS "\f(CW$yatw\fP\->delete"
.IX Subsection "$yatw->delete"
The root of the tree that is currently matched 
by the \s-1YATW\s0 transformation \f(CW$yatw\fR will be deleted from 
the tree as soon as is safe. That usually means 
when the processing of their siblings
is finished. The following
example (taken from file \f(CW\*(C`examples/13ts_simplify_with_delete.pl\*(C'\fR in 
the Parse::Eyapp distribution) 
illustrates how to eliminate \s-1CODE\s0 and syntactic terminals from the 
syntax tree:
.PP
.Vb 10
\& pl@nereida:~/src/perl/YappWithDefaultAction/examples$ \e
\&        sed \-ne \*(Aq62,$p\*(Aq 13ts_simplify_with_delete.pl | cat \-n
\&  1  sub not_useful {
\&  2    my $self = shift; # node
\&  3    my $pat = $_[2];  # get the YATW object
\&  4
\&  5    (ref($self) eq \*(AqCODE\*(Aq) or ((ref($self) eq \*(AqTERMINAL\*(Aq) and ($self\->{token} eq $self\->{attr}))
\&  6      or do { return 0 };
\&  7    $pat\->delete();
\&  8    return 1;
\&  9  }
\& 10
\& 11  Parse::Eyapp\->new_grammar(
\& 12    input=>$translationscheme,
\& 13    classname=>\*(AqCalc\*(Aq,
\& 14    firstline =>7,
\& 15  );
\& 16  my $parser = Calc\->new();                # Create the parser
\& 17
\& 18  $parser\->YYData\->{INPUT} = "2*3\en"; print $parser\->YYData\->{INPUT};
\& 19  my $t = $parser\->Run;                    # Parse it
\& 20  print $t\->str."\en";                      # Show the tree
\& 21  my $p = Parse::Eyapp::YATW\->new(PATTERN => \e&not_useful); 
\& 22  $p\->s($t);                               # Delete nodes
\& 23  print $t\->str."\en";                      # Show the tree
.Ve
.PP
when executed we get the following output:
.PP
.Vb 4
\& pl@nereida:~/src/perl/YappWithDefaultAction/examples$ 13ts_simplify_with_delete.pl
\& 2*3
\& EXP(TIMES(NUM(TERMINAL[2],CODE),TERMINAL[*],NUM(TERMINAL[3],CODE),CODE))
\& EXP(TIMES(NUM(TERMINAL[2]),NUM(TERMINAL[3])))
.Ve
.ie n .SS "$yatw\->unshift"
.el .SS "\f(CW$yatw\fP\->unshift"
.IX Subsection "$yatw->unshift"
The call \f(CW\*(C`$yatw\->unshift($b)\*(C'\fR 
safely unshifts (inserts at the beginning)
the node \f(CW$b\fR in the list of its 
siblings of the node that matched (i.e in the list of siblings of \f(CW$_[0]\fR). 
The following example
shows a \s-1YATW\s0 transformation
\&\f(CW\*(C`insert_child\*(C'\fR that illustrates the use of \f(CW\*(C`unshift\*(C'\fR (file \f(CW\*(C`examples/26delete_with_trreereg.pl\*(C'\fR):
.PP
.Vb 10
\& pl@nereida:~/src/perl/YappWithDefaultAction/examples$ \e
\&         sed \-ne \*(Aq70,$p\*(Aq 26delete_with_trreereg.pl | cat \-n
\&  1  my $transform = Parse::Eyapp::Treeregexp\->new( STRING => q{
\&  2
\&  3      delete_code : CODE => { $delete_code\->delete() }
\&  4
\&  5      {
\&  6        sub not_semantic {
\&  7          my $self = shift;
\&  8          return  1 if ((ref($self) eq \*(AqTERMINAL\*(Aq) and ($self\->{token} eq $self\->{attr}));
\&  9          return 0;
\& 10        }
\& 11      }
\& 12
\& 13      delete_tokens : TERMINAL and { not_semantic($TERMINAL) } => {
\& 14        $delete_tokens\->delete();
\& 15      }
\& 16
\& 17      insert_child : TIMES(NUM(TERMINAL), NUM(TERMINAL)) => {
\& 18        my $b = Parse::Eyapp::Node\->new( \*(AqUMINUS(TERMINAL)\*(Aq,
\& 19          sub { $_[1]\->{attr} = \*(Aq4.5\*(Aq }); # The new node will be a sibling of TIMES
\& 20
\& 21        $insert_child\->unshift($b); 
\& 22      }
\& 23    },
\& 24  )\->generate();
\& 25
\& 26  Parse::Eyapp\->new_grammar(
\& 27    input=>$translationscheme,
\& 28    classname=>\*(AqCalc\*(Aq,
\& 29    firstline =>7,
\& 30  );
\& 31  my $parser = Calc\->new();                # Create the parser
\& 32
\& 33  $parser\->YYData\->{INPUT} = "2*3\en"; print $parser\->YYData\->{INPUT}; # Set the input
\& 34  my $t = $parser\->Run;                # Parse it
\& 35  print $t\->str."\en";                        # Show the tree
\& 36  # Get the AST
\& 37  our ($delete_tokens, $delete_code);
\& 38  $t\->s($delete_tokens, $delete_code);
\& 39  print $t\->str."\en";                        # Show the tree
\& 40  our $insert_child;
\& 41  $insert_child\->s($t);
\& 42  print $t\->str."\en";                        # Show the tree
.Ve
.PP
When is executed the program produces the following output:
.PP
.Vb 5
\& pl@nereida:~/src/perl/YappWithDefaultAction/examples$ 26delete_with_trreereg.pl
\& 2*3
\& EXP(TIMES(NUM(TERMINAL[2],CODE),TERMINAL[*],NUM(TERMINAL[3],CODE),CODE))
\& EXP(TIMES(NUM(TERMINAL[2]),NUM(TERMINAL[3])))
\& EXP(UMINUS(TERMINAL[4.5]),TIMES(NUM(TERMINAL[2]),NUM(TERMINAL[3])))
.Ve
.PP
Don't try to take advantage that the transformation sub receives
in \f(CW$_[1]\fR a reference to the father 
(see the section \*(L"The \s-1YATW\s0 Tree Transformation Call Protocol\*(R") 
and do something like:
.PP
.Vb 1
\&  unshift $_[1]\->{children}, $b
.Ve
.PP
it is unsafe.
.ie n .SS "$yatw\->insert_before"
.el .SS "\f(CW$yatw\fP\->insert_before"
.IX Subsection "$yatw->insert_before"
A call to \f(CW\*(C`$yatw\->insert_before($node)\*(C'\fR safely inserts 
\&\f(CW$node\fR in the list of siblings of \f(CW$_[0]\fR
just before \f(CW$_[0]\fR (i.e. the node that matched with \f(CW$yatw\fR).
The following example (see
file \f(CW\*(C`examples/YATW/moveinvariantoutofloopcomplexformula.pl\*(C'\fR)
illustrates its use:
.PP
.Vb 9
\&  my $p = Parse::Eyapp::Treeregexp\->new( STRING => q{
\&    moveinvariant: WHILE(VAR($b), BLOCK(@a, ASSIGN($x, $e), @c)) 
\&         and { is_invariant($ASSIGN, $WHILE) } => {
\&           my $assign = $ASSIGN;
\&           $BLOCK\->delete($ASSIGN);
\&           $moveinvariant\->insert_before($assign);
\&         }
\&    },
\&  );
.Ve
.PP
Here the \f(CW\*(C`ASSIGN($x, $e)\*(C'\fR subtree \- if is loop invariant \- 
will be moved
to the list of siblings of \f(CW$WHILE\fR
just before the \f(CW$WHILE\fR.
Thus a program like
.PP
.Vb 1
\&  "a =1000; c = 1; while (a) { c = c*a; b = 5; a = a\-1 }\en"
.Ve
.PP
is transformed in s.t. like:
.PP
.Vb 1
\&  "a =1000; c = 1; b = 5; while (a) { c = c*a; a = a\-1 }\en"
.Ve
.SH "TREE MATCHING AND TREE SUBSTITUTION"
.IX Header "TREE MATCHING AND TREE SUBSTITUTION"
See the documentation in Parse::Eyapp::treematchingtut
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.IP "\(bu" 4
The project home is at <http://code.google.com/p/parse\-eyapp/>.
Use a subversion client to anonymously check out the latest project source code:
.Sp
.Vb 1
\&   svn checkout http://parse\-eyapp.googlecode.com/svn/trunk/ parse\-eyapp\-read\-only
.Ve
.IP "\(bu" 4
The tutorial \fIParsing Strings and Trees with\fR \f(CW\*(C`Parse::Eyapp\*(C'\fR
(An Introduction to Compiler Construction in seven pages) in
<http://nereida.deioc.ull.es/~pl/eyapsimple/>
.IP "\(bu" 4
Parse::Eyapp, 
Parse::Eyapp::eyapplanguageref, 
Parse::Eyapp::debuggingtut,
Parse::Eyapp::defaultactionsintro,
Parse::Eyapp::translationschemestut,
Parse::Eyapp::Driver,
Parse::Eyapp::Node,
Parse::Eyapp::YATW,
Parse::Eyapp::Treeregexp,
Parse::Eyapp::Scope,
Parse::Eyapp::Base,
Parse::Eyapp::datagenerationtut
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/languageintro.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/debuggingtut.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/eyapplanguageref.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/Treeregexp.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/Node.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/YATW.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/Eyapp.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/Base.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/translationschemestut.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/treematchingtut.pdf>
.IP "\(bu" 4
perldoc eyapp,
.IP "\(bu" 4
perldoc treereg,
.IP "\(bu" 4
perldoc vgg,
.IP "\(bu" 4
The Syntax Highlight file for vim at <http://www.vim.org/scripts/script.php?script_id=2453>
and <http://nereida.deioc.ull.es/~vim/>
.IP "\(bu" 4
\&\fIAnalisis Lexico y Sintactico\fR, (Notes for a course in compiler 
construction) by  Casiano Rodriguez-Leon. 
Available at  <http://nereida.deioc.ull.es/~pl/perlexamples/>
Is the more complete and reliable source for Parse::Eyapp. However is in Spanish.
.IP "\(bu" 4
Parse::Yapp,
.IP "\(bu" 4
Man pages of \fIyacc\fR\|(1) and
\&\fIbison\fR\|(1),
<http://www.delorie.com/gnu/docs/bison/bison.html>
.IP "\(bu" 4
Language::AttributeGrammar
.IP "\(bu" 4
Parse::RecDescent.
.IP "\(bu" 4
HOP::Parser
.IP "\(bu" 4
HOP::Lexer
.IP "\(bu" 4
ocamlyacc tutorial at 
<http://plus.kaist.ac.kr/~shoh/ocaml/ocamllex\-ocamlyacc/ocamlyacc\-tutorial/ocamlyacc\-tutorial.html>
.SH "REFERENCES"
.IX Header "REFERENCES"
.IP "\(bu" 4
The classic Dragon's book \fICompilers: Principles, Techniques, and Tools\fR 
by Alfred V. Aho, Ravi Sethi and
Jeffrey D. Ullman (Addison-Wesley 1986)
.IP "\(bu" 4
\&\fI\s-1CS2121:\s0 The Implementation and Power of Programming Languages\fR
(See <http://www.cs.man.ac.uk/~pjj>, <http://www.cs.man.ac.uk/~pjj/complang/g2lr.html> 
and <http://www.cs.man.ac.uk/~pjj/cs2121/ho/ho.html>) by 
Pete Jinks
.SH "CONTRIBUTORS"
.IX Header "CONTRIBUTORS"
.IP "\(bu" 2
Hal Finkel <http://www.halssoftware.com/>
.IP "\(bu" 2
G. Williams <http://kasei.us/>
.IP "\(bu" 2
Thomas L. Shinnick <http://search.cpan.org/~tshinnic/>
.IP "\(bu" 2
Frank Leray
.SH "AUTHOR"
.IX Header "AUTHOR"
Casiano Rodriguez-Leon (casiano@ull.es)
.SH "ACKNOWLEDGMENTS"
.IX Header "ACKNOWLEDGMENTS"
This work has been supported by \s-1CEE \s0(\s-1FEDER\s0) and the Spanish Ministry of
\&\fIEducacion y Ciencia\fR through \fIPlan Nacional I+D+I\fR number \s-1TIN2005\-08818\-C04\-04
\&\s0(\s-1ULL::OPLINK\s0 project <http://www.oplink.ull.es/>). 
Support from Gobierno de Canarias was through \s-1GC02210601
\&\s0(\fIGrupos Consolidados\fR).
The University of La Laguna has also supported my work in many ways
and for many years.
.PP
A large percentage of  code is verbatim taken from Parse::Yapp 1.05.
The author of Parse::Yapp is Francois Desarmenien.
.PP
I wish to thank Francois Desarmenien for his Parse::Yapp module, 
to my students at La Laguna and to the Perl Community. Thanks to 
the people who have contributed to improve the module (see \*(L"\s-1CONTRIBUTORS\*(R"\s0 in Parse::Eyapp).
Thanks to Larry Wall for giving us Perl.
Special thanks to Juana.
.SH "LICENCE AND COPYRIGHT"
.IX Header "LICENCE AND COPYRIGHT"
Copyright (c) 2006\-2008 Casiano Rodriguez-Leon (casiano@ull.es). All rights reserved.
.PP
Parse::Yapp copyright is of Francois Desarmenien, all rights reserved. 1998\-2001
.PP
These modules are free software; you can redistribute it and/or
modify it under the same terms as Perl itself. See perlartistic.
.PP
This program is distributed in the hope that it will be useful,
but \s-1WITHOUT ANY WARRANTY\s0; without even the implied warranty of
\&\s-1MERCHANTABILITY\s0 or \s-1FITNESS FOR A PARTICULAR PURPOSE. \s0
