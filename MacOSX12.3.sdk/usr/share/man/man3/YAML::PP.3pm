.\" Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "YAML::PP 3"
.TH YAML::PP 3 "2020-09-10" "perl v5.30.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
YAML::PP \- YAML 1.2 processor
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
\&\s-1WARNING:\s0 Most of the inner \s-1API\s0 is not stable yet.
.PP
Here are a few examples of the basic load and dump methods:
.PP
.Vb 2
\&    use YAML::PP;
\&    my $ypp = YAML::PP\->new;
\&
\&    my $yaml = <<\*(AqEOM\*(Aq;
\&    \-\-\- # Document one is a mapping
\&    name: Tina
\&    age: 29
\&    favourite language: Perl
\&
\&    \-\-\- # Document two is a sequence
\&    \- plain string
\&    \- \*(Aqin single quotes\*(Aq
\&    \- "in double quotes we have escapes! like \et and \en"
\&    \- | # a literal block scalar
\&      line1
\&      line2
\&    \- > # a folded block scalar
\&      this is all one
\&      single line because the
\&      linebreaks will be folded
\&    EOM
\&
\&    my @documents = $ypp\->load_string($yaml);
\&    my @documents = $ypp\->load_file($filename);
\&
\&    my $yaml = $ypp\->dump_string($data1, $data2);
\&    $ypp\->dump_file($filename, $data1, $data2);
\&
\&    # The loader offers JSON::PP::Boolean, boolean.pm or
\&    # perl 1/\*(Aq\*(Aq (currently default) for booleans
\&    my $ypp = YAML::PP\->new(boolean => \*(AqJSON::PP\*(Aq);
\&    my $ypp = YAML::PP\->new(boolean => \*(Aqboolean\*(Aq);
\&    my $ypp = YAML::PP\->new(boolean => \*(Aqperl\*(Aq);
\&
\&    # Enable perl data types and objects
\&    my $ypp = YAML::PP\->new(schema => [qw/ + Perl /]);
\&    my $yaml = $yp\->dump_string($data_with_perl_objects);
\&
\&    # Legacy interface
\&    use YAML::PP qw/ Load Dump LoadFile DumpFile /;
\&    my @documents = Load($yaml);
\&    my @documents = LoadFile($filename);
\&    my @documents = LoadFile($filehandle);
\&    my $yaml = = Dump(@documents);
\&    DumpFile($filename, @documents);
\&    DumpFile($filenhandle @documents);
.Ve
.PP
Some utility scripts, mostly useful for debugging:
.PP
.Vb 2
\&    # Load YAML into a data structure and dump with Data::Dumper
\&    yamlpp\-load < file.yaml
\&
\&    # Load and Dump
\&    yamlpp\-load\-dump < file.yaml
\&
\&    # Print the events from the parser in yaml\-test\-suite format
\&    yamlpp\-events < file.yaml
\&
\&    # Parse and emit events directly without loading
\&    yamlpp\-parse\-emit < file.yaml
\&
\&    # Create ANSI colored YAML. Can also be useful for invalid YAML, showing
\&    # you the exact location of the error
\&    yamlpp\-highlight < file.yaml
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\s-1YAML::PP\s0 is a modular \s-1YAML\s0 processor.
.PP
It aims to support \f(CW\*(C`YAML 1.2\*(C'\fR and \f(CW\*(C`YAML 1.1\*(C'\fR. See <https://yaml.org/>.
Some (rare) syntax elements are not yet supported and documented below.
.PP
\&\s-1YAML\s0 is a serialization language. The \s-1YAML\s0 input is called \*(L"\s-1YAML\s0 Stream\*(R".
A stream consists of one or more \*(L"Documents\*(R", separated by a line with a
document start marker \f(CW\*(C`\-\-\-\*(C'\fR. A document optionally ends with the document
end marker \f(CW\*(C`...\*(C'\fR.
.PP
This allows one to process continuous streams additionally to a fixed input
file or string.
.PP
The \s-1YAML::PP\s0 frontend will currently load all documents, and return only
the first if called with scalar context.
.PP
The \s-1YAML\s0 backend is implemented in a modular way that allows one to add
custom handling of \s-1YAML\s0 tags, perl objects and data types. The inner \s-1API\s0
is not yet stable. Suggestions welcome.
.PP
You can check out all current parse and load results from the
yaml-test-suite here:
<https://perlpunk.github.io/YAML\-PP\-p5/test\-suite.html>
.SH "METHODS"
.IX Header "METHODS"
.SS "new"
.IX Subsection "new"
.Vb 5
\&    my $ypp = YAML::PP\->new;
\&    # load booleans via boolean.pm
\&    my $ypp = YAML::PP\->new( boolean => \*(Aqboolean\*(Aq );
\&    # load booleans via JSON::PP::true/false
\&    my $ypp = YAML::PP\->new( boolean => \*(AqJSON::PP\*(Aq );
\&    
\&    # use YAML 1.2 Failsafe Schema
\&    my $ypp = YAML::PP\->new( schema => [\*(AqFailsafe\*(Aq] );
\&    # use YAML 1.2 JSON Schema
\&    my $ypp = YAML::PP\->new( schema => [\*(AqJSON\*(Aq] );
\&    # use YAML 1.2 Core Schema
\&    my $ypp = YAML::PP\->new( schema => [\*(AqCore\*(Aq] );
\&    
\&    # Die when detecting cyclic references
\&    my $ypp = YAML::PP\->new( cyclic_refs => \*(Aqfatal\*(Aq );
\&    
\&    my $ypp = YAML::PP\->new(
\&        boolean => \*(AqJSON::PP\*(Aq,
\&        schema => [\*(AqCore\*(Aq],
\&        cyclic_refs => \*(Aqfatal\*(Aq,
\&        indent => 4,
\&        header => 1,
\&        footer => 1,
\&        version_directive => 1,
\&    );
.Ve
.PP
Options:
.IP "boolean" 4
.IX Item "boolean"
Values: \f(CW\*(C`perl\*(C'\fR (currently default), \f(CW\*(C`JSON::PP\*(C'\fR, \f(CW\*(C`boolean\*(C'\fR
.Sp
This option is for loading and dumping.
.Sp
Note that when dumping, only the chosen boolean style will be recognized.
So if you choose \f(CW\*(C`JSON::PP\*(C'\fR, \f(CW\*(C`boolean\*(C'\fR objects will not be recognized
as booleans and will be dumped as ordinary objects (if you enable the
Perl schema).
.IP "schema" 4
.IX Item "schema"
Default: \f(CW\*(C`[\*(AqCore\*(Aq]\*(C'\fR
.Sp
This option is for loading and dumping.
.Sp
Array reference. Here you can define what schema to use.
Supported standard Schemas are: \f(CW\*(C`Failsafe\*(C'\fR, \f(CW\*(C`JSON\*(C'\fR, \f(CW\*(C`Core\*(C'\fR, \f(CW\*(C`YAML1_1\*(C'\fR.
.Sp
To get an overview how the different Schemas behave, see
<https://perlpunk.github.io/YAML\-PP\-p5/schemas.html>
.Sp
Additionally you can add further schemas, for example \f(CW\*(C`Merge\*(C'\fR.
.IP "cyclic_refs" 4
.IX Item "cyclic_refs"
Default: 'allow' but will be switched to fatal in the future for safety!
.Sp
This option is for loading only.
.Sp
Defines what to do when a cyclic reference is detected when loading.
.Sp
.Vb 4
\&    # fatal  \- die
\&    # warn   \- Just warn about them and replace with undef
\&    # ignore \- replace with undef
\&    # allow  \- Default
.Ve
.IP "duplicate_keys" 4
.IX Item "duplicate_keys"
Default: 1
.Sp
Since version 0.026
.Sp
This option is for loading.
.Sp
\&\s-1NOTE: THIS OPTION WILL BE SET TO 0 IN THE NEXT RELEASE.\s0
.Sp
The \s-1YAML\s0 Spec says duplicate mapping keys should be forbidden.
.Sp
When set to true, duplicate keys in mappings are allowed (and will overwrite
the previous key).
.Sp
When set to false, duplicate keys will result in an error when loading.
.Sp
This is especially useful when you have a longer mapping and don't see
the duplicate key in your editor:
.Sp
.Vb 5
\&    \-\-\-
\&    a: 1
\&    b: 2
\&    # .............
\&    a: 23 # error
.Ve
.IP "indent" 4
.IX Item "indent"
Default: 2
.Sp
This option is for dumping.
.Sp
Use that many spaces for indenting
.IP "width" 4
.IX Item "width"
Since version 0.025
.Sp
Default: 80
.Sp
This option is for dumping.
.Sp
Maximum columns when dumping.
.Sp
This is only respected when dumping flow collections right now.
.Sp
in the future it will be used also for wrapping long strings.
.IP "header" 4
.IX Item "header"
Default: 1
.Sp
This option is for dumping.
.Sp
Print document heaader \f(CW\*(C`\-\-\-\*(C'\fR
.IP "footer" 4
.IX Item "footer"
Default: 0
.Sp
This option is for dumping.
.Sp
Print document footer \f(CW\*(C`...\*(C'\fR
.IP "yaml_version" 4
.IX Item "yaml_version"
Since version 0.020
.Sp
This option is for loading and dumping.
.Sp
Default: \f(CW1.2\fR
.Sp
Note that in this case, a directive \f(CW\*(C`%YAML 1.1\*(C'\fR will basically be ignored
and everything loaded with the \f(CW\*(C`1.2 Core\*(C'\fR Schema.
.Sp
If you want to support both \s-1YAML 1.1\s0 and 1.2, you have to specify that, and the
schema (\f(CW\*(C`Core\*(C'\fR or \f(CW\*(C`YAML1_1\*(C'\fR) will be chosen automatically.
.Sp
.Vb 3
\&    my $yp = YAML::PP\->new(
\&        yaml_version => [\*(Aq1.2\*(Aq, \*(Aq1.1\*(Aq],
\&    );
.Ve
.Sp
This is the same as
.Sp
.Vb 4
\&    my $yp = YAML::PP\->new(
\&        schema => [\*(Aq+\*(Aq],
\&        yaml_version => [\*(Aq1.2\*(Aq, \*(Aq1.1\*(Aq],
\&    );
.Ve
.Sp
because the \f(CW\*(C`+\*(C'\fR stands for the default schema per version.
.Sp
When loading, and there is no \f(CW%YAML\fR directive, \f(CW1.2\fR will be considered
as default, and the \f(CW\*(C`Core\*(C'\fR schema will be used.
.Sp
If there is a \f(CW\*(C`%YAML 1.1\*(C'\fR directive, the \f(CW\*(C`YAML1_1\*(C'\fR schema will be used.
.Sp
Of course, you can also make \f(CW1.1\fR the default:
.Sp
.Vb 3
\&    my $yp = YAML::PP\->new(
\&        yaml_version => [\*(Aq1.1\*(Aq, \*(Aq1.2\*(Aq],
\&    );
.Ve
.Sp
You can also specify \f(CW1.1\fR only:
.Sp
.Vb 3
\&    my $yp = YAML::PP\->new(
\&        yaml_version => [\*(Aq1.1\*(Aq],
\&    );
.Ve
.Sp
In this case also documents with \f(CW\*(C`%YAML 1.2\*(C'\fR will be loaded with the \f(CW\*(C`YAML1_1\*(C'\fR
schema.
.IP "version_directive" 4
.IX Item "version_directive"
Since version 0.020
.Sp
This option is for dumping.
.Sp
Default: 0
.Sp
Print Version Directive \f(CW\*(C`%YAML 1.2\*(C'\fR (or \f(CW\*(C`%YAML 1.1\*(C'\fR) on top of each \s-1YAML\s0
document. It will use the first version specified in the \f(CW\*(C`yaml_version\*(C'\fR option.
.IP "preserve" 4
.IX Item "preserve"
Since version 0.021
.Sp
Default: false
.Sp
This option is for loading and dumping.
.Sp
Preserving scalar styles is still experimental.
.Sp
.Vb 1
\&    use YAML::PP::Common qw/ PRESERVE_ORDER PRESERVE_SCALAR_STYLE /;
\&
\&    # Preserve the order of hash keys
\&    my $yp = YAML::PP\->new( preserve => PRESERVE_ORDER );
\&
\&    # Preserve the quoting style of scalars
\&    my $yp = YAML::PP\->new( preserve => PRESERVE_SCALAR_STYLE );
\&
\&    # Preserve block/flow style (since 0.024)
\&    my $yp = YAML::PP\->new( preserve => PRESERVE_FLOW_STYLE );
\&
\&    # Combine, e.g. preserve order and scalar style
\&    my $yp = YAML::PP\->new( preserve => PRESERVE_ORDER | PRESERVE_SCALAR_STYLE );
.Ve
.Sp
Do \s-1NOT\s0 rely on the internal implementation of it.
.Sp
If you load the following input:
.Sp
.Vb 10
\&    \-\-\-
\&    z: 1
\&    a: 2
\&    \-\-\-
\&    \- plain
\&    \- \*(Aqsingle\*(Aq
\&    \- "double"
\&    \- |
\&      literal
\&    \-\-\-
\&    block mapping:
\&      flow sequence: [a, b]
\&    flow mapping: {a: b}
.Ve
.Sp
with this code:
.Sp
.Vb 5
\&    my $yp = YAML::PP\->new(
\&        preserve => PRESERVE_ORDER | PRESERVE_SCALAR_STYLE | PRESERVE_FLOW_STYLE
\&    );
\&    my ($hash, $styles, $flow) = $yp\->load_file($file);
\&    $yp\->dump_file($hash, $styles, $flow);
.Ve
.Sp
Then dumping it will return the same output.
Only folded block scalars '>' cannot preserve the style yet.
.Sp
When loading, hashes will be tied to an internal class
(\f(CW\*(C`YAML::PP::Preserve::Hash\*(C'\fR) that keeps the key order.
.Sp
Scalars will be returned as objects of an internal class
(\f(CW\*(C`YAML::PP::Preserve::Scalar\*(C'\fR) with overloading. If you assign to such
a scalar, the object will be replaced by a simple scalar.
.Sp
.Vb 2
\&    # assignment, style gets lost
\&    $styles\->[1] .= \*(Aq append\*(Aq;
.Ve
.Sp
You can also pass \f(CW1\fR as a value. In this case all preserving options will be
enabled, also if there are new options added in the future.
.Sp
There are also methods to craete preserved nodes from scratch. See the
\&\f(CW\*(C`preserved_(scalar|mapping|sequence\*(C'\fR \*(L"\s-1METHODS\*(R"\s0 below.
.SS "load_string"
.IX Subsection "load_string"
.Vb 2
\&    my $doc = $ypp\->load_string("foo: bar");
\&    my @docs = $ypp\->load_string("foo: bar\en\-\-\-\en\- a");
.Ve
.PP
Input should be Unicode characters.
.PP
So if you read from a file, you should decode it, for example with
\&\f(CW\*(C`Encode::decode()\*(C'\fR.
.PP
Note that in scalar context, \f(CW\*(C`load_string\*(C'\fR and \f(CW\*(C`load_file\*(C'\fR return the first
document (like YAML::Syck), while \s-1YAML\s0 and \s-1YAML::XS\s0 return the
last.
.SS "load_file"
.IX Subsection "load_file"
.Vb 2
\&    my $doc = $ypp\->load_file("file.yaml");
\&    my @docs = $ypp\->load_file("file.yaml");
.Ve
.PP
Strings will be loaded as unicode characters.
.SS "dump_string"
.IX Subsection "dump_string"
.Vb 3
\&    my $yaml = $ypp\->dump_string($doc);
\&    my $yaml = $ypp\->dump_string($doc1, $doc2);
\&    my $yaml = $ypp\->dump_string(@docs);
.Ve
.PP
Input strings should be Unicode characters.
.PP
Output will return Unicode characters.
.PP
So if you want to write that to a file (or pass to \s-1YAML::XS,\s0 for example),
you typically encode it via \f(CW\*(C`Encode::encode()\*(C'\fR.
.SS "dump_file"
.IX Subsection "dump_file"
.Vb 3
\&    $ypp\->dump_file("file.yaml", $doc);
\&    $ypp\->dump_file("file.yaml", $doc1, $doc2);
\&    $ypp\->dump_file("file.yaml", @docs);
.Ve
.PP
Input data should be Unicode characters.
.SS "dump"
.IX Subsection "dump"
This will dump to a predefined writer. By default it will just use the
YAML::PP::Writer and output a string.
.PP
.Vb 5
\&    my $writer = MyWriter\->new(\emy $output);
\&    my $yp = YAML::PP\->new(
\&        writer => $writer,
\&    );
\&    $yp\->dump($data);
.Ve
.SS "preserved_scalar"
.IX Subsection "preserved_scalar"
Since version 0.024
.PP
Experimental. Please report bugs or let me know this is useful and works.
.PP
You can define a certain scalar style when dumping data.
Figuring out the best style is a hard task and practically impossible to get
it right for all cases. It's also a matter of taste.
.PP
.Vb 6
\&    use YAML::PP::Common qw/ PRESERVE_SCALAR_STYLE /;
\&    my $yp = YAML::PP\->new(
\&        preserve => PRESERVE_SCALAR_STYLE,
\&    );
\&    # a single linebreak would normally be dumped with double quotes: "\en"
\&    my $scalar = $yp\->preserved_scalar("\en", style => YAML_LITERAL_SCALAR_STYLE );
\&
\&    my $data = { literal => $scalar };
\&    my $dump = $yp\->dump_string($data);
\&    # output
\&    \-\-\-
\&    literal: |+
\&
\&    ...
.Ve
.SS "preserved_mapping, preserved_sequence"
.IX Subsection "preserved_mapping, preserved_sequence"
Since version 0.024
.PP
Experimental. Please report bugs or let me know this is useful and works.
.PP
With this you can define which nodes are dumped with the more compact flow
style instead of block style.
.PP
If you add \f(CW\*(C`PRESERVE_ORDER\*(C'\fR to the \f(CW\*(C`preserve\*(C'\fR option, it will also keep the
order of the keys in a hash.
.PP
.Vb 4
\&    use YAML::PP::Common qw/ PRESERVE_ORDER PRESERVE_FLOW_STYLE /;
\&    my $yp = YAML::PP\->new(
\&        preserve => PRESERVE_FLOW_STYLE | PRESERVE_ORDER
\&    );
\&
\&    my $hash = $yp\->preserved_mapping({}, style => YAML_FLOW_MAPPING_STYLE);
\&    # Add values after initialization to preserve order
\&    %$hash = (z => 1, a => 2, y => 3, b => 4);
\&
\&    my $array = $yp\->preserved_sequence([23, 24], style => YAML_FLOW_SEQUENCE_STYLE);
\&
\&    my $data = $yp\->preserved_mapping({});
\&    %$data = ( map => $hash, seq => $array );
\&
\&    my $dump = $yp\->dump_string($data);
\&    # output
\&    \-\-\-
\&    map: {z: 1, a: 2, y: 3, b: 4}
\&    seq: [23, 24]
.Ve
.SS "loader"
.IX Subsection "loader"
Returns or sets the loader object, by default YAML::PP::Loader
.SS "dumper"
.IX Subsection "dumper"
Returns or sets the dumper object, by default YAML::PP::Dumper
.SS "schema"
.IX Subsection "schema"
Returns or sets the schema object
.SS "default_schema"
.IX Subsection "default_schema"
Creates and returns the default schema
.SH "FUNCTIONS"
.IX Header "FUNCTIONS"
The functions \f(CW\*(C`Load\*(C'\fR, \f(CW\*(C`LoadFile\*(C'\fR, \f(CW\*(C`Dump\*(C'\fR and \f(CW\*(C`DumpFile\*(C'\fR are provided
as a drop-in replacement for other existing \s-1YAML\s0 processors.
No function is exported by default.
.PP
Note that in scalar context, \f(CW\*(C`Load\*(C'\fR and \f(CW\*(C`LoadFile\*(C'\fR return the first
document (like YAML::Syck), while \s-1YAML\s0 and \s-1YAML::XS\s0 return the
last.
.IP "Load" 4
.IX Item "Load"
.Vb 3
\&    use YAML::PP qw/ Load /;
\&    my $doc = Load($yaml);
\&    my @docs = Load($yaml);
.Ve
.Sp
Works like \f(CW\*(C`load_string\*(C'\fR.
.IP "LoadFile" 4
.IX Item "LoadFile"
.Vb 4
\&    use YAML::PP qw/ LoadFile /;
\&    my $doc = LoadFile($file);
\&    my @docs = LoadFile($file);
\&    my @docs = LoadFile($filehandle);
.Ve
.Sp
Works like \f(CW\*(C`load_file\*(C'\fR.
.IP "Dump" 4
.IX Item "Dump"
.Vb 3
\&    use YAML::PP qw/ Dump /;
\&    my $yaml = Dump($doc);
\&    my $yaml = Dump(@docs);
.Ve
.Sp
Works like \f(CW\*(C`dump_string\*(C'\fR.
.IP "DumpFile" 4
.IX Item "DumpFile"
.Vb 4
\&    use YAML::PP qw/ DumpFile /;
\&    DumpFile($file, $doc);
\&    DumpFile($file, @docs);
\&    DumpFile($filehandle, @docs);
.Ve
.Sp
Works like \f(CW\*(C`dump_file\*(C'\fR.
.SH "PLUGINS"
.IX Header "PLUGINS"
You can alter the behaviour of \s-1YAML::PP\s0 by using the following schema
classes:
.IP "YAML::PP::Schema::Failsafe" 4
.IX Item "YAML::PP::Schema::Failsafe"
One of the three \s-1YAML 1.2\s0 official schemas
.IP "YAML::PP::Schema::JSON" 4
.IX Item "YAML::PP::Schema::JSON"
One of the three \s-1YAML 1.2\s0 official schemas.
.IP "YAML::PP::Schema::Core" 4
.IX Item "YAML::PP::Schema::Core"
One of the three \s-1YAML 1.2\s0 official schemas. Default
.IP "YAML::PP::Schema::YAML1_1" 4
.IX Item "YAML::PP::Schema::YAML1_1"
Schema implementing the most common \s-1YAML 1.1\s0 types
.IP "YAML::PP::Schema::Perl" 4
.IX Item "YAML::PP::Schema::Perl"
Serializing Perl objects and types
.IP "YAML::PP::Schema::Binary" 4
.IX Item "YAML::PP::Schema::Binary"
Serializing binary data
.IP "YAML::PP::Schema::Tie::IxHash" 4
.IX Item "YAML::PP::Schema::Tie::IxHash"
Deprecated. See option \f(CW\*(C`preserve\*(C'\fR
.IP "YAML::PP::Schema::Merge" 4
.IX Item "YAML::PP::Schema::Merge"
\&\s-1YAML 1.1\s0 merge keys for mappings
.IP "YAML::PP::Schema::Include" 4
.IX Item "YAML::PP::Schema::Include"
Include other \s-1YAML\s0 files via \f(CW\*(C`!include\*(C'\fR tags
.PP
To make the parsing process faster, you can plugin the libyaml parser
with YAML::PP::LibYAML.
.SH "IMPLEMENTATION"
.IX Header "IMPLEMENTATION"
The process of loading and dumping is split into the following steps:
.PP
.Vb 1
\&    Load:
\&
\&    YAML Stream        Tokens        Event List        Data Structure
\&              \-\-\-\-\-\-\-\-\->    \-\-\-\-\-\-\-\-\->        \-\-\-\-\-\-\-\-\->
\&                lex           parse           construct
\&
\&
\&    Dump:
\&
\&    Data Structure       Event List        YAML Stream
\&                \-\-\-\-\-\-\-\-\->        \-\-\-\-\-\-\-\-\->
\&                represent           emit
.Ve
.PP
You can dump basic perl types like hashes, arrays, scalars (strings, numbers).
For dumping blessed objects and things like coderefs have a look at
YAML::PP::Perl/YAML::PP::Schema::Perl.
.IP "YAML::PP::Lexer" 4
.IX Item "YAML::PP::Lexer"
The Lexer is reading the \s-1YAML\s0 stream into tokens. This makes it possible
to generate syntax highlighted \s-1YAML\s0 output.
.Sp
Note that the \s-1API\s0 to retrieve the tokens will change.
.IP "YAML::PP::Parser" 4
.IX Item "YAML::PP::Parser"
The Parser retrieves the tokens from the Lexer. The main \s-1YAML\s0 content is then
parsed with the Grammar.
.IP "YAML::PP::Grammar" 4
.IX Item "YAML::PP::Grammar"
.PD 0
.IP "YAML::PP::Constructor" 4
.IX Item "YAML::PP::Constructor"
.PD
The Constructor creates a data structure from the Parser events.
.IP "YAML::PP::Loader" 4
.IX Item "YAML::PP::Loader"
The Loader combines the constructor and parser.
.IP "YAML::PP::Dumper" 4
.IX Item "YAML::PP::Dumper"
The Dumper will delegate to the Representer
.IP "YAML::PP::Representer" 4
.IX Item "YAML::PP::Representer"
The Representer will create Emitter events from the given data structure.
.IP "YAML::PP::Emitter" 4
.IX Item "YAML::PP::Emitter"
The Emitter creates a \s-1YAML\s0 stream.
.SS "YAML::PP::Parser"
.IX Subsection "YAML::PP::Parser"
Still \s-1TODO:\s0
.IP "Implicit collection keys" 4
.IX Item "Implicit collection keys"
.Vb 2
\&    \-\-\-
\&    [ a, b, c ]: value
.Ve
.IP "Implicit mapping in flow style sequences" 4
.IX Item "Implicit mapping in flow style sequences"
.Vb 4
\&    \-\-\-
\&    [ a, b, c: d ]
\&    # equals
\&    [ a, b, { c: d } ]
.Ve
.IP "Plain mapping keys ending with colons" 4
.IX Item "Plain mapping keys ending with colons"
.Vb 2
\&    \-\-\-
\&    key ends with two colons::: value
.Ve
.IP "Supported Characters" 4
.IX Item "Supported Characters"
If you have valid \s-1YAML\s0 that's not parsed, or the other way round, please
create an issue.
.IP "Line and Column Numbers" 4
.IX Item "Line and Column Numbers"
You will see line and column numbers in the error message. The column numbers
might still be wrong in some cases.
.IP "Error Messages" 4
.IX Item "Error Messages"
The error messages need to be improved.
.IP "Unicode Surrogate Pairs" 4
.IX Item "Unicode Surrogate Pairs"
Currently loaded as single characters without validating
.IP "Possibly more" 4
.IX Item "Possibly more"
.SS "YAML::PP::Constructor"
.IX Subsection "YAML::PP::Constructor"
The Constructor now supports all three \s-1YAML 1.2\s0 Schemas, Failsafe, \s-1JSON\s0 and
Core.  Additionally you can choose the schema for \s-1YAML 1.1\s0 as \f(CW\*(C`YAML1_1\*(C'\fR.
.PP
Too see what strings are resolved as booleans, numbers, null etc. look at
<https://perlpunk.github.io/YAML\-PP\-p5/schema\-examples.html>.
.PP
You can choose the Schema like this:
.PP
.Vb 1
\&    my $ypp = YAML::PP\->new(schema => [\*(AqJSON\*(Aq]); # default is \*(AqCore\*(Aq
.Ve
.PP
The Tags \f(CW\*(C`!!seq\*(C'\fR and \f(CW\*(C`!!map\*(C'\fR are still ignored for now.
.PP
It supports:
.IP "Handling of Anchors/Aliases" 4
.IX Item "Handling of Anchors/Aliases"
Like in modules like \s-1YAML\s0, the Constructor will use references for mappings and
sequences, but obviously not for scalars.
.Sp
\&\s-1YAML::XS\s0 uses real aliases, which allows also aliasing scalars. I might add
an option for that since aliasing is now available in pure perl.
.IP "Boolean Handling" 4
.IX Item "Boolean Handling"
You can choose between \f(CW\*(Aqperl\*(Aq\fR (1/'', currently default), \f(CW\*(AqJSON::PP\*(Aq\fR and
\&\f(CW\*(Aqboolean\*(Aq\fR.pm for handling boolean types.  That allows you to dump the data
structure with one of the \s-1JSON\s0 modules without losing information about
booleans.
.IP "Numbers" 4
.IX Item "Numbers"
Numbers are created as real numbers instead of strings, so that they are
dumped correctly by modules like \s-1JSON::PP\s0 or \s-1JSON::XS\s0, for example.
.IP "Complex Keys" 4
.IX Item "Complex Keys"
Mapping Keys in \s-1YAML\s0 can be more than just scalars. Of course, you can't load
that into a native perl structure. The Constructor will stringify those keys
with Data::Dumper instead of just returning something like
\&\f(CW\*(C`HASH(0x55dc1b5d0178)\*(C'\fR.
.Sp
Example:
.Sp
.Vb 10
\&    use YAML::PP;
\&    use JSON::PP;
\&    my $ypp = YAML::PP\->new;
\&    my $coder = JSON::PP\->new\->ascii\->pretty\->allow_nonref\->canonical;
\&    my $yaml = <<\*(AqEOM\*(Aq;
\&    complex:
\&        ?
\&            ?
\&                a: 1
\&                c: 2
\&            : 23
\&        : 42
\&    EOM
\&    my $data = $yppl\->load_string($yaml);
\&    say $coder\->encode($data);
\&    _\|_END_\|_
\&    {
\&       "complex" : {
\&          "{\*(Aq{a => 1,c => 2}\*(Aq => 23}" : 42
\&       }
\&    }
.Ve
.PP
\&\s-1TODO:\s0
.IP "Parse Tree" 4
.IX Item "Parse Tree"
I would like to generate a complete parse tree, that allows you to manipulate
the data structure and also dump it, including all whitespaces and comments.
The spec says that this is throwaway content, but I read that many people
wish to be able to keep the comments.
.SS "YAML::PP::Dumper, YAML::PP::Emitter"
.IX Subsection "YAML::PP::Dumper, YAML::PP::Emitter"
The Dumper should be able to dump strings correctly, adding quotes
whenever a plain scalar would look like a special string, like \f(CW\*(C`true\*(C'\fR,
or when it contains or starts with characters that are not allowed.
.PP
Most strings will be dumped as plain scalars without quotes. If they
contain special characters or have a special meaning, they will be dumped
with single quotes. If they contain control characters, including <\*(L"\en\*(R">,
they will be dumped with double quotes.
.PP
It will recognize JSON::PP::Boolean and boolean.pm objects and dump them
correctly.
.PP
Numbers which also have a \s-1PV\s0 flag will be recognized as numbers and not
as strings:
.PP
.Vb 2
\&    my $int = 23;
\&    say "int: $int"; # $int will now also have a PV flag
.Ve
.PP
That means that if you accidentally use a string in numeric context, it will
also be recognized as a number:
.PP
.Vb 4
\&    my $string = "23";
\&    my $something = $string + 0;
\&    print $yp\->dump_string($string);
\&    # will be emitted as an integer without quotes!
.Ve
.PP
The layout is like libyaml output:
.PP
.Vb 10
\&    key:
\&    \- a
\&    \- b
\&    \- c
\&    \-\-\-
\&    \- key1: 1
\&      key2: 2
\&      key3: 3
\&    \-\-\-
\&    \- \- a1
\&      \- a2
\&    \- \- b1
\&      \- b2
.Ve
.SH "WHY"
.IX Header "WHY"
All the available parsers and loaders for Perl are behaving differently,
and more important, aren't conforming to the spec. \s-1YAML::XS\s0 is
doing pretty well, but \f(CW\*(C`libyaml\*(C'\fR only handles \s-1YAML 1.1\s0 and diverges
a bit from the spec. The pure perl loaders lack support for a number of
features.
.PP
I was going over \s-1YAML\s0.pm issues end of 2016, integrating old patches
from rt.cpan.org and creating some pull requests myself. I realized
that it would be difficult to patch \s-1YAML\s0.pm to parse \s-1YAML 1.1\s0 or even 1.2,
and it would also break existing usages relying on the current behaviour.
.PP
In 2016 Ingy döt Net initiated two really cool projects:
.ie n .IP """\s-1YAML TEST SUITE""\s0" 4
.el .IP "``\s-1YAML TEST SUITE''\s0" 4
.IX Item "YAML TEST SUITE"
.PD 0
.ie n .IP """\s-1YAML EDITOR""\s0" 4
.el .IP "``\s-1YAML EDITOR''\s0" 4
.IX Item "YAML EDITOR"
.PD
.PP
These projects are a big help for any developer. So I got the idea
to write my own parser and started on New Year's Day 2017.
Without the test suite and the editor I would have never started this.
.PP
I also started another \s-1YAML\s0 Test project which allows one to get a quick
overview of which frameworks support which \s-1YAML\s0 features:
.ie n .IP """\s-1YAML TEST MATRIX""\s0" 4
.el .IP "``\s-1YAML TEST MATRIX''\s0" 4
.IX Item "YAML TEST MATRIX"
.SS "\s-1YAML TEST SUITE\s0"
.IX Subsection "YAML TEST SUITE"
<https://github.com/yaml/yaml\-test\-suite>
.PP
It contains about 230 test cases and expected parsing events and more.
There will be more tests coming. This test suite allows you to write parsers
without turning the examples from the Specification into tests yourself.
Also the examples aren't completely covering all cases \- the test suite
aims to do that.
.PP
The suite contains .tml files, and in a separate 'data' release you will
find the content in separate files, if you can't or don't want to
use TestML.
.PP
Thanks also to Felix Krause, who is writing a \s-1YAML\s0 parser in Nim.
He turned all the spec examples into test cases.
.SS "\s-1YAML EDITOR\s0"
.IX Subsection "YAML EDITOR"
This is a tool to play around with several \s-1YAML\s0 parsers and loaders in vim.
.PP
<https://github.com/yaml/yaml\-editor>
.PP
The project contains the code to build the frameworks (16 as of this
writing) and put it into one big Docker image.
.PP
It also contains the yaml-editor itself, which will start a vim in the docker
container. It uses a lot of funky vimscript that makes playing with it easy
and useful. You can choose which frameworks you want to test and see the
output in a grid of vim windows.
.PP
Especially when writing a parser it is extremely helpful to have all
the test cases and be able to play around with your own examples to see
how they are handled.
.SS "\s-1YAML TEST MATRIX\s0"
.IX Subsection "YAML TEST MATRIX"
I was curious to see how the different frameworks handle the test cases,
so, using the test suite and the docker image, I wrote some code that runs
the tests, manipulates the output to compare it with the expected output,
and created a matrix view.
.PP
<https://github.com/perlpunk/yaml\-test\-matrix>
.PP
You can find the latest build at <https://matrix.yaml.io>
.PP
As of this writing, the test matrix only contains valid test cases.
Invalid ones will be added.
.SH "CONTRIBUTORS"
.IX Header "CONTRIBUTORS"
.IP "Ingy döt Net" 4
.IX Item "Ingy döt Net"
Ingy is one of the creators of \s-1YAML.\s0 In 2016 he started the \s-1YAML\s0 Test Suite
and the \s-1YAML\s0 Editor. He also made useful suggestions on the class
hierarchy of \s-1YAML::PP.\s0
.ie n .IP "Felix ""flyx"" Krause" 4
.el .IP "Felix ``flyx'' Krause" 4
.IX Item "Felix flyx Krause"
Felix answered countless questions about the \s-1YAML\s0 Specification.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.IP "\s-1YAML\s0" 4
.IX Item "YAML"
.PD 0
.IP "\s-1YAML::XS\s0" 4
.IX Item "YAML::XS"
.IP "YAML::Syck" 4
.IX Item "YAML::Syck"
.IP "YAML::Tiny" 4
.IX Item "YAML::Tiny"
.IP "YAML::PP::LibYAML" 4
.IX Item "YAML::PP::LibYAML"
.IP "YAML::LibYAML::API" 4
.IX Item "YAML::LibYAML::API"
.IP "<https://www.yaml.info>" 4
.IX Item "<https://www.yaml.info>"
.PD
.SH "SPONSORS"
.IX Header "SPONSORS"
The Perl Foundation <https://www.perlfoundation.org/> sponsored this project
(and the \s-1YAML\s0 Test Suite) with a grant of 2500 \s-1USD\s0 in 2017\-2018.
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright 2017\-2020 by Tina Müller
.PP
This library is free software and may be distributed under the same terms
as perl itself.
