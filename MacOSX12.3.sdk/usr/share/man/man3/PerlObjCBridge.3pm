.\" Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "PerlObjCBridge 3"
.TH PerlObjCBridge 3 "2021-09-10" "perl v5.30.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
PerlObjCBridge.pm \- Bridges Perl and Objective\-C runtimes
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use Foundation;
\&    
\&    $s1 = NSString\->stringWithCString_("Hello ");
\&    $s2 = NSString\->alloc()\->initWithCString_("World");
\&    $s3 = $s1\->stringByAppendingString_($s2);
\&    printf "%s\en", $s3\->cString();
.Ve
.SH "SUMMARY"
.IX Header "SUMMARY"
The PerlObjCBridge module supports creating and messaging Objective-C objects from Perl programs, allowing Cocoa objects in Apple Computer's Mac \s-1OS X\s0 to be directly manipulated from Perl. In addition, Perl objects can be messaged from Objective-C, making it possible for Perl objects to function as Cocoa delegates and as targets of notifications and other Cocoa call-back messages. Perl programs can take advantage of Cocoa's Distributed Objects mechanism to support messaging between Perl objects and Objective-C objects (or other Perl objects) in different address spaces, possibly on different machines.
.SH "LIMITATION"
.IX Header "LIMITATION"
This version of PerlObjCBridge does not directly support writing \s-1GUI\s0 Cocoa applications in Perl. Consult http://www.sourceforge.net/projects/camelbones for a freeware package that supports \s-1GUI\s0 Perl/Cocoa apps.
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Using PerlObjCBridge, Perl programs can reference Objective-C objects in a manner similar to references to native Perl objects. The Objective-C objects must inherit from the NSObject root class in the Mac \s-1OS X\s0 Foundation framework (which is true for Cocoa objects). In Objective-C an object is accessed via an object identifier that is implemented as a pointer to a structure containing the object's instance data. PerlObjCBridge represents an Objective-C object as a Perl reference to a scalar value that contains the Objective-C \s-1ID.\s0 For example, if an Objective-C object has an \s-1ID\s0 with value 0x12345678, then PerlObjCBridge represents that object as a reference to a scalar with value 0x12345678. The Perl reference is \*(L"blessed\*(R" into a Perl class that has the same name as the Objective-C class. The Perl inheritance mechanism is then used to route any messages sent to the object from Perl through the PerlObjCBridge extension module and ultimately to the Objective-C object. The return values of the Objective-C messages are similarly routed back through the bridge where they are converted into Perl return values.
.PP
It is also possible to use Perl objects in places where Cocoa methods normally take Objective-C arguments. For example, one can register Perl objects to receive NSNotifications, in which case the perl objects provide the notification handling methods that are asynchronously messaged by NSNotificationCenter when interesting events occur. As another example, a Perl object can be registered as a server object via NSConnection, after which Objective-C or Perl objects in other address spaces can send messages to the server object via the Distributed Objects mechanism. In these examples an Objective-C proxy object is created by PerlObjCBridge that gets passed to Objective-C methods, and that forwards messages from Objective-C to the Perl object.
.SH "MESSAGING"
.IX Header "MESSAGING"
Ordinary Perl \*(L"object\->method(argument\-list)\*(R" syntax is used to send messages to Objective-C objects. The ':' character that delimits arguments in Objective-C is illegal in Perl method names, so underscores are used instead. An method that is invoked in Objective-C as:
.PP
.Vb 1
\&    [anObject arg1:x arg2:y];
.Ve
.PP
can be invoked from Perl using something like:
.PP
.Vb 1
\&    $anObject\->arg1_arg2_($x, $y);
.Ve
.PP
Contrast the following Objective-C code fragment with its Perl analogue in the synopsis at the top of this man page:
.PP
.Vb 1
\&    #import <Foundation/Foundation.h>
\&
\&    NSString *s1 = [NSString stringWithCString:"Hello "];
\&    NSString *s2 = [[NSString alloc] initWithCString:"World"];
\&    NSString *s3 = [s1 stringByAppendingString:s2];
\&    printf("%s\en", [s3 cString]);
.Ve
.PP
To send a message to an Objective-C class, one uses the syntactic form ClassName\->method(...args...). For example, one can send the \*(L"defaultManager\*(R" message to the NSFileManager class as follows:
.PP
.Vb 1
\&    $defMgr = NSFileManager\->defaultManager();
.Ve
.PP
An important special case of a class method is a \*(L"factory\*(R" method that constructs a new instance of a class:
.PP
.Vb 1
\&    $array = NSMutableArray\->array();
\&    
\&    $string = NSString\->stringWithCString_("Hi there");
.Ve
.PP
The NSString factory method illustrates how PerlObjCBridge passes Perl strings to Objective-C as char *'s.
.PP
To send a message to an Objective-C object, one uses the syntactic form \f(CW$object\fR\->method(...args...). If \f(CW$array\fR is a reference to an NSMutableArray then one can add the NSString referenced by \f(CW$string\fR by sending \f(CW$array\fR the \*(L"addObject:\*(R" message:
.PP
.Vb 1
\&    $array\->addObject_($string);
.Ve
.PP
Message sends can be chained from left to right:
.PP
.Vb 1
\&    $hostName = NSProcessInfo\->processInfo()\->hostName();
.Ve
.PP
In the above example, the object returned by NSProcessInfo\->\fBprocessInfo()\fR is in turn sent the hostName message.
.SH "USING COCOA FRAMEWORKS"
.IX Header "USING COCOA FRAMEWORKS"
PerlObjCBridge automatically generates a bridge module for the Foundation framework that is included with the Cocoa environment in Mac \s-1OS X.\s0 This bridge module is created when PerlObjCBridge is built. The bridge module for a framework causes that framework to be dynamically loaded into the Perl program's address space. In addition Perl packages are created for each of the Objective-C classes in the framework so that the Objective-C classes exist in the Perl name space.
.PP
To access a framework from Perl \*(L"use\*(R" its bridge module. For example, to access Foundation objects do:
.PP
.Vb 1
\&    use Foundation;
.Ve
.SH "DISTRIBUTED MESSAGING"
.IX Header "DISTRIBUTED MESSAGING"
Perl objects can send messages to other objects (Perl or Cocoa) in different address spaces by using Cocoa's Distributed Objects (\s-1DO\s0) mechanism. This makes it easy to create distributed systems (such as client/server systems) that mix Perl and Cocoa programs. It also makes it easy to create a pure Perl distributed system, where Perl objects in different address spaces communicate via Cocoa \s-1DO.\s0
.PP
Here is a complete example of a distributed client/server system, where the client and server objects are written in Perl but communicate by means of \s-1DO.\s0 The system consists of a Perl client program, a Perl server program, and a Perl \s-1XSUB\s0 module that provides the glue between the Perl programs and \s-1DO.\s0 The \s-1XSUB\s0 module is initially created by running the following  command:
.PP
.Vb 1
\&    h2xs \-A \-n AddSystem
.Ve
.PP
An AddSystem directory is created with these files:
.PP
.Vb 8
\&    ppport.h
\&    lib/AddSystem.pm
\&    AddSystem.xs
\&    Makefile.PL
\&    README
\&    t/AddSystem.t    
\&    Changes
\&    MANIFEST
.Ve
.PP
Edit the Makefile.PL to add the \s-1CCFLAGS\s0 entry with the '\-x objective\-c' flag:
.PP
.Vb 1
\&    \*(AqCCFLAGS\*(Aq        => \*(Aq\-x objective\-c\*(Aq,
.Ve
.PP
Modify the contents of AddSystem.pm to contain:
.PP
.Vb 1
\&    package AddSystem;
\&
\&    @ISA = qw(Exporter DynaLoader);
\&    @EXPORT = qw( );
\&    $VERSION = \*(Aq1.0\*(Aq;
\&    bootstrap AddSystem $VERSION;
\&
\&    use Foundation;
\&
\&    1;
.Ve
.PP
and modify AddSystem.xs to have the contents:
.PP
.Vb 10
\&    #include <mach\-o/dyld.h>
\&    #include "EXTERN.h"
\&    #include "perl.h"
\&    #include "XSUB.h"
\&    #ifdef Move
\&    #undef Move
\&    #endif Move
\&    #ifdef DEBUG
\&    #undef DEBUG
\&    #endif DEBUG
\&    #ifdef I_POLL
\&    #undef I_POLL
\&    #endif I_POLL
\&    #import <Foundation/Foundation.h>
\&
\&    @interface AddClient : NSObject
\&    @end
\&
\&    @implementation AddClient
\&    \- (int)firstNumber { return 0; }
\&    \- (int)secondNumber { return 0; }
\&    @end
\&
\&    @interface AddServer: NSObject
\&    @end
\&
\&    @implementation AddServer
\&    \- (int)addNumbersForClient:(NSObject *)client { return 0; }
\&    @end
\&
\&    MODULE = AddSystem          PACKAGE = AddSystem
.Ve
.PP
AddSystem.xs defines \*(L"dummy\*(R" AddClient and AddServer Objective-C classes that implement the methods that the Perl client and server will provide. These dummy Objective-C classes are needed in this case because there would otherwise not be enough information for the \s-1DO\s0 runtime system to determine the numbers, types, and sizes of the method arguments and return values. These dummy Objective-C implementations are usually only needed when \s-1DO\s0 is being used and the Perl program does not link against any libraries that contain objects that already implement the methods. The actual method bodies are irrelevant and can be trivially defined to return 0 or \s-1NULL.\s0 In the case of methods that return void, the dummy methods can have empty bodies.
.PP
After modifying Makefile.PL, AddSystem.pm, and AddSystem.xs, execute the following commands (as root or as an admin user):
.PP
.Vb 2
\&    perl Makefile.PL
\&    make install
.Ve
.PP
Now add two Perl programs to the AddSystem directory. The first program is addServer:
.PP
.Vb 1
\&    #!/usr/bin/perl
\&
\&    use AddSystem;
\&
\&    package AddServer;
\&    @ISA = qw(PerlObjCBridge);
\&    @EXPORT = qw( );
\&
\&    PerlObjCBridge::preloadSelectors(\*(AqAddClient\*(Aq);
\&
\&    sub new
\&    {
\&        my $class = shift;
\&        my $self = {};
\&        bless $self, $class;
\&        return $self;
\&    }
\&
\&    sub addNumbersForClient_
\&    {
\&        my($self, $client) = @_;
\&        my $first = $client\->firstNumber();
\&        my $second = $client\->secondNumber();
\&        return int($first + $second);
\&    }
\&
\&    $server = new AddServer;
\&    $connection = NSConnection\->defaultConnection();
\&    $connection\->setRootObject_($server);
\&    $connection\->registerName_(NSString\->stringWithCString_("AddServer"));
\&
\&    NSRunLoop\->currentRunLoop()\->run();
.Ve
.PP
Make sure that the line \*(L"#!/usr/bin/perl\*(R" does not contain leading whitespace.
.PP
The line:
.PP
.Vb 1
\&    use AddSystem;
.Ve
.PP
causes addServer to load the AddSystem \s-1XSUB\s0 module, which in turn loads the dummy AddClient and AddServer Objective-C classes, thus making them available to the \s-1DO\s0 runtime system. The lines:
.PP
.Vb 3
\&    package AddServer;
\&    @ISA = qw(PerlObjCBridge);
\&    @EXPORT = qw( );
.Ve
.PP
cause the AddServer package to inherit from PerlObjCBridge. As a consequence, messages to and from AddServer objects will be routed through PerlObjCBridge.
.PP
The line:
.PP
.Vb 1
\&    PerlObjCBridge::preloadSelectors(\*(AqAddClient\*(Aq);
.Ve
.PP
instructs PerlObjCBridge to pre-cache all method selectors for the Objective-C class AddClient. By doing this, PerlObjCBridge is \*(L"primed\*(R" with the information needed to send messages to objects of class AddClient.
.PP
After a standard \*(L"new\*(R" constructor method, there is a addNumbersForClient_ method that provides the service vended by the AddServer class. The method name \*(L"addNumbersForClient_\*(R" corresponds to the Objective-C selector \*(L"addNumbersForClient:\*(R", which has a dummy implementation in AddSystem.xs. In addition to the standard \f(CW$self\fR argument, addNumbersForClient_ takes a second argument \f(CW$client\fR which is a reference to the invoking client object. The client object is then sent the messages \*(L"firstNumber\*(R" and \*(L"secondNumber\*(R", each of which returns an integer. The server adds the two numbers and returns the result.
.PP
The lines:
.PP
.Vb 4
\&    $server = new AddServer;
\&    $connection = NSConnection\->defaultConnection();
\&    $connection\->setRootObject_($server);
\&    $connection\->registerName_(NSString\->stringWithCString_("AddServer"));
.Ve
.PP
create a new AddServer object and set it as the root object of a \s-1DO\s0 connection, registered with the name \*(L"AddServer\*(R". Clients can then look up the name \*(L"AddServer\*(R" to connect to this object.
.PP
The final line:
.PP
.Vb 1
\&    NSRunLoop\->currentRunLoop()\->run();
.Ve
.PP
puts addServer into a event loop, waiting for incoming connections from clients.
.PP
The second program, addClient, consists of:
.PP
.Vb 1
\&    #!/usr/bin/perl
\&
\&    use AddSystem;
\&
\&    package AddClient;
\&    @ISA = qw(PerlObjCBridge);
\&    @EXPORT = qw( );
\&
\&    PerlObjCBridge::preloadSelectors(\*(AqAddServer\*(Aq);
\&
\&    sub new
\&    {
\&        my $class = shift;
\&        my $self = {};
\&        bless $self, $class;
\&        $self{\*(AqfirstNumber\*(Aq} = shift;
\&        $self{\*(AqsecondNumber\*(Aq} = shift;
\&        return $self;
\&    }
\&
\&    sub firstNumber
\&    {
\&        my($self) = @_;
\&        return $self{\*(AqfirstNumber\*(Aq};
\&    }
\&
\&    sub secondNumber
\&    {
\&        my($self) = @_;
\&        return $self{\*(AqsecondNumber\*(Aq};
\&    }
\&
\&    die "usage: perlClient <firstNumber> <secondNumber>\en" unless @ARGV == 2;
\&
\&    # create client
\&    $client = new AddClient (@ARGV);
\&    
\&    # create connection to server
\&    $name = NSString\->stringWithCString_("AddServer");
\&    $server = NSConnection\->rootProxyForConnectionWithRegisteredName_host_($name, 0);
\&    if (!$server or !$$server) {
\&        print "Can\*(Aqt get server\en";
\&        exit(1);
\&    }
\&    $server\->retain();
\&    
\&    printf "%d\en", $server\->addNumbersForClient_($client);
.Ve
.PP
Make sure that the line \*(L"#!/usr/bin/perl\*(R" does not contain leading whitespace.
.PP
The AddClient methods \*(L"firstNumber\*(R" and \*(L"secondNumber\*(R" implement the call-back methods invoked by the AddServer. The lines:
.PP
.Vb 7
\&    $name = NSString\->stringWithCString_("AddServer");
\&    $server = NSConnection\->rootProxyForConnectionWithRegisteredName_host_($name, 0);
\&    if (!$server or !$$server) {
\&        print "Can\*(Aqt get server\en";
\&        exit(1);
\&    }
\&    $server\->retain();
.Ve
.PP
results in \f(CW$server\fR being assigned a \s-1DO\s0 \*(L"proxy\*(R" object for the AddServer object in the addServer program. Any messages sent by the client will by forwarded by the \s-1DO\s0 proxy to the actual AddServer object in the addServer address space.
.PP
The final line:
.PP
.Vb 1
\&    printf "%d\en", $server\->addNumbersForClient_($client);
.Ve
.PP
invokes the AddServer object with a reference to the client object. The control flow that results is:
.PP
.Vb 6
\&    addClient sends "addNumbersForClient:" to addServer
\&    addServer sends "firstNumber" to addClient
\&    addClient returns first number
\&    addServer sends "secondNumber" to addClient
\&    addClient returns second number
\&    addServer returns sum of first and second number
.Ve
.PP
To execute these programs, first make sure addServer and addClient are executable:
.PP
.Vb 1
\&    chmod +x addServer addClient
.Ve
.PP
Next run the server in one shell:
.PP
.Vb 1
\&    addServer
.Ve
.PP
then the client in another shell:
.PP
.Vb 2
\&    addClient 1 2
\&    3
.Ve
.SH "AUTOMATIC STRING CONVERSION"
.IX Header "AUTOMATIC STRING CONVERSION"
For convenience, PerlObjCBridge automatically converts Perl strings into NSString Objective-C objects when an NSObject is expected as the argument to an Objective-C method. For example, suppose an Objective-C dictionary is created:
.PP
.Vb 1
\&    $dict = NSMutableDictionary\->dictionary();
.Ve
.PP
The dictionary method \*(L"setObject:forKey:\*(R" expects the key argument to be an NSString and the value argument to be any NSObject. The following automatically converts both \*(L"aKey\*(R" and \*(L"aValue\*(R" to NSStrings and then inserts the pair into the dictionary:
.PP
.Vb 1
\&    $dict\->setObject_forKey_("aValue", "aKey");
.Ve
.PP
The value can be retrieved as follows, where \*(L"aKey\*(R" is again automatically converted to an NSString:
.PP
.Vb 2
\&    $value = $dict\->objectForKey_("aKey");
\&    printf "value is %s\en", $value\->cString();
.Ve
.PP
Note that the return value assigned to \f(CW$value\fR is a reference to an NSString and is not automatically converted to a Perl string. The automatic conversions occur only from Perl strings to NSStrings for Objective-C method arguments. NSStrings return values are not automatically converted to Perl strings.
.PP
Automatic conversion also occurs when a Perl string is passed as an argument to a method that expects an Objective-C selector. For example, the \*(L"performSelector:\*(R" message can be sent to any NSObject. The argument to the \*(L"performSelector:\*(R" message must be an Objective-C selector. In Objective-C, one can copy an existing NSString \*(L"origString\*(R" by asking it to perform the \*(L"copy\*(R" selector:
.PP
.Vb 1
\&    copy = [origString performSelector:@selector(copy)];
.Ve
.PP
This is equivalent to:
.PP
.Vb 1
\&    copy = [origString copy];
.Ve
.PP
In Perl the selector form can be executed as:
.PP
.Vb 1
\&    $copy = $origString\->performSelector_("copy");
.Ve
.PP
In this case the Perl string \*(L"copy\*(R" is automatically converted to an Objective-C selector.
.SH "NIL ARGUMENTS AND RETURN VALUES"
.IX Header "NIL ARGUMENTS AND RETURN VALUES"
It is sometimes necessary to pass the Objective-C object \s-1ID\s0 \*(L"nil\*(R" (a null pointer) as an argument to an Objective-C method. Since PerlObjCBridge represents Objective-C \s-1ID\s0's as Perl references, strictly speaking the Perl value 0 is not a legal representation for Objective-C's nil because it is a simple scalar, not a reference. However, for convenience, when an argument to an Objective-C method is expected to be an object \s-1ID\s0 and the value 0 is passed from Perl, PerlObjCBridge coerces the 0 value to a reference to a zero-valued scalar and the Objective-C method receives nil for that argument. In the following example, the Objective-c method \*(L"arg1:optionalArg:\*(R" would receive nil as its second argument.
.PP
.Vb 1
\&    MyClass\->arg1_optionalArg_($obj, 0);
.Ve
.PP
The special value \*(L"undef\*(R" can also be used:
.PP
.Vb 1
\&    MyClass\->arg1_optionalArg_($obj, undef);
.Ve
.PP
When an Objective-C method returns nil, the corresponding Perl return value is a reference to a zero-valued scalar. This return value can subsequently be passed as an argument to an Objective-C method. In the following example, if \*(L"aMethod\*(R" returns nil then \*(L"arg1:optionalArg:\*(R" would receive nil as its second argument:
.PP
.Vb 1
\&    MyClass\->arg1_optionalArg_($obj, YourClass\->aMethod());
.Ve
.PP
To determine whether an Objective-C method returned nil one should test both the Perl reference and its referent. The referent will be zero-valued when the Objective-C method returned nil, but it is also possible for the reference itself to be undefined (for example, when the method raised an NSException, as discussed below). The following example illustrates the use of an Objective-C NSEnumerator object to print the elements of an NSArray. In Objective-C, the enumerator returns nil after the last object in the array has been enumerated. In the Perl loop, both the reference \f(CW$obj\fR and the referent $$obj are tested in the loop condition. Under normal circumstances looping ends when $$obj becomes zero-valued, indicating the enumerator returned nil.
.PP
.Vb 4
\&    $enumerator = $array\->objectEnumerator();
\&    while ($obj = $enumerator\->nextObject() and $$obj) {
\&        printf "%s\en", $obj\->description()\->cString();
\&    }
.Ve
.SH "ARGUMENTS THAT RETURN OBJECTS BY REFERENCE"
.IX Header "ARGUMENTS THAT RETURN OBJECTS BY REFERENCE"
Sometimes Objective-C methods return objects to the caller using return-by-reference arguments. For example, the following method defines an argument that returns an NSError object by reference.
.PP
.Vb 1
\&    \- (BOOL)doSomethingAndReturnError:(NSError **)error;
.Ve
.PP
When the doSomethingAndReturnError: method fails it returns a Boolean value of \s-1NO\s0 and (optionally) also returns a by-reference NSError argument. An Objective-C caller of this method will typically do something like the following.
.PP
.Vb 1
\&    NSError *error = nil;
\&
\&    BOOL result = [anObject doSomethingAndReturnError:&error];
\&    if ( ! result ) {
\&        if ( error ) {
\&            NSLog(@"error code is %d", [error code]);
\&        }
\&    }
.Ve
.PP
Return-by-reference arguments can be used from Perl as illustrated by the following example.
.PP
.Vb 2
\&    my $errorVal;                   # declare $errorVal as an uninitialized scalar
\&    my $error = \e$errorVal;         # initialize $error as a reference to $errorVal
\&    
\&    my $result = $anObject\->doSomethingAndReturnError_($error);
\&    if ( ! $result ) {
\&        if ( $$error ) {
\&            printf "error code is %d\en", $error\->code( );
\&        }
\&    }
.Ve
.PP
Note: the following does not work.
.PP
.Vb 2
\&    my $errorVal;
\&    my $result = $anObject\->doSomethingAndReturnError_($errorVal);
.Ve
.PP
The following does not work either.
.PP
.Vb 2
\&    my $errorVal;
\&    my $result = $anObject\->doSomethingAndReturnError_(\e$errorVal);
.Ve
.PP
Pass undef to avoid returning the Objective-C object:
.PP
.Vb 1
\&    my $result = $anObject\->doSomethingAndReturnError_(undef);
.Ve
.SH "POINTERS TO BUFFERS"
.IX Header "POINTERS TO BUFFERS"
For Objective-C methods such as \-[NSData getBytes:length:] it is necessary to pass an argument that represents a pointer to a buffer of known length.  This may be accomplished using the \fBpack()\fR and \fBunpack()\fR functions, as shown in the following example. The \*(L"L!\*(R" template forces the \fBunpack()\fR function to return a native-length unsigned long value, which is always the same size as a pointer in Mac \s-1OS X.\s0
.PP
In this example, assume \f(CW$nsData\fR points to a valid NSData object:
.PP
.Vb 7
\&    my $buffer;
\&    if ($nsData && $$nsData) {
\&        my $length = $nsData\->length();
\&        $buffer = \*(Aq\e0\*(Aq x $length;
\&        my $pointerToBuffer = unpack("L!", pack("p", $buffer));
\&        $nsData\->getBytes_length_($pointerToBuffer, $length);
\&    }
.Ve
.SH "EXCEPTION HANDLING"
.IX Header "EXCEPTION HANDLING"
NSExceptions that are raised as a result of messages sent by Perl programs to Objective-C objects are dealt with as follows. PerlObjCBridge has a built-in NSException handler that writes the message selector, the class of the target object, and the NSException name, reason, and userInfo to standard error. By default, the built-in NSException handler then dies with a message. The function \fBPerlObjCBridge::setDieOnExceptions()\fR can be used to control the latter behavior. Invoking \fBsetDieOnExceptions()\fR with an argument of 0 will cause the built-in exception handler to issue a warning and return without dying, whereas a non-zero argument (or no argument) will cause the built-in exception handler to die. In the case where the built-in exception handler returns with a warning, the original message that caused the exception returns undef.
.PP
Alternatively, the Perl program can set its own exception handler by calling \fBPerlObjCBridge::setNSExceptionHandler()\fR with a single argument that must be a reference to a Perl function that acts as the exception handler. The Perl program can get a reference to the current exception handler by calling \fBPerlObjCBridge::getNSExceptionHandler()\fR. If a user-defined exception handler is set and an NSException is raised then the user-defined handler will be called with five string arguments: (1) the Objective-C selector for the message that induced the NSException, (2) the class name of the object to which the message was sent, and (3,4,5) the NSException name, reason, and userInfo (the latter represented as the string [userInfo description]). If the user-defined exception handler returns, then the original message returns undef. When a user-defined exception handler is set, it is up to the handler to decide whether the program exits or continues when NSExceptions are raised (i.e., when a user-defined exception handler is set the function \fBsetDieOnExceptions()\fR has no effect).
.PP
The example below stores the original exception handler, sets a new exception handler, provokes an NSException by attempting to set a dictionary entry with a nil key and a nil value, and then restores the original exception handler.
.PP
.Vb 10
\&   sub myHandler
\&   {
\&       my($sel, $pkg, $name, $reason, $userInfo) = @_;
\&       print "NSException raised!\en";
\&       print "selector:  $selector\en";
\&       print "package:   $package\en";
\&       print "name:      $name\en";
\&       print "reason:    $reason\en";
\&       print "userInfo:  $userInfo\en";
\&   }
\&
\&   $oldHandler = PerlObjCBridge::getNSExceptionHandler();
\&   PerlObjCBridge::setNSExceptionHandler(\e&myHandler);
\&   $dict = NSMutableDictionary\->dictionary();
\&   $dict\->setObject_forKey_(0, 0);
\&   PerlObjCBridge::setNSExceptionHandler($oldHandler);
.Ve
.PP
This results in myHandler printing the output:
.PP
.Vb 6
\&   NSException raised!
\&   selector:     setObject:forKey:
\&   target class: NSCFDictionary 
\&   name:         NSInvalidArgumentException
\&   reason:       *** \-[NSCFDictionary setObject:forKey:]: attempt to insert nil key
\&   userInfo:
.Ve
.SH "LARGE NUMERIC VALUES"
.IX Header "LARGE NUMERIC VALUES"
PerlObjCBridge assumes no Perl support for 64\-bit integers. When an Objective-C method has a 64\-bit integer return type (i.e., long long or unsigned long long) and the result of invoking that method is a return value that is too large (i.e., >= 2^^31) or too small (<= \-(2^^31)) to be represented in Perl as a signed integer then the value is returned as a Perl double. Similarly, when a parameter to an Objective-C method is a long long or unsigned long long then the type of the Perl argument value is examined. If the argument value is a Perl integer then its value is passed directly to the Objective-C method in long long or unsigned long long form (coercing in the unsigned case). Otherwise if the argument value is a Perl double then it is coerced to the appropriate long long or unsigned long long form before it is passed to the method.
.PP
Similar considerations apply to 32\-bit unsigned longs and unsigned ints. When an Objective-C method has a 32\-bit unsigned long or unsigned int return type and the result of invoking that method is a return value that is too large (>= 2^^31) to be represented in Perl as a signed integer then the value is returned as a Perl double. When a parameter to an Objective-C method is a 32\-bit unsigned long or unsigned int then the Perl int or float argument is simply coerced to the unsigned long or int. This can of course have unpleasant consequences if the Perl argument is negative or larger than 2^^32.
.SH "CONTROL FUNCTIONS"
.IX Header "CONTROL FUNCTIONS"
Calling \fBPerlObjCBridge::setTracing()\fR with a non-zero argument (or no argument) will cause PerlObjCBridge to log diagnostic messages as it executes. Calling \fBsetTracing()\fR with an argument of zero turns the diagnostics off.
.PP
Calling \fBPerlObjCBridge::setDieOnErrors()\fR with a non-zero argument (or no argument) will cause PerlObjCBridge to die with a warning message whenever there is an error during the sending of an Objective-C message (this is the default behavior). Calling \fBsetDieOnErrors()\fR with an argument of zero allows the program to print a warning message but not die after such an error.
.SH "BUGS AND LIMITATIONS"
.IX Header "BUGS AND LIMITATIONS"
PerlObjCBridge should take advantage of Perl support for 64\-bit integers if available. Feel free to fix this.
.PP
When structs are passed by value, sometimes pointers embedded in the structs get mangled. It is better to pass structs by reference if they contain embedded pointers.
.PP
Varargs-style messaging is not supported. This is unfortunate, but it's due to the lack of varargs support in NSInvocation and NSMethodSignature. Fix that and it should be easy to support varargs messaging in PerlObjCBridge.
.PP
Access to functions, variables, and other non-object-oriented constructs exported by libraries containing Objective-C is not currently supported. It seems dubious that those things are exported as C\-level constructs to begin with, when they could/should be Objective-C class methods. One possible workaround is to create an \s-1XSUB\s0 that provides Objective-C \*(L"covers\*(R" for these items. For example, if a library exports a variable:
.PP
.Vb 1
\&    extern int GreatBigFoo;
.Ve
.PP
then an \s-1XSUB\s0 with a cover might define:
.PP
.Vb 3
\&    @interface Covers: NSObject
\&    + (int)GreatBigFoo;
\&    @end
\&    
\&    @implementation Covers
\&    + (int)GreatBigFoo
\&    {
\&        return GreatBigFoo;
\&    }
\&    @end
.Ve
.PP
Then the value of the variable could be accessed in Perl:
.PP
.Vb 1
\&    $gbf = Covers::GreatBigFoo();
.Ve
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fBperl\fR\|(1).
Mac \s-1OS X:\s0 /Developer/Documentation/Cocoa/ObjectiveC
Mac \s-1OS X:\s0 /Developer/Documentation/Cocoa/Reference/Foundation
