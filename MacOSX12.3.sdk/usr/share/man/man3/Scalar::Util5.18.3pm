.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Scalar::Util 3"
.TH Scalar::Util 3 "2014-01-22" "perl v5.18.4" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Scalar::Util \- A selection of general\-utility scalar subroutines
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 4
\&    use Scalar::Util qw(blessed dualvar isdual readonly refaddr reftype
\&                        tainted weaken isweak isvstring looks_like_number
\&                        set_prototype);
\&                        # and other useful utils appearing below
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\f(CW\*(C`Scalar::Util\*(C'\fR contains a selection of subroutines that people have expressed
would be nice to have in the perl core, but the usage would not really be high
enough to warrant the use of a keyword, and the size so small such that being
individual extensions would be wasteful.
.PP
By default \f(CW\*(C`Scalar::Util\*(C'\fR does not export any subroutines.
.SH "FUNCTIONS FOR REFERENCES"
.IX Header "FUNCTIONS FOR REFERENCES"
The following functions all perform some useful activity on reference values.
.ie n .SS "$pkg = blessed( $ref )"
.el .SS "\f(CW$pkg\fP = blessed( \f(CW$ref\fP )"
.IX Subsection "$pkg = blessed( $ref )"
If \f(CW$ref\fR is a blessed reference the name of the package that it is blessed
into is returned. Otherwise \f(CW\*(C`undef\*(C'\fR is returned.
.PP
.Vb 2
\&    $scalar = "foo";
\&    $class  = blessed $scalar;           # undef
\&
\&    $ref    = [];
\&    $class  = blessed $ref;              # undef
\&
\&    $obj    = bless [], "Foo";
\&    $class  = blessed $obj;              # "Foo"
.Ve
.PP
Take care when using this function simply as a truth test (such as in
\&\f(CW\*(C`if(blessed $ref)...\*(C'\fR) because the package name \f(CW"0"\fR is defined yet false.
.ie n .SS "$addr = refaddr( $ref )"
.el .SS "\f(CW$addr\fP = refaddr( \f(CW$ref\fP )"
.IX Subsection "$addr = refaddr( $ref )"
If \f(CW$ref\fR is reference the internal memory address of the referenced value is
returned as a plain integer. Otherwise \f(CW\*(C`undef\*(C'\fR is returned.
.PP
.Vb 3
\&    $addr = refaddr "string";           # undef
\&    $addr = refaddr \e$var;              # eg 12345678
\&    $addr = refaddr [];                 # eg 23456784
\&
\&    $obj  = bless {}, "Foo";
\&    $addr = refaddr $obj;               # eg 88123488
.Ve
.ie n .SS "$type = reftype( $ref )"
.el .SS "\f(CW$type\fP = reftype( \f(CW$ref\fP )"
.IX Subsection "$type = reftype( $ref )"
If \f(CW$ref\fR is a reference the basic Perl type of the variable referenced is
returned as a plain string (such as \f(CW\*(C`ARRAY\*(C'\fR or \f(CW\*(C`HASH\*(C'\fR). Otherwise \f(CW\*(C`undef\*(C'\fR
is returned.
.PP
.Vb 3
\&    $type = reftype "string";           # undef
\&    $type = reftype \e$var;              # SCALAR
\&    $type = reftype [];                 # ARRAY
\&
\&    $obj  = bless {}, "Foo";
\&    $type = reftype $obj;               # HASH
.Ve
.SS "weaken( \s-1REF \s0)"
.IX Subsection "weaken( REF )"
The lvalue \f(CW\*(C`REF\*(C'\fR will be turned into a weak reference. This means that it
will not hold a reference count on the object it references. Also when the
reference count on that object reaches zero, the reference will be set to
undef. This function mutates the lvalue passed as its argument and returns no
value.
.PP
This is useful for keeping copies of references, but you don't want to prevent
the object being DESTROY-ed at its usual time.
.PP
.Vb 6
\&    {
\&      my $var;
\&      $ref = \e$var;
\&      weaken($ref);                     # Make $ref a weak reference
\&    }
\&    # $ref is now undef
.Ve
.PP
Note that if you take a copy of a scalar with a weakened reference, the copy
will be a strong reference.
.PP
.Vb 4
\&    my $var;
\&    my $foo = \e$var;
\&    weaken($foo);                       # Make $foo a weak reference
\&    my $bar = $foo;                     # $bar is now a strong reference
.Ve
.PP
This may be less obvious in other situations, such as \f(CW\*(C`grep()\*(C'\fR, for instance
when grepping through a list of weakened references to objects that may have
been destroyed already:
.PP
.Vb 1
\&    @object = grep { defined } @object;
.Ve
.PP
This will indeed remove all references to destroyed objects, but the remaining
references to objects will be strong, causing the remaining objects to never be
destroyed because there is now always a strong reference to them in the \f(CW@object\fR
array.
.SS "unweaken( \s-1REF \s0)"
.IX Subsection "unweaken( REF )"
The lvalue \f(CW\*(C`REF\*(C'\fR will be turned from a weak reference back into a normal
(strong) reference again. This function mutates the lvalue passed as its
argument and returns no value. This undoes the action performed by
\&\f(CW\*(C`weaken()\*(C'\fR.
.PP
This function is slightly neater and more convenient than the
otherwise-equivalent code
.PP
.Vb 3
\&    my $tmp = $REF;
\&    undef $REF;
\&    $REF = $tmp;
.Ve
.PP
(because in particular, simply assigning a weak reference back to itself does
not work to unweaken it; \f(CW\*(C`$REF = $REF\*(C'\fR does not work).
.ie n .SS "$weak = isweak( $ref )"
.el .SS "\f(CW$weak\fP = isweak( \f(CW$ref\fP )"
.IX Subsection "$weak = isweak( $ref )"
Returns true if \f(CW$ref\fR is a weak reference.
.PP
.Vb 4
\&    $ref  = \e$foo;
\&    $weak = isweak($ref);               # false
\&    weaken($ref);
\&    $weak = isweak($ref);               # true
.Ve
.PP
\&\fB\s-1NOTE\s0\fR: Copying a weak reference creates a normal, strong, reference.
.PP
.Vb 2
\&    $copy = $ref;
\&    $weak = isweak($copy);              # false
.Ve
.SH "OTHER FUNCTIONS"
.IX Header "OTHER FUNCTIONS"
.ie n .SS "$var = dualvar( $num, $string )"
.el .SS "\f(CW$var\fP = dualvar( \f(CW$num\fP, \f(CW$string\fP )"
.IX Subsection "$var = dualvar( $num, $string )"
Returns a scalar that has the value \f(CW$num\fR in a numeric context and the value
\&\f(CW$string\fR in a string context.
.PP
.Vb 3
\&    $foo = dualvar 10, "Hello";
\&    $num = $foo + 2;                    # 12
\&    $str = $foo . " world";             # Hello world
.Ve
.ie n .SS "$dual = isdual( $var )"
.el .SS "\f(CW$dual\fP = isdual( \f(CW$var\fP )"
.IX Subsection "$dual = isdual( $var )"
If \f(CW$var\fR is a scalar that has both numeric and string values, the result is
true.
.PP
.Vb 2
\&    $foo = dualvar 86, "Nix";
\&    $dual = isdual($foo);               # true
.Ve
.PP
Note that a scalar can be made to have both string and numeric content through
numeric operations:
.PP
.Vb 4
\&    $foo = "10";
\&    $dual = isdual($foo);               # false
\&    $bar = $foo + 0;
\&    $dual = isdual($foo);               # true
.Ve
.PP
Note that although \f(CW$!\fR appears to be dual-valued variable, it is actually
implemented using a tied scalar:
.PP
.Vb 3
\&    $! = 1;
\&    print("$!\en");                      # "Operation not permitted"
\&    $dual = isdual($!);                 # false
.Ve
.PP
You can capture its numeric and string content using:
.PP
.Vb 2
\&    $err = dualvar $!, $!;
\&    $dual = isdual($err);               # true
.Ve
.ie n .SS "$vstring = isvstring( $var )"
.el .SS "\f(CW$vstring\fP = isvstring( \f(CW$var\fP )"
.IX Subsection "$vstring = isvstring( $var )"
If \f(CW$var\fR is a scalar which was coded as a vstring the result is true.
.PP
.Vb 3
\&    $vs   = v49.46.48;
\&    $fmt  = isvstring($vs) ? "%vd" : "%s"; #true
\&    printf($fmt,$vs);
.Ve
.ie n .SS "$isnum = looks_like_number( $var )"
.el .SS "\f(CW$isnum\fP = looks_like_number( \f(CW$var\fP )"
.IX Subsection "$isnum = looks_like_number( $var )"
Returns true if perl thinks \f(CW$var\fR is a number. See
\&\*(L"looks_like_number\*(R" in perlapi.
.ie n .SS "$fh = openhandle( $fh )"
.el .SS "\f(CW$fh\fP = openhandle( \f(CW$fh\fP )"
.IX Subsection "$fh = openhandle( $fh )"
Returns \f(CW$fh\fR itself if \f(CW$fh\fR may be used as a filehandle and is open, or is
is a tied handle. Otherwise \f(CW\*(C`undef\*(C'\fR is returned.
.PP
.Vb 4
\&    $fh = openhandle(*STDIN);           # \e*STDIN
\&    $fh = openhandle(\e*STDIN);          # \e*STDIN
\&    $fh = openhandle(*NOTOPEN);         # undef
\&    $fh = openhandle("scalar");         # undef
.Ve
.ie n .SS "$ro = readonly( $var )"
.el .SS "\f(CW$ro\fP = readonly( \f(CW$var\fP )"
.IX Subsection "$ro = readonly( $var )"
Returns true if \f(CW$var\fR is readonly.
.PP
.Vb 1
\&    sub foo { readonly($_[0]) }
\&
\&    $readonly = foo($bar);              # false
\&    $readonly = foo(0);                 # true
.Ve
.ie n .SS "$code = set_prototype( $code, $prototype )"
.el .SS "\f(CW$code\fP = set_prototype( \f(CW$code\fP, \f(CW$prototype\fP )"
.IX Subsection "$code = set_prototype( $code, $prototype )"
Sets the prototype of the function given by the \f(CW$code\fR reference, or deletes
it if \f(CW$prototype\fR is \f(CW\*(C`undef\*(C'\fR. Returns the \f(CW$code\fR reference itself.
.PP
.Vb 1
\&    set_prototype \e&foo, \*(Aq$$\*(Aq;
.Ve
.ie n .SS "$t = tainted( $var )"
.el .SS "\f(CW$t\fP = tainted( \f(CW$var\fP )"
.IX Subsection "$t = tainted( $var )"
Return true if \f(CW$var\fR is tainted.
.PP
.Vb 2
\&    $taint = tainted("constant");       # false
\&    $taint = tainted($ENV{PWD});        # true if running under \-T
.Ve
.SH "DIAGNOSTICS"
.IX Header "DIAGNOSTICS"
Module use may give one of the following errors during import.
.IP "Weak references are not implemented in the version of perl" 4
.IX Item "Weak references are not implemented in the version of perl"
The version of perl that you are using does not implement weak references, to
use \f(CW\*(C`isweak\*(C'\fR or \f(CW\*(C`weaken\*(C'\fR you will need to use a newer release of perl.
.IP "Vstrings are not implemented in the version of perl" 4
.IX Item "Vstrings are not implemented in the version of perl"
The version of perl that you are using does not implement Vstrings, to use
\&\f(CW\*(C`isvstring\*(C'\fR you will need to use a newer release of perl.
.ie n .IP """NAME"" is only available with the \s-1XS\s0 version of Scalar::Util" 4
.el .IP "\f(CWNAME\fR is only available with the \s-1XS\s0 version of Scalar::Util" 4
.IX Item "NAME is only available with the XS version of Scalar::Util"
\&\f(CW\*(C`Scalar::Util\*(C'\fR contains both perl and C implementations of many of its
functions so that those without access to a C compiler may still use it.
However some of the functions are only available when a C compiler was
available to compile the \s-1XS\s0 version of the extension.
.Sp
At present that list is: weaken, isweak, dualvar, isvstring, set_prototype
.SH "KNOWN BUGS"
.IX Header "KNOWN BUGS"
There is a bug in perl5.6.0 with \s-1UV\s0's that are >= 1<<31. This will
show up as tests 8 and 9 of dualvar.t failing
.SH "SEE ALSO"
.IX Header "SEE ALSO"
List::Util
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (c) 1997\-2007 Graham Barr <gbarr@pobox.com>. All rights reserved.
This program is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.
.PP
Except weaken and isweak which are
.PP
Copyright (c) 1999 Tuomas J. Lukka <lukka@iki.fi>. All rights reserved.
This program is free software; you can redistribute it and/or modify it
under the same terms as perl itself.
