.\" Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "install::TempContent::Objects::mod_perl-2.0.9::docs::api::APR::ThreadRWLock 3"
.TH install::TempContent::Objects::mod_perl-2.0.9::docs::api::APR::ThreadRWLock 3 "2015-06-18" "perl v5.30.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
APR::ThreadRWLock \- Perl API for APR thread read/write locks
.SH "Synopsis"
.IX Header "Synopsis"
.Vb 1
\&  use APR::ThreadRWLock ();
\&
\&  my $mutex = APR::ThreadRWLock\->new($r\->pool);
\&  $mutex\->rdlock;
\&  $mutex\->wrlock;
\&  $mutex\->tryrdlock;
\&  $mutex\->trywrlock;
\&  $mutex\->unlock;
.Ve
.SH "Description"
.IX Header "Description"
\&\f(CW\*(C`APR::ThreadRWLock\*(C'\fR interfaces \s-1APR\s0 thread read/write locks.
.PP
See \fIsrclib/apr/locks/unix/thread_rwlock.c\fR in your Apache source tree.
At the time of this writing these methods are not supported on all
platforms. Thus, check your libraries!
.SH "API"
.IX Header "API"
\&\f(CW\*(C`APR::ThreadRWLock\*(C'\fR provides the following functions and/or methods:
.SH "Unsupported API"
.IX Header "Unsupported API"
\&\f(CW\*(C`APR::ThreadRWLock\*(C'\fR also provides auto-generated Perl interface for a
few other methods which aren't tested at the moment and therefore
their \s-1API\s0 is a subject to change. These methods will be finalized
later as a need arises. If you want to rely on any of the following
methods please contact the the mod_perl development mailing
list so we can help each other take the steps necessary
to shift the method to an officially supported \s-1API.\s0
.ie n .SS """DESTROY"""
.el .SS "\f(CWDESTROY\fP"
.IX Subsection "DESTROY"
\&\s-1META:\s0 Autogenerated \- needs to be reviewed/completed
.PP
Destroy the lock and free the associated memory.
.PP
.Vb 1
\&  $lock\->DESTROY();
.Ve
.ie n .IP "obj: $lock ( ""APR::ThreadRWLock object"" )" 4
.el .IP "obj: \f(CW$lock\fR ( \f(CWAPR::ThreadRWLock object\fR )" 4
.IX Item "obj: $lock ( APR::ThreadRWLock object )"
the lock to destroy.
.IP "ret: no return value" 4
.IX Item "ret: no return value"
.PD 0
.IP "since: subject to change" 4
.IX Item "since: subject to change"
.PD
.ie n .SS """rdlock"""
.el .SS "\f(CWrdlock\fP"
.IX Subsection "rdlock"
\&\s-1META:\s0 Autogenerated \- needs to be reviewed/completed
.PP
Acquire the read lock for the given lock. The calling thread acquires the
read lock if a writer does not hold the lock and there are  no  writers
blocked on the lock. Otherwize it is put to sleep until these conditions
are met.
.PP
.Vb 1
\&  $ret = $lock\->rdlock();
.Ve
.ie n .IP "obj: $lock ( ""APR::ThreadRWLock object"" )" 4
.el .IP "obj: \f(CW$lock\fR ( \f(CWAPR::ThreadRWLock object\fR )" 4
.IX Item "obj: $lock ( APR::ThreadRWLock object )"
the lock on which to acquire the lock.
.ie n .IP "ret: $ret ( integer )" 4
.el .IP "ret: \f(CW$ret\fR ( integer )" 4
.IX Item "ret: $ret ( integer )"
.PD 0
.IP "since: subject to change" 4
.IX Item "since: subject to change"
.PD
.ie n .SS """tryrdlock"""
.el .SS "\f(CWtryrdlock\fP"
.IX Subsection "tryrdlock"
\&\s-1META:\s0 Autogenerated \- needs to be reviewed/completed
.PP
Performs the same operation as \f(CW\*(C`rdlock\*(C'\fR with the exception that the
function shall fail if the thread would be blocked.
.PP
.Vb 1
\&  $ret = $lock\->tryrdlock();
.Ve
.ie n .IP "obj: $lock ( ""APR::ThreadRWLock object"" )" 4
.el .IP "obj: \f(CW$lock\fR ( \f(CWAPR::ThreadRWLock object\fR )" 4
.IX Item "obj: $lock ( APR::ThreadRWLock object )"
the lock on which to acquire the lock.
.ie n .IP "ret: $ret ( integer )" 4
.el .IP "ret: \f(CW$ret\fR ( integer )" 4
.IX Item "ret: $ret ( integer )"
.PD 0
.IP "since: subject to change" 4
.IX Item "since: subject to change"
.PD
.ie n .SS """wrlock"""
.el .SS "\f(CWwrlock\fP"
.IX Subsection "wrlock"
\&\s-1META:\s0 Autogenerated \- needs to be reviewed/completed
.PP
Acquire the write lock for the given lock. The calling thread acquires the
write lock if if no other thread (reader or writer) holds it. Otherwize it
is put to sleep until this condition is met.
.PP
.Vb 1
\&  $ret = $lock\->wrlock();
.Ve
.ie n .IP "obj: $lock ( ""APR::ThreadRWLock object"" )" 4
.el .IP "obj: \f(CW$lock\fR ( \f(CWAPR::ThreadRWLock object\fR )" 4
.IX Item "obj: $lock ( APR::ThreadRWLock object )"
the lock on which to acquire the lock.
.ie n .IP "ret: $ret ( integer )" 4
.el .IP "ret: \f(CW$ret\fR ( integer )" 4
.IX Item "ret: $ret ( integer )"
.PD 0
.IP "since: subject to change" 4
.IX Item "since: subject to change"
.PD
.ie n .SS """trywrlock"""
.el .SS "\f(CWtrywrlock\fP"
.IX Subsection "trywrlock"
\&\s-1META:\s0 Autogenerated \- needs to be reviewed/completed
.PP
Performs the same operation as \f(CW\*(C`wrlock\*(C'\fR with the exception that the
function shall fail if the thread would be blocked.
.PP
.Vb 1
\&  $ret = $lock\->trywrlock();
.Ve
.ie n .IP "obj: $lock ( ""APR::ThreadRWLock object"" )" 4
.el .IP "obj: \f(CW$lock\fR ( \f(CWAPR::ThreadRWLock object\fR )" 4
.IX Item "obj: $lock ( APR::ThreadRWLock object )"
the lock on which to acquire the lock.
.ie n .IP "ret: $ret ( integer )" 4
.el .IP "ret: \f(CW$ret\fR ( integer )" 4
.IX Item "ret: $ret ( integer )"
.PD 0
.IP "since: subject to change" 4
.IX Item "since: subject to change"
.PD
.ie n .SS """new"""
.el .SS "\f(CWnew\fP"
.IX Subsection "new"
Create a new lock
.PP
.Vb 1
\&  my $lock = APR::ThreadRWLock\->new($p);
.Ve
.ie n .IP "obj: ""APR::ThreadRWLock"" ( class name )" 4
.el .IP "obj: \f(CWAPR::ThreadRWLock\fR ( class name )" 4
.IX Item "obj: APR::ThreadRWLock ( class name )"
.PD 0
.ie n .IP "arg1: $p ( ""APR::Pool object"" )" 4
.el .IP "arg1: \f(CW$p\fR ( \f(CWAPR::Pool object\fR )" 4
.IX Item "arg1: $p ( APR::Pool object )"
.ie n .IP "ret: $lock ( ""APR::ThreadRWLock object"" )" 4
.el .IP "ret: \f(CW$lock\fR ( \f(CWAPR::ThreadRWLock object\fR )" 4
.IX Item "ret: $lock ( APR::ThreadRWLock object )"
.IP "since: subject to change" 4
.IX Item "since: subject to change"
.PD
.ie n .SS """pool_get"""
.el .SS "\f(CWpool_get\fP"
.IX Subsection "pool_get"
\&\s-1META:\s0 Autogenerated \- needs to be reviewed/completed
.PP
\&\s-1META:\s0 should probably be renamed to \fBpool()\fR, like all other pool
accessors
.PP
Get the pool used by this thread_lock.
.PP
.Vb 1
\&  $ret = $obj\->pool_get();
.Ve
.ie n .IP "obj: $obj ( ""APR::ThreadRWLock object"" )" 4
.el .IP "obj: \f(CW$obj\fR ( \f(CWAPR::ThreadRWLock object\fR )" 4
.IX Item "obj: $obj ( APR::ThreadRWLock object )"
.PD 0
.ie n .IP "ret: $ret ( ""APR::Pool object"" )" 4
.el .IP "ret: \f(CW$ret\fR ( \f(CWAPR::Pool object\fR )" 4
.IX Item "ret: $ret ( APR::Pool object )"
.PD
apr_pool_t the pool
.IP "since: subject to change" 4
.IX Item "since: subject to change"
.ie n .SS """unlock"""
.el .SS "\f(CWunlock\fP"
.IX Subsection "unlock"
\&\s-1META:\s0 Autogenerated \- needs to be reviewed/completed
.PP
Release the lock for the given lock.
.PP
.Vb 1
\&  $ret = $lock\->unlock();
.Ve
.ie n .IP "obj: $lock ( ""APR::ThreadRWLock object"" )" 4
.el .IP "obj: \f(CW$lock\fR ( \f(CWAPR::ThreadRWLock object\fR )" 4
.IX Item "obj: $lock ( APR::ThreadRWLock object )"
the lock from which to release the lock.
.ie n .IP "ret: $ret ( integer )" 4
.el .IP "ret: \f(CW$ret\fR ( integer )" 4
.IX Item "ret: $ret ( integer )"
.PD 0
.IP "since: subject to change" 4
.IX Item "since: subject to change"
.PD
.SH "See Also"
.IX Header "See Also"
mod_perl 2.0 documentation.
.SH "Copyright"
.IX Header "Copyright"
mod_perl 2.0 and its core modules are copyrighted under
The Apache Software License, Version 2.0.
.SH "Authors"
.IX Header "Authors"
The mod_perl development team and numerous
contributors.
