.\" Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Pegex::Tutorial::JSON 3"
.TH Pegex::Tutorial::JSON 3 "2020-02-13" "perl v5.30.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "How to write a JSON Parser in Pegex"
.IX Header "How to write a JSON Parser in Pegex"
This document details the creation of the \s-1CPAN\s0 module: Pegex::JSON which is
a \s-1JSON\s0 parser/decoder written in Perl using the Pegex parsing framework. The
code lives on github here: <https://github.com/ingydotnet/pegex\-json\-pm>.
.SH "Test First"
.IX Header "Test First"
Have a look at
<https://github.com/ingydotnet/pegex\-json\-pm/blob/master/test/test.t>.
This simple test has a bunch of small pieces of
\&\s-1JSON\s0 and their \s-1YAML\s0 equivalents. It asserts that when the \s-1JSON\s0 is decoded, it
will match the \s-1YAML.\s0
.PP
The test is written in a testing language known as TestML. TestML just happens
to also use Pegex in its compiler. Both TestML and Pegex are \fBAcmeist\fR
frameworks, meaning that they are intended to work in multiple programming
languages.
.PP
You can run the test like normal:
.PP
.Vb 1
\&    > prove \-lv t/test.t
.Ve
.SH "The Pegex JSON Grammar"
.IX Header "The Pegex JSON Grammar"
The next thing to do is write the \s-1JSON\s0 grammar in the Pegex grammar language.
Writing grammars is the heart and soul of using Pegex. A grammar is simply a
definition of a language that specifies what is what, and how it must be
structured.
.PP
Since Pegex is Acmeist, I put the \s-1JSON\s0 grammar in its own repo so that it
could be shared by many different projects in different programming languages.
The grammar file is here:
<https://github.com/ingydotnet/json\-pgx/blob/master/json.pgx>.
.PP
Let's look at this small but complete language definition in detail.
.PP
The file starts with some comments. Comments can be used liberally in Pegex
and go from a '#' to the end of a line. Just as you would expect.
.PP
.Vb 3
\&    # A simple grammar for the simple JSON data language.
\&    # For parser implementations that use this grammar, see:
\&    # * https://github.com/ingydotnet/pegex\-json\-pm
.Ve
.PP
Next we have what is called the Meta section of the grammar.
.PP
.Vb 2
\&    %grammar json
\&    %version 0.0.1
.Ve
.PP
Meta section lines are of the form:
.PP
.Vb 1
\&    %key value
.Ve
.PP
Your grammar should have at least a name and a version.
.PP
Everything else in the grammar is a set of things called \*(L"rules\*(R". A rule has a
name and a definition. The first rule in a grammar is special. When a parser
starts parsing it defaults to using the first rule as the starting rule
(although this can be overridden).
.PP
We start the \s-1JSON\s0 grammar with this rule:
.PP
.Vb 1
\&    json: map | seq
.Ve
.PP
The name of this rule is 'json'. When we start parsing \s-1JSON\s0 we say that the
entire text must match the rule 'json'. This makes a lot of sense.
.PP
This style of parsing is known as Top Down and Recursive Descent. Pegex is
both of these. It should be noted that Pegex does not tokenize a text before
parsing it. The rules themselves form a kind of tokenizer, pulling out the
desired data segments as needed.
.PP
In this rule, we are saying that a 'json' document is either a 'map' (aka
mapping or hash) \s-1OR\s0 it is a 'seq' (aka sequence or array), which assuming you
know \s-1JSON\s0 (almost everybody does), is the only thing allowed at the top level.
.PP
In this rule, 'map' and 'seq' are called 'rule \fIreferences\fR'. They point to
other named rules that are expected to be in the grammar. References are
usually just the name of the subrule itself, but can also be enclosed in angle
brackets (which are sometimes required). ie the rule above could also be
written like this:
.PP
.Vb 1
\&    json: map | seq
.Ve
.PP
We are also introduced to the \s-1OR\s0 operator which is a single \s-1PIPE\s0 character. It
should also be noted that a \s-1COLON\s0 simply separates a rule name and its
definition.
.PP
The next line defines a new rule called 'node':
.PP
.Vb 1
\&    node: map | seq | scalar
.Ve
.PP
We are calling 'node' the list of general structures that any given point in
the \s-1JSON\s0 data graph can be. This is simply a mapping, sequence or scalar.
.PP
Moving on, we need rules describing 'map', 'seq' 'scalar'. A grammar is
complete when all of its rule references are defined.
.PP
Let's start with map:
.PP
.Vb 4
\&    map:
\&        /\- LCURLY \-/
\&        pair* % /\- COMMA \-/
\&        /\- RCURLY \-/
.Ve
.PP
This seems a lot more complicated, but let's break things down, one at a time.
What we will find this rule to mean, is that a map is a '{' followed by zero
or more (key/value) pairs separated by a comma, then ending with a '}'. Along
the way there may also be intermittent whitespace. The '\-' character indicates
whitespace, but we'll cover that more later.
.PP
The first thing we notice is that a rule definition can span multiple lines. A
rule definition ends when the next rule begins. Pegex actually allows for
multiple rules on one line, but they must be separated by semicolons, like so:
.PP
.Vb 1
\&    rule1: a|b; rule2: c|d; rule3: e|f
.Ve
.PP
The next thing we see are forward slash characters. Like in Perl and
JavaScript, a pair of slashes indicate a regular expression. In this rule we
have 3 regular expressions.
.PP
It is a good time to note that Pegex grammars get compiled into a simple data
structure that you can express as \s-1JSON\s0 or \s-1YAML.\s0 In fact the repository
containing the Pegex grammar that we are discussing also contains the matching
compiled forms. See:
<https://github.com/ingydotnet/json\-pgx/blob/master/json.pgx.yaml>.
A quick glance at this file shows all the same
rule definitions, but the regexes look much different.
.PP
That's because Pegex tries to make regexes readable and composable. That means
that complex regexes can be defined as small parts that get composed into
bigger parts. By the time they get compiled, they can be quite hard to
understand.
.PP
For example if we had this Pegex grammar:
.PP
.Vb 3
\&    greeting: / hello COMMA \- world /
\&    hello: / (:\*(AqO\*(Aq SPACE \*(AqHAI\*(Aq | \*(AqHey\*(Aq SPACE \*(Aqthere\*(Aq) /
\&    world: / (:Earth|Mars|Venus) /
.Ve
.PP
It would compile to:
.PP
.Vb 2
\&    greeting:
\&      .rgx: (?:O\e HAI|Hey\e there),\es*(?:Earth|Mars|Venus)
.Ve
.PP
Note the the 'hello' and 'world' rules are gone, but their definitions have
been baked into the one big regex for 'greeting'.
.PP
Additionally there are references to things like \s-1COMMA\s0 and \s-1SPACE.\s0 These are
called Pegex \fBAtoms\fR, and there are atoms for all the punctuation characters,
whitespace chars, and others. The full list is here: Pegex::Grammar::Atoms.
.PP
Having to write out '\s-1SEMI\s0' instead of ';' seems strange at first, but it is
how Pegex easily separates metasyntax from text to be matched. Once you get
used to it, it is very readable.
.PP
The actual whitespace (and comments) inside a regex are completely ignored by
Pegex. This is the same as Perl's 'x' regex flag.
.PP
Finally the '\-' is Pegex's 'possible whitespace' indicator, and usually
expands to \f(CW\*(C`\es*\*(C'\fR. It actually expands to \f(CW\*(C`ws1\*(C'\fR, which expands to \f(CW\*(C`ws*\*(C'\fR,
which expands to \f(CW\*(C`WS*\*(C'\fR, which expands to \f(CW\*(C`\es*\*(C'\fR (unless you override any of
those rules).
.PP
Getting back to \s-1JSON...\s0
.PP
The rule we defined for 'map' should now be more readable. Let's look at it
again, but this time in a more compact form:
.PP
.Vb 1
\&    map: /\- LCURLY \-/   (pair* % /\- COMMA \-/)   /\- RCURLY \-/
.Ve
.PP
I've compacted the regexes (since they just mean curlies and commas with
possible whitespace), and I've added parentheses around the middle stuff to
indicate the the '%' operator has a tighter binding.
.PP
So what is the '%' operator? It was borrowed from Perl 6 Rules. Consider:
.PP
.Vb 1
\&    a+ % b
.Ve
.PP
This means one or more 'a', separated by 'b'. Simple. The %% operator means
the same thing, except it indicates that a trailing 'b' is \s-1OK.\s0
.PP
This notation is handy for things like comma separated lists. (Which is
exactly what we are using it for here.)
.PP
The rule above means zero or more 'pair's separated by commas. (trailing comma
not allowed, which is strictly correct for \s-1JSON\s0).
.PP
Now is a good time to bring up 'rule \fIquantifiers\fR'. A rule quantifier is a
suffix to a rule reference, and can be one of ? * or +. These suffixes mean
the same thing that they would in regexes.
.PP
There are two other quantifier suffixes. '2+' is equivalent to the regex
syntax {2,} and 2\-5 is the same as {2,5}. When you use one of these two forms,
you need to put the rule reference in angle brackets, or else the number looks
like part of the rule name. For example:
.PP
.Vb 1
\&    rule1: <rule2>5\-9 <rule3>29+
.Ve
.PP
not:
.PP
.Vb 1
\&    rule1: rule25\-9 rule329+
.Ve
.PP
Let's take a look at that rule after Pegex compilation:
.PP
.Vb 8
\&    map:
\&      .all:
\&      \- .rgx: \es*\e{\es*
\&      \- +min: 0
\&        .ref: pair
\&        .sep:
\&          .rgx: \es*,\es*
\&      \- .rgx: \es*\e}\es*
.Ve
.PP
The rule for 'map' says that the text must match 3 thing: a regex (opening
curly brace), zero or more occurrences of a rule called 'pair' separated by a
regex (comma), and finally another regex (closing curly).
.PP
One thing that we have silently covered is the \s-1AND\s0 operator. That's because
there is no operator symbol for it. Consider the rules:
.PP
.Vb 3
\&    a: b c+ /d/
\&    b: c | d
\&    c: d e | f % g
.Ve
.PP
The \s-1PIPE\s0 character between 2 things means \s-1OR.\s0 No symbol between 2 things means
\&\s-1AND. A PERCENT\s0 means \s-1ALTERNATION. ALTERNATION\s0 binds tightest and \s-1OR\s0 binds
loosest, with \s-1AND\s0 in the middle. Precedence can be disambiguated with
parentheses. Thus the rule for 'c' can be restated:
.PP
.Vb 1
\&    c: ((d e) | (f % g))
.Ve
.PP
\&\s-1OK. I\s0 think we've covered just about everything needed so far. That was a lot
of learning for one rule, but now you know most of Pegex!
.PP
The next three rules need no new knowledge. Take a look at these and see if
you can figure them out.
.PP
.Vb 4
\&    pair:
\&        string
\&        /\- COLON \-/
\&        node
\&
\&    seq:
\&        /\- LSQUARE \-/
\&        node* % /\- COMMA \-/
\&        /\- RSQUARE \-/
\&
\&    scalar:
\&        string |
\&        number |
\&        boolean |
\&        null
.Ve
.PP
A pair (you know... a hash key/value), is a string, a colon, and some node. A
seq is zero or more comma-separated nodes between square brackets. A scalar
can be one of 4 forms. Simple.
.PP
One interesting point is that has just arisen here, is the use of recursion.
The rules for pair and seq both reference the rule for node. Thus, the grammar
is recursive descent. It starts with the rule for the thing as a whole (ie
\&'json') and descends (recursively) until it matches all the specific
characters.
.SS "Pegex Regexes in More Depth"
.IX Subsection "Pegex Regexes in More Depth"
Next we have the definition for a \s-1JSON\s0 string:
.PP
.Vb 10
\&    # string and number are interpretations of http://www.json.org/
\&    string: /
\&        DOUBLE
\&            (
\&                (:
\&                    BACK (:       # Backslash escapes
\&                        [
\&                            DOUBLE      # Double Quote
\&                            BACK        # Back Slash
\&                            SLASH       # Forward Slash
\&                            b           # Back Space
\&                            f           # Form Feed
\&                            n           # New Line
\&                            r           # Carriage Return
\&                            t           # Horizontal Tab
\&                        ]
\&                    |
\&                        u HEX{4}        # Unicode octet pair
\&                    )
\&                |
\&                    [^ DOUBLE CONTROLS ]  # Anything else
\&                )*
\&            )
\&        DOUBLE
\&    /
.Ve
.PP
which Pegex compiles to this (simple and obvious;) regex:
.PP
.Vb 1
\&    /"((?:\e\e(?:["\e\e/bfnrt]|u[0\-9a\-fA\-F]{4})|[^"\ex00\-\ex1f])*)"/
.Ve
.PP
Let's see what's new here...
.PP
First off, we have lots of whitespace and comments. This should make it pretty
easy to at least get the overall picture of what is being accomplished.
.PP
Understanding how the text between a pair of '/' characters gets transformed
into a real regular expression, is the key to really understanding Pegex.
.PP
Notice the '*', the '{4}', the '|', the '(...)' and the '^...'. All of this
punctuation gets passed on verbatim into the compiled regex. There are just a
few exceptions. Let's cover them in detail.
.PP
Everything inside \f(CW\*(C`<some_rule_ref>\*(C'\fR gets replaced by the regex that the
reference points to. Rule references inside a regex \fBmust\fR point directly to
another reference, although those rules can point to even more regex parts.
.PP
The \f(CW\*(C`\-\*(C'\fR characters get replaced by 'ws1', which is subsequently replaced by
its rule definition. \f(CW\*(C`+\*(C'\fR gets replaced by \f(CW\*(C`ws2\*(C'\fR (which resolves to \f(CW\*(C`\es+\*(C'\fR
by default).
.PP
Finally '(:' gets replaced by '(?:)'. This is simply to make your non\-
capturing paren syntax be a little prettier. In general, you can leave out '?'
after a '(' and Pegex will put them in for you.
.PP
That's it. Everything else that you put between slash characters, will go
verbatim into the regex.
.PP
In some sense, Pegex is just a very highly organized way to write a parser
from regular expressions. To be really good at Pegex \fBdoes\fR require fairly
solid understanding of how regexes work, but given that regexes are so very
common, Pegex makes the task of turning them into a Parser, quite simple.
.SS "Capturing Data"
.IX Subsection "Capturing Data"
The next thing to cover is regex \fIcapturing\fR. When you are parsing data, it
is generally important to pull out certain chunks of text so that you can do
things with them.
.PP
Pegex has one very simple, straightforward and obvious way to do this:
Any capturing parens in any regexes will capture data and pass it on to
the \fIreceiver\fR object. Since Pegex is built over regexes, this make
perfect sense.
.PP
We will talk about receiver objects in the next section. For now, just know
that a receiver object is the thing that makes something out of the data and
events matched during a parse. In our \s-1JSON\s0 case here, our receiver will make a
Perl data structure that matches the \s-1JSON\s0 we are parsing. Obvious!
.PP
In the rule for 'string' above, we are capturing the characters between the
double quotes. This is the raw data that will be turned into a Perl scalar.
.SS "Finishing up the \s-1JSON\s0 Grammar"
.IX Subsection "Finishing up the JSON Grammar"
There are just 5 more simple rules needed to complete the \s-1JSON\s0 Pegex grammar:
.PP
.Vb 6
\&    number: /(
\&        DASH?
\&        (: 0 | [1\-9] DIGIT* )
\&        (: DOT DIGIT* )?
\&        (: [eE] [ DASH PLUS ]? DIGIT+ )?
\&    )/
\&
\&    boolean: true | false
\&
\&    true: /true/
\&
\&    false: /false/
\&
\&    null: /null/
.Ve
.PP
Note that the rule for 'number' captures data, but the other rules don't.
That's because as long as the receiver is told that a 'null' rule was
matched, it can turn it into a Perl \f(CW\*(C`undef\*(C'\fR. It's not important what the
actual matching text was (even though in this case it has to be exactly the
string 'null').
.SH "Pegex::JSON::Grammar \- The Pegex Grammar Class"
.IX Header "Pegex::JSON::Grammar - The Pegex Grammar Class"
The Pegex \s-1JSON\s0 grammar that we just looked at in excruciating detail gets
compiled into a Perl data structure and then embedded into a grammar class. A
Pegex::Parser object (the thing that does the parsing) requires a grammar
object (what to look for) and a receiver object (what to do when you find it).
.PP
It should be noted that Pegex uses Pegex to parse Pegex grammars. That is,
this grammar: <https://github.com/ingydotnet/pegex\-pgx/blob/master/pegex.pgx>
is used by Pegex to parse our json.pgx grammar (and yes, it can parse
pegex.pgx too).
.PP
It is conceivable that every time we wanted to parse \s-1JSON,\s0 we could parse the
json.pgx grammar first, but that would be a waste of time. So we cache the big
grammar tree as a pure Perl data structure inside Pegex::JSON::Grammar.
.PP
If for some reason we did need to change the json.pgx, we would have to
recompile it to Perl and copy/paste it into our module. This would be a pain,
so there is a special command to do it for us. Just run this:
.PP
.Vb 1
\&    perl \-Ilib \-MPegex::JSON:Grammar=compile
.Ve
.PP
If you are in heavy development mode and changing the grammar a lot, you can
simply set an environment variable like this:
.PP
.Vb 1
\&    export PERL_PEGEX_AUTO_COMPILE=Pegex::JSON::Grammar
.Ve
.PP
and recompilation will happen automatically. This is possible because of this
line in the grammar module:
.PP
.Vb 1
\&    use constant file => \*(Aq../json\-pgx/json.pgx\*(Aq;
.Ve
.PP
That line is only used during development and requires the grammar file to be
in that location.
.SH "Pegex::JSON::Data \- The Pegex Receiver Class"
.IX Header "Pegex::JSON::Data - The Pegex Receiver Class"
Every Pegex parse requires a grammar object (the \s-1JSON\s0 grammar), and input
object (the \s-1JSON\s0 being parsed) and a receiver object (the Perl maker).
.PP
One of the hallmarks of Pegex, is that it keeps the grammar separate from the
(receiver) code, thus
