.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Module::Build::Authoring 3pm"
.TH Module::Build::Authoring 3pm "2014-09-30" "perl v5.18.4" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Module::Build::Authoring \- Authoring Module::Build modules
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
When creating a \f(CW\*(C`Build.PL\*(C'\fR script for a module, something like the
following code will typically be used:
.PP
.Vb 12
\&  use Module::Build;
\&  my $build = Module::Build\->new
\&    (
\&     module_name => \*(AqFoo::Bar\*(Aq,
\&     license  => \*(Aqperl\*(Aq,
\&     requires => {
\&                  \*(Aqperl\*(Aq          => \*(Aq5.6.1\*(Aq,
\&                  \*(AqSome::Module\*(Aq  => \*(Aq1.23\*(Aq,
\&                  \*(AqOther::Module\*(Aq => \*(Aq>= 1.2, != 1.5, < 2.0\*(Aq,
\&                 },
\&    );
\&  $build\->create_build_script;
.Ve
.PP
A simple module could get away with something as short as this for its
\&\f(CW\*(C`Build.PL\*(C'\fR script:
.PP
.Vb 5
\&  use Module::Build;
\&  Module::Build\->new(
\&    module_name => \*(AqFoo::Bar\*(Aq,
\&    license     => \*(Aqperl\*(Aq,
\&  )\->create_build_script;
.Ve
.PP
The model used by \f(CW\*(C`Module::Build\*(C'\fR is a lot like the \f(CW\*(C`MakeMaker\*(C'\fR
metaphor, with the following correspondences:
.PP
.Vb 5
\&   In Module::Build                 In ExtUtils::MakeMaker
\&  \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-      \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&   Build.PL (initial script)        Makefile.PL (initial script)
\&   Build (a short perl script)      Makefile (a long Makefile)
\&   _build/ (saved state info)       various config text in the Makefile
.Ve
.PP
Any customization can be done simply by subclassing \f(CW\*(C`Module::Build\*(C'\fR
and adding a method called (for example) \f(CW\*(C`ACTION_test\*(C'\fR, overriding
the default 'test' action.  You could also add a method called
\&\f(CW\*(C`ACTION_whatever\*(C'\fR, and then you could perform the action \f(CW\*(C`Build
whatever\*(C'\fR.
.PP
For information on providing compatibility with
\&\f(CW\*(C`ExtUtils::MakeMaker\*(C'\fR, see Module::Build::Compat and
<http://www.makemaker.org/wiki/index.cgi?ModuleBuildConversionGuide>.
.SH "STRUCTURE"
.IX Header "STRUCTURE"
Module::Build creates a class hierarchy conducive to customization.
Here is the parent-child class hierarchy in classy \s-1ASCII\s0 art:
.PP
.Vb 10
\&   /\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\e
\&   |   Your::Parent     |  (If you subclass Module::Build)
\&   \e\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-/
\&            |
\&            |
\&   /\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\e  (Doesn\*(Aqt define any functionality
\&   |   Module::Build    |   of its own \- just figures out what
\&   \e\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-/   other modules to load.)
\&            |
\&            |
\&   /\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\e  (Some values of $^O may
\&   |   Module::Build::Platform::$^O    |   define specialized functionality.
\&   \e\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-/   Otherwise it\*(Aqs ...::Default, a
\&            |                              pass\-through class.)
\&            |
\&   /\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\e
\&   |   Module::Build::Base    |  (Most of the functionality of 
\&   \e\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-/   Module::Build is defined here.)
.Ve
.SH "SUBCLASSING"
.IX Header "SUBCLASSING"
Right now, there are two ways to subclass Module::Build.  The first
way is to create a regular module (in a \f(CW\*(C`.pm\*(C'\fR file) that inherits
from Module::Build, and use that module's class instead of using
Module::Build directly:
.PP
.Vb 2
\&  \-\-\-\-\-\- in Build.PL: \-\-\-\-\-\-\-\-\-\-
\&  #!/usr/bin/perl
\&
\&  use lib q(/nonstandard/library/path);
\&  use My::Builder;  # Or whatever you want to call it
\&
\&  my $build = My::Builder\->new
\&    (
\&     module_name => \*(AqFoo::Bar\*(Aq,  # All the regular args...
\&     license     => \*(Aqperl\*(Aq,
\&     dist_author => \*(AqA N Other <me@here.net.au>\*(Aq,
\&     requires    => { Carp => 0 }
\&    );
\&  $build\->create_build_script;
.Ve
.PP
This is relatively straightforward, and is the best way to do things
if your My::Builder class contains lots of code.  The
\&\f(CW\*(C`create_build_script()\*(C'\fR method will ensure that the current value of
\&\f(CW@INC\fR (including the \f(CW\*(C`/nonstandard/library/path\*(C'\fR) is propagated to
the Build script, so that My::Builder can be found when running build
actions.  If you find that you need to \f(CW\*(C`chdir\*(C'\fR into a different directories
in your subclass methods or actions, be sure to always return to the original
directory (available via the \f(CW\*(C`base_dir()\*(C'\fR method) before returning control
to the parent class.  This is important to avoid data serialization problems.
.PP
For very small additions, Module::Build provides a \f(CW\*(C`subclass()\*(C'\fR
method that lets you subclass Module::Build more conveniently, without
creating a separate file for your module:
.PP
.Vb 2
\&  \-\-\-\-\-\- in Build.PL: \-\-\-\-\-\-\-\-\-\-
\&  #!/usr/bin/perl
\&
\&  use Module::Build;
\&  my $class = Module::Build\->subclass
\&    (
\&     class => \*(AqMy::Builder\*(Aq,
\&     code => q{
\&       sub ACTION_foo {
\&         print "I\*(Aqm fooing to death!\en";
\&       }
\&     },
\&    );
\&
\&  my $build = $class\->new
\&    (
\&     module_name => \*(AqFoo::Bar\*(Aq,  # All the regular args...
\&     license     => \*(Aqperl\*(Aq,
\&     dist_author => \*(AqA N Other <me@here.net.au>\*(Aq,
\&     requires    => { Carp => 0 }
\&    );
\&  $build\->create_build_script;
.Ve
.PP
Behind the scenes, this actually does create a \f(CW\*(C`.pm\*(C'\fR file, since the
code you provide must persist after Build.PL is run if it is to be
very useful.
.PP
See also the documentation for the \*(L"\fIsubclass()\fR\*(R" in Module::Build::API
method.
.SH "PREREQUISITES"
.IX Header "PREREQUISITES"
.SS "Types of prerequisites"
.IX Subsection "Types of prerequisites"
To specify what versions of other modules are used by this
distribution, several types of prerequisites can be defined with the
following parameters:
.IP "configure_requires" 3
.IX Item "configure_requires"
Items that must be installed \fIbefore\fR configuring this distribution
(i.e. before running the \fIBuild.PL\fR script).  This might be a
specific minimum version of \f(CW\*(C`Module::Build\*(C'\fR or any other module the
\&\fIBuild.PL\fR needs in order to do its stuff.  Clients like \f(CW\*(C`CPAN.pm\*(C'\fR
or \f(CW\*(C`CPANPLUS\*(C'\fR will be expected to pick \f(CW\*(C`configure_requires\*(C'\fR out of the
\&\fI\s-1META\s0.yml\fR file and install these items before running the
\&\f(CW\*(C`Build.PL\*(C'\fR.
.Sp
If no configure_requires is specified, the current version of Module::Build
is automatically added to configure_requires.
.IP "build_requires" 3
.IX Item "build_requires"
Items that are necessary for building and testing this distribution,
but aren't necessary after installation.  This can help users who only
want to install these items temporarily.  It also helps reduce the
size of the \s-1CPAN\s0 dependency graph if everything isn't smooshed into
\&\f(CW\*(C`requires\*(C'\fR.
.IP "requires" 3
.IX Item "requires"
Items that are necessary for basic functioning.
.IP "recommends" 3
.IX Item "recommends"
Items that are recommended for enhanced functionality, but there are
ways to use this distribution without having them installed.  You
might also think of this as \*(L"can use\*(R" or \*(L"is aware of\*(R" or \*(L"changes
behavior in the presence of\*(R".
.IP "conflicts" 3
.IX Item "conflicts"
Items that can cause problems with this distribution when installed.
This is pretty rare.
.SS "Format of prerequisites"
.IX Subsection "Format of prerequisites"
The prerequisites are given in a hash reference, where the keys are
the module names and the values are version specifiers:
.PP
.Vb 6
\&  requires => {
\&               Foo::Module => \*(Aq2.4\*(Aq,
\&               Bar::Module => 0,
\&               Ken::Module => \*(Aq>= 1.2, != 1.5, < 2.0\*(Aq,
\&               perl => \*(Aq5.6.0\*(Aq
\&              },
.Ve
.PP
The above four version specifiers have different effects.  The value
\&\f(CW\*(Aq2.4\*(Aq\fR means that \fBat least\fR version 2.4 of \f(CW\*(C`Foo::Module\*(C'\fR must be
installed.  The value \f(CW0\fR means that \fBany\fR version of \f(CW\*(C`Bar::Module\*(C'\fR
is acceptable, even if \f(CW\*(C`Bar::Module\*(C'\fR doesn't define a version.  The
more verbose value \f(CW\*(Aq>= 1.2, != 1.5, < 2.0\*(Aq\fR means that
\&\f(CW\*(C`Ken::Module\*(C'\fR's version must be \fBat least\fR 1.2, \fBless than\fR 2.0,
and \fBnot equal to\fR 1.5.  The list of criteria is separated by commas,
and all criteria must be satisfied.
.PP
A special \f(CW\*(C`perl\*(C'\fR entry lets you specify the versions of the Perl
interpreter that are supported by your module.  The same version
dependency-checking semantics are available, except that we also
understand perl's new double-dotted version numbers.
.SS "\s-1XS\s0 Extensions"
.IX Subsection "XS Extensions"
Modules which need to compile \s-1XS\s0 code should list \f(CW\*(C`ExtUtils::CBuilder\*(C'\fR
as a \f(CW\*(C`build_requires\*(C'\fR element.
.SH "SAVING CONFIGURATION INFORMATION"
.IX Header "SAVING CONFIGURATION INFORMATION"
Module::Build provides a very convenient way to save configuration
information that your installed modules (or your regression tests) can
access.  If your Build process calls the \f(CW\*(C`feature()\*(C'\fR or
\&\f(CW\*(C`config_data()\*(C'\fR methods, then a \f(CW\*(C`Foo::Bar::ConfigData\*(C'\fR module will
automatically be created for you, where \f(CW\*(C`Foo::Bar\*(C'\fR is the
\&\f(CW\*(C`module_name\*(C'\fR parameter as passed to \f(CW\*(C`new()\*(C'\fR.  This module provides
access to the data saved by these methods, and a way to update the
values.  There is also a utility script called \f(CW\*(C`config_data\*(C'\fR
distributed with Module::Build that provides a command line interface
to this same functionality.  See also the generated
\&\f(CW\*(C`Foo::Bar::ConfigData\*(C'\fR documentation, and the \f(CW\*(C`config_data\*(C'\fR
script's documentation, for more information.
.SH "STARTING MODULE DEVELOPMENT"
.IX Header "STARTING MODULE DEVELOPMENT"
When starting development on a new module, it's rarely worth your time
to create a tree of all the files by hand.  Some automatic
module-creators are available: the oldest is \f(CW\*(C`h2xs\*(C'\fR, which has
shipped with perl itself for a long time.  Its name reflects the fact
that modules were originally conceived of as a way to wrap up a C
library (thus the \f(CW\*(C`h\*(C'\fR part) into perl extensions (thus the \f(CW\*(C`xs\*(C'\fR
part).
.PP
These days, \f(CW\*(C`h2xs\*(C'\fR has largely been superseded by modules like
\&\f(CW\*(C`ExtUtils::ModuleMaker\*(C'\fR, and \f(CW\*(C`Module::Starter\*(C'\fR.  They have varying
degrees of support for \f(CW\*(C`Module::Build\*(C'\fR.
.SH "AUTOMATION"
.IX Header "AUTOMATION"
One advantage of Module::Build is that since it's implemented as Perl
methods, you can invoke these methods directly if you want to install
a module non-interactively.  For instance, the following Perl script
will invoke the entire build/install procedure:
.PP
.Vb 4
\&  my $build = Module::Build\->new(module_name => \*(AqMyModule\*(Aq);
\&  $build\->dispatch(\*(Aqbuild\*(Aq);
\&  $build\->dispatch(\*(Aqtest\*(Aq);
\&  $build\->dispatch(\*(Aqinstall\*(Aq);
.Ve
.PP
If any of these steps encounters an error, it will throw a fatal
exception.
.PP
You can also pass arguments as part of the build process:
.PP
.Vb 4
\&  my $build = Module::Build\->new(module_name => \*(AqMyModule\*(Aq);
\&  $build\->dispatch(\*(Aqbuild\*(Aq);
\&  $build\->dispatch(\*(Aqtest\*(Aq, verbose => 1);
\&  $build\->dispatch(\*(Aqinstall\*(Aq, sitelib => \*(Aq/my/secret/place/\*(Aq);
.Ve
.PP
Building and installing modules in this way skips creating the
\&\f(CW\*(C`Build\*(C'\fR script.
.SH "MIGRATION"
.IX Header "MIGRATION"
Note that if you want to provide both a \fIMakefile.PL\fR and a
\&\fIBuild.PL\fR for your distribution, you probably want to add the
following to \f(CW\*(C`WriteMakefile\*(C'\fR in your \fIMakefile.PL\fR so that \f(CW\*(C`MakeMaker\*(C'\fR
doesn't try to run your \fIBuild.PL\fR as a normal \fI.PL\fR file:
.PP
.Vb 1
\&  PL_FILES => {},
.Ve
.PP
You may also be interested in looking at the \f(CW\*(C`Module::Build::Compat\*(C'\fR
module, which can automatically create various kinds of \fIMakefile.PL\fR
compatibility layers.
.SH "AUTHOR"
.IX Header "AUTHOR"
Ken Williams <kwilliams@cpan.org>
.PP
Development questions, bug reports, and patches should be sent to the
Module-Build mailing list at <module\-build@perl.org>.
.PP
Bug reports are also welcome at
<http://rt.cpan.org/NoAuth/Bugs.html?Dist=Module\-Build>.
.PP
The latest development version is available from the Git
repository at <https://github.com/Perl\-Toolchain\-Gang/Module\-Build>
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fIperl\fR\|(1), Module::Build(3), Module::Build::API(3),
Module::Build::Cookbook(3), ExtUtils::MakeMaker(3), \s-1YAML\s0(3)
.PP
\&\fI\s-1META\s0.yml\fR Specification:
CPAN::META::Spec
.PP
<http://www.dsmit.com/cons/>
.PP
<http://search.cpan.org/dist/PerlBuildSystem/>
