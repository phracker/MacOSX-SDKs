.\" Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Mail::DKIM::ARC::Verifier 3"
.TH Mail::DKIM::ARC::Verifier 3 "2019-11-13" "perl v5.30.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Mail::DKIM::ARC::Verifier \- verifies an ARC\-Sealed message
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use Mail::DKIM::ARC::Verifier;
\&
\&  # create a verifier object
\&  my $arc = Mail::DKIM::ARC::Verifier\->new();
\&
\&  # read an email from a file handle
\&  $arc\->load(*STDIN);
\&
\&  # or read an email and pass it into the verifier, incrementally
\&  while (<STDIN>)
\&  {
\&      # remove local line terminators
\&      chomp;
\&      s/\e015$//;
\&
\&      # use SMTP line terminators
\&      $arc\->PRINT("$_\e015\e012");
\&  }
\&  $arc\->CLOSE;
\&
\&  # what is the result of the verify?
\&  my $result = $arc\->result;
\&
\&  # print the results for all the message\-signatures and seals on the message
\&  foreach my $signature ($arc\->signatures)
\&  {
\&      print $signature\->prefix() . \*(Aq v=\*(Aq . $signature\->instance .
\&                                     \*(Aq \*(Aq . $signature\->result_detail . "\en";
\&  }
\&
\&  # example output.  Note that to pass, only the MOST RECENT ARC\-Message\-Signature
\&  # must match, because other steps may have modified the signature.  What matters
\&  # is that all ARC\-Seals pass, and the most recent ARC\-Message\-Signature passes.
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The verifier object allows an email message to be scanned for \s-1ARC\s0
seals and their associated signatures to be verified. The verifier
tracks the state of the message as it is read into memory. When the
message has been completely read, the signatures are verified and the
results of the verification can be accessed.
.PP
To use the verifier, first create the verifier object. Then start
\&\*(L"feeding\*(R" it the email message to be verified. When all the _headers_
have been read, the verifier:
.PP
.Vb 4
\& 1. checks whether any ARC signatures were found
\& 2. queries for the public keys needed to verify the signatures
\& 3. sets up the appropriate algorithms and canonicalization objects
\& 4. canonicalizes the headers and computes the header hash
.Ve
.PP
Then, when the _body_ of the message has been completely fed into the
verifier, the body hash is computed and the signatures are verified.
.PP
The results of the verification can be checked with \*(L"\fBresult()\fR\*(R"
or \*(L"\fBsignatures()\fR\*(R".
.PP
The final result is calculated by the algorithm layed out in
https://tools.ietf.org/html/draft\-ietf\-dmarc\-arc\-protocol\-06 \-
if \s-1ALL\s0 ARC-Seal headers pass and the highest index (i=)
ARC-Message-Signature passes, then the seal is intact.
.SH "CONSTRUCTOR"
.IX Header "CONSTRUCTOR"
.SS "\fBnew()\fP"
.IX Subsection "new()"
Constructs an object-oriented verifier.
.PP
.Vb 1
\&  my $arc = Mail::DKIM::ARC::Verifier\->new();
\&
\&  my $arc = Mail::DKIM::ARC::Verifier\->new(%options);
.Ve
.PP
The only options supported at this time are:
.IP "AS_Canonicalization" 4
.IX Item "AS_Canonicalization"
if specified, the canonicalized message for the ARC-Seal
is written to the referenced string or file handle.
.IP "AMA_Canonicalization" 4
.IX Item "AMA_Canonicalization"
if specified, the canonicalized message for the ARC-Message-Signature
is written to the referenced string or file handle.
.IP "Strict" 4
.IX Item "Strict"
If true, rejects sha1 hashes and signing keys shorter than 1024 bits.
.SH "METHODS"
.IX Header "METHODS"
.SS "\s-1\fBPRINT\s0()\fP"
.IX Subsection "PRINT()"
Feeds part of the message to the verifier.
.PP
.Vb 3
\&  $arc\->PRINT("a line of the message\e015\e012");
\&  $arc\->PRINT(\*(Aqmore of\*(Aq);
\&  $arc\->PRINT(" the message\e015\e012bye\e015\e012");
.Ve
.PP
Feeds content of the message being verified into the verifier.
The \s-1API\s0 is designed this way so that the entire message does \s-1NOT\s0 need
to be read into memory at once.
.PP
Please note that although the \s-1\fBPRINT\s0()\fR method expects you to use
SMTP-style line termination characters, you should \s-1NOT\s0 use the
SMTP-style dot-stuffing technique described in \s-1RFC 2821\s0 section 4.5.2.
Nor should you use a <\s-1CR\s0><\s-1LF\s0>.<\s-1CR\s0><\s-1LF\s0> sequence to terminate the
message.
.SS "\s-1\fBCLOSE\s0()\fP"
.IX Subsection "CLOSE()"
Call this when finished feeding in the message.
.PP
.Vb 1
\&  $arc\->CLOSE;
.Ve
.PP
This method finishes the canonicalization process, computes a hash,
and verifies the signature.
.SS "\fBload()\fP"
.IX Subsection "load()"
Load the entire message from a file handle.
.PP
.Vb 1
\&  $arc\->load($file_handle);
.Ve
.PP
Reads a complete message from the designated file handle,
feeding it into the verifier. The message must use <\s-1CRLF\s0> line
terminators (same as the \s-1SMTP\s0 protocol).
.SS "\fBmessage_originator()\fP"
.IX Subsection "message_originator()"
Access the \*(L"From\*(R" header.
.PP
.Vb 1
\&  my $address = $arc\->message_originator;
.Ve
.PP
Returns the \*(L"originator address\*(R" found in the message, as a
Mail::Address object.
This is typically the (first) name and email address found in the
From: header. If there is no From: header,
then an empty Mail::Address object is returned.
.PP
To get just the email address part, do:
.PP
.Vb 1
\&  my $email = $arc\->message_originator\->address;
.Ve
.PP
See also \*(L"\fBmessage_sender()\fR\*(R".
.SS "\fBmessage_sender()\fP"
.IX Subsection "message_sender()"
Access the \*(L"From\*(R" or \*(L"Sender\*(R" header.
.PP
.Vb 1
\&  my $address = $arc\->message_sender;
.Ve
.PP
Returns the \*(L"sender\*(R" found in the message, as a Mail::Address object.
This is typically the (first) name and email address found in the
Sender: header. If there is no Sender: header, it is the first name and
email address in the From: header. If neither header is present,
then an empty Mail::Address object is returned.
.PP
To get just the email address part, do:
.PP
.Vb 1
\&  my $email = $arc\->message_sender\->address;
.Ve
.PP
The \*(L"sender\*(R" is the mailbox of the agent responsible for the actual
transmission of the message. For example, if a secretary were to send a
message for another person, the \*(L"sender\*(R" would be the secretary and
the \*(L"originator\*(R" would be the actual author.
.SS "\fBresult()\fP"
.IX Subsection "result()"
Access the result of the verification.
.PP
.Vb 1
\&  my $result = $arc\->result;
.Ve
.PP
Gives the result of the verification. The following values are possible:
.IP "pass" 4
.IX Item "pass"
Returned if a valid \s-1ARC\s0 chain was found, with all the ARC-Seals passing,
and the most recent (highest index) ARC-Message-Signature passing.
.IP "fail" 4
.IX Item "fail"
Returned if any ARC-Seal failed, or if the ARC-Message-Signature failed.
Will also be a fail if there is a \s-1DNS\s0 temporary failure, which is a
known flaw in this version of the ARC::Verifier.  Future versions may
reject this message outright (4xx) and ask the sender to attempt
delivery later to avoid creating a broken chain.  There is no temperror
for \s-1ARC,\s0 as it doesn't make sense to sign a chain with temperror in it
or every spammer would just use one of those.
.IP "invalid" 4
.IX Item "invalid"
Returned if a ARC-Seal could not be checked because of a problem
in the signature itself or the public key record. I.e. the signature
could not be processed.
.IP "none" 4
.IX Item "none"
Returned if no ARC\-* headers were found.
.SS "\fBresult_detail()\fP"
.IX Subsection "result_detail()"
Access the result, plus details if available.
.PP
.Vb 1
\&  my $detail = $dkim\->result_detail;
.Ve
.PP
The detail is constructed by taking the result (e.g. \*(L"pass\*(R", \*(L"fail\*(R",
\&\*(L"invalid\*(R" or \*(L"none\*(R") and appending any details provided by the verification
process for the topmost ARC-Seal in parenthesis.
.PP
The following are possible results from the \fBresult_detail()\fR method:
.PP
.Vb 10
\&  pass
\&  fail (bad RSA signature)
\&  fail (OpenSSL error: ...)
\&  fail (message has been altered)
\&  fail (body has been altered)
\&  invalid (bad instance)
\&  invalid (invalid domain in d tag)
\&  invalid (missing q tag)
\&  invalid (missing d tag)
\&  invalid (missing s tag)
\&  invalid (unsupported version 0.1)
\&  invalid (unsupported algorithm ...)
\&  invalid (unsupported canonicalization ...)
\&  invalid (unsupported query protocol ...)
\&  invalid (signature is expired)
\&  invalid (public key: not available)
\&  invalid (public key: unknown query type ...)
\&  invalid (public key: syntax error)
\&  invalid (public key: unsupported version)
\&  invalid (public key: unsupported key type)
\&  invalid (public key: missing p= tag)
\&  invalid (public key: invalid data)
\&  invalid (public key: does not support email)
\&  invalid (public key: does not support hash algorithm \*(Aqsha1\*(Aq)
\&  invalid (public key: does not support signing subdomains)
\&  invalid (public key: revoked)
\&  invalid (public key: granularity mismatch)
\&  invalid (public key: granularity is empty)
\&  invalid (public key: OpenSSL error: ...)
\&  none
.Ve
.SS "\fBsignatures()\fP"
.IX Subsection "signatures()"
Access all of this message's signatures.
.PP
.Vb 1
\&  my @all_signatures = $arc\->signatures;
.Ve
.PP
Use \f(CW$signature\fR\->result or \f(CW$signature\fR\->result_detail to access
the verification results of each signature.
.PP
Use \f(CW$signature\fR\->instance and \f(CW$signature\fR\->prefix to find the
instance and header-name for each signature.
.SH "AUTHOR"
.IX Header "AUTHOR"
Bron Gondwana, <brong@fastmailteam.com>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright (C) 2017 FastMail Pty Ltd.
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself, either Perl version 5.8.6 or,
at your option, any later version of Perl 5 you may have available.
