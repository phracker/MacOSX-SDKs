.\" Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "LibXSLT 3"
.TH LibXSLT 3 "2020-01-16" "perl v5.30.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
XML::LibXSLT \- Interface to the GNOME libxslt library
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&  use XML::LibXSLT;
\&  use XML::LibXML;
\&
\&  my $xslt = XML::LibXSLT\->new();
\&
\&  my $source = XML::LibXML\->load_xml(location => \*(Aqfoo.xml\*(Aq);
\&  my $style_doc = XML::LibXML\->load_xml(location=>\*(Aqbar.xsl\*(Aq, no_cdata=>1);
\&
\&  my $stylesheet = $xslt\->parse_stylesheet($style_doc);
\&
\&  my $results = $stylesheet\->transform($source);
\&
\&  print $stylesheet\->output_as_bytes($results);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module is an interface to the \s-1GNOME\s0 project's libxslt. This is an
extremely good \s-1XSLT\s0 engine, highly compliant and also very fast. I have
tests showing this to be more than twice as fast as Sablotron.
.SH "OPTIONS"
.IX Header "OPTIONS"
XML::LibXSLT has some global options. Note that these are probably not
thread or even fork safe \- so only set them once per process. Each one
of these options can be called either as class methods, or as instance
methods. However either way you call them, it still sets global options.
.PP
Each of the option methods returns its previous value, and can be called
without a parameter to retrieve the current value.
.IP "max_depth" 4
.IX Item "max_depth"
.Vb 1
\&  XML::LibXSLT\->max_depth(1000);
.Ve
.Sp
This option sets the maximum recursion depth for a stylesheet. See the
very end of section 5.4 of the \s-1XSLT\s0 specification for more details on
recursion and detecting it. If your stylesheet or \s-1XML\s0 file requires
seriously deep recursion, this is the way to set it. Default value is
250.
.IP "max_vars" 4
.IX Item "max_vars"
.Vb 1
\&  XML::LibXSLT\->max_vars(100_000);
.Ve
.Sp
This option sets the maximum number of variables for a stylesheet. If your
stylesheet or \s-1XML\s0 file requires many variables, this is the way to increase
their limit. Default value is system-specific and may vary.
.IP "debug_callback" 4
.IX Item "debug_callback"
.Vb 1
\&  XML::LibXSLT\->debug_callback($subref);
.Ve
.Sp
Sets a callback to be used for debug messages. If you don't set this,
debug messages will be ignored.
.IP "register_function" 4
.IX Item "register_function"
.Vb 2
\&  XML::LibXSLT\->register_function($uri, $name, $subref);
\&  $stylesheet\->register_function($uri, $name, $subref);
.Ve
.Sp
Registers an \s-1XSLT\s0 extension function mapped to the given \s-1URI.\s0 For example:
.Sp
.Vb 2
\&  XML::LibXSLT\->register_function("urn:foo", "bar",
\&    sub { scalar localtime });
.Ve
.Sp
Will register a \f(CW\*(C`bar\*(C'\fR function in the \f(CW\*(C`urn:foo\*(C'\fR namespace (which you
have to define in your \s-1XSLT\s0 using \f(CW\*(C`xmlns:...\*(C'\fR) that will return the
current date and time as a string:
.Sp
.Vb 7
\&  <xsl:stylesheet version="1.0"
\&    xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
\&    xmlns:foo="urn:foo">
\&  <xsl:template match="/">
\&    The time is: <xsl:value\-of select="foo:bar()"/>
\&  </xsl:template>
\&  </xsl:stylesheet>
.Ve
.Sp
Parameters can be in whatever format you like. If you pass in a nodelist
it will be a XML::LibXML::NodeList object in your perl code, but ordinary
values (strings, numbers and booleans) will be ordinary perl scalars. If
you wish them to be \f(CW\*(C`XML::LibXML::Literal\*(C'\fR, \f(CW\*(C`XML::LibXML::Number\*(C'\fR and
\&\f(CW\*(C`XML::LibXML::Number\*(C'\fR values respectively then set the variable
\&\f(CW$XML::LibXSLT::USE_LIBXML_DATA_TYPES\fR to a true value. Return values can
be a nodelist or a plain value \- the code will just do the right thing.
But only a single return value is supported (a list is not converted to
a nodelist).
.IP "register_element" 4
.IX Item "register_element"
.Vb 1
\&        $stylesheet\->register_element($uri, $name, $subref)
.Ve
.Sp
Registers an \s-1XSLT\s0 extension element \f(CW$name\fR mapped to the given \s-1URI.\s0 For example:
.Sp
.Vb 4
\&  $stylesheet\->register_element("urn:foo", "hello", sub {
\&          my $name = $_[2]\->getAttribute( "name" );
\&          return XML::LibXML::Text\->new( "Hello, $name!" );
\&  });
.Ve
.Sp
Will register a \f(CW\*(C`hello\*(C'\fR element in the \f(CW\*(C`urn:foo\*(C'\fR namespace that returns a \*(L"Hello, X!\*(R" text node. You must define this namespace in your \s-1XSLT\s0 and include its prefix in the \f(CW\*(C`extension\-element\-prefixes\*(C'\fR list:
.Sp
.Vb 8
\&  <xsl:stylesheet version="1.0"
\&    xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
\&    xmlns:foo="urn:foo"
\&        extension\-element\-prefixes="foo">
\&  <xsl:template match="/">
\&    <foo:hello name="bob"/>
\&  </xsl:template>
\&  </xsl:stylesheet>
.Ve
.Sp
The callback is passed the input document node as \f(CW$_\fR[1] and the stylesheet node as \f(CW$_\fR[2]. \f(CW$_\fR[0] is reserved for future use.
.SH "API"
.IX Header "API"
The following methods are available on the new XML::LibXSLT object:
.IP "parse_stylesheet($stylesheet_doc)" 4
.IX Item "parse_stylesheet($stylesheet_doc)"
\&\f(CW$stylesheet_doc\fR here is an XML::LibXML::Document object (see XML::LibXML)
representing an \s-1XSLT\s0 file. This method will return a
XML::LibXSLT::Stylesheet object, or undef on failure. If the \s-1XSLT\s0 is
invalid, an exception will be thrown, so wrap the call to
parse_stylesheet in an eval{} block to trap this.
.Sp
\&\s-1IMPORTANT:\s0 \f(CW$stylesheet_doc\fR should not contain \s-1CDATA\s0 sections,
otherwise libxslt may misbehave. The best way to assure this is to
load the stylesheet with no_cdata flag, e.g.
.Sp
.Vb 1
\&  my $stylesheet_doc = XML::LibXML\->load_xml(location=>"some.xsl", no_cdata=>1);
.Ve
.IP "parse_stylesheet_file($filename)" 4
.IX Item "parse_stylesheet_file($filename)"
Exactly the same as the above, but parses the given filename directly.
.SH "Input Callbacks"
.IX Header "Input Callbacks"
To define XML::LibXSLT or XML::LibXSLT::Stylesheet specific input
callbacks, reuse the XML::LibXML input callback \s-1API\s0 as described in
\&\fBXML::LibXML::InputCallback\fR\|(3).
.IP "input_callbacks($icb)" 4
.IX Item "input_callbacks($icb)"
Enable the callbacks in \f(CW$icb\fR only for this XML::LibXSLT object.
\&\f(CW$icb\fR should be a \f(CW\*(C`XML::LibXML::InputCallback\*(C'\fR object. This will
call \f(CW\*(C`init_callbacks\*(C'\fR and \f(CW\*(C`cleanup_callbacks\*(C'\fR automatically during
parsing or transformation.
.SH "Security Callbacks"
.IX Header "Security Callbacks"
To create security preferences for the transformation see
XML::LibXSLT::Security. Once the security preferences have been defined you
can apply them to an XML::LibXSLT or XML::LibXSLT::Stylesheet instance using
the \f(CW\*(C`security_callbacks()\*(C'\fR method.
.SH "XML::LibXSLT::Stylesheet"
.IX Header "XML::LibXSLT::Stylesheet"
The main \s-1API\s0 is on the stylesheet, though it is fairly minimal.
.PP
One of the main advantages of XML::LibXSLT is that you have a generic
stylesheet object which you call the \fBtransform()\fR method passing in a
document to transform. This allows you to have multiple transformations
happen with one stylesheet without requiring a reparse.
.ie n .IP "transform(doc, %params)" 4
.el .IP "transform(doc, \f(CW%params\fR)" 4
.IX Item "transform(doc, %params)"
.Vb 2
\&  my $results = $stylesheet\->transform($doc, foo => "\*(Aqbar\*(Aq");
\&  print $stylesheet\->output_as_bytes($results);
.Ve
.Sp
Transforms the passed in XML::LibXML::Document object, and returns a
new XML::LibXML::Document. Extra hash entries are used as parameters.
Be sure to keep in mind the caveat with regard to quotes explained in
the section on \*(L"Parameters\*(R" below.
.ie n .IP "transform_file(filename, %params)" 4
.el .IP "transform_file(filename, \f(CW%params\fR)" 4
.IX Item "transform_file(filename, %params)"
.Vb 1
\&  my $results = $stylesheet\->transform_file($filename, bar => "\*(Aqbaz\*(Aq");
.Ve
.Sp
Note the string parameter caveat, detailed in the section on
\&\*(L"Parameters\*(R" below.
.IP "output_as_bytes(result)" 4
.IX Item "output_as_bytes(result)"
Returns a scalar that is the \s-1XSLT\s0 rendering of the
XML::LibXML::Document object using the desired output format
(specified in the xsl:output tag in the stylesheet). Note that you can
also call \f(CW$result\fR\->toString, but that will *always* output the
document in \s-1XML\s0 format which may not be what you asked for in the
xsl:output tag. The scalar is a byte string encoded in the output
encoding specified in the stylesheet.
.IP "output_as_chars(result)" 4
.IX Item "output_as_chars(result)"
Like \f(CW\*(C`output_as_bytes(result)\*(C'\fR, but always return the output as (\s-1UTF\-8\s0
encoded) string of characters.
.IP "output_string(result)" 4
.IX Item "output_string(result)"
\&\s-1DEPRECATED:\s0 This method is something between
\&\f(CW\*(C`output_as_bytes(result)\*(C'\fR and \f(CW\*(C`output_as_bytes(result)\*(C'\fR: The scalar
returned by this function appears to Perl as characters (\s-1UTF8\s0 flag is
on) if the output encoding specified in the \s-1XSLT\s0 stylesheet was \s-1UTF\-8\s0
and as bytes if no output encoding was specified or if the output
encoding was other than \s-1UTF\-8.\s0 Since the behavior of this function
depends on the particular stylesheet, it is deprecated in favor of
\&\f(CW\*(C`output_as_bytes(result)\*(C'\fR and \f(CW\*(C`output_as_chars(result)\*(C'\fR.
.IP "output_fh(result, fh)" 4
.IX Item "output_fh(result, fh)"
Outputs the result to the filehandle given in \f(CW$fh\fR.
.IP "output_file(result, filename)" 4
.IX Item "output_file(result, filename)"
Outputs the result to the file named in \f(CW$filename\fR.
.IP "\fBoutput_encoding()\fR" 4
.IX Item "output_encoding()"
Returns the output encoding of the results. Defaults to \*(L"\s-1UTF\-8\*(R".\s0
.IP "\fBoutput_method()\fR" 4
.IX Item "output_method()"
Returns the value of the \f(CW\*(C`method\*(C'\fR attribute from \f(CW\*(C`xsl:output\*(C'\fR
(usually \f(CW\*(C`xml\*(C'\fR, \f(CW\*(C`html\*(C'\fR or \f(CW\*(C`text\*(C'\fR). If this attribute is
unspecified, the default value is initially \f(CW\*(C`xml\*(C'\fR. If the
transform method is used to produce an \s-1HTML\s0 document, as per the
\&\s-1XSLT\s0 spec <http://www.w3.org/TR/xslt#output>, the default value will
change to \f(CW\*(C`html\*(C'\fR. To override this behavior completely, supply an
\&\f(CW\*(C`xsl:output\*(C'\fR element in the stylesheet source document.
.IP "\fBmedia_type()\fR" 4
.IX Item "media_type()"
Returns the value of the \f(CW\*(C`media\-type\*(C'\fR attribute from
\&\f(CW\*(C`xsl:output\*(C'\fR. If this attribute is unspecified, the default media
type is initially \f(CW\*(C`text/xml\*(C'\fR. This default changes to \f(CW\*(C`text/html\*(C'\fR
under the same conditions as output_method.
.IP "input_callbacks($icb)" 4
.IX Item "input_callbacks($icb)"
Enable the callbacks in \f(CW$icb\fR only for this stylesheet. \f(CW$icb\fR
should be a \f(CW\*(C`XML::LibXML::InputCallback\*(C'\fR object. This will call
\&\f(CW\*(C`init_callbacks\*(C'\fR and \f(CW\*(C`cleanup_callbacks\*(C'\fR automatically during
transformation.
.SH "Parameters"
.IX Header "Parameters"
LibXSLT expects parameters in XPath format. That is, if you wish to pass
a string to the \s-1XSLT\s0 engine, you actually have to pass it as a quoted
string:
.PP
.Vb 1
\&  $stylesheet\->transform($doc, param => "\*(Aqstring\*(Aq");
.Ve
.PP
Note the quotes within quotes there!
.PP
Obviously this isn't much fun, so you can make it easy on yourself:
.PP
.Vb 3
\&  $stylesheet\->transform($doc, XML::LibXSLT::xpath_to_string(
\&        param => "string"
\&        ));
.Ve
.PP
The utility function does the right thing with respect to strings in XPath,
including when you have quotes already embedded within your string.
.SH "XML::LibXSLT::Security"
.IX Header "XML::LibXSLT::Security"
Provides an interface to the libxslt security framework by allowing callbacks
to be defined that can restrict access to various resources (files or URLs)
during a transformation.
.PP
The libxslt security framework allows callbacks to be defined for certain
actions that a stylesheet may attempt during a transformation. It may be
desirable to restrict some of these actions (for example, writing a new file
using exsl:document). The actions that may be restricted are:
.IP "read_file" 4
.IX Item "read_file"
Called when the stylesheet attempts to open a local file (ie: when using the
\&\fBdocument()\fR function).
.IP "write_file" 4
.IX Item "write_file"
Called when an attempt is made to write a local file (ie: when using the
exsl:document element).
.IP "create_dir" 4
.IX Item "create_dir"
Called when a directory needs to be created in order to write a file.
.Sp
\&\s-1NOTE:\s0 By default, create_dir is not allowed. To enable it a callback must be
registered.
.IP "read_net" 4
.IX Item "read_net"
Called when the stylesheet attempts to read from the network.
.IP "write_net" 4
.IX Item "write_net"
Called when the stylesheet attempts to write to the network.
.SS "Using XML::LibXSLT::Security"
.IX Subsection "Using XML::LibXSLT::Security"
The interface for this module is similar to XML::LibXML::InputCallback. After
creating a new instance you may register callbacks for each of the security
options listed above. Then you apply the security preferences to the
XML::LibXSLT or XML::LibXSLT::Stylesheet object using \f(CW\*(C`security_callbacks()\*(C'\fR.
.PP
.Vb 6
\&  my $security = XML::LibXSLT::Security\->new();
\&  $security\->register_callback( read_file  => $read_cb );
\&  $security\->register_callback( write_file => $write_cb );
\&  $security\->register_callback( create_dir => $create_cb );
\&  $security\->register_callback( read_net   => $read_net_cb );
\&  $security\->register_callback( write_net  => $write_net_cb );
\&
\&  $xslt\->security_callbacks( $security );
\&   \-OR\-
\&  $stylesheet\->security_callbacks( $security );
.Ve
.PP
The registered callback functions are called when access to a resource is
requested. If the access should be allowed the callback should return 1, if
not it should return 0. The callback functions should accept the following
arguments:
.ie n .IP "$tctxt" 4
.el .IP "\f(CW$tctxt\fR" 4
.IX Item "$tctxt"
This is the transform context (XML::LibXSLT::TransformContext). You can use
this to get the current XML::LibXSLT::Stylesheet object by calling
\&\f(CW\*(C`stylesheet()\*(C'\fR.
.Sp
.Vb 1
\&  my $stylesheet = $tctxt\->stylesheet();
.Ve
.Sp
The stylesheet object can then be used to share contextual information between
different calls to the security callbacks.
.ie n .IP "$value" 4
.el .IP "\f(CW$value\fR" 4
.IX Item "$value"
This is the name of the resource (file or \s-1URI\s0) that has been requested.
.PP
If a particular option (except for \f(CW\*(C`create_dir\*(C'\fR) doesn't have a registered
callback, then the stylesheet will have full access for that action.
.SS "Interface"
.IX Subsection "Interface"
.IP "\fBnew()\fR" 4
.IX Item "new()"
Creates a new XML::LibXSLT::Security object.
.ie n .IP "register_callback( $option, $callback )" 4
.el .IP "register_callback( \f(CW$option\fR, \f(CW$callback\fR )" 4
.IX Item "register_callback( $option, $callback )"
Registers a callback function for the given security option (listed above).
.ie n .IP "unregister_callback( $option )" 4
.el .IP "unregister_callback( \f(CW$option\fR )" 4
.IX Item "unregister_callback( $option )"
Removes the callback for the given option. This has the effect of allowing all
access for the given option (except for \f(CW\*(C`create_dir\*(C'\fR).
.SH "BENCHMARK"
.IX Header "BENCHMARK"
Included in the distribution is a simple benchmark script, which has two
drivers \- one for LibXSLT and one for Sablotron. The benchmark requires
the testcases files from the XSLTMark distribution which you can find
at http://www.datapower.com/XSLTMark/
.PP
Put the testcases directory in the directory created by this distribution,
and then run:
.PP
.Vb 1
\&  perl benchmark.pl \-h
.Ve
.PP
to get a list of options.
.PP
The benchmark requires XML::XPath at the moment, but I hope to factor that
out of the equation fairly soon. It also requires Time::HiRes, which I
could be persuaded to factor out, replacing it with Benchmark.pm, but I
haven't done so yet.
.PP
I would love to get drivers for \s-1XML::XSLT\s0 and XML::Transformiix, if you
would like to contribute them. Also if you get this running on Win32, I'd
love to get a driver for \s-1MSXSLT\s0 via \s-1OLE,\s0 to see what we can do against
those Redmond boys!
.SH "LIBRARY VERSIONS"
.IX Header "LIBRARY VERSIONS"
For debugging purposes, XML::LibXSLT provides version information
about the libxslt C library (but do not confuse it with the version
number of XML::LibXSLT module itself, i.e. with
\&\f(CW$XML::LibXSLT::VERSION\fR). XML::LibXSLT issues a warning if the
runtime version of the library is less then the compile-time version.
.IP "\fBXML::LibXSLT::LIBXSLT_VERSION()\fR" 4
.IX Item "XML::LibXSLT::LIBXSLT_VERSION()"
Returns version number of libxslt library which was used to compile
XML::LibXSLT as an integer. For example, for libxslt\-1.1.18, it will
return 10118.
.IP "\fBXML::LibXSLT::LIBXSLT_DOTTED_VERSION()\fR" 4
.IX Item "XML::LibXSLT::LIBXSLT_DOTTED_VERSION()"
Returns version number of libxslt library which was used to compile
XML::LibXSLT as a string, e.g. \*(L"1.1.18\*(R".
.IP "\fBXML::LibXSLT::LIBXSLT_RUNTIME_VERSION()\fR" 4
.IX Item "XML::LibXSLT::LIBXSLT_RUNTIME_VERSION()"
Returns version number of libxslt library to which XML::LibXSLT is
linked at runtime (either dynamically or statically). For example, for
example, for libxslt.so.1.1.18, it will return 10118.
.IP "\fBXML::LibXSLT::HAVE_EXLT()\fR" 4
.IX Item "XML::LibXSLT::HAVE_EXLT()"
Returns 1 if the module was compiled with libexslt, 0 otherwise.
.SH "LICENSE"
.IX Header "LICENSE"
This is free software, you may use it and distribute it under the same terms as
Perl itself.
.PP
Copyright 2001\-2009, AxKit.com Ltd.
.SH "AUTHOR"
.IX Header "AUTHOR"
Matt Sergeant, matt@sergeant.org
.PP
Security callbacks implementation contributed by Shane Corgatelli.
.SH "MAINTAINER"
.IX Header "MAINTAINER"
Petr Pajas , pajas@matfyz.org
.SH "BUGS"
.IX Header "BUGS"
Please report bugs via
.PP
.Vb 1
\&  http://rt.cpan.org/NoAuth/Bugs.html?Dist=XML\-LibXSLT
.Ve
.SH "SEE ALSO"
.IX Header "SEE ALSO"
XML::LibXML
