.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Parse::Eyapp::defaultactionsintro 3"
.TH Parse::Eyapp::defaultactionsintro 3 "2012-03-23" "perl v5.18.4" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Parse::Eyapp::defaultactionsintro \- Introduction to Default Actions and Grammar Reuse
.SH "Introduction"
.IX Header "Introduction"
The examples used in this tutorial can be found in the
directory \f(CW\*(C`examples/recycle\*(C'\fR accompanying this distribution
.SH "Default Actions"
.IX Header "Default Actions"
.SS "Default actions"
.IX Subsection "Default actions"
When no action is specified both \f(CW\*(C`yapp\*(C'\fR and \f(CW\*(C`eyapp\*(C'\fR
implicitly insert the semantic action \f(CW\*(C`{ $_[1] }\*(C'\fR. 
In \f(CW\*(C`Parse::Eyapp\*(C'\fR you can modify such behavior using the \f(CW\*(C`%defaultaction { Perl code }\*(C'\fR
directive. The \f(CW\*(C`{ Perl code }\*(C'\fR clause that follows the \f(CW%defaultaction\fR
directive is
executed when reducing by any production for which no explicit
action was specified.
.PP
\fITranslator from Infix to Postfix\fR
.IX Subsection "Translator from Infix to Postfix"
.PP
See the example in \f(CW\*(C`examples/eyapplanguageref/Postfix.eyp\*(C'\fR  that translates an infix expression
like \f(CW\*(C`a=b*\-3\*(C'\fR into a postfix expression like \f(CW\*(C`a b 3 NEG * = \*(C'\fR:
.PP
.Vb 10
\&  Parse\-Eyapp/examples/eyapplanguageref$ cat \-n Postfix.eyp
\&     1  # File Postfix.eyp
\&     2  %right  \*(Aq=\*(Aq
\&     3  %left   \*(Aq\-\*(Aq \*(Aq+\*(Aq
\&     4  %left   \*(Aq*\*(Aq \*(Aq/\*(Aq
\&     5  %left   NEG
\&     6
\&     7  %defaultaction { return  "$left $right $op"; }
\&     8
\&     9  %%
\&    10  line: $exp  { print "$exp\en" }
\&    11  ;
\&    12
\&    13  exp:        $NUM  { $NUM }
\&    14          |   $VAR  { $VAR }
\&    15          |   VAR.left \*(Aq=\*(Aq.op exp.right
\&    16          |   exp.left \*(Aq+\*(Aq.op exp.right
\&    17          |   exp.left \*(Aq\-\*(Aq.op exp.right
\&    18          |   exp.left \*(Aq*\*(Aq.op exp.right
\&    19          |   exp.left \*(Aq/\*(Aq.op exp.right
\&    20          |   \*(Aq\-\*(Aq $exp %prec NEG { "$exp NEG" }
\&    21          |   \*(Aq(\*(Aq $exp \*(Aq)\*(Aq { $exp }
\&    22  ;
\&    23
\&    24  %%
\&    25
\&    26  sub _Error {
\&    27    my($token)=$_[0]\->YYCurval;
\&    28    my($what)= $token ? "input: \*(Aq$token\*(Aq" : "end of input";
\&    29    my @expected = $_[0]\->YYExpect();
\&    30
\&    31    local $" = \*(Aq, \*(Aq;
\&    32    die "Syntax error near $what. Expected one of these tokens: @expected\en";
\&    33  }
\&    34
\&    35  my $x;
\&    36
\&    37  sub _Lexer {
\&    38    my($parser)=shift;
\&    39
\&    40    for ($x) {
\&    41      s/^\es+//;
\&    42      $_ eq \*(Aq\*(Aq and return(\*(Aq\*(Aq,undef);
\&    43
\&    44      s/^([0\-9]+(?:\e.[0\-9]+)?)//   and return(\*(AqNUM\*(Aq,$1);
\&    45      s/^([A\-Za\-z][A\-Za\-z0\-9_]*)// and return(\*(AqVAR\*(Aq,$1);
\&    46      s/^(.)//s                    and return($1,$1);
\&    47    }
\&    48  }
\&    49
\&    50  sub Run {
\&    51    my($self)=shift;
\&    52    my $debug = shift @ARGV;
\&    53    $debug = 0x1F if $debug;
\&    54    print "Infix to postfix translator. Write an arithmetic expression: ";
\&    55    $x = <STDIN>;
\&    56    $self\->YYParse(
\&    57      yylex => \e&_Lexer,
\&    58      yyerror => \e&_Error,
\&    59      yydebug => $debug,
\&    60    );
\&    61  }
\&    62
\&    63   # Modulino
\&    64   _\|_PACKAGE_\|_\->new()\->Run unless caller();
.Ve
.PP
The file containing the \f(CW\*(C`Eyapp\*(C'\fR program must be compiled with \f(CW\*(C`eyapp\*(C'\fR:
.PP
.Vb 1
\& Parse\-Eyapp/examples/eyapplanguageref$ eyapp Postfix.eyp
.Ve
.PP
Next, you have to write a client program:
.PP
.Vb 7
\&  Parse\-Eyapp/examples/eyapplanguageref$ cat \-n usepostfix.pl
\&     1  #!/usr/bin/perl \-w
\&     2  use strict;
\&     3  use Postfix;
\&     4
\&     5  my $parser = new Postfix();
\&     6  $parser\->Run;
.Ve
.PP
Now we can run the client program:
.PP
.Vb 3
\& Parse\-Eyapp/examples/eyapplanguageref$ usepostfix.pl
\& Infix to postfix translator. Write an arithmetic expression: \-(2*a\-b*\-3)
\& 2 a * b 3 NEG * \- NEG
.Ve
.PP
An alternative is to use the generated module as a modulino, 
compiling the grammar using option \f(CW\*(C`\-b\*(C'\fR:
.PP
.Vb 1
\&  Parse\-Eyapp/examples/eyapplanguageref$ eyapp \-b \*(Aq\*(Aq Postfix.eyp
.Ve
.PP
This way, we can directly use the modulo as a script:
.PP
.Vb 3
\&  Parse\-Eyapp/examples/eyapplanguageref$ ./Postfix.pm
\&  Infix to postfix translator. Write an arithmetic expression: 2*3+b
\&  2 3 * b +
.Ve
.PP
\fIDefault Actions, \f(CI%name\fI and \f(CI\*(C`YYName\*(C'\fI\fR
.IX Subsection "Default Actions, %name and YYName"
.PP
In \f(CW\*(C`eyapp\*(C'\fR each production rule has a name.
The name of a rule can be explicitly given by the programmer 
using the \f(CW%name\fR directive. For example, in the piece of code
that follows the name \f(CW\*(C`ASSIGN\*(C'\fR is given to the rule \f(CW\*(C`exp: VAR \*(Aq=\*(Aq exp\*(C'\fR.
.PP
When no explicit name is given the rule has an implicit name.
The implicit name of a rule is shaped by concatenating
the name of the syntactic variable on its left, an underscore 
and the ordinal number of the production rule \f(CW\*(C`Lhs_#\*(C'\fR
as it appears in the \f(CW\*(C`.output\*(C'\fR file.
Avoid giving names matching such pattern to production rules.
The patterns
\&\f(CW\*(C`/${lhs}_\ed+$/\*(C'\fR where \f(CW\*(C`${lhs}\*(C'\fR is the name of the syntactic variable
are reserved for internal use by \f(CW\*(C`eyapp\*(C'\fR.
.PP
.Vb 10
\&  pl@nereida:~/LEyapp/examples$ cat \-n Lhs.eyp
\&   1  # Lhs.eyp
\&   2
\&   3  %right  \*(Aq=\*(Aq
\&   4  %left   \*(Aq\-\*(Aq \*(Aq+\*(Aq
\&   5  %left   \*(Aq*\*(Aq \*(Aq/\*(Aq
\&   6  %left   NEG
\&   7
\&   8  %defaultaction {
\&   9    my $self = shift;
\&  10    my $name = $self\->YYName();
\&  11    bless { children => [ grep {ref($_)} @_] }, $name;
\&  12  }
\&  13
\&  14  %%
\&  15  input:
\&  16              /* empty */
\&  17                { [] }
\&  18          |   input line
\&  19                {
\&  20                  push @{$_[1]}, $_[2] if defined($_[2]);
\&  21                  $_[1]
\&  22                }
\&  23  ;
\&  24
\&  25  line:     \*(Aq\en\*(Aq       { }
\&  26          | exp \*(Aq\en\*(Aq   {  $_[1] }
\&  27  ;
\&  28
\&  29  exp:
\&  30              NUM   { $_[1] }
\&  31          |   VAR   { $_[1] }
\&  32          |   %name ASSIGN
\&  33              VAR \*(Aq=\*(Aq exp
\&  34          |   %name PLUS
\&  35              exp \*(Aq+\*(Aq exp
\&  36          |   %name MINUS
\&  37              exp \*(Aq\-\*(Aq exp
\&  38          |   %name TIMES
\&  39              exp \*(Aq*\*(Aq exp
\&  40          |   %name DIV
\&  41              exp \*(Aq/\*(Aq exp
\&  42          |   %name UMINUS
\&  43              \*(Aq\-\*(Aq exp %prec NEG
\&  44          |  \*(Aq(\*(Aq exp \*(Aq)\*(Aq  { $_[2] }
\&  45  ;
.Ve
.PP
Inside a semantic action
the name of the current rule can be recovered 
using the method \f(CW\*(C`YYName\*(C'\fR of the parser object.
.PP
The default action (lines 8\-12) computes as attribute of the left
hand side a reference to an object blessed in the name of the rule.
The object has an attribute \f(CW\*(C`children\*(C'\fR which is a reference 
to the list of children of the node.
The call to \f(CW\*(C`grep\*(C'\fR
.PP
.Vb 1
\&  11    bless { children => [ grep {ref($_)} @_] }, $name;
.Ve
.PP
excludes children that aren't references. Notice that the lexical analyzer 
only returns references for the \f(CW\*(C`NUM\*(C'\fR and \f(CW\*(C`VAR\*(C'\fR terminals:
.PP
.Vb 10
\&  59  sub _Lexer {
\&  60      my($parser)=shift;
\&  61
\&  62      for ($parser\->YYData\->{INPUT}) {
\&  63          s/^[ \et]+//;
\&  64          return(\*(Aq\*(Aq,undef) unless $_;
\&  65          s/^([0\-9]+(?:\e.[0\-9]+)?)//
\&  66                  and return(\*(AqNUM\*(Aq, bless { attr => $1}, \*(AqNUM\*(Aq);
\&  67          s/^([A\-Za\-z][A\-Za\-z0\-9_]*)//
\&  68                  and return(\*(AqVAR\*(Aq,bless {attr => $1}, \*(AqVAR\*(Aq);
\&  69          s/^(.)//s
\&  70                  and return($1, $1);
\&  71      }
\&  72      return(\*(Aq\*(Aq,undef);
\&  73  }
.Ve
.PP
follows the client program:
.PP
.Vb 10
\&  pl@nereida:~/LEyapp/examples$ cat \-n uselhs.pl
\&       1  #!/usr/bin/perl \-w
\&       2  use Lhs;
\&       3  use Data::Dumper;
\&       4
\&       5  $parser = new Lhs();
\&       6  my $tree = $parser\->Run;
\&       7  $Data::Dumper::Indent = 1;
\&       8  if (defined($tree)) { print Dumper($tree); }
\&       9  else { print "Cadena no va\*'lida\en"; }
.Ve
.PP
When executed with input \f(CW\*(C`a=(2+3)*b\*(C'\fR the parser produces
the following tree:
.PP
.Vb 1
\&  ASSIGN(TIMES(PLUS(NUM[2],NUM[3]), VAR[b]))
.Ve
.PP
See the result of an execution:
.PP
.Vb 10
\&  pl@nereida:~/LEyapp/examples$ uselhs.pl
\&  a=(2+3)*b
\&  $VAR1 = [
\&    bless( {
\&      \*(Aqchildren\*(Aq => [
\&        bless( { \*(Aqattr\*(Aq => \*(Aqa\*(Aq }, \*(AqVAR\*(Aq ),
\&        bless( {
\&          \*(Aqchildren\*(Aq => [
\&            bless( {
\&              \*(Aqchildren\*(Aq => [
\&                bless( { \*(Aqattr\*(Aq => \*(Aq2\*(Aq }, \*(AqNUM\*(Aq ),
\&                bless( { \*(Aqattr\*(Aq => \*(Aq3\*(Aq }, \*(AqNUM\*(Aq )
\&              ]
\&            }, \*(AqPLUS\*(Aq ),
\&            bless( { \*(Aqattr\*(Aq => \*(Aqb\*(Aq }, \*(AqVAR\*(Aq )
\&          ]
\&        }, \*(AqTIMES\*(Aq )
\&      ]
\&    }, \*(AqASSIGN\*(Aq )
\&  ];
.Ve
.PP
The name of a production rule can be changed at execution time.
See the following example:
.PP
.Vb 10
\&  29  exp:
\&  30              NUM   { $_[1] }
\&  31          |   VAR   { $_[1] }
\&  32          |   %name ASSIGN
\&  33              VAR \*(Aq=\*(Aq exp
\&  34          |   %name PLUS
\&  35              exp \*(Aq+\*(Aq exp
\&  36          |   %name MINUS
\&  37              exp \*(Aq\-\*(Aq exp
\&  38                {
\&  39                  my $self = shift;
\&  40                  $self\->YYName(\*(AqSUBTRACT\*(Aq); # rename it
\&  41                  $self\->YYBuildAST(@_); # build the node
\&  42                }
\&  43          |   %name TIMES
\&  44              exp \*(Aq*\*(Aq exp
\&  45          |   %name DIV
\&  46              exp \*(Aq/\*(Aq exp
\&  47          |   %name UMINUS
\&  48              \*(Aq\-\*(Aq exp %prec NEG
\&  49          |  \*(Aq(\*(Aq exp \*(Aq)\*(Aq  { $_[2] }
\&  50  ;
.Ve
.PP
When the client program is executed we can see the presence
of the \f(CW\*(C`SUBTRACT\*(C'\fR nodes:
.PP
.Vb 10
\&  pl@nereida:~/LEyapp/examples$ useyynamedynamic.pl
\&  2\-b
\&  $VAR1 = [
\&    bless( {
\&      \*(Aqchildren\*(Aq => [
\&        bless( {
\&          \*(Aqattr\*(Aq => \*(Aq2\*(Aq
\&        }, \*(AqNUM\*(Aq ),
\&        bless( {
\&          \*(Aqattr\*(Aq => \*(Aqb\*(Aq
\&        }, \*(AqVAR\*(Aq )
\&      ]
\&    }, \*(AqSUBTRACT\*(Aq )
\&  ];
.Ve
.SH "Grammar Reuse"
.IX Header "Grammar Reuse"
Terence Parr in his talk \*(L"Reuse of Grammars with Embedded Semantic Actions\*(R"
(see <http://www.cs.vu.nl/icpc2008/docs/Parr.pdf>)
explains the problem:
.PP
.Vb 8
\& "Because many applications deal with the same language, the reuse of a common
\&syntax specification with different semantics provides a number of advantages.
\&While the advantages are obvious, the mechanism for grammar reuse is not so
\&clear.  To go beyond syntax checking, grammars must have some way to specify
\&the translation or interpretation logic (the semantics). Unfortunately, the act
\&of specifying the semantics can lock a grammar into one specific application
\&since the grammar is often modified to suit (e.g., programmers often want to
\&embed unrestricted semantic actions)."
.Ve
.PP
The incoming sections deal with different solutions to the problem.
.SS "An Action Method for each Production"
.IX Subsection "An Action Method for each Production"
Default actions provide a way to write reusable
grammars.  Here is one solution:
.PP
.Vb 10
\&  pl@europa:~/LEyapp/examples/recycle$ cat \-n Noactions.eyp
\&     1  %left   \*(Aq+\*(Aq
\&     2  %left   \*(Aq*\*(Aq
\&     3
\&     4  %defaultaction {
\&     5    my $self = shift;
\&     6
\&     7    my $class = $self\->YYPrefix;
\&     8    $class .=  $self\->YYName;
\&     9
\&    10    $class\->action(@_);
\&    11  }
\&    12
\&    13  %%
\&    14  exp:        %name NUM
\&    15                NUM
\&    16          |   %name PLUS
\&    17                exp \*(Aq+\*(Aq exp
\&    18          |   %name TIMES
\&    19                exp \*(Aq*\*(Aq exp
\&    20          |   \*(Aq(\*(Aq exp \*(Aq)\*(Aq
\&    21                { $_[2] }
\&    22  ;
\&    23
\&    24  %%
\&    25
\&    26  sub _Error {
\&    27    my($token)=$_[0]\->YYCurval;
\&    28    my($what)= $token ? "input: \*(Aq$token\*(Aq" : "end of input";
\&    29    my @expected = $_[0]\->YYExpect();
\&    30
\&    31    local $" = \*(Aq, \*(Aq;
\&    32    die "Syntax error near $what. Expected one of these tokens: @expected\en";
\&    33  }
\&    34
\&    35
\&    36  my $x = \*(Aq\*(Aq;
\&    37
\&    38  sub _Lexer {
\&    39    my($parser)=shift;
\&    40
\&    41    for ($x) {
\&    42      s/^\es+//;
\&    43      $_ eq \*(Aq\*(Aq and return(\*(Aq\*(Aq,undef);
\&    44
\&    45      s/^([0\-9]+(?:\e.[0\-9]+)?)//   and return(\*(AqNUM\*(Aq,$1);
\&    46      s/^([A\-Za\-z][A\-Za\-z0\-9_]*)// and return(\*(AqVAR\*(Aq,$1);
\&    47      s/^(.)//s                    and return($1,$1);
\&    48    }
\&    49  }
\&    50
\&    51  sub Run {
\&    52    my($self)=shift;
\&    53    $x = shift;
\&    54    my $debug = shift;
\&    55
\&    56    $self\->YYParse(
\&    57      yylex    => \e&_Lexer,
\&    58      yyerror  => \e&_Error,
\&    59      yydebug  => $debug,
\&    60    );
\&    61  }
.Ve
.PP
This grammar is reused by the following program to implement a calculator:
and a translator from infix to postfix:
.PP
.Vb 10
\&  pl@europa:~/LEyapp/examples/recycle$ cat \-n calcu_and_post.pl
\&     1  #!/usr/bin/perl
\&     2  use warnings;
\&     3  use Noactions;
\&     4
\&     5  sub Calc::NUM::action {
\&     6    return $_[1];
\&     7  }
\&     8
\&     9  sub Calc::PLUS::action {
\&    10    $_[1]+$_[3];
\&    11  }
\&    12
\&    13  sub Calc::TIMES::action {
\&    14    $_[1]*$_[3];
\&    15  }
\&    16
\&    17  sub Post::NUM::action {
\&    18    return $_[1];
\&    19  }
\&    20
\&    21  sub Post::PLUS::action {
\&    22    "$_[1] $_[3] +";
\&    23  }
\&    24
\&    25  sub Post::TIMES::action {
\&    26    "$_[1] $_[3] *";
\&    27  }
\&    28
\&    29  my $debug = shift || 0;
\&    30  my $pparser = Noactions\->new( yyprefix => \*(AqPost::\*(Aq);
\&    31  print "Write an expression: ";
\&    32  my $x = <STDIN>;
\&    33  my $t = $pparser\->Run($x, $debug);
\&    34
\&    35  print "$t\en";
\&    36
\&    37  my $cparser = Noactions\->new(yyprefix => \*(AqCalc::\*(Aq);
\&    38  my $e = $cparser\->Run($x, $debug);
\&    39
\&    40  print "$e\en";
.Ve
.SS "Reusing Grammars Using Inheritance"
.IX Subsection "Reusing Grammars Using Inheritance"
An method to reuse a grammar is via inheritance. 
The client inherits the generated parser module and expands it 
with methods that inherit or overwrite the actions.
Here is an example. Initially we have this Eyapp grammar:
.PP
.Vb 10
\&  pl@europa:~/LEyapp/examples/recycle$ cat \-n NoacInh.eyp
\&     1  %left   \*(Aq+\*(Aq
\&     2  %left   \*(Aq*\*(Aq
\&     3
\&     4  %defaultaction {
\&     5    my $self = shift;
\&     6
\&     7    my $action = $self\->YYName;
\&     8
\&     9    $self\->$action(@_);
\&    10  }
\&    11
\&    12  %%
\&    13  exp:        %name NUM
\&    14                NUM
\&    15          |   %name PLUS
\&    16                exp \*(Aq+\*(Aq exp
\&    17          |   %name TIMES
\&    18                exp \*(Aq*\*(Aq exp
\&    19          |   \*(Aq(\*(Aq exp \*(Aq)\*(Aq
\&    20                { $_[2] }
\&    21  ;
\&    22
\&    23  %%
\&    24
\&    25  sub _Error {
\&    26    my($token)=$_[0]\->YYCurval;
\&    27    my($what)= $token ? "input: \*(Aq$token\*(Aq" : "end of input";
\&    28    my @expected = $_[0]\->YYExpect();
\&    29
\&    30    local $" = \*(Aq, \*(Aq;
\&    31    die "Syntax error near $what. Expected one of these tokens: @expected\en";
\&    32  }
\&    33
\&    34
\&    35  my $x = \*(Aq\*(Aq;
\&    36
\&    37  sub _Lexer {
\&    38    my($parser)=shift;
\&    39
\&    40    for ($x) {
\&    41      s/^\es+//;
\&    42      $_ eq \*(Aq\*(Aq and return(\*(Aq\*(Aq,undef);
\&    43
\&    44      s/^([0\-9]+(?:\e.[0\-9]+)?)//   and return(\*(AqNUM\*(Aq,$1);
\&    45      s/^([A\-Za\-z][A\-Za\-z0\-9_]*)// and return(\*(AqVAR\*(Aq,$1);
\&    46      s/^(.)//s                    and return($1,$1);
\&    47    }
\&    48  }
\&    49
\&    50  sub Run {
\&    51    my($self)=shift;
\&    52    $x = shift;
\&    53    my $debug = shift;
\&    54
\&    55    $self\->YYParse(
\&    56      yylex => \e&_Lexer,
\&    57      yyerror => \e&_Error,
\&    58      yydebug => $debug,
\&    59    );
\&    60  }
.Ve
.PP
The following program defines two classes: \f(CW\*(C`CalcActions\*(C'\fR
that implements the actions for the calculator
and package \f(CW\*(C`PostActions\*(C'\fR that implements the actions
for the infix to postfix translation. This way we have an 
example that reuses the former grammar twice:
.PP
.Vb 10
\&  pl@europa:~/LEyapp/examples/recycle$ cat \-n icalcu_and_ipost.pl
\&     1  #!/usr/bin/perl \-w
\&     2  package CalcActions;
\&     3  use strict;
\&     4  use base qw{NoacInh};
\&     5
\&     6  sub NUM {
\&     7    return $_[1];
\&     8  }
\&     9
\&    10  sub PLUS {
\&    11    $_[1]+$_[3];
\&    12  }
\&    13
\&    14  sub TIMES {
\&    15    $_[1]*$_[3];
\&    16  }
\&    17
\&    18  package PostActions;
\&    19  use strict;
\&    20  use base qw{NoacInh};
\&    21
\&    22  sub NUM {
\&    23    return $_[1];
\&    24  }
\&    25
\&    26  sub PLUS {
\&    27    "$_[1] $_[3] +";
\&    28  }
\&    29
\&    30  sub TIMES {
\&    31    "$_[1] $_[3] *";
\&    32  }
\&    33
\&    34  package main;
\&    35  use strict;
\&    36
\&    37  my $calcparser = CalcActions\->new();
\&    38  print "Write an expression: ";
\&    39  my $x = <STDIN>;
\&    40  my $e = $calcparser\->Run($x);
\&    41
\&    42  print "$e\en";
\&    43
\&    44  my $postparser = PostActions\->new();
\&    45  my $p = $postparser\->Run($x);
\&    46
\&    47  print "$p\en";
.Ve
.PP
The subroutine used as default action in \f(CW\*(C`NoacInh.eyp\*(C'\fR is so useful 
that is packed as the Parse::Eyapp::Driver method 
\&\f(CW\*(C`YYDelegateaction\*(C'\fR.
.PP
See files \f(CW\*(C`examples/recycle/NoacYYDelegateaction.eyp\*(C'\fR
and \f(CW\*(C`examples/recycle/icalcu_and_ipost_yydel.pl\*(C'\fR
for an example of use of \f(CW\*(C`YYDelegateaction\*(C'\fR.
.SS "Reusing Grammars by Dynamic Substitution of Semantic Actions"
.IX Subsection "Reusing Grammars by Dynamic Substitution of Semantic Actions"
The methods \f(CW\*(C`YYSetaction\*(C'\fR and \f(CW\*(C`YYAction\*(C'\fR of the parser object provide a way
to selectively substitute some actions of a given grammar.
Let us consider once more a postfix to infix translator:
.PP
.Vb 10
\&  pl@europa:~/LEyapp/examples/recycle$ cat \-n PostfixWithActions.eyp
\&     1  # File PostfixWithActions.eyp
\&     2  %right  \*(Aq=\*(Aq
\&     3  %left   \*(Aq\-\*(Aq \*(Aq+\*(Aq
\&     4  %left   \*(Aq*\*(Aq \*(Aq/\*(Aq
\&     5  %left   NEG
\&     6
\&     7  %%
\&     8  line: $exp  { print "$exp\en" }
\&     9  ;
\&    10
\&    11  exp:        $NUM
\&    12                  { $NUM }
\&    13          |   $VAR
\&    14                  { $VAR }
\&    15          |   %name ASSIGN
\&    16                VAR.left \*(Aq=\*(Aqexp.right
\&    17                  { "$_[3] &$_[1] ASSIGN"; }
\&    18          |   %name PLUS
\&    19                exp.left \*(Aq+\*(Aqexp.right
\&    20                  { "$_[1] $_[3] PLUS"; }
\&    21          |   %name MINUS
\&    22                exp.left \*(Aq\-\*(Aqexp.right
\&    23                  { "$_[1] $_[3] MINUS"; }
\&    24          |   %name TIMES
\&    25                exp.left \*(Aq*\*(Aqexp.right
\&    26                  { "$_[1] $_[3] TIMES"; }
\&    27          |   %name DIV
\&    28                exp.left \*(Aq/\*(Aqexp.right
\&    29                  { "$_[1] $_[3] DIV"; }
\&    30          |   %name NEG \*(Aq\-\*(Aq $exp %prec NEG
\&    31                  { "$exp NEG" }
\&    32          |   \*(Aq(\*(Aq $exp \*(Aq)\*(Aq
\&    33                  { $exp }
\&    34  ;
\&    35
\&    36  %%
\&    37
\&    38  sub _Error {
\&    39    my($token)=$_[0]\->YYCurval;
\&    40    my($what)= $token ? "input: \*(Aq$token\*(Aq" : "end of input";
\&    41    my @expected = $_[0]\->YYExpect();
\&    42
\&    43    local $" = \*(Aq, \*(Aq;
\&    44    die "Syntax error near $what. Expected one of these tokens: @expected\en";
\&    45  }
\&    46
\&    47  my $x;
\&    48
\&    49  sub _Lexer {
\&    50    my($parser)=shift;
\&    51
\&    52    for ($x) {
\&    53      s/^\es+//;
\&    54      $_ eq \*(Aq\*(Aq and return(\*(Aq\*(Aq,undef);
\&    55
\&    56      s/^([0\-9]+(?:\e.[0\-9]+)?)//   and return(\*(AqNUM\*(Aq,$1);
\&    57      s/^([A\-Za\-z][A\-Za\-z0\-9_]*)// and return(\*(AqVAR\*(Aq,$1);
\&    58      s/^(.)//s                    and return($1,$1);
\&    59    }
\&    60  }
\&    61
\&    62  sub Run {
\&    63    my($self)=shift;
\&    64    $x = shift;
\&    65    $self\->YYParse( yylex => \e&_Lexer, yyerror => \e&_Error,
\&    66      #yydebug => 0xFF
\&    67    );
\&    68  }
.Ve
.PP
The program \f(CW\*(C`rewritepostfixwithactions.pl\*(C'\fR uses the former grammar
to translate infix expressions to postfix expressions.
It also implements a calculator reusing the grammar in
\&\f(CW\*(C`PostfixWithActions.eyp\*(C'\fR. It does so using
the \f(CW\*(C`YYSetaction\*(C'\fR method.
The semantic actions for the productions named
.IP "\(bu" 2
\&\s-1ASSIGN\s0
.IP "\(bu" 2
\&\s-1PLUS\s0
.IP "\(bu" 2
\&\s-1TIMES\s0
.IP "\(bu" 2
\&\s-1DIV\s0
.IP "\(bu" 2
\&\s-1NEG\s0
.PP
are selectively substituted by the appropriate actions, while the other
semantic actions remain unchanged:
.PP
.Vb 10
\&  pl@europa:~/LEyapp/examples/recycle$ cat \-n rewritepostfixwithactions.pl
\&     1  #!/usr/bin/perl
\&     2  use warnings;
\&     3  use PostfixWithActions;
\&     4
\&     5  my $debug = shift || 0;
\&     6  my $pparser = PostfixWithActions\->new();
\&     7  print "Write an expression: ";
\&     8  my $x = <STDIN>;
\&     9
\&    10  # First, trasnlate to postfix ...
\&    11  $pparser\->Run($x, $debug);
\&    12
\&    13  # And then selectively substitute
\&    14  # some semantic actions
\&    15  # to obtain an infix calculator ...
\&    16  my %s;            # symbol table
\&    17  $pparser\->YYSetaction(
\&    18    ASSIGN => sub { $s{$_[1]} = $_[3] },
\&    19    PLUS   => sub { $_[1] + $_[3] },
\&    20    TIMES  => sub { $_[1] * $_[3] },
\&    21    DIV    => sub { $_[1] / $_[3] },
\&    22    NEG    => sub { \-$_[2] },
\&    23  );
\&    24
\&    25  $pparser\->Run($x, $debug);
.Ve
.PP
When running this program the output is:
.PP
.Vb 8
\&  examples/recycle$ ./rewritepostfixwithactions.pl
\&  Write an expression: 2*3+4
\&  2 3 TIMES 4 PLUS
\&  10
\&  examples/recycle$ rewritepostfixwithactions.pl
\&  Write an expression: a = 2*(b = 3+5)
\&  2 3 5 PLUS &b ASSIGN TIMES &a ASSIGN
\&  16
.Ve
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.IP "\(bu" 4
The project home is at <http://code.google.com/p/parse\-eyapp/>.
Use a subversion client to anonymously check out the latest project source code:
.Sp
.Vb 1
\&   svn checkout http://parse\-eyapp.googlecode.com/svn/trunk/ parse\-eyapp\-read\-only
.Ve
.IP "\(bu" 4
The tutorial \fIParsing Strings and Trees with\fR \f(CW\*(C`Parse::Eyapp\*(C'\fR
(An Introduction to Compiler Construction in seven pages) in
<http://nereida.deioc.ull.es/~pl/eyapsimple/>
.IP "\(bu" 4
Parse::Eyapp, 
Parse::Eyapp::eyapplanguageref, 
Parse::Eyapp::debuggingtut,
Parse::Eyapp::defaultactionsintro,
Parse::Eyapp::translationschemestut,
Parse::Eyapp::Driver,
Parse::Eyapp::Node,
Parse::Eyapp::YATW,
Parse::Eyapp::Treeregexp,
Parse::Eyapp::Scope,
Parse::Eyapp::Base,
Parse::Eyapp::datagenerationtut
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/languageintro.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/debuggingtut.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/eyapplanguageref.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/Treeregexp.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/Node.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/YATW.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/Eyapp.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/Base.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/translationschemestut.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/treematchingtut.pdf>
.IP "\(bu" 4
perldoc eyapp,
.IP "\(bu" 4
perldoc treereg,
.IP "\(bu" 4
perldoc vgg,
.IP "\(bu" 4
The Syntax Highlight file for vim at <http://www.vim.org/scripts/script.php?script_id=2453>
and <http://nereida.deioc.ull.es/~vim/>
.IP "\(bu" 4
\&\fIAnalisis Lexico y Sintactico\fR, (Notes for a course in compiler 
construction) by  Casiano Rodriguez-Leon. 
Available at  <http://nereida.deioc.ull.es/~pl/perlexamples/>
Is the more complete and reliable source for Parse::Eyapp. However is in Spanish.
.IP "\(bu" 4
Parse::Yapp,
.IP "\(bu" 4
Man pages of \fIyacc\fR\|(1) and
\&\fIbison\fR\|(1),
<http://www.delorie.com/gnu/docs/bison/bison.html>
.IP "\(bu" 4
Language::AttributeGrammar
.IP "\(bu" 4
Parse::RecDescent.
.IP "\(bu" 4
HOP::Parser
.IP "\(bu" 4
HOP::Lexer
.IP "\(bu" 4
ocamlyacc tutorial at 
<http://plus.kaist.ac.kr/~shoh/ocaml/ocamllex\-ocamlyacc/ocamlyacc\-tutorial/ocamlyacc\-tutorial.html>
.SH "REFERENCES"
.IX Header "REFERENCES"
.IP "\(bu" 4
The classic Dragon's book \fICompilers: Principles, Techniques, and Tools\fR 
by Alfred V. Aho, Ravi Sethi and
Jeffrey D. Ullman (Addison-Wesley 1986)
.IP "\(bu" 4
\&\fI\s-1CS2121:\s0 The Implementation and Power of Programming Languages\fR
(See <http://www.cs.man.ac.uk/~pjj>, <http://www.cs.man.ac.uk/~pjj/complang/g2lr.html> 
and <http://www.cs.man.ac.uk/~pjj/cs2121/ho/ho.html>) by 
Pete Jinks
.SH "CONTRIBUTORS"
.IX Header "CONTRIBUTORS"
.IP "\(bu" 2
Hal Finkel <http://www.halssoftware.com/>
.IP "\(bu" 2
G. Williams <http://kasei.us/>
.IP "\(bu" 2
Thomas L. Shinnick <http://search.cpan.org/~tshinnic/>
.IP "\(bu" 2
Frank Leray
.SH "AUTHOR"
.IX Header "AUTHOR"
Casiano Rodriguez-Leon (casiano@ull.es)
.SH "ACKNOWLEDGMENTS"
.IX Header "ACKNOWLEDGMENTS"
This work has been supported by \s-1CEE \s0(\s-1FEDER\s0) and the Spanish Ministry of
\&\fIEducacion y Ciencia\fR through \fIPlan Nacional I+D+I\fR number \s-1TIN2005\-08818\-C04\-04
\&\s0(\s-1ULL::OPLINK\s0 project <http://www.oplink.ull.es/>). 
Support from Gobierno de Canarias was through \s-1GC02210601
\&\s0(\fIGrupos Consolidados\fR).
The University of La Laguna has also supported my work in many ways
and for many years.
.PP
A large percentage of  code is verbatim taken from Parse::Yapp 1.05.
The author of Parse::Yapp is Francois Desarmenien.
.PP
I wish to thank Francois Desarmenien for his Parse::Yapp module, 
to my students at La Laguna and to the Perl Community. Thanks to 
the people who have contributed to improve the module (see \*(L"\s-1CONTRIBUTORS\*(R"\s0 in Parse::Eyapp).
Thanks to Larry Wall for giving us Perl.
Special thanks to Juana.
.SH "LICENCE AND COPYRIGHT"
.IX Header "LICENCE AND COPYRIGHT"
Copyright (c) 2006\-2008 Casiano Rodriguez-Leon (casiano@ull.es). All rights reserved.
.PP
Parse::Yapp copyright is of Francois Desarmenien, all rights reserved. 1998\-2001
.PP
These modules are free software; you can redistribute it and/or
modify it under the same terms as Perl itself. See perlartistic.
.PP
This program is distributed in the hope that it will be useful,
but \s-1WITHOUT ANY WARRANTY\s0; without even the implied warranty of
\&\s-1MERCHANTABILITY\s0 or \s-1FITNESS FOR A PARTICULAR PURPOSE. \s0
.SH "POD ERRORS"
.IX Header "POD ERRORS"
Hey! \fBThe above document had some coding errors, which are explained below:\fR
.IP "Around line 232:" 4
.IX Item "Around line 232:"
Non-ASCII character seen before =encoding in 'va\*'lida\en";'. Assuming \s-1UTF\-8\s0
