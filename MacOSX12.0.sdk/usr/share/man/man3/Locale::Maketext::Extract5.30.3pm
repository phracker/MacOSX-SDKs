.\" Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Locale::Maketext::Extract 3"
.TH Locale::Maketext::Extract 3 "2014-03-06" "perl v5.30.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Locale::Maketext::Extract \- Extract translatable strings from source
.SH "VERSION"
.IX Header "VERSION"
version 1.00
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 3
\&    my $Ext = Locale::Maketext::Extract\->new;
\&    $Ext\->read_po(\*(Aqmessages.po\*(Aq);
\&    $Ext\->extract_file($_) for <*.pl>;
\&
\&    # Set $entries_are_in_gettext_format if the .pl files above use
\&    # loc(\*(Aq%1\*(Aq) instead of loc(\*(Aq[_1]\*(Aq)
\&    $Ext\->compile($entries_are_in_gettext_format);
\&
\&    $Ext\->write_po(\*(Aqmessages.po\*(Aq);
\&
\&    \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&
\&    ### Specifying parser plugins ###
\&
\&    my $Ext = Locale::Maketext::Extract\->new(
\&
\&        # Specify which parser plugins to use
\&        plugins => {
\&
\&            # Use Perl parser, process files with extension .pl .pm .cgi
\&            perl => [],
\&
\&            # Use YAML parser, process all files
\&            yaml => [\*(Aq*\*(Aq],
\&
\&            # Use TT2 parser, process files with extension .tt2 .tt .html
\&            # or which match the regex
\&            tt2  => [
\&                \*(Aqtt2\*(Aq,
\&                \*(Aqtt\*(Aq,
\&                \*(Aqhtml\*(Aq,
\&                qr/\e.tt2?\e./
\&            ],
\&
\&            # Use My::Module as a parser for all files
\&            \*(AqMy::Module\*(Aq => [\*(Aq*\*(Aq],
\&
\&        },
\&
\&        # Warn if a parser can\*(Aqt process a file or problems loading a plugin
\&        warnings => 1,
\&
\&        # List processed files
\&        verbose => 1,
\&
\&    );
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module can extract translatable strings from files, and write
them back to \s-1PO\s0 files.  It can also parse existing \s-1PO\s0 files and merge
their contents with newly extracted strings.
.PP
A command-line utility, xgettext.pl, is installed with this module
as well.
.PP
The format parsers are loaded as plugins, so it is possible to define
your own parsers.
.PP
Following formats of input files are supported:
.IP "Perl source files  (plugin: perl)" 4
.IX Item "Perl source files (plugin: perl)"
Valid localization function names are: \f(CW\*(C`translate\*(C'\fR, \f(CW\*(C`maketext\*(C'\fR,
\&\f(CW\*(C`gettext\*(C'\fR, \f(CW\*(C`l\*(C'\fR, \f(CW\*(C`loc\*(C'\fR, \f(CW\*(C`x\*(C'\fR, \f(CW\*(C`_\*(C'\fR and \f(CW\*(C`_\|_\*(C'\fR.
.Sp
For a slightly more accurate, but much slower Perl parser, you can  use the \s-1PPI\s0
plugin. This does not have a short name (like \f(CW\*(C`perl\*(C'\fR), but must be specified
in full.
.IP "HTML::Mason (Mason 1) and Mason (Mason 2) (plugin: mason)" 4
.IX Item "HTML::Mason (Mason 1) and Mason (Mason 2) (plugin: mason)"
HTML::Mason (aka Mason 1)
 Strings inside <&|/l>...</&> and <&|/loc>...</&> are extracted.
.Sp
Mason (aka Mason 2)
Strings inside <% $.floc { %>...</%> or <% $.fl { %>...</%> or
<% \f(CW$self\fR\->floc { %>...</%> or <% \f(CW$self\fR\->fl { %>...</%> are extracted.
.IP "Template Toolkit (plugin: tt2)" 4
.IX Item "Template Toolkit (plugin: tt2)"
Valid forms are:
.Sp
.Vb 3
\&  [% | l(arg1,argn) %]string[% END %]
\&  [% \*(Aqstring\*(Aq | l(arg1,argn) %]
\&  [% l(\*(Aqstring\*(Aq,arg1,argn) %]
\&
\&  FILTER and | are interchangeable
\&  l and loc are interchangeable
\&  args are optional
.Ve
.IP "Text::Template (plugin: text)" 4
.IX Item "Text::Template (plugin: text)"
Sentences between \f(CW\*(C`STARTxxx\*(C'\fR and \f(CW\*(C`ENDxxx\*(C'\fR are extracted individually.
.IP "\s-1YAML\s0 (plugin: yaml)" 4
.IX Item "YAML (plugin: yaml)"
Valid forms are _\*(L"string\*(R" or _'string', eg:
.Sp
.Vb 2
\&    title: _"My title"
\&    desc:  _\*(AqMy "quoted" string\*(Aq
.Ve
.Sp
Quotes do not have to be escaped, so you could also do:
.Sp
.Vb 1
\&    desc:  _"My "quoted" string"
.Ve
.IP "HTML::FormFu (plugin: formfu)" 4
.IX Item "HTML::FormFu (plugin: formfu)"
HTML::FormFu uses a config-file to generate forms, with built in
support for localizing errors, labels etc.
.Sp
We extract the text after \f(CW\*(C`_loc: \*(C'\fR:
    content_loc: this is the string
    message_loc: ['Max string length: [_1]', 10]
.IP "Generic Template (plugin: generic)" 4
.IX Item "Generic Template (plugin: generic)"
Strings inside {{...}} are extracted.
.SH "METHODS"
.IX Header "METHODS"
.SS "Constructor"
.IX Subsection "Constructor"
.Vb 1
\&    new()
\&
\&    new(
\&        plugins   => {...},
\&        warnings  => 1 | 0,
\&        verbose   => 0 | 1 | 2 | 3,
\&    )
.Ve
.PP
See \*(L"Plugins\*(R", \*(L"Warnings\*(R" and \*(L"Verbose\*(R" for details
.SS "Plugins"
.IX Subsection "Plugins"
.Vb 1
\&    $ext\->plugins({...});
.Ve
.PP
Locale::Maketext::Extract uses plugins (see below for the list)
to parse different formats.
.PP
Each plugin can also specify which file types it can parse.
.PP
.Vb 3
\&    # use only the YAML plugin
\&    # only parse files with the default extension list defined in the plugin
\&    # ie .yaml .yml .conf
\&
\&    $ext\->plugins({
\&        yaml => [],
\&    })
\&
\&
\&    # use only the Perl plugin
\&    # parse all file types
\&
\&    $ext\->plugins({
\&        perl => \*(Aq*\*(Aq
\&    })
\&
\&    $ext\->plugins({
\&        tt2  => [
\&            \*(Aqtt\*(Aq,              # matches base filename against /\e.tt$/
\&            qr/\e.tt2?\e./,      # matches base filename against regex
\&            \e&my_filter,       # codref called
\&        ]
\&    })
\&
\&    sub my_filter {
\&        my ($base_filename,$path_to_file) = @_;
\&
\&        return 1 | 0;
\&    }
\&
\&    # Specify your own parser
\&    # only parse files with the default extension list defined in the plugin
\&
\&    $ext\->plugins({
\&        \*(AqMy::Extract::Parser\*(Aq  => []
\&    })
.Ve
.PP
By default, if no plugins are specified, it first tries to determine which
plugins are intended specifically for the file type and uses them. If no
such plugins are found, it then uses all of the builtin plugins, overriding
the file types specified in each.
.PP
\fIAvailable plugins\fR
.IX Subsection "Available plugins"
.ie n .IP """perl""    : Locale::Maketext::Extract::Plugin::Perl" 4
.el .IP "\f(CWperl\fR    : Locale::Maketext::Extract::Plugin::Perl" 4
.IX Item "perl : Locale::Maketext::Extract::Plugin::Perl"
For a slightly more accurate but much slower Perl parser, you can use
the \s-1PPI\s0 plugin. This does not have a short name, but must be specified in
full, ie: Locale::Maketext::Extract::Plugin::PPI
.ie n .IP """tt2""     : Locale::Maketext::Extract::Plugin::TT2" 4
.el .IP "\f(CWtt2\fR     : Locale::Maketext::Extract::Plugin::TT2" 4
.IX Item "tt2 : Locale::Maketext::Extract::Plugin::TT2"
.PD 0
.ie n .IP """yaml""    : Locale::Maketext::Extract::Plugin::YAML" 4
.el .IP "\f(CWyaml\fR    : Locale::Maketext::Extract::Plugin::YAML" 4
.IX Item "yaml : Locale::Maketext::Extract::Plugin::YAML"
.ie n .IP """formfu""  : Locale::Maketext::Extract::Plugin::FormFu" 4
.el .IP "\f(CWformfu\fR  : Locale::Maketext::Extract::Plugin::FormFu" 4
.IX Item "formfu : Locale::Maketext::Extract::Plugin::FormFu"
.ie n .IP """mason""   : Locale::Maketext::Extract::Plugin::Mason" 4
.el .IP "\f(CWmason\fR   : Locale::Maketext::Extract::Plugin::Mason" 4
.IX Item "mason : Locale::Maketext::Extract::Plugin::Mason"
.ie n .IP """text""    : Locale::Maketext::Extract::Plugin::TextTemplate" 4
.el .IP "\f(CWtext\fR    : Locale::Maketext::Extract::Plugin::TextTemplate" 4
.IX Item "text : Locale::Maketext::Extract::Plugin::TextTemplate"
.ie n .IP """generic"" : Locale::Maketext::Extract::Plugin::Generic" 4
.el .IP "\f(CWgeneric\fR : Locale::Maketext::Extract::Plugin::Generic" 4
.IX Item "generic : Locale::Maketext::Extract::Plugin::Generic"
.PD
.PP
Also, see Locale::Maketext::Extract::Plugin::Base for details of how to
write your own plugin.
.SS "Warnings"
.IX Subsection "Warnings"
Because the \s-1YAML\s0 and \s-1TT2\s0 plugins use proper parsers, rather than just regexes,
if a source file is not valid and it is unable to parse the file, then the
parser will throw an error and abort parsing.
.PP
The next enabled plugin will be tried.
.PP
By default, you will not see these errors.  If you would like to see them,
then enable warnings via \fBnew()\fR. All parse errors will be printed to \s-1STDERR.\s0
.PP
Also, if developing your own plugin, turn on warnings to see any errors that
result from loading your plugin.
.SS "Verbose"
.IX Subsection "Verbose"
If you would like to see which files have been processed, which plugins were
used, and which strings were extracted, then enable \f(CW\*(C`verbose\*(C'\fR. If no
acceptable plugin was found, or no strings were extracted, then the file
is not listed:
.PP
.Vb 1
\&      $ext = Locale::Extract\->new( verbose => 1 | 2 | 3);
\&
\&   OR
\&      xgettext.pl ... \-v           # files reported
\&      xgettext.pl ... \-v \-v        # files and plugins reported
\&      xgettext.pl ... \-v \-v \-v     # files, plugins and strings reported
.Ve
.SS "Accessors"
.IX Subsection "Accessors"
.Vb 6
\&    header, set_header
\&    lexicon, set_lexicon, msgstr, set_msgstr
\&    entries, set_entries, entry, add_entry, del_entry
\&    compiled_entries, set_compiled_entries, compiled_entry,
\&    add_compiled_entry, del_compiled_entry
\&    clear
.Ve
.SS "\s-1PO\s0 File manipulation"
.IX Subsection "PO File manipulation"
\fImethod read_po ($file)\fR
.IX Subsection "method read_po ($file)"
.PP
\fImethod write_po ($file, \f(CI$add_format_marker\fI?)\fR
.IX Subsection "method write_po ($file, $add_format_marker?)"
.SS "Extraction"
.IX Subsection "Extraction"
.Vb 2
\&    extract
\&    extract_file
.Ve
.SS "Compilation"
.IX Subsection "Compilation"
\fIcompile($entries_are_in_gettext_style?)\fR
.IX Subsection "compile($entries_are_in_gettext_style?)"
.PP
Merges the \f(CW\*(C`entries\*(C'\fR into \f(CW\*(C`compiled_entries\*(C'\fR.
.PP
If \f(CW$entries_are_in_gettext_style\fR is true, the previously extracted entries
are assumed to be in the \fBGettext\fR style (e.g. \f(CW%1\fR).
.PP
Otherwise they are assumed to be in \fBMaketext\fR style (e.g. \f(CW\*(C`[_1]\*(C'\fR) and are
converted into \fBGettext\fR style before merging into \f(CW\*(C`compiled_entries\*(C'\fR.
.PP
The \f(CW\*(C`entries\*(C'\fR are \fInot\fR cleared after each compilation; use
\&\f(CW\*(C`\-\*(C'\fR\fBset_entries()\fR> to clear them if you need to extract from sources with
varying styles.
.PP
\fInormalize_space\fR
.IX Subsection "normalize_space"
.SS "Lexicon accessors"
.IX Subsection "Lexicon accessors"
.Vb 3
\&    msgids, has_msgid,
\&    msgstr, set_msgstr
\&    msg_positions, msg_variables, msg_format, msg_out
.Ve
.SS "Internal utilities"
.IX Subsection "Internal utilities"
.Vb 5
\&    _default_header
\&    _maketext_to_gettext
\&    _escape
\&    _format
\&    _plugins_specifically_for_file
.Ve
.SH "ACKNOWLEDGMENTS"
.IX Header "ACKNOWLEDGMENTS"
Thanks to Jesse Vincent for contributing to an early version of this
module.
.PP
Also to Alain Barbet, who effectively re-wrote the source parser with a
flex-like algorithm.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
xgettext.pl, Locale::Maketext, Locale::Maketext::Lexicon
.SH "AUTHORS"
.IX Header "AUTHORS"
Audrey Tang <cpan@audreyt.org>
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright 2003\-2013 by Audrey Tang <cpan@audreyt.org>.
.PP
This software is released under the \s-1MIT\s0 license cited below.
.ie n .SS "The ""\s-1MIT""\s0 License"
.el .SS "The ``\s-1MIT''\s0 License"
.IX Subsection "The MIT License"
Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the \*(L"Software\*(R"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:
.PP
The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.
.PP
\&\s-1THE SOFTWARE IS PROVIDED \*(L"AS IS\*(R", WITHOUT WARRANTY OF ANY KIND, EXPRESS
OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.\s0
.SH "AUTHORS"
.IX Header "AUTHORS"
.IP "\(bu" 4
Clinton Gormley <drtech@cpan.org>
.IP "\(bu" 4
Audrey Tang <cpan@audreyt.org>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is Copyright (c) 2014 by Audrey Tang.
.PP
This is free software, licensed under:
.PP
.Vb 1
\&  The MIT (X11) License
.Ve
