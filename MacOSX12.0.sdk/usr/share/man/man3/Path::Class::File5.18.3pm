.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Path::Class::File 3"
.TH Path::Class::File 3 "2021-08-27" "perl v5.18.4" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Path::Class::File \- Objects representing files
.SH "VERSION"
.IX Header "VERSION"
version 0.33
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use Path::Class;  # Exports file() by default
\&  
\&  my $file = file(\*(Aqfoo\*(Aq, \*(Aqbar.txt\*(Aq);  # Path::Class::File object
\&  my $file = Path::Class::File\->new(\*(Aqfoo\*(Aq, \*(Aqbar.txt\*(Aq); # Same thing
\&  
\&  # Stringifies to \*(Aqfoo/bar.txt\*(Aq on Unix, \*(Aqfoo\ebar.txt\*(Aq on Windows, etc.
\&  print "file: $file\en";
\&  
\&  if ($file\->is_absolute) { ... }
\&  if ($file\->is_relative) { ... }
\&  
\&  my $v = $file\->volume; # Could be \*(AqC:\*(Aq on Windows, empty string
\&                         # on Unix, \*(AqMacintosh HD:\*(Aq on Mac OS
\&  
\&  $file\->cleanup; # Perform logical cleanup of pathname
\&  $file\->resolve; # Perform physical cleanup of pathname
\&  
\&  my $dir = $file\->dir;  # A Path::Class::Dir object
\&  
\&  my $abs = $file\->absolute; # Transform to absolute path
\&  my $rel = $file\->relative; # Transform to relative path
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The \f(CW\*(C`Path::Class::File\*(C'\fR class contains functionality for manipulating
file names in a cross-platform way.
.SH "METHODS"
.IX Header "METHODS"
.ie n .IP "$file = Path::Class::File\->new( <dir1>, <dir2>, ..., <file> )" 4
.el .IP "\f(CW$file\fR = Path::Class::File\->new( <dir1>, <dir2>, ..., <file> )" 4
.IX Item "$file = Path::Class::File->new( <dir1>, <dir2>, ..., <file> )"
.PD 0
.ie n .IP "$file = file( <dir1>, <dir2>, ..., <file> )" 4
.el .IP "\f(CW$file\fR = file( <dir1>, <dir2>, ..., <file> )" 4
.IX Item "$file = file( <dir1>, <dir2>, ..., <file> )"
.PD
Creates a new \f(CW\*(C`Path::Class::File\*(C'\fR object and returns it.  The
arguments specify the path to the file.  Any volume may also be
specified as the first argument, or as part of the first argument.
You can use platform-neutral syntax:
.Sp
.Vb 1
\&  my $file = file( \*(Aqfoo\*(Aq, \*(Aqbar\*(Aq, \*(Aqbaz.txt\*(Aq );
.Ve
.Sp
or platform-native syntax:
.Sp
.Vb 1
\&  my $file = file( \*(Aqfoo/bar/baz.txt\*(Aq );
.Ve
.Sp
or a mixture of the two:
.Sp
.Vb 1
\&  my $file = file( \*(Aqfoo/bar\*(Aq, \*(Aqbaz.txt\*(Aq );
.Ve
.Sp
All three of the above examples create relative paths.  To create an
absolute path, either use the platform native syntax for doing so:
.Sp
.Vb 1
\&  my $file = file( \*(Aq/var/tmp/foo.txt\*(Aq );
.Ve
.Sp
or use an empty string as the first argument:
.Sp
.Vb 1
\&  my $file = file( \*(Aq\*(Aq, \*(Aqvar\*(Aq, \*(Aqtmp\*(Aq, \*(Aqfoo.txt\*(Aq );
.Ve
.Sp
If the second form seems awkward, that's somewhat intentional \- paths
like \f(CW\*(C`/var/tmp\*(C'\fR or \f(CW\*(C`\eWindows\*(C'\fR aren't cross-platform concepts in the
first place, so they probably shouldn't appear in your code if you're
trying to be cross-platform.  The first form is perfectly fine,
because paths like this may come from config files, user input, or
whatever.
.ie n .IP "$file\->stringify" 4
.el .IP "\f(CW$file\fR\->stringify" 4
.IX Item "$file->stringify"
This method is called internally when a \f(CW\*(C`Path::Class::File\*(C'\fR object is
used in a string context, so the following are equivalent:
.Sp
.Vb 2
\&  $string = $file\->stringify;
\&  $string = "$file";
.Ve
.ie n .IP "$file\->volume" 4
.el .IP "\f(CW$file\fR\->volume" 4
.IX Item "$file->volume"
Returns the volume (e.g. \f(CW\*(C`C:\*(C'\fR on Windows, \f(CW\*(C`Macintosh HD:\*(C'\fR on Mac \s-1OS,\s0
etc.) of the object, if any.  Otherwise, returns the empty string.
.ie n .IP "$file\->basename" 4
.el .IP "\f(CW$file\fR\->basename" 4
.IX Item "$file->basename"
Returns the name of the file as a string, without the directory
portion (if any).
.ie n .IP "$file\->components" 4
.el .IP "\f(CW$file\fR\->components" 4
.IX Item "$file->components"
Returns a list of the directory components of this file, followed by
the basename.
.Sp
Note: unlike \f(CW\*(C`$dir\->components\*(C'\fR, this method currently does not
accept any arguments to select which elements of the list will be
returned.  It may do so in the future.  Currently it throws an
exception if such arguments are present.
.ie n .IP "$file\->is_dir" 4
.el .IP "\f(CW$file\fR\->is_dir" 4
.IX Item "$file->is_dir"
Returns a boolean value indicating whether this object represents a
directory.  Not surprisingly, \f(CW\*(C`Path::Class::File\*(C'\fR objects always
return false, and Path::Class::Dir objects always return true.
.ie n .IP "$file\->is_absolute" 4
.el .IP "\f(CW$file\fR\->is_absolute" 4
.IX Item "$file->is_absolute"
Returns true or false depending on whether the file refers to an
absolute path specifier (like \f(CW\*(C`/usr/local/foo.txt\*(C'\fR or \f(CW\*(C`\eWindows\eFoo.txt\*(C'\fR).
.ie n .IP "$file\->is_relative" 4
.el .IP "\f(CW$file\fR\->is_relative" 4
.IX Item "$file->is_relative"
Returns true or false depending on whether the file refers to a
relative path specifier (like \f(CW\*(C`lib/foo.txt\*(C'\fR or \f(CW\*(C`.\eFoo.txt\*(C'\fR).
.ie n .IP "$file\->cleanup" 4
.el .IP "\f(CW$file\fR\->cleanup" 4
.IX Item "$file->cleanup"
Performs a logical cleanup of the file path.  For instance:
.Sp
.Vb 2
\&  my $file = file(\*(Aq/foo//baz/./foo.txt\*(Aq)\->cleanup;
\&  # $file now represents \*(Aq/foo/baz/foo.txt\*(Aq;
.Ve
.ie n .IP "$dir\->resolve" 4
.el .IP "\f(CW$dir\fR\->resolve" 4
.IX Item "$dir->resolve"
Performs a physical cleanup of the file path.  For instance:
.Sp
.Vb 2
\&  my $file = file(\*(Aq/foo/baz/../foo.txt\*(Aq)\->resolve;
\&  # $file now represents \*(Aq/foo/foo.txt\*(Aq, assuming no symlinks
.Ve
.Sp
This actually consults the filesystem to verify the validity of the
path.
.ie n .IP "$dir = $file\->dir" 4
.el .IP "\f(CW$dir\fR = \f(CW$file\fR\->dir" 4
.IX Item "$dir = $file->dir"
Returns a \f(CW\*(C`Path::Class::Dir\*(C'\fR object representing the directory
containing this file.
.ie n .IP "$dir = $file\->parent" 4
.el .IP "\f(CW$dir\fR = \f(CW$file\fR\->parent" 4
.IX Item "$dir = $file->parent"
A synonym for the \f(CW\*(C`dir()\*(C'\fR method.
.ie n .IP "$abs = $file\->absolute" 4
.el .IP "\f(CW$abs\fR = \f(CW$file\fR\->absolute" 4
.IX Item "$abs = $file->absolute"
Returns a \f(CW\*(C`Path::Class::File\*(C'\fR object representing \f(CW$file\fR as an
absolute path.  An optional argument, given as either a string or a
Path::Class::Dir object, specifies the directory to use as the base
of relativity \- otherwise the current working directory will be used.
.ie n .IP "$rel = $file\->relative" 4
.el .IP "\f(CW$rel\fR = \f(CW$file\fR\->relative" 4
.IX Item "$rel = $file->relative"
Returns a \f(CW\*(C`Path::Class::File\*(C'\fR object representing \f(CW$file\fR as a
relative path.  An optional argument, given as either a string or a
\&\f(CW\*(C`Path::Class::Dir\*(C'\fR object, specifies the directory to use as the base
of relativity \- otherwise the current working directory will be used.
.ie n .IP "$foreign = $file\->as_foreign($type)" 4
.el .IP "\f(CW$foreign\fR = \f(CW$file\fR\->as_foreign($type)" 4
.IX Item "$foreign = $file->as_foreign($type)"
Returns a \f(CW\*(C`Path::Class::File\*(C'\fR object representing \f(CW$file\fR as it would
be specified on a system of type \f(CW$type\fR.  Known types include
\&\f(CW\*(C`Unix\*(C'\fR, \f(CW\*(C`Win32\*(C'\fR, \f(CW\*(C`Mac\*(C'\fR, \f(CW\*(C`VMS\*(C'\fR, and \f(CW\*(C`OS2\*(C'\fR, i.e. anything for which
there is a subclass of \f(CW\*(C`File::Spec\*(C'\fR.
.Sp
Any generated objects (subdirectories, files, parents, etc.) will also
retain this type.
.ie n .IP "$foreign = Path::Class::File\->new_foreign($type, @args)" 4
.el .IP "\f(CW$foreign\fR = Path::Class::File\->new_foreign($type, \f(CW@args\fR)" 4
.IX Item "$foreign = Path::Class::File->new_foreign($type, @args)"
Returns a \f(CW\*(C`Path::Class::File\*(C'\fR object representing a file as it would
be specified on a system of type \f(CW$type\fR.  Known types include
\&\f(CW\*(C`Unix\*(C'\fR, \f(CW\*(C`Win32\*(C'\fR, \f(CW\*(C`Mac\*(C'\fR, \f(CW\*(C`VMS\*(C'\fR, and \f(CW\*(C`OS2\*(C'\fR, i.e. anything for which
there is a subclass of \f(CW\*(C`File::Spec\*(C'\fR.
.Sp
The arguments in \f(CW@args\fR are the same as they would be specified in
\&\f(CW\*(C`new()\*(C'\fR.
.ie n .IP "$fh = $file\->open($mode, $permissions)" 4
.el .IP "\f(CW$fh\fR = \f(CW$file\fR\->open($mode, \f(CW$permissions\fR)" 4
.IX Item "$fh = $file->open($mode, $permissions)"
Passes the given arguments, including \f(CW$file\fR, to \f(CW\*(C`IO::File\->new\*(C'\fR
(which in turn calls \f(CW\*(C`IO::File\->open\*(C'\fR and returns the result
as an IO::File object.  If the opening
fails, \f(CW\*(C`undef\*(C'\fR is returned and \f(CW$!\fR is set.
.ie n .IP "$fh = $file\->\fIopenr()\fR" 4
.el .IP "\f(CW$fh\fR = \f(CW$file\fR\->\fIopenr()\fR" 4
.IX Item "$fh = $file->openr()"
A shortcut for
.Sp
.Vb 1
\& $fh = $file\->open(\*(Aqr\*(Aq) or croak "Can\*(Aqt read $file: $!";
.Ve
.ie n .IP "$fh = $file\->\fIopenw()\fR" 4
.el .IP "\f(CW$fh\fR = \f(CW$file\fR\->\fIopenw()\fR" 4
.IX Item "$fh = $file->openw()"
A shortcut for
.Sp
.Vb 1
\& $fh = $file\->open(\*(Aqw\*(Aq) or croak "Can\*(Aqt write to $file: $!";
.Ve
.ie n .IP "$fh = $file\->\fIopena()\fR" 4
.el .IP "\f(CW$fh\fR = \f(CW$file\fR\->\fIopena()\fR" 4
.IX Item "$fh = $file->opena()"
A shortcut for
.Sp
.Vb 1
\& $fh = $file\->open(\*(Aqa\*(Aq) or croak "Can\*(Aqt append to $file: $!";
.Ve
.ie n .IP "$file\->touch" 4
.el .IP "\f(CW$file\fR\->touch" 4
.IX Item "$file->touch"
Sets the modification and access time of the given file to right now,
if the file exists.  If it doesn't exist, \f(CW\*(C`touch()\*(C'\fR will \fImake\fR it
exist, and \- \s-1YES\s0! \- set its modification and access time to now.
.ie n .IP "$file\->\fIslurp()\fR" 4
.el .IP "\f(CW$file\fR\->\fIslurp()\fR" 4
.IX Item "$file->slurp()"
In a scalar context, returns the contents of \f(CW$file\fR in a string.  In
a list context, returns the lines of \f(CW$file\fR (according to how \f(CW$/\fR
is set) as a list.  If the file can't be read, this method will throw
an exception.
.Sp
If you want \f(CW\*(C`chomp()\*(C'\fR run on each line of the file, pass a true value
for the \f(CW\*(C`chomp\*(C'\fR or \f(CW\*(C`chomped\*(C'\fR parameters:
.Sp
.Vb 1
\&  my @lines = $file\->slurp(chomp => 1);
.Ve
.Sp
You may also use the \f(CW\*(C`iomode\*(C'\fR parameter to pass in an \s-1IO\s0 mode to use
when opening the file, usually \s-1IO\s0 layers (though anything accepted by
the \s-1MODE\s0 argument of \f(CW\*(C`open()\*(C'\fR is accepted here).  Just make sure it's
a \fIreading\fR mode.
.Sp
.Vb 2
\&  my @lines = $file\->slurp(iomode => \*(Aq:crlf\*(Aq);
\&  my $lines = $file\->slurp(iomode => \*(Aq<:encoding(UTF\-8)\*(Aq);
.Ve
.Sp
The default \f(CW\*(C`iomode\*(C'\fR is \f(CW\*(C`r\*(C'\fR.
.Sp
Lines can also be automatically split, mimicking the perl command-line
option \f(CW\*(C`\-a\*(C'\fR by using the \f(CW\*(C`split\*(C'\fR parameter. If this parameter is used,
each line will be returned as an array ref.
.Sp
.Vb 1
\&    my @lines = $file\->slurp( chomp => 1, split => qr/\es*,\es*/ );
.Ve
.Sp
The \f(CW\*(C`split\*(C'\fR parameter can only be used in a list context.
.ie n .IP "$file\->spew( $content );" 4
.el .IP "\f(CW$file\fR\->spew( \f(CW$content\fR );" 4
.IX Item "$file->spew( $content );"
The opposite of \*(L"slurp\*(R", this takes a list of strings and prints them
to the file in write mode.  If the file can't be written to, this method
will throw an exception.
.Sp
The content to be written can be either an array ref or a plain scalar.
If the content is an array ref then each entry in the array will be
written to the file.
.Sp
You may use the \f(CW\*(C`iomode\*(C'\fR parameter to pass in an \s-1IO\s0 mode to use when
opening the file, just like \*(L"slurp\*(R" supports.
.Sp
.Vb 1
\&  $file\->spew(iomode => \*(Aq>:raw\*(Aq, $content);
.Ve
.Sp
The default \f(CW\*(C`iomode\*(C'\fR is \f(CW\*(C`w\*(C'\fR.
.ie n .IP "$file\->traverse(sub { ... }, @args)" 4
.el .IP "\f(CW$file\fR\->traverse(sub { ... }, \f(CW@args\fR)" 4
.IX Item "$file->traverse(sub { ... }, @args)"
Calls the given callback on \f(CW$file\fR. This doesn't do much on its own,
but see the associated documentation in Path::Class::Dir.
.ie n .IP "$file\->\fIremove()\fR" 4
.el .IP "\f(CW$file\fR\->\fIremove()\fR" 4
.IX Item "$file->remove()"
This method will remove the file in a way that works well on all
platforms, and returns a boolean value indicating whether or not the
file was successfully removed.
.Sp
\&\f(CW\*(C`remove()\*(C'\fR is better than simply calling Perl's \f(CW\*(C`unlink()\*(C'\fR function,
because on some platforms (notably \s-1VMS\s0) you actually may need to call
\&\f(CW\*(C`unlink()\*(C'\fR several times before all versions of the file are gone \-
the \f(CW\*(C`remove()\*(C'\fR method handles this process for you.
.ie n .IP "$st = $file\->\fIstat()\fR" 4
.el .IP "\f(CW$st\fR = \f(CW$file\fR\->\fIstat()\fR" 4
.IX Item "$st = $file->stat()"
Invokes \f(CW\*(C`File::stat::stat()\*(C'\fR on this file and returns a
File::stat object representing the result.
.ie n .IP "$st = $file\->\fIlstat()\fR" 4
.el .IP "\f(CW$st\fR = \f(CW$file\fR\->\fIlstat()\fR" 4
.IX Item "$st = $file->lstat()"
Same as \f(CW\*(C`stat()\*(C'\fR, but if \f(CW$file\fR is a symbolic link, \f(CW\*(C`lstat()\*(C'\fR
stats the link instead of the file the link points to.
.ie n .IP "$class = $file\->\fIdir_class()\fR" 4
.el .IP "\f(CW$class\fR = \f(CW$file\fR\->\fIdir_class()\fR" 4
.IX Item "$class = $file->dir_class()"
Returns the class which should be used to create directory objects.
.Sp
Generally overridden whenever this class is subclassed.
.ie n .IP "$file\->copy_to( $dest );" 4
.el .IP "\f(CW$file\fR\->copy_to( \f(CW$dest\fR );" 4
.IX Item "$file->copy_to( $dest );"
Copies the \f(CW$file\fR to \f(CW$dest\fR.
.ie n .IP "$file\->move_to( $dest );" 4
.el .IP "\f(CW$file\fR\->move_to( \f(CW$dest\fR );" 4
.IX Item "$file->move_to( $dest );"
Moves the \f(CW$file\fR to \f(CW$dest\fR.
.SH "AUTHOR"
.IX Header "AUTHOR"
Ken Williams, kwilliams@cpan.org
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Path::Class, Path::Class::Dir, File::Spec
