.\" Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Moose::Meta::TypeConstraint::Union 3"
.TH Moose::Meta::TypeConstraint::Union 3 "2019-11-22" "perl v5.30.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Moose::Meta::TypeConstraint::Union \- A union of Moose type constraints
.SH "VERSION"
.IX Header "VERSION"
version 2.2012
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This metaclass represents a union of type constraints. A union takes
multiple type constraints, and is true if any one of its member
constraints is true.
.SH "INHERITANCE"
.IX Header "INHERITANCE"
\&\f(CW\*(C`Moose::Meta::TypeConstraint::Union\*(C'\fR is a subclass of
Moose::Meta::TypeConstraint.
.SH "METHODS"
.IX Header "METHODS"
.SS "Moose::Meta::TypeConstraint::Union\->new(%options)"
.IX Subsection "Moose::Meta::TypeConstraint::Union->new(%options)"
This creates a new class type constraint based on the given
\&\f(CW%options\fR.
.PP
It takes the same options as its parent. It also requires an
additional option, \f(CW\*(C`type_constraints\*(C'\fR. This is an array reference
containing the Moose::Meta::TypeConstraint objects that are the
members of the union type. The \f(CW\*(C`name\*(C'\fR option defaults to the names
all of these member types sorted and then joined by a pipe (|).
.PP
The constructor sets the implementation of the constraint so that is
simply calls \f(CW\*(C`check\*(C'\fR on the newly created object.
.PP
Finally, the constructor also makes sure that the object's \f(CW\*(C`coercion\*(C'\fR
attribute is a Moose::Meta::TypeCoercion::Union object.
.ie n .SS "$constraint\->type_constraints"
.el .SS "\f(CW$constraint\fP\->type_constraints"
.IX Subsection "$constraint->type_constraints"
This returns the array reference of \f(CW\*(C`type_constraints\*(C'\fR provided to
the constructor.
.ie n .SS "$constraint\->parent"
.el .SS "\f(CW$constraint\fP\->parent"
.IX Subsection "$constraint->parent"
This returns the nearest common ancestor of all the components of the union.
.ie n .SS "$constraint\->check($value)"
.el .SS "\f(CW$constraint\fP\->check($value)"
.IX Subsection "$constraint->check($value)"
.ie n .SS "$constraint\->validate($value)"
.el .SS "\f(CW$constraint\fP\->validate($value)"
.IX Subsection "$constraint->validate($value)"
These two methods simply call the relevant method on each of the
member type constraints in the union. If any type accepts the value,
the value is valid.
.PP
With \f(CW\*(C`validate\*(C'\fR the error message returned includes all of the error
messages returned by the member type constraints.
.ie n .SS "$constraint\->equals($type_name_or_object)"
.el .SS "\f(CW$constraint\fP\->equals($type_name_or_object)"
.IX Subsection "$constraint->equals($type_name_or_object)"
A type is considered equal if it is also a union type, and the two
unions have the same member types.
.ie n .SS "$constraint\->find_type_for($value)"
.el .SS "\f(CW$constraint\fP\->find_type_for($value)"
.IX Subsection "$constraint->find_type_for($value)"
This returns the first member type constraint for which \f(CW\*(C`check($value)\*(C'\fR is
true, allowing you to determine which of the Union's member type constraints
a given value matches.
.ie n .SS "$constraint\->is_a_type_of($type_name_or_object)"
.el .SS "\f(CW$constraint\fP\->is_a_type_of($type_name_or_object)"
.IX Subsection "$constraint->is_a_type_of($type_name_or_object)"
This returns true if all of the member type constraints return true
for the \f(CW\*(C`is_a_type_of\*(C'\fR method.
.ie n .SS "$constraint\->is_subtype_of"
.el .SS "\f(CW$constraint\fP\->is_subtype_of"
.IX Subsection "$constraint->is_subtype_of"
This returns true if all of the member type constraints return true
for the \f(CW\*(C`is_subtype_of\*(C'\fR method.
.ie n .SS "$constraint\->create_child_type(%options)"
.el .SS "\f(CW$constraint\fP\->create_child_type(%options)"
.IX Subsection "$constraint->create_child_type(%options)"
This returns a new Moose::Meta::TypeConstraint object with the type
as its parent.
.SH "BUGS"
.IX Header "BUGS"
See \*(L"\s-1BUGS\*(R"\s0 in Moose for details on reporting bugs.
.SH "AUTHORS"
.IX Header "AUTHORS"
.IP "\(bu" 4
Stevan Little <stevan.little@iinteractive.com>
.IP "\(bu" 4
Dave Rolsky <autarch@urth.org>
.IP "\(bu" 4
Jesse Luehrs <doy@tozt.net>
.IP "\(bu" 4
Shawn M Moore <code@sartak.org>
.IP "\(bu" 4
יובל קוג'מן (Yuval Kogman) <nothingmuch@woobling.org>
.IP "\(bu" 4
Karen Etheridge <ether@cpan.org>
.IP "\(bu" 4
Florian Ragwitz <rafl@debian.org>
.IP "\(bu" 4
Hans Dieter Pearcey <hdp@weftsoar.net>
.IP "\(bu" 4
Chris Prather <chris@prather.org>
.IP "\(bu" 4
Matt S Trout <mst@shadowcat.co.uk>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is copyright (c) 2006 by Infinity Interactive, Inc.
.PP
This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.
