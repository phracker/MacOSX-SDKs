.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "File::Basename 3pm"
.TH File::Basename 3pm "2014-09-30" "perl v5.18.4" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
File::Basename \- Parse file paths into directory, filename and suffix.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use File::Basename;
\&
\&    ($name,$path,$suffix) = fileparse($fullname,@suffixlist);
\&    $name = fileparse($fullname,@suffixlist);
\&
\&    $basename = basename($fullname,@suffixlist);
\&    $dirname  = dirname($fullname);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
These routines allow you to parse file paths into their directory, filename
and suffix.
.PP
\&\fB\s-1NOTE\s0\fR: \f(CW\*(C`dirname()\*(C'\fR and \f(CW\*(C`basename()\*(C'\fR emulate the behaviours, and
quirks, of the shell and C functions of the same name.  See each
function's documentation for details.  If your concern is just parsing
paths it is safer to use File::Spec's \f(CW\*(C`splitpath()\*(C'\fR and
\&\f(CW\*(C`splitdir()\*(C'\fR methods.
.PP
It is guaranteed that
.PP
.Vb 2
\&    # Where $path_separator is / for Unix, \e for Windows, etc...
\&    dirname($path) . $path_separator . basename($path);
.Ve
.PP
is equivalent to the original path for all systems but \s-1VMS.\s0
.ie n .IP """fileparse""" 4
.el .IP "\f(CWfileparse\fR" 4
.IX Xref "fileparse"
.IX Item "fileparse"
.Vb 3
\&    my($filename, $directories, $suffix) = fileparse($path);
\&    my($filename, $directories, $suffix) = fileparse($path, @suffixes);
\&    my $filename                         = fileparse($path, @suffixes);
.Ve
.Sp
The \f(CW\*(C`fileparse()\*(C'\fR routine divides a file path into its \f(CW$directories\fR, \f(CW$filename\fR
and (optionally) the filename \f(CW$suffix\fR.
.Sp
\&\f(CW$directories\fR contains everything up to and including the last
directory separator in the \f(CW$path\fR including the volume (if applicable).
The remainder of the \f(CW$path\fR is the \f(CW$filename\fR.
.Sp
.Vb 2
\&     # On Unix returns ("baz", "/foo/bar/", "")
\&     fileparse("/foo/bar/baz");
\&
\&     # On Windows returns ("baz", \*(AqC:\efoo\ebar\e\*(Aq, "")
\&     fileparse(\*(AqC:\efoo\ebar\ebaz\*(Aq);
\&
\&     # On Unix returns ("", "/foo/bar/baz/", "")
\&     fileparse("/foo/bar/baz/");
.Ve
.Sp
If \f(CW@suffixes\fR are given each element is a pattern (either a string or a
\&\f(CW\*(C`qr//\*(C'\fR) matched against the end of the \f(CW$filename\fR.  The matching
portion is removed and becomes the \f(CW$suffix\fR.
.Sp
.Vb 2
\&     # On Unix returns ("baz", "/foo/bar/", ".txt")
\&     fileparse("/foo/bar/baz.txt", qr/\e.[^.]*/);
.Ve
.Sp
If type is non-Unix (see \*(L"fileparse_set_fstype\*(R") then the pattern
matching for suffix removal is performed case-insensitively, since
those systems are not case-sensitive when opening existing files.
.Sp
You are guaranteed that \f(CW\*(C`$directories . $filename . $suffix\*(C'\fR will
denote the same location as the original \f(CW$path\fR.
.ie n .IP """basename""" 4
.el .IP "\f(CWbasename\fR" 4
.IX Xref "basename filename"
.IX Item "basename"
.Vb 2
\&    my $filename = basename($path);
\&    my $filename = basename($path, @suffixes);
.Ve
.Sp
This function is provided for compatibility with the Unix shell command
\&\f(CWbasename(1)\fR.  It does \fB\s-1NOT\s0\fR always return the file name portion of a
path as you might expect.  To be safe, if you want the file name portion of
a path use \f(CW\*(C`fileparse()\*(C'\fR.
.Sp
\&\f(CW\*(C`basename()\*(C'\fR returns the last level of a filepath even if the last
level is clearly directory.  In effect, it is acting like \f(CW\*(C`pop()\*(C'\fR for
paths.  This differs from \f(CW\*(C`fileparse()\*(C'\fR's behaviour.
.Sp
.Vb 3
\&    # Both return "bar"
\&    basename("/foo/bar");
\&    basename("/foo/bar/");
.Ve
.Sp
\&\f(CW@suffixes\fR work as in \f(CW\*(C`fileparse()\*(C'\fR except all regex metacharacters are
quoted.
.Sp
.Vb 3
\&    # These two function calls are equivalent.
\&    my $filename = basename("/foo/bar/baz.txt",  ".txt");
\&    my $filename = fileparse("/foo/bar/baz.txt", qr/\eQ.txt\eE/);
.Ve
.Sp
Also note that in order to be compatible with the shell command,
\&\f(CW\*(C`basename()\*(C'\fR does not strip off a suffix if it is identical to the
remaining characters in the filename.
.ie n .IP """dirname""" 4
.el .IP "\f(CWdirname\fR" 4
.IX Xref "dirname"
.IX Item "dirname"
This function is provided for compatibility with the Unix shell
command \f(CWdirname(1)\fR and has inherited some of its quirks.  In spite of
its name it does \fB\s-1NOT\s0\fR always return the directory name as you might
expect.  To be safe, if you want the directory name of a path use
\&\f(CW\*(C`fileparse()\*(C'\fR.
.Sp
Only on \s-1VMS \s0(where there is no ambiguity between the file and directory
portions of a path) and AmigaOS (possibly due to an implementation quirk in
this module) does \f(CW\*(C`dirname()\*(C'\fR work like \f(CW\*(C`fileparse($path)\*(C'\fR, returning just the
\&\f(CW$directories\fR.
.Sp
.Vb 2
\&    # On VMS and AmigaOS
\&    my $directories = dirname($path);
.Ve
.Sp
When using Unix or \s-1MSDOS\s0 syntax this emulates the \f(CWdirname(1)\fR shell function
which is subtly different from how \f(CW\*(C`fileparse()\*(C'\fR works.  It returns all but
the last level of a file path even if the last level is clearly a directory.
In effect, it is not returning the directory portion but simply the path one
level up acting like \f(CW\*(C`chop()\*(C'\fR for file paths.
.Sp
Also unlike \f(CW\*(C`fileparse()\*(C'\fR, \f(CW\*(C`dirname()\*(C'\fR does not include a trailing slash on
its returned path.
.Sp
.Vb 2
\&    # returns /foo/bar.  fileparse() would return /foo/bar/
\&    dirname("/foo/bar/baz");
\&
\&    # also returns /foo/bar despite the fact that baz is clearly a 
\&    # directory.  fileparse() would return /foo/bar/baz/
\&    dirname("/foo/bar/baz/");
\&
\&    # returns \*(Aq.\*(Aq.  fileparse() would return \*(Aqfoo/\*(Aq
\&    dirname("foo/");
.Ve
.Sp
Under \s-1VMS,\s0 if there is no directory information in the \f(CW$path\fR, then the
current default device and directory is used.
.ie n .IP """fileparse_set_fstype""" 4
.el .IP "\f(CWfileparse_set_fstype\fR" 4
.IX Xref "filesystem"
.IX Item "fileparse_set_fstype"
.Vb 2
\&  my $type = fileparse_set_fstype();
\&  my $previous_type = fileparse_set_fstype($type);
.Ve
.Sp
Normally File::Basename will assume a file path type native to your current
operating system (ie. /foo/bar style on Unix, \efoo\ebar on Windows, etc...).
With this function you can override that assumption.
.Sp
Valid \f(CW$types\fR are \*(L"MacOS\*(R", \*(L"\s-1VMS\*(R", \s0\*(L"AmigaOS\*(R", \*(L"\s-1OS2\*(R", \*(L"RISCOS\*(R",
\&\s0\*(L"MSWin32\*(R", \*(L"\s-1DOS\*(R" \s0(also \*(L"\s-1MSDOS\*(R"\s0 for backwards bug compatibility),
\&\*(L"Epoc\*(R" and \*(L"Unix\*(R" (all case-insensitive).  If an unrecognized \f(CW$type\fR is
given \*(L"Unix\*(R" will be assumed.
.Sp
If you've selected \s-1VMS\s0 syntax, and the file specification you pass to
one of these routines contains a \*(L"/\*(R", they assume you are using Unix
emulation and apply the Unix syntax rules instead, for that function
call only.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fIdirname\fR\|(1), \fIbasename\fR\|(1), File::Spec
