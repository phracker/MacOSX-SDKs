.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "DB 3pm"
.TH DB 3pm "2014-09-30" "perl v5.18.4" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
DB \- programmatic interface to the Perl debugging API
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 3
\&    package CLIENT;
\&    use DB;
\&    @ISA = qw(DB);
\&
\&    # these (inherited) methods can be called by the client
\&
\&    CLIENT\->register()      # register a client package name
\&    CLIENT\->done()          # de\-register from the debugging API
\&    CLIENT\->skippkg(\*(Aqhide::hide\*(Aq)  # ask DB not to stop in this package
\&    CLIENT\->cont([WHERE])       # run some more (until BREAK or another breakpt)
\&    CLIENT\->step()              # single step
\&    CLIENT\->next()              # step over
\&    CLIENT\->ret()               # return from current subroutine
\&    CLIENT\->backtrace()         # return the call stack description
\&    CLIENT\->ready()             # call when client setup is done
\&    CLIENT\->trace_toggle()      # toggle subroutine call trace mode
\&    CLIENT\->subs([SUBS])        # return subroutine information
\&    CLIENT\->files()             # return list of all files known to DB
\&    CLIENT\->lines()             # return lines in currently loaded file
\&    CLIENT\->loadfile(FILE,LINE) # load a file and let other clients know
\&    CLIENT\->lineevents()        # return info on lines with actions
\&    CLIENT\->set_break([WHERE],[COND])
\&    CLIENT\->set_tbreak([WHERE])
\&    CLIENT\->clr_breaks([LIST])
\&    CLIENT\->set_action(WHERE,ACTION)
\&    CLIENT\->clr_actions([LIST])
\&    CLIENT\->evalcode(STRING)  # eval STRING in executing code\*(Aqs context
\&    CLIENT\->prestop([STRING]) # execute in code context before stopping
\&    CLIENT\->poststop([STRING])# execute in code context before resuming
\&
\&    # These methods will be called at the appropriate times.
\&    # Stub versions provided do nothing.
\&    # None of these can block.
\&
\&    CLIENT\->init()          # called when debug API inits itself
\&    CLIENT\->stop(FILE,LINE) # when execution stops
\&    CLIENT\->idle()          # while stopped (can be a client event loop)
\&    CLIENT\->cleanup()       # just before exit
\&    CLIENT\->output(LIST)    # called to print any output that API must show
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Perl debug information is frequently required not just by debuggers,
but also by modules that need some \*(L"special\*(R" information to do their
job properly, like profilers.
.PP
This module abstracts and provides all of the hooks into Perl internal
debugging functionality, so that various implementations of Perl debuggers
(or packages that want to simply get at the \*(L"privileged\*(R" debugging data)
can all benefit from the development of this common code.  Currently used
by Swat, the perl/Tk \s-1GUI\s0 debugger.
.PP
Note that multiple \*(L"front-ends\*(R" can latch into this debugging \s-1API\s0
simultaneously.  This is intended to facilitate things like
debugging with a command line and \s-1GUI\s0 at the same time, debugging 
debuggers etc.  [Sounds nice, but this needs some serious support \*(-- \s-1GSAR\s0]
.PP
In particular, this \s-1API\s0 does \fBnot\fR provide the following functions:
.IP "\(bu" 4
data display
.IP "\(bu" 4
command processing
.IP "\(bu" 4
command alias management
.IP "\(bu" 4
user interface (tty or graphical)
.PP
These are intended to be services performed by the clients of this \s-1API.\s0
.PP
This module attempts to be squeaky clean w.r.t \f(CW\*(C`use strict;\*(C'\fR and when
warnings are enabled.
.SS "Global Variables"
.IX Subsection "Global Variables"
The following \*(L"public\*(R" global names can be read by clients of this \s-1API.\s0
Beware that these should be considered \*(L"readonly\*(R".
.ie n .IP "$DB::sub" 8
.el .IP "\f(CW$DB::sub\fR" 8
.IX Item "$DB::sub"
Name of current executing subroutine.
.ie n .IP "%DB::sub" 8
.el .IP "\f(CW%DB::sub\fR" 8
.IX Item "%DB::sub"
The keys of this hash are the names of all the known subroutines.  Each value
is an encoded string that has the \fIsprintf\fR\|(3) format 
\&\f(CW\*(C`("%s:%d\-%d", filename, fromline, toline)\*(C'\fR.
.ie n .IP "$DB::single" 8
.el .IP "\f(CW$DB::single\fR" 8
.IX Item "$DB::single"
Single-step flag.  Will be true if the \s-1API\s0 will stop at the next statement.
.ie n .IP "$DB::signal" 8
.el .IP "\f(CW$DB::signal\fR" 8
.IX Item "$DB::signal"
Signal flag. Will be set to a true value if a signal was caught.  Clients may
check for this flag to abort time-consuming operations.
.ie n .IP "$DB::trace" 8
.el .IP "\f(CW$DB::trace\fR" 8
.IX Item "$DB::trace"
This flag is set to true if the \s-1API\s0 is tracing through subroutine calls.
.ie n .IP "@DB::args" 8
.el .IP "\f(CW@DB::args\fR" 8
.IX Item "@DB::args"
Contains the arguments of current subroutine, or the \f(CW@ARGV\fR array if in the 
toplevel context.
.ie n .IP "@DB::dbline" 8
.el .IP "\f(CW@DB::dbline\fR" 8
.IX Item "@DB::dbline"
List of lines in currently loaded file.
.ie n .IP "%DB::dbline" 8
.el .IP "\f(CW%DB::dbline\fR" 8
.IX Item "%DB::dbline"
Actions in current file (keys are line numbers).  The values are strings that
have the \fIsprintf\fR\|(3) format \f(CW\*(C`("%s\e000%s", breakcondition, actioncode)\*(C'\fR.
.ie n .IP "$DB::package" 8
.el .IP "\f(CW$DB::package\fR" 8
.IX Item "$DB::package"
Package namespace of currently executing code.
.ie n .IP "$DB::filename" 8
.el .IP "\f(CW$DB::filename\fR" 8
.IX Item "$DB::filename"
Currently loaded filename.
.ie n .IP "$DB::subname" 8
.el .IP "\f(CW$DB::subname\fR" 8
.IX Item "$DB::subname"
Fully qualified name of currently executing subroutine.
.ie n .IP "$DB::lineno" 8
.el .IP "\f(CW$DB::lineno\fR" 8
.IX Item "$DB::lineno"
Line number that will be executed next.
.SS "\s-1API\s0 Methods"
.IX Subsection "API Methods"
The following are methods in the \s-1DB\s0 base class.  A client must
access these methods by inheritance (*not* by calling them directly),
since the \s-1API\s0 keeps track of clients through the inheritance
mechanism.
.IP "\s-1CLIENT\-\s0>\fIregister()\fR" 8
.IX Item "CLIENT->register()"
register a client object/package
.IP "\s-1CLIENT\-\s0>evalcode(\s-1STRING\s0)" 8
.IX Item "CLIENT->evalcode(STRING)"
eval \s-1STRING\s0 in executing code context
.IP "\s-1CLIENT\-\s0>skippkg('D::hide')" 8
.IX Item "CLIENT->skippkg('D::hide')"
ask \s-1DB\s0 not to stop in these packages
.IP "\s-1CLIENT\-\s0>\fIrun()\fR" 8
.IX Item "CLIENT->run()"
run some more (until a breakpt is reached)
.IP "\s-1CLIENT\-\s0>\fIstep()\fR" 8
.IX Item "CLIENT->step()"
single step
.IP "\s-1CLIENT\-\s0>\fInext()\fR" 8
.IX Item "CLIENT->next()"
step over
.IP "\s-1CLIENT\-\s0>\fIdone()\fR" 8
.IX Item "CLIENT->done()"
de-register from the debugging \s-1API\s0
.SS "Client Callback Methods"
.IX Subsection "Client Callback Methods"
The following \*(L"virtual\*(R" methods can be defined by the client.  They will
be called by the \s-1API\s0 at appropriate points.  Note that unless specified
otherwise, the debug \s-1API\s0 only defines empty, non-functional default versions
of these methods.
.IP "\s-1CLIENT\-\s0>\fIinit()\fR" 8
.IX Item "CLIENT->init()"
Called after debug \s-1API\s0 inits itself.
.IP "\s-1CLIENT\-\s0>prestop([\s-1STRING\s0])" 8
.IX Item "CLIENT->prestop([STRING])"
Usually inherited from \s-1DB\s0 package.  If no arguments are passed,
returns the prestop action string.
.IP "\s-1CLIENT\-\s0>\fIstop()\fR" 8
.IX Item "CLIENT->stop()"
Called when execution stops (w/ args file, line).
.IP "\s-1CLIENT\-\s0>\fIidle()\fR" 8
.IX Item "CLIENT->idle()"
Called while stopped (can be a client event loop).
.IP "\s-1CLIENT\-\s0>poststop([\s-1STRING\s0])" 8
.IX Item "CLIENT->poststop([STRING])"
Usually inherited from \s-1DB\s0 package.  If no arguments are passed,
returns the poststop action string.
.IP "\s-1CLIENT\-\s0>evalcode(\s-1STRING\s0)" 8
.IX Item "CLIENT->evalcode(STRING)"
Usually inherited from \s-1DB\s0 package.  Ask for a \s-1STRING\s0 to be \f(CW\*(C`eval\*(C'\fR\-ed
in executing code context.
.IP "\s-1CLIENT\-\s0>\fIcleanup()\fR" 8
.IX Item "CLIENT->cleanup()"
Called just before exit.
.IP "\s-1CLIENT\-\s0>output(\s-1LIST\s0)" 8
.IX Item "CLIENT->output(LIST)"
Called when \s-1API\s0 must show a message (warnings, errors etc.).
.SH "BUGS"
.IX Header "BUGS"
The interface defined by this module is missing some of the later additions
to perl's debugging functionality.  As such, this interface should be considered
highly experimental and subject to change.
.SH "AUTHOR"
.IX Header "AUTHOR"
Gurusamy Sarathy	gsar@activestate.com
.PP
This code heavily adapted from an early version of perl5db.pl attributable
to Larry Wall and the Perl Porters.
