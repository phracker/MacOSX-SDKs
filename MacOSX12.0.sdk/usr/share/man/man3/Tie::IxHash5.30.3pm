.\" Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Tie::IxHash 3"
.TH Tie::IxHash 3 "2021-08-28" "perl v5.30.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Tie::IxHash \- ordered associative arrays for Perl
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 3
\&    # simple usage
\&    use Tie::IxHash;
\&    tie HASHVARIABLE, \*(AqTie::IxHash\*(Aq [, LIST];
\&
\&    # OO interface with more powerful features
\&    use Tie::IxHash;
\&    TIEOBJECT = Tie::IxHash\->new( [LIST] );
\&    TIEOBJECT\->Splice( OFFSET [, LENGTH [, LIST]] );
\&    TIEOBJECT\->Push( LIST );
\&    TIEOBJECT\->Pop;
\&    TIEOBJECT\->Shift;
\&    TIEOBJECT\->Unshift( LIST );
\&    TIEOBJECT\->Keys( [LIST] );
\&    TIEOBJECT\->Values( [LIST] );
\&    TIEOBJECT\->Indices( LIST );
\&    TIEOBJECT\->Delete( [LIST] );
\&    TIEOBJECT\->Replace( OFFSET, VALUE, [KEY] );
\&    TIEOBJECT\->Reorder( LIST );
\&    TIEOBJECT\->SortByKey;
\&    TIEOBJECT\->SortByValue;
\&    TIEOBJECT\->Length;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This Perl module implements Perl hashes that preserve the order in which the
hash elements were added.  The order is not affected when values
corresponding to existing keys in the IxHash are changed.  The elements can
also be set to any arbitrary supplied order.  The familiar perl array
operations can also be performed on the IxHash.
.ie n .SS "Standard ""TIEHASH"" Interface"
.el .SS "Standard \f(CWTIEHASH\fP Interface"
.IX Subsection "Standard TIEHASH Interface"
The standard \f(CW\*(C`TIEHASH\*(C'\fR mechanism is available. This interface is 
recommended for simple uses, since the usage is exactly the same as
regular Perl hashes after the \f(CW\*(C`tie\*(C'\fR is declared.
.SS "Object Interface"
.IX Subsection "Object Interface"
This module also provides an extended object-oriented interface that can be
used for more powerful operations with the IxHash.  The following methods
are available:
.IP "\s-1FETCH, STORE, DELETE, EXISTS\s0" 8
.IX Item "FETCH, STORE, DELETE, EXISTS"
These standard \f(CW\*(C`TIEHASH\*(C'\fR methods mandated by Perl can be used directly.
See the \f(CW\*(C`tie\*(C'\fR entry in \fBperlfunc\fR\|(1) for details.
.IP "Push, Pop, Shift, Unshift, Splice" 8
.IX Item "Push, Pop, Shift, Unshift, Splice"
These additional methods resembling Perl functions are available for
operating on key-value pairs in the IxHash. The behavior is the same as the
corresponding perl functions, except when a supplied hash key already exists
in the hash. In that case, the existing value is updated but its order is
not affected.  To unconditionally alter the order of a supplied key-value
pair, first \f(CW\*(C`DELETE\*(C'\fR the IxHash element.
.IP "Keys" 8
.IX Item "Keys"
Returns an array of IxHash element keys corresponding to the list of supplied
indices.  Returns an array of all the keys if called without arguments.
Note the return value is mostly only useful when used in a list context
(since perl will convert it to the number of elements in the array when
used in a scalar context, and that may not be very useful).
.Sp
If a single argument is given, returns the single key corresponding to
the index.  This is usable in either scalar or list context.
.IP "Values" 8
.IX Item "Values"
Returns an array of IxHash element values corresponding to the list of supplied
indices.  Returns an array of all the values if called without arguments.
Note the return value is mostly only useful when used in a list context
(since perl will convert it to the number of elements in the array when
used in a scalar context, and that may not be very useful).
.Sp
If a single argument is given, returns the single value corresponding to
the index.  This is usable in either scalar or list context.
.IP "Indices" 8
.IX Item "Indices"
Returns an array of indices corresponding to the supplied list of keys.
Note the return value is mostly only useful when used in a list context
(since perl will convert it to the number of elements in the array when
used in a scalar context, and that may not be very useful).
.Sp
If a single argument is given, returns the single index corresponding to
the key.  This is usable in either scalar or list context.
.IP "Delete" 8
.IX Item "Delete"
Removes elements with the supplied keys from the IxHash.
.IP "Replace" 8
.IX Item "Replace"
Substitutes the IxHash element at the specified index with the supplied
value-key pair.  If a key is not supplied, simply substitutes the value at
index with the supplied value. If an element with the supplied key already
exists, it will be removed from the IxHash first.
.IP "Reorder" 8
.IX Item "Reorder"
This method can be used to manipulate the internal order of the IxHash
elements by supplying a list of keys in the desired order.  Note however,
that any IxHash elements whose keys are not in the list will be removed from
the IxHash.
.IP "Length" 8
.IX Item "Length"
Returns the number of IxHash elements.
.IP "SortByKey" 8
.IX Item "SortByKey"
Reorders the IxHash elements by textual comparison of the keys.
.IP "SortByValue" 8
.IX Item "SortByValue"
Reorders the IxHash elements by textual comparison of the values.
.IP "Clear" 8
.IX Item "Clear"
Resets the IxHash to its pristine state: with no elements at all.
.SH "EXAMPLE"
.IX Header "EXAMPLE"
.Vb 1
\&    use Tie::IxHash;
\&
\&    # simple interface
\&    $t = tie(%myhash, \*(AqTie::IxHash\*(Aq, \*(Aqa\*(Aq => 1, \*(Aqb\*(Aq => 2);
\&    %myhash = (first => 1, second => 2, third => 3);
\&    $myhash{fourth} = 4;
\&    @keys = keys %myhash;
\&    @values = values %myhash;
\&    print("y") if exists $myhash{third};
\&
\&    # OO interface
\&    $t = Tie::IxHash\->new(first => 1, second => 2, third => 3);
\&    $t\->Push(fourth => 4); # same as $myhash{\*(Aqfourth\*(Aq} = 4;
\&    ($k, $v) = $t\->Pop;    # $k is \*(Aqfourth\*(Aq, $v is 4
\&    $t\->Unshift(neg => \-1, zeroth => 0); 
\&    ($k, $v) = $t\->Shift;  # $k is \*(Aqneg\*(Aq, $v is \-1
\&    @oneandtwo = $t\->Splice(1, 2, foo => 100, bar => 101);
\&
\&    @keys = $t\->Keys;
\&    @values = $t\->Values;
\&    @indices = $t\->Indices(\*(Aqfoo\*(Aq, \*(Aqzeroth\*(Aq);
\&    @itemkeys = $t\->Keys(@indices);
\&    @itemvals = $t\->Values(@indices);
\&    $t\->Replace(2, 0.3, \*(Aqother\*(Aq);
\&    $t\->Delete(\*(Aqsecond\*(Aq, \*(Aqzeroth\*(Aq);
\&    $len = $t\->Length;     # number of key\-value pairs
\&
\&    $t\->Reorder(reverse @keys);
\&    $t\->SortByKey;
\&    $t\->SortByValue;
.Ve
.SH "BUGS"
.IX Header "BUGS"
You cannot specify a negative length to \f(CW\*(C`Splice\*(C'\fR. Negative indexes are \s-1OK,\s0
though.
.SH "NOTE"
.IX Header "NOTE"
Indexing always begins at 0 (despite the current \f(CW$[\fR setting) for 
all the functions.
.SH "TODO"
.IX Header "TODO"
Addition of elements with keys that already exist to the end of the IxHash
must be controlled by a switch.
.PP
Provide \f(CW\*(C`TIEARRAY\*(C'\fR interface when it stabilizes in Perl.
.PP
Rewrite using XSUBs for efficiency.
.SH "AUTHOR"
.IX Header "AUTHOR"
Gurusamy Sarathy        gsar@umich.edu
.PP
Copyright (c) 1995 Gurusamy Sarathy. All rights reserved.
This program is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.
.SH "VERSION"
.IX Header "VERSION"
Version 1.23
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fBperl\fR\|(1)
