.\" Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Moose::Meta::TypeConstraint 3"
.TH Moose::Meta::TypeConstraint 3 "2019-11-22" "perl v5.30.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Moose::Meta::TypeConstraint \- The Moose Type Constraint metaclass
.SH "VERSION"
.IX Header "VERSION"
version 2.2012
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This class represents a single type constraint. Moose's built-in type
constraints, as well as constraints you define, are all stored in a
Moose::Meta::TypeConstraint::Registry object as objects of this
class.
.SH "INHERITANCE"
.IX Header "INHERITANCE"
\&\f(CW\*(C`Moose::Meta::TypeConstraint\*(C'\fR is a subclass of Class::MOP::Object.
.SH "METHODS"
.IX Header "METHODS"
.SS "Moose::Meta::TypeConstraint\->new(%options)"
.IX Subsection "Moose::Meta::TypeConstraint->new(%options)"
This creates a new type constraint based on the provided \f(CW%options\fR:
.IP "\(bu" 4
name
.Sp
The constraint name. If a name is not provided, it will be set to
\&\*(L"_\|_ANON_\|_\*(R".
.IP "\(bu" 4
parent
.Sp
A \f(CW\*(C`Moose::Meta::TypeConstraint\*(C'\fR object which is the parent type for
the type being created. This is optional.
.IP "\(bu" 4
constraint
.Sp
This is the subroutine reference that implements the actual constraint
check. This defaults to a subroutine which always returns true.
.IP "\(bu" 4
message
.Sp
A subroutine reference which is used to generate an error message when
the constraint fails. This is optional.
.IP "\(bu" 4
coercion
.Sp
A Moose::Meta::TypeCoercion object representing the coercions to
the type. This is optional.
.IP "\(bu" 4
inlined
.Sp
A subroutine which returns a string suitable for inlining this type
constraint. It will be called as a method on the type constraint object, and
will receive a single additional parameter, a variable name to be tested
(usually \f(CW"$_"\fR or \f(CW"$_[0]"\fR.
.Sp
This is optional.
.IP "\(bu" 4
inline_environment
.Sp
A hash reference of variables to close over. The keys are variables names, and
the values are \fIreferences\fR to the variables.
.ie n .SS "$constraint\->equals($type_name_or_object)"
.el .SS "\f(CW$constraint\fP\->equals($type_name_or_object)"
.IX Subsection "$constraint->equals($type_name_or_object)"
Returns true if the supplied name or type object is the same as the
current type.
.ie n .SS "$constraint\->is_subtype_of($type_name_or_object)"
.el .SS "\f(CW$constraint\fP\->is_subtype_of($type_name_or_object)"
.IX Subsection "$constraint->is_subtype_of($type_name_or_object)"
Returns true if the supplied name or type object is a parent of the
current type.
.ie n .SS "$constraint\->is_a_type_of($type_name_or_object)"
.el .SS "\f(CW$constraint\fP\->is_a_type_of($type_name_or_object)"
.IX Subsection "$constraint->is_a_type_of($type_name_or_object)"
Returns true if the given type is the same as the current type, or is
a parent of the current type. This is a shortcut for checking
\&\f(CW\*(C`equals\*(C'\fR and \f(CW\*(C`is_subtype_of\*(C'\fR.
.ie n .SS "$constraint\->coerce($value)"
.el .SS "\f(CW$constraint\fP\->coerce($value)"
.IX Subsection "$constraint->coerce($value)"
This will attempt to coerce the value to the type. If the type does not
have any defined coercions this will throw an error.
.PP
If no coercion can produce a value matching \f(CW$constraint\fR, the original
value is returned.
.ie n .SS "$constraint\->assert_coerce($value)"
.el .SS "\f(CW$constraint\fP\->assert_coerce($value)"
.IX Subsection "$constraint->assert_coerce($value)"
This method behaves just like \f(CW\*(C`coerce\*(C'\fR, but if the result is not valid
according to \f(CW$constraint\fR, an error is thrown.
.ie n .SS "$constraint\->check($value)"
.el .SS "\f(CW$constraint\fP\->check($value)"
.IX Subsection "$constraint->check($value)"
Returns true if the given value passes the constraint for the type.
.ie n .SS "$constraint\->validate($value)"
.el .SS "\f(CW$constraint\fP\->validate($value)"
.IX Subsection "$constraint->validate($value)"
This is similar to \f(CW\*(C`check\*(C'\fR. However, if the type \fIis valid\fR then the
method returns an explicit \f(CW\*(C`undef\*(C'\fR. If the type is not valid, we call
\&\f(CW\*(C`$self\->get_message($value)\*(C'\fR internally to generate an error
message.
.ie n .SS "$constraint\->assert_valid($value)"
.el .SS "\f(CW$constraint\fP\->assert_valid($value)"
.IX Subsection "$constraint->assert_valid($value)"
Like \f(CW\*(C`check\*(C'\fR and \f(CW\*(C`validate\*(C'\fR, this method checks whether \f(CW$value\fR is
valid under the constraint.  If it is, it will return true.  If it is not,
an exception will be thrown with the results of
\&\f(CW\*(C`$self\->get_message($value)\*(C'\fR.
.ie n .SS "$constraint\->name"
.el .SS "\f(CW$constraint\fP\->name"
.IX Subsection "$constraint->name"
Returns the type's name, as provided to the constructor.
.ie n .SS "$constraint\->parent"
.el .SS "\f(CW$constraint\fP\->parent"
.IX Subsection "$constraint->parent"
Returns the type's parent, as provided to the constructor, if any.
.ie n .SS "$constraint\->has_parent"
.el .SS "\f(CW$constraint\fP\->has_parent"
.IX Subsection "$constraint->has_parent"
Returns true if the type has a parent type.
.ie n .SS "$constraint\->parents"
.el .SS "\f(CW$constraint\fP\->parents"
.IX Subsection "$constraint->parents"
Returns all of the types parents as an list of type constraint objects.
.ie n .SS "$constraint\->constraint"
.el .SS "\f(CW$constraint\fP\->constraint"
.IX Subsection "$constraint->constraint"
Returns the type's constraint, as provided to the constructor.
.ie n .SS "$constraint\->get_message($value)"
.el .SS "\f(CW$constraint\fP\->get_message($value)"
.IX Subsection "$constraint->get_message($value)"
This generates a method for the given value. If the type does not have
an explicit message, we generate a default message.
.ie n .SS "$constraint\->has_message"
.el .SS "\f(CW$constraint\fP\->has_message"
.IX Subsection "$constraint->has_message"
Returns true if the type has a message.
.ie n .SS "$constraint\->message"
.el .SS "\f(CW$constraint\fP\->message"
.IX Subsection "$constraint->message"
Returns the type's message as a subroutine reference.
.ie n .SS "$constraint\->coercion"
.el .SS "\f(CW$constraint\fP\->coercion"
.IX Subsection "$constraint->coercion"
Returns the type's Moose::Meta::TypeCoercion object, if one
exists.
.ie n .SS "$constraint\->has_coercion"
.el .SS "\f(CW$constraint\fP\->has_coercion"
.IX Subsection "$constraint->has_coercion"
Returns true if the type has a coercion.
.ie n .SS "$constraint\->can_be_inlined"
.el .SS "\f(CW$constraint\fP\->can_be_inlined"
.IX Subsection "$constraint->can_be_inlined"
Returns true if this type constraint can be inlined. A type constraint which
subtypes an inlinable constraint and does not add an additional constraint
\&\*(L"inherits\*(R" its parent type's inlining.
.ie n .SS "$constraint\->create_child_type(%options)"
.el .SS "\f(CW$constraint\fP\->create_child_type(%options)"
.IX Subsection "$constraint->create_child_type(%options)"
This returns a new type constraint of the same class using the
provided \f(CW%options\fR. The \f(CW\*(C`parent\*(C'\fR option will be the current type.
.PP
This method exists so that subclasses of this class can override this
behavior and change how child types are created.
.SH "BUGS"
.IX Header "BUGS"
See \*(L"\s-1BUGS\*(R"\s0 in Moose for details on reporting bugs.
.SH "AUTHORS"
.IX Header "AUTHORS"
.IP "\(bu" 4
Stevan Little <stevan.little@iinteractive.com>
.IP "\(bu" 4
Dave Rolsky <autarch@urth.org>
.IP "\(bu" 4
Jesse Luehrs <doy@tozt.net>
.IP "\(bu" 4
Shawn M Moore <code@sartak.org>
.IP "\(bu" 4
יובל קוג'מן (Yuval Kogman) <nothingmuch@woobling.org>
.IP "\(bu" 4
Karen Etheridge <ether@cpan.org>
.IP "\(bu" 4
Florian Ragwitz <rafl@debian.org>
.IP "\(bu" 4
Hans Dieter Pearcey <hdp@weftsoar.net>
.IP "\(bu" 4
Chris Prather <chris@prather.org>
.IP "\(bu" 4
Matt S Trout <mst@shadowcat.co.uk>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is copyright (c) 2006 by Infinity Interactive, Inc.
.PP
This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.
