.\" Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "install::TempContent::Objects::mod_perl-2.0.9::docs::api::ModPerl::Util 3"
.TH install::TempContent::Objects::mod_perl-2.0.9::docs::api::ModPerl::Util 3 "2015-06-18" "perl v5.30.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
ModPerl::Util \- Helper mod_perl Functions
.SH "Synopsis"
.IX Header "Synopsis"
.Vb 1
\&  use ModPerl::Util;
\&  
\&  # e.g. PerlResponseHandler
\&  $callback = ModPerl::Util::current_callback;
\&  
\&  # exit w/o killing the interpreter
\&  ModPerl::Util::exit();
\&  
\&  # untaint a string (do not use it! see the doc)
\&  ModPerl::Util::untaint($string);
\&  
\&  # removes a stash (.so, %INC{$stash}, etc.) as best as it can
\&  ModPerl::Util::unload_package($stash);
\&  
\&  # current perl\*(Aqs address (0x92ac760 or 0x0 under non\-threaded perl)
\&  ModPerl::Util::current_perl_id();
.Ve
.SH "Description"
.IX Header "Description"
\&\f(CW\*(C`ModPerl::Util\*(C'\fR provides mod_perl utilities \s-1API.\s0
.SH "API"
.IX Header "API"
\&\f(CW\*(C`ModPerl::Util\*(C'\fR provides the following functions and/or methods:
.ie n .SS """current_callback"""
.el .SS "\f(CWcurrent_callback\fP"
.IX Subsection "current_callback"
Returns the currently running callback name,
e.g. \f(CW\*(AqPerlResponseHandler\*(Aq\fR.
.PP
.Vb 1
\&  $callback = ModPerl::Util::current_callback();
.Ve
.ie n .IP "ret: $callback ( string )" 4
.el .IP "ret: \f(CW$callback\fR ( string )" 4
.IX Item "ret: $callback ( string )"
.PD 0
.IP "since: 2.0.00" 4
.IX Item "since: 2.0.00"
.PD
.ie n .SS """current_perl_id"""
.el .SS "\f(CWcurrent_perl_id\fP"
.IX Subsection "current_perl_id"
Return the memory address of the perl interpreter
.PP
.Vb 1
\&  $perl_id = ModPerl::Util::current_perl_id();
.Ve
.ie n .IP "ret: $perl_id ( string )" 4
.el .IP "ret: \f(CW$perl_id\fR ( string )" 4
.IX Item "ret: $perl_id ( string )"
Under threaded perl returns something like: \f(CW0x92ac760\fR
.Sp
Under non-thread perl returns \f(CW0x0\fR
.IP "since: 2.0.00" 4
.IX Item "since: 2.0.00"
.PP
Mainly useful for debugging applications running under threaded-perl.
.ie n .SS """exit"""
.el .SS "\f(CWexit\fP"
.IX Subsection "exit"
Terminate the request, but not the current process (or not the current
Perl interpreter with threaded mpms).
.PP
.Vb 1
\&  ModPerl::Util::exit($status);
.Ve
.ie n .IP "opt arg1: $status ( integer )" 4
.el .IP "opt arg1: \f(CW$status\fR ( integer )" 4
.IX Item "opt arg1: $status ( integer )"
The exit status, which as of this writing is ignored. (it's accepted
to be compatible with the core \f(CW\*(C`exit\*(C'\fR function.)
.IP "ret: no return value" 4
.IX Item "ret: no return value"
.PD 0
.IP "since: 2.0.00" 4
.IX Item "since: 2.0.00"
.PD
.PP
Normally you will use the plain \f(CW\*(C`exit()\*(C'\fR in your code. You don't need
to use \f(CW\*(C`ModPerl::Util::exit\*(C'\fR explicitly, since mod_perl overrides
\&\f(CW\*(C`exit()\*(C'\fR by setting \f(CW\*(C`CORE::GLOBAL::exit\*(C'\fR to
\&\f(CW\*(C`ModPerl::Util::exit\*(C'\fR. Only if you redefine \f(CW\*(C`CORE::GLOBAL::exit\*(C'\fR
once mod_perl is running, you may want to use this function.
.PP
The original \f(CW\*(C`exit()\*(C'\fR is still available via \f(CW\*(C`CORE::exit()\*(C'\fR.
.PP
\&\f(CW\*(C`ModPerl::Util::exit\*(C'\fR is implemented as a special \f(CW\*(C`die()\*(C'\fR call,
therefore if you call it inside \f(CW\*(C`eval BLOCK\*(C'\fR or \f(CW\*(C`eval "STRING"\*(C'\fR,
while an exception is being thrown, it is caught by \f(CW\*(C`eval\*(C'\fR. For
example:
.PP
.Vb 2
\&  exit;
\&  print "Still running";
.Ve
.PP
will not print anything. But:
.PP
.Vb 4
\&  eval {
\&     exit;
\&  }
\&  print "Still running";
.Ve
.PP
will print \fIStill running\fR. So you either need to check whether the
exception is specific to \f(CW\*(C`exit\*(C'\fR and call
\&\f(CW\*(C`exit()\*(C'\fR again:
.PP
.Vb 6
\&  use ModPerl::Const \-compile => \*(AqEXIT\*(Aq;
\&  eval {
\&     exit;
\&  }
\&  exit if $@ && ref $@ eq \*(AqAPR::Error\*(Aq && $@ == ModPerl::EXIT;
\&  print "Still running";
.Ve
.PP
or use \f(CW\*(C`CORE::exit()\*(C'\fR:
.PP
.Vb 4
\&  eval {
\&     CORE::exit;
\&  }
\&  print "Still running";
.Ve
.PP
and nothing will be printed. The problem with the latter is the
current process (or a Perl Interpreter) will be killed; something that
you really want to avoid under mod_perl.
.ie n .SS """unload_package"""
.el .SS "\f(CWunload_package\fP"
.IX Subsection "unload_package"
Unloads a stash from the current Perl interpreter in the safest way
possible.
.PP
.Vb 1
\&  ModPerl::Util::unload_package($stash);
.Ve
.ie n .IP "arg1: $stash ( string )" 4
.el .IP "arg1: \f(CW$stash\fR ( string )" 4
.IX Item "arg1: $stash ( string )"
The Perl stash to unload. e.g. \f(CW\*(C`MyApache2::MyData\*(C'\fR.
.IP "ret: no return value" 4
.IX Item "ret: no return value"
.PD 0
.IP "since: 2.0.00" 4
.IX Item "since: 2.0.00"
.PD
.PP
Unloading a Perl stash (package) is a complicated business. This
function tries very hard to do the right thing. After calling this
function, it should be safe to \f(CW\*(C`use()\*(C'\fR a new version of the module
that loads the wiped package.
.PP
References to stash elements (functions, variables, etc.) taken from
outside the unloaded package will still be valid.
.PP
This function may wipe off things loaded by other modules, if the
latter have inserted things into the \f(CW$stash\fR it was told to unload.
.PP
If a stash had a corresponding \s-1XS\s0 shared object (.so) loaded it will
be unloaded as well.
.PP
If the stash had a corresponding entry in \f(CW%INC\fR, it will be removed
from there.
.PP
\&\f(CW\*(C`unload_package()\*(C'\fR takes care to leave sub-stashes intact while
deleting the requested stash. So for example if \f(CW\*(C`CGI\*(C'\fR and
\&\f(CW\*(C`CGI::Carp\*(C'\fR are loaded, calling \f(CW\*(C`unload_package(\*(AqCGI\*(Aq)\*(C'\fR won't affect
\&\f(CW\*(C`CGI::Carp\*(C'\fR.
.ie n .SS """untaint"""
.el .SS "\f(CWuntaint\fP"
.IX Subsection "untaint"
Untaint the variable, by turning its tainted \s-1SV\s0 flag off (used
internally).
.PP
.Vb 1
\&  ModPerl::Util::untaint($tainted_var);
.Ve
.ie n .IP "arg1: $tainted_var (scalar)" 4
.el .IP "arg1: \f(CW$tainted_var\fR (scalar)" 4
.IX Item "arg1: $tainted_var (scalar)"
.PD 0
.IP "ret: no return value" 4
.IX Item "ret: no return value"
.PD
\&\f(CW$tainted_var\fR is untainted.
.IP "since: 2.0.00" 4
.IX Item "since: 2.0.00"
.PP
Do not use this function unless you know what you are doing. To learn
how to properly untaint variables refer to the \fIperlsec\fR manpage.
.SH "See Also"
.IX Header "See Also"
mod_perl 2.0 documentation.
.SH "Copyright"
.IX Header "Copyright"
mod_perl 2.0 and its core modules are copyrighted under
The Apache Software License, Version 2.0.
.SH "Authors"
.IX Header "Authors"
The mod_perl development team and numerous
contributors.
