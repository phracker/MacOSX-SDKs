.\" Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "install::TempContent::Objects::mod_perl-2.0.9::docs::api::Apache2::RequestRec 3"
.TH install::TempContent::Objects::mod_perl-2.0.9::docs::api::Apache2::RequestRec 3 "2015-06-18" "perl v5.30.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Apache2::RequestRec \- Perl API for Apache request record accessors
.SH "Synopsis"
.IX Header "Synopsis"
.Vb 1
\&  use Apache2::RequestRec ();
\&  
\&  # set supported by the handler HTTP methods
\&  $allowed = $r\->allowed();
\&  
\&  # auth type
\&  $auth_type = $r\->ap_auth_type();
\&  
\&  # QUERY_STRING
\&  $args = $r\->args();
\&  
\&  # non\-parsed\-headers handler
\&  $status = $r\->assbackwards();
\&  
\&  # how many bytes were sent
\&  $bytes_sent = $r\->bytes_sent();
\&  
\&  # client connection record
\&  $c = $r\->connection();
\&  
\&  # "Content\-Encoding" HTTP response header
\&  $r\->content_encoding("gzip");
\&  
\&  # the languages of the content
\&  $languages = $r\->content_languages();
\&  
\&  # "Content\-Encoding" HTTP response header
\&  $r\->content_type(\*(Aqtext/plain\*(Aq);
\&  
\&  # special response headers table
\&  $err_headers_out = $r\->err_headers_out();
\&  
\&  # request mapped filename
\&  $filename = $r\->filename();
\&  
\&  # request finfo
\&  $finfo = $r\->finfo();
\&  
\&  # \*(AqSetHandler perl\-script\*(Aq equivalent
\&  $r\->handler(\*(Aqperl\-script\*(Aq);
\&  
\&  # was it a HEAD request?
\&  $status = $r\->header_only();
\&  
\&  # request input headers table
\&  $headers_in = $r\->headers_in();
\&  
\&  # request output headers table
\&  $headers_out = $r\->headers_out();
\&  
\&  # hostname
\&  $hostname = $r\->hostname();
\&  
\&  # input filters stack
\&  $input_filters = $r\->input_filters();
\&  
\&  # get the main request obj in a sub\-request
\&  $main_r = $r\->main();
\&  
\&  # what\*(Aqs the current request (GET/POST/etc)?
\&  $method = $r\->method();
\&  
\&  # what\*(Aqs the current method number?
\&  $methnum = $r\->method_number();
\&  
\&  # current resource last modified time
\&  $mtime = $r\->mtime();
\&  
\&  # next request object (in redirect)
\&  $next_r = $r\->next();
\&  
\&  # there is no local copy
\&  $r\->no_local_copy();
\&  
\&  # Apache ascii notes table
\&  $notes = $r\->notes();
\&  
\&  # output filters stack
\&  $output_filters = $r\->output_filters();
\&  
\&  # PATH_INFO
\&  $path_info = $r\->path_info();
\&  
\&  # used in configuration directives modules
\&  $per_dir_config = $r\->per_dir_config();
\&  
\&  # pool with life span of the current request
\&  $p = $r\->pool();
\&  
\&  # previous request object in the internal redirect
\&  $prev_r = $r\->prev();
\&  
\&  # connection level input filters stack
\&  $proto_input_filters = $r\->proto_input_filters();
\&  
\&  # HTTP protocol version number
\&  $proto_num = $r\->proto_num();
\&  
\&  # connection level output filters stack
\&  $proto_output_filters = $r\->proto_output_filters();
\&  
\&  # the protocol, the client speaks: "HTTP/1.0", "HTTP/1.1", etc.
\&  $protocol = $r\->protocol();
\&  
\&  # is it a proxy request
\&  $status = $r\->proxyreq($val);
\&  
\&  # Time when the request started
\&  $request_time = $r\->request_time();
\&  
\&  # server object
\&  $s = $r\->server();
\&  
\&  # response status
\&  $status = $r\->status();
\&  
\&  # response status line
\&  $status_line = $r\->status_line();
\&  
\&  # manipulate %ENV of the subprocess
\&  $r\->subprocess_env;
\&  $r\->subprocess_env($key => $val);
\&  
\&  # first HTTP request header
\&  $request = $r\->the_request();
\&  
\&  # the URI without any parsing performed
\&  $unparsed_uri = $r\->unparsed_uri();
\&  
\&  # The path portion of the URI
\&  $uri = $r\->uri();
\&  
\&  # auth username
\&  $user = $r\->user();
.Ve
.SH "Description"
.IX Header "Description"
\&\f(CW\*(C`Apache2::RequestRec\*(C'\fR provides the Perl \s-1API\s0 for Apache request_rec
object.
.PP
The following packages extend the \f(CW\*(C`Apache2::RequestRec\*(C'\fR functionality:
\&\f(CW\*(C`Apache2::Access\*(C'\fR,
\&\f(CW\*(C`Apache2::Log\*(C'\fR,
\&\f(CW\*(C`Apache2::RequestIO\*(C'\fR,
\&\f(CW\*(C`Apache2::RequestUtil\*(C'\fR,
\&\f(CW\*(C`Apache2::Response\*(C'\fR,
\&\f(CW\*(C`Apache2::SubRequest\*(C'\fR and
\&\f(CW\*(C`Apache2::URI\*(C'\fR.
.SH "API"
.IX Header "API"
\&\f(CW\*(C`Apache2::RequestRec\*(C'\fR provides the following functions and/or methods:
.ie n .SS """allowed"""
.el .SS "\f(CWallowed\fP"
.IX Subsection "allowed"
Get/set the allowed methods bitmask.
.PP
.Vb 2
\&  $allowed      = $r\->allowed();
\&  $prev_allowed = $r\->allowed($new_allowed);
.Ve
.ie n .IP "obj: $r ( ""Apache2::RequestRec object"" )" 4
.el .IP "obj: \f(CW$r\fR ( \f(CWApache2::RequestRec object\fR )" 4
.IX Item "obj: $r ( Apache2::RequestRec object )"
.PD 0
.ie n .IP "opt arg1: $new_allowed ( bitmask )" 4
.el .IP "opt arg1: \f(CW$new_allowed\fR ( bitmask )" 4
.IX Item "opt arg1: $new_allowed ( bitmask )"
.PD
Set the bitvector.
.ie n .IP "ret: $allowed ( bitmask )" 4
.el .IP "ret: \f(CW$allowed\fR ( bitmask )" 4
.IX Item "ret: $allowed ( bitmask )"
returns \f(CW$allowed\fR, which is a bitvector of the allowed methods.
.Sp
If the \f(CW$new_allowed\fR argument is passed, the value before the change
is returned.
.IP "since: 2.0.00" 4
.IX Item "since: 2.0.00"
.PP
A handler must ensure that the request method is one that it is
capable of handling.  Generally modules should \f(CW\*(C`Apache2::DECLINE\*(C'\fR any
request methods they do not handle.  Prior to aborting the handler
like this the handler should set \f(CW\*(C`$r\->allowed\*(C'\fR to the list of
methods that it is willing to handle.  This bitvector is used to
construct the \f(CW"Allow:"\fR header required for \f(CW\*(C`OPTIONS\*(C'\fR requests, and
\&\f(CW\*(C`Apache2::Const::HTTP_METHOD_NOT_ALLOWED\*(C'\fR (405) and
\&\f(CW\*(C`Apache2::Const::HTTP_NOT_IMPLEMENTED\*(C'\fR (501) status codes.
.PP
Since the default Apache handler deals with the \f(CW\*(C`OPTIONS\*(C'\fR method, all
response handlers can usually decline to deal with \f(CW\*(C`OPTIONS\*(C'\fR. For
example if the response handler handles only \f(CW\*(C`GET\*(C'\fR and \f(CW\*(C`POST\*(C'\fR
methods, and not \f(CW\*(C`OPTIONS\*(C'\fR, it may want to say:
.PP
.Vb 5
\&   use Apache2::Const \-compile => qw(OK DECLINED M_GET M_POST M_OPTIONS);
\&   if ($r\->method_number == Apache2::Const::M_OPTIONS) {
\&       $r\->allowed($r\->allowed | (1<<Apache2::Const::M_GET) | (1<<Apache2::Const::M_POST));
\&       return Apache2::Const::DECLINED;
\&   }
.Ve
.PP
\&\f(CW\*(C`TRACE\*(C'\fR is always allowed, modules don't need to set it explicitly.
.PP
Since the default_handler will always handle a \f(CW\*(C`GET\*(C'\fR, a module which
does *not* implement \f(CW\*(C`GET\*(C'\fR should probably return
\&\f(CW\*(C`Apache2::Const::HTTP_METHOD_NOT_ALLOWED\*(C'\fR.  Unfortunately this means that a
script \f(CW\*(C`GET\*(C'\fR handler can't be installed by mod_actions.
.PP
For example, if the module can handle only \s-1POST\s0 method it could start
with:
.PP
.Vb 5
\&   use Apache2::Const \-compile => qw(M_POST HTTP_METHOD_NOT_ALLOWED);
\&   unless ($r\->method_number == Apache2::Const::M_POST) {
\&       $r\->allowed($r\->allowed | (1<<Apache2::Const::M_POST));
\&       return Apache2::Const::HTTP_METHOD_NOT_ALLOWED;
\&   }
.Ve
.ie n .SS """ap_auth_type"""
.el .SS "\f(CWap_auth_type\fP"
.IX Subsection "ap_auth_type"
If an authentication check was made, get or set the \fIap_auth_type\fR
slot in the request record
.PP
.Vb 2
\&  $auth_type = $r\->ap_auth_type();
\&  $r\->ap_auth_type($newval);
.Ve
.ie n .IP "obj: $r ( ""Apache2::RequestRec object"" )" 4
.el .IP "obj: \f(CW$r\fR ( \f(CWApache2::RequestRec object\fR )" 4
.IX Item "obj: $r ( Apache2::RequestRec object )"
.PD 0
.ie n .IP "opt arg1: $newval (string)" 4
.el .IP "opt arg1: \f(CW$newval\fR (string)" 4
.IX Item "opt arg1: $newval (string)"
.PD
If this argument is passed then a new auth type is assigned. For example:
.Sp
.Vb 1
\&  $r\->auth_type(\*(AqBasic\*(Aq);
.Ve
.ie n .IP "ret: $auth_type (string)" 4
.el .IP "ret: \f(CW$auth_type\fR (string)" 4
.IX Item "ret: $auth_type (string)"
If \f(CW$newval\fR is passed, nothing is returned. Otherwise the current
auth type is returned.
.IP "since: 2.0.00" 4
.IX Item "since: 2.0.00"
.PP
\&\fIap_auth_type\fR holds the authentication type that has been negotiated
between the client and server during the actual request.  Generally,
\&\fIap_auth_type\fR is populated automatically when you call
\&\f(CW\*(C`$r\->get_basic_auth_pw\*(C'\fR so you don't really need to worry too
much about it, but if you want to roll your own authentication
mechanism then you will have to populate \fIap_auth_type\fR yourself.
.PP
Note that \f(CW\*(C`$r\->ap_auth_type\*(C'\fR was
\&\f(CW\*(C`$r\->connection\->auth_type\*(C'\fR in the mod_perl 1.0 \s-1API.\s0
.ie n .SS """args"""
.el .SS "\f(CWargs\fP"
.IX Subsection "args"
Get/set the request \s-1QUERY\s0 string
.PP
.Vb 2
\&  $args      = $r\->args();
\&  $prev_args = $r\->args($new_args);
.Ve
.ie n .IP "obj: $r ( ""Apache2::RequestRec object"" )" 4
.el .IP "obj: \f(CW$r\fR ( \f(CWApache2::RequestRec object\fR )" 4
.IX Item "obj: $r ( Apache2::RequestRec object )"
.PD 0
.ie n .IP "opt arg1: $new_args ( string )" 4
.el .IP "opt arg1: \f(CW$new_args\fR ( string )" 4
.IX Item "opt arg1: $new_args ( string )"
.PD
Optionally set the new \s-1QUERY\s0 string
.ie n .IP "ret: $args ( string )" 4
.el .IP "ret: \f(CW$args\fR ( string )" 4
.IX Item "ret: $args ( string )"
The current \s-1QUERY\s0 string
.Sp
If \f(CW$new_args\fR was passed, returns the value before the change.
.IP "since: 2.0.00" 4
.IX Item "since: 2.0.00"
.ie n .SS """assbackwards"""
.el .SS "\f(CWassbackwards\fP"
.IX Subsection "assbackwards"
When set to a true value, Apache won't send any \s-1HTTP\s0 response headers
allowing you to send any headers.
.PP
.Vb 2
\&  $status      = $r\->assbackwards();
\&  $prev_status = $r\->assbackwards($newval);
.Ve
.ie n .IP "obj: $r ( ""Apache2::RequestRec object"" )" 4
.el .IP "obj: \f(CW$r\fR ( \f(CWApache2::RequestRec object\fR )" 4
.IX Item "obj: $r ( Apache2::RequestRec object )"
.PD 0
.ie n .IP "opt arg1: $newval (integer)" 4
.el .IP "opt arg1: \f(CW$newval\fR (integer)" 4
.IX Item "opt arg1: $newval (integer)"
.PD
assign a new state.
.ie n .IP "ret: $status (integer)" 4
.el .IP "ret: \f(CW$status\fR (integer)" 4
.IX Item "ret: $status (integer)"
current state.
.IP "since: 2.0.00" 4
.IX Item "since: 2.0.00"
.PP
If you send your own set of headers, which includes the \f(CW\*(C`Keep\-Alive\*(C'\fR
\&\s-1HTTP\s0 response header, you must make sure to increment the number of
requests served over this connection (which is normally done by the
core connection output filter \f(CW\*(C`ap_http_header_filter\*(C'\fR, but skipped
when \f(CW\*(C`assbackwards\*(C'\fR is enabled).
.PP
.Vb 1
\&  $r\->connection\->keepalives($r\->connection\->keepalives + 1);
.Ve
.PP
otherwise code relying on the value of
\&\f(CW\*(C`$r\->connection\->keepalives\*(C'\fR
may malfunction. For example, this counter is used to tell when a new
request is coming in over the same connection to a filter that wants
to parse only \s-1HTTP\s0 headers (like
\&\f(CW\*(C`Apache2::Filter::HTTPHeadersFixup\*(C'\fR). Of course you will need to set
\&\f(CW\*(C`$r\->connection\->keepalive(1)\*(C'\fR
) as well.
.ie n .SS """bytes_sent"""
.el .SS "\f(CWbytes_sent\fP"
.IX Subsection "bytes_sent"
The number of bytes sent to the client, handy for logging, etc.
.PP
.Vb 1
\&  $bytes_sent = $r\->bytes_sent();
.Ve
.ie n .IP "obj: $r ( ""Apache2::RequestRec object"" )" 4
.el .IP "obj: \f(CW$r\fR ( \f(CWApache2::RequestRec object\fR )" 4
.IX Item "obj: $r ( Apache2::RequestRec object )"
.PD 0
.ie n .IP "ret: $bytes_sent (integer)" 4
.el .IP "ret: \f(CW$bytes_sent\fR (integer)" 4
.IX Item "ret: $bytes_sent (integer)"
.IP "since: 2.0.00" 4
.IX Item "since: 2.0.00"
.PD
.PP
Though as of this writing in Apache 2.0 it doesn't really do what it
did in Apache 1.3. It's just set to the size of the response body.
The issue is that buckets from one request may get buffered and not
sent during the lifetime of the request, so it's not easy to give a
truly accurate count of \*(L"bytes sent to the network for this response\*(R".
.ie n .SS """connection"""
.el .SS "\f(CWconnection\fP"
.IX Subsection "connection"
Get the client connection record
.PP
.Vb 1
\&  $c = $r\->connection();
.Ve
.ie n .IP "obj: $r ( ""Apache2::RequestRec object"" )" 4
.el .IP "obj: \f(CW$r\fR ( \f(CWApache2::RequestRec object\fR )" 4
.IX Item "obj: $r ( Apache2::RequestRec object )"
.PD 0
.ie n .IP "ret: $c ( ""Apache2::Connection object"" )" 4
.el .IP "ret: \f(CW$c\fR ( \f(CWApache2::Connection object\fR )" 4
.IX Item "ret: $c ( Apache2::Connection object )"
.IP "since: 2.0.00" 4
.IX Item "since: 2.0.00"
.PD
.ie n .SS """content_encoding"""
.el .SS "\f(CWcontent_encoding\fP"
.IX Subsection "content_encoding"
Get/set content encoding (the \*(L"Content-Encoding\*(R" \s-1HTTP\s0 header).
Content encodings are string like \fI\*(L"gzip\*(R"\fR or \fI\*(L"compress\*(R"\fR.
.PP
.Vb 2
\&  $ce      = $r\->content_encoding();
\&  $prev_ce = $r\->content_encoding($new_ce);
.Ve
.ie n .IP "obj: $r ( ""Apache2::RequestRec object"" )" 4
.el .IP "obj: \f(CW$r\fR ( \f(CWApache2::RequestRec object\fR )" 4
.IX Item "obj: $r ( Apache2::RequestRec object )"
.PD 0
.ie n .IP "opt arg1: $new_ce ( string )" 4
.el .IP "opt arg1: \f(CW$new_ce\fR ( string )" 4
.IX Item "opt arg1: $new_ce ( string )"
.PD
If passed, sets the content encoding to a new value. It must be a
lowercased string.
.ie n .IP "ret: $ce ( string )" 4
.el .IP "ret: \f(CW$ce\fR ( string )" 4
.IX Item "ret: $ce ( string )"
The current content encoding.
.Sp
If \f(CW$new_ce\fR is passed, then the previous value is returned.
.IP "since: 2.0.00" 4
.IX Item "since: 2.0.00"
.PP
For example, here is how to send a gzip'ed response:
.PP
.Vb 4
\&  require Compress::Zlib;
\&  $r\->content_type("text/plain");
\&  $r\->content_encoding("gzip");
\&  $r\->print(Compress::Zlib::memGzip("some text to be gzipped));
.Ve
.ie n .SS """content_languages"""
.el .SS "\f(CWcontent_languages\fP"
.IX Subsection "content_languages"
Get/set content languages (the \f(CW"Content\-Language"\fR \s-1HTTP\s0 header).
Content languages are string like \fI\*(L"en\*(R"\fR or \fI\*(L"fr\*(R"\fR.
.PP
.Vb 2
\&  $languages = $r\->content_languages();
\&  $prev_lang = $r\->content_languages($nev_lang);
.Ve
.ie n .IP "obj: $r ( ""Apache2::RequestRec object"" )" 4
.el .IP "obj: \f(CW$r\fR ( \f(CWApache2::RequestRec object\fR )" 4
.IX Item "obj: $r ( Apache2::RequestRec object )"
.PD 0
.ie n .IP "opt arg1: $new_lang ( \s-1ARRAY\s0 ref )" 4
.el .IP "opt arg1: \f(CW$new_lang\fR ( \s-1ARRAY\s0 ref )" 4
.IX Item "opt arg1: $new_lang ( ARRAY ref )"
.PD
If passed, sets the content languages to new values. It must be an
\&\s-1ARRAY\s0 reference of language names, like \fI\*(L"en\*(R"\fR or \fI\*(L"fr\*(R"\fR
.ie n .IP "ret: $languages ( \s-1ARRAY\s0 ref )" 4
.el .IP "ret: \f(CW$languages\fR ( \s-1ARRAY\s0 ref )" 4
.IX Item "ret: $languages ( ARRAY ref )"
The current list of content languages, as an \s-1ARRAY\s0 reference.
.Sp
If \f(CW$new_lang\fR is passed, then the previous value is returned.
.IP "since: 2.0.00" 4
.IX Item "since: 2.0.00"
.ie n .SS """content_type"""
.el .SS "\f(CWcontent_type\fP"
.IX Subsection "content_type"
Get/set the \s-1HTTP\s0 response \fIContent-type\fR header value.
.PP
.Vb 2
\&  my $content_type      = $r\->content_type();
\&  my $prev_content_type = $r\->content_type($new_content_type);
.Ve
.ie n .IP "obj: $r ( ""Apache2::RequestRec object"" )" 4
.el .IP "obj: \f(CW$r\fR ( \f(CWApache2::RequestRec object\fR )" 4
.IX Item "obj: $r ( Apache2::RequestRec object )"
.PD 0
.ie n .IP "opt arg1: $new_content_type (\s-1MIME\s0 type string)" 4
.el .IP "opt arg1: \f(CW$new_content_type\fR (\s-1MIME\s0 type string)" 4
.IX Item "opt arg1: $new_content_type (MIME type string)"
.PD
Assign a new \s-1HTTP\s0 response content-type. It will affect the response
only if \s-1HTTP\s0 headers weren't sent yet.
.ie n .IP "ret: $content_type" 4
.el .IP "ret: \f(CW$content_type\fR" 4
.IX Item "ret: $content_type"
The current content-type value.
.Sp
If \f(CW$new_content_type\fR was passed, the previous value is returned
instead.
.IP "since: 2.0.00" 4
.IX Item "since: 2.0.00"
.PP
For example, set the \f(CW\*(C`Content\-type\*(C'\fR header to \fItext/plain\fR.
.PP
.Vb 1
\&  $r\->content_type(\*(Aqtext/plain\*(Aq);
.Ve
.PP
If you set this header via the
\&\f(CW\*(C`headers_out\*(C'\fR
table directly, it will be ignored by Apache. So do not do that.
.ie n .SS """err_headers_out"""
.el .SS "\f(CWerr_headers_out\fP"
.IX Subsection "err_headers_out"
Get/set \s-1MIME\s0 response headers, printed even on errors and persist
across internal redirects.
.PP
.Vb 1
\&  $err_headers_out = $r\->err_headers_out();
.Ve
.ie n .IP "obj: $r ( ""Apache2::RequestRec object"" )" 4
.el .IP "obj: \f(CW$r\fR ( \f(CWApache2::RequestRec object\fR )" 4
.IX Item "obj: $r ( Apache2::RequestRec object )"
.PD 0
.ie n .IP "ret: $err_headers_out ( ""APR::Table object"" )" 4
.el .IP "ret: \f(CW$err_headers_out\fR ( \f(CWAPR::Table object\fR )" 4
.IX Item "ret: $err_headers_out ( APR::Table object )"
.IP "since: 2.0.00" 4
.IX Item "since: 2.0.00"
.PD
.PP
The difference between \f(CW\*(C`headers_out\*(C'\fR and
\&\f(CW\*(C`err_headers_out\*(C'\fR, is that the latter are printed even on error, and
persist across internal redirects (so the headers printed for
\&\f(CW\*(C`ErrorDocument\*(C'\fR handlers will have them).
.PP
For example, if a handler wants to return a 404 response, but
nevertheless to set a cookie, it has to be:
.PP
.Vb 2
\&  $r\->err_headers_out\->add(\*(AqSet\-Cookie\*(Aq => $cookie);
\&  return Apache2::Const::NOT_FOUND;
.Ve
.PP
If the handler does:
.PP
.Vb 2
\&  $r\->headers_out\->add(\*(AqSet\-Cookie\*(Aq => $cookie);
\&  return Apache2::Const::NOT_FOUND;
.Ve
.PP
the \f(CW\*(C`Set\-Cookie\*(C'\fR header won't be sent.
.ie n .SS """filename"""
.el .SS "\f(CWfilename\fP"
.IX Subsection "filename"
Get/set the filename on disk corresponding to this response (the
result of the \fI\s-1URI\s0 \-\-> filename\fR translation).
.PP
.Vb 2
\&  $filename      = $r\->filename();
\&  $prev_filename = $r\->filename($new_filename);
.Ve
.ie n .IP "obj: $r ( ""Apache2::RequestRec object"" )" 4
.el .IP "obj: \f(CW$r\fR ( \f(CWApache2::RequestRec object\fR )" 4
.IX Item "obj: $r ( Apache2::RequestRec object )"
.PD 0
.ie n .IP "opt arg1: $new_filename ( string )" 4
.el .IP "opt arg1: \f(CW$new_filename\fR ( string )" 4
.IX Item "opt arg1: $new_filename ( string )"
.PD
new value
.ie n .IP "ret: $filename ( string )" 4
.el .IP "ret: \f(CW$filename\fR ( string )" 4
.IX Item "ret: $filename ( string )"
the current filename, or the previous value if the optional
\&\f(CW$new_filename\fR argument was passed
.IP "since: 2.0.00" 4
.IX Item "since: 2.0.00"
.PP
Note that if you change the filename after the
\&\f(CW\*(C`PerlMapToStorageHandler\*(C'\fR
phase was run and expect Apache to serve it, you need to update its
\&\f(CW\*(C`stat\*(C'\fR record, like so:
.PP
.Vb 5
\&  use Apache2::RequestRec ();
\&  use APR::Finfo ();
\&  use APR::Const \-compile => qw(FINFO_NORM);
\&  $r\->filename($newfile);
\&  $r\->finfo(APR::Finfo::stat($newfile, APR::Const::FINFO_NORM, $r\->pool));
.Ve
.PP
if you don't, Apache will still try to use the previously cached
information about the previously set value of the filename.
.ie n .SS """finfo"""
.el .SS "\f(CWfinfo\fP"
.IX Subsection "finfo"
Get and set the \fIfinfo\fR request record member:
.PP
.Vb 2
\&  $finfo = $r\->finfo();
\&  $r\->finfo($finfo);
.Ve
.ie n .IP "obj: $r ( ""Apache2::RequestRec object"" )" 4
.el .IP "obj: \f(CW$r\fR ( \f(CWApache2::RequestRec object\fR )" 4
.IX Item "obj: $r ( Apache2::RequestRec object )"
.PD 0
.ie n .IP "opt arg1: $finfo ( ""APR::Finfo object"" )" 4
.el .IP "opt arg1: \f(CW$finfo\fR ( \f(CWAPR::Finfo object\fR )" 4
.IX Item "opt arg1: $finfo ( APR::Finfo object )"
.ie n .IP "ret: $finfo ( ""APR::Finfo object"" )" 4
.el .IP "ret: \f(CW$finfo\fR ( \f(CWAPR::Finfo object\fR )" 4
.IX Item "ret: $finfo ( APR::Finfo object )"
.PD
Always returns the current object.
.Sp
Due to the internal Apache implementation it's not possible to have
two different objects originating from \f(CW\*(C`$r\->finfo\*(C'\fR at the same
time. Whenever \f(CW\*(C`$r\->finfo\*(C'\fR is updated all objects will be updated
too to the latest value.
.IP "since: 2.0.00" 4
.IX Item "since: 2.0.00"
.PP
Most of the time, this method is used to get the \f(CW\*(C`finfo\*(C'\fR member. The
only reason you may want to set it is you need to use it before the
Apache's default map_to_storage phase is called.
.PP
Examples:
.IP "\(bu" 4
What Apache thinks is the current request filename (post the
\&\f(CW\*(C`PerlMapToStorageHandler\*(C'\fR
phase):
.Sp
.Vb 3
\&  use Apache2::RequestRec ();
\&  use APR::Finfo ();
\&  print $r\->finfo\->fname;
.Ve
.IP "\(bu" 4
Populate the \f(CW\*(C`finfo\*(C'\fR member (normally, before the
\&\f(CW\*(C`PerlMapToStorageHandler\*(C'\fR
phase):
.Sp
.Vb 2
\&  use APR::Finfo ();
\&  use APR::Const \-compile => qw(FINFO_NORM);
\&  
\&  my $finfo = APR::Finfo::stat(_\|_FILE_\|_, APR::Const::FINFO_NORM, $r\->pool);
\&  $r\->finfo($finfo);
.Ve
.ie n .SS """handler"""
.el .SS "\f(CWhandler\fP"
.IX Subsection "handler"
Get/set the equivalent of the \f(CW\*(C`SetHandler\*(C'\fR directive.
.PP
.Vb 2
\&  $handler      = $r\->handler();
\&  $prev_handler = $r\->handler($new_handler);
.Ve
.ie n .IP "obj: $r ( ""Apache2::RequestRec object"" )" 4
.el .IP "obj: \f(CW$r\fR ( \f(CWApache2::RequestRec object\fR )" 4
.IX Item "obj: $r ( Apache2::RequestRec object )"
.PD 0
.ie n .IP "opt arg1: $new_handler ( string )" 4
.el .IP "opt arg1: \f(CW$new_handler\fR ( string )" 4
.IX Item "opt arg1: $new_handler ( string )"
.PD
the new handler.
.ie n .IP "ret: $handler ( string )" 4
.el .IP "ret: \f(CW$handler\fR ( string )" 4
.IX Item "ret: $handler ( string )"
the current handler.
.Sp
If \f(CW$new_handler\fR is passed, the previous value is returned.
.IP "since: 2.0.00" 4
.IX Item "since: 2.0.00"
.ie n .SS """header_only"""
.el .SS "\f(CWheader_only\fP"
.IX Subsection "header_only"
Did the client has asked for headers only? e.g. if the request method
was \fB\s-1HEAD\s0\fR.
.PP
.Vb 1
\&  $status = $r\->header_only();
.Ve
.ie n .IP "obj: $r ( ""Apache2::RequestRec object"" )" 4
.el .IP "obj: \f(CW$r\fR ( \f(CWApache2::RequestRec object\fR )" 4
.IX Item "obj: $r ( Apache2::RequestRec object )"
.PD 0
.ie n .IP "ret: $status ( boolean )" 4
.el .IP "ret: \f(CW$status\fR ( boolean )" 4
.IX Item "ret: $status ( boolean )"
.PD
Returns true if the client is asking for headers only, false otherwise
.IP "since: 2.0.00" 4
.IX Item "since: 2.0.00"
.ie n .SS """headers_in"""
.el .SS "\f(CWheaders_in\fP"
.IX Subsection "headers_in"
Get/set the request \s-1MIME\s0 headers:
.PP
.Vb 1
\&  $headers_in = $r\->headers_in();
.Ve
.ie n .IP "obj: $r ( ""Apache2::RequestRec object"" )" 4
.el .IP "obj: \f(CW$r\fR ( \f(CWApache2::RequestRec object\fR )" 4
.IX Item "obj: $r ( Apache2::RequestRec object )"
.PD 0
.ie n .IP "ret: $headers_in ( ""APR::Table object"" )" 4
.el .IP "ret: \f(CW$headers_in\fR ( \f(CWAPR::Table object\fR )" 4
.IX Item "ret: $headers_in ( APR::Table object )"
.IP "since: 2.0.00" 4
.IX Item "since: 2.0.00"
.PD
.PP
This table is available starting from the
\&\f(CW\*(C`PerlHeaderParserHandler\*(C'\fR
phase.
.PP
For example you can use it to retrieve the cookie value sent by the
client, in the \f(CW\*(C`Cookie:\*(C'\fR header:
.PP
.Vb 1
\&    my $cookie = $r\->headers_in\->{Cookie} || \*(Aq\*(Aq;
.Ve
.ie n .SS """headers_out"""
.el .SS "\f(CWheaders_out\fP"
.IX Subsection "headers_out"
Get/set \s-1MIME\s0 response headers, printed only on 2xx responses.
.PP
.Vb 1
\&  $headers_out = $r\->headers_out();
.Ve
.ie n .IP "obj: $r ( ""Apache2::RequestRec object"" )" 4
.el .IP "obj: \f(CW$r\fR ( \f(CWApache2::RequestRec object\fR )" 4
.IX Item "obj: $r ( Apache2::RequestRec object )"
.PD 0
.ie n .IP "ret: $headers_out ( ""APR::Table object"" )" 4
.el .IP "ret: \f(CW$headers_out\fR ( \f(CWAPR::Table object\fR )" 4
.IX Item "ret: $headers_out ( APR::Table object )"
.IP "since: 2.0.00" 4
.IX Item "since: 2.0.00"
.PD
.PP
See also \f(CW\*(C`err_headers_out\*(C'\fR, which allows to
set headers for non\-2xx responses and persist across internal
redirects.
.ie n .SS """hostname"""
.el .SS "\f(CWhostname\fP"
.IX Subsection "hostname"
Host, as set by full \s-1URI\s0 or Host:
.PP
.Vb 2
\&  $hostname = $r\->hostname();
\&  $prev_hostname = $r\->hostname($new_hostname);
.Ve
.ie n .IP "obj: $r ( ""Apache2::RequestRec object"" )" 4
.el .IP "obj: \f(CW$r\fR ( \f(CWApache2::RequestRec object\fR )" 4
.IX Item "obj: $r ( Apache2::RequestRec object )"
.PD 0
.ie n .IP "opt arg1: $new_hostname ( string )" 4
.el .IP "opt arg1: \f(CW$new_hostname\fR ( string )" 4
.IX Item "opt arg1: $new_hostname ( string )"
.PD
new value
.ie n .IP "ret: $hostname ( string )" 4
.el .IP "ret: \f(CW$hostname\fR ( string )" 4
.IX Item "ret: $hostname ( string )"
the current hostname, or the previous value if the optional
\&\f(CW$new_hostname\fR argument was passed
.IP "since: 2.0.00" 4
.IX Item "since: 2.0.00"
.ie n .SS """input_filters"""
.el .SS "\f(CWinput_filters\fP"
.IX Subsection "input_filters"
Get/set the first filter in a linked list of request level input
filters:
.PP
.Vb 2
\&  $input_filters      = $r\->input_filters();
\&  $prev_input_filters = $r\->input_filters($new_input_filters);
.Ve
.ie n .IP "obj: $r ( ""Apache2::RequestRec object"" )" 4
.el .IP "obj: \f(CW$r\fR ( \f(CWApache2::RequestRec object\fR )" 4
.IX Item "obj: $r ( Apache2::RequestRec object )"
.PD 0
.ie n .IP "opt arg1: $new_input_filters" 4
.el .IP "opt arg1: \f(CW$new_input_filters\fR" 4
.IX Item "opt arg1: $new_input_filters"
.PD
Set a new value
.ie n .IP "ret: $input_filters ( ""Apache2::Filter object"" )" 4
.el .IP "ret: \f(CW$input_filters\fR ( \f(CWApache2::Filter object\fR )" 4
.IX Item "ret: $input_filters ( Apache2::Filter object )"
The first filter in the request level input filters chain.
.Sp
If \f(CW$new_input_filters\fR was passed, returns the previous value.
.IP "since: 2.0.00" 4
.IX Item "since: 2.0.00"
.PP
For example instead of using
\&\f(CW\*(C`$r\->read()\*(C'\fR to read
the \s-1POST\s0 data, one could use an explicit walk through incoming bucket
brigades to get that data. The following function \f(CW\*(C`read_post()\*(C'\fR does
just that (in fact that's what
\&\f(CW\*(C`$r\->read()\*(C'\fR does
behind the scenes):
.PP
.Vb 3
\&  use APR::Brigade ();
\&  use APR::Bucket ();
\&  use Apache2::Filter ();
\&  
\&  use Apache2::Const \-compile => qw(MODE_READBYTES);
\&  use APR::Const    \-compile => qw(SUCCESS BLOCK_READ);
\&  
\&  use constant IOBUFSIZE => 8192;
\&  
\&  sub read_post {
\&      my $r = shift;
\&  
\&      my $bb = APR::Brigade\->new($r\->pool,
\&                                 $r\->connection\->bucket_alloc);
\&  
\&      my $data = \*(Aq\*(Aq;
\&      my $seen_eos = 0;
\&      do {
\&          $r\->input_filters\->get_brigade($bb, Apache2::Const::MODE_READBYTES,
\&                                         APR::Const::BLOCK_READ, IOBUFSIZE);
\&  
\&          for (my $b = $bb\->first; $b; $b = $bb\->next($b)) {
\&              if ($b\->is_eos) {
\&                  $seen_eos++;
\&                  last;
\&              }
\&  
\&              if ($b\->read(my $buf)) {
\&                  $data .= $buf;
\&              }
\&  
\&              $b\->remove; # optimization to reuse memory
\&          }
\&  
\&      } while (!$seen_eos);
\&  
\&      $bb\->destroy;
\&  
\&      return $data;
\&  }
.Ve
.PP
As you can see \f(CW\*(C`$r\->input_filters\*(C'\fR gives us a pointer to the last
of the top of the incoming filters stack.
.ie n .SS """main"""
.el .SS "\f(CWmain\fP"
.IX Subsection "main"
Get the main request record
.PP
.Vb 1
\&  $main_r = $r\->main();
.Ve
.ie n .IP "obj: $r ( ""Apache2::RequestRec object"" )" 4
.el .IP "obj: \f(CW$r\fR ( \f(CWApache2::RequestRec object\fR )" 4
.IX Item "obj: $r ( Apache2::RequestRec object )"
.PD 0
.ie n .IP "ret: $main_r ( ""Apache2::RequestRec object"" )" 4
.el .IP "ret: \f(CW$main_r\fR ( \f(CWApache2::RequestRec object\fR )" 4
.IX Item "ret: $main_r ( Apache2::RequestRec object )"
.PD
If the current request is a sub-request, this method returns a blessed
reference to the main request structure. If the current request is the
main request, then this method returns \f(CW\*(C`undef\*(C'\fR.
.Sp
To figure out whether you are inside a main request or a
sub\-request/internal redirect, use
\&\f(CW\*(C`$r\->is_initial_req\*(C'\fR.
.IP "since: 2.0.00" 4
.IX Item "since: 2.0.00"
.ie n .SS """method"""
.el .SS "\f(CWmethod\fP"
.IX Subsection "method"
Get/set the current request method (e.g. \f(CW\*(C`GET\*(C'\fR, \f(CW\*(C`HEAD\*(C'\fR, \f(CW\*(C`POST\*(C'\fR, etc.):
.PP
.Vb 2
\&  $method     = $r\->method();
\&  $pre_method = $r\->method($new_method);
.Ve
.ie n .IP "obj: $r ( ""Apache2::RequestRec object"" )" 4
.el .IP "obj: \f(CW$r\fR ( \f(CWApache2::RequestRec object\fR )" 4
.IX Item "obj: $r ( Apache2::RequestRec object )"
.PD 0
.ie n .IP "opt arg1: $new_method ( string )" 4
.el .IP "opt arg1: \f(CW$new_method\fR ( string )" 4
.IX Item "opt arg1: $new_method ( string )"
.PD
a new value
.ie n .IP "ret: $method ( string )" 4
.el .IP "ret: \f(CW$method\fR ( string )" 4
.IX Item "ret: $method ( string )"
The current method as a string
.Sp
if \f(CW$new_method\fR was passed the previous value is returned.
.IP "since: 2.0.00" 4
.IX Item "since: 2.0.00"
.ie n .SS """method_number"""
.el .SS "\f(CWmethod_number\fP"
.IX Subsection "method_number"
Get/set the \s-1HTTP\s0 method, issued by the client (\f(CW\*(C`Apache2::Const::M_GET\*(C'\fR,
\&\f(CW\*(C`Apache2::Const::M_POST\*(C'\fR, etc.)
.PP
.Vb 2
\&  $methnum      = $r\->method_number();
\&  $prev_methnum = $r\->method_number($new_methnum);
.Ve
.ie n .IP "obj: $r ( ""Apache2::RequestRec object"" )" 4
.el .IP "obj: \f(CW$r\fR ( \f(CWApache2::RequestRec object\fR )" 4
.IX Item "obj: $r ( Apache2::RequestRec object )"
.PD 0
.ie n .IP "opt arg1: $new_methnum ( ""Apache2::Const :methods constant"" )" 4
.el .IP "opt arg1: \f(CW$new_methnum\fR ( \f(CWApache2::Const :methods constant\fR )" 4
.IX Item "opt arg1: $new_methnum ( Apache2::Const :methods constant )"
.PD
a new value
.ie n .IP "ret: $methnum ( ""Apache2::Const :methods constant"" )" 4
.el .IP "ret: \f(CW$methnum\fR ( \f(CWApache2::Const :methods constant\fR )" 4
.IX Item "ret: $methnum ( Apache2::Const :methods constant )"
The current method as a number
.Sp
if \f(CW$new_methnum\fR was passed the previous value is returned.
.IP "since: 2.0.00" 4
.IX Item "since: 2.0.00"
.PP
See the \f(CW\*(C`$r\->allowed\*(C'\fR entry for examples.
.ie n .SS """mtime"""
.el .SS "\f(CWmtime\fP"
.IX Subsection "mtime"
Last modified time of the requested resource
.PP
.Vb 2
\&  $mtime      = $r\->mtime();
\&  $prev_mtime = $r\->mtime($new_mtime);
.Ve
.ie n .IP "obj: $r ( ""Apache2::RequestRec object"" )" 4
.el .IP "obj: \f(CW$r\fR ( \f(CWApache2::RequestRec object\fR )" 4
.IX Item "obj: $r ( Apache2::RequestRec object )"
.PD 0
.ie n .IP "opt arg1: $new_mtime (epoch seconds)." 4
.el .IP "opt arg1: \f(CW$new_mtime\fR (epoch seconds)." 4
.IX Item "opt arg1: $new_mtime (epoch seconds)."
.PD
a new value
.ie n .IP "ret: $mtime (epoch seconds)." 4
.el .IP "ret: \f(CW$mtime\fR (epoch seconds)." 4
.IX Item "ret: $mtime (epoch seconds)."
the current value
.Sp
if \f(CW$new_mtime\fR was passed the previous value is returned.
.IP "since: 2.0.00" 4
.IX Item "since: 2.0.00"
.ie n .SS """next"""
.el .SS "\f(CWnext\fP"
.IX Subsection "next"
Pointer to the redirected request if this is an external redirect
.PP
.Vb 1
\&  $next_r = $r\->next();
.Ve
.ie n .IP "obj: $r ( ""Apache2::RequestRec object"" )" 4
.el .IP "obj: \f(CW$r\fR ( \f(CWApache2::RequestRec object\fR )" 4
.IX Item "obj: $r ( Apache2::RequestRec object )"
.PD 0
.ie n .IP "ret: $next_r ( ""Apache2::RequestRec object"" )" 4
.el .IP "ret: \f(CW$next_r\fR ( \f(CWApache2::RequestRec object\fR )" 4
.IX Item "ret: $next_r ( Apache2::RequestRec object )"
.PD
returns a blessed reference to the next (internal) request structure
or \f(CW\*(C`undef\*(C'\fR if there is no next request.
.IP "since: 2.0.00" 4
.IX Item "since: 2.0.00"
.ie n .SS """no_local_copy"""
.el .SS "\f(CWno_local_copy\fP"
.IX Subsection "no_local_copy"
There is no local copy of this response
.PP
.Vb 1
\&  $status = $r\->no_local_copy();
.Ve
.ie n .IP "obj: $r ( ""Apache2::RequestRec object"" )" 4
.el .IP "obj: \f(CW$r\fR ( \f(CWApache2::RequestRec object\fR )" 4
.IX Item "obj: $r ( Apache2::RequestRec object )"
.PD 0
.ie n .IP "ret: $status (integer)" 4
.el .IP "ret: \f(CW$status\fR (integer)" 4
.IX Item "ret: $status (integer)"
.IP "since: 2.0.00" 4
.IX Item "since: 2.0.00"
.PD
.PP
Used internally in certain sub-requests to prevent sending
\&\f(CW\*(C`Apache2::Const::HTTP_NOT_MODIFIED\*(C'\fR for a fragment or error documents. For
example see the implementation in \fImodules/filters/mod_include.c\fR.
.PP
Also used internally in
\&\f(CW\*(C`$r\->meets_conditions\*(C'\fR
\&\*(-- if set to a true value, the conditions are always met.
.ie n .SS """notes"""
.el .SS "\f(CWnotes\fP"
.IX Subsection "notes"
Get/set text notes for the duration of this request. These notes can
be passed from one module to another (not only mod_perl, but modules
in any other language):
.PP
.Vb 2
\&  $notes      = $r\->notes();
\&  $prev_notes = $r\->notes($new_notes);
.Ve
.ie n .IP "obj: $r ( ""Apache2::RequestRec object"" )" 4
.el .IP "obj: \f(CW$r\fR ( \f(CWApache2::RequestRec object\fR )" 4
.IX Item "obj: $r ( Apache2::RequestRec object )"
.PD 0
.ie n .IP "opt arg1: $new_notes ( ""APR::Table object"" )" 4
.el .IP "opt arg1: \f(CW$new_notes\fR ( \f(CWAPR::Table object\fR )" 4
.IX Item "opt arg1: $new_notes ( APR::Table object )"
.ie n .IP "ret: $notes ( ""APR::Table object"" )" 4
.el .IP "ret: \f(CW$notes\fR ( \f(CWAPR::Table object\fR )" 4
.IX Item "ret: $notes ( APR::Table object )"
.PD
the current notes table.
.Sp
if the \f(CW$new_notes\fR argument was passed, returns the previous value.
.IP "since: 2.0.00" 4
.IX Item "since: 2.0.00"
.PP
If you want to pass Perl structures, you can use
\&\f(CW\*(C`$r\->pnotes\*(C'\fR.
.PP
Also see
\&\f(CW\*(C`$c\->notes\*(C'\fR
.ie n .SS """output_filters"""
.el .SS "\f(CWoutput_filters\fP"
.IX Subsection "output_filters"
Get the first filter in a linked list of request level output filters:
.PP
.Vb 2
\&  $output_filters      = $r\->output_filters();
\&  $prev_output_filters = $r\->output_filters($new_output_filters);
.Ve
.ie n .IP "obj: $r ( ""Apache2::RequestRec object"" )" 4
.el .IP "obj: \f(CW$r\fR ( \f(CWApache2::RequestRec object\fR )" 4
.IX Item "obj: $r ( Apache2::RequestRec object )"
.PD 0
.ie n .IP "opt arg1: $new_output_filters" 4
.el .IP "opt arg1: \f(CW$new_output_filters\fR" 4
.IX Item "opt arg1: $new_output_filters"
.PD
Set a new value
.ie n .IP "ret: $output_filters ( ""Apache2::Filter object"" )" 4
.el .IP "ret: \f(CW$output_filters\fR ( \f(CWApache2::Filter object\fR )" 4
.IX Item "ret: $output_filters ( Apache2::Filter object )"
The first filter in the request level output filters chain.
.Sp
If \f(CW$new_output_filters\fR was passed, returns the previous value.
.IP "since: 2.0.00" 4
.IX Item "since: 2.0.00"
.PP
For example instead of using
\&\f(CW\*(C`$r\->print()\*(C'\fR to
send the response body, one could send the data directly to the first
output filter. The following function \f(CW\*(C`send_response_body()\*(C'\fR does
just that:
.PP
.Vb 3
\&  use APR::Brigade ();
\&  use APR::Bucket ();
\&  use Apache2::Filter ();
\&  
\&  sub send_response_body {
\&      my ($r, $data) = @_;
\&  
\&      my $bb = APR::Brigade\->new($r\->pool,
\&                                 $r\->connection\->bucket_alloc);
\&  
\&      my $b = APR::Bucket\->new($bb\->bucket_alloc, $data);
\&      $bb\->insert_tail($b);
\&      $r\->output_filters\->fflush($bb);
\&      $bb\->destroy;
\&  }
.Ve
.PP
In fact that's what
\&\f(CW\*(C`$r\->read()\*(C'\fR does
behind the scenes. But it also knows to parse \s-1HTTP\s0 headers passed
together with the data and it also implements buffering, which the
above function does not.
.ie n .SS """path_info"""
.el .SS "\f(CWpath_info\fP"
.IX Subsection "path_info"
Get/set the \f(CW\*(C`PATH_INFO\*(C'\fR, what is left in the path after the \fI\s-1URI\s0
\&\-\-> filename\fR translation:
.PP
.Vb 2
\&  $path_info      = $r\->path_info();
\&  $prev_path_info = $r\->path_info($path_info);
.Ve
.ie n .IP "obj: $r ( ""Apache2::RequestRec object"" )" 4
.el .IP "obj: \f(CW$r\fR ( \f(CWApache2::RequestRec object\fR )" 4
.IX Item "obj: $r ( Apache2::RequestRec object )"
.PD 0
.ie n .IP "opt arg1: $path_info ( string )" 4
.el .IP "opt arg1: \f(CW$path_info\fR ( string )" 4
.IX Item "opt arg1: $path_info ( string )"
.PD
Set a new value
.ie n .IP "ret: $path_info ( string )" 4
.el .IP "ret: \f(CW$path_info\fR ( string )" 4
.IX Item "ret: $path_info ( string )"
Return the current value.
.Sp
If the optional argument \f(CW$path_info\fR is passed, the previous value
is returned.
.IP "since: 2.0.00" 4
.IX Item "since: 2.0.00"
.ie n .SS """per_dir_config"""
.el .SS "\f(CWper_dir_config\fP"
.IX Subsection "per_dir_config"
Get the dir config vector:
.PP
.Vb 1
\&  $per_dir_config = $r\->per_dir_config();
.Ve
.ie n .IP "obj: $r ( ""Apache2::RequestRec object"" )" 4
.el .IP "obj: \f(CW$r\fR ( \f(CWApache2::RequestRec object\fR )" 4
.IX Item "obj: $r ( Apache2::RequestRec object )"
.PD 0
.ie n .IP "ret: $per_dir_config ( ""Apache2::ConfVector object"" )" 4
.el .IP "ret: \f(CW$per_dir_config\fR ( \f(CWApache2::ConfVector object\fR )" 4
.IX Item "ret: $per_dir_config ( Apache2::ConfVector object )"
.IP "since: 2.0.00" 4
.IX Item "since: 2.0.00"
.PD
.PP
For an indepth discussion, refer to the Apache Server Configuration
Customization in Perl chapter.
.ie n .SS """pool"""
.el .SS "\f(CWpool\fP"
.IX Subsection "pool"
The pool associated with the request
.PP
.Vb 1
\&  $p = $r\->pool();
.Ve
.ie n .IP "obj: $r ( ""Apache2::RequestRec object"" )" 4
.el .IP "obj: \f(CW$r\fR ( \f(CWApache2::RequestRec object\fR )" 4
.IX Item "obj: $r ( Apache2::RequestRec object )"
.PD 0
.ie n .IP "ret: $p ( ""APR::Pool object"" )" 4
.el .IP "ret: \f(CW$p\fR ( \f(CWAPR::Pool object\fR )" 4
.IX Item "ret: $p ( APR::Pool object )"
.IP "since: 2.0.00" 4
.IX Item "since: 2.0.00"
.PD
.ie n .SS """prev"""
.el .SS "\f(CWprev\fP"
.IX Subsection "prev"
Pointer to the previous request if this is an internal redirect
.PP
.Vb 1
\&  $prev_r = $r\->prev();
.Ve
.ie n .IP "obj: $r ( ""Apache2::RequestRec object"" )" 4
.el .IP "obj: \f(CW$r\fR ( \f(CWApache2::RequestRec object\fR )" 4
.IX Item "obj: $r ( Apache2::RequestRec object )"
.PD 0
.ie n .IP "ret: $prev_r ( ""Apache2::RequestRec object"" )" 4
.el .IP "ret: \f(CW$prev_r\fR ( \f(CWApache2::RequestRec object\fR )" 4
.IX Item "ret: $prev_r ( Apache2::RequestRec object )"
.PD
a blessed reference to the previous (internal) request structure or
\&\f(CW\*(C`undef\*(C'\fR if there is no previous request.
.IP "since: 2.0.00" 4
.IX Item "since: 2.0.00"
.ie n .SS """proto_input_filters"""
.el .SS "\f(CWproto_input_filters\fP"
.IX Subsection "proto_input_filters"
Get the first filter in a linked list of protocol level input filters:
.PP
.Vb 2
\&  $proto_input_filters      = $r\->proto_input_filters();
\&  $prev_proto_input_filters = $r\->proto_input_filters($new_proto_input_filters);
.Ve
.ie n .IP "obj: $r ( ""Apache2::RequestRec object"" )" 4
.el .IP "obj: \f(CW$r\fR ( \f(CWApache2::RequestRec object\fR )" 4
.IX Item "obj: $r ( Apache2::RequestRec object )"
.PD 0
.ie n .IP "opt arg1: $new_proto_input_filters" 4
.el .IP "opt arg1: \f(CW$new_proto_input_filters\fR" 4
.IX Item "opt arg1: $new_proto_input_filters"
.PD
Set a new value
.ie n .IP "ret: $proto_input_filters ( ""Apache2::Filter object"" )" 4
.el .IP "ret: \f(CW$proto_input_filters\fR ( \f(CWApache2::Filter object\fR )" 4
.IX Item "ret: $proto_input_filters ( Apache2::Filter object )"
The first filter in the protocol level input filters chain.
.Sp
If \f(CW$new_proto_input_filters\fR was passed, returns the previous value.
.IP "since: 2.0.00" 4
.IX Item "since: 2.0.00"
.PP
\&\f(CW\*(C`$r\->proto_input_filters\*(C'\fR points to the same filter as
\&\f(CW\*(C`$r\->connection\->input_filters\*(C'\fR.
.ie n .SS """proto_num"""
.el .SS "\f(CWproto_num\fP"
.IX Subsection "proto_num"
Get current request's \s-1HTTP\s0 protocol version number
.PP
.Vb 1
\&  $proto_num = $r\->proto_num();
.Ve
.ie n .IP "obj: $r ( ""Apache2::RequestRec object"" )" 4
.el .IP "obj: \f(CW$r\fR ( \f(CWApache2::RequestRec object\fR )" 4
.IX Item "obj: $r ( Apache2::RequestRec object )"
.PD 0
.ie n .IP "ret: $proto_num (integer)" 4
.el .IP "ret: \f(CW$proto_num\fR (integer)" 4
.IX Item "ret: $proto_num (integer)"
.PD
current request's \s-1HTTP\s0 protocol version number, e.g.: \s-1HTTP/1.0\s0 ==
1000, \s-1HTTP/1.1\s0 = 1001
.IP "since: 2.0.00" 4
.IX Item "since: 2.0.00"
.ie n .SS """proto_output_filters"""
.el .SS "\f(CWproto_output_filters\fP"
.IX Subsection "proto_output_filters"
Get the first filter in a linked list of protocol level output
filters:
.PP
.Vb 2
\&  $proto_output_filters      = $r\->proto_output_filters();
\&  $prev_proto_output_filters = $r\->proto_output_filters($new_proto_output_filters);
.Ve
.ie n .IP "obj: $r ( ""Apache2::RequestRec object"" )" 4
.el .IP "obj: \f(CW$r\fR ( \f(CWApache2::RequestRec object\fR )" 4
.IX Item "obj: $r ( Apache2::RequestRec object )"
.PD 0
.ie n .IP "opt arg1: $new_proto_output_filters" 4
.el .IP "opt arg1: \f(CW$new_proto_output_filters\fR" 4
.IX Item "opt arg1: $new_proto_output_filters"
.PD
Set a new value
.ie n .IP "ret: $proto_output_filters ( ""Apache2::Filter object"" )" 4
.el .IP "ret: \f(CW$proto_output_filters\fR ( \f(CWApache2::Filter object\fR )" 4
.IX Item "ret: $proto_output_filters ( Apache2::Filter object )"
The first filter in the protocol level output filters chain.
.Sp
If \f(CW$new_proto_output_filters\fR was passed, returns the previous value.
.IP "since: 2.0.00" 4
.IX Item "since: 2.0.00"
.PP
\&\f(CW\*(C`$r\->proto_output_filters\*(C'\fR points to the same filter as
\&\f(CW\*(C`$r\->connection\->output_filters\*(C'\fR.
.ie n .SS """protocol"""
.el .SS "\f(CWprotocol\fP"
.IX Subsection "protocol"
Get a string identifying the protocol that the client speaks.
.PP
.Vb 1
\&  $protocol = $r\->protocol();
.Ve
.ie n .IP "obj: $r ( ""Apache2::RequestRec object"" )" 4
.el .IP "obj: \f(CW$r\fR ( \f(CWApache2::RequestRec object\fR )" 4
.IX Item "obj: $r ( Apache2::RequestRec object )"
.PD 0
.ie n .IP "ret: $protocl ( string )" 4
.el .IP "ret: \f(CW$protocl\fR ( string )" 4
.IX Item "ret: $protocl ( string )"
.PD
Typical values are \f(CW"HTTP/1.0"\fR or \f(CW"HTTP/1.1"\fR.
.Sp
If the client didn't specify the protocol version, the default is
\&\f(CW"HTTP/0.9"\fR
.IP "since: 2.0.00" 4
.IX Item "since: 2.0.00"
.ie n .SS """proxyreq"""
.el .SS "\f(CWproxyreq\fP"
.IX Subsection "proxyreq"
Get/set the \fIproxyrec\fR request record member and optionally adjust
other related fields.
.PP
.Vb 1
\&  $status = $r\->proxyreq($val);
.Ve
.ie n .IP "obj: $r ( ""Apache2::RequestRec object"" )" 4
.el .IP "obj: \f(CW$r\fR ( \f(CWApache2::RequestRec object\fR )" 4
.IX Item "obj: $r ( Apache2::RequestRec object )"
.PD 0
.ie n .IP "opt arg1: $val ( integer )" 4
.el .IP "opt arg1: \f(CW$val\fR ( integer )" 4
.IX Item "opt arg1: $val ( integer )"
.PD
\&\s-1PROXYREQ_NONE, PROXYREQ_PROXY, PROXYREQ_REVERSE, PROXYREQ_RESPONSE\s0
.ie n .IP "ret: $status ( integer )" 4
.el .IP "ret: \f(CW$status\fR ( integer )" 4
.IX Item "ret: $status ( integer )"
If \f(CW$val\fR is defined the \fIproxyrec\fR member will be set to that value
and previous value will be returned.
.Sp
If \f(CW$val\fR is not passed, and \f(CW\*(C`$r\->proxyreq\*(C'\fR is not true, and the
proxy request is matching the current vhost (scheme, hostname and
port), the \fIproxyrec\fR member will be set to \s-1PROXYREQ_PROXY\s0 and that value
will be returned. In addition \f(CW\*(C`$r\->uri\*(C'\fR is set to \f(CW\*(C`$r\->unparsed_uri\*(C'\fR
and \f(CW\*(C`$r\->filename\*(C'\fR is set to \f(CW\*(C`"modperl\-proxy:".$r\->uri\*(C'\fR. If
those conditions aren't true 0 is returned.
.IP "since: 2.0.00" 4
.IX Item "since: 2.0.00"
.PP
For example to turn a normal request into a proxy request to be
handled on the same server in the \f(CW\*(C`PerlTransHandler\*(C'\fR phase run:
.PP
.Vb 5
\&  my $real_url = $r\->unparsed_uri;
\&  $r\->proxyreq(Apache2::Const::PROXYREQ_PROXY);
\&  $r\->uri($real_url);
\&  $r\->filename("proxy:$real_url");
\&  $r\->handler(\*(Aqproxy\-server\*(Aq);
.Ve
.PP
Also remember that if you want to turn a proxy request into a
non-proxy request, it's not enough to call:
.PP
.Vb 1
\&  $r\->proxyreq(Apache2::Const::PROXYREQ_NONE);
.Ve
.PP
You need to adjust \f(CW\*(C`$r\->uri\*(C'\fR and \f(CW\*(C`$r\->filename\*(C'\fR as well if
you run that code in \f(CW\*(C`PerlPostReadRequestHandler\*(C'\fR phase, since if you
don't \*(-- \f(CW\*(C`mod_proxy\*(C'\fR's own post_read_request handler will override
your settings (as it will run after the mod_perl handler).
.PP
And you may also want to add
.PP
.Vb 1
\&  $r\->set_handlers(PerlResponseHandler => []);
.Ve
.PP
so that any response handlers which match apache directives
will not run in addition to the mod_proxy content handler.
.ie n .SS """request_time"""
.el .SS "\f(CWrequest_time\fP"
.IX Subsection "request_time"
Time when the request started
.PP
.Vb 1
\&  $request_time = $r\->request_time();
.Ve
.ie n .IP "obj: $r ( ""Apache2::RequestRec object"" )" 4
.el .IP "obj: \f(CW$r\fR ( \f(CWApache2::RequestRec object\fR )" 4
.IX Item "obj: $r ( Apache2::RequestRec object )"
.PD 0
.ie n .IP "ret: $request_time (epoch seconds)." 4
.el .IP "ret: \f(CW$request_time\fR (epoch seconds)." 4
.IX Item "ret: $request_time (epoch seconds)."
.IP "since: 2.0.00" 4
.IX Item "since: 2.0.00"
.PD
.ie n .SS """server"""
.el .SS "\f(CWserver\fP"
.IX Subsection "server"
Get the \f(CW\*(C`Apache2::Server\*(C'\fR object for
the server the request \f(CW$r\fR is running under.
.PP
.Vb 1
\&  $s = $r\->server();
.Ve
.ie n .IP "obj: $r ( ""Apache2::RequestRec object"" )" 4
.el .IP "obj: \f(CW$r\fR ( \f(CWApache2::RequestRec object\fR )" 4
.IX Item "obj: $r ( Apache2::RequestRec object )"
.PD 0
.ie n .IP "ret: $s ( ""Apache2::ServerRec object"" )" 4
.el .IP "ret: \f(CW$s\fR ( \f(CWApache2::ServerRec object\fR )" 4
.IX Item "ret: $s ( Apache2::ServerRec object )"
.IP "since: 2.0.00" 4
.IX Item "since: 2.0.00"
.PD
.ie n .SS """status"""
.el .SS "\f(CWstatus\fP"
.IX Subsection "status"
Get/set the reply status for the client request.
.PP
.Vb 2
\&  $status      = $r\->status();
\&  $prev_status = $r\->status($new_status);
.Ve
.ie n .IP "obj: $r ( ""Apache2::RequestRec object"" )" 4
.el .IP "obj: \f(CW$r\fR ( \f(CWApache2::RequestRec object\fR )" 4
.IX Item "obj: $r ( Apache2::RequestRec object )"
.PD 0
.ie n .IP "opt arg1: $new_status ( integer )" 4
.el .IP "opt arg1: \f(CW$new_status\fR ( integer )" 4
.IX Item "opt arg1: $new_status ( integer )"
.PD
If \f(CW$new_status\fR is passed the new status is assigned.
.Sp
Normally you would use some \f(CW\*(C`Apache2::Const
constant\*(C'\fR, e.g. \f(CW\*(C`Apache2::Const::REDIRECT\*(C'\fR.
.ie n .IP "ret: $newval ( integer )" 4
.el .IP "ret: \f(CW$newval\fR ( integer )" 4
.IX Item "ret: $newval ( integer )"
The current value.
.Sp
If \f(CW$new_status\fR is passed the old value is returned.
.IP "since: 2.0.00" 4
.IX Item "since: 2.0.00"
.PP
Usually you will set this value indirectly by returning the status
code as the handler's function result.  However, there are rare
instances when you want to trick Apache into thinking that the module
returned an \f(CW\*(C`Apache2::Const::OK\*(C'\fR status code, but actually send the browser a
non-OK status. This may come handy when implementing an \s-1HTTP\s0 proxy
handler.  The proxy handler needs to send to the client, whatever
status code the proxied server has returned, while returning
\&\f(CW\*(C`Apache2::Const::OK\*(C'\fR to Apache. e.g.:
.PP
.Vb 2
\&  $r\->status($some_code);
\&  return Apache2::Const::OK
.Ve
.PP
See also \f(CW\*(C`$r\->status_line\*(C'\fR, which. if set,
overrides \f(CW\*(C`$r\->status\*(C'\fR.
.ie n .SS """status_line"""
.el .SS "\f(CWstatus_line\fP"
.IX Subsection "status_line"
Get/set the response status line.  The status line is a string like
\&\*(L"200 Document follows\*(R" and it will take precedence over the value
specified using the \f(CW\*(C`$r\->status()\*(C'\fR described above.
.PP
.Vb 2
\&  $status_line      = $r\->status_line();
\&  $prev_status_line = $r\->status_line($new_status_line);
.Ve
.ie n .IP "obj: $r ( ""Apache2::RequestRec object"" )" 4
.el .IP "obj: \f(CW$r\fR ( \f(CWApache2::RequestRec object\fR )" 4
.IX Item "obj: $r ( Apache2::RequestRec object )"
.PD 0
.ie n .IP "opt arg1: $new_status_line ( string )" 4
.el .IP "opt arg1: \f(CW$new_status_line\fR ( string )" 4
.IX Item "opt arg1: $new_status_line ( string )"
.ie n .IP "ret: $status_line ( string )" 4
.el .IP "ret: \f(CW$status_line\fR ( string )" 4
.IX Item "ret: $status_line ( string )"
.IP "since: 2.0.00" 4
.IX Item "since: 2.0.00"
.PD
.PP
When discussing \f(CW\*(C`$r\->status\*(C'\fR we have mentioned that
sometimes a handler runs to a successful completion, but may need to
return a different code, which is the case with the proxy
server. Assuming that the proxy handler forwards to the client
whatever response the proxied server has sent, it'll usually use
\&\f(CW\*(C`status_line()\*(C'\fR, like so:
.PP
.Vb 2
\&  $r\->status_line($response\->code() . \*(Aq \*(Aq . $response\->message());
\&  return Apache2::Const::OK;
.Ve
.PP
In this example \f(CW$response\fR could be for example an \f(CW\*(C`HTTP::Response\*(C'\fR
object, if \f(CW\*(C`LWP::UserAgent\*(C'\fR was used to implement the proxy.
.PP
This method is also handy when you extend the \s-1HTTP\s0 protocol and add
new response codes. For example you could invent a new error code and
tell Apache to use that in the response like so:
.PP
.Vb 2
\&  $r\->status_line("499 We have been FooBared");
\&  return Apache2::Const::OK;
.Ve
.PP
Here \f(CW499\fR is the new response code, and \fIWe have been FooBared\fR is
the custom response message.
.ie n .SS """subprocess_env"""
.el .SS "\f(CWsubprocess_env\fP"
.IX Subsection "subprocess_env"
Get/set the Apache \f(CW\*(C`subprocess_env\*(C'\fR table, or optionally set the
value of a named entry.
.PP
.Vb 2
\&               $r\->subprocess_env;
\&  $env_table = $r\->subprocess_env;
\&  
\&         $r\->subprocess_env($key => $val);
\&  $val = $r\->subprocess_env($key);
.Ve
.ie n .IP "obj: $r ( ""Apache2::RequestRec object"" )" 4
.el .IP "obj: \f(CW$r\fR ( \f(CWApache2::RequestRec object\fR )" 4
.IX Item "obj: $r ( Apache2::RequestRec object )"
.PD 0
.ie n .IP "opt arg1: $key ( string )" 4
.el .IP "opt arg1: \f(CW$key\fR ( string )" 4
.IX Item "opt arg1: $key ( string )"
.ie n .IP "opt arg2: $val ( string )" 4
.el .IP "opt arg2: \f(CW$val\fR ( string )" 4
.IX Item "opt arg2: $val ( string )"
.ie n .IP "ret: ""...""" 4
.el .IP "ret: \f(CW...\fR" 4
.IX Item "ret: ..."
.IP "since: 2.0.00" 4
.IX Item "since: 2.0.00"
.PD
.PP
When called in \s-1VOID\s0 context with no arguments, it populate \f(CW%ENV\fR
with special variables (e.g. \f(CW$ENV{QUERY_STRING}\fR) like mod_cgi
does.
.PP
When called in a non-VOID context with no arguments, it returns an
\&\f(CW\*(C`APR::Table object\*(C'\fR.
.PP
When the \f(CW$key\fR argument (string) is passed, it returns the
corresponding value (if such exists, or \f(CW\*(C`undef\*(C'\fR. The following two
lines are equivalent:
.PP
.Vb 2
\&  $val = $r\->subprocess_env($key);
\&  $val = $r\->subprocess_env\->get($key);
.Ve
.PP
When the \f(CW$key\fR and the \f(CW$val\fR arguments (strings) are passed, the
value is set. The following two lines are equivalent:
.PP
.Vb 2
\&  $r\->subprocess_env($key => $val);
\&  $r\->subprocess_env\->set($key => $val);
.Ve
.PP
The \f(CW\*(C`subprocess_env\*(C'\fR \f(CW\*(C`table\*(C'\fR is used
by \f(CW\*(C`Apache2::SubProcess\*(C'\fR, to
pass environment variables to externally spawned processes. It's also
used by various Apache modules, and you should use this table to pass
the environment variables. For example if in
\&\f(CW\*(C`PerlHeaderParserHandler\*(C'\fR you do:
.PP
.Vb 1
\&   $r\->subprocess_env(MyLanguage => "de");
.Ve
.PP
you can then deploy \f(CW\*(C`mod_include\*(C'\fR and write in \fI.shtml\fR document:
.PP
.Vb 7
\&   <!\-\-#if expr="$MyLanguage = en" \-\->
\&   English
\&   <!\-\-#elif expr="$MyLanguage = de" \-\->
\&   Deutsch
\&   <!\-\-#else \-\->
\&   Sorry
\&   <!\-\-#endif \-\->
.Ve
.ie n .SS """the_request"""
.el .SS "\f(CWthe_request\fP"
.IX Subsection "the_request"
First \s-1HTTP\s0 request header
.PP
.Vb 2
\&  $request = $r\->the_request();
\&  $old_request = $r\->uri($new_request);
.Ve
.ie n .IP "obj: $r ( ""Apache2::RequestRec object"" )" 4
.el .IP "obj: \f(CW$r\fR ( \f(CWApache2::RequestRec object\fR )" 4
.IX Item "obj: $r ( Apache2::RequestRec object )"
.PD 0
.ie n .IP "opt arg1: $new_request ( string )" 4
.el .IP "opt arg1: \f(CW$new_request\fR ( string )" 4
.IX Item "opt arg1: $new_request ( string )"
.ie n .IP "ret: $request ( string )" 4
.el .IP "ret: \f(CW$request\fR ( string )" 4
.IX Item "ret: $request ( string )"
.PD
For example:
.Sp
.Vb 1
\&  GET /foo/bar/my_path_info?args=3 HTTP/1.0
.Ve
.IP "since: 2.0.00" 4
.IX Item "since: 2.0.00"
.ie n .SS """unparsed_uri"""
.el .SS "\f(CWunparsed_uri\fP"
.IX Subsection "unparsed_uri"
The \s-1URI\s0 without any parsing performed
.PP
.Vb 1
\&  $unparsed_uri = $r\->unparsed_uri();
.Ve
.ie n .IP "obj: $r ( ""Apache2::RequestRec object"" )" 4
.el .IP "obj: \f(CW$r\fR ( \f(CWApache2::RequestRec object\fR )" 4
.IX Item "obj: $r ( Apache2::RequestRec object )"
.PD 0
.ie n .IP "ret: $unparsed_uri ( string )" 4
.el .IP "ret: \f(CW$unparsed_uri\fR ( string )" 4
.IX Item "ret: $unparsed_uri ( string )"
.IP "since: 2.0.00" 4
.IX Item "since: 2.0.00"
.PD
.PP
If for example the request was:
.PP
.Vb 1
\&  GET /foo/bar/my_path_info?args=3 HTTP/1.0
.Ve
.PP
\&\f(CW\*(C`$r\->uri\*(C'\fR returns:
.PP
.Vb 1
\&  /foo/bar/my_path_info
.Ve
.PP
whereas \f(CW\*(C`$r\->unparsed_uri\*(C'\fR returns:
.PP
.Vb 1
\&  /foo/bar/my_path_info?args=3
.Ve
.ie n .SS """uri"""
.el .SS "\f(CWuri\fP"
.IX Subsection "uri"
The path portion of the \s-1URI\s0
.PP
.Vb 2
\&  $uri         = $r\->uri();
\&  my $prec_uri = $r\->uri($new_uri);
.Ve
.ie n .IP "obj: $r ( ""Apache2::RequestRec object"" )" 4
.el .IP "obj: \f(CW$r\fR ( \f(CWApache2::RequestRec object\fR )" 4
.IX Item "obj: $r ( Apache2::RequestRec object )"
.PD 0
.ie n .IP "opt arg1: $new_uri ( string )" 4
.el .IP "opt arg1: \f(CW$new_uri\fR ( string )" 4
.IX Item "opt arg1: $new_uri ( string )"
.ie n .IP "ret: $uri ( string )" 4
.el .IP "ret: \f(CW$uri\fR ( string )" 4
.IX Item "ret: $uri ( string )"
.IP "since: 2.0.00" 4
.IX Item "since: 2.0.00"
.PD
.PP
See the example in the \f(CW\*(C`$r\->unparsed_uri\*(C'\fR
section.
.ie n .SS """user"""
.el .SS "\f(CWuser\fP"
.IX Subsection "user"
Get the user name, if an authentication process was successful. Or
set it.
.PP
.Vb 2
\&  $user      = $r\->user();
\&  $prev_user = $r\->user($new_user);
.Ve
.ie n .IP "obj: $r ( ""Apache2::RequestRec object"" )" 4
.el .IP "obj: \f(CW$r\fR ( \f(CWApache2::RequestRec object\fR )" 4
.IX Item "obj: $r ( Apache2::RequestRec object )"
.PD 0
.ie n .IP "opt arg1: $new_user ( string )" 4
.el .IP "opt arg1: \f(CW$new_user\fR ( string )" 4
.IX Item "opt arg1: $new_user ( string )"
.PD
Pass \f(CW$new_user\fR to set a new value
.ie n .IP "ret: $user ( string )" 4
.el .IP "ret: \f(CW$user\fR ( string )" 4
.IX Item "ret: $user ( string )"
The current username if an authentication process was successful.
.Sp
If \f(CW$new_user\fR was passed, the previous value is returned.
.IP "since: 2.0.00" 4
.IX Item "since: 2.0.00"
.PP
For example, let's print the username passed by the client:
.PP
.Vb 3
\&  my ($res, $sent_pw) = $r\->get_basic_auth_pw;
\&  return $res if $res != Apache2::Const::OK;
\&  print "User: ", $r\->user;
.Ve
.SH "Unsupported API"
.IX Header "Unsupported API"
\&\f(CW\*(C`Apache2::RequestRec\*(C'\fR also provides auto-generated Perl interface for
a few other methods which aren't tested at the moment and therefore
their \s-1API\s0 is a subject to change. These methods will be finalized
later as a need arises. If you want to rely on any of the following
methods please contact the the mod_perl development mailing
list so we can help each other take the steps necessary
to shift the method to an officially supported \s-1API.\s0
.ie n .SS """allowed_methods"""
.el .SS "\f(CWallowed_methods\fP"
.IX Subsection "allowed_methods"
\&\s-1META:\s0 Autogenerated \- needs to be reviewed/completed
.PP
List of allowed methods
.PP
.Vb 1
\&  $list = $r\->allowed_methods();
.Ve
.ie n .IP "obj: $r ( ""Apache2::RequestRec object"" )" 4
.el .IP "obj: \f(CW$r\fR ( \f(CWApache2::RequestRec object\fR )" 4
.IX Item "obj: $r ( Apache2::RequestRec object )"
.PD 0
.ie n .IP "ret: $list ( ""Apache2::MethodList object"" )" 4
.el .IP "ret: \f(CW$list\fR ( \f(CWApache2::MethodList object\fR )" 4
.IX Item "ret: $list ( Apache2::MethodList object )"
.IP "since: 2.0.00" 4
.IX Item "since: 2.0.00"
.PD
.PP
\&\s-1META:\s0 Apache2::MethodList is not available at the moment
.ie n .SS """allowed_xmethods"""
.el .SS "\f(CWallowed_xmethods\fP"
.IX Subsection "allowed_xmethods"
\&\s-1META:\s0 Autogenerated \- needs to be reviewed/completed
.PP
Array of extension methods
.PP
.Vb 1
\&  $array = $r\->allowed_xmethods();
.Ve
.ie n .IP "obj: $r ( ""Apache2::RequestRec object"" )" 4
.el .IP "obj: \f(CW$r\fR ( \f(CWApache2::RequestRec object\fR )" 4
.IX Item "obj: $r ( Apache2::RequestRec object )"
.PD 0
.ie n .IP "ret: $array ( ""APR::ArrayHeader object"" )" 4
.el .IP "ret: \f(CW$array\fR ( \f(CWAPR::ArrayHeader object\fR )" 4
.IX Item "ret: $array ( APR::ArrayHeader object )"
.IP "since: 2.0.00" 4
.IX Item "since: 2.0.00"
.PD
.PP
\&\s-1META:\s0 APR::ArrayHeader is not available at the moment
.ie n .SS """request_config"""
.el .SS "\f(CWrequest_config\fP"
.IX Subsection "request_config"
Config vector containing pointers to request's per-server config
structures
.PP
.Vb 1
\&  $ret = $r\->request_config($newval);
.Ve
.ie n .IP "obj: $r ( ""Apache2::RequestRec object"" )" 4
.el .IP "obj: \f(CW$r\fR ( \f(CWApache2::RequestRec object\fR )" 4
.IX Item "obj: $r ( Apache2::RequestRec object )"
.PD 0
.ie n .IP "opt arg1: $newval ( ""Apache2::ConfVector object"" )" 4
.el .IP "opt arg1: \f(CW$newval\fR ( \f(CWApache2::ConfVector object\fR )" 4
.IX Item "opt arg1: $newval ( Apache2::ConfVector object )"
.IP "since: 2.0.00" 4
.IX Item "since: 2.0.00"
.PD
.ie n .SS """used_path_info"""
.el .SS "\f(CWused_path_info\fP"
.IX Subsection "used_path_info"
\&\s-1META:\s0 Autogenerated \- needs to be reviewed/completed
.PP
Flag for the handler to accept or reject path_info on
the current request.  All modules should respect the
\&\s-1AP_REQ_ACCEPT_PATH_INFO\s0 and \s-1AP_REQ_REJECT_PATH_INFO\s0
values, while \s-1AP_REQ_DEFAULT_PATH_INFO\s0 indicates they
may follow existing conventions.  This is set to the
user's preference upon \s-1HOOK_VERY_FIRST\s0 of the fixups.
.PP
.Vb 1
\&  $ret = $r\->used_path_info($newval);
.Ve
.ie n .IP "obj: $r ( ""Apache2::RequestRec object"" )" 4
.el .IP "obj: \f(CW$r\fR ( \f(CWApache2::RequestRec object\fR )" 4
.IX Item "obj: $r ( Apache2::RequestRec object )"
.PD 0
.ie n .IP "arg1: $newval (integer)" 4
.el .IP "arg1: \f(CW$newval\fR (integer)" 4
.IX Item "arg1: $newval (integer)"
.IP "since: 2.0.00" 4
.IX Item "since: 2.0.00"
.PD
.SH "See Also"
.IX Header "See Also"
mod_perl 2.0 documentation.
.SH "Copyright"
.IX Header "Copyright"
mod_perl 2.0 and its core modules are copyrighted under
The Apache Software License, Version 2.0.
.SH "Authors"
.IX Header "Authors"
The mod_perl development team and numerous
contributors.
