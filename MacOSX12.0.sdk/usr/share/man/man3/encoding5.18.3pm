.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "encoding 3pm"
.TH encoding 3pm "2014-09-30" "perl v5.18.4" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
encoding \- allows you to write your script in non\-ascii or non\-utf8
.SH "WARNING"
.IX Header "WARNING"
This module is deprecated under perl 5.18.  It uses a mechanism provided by
perl that is deprecated under 5.18 and higher, and may be removed in a
future version.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&  use encoding "greek";  # Perl like Greek to you?
\&  use encoding "euc\-jp"; # Jperl!
\&
\&  # or you can even do this if your shell supports your native encoding
\&
\&  perl \-Mencoding=latin2 \-e\*(Aq...\*(Aq # Feeling centrally European?
\&  perl \-Mencoding=euc\-kr \-e\*(Aq...\*(Aq # Or Korean?
\&
\&  # more control
\&
\&  # A simple euc\-cn => utf\-8 converter
\&  use encoding "euc\-cn", STDOUT => "utf8";  while(<>){print};
\&
\&  # "no encoding;" supported (but not scoped!)
\&  no encoding;
\&
\&  # an alternate way, Filter
\&  use encoding "euc\-jp", Filter=>1;
\&  # now you can use kanji identifiers \-\- in euc\-jp!
\&
\&  # switch on locale \-
\&  # note that this probably means that unless you have a complete control
\&  # over the environments the application is ever going to be run, you should
\&  # NOT use the feature of encoding pragma allowing you to write your script
\&  # in any recognized encoding because changing locale settings will wreck
\&  # the script; you can of course still use the other features of the pragma.
\&  use encoding \*(Aq:locale\*(Aq;
.Ve
.SH "ABSTRACT"
.IX Header "ABSTRACT"
Let's start with a bit of history: Perl 5.6.0 introduced Unicode
support.  You could apply \f(CW\*(C`substr()\*(C'\fR and regexes even to complex \s-1CJK\s0
characters \*(-- so long as the script was written in \s-1UTF\-8. \s0 But back
then, text editors that supported \s-1UTF\-8\s0 were still rare and many users
instead chose to write scripts in legacy encodings, giving up a whole
new feature of Perl 5.6.
.PP
Rewind to the future: starting from perl 5.8.0 with the \fBencoding\fR
pragma, you can write your script in any encoding you like (so long
as the \f(CW\*(C`Encode\*(C'\fR module supports it) and still enjoy Unicode support.
This pragma achieves that by doing the following:
.IP "\(bu" 4
Internally converts all literals (\f(CW\*(C`q//,qq//,qr//,qw///, qx//\*(C'\fR) from
the encoding specified to utf8.  In Perl 5.8.1 and later, literals in
\&\f(CW\*(C`tr///\*(C'\fR and \f(CW\*(C`DATA\*(C'\fR pseudo-filehandle are also converted.
.IP "\(bu" 4
Changing PerlIO layers of \f(CW\*(C`STDIN\*(C'\fR and \f(CW\*(C`STDOUT\*(C'\fR to the encoding
 specified.
.SS "Literal Conversions"
.IX Subsection "Literal Conversions"
You can write code in EUC-JP as follows:
.PP
.Vb 3
\&  my $Rakuda = "\exF1\exD1\exF1\exCC"; # Camel in Kanji
\&               #<\-char\-><\-char\->   # 4 octets
\&  s/\ebCamel\eb/$Rakuda/;
.Ve
.PP
And with \f(CW\*(C`use encoding "euc\-jp"\*(C'\fR in effect, it is the same thing as
the code in \s-1UTF\-8:\s0
.PP
.Vb 2
\&  my $Rakuda = "\ex{99F1}\ex{99DD}"; # two Unicode Characters
\&  s/\ebCamel\eb/$Rakuda/;
.Ve
.ie n .SS "PerlIO layers for ""STD(IN|OUT)"""
.el .SS "PerlIO layers for \f(CWSTD(IN|OUT)\fP"
.IX Subsection "PerlIO layers for STD(IN|OUT)"
The \fBencoding\fR pragma also modifies the filehandle layers of
\&\s-1STDIN\s0 and \s-1STDOUT\s0 to the specified encoding.  Therefore,
.PP
.Vb 5
\&  use encoding "euc\-jp";
\&  my $message = "Camel is the symbol of perl.\en";
\&  my $Rakuda = "\exF1\exD1\exF1\exCC"; # Camel in Kanji
\&  $message =~ s/\ebCamel\eb/$Rakuda/;
\&  print $message;
.Ve
.PP
Will print \*(L"\exF1\exD1\exF1\exCC is the symbol of perl.\en\*(R",
not \*(L"\ex{99F1}\ex{99DD} is the symbol of perl.\en\*(R".
.PP
You can override this by giving extra arguments; see below.
.SS "Implicit upgrading for byte strings"
.IX Subsection "Implicit upgrading for byte strings"
By default, if strings operating under byte semantics and strings
with Unicode character data are concatenated, the new string will
be created by decoding the byte strings as \fI\s-1ISO 8859\-1 \s0(Latin\-1)\fR.
.PP
The \fBencoding\fR pragma changes this to use the specified encoding
instead.  For example:
.PP
.Vb 5
\&    use encoding \*(Aqutf8\*(Aq;
\&    my $string = chr(20000); # a Unicode string
\&    utf8::encode($string);   # now it\*(Aqs a UTF\-8 encoded byte string
\&    # concatenate with another Unicode string
\&    print length($string . chr(20000));
.Ve
.PP
Will print \f(CW2\fR, because \f(CW$string\fR is upgraded as \s-1UTF\-8. \s0 Without
\&\f(CW\*(C`use encoding \*(Aqutf8\*(Aq;\*(C'\fR, it will print \f(CW4\fR instead, since \f(CW$string\fR
is three octets when interpreted as Latin\-1.
.SS "Side effects"
.IX Subsection "Side effects"
If the \f(CW\*(C`encoding\*(C'\fR pragma is in scope then the lengths returned are
calculated from the length of \f(CW$/\fR in Unicode characters, which is not
always the same as the length of \f(CW$/\fR in the native encoding.
.PP
This pragma affects utf8::upgrade, but not utf8::downgrade.
.SH "FEATURES THAT REQUIRE 5.8.1"
.IX Header "FEATURES THAT REQUIRE 5.8.1"
Some of the features offered by this pragma requires perl 5.8.1.  Most
of these are done by Inaba Hiroto.  Any other features and changes
are good for 5.8.0.
.ie n .IP """NON-EUC"" doublebyte encodings" 4
.el .IP "``NON-EUC'' doublebyte encodings" 4
.IX Item "NON-EUC doublebyte encodings"
Because perl needs to parse script before applying this pragma, such
encodings as Shift_JIS and Big\-5 that may contain '\e' (\s-1BACKSLASH\s0;
\&\ex5c) in the second byte fails because the second byte may
accidentally escape the quoting character that follows.  Perl 5.8.1
or later fixes this problem.
.IP "tr//" 4
.IX Item "tr//"
\&\f(CW\*(C`tr//\*(C'\fR was overlooked by Perl 5 porters when they released perl 5.8.0
See the section below for details.
.IP "\s-1DATA\s0 pseudo-filehandle" 4
.IX Item "DATA pseudo-filehandle"
Another feature that was overlooked was \f(CW\*(C`DATA\*(C'\fR.
.SH "USAGE"
.IX Header "USAGE"
.IP "use encoding [\fI\s-1ENCNAME\s0\fR] ;" 4
.IX Item "use encoding [ENCNAME] ;"
Sets the script encoding to \fI\s-1ENCNAME\s0\fR.  And unless ${^UNICODE}
exists and non-zero, PerlIO layers of \s-1STDIN\s0 and \s-1STDOUT\s0 are set to
":encoding(\fI\s-1ENCNAME\s0\fR)".
.Sp
Note that \s-1STDERR WILL NOT\s0 be changed.
.Sp
Also note that non-STD file handles remain unaffected.  Use \f(CW\*(C`use
open\*(C'\fR or \f(CW\*(C`binmode\*(C'\fR to change layers of those.
.Sp
If no encoding is specified, the environment variable \s-1PERL_ENCODING\s0
is consulted.  If no encoding can be found, the error \f(CW\*(C`Unknown encoding
\&\*(Aq\f(CIENCNAME\f(CW\*(Aq\*(C'\fR will be thrown.
.IP "use encoding \fI\s-1ENCNAME\s0\fR [ \s-1STDIN\s0 => \fI\s-1ENCNAME_IN\s0\fR ...] ;" 4
.IX Item "use encoding ENCNAME [ STDIN => ENCNAME_IN ...] ;"
You can also individually set encodings of \s-1STDIN\s0 and \s-1STDOUT\s0 via the
\&\f(CW\*(C`STDIN => \f(CIENCNAME\f(CW\*(C'\fR form.  In this case, you cannot omit the
first \fI\s-1ENCNAME\s0\fR.  \f(CW\*(C`STDIN => undef\*(C'\fR turns the \s-1IO\s0 transcoding
completely off.
.Sp
When ${^UNICODE} exists and non-zero, these options will completely
ignored.  ${^UNICODE} is a variable introduced in perl 5.8.1.  See
perlrun see \*(L"${^UNICODE}\*(R" in perlvar and \*(L"\-C\*(R" in perlrun for
details (perl 5.8.1 and later).
.IP "use encoding \fI\s-1ENCNAME\s0\fR Filter=>1;" 4
.IX Item "use encoding ENCNAME Filter=>1;"
This turns the encoding pragma into a source filter.  While the
default approach just decodes interpolated literals (in \fIqq()\fR and
\&\fIqr()\fR), this will apply a source filter to the entire source code.  See
\&\*(L"The Filter Option\*(R" below for details.
.IP "no encoding;" 4
.IX Item "no encoding;"
Unsets the script encoding. The layers of \s-1STDIN, STDOUT\s0 are
reset to \*(L":raw\*(R" (the default unprocessed raw stream of bytes).
.SH "The Filter Option"
.IX Header "The Filter Option"
The magic of \f(CW\*(C`use encoding\*(C'\fR is not applied to the names of
identifiers.  In order to make \f(CW\*(C`${"\ex{4eba}"}++\*(C'\fR ($human++, where human
is a single Han ideograph) work, you still need to write your script
in \s-1UTF\-8\s0 \*(-- or use a source filter.  That's what 'Filter=>1' does.
.PP
What does this mean?  Your source code behaves as if it is written in
\&\s-1UTF\-8\s0 with 'use utf8' in effect.  So even if your editor only supports
Shift_JIS, for example, you can still try examples in Chapter 15 of
\&\f(CW\*(C`Programming Perl, 3rd Ed.\*(C'\fR.  For instance, you can use \s-1UTF\-8\s0
identifiers.
.PP
This option is significantly slower and (as of this writing) non-ASCII
identifiers are not very stable \s-1WITHOUT\s0 this option and with the
source code written in \s-1UTF\-8.\s0
.SS "Filter-related changes at Encode version 1.87"
.IX Subsection "Filter-related changes at Encode version 1.87"
.IP "\(bu" 4
The Filter option now sets \s-1STDIN\s0 and \s-1STDOUT\s0 like non-filter options.
And \f(CW\*(C`STDIN=>\f(CIENCODING\f(CW\*(C'\fR and \f(CW\*(C`STDOUT=>\f(CIENCODING\f(CW\*(C'\fR work like
non-filter version.
.IP "\(bu" 4
\&\f(CW\*(C`use utf8\*(C'\fR is implicitly declared so you no longer have to \f(CW\*(C`use
utf8\*(C'\fR to \f(CW\*(C`${"\ex{4eba}"}++\*(C'\fR.
.SH "CAVEATS"
.IX Header "CAVEATS"
.SS "\s-1NOT SCOPED\s0"
.IX Subsection "NOT SCOPED"
The pragma is a per script, not a per block lexical.  Only the last
\&\f(CW\*(C`use encoding\*(C'\fR or \f(CW\*(C`no encoding\*(C'\fR matters, and it affects
\&\fBthe whole script\fR.  However, the <no encoding> pragma is supported and
\&\fBuse encoding\fR can appear as many times as you want in a given script.
The multiple use of this pragma is discouraged.
.PP
By the same reason, the use this pragma inside modules is also
discouraged (though not as strongly discouraged as the case above.
See below).
.PP
If you still have to write a module with this pragma, be very careful
of the load order.  See the codes below;
.PP
.Vb 5
\&  # called module
\&  package Module_IN_BAR;
\&  use encoding "bar";
\&  # stuff in "bar" encoding here
\&  1;
\&
\&  # caller script
\&  use encoding "foo"
\&  use Module_IN_BAR;
\&  # surprise! use encoding "bar" is in effect.
.Ve
.PP
The best way to avoid this oddity is to use this pragma \s-1RIGHT AFTER\s0
other modules are loaded.  i.e.
.PP
.Vb 2
\&  use Module_IN_BAR;
\&  use encoding "foo";
.Ve
.SS "\s-1DO NOT MIX MULTIPLE ENCODINGS\s0"
.IX Subsection "DO NOT MIX MULTIPLE ENCODINGS"
Notice that only literals (string or regular expression) having only
legacy code points are affected: if you mix data like this
.PP
.Vb 1
\&    \exDF\ex{100}
.Ve
.PP
the data is assumed to be in (Latin 1 and) Unicode, not in your native
encoding.  In other words, this will match in \*(L"greek\*(R":
.PP
.Vb 1
\&    "\exDF" =~ /\ex{3af}/
.Ve
.PP
but this will not
.PP
.Vb 1
\&    "\exDF\ex{100}" =~ /\ex{3af}\ex{100}/
.Ve
.PP
since the \f(CW\*(C`\exDF\*(C'\fR (\s-1ISO 8859\-7 GREEK SMALL LETTER IOTA WITH TONOS\s0) on
the left will \fBnot\fR be upgraded to \f(CW\*(C`\ex{3af}\*(C'\fR (Unicode \s-1GREEK SMALL
LETTER IOTA WITH TONOS\s0) because of the \f(CW\*(C`\ex{100}\*(C'\fR on the left.  You
should not be mixing your legacy data and Unicode in the same string.
.PP
This pragma also affects encoding of the 0x80..0xFF code point range:
normally characters in that range are left as eight-bit bytes (unless
they are combined with characters with code points 0x100 or larger,
in which case all characters need to become \s-1UTF\-8\s0 encoded), but if
the \f(CW\*(C`encoding\*(C'\fR pragma is present, even the 0x80..0xFF range always
gets \s-1UTF\-8\s0 encoded.
.PP
After all, the best thing about this pragma is that you don't have to
resort to \ex{....} just to spell your name in a native encoding.
So feel free to put your strings in your encoding in quotes and
regexes.
.SS "tr/// with ranges"
.IX Subsection "tr/// with ranges"
The \fBencoding\fR pragma works by decoding string literals in
\&\f(CW\*(C`q//,qq//,qr//,qw///, qx//\*(C'\fR and so forth.  In perl 5.8.0, this
does not apply to \f(CW\*(C`tr///\*(C'\fR.  Therefore,
.PP
.Vb 4
\&  use encoding \*(Aqeuc\-jp\*(Aq;
\&  #....
\&  $kana =~ tr/\exA4\exA1\-\exA4\exF3/\exA5\exA1\-\exA5\exF3/;
\&  #           \-\-\-\-\-\-\-\- \-\-\-\-\-\-\-\- \-\-\-\-\-\-\-\- \-\-\-\-\-\-\-\-
.Ve
.PP
Does not work as
.PP
.Vb 1
\&  $kana =~ tr/\ex{3041}\-\ex{3093}/\ex{30a1}\-\ex{30f3}/;
.Ve
.IP "Legend of characters above" 4
.IX Item "Legend of characters above"
.Vb 6
\&  utf8     euc\-jp   charnames::viacode()
\&  \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&  \ex{3041} \exA4\exA1 HIRAGANA LETTER SMALL A
\&  \ex{3093} \exA4\exF3 HIRAGANA LETTER N
\&  \ex{30a1} \exA5\exA1 KATAKANA LETTER SMALL A
\&  \ex{30f3} \exA5\exF3 KATAKANA LETTER N
.Ve
.PP
This counterintuitive behavior has been fixed in perl 5.8.1.
.PP
\fIworkaround to tr///;\fR
.IX Subsection "workaround to tr///;"
.PP
In perl 5.8.0, you can work around as follows;
.PP
.Vb 3
\&  use encoding \*(Aqeuc\-jp\*(Aq;
\&  #  ....
\&  eval qq{ \e$kana =~ tr/\exA4\exA1\-\exA4\exF3/\exA5\exA1\-\exA5\exF3/ };
.Ve
.PP
Note the \f(CW\*(C`tr//\*(C'\fR expression is surrounded by \f(CW\*(C`qq{}\*(C'\fR.  The idea behind
is the same as classic idiom that makes \f(CW\*(C`tr///\*(C'\fR 'interpolate'.
.PP
.Vb 2
\&   tr/$from/$to/;            # wrong!
\&   eval qq{ tr/$from/$to/ }; # workaround.
.Ve
.PP
Nevertheless, in case of \fBencoding\fR pragma even \f(CW\*(C`q//\*(C'\fR is affected so
\&\f(CW\*(C`tr///\*(C'\fR not being decoded was obviously against the will of Perl5
Porters so it has been fixed in Perl 5.8.1 or later.
.SH "EXAMPLE \- Greekperl"
.IX Header "EXAMPLE - Greekperl"
.Vb 1
\&    use encoding "iso 8859\-7";
\&
\&    # \exDF in ISO 8859\-7 (Greek) is \ex{3af} in Unicode.
\&
\&    $a = "\exDF";
\&    $b = "\ex{100}";
\&
\&    printf "%#x\en", ord($a); # will print 0x3af, not 0xdf
\&
\&    $c = $a . $b;
\&
\&    # $c will be "\ex{3af}\ex{100}", not "\ex{df}\ex{100}".
\&
\&    # chr() is affected, and ...
\&
\&    print "mega\en"  if ord(chr(0xdf)) == 0x3af;
\&
\&    # ... ord() is affected by the encoding pragma ...
\&
\&    print "tera\en" if ord(pack("C", 0xdf)) == 0x3af;
\&
\&    # ... as are eq and cmp ...
\&
\&    print "peta\en" if "\ex{3af}" eq  pack("C", 0xdf);
\&    print "exa\en"  if "\ex{3af}" cmp pack("C", 0xdf) == 0;
\&
\&    # ... but pack/unpack C are not affected, in case you still
\&    # want to go back to your native encoding
\&
\&    print "zetta\en" if unpack("C", (pack("C", 0xdf))) == 0xdf;
.Ve
.SH "KNOWN PROBLEMS"
.IX Header "KNOWN PROBLEMS"
.IP "literals in regex that are longer than 127 bytes" 4
.IX Item "literals in regex that are longer than 127 bytes"
For native multibyte encodings (either fixed or variable length),
the current implementation of the regular expressions may introduce
recoding errors for regular expression literals longer than 127 bytes.
.IP "\s-1EBCDIC\s0" 4
.IX Item "EBCDIC"
The encoding pragma is not supported on \s-1EBCDIC\s0 platforms.
(Porters who are willing and able to remove this limitation are
welcome.)
.IP "format" 4
.IX Item "format"
This pragma doesn't work well with format because PerlIO does not
get along very well with it.  When format contains non-ascii
characters it prints funny or gets \*(L"wide character warnings\*(R".
To understand it, try the code below.
.Sp
.Vb 11
\&  # Save this one in utf8
\&  # replace *non\-ascii* with a non\-ascii string
\&  my $camel;
\&  format STDOUT =
\&  *non\-ascii*@>>>>>>>
\&  $camel
\&  .
\&  $camel = "*non\-ascii*";
\&  binmode(STDOUT=>\*(Aq:encoding(utf8)\*(Aq); # bang!
\&  write;              # funny
\&  print $camel, "\en"; # fine
.Ve
.Sp
Without binmode this happens to work but without binmode, \fIprint()\fR
fails instead of \fIwrite()\fR.
.Sp
At any rate, the very use of format is questionable when it comes to
unicode characters since you have to consider such things as character
width (i.e. double-width for ideographs) and directions (i.e. \s-1BIDI\s0 for
Arabic and Hebrew).
.IP "Thread safety" 4
.IX Item "Thread safety"
\&\f(CW\*(C`use encoding ...\*(C'\fR is not thread-safe (i.e., do not use in threaded
applications).
.SS "The Logic of :locale"
.IX Subsection "The Logic of :locale"
The logic of \f(CW\*(C`:locale\*(C'\fR is as follows:
.IP "1." 4
If the platform supports the langinfo(\s-1CODESET\s0) interface, the codeset
returned is used as the default encoding for the open pragma.
.IP "2." 4
If 1. didn't work but we are under the locale pragma, the environment
variables \s-1LC_ALL\s0 and \s-1LANG \s0(in that order) are matched for encodings
(the part after \f(CW\*(C`.\*(C'\fR, if any), and if any found, that is used
as the default encoding for the open pragma.
.IP "3." 4
If 1. and 2. didn't work, the environment variables \s-1LC_ALL\s0 and \s-1LANG
\&\s0(in that order) are matched for anything looking like \s-1UTF\-8,\s0 and if
any found, \f(CW\*(C`:utf8\*(C'\fR is used as the default encoding for the open
pragma.
.PP
If your locale environment variables (\s-1LC_ALL, LC_CTYPE, LANG\s0)
contain the strings '\s-1UTF\-8\s0' or '\s-1UTF8\s0' (case-insensitive matching),
the default encoding of your \s-1STDIN, STDOUT,\s0 and \s-1STDERR,\s0 and of
\&\fBany subsequent file open\fR, is \s-1UTF\-8.\s0
.SH "HISTORY"
.IX Header "HISTORY"
This pragma first appeared in Perl 5.8.0.  For features that require
5.8.1 and better, see above.
.PP
The \f(CW\*(C`:locale\*(C'\fR subpragma was implemented in 2.01, or Perl 5.8.6.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
perlunicode, Encode, open, Filter::Util::Call,
.PP
Ch. 15 of \f(CW\*(C`Programming Perl (3rd Edition)\*(C'\fR
by Larry Wall, Tom Christiansen, Jon Orwant;
O'Reilly & Associates; \s-1ISBN 0\-596\-00027\-8\s0
