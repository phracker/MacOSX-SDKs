.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "HTTP::Cookies 3"
.TH HTTP::Cookies 3 "2012-02-15" "perl v5.18.4" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
HTTP::Cookies \- HTTP cookie jars
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 5
\&  use HTTP::Cookies;
\&  $cookie_jar = HTTP::Cookies\->new(
\&    file => "$ENV{\*(AqHOME\*(Aq}/lwp_cookies.dat",
\&    autosave => 1,
\&  );
\&
\&  use LWP;
\&  my $browser = LWP::UserAgent\->new;
\&  $browser\->cookie_jar($cookie_jar);
.Ve
.PP
Or for an empty and temporary cookie jar:
.PP
.Vb 3
\&  use LWP;
\&  my $browser = LWP::UserAgent\->new;
\&  $browser\->cookie_jar( {} );
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This class is for objects that represent a \*(L"cookie jar\*(R" \*(-- that is, a
database of all the \s-1HTTP\s0 cookies that a given LWP::UserAgent object
knows about.
.PP
Cookies are a general mechanism which server side connections can use
to both store and retrieve information on the client side of the
connection.  For more information about cookies refer to
<URL:http://curl.haxx.se/rfc/cookie_spec.html> and
<URL:http://www.cookiecentral.com/>.  This module also implements the
new style cookies described in \fI\s-1RFC 2965\s0\fR.
The two variants of cookies are supposed to be able to coexist happily.
.PP
Instances of the class \fIHTTP::Cookies\fR are able to store a collection
of Set\-Cookie2: and Set-Cookie: headers and are able to use this
information to initialize Cookie-headers in \fIHTTP::Request\fR objects.
The state of a \fIHTTP::Cookies\fR object can be saved in and restored from
files.
.SH "METHODS"
.IX Header "METHODS"
The following methods are provided:
.ie n .IP "$cookie_jar = HTTP::Cookies\->new" 4
.el .IP "\f(CW$cookie_jar\fR = HTTP::Cookies\->new" 4
.IX Item "$cookie_jar = HTTP::Cookies->new"
The constructor takes hash style parameters.  The following
parameters are recognized:
.Sp
.Vb 4
\&  file:            name of the file to restore cookies from and save cookies to
\&  autosave:        save during destruction (bool)
\&  ignore_discard:  save even cookies that are requested to be discarded (bool)
\&  hide_cookie2:    do not add Cookie2 header to requests
.Ve
.Sp
Future parameters might include (not yet implemented):
.Sp
.Vb 3
\&  max_cookies               300
\&  max_cookies_per_domain    20
\&  max_cookie_size           4096
\&
\&  no_cookies   list of domain names that we never return cookies to
.Ve
.ie n .IP "$cookie_jar\->add_cookie_header( $request )" 4
.el .IP "\f(CW$cookie_jar\fR\->add_cookie_header( \f(CW$request\fR )" 4
.IX Item "$cookie_jar->add_cookie_header( $request )"
The \fIadd_cookie_header()\fR method will set the appropriate Cookie:\-header
for the \fIHTTP::Request\fR object given as argument.  The \f(CW$request\fR must
have a valid url attribute before this method is called.
.ie n .IP "$cookie_jar\->extract_cookies( $response )" 4
.el .IP "\f(CW$cookie_jar\fR\->extract_cookies( \f(CW$response\fR )" 4
.IX Item "$cookie_jar->extract_cookies( $response )"
The \fIextract_cookies()\fR method will look for Set-Cookie: and
Set\-Cookie2: headers in the \fIHTTP::Response\fR object passed as
argument.  Any of these headers that are found are used to update
the state of the \f(CW$cookie_jar\fR.
.ie n .IP "$cookie_jar\->set_cookie( $version, $key, $val, $path, $domain, $port, $path_spec, $secure, $maxage, $discard, \e%rest )" 4
.el .IP "\f(CW$cookie_jar\fR\->set_cookie( \f(CW$version\fR, \f(CW$key\fR, \f(CW$val\fR, \f(CW$path\fR, \f(CW$domain\fR, \f(CW$port\fR, \f(CW$path_spec\fR, \f(CW$secure\fR, \f(CW$maxage\fR, \f(CW$discard\fR, \e%rest )" 4
.IX Item "$cookie_jar->set_cookie( $version, $key, $val, $path, $domain, $port, $path_spec, $secure, $maxage, $discard, %rest )"
The \fIset_cookie()\fR method updates the state of the \f(CW$cookie_jar\fR.  The
\&\f(CW$key\fR, \f(CW$val\fR, \f(CW$domain\fR, \f(CW$port\fR and \f(CW$path\fR arguments are strings.  The
\&\f(CW$path_spec\fR, \f(CW$secure\fR, \f(CW$discard\fR arguments are boolean values. The \f(CW$maxage\fR
value is a number indicating number of seconds that this cookie will
live.  A value <= 0 will delete this cookie.  \f(CW%rest\fR defines
various other attributes like \*(L"Comment\*(R" and \*(L"CommentURL\*(R".
.ie n .IP "$cookie_jar\->save" 4
.el .IP "\f(CW$cookie_jar\fR\->save" 4
.IX Item "$cookie_jar->save"
.PD 0
.ie n .IP "$cookie_jar\->save( $file )" 4
.el .IP "\f(CW$cookie_jar\fR\->save( \f(CW$file\fR )" 4
.IX Item "$cookie_jar->save( $file )"
.PD
This method file saves the state of the \f(CW$cookie_jar\fR to a file.
The state can then be restored later using the \fIload()\fR method.  If a
filename is not specified we will use the name specified during
construction.  If the attribute \fIignore_discard\fR is set, then we
will even save cookies that are marked to be discarded.
.Sp
The default is to save a sequence of \*(L"Set\-Cookie3\*(R" lines.
\&\*(L"Set\-Cookie3\*(R" is a proprietary \s-1LWP\s0 format, not known to be compatible
with any browser.  The \fIHTTP::Cookies::Netscape\fR sub-class can
be used to save in a format compatible with Netscape.
.ie n .IP "$cookie_jar\->load" 4
.el .IP "\f(CW$cookie_jar\fR\->load" 4
.IX Item "$cookie_jar->load"
.PD 0
.ie n .IP "$cookie_jar\->load( $file )" 4
.el .IP "\f(CW$cookie_jar\fR\->load( \f(CW$file\fR )" 4
.IX Item "$cookie_jar->load( $file )"
.PD
This method reads the cookies from the file and adds them to the
\&\f(CW$cookie_jar\fR.  The file must be in the format written by the \fIsave()\fR
method.
.ie n .IP "$cookie_jar\->revert" 4
.el .IP "\f(CW$cookie_jar\fR\->revert" 4
.IX Item "$cookie_jar->revert"
This method empties the \f(CW$cookie_jar\fR and re-loads the \f(CW$cookie_jar\fR
from the last save file.
.ie n .IP "$cookie_jar\->clear" 4
.el .IP "\f(CW$cookie_jar\fR\->clear" 4
.IX Item "$cookie_jar->clear"
.PD 0
.ie n .IP "$cookie_jar\->clear( $domain )" 4
.el .IP "\f(CW$cookie_jar\fR\->clear( \f(CW$domain\fR )" 4
.IX Item "$cookie_jar->clear( $domain )"
.ie n .IP "$cookie_jar\->clear( $domain, $path )" 4
.el .IP "\f(CW$cookie_jar\fR\->clear( \f(CW$domain\fR, \f(CW$path\fR )" 4
.IX Item "$cookie_jar->clear( $domain, $path )"
.ie n .IP "$cookie_jar\->clear( $domain, $path, $key )" 4
.el .IP "\f(CW$cookie_jar\fR\->clear( \f(CW$domain\fR, \f(CW$path\fR, \f(CW$key\fR )" 4
.IX Item "$cookie_jar->clear( $domain, $path, $key )"
.PD
Invoking this method without arguments will empty the whole
\&\f(CW$cookie_jar\fR.  If given a single argument only cookies belonging to
that domain will be removed.  If given two arguments, cookies
belonging to the specified path within that domain are removed.  If
given three arguments, then the cookie with the specified key, path
and domain is removed.
.ie n .IP "$cookie_jar\->clear_temporary_cookies" 4
.el .IP "\f(CW$cookie_jar\fR\->clear_temporary_cookies" 4
.IX Item "$cookie_jar->clear_temporary_cookies"
Discard all temporary cookies. Scans for all cookies in the jar
with either no expire field or a true \f(CW\*(C`discard\*(C'\fR flag. To be
called when the user agent shuts down according to \s-1RFC 2965.\s0
.ie n .IP "$cookie_jar\->scan( \e&callback )" 4
.el .IP "\f(CW$cookie_jar\fR\->scan( \e&callback )" 4
.IX Item "$cookie_jar->scan( &callback )"
The argument is a subroutine that will be invoked for each cookie
stored in the \f(CW$cookie_jar\fR.  The subroutine will be invoked with
the following arguments:
.Sp
.Vb 11
\&  0  version
\&  1  key
\&  2  val
\&  3  path
\&  4  domain
\&  5  port
\&  6  path_spec
\&  7  secure
\&  8  expires
\&  9  discard
\& 10  hash
.Ve
.ie n .IP "$cookie_jar\->as_string" 4
.el .IP "\f(CW$cookie_jar\fR\->as_string" 4
.IX Item "$cookie_jar->as_string"
.PD 0
.ie n .IP "$cookie_jar\->as_string( $skip_discardables )" 4
.el .IP "\f(CW$cookie_jar\fR\->as_string( \f(CW$skip_discardables\fR )" 4
.IX Item "$cookie_jar->as_string( $skip_discardables )"
.PD
The \fIas_string()\fR method will return the state of the \f(CW$cookie_jar\fR
represented as a sequence of \*(L"Set\-Cookie3\*(R" header lines separated by
\&\*(L"\en\*(R".  If \f(CW$skip_discardables\fR is \s-1TRUE,\s0 it will not return lines for
cookies with the \fIDiscard\fR attribute.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
HTTP::Cookies::Netscape, HTTP::Cookies::Microsoft
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright 1997\-2002 Gisle Aas
.PP
This library is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.
