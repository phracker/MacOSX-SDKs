.\" Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "DBIx::Class::Manual::Intro 3"
.TH DBIx::Class::Manual::Intro 3 "2017-12-08" "perl v5.30.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
DBIx::Class::Manual::Intro \- Introduction to DBIx::Class
.SH "INTRODUCTION"
.IX Header "INTRODUCTION"
You're bored with \s-1SQL,\s0 and want a native Perl interface for your database?  Or
you've been doing this for a while with Class::DBI, and think there's a
better way?  You've come to the right place.
.SH "THE DBIx::Class WAY"
.IX Header "THE DBIx::Class WAY"
Here are a few simple tips that will help you get your bearings with
DBIx::Class.
.SS "Tables become Result classes"
.IX Subsection "Tables become Result classes"
DBIx::Class needs to know what your Table structure looks like.  You
do that by defining Result classes. Result classes are defined by
calling methods proxied to DBIx::Class::ResultSource.  Each Result
class defines one Table, which defines the Columns it has, along with
any Relationships it has to other tables.  (And oh, so much more
besides) The important thing to understand:
.PP
.Vb 1
\&  A Result class == Table
.Ve
.PP
(most of the time, but just bear with my simplification)
.SS "It's all about the ResultSet"
.IX Subsection "It's all about the ResultSet"
So, we've got some ResultSources defined.  Now, we want to actually use those
definitions to help us translate the queries we need into handy perl objects!
.PP
Let's say we defined a ResultSource for an \*(L"album\*(R" table with three columns:
\&\*(L"albumid\*(R", \*(L"artist\*(R", and \*(L"title\*(R".  Any time we want to query this table, we'll
be creating a DBIx::Class::ResultSet from its ResultSource.  For example, the
results of:
.PP
.Vb 1
\&  SELECT albumid, artist, title FROM album;
.Ve
.PP
Would be retrieved by creating a ResultSet object from the album table's
ResultSource, likely by using the \*(L"search\*(R" method.
.PP
DBIx::Class doesn't limit you to creating only simple ResultSets \*(-- if you
wanted to do something like:
.PP
.Vb 1
\&  SELECT title FROM album GROUP BY title;
.Ve
.PP
You could easily achieve it.
.PP
The important thing to understand:
.PP
.Vb 2
\&  Any time you would reach for a SQL query in DBI, you are
\&  creating a DBIx::Class::ResultSet.
.Ve
.ie n .SS "Search is like ""prepare"""
.el .SS "Search is like ``prepare''"
.IX Subsection "Search is like prepare"
DBIx::Class tends to wait until it absolutely must fetch information from the
database.  If you are returning a ResultSet, the query won't execute until you
use a method that wants to access the data. (Such as \*(L"next\*(R", or \*(L"first\*(R")
.PP
The important thing to understand:
.PP
.Vb 2
\&  Setting up a ResultSet does not execute the query; retrieving
\&  the data does.
.Ve
.SS "Search results are returned as Rows"
.IX Subsection "Search results are returned as Rows"
Rows of the search from the database are blessed into
Result objects.
.SH "SETTING UP DBIx::Class"
.IX Header "SETTING UP DBIx::Class"
Let's look at how you can set and use your first native DBIx::Class tree.
.PP
First we'll see how you can set up your classes yourself.  If you want them to
be auto-discovered, just skip to the next section, which shows you how to use
DBIx::Class::Schema::Loader.
.SS "Setting it up manually"
.IX Subsection "Setting it up manually"
First, you should create your base schema class, which inherits from
DBIx::Class::Schema:
.PP
.Vb 2
\&  package My::Schema;
\&  use base qw/DBIx::Class::Schema/;
.Ve
.PP
In this class you load your result_source (\*(L"table\*(R", \*(L"model\*(R") classes, which we
will define later, using the \fBload_namespaces()\fR method:
.PP
.Vb 2
\&  # load My::Schema::Result::* and their resultset classes
\&  _\|_PACKAGE_\|_\->load_namespaces();
.Ve
.PP
By default this loads all the Result (Row) classes in the
My::Schema::Result:: namespace, and also any resultset classes in the
My::Schema::ResultSet:: namespace (if missing, the resultsets are
defaulted to be DBIx::Class::ResultSet objects). You can change the
result and resultset namespaces by using options to the
\&\*(L"load_namespaces\*(R" in DBIx::Class::Schema call.
.PP
It is also possible to do the same things manually by calling
\&\f(CW\*(C`load_classes\*(C'\fR for the Row classes and defining in those classes any
required resultset classes.
.PP
Next, create each of the classes you want to load as specified above:
.PP
.Vb 2
\&  package My::Schema::Result::Album;
\&  use base qw/DBIx::Class::Core/;
.Ve
.PP
Load any additional components you may need with the \fBload_components()\fR method,
and provide component configuration if required. For example, if you want
automatic row ordering:
.PP
.Vb 2
\&  _\|_PACKAGE_\|_\->load_components(qw/ Ordered /);
\&  _\|_PACKAGE_\|_\->position_column(\*(Aqrank\*(Aq);
.Ve
.PP
Ordered will refer to a field called 'position' unless otherwise directed.  Here you are defining
the ordering field to be named 'rank'.  (\s-1NOTE:\s0 Insert errors may occur if you use the Ordered
component, but have not defined a position column or have a 'position' field in your row.)
.PP
Set the table for your class:
.PP
.Vb 1
\&  _\|_PACKAGE_\|_\->table(\*(Aqalbum\*(Aq);
.Ve
.PP
Add columns to your class:
.PP
.Vb 1
\&  _\|_PACKAGE_\|_\->add_columns(qw/ albumid artist title rank /);
.Ve
.PP
Each column can also be set up with its own accessor, data_type and other pieces
of information that it may be useful to have \*(-- just pass \f(CW\*(C`add_columns\*(C'\fR a hash:
.PP
.Vb 10
\&  _\|_PACKAGE_\|_\->add_columns(albumid =>
\&                            { accessor  => \*(Aqalbum\*(Aq,
\&                              data_type => \*(Aqinteger\*(Aq,
\&                              size      => 16,
\&                              is_nullable => 0,
\&                              is_auto_increment => 1,
\&                            },
\&                          artist =>
\&                            { data_type => \*(Aqinteger\*(Aq,
\&                              size      => 16,
\&                              is_nullable => 0,
\&                            },
\&                          title  =>
\&                            { data_type => \*(Aqvarchar\*(Aq,
\&                              size      => 256,
\&                              is_nullable => 0,
\&                            },
\&                          rank =>
\&                            { data_type => \*(Aqinteger\*(Aq,
\&                              size      => 16,
\&                              is_nullable => 0,
\&                              default_value => 0,
\&                            }
\&                         );
.Ve
.PP
DBIx::Class doesn't directly use most of this data yet, but various related
modules such as HTML::FormHandler::Model::DBIC make use of it.
Also it allows you to create your database tables from your Schema,
instead of the other way around.
See \*(L"deploy\*(R" in DBIx::Class::Schema for details.
.PP
See DBIx::Class::ResultSource for more details of the possible column
attributes.
.PP
Accessors are created for each column automatically, so My::Schema::Result::Album will
have \fBalbumid()\fR (or \fBalbum()\fR, when using the accessor), \fBartist()\fR and \fBtitle()\fR
methods.
.PP
Define a primary key for your class:
.PP
.Vb 1
\&  _\|_PACKAGE_\|_\->set_primary_key(\*(Aqalbumid\*(Aq);
.Ve
.PP
If you have a multi-column primary key, just pass a list instead:
.PP
.Vb 1
\&  _\|_PACKAGE_\|_\->set_primary_key( qw/ albumid artistid / );
.Ve
.PP
Define this class' relationships with other classes using either \f(CW\*(C`belongs_to\*(C'\fR
to describe a column which contains an \s-1ID\s0 of another Table, or \f(CW\*(C`has_many\*(C'\fR to
make a predefined accessor for fetching objects that contain this Table's
foreign key:
.PP
.Vb 2
\&  # in My::Schema::Result::Artist
\&  _\|_PACKAGE_\|_\->has_many(\*(Aqalbums\*(Aq, \*(AqMy::Schema::Result::Album\*(Aq, \*(Aqartist\*(Aq);
.Ve
.PP
See DBIx::Class::Relationship for more information about the various types of
available relationships and how you can design your own.
.SS "Using DBIx::Class::Schema::Loader"
.IX Subsection "Using DBIx::Class::Schema::Loader"
This module (DBIx::Class::Schema::Loader) is an external module, and not part
of the DBIx::Class distribution. It inspects your database, and automatically
creates classes for all the tables in your schema.
.PP
The simplest way to use it is via the dbicdump script from the
DBIx::Class::Schema::Loader distribution. For example:
.PP
.Vb 3
\&    $ dbicdump \-o dump_directory=./lib \e
\&        \-o components=\*(Aq["InflateColumn::DateTime"]\*(Aq \e
\&        MyApp::Schema dbi:mysql:mydb user pass
.Ve
.PP
If you have a mixed-case database, use the \f(CW\*(C`preserve_case\*(C'\fR option, e.g.:
.PP
.Vb 3
\&    $ dbicdump \-o dump_directory=./lib \-o preserve_case=1 \e
\&        \-o components=\*(Aq["InflateColumn::DateTime"]\*(Aq \e
\&        MyApp::Schema dbi:mysql:mydb user pass
.Ve
.PP
If you are using Catalyst, then you can use the helper that comes with
Catalyst::Model::DBIC::Schema:
.PP
.Vb 3
\&    $ script/myapp_create.pl model MyModel DBIC::Schema MyApp::Schema \e
\&        create=static moniker_map=\*(Aq{ foo => "FOO" }\*(Aq dbi:SQLite:./myapp.db \e
\&        on_connect_do=\*(AqPRAGMA foreign_keys=ON\*(Aq quote_char=\*(Aq"\*(Aq
.Ve
.PP
See Catalyst::Helper::Model::DBIC::Schema for more information on this
helper.
.PP
See the DBIx::Class::Schema::Loader and DBIx::Class::Schema::Loader::Base
documentation for more information on the many loader options.
.SS "Connecting"
.IX Subsection "Connecting"
To connect to your Schema, you need to provide the connection details or a
database handle.
.PP
\fIVia connection details\fR
.IX Subsection "Via connection details"
.PP
The arguments are the same as for \*(L"connect\*(R" in \s-1DBI\s0:
.PP
.Vb 1
\&  my $schema = My::Schema\->connect(\*(Aqdbi:SQLite:/home/me/myapp/my.db\*(Aq);
.Ve
.PP
You can create as many different schema instances as you need. So if you have a
second database you want to access:
.PP
.Vb 1
\&  my $other_schema = My::Schema\->connect( $dsn, $user, $password, $attrs );
.Ve
.PP
Note that DBIx::Class::Schema does not cache connections for you. If you use
multiple connections, you need to do this manually.
.PP
To execute some \s-1SQL\s0 statements on every connect you can add them as an option in
a special fifth argument to connect:
.PP
.Vb 7
\&  my $another_schema = My::Schema\->connect(
\&      $dsn,
\&      $user,
\&      $password,
\&      $attrs,
\&      { on_connect_do => \e@on_connect_sql_statments }
\&  );
.Ve
.PP
See \*(L"connect_info\*(R" in DBIx::Class::Storage::DBI for more information about
this and other special \f(CW\*(C`connect\*(C'\fR\-time options.
.PP
\fIVia a database handle\fR
.IX Subsection "Via a database handle"
.PP
The supplied coderef is expected to return a single connected database handle
(e.g. a \s-1DBI\s0 \f(CW$dbh\fR)
.PP
.Vb 4
\&  my $schema = My::Schema\->connect (
\&    sub { Some::DBH::Factory\->connect },
\&    \e%extra_attrs,
\&  );
.Ve
.SS "Basic usage"
.IX Subsection "Basic usage"
Once you've defined the basic classes, either manually or using
DBIx::Class::Schema::Loader, you can start interacting with your database.
.PP
To access your database using your \f(CW$schema\fR object, you can fetch a
\&\*(L"ResultSet\*(R" in DBIx::Class::Manual::Glossary representing each of your tables by
calling the \f(CW\*(C`resultset\*(C'\fR method.
.PP
The simplest way to get a record is by primary key:
.PP
.Vb 1
\&  my $album = $schema\->resultset(\*(AqAlbum\*(Aq)\->find(14);
.Ve
.PP
This will run a \f(CW\*(C`SELECT\*(C'\fR with \f(CW\*(C`albumid = 14\*(C'\fR in the \f(CW\*(C`WHERE\*(C'\fR clause, and
return an instance of \f(CW\*(C`My::Schema::Result::Album\*(C'\fR that represents this row.  Once you
have that row, you can access and update columns:
.PP
.Vb 2
\&  $album\->title(\*(AqPhysical Graffiti\*(Aq);
\&  my $title = $album\->title; # $title holds \*(AqPhysical Graffiti\*(Aq
.Ve
.PP
If you prefer, you can use the \f(CW\*(C`set_column\*(C'\fR and \f(CW\*(C`get_column\*(C'\fR accessors
instead:
.PP
.Vb 2
\&  $album\->set_column(\*(Aqtitle\*(Aq, \*(AqPresence\*(Aq);
\&  $title = $album\->get_column(\*(Aqtitle\*(Aq);
.Ve
.PP
Just like with Class::DBI, you call \f(CW\*(C`update\*(C'\fR to save your changes to the
database (by executing the actual \f(CW\*(C`UPDATE\*(C'\fR statement):
.PP
.Vb 1
\&  $album\->update;
.Ve
.PP
If needed, you can throw away your local changes:
.PP
.Vb 1
\&  $album\->discard_changes if $album\->is_changed;
.Ve
.PP
As you can see, \f(CW\*(C`is_changed\*(C'\fR allows you to check if there are local changes to
your object.
.SS "Adding and removing rows"
.IX Subsection "Adding and removing rows"
To create a new record in the database, you can use the \f(CW\*(C`create\*(C'\fR method.  It
returns an instance of \f(CW\*(C`My::Schema::Result::Album\*(C'\fR that can be used to access the data
in the new record:
.PP
.Vb 4
\&  my $new_album = $schema\->resultset(\*(AqAlbum\*(Aq)\->create({
\&    title  => \*(AqWish You Were Here\*(Aq,
\&    artist => \*(AqPink Floyd\*(Aq
\&  });
.Ve
.PP
Now you can add data to the new record:
.PP
.Vb 3
\&  $new_album\->label(\*(AqCapitol\*(Aq);
\&  $new_album\->year(\*(Aq1975\*(Aq);
\&  $new_album\->update;
.Ve
.PP
Likewise, you can remove it from the database:
.PP
.Vb 1
\&  $new_album\->delete;
.Ve
.PP
You can also remove records without retrieving them first, by calling delete
directly on a ResultSet object.
.PP
.Vb 2
\&  # Delete all of Falco\*(Aqs albums
\&  $schema\->resultset(\*(AqAlbum\*(Aq)\->search({ artist => \*(AqFalco\*(Aq })\->delete;
.Ve
.SS "Finding your objects"
.IX Subsection "Finding your objects"
DBIx::Class provides a few different ways to retrieve data from your
database.  Here's one example:
.PP
.Vb 2
\&  # Find all of Santana\*(Aqs albums
\&  my $rs = $schema\->resultset(\*(AqAlbum\*(Aq)\->search({ artist => \*(AqSantana\*(Aq });
.Ve
.PP
In scalar context, as above, \f(CW\*(C`search\*(C'\fR returns a DBIx::Class::ResultSet
object.  It can be used to peek at the first album returned by the database:
.PP
.Vb 2
\&  my $album = $rs\->first;
\&  print $album\->title;
.Ve
.PP
You can loop over the albums and update each one:
.PP
.Vb 5
\&  while (my $album = $rs\->next) {
\&    print $album\->artist . \*(Aq \- \*(Aq . $album\->title;
\&    $album\->year(2001);
\&    $album\->update;
\&  }
.Ve
.PP
Or, you can update them all at once:
.PP
.Vb 1
\&  $rs\->update({ year => 2001 });
.Ve
.PP
In list context, the \f(CW\*(C`search\*(C'\fR method returns all of the matching rows:
.PP
.Vb 7
\&  # Fetch immediately all of Carlos Santana\*(Aqs albums
\&  my @albums = $schema\->resultset(\*(AqAlbum\*(Aq)\->search(
\&    { artist => \*(AqCarlos Santana\*(Aq }
\&  );
\&  foreach my $album (@albums) {
\&    print $album\->artist . \*(Aq \- \*(Aq . $album\->title;
\&  }
.Ve
.PP
We also provide a handy shortcut for doing a \f(CW\*(C`LIKE\*(C'\fR search:
.PP
.Vb 2
\&  # Find albums whose artist starts with \*(AqJimi\*(Aq
\&  my $rs = $schema\->resultset(\*(AqAlbum\*(Aq)\->search_like({ artist => \*(AqJimi%\*(Aq });
.Ve
.PP
Or you can provide your own \f(CW\*(C`WHERE\*(C'\fR clause:
.PP
.Vb 4
\&  # Find Peter Frampton albums from the year 1986
\&  my $where = \*(Aqartist = ? AND year = ?\*(Aq;
\&  my @bind  = ( \*(AqPeter Frampton\*(Aq, 1986 );
\&  my $rs    = $schema\->resultset(\*(AqAlbum\*(Aq)\->search_literal( $where, @bind );
.Ve
.PP
The preferred way to generate complex queries is to provide a SQL::Abstract
construct to \f(CW\*(C`search\*(C'\fR:
.PP
.Vb 5
\&  my $rs = $schema\->resultset(\*(AqAlbum\*(Aq)\->search({
\&    artist  => { \*(Aq!=\*(Aq, \*(AqJanis Joplin\*(Aq },
\&    year    => { \*(Aq<\*(Aq => 1980 },
\&    albumid => { \*(Aq\-in\*(Aq => [ 1, 14, 15, 65, 43 ] }
\&  });
.Ve
.PP
This results in something like the following \f(CW\*(C`WHERE\*(C'\fR clause:
.PP
.Vb 3
\&  WHERE artist != \*(AqJanis Joplin\*(Aq
\&    AND year < 1980
\&    AND albumid IN (1, 14, 15, 65, 43)
.Ve
.PP
For more examples of complex queries, see DBIx::Class::Manual::Cookbook.
.PP
The search can also be modified by passing another hash with
attributes:
.PP
.Vb 4
\&  my @albums = My::Schema\->resultset(\*(AqAlbum\*(Aq)\->search(
\&    { artist => \*(AqBob Marley\*(Aq },
\&    { rows => 2, order_by => { \-desc => \*(Aqyear\*(Aq } }
\&  );
.Ve
.PP
\&\f(CW@albums\fR then holds the two most recent Bob Marley albums.
.PP
For more information on what you can do with a DBIx::Class::ResultSet, see
\&\*(L"\s-1METHODS\*(R"\s0 in DBIx::Class::ResultSet.
.PP
For a complete overview of the available attributes, see
\&\*(L"\s-1ATTRIBUTES\*(R"\s0 in DBIx::Class::ResultSet.
.SH "NOTES"
.IX Header "NOTES"
.SS "The Significance and Importance of Primary Keys"
.IX Subsection "The Significance and Importance of Primary Keys"
The concept of a primary key in
DBIx::Class warrants special discussion. The formal definition (which somewhat
resembles that of a classic \s-1RDBMS\s0) is \fIa unique constraint that is least
likely to change after initial row creation\fR. However this is where the
similarity ends. Any time you call a \s-1CRUD\s0 operation on a row (e.g.
delete,
update,
discard_changes,
etc.) DBIx::Class will use the values of the
primary key columns to populate
the \f(CW\*(C`WHERE\*(C'\fR clause necessary to accomplish the operation. This is why it is
important to declare a primary key
on all your result sources \fBeven if the underlying \s-1RDBMS\s0 does not have one\fR.
In a pinch one can always declare each row identifiable by all its columns:
.PP
.Vb 1
\& _\|_PACKAGE_\|_\->set_primary_key(_\|_PACKAGE_\|_\->columns);
.Ve
.PP
Note that DBIx::Class is smart enough to store a copy of the \s-1PK\s0 values before
any row-object changes take place, so even if you change the values of \s-1PK\s0
columns the \f(CW\*(C`WHERE\*(C'\fR clause will remain correct.
.PP
If you elect not to declare a \f(CW\*(C`primary key\*(C'\fR, DBIx::Class will behave correctly
by throwing exceptions on any row operation that relies on unique identifiable
rows. If you inherited datasets with multiple identical rows in them, you can
still operate with such sets provided you only utilize
DBIx::Class::ResultSet \s-1CRUD\s0 methods:
search,
update,
delete
.PP
For example, the following would not work (assuming \f(CW\*(C`People\*(C'\fR does not have
a declared \s-1PK\s0):
.PP
.Vb 5
\& my $result = $schema\->resultset(\*(AqPeople\*(Aq)
\&                   \->search({ last_name => \*(AqDantes\*(Aq })
\&                    \->next;
\& $result\->update({ children => 2 }); # <\-\- exception thrown because $result isn\*(Aqt
\&                                  # necessarily unique
.Ve
.PP
So instead the following should be done:
.PP
.Vb 3
\& $schema\->resultset(\*(AqPeople\*(Aq)
\&         \->search({ last_name => \*(AqDantes\*(Aq })
\&          \->update({ children => 2 }); # <\-\- update\*(Aqs ALL Dantes to have children of 2
.Ve
.SS "Problems on RHEL5/CentOS5"
.IX Subsection "Problems on RHEL5/CentOS5"
There used to be an issue with the system perl on Red Hat Enterprise
Linux 5, some versions of Fedora and derived systems. Further
information on this can be found in DBIx::Class::Manual::Troubleshooting
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.IP "\(bu" 4
DBIx::Class::Manual::Cookbook
.SH "FURTHER QUESTIONS?"
.IX Header "FURTHER QUESTIONS?"
Check the list of additional \s-1DBIC\s0 resources.
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This module is free software copyright
by the DBIx::Class (\s-1DBIC\s0) authors. You can
redistribute it and/or modify it under the same terms as the
DBIx::Class library.
