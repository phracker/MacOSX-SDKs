.\" Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Test2::Tools::ClassicCompare 3"
.TH Test2::Tools::ClassicCompare 3 "2020-10-22" "perl v5.30.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Test2::Tools::ClassicCompare \- Classic (Test::More style) comparison tools.
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This provides comparison functions that behave like they did in Test::More,
unlike the Test2::Tools::Compare plugin which has modified them.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use Test2::Tools::ClassicCompare qw/is is_deeply isnt like unlike cmp_ok/;
\&
\&    is($got, $expect, "These are the same when stringified");
\&    isnt($got, $unexpect, "These are not the same when stringified");
\&
\&    like($got, qr/.../, "\*(Aqgot\*(Aq matches the pattern");
\&    unlike($got, qr/.../, "\*(Aqgot\*(Aq does not match the pattern");
\&
\&    is_deeply($got, $expect, "These structures are same when checked deeply");
\&
\&    cmp_ok($GOT, $OP, $WANT, \*(AqCompare these items using the specified operatr\*(Aq);
.Ve
.SH "EXPORTS"
.IX Header "EXPORTS"
.ie n .IP "$bool = is($got, $expect)" 4
.el .IP "\f(CW$bool\fR = is($got, \f(CW$expect\fR)" 4
.IX Item "$bool = is($got, $expect)"
.PD 0
.ie n .IP "$bool = is($got, $expect, $name)" 4
.el .IP "\f(CW$bool\fR = is($got, \f(CW$expect\fR, \f(CW$name\fR)" 4
.IX Item "$bool = is($got, $expect, $name)"
.ie n .IP "$bool = is($got, $expect, $name, @diag)" 4
.el .IP "\f(CW$bool\fR = is($got, \f(CW$expect\fR, \f(CW$name\fR, \f(CW@diag\fR)" 4
.IX Item "$bool = is($got, $expect, $name, @diag)"
.PD
This does a string comparison of the two arguments. If the two arguments are the
same after stringification the test passes. The test will also pass if both
arguments are undef.
.Sp
The test \f(CW$name\fR is optional.
.Sp
The test \f(CW@diag\fR is optional, it is extra diagnostics messages that will be
displayed if the test fails. The diagnostics are ignored if the test passes.
.Sp
It is important to note that this tool considers \f(CW"1"\fR and \f(CW"1.0"\fR to not be
equal as it uses a string comparison.
.Sp
See Test2::Tools::Compare if you want an \f(CW\*(C`is()\*(C'\fR function that tries
to be smarter for you.
.ie n .IP "$bool = isnt($got, $dont_expect)" 4
.el .IP "\f(CW$bool\fR = isnt($got, \f(CW$dont_expect\fR)" 4
.IX Item "$bool = isnt($got, $dont_expect)"
.PD 0
.ie n .IP "$bool = isnt($got, $dont_expect, $name)" 4
.el .IP "\f(CW$bool\fR = isnt($got, \f(CW$dont_expect\fR, \f(CW$name\fR)" 4
.IX Item "$bool = isnt($got, $dont_expect, $name)"
.ie n .IP "$bool = isnt($got, $dont_expect, $name, @diag)" 4
.el .IP "\f(CW$bool\fR = isnt($got, \f(CW$dont_expect\fR, \f(CW$name\fR, \f(CW@diag\fR)" 4
.IX Item "$bool = isnt($got, $dont_expect, $name, @diag)"
.PD
This is the inverse of \f(CW\*(C`is()\*(C'\fR, it passes when the strings are not the same.
.ie n .IP "$bool = like($got, $pattern)" 4
.el .IP "\f(CW$bool\fR = like($got, \f(CW$pattern\fR)" 4
.IX Item "$bool = like($got, $pattern)"
.PD 0
.ie n .IP "$bool = like($got, $pattern, $name)" 4
.el .IP "\f(CW$bool\fR = like($got, \f(CW$pattern\fR, \f(CW$name\fR)" 4
.IX Item "$bool = like($got, $pattern, $name)"
.ie n .IP "$bool = like($got, $pattern, $name, @diag)" 4
.el .IP "\f(CW$bool\fR = like($got, \f(CW$pattern\fR, \f(CW$name\fR, \f(CW@diag\fR)" 4
.IX Item "$bool = like($got, $pattern, $name, @diag)"
.PD
Check if \f(CW$got\fR matches the specified pattern. Will fail if it does not match.
.Sp
The test \f(CW$name\fR is optional.
.Sp
The test \f(CW@diag\fR is optional. It contains extra diagnostics messages that will
be displayed if the test fails. The diagnostics are ignored if the test passes.
.ie n .IP "$bool = unlike($got, $pattern)" 4
.el .IP "\f(CW$bool\fR = unlike($got, \f(CW$pattern\fR)" 4
.IX Item "$bool = unlike($got, $pattern)"
.PD 0
.ie n .IP "$bool = unlike($got, $pattern, $name)" 4
.el .IP "\f(CW$bool\fR = unlike($got, \f(CW$pattern\fR, \f(CW$name\fR)" 4
.IX Item "$bool = unlike($got, $pattern, $name)"
.ie n .IP "$bool = unlike($got, $pattern, $name, @diag)" 4
.el .IP "\f(CW$bool\fR = unlike($got, \f(CW$pattern\fR, \f(CW$name\fR, \f(CW@diag\fR)" 4
.IX Item "$bool = unlike($got, $pattern, $name, @diag)"
.PD
This is the inverse of \f(CW\*(C`like()\*(C'\fR. This will fail if \f(CW$got\fR matches
\&\f(CW$pattern\fR.
.ie n .IP "$bool = is_deeply($got, $expect)" 4
.el .IP "\f(CW$bool\fR = is_deeply($got, \f(CW$expect\fR)" 4
.IX Item "$bool = is_deeply($got, $expect)"
.PD 0
.ie n .IP "$bool = is_deeply($got, $expect, $name)" 4
.el .IP "\f(CW$bool\fR = is_deeply($got, \f(CW$expect\fR, \f(CW$name\fR)" 4
.IX Item "$bool = is_deeply($got, $expect, $name)"
.ie n .IP "$bool = is_deeply($got, $expect, $name, @diag)" 4
.el .IP "\f(CW$bool\fR = is_deeply($got, \f(CW$expect\fR, \f(CW$name\fR, \f(CW@diag\fR)" 4
.IX Item "$bool = is_deeply($got, $expect, $name, @diag)"
.PD
This does a deep check, comparing the structures in \f(CW$got\fR with those in
\&\f(CW$expect\fR. It will recurse into hashrefs, arrayrefs, and scalar refs. All
other values will be stringified and compared as strings. It is important to
note that this tool considers \f(CW"1"\fR and \f(CW"1.0"\fR to not be equal as it uses a
string comparison.
.Sp
This is the same as \f(CW\*(C`Test2::Tools::Compare::is()\*(C'\fR.
.ie n .IP "cmp_ok($got, $op, $expect)" 4
.el .IP "cmp_ok($got, \f(CW$op\fR, \f(CW$expect\fR)" 4
.IX Item "cmp_ok($got, $op, $expect)"
.PD 0
.ie n .IP "cmp_ok($got, $op, $expect, $name)" 4
.el .IP "cmp_ok($got, \f(CW$op\fR, \f(CW$expect\fR, \f(CW$name\fR)" 4
.IX Item "cmp_ok($got, $op, $expect, $name)"
.ie n .IP "cmp_ok($got, $op, $expect, $name, @diag)" 4
.el .IP "cmp_ok($got, \f(CW$op\fR, \f(CW$expect\fR, \f(CW$name\fR, \f(CW@diag\fR)" 4
.IX Item "cmp_ok($got, $op, $expect, $name, @diag)"
.PD
Compare \f(CW$got\fR to \f(CW$expect\fR using the operator specified in \f(CW$op\fR. This is
effectively an \f(CW\*(C`eval "\e$got $op \e$expect"\*(C'\fR with some other stuff to make it
more sane. This is useful for comparing numbers, overloaded objects, etc.
.Sp
\&\fBOverloading Note:\fR Your input is passed as-is to the comparison.
If the comparison fails between two overloaded objects, the diagnostics will
try to show you the overload form that was used in comparisons. It is possible
that the diagnostics will be wrong, though attempts have been made to improve
them since Test::More.
.Sp
\&\fBExceptions:\fR If the comparison results in an exception then the test will
fail and the exception will be shown.
.Sp
\&\f(CW\*(C`cmp_ok()\*(C'\fR has an internal list of operators it supports. If you provide an
unsupported operator it will issue a warning. You can add operators to the
\&\f(CW%Test2::Tools::ClassicCompare::OPS\fR hash, the key should be the operator, and
the value should either be 'str' for string comparison operators, 'num' for
numeric operators, or any other true value for other operators.
.Sp
Supported operators:
.RS 4
.IP "==  (num)" 4
.IX Item "== (num)"
.PD 0
.IP "!=  (num)" 4
.IX Item "!= (num)"
.IP ">=  (num)" 4
.IX Item ">= (num)"
.IP "<=  (num)" 4
.IX Item "<= (num)"
.IP ">   (num)" 4
.IX Item "> (num)"
.IP "<   (num)" 4
.IX Item "< (num)"
.IP "<=> (num)" 4
.IX Item "<=> (num)"
.IP "eq  (str)" 4
.IX Item "eq (str)"
.IP "ne  (str)" 4
.IX Item "ne (str)"
.IP "gt  (str)" 4
.IX Item "gt (str)"
.IP "lt  (str)" 4
.IX Item "lt (str)"
.IP "ge  (str)" 4
.IX Item "ge (str)"
.IP "le  (str)" 4
.IX Item "le (str)"
.IP "cmp (str)" 4
.IX Item "cmp (str)"
.IP "!~  (str)" 4
.IX Item "!~ (str)"
.IP "=~  (str)" 4
.IX Item "=~ (str)"
.IP "&&" 4
.IP "||" 4
.IP "xor" 4
.IX Item "xor"
.IP "or" 4
.IX Item "or"
.IP "and" 4
.IX Item "and"
.IP "//" 4
.IP "&" 4
.IP "|" 4
.IP "~~" 4
.RE
.RS 4
.RE
.PD
.SH "SOURCE"
.IX Header "SOURCE"
The source code repository for Test2\-Suite can be found at
\&\fIhttps://github.com/Test\-More/Test2\-Suite/\fR.
.SH "MAINTAINERS"
.IX Header "MAINTAINERS"
.IP "Chad Granum <exodist@cpan.org>" 4
.IX Item "Chad Granum <exodist@cpan.org>"
.SH "AUTHORS"
.IX Header "AUTHORS"
.PD 0
.IP "Chad Granum <exodist@cpan.org>" 4
.IX Item "Chad Granum <exodist@cpan.org>"
.PD
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright 2018 Chad Granum <exodist@cpan.org>.
.PP
This program is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.
.PP
See \fIhttp://dev.perl.org/licenses/\fR
