.\" Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "SQL::Abstract::Test 3"
.TH SQL::Abstract::Test 3 "2018-06-11" "perl v5.30.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
SQL::Abstract::Test \- Helper function for testing SQL::Abstract
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 6
\&  use SQL::Abstract;
\&  use Test::More;
\&  use SQL::Abstract::Test import => [qw/
\&    is_same_sql_bind is_same_sql is_same_bind
\&    eq_sql_bind eq_sql eq_bind
\&  /];
\&
\&  my ($sql, @bind) = SQL::Abstract\->new\->select(%args);
\&
\&  is_same_sql_bind($given_sql,    \e@given_bind,
\&                   $expected_sql, \e@expected_bind, $test_msg);
\&
\&  is_same_sql($given_sql, $expected_sql, $test_msg);
\&  is_same_bind(\e@given_bind, \e@expected_bind, $test_msg);
\&
\&  my $is_same = eq_sql_bind($given_sql,    \e@given_bind,
\&                            $expected_sql, \e@expected_bind);
\&
\&  my $sql_same = eq_sql($given_sql, $expected_sql);
\&  my $bind_same = eq_bind(\e@given_bind, \e@expected_bind);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module is only intended for authors of tests on
SQL::Abstract and related modules;
it exports functions for comparing two \s-1SQL\s0 statements
and their bound values.
.PP
The \s-1SQL\s0 comparison is performed on \fIabstract syntax\fR,
ignoring differences in spaces or in levels of parentheses.
Therefore the tests will pass as long as the semantics
is preserved, even if the surface syntax has changed.
.PP
\&\fBDisclaimer\fR : the semantic equivalence handling is pretty limited.
A lot of effort goes into distinguishing significant from
non-significant parenthesis, including \s-1AND/OR\s0 operator associativity.
Currently this module does not support commutativity and more
intelligent transformations like De Morgan's laws
 <http://en.wikipedia.org/wiki/De_Morgan's_laws>, etc.
.PP
For a good overview of what this test framework is currently capable of refer
to \f(CW\*(C`t/10test.t\*(C'\fR
.SH "FUNCTIONS"
.IX Header "FUNCTIONS"
.SS "is_same_sql_bind"
.IX Subsection "is_same_sql_bind"
.Vb 5
\&  is_same_sql_bind(
\&    $given_sql, \e@given_bind,
\&    $expected_sql, \e@expected_bind,
\&    $test_msg
\&  );
\&
\&  is_same_sql_bind(
\&    \e[$given_sql, @given_bind],
\&    \e[$expected_sql, @expected_bind],
\&    $test_msg
\&  );
\&
\&  is_same_sql_bind(
\&    $dbic_rs\->as_query
\&    $expected_sql, \e@expected_bind,
\&    $test_msg
\&  );
.Ve
.PP
Compares given and expected pairs of \f(CW\*(C`($sql, \e@bind)\*(C'\fR by unpacking \f(CW@_\fR
as shown in the examples above and passing the arguments to \*(L"eq_sql\*(R" and
\&\*(L"eq_bind\*(R". Calls \*(L"ok\*(R" in Test::Builder with the combined result, with
\&\f(CW$test_msg\fR as message.
If the test fails, a detailed diagnostic is printed.
.SS "is_same_sql"
.IX Subsection "is_same_sql"
.Vb 5
\&  is_same_sql(
\&    $given_sql,
\&    $expected_sql,
\&    $test_msg
\&  );
.Ve
.PP
Compares given and expected \s-1SQL\s0 statements via \*(L"eq_sql\*(R", and calls
\&\*(L"ok\*(R" in Test::Builder on the result, with \f(CW$test_msg\fR as message.
If the test fails, a detailed diagnostic is printed.
.SS "is_same_bind"
.IX Subsection "is_same_bind"
.Vb 5
\&  is_same_bind(
\&    \e@given_bind,
\&    \e@expected_bind,
\&    $test_msg
\&  );
.Ve
.PP
Compares given and expected bind values via \*(L"eq_bind\*(R", and calls
\&\*(L"ok\*(R" in Test::Builder on the result, with \f(CW$test_msg\fR as message.
If the test fails, a detailed diagnostic is printed.
.SS "eq_sql_bind"
.IX Subsection "eq_sql_bind"
.Vb 4
\&  my $is_same = eq_sql_bind(
\&    $given_sql, \e@given_bind,
\&    $expected_sql, \e@expected_bind,
\&  );
\&
\&  my $is_same = eq_sql_bind(
\&    \e[$given_sql, @given_bind],
\&    \e[$expected_sql, @expected_bind],
\&  );
\&
\&  my $is_same = eq_sql_bind(
\&    $dbic_rs\->as_query
\&    $expected_sql, \e@expected_bind,
\&  );
.Ve
.PP
Unpacks \f(CW@_\fR depending on the given arguments and calls \*(L"eq_sql\*(R" and
\&\*(L"eq_bind\*(R", returning their combined result.
.SS "eq_sql"
.IX Subsection "eq_sql"
.Vb 1
\&  my $is_same = eq_sql($given_sql, $expected_sql);
.Ve
.PP
Compares the abstract syntax of two \s-1SQL\s0 statements. Similar to \*(L"is_same_sql\*(R",
but it just returns a boolean value and does not print diagnostics or talk to
Test::Builder. If the result is false, the global variable \*(L"$sql_differ\*(R"
will contain the \s-1SQL\s0 portion where a difference was encountered; this is useful
for printing diagnostics.
.SS "eq_bind"
.IX Subsection "eq_bind"
.Vb 1
\&  my $is_same = eq_sql(\e@given_bind, \e@expected_bind);
.Ve
.PP
Compares two lists of bind values, taking into account the fact that some of
the values may be arrayrefs (see \*(L"bindtype\*(R" in SQL::Abstract). Similar to
\&\*(L"is_same_bind\*(R", but it just returns a boolean value and does not print
diagnostics or talk to Test::Builder.
.SH "GLOBAL VARIABLES"
.IX Header "GLOBAL VARIABLES"
.ie n .SS "$case_sensitive"
.el .SS "\f(CW$case_sensitive\fP"
.IX Subsection "$case_sensitive"
If true, \s-1SQL\s0 comparisons will be case-sensitive. Default is false;
.ie n .SS "$parenthesis_significant"
.el .SS "\f(CW$parenthesis_significant\fP"
.IX Subsection "$parenthesis_significant"
If true, \s-1SQL\s0 comparison will preserve and report difference in nested
parenthesis. Useful while testing \f(CW\*(C`IN (( x ))\*(C'\fR vs \f(CW\*(C`IN ( x )\*(C'\fR.
Defaults to false;
.ie n .SS "$order_by_asc_significant"
.el .SS "\f(CW$order_by_asc_significant\fP"
.IX Subsection "$order_by_asc_significant"
If true \s-1SQL\s0 comparison will consider \f(CW\*(C`ORDER BY foo ASC\*(C'\fR and
\&\f(CW\*(C`ORDER BY foo\*(C'\fR to be different. Default is false;
.ie n .SS "$sql_differ"
.el .SS "\f(CW$sql_differ\fP"
.IX Subsection "$sql_differ"
When \*(L"eq_sql\*(R" returns false, the global variable
\&\f(CW$sql_differ\fR contains the \s-1SQL\s0 portion
where a difference was encountered.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
SQL::Abstract, Test::More, Test::Builder.
.SH "AUTHORS"
.IX Header "AUTHORS"
Laurent Dami <laurent.dami \s-1AT\s0 etat  geneve  ch>
.PP
Norbert Buchmuller <norbi@nix.hu>
.PP
Peter Rabbitson <ribasushi@cpan.org>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright 2008 by Laurent Dami.
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.
