.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "autobox 3"
.TH autobox 3 "2018-04-20" "perl v5.18.4" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
autobox \- call methods on native types
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use autobox;
\&
\&    # integers
\&
\&        my $range = 10\->to(1); # [ 10, 9, 8, 7, 6, 5, 4, 3, 2, 1 ]
\&
\&    # floats
\&
\&        my $error = 3.1415927\->minus(22/7)\->abs();
\&
\&    # strings
\&
\&        my @list = \*(AqSELECT * FROM foo\*(Aq\->list();
\&        my $greeting = "Hello, world!"\->upper(); # "HELLO, WORLD!"
\&
\&        $greeting\->for_each(\e&character_handler);
\&
\&    # arrays and array refs
\&
\&        my $schwartzian = @_\->map(...)\->sort(...)\->map(...);
\&        my $hash = [ \*(AqSELECT * FROM foo WHERE id IN (?, ?)\*(Aq, 1, 2 ]\->hash();
\&
\&    # hashes and hash refs
\&
\&        { alpha => \*(Aqbeta\*(Aq, gamma => \*(Aqvlissides\*(Aq }\->for_each(...);
\&        %hash\->keys();
\&
\&    # code refs
\&
\&        my $plus_five = (\e&add)\->curry()\->(5);
\&        my $minus_three = sub { $_[0] \- $_[1] }\->reverse\->curry\->(3);
\&
\&    # can, isa, VERSION, import and unimport can be accessed via autobox_class
\&
\&        42\->autobox_class\->isa(\*(AqMyNumber\*(Aq)
\&        say []\->autobox_class\->VERSION
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The \f(CW\*(C`autobox\*(C'\fR pragma allows methods to be called on integers, floats, strings, arrays,
hashes, and code references in exactly the same manner as blessed references.
.PP
Autoboxing is transparent: values are not blessed into their (user-defined)
implementation class (unless the method elects to bestow such a blessing) \- they simply
use its methods as though they are.
.PP
The classes (packages) into which the native types are boxed are fully configurable.
By default, a method invoked on a non-object value is assumed to be
defined in a class whose name corresponds to the \f(CW\*(C`ref()\*(C'\fR type of that
value \- or \s-1SCALAR\s0 if the value is a non-reference.
.PP
This mapping can be overridden by passing key/value pairs to the \f(CW\*(C`use autobox\*(C'\fR
statement, in which the keys represent native types, and the values
their associated classes.
.PP
As with regular objects, autoboxed values are passed as the first argument of the specified method.
Consequently, given a vanilla \f(CW\*(C`use autobox\*(C'\fR:
.PP
.Vb 1
\&    "Hello, world!"\->upper()
.Ve
.PP
is invoked as:
.PP
.Vb 1
\&    SCALAR::upper("hello, world!")
.Ve
.PP
while:
.PP
.Vb 1
\&    [ 1 .. 10 ]\->for_each(sub { ... })
.Ve
.PP
resolves to:
.PP
.Vb 1
\&    ARRAY::for_each([ 1 .. 10 ], sub { ... })
.Ve
.PP
Values beginning with the array \f(CW\*(C`@\*(C'\fR and hash \f(CW\*(C`%\*(C'\fR sigils are passed by reference, i.e. under the default bindings:
.PP
.Vb 4
\&    @array\->join(\*(Aq, \*(Aq)
\&    @{ ... }\->length()
\&    %hash\->keys()
\&    %$hash\->values()
.Ve
.PP
are equivalent to:
.PP
.Vb 4
\&    ARRAY::join(\e@array, \*(Aq, \*(Aq)
\&    ARRAY::length(\e@{ ... })
\&    HASH::keys(\e%hash)
\&    HASH::values(\e%$hash)
.Ve
.PP
Multiple \f(CW\*(C`use autobox\*(C'\fR statements can appear in the same scope. These are merged both \*(L"horizontally\*(R" (i.e.
multiple classes can be associated with a particular type) and \*(L"vertically\*(R" (i.e. multiple classes can be associated
with multiple types).
.PP
Thus:
.PP
.Vb 2
\&    use autobox SCALAR => \*(AqFoo\*(Aq;
\&    use autobox SCALAR => \*(AqBar\*(Aq;
.Ve
.PP
\&\- associates \s-1SCALAR\s0 types with a synthetic class whose \f(CW@ISA\fR includes both \f(CW\*(C`Foo\*(C'\fR and \f(CW\*(C`Bar\*(C'\fR (in that order).
.PP
Likewise:
.PP
.Vb 3
\&    use autobox SCALAR => \*(AqFoo\*(Aq;
\&    use autobox SCALAR => \*(AqBar\*(Aq;
\&    use autobox ARRAY  => \*(AqBaz\*(Aq;
.Ve
.PP
and
.PP
.Vb 2
\&    use autobox SCALAR => [ \*(AqFoo\*(Aq, \*(AqBar\*(Aq ];
\&    use autobox ARRAY  => \*(AqBaz\*(Aq;
.Ve
.PP
\&\- bind \s-1SCALAR\s0 types to the \f(CW\*(C`Foo\*(C'\fR and \f(CW\*(C`Bar\*(C'\fR classes and \s-1ARRAY\s0 types to \f(CW\*(C`Baz\*(C'\fR.
.PP
\&\f(CW\*(C`autobox\*(C'\fR is lexically scoped, and bindings for an outer scope
can be extended or countermanded in a nested scope:
.PP
.Vb 3
\&    {
\&        use autobox; # default bindings: autobox all native types
\&        ...
\&
\&        {
\&            # appends \*(AqMyScalar\*(Aq to the @ISA associated with SCALAR types
\&            use autobox SCALAR => \*(AqMyScalar\*(Aq;
\&            ...
\&        }
\&
\&        # back to the default (no MyScalar)
\&        ...
\&    }
.Ve
.PP
Autoboxing can be turned off entirely by using the \f(CW\*(C`no\*(C'\fR syntax:
.PP
.Vb 6
\&    {
\&        use autobox;
\&        ...
\&        no autobox;
\&        ...
\&    }
.Ve
.PP
\&\- or can be selectively disabled by passing arguments to the \f(CW\*(C`no autobox\*(C'\fR statement:
.PP
.Vb 1
\&    use autobox; # default bindings
\&
\&    no autobox qw(SCALAR);
\&
\&    []\->foo(); # OK: ARRAY::foo([])
\&
\&    "Hello, world!"\->bar(); # runtime error
.Ve
.PP
Autoboxing is not performed for barewords i.e.
.PP
.Vb 1
\&    my $foo = Foo\->new();
.Ve
.PP
and:
.PP
.Vb 1
\&    my $foo = new Foo;
.Ve
.PP
behave as expected.
.PP
Methods are called on native types by means of the arrow operator. As with
regular objects, the right hand side of the operator can either be a bare method name or a variable containing
a method name or subroutine reference. Thus the following are all valid:
.PP
.Vb 4
\&    sub method1 { ... }
\&    my $method2 = \*(Aqsome_method\*(Aq;
\&    my $method3 = sub { ... };
\&    my $method4 = \e&some_method;
\&
\&    " ... "\->method1();
\&    [ ... ]\->$method2();
\&    { ... }\->$method3();
\&    sub { ... }\->$method4();
.Ve
.PP
A native type is only associated with a class if the type => class mapping
is supplied in the \f(CW\*(C`use autobox\*(C'\fR statement. Thus the following will not work:
.PP
.Vb 1
\&    use autobox SCALAR => \*(AqMyScalar\*(Aq;
\&
\&    @array\->some_array_method();
.Ve
.PP
\&\- as no class is specified for the \s-1ARRAY\s0 type. Note: the result of calling a method
on a native type that is not associated with a class is the usual runtime error message:
.PP
.Vb 1
\&    Can\*(Aqt call method "some_array_method" on unblessed reference at ...
.Ve
.PP
As a convenience, there is one exception to this rule. If \f(CW\*(C`use autobox\*(C'\fR is invoked with no arguments
(ignoring the \s-1DEBUG\s0 option) the four main native types are associated with classes of the same name.
.PP
Thus:
.PP
.Vb 1
\&    use autobox;
.Ve
.PP
\&\- is equivalent to:
.PP
.Vb 6
\&    use autobox {
\&        SCALAR => \*(AqSCALAR\*(Aq,
\&        ARRAY  => \*(AqARRAY\*(Aq,
\&        HASH   => \*(AqHASH\*(Aq,
\&        CODE   => \*(AqCODE\*(Aq,
\&    }
.Ve
.PP
This facilitates one-liners and prototypes:
.PP
.Vb 1
\&    use autobox;
\&
\&    sub SCALAR::split { [ split \*(Aq\*(Aq, $_[0] ] }
\&    sub ARRAY::length { scalar @{$_[0]} }
\&
\&    print "Hello, world!"\->split\->length();
.Ve
.PP
However, using these default bindings is not recommended as there's no guarantee that another
piece of code won't trample over the same namespace/methods.
.SH "OPTIONS"
.IX Header "OPTIONS"
A mapping from native types to their user-defined classes can be specified
by passing a hashref or a list of key/value pairs to the \f(CW\*(C`use autobox\*(C'\fR statement.
.PP
The following example shows the range of valid arguments:
.PP
.Vb 10
\&    use autobox {
\&        SCALAR    => \*(AqMyScalar\*(Aq                     # class name
\&        ARRAY     => \*(AqMyNamespace::\*(Aq,               # class prefix (ending in \*(Aq::\*(Aq)
\&        HASH      => [ \*(AqMyHash\*(Aq, \*(AqMyNamespace::\*(Aq ], # one or more class names and/or prefixes
\&        CODE      => ...,                           # any of the 3 value types above
\&        INTEGER   => ...,                           # any of the 3 value types above
\&        FLOAT     => ...,                           # any of the 3 value types above
\&        NUMBER    => ...,                           # any of the 3 value types above
\&        STRING    => ...,                           # any of the 3 value types above
\&        UNDEF     => ...,                           # any of the 3 value types above
\&        UNIVERSAL => ...,                           # any of the 3 value types above
\&        DEFAULT   => ...,                           # any of the 3 value types above
\&        DEBUG     => ...                            # boolean or coderef
\&    }
.Ve
.PP
The \s-1INTEGER, FLOAT, NUMBER, STRING, SCALAR, ARRAY, HASH, CODE, UNDEF, DEFAULT\s0 and \s-1UNIVERSAL\s0 options can take
three different types of value:
.IP "\(bu" 4
A class name e.g.
.Sp
.Vb 1
\&    use autobox INTEGER => \*(AqMyInt\*(Aq;
.Ve
.Sp
This binds the specified native type to the specified class. All methods invoked on
values of type \f(CW\*(C`key\*(C'\fR will be dispatched as methods of the class specified in
the corresponding \f(CW\*(C`value\*(C'\fR.
.IP "\(bu" 4
A namespace: this is a class prefix (up to and including the final '::')
to which the specified type name (\s-1INTEGER, FLOAT, STRING\s0 &c.) will be appended:
.Sp
Thus:
.Sp
.Vb 1
\&    use autobox ARRAY => \*(AqPrelude::\*(Aq;
.Ve
.Sp
is equivalent to:
.Sp
.Vb 1
\&    use autobox ARRAY => \*(AqPrelude::ARRAY\*(Aq;
.Ve
.IP "\(bu" 4
A reference to an array of class names and/or namespaces. This associates multiple classes with the
specified type.
.SS "\s-1DEFAULT\s0"
.IX Subsection "DEFAULT"
The \f(CW\*(C`DEFAULT\*(C'\fR option specifies bindings for any of the four default types (\s-1SCALAR, ARRAY, HASH\s0 and \s-1CODE\s0)
not supplied in the \f(CW\*(C`use autobox\*(C'\fR statement. As with the other options, the \f(CW\*(C`value\*(C'\fR corresponding to
the \f(CW\*(C`DEFAULT\*(C'\fR \f(CW\*(C`key\*(C'\fR can be a class name, a namespace, or a reference to an array containing one or
more class names and/or namespaces.
.PP
Thus:
.PP
.Vb 4
\&    use autobox {
\&        STRING  => \*(AqMyString\*(Aq,
\&        DEFAULT => \*(AqMyDefault\*(Aq,
\&    }
.Ve
.PP
is equivalent to:
.PP
.Vb 7
\&    use autobox {
\&        STRING  => \*(AqMyString\*(Aq,
\&        SCALAR  => \*(AqMyDefault\*(Aq,
\&        ARRAY   => \*(AqMyDefault\*(Aq,
\&        HASH    => \*(AqMyDefault\*(Aq,
\&        CODE    => \*(AqMyDefault\*(Aq,
\&    }
.Ve
.PP
Which in turn is equivalent to:
.PP
.Vb 8
\&    use autobox {
\&        INTEGER => \*(AqMyDefault\*(Aq,
\&        FLOAT   => \*(AqMyDefault\*(Aq,
\&        STRING  => [ \*(AqMyString\*(Aq, \*(AqMyDefault\*(Aq ],
\&        ARRAY   => \*(AqMyDefault\*(Aq,
\&        HASH    => \*(AqMyDefault\*(Aq,
\&        CODE    => \*(AqMyDefault\*(Aq,
\&    }
.Ve
.PP
Namespaces in \s-1DEFAULT\s0 values have the default type name appended, which, in the case of defaulted \s-1SCALAR\s0 types,
is \s-1SCALAR\s0 rather than \s-1INTEGER, FLOAT\s0 &c.
.PP
Thus:
.PP
.Vb 6
\&    use autobox {
\&        ARRAY   => \*(AqMyArray\*(Aq,
\&        HASH    => \*(AqMyHash\*(Aq,
\&        CODE    => \*(AqMyCode\*(Aq,
\&        DEFAULT => \*(AqMyNamespace::\*(Aq,
\&    }
.Ve
.PP
is equivalent to:
.PP
.Vb 8
\&    use autobox {
\&        INTEGER => \*(AqMyNamespace::SCALAR\*(Aq,
\&        FLOAT   => \*(AqMyNamespace::SCALAR\*(Aq,
\&        STRING  => \*(AqMyNamespace::SCALAR\*(Aq,
\&        ARRAY   => \*(AqMyArray\*(Aq,
\&        HASH    => \*(AqMyArray\*(Aq,
\&        CODE    => \*(AqMyCode\*(Aq,
\&    }
.Ve
.PP
Any of the four default types can be exempted from defaulting to the \s-1DEFAULT\s0 value by supplying a value of undef:
.PP
.Vb 4
\&    use autobox {
\&        HASH    => undef,
\&        DEFAULT => \*(AqMyDefault\*(Aq,
\&    }
\&
\&    42\->foo # ok: MyDefault::foo
\&    []\->bar # ok: MyDefault::bar
\&
\&    %INC\->baz # not ok: runtime error
.Ve
.SS "\s-1UNDEF\s0"
.IX Subsection "UNDEF"
The pseudotype, \s-1UNDEF,\s0 can be used to autobox undefined values. These are not autoboxed by default.
.PP
This doesn't work:
.PP
.Vb 1
\&    use autobox;
\&
\&    undef\->foo() # runtime error
.Ve
.PP
This works:
.PP
.Vb 1
\&    use autobox UNDEF => \*(AqMyUndef\*(Aq;
\&
\&    undef\->foo(); # ok
.Ve
.PP
So does this:
.PP
.Vb 1
\&    use autobox UNDEF => \*(AqMyNamespace::\*(Aq;
\&
\&    undef\->foo(); # ok
.Ve
.SS "\s-1NUMBER, SCALAR\s0 and \s-1UNIVERSAL\s0"
.IX Subsection "NUMBER, SCALAR and UNIVERSAL"
The virtual types \s-1NUMBER, SCALAR\s0 and \s-1UNIVERSAL\s0 function as macros or shortcuts which create
bindings for their subtypes. The type hierarchy is as follows:
.PP
.Vb 10
\&  UNIVERSAL \-+
\&             |
\&             +\- SCALAR \-+
\&             |          |
\&             |          +\- NUMBER \-+
\&             |          |          |
\&             |          |          +\- INTEGER
\&             |          |          |
\&             |          |          +\- FLOAT
\&             |          |
\&             |          +\- STRING
\&             |
\&             +\- ARRAY
\&             |
\&             +\- HASH
\&             |
\&             +\- CODE
.Ve
.PP
Thus:
.PP
.Vb 1
\&    use autobox NUMBER => \*(AqMyNumber\*(Aq;
.Ve
.PP
is equivalent to:
.PP
.Vb 4
\&    use autobox {
\&        INTEGER => \*(AqMyNumber\*(Aq,
\&        FLOAT   => \*(AqMyNumber\*(Aq,
\&    }
.Ve
.PP
And:
.PP
.Vb 1
\&    use autobox SCALAR => \*(AqMyScalar\*(Aq;
.Ve
.PP
is equivalent to:
.PP
.Vb 5
\&    use autobox {
\&        INTEGER => \*(AqMyScalar\*(Aq,
\&        FLOAT   => \*(AqMyScalar\*(Aq,
\&        STRING  => \*(AqMyScalar\*(Aq,
\&    }
.Ve
.PP
Virtual types can also be passed to \f(CW\*(C`unimport\*(C'\fR via the \f(CW\*(C`no autobox\*(C'\fR syntax. This disables autoboxing
for the corresponding subtypes e.g.
.PP
.Vb 1
\&    no autobox qw(NUMBER);
.Ve
.PP
is equivalent to:
.PP
.Vb 1
\&    no autobox qw(INTEGER FLOAT);
.Ve
.PP
Virtual type bindings can be mixed with ordinary bindings to provide fine-grained control over
inheritance and delegation. For instance:
.PP
.Vb 5
\&    use autobox {
\&        INTEGER => \*(AqMyInteger\*(Aq,
\&        NUMBER  => \*(AqMyNumber\*(Aq,
\&        SCALAR  => \*(AqMyScalar\*(Aq,
\&    }
.Ve
.PP
would result in the following bindings:
.PP
.Vb 3
\&    42\->foo             \-> [ MyInteger, MyNumber, MyScalar ]
\&    3.1415927\->bar      \-> [ MyNumber, MyScalar ]
\&    "Hello, world!\->baz \-> [ MyScalar ]
.Ve
.PP
Note that \s-1DEFAULT\s0 bindings take precedence over virtual type bindings i.e.
.PP
.Vb 4
\&    use autobox {
\&        UNIVERSAL => \*(AqMyUniversal\*(Aq,
\&        DEFAULT   => \*(AqMyDefault\*(Aq, # default SCALAR, ARRAY, HASH and CODE before UNIVERSAL
\&    }
.Ve
.PP
is equivalent to:
.PP
.Vb 4
\&  use autobox {
\&      INTEGER => [ \*(AqMyDefault\*(Aq, \*(AqMyUniversal\*(Aq ],
\&      FLOAT   => [ \*(AqMyDefault\*(Aq, \*(AqMyUniversal\*(Aq ], # ... &c.
\&  }
.Ve
.SS "\s-1DEBUG\s0"
.IX Subsection "DEBUG"
\&\f(CW\*(C`DEBUG\*(C'\fR exposes the current bindings for the scope in which \f(CW\*(C`use autobox\*(C'\fR is called by means
of a callback, or a static debugging function.
.PP
This allows the computed bindings to be seen in \*(L"longhand\*(R".
.PP
The option is ignored if the value corresponding to the \f(CW\*(C`DEBUG\*(C'\fR key is false.
.PP
If the value is a \s-1CODE\s0 ref, then this sub is called with a reference to
the hash containing the computed bindings for the current scope.
.PP
Finally, if \f(CW\*(C`DEBUG\*(C'\fR is true but not a \s-1CODE\s0 ref, the bindings are dumped
to \s-1STDERR.\s0
.PP
Thus:
.PP
.Vb 1
\&    use autobox DEBUG => 1, ...
.Ve
.PP
or
.PP
.Vb 1
\&    use autobox DEBUG => sub { ... }, ...
.Ve
.PP
or
.PP
.Vb 4
\&    sub my_callback ($) {
\&        my $hashref = shift;
\&        ...
\&    }
\&
\&    use autobox DEBUG => \e&my_callback, ...
.Ve
.SH "METHODS"
.IX Header "METHODS"
.SS "import"
.IX Subsection "import"
This method sets up \f(CW\*(C`autobox\*(C'\fR bindings for the current lexical scope. It can be used to implement
\&\f(CW\*(C`autobox\*(C'\fR extensions i.e. lexically-scoped modules that provide \f(CW\*(C`autobox\*(C'\fR bindings for one or more
native types without requiring calling code to \f(CW\*(C`use autobox\*(C'\fR.
.PP
This is done by subclassing \f(CW\*(C`autobox\*(C'\fR and overriding \f(CW\*(C`import\*(C'\fR. This allows extensions to effectively
translate \f(CW\*(C`use MyModule\*(C'\fR into a bespoke \f(CW\*(C`use autobox\*(C'\fR call. e.g.:
.PP
.Vb 1
\&    package String::Trim;
\&
\&    use base qw(autobox);
\&
\&    sub import {
\&        my $class = shift;
\&        $class\->SUPER::import(
\&            STRING => \*(AqString::Trim::String\*(Aq
\&        );
\&    }
\&
\&    package String::Trim::String;
\&
\&    sub trim {
\&        my $string = shift;
\&        $string =~ s/^\es+//;
\&        $string =~ s/\es+$//;
\&        $string;
\&    }
\&
\&    1;
.Ve
.PP
Note that \f(CW\*(C`trim\*(C'\fR is defined in an auxiliary class rather than in \f(CW\*(C`String::Trim\*(C'\fR itself to prevent
\&\f(CW\*(C`String::Trim\*(C'\fR's own methods (i.e. the methods it inherits from \f(CW\*(C`autobox\*(C'\fR) being exposed to \f(CW\*(C`STRING\*(C'\fR types.
.PP
This module can now be used without a \f(CW\*(C`use autobox\*(C'\fR statement to enable the \f(CW\*(C`trim\*(C'\fR method in the current
lexical scope. e.g.:
.PP
.Vb 1
\&    #!/usr/bin/env perl
\&
\&    use String::Trim;
\&
\&    print "  Hello, world!  "\->trim();
.Ve
.SH "UNIVERSAL METHODS FOR AUTOBOXED TYPES"
.IX Header "UNIVERSAL METHODS FOR AUTOBOXED TYPES"
.SS "autobox_class"
.IX Subsection "autobox_class"
\&\f(CW\*(C`autobox\*(C'\fR adds a single method to all autoboxed types: \f(CW\*(C`autobox_class\*(C'\fR. This can be used to
call \f(CW\*(C`can\*(C'\fR, \f(CW\*(C`isa\*(C'\fR, \f(CW\*(C`VERSION\*(C'\fR, \f(CW\*(C`import\*(C'\fR and \f(CW\*(C`unimport\*(C'\fR. e.g.
.PP
.Vb 2
\&    if (sub { ... }\->autobox_class\->can(\*(Aqcurry\*(Aq)) ...
\&    if (42\->autobox_class\->isa(\*(AqSCALAR\*(Aq)) ...
.Ve
.PP
Note: \f(CW\*(C`autobox_class\*(C'\fR should \fBalways\fR be used when calling these methods. The behaviour when
these methods are called directly on the native type e.g.:
.PP
.Vb 3
\&    42\->can(\*(Aqfoo\*(Aq)
\&    42\->isa(\*(AqBar\*(Aq)
\&    42\->VERSION
.Ve
.PP
\&\- is undefined.
.SH "EXPORTS"
.IX Header "EXPORTS"
.SS "type"
.IX Subsection "type"
\&\f(CW\*(C`autobox\*(C'\fR includes an additional module, \f(CW\*(C`autobox::universal\*(C'\fR, which exports a single subroutine, \f(CW\*(C`type\*(C'\fR.
.PP
This sub returns the type of its argument within \f(CW\*(C`autobox\*(C'\fR (which is essentially longhand for the type names
used within perl). This value is used by \f(CW\*(C`autobox\*(C'\fR to associate a method invocant with its designated classes. e.g.
.PP
.Vb 1
\&    use autobox::universal qw(type);
\&
\&    type("42")  # STRING
\&    type(42)    # INTEGER
\&    type(42.0)  # FLOAT
\&    type(undef) # UNDEF
.Ve
.PP
\&\f(CW\*(C`autobox::universal\*(C'\fR is loaded automatically by \f(CW\*(C`autobox\*(C'\fR, and, as its name suggests, can be used to install
a universal \f(CW\*(C`type\*(C'\fR method for autoboxed values e.g.
.PP
.Vb 1
\&    use autobox UNIVERSAL => \*(Aqautobox::universal\*(Aq;
\&
\&    42\->type        # INTEGER
\&    3.1415927\->type # FLOAT
\&    %ENV\->type      # HASH
.Ve
.SH "CAVEATS"
.IX Header "CAVEATS"
.SS "Performance"
.IX Subsection "Performance"
Calling
.PP
.Vb 1
\&    "Hello, world!"\->length()
.Ve
.PP
is slightly slower than the equivalent method call on a string-like object, and significantly slower than
.PP
.Vb 1
\&    length("Hello, world!")
.Ve
.SS "Gotchas"
.IX Subsection "Gotchas"
\fIPrecedence\fR
.IX Subsection "Precedence"
.PP
Due to Perl's precedence rules, some autoboxed literals may need to be parenthesized:
.PP
For instance, while this works:
.PP
.Vb 1
\&    my $curried = sub { ... }\->curry();
.Ve
.PP
this doesn't:
.PP
.Vb 1
\&    my $curried = \e&foo\->curry();
.Ve
.PP
The solution is to wrap the reference in parentheses:
.PP
.Vb 1
\&    my $curried = (\e&foo)\->curry();
.Ve
.PP
The same applies for signed integer and float literals:
.PP
.Vb 2
\&    # this works
\&    my $range = 10\->to(1);
\&
\&    # this doesn\*(Aqt work
\&    my $range = \-10\->to(10);
\&
\&    # this works
\&    my $range = (\-10)\->to(10);
.Ve
.PP
\fIprint \s-1BLOCK\s0\fR
.IX Subsection "print BLOCK"
.PP
Perl's special-casing for the \f(CW\*(C`print BLOCK ...\*(C'\fR syntax (see perlsub) means that \f(CW\*(C`print { expression() } ...\*(C'\fR
(where the curly brackets denote an anonymous \s-1HASH\s0 ref) may require some further disambiguation:
.PP
.Vb 2
\&    # this works
\&    print { foo => \*(Aqbar\*(Aq }\->foo();
\&
\&    # and this
\&    print { \*(Aqfoo\*(Aq, \*(Aqbar\*(Aq }\->foo();
\&
\&    # and even this
\&    print { \*(Aqfoo\*(Aq, \*(Aqbar\*(Aq, @_ }\->foo();
\&
\&    # but this doesn\*(Aqt
\&    print { @_ }\->foo() ? 1 : 0
.Ve
.PP
In the latter case, the solution is to supply something
other than a \s-1HASH\s0 ref literal as the first argument
to \f(CW\*(C`print()\*(C'\fR:
.PP
.Vb 2
\&    # e.g.
\&    print STDOUT { @_ }\->foo() ? 1 : 0;
\&
\&    # or
\&    my $hashref = { @_ };
\&    print $hashref\->foo() ? 1 : 0;
\&
\&    # or
\&    print \*(Aq\*(Aq, { @_ }\->foo() ? 1 : 0;
\&
\&    # or
\&    print \*(Aq\*(Aq . { @_ }\->foo() ? 1 : 0;
\&
\&    # or even
\&    { @_ }\->print_if_foo(1, 0);
.Ve
.PP
\fIeval \s-1EXPR\s0\fR
.IX Subsection "eval EXPR"
.PP
Like most pragmas, \f(CW\*(C`autobox\*(C'\fR performs operations at compile time, and,
as a result, runtime string \f(CW\*(C`eval\*(C'\fRs are not executed within its scope i.e. this
doesn't work:
.PP
.Vb 1
\&    use autobox;
\&
\&    eval "42\->foo";
.Ve
.PP
The workaround is to use \f(CW\*(C`autobox\*(C'\fR within the \f(CW\*(C`eval\*(C'\fR e.g.
.PP
.Vb 4
\&    eval <<\*(AqEOS\*(Aq;
\&        use autobox;
\&        42\->foo();
\&    EOS
.Ve
.PP
Note that the \f(CW\*(C`eval BLOCK\*(C'\fR form works as expected:
.PP
.Vb 1
\&    use autobox;
\&
\&    eval { 42\->foo() }; # OK
.Ve
.PP
\fIOperator Overloading\fR
.IX Subsection "Operator Overloading"
.PP
Operator overloading via the overload pragma doesn't (automatically) work.
\&\f(CW\*(C`autobox\*(C'\fR works by lexically overriding the arrow operator.
It doesn't bless native types into objects, so overloading \- or any other kind of \*(L"magic\*(R"
which depends on values being blessed \- doesn't apply.
.SH "VERSION"
.IX Header "VERSION"
2.86
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.IP "\(bu" 4
autobox::Core
.IP "\(bu" 4
Moose::Autobox
.IP "\(bu" 4
perl5i
.IP "\(bu" 4
Scalar::Properties
.SH "AUTHOR"
.IX Header "AUTHOR"
chocolateboy <chocolate@cpan.org>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright (c) 2003\-2018 by chocolateboy.
.PP
This library is free software; you can redistribute it and/or modify it under the
terms of the Artistic License 2.0 <http://www.opensource.org/licenses/artistic-license-2.0.php>.
