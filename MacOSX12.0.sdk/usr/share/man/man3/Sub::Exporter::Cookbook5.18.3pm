.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Sub::Exporter::Cookbook 3"
.TH Sub::Exporter::Cookbook 3 "2013-10-18" "perl v5.18.4" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Sub::Exporter::Cookbook \- useful, demonstrative, or stupid Sub::Exporter tricks
.SH "VERSION"
.IX Header "VERSION"
version 0.987
.SH "OVERVIEW"
.IX Header "OVERVIEW"
Sub::Exporter is a fairly simple tool, and can be used to achieve some very
simple goals.  Its basic behaviors and their basic application (that is,
\&\*(L"traditional\*(R" exporting of routines) are described in
Sub::Exporter::Tutorial and Sub::Exporter.  This document presents
applications that may not be immediately obvious, or that can demonstrate how
certain features can be put to use (for good or evil).
.SH "THE RECIPES"
.IX Header "THE RECIPES"
.SS "Exporting Methods as Routines"
.IX Subsection "Exporting Methods as Routines"
With Exporter.pm, exporting methods is a non-starter.  Sub::Exporter makes it
simple.  By using the \f(CW\*(C`curry_method\*(C'\fR utility provided in
Sub::Exporter::Util, a method can be exported with the invocant built in.
.PP
.Vb 1
\&  package Object::Strenuous;
\&
\&  use Sub::Exporter::Util \*(Aqcurry_method\*(Aq;
\&  use Sub::Exporter \-setup => {
\&    exports => [ objection => curry_method(\*(Aqnew\*(Aq) ],
\&  };
.Ve
.PP
With this configuration, the importing code may contain:
.PP
.Vb 1
\&  my $obj = objection("irrelevant");
.Ve
.PP
\&...and this will be equivalent to:
.PP
.Vb 1
\&  my $obj = Object::Strenuous\->new("irrelevant");
.Ve
.PP
The built-in invocant is determined by the invocant for the \f(CW\*(C`import\*(C'\fR method.
That means that if we were to subclass Object::Strenuous as follows:
.PP
.Vb 2
\&  package Object::Strenuous::Repeated;
\&  @ISA = \*(AqObject::Strenuous\*(Aq;
.Ve
.PP
\&...then importing \f(CW\*(C`objection\*(C'\fR from the subclass would build-in that subclass.
.PP
Finally, since the invocant can be an object, you can write something like
this:
.PP
.Vb 5
\&  package Cypher;
\&  use Sub::Exporter::Util \*(Aqcurry_method\*(Aq;
\&  use Sub::Exporter \-setup => {
\&    exports => [ encypher => curry_method ],
\&  };
.Ve
.PP
with the expectation that \f(CW\*(C`import\*(C'\fR will be called on an instantiated Cypher
object:
.PP
.Vb 4
\&  BEGIN {
\&    my $cypher = Cypher\->new( ... );
\&    $cypher\->import(\*(Aqencypher\*(Aq);
\&  }
.Ve
.PP
Now there is a globally-available \f(CW\*(C`encypher\*(C'\fR routine which calls the encypher
method on an otherwise unavailable Cypher object.
.SS "Exporting Methods as Methods"
.IX Subsection "Exporting Methods as Methods"
While exporting modules usually export subroutines to be called as subroutines,
it's easy to use Sub::Exporter to export subroutines meant to be called as
methods on the importing package or its objects.
.PP
Here's a trivial (and naive) example:
.PP
.Vb 1
\&  package Mixin::DumpObj;
\&
\&  use Data::Dumper;
\&
\&  use Sub::Exporter \-setup => {
\&    exports => [ qw(dump) ]
\&  };
\&
\&  sub dump {
\&    my ($self) = @_;
\&    return Dumper($self);
\&  }
.Ve
.PP
When writing your own object class, you can then import \f(CW\*(C`dump\*(C'\fR to be used as a
method, called like so:
.PP
.Vb 1
\&  $object\->dump;
.Ve
.PP
By assuming that the importing class will provide a certain interface, a
method-exporting module can be used as a simple plugin:
.PP
.Vb 6
\&  package Number::Plugin::Upto;
\&  use Sub::Exporter \-setup => {
\&    into    => \*(AqNumber\*(Aq,
\&    exports => [ qw(upto) ],
\&    groups  => [ default => [ qw(upto) ] ],
\&  };
\&
\&  sub upto {
\&    my ($self) = @_;
\&    return 1 .. abs($self\->as_integer);
\&  }
.Ve
.PP
The \f(CW\*(C`into\*(C'\fR line in the configuration says that this plugin will export, by
default, into the Number package, not into the \f(CW\*(C`use\*(C'\fR\-ing package.  It can be
exported anyway, though, and will work as long as the destination provides an
\&\f(CW\*(C`as_integer\*(C'\fR method like the one it expects.  To import it to a different
destination, one can just write:
.PP
.Vb 1
\&  use Number::Plugin::Upto { into => \*(AqQuantity\*(Aq };
.Ve
.SS "Mixing-in Complex External Behavior"
.IX Subsection "Mixing-in Complex External Behavior"
When exporting methods to be used as methods (see above), one very powerful
option is to export methods that are generated routines that maintain an
enclosed reference to the exporting module.  This allows a user to import a
single method which is implemented in terms of a complete, well-structured
package.
.PP
Here is a very small example:
.PP
.Vb 1
\&  package Data::Analyzer;
\&
\&  use Sub::Exporter \-setup => {
\&    exports => [ analyze => \e\*(Aq_generate_analyzer\*(Aq ],
\&  };
\&
\&  sub _generate_analyzer {
\&    my ($mixin, $name, $arg, $col) = @_;
\&
\&    return sub {
\&      my ($self) = @_;
\&
\&      my $values = [ $self\->values ];
\&
\&      my $analyzer = $mixin\->new($values);
\&      $analyzer\->perform_analysis;
\&      $analyzer\->aggregate_results;
\&
\&      return $analyzer\->summary;
\&    };
\&  }
.Ve
.PP
If imported by any package providing a \f(CW\*(C`values\*(C'\fR method, this plugin will
provide a single \f(CW\*(C`analyze\*(C'\fR method that acts as a simple interface to a more
complex set of behaviors.
.PP
Even more importantly, because the \f(CW$mixin\fR value will be the invocant on
which the \f(CW\*(C`import\*(C'\fR was actually called, one can subclass \f(CW\*(C`Data::Analyzer\*(C'\fR and
replace only individual pieces of the complex behavior, making it easy to write
complex, subclassable toolkits with simple single points of entry for external
interfaces.
.SS "Exporting Constants"
.IX Subsection "Exporting Constants"
While Sub::Exporter isn't in the constant-exporting business, it's easy to
export constants by using one of its sister modules, Package::Generator.
.PP
.Vb 1
\&  package Important::Constants;
\& 
\&  use Sub::Exporter \-setup => {
\&    collectors => [ constants => \e\*(Aq_set_constants\*(Aq ],
\&  };
\& 
\&  sub _set_constants {
\&    my ($class, $value, $data) = @_;
\& 
\&    Package::Generator\->assign_symbols(
\&      $data\->{into},
\&      [
\&        MEANING_OF_LIFE => \e42,
\&        ONE_TRUE_BASE   => \e13,
\&        FACTORS         => [ 6, 9 ],
\&      ],
\&    );
\&
\&    return 1;
\&  }
.Ve
.PP
Then, someone can write:
.PP
.Vb 1
\&  use Important::Constants \*(Aqconstants\*(Aq;
\&  
\&  print "The factors @FACTORS produce $MEANING_OF_LIFE in $ONE_TRUE_BASE.";
.Ve
.PP
(The constants must be exported via a collector, because they are effectively
altering the importing class in a way other than installing subroutines.)
.ie n .SS "Altering the Importer's @ISA"
.el .SS "Altering the Importer's \f(CW@ISA\fP"
.IX Subsection "Altering the Importer's @ISA"
It's trivial to make a collector that changes the inheritance of an importing
package:
.PP
.Vb 3
\&  use Sub::Exporter \-setup => {
\&    collectors => { \-base => \e\*(Aq_make_base\*(Aq },
\&  };
\&
\&  sub _make_base {
\&    my ($class, $value, $data) = @_;
\&
\&    my $target = $data\->{into};
\&    push @{"$target\e::ISA"}, $class;
\&  }
.Ve
.PP
Then, the user of your class can write:
.PP
.Vb 1
\&  use Some::Class \-base;
.Ve
.PP
and become a subclass.  This can be quite useful in building, for example, a
module that helps build plugins.  We may want a few utilities imported, but we
also want to inherit behavior from some base plugin class;
.PP
.Vb 1
\&  package Framework::Util;
\&
\&  use Sub::Exporter \-setup => {
\&    exports    => [ qw(log global_config) ],
\&    groups     => [ _plugin => [ qw(log global_config) ]
\&    collectors => { \*(Aq\-plugin\*(Aq => \e\*(Aq_become_plugin\*(Aq },
\&  };
\&
\&  sub _become_plugin {
\&    my ($class, $value, $data) = @_;
\&
\&    my $target = $data\->{into};
\&    push @{"$target\e::ISA"}, $class\->plugin_base_class;
\&
\&    push @{ $data\->{import_args} }, \*(Aq\-_plugin\*(Aq;
\&  }
.Ve
.PP
Now, you can write a plugin like this:
.PP
.Vb 2
\&  package Framework::Plugin::AirFreshener;
\&  use Framework::Util \-plugin;
.Ve
.SS "Eating Exporter.pm's Brain"
.IX Subsection "Eating Exporter.pm's Brain"
You probably shouldn't actually do this in production.  It's offered more as a
demonstration than a suggestion.
.PP
.Vb 3
\& sub exporter_upgrade {
\&   my ($pkg) = @_;
\&   my $new_pkg = "$pkg\e::UsingSubExporter";
\&
\&   return $new_pkg if $new_pkg\->isa($pkg);
\&
\&   Sub::Exporter::setup_exporter({
\&     as      => \*(Aqimport\*(Aq,
\&     into    => $new_pkg,
\&     exports => [ @{"$pkg\e::EXPORT_OK"} ],
\&     groups  => {
\&       %{"$pkg\e::EXPORT_TAG"},
\&       default => [ @{"$pkg\e::EXPORTS"} ],
\&     },
\&   });
\&
\&   @{"$new_pkg\e::ISA"} = $pkg;
\&   return $new_pkg;
\& }
.Ve
.PP
This routine, given the name of an existing package configured to use
Exporter.pm, returns the name of a new package with a Sub::Exporter\-powered
\&\f(CW\*(C`import\*(C'\fR routine.  This lets you import \f(CW\*(C`Toolkit::exported_sub\*(C'\fR into the
current package with the name \f(CW\*(C`foo\*(C'\fR by writing:
.PP
.Vb 4
\&  BEGIN {
\&    require Toolkit;
\&    exporter_upgrade(\*(AqToolkit\*(Aq)\->import(exported_sub => { \-as => \*(Aqfoo\*(Aq })
\&  }
.Ve
.PP
If you're feeling particularly naughty, this routine could have been declared
in the \s-1UNIVERSAL\s0 package, meaning you could write:
.PP
.Vb 4
\&  BEGIN {
\&    require Toolkit;
\&    Toolkit\->exporter_upgrade\->import(exported_sub => { \-as => \*(Aqfoo\*(Aq })
\&  }
.Ve
.PP
The new package will have all the same exporter configuration as the original,
but will support export and group renaming, including exporting into scalar
references.  Further, since Sub::Exporter uses \f(CW\*(C`can\*(C'\fR to find the routine being
exported, the new package may be subclassed and some of its exports replaced.
.SH "AUTHOR"
.IX Header "AUTHOR"
Ricardo Signes <rjbs@cpan.org>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is copyright (c) 2007 by Ricardo Signes.
.PP
This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.
