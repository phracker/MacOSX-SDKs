.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "arybase 3pm"
.TH arybase 3pm "2014-09-30" "perl v5.18.4" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
arybase \- Set indexing base via $[
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    $[ = 1;
\&
\&    @a = qw(Sun Mon Tue Wed Thu Fri Sat);
\&    print $a[3], "\en";  # prints Tue
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module implements Perl's \f(CW$[\fR variable.  You should not use it
directly.
.PP
Assigning to \f(CW$[\fR has the \fIcompile-time\fR effect of making the assigned
value, converted to an integer, the index of the first element in an array
and the first character in a substring, within the enclosing lexical scope.
.PP
It can be written with or without \f(CW\*(C`local\*(C'\fR:
.PP
.Vb 2
\&    $[ = 1;
\&    local $[ = 1;
.Ve
.PP
It only works if the assignment can be detected at compile time and the
value assigned is constant.
.PP
It affects the following operations:
.PP
.Vb 7
\&    $array[$element]
\&    @array[@slice]
\&    $#array
\&    (list())[$slice]
\&    splice @array, $index, ...
\&    each @array
\&    keys @array
\&
\&    index $string, $substring  # return value is affected
\&    pos $string
\&    substr $string, $offset, ...
.Ve
.PP
As with the default base of 0, negative bases count from the end of the
array or string, starting with \-1.  If \f(CW$[\fR is a positive integer, indices
from \f(CW\*(C`$[\-1\*(C'\fR to 0 also count from the end.  If \f(CW$[\fR is negative (why would
you do that, though?), indices from \f(CW$[\fR to 0 count from the beginning of
the string, but indices below \f(CW$[\fR count from the end of the string as
though the base were 0.
.PP
Prior to Perl 5.16, indices from 0 to \f(CW\*(C`$[\-1\*(C'\fR inclusive, for positive
values of \f(CW$[\fR, behaved differently for different operations; negative
indices equal to or greater than a negative \f(CW$[\fR likewise behaved
inconsistently.
.SH "HISTORY"
.IX Header "HISTORY"
Before Perl 5, \f(CW$[\fR was a global variable that affected all array indices
and string offsets.
.PP
Starting with Perl 5, it became a file-scoped compile-time directive, which
could be made lexically-scoped with \f(CW\*(C`local\*(C'\fR.  \*(L"File-scoped\*(R" means that the
\&\f(CW$[\fR assignment could leak out of the block in which occurred:
.PP
.Vb 5
\&    {
\&        $[ = 1;
\&        # ... array base is 1 here ...
\&    }
\&    # ... still 1, but not in other files ...
.Ve
.PP
In Perl 5.10, it became strictly lexical.  The file-scoped behaviour was
removed (perhaps inadvertently, but what's done is done).
.PP
In Perl 5.16, the implementation was moved into this module, and out of the
Perl core.  The erratic behaviour that occurred with indices between \-1 and
\&\f(CW$[\fR was made consistent between operations, and, for negative bases,
indices from \f(CW$[\fR to \-1 inclusive were made consistent between operations.
.SH "BUGS"
.IX Header "BUGS"
Error messages that mention array indices use the 0\-based index.
.PP
\&\f(CW\*(C`keys $arrayref\*(C'\fR and \f(CW\*(C`each $arrayref\*(C'\fR do not respect the current value of
\&\f(CW$[\fR.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\*(L"$[\*(R" in perlvar, Array::Base and String::Base.
