.\" Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "DBIx::Class::Storage::DBI::Replicated 3"
.TH DBIx::Class::Storage::DBI::Replicated 3 "2018-01-29" "perl v5.30.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
DBIx::Class::Storage::DBI::Replicated \- BETA Replicated database support
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
The Following example shows how to change an existing \f(CW$schema\fR to a replicated
storage type, add some replicated (read-only) databases, and perform reporting
tasks.
.PP
You should set the 'storage_type attribute to a replicated type.  You should
also define your arguments, such as which balancer you want and any arguments
that the Pool object should get.
.PP
.Vb 3
\&  my $schema = Schema::Class\->clone;
\&  $schema\->storage_type([\*(Aq::DBI::Replicated\*(Aq, { balancer_type => \*(Aq::Random\*(Aq }]);
\&  $schema\->connection(...);
.Ve
.PP
Next, you need to add in the Replicants.  Basically this is an array of
arrayrefs, where each arrayref is database connect information.  Think of these
arguments as what you'd pass to the 'normal' \f(CW$schema\fR\->connect method.
.PP
.Vb 5
\&  $schema\->storage\->connect_replicants(
\&    [$dsn1, $user, $pass, \e%opts],
\&    [$dsn2, $user, $pass, \e%opts],
\&    [$dsn3, $user, $pass, \e%opts],
\&  );
.Ve
.PP
Now, just use the \f(CW$schema\fR as you normally would.  Automatically all reads will
be delegated to the replicants, while writes to the master.
.PP
.Vb 1
\&  $schema\->resultset(\*(AqSource\*(Aq)\->search({name=>\*(Aqetc\*(Aq});
.Ve
.PP
You can force a given query to use a particular storage using the search
attribute 'force_pool'.  For example:
.PP
.Vb 1
\&  my $rs = $schema\->resultset(\*(AqSource\*(Aq)\->search(undef, {force_pool=>\*(Aqmaster\*(Aq});
.Ve
.PP
Now \f(CW$rs\fR will force everything (both reads and writes) to use whatever was setup
as the master storage.  'master' is hardcoded to always point to the Master,
but you can also use any Replicant name.  Please see:
DBIx::Class::Storage::DBI::Replicated::Pool and the replicants attribute for more.
.PP
Also see transactions and \*(L"execute_reliably\*(R" for alternative ways to
force read traffic to the master.  In general, you should wrap your statements
in a transaction when you are reading and writing to the same tables at the
same time, since your replicants will often lag a bit behind the master.
.PP
If you have a multi-statement read only transaction you can force it to select
a random server in the pool by:
.PP
.Vb 3
\&  my $rs = $schema\->resultset(\*(AqSource\*(Aq)\->search( undef,
\&    { force_pool => $db\->storage\->read_handler\->next_storage }
\&  );
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Warning: This class is marked \s-1BETA.\s0  This has been running a production
website using MySQL native replication as its backend and we have some decent
test coverage but the code hasn't yet been stressed by a variety of databases.
Individual DBs may have quirks we are not aware of.  Please use this in first
development and pass along your experiences/bug fixes.
.PP
This class implements replicated data store for \s-1DBI.\s0 Currently you can define
one master and numerous slave database connections. All write-type queries
(\s-1INSERT, UPDATE, DELETE\s0 and even \s-1LAST_INSERT_ID\s0) are routed to master
database, all read-type queries (SELECTs) go to the slave database.
.PP
Basically, any method request that DBIx::Class::Storage::DBI would normally
handle gets delegated to one of the two attributes: \*(L"read_handler\*(R" or to
\&\*(L"write_handler\*(R".  Additionally, some methods need to be distributed
to all existing storages.  This way our storage class is a drop in replacement
for DBIx::Class::Storage::DBI.
.PP
Read traffic is spread across the replicants (slaves) occurring to a user
selected algorithm.  The default algorithm is random weighted.
.SH "NOTES"
.IX Header "NOTES"
The consistency between master and replicants is database specific.  The Pool
gives you a method to validate its replicants, removing and replacing them
when they fail/pass predefined criteria.  Please make careful use of the ways
to force a query to run against Master when needed.
.SH "REQUIREMENTS"
.IX Header "REQUIREMENTS"
Replicated Storage has additional requirements not currently part of
DBIx::Class. See DBIx::Class::Optional::Dependencies for more details.
.SH "ATTRIBUTES"
.IX Header "ATTRIBUTES"
This class defines the following attributes.
.SS "schema"
.IX Subsection "schema"
The underlying DBIx::Class::Schema object this storage is attaching
.SS "pool_type"
.IX Subsection "pool_type"
Contains the classname which will instantiate the \*(L"pool\*(R" object.  Defaults
to: DBIx::Class::Storage::DBI::Replicated::Pool.
.SS "pool_args"
.IX Subsection "pool_args"
Contains a hashref of initialized information to pass to the Balancer object.
See DBIx::Class::Storage::DBI::Replicated::Pool for available arguments.
.SS "balancer_type"
.IX Subsection "balancer_type"
The replication pool requires a balance class to provider the methods for
choose how to spread the query load across each replicant in the pool.
.SS "balancer_args"
.IX Subsection "balancer_args"
Contains a hashref of initialized information to pass to the Balancer object.
See DBIx::Class::Storage::DBI::Replicated::Balancer for available arguments.
.SS "pool"
.IX Subsection "pool"
Is a DBIx::Class::Storage::DBI::Replicated::Pool or derived class.  This is a
container class for one or more replicated databases.
.SS "balancer"
.IX Subsection "balancer"
Is a DBIx::Class::Storage::DBI::Replicated::Balancer or derived class.  This
is a class that takes a pool (DBIx::Class::Storage::DBI::Replicated::Pool)
.SS "master"
.IX Subsection "master"
The master defines the canonical state for a pool of connected databases.  All
the replicants are expected to match this databases state.  Thus, in a classic
Master / Slaves distributed system, all the slaves are expected to replicate
the Master's state as quick as possible.  This is the only database in the
pool of databases that is allowed to handle write traffic.
.SH "ATTRIBUTES IMPLEMENTING THE DBIx::Storage::DBI INTERFACE"
.IX Header "ATTRIBUTES IMPLEMENTING THE DBIx::Storage::DBI INTERFACE"
The following methods are delegated all the methods required for the
DBIx::Class::Storage::DBI interface.
.SS "read_handler"
.IX Subsection "read_handler"
Defines an object that implements the read side of DBIx::Class::Storage::DBI.
.SS "write_handler"
.IX Subsection "write_handler"
Defines an object that implements the write side of DBIx::Class::Storage::DBI,
as well as methods that don't write or read that can be called on only one
storage, methods that return a \f(CW$dbh\fR, and any methods that don't make sense to
run on a replicant.
.SS "around: connect_info"
.IX Subsection "around: connect_info"
Preserves master's \f(CW\*(C`connect_info\*(C'\fR options (for merging with replicants.)
Also sets any Replicated-related options from connect_info, such as
\&\f(CW\*(C`pool_type\*(C'\fR, \f(CW\*(C`pool_args\*(C'\fR, \f(CW\*(C`balancer_type\*(C'\fR and \f(CW\*(C`balancer_args\*(C'\fR.
.SH "METHODS"
.IX Header "METHODS"
This class defines the following methods.
.SS "\s-1BUILDARGS\s0"
.IX Subsection "BUILDARGS"
DBIx::Class::Schema when instantiating its storage passed itself as the
first argument.  So we need to massage the arguments a bit so that all the
bits get put into the correct places.
.SS "_build_master"
.IX Subsection "_build_master"
Lazy builder for the \*(L"master\*(R" attribute.
.SS "_build_pool"
.IX Subsection "_build_pool"
Lazy builder for the \*(L"pool\*(R" attribute.
.SS "_build_balancer"
.IX Subsection "_build_balancer"
Lazy builder for the \*(L"balancer\*(R" attribute.  This takes a Pool object so that
the balancer knows which pool it's balancing.
.SS "_build_write_handler"
.IX Subsection "_build_write_handler"
Lazy builder for the \*(L"write_handler\*(R" attribute.  The default is to set this to
the \*(L"master\*(R".
.SS "_build_read_handler"
.IX Subsection "_build_read_handler"
Lazy builder for the \*(L"read_handler\*(R" attribute.  The default is to set this to
the \*(L"balancer\*(R".
.SS "around: connect_replicants"
.IX Subsection "around: connect_replicants"
All calls to connect_replicants needs to have an existing \f(CW$schema\fR tacked onto
top of the args, since DBIx::Class::Storage::DBI needs it, and any
connect_info
options merged with the master, with replicant opts having higher priority.
.SS "all_storages"
.IX Subsection "all_storages"
Returns an array of all the connected storage backends.  The first element
in the returned array is the master, and the rest are each of the
replicants.
.SS "execute_reliably ($coderef, ?@args)"
.IX Subsection "execute_reliably ($coderef, ?@args)"
Given a coderef, saves the current state of the \*(L"read_handler\*(R", forces it to
use reliable storage (e.g. sets it to the master), executes a coderef and then
restores the original state.
.PP
Example:
.PP
.Vb 6
\&  my $reliably = sub {
\&    my $name = shift @_;
\&    $schema\->resultset(\*(AqUser\*(Aq)\->create({name=>$name});
\&    my $user_rs = $schema\->resultset(\*(AqUser\*(Aq)\->find({name=>$name});
\&    return $user_rs;
\&  };
\&
\&  my $user_rs = $schema\->storage\->execute_reliably($reliably, \*(AqJohn\*(Aq);
.Ve
.PP
Use this when you must be certain of your database state, such as when you just
inserted something and need to get a resultset including it, etc.
.SS "set_reliable_storage"
.IX Subsection "set_reliable_storage"
Sets the current \f(CW$schema\fR to be 'reliable', that is all queries, both read and
write are sent to the master
.SS "set_balanced_storage"
.IX Subsection "set_balanced_storage"
Sets the current \f(CW$schema\fR to be use the </balancer> for all reads, while all
writes are sent to the master only
.SS "connected"
.IX Subsection "connected"
Check that the master and at least one of the replicants is connected.
.SS "ensure_connected"
.IX Subsection "ensure_connected"
Make sure all the storages are connected.
.SS "limit_dialect"
.IX Subsection "limit_dialect"
Set the limit_dialect for all existing storages
.SS "quote_char"
.IX Subsection "quote_char"
Set the quote_char for all existing storages
.SS "name_sep"
.IX Subsection "name_sep"
Set the name_sep for all existing storages
.SS "set_schema"
.IX Subsection "set_schema"
Set the schema object for all existing storages
.SS "debug"
.IX Subsection "debug"
set a debug flag across all storages
.SS "debugobj"
.IX Subsection "debugobj"
set a debug object
.SS "debugfh"
.IX Subsection "debugfh"
set a debugfh object
.SS "debugcb"
.IX Subsection "debugcb"
set a debug callback
.SS "disconnect"
.IX Subsection "disconnect"
disconnect everything
.SS "cursor_class"
.IX Subsection "cursor_class"
set cursor class on all storages, or return master's
.SS "cursor"
.IX Subsection "cursor"
set cursor class on all storages, or return master's, alias for \*(L"cursor_class\*(R"
above.
.SS "unsafe"
.IX Subsection "unsafe"
sets the \*(L"unsafe\*(R" in DBIx::Class::Storage::DBI option on all storages or returns
master's current setting
.SS "disable_sth_caching"
.IX Subsection "disable_sth_caching"
sets the \*(L"disable_sth_caching\*(R" in DBIx::Class::Storage::DBI option on all storages
or returns master's current setting
.SS "lag_behind_master"
.IX Subsection "lag_behind_master"
returns the highest Replicant \*(L"lag_behind_master\*(R" in DBIx::Class::Storage::DBI
setting
.SS "is_replicating"
.IX Subsection "is_replicating"
returns true if all replicants return true for
\&\*(L"is_replicating\*(R" in DBIx::Class::Storage::DBI
.SS "connect_call_datetime_setup"
.IX Subsection "connect_call_datetime_setup"
calls \*(L"connect_call_datetime_setup\*(R" in DBIx::Class::Storage::DBI for all storages
.SH "GOTCHAS"
.IX Header "GOTCHAS"
Due to the fact that replicants can lag behind a master, you must take care to
make sure you use one of the methods to force read queries to a master should
you need realtime data integrity.  For example, if you insert a row, and then
immediately re-read it from the database (say, by doing
\&\f(CW$result\fR\->discard_changes)
or you insert a row and then immediately build a query that expects that row
to be an item, you should force the master to handle reads.  Otherwise, due to
the lag, there is no certainty your data will be in the expected state.
.PP
For data integrity, all transactions automatically use the master storage for
all read and write queries.  Using a transaction is the preferred and recommended
method to force the master to handle all read queries.
.PP
Otherwise, you can force a single query to use the master with the 'force_pool'
attribute:
.PP
.Vb 1
\&  my $result = $resultset\->search(undef, {force_pool=>\*(Aqmaster\*(Aq})\->find($pk);
.Ve
.PP
This attribute will safely be ignored by non replicated storages, so you can use
the same code for both types of systems.
.PP
Lastly, you can use the \*(L"execute_reliably\*(R" method, which works very much like
a transaction.
.PP
For debugging, you can turn replication on/off with the methods \*(L"set_reliable_storage\*(R"
and \*(L"set_balanced_storage\*(R", however this operates at a global level and is not
suitable if you have a shared Schema object being used by multiple processes,
such as on a web application server.  You can get around this limitation by
using the Schema clone method.
.PP
.Vb 2
\&  my $new_schema = $schema\->clone;
\&  $new_schema\->set_reliable_storage;
\&
\&  ## $new_schema will use only the Master storage for all reads/writes while
\&  ## the $schema object will use replicated storage.
.Ve
.SH "FURTHER QUESTIONS?"
.IX Header "FURTHER QUESTIONS?"
Check the list of additional \s-1DBIC\s0 resources.
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This module is free software copyright
by the DBIx::Class (\s-1DBIC\s0) authors. You can
redistribute it and/or modify it under the same terms as the
DBIx::Class library.
