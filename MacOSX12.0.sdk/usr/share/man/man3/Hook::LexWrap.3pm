.\" Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Hook::LexWrap 3"
.TH Hook::LexWrap 3 "2017-02-23" "perl v5.30.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Hook::LexWrap \- Lexically scoped subroutine wrappers
.SH "VERSION"
.IX Header "VERSION"
version 0.26
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&        use Hook::LexWrap;
\&
\&        sub doit { print "[doit:", caller, "]"; return {my=>"data"} }
\&
\&        SCOPED: {
\&                wrap doit =>
\&                        pre  => sub { print "[pre1: @_]\en" },
\&                        post => sub { print "[post1:@_]\en"; $_[1]=9; };
\&
\&                my $temporarily = wrap doit =>
\&                        post => sub { print "[post2:@_]\en" },
\&                        pre  => sub { print "[pre2: @_]\en  "};
\&
\&                @args = (1,2,3);
\&                doit(@args);    # pre2\->pre1\->doit\->post1\->post2
\&        }
\&
\&        @args = (4,5,6);
\&        doit(@args);            # pre1\->doit\->post1
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Hook::LexWrap allows you to install a pre\- or post-wrapper (or both)
around an existing subroutine. Unlike other modules that provide this
capacity (e.g. Hook::PreAndPost and Hook::WrapSub), Hook::LexWrap
implements wrappers in such a way that the standard \f(CW\*(C`caller\*(C'\fR function
works correctly within the wrapped subroutine.
.PP
To install a prewrappers, you write:
.PP
.Vb 1
\&        use Hook::LexWrap;
\&
\&        wrap \*(Aqsubroutine_name\*(Aq, pre => \e&some_other_sub;
\&
\&   #or: wrap *subroutine_name,  pre => \e&some_other_sub;
.Ve
.PP
The first argument to \f(CW\*(C`wrap\*(C'\fR is a string containing the name of the
subroutine to be wrapped (or the typeglob containing it, or a
reference to it). The subroutine name may be qualified, and the
subroutine must already be defined. The second argument indicates the
type of wrapper being applied and must be either \f(CW\*(Aqpre\*(Aq\fR or
\&\f(CW\*(Aqpost\*(Aq\fR. The third argument must be a reference to a subroutine that
implements the wrapper.
.PP
To install a post-wrapper, you write:
.PP
.Vb 1
\&        wrap \*(Aqsubroutine_name\*(Aq, post => \e&yet_another_sub;
\&
\&   #or: wrap *subroutine_name,  post => \e&yet_another_sub;
.Ve
.PP
To install both at once:
.PP
.Vb 3
\&        wrap \*(Aqsubroutine_name\*(Aq,
\&             pre  => \e&some_other_sub,
\&             post => \e&yet_another_sub;
.Ve
.PP
or:
.PP
.Vb 3
\&        wrap *subroutine_name,
\&             post => \e&yet_another_sub,  # order in which wrappers are
\&             pre  => \e&some_other_sub;   # specified doesn\*(Aqt matter
.Ve
.PP
Once they are installed, the pre\- and post-wrappers will be called before
and after the subroutine itself, and will be passed the same argument list.
.PP
The pre\- and post-wrappers and the original subroutine also all see the same
(correct!) values from \f(CW\*(C`caller\*(C'\fR and \f(CW\*(C`wantarray\*(C'\fR.
.SS "Short-circuiting and long-circuiting return values"
.IX Subsection "Short-circuiting and long-circuiting return values"
The pre\- and post-wrappers both receive an extra argument in their \f(CW@_\fR
arrays. That extra argument is appended to the original argument list
(i.e. is can always be accessed as \f(CW$_\fR[\-1]) and acts as a place-holder for
the original subroutine's return value.
.PP
In a pre-wrapper, \f(CW$_\fR[\-1] is \*(-- for obvious reasons \*(-- \f(CW\*(C`undef\*(C'\fR. However,
\&\f(CW$_\fR[\-1] may be assigned to in a pre-wrapper, in which case Hook::LexWrap
assumes that the original subroutine has been \*(L"pre-empted\*(R", and that
neither it, nor the corresponding post-wrapper, nor any wrappers that
were applied \fIbefore\fR the pre-empting pre-wrapper was installed, need
be run. Note that any post-wrappers that were installed after the
pre-empting pre-wrapper was installed \fIwill\fR still be called before the
original subroutine call returns.
.PP
In a post-wrapper, \f(CW$_\fR[\-1] contains the return value produced by the
wrapped subroutine. In a scalar return context, this value is the scalar
return value. In an list return context, this value is a reference to
the array of return values. \f(CW$_\fR[\-1] may be assigned to in a post-wrapper,
and this changes the return value accordingly.
.PP
Access to the arguments and return value is useful for implementing
techniques such as memoization:
.PP
.Vb 4
\&        my %cache;
\&        wrap fibonacci =>
\&                pre  => sub { $_[\-1] = $cache{$_[0]} if $cache{$_[0]} },
\&                post => sub { $cache{$_[0]} = $_[\-1] };
.Ve
.PP
or for converting arguments and return values in a consistent manner:
.PP
.Vb 5
\&        # set_temp expects and returns degrees Fahrenheit,
\&        # but we want to use Celsius
\&        wrap set_temp =>
\&                pre   => sub { splice @_, 0, 1, $_[0] * 1.8 + 32 },
\&                post  => sub { $_[\-1] = ($_[0] \- 32) / 1.8 };
.Ve
.SS "Lexically scoped wrappers"
.IX Subsection "Lexically scoped wrappers"
Normally, any wrappers installed by \f(CW\*(C`wrap\*(C'\fR remain attached to the 
subroutine until it is undefined. However, it is possible to make
specific wrappers lexically bound, so that they operate only until
the end of the scope in which they're created (or until some other
specific point in the code).
.PP
If \f(CW\*(C`wrap\*(C'\fR is called in a \fInon-void\fR context:
.PP
.Vb 1
\&        my $lexical = wrap \*(Aqsub_name\*(Aq, pre => \e&wrapper;
.Ve
.PP
it returns a special object corresponding to the particular wrapper being
placed around the original subroutine. When that object is destroyed
\&\*(-- when its container variable goes out of scope, or when its
reference count otherwise falls to zero (e.g. \f(CW\*(C`undef $lexical\*(C'\fR), or 
when it is explicitly destroyed (\f(CW\*(C`$lexical\->DESTROY\*(C'\fR) \*(--
the corresponding wrapper is removed from around
the original subroutine. Note, however, that all other wrappers around the
subroutine are preserved.
.SS "Anonymous wrappers"
.IX Subsection "Anonymous wrappers"
If the subroutine to be wrapped is passed as a reference (rather than by name
or by typeglob), \f(CW\*(C`wrap\*(C'\fR does not install the wrappers around the 
original subroutine. Instead it generates a new subroutine which acts
as if it were the original with those wrappers around it.
It then returns a reference to that new subroutine. Only calls to the original
through that wrapped reference invoke the wrappers. Direct by-name calls to
the original, or calls through another reference, do not.
.PP
If the original is subsequently wrapped by name, the anonymously wrapped
subroutine reference does not see those wrappers. In other words,
wrappers installed via a subroutine reference are completely independent
of those installed via the subroutine's name (or typeglob).
.PP
For example:
.PP
.Vb 1
\&        sub original { print "ray" }
\&
\&        # Wrap anonymously...
\&        my $anon_wrapped = wrap \e&original, pre => sub { print "do..." };
\&
\&        # Show effects...
\&        original();             # prints "ray"
\&        $anon_wrapped\->();      # prints "do..ray"
\&
\&        # Wrap nonymously...
\&        wrap *original,
\&                pre  => sub { print "fa.." },
\&                post => sub { print "..mi" };
\&
\&        # Show effects...
\&        original();             #   now prints "fa..ray..mi"
\&        $anon_wrapped\->();      # still prints "do...ray"
.Ve
.SH "DIAGNOSTICS"
.IX Header "DIAGNOSTICS"
.ie n .IP """Can\*(Aqt wrap non\-existent subroutine %s""" 4
.el .IP "\f(CWCan\*(Aqt wrap non\-existent subroutine %s\fR" 4
.IX Item "Cant wrap non-existent subroutine %s"
An attempt was made to wrap a subroutine that was not defined at the
point of wrapping.
.ie n .IP """\*(Aqpre\*(Aq value is not a subroutine reference""" 4
.el .IP "\f(CW\*(Aqpre\*(Aq value is not a subroutine reference\fR" 4
.IX Item "pre value is not a subroutine reference"
The value passed to \f(CW\*(C`wrap\*(C'\fR after the \f(CW\*(Aqpre\*(Aq\fR flag was not
a subroutine reference. Typically, someone forgot the \f(CW\*(C`sub\*(C'\fR on
the anonymous subroutine:
.Sp
.Vb 1
\&        wrap \*(Aqsubname\*(Aq, pre => { your_code_here() };
.Ve
.Sp
and Perl interpreted the last argument as a hash constructor.
.ie n .IP """\*(Aqpost\*(Aq value is not a subroutine reference""" 4
.el .IP "\f(CW\*(Aqpost\*(Aq value is not a subroutine reference\fR" 4
.IX Item "post value is not a subroutine reference"
The value passed to \f(CW\*(C`wrap\*(C'\fR after the \f(CW\*(Aqpost\*(Aq\fR flag was not
a subroutine reference.
.ie n .IP """Uselessly wrapped subroutine reference in void context"" (warning only)" 4
.el .IP "\f(CWUselessly wrapped subroutine reference in void context\fR (warning only)" 4
.IX Item "Uselessly wrapped subroutine reference in void context (warning only)"
When the subroutine to be wrapped is passed as a subroutine reference,
\&\f(CW\*(C`wrap\*(C'\fR does not install the wrapper around the original, but instead
returns a reference to a subroutine which wraps the original
(see \*(L"Anonymous wrappers\*(R").
.Sp
However, there's no point in doing this if you don't catch the resulting
subroutine reference.
.SH "BLAME"
.IX Header "BLAME"
Schwern made me do this (by implying it wasn't possible ;\-)
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Sub::Prepend
.SH "BUGS"
.IX Header "BUGS"
There are undoubtedly serious bugs lurking somewhere in code this funky :\-)
.PP
Bug reports and other feedback are most welcome.
.PP
Bugs may be submitted through the \s-1RT\s0 bug tracker <https://rt.cpan.org/Public/Dist/Display.html?Name=Hook-LexWrap>
(or bug\-Hook\-LexWrap@rt.cpan.org <mailto:bug-Hook-LexWrap@rt.cpan.org>).
.SH "AUTHOR"
.IX Header "AUTHOR"
Damian Conway <damian@conway.org>
.SH "CONTRIBUTORS"
.IX Header "CONTRIBUTORS"
.IP "\(bu" 4
Karen Etheridge <ether@cpan.org>
.IP "\(bu" 4
Alexandr Ciornii <alexchorny@gmail.com>
.IP "\(bu" 4
Father Chrysostomos <sprout@cpan.org>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is copyright (c) 2001 by Damian Conway.
.PP
This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.
