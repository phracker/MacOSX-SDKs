.\" Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Writer 3"
.TH Writer 3 "2014-06-05" "perl v5.30.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
XML::Writer \- Perl extension for writing XML documents.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&  use XML::Writer;
\&  use IO::File;
\&
\&  my $output = IO::File\->new(">output.xml");
\&
\&  my $writer = XML::Writer\->new(OUTPUT => $output);
\&  $writer\->startTag("greeting",
\&                    "class" => "simple");
\&  $writer\->characters("Hello, world!");
\&  $writer\->endTag("greeting");
\&  $writer\->end();
\&  $output\->close();
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
XML::Writer is a helper module for Perl programs that write an \s-1XML\s0
document.  The module handles all escaping for attribute values and
character data and constructs different types of markup, such as tags,
comments, and processing instructions.
.PP
By default, the module performs several well-formedness checks to
catch errors during output.  This behaviour can be extremely useful
during development and debugging, but it can be turned off for
production-grade code.
.PP
The module can operate either in regular mode in or Namespace
processing mode.  In Namespace mode, the module will generate
Namespace Declarations itself, and will perform additional checks on
the output.
.PP
Additional support is available for a simplified data mode with no
mixed content: newlines are automatically inserted around elements and
elements can optionally be indented based as their nesting level.
.SH "METHODS"
.IX Header "METHODS"
.SS "Writing \s-1XML\s0"
.IX Subsection "Writing XML"
.IP "new([$params])" 4
.IX Item "new([$params])"
Create a new XML::Writer object:
.Sp
.Vb 1
\&  my $writer = XML::Writer\->new(OUTPUT => $output, NEWLINES => 1);
.Ve
.Sp
Arguments are an anonymous hash array of parameters:
.RS 4
.IP "\s-1OUTPUT\s0" 4
.IX Item "OUTPUT"
An object blessed into IO::Handle or one of its subclasses (such as IO::File),
or a reference to a string, or any blessed object that has a \fBprint()\fR method;
if this parameter is not present, the module will write to standard output. If
a string reference is passed, it will capture the generated \s-1XML\s0 (as a string;
to get bytes use the \f(CW\*(C`Encode\*(C'\fR module).
.Sp
If the string \fIself\fR is passed, the output will be captured internally by the
object, and can be accessed via the \f(CW\*(C`to_string()\*(C'\fR method, or by calling the
object in a string context.
.Sp
.Vb 1
\&    my $writer = XML::Writer\->new( OUTPUT => \*(Aqself\*(Aq );
\&
\&    $writer\->dataElement( hello => \*(Aqworld\*(Aq );
\&
\&    print $writer\->to_string;  # outputs <hello>world</hello>
\&    print "$writer";           # ditto
.Ve
.IP "\s-1NAMESPACES\s0" 4
.IX Item "NAMESPACES"
A true (1) or false (0, undef) value; if this parameter is present and
its value is true, then the module will accept two-member array
reference in the place of element and attribute names, as in the
following example:
.Sp
.Vb 3
\&  my $rdfns = "http://www.w3.org/1999/02/22\-rdf\-syntax\-ns#";
\&  my $writer = XML::Writer\->new(NAMESPACES => 1);
\&  $writer\->startTag([$rdfns, "Description"]);
.Ve
.Sp
The first member of the array is a namespace \s-1URI,\s0 and the second part
is the local part of a qualified name.  The module will automatically
generate appropriate namespace declarations and will replace the \s-1URI\s0
part with a prefix.
.IP "\s-1PREFIX_MAP\s0" 4
.IX Item "PREFIX_MAP"
A hash reference; if this parameter is present and the module is
performing namespace processing (see the \s-1NAMESPACES\s0 parameter), then
the module will use this hash to look up preferred prefixes for
namespace URIs:
.Sp
.Vb 3
\&  my $rdfns = "http://www.w3.org/1999/02/22\-rdf\-syntax\-ns#";
\&  my $writer = XML::Writer\->new(NAMESPACES => 1,
\&                               PREFIX_MAP => {$rdfns => \*(Aqrdf\*(Aq});
.Ve
.Sp
The keys in the hash table are namespace URIs, and the values are the
associated prefixes.  If there is not a preferred prefix for the
namespace \s-1URI\s0 in this hash, then the module will automatically
generate prefixes of the form \*(L"_\|_NS1\*(R", \*(L"_\|_NS2\*(R", etc.
.Sp
To set the default namespace, use '' for the prefix.
.IP "\s-1FORCED_NS_DECLS\s0" 4
.IX Item "FORCED_NS_DECLS"
An array reference; if this parameter is present, the document element
will contain declarations for all the given namespace URIs.
Declaring namespaces in advance is particularly useful when a large
number of elements from a namespace are siblings, but don't share a direct
ancestor from the same namespace.
.IP "\s-1NEWLINES\s0" 4
.IX Item "NEWLINES"
A true or false value; if this parameter is present and its value is
true, then the module will insert an extra newline before the closing
delimiter of start, end, and empty tags to guarantee that the document
does not end up as a single, long line.  If the parameter is not
present, the module will not insert the newlines.
.IP "\s-1UNSAFE\s0" 4
.IX Item "UNSAFE"
A true or false value; if this parameter is present and its value is
true, then the module will skip most well-formedness error checking.
If the parameter is not present, the module will perform the
well-formedness error checking by default.  Turn off error checking at
your own risk!
.IP "\s-1DATA_MODE\s0" 4
.IX Item "DATA_MODE"
A true or false value; if this parameter is present and its value is
true, then the module will enter a special data mode, inserting
newlines automatically around elements and (unless \s-1UNSAFE\s0 is also
specified) reporting an error if any element has both characters and
elements as content.
.IP "\s-1DATA_INDENT\s0" 4
.IX Item "DATA_INDENT"
A numeric value or white space; if this parameter is present, it represents the
indent step for elements in data mode (it will be ignored when not in
data mode). If it is white space it will be repeated for each level of
indentation.
.IP "\s-1ENCODING\s0" 4
.IX Item "ENCODING"
A character encoding to use for the output; currently this must be one of
\&'utf\-8' or 'us\-ascii'.
If present, it will be used for the underlying character encoding and as the
default in the \s-1XML\s0 declaration.
All character data should be passed as Unicode strings when an encoding is
set.
.IP "\s-1CHECK_PRINT\s0" 4
.IX Item "CHECK_PRINT"
A true or false value; if this parameter is present and its value is
true, all prints to the underlying output will be checked for success. Failures
will cause a croak rather than being ignored.
.RE
.RS 4
.RE
.IP "\fBend()\fR" 4
.IX Item "end()"
Finish creating an \s-1XML\s0 document.  This method will check that the
document has exactly one document element, and that all start tags are
closed:
.Sp
.Vb 1
\&  $writer\->end();
.Ve
.Sp
If \fI\s-1OUTPUT\s0\fR as been set to \fIself\fR, \f(CW\*(C`end()\*(C'\fR will return the generated
document as well.
.ie n .IP "xmlDecl([$encoding, $standalone])" 4
.el .IP "xmlDecl([$encoding, \f(CW$standalone\fR])" 4
.IX Item "xmlDecl([$encoding, $standalone])"
Add an \s-1XML\s0 declaration to the beginning of an \s-1XML\s0 document.  The
version will always be \*(L"1.0\*(R".  If you provide a non-null encoding or
standalone argument, its value will appear in the declaration (any
non-null value for standalone except 'no' will automatically be
converted to 'yes'). If not given here, the encoding will be taken from the
\&\s-1ENCODING\s0 argument. Pass the empty string to suppress this behaviour.
.Sp
.Vb 1
\&  $writer\->xmlDecl("UTF\-8");
.Ve
.ie n .IP "doctype($name, [$publicId, $systemId])" 4
.el .IP "doctype($name, [$publicId, \f(CW$systemId\fR])" 4
.IX Item "doctype($name, [$publicId, $systemId])"
Add a \s-1DOCTYPE\s0 declaration to an \s-1XML\s0 document.  The declaration must
appear before the beginning of the root element.  If you provide a
publicId, you must provide a systemId as well, but you may provide
just a system \s-1ID\s0 by passing 'undef' for the publicId.
.Sp
.Vb 1
\&  $writer\->doctype("html");
.Ve
.IP "comment($text)" 4
.IX Item "comment($text)"
Add a comment to an \s-1XML\s0 document.  If the comment appears outside the
document element (either before the first start tag or after the last
end tag), the module will add a carriage return after it to improve
readability. In data mode, comments will be treated as empty tags:
.Sp
.Vb 1
\&  $writer\->comment("This is a comment");
.Ve
.ie n .IP "pi($target [, $data])" 4
.el .IP "pi($target [, \f(CW$data\fR])" 4
.IX Item "pi($target [, $data])"
Add a processing instruction to an \s-1XML\s0 document:
.Sp
.Vb 1
\&  $writer\->pi(\*(Aqxml\-stylesheet\*(Aq, \*(Aqhref="style.css" type="text/css"\*(Aq);
.Ve
.Sp
If the processing instruction appears outside the document element
(either before the first start tag or after the last end tag), the
module will add a carriage return after it to improve readability.
.Sp
The \f(CW$target\fR argument must be a single \s-1XML\s0 name.  If you provide the
\&\f(CW$data\fR argument, the module will insert its contents following the
\&\f(CW$target\fR argument, separated by a single space.
.ie n .IP "startTag($name [, $aname1 => $value1, ...])" 4
.el .IP "startTag($name [, \f(CW$aname1\fR => \f(CW$value1\fR, ...])" 4
.IX Item "startTag($name [, $aname1 => $value1, ...])"
Add a start tag to an \s-1XML\s0 document.  Any arguments after the element
name are assumed to be name/value pairs for attributes: the module
will escape all '&', '<', '>', and '"' characters in the attribute
values using the predefined \s-1XML\s0 entities:
.Sp
.Vb 3
\&  $writer\->startTag(\*(Aqdoc\*(Aq, \*(Aqversion\*(Aq => \*(Aq1.0\*(Aq,
\&                           \*(Aqstatus\*(Aq => \*(Aqdraft\*(Aq,
\&                           \*(Aqtopic\*(Aq => \*(AqAT&T\*(Aq);
.Ve
.Sp
All start tags must eventually have matching end tags.
.ie n .IP "emptyTag($name [, $aname1 => $value1, ...])" 4
.el .IP "emptyTag($name [, \f(CW$aname1\fR => \f(CW$value1\fR, ...])" 4
.IX Item "emptyTag($name [, $aname1 => $value1, ...])"
Add an empty tag to an \s-1XML\s0 document.  Any arguments after the element
name are assumed to be name/value pairs for attributes (see \fBstartTag()\fR
for details):
.Sp
.Vb 2
\&  $writer\->emptyTag(\*(Aqimg\*(Aq, \*(Aqsrc\*(Aq => \*(Aqportrait.jpg\*(Aq,
\&                           \*(Aqalt\*(Aq => \*(AqPortrait of Emma.\*(Aq);
.Ve
.IP "endTag([$name])" 4
.IX Item "endTag([$name])"
Add an end tag to an \s-1XML\s0 document.  The end tag must match the closest
open start tag, and there must be a matching and properly-nested end
tag for every start tag:
.Sp
.Vb 1
\&  $writer\->endTag(\*(Aqdoc\*(Aq);
.Ve
.Sp
If the \f(CW$name\fR argument is omitted, then the module will automatically
supply the name of the currently open element:
.Sp
.Vb 2
\&  $writer\->startTag(\*(Aqp\*(Aq);
\&  $writer\->endTag();
.Ve
.ie n .IP "dataElement($name, $data [, $aname1 => $value1, ...])" 4
.el .IP "dataElement($name, \f(CW$data\fR [, \f(CW$aname1\fR => \f(CW$value1\fR, ...])" 4
.IX Item "dataElement($name, $data [, $aname1 => $value1, ...])"
Print an entire element containing only character data.  This is
equivalent to
.Sp
.Vb 3
\&  $writer\->startTag($name [, $aname1 => $value1, ...]);
\&  $writer\->characters($data);
\&  $writer\->endTag($name);
.Ve
.IP "characters($data)" 4
.IX Item "characters($data)"
Add character data to an \s-1XML\s0 document.  All '<', '>', and '&'
characters in the \f(CW$data\fR argument will automatically be escaped using
the predefined \s-1XML\s0 entities:
.Sp
.Vb 2
\&  $writer\->characters("Here is the formula: ");
\&  $writer\->characters("a < 100 && a > 5");
.Ve
.Sp
You may invoke this method only within the document element
(i.e. after the first start tag and before the last end tag).
.Sp
In data mode, you must not use this method to add whitespace between
elements.
.IP "raw($data)" 4
.IX Item "raw($data)"
Print data completely unquoted and unchecked to the \s-1XML\s0 document.  For
example \f(CW\*(C`raw(\*(Aq<\*(Aq)\*(C'\fR will print a literal < character.  This
necessarily bypasses all well-formedness checking, and is therefore
only available in unsafe mode.
.Sp
This can sometimes be useful for printing entities which are defined
for your \s-1XML\s0 format but the module doesn't know about, for example
&nbsp; for \s-1XHTML.\s0
.IP "cdata($data)" 4
.IX Item "cdata($data)"
As \f(CW\*(C`characters()\*(C'\fR but writes the data quoted in a \s-1CDATA\s0 section, that
is, between <![CDATA[ and ]]>.  If the data to be written itself
contains ]]>, it will be written as several consecutive \s-1CDATA\s0
sections.
.ie n .IP "cdataElement($name, $data [, $aname1 => $value1, ...])" 4
.el .IP "cdataElement($name, \f(CW$data\fR [, \f(CW$aname1\fR => \f(CW$value1\fR, ...])" 4
.IX Item "cdataElement($name, $data [, $aname1 => $value1, ...])"
As \f(CW\*(C`dataElement()\*(C'\fR but the element content is written as one or more
\&\s-1CDATA\s0 sections (see \f(CW\*(C`cdata()\*(C'\fR).
.IP "setOutput($output)" 4
.IX Item "setOutput($output)"
Set the current output destination, as in the \s-1OUTPUT\s0 parameter for the
constructor.
.IP "\fBgetOutput()\fR" 4
.IX Item "getOutput()"
Return the current output destination, as in the \s-1OUTPUT\s0 parameter for
the constructor.
.IP "setDataMode($mode)" 4
.IX Item "setDataMode($mode)"
Enable or disable data mode, as in the \s-1DATA_MODE\s0 parameter for the
constructor.
.IP "\fBgetDataMode()\fR" 4
.IX Item "getDataMode()"
Return the current data mode, as in the \s-1DATA_MODE\s0 parameter for the
constructor.
.IP "setDataIndent($step)" 4
.IX Item "setDataIndent($step)"
Set the indent step for data mode, as in the \s-1DATA_INDENT\s0 parameter for
the constructor.
.IP "\fBgetDataIndent()\fR" 4
.IX Item "getDataIndent()"
Return the indent step for data mode, as in the \s-1DATA_INDENT\s0 parameter
for the constructor.
.SS "Querying \s-1XML\s0"
.IX Subsection "Querying XML"
.IP "in_element($name)" 4
.IX Item "in_element($name)"
Return a true value if the most recent open element matches \f(CW$name:\fR
.Sp
.Vb 5
\&  if ($writer\->in_element(\*(Aqdl\*(Aq)) {
\&    $writer\->startTag(\*(Aqdt\*(Aq);
\&  } else {
\&    $writer\->startTag(\*(Aqli\*(Aq);
\&  }
.Ve
.IP "within_element($name)" 4
.IX Item "within_element($name)"
Return a true value if any open element matches \f(CW$name:\fR
.Sp
.Vb 5
\&  if ($writer\->within_element(\*(Aqbody\*(Aq)) {
\&    $writer\->startTag(\*(Aqh1\*(Aq);
\&  } else {
\&    $writer\->startTag(\*(Aqtitle\*(Aq);
\&  }
.Ve
.IP "\fBcurrent_element()\fR" 4
.IX Item "current_element()"
Return the name of the currently open element:
.Sp
.Vb 1
\&  my $name = $writer\->current_element();
.Ve
.Sp
This is the equivalent of
.Sp
.Vb 1
\&  my $name = $writer\->ancestor(0);
.Ve
.IP "ancestor($n)" 4
.IX Item "ancestor($n)"
Return the name of the nth ancestor, where \f(CW$n\fR=0 for the current open
element.
.SS "Additional Namespace Support"
.IX Subsection "Additional Namespace Support"
As of 0.510, these methods may be used while writing a document.
.ie n .IP "addPrefix($uri, $prefix)" 4
.el .IP "addPrefix($uri, \f(CW$prefix\fR)" 4
.IX Item "addPrefix($uri, $prefix)"
Add a preferred mapping between a Namespace \s-1URI\s0 and a prefix.  See
also the \s-1PREFIX_MAP\s0 constructor parameter.
.Sp
To set the default namespace, omit the \f(CW$prefix\fR parameter or set it to
\&''.
.IP "removePrefix($uri)" 4
.IX Item "removePrefix($uri)"
Remove a preferred mapping between a Namespace \s-1URI\s0 and a prefix.
.IP "forceNSDecl($uri)" 4
.IX Item "forceNSDecl($uri)"
Indicate that a namespace declaration for this \s-1URI\s0 should be included
with the next element to be started.
.SH "ERROR REPORTING"
.IX Header "ERROR REPORTING"
With the default settings, the XML::Writer module can detect several
basic \s-1XML\s0 well-formedness errors:
.IP "\(bu" 4
Lack of a (top-level) document element, or multiple document elements.
.IP "\(bu" 4
Unclosed start tags.
.IP "\(bu" 4
Misplaced delimiters in the contents of processing instructions or
comments.
.IP "\(bu" 4
Misplaced or duplicate \s-1XML\s0 declaration(s).
.IP "\(bu" 4
Misplaced or duplicate \s-1DOCTYPE\s0 declaration(s).
.IP "\(bu" 4
Mismatch between the document type name in the \s-1DOCTYPE\s0 declaration and
the name of the document element.
.IP "\(bu" 4
Mismatched start and end tags.
.IP "\(bu" 4
Attempts to insert character data outside the document element.
.IP "\(bu" 4
Duplicate attributes with the same name.
.PP
During Namespace processing, the module can detect the following
additional errors:
.IP "\(bu" 4
Attempts to use \s-1PI\s0 targets or element or attribute names containing a
colon.
.IP "\(bu" 4
Attempts to use attributes with names beginning \*(L"xmlns\*(R".
.PP
To ensure full error detection, a program must also invoke the end
method when it has finished writing a document:
.PP
.Vb 4
\&  $writer\->startTag(\*(Aqgreeting\*(Aq);
\&  $writer\->characters("Hello, world!");
\&  $writer\->endTag(\*(Aqgreeting\*(Aq);
\&  $writer\->end();
.Ve
.PP
This error reporting can catch many hidden bugs in Perl programs that
create \s-1XML\s0 documents; however, if necessary, it can be turned off by
providing an \s-1UNSAFE\s0 parameter:
.PP
.Vb 1
\&  my $writer = XML::Writer\->new(OUTPUT => $output, UNSAFE => 1);
.Ve
.SS "\s-1PRINTING OUTPUT\s0"
.IX Subsection "PRINTING OUTPUT"
If \fI\s-1OUTPUT\s0\fR has been set to \fIself\fR and the object has been called in
a string context, it'll return the xml document.
.IP "to_string" 4
.IX Item "to_string"
If \fI\s-1OUTPUT\s0\fR has been set to \fIself\fR, calls an implicit \f(CW\*(C`end()\*(C'\fR on the
document and prints it. Dies if \fI\s-1OUTPUT\s0\fR has been set to anything else.
.SH "AUTHOR"
.IX Header "AUTHOR"
David Megginson <david@megginson.com>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright (c) 1999 by Megginson Technologies.
.PP
Copyright (c) 2003 Ed Avis <ed@membled.com>
.PP
Copyright (c) 2004\-2010 Joseph Walton <joe@kafsemo.org>
.PP
Redistribution and use in source and compiled forms, with or without
modification, are permitted under any circumstances.  No warranty.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
XML::Parser
