.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Class::Tiny 3"
.TH Class::Tiny 3 "2013-11-28" "perl v5.18.4" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Class::Tiny \- Minimalist class construction
.SH "VERSION"
.IX Header "VERSION"
version 0.014
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
In \fIPerson.pm\fR:
.PP
.Vb 1
\&  package Person;
\&
\&  use Class::Tiny qw( name );
\&
\&  1;
.Ve
.PP
In \fIEmployee.pm\fR:
.PP
.Vb 2
\&  package Employee;
\&  use parent \*(AqPerson\*(Aq;
\&
\&  use Class::Tiny qw( ssn ), {
\&    timestamp => sub { time }   # attribute with default
\&  };
\&
\&  1;
.Ve
.PP
In \fIexample.pl\fR:
.PP
.Vb 1
\&  use Employee;
\&
\&  my $obj = Employee\->new( name => "Larry", ssn => "111\-22\-3333" );
\&
\&  # unknown attributes are fatal:
\&  eval { Employee\->new( name => "Larry", OS => "Linux" ) };
\&  die "Error creating Employee: $@" if $@;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module offers a minimalist class construction kit in around 120 lines of
code.  Here is a list of features:
.IP "\(bu" 4
defines attributes via import arguments
.IP "\(bu" 4
generates read-write accessors
.IP "\(bu" 4
supports lazy attribute defaults
.IP "\(bu" 4
supports custom accessors
.IP "\(bu" 4
superclass provides a standard \f(CW\*(C`new\*(C'\fR constructor
.IP "\(bu" 4
\&\f(CW\*(C`new\*(C'\fR takes a hash reference or list of key/value pairs
.IP "\(bu" 4
\&\f(CW\*(C`new\*(C'\fR has heuristics to catch constructor attribute typos
.IP "\(bu" 4
\&\f(CW\*(C`new\*(C'\fR calls \f(CW\*(C`BUILD\*(C'\fR for each class from parent to child
.IP "\(bu" 4
superclass provides a \f(CW\*(C`DESTROY\*(C'\fR method
.IP "\(bu" 4
\&\f(CW\*(C`DESTROY\*(C'\fR calls \f(CW\*(C`DEMOLISH\*(C'\fR for each class from child to parent
.PP
Multiple-inheritance is possible, with superclass order determined via
mro::get_linear_isa.
.PP
It uses no non-core modules for any recent Perl. On Perls older than v5.10 it
requires MRO::Compat. On Perls older than v5.14, it requires
Devel::GlobalDestruction.
.SH "USAGE"
.IX Header "USAGE"
.SS "Defining attributes"
.IX Subsection "Defining attributes"
Define attributes as a list of import arguments:
.PP
.Vb 1
\&    package Foo::Bar;
\&
\&    use Class::Tiny qw(
\&        name
\&        id
\&        height
\&        weight
\&    );
.Ve
.PP
For each attribute, a read-write accessor is created unless a subroutine of that
name already exists:
.PP
.Vb 2
\&    $obj\->name;               # getter
\&    $obj\->name( "John Doe" ); # setter
.Ve
.PP
Attribute names must be valid subroutine identifiers or an exception will
be thrown.
.PP
You can specify lazy defaults by defining attributes with a hash reference.
Keys define attribute names and values are constants or code references that
will be evaluated when the attribute is first accessed if no value has been
set.  The object is passed as an argument to a code reference.
.PP
.Vb 1
\&    package Foo::WithDefaults;
\&
\&    use Class::Tiny qw/name id/, {
\&        title     => \*(AqPeon\*(Aq,
\&        skills    => sub { [] },
\&        hire_date => sub { $_[0]\->_build_hire_date },
\&    };
.Ve
.PP
When subclassing, if multiple accessors of the same name exist in different
classes, any default (or lack of default) is determined by standard
method resolution order.
.PP
To make your own custom accessors, just pre-declare the method name before
loading Class::Tiny:
.PP
.Vb 1
\&    package Foo::Bar;
\&
\&    use subs \*(Aqid\*(Aq;
\&
\&    use Class::Tiny qw( name id );
\&
\&    sub id { ... }
.Ve
.PP
By declaring \f(CW\*(C`id\*(C'\fR also with Class::Tiny, you include it in the list of known
attributes for introspection.  Default values will not be set for custom
accessors unless you handle that yourself.
.SS "Class::Tiny::Object is your base class"
.IX Subsection "Class::Tiny::Object is your base class"
If your class \fBdoes not\fR already inherit from some class, then
Class::Tiny::Object will be added to your \f(CW@ISA\fR to provide \f(CW\*(C`new\*(C'\fR and
\&\f(CW\*(C`DESTROY\*(C'\fR.
.PP
If your class \fBdoes\fR inherit from something, then no additional inheritance is
set up.  If the parent subclasses Class::Tiny::Object, then all is well.  If
not, then you'll get accessors set up but no constructor or destructor. Don't
do that unless you really have a special need for it.
.PP
Define subclasses as normal.  It's best to define them with base, parent
or superclass before defining attributes with Class::Tiny so the \f(CW@ISA\fR
array is already populated at compile-time:
.PP
.Vb 1
\&    package Foo::Bar::More;
\&
\&    use parent \*(AqFoo::Bar\*(Aq;
\&
\&    use Class::Tiny qw( shoe_size );
.Ve
.SS "Object construction"
.IX Subsection "Object construction"
If your class inherits from Class::Tiny::Object (as it should if you followed
the advice above), it provides the \f(CW\*(C`new\*(C'\fR constructor for you.
.PP
Objects can be created with attributes given as a hash reference or as a list
of key/value pairs:
.PP
.Vb 1
\&    $obj = Foo::Bar\->new( name => "David" );
\&
\&    $obj = Foo::Bar\->new( { name => "David" } );
.Ve
.PP
If a reference is passed as a single argument, it must be able to be
dereferenced as a hash or an exception is thrown.  A shallow copy is made of
the reference provided.
.PP
In order to help catch typos in constructor arguments, any argument that it is
not also a valid method (e.g. an accessor or other method) will result in a
fatal exception.  This is not perfect, but should catch typical transposition
typos. Also see \*(L"\s-1BUILD\*(R"\s0 for how to explicitly hide non-attribute, non-method
arguments if desired.
.SS "\s-1BUILD\s0"
.IX Subsection "BUILD"
If your class or any superclass defines a \f(CW\*(C`BUILD\*(C'\fR method, it will be called
by the constructor from the furthest parent class down to the child class after
the object has been created.
.PP
It is passed the constructor arguments as a hash reference.  The return value
is ignored.  Use \f(CW\*(C`BUILD\*(C'\fR for validation or setting default values.
.PP
.Vb 5
\&    sub BUILD {
\&        my ($self, $args) = @_;
\&        $self\->foo(42) unless defined $self\->foo;
\&        croak "Foo must be non\-negative" if $self\->foo < 0;
\&    }
.Ve
.PP
If you want to hide a non-attribute constructor argument from validation,
delete it from the passed-in argument hash reference.
.PP
.Vb 2
\&    sub BUILD {
\&        my ($self, $args) = @_;
\&
\&        if ( delete $args\->{do_something_special} ) {
\&            ...
\&        }
\&    }
.Ve
.PP
The argument reference is a copy, so deleting elements won't affect data in the
object. You have to delete it from both if that's what you want.
.PP
.Vb 2
\&    sub BUILD {
\&        my ($self, $args) = @_;
\&
\&        if ( delete $args\->{do_something_special} ) {
\&            delete $self\->{do_something_special};
\&            ...
\&        }
\&    }
.Ve
.SS "\s-1DEMOLISH\s0"
.IX Subsection "DEMOLISH"
Class::Tiny provides a \f(CW\*(C`DESTROY\*(C'\fR method.  If your class or any superclass
defines a \f(CW\*(C`DEMOLISH\*(C'\fR method, they will be called from the child class to the
furthest parent class during object destruction.  It is provided a single
boolean argument indicating whether Perl is in global destruction.  Return
values and errors are ignored.
.PP
.Vb 4
\&    sub DEMOLISH {
\&        my ($self, $global_destruct) = @_;
\&        $self\->cleanup();
\&    }
.Ve
.SS "Introspection and internals"
.IX Subsection "Introspection and internals"
You can retrieve an unsorted list of valid attributes known to Class::Tiny
for a class and its superclasses with the \f(CW\*(C`get_all_attributes_for\*(C'\fR class
method.
.PP
.Vb 2
\&    my @attrs = Class::Tiny\->get_all_attributes_for("Employee");
\&    # returns qw/name ssn timestamp/
.Ve
.PP
Likewise, a hash reference of all valid attributes and default values (or code
references) may be retrieved with the \f(CW\*(C`get_all_attribute_defaults_for\*(C'\fR class
method.  Any attributes without a default will be \f(CW\*(C`undef\*(C'\fR.
.PP
.Vb 6
\&    my $def = Class::Tiny\->get_all_attribute_defaults_for("Employee");
\&    # returns {
\&    #   name => undef,
\&    #   ssn => undef
\&    #   timestamp => $coderef
\&    # }
.Ve
.PP
The \f(CW\*(C`import\*(C'\fR method uses two class methods, \f(CW\*(C`prepare_class\*(C'\fR and
\&\f(CW\*(C`create_attributes\*(C'\fR to set up the \f(CW@ISA\fR array and attributes.  Anyone
attempting to extend Class::Tiny itself should use these instead of mocking up
a call to \f(CW\*(C`import\*(C'\fR.
.PP
When the first object is created, linearized \f(CW@ISA\fR and various subroutines
references are cached for speed.  Ensure that all inheritance and methods are
in place before creating objects. (You don't want to be changing that once you
create objects anyway, right?)
.SH "RATIONALE"
.IX Header "RATIONALE"
.SS "Why this instead of Object::Tiny or Class::Accessor or something else?"
.IX Subsection "Why this instead of Object::Tiny or Class::Accessor or something else?"
I wanted something so simple that it could potentially be used by core Perl
modules I help maintain (or hope to write), most of which either use
Class::Struct or roll-their-own \s-1OO\s0 framework each time.
.PP
Object::Tiny and Object::Tiny::RW were close to what I wanted, but
lacking some features I deemed necessary, and their maintainers have an even
more strict philosophy against feature creep than I have.
.PP
I also considered Class::Accessor, which has been around a long time and is
heavily used, but it, too, lacked features I wanted and did things in ways I
considered poor design.
.PP
I looked for something else on \s-1CPAN,\s0 but after checking a dozen class creators
I realized I could implement exactly what I wanted faster than I could search
\&\s-1CPAN\s0 for something merely sufficient.
.PP
In general, compared to most things on \s-1CPAN \s0(other than Object::Tiny),
Class::Tiny is smaller in implementation and simpler in \s-1API.\s0
.PP
Specifically, here is how Class::Tiny (\*(L"C::T\*(R") compares to Object::Tiny
(\*(L"O::T\*(R") and Class::Accessor (\*(L"C::A\*(R"):
.PP
.Vb 11
\& FEATURE                            C::T    O::T      C::A
\& \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\& attributes defined via import      yes     yes       no
\& read/write accessors               yes     no        yes
\& lazy attribute defaults            yes     no        no
\& provides new                       yes     yes       yes
\& provides DESTROY                   yes     no        no
\& new takes either hashref or list   yes     no (list) no (hash)
\& new validates arguments            yes     no        no
\& Moo(se)\-like BUILD/DEMOLISH        yes     no        no
\& no extraneous methods via @ISA     yes     yes       no
.Ve
.SS "Why this instead of Moose or Moo?"
.IX Subsection "Why this instead of Moose or Moo?"
Moose and Moo are both excellent \s-1OO\s0 frameworks.  Moose offers a powerful
meta-object protocol (\s-1MOP\s0), but is slow to start up and has about 30 non-core
dependencies including \s-1XS\s0 modules.  Moo is faster to start up and has about 10
pure Perl dependencies but provides no true \s-1MOP,\s0 relying instead on its ability
to transparently upgrade Moo to Moose when Moose's full feature set is
required.
.PP
By contrast, Class::Tiny has no \s-1MOP\s0 and has \fBzero\fR non-core dependencies for
Perls in the support window.  It has far less code, less
complexity and no learning curve. If you don't need or can't afford what Moo or
Moose offer, this is intended to be a reasonable fallback.
.PP
That said, Class::Tiny offers Moose-like conventions for things like \f(CW\*(C`BUILD\*(C'\fR
and \f(CW\*(C`DEMOLISH\*(C'\fR for some minimal interoperability and an easier upgrade path.
.SH "SUPPORT"
.IX Header "SUPPORT"
.SS "Bugs / Feature Requests"
.IX Subsection "Bugs / Feature Requests"
Please report any bugs or feature requests through the issue tracker
at <https://github.com/dagolden/Class\-Tiny/issues>.
You will be notified automatically of any progress on your issue.
.SS "Source Code"
.IX Subsection "Source Code"
This is open source software.  The code repository is available for
public review and contribution under the terms of the license.
.PP
<https://github.com/dagolden/Class\-Tiny>
.PP
.Vb 1
\&  git clone https://github.com/dagolden/Class\-Tiny.git
.Ve
.SH "AUTHOR"
.IX Header "AUTHOR"
David Golden <dagolden@cpan.org>
.SH "CONTRIBUTORS"
.IX Header "CONTRIBUTORS"
.IP "\(bu" 4
Dagfinn Ilmari Mannsa\*oker <ilmari@ilmari.org>
.IP "\(bu" 4
Gelu Lupas <gelu@devnull.ro>
.IP "\(bu" 4
Karen Etheridge <ether@cpan.org>
.IP "\(bu" 4
Matt S Trout <mstrout@cpan.org>
.IP "\(bu" 4
Olivier Mengue\*' <dolmen@cpan.org>
.IP "\(bu" 4
Toby Inkster <tobyink@cpan.org>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is Copyright (c) 2013 by David Golden.
.PP
This is free software, licensed under:
.PP
.Vb 1
\&  The Apache License, Version 2.0, January 2004
.Ve
