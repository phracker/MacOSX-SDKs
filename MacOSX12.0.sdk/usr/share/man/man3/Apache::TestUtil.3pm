.\" Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Apache::TestUtil 3"
.TH Apache::TestUtil 3 "2015-06-18" "perl v5.30.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Apache::TestUtil \- Utility functions for writing tests
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&  use Apache::Test;
\&  use Apache::TestUtil;
\&
\&  ok t_cmp("foo", "foo", "sanity check");
\&  t_write_file("filename", @content);
\&  my $fh = t_open_file($filename);
\&  t_mkdir("/foo/bar");
\&  t_rmtree("/foo/bar");
\&  t_is_equal($a, $b);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\f(CW\*(C`Apache::TestUtil\*(C'\fR automatically exports a number of functions useful
in writing tests.
.PP
All the files and directories created using the functions from this
package will be automatically destroyed at the end of the program
execution (via \s-1END\s0 block). You should not use these functions other
than from within tests which should cleanup all the created
directories and files at the end of the test.
.SH "FUNCTIONS"
.IX Header "FUNCTIONS"
.IP "\fBt_cmp()\fR" 4
.IX Item "t_cmp()"
.Vb 1
\&  t_cmp($received, $expected, $comment);
.Ve
.Sp
\&\fBt_cmp()\fR prints the values of \fI\f(CI$comment\fI\fR, \fI\f(CI$expected\fI\fR and
\&\fI\f(CI$received\fI\fR. e.g.:
.Sp
.Vb 1
\&  t_cmp(1, 1, "1 == 1?");
.Ve
.Sp
prints:
.Sp
.Vb 3
\&  # testing : 1 == 1?
\&  # expected: 1
\&  # received: 1
.Ve
.Sp
then it returns the result of comparison of the \fI\f(CI$expected\fI\fR and the
\&\fI\f(CI$received\fI\fR variables. Usually, the return value of this function is
fed directly to the \fBok()\fR function, like this:
.Sp
.Vb 1
\&  ok t_cmp(1, 1, "1 == 1?");
.Ve
.Sp
the third argument (\fI\f(CI$comment\fI\fR) is optional, mostly useful for
telling what the comparison is trying to do.
.Sp
It is valid to use \f(CW\*(C`undef\*(C'\fR as an expected value. Therefore:
.Sp
.Vb 2
\&  my $foo;
\&  t_cmp(undef, $foo, "undef == undef?");
.Ve
.Sp
will return a \fItrue\fR value.
.Sp
You can compare any two data-structures with \fBt_cmp()\fR. Just make sure
that if you pass non-scalars, you have to pass their references. The
datastructures can be deeply nested. For example you can compare:
.Sp
.Vb 3
\&  t_cmp({1 => [2..3,{5..8}], 4 => [5..6]},
\&        {1 => [2..3,{5..8}], 4 => [5..6]},
\&        "hash of array of hashes");
.Ve
.Sp
You can also compare the second argument against the first as a
regex. Use the \f(CW\*(C`qr//\*(C'\fR function in the second argument. For example:
.Sp
.Vb 1
\&  t_cmp("abcd", qr/^abc/, "regex compare");
.Ve
.Sp
will do:
.Sp
.Vb 1
\&  "abcd" =~ /^abc/;
.Ve
.Sp
This function is exported by default.
.IP "\fBt_filepath_cmp()\fR" 4
.IX Item "t_filepath_cmp()"
This function is used to compare two filepaths via \fBt_cmp()\fR.
For non\-Win32, it simply uses \fBt_cmp()\fR for the comparison,
but for Win32, \fBWin32::GetLongPathName()\fR is invoked to convert
the first two arguments to their \s-1DOS\s0 long pathname. This is useful
when there is a possibility the two paths being compared
are not both represented by their long or short pathname.
.Sp
This function is exported by default.
.IP "\fBt_debug()\fR" 4
.IX Item "t_debug()"
.Vb 2
\&  t_debug("testing feature foo");
\&  t_debug("test", [1..3], 5, {a=>[1..5]});
.Ve
.Sp
\&\fBt_debug()\fR prints out any datastructure while prepending \f(CW\*(C`#\*(C'\fR at the
beginning of each line, to make the debug printouts comply with
\&\f(CW\*(C`Test::Harness\*(C'\fR's requirements. This function should be always used
for debug prints, since if in the future the debug printing will
change (e.g. redirected into a file) your tests won't need to be
changed.
.Sp
the special global variable \f(CW$Apache::TestUtil::DEBUG_OUTPUT\fR can
be used to redirect the output from \fBt_debug()\fR and related calls
such as \fBt_write_file()\fR.  for example, from a server-side test
you would probably need to redirect it to \s-1STDERR:\s0
.Sp
.Vb 2
\&  sub handler {
\&    plan $r, tests => 1;
\&
\&    local $Apache::TestUtil::DEBUG_OUTPUT = \e*STDERR;
\&
\&    t_write_file(\*(Aq/tmp/foo\*(Aq, \*(Aqbar\*(Aq);
\&    ...
\&  }
.Ve
.Sp
left to its own devices, \fBt_debug()\fR will collide with the standard
\&\s-1HTTP\s0 protocol during server-side tests, resulting in a situation
both confusing difficult to debug.  but \s-1STDOUT\s0 is left as the
default, since you probably don't want debug output under normal
circumstances unless running under verbose mode.
.Sp
This function is exported by default.
.IP "\fBt_write_test_lib()\fR" 4
.IX Item "t_write_test_lib()"
.Vb 1
\&  t_write_test_lib($filename, @lines)
.Ve
.Sp
\&\fBt_write_test_lib()\fR creates a new file at \fI\f(CI$filename\fI\fR or overwrites
the existing file with the content passed in \fI\f(CI@lines\fI\fR.  The file
is created in a temporary directory which is added to \f(CW@INC\fR at
test configuration time.  It is intended to be used for creating
temporary packages for testing which can be modified at run time,
see the Apache::Reload unit tests for an example.
.IP "\fBt_write_file()\fR" 4
.IX Item "t_write_file()"
.Vb 1
\&  t_write_file($filename, @lines);
.Ve
.Sp
\&\fBt_write_file()\fR creates a new file at \fI\f(CI$filename\fI\fR or overwrites the
existing file with the content passed in \fI\f(CI@lines\fI\fR. If only the
\&\fI\f(CI$filename\fI\fR is passed, an empty file will be created.
.Sp
If parent directories of \f(CW$filename\fR don't exist they will be
automagically created.
.Sp
The generated file will be automatically deleted at the end of the
program's execution.
.Sp
This function is exported by default.
.IP "\fBt_append_file()\fR" 4
.IX Item "t_append_file()"
.Vb 1
\&  t_append_file($filename, @lines);
.Ve
.Sp
\&\fBt_append_file()\fR is similar to \fBt_write_file()\fR, but it doesn't clobber
existing files and appends \f(CW@lines\fR to the end of the file. If the
file doesn't exist it will create it.
.Sp
If parent directories of \f(CW$filename\fR don't exist they will be
automagically created.
.Sp
The generated file will be registered to be automatically deleted at
the end of the program's execution, only if the file was created by
\&\fBt_append_file()\fR.
.Sp
This function is exported by default.
.IP "\fBt_write_shell_script()\fR" 4
.IX Item "t_write_shell_script()"
.Vb 1
\&  Apache::TestUtil::t_write_shell_script($filename, @lines);
.Ve
.Sp
Similar to \fBt_write_file()\fR but creates a portable shell/batch
script. The created filename is constructed from \f(CW$filename\fR and an
appropriate extension automatically selected according to the platform
the code is running under.
.Sp
It returns the extension of the created file.
.IP "\fBt_write_perl_script()\fR" 4
.IX Item "t_write_perl_script()"
.Vb 1
\&  Apache::TestUtil::t_write_perl_script($filename, @lines);
.Ve
.Sp
Similar to \fBt_write_file()\fR but creates a executable Perl script with
correctly set shebang line.
.IP "\fBt_open_file()\fR" 4
.IX Item "t_open_file()"
.Vb 1
\&  my $fh = t_open_file($filename);
.Ve
.Sp
\&\fBt_open_file()\fR opens a file \fI\f(CI$filename\fI\fR for writing and returns the
file handle to the opened file.
.Sp
If parent directories of \f(CW$filename\fR don't exist they will be
automagically created.
.Sp
The generated file will be automatically deleted at the end of the
program's execution.
.Sp
This function is exported by default.
.IP "\fBt_mkdir()\fR" 4
.IX Item "t_mkdir()"
.Vb 1
\&  t_mkdir($dirname);
.Ve
.Sp
\&\fBt_mkdir()\fR creates a directory \fI\f(CI$dirname\fI\fR. The operation will fail if
the parent directory doesn't exist.
.Sp
If parent directories of \f(CW$dirname\fR don't exist they will be
automagically created.
.Sp
The generated directory will be automatically deleted at the end of
the program's execution.
.Sp
This function is exported by default.
.IP "\fBt_rmtree()\fR" 4
.IX Item "t_rmtree()"
.Vb 1
\&  t_rmtree(@dirs);
.Ve
.Sp
\&\fBt_rmtree()\fR deletes the whole directories trees passed in \fI\f(CI@dirs\fI\fR.
.Sp
This function is exported by default.
.IP "\fBt_chown()\fR" 4
.IX Item "t_chown()"
.Vb 1
\&  Apache::TestUtil::t_chown($file);
.Ve
.Sp
Change ownership of \f(CW$file\fR to the test's \fIUser\fR/\fIGroup\fR.  This
function is noop on platforms where \fBchown\fR\|(2) is unsupported
(e.g. Win32).
.IP "\fBt_is_equal()\fR" 4
.IX Item "t_is_equal()"
.Vb 1
\&  t_is_equal($a, $b);
.Ve
.Sp
\&\fBt_is_equal()\fR compares any two datastructures and returns 1 if they are
exactly the same, otherwise 0. The datastructures can be nested
hashes, arrays, scalars, undefs or a combination of any of these.  See
\&\fBt_cmp()\fR for an example.
.Sp
If \f(CW$b\fR is a regex reference, the regex comparison \f(CW\*(C`$a =~ $b\*(C'\fR is
performed. For example:
.Sp
.Vb 1
\&  t_is_equal($server_version, qr{^Apache});
.Ve
.Sp
If comparing non-scalars make sure to pass the references to the
datastructures.
.Sp
This function is exported by default.
.IP "\fBt_server_log_error_is_expected()\fR" 4
.IX Item "t_server_log_error_is_expected()"
If the handler's execution results in an error or a warning logged to
the \fIerror_log\fR file which is expected, it's a good idea to have a
disclaimer printed before the error itself, so one can tell real
problems with tests from expected errors. For example when testing how
the package behaves under error conditions the \fIerror_log\fR file might
be loaded with errors, most of which are expected.
.Sp
For example if a handler is about to generate a run-time error, this
function can be used as:
.Sp
.Vb 8
\&  use Apache::TestUtil;
\&  ...
\&  sub handler {
\&      my $r = shift;
\&      ...
\&      t_server_log_error_is_expected();
\&      die "failed because ...";
\&  }
.Ve
.Sp
After running this handler the \fIerror_log\fR file will include:
.Sp
.Vb 2
\&  *** The following error entry is expected and harmless ***
\&  [Tue Apr 01 14:00:21 2003] [error] failed because ...
.Ve
.Sp
When more than one entry is expected, an optional numerical argument,
indicating how many entries to expect, can be passed. For example:
.Sp
.Vb 1
\&  t_server_log_error_is_expected(2);
.Ve
.Sp
will generate:
.Sp
.Vb 1
\&  *** The following 2 error entries are expected and harmless ***
.Ve
.Sp
If the error is generated at compile time, the logging must be done in
the \s-1BEGIN\s0 block at the very beginning of the file:
.Sp
.Vb 5
\&  BEGIN {
\&      use Apache::TestUtil;
\&      t_server_log_error_is_expected();
\&  }
\&  use DOES_NOT_exist;
.Ve
.Sp
After attempting to run this handler the \fIerror_log\fR file will
include:
.Sp
.Vb 3
\&  *** The following error entry is expected and harmless ***
\&  [Tue Apr 01 14:04:49 2003] [error] Can\*(Aqt locate "DOES_NOT_exist.pm"
\&  in @INC (@INC contains: ...
.Ve
.Sp
Also see \f(CW\*(C`t_server_log_warn_is_expected()\*(C'\fR which is similar but used
for warnings.
.Sp
This function is exported by default.
.IP "\fBt_server_log_warn_is_expected()\fR" 4
.IX Item "t_server_log_warn_is_expected()"
\&\f(CW\*(C`t_server_log_warn_is_expected()\*(C'\fR generates a disclaimer for expected
warnings.
.Sp
See the explanation for \f(CW\*(C`t_server_log_error_is_expected()\*(C'\fR for more
details.
.Sp
This function is exported by default.
.IP "\fBt_client_log_error_is_expected()\fR" 4
.IX Item "t_client_log_error_is_expected()"
\&\f(CW\*(C`t_client_log_error_is_expected()\*(C'\fR generates a disclaimer for
expected errors. But in contrast to
\&\f(CW\*(C`t_server_log_error_is_expected()\*(C'\fR called by the client side of the
script.
.Sp
See the explanation for \f(CW\*(C`t_server_log_error_is_expected()\*(C'\fR for more
details.
.Sp
For example the following client script fails to find the handler:
.Sp
.Vb 3
\&  use Apache::Test;
\&  use Apache::TestUtil;
\&  use Apache::TestRequest qw(GET);
\&
\&  plan tests => 1;
\&
\&  t_client_log_error_is_expected();
\&  my $url = "/error_document/cannot_be_found";
\&  my $res = GET($url);
\&  ok t_cmp(404, $res\->code, "test 404");
.Ve
.Sp
After running this test the \fIerror_log\fR file will include an entry
similar to the following snippet:
.Sp
.Vb 3
\&  *** The following error entry is expected and harmless ***
\&  [Tue Apr 01 14:02:55 2003] [error] [client 127.0.0.1]
\&  File does not exist: /tmp/test/t/htdocs/error
.Ve
.Sp
When more than one entry is expected, an optional numerical argument,
indicating how many entries to expect, can be passed. For example:
.Sp
.Vb 1
\&  t_client_log_error_is_expected(2);
.Ve
.Sp
will generate:
.Sp
.Vb 1
\&  *** The following 2 error entries are expected and harmless ***
.Ve
.Sp
This function is exported by default.
.IP "\fBt_client_log_warn_is_expected()\fR" 4
.IX Item "t_client_log_warn_is_expected()"
\&\f(CW\*(C`t_client_log_warn_is_expected()\*(C'\fR generates a disclaimer for expected
warnings on the client side.
.Sp
See the explanation for \f(CW\*(C`t_client_log_error_is_expected()\*(C'\fR for more
details.
.Sp
This function is exported by default.
.IP "t_catfile('a', 'b', 'c')" 4
.IX Item "t_catfile('a', 'b', 'c')"
This function is essentially \f(CW\*(C`File::Spec\->catfile\*(C'\fR, but
on Win32 will use \f(CW\*(C`Win32::GetLongpathName()\*(C'\fR to convert the
result to a long path name (if the result is an absolute file).
The function is not exported by default.
.IP "t_catfile_apache('a', 'b', 'c')" 4
.IX Item "t_catfile_apache('a', 'b', 'c')"
This function is essentially \f(CW\*(C`File::Spec::Unix\->catfile\*(C'\fR, but
on Win32 will use \f(CW\*(C`Win32::GetLongpathName()\*(C'\fR to convert the
result to a long path name (if the result is an absolute file).
It is useful when comparing something to that returned by Apache,
which uses a Unix-style specification with forward slashes for
directory separators. The function is not exported by default.
.IP "\fBt_start_error_log_watch()\fR, \fBt_finish_error_log_watch()\fR" 4
.IX Item "t_start_error_log_watch(), t_finish_error_log_watch()"
This pair of functions provides an easy interface for checking
the presence or absense of any particular message or messages
in the httpd error_log that were generated by the httpd daemon
as part of a test suite.  It is likely, that you should proceed
this with a call to one of the t_*\fB_is_expected()\fR functions.
.Sp
.Vb 3
\&  t_start_error_log_watch();
\&  do_it;
\&  ok grep {...} t_finish_error_log_watch();
.Ve
.Sp
Another usage case could be a handler that emits some debugging messages
to the error_log. Now, if this handler is called in a series of other
test cases it can be hard to find the relevant messages manually. In such
cases the following sequence in the test file may help:
.Sp
.Vb 3
\&  t_start_error_log_watch();
\&  GET \*(Aq/this/or/that\*(Aq;
\&  t_debug t_finish_error_log_watch();
.Ve
.IP "\fBt_start_file_watch()\fR" 4
.IX Item "t_start_file_watch()"
.Vb 1
\&  Apache::TestUtil::t_start_file_watch(\*(Aqaccess_log\*(Aq);
.Ve
.Sp
This function is similar to \f(CW\*(C`t_start_error_log_watch()\*(C'\fR but allows for
other files than \f(CW\*(C`error_log\*(C'\fR to be watched. It opens the given file
and positions the file pointer at its end. Subsequent calls to
\&\f(CW\*(C`t_read_file_watch()\*(C'\fR or \f(CW\*(C`t_finish_file_watch()\*(C'\fR will read lines that
have been appended after this call.
.Sp
A file name can be passed as parameter. If omitted
or undefined the \f(CW\*(C`error_log\*(C'\fR is opened. Relative file name are
evaluated relative to the directory containing \f(CW\*(C`error_log\*(C'\fR.
.Sp
If the specified file does not exist (yet) no error is returned. It is
assumed that it will appear soon. In this case \f(CW\*(C`t_{read,finish}_file_watch()\*(C'\fR
will open the file silently and read from the beginning.
.IP "\fBt_read_file_watch()\fR, \fBt_finish_file_watch()\fR" 4
.IX Item "t_read_file_watch(), t_finish_file_watch()"
.Vb 3
\&  local $/ = "\en";
\&  $line1=Apache::TestUtil::t_read_file_watch(\*(Aqaccess_log\*(Aq);
\&  $line2=Apache::TestUtil::t_read_file_watch(\*(Aqaccess_log\*(Aq);
\&
\&  @lines=Apache::TestUtil::t_finish_file_watch(\*(Aqaccess_log\*(Aq);
.Ve
.Sp
This pair of functions reads the file opened by \f(CW\*(C`t_start_error_log_watch()\*(C'\fR.
.Sp
As does the core \f(CW\*(C`readline\*(C'\fR function, they return one line if called in
scalar context, otherwise all lines until end of file.
.Sp
Before calling \f(CW\*(C`readline\*(C'\fR these functions do not set \f(CW$/\fR as does
\&\f(CW\*(C`t_finish_error_log_watch\*(C'\fR. So, if the file has for example a fixed
record length use this:
.Sp
.Vb 4
\&  {
\&    local $/=\e$record_length;
\&    @lines=t_finish_file_watch($name);
\&  }
.Ve
.IP "\fBt_file_watch_for()\fR" 4
.IX Item "t_file_watch_for()"
.Vb 3
\&  @lines=Apache::TestUtil::t_file_watch_for(\*(Aqaccess_log\*(Aq,
\&                                            qr/condition/,
\&                                            $timeout);
.Ve
.Sp
This function reads the file from the current position and looks for the
first line that matches \f(CW\*(C`qr/condition/\*(C'\fR. If no such line could be found
until end of file the function pauses and retries until either such a line
is found or the timeout (in seconds) is reached.
.Sp
In scalar or void context only the matching line is returned. In list
context all read lines are returned with the matching one in last position.
.Sp
The function uses \f(CW\*(C`\en\*(C'\fR and end-of-line marker and waits for complete lines.
.Sp
The timeout although it can be specified with sub-second precision is not very
accurate. It is simply multiplied by 10. The result is used as a maximum loop
count. For the intented purpose this should be good enough.
.Sp
Use this function to check for logfile entries when you cannot be sure that
they are already written when the test program reaches the point, for example
to check for messages that are written in a PerlCleanupHandler or a
PerlLogHandler.
.Sp
.Vb 1
\& ok t_file_watch_for \*(Aqaccess_log\*(Aq, qr/expected log entry/, 2;
.Ve
.Sp
This call reads the \f(CW\*(C`access_log\*(C'\fR and waits for maximum 2 seconds for the
expected entry to appear.
.SH "AUTHOR"
.IX Header "AUTHOR"
Stas Bekman <stas@stason.org>,
Torsten Förtsch <torsten.foertsch@gmx.net>
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fBperl\fR\|(1)
