.\" Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "indirect 3"
.TH indirect 3 "2019-07-08" "perl v5.30.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
indirect \- Lexically warn about using the indirect method call syntax.
.SH "VERSION"
.IX Header "VERSION"
Version 0.39
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
In a script :
.PP
.Vb 10
\&    no indirect;               # lexically enables the pragma
\&    my $x = new Apple 1, 2, 3; # warns
\&    {
\&     use indirect;     # lexically disables the pragma
\&     my $y = new Pear; # legit, does not warn
\&     {
\&      # lexically specify an hook called for each indirect construct
\&      no indirect hook => sub {
\&       die "You really wanted $_[0]\e\->$_[1] at $_[2]:$_[3]"
\&      };
\&      my $z = new Pineapple \*(Aqfresh\*(Aq; # croaks \*(AqYou really wanted...\*(Aq
\&     }
\&    }
\&    try { ... }; # warns if try() hasn\*(Aqt been declared in this package
\&
\&    no indirect \*(Aqfatal\*(Aq;     # or \*(Aq:fatal\*(Aq, \*(AqFATAL\*(Aq, \*(Aq:Fatal\*(Aq ...
\&    if (defied $foo) { ... } # croaks, note the typo
.Ve
.PP
Global uses :
.PP
.Vb 2
\&    # Globally enable the pragma from the command\-line
\&    perl \-M\-indirect=global \-e \*(Aqmy $x = new Banana;\*(Aq # warns
\&
\&    # Globally enforce the pragma each time perl is executed
\&    export PERL5OPT="\-M\-indirect=global,fatal"
\&    perl \-e \*(Aqmy $y = new Coconut;\*(Aq # croaks
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
When enabled, this pragma warns about indirect method calls that are present in your code.
.PP
The indirect syntax is now considered harmful, since its parsing has many quirks and its use is error prone : when the subroutine \f(CW\*(C`foo\*(C'\fR has not been declared in the current package, \f(CW\*(C`foo $x\*(C'\fR actually compiles to \f(CW\*(C`$x\->foo\*(C'\fR, and \f(CW\*(C`foo { key => 1 }\*(C'\fR to \f(CW\*(C`\*(Aqkey\*(Aq\->foo(1)\*(C'\fR.
Please refer to the \*(L"\s-1REFERENCES\*(R"\s0 section for a more complete list of reasons for avoiding this construct.
.PP
This pragma currently does not warn for core functions (\f(CW\*(C`print\*(C'\fR, \f(CW\*(C`say\*(C'\fR, \f(CW\*(C`exec\*(C'\fR or \f(CW\*(C`system\*(C'\fR).
This may change in the future, or may be added as optional features that would be enabled by passing options to \f(CW\*(C`unimport\*(C'\fR.
.PP
This module is \fBnot\fR a source filter.
.SH "METHODS"
.IX Header "METHODS"
.ie n .SS """unimport"""
.el .SS "\f(CWunimport\fP"
.IX Subsection "unimport"
.Vb 6
\&    no indirect;
\&    no indirect \*(Aqfatal\*(Aq;
\&    no indirect hook => sub { my ($obj, $name, $file, $line) = @_; ... };
\&    no indirect \*(Aqglobal\*(Aq;
\&    no indirect \*(Aqglobal, \*(Aqfatal\*(Aq;
\&    no indirect \*(Aqglobal\*(Aq, hook => sub { ... };
.Ve
.PP
Magically called when \f(CW\*(C`no indirect @opts\*(C'\fR is encountered.
Turns the module on.
The policy to apply depends on what is first found in \f(CW@opts\fR :
.IP "\(bu" 4
If it is a string that matches \f(CW\*(C`/^:?fatal$/i\*(C'\fR, the compilation will croak when the first indirect method call is found.
.Sp
This option is mutually exclusive with the \f(CW\*(Aqhook\*(Aq\fR option.
.IP "\(bu" 4
If the key/value pair \f(CW\*(C`hook => $hook\*(C'\fR comes first, \f(CW$hook\fR will be called for each error with a string representation of the object as \f(CW$_[0]\fR, the method name as \f(CW$_[1]\fR, the current file as \f(CW$_[2]\fR and the line number as \f(CW$_[3]\fR.
If and only if the object is actually a block, \f(CW$_[0]\fR is assured to start by \f(CW\*(Aq{\*(Aq\fR.
.Sp
This option is mutually exclusive with the \f(CW\*(Aqfatal\*(Aq\fR option.
.IP "\(bu" 4
If none of \f(CW\*(C`fatal\*(C'\fR and \f(CW\*(C`hook\*(C'\fR are specified, a warning will be emitted for each indirect method call.
.IP "\(bu" 4
If \f(CW@opts\fR contains a string that matches \f(CW\*(C`/^:?global$/i\*(C'\fR, the pragma will be globally enabled for \fBall\fR code compiled after the current \f(CW\*(C`no indirect\*(C'\fR statement, except for code that is in the lexical scope of \f(CW\*(C`use indirect\*(C'\fR.
This option may come indifferently before or after the \f(CW\*(C`fatal\*(C'\fR or \f(CW\*(C`hook\*(C'\fR options, in the case they are also passed to \*(L"unimport\*(R".
.Sp
The global policy applied is the one resulting of the \f(CW\*(C`fatal\*(C'\fR or \f(CW\*(C`hook\*(C'\fR options, thus defaults to a warning when none of those are specified :
.Sp
.Vb 3
\&    no indirect \*(Aqglobal\*(Aq;                # warn for any indirect call
\&    no indirect qw<global fatal>;        # die on any indirect call
\&    no indirect \*(Aqglobal\*(Aq, hook => \e&hook # custom global action
.Ve
.Sp
Note that if another policy is installed by a \f(CW\*(C`no indirect\*(C'\fR statement further in the code, it will overrule the global policy :
.Sp
.Vb 7
\&    no indirect \*(Aqglobal\*(Aq;  # warn globally
\&    {
\&     no indirect \*(Aqfatal\*(Aq;  # throw exceptions for this lexical scope
\&     ...
\&     require Some::Module; # the global policy will apply for the
\&                           # compilation phase of this module
\&    }
.Ve
.ie n .SS """import"""
.el .SS "\f(CWimport\fP"
.IX Subsection "import"
.Vb 1
\&    use indirect;
.Ve
.PP
Magically called at each \f(CW\*(C`use indirect\*(C'\fR. Turns the module off.
.PP
As explained in \*(L"unimport\*(R"'s description, an \f(CW\*(C`use indirect\*(C'\fR statement will lexically override a global policy previously installed by \f(CW\*(C`no indirect \*(Aqglobal\*(Aq, ...\*(C'\fR (if there's one).
.SH "FUNCTIONS"
.IX Header "FUNCTIONS"
.ie n .SS """msg"""
.el .SS "\f(CWmsg\fP"
.IX Subsection "msg"
.Vb 1
\&    my $msg = msg($object, $method, $file, $line);
.Ve
.PP
Returns the default error message that \f(CW\*(C`indirect\*(C'\fR generates when an indirect method call is reported.
.SH "CONSTANTS"
.IX Header "CONSTANTS"
.ie n .SS """I_THREADSAFE"""
.el .SS "\f(CWI_THREADSAFE\fP"
.IX Subsection "I_THREADSAFE"
True iff the module could have been built with thread-safety features enabled.
.ie n .SS """I_FORKSAFE"""
.el .SS "\f(CWI_FORKSAFE\fP"
.IX Subsection "I_FORKSAFE"
True iff this module could have been built with fork-safety features enabled.
This will always be true except on Windows where it's false for perl 5.10.0 and below .
.SH "DIAGNOSTICS"
.IX Header "DIAGNOSTICS"
.ie n .SS """Indirect call of method ""%s"" on object ""%s"" at %s line %d."""
.el .SS "\f(CWIndirect call of method ``%s'' on object ``%s'' at %s line %d.\fP"
.IX Subsection "Indirect call of method ""%s"" on object ""%s"" at %s line %d."
The default warning/exception message thrown when an indirect method call on an object is found.
.ie n .SS """Indirect call of method ""%s"" on a block at %s line %d."""
.el .SS "\f(CWIndirect call of method ``%s'' on a block at %s line %d.\fP"
.IX Subsection "Indirect call of method ""%s"" on a block at %s line %d."
The default warning/exception message thrown when an indirect method call on a block is found.
.SH "ENVIRONMENT"
.IX Header "ENVIRONMENT"
.ie n .SS """PERL_INDIRECT_PM_DISABLE"""
.el .SS "\f(CWPERL_INDIRECT_PM_DISABLE\fP"
.IX Subsection "PERL_INDIRECT_PM_DISABLE"
If this environment variable is set to true when the pragma is used for the first time, the \s-1XS\s0 code won't be loaded and, although the \f(CW\*(Aqindirect\*(Aq\fR lexical hint will be set to true in the scope of use, the pragma itself won't do anything.
In this case, the pragma will always be considered to be thread-safe, and as such \*(L"I_THREADSAFE\*(R" will be true.
This is useful for disabling \f(CW\*(C`indirect\*(C'\fR in production environments.
.PP
Note that clearing this variable after \f(CW\*(C`indirect\*(C'\fR was loaded has no effect.
If you want to re-enable the pragma later, you also need to reload it by deleting the \f(CW\*(Aqindirect.pm\*(Aq\fR entry from \f(CW%INC\fR.
.SH "CAVEATS"
.IX Header "CAVEATS"
The implementation was tweaked to work around several limitations of vanilla \f(CW\*(C`perl\*(C'\fR pragmas : it's thread safe, and does not suffer from a \f(CW\*(C`perl 5.8.x\-5.10.0\*(C'\fR bug that causes all pragmas to propagate into \f(CW\*(C`require\*(C'\fRd scopes.
.PP
Before \f(CW\*(C`perl\*(C'\fR 5.12, \f(CW\*(C`meth $obj\*(C'\fR (no semicolon) at the end of a file is not seen as an indirect method call, although it is as soon as there is another token before the end (as in \f(CW\*(C`meth $obj;\*(C'\fR or \f(CW\*(C`meth $obj 1\*(C'\fR).
If you use \f(CW\*(C`perl\*(C'\fR 5.12 or greater, those constructs are correctly reported.
.PP
With 5.8 perls, the pragma does not propagate into \f(CW\*(C`eval STRING\*(C'\fR.
This is due to a shortcoming in the way perl handles the hints hash, which is addressed in perl 5.10.
.PP
The search for indirect method calls happens before constant folding.
Hence \f(CW\*(C`my $x = new Class if 0\*(C'\fR will be caught.
.SH "REFERENCES"
.IX Header "REFERENCES"
Numerous articles have been written about the quirks of the indirect object construct :
.IP "\(bu" 4
<http://markmail.org/message/o7d5sxnydya7bwvv> : \fBFar More Than Everything You've Ever Wanted to Know about the Indirect Object syntax\fR, Tom Christiansen, 1998\-01\-28.
.Sp
This historical post to the \f(CW\*(C`perl5\-porters\*(C'\fR mailing list raised awareness about the perils of this syntax.
.IP "\(bu" 4
<http://www.shadowcat.co.uk/blog/matt\-s\-trout/indirect\-but\-still\-fatal> : \fBIndirect but still fatal\fR, Matt S. Trout, 2009\-07\-29.
.Sp
In this blog post, the author gives an example of an undesirable indirect method call on a block that causes a particularly bewildering error.
.SH "DEPENDENCIES"
.IX Header "DEPENDENCIES"
perl 5.8.1.
.PP
A C compiler.
This module may happen to build with a \*(C+ compiler as well, but don't rely on it, as no guarantee is made in this regard.
.PP
Carp (standard since perl 5), XSLoader (since perl 5.6.0).
.SH "AUTHOR"
.IX Header "AUTHOR"
Vincent Pit \f(CW\*(C`<vpit@cpan.org>\*(C'\fR.
.PP
You can contact me by mail or on \f(CW\*(C`irc.perl.org\*(C'\fR (vincent).
.SH "BUGS"
.IX Header "BUGS"
Please report any bugs or feature requests to \f(CW\*(C`bug\-indirect at rt.cpan.org\*(C'\fR, or through the web interface at <http://rt.cpan.org/NoAuth/ReportBug.html?Queue=indirect>.
I will be notified, and then you'll automatically be notified of progress on your bug as I make changes.
.SH "SUPPORT"
.IX Header "SUPPORT"
You can find documentation for this module with the perldoc command.
.PP
.Vb 1
\&    perldoc indirect
.Ve
.SH "ACKNOWLEDGEMENTS"
.IX Header "ACKNOWLEDGEMENTS"
Bram, for motivation and advices.
.PP
Andrew Main and Florian Ragwitz, for testing on real-life code and reporting issues.
.SH "COPYRIGHT & LICENSE"
.IX Header "COPYRIGHT & LICENSE"
Copyright 2008,2009,2010,2011,2012,2013,2014,2015,2016,2017,2019 Vincent Pit, all rights reserved.
.PP
This program is free software; you can redistribute it and/or modify it under the same terms as Perl itself.
