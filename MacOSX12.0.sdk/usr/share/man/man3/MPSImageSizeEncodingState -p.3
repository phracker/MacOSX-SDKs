.TH "<MPSImageSizeEncodingState >" 3 "Mon Jul 9 2018" "Version MetalPerformanceShaders-119.3" "MetalPerformanceShaders.framework" \" -*- nroff -*-
.ad l
.nh
.SH NAME
<MPSImageSizeEncodingState >
.SH SYNOPSIS
.br
.PP
.PP
\fC#import <MPSNeuralNetworkTypes\&.h>\fP
.PP
Inherits <NSObject>\&.
.SS "Properties"

.in +1c
.ti -1c
.RI "NSUInteger \fBsourceWidth\fP"
.br
.ti -1c
.RI "NSUInteger \fBsourceHeight\fP"
.br
.in -1c
.SH "Detailed Description"
.PP 
MPSStates conforming to this protocol contain information about a image size elsewhere in the graph  In some graphs a sequence of operations are done, then they are undone ins a series of 'reverse' operations\&. Examples might be pooling vs pooling gradient / upsampling, or convolution vs\&. convolution transpose\&. In such cases, the 'reverse' pass generally is converting from a smaller image to a larger image, and there is insufficient information to do this correctly\&. Several answers exist and we don't know which is correct\&.
.PP
As an example, consider trying to 'undo' integer division with a multiplication\&. The expression c = a/b is incomplete because there is also a remainder, which may constitute information lost\&. If we want to reconstitute a based on c and b, we need to use a = c * b + remainder, not just a = c*b\&. Similarly, when undoing a downsizing operation, we need the original size to find which answer in the range of a = c*b + [0,b-1] is the right one\&. 
.SH "Property Documentation"
.PP 
.SS "\- (NSUInteger MPSImageSizeEncodingState) sourceHeight\fC [read]\fP, \fC [nonatomic]\fP, \fC [assign]\fP"
The height of the source image passed to \fBMPSCNNConvolution\fP encode call\&. 
.SS "\- (NSUInteger MPSImageSizeEncodingState) sourceWidth\fC [read]\fP, \fC [nonatomic]\fP, \fC [assign]\fP"
The width of the source image passed to \fBMPSCNNConvolution\fP encode call\&. 

.SH "Author"
.PP 
Generated automatically by Doxygen for MetalPerformanceShaders\&.framework from the source code\&.
