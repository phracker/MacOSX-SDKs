.\" Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "File::Slurp 3"
.TH File::Slurp 3 "2020-03-09" "perl v5.30.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
File::Slurp \- Simple and Efficient Reading/Writing/Modifying of Complete Files
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use File::Slurp;
\&
\&  # read in a whole file into a scalar
\&  my $text = read_file(\*(Aq/path/file\*(Aq);
\&
\&  # read in a whole file into an array of lines
\&  my @lines = read_file(\*(Aq/path/file\*(Aq);
\&
\&  # write out a whole file from a scalar
\&  write_file(\*(Aq/path/file\*(Aq, $text);
\&
\&  # write out a whole file from an array of lines
\&  write_file(\*(Aq/path/file\*(Aq, @lines);
\&
\&  # Here is a simple and fast way to load and save a simple config file
\&  # made of key=value lines.
\&  my %conf = read_file(\*(Aq/path/file\*(Aq) =~ /^(\ew+)=(.*)$/mg;
\&  write_file(\*(Aq/path/file\*(Aq, {atomic => 1}, map "$_=$conf{$_}\en", keys %conf);
\&
\&  # insert text at the beginning of a file
\&  prepend_file(\*(Aq/path/file\*(Aq, $text);
\&
\&  # in\-place edit to replace all \*(Aqfoo\*(Aq with \*(Aqbar\*(Aq in file
\&  edit_file { s/foo/bar/g } \*(Aq/path/file\*(Aq;
\&
\&  # in\-place edit to delete all lines with \*(Aqfoo\*(Aq from file
\&  edit_file_lines sub { $_ = \*(Aq\*(Aq if /foo/ }, \*(Aq/path/file\*(Aq;
\&
\&  # read in a whole directory of file names (skipping . and ..)
\&  my @files = read_dir(\*(Aq/path/to/dir\*(Aq);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module provides subs that allow you to read or write entire files
with one simple call. They are designed to be simple to use, have
flexible ways to pass in or get the file contents and to be very
efficient. There is also a sub to read in all the files in a
directory.
.SS "\s-1WARNING\s0 \- \s-1PENDING DOOM\s0"
.IX Subsection "WARNING - PENDING DOOM"
Although you technically \fIcan\fR, do \s-1NOT\s0 use this module to work on file handles,
pipes, sockets, standard \s-1IO,\s0 or the \f(CW\*(C`DATA\*(C'\fR handle. These are
features implemented long ago that just really shouldn't be abused here.
.PP
Be warned: this activity will lead to inaccurate encoding/decoding of data.
.PP
All further mentions of actions on the above have been removed from this
documentation and that feature set will likely be deprecated in the future.
.PP
In other words, if you don't have a filename to pass, consider using the
standard \f(CW\*(C`do { local $/; <$fh> }\*(C'\fR, or
Data::Section/Data::Section::Simple for working with \f(CW\*(C`_\|_DATA_\|_\*(C'\fR.
.SH "FUNCTIONS"
.IX Header "FUNCTIONS"
File::Slurp implements the following functions.
.SS "append_file"
.IX Subsection "append_file"
.Vb 4
\&        use File::Slurp qw(append_file write_file);
\&        my $res = append_file(\*(Aq/path/file\*(Aq, "Some text");
\&        # same as
\&        my $res = write_file(\*(Aq/path/file\*(Aq, {append => 1}, "Some text");
.Ve
.PP
The \f(CW\*(C`append_file\*(C'\fR function is simply a synonym for the
\&\*(L"write_file\*(R" in File::Slurp function, but ensures that the \f(CW\*(C`append\*(C'\fR option is
set.
.SS "edit_file"
.IX Subsection "edit_file"
.Vb 6
\&        use File::Slurp qw(edit_file);
\&        # perl \-0777 \-pi \-e \*(Aqs/foo/bar/g\*(Aq /path/file
\&        edit_file { s/foo/bar/g } \*(Aq/path/file\*(Aq;
\&        edit_file sub { s/foo/bar/g }, \*(Aq/path/file\*(Aq;
\&        sub replace_foo { s/foo/bar/g }
\&        edit_file \e&replace_foo, \*(Aq/path/file\*(Aq;
.Ve
.PP
The \f(CW\*(C`edit_file\*(C'\fR function reads in a file into \f(CW$_\fR, executes a code block that
should modify \f(CW$_\fR, and then writes \f(CW$_\fR back to the file. The \f(CW\*(C`edit_file\*(C'\fR
function reads in the entire file and calls the code block one time. It is
equivalent to the \f(CW\*(C`\-pi\*(C'\fR command line options of Perl but you can call it from
inside your program and not have to fork out a process.
.PP
The first argument to \f(CW\*(C`edit_file\*(C'\fR is a code block or a code reference. The
code block is not followed by a comma (as with \f(CW\*(C`grep\*(C'\fR and \f(CW\*(C`map\*(C'\fR) but a code
reference is followed by a comma.
.PP
The next argument is the filename.
.PP
The next argument(s) is either a hash reference or a flattened hash,
\&\f(CW\*(C`key => value\*(C'\fR pairs. The options are passed through to the
\&\*(L"write_file\*(R" in File::Slurp function. All options are described there.
Only the \f(CW\*(C`binmode\*(C'\fR and \f(CW\*(C`err_mode\*(C'\fR options are supported. The call to
\&\*(L"write_file\*(R" in File::Slurp has the \f(CW\*(C`atomic\*(C'\fR option set so you will always
have a consistent file.
.SS "edit_file_lines"
.IX Subsection "edit_file_lines"
.Vb 6
\&        use File::Slurp qw(edit_file_lines);
\&        # perl \-pi \-e \*(Aq$_ = "" if /foo/\*(Aq /path/file
\&        edit_file_lines { $_ = \*(Aq\*(Aq if /foo/ } \*(Aq/path/file\*(Aq;
\&        edit_file_lines sub { $_ = \*(Aq\*(Aq if /foo/ }, \*(Aq/path/file\*(Aq;
\&        sub delete_foo { $_ = \*(Aq\*(Aq if /foo/ }
\&        edit_file \e&delete_foo, \*(Aq/path/file\*(Aq;
.Ve
.PP
The \f(CW\*(C`edit_file_lines\*(C'\fR function reads each line of a file into \f(CW$_\fR, and
executes a code block that should modify \f(CW$_\fR. It will then write \f(CW$_\fR back
to the file. It is equivalent to the \f(CW\*(C`\-pi\*(C'\fR command line options of Perl but
you can call it from inside your program and not have to fork out a process.
.PP
The first argument to \f(CW\*(C`edit_file_lines\*(C'\fR is a code block or a code reference.
The code block is not followed by a comma (as with \f(CW\*(C`grep\*(C'\fR and \f(CW\*(C`map\*(C'\fR) but a
code reference is followed by a comma.
.PP
The next argument is the filename.
.PP
The next argument(s) is either a hash reference or a flattened hash,
\&\f(CW\*(C`key => value\*(C'\fR pairs. The options are passed through to the
\&\*(L"write_file\*(R" in File::Slurp function. All options are described there.
Only the \f(CW\*(C`binmode\*(C'\fR and \f(CW\*(C`err_mode\*(C'\fR options are supported. The call to
\&\*(L"write_file\*(R" in File::Slurp has the \f(CW\*(C`atomic\*(C'\fR option set so you will always
have a consistent file.
.SS "ef"
.IX Subsection "ef"
.Vb 6
\&        use File::Slurp qw(ef);
\&        # perl \-0777 \-pi \-e \*(Aqs/foo/bar/g\*(Aq /path/file
\&        ef { s/foo/bar/g } \*(Aq/path/file\*(Aq;
\&        ef sub { s/foo/bar/g }, \*(Aq/path/file\*(Aq;
\&        sub replace_foo { s/foo/bar/g }
\&        ef \e&replace_foo, \*(Aq/path/file\*(Aq;
.Ve
.PP
The \f(CW\*(C`ef\*(C'\fR function is simply a synonym for the \*(L"edit_file\*(R" in File::Slurp
function.
.SS "efl"
.IX Subsection "efl"
.Vb 6
\&        use File::Slurp qw(efl);
\&        # perl \-pi \-e \*(Aq$_ = "" if /foo/\*(Aq /path/file
\&        efl { $_ = \*(Aq\*(Aq if /foo/ } \*(Aq/path/file\*(Aq;
\&        efl sub { $_ = \*(Aq\*(Aq if /foo/ }, \*(Aq/path/file\*(Aq;
\&        sub delete_foo { $_ = \*(Aq\*(Aq if /foo/ }
\&        efl \e&delete_foo, \*(Aq/path/file\*(Aq;
.Ve
.PP
The \f(CW\*(C`efl\*(C'\fR function is simply a synonym for the \*(L"edit_file_lines\*(R" in File::Slurp
function.
.SS "overwrite_file"
.IX Subsection "overwrite_file"
.Vb 2
\&        use File::Slurp qw(overwrite_file);
\&        my $res = overwrite_file(\*(Aq/path/file\*(Aq, "Some text");
.Ve
.PP
The \f(CW\*(C`overwrite_file\*(C'\fR function is simply a synonym for the
\&\*(L"write_file\*(R" in File::Slurp function.
.SS "prepend_file"
.IX Subsection "prepend_file"
.Vb 4
\&        use File::Slurp qw(prepend_file);
\&        prepend_file(\*(Aq/path/file\*(Aq, $header);
\&        prepend_file(\*(Aq/path/file\*(Aq, \e@lines);
\&        prepend_file(\*(Aq/path/file\*(Aq, { binmode => \*(Aq:raw\*(Aq}, $bin_data);
\&
\&        # equivalent to:
\&        use File::Slurp qw(read_file write_file);
\&        my $content = read_file(\*(Aq/path/file\*(Aq);
\&        my $new_content = "hahahaha";
\&        write_file(\*(Aq/path/file\*(Aq, $new_content . $content);
.Ve
.PP
The \f(CW\*(C`prepend_file\*(C'\fR function is the opposite of \*(L"append_file\*(R" in File::Slurp as
it writes new contents to the beginning of the file instead of the end. It is a
combination of \*(L"read_file\*(R" in File::Slurp and \*(L"write_file\*(R" in File::Slurp. It
works by first using \f(CW\*(C`read_file\*(C'\fR to slurp in the file and then calling
\&\f(CW\*(C`write_file\*(C'\fR with the new data and the existing file data.
.PP
The first argument to \f(CW\*(C`prepend_file\*(C'\fR is the filename.
.PP
The next argument(s) is either a hash reference or a flattened hash,
\&\f(CW\*(C`key => value\*(C'\fR pairs. The options are passed through to the
\&\*(L"write_file\*(R" in File::Slurp function. All options are described there.
.PP
Only the \f(CW\*(C`binmode\*(C'\fR and \f(CW\*(C`err_mode\*(C'\fR options are supported. The
\&\f(CW\*(C`write_file\*(C'\fR call has the \f(CW\*(C`atomic\*(C'\fR option set so you will always have
a consistent file.
.SS "read_dir"
.IX Subsection "read_dir"
.Vb 8
\&        use File::Slurp qw(read_dir);
\&        my @files = read_dir(\*(Aq/path/to/dir\*(Aq);
\&        # all files, even the dots
\&        my @files = read_dir(\*(Aq/path/to/dir\*(Aq, keep_dot_dot => 1);
\&        # keep the full file path
\&        my @paths = read_dir(\*(Aq/path/to/dir\*(Aq, prefix => 1);
\&        # scalar context
\&        my $files_ref = read_dir(\*(Aq/path/to/dir\*(Aq);
.Ve
.PP
This function returns a list of the filenames in the supplied directory. In
list context, an array is returned, in scalar context, an array reference is
returned.
.PP
The first argument is the path to the directory to read.
.PP
The next argument(s) is either a hash reference or a flattened hash,
\&\f(CW\*(C`key => value\*(C'\fR pairs. The following options are available:
.IP "\(bu" 4
err_mode
.Sp
The \f(CW\*(C`err_mode\*(C'\fR option has three possible values: \f(CW\*(C`quiet\*(C'\fR, \f(CW\*(C`carp\*(C'\fR, or the
default, \f(CW\*(C`croak\*(C'\fR. In \f(CW\*(C`quiet\*(C'\fR mode, all errors will be silent. In \f(CW\*(C`carp\*(C'\fR mode,
all errors will be emitted as warnings. And, in \f(CW\*(C`croak\*(C'\fR mode, all errors will
be emitted as exceptions. Take a look at Try::Tiny or
Syntax::Keyword::Try to see how to catch exceptions.
.IP "\(bu" 4
keep_dot_dot
.Sp
The \f(CW\*(C`keep_dot_dot\*(C'\fR option is a boolean option, defaulted to false (\f(CW0\fR).
Setting this option to true (\f(CW1\fR) will also return the \f(CW\*(C`.\*(C'\fR and \f(CW\*(C`..\*(C'\fR files
that are removed from the file list by default.
.IP "\(bu" 4
prefix
.Sp
The \f(CW\*(C`prefix\*(C'\fR option is a boolean option, defaulted to false (\f(CW0\fR).
Setting this option to true (\f(CW1\fR) add the directory as a prefix to the file.
The directory and the filename are joined using \f(CW\*(C`File::Spec\->catfile()\*(C'\fR to
ensure the proper directory separator is used for your \s-1OS.\s0 See File::Spec.
.SS "read_file"
.IX Subsection "read_file"
.Vb 6
\&        use File::Slurp qw(read_file);
\&        my $text = read_file(\*(Aq/path/file\*(Aq);
\&        my $bin = read_file(\*(Aq/path/file\*(Aq, { binmode => \*(Aq:raw\*(Aq });
\&        my @lines = read_file(\*(Aq/path/file\*(Aq);
\&        my $lines_ref = read_file(\*(Aq/path/file\*(Aq, array_ref => 1);
\&        my $lines_ref = [ read_file(\*(Aq/path/file\*(Aq) ];
\&
\&        # or we can read into a buffer:
\&        my $buffer;
\&        read_file(\*(Aq/path/file\*(Aq, buf_ref => \e$buffer);
\&
\&        # or we can set the block size for the read
\&        my $text_ref = read_file(\*(Aq/path/file\*(Aq, blk_size => 10_000_000, array_ref => 1);
\&
\&        # or we can get a scalar reference
\&        my $text_ref = read_file(\*(Aq/path/file\*(Aq, scalar_ref => 1);
.Ve
.PP
This function reads in an entire file and returns its contents to the
caller. In scalar context it returns the entire file as a single
scalar. In list context it will return a list of lines (using the
current value of \f(CW$/\fR as the separator, including support for paragraph
mode when it is set to \f(CW\*(Aq\*(Aq\fR).
.PP
The first argument is the path to the file to be slurped in.
.PP
The next argument(s) is either a hash reference or a flattened hash,
\&\f(CW\*(C`key => value\*(C'\fR pairs. The following options are available:
.IP "\(bu" 4
array_ref
.Sp
The \f(CW\*(C`array_ref\*(C'\fR option is a boolean option, defaulted to false (\f(CW0\fR). Setting
this option to true (\f(CW1\fR) will only have relevance if the \f(CW\*(C`read_file\*(C'\fR function
is called in scalar context. When true, the \f(CW\*(C`read_file\*(C'\fR function will return
a reference to an array of the lines in the file.
.IP "\(bu" 4
binmode
.Sp
The \f(CW\*(C`binmode\*(C'\fR option is a string option, defaulted to empty (\f(CW\*(Aq\*(Aq\fR). If you
set the \f(CW\*(C`binmode\*(C'\fR option, then its value is passed to a call to \f(CW\*(C`binmode\*(C'\fR on
the opened handle. You can use this to set the file to be read in binary mode,
utf8, etc. See \f(CW\*(C`perldoc \-f binmode\*(C'\fR for more.
.IP "\(bu" 4
blk_size
.Sp
You can use this option to set the block size used when slurping from
an already open handle (like \f(CW\*(C`\e*STDIN\*(C'\fR). It defaults to 1MB.
.IP "\(bu" 4
buf_ref
.Sp
The \f(CW\*(C`buf_ref\*(C'\fR option can be used in conjunction with any of the other options.
You can use this option to pass in a scalar reference and the slurped
file contents will be stored in the scalar. This saves an extra copy of
the slurped file and can lower \s-1RAM\s0 usage vs returning the file. It is
usually the fastest way to read a file into a scalar.
.IP "\(bu" 4
chomp
.Sp
The \f(CW\*(C`chomp\*(C'\fR option is a boolean option, defaulted to false (\f(CW0\fR). Setting
this option to true (\f(CW1\fR) will cause each line to have its contents \f(CW\*(C`chomp\*(C'\fRed.
This option works in list context or in scalar context with the \f(CW\*(C`array_ref\*(C'\fR
option.
.IP "\(bu" 4
err_mode
.Sp
The \f(CW\*(C`err_mode\*(C'\fR option has three possible values: \f(CW\*(C`quiet\*(C'\fR, \f(CW\*(C`carp\*(C'\fR, or the
default, \f(CW\*(C`croak\*(C'\fR. In \f(CW\*(C`quiet\*(C'\fR mode, all errors will be silent. In \f(CW\*(C`carp\*(C'\fR mode,
all errors will be emitted as warnings. And, in \f(CW\*(C`croak\*(C'\fR mode, all errors will
be emitted as exceptions. Take a look at Try::Tiny or
Syntax::Keyword::Try to see how to catch exceptions.
.IP "\(bu" 4
scalar_ref
.Sp
The \f(CW\*(C`scalar_ref\*(C'\fR option is a boolean option, defaulted to false (\f(CW0\fR). It only
has meaning in scalar context. The return value will be a scalar reference to a
string which is the contents of the slurped file. This will usually be faster
than returning the plain scalar. It will also save memory as it will not make a
copy of the file to return.
.SS "rf"
.IX Subsection "rf"
.Vb 2
\&        use File::Slurp qw(rf);
\&        my $text = rf(\*(Aq/path/file\*(Aq);
.Ve
.PP
The \f(CW\*(C`rf\*(C'\fR function is simply a synonym for the \*(L"read_file\*(R" in File::Slurp
function.
.SS "slurp"
.IX Subsection "slurp"
.Vb 2
\&        use File::Slurp qw(slurp);
\&        my $text = slurp(\*(Aq/path/file\*(Aq);
.Ve
.PP
The \f(CW\*(C`slurp\*(C'\fR function is simply a synonym for the \*(L"read_file\*(R" in File::Slurp
function.
.SS "wf"
.IX Subsection "wf"
.Vb 2
\&        use File::Slurp qw(wf);
\&        my $res = wf(\*(Aq/path/file\*(Aq, "Some text");
.Ve
.PP
The \f(CW\*(C`wf\*(C'\fR function is simply a synonym for the
\&\*(L"write_file\*(R" in File::Slurp function.
.SS "write_file"
.IX Subsection "write_file"
.Vb 8
\&        use File::Slurp qw(write_file);
\&        write_file(\*(Aq/path/file\*(Aq, @data);
\&        write_file(\*(Aq/path/file\*(Aq, {append => 1}, @data);
\&        write_file(\*(Aq/path/file\*(Aq, {binmode => \*(Aq:raw\*(Aq}, $buffer);
\&        write_file(\*(Aq/path/file\*(Aq, \e$buffer);
\&        write_file(\*(Aq/path/file\*(Aq, $buffer);
\&        write_file(\*(Aq/path/file\*(Aq, \e@lines);
\&        write_file(\*(Aq/path/file\*(Aq, @lines);
\&
\&        # binmode
\&        write_file(\*(Aq/path/file\*(Aq, {binmode => \*(Aq:raw\*(Aq}, @data);
\&        write_file(\*(Aq/path/file\*(Aq, {binmode => \*(Aq:utf8\*(Aq}, $utf_text);
\&
\&        # buffered
\&        write_file(\*(Aq/path/file\*(Aq, {buf_ref => \e$buffer});
\&        write_file(\*(Aq/path/file\*(Aq, \e$buffer);
\&        write_file(\*(Aq/path/file\*(Aq, $buffer);
\&
\&        # append
\&        write_file(\*(Aq/path/file\*(Aq, {append => 1}, @data);
\&
\&        # no clobbering
\&        write_file(\*(Aq/path/file\*(Aq, {no_clobber => 1}, @data);
.Ve
.PP
This function writes out an entire file in one call. By default \f(CW\*(C`write_file\*(C'\fR
returns \f(CW1\fR upon successfully writing the file or \f(CW\*(C`undef\*(C'\fR if it encountered
an error. You can change how errors are handled with the \f(CW\*(C`err_mode\*(C'\fR option.
.PP
The first argument to \f(CW\*(C`write_file\*(C'\fR is the filename.
.PP
The next argument(s) is either a hash reference or a flattened hash,
\&\f(CW\*(C`key => value\*(C'\fR pairs. The following options are available:
.IP "\(bu" 4
append
.Sp
The \f(CW\*(C`append\*(C'\fR option is a boolean option, defaulted to false (\f(CW0\fR). Setting
this option to true (\f(CW1\fR) will cause the data to be be written at the end of
the current file. Internally this sets the \f(CW\*(C`sysopen\*(C'\fR mode flag \f(CW\*(C`O_APPEND\*(C'\fR.
.Sp
The \*(L"append_file\*(R" in File::Slurp function sets this option by default.
.IP "\(bu" 4
atomic
.Sp
The \f(CW\*(C`atomic\*(C'\fR option is a boolean option, defaulted to false (\f(CW0\fR). Setting
this option to true (\f(CW1\fR) will cause the file to be be written to in an
atomic fashion. A temporary file name is created using \*(L"tempfile\*(R" in File::Temp.
After the file is closed it is renamed to the original file name
(and \f(CW\*(C`rename\*(C'\fR is an atomic operation on most OSes). If the program using
this were to crash in the middle of this, then the temporary file could
be left behind.
.IP "\(bu" 4
binmode
.Sp
The \f(CW\*(C`binmode\*(C'\fR option is a string option, defaulted to empty (\f(CW\*(Aq\*(Aq\fR). If you
set the \f(CW\*(C`binmode\*(C'\fR option, then its value is passed to a call to \f(CW\*(C`binmode\*(C'\fR on
the opened handle. You can use this to set the file to be read in binary mode,
utf8, etc. See \f(CW\*(C`perldoc \-f binmode\*(C'\fR for more.
.IP "\(bu" 4
buf_ref
.Sp
The \f(CW\*(C`buf_ref\*(C'\fR option is used to pass in a scalar reference which has the
data to be written. If this is set then any data arguments (including
the scalar reference shortcut) in \f(CW@_\fR will be ignored.
.IP "\(bu" 4
err_mode
.Sp
The \f(CW\*(C`err_mode\*(C'\fR option has three possible values: \f(CW\*(C`quiet\*(C'\fR, \f(CW\*(C`carp\*(C'\fR, or the
default, \f(CW\*(C`croak\*(C'\fR. In \f(CW\*(C`quiet\*(C'\fR mode, all errors will be silent. In \f(CW\*(C`carp\*(C'\fR mode,
all errors will be emitted as warnings. And, in \f(CW\*(C`croak\*(C'\fR mode, all errors will
be emitted as exceptions. Take a look at Try::Tiny or
Syntax::Keyword::Try to see how to catch exceptions.
.IP "\(bu" 4
no_clobber
.Sp
The \f(CW\*(C`no_clobber\*(C'\fR option is a boolean option, defaulted to false (\f(CW0\fR). Setting
this option to true (\f(CW1\fR) will ensure an that existing file will not be
overwritten.
.IP "\(bu" 4
perms
.Sp
The \f(CW\*(C`perms\*(C'\fR option sets the permissions of newly-created files. This value
is modified by your process's \f(CW\*(C`umask\*(C'\fR and defaults to \f(CW0666\fR (same as
\&\f(CW\*(C`sysopen\*(C'\fR).
.Sp
\&\s-1NOTE:\s0 this option is new as of File::Slurp version 9999.14.
.SH "EXPORT"
.IX Header "EXPORT"
These are exported by default or with
.PP
.Vb 2
\&        use File::Slurp qw(:std);
\&        # read_file write_file overwrite_file append_file read_dir
.Ve
.PP
These are exported with
.PP
.Vb 2
\&        use File::Slurp qw(:edit);
\&        # edit_file edit_file_lines
.Ve
.PP
You can get all subs in the module exported with
.PP
.Vb 1
\&        use File::Slurp qw(:all);
.Ve
.SH "AUTHOR"
.IX Header "AUTHOR"
Uri Guttman, <\fIuri@stemsystems.com\fR>
.SH "COPYRIGHT & LICENSE"
.IX Header "COPYRIGHT & LICENSE"
Copyright (c) 2003 Uri Guttman. All rights reserved.
.PP
This program is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.
