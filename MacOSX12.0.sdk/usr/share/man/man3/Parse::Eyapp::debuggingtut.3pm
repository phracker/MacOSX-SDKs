.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Parse::Eyapp::debuggingtut 3"
.TH Parse::Eyapp::debuggingtut 3 "2012-03-23" "perl v5.18.4" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Parse::Eyapp::debuggingtut \- Solving ambiguities and fixing lexical, syntactic and semantic errors
.SH "INTRODUCTION"
.IX Header "INTRODUCTION"
The sources of error when programming 
with \f(CW\*(C`eyapp\*(C'\fR are many and various. 
Some of them are minor, as having a 
nonterminal without production rules or a terminal
that is never produced by the lexical analyzer. These kind of errors
can be caught with the help of the \f(CW%strict\fR directive.
.PP
In the following 
sections we will discuss three main kind 
of errors that correspond to three development
stages:
.IP "\(bu" 2
Conflict errors:
.Sp
Conflicts with the grammar: the grammar is ambiguous or
is not clear \- perhaps due to the fact that \f(CW\*(C`eyapp\*(C'\fR
uses only a lookahead symbol \- which sort of tree must be built for
some inputs
.IP "\(bu" 2
Tree building errors:
.Sp
There are no conflicts but the parser does not build the syntax
tree as expected. May be it rejects correct sentences
or accepts incorrect ones. Or may be it accepts correct ones but
the syntax tree has not the shape we want (i.e. we have a precedence
problem).
.IP "\(bu" 2
Semantic errors:
.Sp
We have solved the conflicts and trees are satisfactory but
we have errors inside the semantic actions.
.PP
Each time you discover an error write a test that covers that
error. Section \*(L"\s-1TREE EQUALITY\*(R"\s0 deals with the problem of
checking if the generated abstract syntax tree 
has the correct shape and attributes.
.PP
As Andreas Zeller points out in his article \*(L"Beautiful Debugging\*(R" 
finding the causes of a failing program must follow the scientific method:
.IP "1. Observe the failure (there are conflicts or ambiguity, there are precedence problems, there are semantic errors, the output is wrong)" 2
.IX Item "1. Observe the failure (there are conflicts or ambiguity, there are precedence problems, there are semantic errors, the output is wrong)"
.PD 0
.ie n .IP "2. Guess a hypothesis for the failure (if necessary use ""eyapp"" ""\-v"" option, ""yydebug"", the Perl debugger, etc. to build the hypothesis). If you use continuous testing it is likely related with the recently written code." 2
.el .IP "2. Guess a hypothesis for the failure (if necessary use \f(CWeyapp\fR \f(CW\-v\fR option, \f(CWyydebug\fR, the Perl debugger, etc. to build the hypothesis). If you use continuous testing it is likely related with the recently written code." 2
.IX Item "2. Guess a hypothesis for the failure (if necessary use eyapp -v option, yydebug, the Perl debugger, etc. to build the hypothesis). If you use continuous testing it is likely related with the recently written code."
.IP "3. Based on your hypothesis make predictions" 2
.IX Item "3. Based on your hypothesis make predictions"
.ie n .IP "3. Using appropriate input tests and the available tools (""eyapp"" ""\-v"" option, ""yydebug"", the Perl debugger, etc.) see if your predictions hold. Reject your hypothesis if they don't hold." 2
.el .IP "3. Using appropriate input tests and the available tools (\f(CWeyapp\fR \f(CW\-v\fR option, \f(CWyydebug\fR, the Perl debugger, etc.) see if your predictions hold. Reject your hypothesis if they don't hold." 2
.IX Item "3. Using appropriate input tests and the available tools (eyapp -v option, yydebug, the Perl debugger, etc.) see if your predictions hold. Reject your hypothesis if they don't hold."
.IP "4. Repeat the last two steps until your hypothesis is confirmed. The hypothesis then becomes a theory." 2
.IX Item "4. Repeat the last two steps until your hypothesis is confirmed. The hypothesis then becomes a theory."
.IP "5. Convert the knowledge and informal tests developed during this process in a formal test that covers the failure" 2
.IX Item "5. Convert the knowledge and informal tests developed during this process in a formal test that covers the failure"
.PD
.ie n .SH "THE %strict DIRECTIVE"
.el .SH "THE \f(CW%strict\fP DIRECTIVE"
.IX Header "THE %strict DIRECTIVE"
By default, identifiers appearing in the rule section
will be classified as terminal if they don't appear 
in the left hand side of any production rules.
.PP
The directive \f(CW%strict\fR forces the declaration of all tokens. 
The following \f(CW\*(C`eyapp\*(C'\fR program issues a warning:
.PP
.Vb 7
\&  pl@nereida:~/LEyapp/examples/eyapplanguageref$ cat \-n bugyapp2.eyp
\&       1  %strict
\&       2  %%
\&       3  expr: NUM;
\&       4  %%
\&  pl@nereida:~/LEyapp/examples/eyapplanguageref$ eyapp bugyapp2.eyp
\&  Warning! Non declared token NUM at line 3 of bugyapp2.eyp
.Ve
.PP
To keep silent the compiler declare all tokens using
one of the token declaration directives (\f(CW%token\fR, \f(CW%left\fR, etc.)
.PP
.Vb 9
\&  pl@nereida:~/LEyapp/examples/eyapplanguageref$ cat \-n bugyapp3.eyp
\&       1  %strict
\&       2  %token NUM
\&       3  %%
\&       4  expr: NUM;
\&       5  %%
\&  pl@nereida:~/LEyapp/examples/eyapplanguageref$ eyapp bugyapp3.eyp
\&  pl@nereida:~/LEyapp/examples/eyapplanguageref$ ls \-ltr | tail \-1
\&  \-rw\-r\-\-r\-\- 1 pl users 2395 2008\-10\-02 09:41 bugyapp3.pm
.Ve
.PP
It is a good practice to use \f(CW%strict\fR at the beginning of your grammar.
.SH "CONFLICTS AND AMBIGUITIES"
.IX Header "CONFLICTS AND AMBIGUITIES"
.SS "Understanding Priorities"
.IX Subsection "Understanding Priorities"
Token and production priorities are used to solve conflicts.
Recall the main points of yacc-like parsers related to priorities:
.IP "\(bu" 2
The directives
.Sp
.Vb 3
\&            %left
\&            %right
\&            %nonassoc
.Ve
.Sp
can be used in the head section to declare the priority of a token
.IP "\(bu" 2
The later the declaration line the higher the priority
.IP "\(bu" 2
The precedence of a production rule (right hand side) is the precedence
of the last token in the right hand side
.IP "\(bu" 2
In a shift-reduce conflict the default action is to shift. This action can be changed
if the production and the token have explicit priorities
.IP "\(bu" 2
If the precedence of the production rule is higher the shift-reduce conflict is solved 
in favor of the reduction
.IP "\(bu" 2
If the precedence of the token is higher the shift-reduce conflict is solved 
in favor of the shift
.IP "\(bu" 2
If the precedence of the token is the same than the precedence of the rule, and is left 
the shift-reduce conflict is solved in favor of the reduction
.IP "\(bu" 2
If the precedence of the token is the same than the precedence of the rule, and is right 
the shift-reduce conflict is solved in favor of the shift
.IP "\(bu" 2
If the precedence of the token is the same than the precedence of the rule, and is nonassoc 
the presence of a shift-reduce conflict means an error.
This is used to describe operators, like the operator \f(CW\*(C`.LT.\*(C'\fR in \s-1FORTRAN, \s0
that may not associate with themselves. That is, because
.Sp
.Vb 1
\&                             A .LT. B .LT. C
.Ve
.Sp
is invalid in \s-1FORTRAN, \s0\f(CW\*(C`.LT.\*(C'\fR would be described with the keyword \f(CW%nonassoc\fR in eyapp.
.IP "\(bu" 2
The default precedence of a production can be changed using the \f(CW\*(C`%prec TOKEN\*(C'\fR directive.
Now the rule has the precedence and associativity of the specified \f(CW\*(C`TOKEN\*(C'\fR.
.PP
The program \f(CW\*(C`Precedencia.eyp\*(C'\fR illustrates the way priorities work in \f(CW\*(C`eyapp\*(C'\fR:
.PP
.Vb 5
\&  pl@europa:~/LEyapp/examples/debuggingtut$ eyapp \-c Precedencia.eyp
\&  %token NUM
\&  %left \*(Aq@\*(Aq
\&  %right \*(Aq&\*(Aq dummy
\&  %tree
\&
\&  %%
\&
\&  list:
\&      | list \*(Aq\en\*(Aq
\&      | list e
\&  ;
\&  e:
\&        %name NUM
\&        NUM
\&      | %name AMPERSAND
\&        e \*(Aq&\*(Aq e
\&      | %name AT
\&        e \*(Aq@\*(Aq e %prec dummy
\&  ;
\&
\&  %%
.Ve
.PP
See an execution:
.PP
.Vb 11
\&  pl@europa:~/LEyapp/examples/debuggingtut$ ./Precedencia.pm
\&  Expressions. Press CTRL\-D (Unix) or CTRL\-Z (Windows) to finish:
\&  2@3@4
\&  2@3&4
\&  2&3@4
\&  2&3&4
\&  <CTRL\-D>
\&  AT(AT(NUM(TERMINAL[2]),NUM(TERMINAL[3])),NUM(TERMINAL[4]))
\&  AT(NUM(TERMINAL[2]),AMPERSAND(NUM(TERMINAL[3]),NUM(TERMINAL[4])))
\&  AT(AMPERSAND(NUM(TERMINAL[2]),NUM(TERMINAL[3])),NUM(TERMINAL[4]))
\&  AMPERSAND(NUM(TERMINAL[2]),AMPERSAND(NUM(TERMINAL[3]),NUM(TERMINAL[4])))
.Ve
.PP
See if you are able to understand the output:
.IP "\(bu" 2
\&\f(CW\*(C`2@3@4\*(C'\fR: The phrase is interpreted as \f(CW\*(C`(2@3)@4\*(C'\fR 
since the rule \f(CW\*(C`e \*(Aq@\*(Aq e\*(C'\fR has the precedence of the token \f(CW\*(C`dummy\*(C'\fR which is stronger  
that then priority of token \f(CW\*(C`@\*(C'\fR. The conflict is solved in favor of the reduction
.IP "\(bu" 2
\&\f(CW\*(C`2@3&4\*(C'\fR: The rule \f(CW\*(C`e \*(Aq@\*(Aq e\*(C'\fR has the precedence of \f(CW\*(C`dummy\*(C'\fR
which is the same than the token \f(CW\*(C`&\*(C'\fR. The associativity decides. Since they were declared \f(CW%right\fR
the conflict is solved in favor of the shift. The phrase is interpreted as
\&\f(CW\*(C`2@(3&4)\*(C'\fR
.IP "\(bu" 2
\&\f(CW\*(C`2&3@4\*(C'\fR: The rule \f(CW\*(C`e \*(Aq&\*(Aq e\*(C'\fR has more precedence than the token \f(CW\*(C`@\*(C'\fR. The 
phrase is interpreted as \f(CW\*(C`(2&3)@4\*(C'\fR
.IP "\(bu" 2
\&\f(CW\*(C`2&3&4\*(C'\fR: Both the rule and the token have the same precedence. Since they were declared
\&\f(CW%right\fR, the conflict is solved in favor of the shift. The phrase is interpreted as \f(CW\*(C`2&(3&4)\*(C'\fR
.ie n .SS "An ""eyapp"" Program with Errors"
.el .SS "An \f(CWeyapp\fP Program with Errors"
.IX Subsection "An eyapp Program with Errors"
The following simplified \f(CW\*(C`eyapp\*(C'\fR program has some errors.
The generated language is made of lists 
of declarations (\f(CW\*(C`D\*(C'\fR stands for declaration)
followed by lists of sentences (\f(CW\*(C`S\*(C'\fR stands for statement)
separated by semicolons:
.PP
.Vb 10
\&  pl@nereida:~/LEyapp/examples/debuggingtut$ cat \-n Debug.eyp                   
\&     1  %{                                                                    
\&     2  =head1 SYNOPSIS                                                       
\&     3                                                                        
\&     4  This grammar has an unsolved shift\-reduce conflict.                   
\&     5                                                                        
\&     6  Be sure C<DebugTail.pm> is reachable.                                 
\&     7  Compile it with                                                       
\&     8                                                                        
\&     9        eyapp \-b \*(Aq\*(Aq Debug.eyp                                           
\&    10                                                                        
\&    11  See the C<Debug.output> file generated.                               
\&    12  Execute the generated modulino with:                                  
\&    13                                                                        
\&    14        ./Debug.pm \-d  # to activate debugging                          
\&    15        ./Debug.pm \-h  # for help
\&    16
\&    17  The generated parser will not recognize any input, since its shifts forever.
\&    18  Try input C<\*(AqD; D; S\*(Aq>.
\&    19
\&    20  =head1 See also
\&    21
\&    22      http://search.cpan.org/perldoc?Parse::Eyapp::debuggingtut
\&    23
\&    24      Debug1.eyp Debug2.eyp DebugLookForward.eyp DebugDynamicResolution.eyp
\&    25
\&    26  =cut
\&    27
\&    28  our $VERSION = \*(Aq0.01\*(Aq;
\&    29  use base q{DebugTail};
\&    30
\&    31  %}
\&    32
\&    33  %token D S
\&    34
\&    35  %%
\&    36  p:
\&    37      ds \*(Aq;\*(Aq ss
\&    38    | ss
\&    39  ;
\&    40
\&    41  ds:
\&    42      D \*(Aq;\*(Aq ds
\&    43    | D          /* this production is never used */
\&    44  ;
\&    45
\&    46  ss:
\&    47      S \*(Aq;\*(Aq ss
\&    48    | S
\&    49  ;
\&    50
\&    51  %%
\&    52
\&    53  _\|_PACKAGE_\|_\->main(\*(AqProvide a statement like "D; D; S" and press <CR><CTRL\-D>: \*(Aq) unless caller;
.Ve
.SS "Focusing in the Grammar"
.IX Subsection "Focusing in the Grammar"
Sometimes the presence of actions, attribute names and support code 
makes more difficult the readability of the grammar. You can use the \f(CW\*(C`\-c\*(C'\fR
option of eyapp, to see only the syntactic parts:
.PP
.Vb 2
\&  $ eyapp \-c examples/debuggingtut/Debug.eyp
\&  %token D S
\&
\&  %%
\&
\&  p:
\&        ds \*(Aq;\*(Aq ss
\&      | ss
\&  ;
\&  ds:
\&        D \*(Aq;\*(Aq ds
\&      | D
\&  ;
\&  ss:
\&        S \*(Aq;\*(Aq ss
\&      | S
\&  ;
\&
\&  $
.Ve
.PP
It is clear now that the language generated by this grammar is made of 
non empty sequences of \f(CW\*(C`D\*(C'\fR followed by non empty sequences of <S>
separated by semicolons.
.SS "Detecting Conflicts"
.IX Subsection "Detecting Conflicts"
When compiling this grammar,
\&\f(CW\*(C`eyapp\*(C'\fR produces a warning message announcing the existence of a
conflict:
.PP
.Vb 4
\&  pl@nereida:~/LEyapp/examples$ eyapp Debug.eyp
\&  1 shift/reduce conflict (see .output file)
\&  State 4: shifts:
\&    to state    8 with \*(Aq;\*(Aq
.Ve
.ie n .SS "Studying the "".output"" file"
.el .SS "Studying the \f(CW.output\fP file"
.IX Subsection "Studying the .output file"
The existence of warnings triggers the creation of a file
\&\f(CW\*(C`Debug.output\*(C'\fR 
containing information about 
the grammar and the syntax analyzer.
.PP
Let us see the contents of the \f(CW\*(C`Debug.output\*(C'\fR file:
.PP
.Vb 10
\&  pl@nereida:~/LEyapp/examples$ cat \-n Debug.output
\&     1  Warnings:
\&     2  \-\-\-\-\-\-\-\-\-
\&     3  1 shift/reduce conflict (see .output file)
\&     4  State 4: shifts:
\&     5    to state    8 with \*(Aq;\*(Aq
\&     6
\&     7  Conflicts:
\&     8  \-\-\-\-\-\-\-\-\-\-
\&     9  State 4 contains 1 shift/reduce conflict
\&    10
\&    11  Rules:
\&    12  \-\-\-\-\-\-
\&    13  0:      $start \-> p $end
\&    14  1:      p \-> ds \*(Aq;\*(Aq ss
\&    15  2:      p \-> ss
\&    16  3:      ds \-> D \*(Aq;\*(Aq ds
\&    17  4:      ds \-> D
\&    18  5:      ss \-> S \*(Aq;\*(Aq ss
\&    19  6:      ss \-> S
\&    20
\&    21  States:
\&    22  \-\-\-\-\-\-\-
\&    23  State 0:
\&    24
\&    25          $start \-> . p $end      (Rule 0)
\&    26
\&    27          D       shift, and go to state 4
\&    28          S       shift, and go to state 1
\&    29
\&    30          p       go to state 2
\&    31          ss      go to state 3
\&    32          ds      go to state 5
\&    33
\&    ..  .........................................
\&    55  State 4:
\&    56
\&    57          ds \-> D . \*(Aq;\*(Aq ds        (Rule 3)
\&    58          ds \-> D .       (Rule 4)
\&    59
\&    60          \*(Aq;\*(Aq     shift, and go to state 8
\&    61
\&    62          \*(Aq;\*(Aq     [reduce using rule 4 (ds)]
\&    63
\&    ..  .........................................
\&    84  State 8:
\&    85
\&    86          ds \-> D \*(Aq;\*(Aq . ds        (Rule 3)
\&    87
\&    88          D       shift, and go to state 4
\&    89
\&    90          ds      go to state 11
\&    91
\&    ..  .........................................
\&   112  State 12:
\&   113
\&   114          p \-> ds \*(Aq;\*(Aq ss .        (Rule 1)
\&   115
\&   116          $default        reduce using rule 1 (p)
\&   117
\&   118
\&   119  Summary:
\&   120  \-\-\-\-\-\-\-\-
\&   121  Number of rules         : 7
\&   122  Number of terminals     : 4
\&   123  Number of non\-terminals : 4
\&   124  Number of states        : 13
.Ve
.PP
The parser generated by \f(CW\*(C`Parse::Eyapp\*(C'\fR
is based on a \fIdeterministic finite automaton\fR. 
Each state of the automaton \fIremembers\fR what production rules
are candidates to apply and what have been seen
from the right hand side of the production rule. 
The problem, according to the warning, occurs in state 4.
State 4 contains:
.PP
.Vb 9
\&    55  State 4:
\&    56
\&    57          ds \-> D . \*(Aq;\*(Aq ds        (Rule 3)
\&    58          ds \-> D .       (Rule 4)
\&    59
\&    60          \*(Aq;\*(Aq     shift, and go to state 8
\&    61
\&    62          \*(Aq;\*(Aq     [reduce using rule 4 (ds)]
\&    63
.Ve
.PP
An state is a set of production rules with a marker 
(the dot in rules 3 and 4)
somewhere in its right hand side. 
If the parser is in state 4 
is because the production rules \f(CW\*(C`ds \-> D \*(Aq;\*(Aq ds\*(C'\fR
and \f(CW\*(C`ds \-> D\*(C'\fR are potential candidates 
to build the syntax tree. That they will win or not
depends on what will happen next when more
input is processed.
.PP
The dot that appears on the right hand side 
means \fIposition\fR in our guessing. The fact
that \f(CW\*(C`ds \-> D .\*(Aq;\*(Aq ds\*(C'\fR
is in state 4 means that if the parser is in state 4 we have already seen 
\&\f(CW\*(C`D\*(C'\fR  and we 
expect to see a semicolon followed by \f(CW\*(C`ds\*(C'\fR (or something
derivable from \f(CW\*(C`ds\*(C'\fR). If such thing happens 
this production will be the right one (will be the \fIhandle\fR
in the jargon). The comment
.PP
.Vb 1
\&    60          \*(Aq;\*(Aq     shift, and go to state 8
.Ve
.PP
means that if the next token is a semicolon the next state
will be state 8:
.PP
.Vb 7
\&    84  State 8:
\&    85
\&    86          ds \-> D \*(Aq;\*(Aq . ds        (Rule 3)
\&    87
\&    88          D       shift, and go to state 4
\&    89
\&    90          ds      go to state 11
.Ve
.PP
As we see state 8 has the item \f(CW\*(C`ds \-> D \*(Aq;\*(Aq . ds\*(C'\fR which
means that we have already seen a \f(CW\*(C`D\*(C'\fR and a semicolon.
.PP
The fact that \f(CW\*(C`ds \-> D .\*(C'\fR is in state 4 means that we have already seen 
\&\f(CW\*(C`D\*(C'\fR and since the dot is at the end of the rule,
this production can be the right one, even if
a semicolon is just waiting in the input. 
An example that it will be correct to \*(L"reduce\*(R" by the rule
\&\f(CW\*(C`ds \-> D .\*(C'\fR in the presence of a semicolon is given by the
input \f(CW\*(C`D ; S\*(C'\fR. A rightmost derivation for such input is:
.PP
.Vb 1
\&  p => ds ; ss => ds ; S => D ; S
.Ve
.PP
that is processed by the \s-1\fILALR\s0\fR\|(1) algorithm 
following this sequence of actions:
.PP
.Vb 10
\& +\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-+
\& | rule     | read    | input   |
\& |          |         | D ; S $ |
\& |          | D       |   ; S $ |
\& | ds\->d    | ds      |   ; S $ |
\& |          | ds ;    |     S $ |
\& |          | ds ; S  |       $ |
\& | ss\->s    | ds ; ss |       $ |
\& | p\->ds;ss | p       |         |
\& +\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-+
.Ve
.PP
Since it is correct to reduce in some cases
by the production \f(CW\*(C`ds \-> D .\*(C'\fR
and others in which is correct to shift the semicolon,
\&\f(CW\*(C`eyapp\*(C'\fR complains about a shift/reduce 
conflict with \f(CW\*(Aq;\*(Aq\fR. State 4 has two
rules that compete to be the right one:
.PP
.Vb 2
\&  pl@nereida:~/LEyapp/examples$ eyapp Debug.eyp
\&  1 shift/reduce conflict (see .output file)
.Ve
.PP
We can guess that the right item (the rules with the dot, i.e. the states 
of the automaton are called \s-1\fILALR\s0\fR\|(0) items in the yacc jargon)  is 
\&\f(CW\*(C`ds \-> D .\*(Aq;\*(Aq ds\*(C'\fR and 
\&\fIshift to state 8\fR consuming the semicolon,
expecting to see something derivable from \f(CW\*(C`ds\*(C'\fR later
or guess that  \f(CW\*(C`ds \-> D .\*(C'\fR is the right \s-1\fILR\s0\fR\|(0) item
and \fIreduce\fR for such rule. This is the meaning of the comments in 
state 4:
.PP
.Vb 3
\&    60          \*(Aq;\*(Aq     shift, and go to state 8
\&    61
\&    62          \*(Aq;\*(Aq     [reduce using rule 4 (ds)]
.Ve
.PP
To illustrate the problem let us consider the phrases
\&\f(CW\*(C`D;S\*(C'\fR and \f(CW\*(C`D;D;S\*(C'\fR.
.PP
For both phrases, after consuming the \f(CW\*(C`D\*(C'\fR 
the parser will go to state 4 and the current token will be the semicolon.
.PP
For the first phrase 
\&\f(CW\*(C`D;S\*(C'\fR the correct decision
is to use rule 4 \f(CW\*(C`ds \-> D\*(C'\fR (to \fIreduce\fR in the jargon).
For the second phrase 
\&\f(CW\*(C`D;D;S\*(C'\fR the correct decision is to follow rule 3
\&\f(CW\*(C`ds \-> D . \*(Aq;\*(Aq ds\*(C'\fR.
.PP
The parser generated by \f(CW\*(C`eyapp\*(C'\fR would be able to know 
which rule is correct for each
case if it were allowed to look at the token after the semicolon:
if it is a \f(CW\*(C`S\*(C'\fR is rule 4, if it is a \f(CW\*(C`D\*(C'\fR is rule 3.
But the parsers generated by \f(CW\*(C`Eyapp\*(C'\fR do not lookahead more than the
next token (this is what the \*(L"1\*(R" means when we say that 
\&\f(CW\*(C`Parse::Eyapp\*(C'\fR parsers are \s-1\fILALR\s0\fR\|(1)) and therefore
is not in condition to decide which production rule applies.
.PP
Unfortunately this is the sort of conflict that can't be solved
by assigning priorities to the productions and tokens 
as it was done for the calculator example 
in Parse::Eyapp::eyappintro. If we run the analyzer
it will refuse to accept correct entries like \f(CW\*(C`D;D;S\*(C'\fR:
.PP
.Vb 10
\&  pl@europa:~/LEyapp/examples/debuggingtut$ eyapp \-b \*(Aq\*(Aq \-o debug.pl Debug.eyp
\&  1 shift/reduce conflict (see .output file)
\&  State 4: shifts:
\&    to state    8 with \*(Aq;\*(Aq
\&  pl@europa:~/LEyapp/examples/debuggingtut$ ./debug.pl
\&  D;D;S
\&  \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&  In state 0:
\&  Stack:[0]
\&  Need token. Got >D<
\&  Shift and go to state 4.
\&  \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&  In state 4:
\&  Stack:[0,4]
\&  Need token. Got >;<
\&  Shift and go to state 8.
\&  \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&  In state 8:
\&  Stack:[0,4,8]
\&  Need token. Got >D<
\&  Shift and go to state 4.
\&  \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&  In state 4:
\&  Stack:[0,4,8,4]
\&  Need token. Got >;<
\&  Shift and go to state 8.
\&  \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&  In state 8:
\&  Stack:[0,4,8,4,8]
\&  Need token. Got >S<
\&  Syntax error near input: \*(AqS\*(Aq line num 1
.Ve
.PP
The default parsing action is to shift
the token \f(CW\*(C`;\*(C'\fR giving priority to the production
.PP
.Vb 1
\&           ds \-> D . \*(Aq;\*(Aq ds
.Ve
.PP
over the production
.PP
.Vb 1
\&           ds \-> D .
.Ve
.PP
Since no \f(CW\*(C`ds\*(C'\fR  production starts with \f(CW\*(C`S\*(C'\fR,
the presence of \f(CW\*(C`S\*(C'\fR is (erroneously)
interpreted as an error.
.PP
\fIThe Importance of the \s-1FOLLOW\s0 Set\fR
.IX Subsection "The Importance of the FOLLOW Set"
.PP
You may wonder why the productions
.PP
.Vb 4
\&  ss:
\&        S \*(Aq;\*(Aq ss
\&      | S
\&  ;
.Ve
.PP
do not also produce a shift-reduce conflict with the semicolon. This is because the reduction
by \f(CW\*(C`ss \-> S\*(C'\fR always corresponds to the last \f(CW\*(C`S\*(C'\fR in a derivation:
.PP
.Vb 1
\&   ss => S ; ss => S ; S ; ss => S ; S; S
.Ve
.PP
and thus, the reduction by \f(CW\*(C`ss \-> S\*(C'\fR only occurs in the presence
of the \f(CW\*(C`end of input\*(C'\fR token and never with the semicolon. 
The \s-1FOLLOW\s0 set of a syntactic variable 
is the set of tokens that may appear next to such variable
in some derivation. While the semicolon \f(CW\*(C`;\*(C'\fR is in the \s-1FOLLOW\s0 of \f(CW\*(C`dd\*(C'\fR,
it isn't in the \s-1FOLLOW\s0 of \f(CW\*(C`ss\*(C'\fR.
.SS "Solving Shift-Reduce Conflicts by Factorizing"
.IX Subsection "Solving Shift-Reduce Conflicts by Factorizing"
To solve the former conflict the \f(CW\*(C`Eyapp\*(C'\fR programmer
has to reformulate the grammar modifying
priorities and reorganizing the rules.
Rewriting the recursive rule for \f(CW\*(C`ds\*(C'\fR to
be let recursive solves the conflict:
.PP
.Vb 7
\&  pl@nereida:~/LEyapp/examples/debuggingtut$ sed \-ne \*(Aq/^ds:/,/^;/p\*(Aq Debug1.eyp | cat \-n
\&     1  ds:
\&     2      %name D2
\&     3        ds \*(Aq;\*(Aq D
\&     4    | %name D1
\&     5        D
\&     6  ;
.Ve
.PP
Now, for any phrase matching the pattern \f(CW\*(C`D ; ...\*(C'\fR the action to build
the tree is to reduce by
\&\f(CW\*(C`ds \-> D\*(C'\fR.
.PP
The rightmost reverse derivation for \f(CW\*(C`D;D;S\*(C'\fR is:
.PP
.Vb 3
\&             Derivation                 |             Tree
\&  \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&  D;D;S <= ds;D;S <= ds;S <= ds;ss <= p |  p(ds(ds(D),\*(Aq;\*(Aq,D),\*(Aq;\*(Aq,ss(S))
.Ve
.PP
while the rightmost reverse derivation for \f(CW\*(C`D;S\*(C'\fR is:
.PP
.Vb 3
\&             Derivation                 |             Tree
\&  \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&  D;S <= ds;S <= ds;ss <= p             |      p(ds(D),\*(Aq;\*(Aq,ss(S))
.Ve
.PP
When we recompile the modified grammar no warnings appear:
.PP
.Vb 2
\&  pl@nereida:~/LEyapp/examples$ eyapp Debug1.eyp
\&  pl@nereida:~/LEyapp/examples$
.Ve
.SS "Solving Shift-Reduce Conflicts By Looking Ahead"
.IX Subsection "Solving Shift-Reduce Conflicts By Looking Ahead"
The problem here is that \f(CW\*(C`Eyapp/Yapp/Yacc\*(C'\fR etc. produce \s-1\fILALR\s0\fR\|(1) parsers.
They only look the next token. 
We can decide how to solve the conflict by rewriting the lexical analyzer 
to peer forward what token comes after the semicolon: it now returns
\&\f(CW\*(C`SEMICOLONS\*(C'\fR if it is an \f(CW\*(C`S\*(C'\fR and 
\&\f(CW\*(C`SEMICOLOND\*(C'\fR if it is an \f(CW\*(C`D\*(C'\fR.
Here is a solution based in this idea:
.PP
.Vb 10
\&  pl@nereida:~/LEyapp/examples/debuggingtut$ cat \-n DebugLookForward.eyp               
\&     1  /*VIM: set ts=2 */                                                           
\&     2  %{                                                                           
\&     3  =head1 SYNOPSIS                                                              
\&     4                                                                               
\&     5  See                                                                          
\&     6                                                                               
\&     7     http://search.cpan.org/perldoc?Parse::Eyapp::debuggingtut                 
\&     8     file DebugLookForward.eyp                                                 
\&     9                                                                               
\&    10  This grammar fixes the conflicts an bugs in Debug.eyp and Debug1.eyp         
\&    11                                                                               
\&    12  Be sure C<DebugTail.pm> is reachable                                         
\&    13  compile it with                                                              
\&    14                                                                               
\&    15        eyapp \-b \*(Aq\*(Aq DebugLookForward.eyp                                       
\&    16                                                                               
\&    17  execute the generated modulino with:                                         
\&    18                                                                               
\&    19        ./DebugLookForward.pm \-t                                               
\&    20                                                                               
\&    21  =head1 See also                                                              
\&    22                                                                               
\&    23      Debug.eyp Debug1.eyp Debug2.eyp                                          
\&    24                                                                               
\&    25  =cut                                                                         
\&    26                                                                               
\&    27  our $VERSION = \*(Aq0.01\*(Aq;                                                       
\&    28  use base q{DebugTail};                                                       
\&    29                                                                               
\&    30  %}                                                                           
\&    31                                                                               
\&    32  %token D S                                                                   
\&    33  %syntactic token SEMICOLONS SEMICOLOND                                       
\&    34                                                                               
\&    35  %tree                                                                        
\&    36                                                                               
\&    37  %%                                                                           
\&    38  p:                                                                           
\&    39      %name P                                                                  
\&    40      ds SEMICOLONS ss                                                         
\&    41    | %name SS
\&    42      ss
\&    43  ;
\&    44
\&    45  ds:
\&    46      %name D2
\&    47        D SEMICOLOND ds
\&    48    | %name D1
\&    49        D
\&    50  ;
\&    51
\&    52  ss:
\&    53      %name S2
\&    54        S SEMICOLONS ss
\&    55    | %name S1
\&    56        S
\&    57  ;
\&    58
\&    59  %%
\&    60
\&    61  _\|_PACKAGE_\|_\->lexer(
\&    62    sub {
\&    63      my $self = shift;
\&    64
\&    65      for (${$self\->input()}) {
\&    66         s{^(\es+)}{} and $self\->tokenline($1 =~ tr{\en}{});
\&    67         return (\*(Aq\*(Aq,undef) unless $_;
\&    68
\&    69         return ($1,$1) if s/^([sSDd])//;
\&    70         return (\*(AqSEMICOLOND\*(Aq, \*(AqSEMICOLOND\*(Aq) if s/^;\es*D/D/;
\&    71         return (\*(AqSEMICOLONS\*(Aq, \*(AqSEMICOLONS\*(Aq) if s/^;\es*S/S/;
\&    72         die "Syntax error at line num ${$self\->tokenline()}: ${substr($_,0,10)}\en";
\&    73      }
\&    74      return (\*(Aq\*(Aq,undef);
\&    75    }
\&    76  );
\&    77
\&    78  _\|_PACKAGE_\|_\->main unless caller();
.Ve
.SH "ERRORS DURING TREE CONSTRUCTION"
.IX Header "ERRORS DURING TREE CONSTRUCTION"
Though \f(CW\*(C`Debug1.pm\*(C'\fR seems to work:
.PP
.Vb 3
\&  pl@nereida:~/LEyapp/examples/debuggingtut$ ./Debug1.pm \-t
\&  Try first "D;S" and then "D; D;  S" (press <CR><CTRL\-D> to finish): D;D;S
\&  P(D2(D1(TERMINAL[D]),TERMINAL[D]),S1(TERMINAL[S]))
.Ve
.PP
There are occasions where we observe an abnormal behavior:
.PP
.Vb 3
\&  pl@nereida:~/LEyapp/examples/debuggingtut$ ./Debug1.pm \-t
\&  Try first "D;S" and then "D; D;  S" (press <CR><CTRL\-D> to finish):
\&  D
\&
\&  ;
\&
\&  D
\&
\&  ;
\&  S
\&  Syntax error near end of input line num 3. Expecting (;)
.Ve
.PP
We can activate the option \f(CW\*(C`yydebug => 0xF\*(C'\fR
in the call to the parser method \f(CW\*(C`YYParser\*(C'\fR.
The integer parameter \f(CW\*(C`yydebug\*(C'\fR of \f(CW\*(C`new\*(C'\fR and \f(CW\*(C`YYParse\*(C'\fR
controls the level of debugging. Different levels of 
verbosity can be obtained by setting the bits of this
argument. It works as follows:
.PP
.Vb 10
\&     /============================================================\e
\&     | Bit Value  | Outputs                                       |
\&     |\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-|
\&     |  0x01      |  Token reading (useful for Lexer debugging)   |
\&     |\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-|
\&     |  0x02      |  States information                           |
\&     |\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-|
\&     |  0x04      |  Driver actions (shifts, reduces, accept...)  |
\&     |\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-|
\&     |  0x08      |  Parse Stack dump                             |
\&     |\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-|
\&     |  0x10      |  Error Recovery tracing                       |
\&     \e============================================================/
.Ve
.PP
Let us see what happens when the input is \f(CW\*(C`D;S\*(C'\fR. We have introduced
some white spaces and carriage returns between the terminals:
.PP
.Vb 3
\&  pl@nereida:~/LEyapp/examples/debuggingtut$ ./Debug1.pm \-d
\&  Try first "D;S" and then "D; D;  S" (press <CR><CTRL\-D> to finish):
\&  D
\&
\&  ;
\&
\&  D
\&
\&  ;
\&  S
\&  \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&  In state 0:
\&  Stack:[0]
\&  Need token. Got >D<
\&  Shift and go to state 4.
\&  \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&  In state 4:
\&  Stack:[0,4]
\&  Don\*(Aqt need token.
\&  Reduce using rule 4 (ds \-\-> D): Back to state 0, then go to state 5.
\&  \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&  In state 5:
\&  Stack:[0,5]
\&  Need token. Got ><
\&  Syntax error near end of input line num 3. Expecting (;)
.Ve
.PP
What's going on?
After reading the carriage return
.PP
.Vb 1
\&   Need token. Got >D<
.Ve
.PP
the parser receives an end of file. XWhy?.
Something is going wrong in the communications between lexical analyzer
and parser. Let us review the lexical analyzer:
.PP
.Vb 10
\&  pl@nereida:~/LEyapp/examples/debuggingtut$ sed \-ne \*(Aq/lexer/,/^)/p\*(Aq Debug1.eyp | cat \-n
\&     1  _\|_PACKAGE_\|_\->lexer(
\&     2    sub {
\&     3      my $self = shift;
\&     4
\&     5      for (${$self\->input()}) {  # contextualize
\&     6          s{^(\es)}{} and $self\->tokenline($1 =~ tr{\en}{});
\&     7
\&     8          return (\*(Aq\*(Aq, undef) unless $_;
\&     9          return ($1, $1) if s/^(.)//;
\&    10      }
\&    11      return (\*(Aq\*(Aq, undef);
\&    12    }
\&    13  );
.Ve
.PP
The error is at line 6. Only a single white space is eaten!
The second carraige return in the input does not match lines 8 and 9 and the 
contextualizing \f(CW\*(C`for\*(C'\fR finishes. Line 11 then unconditionally returns
the \f(CW\*(C`(\*(Aq\*(Aq,undef)\*(C'\fR signaling the end of input.
.PP
The grammar in file \f(CW\*(C`Debug2.eyp\*(C'\fR fixes the problem:
Now the analysis seems to work for this kind of input:
.PP
.Vb 4
\&  pl@nereida:~/LEyapp/examples/debuggingtut$ eyapp \-b \*(Aq\*(Aq Debug2.eyp                     
\&  pl@nereida:~/LEyapp/examples/debuggingtut$ ./Debug2.pm \-t \-d                          
\&  Provide a statement like "D; D; S" and press <CR><CTRL\-D>:                            
\&  D                                                                                     
\&
\&  ;
\&
\&  D
\&
\&  ;
\&  S
\&  \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&  In state 0:                             
\&  Stack:[0]                               
\&  Need token. Got >D<                     
\&  Shift and go to state 4.                
\&  \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&  In state 4:                             
\&  Stack:[0,4]                             
\&  Don\*(Aqt need token.                       
\&  Reduce using rule 4 (ds \-\-> D): Back to state 0, then go to state 5.
\&  \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-                            
\&  In state 5:                                                         
\&  Stack:[0,5]                                                         
\&  Need token. Got >;<                                                 
\&  Shift and go to state 8.                                            
\&  \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-                            
\&  In state 8:
\&  Stack:[0,5,8]
\&  Need token. Got >D<
\&  Shift and go to state 11.
\&  \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&  In state 11:
\&  Stack:[0,5,8,11]
\&  Don\*(Aqt need token.
\&  Reduce using rule 3 (ds \-\-> ds ; D): Back to state 0, then go to state 5.
\&  \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&  In state 5:
\&  Stack:[0,5]
\&  Need token. Got >;<
\&  Shift and go to state 8.
\&  \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&  In state 8:
\&  Stack:[0,5,8]
\&  Need token. Got >S<
\&  Shift and go to state 1.
\&  \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&  In state 1:
\&  Stack:[0,5,8,1]
\&  Need token. Got ><
\&  Reduce using rule 6 (ss \-\-> S): Back to state 8, then go to state 10.
\&  \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&  In state 10:
\&  Stack:[0,5,8,10]
\&  Don\*(Aqt need token.
\&  Reduce using rule 1 (p \-\-> ds ; ss): Back to state 0, then go to state 2.
\&  \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&  In state 2:
\&  Stack:[0,2]
\&  Shift and go to state 7.
\&  \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&  In state 7:
\&  Stack:[0,2,7]
\&  Don\*(Aqt need token.
\&  Accept.
\&  P(D2(D1(TERMINAL[D]),TERMINAL[D]),S1(TERMINAL[S]))
.Ve
.ie n .SH "THE LR PARSING ALGORITHM: UNDERSTANDING THE OUTPUT OF ""yydebug"""
.el .SH "THE LR PARSING ALGORITHM: UNDERSTANDING THE OUTPUT OF \f(CWyydebug\fP"
.IX Header "THE LR PARSING ALGORITHM: UNDERSTANDING THE OUTPUT OF yydebug"
The \f(CW\*(C`YYParse\*(C'\fR methods implements the generic \s-1LR\s0 parsing algorithm.
It very much works \f(CW\*(C`Parse::Yapp::YYParse\*(C'\fR and as yacc/bison \f(CW\*(C`yyparse\*(C'\fR.
It accepts almost the same arguments as \f(CW\*(C`Class\->new\*(C'\fR (Being \f(CW\*(C`Class\*(C'\fR the name 
of the generated class).
.PP
The parser uses two tables and a stack. The two tables
are called the \fIaction\fR table and the \fIgoto\fR table.
The stack is used to keep track of the states visited.
.PP
At each step the generated parser consults the 
\&\f(CW\*(C`action\*(C'\fR table and takes one decision:
To shift to a new state consuming one token (and pushing 
the current state in the stack) or to reduce by some
production rule. In the last case the parser pops
from its stack as many states as symbols are on the right hand side
of the production rule. Here is a Perl/C like pseudocode
summarizing the activity of \f(CW\*(C`YYParse\*(C'\fR:
.PP
.Vb 10
\&     1   my $parser = shift; # The parser object
\&     2   push(@stack, $parser\->{startstate});
\&     3   $b = $parser\->YYLexer(); # Get the first token
\&     4   FOREVER: {
\&     5     $s = top(0);  # Get the state on top of the stack
\&     6     $a = $b;
\&     7     switch ($parser\->action[$s\->state][$a]) {
\&     8       case "shift t" : 
\&     9         my $t;
\&    10         $t\->{state} = t;
\&    11         $t\->{attr}  = $a\->{attr};
\&    12         push($t); 
\&    13         $b = $parser\->YYLexer(); # Call the lexical analyzer
\&    14         break;
\&    15       case "reduce A\->alpha" : 
\&    16         # Call the semantic action with the attributes of the rhs as args
\&    17         my $semantic  = $parser\->Semantic{A \->alpha}; # The semantic action
\&    18         my $r;
\&    19         $r\->{attr} = $semantic\->($parser, top(|alpha|\-1)\->attr, ... , top(0)\->attr); 
\&    20  
\&    21         # Pop as many states as symbols on the rhs of A\->alpha
\&    22         pop(|alpha|);  
\&    23  
\&    24         # Goto next state 
\&    25         $r\->{state} = $parser\->goto[top(0)][A]; 
\&    26         push($r); 
\&    27         break;
\&    28       case "accept" : return (1); 
\&    29       default : $parser\->YYError("syntax error"); 
\&    30     }
\&    31     redo FOREVER;
\&    32   }
.Ve
.PP
Here \f(CW\*(C`|alpha|\*(C'\fR stands for the length of \f(CW\*(C`alpha\*(C'\fR. Function \f(CWtop(k)\fR returns
the state in position \f(CW\*(C`k\*(C'\fR from the top of the stack, i.e. the state at depth \f(CW\*(C`k\*(C'\fR.
Function \f(CWpop(k)\fR extracts \f(CW\*(C`k\*(C'\fR states from the stack. The call \f(CW\*(C`$state\->attr\*(C'\fR
returns the attribute associated with \f(CW$state\fR. The call \f(CW\*(C`$parser\->Semantic{A \->alpha}\*(C'\fR
returns the semantic action associated with production \f(CW\*(C`A \->alpha\*(C'\fR.
.PP
Let us see a trace for the small grammar in \f(CW\*(C`examples/debuggingtut/aSb.yp\*(C'\fR:
.PP
.Vb 6
\&  pl@nereida:~/LEyapp/examples$ /usr/local/bin/paste.pl aSb.yp aSb.output | head \-5
\&  %%                                             | Rules:
\&  S:                 { print "S \-> epsilon\en" }  | \-\-\-\-\-\-
\&      |   \*(Aqa\*(Aq S \*(Aqb\*(Aq  { print "S \-> a S b\en" }    | 0:    $start \-> S $end
\&  ;                                              | 1:    S \-> /* empty */
\&  %%                                             | 2:    S \-> \*(Aqa\*(Aq S \*(Aqb\*(Aq
.Ve
.PP
The tables in file \f(CW\*(C`aSb.output\*(C'\fR describe the 
actions and transitions to take:
.PP
.Vb 10
\&  pl@nereida:~/LEyapp/examples$ cat \-n aSb.output
\&     .  .........................................
\&     7  States:
\&     8  \-\-\-\-\-\-\-
\&     9  State 0:
\&    10
\&    11          $start \-> . S $end      (Rule 0)
\&    12
\&    13          \*(Aqa\*(Aq     shift, and go to state 2
\&    14
\&    15          $default        reduce using rule 1 (S)
\&    16
\&    17          S       go to state 1
\&    18
\&    19  State 1:
\&    20
\&    21          $start \-> S . $end      (Rule 0)
\&    22
\&    23          $end    shift, and go to state 3
\&    24
\&    25  State 2:
\&    26
\&    27          S \-> \*(Aqa\*(Aq . S \*(Aqb\*(Aq        (Rule 2)
\&    28
\&    29          \*(Aqa\*(Aq     shift, and go to state 2
\&    30
\&    31          $default        reduce using rule 1 (S)
\&    32
\&    33          S       go to state 4
\&    34
\&    35  State 3:
\&    36
\&    37          $start \-> S $end .      (Rule 0)
\&    38
\&    39          $default        accept
\&    40
\&    41  State 4:
\&    42
\&    43          S \-> \*(Aqa\*(Aq S . \*(Aqb\*(Aq        (Rule 2)
\&    44
\&    45          \*(Aqb\*(Aq     shift, and go to state 5
\&    46
\&    47  State 5:
\&    48
\&    49          S \-> \*(Aqa\*(Aq S \*(Aqb\*(Aq .        (Rule 2)
\&    50
\&    51          $default        reduce using rule 2 (S)
\&    52
\&    53
\&    54  Summary:
\&    55  \-\-\-\-\-\-\-\-
\&    56  Number of rules         : 3
\&    57  Number of terminals     : 3
\&    58  Number of non\-terminals : 2
\&    59  Number of states        : 6
.Ve
.PP
When executed with \f(CW\*(C`yydebug\*(C'\fR set and input \f(CW\*(C`aabb\*(C'\fR  we obtain the following 
output:
.PP
.Vb 10
\&  pl@nereida:~/LEyapp/examples/debuggingtut$ eyapp \-b \*(Aq\*(Aq \-o use_aSb.pl aSb
\&  pl@nereida:~/LEyapp/examples/debuggingtut$ ./use_aSb.pl \-d
\&  Provide a statement like "a a b b" and press <CR><CTRL\-D>: aabb
\&  \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-                       
\&  In state 0:                                                    
\&  Stack:[0]                                                      
\&  Need token. Got >a<                                            
\&  Shift and go to state 2.                                       
\&  \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-                       
\&  In state 2:                                                    
\&  Stack:[0,2]                                                    
\&  Need token. Got >a<
\&  Shift and go to state 2.
\&  \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&  In state 2:
\&  Stack:[0,2,2]
\&  Need token. Got >b<
\&  Reduce using rule 1 (S \-\-> /* empty */): S \-> epsilon
\&  Back to state 2, then go to state 4.
\&  \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&  In state 4:
\&  Stack:[0,2,2,4]
\&  Shift and go to state 5.
\&  \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&  In state 5:
\&  Stack:[0,2,2,4,5]
\&  Don\*(Aqt need token.
\&  Reduce using rule 2 (S \-\-> a S b): S \-> a S b
\&  Back to state 2, then go to state 4.
\&  \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
.Ve
.PP
As a result of reducing by rule 2 
the three last
visited states are popped
from the stack, and the stack becomes \f(CW\*(C`[0,2]\*(C'\fR. But 
that means that we are now in state 2 seeing a \f(CW\*(C`S\*(C'\fR. 
If you look at the table above being in state 2 and seeing a \f(CW\*(C`S\*(C'\fR
we go to state 4.
.PP
.Vb 10
\&  In state 4:
\&  Stack:[0,2,4]
\&  Need token. Got >b<
\&  Shift and go to state 5.
\&  \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&  In state 5:
\&  Stack:[0,2,4,5]
\&  Don\*(Aqt need token.
\&  Reduce using rule 2 (S \-\-> a S b): S \-> a S b
\&  Back to state 0, then go to state 1.
\&  \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&  In state 1:
\&  Stack:[0,1]
\&  Need token. Got ><
\&  Shift and go to state 3.
\&  \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&  In state 3:
\&  Stack:[0,1,3]
\&  Don\*(Aqt need token.
\&  Accept.
.Ve
.SH "ERRORS INSIDE SEMANTIC ACTIONS"
.IX Header "ERRORS INSIDE SEMANTIC ACTIONS"
A third type of error occurs when the code inside
a semantic action doesn't behave as expected.
.PP
The semantic actions are translated in anonymous
methods of the parser object. Since they are anonymous
we can't use breakpoints as
.PP
.Vb 1
\&  b subname # stop when arriving at sub \*(Aq\*(Aqname\*(Aq\*(Aq
.Ve
.PP
or
.PP
.Vb 1
\&  c subname  # contine up to reach sub \*(Aq\*(Aqname\*(Aq\*(Aq
.Ve
.PP
Furthermore the file loaded by the client program is the
generated \f(CW\*(C`.pm\*(C'\fR. The code in the generated module
\&\f(CW\*(C`Debug.pm\*(C'\fR is alien to us \- Was automatically generated
by \f(CW\*(C`Parse::Eyapp\*(C'\fR \-
and it can be difficult to find where 
our inserted semantic actions are.
.PP
To watch the execution of
a semantic action
is simple: We use the debugger \f(CW\*(C`f file.eyp \*(C'\fR option
to switch the viewing filename to our grammar file.
The following session uses the example in
the directory \f(CW\*(C`examples/Calculator\*(C'\fR:
.PP
.Vb 4
\&  pl@nereida:~/LEyapp/examples/Calculator$ perl \-wd scripts/calc.pl
\&  Loading DB routines from perl5db.pl version 1.3
\&  Editor support available.
\&  Enter h or \`h h\*(Aq for help, or \`man perldebug\*(Aq for more help.
\&
\&  main::(scripts/calc.pl:8):      Math::Calc\->main();
\&    DB<1> f lib/Math/Calc.eyp
\&  1       2       3       4       5       6       7       #line 8 "lib/Math/Calc.eyp"
\&  8
\&  9:      use base q{Math::Tail};
\&  10:     my %s; # symbol table
.Ve
.PP
Lines 37 to 41 contain the semantic action associated with the production 
\&\f(CW\*(C`exp \-> VAR\*(C'\fR (see file \f(CW\*(C`examples/Calculator/lib/Math/Calc.eyp\*(C'\fR):
.PP
.Vb 6
\&    DB<2> l 37,41
\&  37:            my $id = $VAR\->[0];
\&  38:            my $val = $s{$id};
\&  39:            $_[0]\->semantic_error("Accesing undefined variable $id at line $VAR\->[1].\en")
\&  40             unless defined($val);
\&  41:            return $val;
.Ve
.PP
now we set a break at line 37, to see what happens when a non initialized variable is used:
.PP
.Vb 1
\&    DB<3> b 37
.Ve
.PP
We issue now the command \f(CW\*(C`c\*(C'\fR (continue). The execution continues until
line 37 of \f(CW\*(C`lib/Math/Calc.eyp\*(C'\fR is reached:
.PP
.Vb 5
\&    DB<4> c
\&  Expressions. Press CTRL\-D (Unix) or CTRL\-Z (Windows) to finish:
\&  a = 2+b                                            # user input
\&  Math::Calc::CODE(0x191da98)(lib/Math/Calc.eyp:37):
\&  37:            my $id = $VAR\->[0];
.Ve
.PP
Now we can issue any debugger commands (like \f(CW\*(C`x\*(C'\fR, \f(CW\*(C`p\*(C'\fR, etc.) 
to investigate the internal state
of our program and determine what are the reasons of any abnormal 
behavior.
.PP
.Vb 7
\&    DB<4> n
\&  Math::Calc::CODE(0x191da98)(lib/Math/Calc.eyp:38):
\&  38:            my $val = $s{$id};
\&    DB<4> x $id
\&  0  \*(Aqb\*(Aq
\&    DB<5> x %s
\&    empty array
.Ve
.SH "SOLVING REDUCE-REDUCE CONFLICTS"
.IX Header "SOLVING REDUCE-REDUCE CONFLICTS"
.SS "Reduce-Reduce Conflict: Default rules"
.IX Subsection "Reduce-Reduce Conflict: Default rules"
Most of the time reduce-reduce conflicts are due to some ambiguity in
the grammar, as it is the case for this minimal example:
.PP
.Vb 10
\&  pl@nereida:~/LEyapp/examples/debuggingtut$ sed \-ne \*(Aq/%%/,/%%/p\*(Aq minimalrr.eyp | cat \-n
\&     1  %%
\&     2  s:
\&     3        %name S_is_a
\&     4        \*(Aqa\*(Aq
\&     5      | A
\&     6  ;
\&     7  A:
\&     8        %name A_is_a
\&     9        \*(Aqa\*(Aq
\&    10  ;
\&    11
\&    12  %%
.Ve
.PP
In case of a reduce-reduce conflict, Parse::Eyapp reduces
using the first production in the text:
.PP
.Vb 5
\&  pl@nereida:~/LEyapp/examples/debuggingtut$ eyapp \-b \*(Aq\*(Aq minimalrr.eyp
\&  1 reduce/reduce conflict
\&  pl@nereida:~/LEyapp/examples/debuggingtut$ ./minimalrr.pm \-t
\&  Try "a" and press <CR><CTRL\-D>: a
\&  S_is_a
.Ve
.PP
If we change the order of the productions
.PP
.Vb 10
\&  pl@nereida:~/LEyapp/examples/debuggingtut$ sed \-ne \*(Aq/%start/,40p\*(Aq minimalrr2.eyp | cat \-n
\&     1  %start s
\&     2
\&     3  %%
\&     4  A:
\&     5        %name A_is_a
\&     6        \*(Aqa\*(Aq
\&     7  ;
\&     8
\&     9  s:
\&    10        %name S_is_a
\&    11        \*(Aqa\*(Aq
\&    12      | %name A
\&    13        A
\&    14  ;
\&    15  %%
.Ve
.PP
the selected production changes:
.PP
.Vb 5
\&  pl@nereida:~/LEyapp/examples/debuggingtut$ eyapp \-b \*(Aq\*(Aq minimalrr2
\&  1 reduce/reduce conflict
\&  pl@nereida:~/LEyapp/examples/debuggingtut$ ./minimalrr2.pm \-t
\&  Try "a" and press <CR><CTRL\-D>: a
\&  A(A_is_a)
.Ve
.SS "Reduce-Reduce conflicts: typical errors"
.IX Subsection "Reduce-Reduce conflicts: typical errors"
In this example the programmer has attempted to define
a language made of mixed lists \f(CW\*(C`ID\*(C'\fRs and \f(CW\*(C`NUM\*(C'\fRbers :
.PP
.Vb 3
\&  ~/LEyapp/examples/debuggingtut$ eyapp \-c typicalrr.eyp 
\&  %token ID NUM 
\&  %tree
\&
\&  %%
\&
\&  s:
\&        /* empty */
\&      | s ws
\&      | s ns 
\&  ;
\&  ns:
\&        /* empty */
\&      | ns NUM 
\&  ;
\&  ws:
\&        /* empty */
\&      | ws ID 
\&  ;
\&
\&  %%
.Ve
.PP
The grammar has several reduce-reduce conflicts:
.PP
.Vb 2
\&  ~/LEyapp/examples/debuggingtut$ eyapp \-b \*(Aq\*(Aq typicalrr.eyp 
\&  3 shift/reduce conflicts and 3 reduce/reduce conflicts
.Ve
.PP
There are several sources of ambiguity in this grammar:
.IP "\(bu" 2
Statments like
.Sp
.Vb 1
\&              NUM NUM NUM
.Ve
.Sp
are ambiguous. The following two left-most derivations
exists:
.Sp
.Vb 2
\&             s =*=> ns ns =*=> NUM NUM ns => NUM NUM NUM
\&and
\&
\&             s =*=> ns ns =*=> NUM ns =*=> NUM NUM NUM
.Ve
.Sp
the same with phrases like \f(CW\*(C`ID ID ID\*(C'\fR
.IP "\(bu" 2
The empty word can be generated in many ways. For 
example:
.Sp
.Vb 1
\&        s => empty
.Ve
.Sp
or
.Sp
.Vb 1
\&        s => s ns => s empty => empty
.Ve
.Sp
etc.
.PP
The generated parser loops forever if feed with a list of identifiers:
.PP
.Vb 10
\&  ~/LEyapp/examples/debuggingtut$ ./typicalrr.pm \-d
\&  Try inputs "4 5",  "a b" and "4 5 a b"(press <CR><CTRL\-D> to finish): ab
\&  \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&  In state 0:
\&  Stack:[0]
\&  Don\*(Aqt need token.
\&  Reduce using rule 1 (s \-\-> /* empty */): Back to state 0, then go to state 1.
\&  \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&  In state 1:
\&  Stack:[0,1]
\&  Need token. Got >ID<
\&  Reduce using rule 4 (ns \-\-> /* empty */): Back to state 1, then go to state 2.
\&  \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&  In state 2:
\&  Stack:[0,1,2]
\&  Reduce using rule 3 (s \-\-> s ns): Back to state 0, then go to state 1.
\&  \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&  In state 1:
\&  Stack:[0,1]
\&  Reduce using rule 4 (ns \-\-> /* empty */): Back to state 1, then go to state 2.
\&  \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&  In state 2:
\&  Stack:[0,1,2]
\&  Reduce using rule 3 (s \-\-> s ns): Back to state 0, then go to state 1.
\&  \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&  ^C
.Ve
.PP
The problem is easily solved designing an equivalent non ambiguous grammar:
.PP
.Vb 11
\&  pl@europa:~/LEyapp/examples/debuggingtut$ cat \-n correcttypicalrr.eyp
\&     1  %token ID NUM
\&     2
\&     3  %%
\&     4  s:
\&     5        /* empty */
\&     6      | s ID
\&     7      | s NUM
\&     8  ;
\&     9
\&    10  %%
.Ve
.PP
See also these files in the \f(CW\*(C`examples/debuggintut/\*(C'\fR directory:
.IP "\(bu" 2
\&\f(CW\*(C`typicalrr2.eyp\*(C'\fR is equivalent to \f(CW\*(C`typicalrr.eyp\*(C'\fR but has \f(CW%name\fR directives, to 
have a nicer tree
.IP "\(bu" 2
\&\f(CW\*(C`typicalrr_fixed.eyp\*(C'\fR eliminates the ambiguity using a combination of priorities
and elimination of the redundant empty productions. Explicit precedence via \f(CW%prec\fR directives
are given to produce right recursive lists
.IP "\(bu" 2
\&\f(CW\*(C`typicalrr_fixed_rightrecursive.eyp\*(C'\fR is almost equal to \f(CW\*(C`typicalrr_fixed.eyp\*(C'\fR
but eliminates the of \f(CW%prec\fR directives by making the list production 
right recursive
.SS "Giving an Explicit Priority to the End-of-Input Token"
.IX Subsection "Giving an Explicit Priority to the End-of-Input Token"
We can also try to disambiguate the former example
using priorities. For that we need to give an explicit priority to the 
end-of-input token. To refer to the end-of-input token in the header section,
use the empty string \f(CW\*(Aq\*(Aq\fR. In the
file \f(CW\*(C`examples/debuggingtut/typicalrrwithprec.eyp\*(C'\fR there
is a priority based solution:
.PP
.Vb 6
\&  ~/LEyapp/examples/debuggingtut$ eyapp \-c typicalrrwithprec.eyp
\&  %right LNUM 
\&  %right NUM 
\&  %right ID 
\&  %right \*(Aq\*(Aq # The string \*(Aq\*(Aq refers to the \*(AqEnd of Input\*(Aq token
\&  %tree bypass
\&
\&  %%
\&
\&  s:
\&        %name EMPTY
\&        /* empty */%prec \*(Aq\*(Aq
\&      | %name LIST
\&        s ws
\&      | %name LIST
\&        s ns 
\&  ;
\&  ns:
\&        %name EMPTYNUM
\&        /* empty */%prec NUM
\&      | %name NUMS
\&        NUM ns 
\&  ;
\&  ws:
\&        %name EMPTYID
\&        /* empty */%prec LNUM
\&      | %name IDS
\&        ID ws 
\&  ;
\&
\&  %%
.Ve
.PP
Observe the use of \f(CW\*(C`%right \*(Aq\*(Aq\*(C'\fR in the header section:
it gives a priority to the end-of-input token.
.PP
.Vb 10
\&  ~/LEyapp/examples/debuggingtut$ ./typicalrrwithprec.pm \-t
\&  Try "4 5 a b 2 3" (press <CR><CTRL\-D> to finish): 4 5 a b 2 3
\&  ^D
\&  LIST(
\&    LIST(
\&      LIST(
\&        EMPTY,
\&        NUMS(
\&          TERMINAL[4],
\&          NUMS(
\&            TERMINAL[5],
\&            EMPTYNUM
\&          )
\&        )
\&      ),
\&      IDS(
\&        TERMINAL[a],
\&        IDS(
\&          TERMINAL[b],
\&          EMPTYID
\&        )
\&      )
\&    ),
\&    NUMS(
\&      TERMINAL[2],
\&      NUMS(
\&        TERMINAL[3],
\&        EMPTYNUM
\&      )
\&    )
\&  )
.Ve
.SS "Reduce-Reduce conflict: Enumerated versus Range declarations in Extended Pascal"
.IX Subsection "Reduce-Reduce conflict: Enumerated versus Range declarations in Extended Pascal"
The grammar in file 
\&\f(CW\*(C`examples/debuggintut/pascalenumeratedvsrange.eyp\*(C'\fR:
.PP
.Vb 4
\&  ~/LEyapp/examples/debuggingtut$ eyapp \-c pascalenumeratedvsrange.eyp 
\&  %token TYPE DOTDOT ID 
\&  %left \*(Aq+\*(Aq \*(Aq\-\*(Aq 
\&  %left \*(Aq*\*(Aq \*(Aq/\*(Aq 
\&
\&  %%
\&
\&  type_decl:
\&        TYPE ID \*(Aq=\*(Aq type \*(Aq;\*(Aq 
\&  ;
\&  type:
\&        \*(Aq(\*(Aq id_list \*(Aq)\*(Aq
\&      | expr DOTDOT expr 
\&  ;
\&  id_list:
\&        ID
\&      | id_list \*(Aq,\*(Aq ID 
\&  ;
\&  expr:
\&        \*(Aq(\*(Aq expr \*(Aq)\*(Aq
\&      | expr \*(Aq+\*(Aq expr
\&      | expr \*(Aq\-\*(Aq expr
\&      | expr \*(Aq*\*(Aq expr
\&      | expr \*(Aq/\*(Aq expr
\&      | ID 
\&  ;
\&
\&  %%
.Ve
.PP
introduces a problem that arises in the declaration of enumerated 
and subrange types in Pascal:
.PP
.Vb 2
\&  type subrange = lo .. hi;
\&  type enum = (a, b, c);
.Ve
.PP
The original language standard allows only numeric literals and constant
identifiers for the subrange bounds (`lo' and `hi'), but Extended Pascal
and many other Pascal implementations allow arbitrary expressions there. This
gives rise to the following situation, containing a superfluous pair of
parentheses:
.PP
.Vb 1
\&     type subrange = (a) .. b;
.Ve
.PP
Compare this to the following declaration of an enumerated type with only one value:
.PP
.Vb 1
\&      type enum = (a);
.Ve
.PP
These two declarations look identical until the \f(CW\*(C`..\*(C'\fR token. With normal \s-1\fILALR\s0\fR\|(1)
one-token look-ahead it is not possible to decide between the two forms when
the identifier \f(CW\*(C`a\*(C'\fR is parsed. It is, however, desirable for a parser to decide
this, since in the latter case \f(CW\*(C`a\*(C'\fR must become a new identifier to represent
the enumeration value, while in the former case \f(CW\*(C`a\*(C'\fR must be evaluated with its
current meaning, which may be a constant or even a function call.
.PP
The consequence is a reduce-reduce conflict, which is summarized in
this state of the \s-1LALR\s0 automata:
.PP
.Vb 1
\&  State 10:
\&
\&    id_list \-> ID . (Rule 4)
\&    expr \-> ID .    (Rule 11)
\&
\&    \*(Aq)\*(Aq [reduce using rule 11 (expr)]
\&    \*(Aq)\*(Aq reduce using rule 4 (id_list)
\&    \*(Aq,\*(Aq reduce using rule 4 (id_list)
\&    $default    reduce using rule 11 (expr)
.Ve
.PP
The grammar in file \f(CW\*(C`pascalenumeratedvsrangesolvedvialex.eyp\*(C'\fR solves
this particular problem by looking ahead in the lexical analyzer: if the parenthesis
is followed by a sequence of comma separated identifiers finished by the closing 
parenthesis and a semicolon we can conclude that is a enumerated type 
declaration. For more details, have a look at the file. Another solution
using the postponed conflict resolution strategy can be found in file
\&\f(CW\*(C`pascalenumeratedvsrangesolvedviadyn.eyp\*(C'\fR.
.SS "Reduce-Reduce Conflicts with Unambiguous Grammars"
.IX Subsection "Reduce-Reduce Conflicts with Unambiguous Grammars"
Though not so common, it may occur that a reduce-reduce conflict
is not due to ambiguity but to the limitations of the \s-1\fILALR\s0\fR\|(1)
algorithm. The following example illustrates the point:
.PP
.Vb 10
\&  pl@europa:~/LEyapp/examples/debuggingtut$ cat \-n rrconflictnamefirst.eyp
\&     1  %token VAR \*(Aq,\*(Aq \*(Aq:\*(Aq
\&     2
\&     3  %{
\&     4  use base q{Tail};
\&     5  %}
\&     6
\&     7  %%
\&     8  def:    param_spec return_spec \*(Aq,\*(Aq
\&     9          ;
\&    10  param_spec:
\&    11               type
\&    12          |    name_list \*(Aq:\*(Aq type
\&    13          ;
\&    14  return_spec:
\&    15               type
\&    16          |    name \*(Aq:\*(Aq type
\&    17          ;
\&    18  name:        VAR
\&    19          ;
\&    20  type:        VAR
\&    21          ;
\&    22  name_list:
\&    23               name
\&    24          |    name \*(Aq,\*(Aq name_list
\&    25          ;
\&    26  %%
\&    27
\&    28  _\|_PACKAGE_\|_\->main unless caller();
.Ve
.PP
This non ambiguous grammar generates a language of sequences like
.PP
.Vb 1
\&                 a, b : e f : e,
.Ve
.PP
The conflict is due to the final comma in:
.PP
.Vb 1
\&      def:    param_spec return_spec \*(Aq,\*(Aq
.Ve
.PP
If you suppress such comma there is no conflict (try it).
When compiling with eyapp we get the warning:
.PP
.Vb 2
\&  pl@europa:~/LEyapp/examples/debuggingtut$ eyapp rrconflictnamefirst.eyp
\&  1 reduce/reduce conflict
.Ve
.PP
Editing the \f(CW\*(C`.output\*(C'\fR file we can see the conflict is in state 2:
.PP
.Vb 8
\&   46 State 2:
\&   47
\&   48         name \-> VAR .   (Rule 6)
\&   49         type \-> VAR .   (Rule 7)
\&   50
\&   51         \*(Aq,\*(Aq     [reduce using rule 7 (type)]
\&   52         VAR     reduce using rule 7 (type)
\&   53         $default        reduce using rule 6 (name)
.Ve
.PP
If we look at the grammar we can see that a reduction by
.PP
.Vb 1
\&                   type \-> VAR .
.Ve
.PP
may occur with a comma as incoming token but only after 
the reduction by \f(CW\*(C`param_spec\*(C'\fR has taken place. The problem
is that the automaton forgets about it. Look the 
automaton transitions in the \f(CW\*(C`.outputfile\*(C'\fR.
By making explicit the difference between the first and second \f(CW\*(C`type\*(C'\fR
we solve the conflict:
.PP
.Vb 10
\&  pl@europa:~/LEyapp/examples/debuggingtut$ cat \-n rrconflictnamefirst_fix1.eyp
\&     1  %token VAR \*(Aq,\*(Aq \*(Aq:\*(Aq
\&     2
\&     3  %{
\&     4  use base q{Tail};
\&     5  %}
\&     6
\&     7  %%
\&     8  def:    param_spec return_spec \*(Aq,\*(Aq
\&     9          ;
\&    10  param_spec:
\&    11               type
\&    12          |    name_list \*(Aq:\*(Aq type
\&    13          ;
\&    14  return_spec:
\&    15               typeafter
\&    16          |    name \*(Aq:\*(Aq typeafter
\&    17          ;
\&    18  name:        VAR
\&    19          ;
\&    20  type:        VAR
\&    21          ;
\&    22  typeafter:        VAR
\&    23          ;
\&    24  name_list:
\&    25               name
\&    26          |    name \*(Aq,\*(Aq name_list
\&    27          ;
\&    28  %%
\&    29
\&    30  _\|_PACKAGE_\|_\->main unless caller();
.Ve
.PP
A reduce-reduce conflict is solved in favor of the first production
found in the text. If we execute the grammar with the conflict \f(CW\*(C`./rrconflictnamefirst.pm\*(C'\fR,
we get the correct behavior:
.PP
.Vb 7
\&  pl@europa:~/LEyapp/examples/debuggingtut$ eyapp \-b \*(Aq\*(Aq rrconflictnamefirst.eyp
\&  1 reduce/reduce conflict
\&  pl@europa:~/LEyapp/examples/debuggingtut$ ./rrconflictnamefirst.pm
\&  Expressions. Press CTRL\-D (Unix) or CTRL\-Z (Windows) to finish:
\&  a,b:c d:e,
\&  <CTRL\-D>
\&  $
.Ve
.PP
The program accepts the correct language \- in spite of the conflict \-
due to the fact that the  production
.PP
.Vb 1
\&                      name:        VAR
.Ve
.PP
is listed first.
.PP
The parser rejects the correct phrases if we swap the order 
of the productions writing the \f(CW\*(C`type: VAR\*(C'\fR production first,
.PP
.Vb 4
\&  pl@europa:~/LEyapp/examples/debuggingtut$ ./reducereduceconflict.pm
\&  Expressions. Press CTRL\-D (Unix) or CTRL\-Z (Windows) to finish:
\&  a,b:c d:e,
\&  <CTRL\-D>
\&
\&  Syntax error near input: \*(Aq,\*(Aq (lin num 1).
\&  Incoming text:
\&  ===
\&  b:c d
\&  ===
\&  Expected one of these terminals: VAR
.Ve
.PP
Files \f(CW\*(C`reducereduceconflict_fix1.eyp\*(C'\fR and \f(CW\*(C`reducereduceconflict_fix2.eyp\*(C'\fR
offer other solutions to the problem.
.SH "TOKENS DEPENDING ON THE SYNTACTIC CONTEXT"
.IX Header "TOKENS DEPENDING ON THE SYNTACTIC CONTEXT"
Usually there is a one-to-one relation between a token and a regexp. Problems arise,
however when a token's type depends upon contextual information.
An example of this problem comes from \s-1PL/I,\s0 where statements like this are
legal:
.PP
.Vb 1
\&         if then=if then if=then
.Ve
.PP
In \s-1PL/I\s0 this problem arises because keywords like \f(CW\*(C`if\*(C'\fR are not reserved and can be used in
other contexts. This simplified grammar illustrates the problem:
.PP
.Vb 12
\&  examples/debuggingtut$ eyapp \-c PL_I_conflict.eyp
\&  # This grammar deals with the famous ambiguous PL/I phrase:
\&  #                if then=if then if=then
\&  # The (partial) solution uses YYExpect in the lexical analyzer to predict the token
\&  # that fulfills the parser expectatives.
\&  # Compile it with:
\&  # eyapp \-b \*(Aq\*(Aq PL_I_conflict.eyp
\&  # Run it with;
\&  # ./PL_I_conflict.pm \-debug
\&  %strict
\&  %token ID
\&  %tree bypass
\&
\&  %%
\&
\&  stmt:
\&        ifstmt
\&      | assignstmt
\&  ;
\&  # Exercise: change this production
\&  #     for \*(Aqif\*(Aq expr \*(Aqthen\*(Aq stmt
\&  # and check with input \*(Aqif then=if then if=then\*(Aq. The problem arises again
\&  ifstmt:
\&        %name IF
\&        \*(Aqif\*(Aq expr \*(Aqthen\*(Aq expr
\&  ;
\&  assignstmt:
\&        id \*(Aq=\*(Aq expr
\&  ;
\&  expr:
\&        %name EQ
\&        id \*(Aq=\*(Aq id
\&      | id
\&  ;
\&  id:
\&        %name ID
\&        ID
\&  ;
\&
\&  %%
.Ve
.PP
If the token ambiguity depends only in the syntactic context,
the problem can be alleviated using the \f(CW\*(C`YYExpect\*(C'\fR method. 
In case of doubt, the lexical analyzer calls the \f(CW\*(C`YYExpect\*(C'\fR method to know
which of the several feasible tokens is expected by the parser:
.PP
.Vb 3
\&  examples/debuggingtut$ sed \-ne \*(Aq/sub lex/,/^}/p\*(Aq PL_I_conflict.eyp
\&  sub lexer {
\&    my $parser = shift;
\&
\&    for ($parser\->{input}) {    # contextualize
\&      m{\eG\es*(\e#.*)?}gc;
\&
\&      m{\eG([a\-zA\-Z_]\ew*)}gc and do {
\&        my $id = $1;
\&
\&        return (\*(Aqif\*(Aq,   \*(Aqif\*(Aq)   if ($id eq \*(Aqif\*(Aq)   && is_in(\*(Aqif\*(Aq, $parser\->YYExpect);
\&        return (\*(Aqthen\*(Aq, \*(Aqthen\*(Aq) if ($id eq \*(Aqthen\*(Aq) && is_in(\*(Aqthen\*(Aq, $parser\->YYExpect);
\&
\&        return (\*(AqID\*(Aq, $id);
\&      };
\&
\&      m{\eG(.)}gc         and return ($1, $1);
\&
\&      return(\*(Aq\*(Aq,undef);
\&    }
\&  }
.Ve
.PP
Here follows an example of execution:
.PP
.Vb 5
\&  examples/debuggingtut$ eyapp \-b \*(Aq\*(Aq PL_I_conflict.eyp
\&  examples/debuggingtut$ ./PL_I_conflict.pm
\&  Expressions. Press CTRL\-D (Unix) or CTRL\-Z (Windows) to finish:
\&  if then=if then if=then
\&  IF(EQ(ID,ID),EQ(ID,ID))
.Ve
.SH "LEXICAL TIE-INS"
.IX Header "LEXICAL TIE-INS"
A \fIlexical tie-in\fR is a flag which is set to alter the behavior of the 
lexical analyzer. It is a way to handle context-dependency.
.ie n .SS "The Parsing of ""C"""
.el .SS "The Parsing of \f(CWC\fP"
.IX Subsection "The Parsing of C"
The C language has a context dependency: the way an identifier is used depends
on what its current meaning is. For example, consider this:
.PP
.Vb 1
\&  T(x);
.Ve
.PP
This looks like a function call statement, but if \f(CW\*(C`T\*(C'\fR is a typedef name, then
this is actually a declaration of \f(CW\*(C`x\*(C'\fR. How can a parser for C decide how to
parse this input?
.PP
Here is another example:
.PP
.Vb 4
\&  {
\&    T * x;
\&    ...
\&  }
.Ve
.PP
What is this, a declaration of \f(CW\*(C`x\*(C'\fR as a pointer to \f(CW\*(C`T\*(C'\fR, 
or a void multiplication of the variables \f(CW\*(C`T\*(C'\fR and \f(CW\*(C`x\*(C'\fR?
.PP
The usual method to solve this problem is to have two different token types, \f(CW\*(C`ID\*(C'\fR and \f(CW\*(C`TYPENAME\*(C'\fR.
When the lexical analyzer finds an identifier, it looks up in the symbol table 
the current declaration of the identifier in order to 
decide which token type to return: \f(CW\*(C`TYPENAME\*(C'\fR if the
identifier is declared as a typedef, \f(CW\*(C`ID\*(C'\fR otherwise.
See the \s-1ANSI C\s0 parser example in the directory \f(CW\*(C`examples/languages/C/ansic.eyp\*(C'\fR
.SS "A Simple Example"
.IX Subsection "A Simple Example"
In the \*(L"Calc\*(R"\-like example in \f(CW\*(C`examples/debuggintut/SemanticInfoInTokens.eyp\*(C'\fR
we have a language with a special construct 
\&\f(CW\*(C`hex (hex\-expr)\*(C'\fR. After the keyword \f(CW\*(C`hex\*(C'\fR comes an \f(CW\*(C`expression\*(C'\fR in parentheses in
which all integers are hexadecimal. In particular, strings in \f(CW\*(C`/[A\-F0\-9]+/\*(C'\fR
like \f(CW\*(C`A1B\*(C'\fR must be treated as an hex integer unless they were previously
declared as variables.  Let us see an example of execution:
.PP
.Vb 5
\&  $ eyapp \-b \*(Aq\*(Aq SemanticInfoInTokens.eyp
\&  $ cat inputforsemanticinfo2.txt
\&  int A2
\&  A2 = HEX(A23);
\&  A2 = HEX(A2)
\&
\&  $ ./SemanticInfoInTokens.pm \-f inputforsemanticinfo2.txt  \-t
\&  EXPS(ASSIGN(TERMINAL[A2],NUM[2595]),ASSIGN(TERMINAL[A2],ID[A2]))
.Ve
.PP
The first hex expression \f(CW\*(C`HEX(A23)\*(C'\fR is interpreted as the number \f(CW2595\fR
while the second \f(CW\*(C`HEX(A2)\*(C'\fR refers to previously declared variable \f(CW\*(C`A2\*(C'\fR.
.PP
An alternative solution to this problem that does not make use of
lexical tie-ins \- but still uses an attribute \f(CW\*(C`HEXFLAG\*(C'\fR for communication
between different semantic actions \- can be found in the file 
\&\f(CW\*(C`examples/debuggintut/Tieins.eyp\*(C'\fR.
.PP
.Vb 10
\&  pl@nereida:~/LEyapp/examples/debuggingtut$ sed \-ne \*(Aq5,91p\*(Aq SemanticInfoInTokens.eyp | cat \-n
\&     1  %strict                                                                             
\&     2                                                                                      
\&     3  %token ID INT INTEGER                                                               
\&     4  %syntactic token HEX                                                                
\&     5                                                                                      
\&     6  %right \*(Aq=\*(Aq                                                                          
\&     7  %left \*(Aq+\*(Aq                                                                           
\&     8                                                                                      
\&     9  %{                                                                                  
\&    10  use base q{DebugTail};                                                              
\&    11  my %st;                                                                             
\&    12  %}                                                                                  
\&    13                                                                                      
\&    14  %tree bypass alias                                                                  
\&    15                                                                                      
\&    16  %%                                                                                  
\&    17  stmt:                                                                               
\&    18      decl <* \*(Aq;\*(Aq> expr <%name EXPS + \*(Aq;\*(Aq>                                            
\&    19        {                                                                             
\&    20          # make the symbol table an attribute                                        
\&    21          # of the root node                                                          
\&    22          $_[2]\->{st} = { %st };                                                      
\&    23          $_[2];                                                                      
\&    24        }                                                                             
\&    25  ;                                                                                   
\&    26                                                                                      
\&    27  decl:                                                                               
\&    28      INT ID <+ \*(Aq,\*(Aq>                                                                  
\&    29        {                                                                             
\&    30          # insert identifiers in the symbol table                                    
\&    31          $st{$_\->{attr}} = 1 for $_[2]\->children();                                  
\&    32        }                                                                             
\&    33  ;                                                                                   
\&    34                                                                                      
\&    35  expr:                                                                               
\&    36      %name ID                                                                        
\&    37      ID                                                                              
\&    38    | %name NUM                                                                       
\&    39      INTEGER                                                                         
\&    40    | %name HEX                                                                       
\&    41      HEX \*(Aq(\*(Aq { $_[0]\->{HEXFLAG} = 1; } $expr \*(Aq)\*(Aq                                     
\&    42        {                                                                             
\&    43          $_[0]\->{HEXFLAG} = 0;                                                       
\&    44          $expr;                                                                      
\&    45        }                                                                             
\&    46    | %name ASSIGN                                                                    
\&    47      id \*(Aq=\*(Aq expr                                                                     
\&    48    | %name PLUS                                                                      
\&    49      expr \*(Aq+\*(Aq expr
\&    50  ;
\&    51
\&    52  id : ID
\&    53  ;
\&    54
\&    55  %%
\&    56
\&    57  # Context\-dependant lexer
\&    58  _\|_PACKAGE_\|_\->lexer( sub {
\&    59      my $parser = shift;
\&    60      my $hexflag = $parser\->{HEXFLAG};
\&    61
\&    62      for (${$parser\->input}) {    # contextualize
\&    63        m{\eG\es*(\e#.*)?}gc;
\&    64
\&    65        m{\eG(HEX\eb|INT\eb)}igc and return (uc($1), $1);
\&    66
\&    67        m{(\eG\ed+)}gc and return (\*(AqINTEGER\*(Aq, $hexflag? hex($1) : $1);
\&    68
\&    69
\&    70        m{\eG([a\-zA\-Z_]\ew*)}gc and do {
\&    71          my $match = $1;
\&    72          $hexflag and !exists($st{$match}) and $match =~ m{^([A\-F0\-9]+$)}gc and return (\*(AqINTEGER\*(Aq, hex($match));
\&    73          return (\*(AqID\*(Aq, $1);
\&    74        };
\&    75
\&    76        m{\eG(.)}gc         and return ($1, $1);
\&    77
\&    78        return(\*(Aq\*(Aq,undef);
\&    79      }
\&    80    }
\&    81  );
\&    82
\&    83  *TERMINAL::info = *NUM::info = *ID::info = sub {
\&    84    $_[0]\->{attr}
\&    85  };
\&    86
\&    87  _\|_PACKAGE_\|_\->main() unless caller();
.Ve
.PP
Here the lexical analyzer looks at the value of the attribute \f(CW\*(C`HEXFLAG\*(C'\fR; when it is nonzero,
all integers are parsed in hexadecimal, and tokens starting with letters are
parsed as integers if possible.
.SS "References about Lexical tie-ins"
.IX Subsection "References about Lexical tie-ins"
For more about lexical tie-ins see also
.IP "\(bu" 2
<http://www.gnu.org/software/bison/manual/html_mono/bison.html#Lexical\-Tie_002dins>
.IP "\(bu" 2
<http://en.wikipedia.org/wiki/The_lexer_hack>
.IP "\(bu" 2
<http://eli.thegreenplace.net/2007/11/24/the\-context\-sensitivity\-of\-cs\-grammar/>
.SH "SOLVING CONFLICTS WITH THE \fIPOSTPONED CONFLICT\fP STRATEGY"
.IX Header "SOLVING CONFLICTS WITH THE POSTPONED CONFLICT STRATEGY"
Yacc-like parser generators provide ways to solve shift-reduce mechanims
based on token precedence. No mechanisms are provided for the resolution
of reduce-reduce conflicts. The solution for such kind of conflicts is to modify
the grammar. The strategy We present here provides a way to broach conflicts
that can't be solved using static precedences.
.SS "The \fIPostponed Conflict Resolution\fP Strategy"
.IX Subsection "The Postponed Conflict Resolution Strategy"
The \fIpostponed conflict strategy\fR presented here can be used whenever there 
is a shift-reduce or reduce-reduce conflict that can not be solved using static 
precedences.
.SS "\fIPostponed Conflict Resolution\fP: Reduce-Reduce Conflicts"
.IX Subsection "Postponed Conflict Resolution: Reduce-Reduce Conflicts"
Let us assume we have a reduce-reduce conflict between to productions
.PP
.Vb 2
\&                      A \-> alpha .
\&                      B \-> beta .
.Ve
.PP
for some token \f(CW\*(C`@\*(C'\fR. Let also assume that production
.PP
.Vb 1
\&                      A \-> alpha
.Ve
.PP
has name \f(CW\*(C`ruleA\*(C'\fR and production
.PP
.Vb 1
\&                      B \-> beta
.Ve
.PP
has name \f(CW\*(C`ruleB\*(C'\fR.
.PP
The postponed conflict resolution strategy consists
in modifying the conflictive grammar by marking the points where the  conflict occurs
with the new \f(CW%PREC\fR directive. In this case at then end of the involved productions:
.PP
.Vb 2
\&                      A \-> alpha %PREC IsAorB 
\&                      B \-> beta  $PREC IsAorB
.Ve
.PP
The \f(CW\*(C`IsAorB\*(C'\fR identifier is called the \fIconflict name\fR.
.PP
Inside the head section, the programmer associates with the 
conflict name a code
whose mission is to solve the conflict by dynamically changing the
parsing table like this:
.PP
.Vb 2
\&                     %conflict IsAorB {
\&                          my $self = shift;
\&
\&                          if (looks_like_A($self)) {
\&                            $self\->YYSetReduce(\*(Aq@\*(Aq, \*(AqruleA\*(Aq );
\&                          }
\&                          else {
\&                            $self\->YYSetReduce(\*(Aq@\*(Aq, \*(AqruleB\*(Aq );
\&                          }
\&                       }
.Ve
.PP
The code associated with the \fIconflict name\fR
receives the name of \fI conflict handler\fR.
The code of \f(CW\*(C`looks_like_A\*(C'\fR stands for some form of nested parsing
which will decide which production applies.
.SS "Solving the Enumerated versus Range declarations conflict using the Posponed Conflict Resolution Strategy"
.IX Subsection "Solving the Enumerated versus Range declarations conflict using the Posponed Conflict Resolution Strategy"
In file \f(CW\*(C`pascalenumeratedvsrangesolvedviadyn.eyp\*(C'\fR we apply the postponed conflict resolution strategy
to the reduce reduce conflict that arises in Extended Pascal between the declaration of ranges and
the declaration of enumerated types (see section \*(L"Reduce-Reduce conflict: Enumerated versus Range declarations in Extended Pascal\*(R").
Here is the solution:
.PP
.Vb 10
\&  ~/LEyapp/examples/debuggingtut$ cat \-n pascalenumeratedvsrangesolvedviadyn.eyp
\&     1  %{
\&     2  =head1 SYNOPSIS
\&     3  
\&     4  See 
\&     5  
\&     6  =over 2
\&     7  
\&     8  =item * File pascalenumeratedvsrange.eyp in examples/debuggintut/
\&     9  
\&    10  =item * The Bison manual L<http://www.gnu.org/software/bison/manual/html_mono/bison.html>
\&    11  
\&    12  =back
\&    13  
\&    14  Compile it with:
\&    15  
\&    16              eyapp \-b \*(Aq\*(Aq pascalenumeratedvsrangesolvedviadyn.eyp
\&    17  
\&    18  run it with this options:
\&    19  
\&    20              ./pascalenumeratedvsrangesolvedviadyn.pm \-t
\&    21  
\&    22  Try these inputs:
\&    23  
\&    24                  type r = (x) ..  y ;
\&    25                  type r = (x+2)*3 ..  y/2 ;
\&    26                  type e = (x, y, z);
\&    27                  type e = (x);
\&    28  
\&    29  =cut
\&    30  
\&    31  use base q{DebugTail}; 
\&    32  
\&    33  my $ID = qr{[A\-Za\-z][A\-Za\-z0\-9_]*};
\&    34               # Identifiers separated by commas
\&    35  my $IDLIST = qr{ \es*(?:\es*,\es* $ID)* \es* }x;
\&    36               # list followed by a closing par and a semicolon 
\&    37  my $RESTOFLIST = qr{$IDLIST \e) \es* ; }x;
\&    38  %}
\&    39  
\&    40  %namingscheme {
\&    41    #Receives a Parse::Eyapp object describing the grammar
\&    42    my $self = shift;
\&    43  
\&    44    $self\->tokennames(
\&    45      \*(Aq(\*(Aq => \*(AqLP\*(Aq,
\&    46      \*(Aq..\*(Aq => \*(AqDOTDOT\*(Aq,
\&    47      \*(Aq,\*(Aq => \*(AqCOMMA\*(Aq,
\&    48      \*(Aq)\*(Aq => \*(AqRP\*(Aq,
\&    49      \*(Aq+\*(Aq => \*(AqPLUS\*(Aq,
\&    50      \*(Aq\-\*(Aq => \*(AqMINUS\*(Aq,
\&    51      \*(Aq*\*(Aq => \*(AqTIMES\*(Aq,
\&    52      \*(Aq/\*(Aq => \*(AqDIV\*(Aq,
\&    53    );
\&    54  
\&    55    # returns the handler that will give names
\&    56    # to the right hand sides
\&    57    \e&give_rhs_name;
\&    58  }
\&    59  
\&    60  %strict
\&    61  
\&    62  %token ID NUM DOTDOT TYPE
\&    63  %left   \*(Aq\-\*(Aq \*(Aq+\*(Aq
\&    64  %left   \*(Aq*\*(Aq \*(Aq/\*(Aq
\&    65  
\&    66  %tree
\&    67  
\&    68  %%
\&    69  
\&    70  type_decl : TYPE ID \*(Aq=\*(Aq type \*(Aq;\*(Aq
\&    71  ;
\&    72  
\&    73  type : 
\&    74        %name ENUM
\&    75        \*(Aq(\*(Aq id_list \*(Aq)\*(Aq
\&    76      | %name RANGE
\&    77        expr DOTDOT expr
\&    78  ;
\&    79  
\&    80  id_list : 
\&    81        %name EnumID
\&    82        ID rangeORenum
\&    83      | id_list \*(Aq,\*(Aq ID
\&    84  ;
\&    85  
\&    86  expr : \*(Aq(\*(Aq expr \*(Aq)\*(Aq
\&    87      | expr \*(Aq+\*(Aq expr
\&    88      | expr \*(Aq\-\*(Aq expr
\&    89      | expr \*(Aq*\*(Aq expr
\&    90      | expr \*(Aq/\*(Aq expr
\&    91      | %name RangeID
\&    92        ID rangeORenum
\&    93      | NUM
\&    94  ;
\&    95  
\&    96  rangeORenum: /* empty: postponed conflict resolution */
\&    97        {
\&    98            my $parser = shift;
\&    99            if (${$parser\->input()} =~ m{\eG(?= $RESTOFLIST)}gcx) {
\&   100                $parser\->YYSetReduce(\*(Aq)\*(Aq, \*(AqEnumID\*(Aq );
\&   101              }
\&   102              else {
\&   103                $parser\->YYSetReduce(\*(Aq)\*(Aq, \*(AqRangeID\*(Aq );
\&   104              }
\&   105        }
\&   106  ;
\&   107  
\&   108  %%
\&   109  
\&   110  _\|_PACKAGE_\|_\->lexer(
\&   111    sub {
\&   112      my $parser = shift;
\&   113  
\&   114      for (${$parser\->input()}) {    # contextualize
\&   115        m{\eG(\es*)}gc;
\&   116        $parser\->tokenline($1 =~ tr{\en}{});
\&   117  
\&   118        m{\eGtype\eb}gic                 and return (\*(AqTYPE\*(Aq, \*(AqTYPE\*(Aq);
\&   119  
\&   120        m{\eG($ID)}gc                   and return (\*(AqID\*(Aq,  $1);
\&   121  
\&   122        m{\eG([0\-9]+)}gc                and return (\*(AqNUM\*(Aq, $1);
\&   123  
\&   124        m{\eG\e.\e.}gc                    and return (\*(AqDOTDOT\*(Aq,  \*(Aq..\*(Aq);
\&   125  
\&   126        m{\eG(.)}gc                     and return ($1,    $1);
\&   127  
\&   128        return(\*(Aq\*(Aq,undef);
\&   129      }
\&   130    }
\&   131  );
\&   132  
\&   133  unless (caller()) {
\&   134    $Parse::Eyapp::Node::INDENT = 1;
\&   135    my $prompt = << \*(AqEOP\*(Aq;
\&   136  Try this input:
\&   137      type 
\&   138      r
\&   139      =
\&   140      (x)
\&   141      ..
\&   142      y
\&   143      ;
\&   144  
\&   145  Here other inputs you can try:
\&   146  
\&   147      type r = (x+2)*3 ..  y/2 ;
\&   148      type e = (x, y, z);
\&   149      type e = (x);
\&   150  
\&   151  Press CTRL\-D (CTRL\-W in windows) to produce the end\-of\-file
\&   152  EOP
\&   153    _\|_PACKAGE_\|_\->main($prompt); 
\&   154  }
.Ve
.PP
This example also illustrates how to modify the default production
naming schema. Follows the result of several executions:
.PP
.Vb 9
\&  ~/LEyapp/examples/debuggingtut$ ./pascalenumeratedvsrangesolvedviadyn.pm \-t
\&  Try this input:
\&      type 
\&      r
\&      =
\&      (x)
\&      ..
\&      y
\&      ;
\&
\&  Here other inputs you can try:
\&
\&      type r = (x+2)*3 ..  y/2 ;
\&      type e = (x, y, z);
\&      type e = (x);
\&
\&  Press CTRL\-D (CTRL\-W in windows) to produce the end\-of\-file
\&  type r = (x+2)*3 ..  y/2 ;
\&  ^D
\&  type_decl_is_TYPE_ID_type(
\&    TERMINAL[TYPE],
\&    TERMINAL[r],
\&    RANGE(
\&      expr_is_expr_TIMES_expr(
\&        expr_is_LP_expr_RP(
\&          expr_is_expr_PLUS_expr(
\&            RangeID(
\&              TERMINAL[x]
\&            ),
\&            expr_is_NUM(
\&              TERMINAL[2]
\&            )
\&          )
\&        ),
\&        expr_is_NUM(
\&          TERMINAL[3]
\&        )
\&      ),
\&      TERMINAL[..],
\&      expr_is_expr_DIV_expr(
\&        RangeID(
\&          TERMINAL[y]
\&        ),
\&        expr_is_NUM(
\&          TERMINAL[2]
\&        )
\&      )
\&    )
\&  )
\&  ~/LEyapp/examples/debuggingtut$ ./pascalenumeratedvsrangesolvedviadyn.pm \-t
\&  Try this input:
\&      type 
\&      r
\&      =
\&      (x)
\&      ..
\&      y
\&      ;
\&
\&  Here other inputs you can try:
\&
\&      type r = (x+2)*3 ..  y/2 ;
\&      type e = (x, y, z);
\&      type e = (x);
\&
\&  Press CTRL\-D (CTRL\-W in windows) to produce the end\-of\-file
\&  type e = (x);
\&  ^D
\&  type_decl_is_TYPE_ID_type(
\&    TERMINAL[TYPE],
\&    TERMINAL[e],
\&    ENUM(
\&      EnumID(
\&        TERMINAL[x]
\&      )
\&    )
\&  )
.Ve
.SS "\fIPostponed Conflict Resolution\fP: Shift-Reduce Conflicts"
.IX Subsection "Postponed Conflict Resolution: Shift-Reduce Conflicts"
The program in \f(CW\*(C`examples/debuggingtut/DynamicallyChangingTheParser2.eyp\*(C'\fR illustrates how the postponed
conflict strategy is used for shift-reduce conflicts.
This is an extension of the grammar in \f(CW\*(C`examples/debuggingtut/Debug.eyp\*(C'\fR.
The generated language is constituted by sequences like:
.PP
.Vb 1
\&    { D; D; S; S; S; } {D; S} { S }
.Ve
.PP
As you remember the conflict was:
.PP
.Vb 2
\&  ~/LEyapp/examples/debuggingtut$ sed \-ne \*(Aq/^St.*13:/,/^St.*14/p\*(Aq DynamicallyChangingTheParser.output  
\&  State 13:
\&
\&      ds \-> D conflict . \*(Aq;\*(Aq ds   (Rule 6)
\&      ds \-> D conflict .  (Rule 7)
\&
\&      \*(Aq;\*(Aq shift, and go to state 16
\&
\&      \*(Aq;\*(Aq [reduce using rule 7 (ds)]
\&
\&  State 14:
.Ve
.PP
The \f(CW\*(C`conflict\*(C'\fR handler below sets the \s-1LR\s0 action
to reduce by the production with name \f(CW\*(C`D1\*(C'\fR
.PP
.Vb 1
\&                 ds \-> D
.Ve
.PP
in the presence of token \f(CW\*(Aq;\*(Aq\fR if indeed is the last \f(CW\*(AqD\*(Aq\fR, that is, if:
.PP
.Vb 1
\&       ${$self\->input()} =~ m{^\es*;\es*S}
.Ve
.PP
Otherwise we set the \f(CW\*(C`shift\*(C'\fR action via a call to the 
\&\f(CW\*(C`YYSetShift\*(C'\fR method.
.PP
.Vb 10
\&  ~/LEyapp/examples/debuggingtut$ sed \-ne \*(Aq30,$p\*(Aq DynamicallyChangingTheParser.eyp | cat \-n
\&     1  %token D S
\&     2  
\&     3  %tree bypass
\&     4  
\&     5  # Expect just 1 shift\-reduce conflict
\&     6  %expect 1 
\&     7  
\&     8  %%
\&     9  p: %name PROG
\&    10      block +
\&    11  ;
\&    12  
\&    13  block:
\&    14      %name BLOCK_DS
\&    15      \*(Aq{\*(Aq ds \*(Aq;\*(Aq ss \*(Aq}\*(Aq 
\&    16    | %name BLOCK_S
\&    17      \*(Aq{\*(Aq ss \*(Aq}\*(Aq
\&    18  ;
\&    19  
\&    20  ds:
\&    21      %name D2
\&    22      D conflict \*(Aq;\*(Aq ds    
\&    23    | %name D1
\&    24      D conflict        
\&    25  ;
\&    26  
\&    27  ss:
\&    28      %name S2
\&    29      S \*(Aq;\*(Aq ss      
\&    30    | %name S1
\&    31      S       
\&    32  ;
\&    33  
\&    34  conflict:
\&    35        /* empty. This action solves the conflict using dynamic precedence */
\&    36        {
\&    37          my $self = shift;
\&    38  
\&    39          if (${$self\->input()} =~ m{^\es*;\es*S}) {
\&    40            $self\->YYSetReduce(\*(Aq;\*(Aq, \*(AqD1\*(Aq )
\&    41          }
\&    42          else {
\&    43            $self\->YYSetShift(\*(Aq;\*(Aq)
\&    44          }
\&    45  
\&    46          undef; # skip this node in the AST
\&    47        }
\&    48  ;
\&    49  
\&    50  %%
\&    51  
\&    52  my $prompt = \*(AqProvide a statement like "{D; S} {D; D; S}" and press <CR><CTRL\-D>: \*(Aq;
\&    53  _\|_PACKAGE_\|_\->main($prompt) unless caller;
.Ve
.SH "TREE EQUALITY"
.IX Header "TREE EQUALITY"
The more the time invested writing tests the less the time spent debugging.
This section deals with the Parse::Eyapp::Node method \f(CW\*(C`equal\*(C'\fR which 
can be used to test that the trees have the shape we expect.
.ie n .SS "$node\->equal"
.el .SS "\f(CW$node\fP\->equal"
.IX Subsection "$node->equal"
A call  \f(CW\*(C`$tree1\->equal($tree2)\*(C'\fR  
compare the two trees \f(CW$tree1\fR and \f(CW$tree2\fR. 
Two trees are considered equal if their root nodes belong to the same class,
they have the same number of children and the children are (recursively) equal.
.PP
In Addition to the two trees the programmer can specify
pairs \f(CW\*(C`attribute_key => equality_handler\*(C'\fR:
.PP
.Vb 1
\&  $tree1\->equal($tree2, attr1 => \e&handler1, attr2 => \e&handler2, ...)
.Ve
.PP
In such case 
the definition of equality is more restrictive:
Two trees are considered equal if
.IP "\(bu" 2
Their root nodes belong to the same class,
.IP "\(bu" 2
They have the same number of children
.IP "\(bu" 2
For each of the specified attributes occur
that for both nodes the existence and definition of the key
is the same
.IP "\(bu" 2
Assuming the key exists and is defined for both 
nodes, the equality handlers return
true for each of its attributes and
.IP "\(bu" 2
The respective children are (recursively) equal.
.PP
An attribute handler receives as arguments the values of the attributes
of the two nodes being compared and must return true if, and only if,
these two attributes are considered equal. Follows an example:
.PP
.Vb 10
\&  examples/Node$ cat \-n equal.pl
\&     1  #!/usr/bin/perl \-w
\&     2  use strict;
\&     3  use Parse::Eyapp::Node;
\&     4
\&     5  my $string1 = shift || \*(AqASSIGN(VAR(TERMINAL))\*(Aq;
\&     6  my $string2 = shift || \*(AqASSIGN(VAR(TERMINAL))\*(Aq;
\&     7  my $t1 = Parse::Eyapp::Node\->new($string1, sub { my $i = 0; $_\->{n} = $i++ for @_ });
\&     8  my $t2 = Parse::Eyapp::Node\->new($string2);
\&     9
\&    10  # Without attributes
\&    11  if ($t1\->equal($t2)) {
\&    12    print "\enNot considering attributes: Equal\en";
\&    13  }
\&    14  else {
\&    15    print "\enNot considering attributes: Not Equal\en";
\&    16  }
\&    17
\&    18  # Equality with attributes
\&    19  if ($t1\->equal($t2, n => sub { return $_[0] == $_[1] })) {
\&    20    print "\enConsidering attributes: Equal\en";
\&    21  }
\&    22  else {
\&    23    print "\enConsidering attributes: Not Equal\en";
\&    24  }
.Ve
.PP
When the former program is run without arguments produces the following
output:
.PP
.Vb 1
\&  examples/Node$ equal.pl
\&
\&  Not considering attributes: Equal
\&
\&  Considering attributes: Not Equal
.Ve
.ie n .SS "Using ""equal"" During Testing"
.el .SS "Using \f(CWequal\fP During Testing"
.IX Subsection "Using equal During Testing"
During the development of your compiler you add new stages
to the existing ones. The consequence is that the \s-1AST\s0 is decorated
with new attributes. Unfortunately, this implies that tests you wrote using 
\&\f(CW\*(C`is_deeply\*(C'\fR and comparisons against formerly correct abstract syntax trees are no longer valid.
This is due to the fact that \f(CW\*(C`is_deeply\*(C'\fR requires both tree structures to be
equivalent in every detail and that our new code produces a tree with new attributes.
.PP
Instead of \f(CW\*(C`is_deeply\*(C'\fR use the \f(CW\*(C`equal\*(C'\fR method to check for partial equivalence between
abstract syntax trees. You can follow these steps:
.IP "\(bu" 2
Dump the tree for the source inserting \f(CW\*(C`Data::Dumper\*(C'\fR statements
.IP "\(bu" 2
Carefully check that the tree is really correct
.IP "\(bu" 2
Decide which attributes will be used for comparison
.IP "\(bu" 2
Write the code for the expected value
editing the output produced by \f(CW\*(C`Data::Dumper\*(C'\fR
.IP "\(bu" 2
Write the handlers for the attributes you decided.
Write the comparison using \f(CW\*(C`equal\*(C'\fR.
.PP
Tests using this methodology will not fail even if later code decorating 
the \s-1AST\s0 with new attributes is introduced.
.PP
See an example that checks an abstract syntax tree produced
by the simple compiler (see  \f(CW\*(C`examples/typechecking/Simple\-Types\-XXX.tar.gz\*(C'\fR) 
for a really simple source:
.PP
.Vb 3
\&  Simple\-Types/script$ cat prueba27.c
\&  int f() {
\&  }
.Ve
.PP
The first thing is to obtain a description of the tree,
that can be done executing the compiler under the control of
the Perl debugger, stopping just after the 
tree has been built and dumping the tree
with Data::Dumper:
.PP
.Vb 11
\&  pl@nereida:~/Lbook/code/Simple\-Types/script$ perl \-wd usetypes.pl prueba27.c
\&  main::(usetypes.pl:5):  my $filename = shift || die "Usage:\en$0 file.c\en";
\&    DB<1> c 12
\&  main::(usetypes.pl:12): Simple::Types::show_trees($t, $debug);
\&    DB<2> use Data::Dumper
\&    DB<3> $Data::Dumper::Purity = 1
\&    DB<4> p Dumper($t)
\&  $VAR1 = bless( {
\&                   ..............................................
\&                 }, \*(AqPROGRAM\*(Aq );
\&  ...............................................................
.Ve
.PP
Once we have the shape of a correct tree we can write
our tests:
.PP
.Vb 10
\&  examples/Node$ cat \-n testequal.pl
\&     1  #!/usr/bin/perl \-w
\&     2  use strict;
\&     3  use Parse::Eyapp::Node;
\&     4  use Data::Dumper;
\&     5  use Data::Compare;
\&     6
\&     7  my $debugging = 0;
\&     8
\&     9  my $handler = sub {
\&    10    print Dumper($_[0], $_[1]) if $debugging;
\&    11    Compare($_[0], $_[1])
\&    12  };
\&    13
\&    14  my $t1 = bless( {
\&    15                   \*(Aqtypes\*(Aq => {
\&    16                                \*(AqCHAR\*(Aq => bless( { \*(Aqchildren\*(Aq => [] }, \*(AqCHAR\*(Aq ),
\&    17                                \*(AqVOID\*(Aq => bless( { \*(Aqchildren\*(Aq => [] }, \*(AqVOID\*(Aq ),
\&    18                                \*(AqINT\*(Aq => bless( { \*(Aqchildren\*(Aq => [] }, \*(AqINT\*(Aq ),
\&    19                                \*(AqF(X_0(),INT)\*(Aq => bless( {
\&    20                                   \*(Aqchildren\*(Aq => [
\&    21                                      bless( { \*(Aqchildren\*(Aq => [] }, \*(AqX_0\*(Aq ),
\&    22                                      bless( { \*(Aqchildren\*(Aq => [] }, \*(AqINT\*(Aq ) ]
\&    23                                 }, \*(AqF\*(Aq )
\&    24                              },
\&    25                   \*(Aqsymboltable\*(Aq => { \*(Aqf\*(Aq => { \*(Aqtype\*(Aq => \*(AqF(X_0(),INT)\*(Aq, \*(Aqline\*(Aq => 1 } },
\&    26                   \*(Aqlines\*(Aq => 2,
\&    27                   \*(Aqchildren\*(Aq => [
\&    28                                   bless( {
\&    29                                            \*(Aqsymboltable\*(Aq => {},
\&    30                                            \*(Aqfatherblock\*(Aq => {},
\&    31                                            \*(Aqchildren\*(Aq => [],
\&    32                                            \*(Aqdepth\*(Aq => 1,
\&    33                                            \*(Aqparameters\*(Aq => [],
\&    34                                            \*(Aqfunction_name\*(Aq => [ \*(Aqf\*(Aq, 1 ],
\&    35                                            \*(AqsymboltableLabel\*(Aq => {},
\&    36                                            \*(Aqline\*(Aq => 1
\&    37                                          }, \*(AqFUNCTION\*(Aq )
\&    38                                 ],
\&    39                   \*(Aqdepth\*(Aq => 0,
\&    40                   \*(Aqline\*(Aq => 1
\&    41                 }, \*(AqPROGRAM\*(Aq );
\&    42  $t1\->{\*(Aqchildren\*(Aq}[0]{\*(Aqfatherblock\*(Aq} = $t1;
\&    43
\&    44  # Tree similar to $t1 but without some attributes (line, depth, etc.)
\&    45  my $t2 = bless( {
\&    46                   \*(Aqtypes\*(Aq => {
\&    47                                \*(AqCHAR\*(Aq => bless( { \*(Aqchildren\*(Aq => [] }, \*(AqCHAR\*(Aq ),
\&    48                                \*(AqVOID\*(Aq => bless( { \*(Aqchildren\*(Aq => [] }, \*(AqVOID\*(Aq ),
\&    49                                \*(AqINT\*(Aq => bless( { \*(Aqchildren\*(Aq => [] }, \*(AqINT\*(Aq ),
\&    50                                \*(AqF(X_0(),INT)\*(Aq => bless( {
\&    51                                   \*(Aqchildren\*(Aq => [
\&    52                                      bless( { \*(Aqchildren\*(Aq => [] }, \*(AqX_0\*(Aq ),
\&    53                                      bless( { \*(Aqchildren\*(Aq => [] }, \*(AqINT\*(Aq ) ]
\&    54                                 }, \*(AqF\*(Aq )
\&    55                              },
\&    56                   \*(Aqsymboltable\*(Aq => { \*(Aqf\*(Aq => { \*(Aqtype\*(Aq => \*(AqF(X_0(),INT)\*(Aq, \*(Aqline\*(Aq => 1 } },
\&    57                   \*(Aqchildren\*(Aq => [
\&    58                                   bless( {
\&    59                                            \*(Aqsymboltable\*(Aq => {},
\&    60                                            \*(Aqfatherblock\*(Aq => {},
\&    61                                            \*(Aqchildren\*(Aq => [],
\&    62                                            \*(Aqparameters\*(Aq => [],
\&    63                                            \*(Aqfunction_name\*(Aq => [ \*(Aqf\*(Aq, 1 ],
\&    64                                          }, \*(AqFUNCTION\*(Aq )
\&    65                                 ],
\&    66                 }, \*(AqPROGRAM\*(Aq );
\&    67  $t2\->{\*(Aqchildren\*(Aq}[0]{\*(Aqfatherblock\*(Aq} = $t2;
\&    68
\&    69  # Tree similar to $t1 but without some attributes (line, depth, etc.)
\&    70  # and without the symboltable and types attributes used in the comparison
\&    71  my $t3 = bless( {
\&    72                   \*(Aqtypes\*(Aq => {
\&    73                                \*(AqCHAR\*(Aq => bless( { \*(Aqchildren\*(Aq => [] }, \*(AqCHAR\*(Aq ),
\&    74                                \*(AqVOID\*(Aq => bless( { \*(Aqchildren\*(Aq => [] }, \*(AqVOID\*(Aq ),
\&    75                                \*(AqINT\*(Aq => bless( { \*(Aqchildren\*(Aq => [] }, \*(AqINT\*(Aq ),
\&    76                                \*(AqF(X_0(),INT)\*(Aq => bless( {
\&    77                                   \*(Aqchildren\*(Aq => [
\&    78                                      bless( { \*(Aqchildren\*(Aq => [] }, \*(AqX_0\*(Aq ),
\&    79                                      bless( { \*(Aqchildren\*(Aq => [] }, \*(AqINT\*(Aq ) ]
\&    80                                 }, \*(AqF\*(Aq )
\&    81                              },
\&    82                   \*(Aqchildren\*(Aq => [
\&    83                                   bless( {
\&    84                                            \*(Aqsymboltable\*(Aq => {},
\&    85                                            \*(Aqfatherblock\*(Aq => {},
\&    86                                            \*(Aqchildren\*(Aq => [],
\&    87                                            \*(Aqparameters\*(Aq => [],
\&    88                                            \*(Aqfunction_name\*(Aq => [ \*(Aqf\*(Aq, 1 ],
\&    89                                          }, \*(AqFUNCTION\*(Aq )
\&    90                                 ],
\&    91                 }, \*(AqPROGRAM\*(Aq );
\&    92
\&    93  $t3\->{\*(Aqchildren\*(Aq}[0]{\*(Aqfatherblock\*(Aq} = $t2;
\&    94
\&    95  # Without attributes
\&    96  if (Parse::Eyapp::Node::equal($t1, $t2)) {
\&    97    print "\enNot considering attributes: Equal\en";
\&    98  }
\&    99  else {
\&   100    print "\enNot considering attributes: Not Equal\en";
\&   101  }
\&   102
\&   103  # Equality with attributes
\&   104  if (Parse::Eyapp::Node::equal(
\&   105        $t1, $t2,
\&   106        symboltable => $handler,
\&   107        types => $handler,
\&   108      )
\&   109     ) {
\&   110        print "\enConsidering attributes: Equal\en";
\&   111  }
\&   112  else {
\&   113    print "\enConsidering attributes: Not Equal\en";
\&   114  }
\&   115
\&   116  # Equality with attributes
\&   117  if (Parse::Eyapp::Node::equal(
\&   118        $t1, $t3,
\&   119        symboltable => $handler,
\&   120        types => $handler,
\&   121      )
\&   122     ) {
\&   123        print "\enConsidering attributes: Equal\en";
\&   124  }
\&   125  else {
\&   126    print "\enConsidering attributes: Not Equal\en";
\&   127  }
.Ve
.PP
The code defining tree \f(CW$t1\fR was obtained from an output using \f(CW\*(C`Data::Dumper\*(C'\fR.
The code for trees \f(CW$t2\fR and \f(CW$t3\fR was written using cut-and-paste from \f(CW$t1\fR.
They have the same shape than \f(CW$t1\fR but differ in their attributes. Tree \f(CW$t2\fR
shares with \f(CW$t1\fR the attributes \f(CW\*(C`symboltable\*(C'\fR and \f(CW\*(C`types\*(C'\fR used in the comparison
and so \f(CW\*(C`equal\*(C'\fR returns \f(CW\*(C`true\*(C'\fR when compared. Since \f(CW$t3\fR differs from \f(CW$t1\fR
in the attributes \f(CW\*(C`symboltable\*(C'\fR and \f(CW\*(C`types\*(C'\fR the call to \f(CW\*(C`equal\*(C'\fR returns \f(CW\*(C`false\*(C'\fR.
.SH "FORMATTING Parse::Eyapp PROGRAMS"
.IX Header "FORMATTING Parse::Eyapp PROGRAMS"
I use these rules for indenting Parse::Eyapp programs:
.IP "\(bu" 2
Use uppercase identifiers for tokens, lowercase identifiers for 
syntactic variables
.IP "\(bu" 2
The syntactic variable that defines the rule must be at in a single line 
at the leftmost position:
.Sp
.Vb 4
\&  synvar:
\&       \*(Aqa\*(Aq othervar \*(Aqc\*(Aq
\&    |  \*(Aqb\*(Aq anothervar SOMETOKEN
\&  ;
.Ve
.Sp
The separation bar \f(CW\*(C`|\*(C'\fR goes indented relative to the left side of the rule.
Each production starts two spaces from the bar.
The first right hand side is aligned with the rest.
.IP "\(bu" 2
The semicolon \f(CW\*(C`;\*(C'\fR must also be in its own line at column 0
.IP "\(bu" 2
If there is an empty production it must be the first one and must be commented
.Sp
.Vb 5
\&  syntacvar:
\&       /* empty */
\&    |  \*(Aqa\*(Aq othervar \*(Aqc\*(Aq
\&    |  \*(Aqb\*(Aq anothervar 
\&  ;
.Ve
.IP "\(bu" 2
Only very short semantic actions can go in the same line than the production.
Semantic actions requiring more than one line must go in its own indented block
like in:
.Sp
.Vb 10
\&  exp:
\&      $NUM            { $NUM\->[0] }
\&    | $VAR
\&       {
\&         my $id = $VAR\->[0];
\&         my $val = $s{$id};
\&         $_[0]\->semantic_error("Accessing undefined variable $id at line $VAR\->[1].\en")
\&         unless defined($val);
\&         return $val;
\&       }
\&    | $VAR \*(Aq=\*(Aq $exp   { $s{$VAR\->[0]} = $exp }
\&    | exp.x \*(Aq+\*(Aq exp.y { $x + $y }
\&    | exp.x \*(Aq\-\*(Aq exp.y { $x \- $y }
\&    | exp.x \*(Aq*\*(Aq exp.y { $x * $y }
\&    | exp.x \*(Aq/\*(Aq.barr exp.y
\&      {
\&         return($x/$y) if $y;
\&         $_[0]\->semantic_error("Illegal division by zero at line $barr\->[1].\en");
\&         undef
\&      }
\&    | \*(Aq\-\*(Aq $exp %prec NEG  { \-$exp }
\&    | exp.x \*(Aq^\*(Aq exp.y     { $x ** $y }
\&    | \*(Aq(\*(Aq $exp \*(Aq)\*(Aq        { $exp }
\&  ;
.Ve
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.IP "\(bu" 4
The project home is at <http://code.google.com/p/parse\-eyapp/>.
Use a subversion client to anonymously check out the latest project source code:
.Sp
.Vb 1
\&   svn checkout http://parse\-eyapp.googlecode.com/svn/trunk/ parse\-eyapp\-read\-only
.Ve
.IP "\(bu" 4
The tutorial \fIParsing Strings and Trees with\fR \f(CW\*(C`Parse::Eyapp\*(C'\fR
(An Introduction to Compiler Construction in seven pages) in
<http://nereida.deioc.ull.es/~pl/eyapsimple/>
.IP "\(bu" 4
Parse::Eyapp, 
Parse::Eyapp::eyapplanguageref, 
Parse::Eyapp::debuggingtut,
Parse::Eyapp::defaultactionsintro,
Parse::Eyapp::translationschemestut,
Parse::Eyapp::Driver,
Parse::Eyapp::Node,
Parse::Eyapp::YATW,
Parse::Eyapp::Treeregexp,
Parse::Eyapp::Scope,
Parse::Eyapp::Base,
Parse::Eyapp::datagenerationtut
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/languageintro.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/debuggingtut.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/eyapplanguageref.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/Treeregexp.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/Node.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/YATW.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/Eyapp.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/Base.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/translationschemestut.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/treematchingtut.pdf>
.IP "\(bu" 4
perldoc eyapp,
.IP "\(bu" 4
perldoc treereg,
.IP "\(bu" 4
perldoc vgg,
.IP "\(bu" 4
The Syntax Highlight file for vim at <http://www.vim.org/scripts/script.php?script_id=2453>
and <http://nereida.deioc.ull.es/~vim/>
.IP "\(bu" 4
\&\fIAnalisis Lexico y Sintactico\fR, (Notes for a course in compiler 
construction) by  Casiano Rodriguez-Leon. 
Available at  <http://nereida.deioc.ull.es/~pl/perlexamples/>
Is the more complete and reliable source for Parse::Eyapp. However is in Spanish.
.IP "\(bu" 4
Parse::Yapp,
.IP "\(bu" 4
Man pages of \fIyacc\fR\|(1) and
\&\fIbison\fR\|(1),
<http://www.delorie.com/gnu/docs/bison/bison.html>
.IP "\(bu" 4
Language::AttributeGrammar
.IP "\(bu" 4
Parse::RecDescent.
.IP "\(bu" 4
HOP::Parser
.IP "\(bu" 4
HOP::Lexer
.IP "\(bu" 4
ocamlyacc tutorial at 
<http://plus.kaist.ac.kr/~shoh/ocaml/ocamllex\-ocamlyacc/ocamlyacc\-tutorial/ocamlyacc\-tutorial.html>
.SH "REFERENCES"
.IX Header "REFERENCES"
.IP "\(bu" 4
The classic Dragon's book \fICompilers: Principles, Techniques, and Tools\fR 
by Alfred V. Aho, Ravi Sethi and
Jeffrey D. Ullman (Addison-Wesley 1986)
.IP "\(bu" 4
\&\fI\s-1CS2121:\s0 The Implementation and Power of Programming Languages\fR
(See <http://www.cs.man.ac.uk/~pjj>, <http://www.cs.man.ac.uk/~pjj/complang/g2lr.html> 
and <http://www.cs.man.ac.uk/~pjj/cs2121/ho/ho.html>) by 
Pete Jinks
.SH "CONTRIBUTORS"
.IX Header "CONTRIBUTORS"
.IP "\(bu" 2
Hal Finkel <http://www.halssoftware.com/>
.IP "\(bu" 2
G. Williams <http://kasei.us/>
.IP "\(bu" 2
Thomas L. Shinnick <http://search.cpan.org/~tshinnic/>
.IP "\(bu" 2
Frank Leray
.SH "AUTHOR"
.IX Header "AUTHOR"
Casiano Rodriguez-Leon (casiano@ull.es)
.SH "ACKNOWLEDGMENTS"
.IX Header "ACKNOWLEDGMENTS"
This work has been supported by \s-1CEE \s0(\s-1FEDER\s0) and the Spanish Ministry of
\&\fIEducacion y Ciencia\fR through \fIPlan Nacional I+D+I\fR number \s-1TIN2005\-08818\-C04\-04
\&\s0(\s-1ULL::OPLINK\s0 project <http://www.oplink.ull.es/>). 
Support from Gobierno de Canarias was through \s-1GC02210601
\&\s0(\fIGrupos Consolidados\fR).
The University of La Laguna has also supported my work in many ways
and for many years.
.PP
A large percentage of  code is verbatim taken from Parse::Yapp 1.05.
The author of Parse::Yapp is Francois Desarmenien.
.PP
I wish to thank Francois Desarmenien for his Parse::Yapp module, 
to my students at La Laguna and to the Perl Community. Thanks to 
the people who have contributed to improve the module (see \*(L"\s-1CONTRIBUTORS\*(R"\s0 in Parse::Eyapp).
Thanks to Larry Wall for giving us Perl.
Special thanks to Juana.
.SH "LICENCE AND COPYRIGHT"
.IX Header "LICENCE AND COPYRIGHT"
Copyright (c) 2006\-2008 Casiano Rodriguez-Leon (casiano@ull.es). All rights reserved.
.PP
Parse::Yapp copyright is of Francois Desarmenien, all rights reserved. 1998\-2001
.PP
These modules are free software; you can redistribute it and/or
modify it under the same terms as Perl itself. See perlartistic.
.PP
This program is distributed in the hope that it will be useful,
but \s-1WITHOUT ANY WARRANTY\s0; without even the implied warranty of
\&\s-1MERCHANTABILITY\s0 or \s-1FITNESS FOR A PARTICULAR PURPOSE. \s0
.SH "POD ERRORS"
.IX Header "POD ERRORS"
Hey! \fBThe above document had some coding errors, which are explained below:\fR
.IP "Around line 814:" 4
.IX Item "Around line 814:"
Non-ASCII character seen before =encoding in 'XWhy?.'. Assuming \s-1ISO8859\-1\s0
