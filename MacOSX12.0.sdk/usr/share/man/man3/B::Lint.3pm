.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "B::Lint 3pm"
.TH B::Lint 3pm "2014-09-30" "perl v5.18.4" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
B::Lint \- Perl lint
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
perl \-MO=Lint[,OPTIONS] foo.pl
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The B::Lint module is equivalent to an extended version of the \fB\-w\fR
option of \fBperl\fR. It is named after the program \fIlint\fR which carries
out a similar process for C programs.
.SH "OPTIONS AND LINT CHECKS"
.IX Header "OPTIONS AND LINT CHECKS"
Option words are separated by commas (not whitespace) and follow the
usual conventions of compiler backend options. Following any options
(indicated by a leading \fB\-\fR) come lint check arguments. Each such
argument (apart from the special \fBall\fR and \fBnone\fR options) is a
word representing one possible lint check (turning on that check) or
is \fBno-foo\fR (turning off that check). Before processing the check
arguments, a standard list of checks is turned on. Later options
override earlier ones. Available options are:
.IP "\fBmagic-diamond\fR" 8
.IX Item "magic-diamond"
Produces a warning whenever the magic \f(CW\*(C`<>\*(C'\fR readline is
used. Internally it uses perl's two-argument open which itself treats
filenames with special characters specially. This could allow
interestingly named files to have unexpected effects when reading.
.Sp
.Vb 2
\&  % touch \*(Aqrm *|\*(Aq
\&  % perl \-pe 1
.Ve
.Sp
The above creates a file named \f(CW\*(C`rm *|\*(C'\fR. When perl opens it with
\&\f(CW\*(C`<>\*(C'\fR it actually executes the shell program \f(CW\*(C`rm *\*(C'\fR. This
makes \f(CW\*(C`<>\*(C'\fR dangerous to use carelessly.
.IP "\fBcontext\fR" 8
.IX Item "context"
Produces a warning whenever an array is used in an implicit scalar
context. For example, both of the lines
.Sp
.Vb 2
\&    $foo = length(@bar);
\&    $foo = @bar;
.Ve
.Sp
will elicit a warning. Using an explicit \fB\f(BIscalar()\fB\fR silences the
warning. For example,
.Sp
.Vb 1
\&    $foo = scalar(@bar);
.Ve
.IP "\fBimplicit-read\fR and \fBimplicit-write\fR" 8
.IX Item "implicit-read and implicit-write"
These options produce a warning whenever an operation implicitly
reads or (respectively) writes to one of Perl's special variables.
For example, \fBimplicit-read\fR will warn about these:
.Sp
.Vb 1
\&    /foo/;
.Ve
.Sp
and \fBimplicit-write\fR will warn about these:
.Sp
.Vb 1
\&    s/foo/bar/;
.Ve
.Sp
Both \fBimplicit-read\fR and \fBimplicit-write\fR warn about this:
.Sp
.Vb 1
\&    for (@a) { ... }
.Ve
.IP "\fBbare-subs\fR" 8
.IX Item "bare-subs"
This option warns whenever a bareword is implicitly quoted, but is also
the name of a subroutine in the current package. Typical mistakes that it will
trap are:
.Sp
.Vb 3
\&    use constant foo => \*(Aqbar\*(Aq;
\&    @a = ( foo => 1 );
\&    $b{foo} = 2;
.Ve
.Sp
Neither of these will do what a naive user would expect.
.IP "\fBdollar-underscore\fR" 8
.IX Item "dollar-underscore"
This option warns whenever \f(CW$_\fR is used either explicitly anywhere or
as the implicit argument of a \fBprint\fR statement.
.IP "\fBprivate-names\fR" 8
.IX Item "private-names"
This option warns on each use of any variable, subroutine or
method name that lives in a non-current package but begins with
an underscore (\*(L"_\*(R"). Warnings aren't issued for the special case
of the single character name \*(L"_\*(R" by itself (e.g. \f(CW$_\fR and \f(CW@_\fR).
.IP "\fBundefined-subs\fR" 8
.IX Item "undefined-subs"
This option warns whenever an undefined subroutine is invoked.
This option will only catch explicitly invoked subroutines such
as \f(CW\*(C`foo()\*(C'\fR and not indirect invocations such as \f(CW\*(C`&$subref()\*(C'\fR
or \f(CW\*(C`$obj\->meth()\*(C'\fR. Note that some programs or modules delay
definition of subs until runtime by means of the \s-1AUTOLOAD\s0
mechanism.
.IP "\fBregexp-variables\fR" 8
.IX Item "regexp-variables"
This option warns whenever one of the regexp variables \f(CW\*(C`$\`\*(C'\fR, \f(CW$&\fR or \f(CW\*(C`$\*(Aq\*(C'\fR
is used. Any occurrence of any of these variables in your
program can slow your whole program down. See perlre for
details.
.IP "\fBall\fR" 8
.IX Item "all"
Turn all warnings on.
.IP "\fBnone\fR" 8
.IX Item "none"
Turn all warnings off.
.SH "NON LINT-CHECK OPTIONS"
.IX Header "NON LINT-CHECK OPTIONS"
.IP "\fB\-u Package\fR" 8
.IX Item "-u Package"
Normally, Lint only checks the main code of the program together
with all subs defined in package main. The \fB\-u\fR option lets you
include other package names whose subs are then checked by Lint.
.SH "EXTENDING LINT"
.IX Header "EXTENDING LINT"
Lint can be extended by with plugins. Lint uses Module::Pluggable
to find available plugins. Plugins are expected but not required to
inform Lint of which checks they are adding.
.PP
The \f(CW\*(C`B::Lint\->register_plugin( MyPlugin => \e@new_checks )\*(C'\fR method
adds the list of \f(CW@new_checks\fR to the list of valid checks. If your
module wasn't loaded by Module::Pluggable then your class name is
added to the list of plugins.
.PP
You must create a \f(CW\*(C`match( \e%checks )\*(C'\fR method in your plugin class or one
of its parents. It will be called on every op as a regular method call
with a hash ref of checks as its parameter.
.PP
The class methods \f(CW\*(C`B::Lint\->file\*(C'\fR and \f(CW\*(C`B::Lint\->line\*(C'\fR contain
the current filename and line number.
.PP
.Vb 3
\&  package Sample;
\&  use B::Lint;
\&  B::Lint\->register_plugin( Sample => [ \*(Aqgood_taste\*(Aq ] );
\&  
\&  sub match {
\&      my ( $op, $checks_href ) = shift @_;
\&      if ( $checks_href\->{good_taste} ) {
\&          ...
\&      }
\&  }
.Ve
.SH "TODO"
.IX Header "TODO"
.ie n .IP "while(<\s-1FH\s0>) stomps $_" 4
.el .IP "while(<\s-1FH\s0>) stomps \f(CW$_\fR" 4
.IX Item "while(<FH>) stomps $_"
.PD 0
.IP "strict oo" 4
.IX Item "strict oo"
.IP "unchecked system calls" 4
.IX Item "unchecked system calls"
.IP "more tests, validate against older perls" 4
.IX Item "more tests, validate against older perls"
.PD
.SH "BUGS"
.IX Header "BUGS"
This is only a very preliminary version.
.SH "AUTHOR"
.IX Header "AUTHOR"
Malcolm Beattie, mbeattie@sable.ox.ac.uk.
.SH "ACKNOWLEDGEMENTS"
.IX Header "ACKNOWLEDGEMENTS"
Sebastien Aperghis-Tramoni \- bug fixes
