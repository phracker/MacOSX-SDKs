.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "URI::QueryParam 3"
.TH URI::QueryParam 3 "2012-03-11" "perl v5.18.4" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
URI::QueryParam \- Additional query methods for URIs
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&  use URI;
\&  use URI::QueryParam;
\&
\&  $u = URI\->new("", "http");
\&  $u\->query_param(foo => 1, 2, 3);
\&  print $u\->query;    # prints foo=1&foo=2&foo=3
\&
\&  for my $key ($u\->query_param) {
\&      print "$key: ", join(", ", $u\->query_param($key)), "\en";
\&  }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Loading the \f(CW\*(C`URI::QueryParam\*(C'\fR module adds some extra methods to
URIs that support query methods.  These methods provide an alternative
interface to the \f(CW$u\fR\->query_form data.
.PP
The query_param_* methods have deliberately been made identical to the
interface of the corresponding \f(CW\*(C`CGI.pm\*(C'\fR methods.
.PP
The following additional methods are made available:
.ie n .IP "@keys = $u\->query_param" 4
.el .IP "\f(CW@keys\fR = \f(CW$u\fR\->query_param" 4
.IX Item "@keys = $u->query_param"
.PD 0
.ie n .IP "@values = $u\->query_param( $key )" 4
.el .IP "\f(CW@values\fR = \f(CW$u\fR\->query_param( \f(CW$key\fR )" 4
.IX Item "@values = $u->query_param( $key )"
.ie n .IP "$first_value = $u\->query_param( $key )" 4
.el .IP "\f(CW$first_value\fR = \f(CW$u\fR\->query_param( \f(CW$key\fR )" 4
.IX Item "$first_value = $u->query_param( $key )"
.ie n .IP "$u\->query_param( $key, $value,... )" 4
.el .IP "\f(CW$u\fR\->query_param( \f(CW$key\fR, \f(CW$value\fR,... )" 4
.IX Item "$u->query_param( $key, $value,... )"
.PD
If \f(CW$u\fR\->query_param is called with no arguments, it returns all the
distinct parameter keys of the \s-1URI. \s0 In a scalar context it returns the
number of distinct keys.
.Sp
When a \f(CW$key\fR argument is given, the method returns the parameter values with the
given key.  In a scalar context, only the first parameter value is
returned.
.Sp
If additional arguments are given, they are used to update successive
parameters with the given key.  If any of the values provided are
array references, then the array is dereferenced to get the actual
values.
.ie n .IP "$u\->query_param_append($key, $value,...)" 4
.el .IP "\f(CW$u\fR\->query_param_append($key, \f(CW$value\fR,...)" 4
.IX Item "$u->query_param_append($key, $value,...)"
Adds new parameters with the given
key without touching any old parameters with the same key.  It
can be explained as a more efficient version of:
.Sp
.Vb 3
\&   $u\->query_param($key,
\&                   $u\->query_param($key),
\&                   $value,...);
.Ve
.Sp
One difference is that this expression would return the old values
of \f(CW$key\fR, whereas the \fIquery_param_append()\fR method does not.
.ie n .IP "@values = $u\->query_param_delete($key)" 4
.el .IP "\f(CW@values\fR = \f(CW$u\fR\->query_param_delete($key)" 4
.IX Item "@values = $u->query_param_delete($key)"
.PD 0
.ie n .IP "$first_value = $u\->query_param_delete($key)" 4
.el .IP "\f(CW$first_value\fR = \f(CW$u\fR\->query_param_delete($key)" 4
.IX Item "$first_value = $u->query_param_delete($key)"
.PD
Deletes all key/value pairs with the given key.
The old values are returned.  In a scalar context, only the first value
is returned.
.Sp
Using the \fIquery_param_delete()\fR method is slightly more efficient than
the equivalent:
.Sp
.Vb 1
\&   $u\->query_param($key, []);
.Ve
.ie n .IP "$hashref = $u\->query_form_hash" 4
.el .IP "\f(CW$hashref\fR = \f(CW$u\fR\->query_form_hash" 4
.IX Item "$hashref = $u->query_form_hash"
.PD 0
.ie n .IP "$u\->query_form_hash( \e%new_form )" 4
.el .IP "\f(CW$u\fR\->query_form_hash( \e%new_form )" 4
.IX Item "$u->query_form_hash( %new_form )"
.PD
Returns a reference to a hash that represents the
query form's key/value pairs.  If a key occurs multiple times, then the hash
value becomes an array reference.
.Sp
Note that sequence information is lost.  This means that:
.Sp
.Vb 1
\&   $u\->query_form_hash($u\->query_form_hash);
.Ve
.Sp
is not necessarily a no-op, as it may reorder the key/value pairs.
The values returned by the \fIquery_param()\fR method should stay the same
though.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\s-1URI\s0, \s-1CGI\s0
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright 2002 Gisle Aas.
