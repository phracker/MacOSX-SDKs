.\" Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Type::Utils 3"
.TH Type::Utils 3 "2020-10-28" "perl v5.30.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Type::Utils \- utility functions to make defining and using type constraints a little easier
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&   package Types::Mine;
\&   
\&   use Type::Library \-base;
\&   use Type::Utils \-all;
\&   
\&   BEGIN { extends "Types::Standard" };
\&   
\&   declare "AllCaps",
\&      as "Str",
\&      where { uc($_) eq $_ },
\&      inline_as { my $varname = $_[1]; "uc($varname) eq $varname" };
\&   
\&   coerce "AllCaps",
\&      from "Str", via { uc($_) };
.Ve
.SH "STATUS"
.IX Header "STATUS"
This module is covered by the
Type-Tiny stability policy.
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module provides utility functions to make defining and using type
constraints a little easier.
.SS "Type declaration functions"
.IX Subsection "Type declaration functions"
Many of the following are similar to the similarly named functions described
in Moose::Util::TypeConstraints.
.ie n .IP """declare $name, %options""" 4
.el .IP "\f(CWdeclare $name, %options\fR" 4
.IX Item "declare $name, %options"
.PD 0
.ie n .IP """declare %options""" 4
.el .IP "\f(CWdeclare %options\fR" 4
.IX Item "declare %options"
.PD
Declare a named or anonymous type constraint. Use \f(CW\*(C`as\*(C'\fR and \f(CW\*(C`where\*(C'\fR to
specify the parent type (if any) and (possibly) refine its definition.
.Sp
.Vb 1
\&   declare EvenInt, as Int, where { $_ % 2 == 0 };
\&
\&   my $EvenInt = declare as Int, where { $_ % 2 == 0 };
.Ve
.Sp
\&\fI\s-1NOTE:\s0\fR
If the caller package inherits from Type::Library then any non-anonymous
types declared in the package will be automatically installed into the
library.
.Sp
Hidden gem: if you're inheriting from a type constraint that includes some
coercions, you can include \f(CW\*(C`coercion => 1\*(C'\fR in the \f(CW%options\fR hash
to inherit the coercions.
.ie n .IP """subtype $name, %options""" 4
.el .IP "\f(CWsubtype $name, %options\fR" 4
.IX Item "subtype $name, %options"
.PD 0
.ie n .IP """subtype %options""" 4
.el .IP "\f(CWsubtype %options\fR" 4
.IX Item "subtype %options"
.PD
Declare a named or anonymous type constraint which is descended from an
existing type constraint. Use \f(CW\*(C`as\*(C'\fR and \f(CW\*(C`where\*(C'\fR to specify the parent
type and refine its definition.
.Sp
Actually, you should use \f(CW\*(C`declare\*(C'\fR instead; this is just an alias.
.Sp
This function is not exported by default.
.ie n .IP """type $name, %options""" 4
.el .IP "\f(CWtype $name, %options\fR" 4
.IX Item "type $name, %options"
.PD 0
.ie n .IP """type %options""" 4
.el .IP "\f(CWtype %options\fR" 4
.IX Item "type %options"
.PD
Declare a named or anonymous type constraint which is not descended from
an existing type constraint. Use \f(CW\*(C`where\*(C'\fR to provide a coderef that
constrains values.
.Sp
Actually, you should use \f(CW\*(C`declare\*(C'\fR instead; this is just an alias.
.Sp
This function is not exported by default.
.ie n .IP """as $parent""" 4
.el .IP "\f(CWas $parent\fR" 4
.IX Item "as $parent"
Used with \f(CW\*(C`declare\*(C'\fR to specify a parent type constraint:
.Sp
.Vb 1
\&   declare EvenInt, as Int, where { $_ % 2 == 0 };
.Ve
.ie n .IP """where { BLOCK }""" 4
.el .IP "\f(CWwhere { BLOCK }\fR" 4
.IX Item "where { BLOCK }"
Used with \f(CW\*(C`declare\*(C'\fR to provide the constraint coderef:
.Sp
.Vb 1
\&   declare EvenInt, as Int, where { $_ % 2 == 0 };
.Ve
.Sp
The coderef operates on \f(CW$_\fR, which is the value being tested.
.ie n .IP """message { BLOCK }""" 4
.el .IP "\f(CWmessage { BLOCK }\fR" 4
.IX Item "message { BLOCK }"
Generate a custom error message when a value fails validation.
.Sp
.Vb 6
\&   declare EvenInt,
\&      as Int,
\&      where { $_ % 2 == 0 },
\&      message {
\&         Int\->validate($_) or "$_ is not divisible by two";
\&      };
.Ve
.Sp
Without a custom message, the messages generated by Type::Tiny are along
the lines of \fIValue \*(L"33\*(R" did not pass type constraint \*(L"EvenInt\*(R"\fR,
which is usually reasonable.
.ie n .IP """inline_as { BLOCK }""" 4
.el .IP "\f(CWinline_as { BLOCK }\fR" 4
.IX Item "inline_as { BLOCK }"
Generate a string of Perl code that can be used to inline the type check into
other functions. If your type check is being used within a Moose or Moo
constructor or accessor methods, or used by Type::Params, this can lead to
significant performance improvements.
.Sp
.Vb 10
\&   declare EvenInt,
\&      as Int,
\&      where { $_ % 2 == 0 },
\&      inline_as {
\&         my ($constraint, $varname) = @_;
\&         my $perlcode = 
\&            $constraint\->parent\->inline_check($varname)
\&            . "&& ($varname % 2 == 0)";
\&         return $perlcode;
\&      };
\&   
\&   warn EvenInt\->inline_check(\*(Aq$xxx\*(Aq);  # demonstration
.Ve
.Sp
Your \f(CW\*(C`inline_as\*(C'\fR block can return a list, in which case
these will be smushed together with \*(L"&&\*(R". The first item on the list may
be undef, in which case the undef will be replaced by the inlined parent
type constraint. (And will throw an exception if there is no parent.)
.Sp
.Vb 6
\&   declare EvenInt,
\&      as Int,
\&      where { $_ % 2 == 0 },
\&      inline_as {
\&         return (undef, "($_ % 2 == 0)");
\&      };
.Ve
.ie n .IP """class_type $name, { class => $package, %options }""" 4
.el .IP "\f(CWclass_type $name, { class => $package, %options }\fR" 4
.IX Item "class_type $name, { class => $package, %options }"
.PD 0
.ie n .IP """class_type { class => $package, %options }""" 4
.el .IP "\f(CWclass_type { class => $package, %options }\fR" 4
.IX Item "class_type { class => $package, %options }"
.ie n .IP """class_type $name""" 4
.el .IP "\f(CWclass_type $name\fR" 4
.IX Item "class_type $name"
.PD
Shortcut for declaring a Type::Tiny::Class type constraint.
.Sp
If \f(CW$package\fR is omitted, is assumed to be the same as \f(CW$name\fR.
If \f(CW$name\fR contains \*(L"::\*(R" (which would be an invalid name as far as
Type::Tiny is concerned), this will be removed.
.Sp
So for example, \f(CW\*(C`class_type("Foo::Bar")\*(C'\fR declares a Type::Tiny::Class
type constraint named \*(L"FooBar\*(R" which constrains values to objects blessed
into the \*(L"Foo::Bar\*(R" package.
.ie n .IP """role_type $name, { role => $package, %options }""" 4
.el .IP "\f(CWrole_type $name, { role => $package, %options }\fR" 4
.IX Item "role_type $name, { role => $package, %options }"
.PD 0
.ie n .IP """role_type { role => $package, %options }""" 4
.el .IP "\f(CWrole_type { role => $package, %options }\fR" 4
.IX Item "role_type { role => $package, %options }"
.ie n .IP """role_type $name""" 4
.el .IP "\f(CWrole_type $name\fR" 4
.IX Item "role_type $name"
.PD
Shortcut for declaring a Type::Tiny::Role type constraint.
.Sp
If \f(CW$package\fR is omitted, is assumed to be the same as \f(CW$name\fR.
If \f(CW$name\fR contains \*(L"::\*(R" (which would be an invalid name as far as
Type::Tiny is concerned), this will be removed.
.ie n .IP """duck_type $name, \e@methods""" 4
.el .IP "\f(CWduck_type $name, \e@methods\fR" 4
.IX Item "duck_type $name, @methods"
.PD 0
.ie n .IP """duck_type \e@methods""" 4
.el .IP "\f(CWduck_type \e@methods\fR" 4
.IX Item "duck_type @methods"
.PD
Shortcut for declaring a Type::Tiny::Duck type constraint.
.ie n .IP """union $name, \e@constraints""" 4
.el .IP "\f(CWunion $name, \e@constraints\fR" 4
.IX Item "union $name, @constraints"
.PD 0
.ie n .IP """union \e@constraints""" 4
.el .IP "\f(CWunion \e@constraints\fR" 4
.IX Item "union @constraints"
.PD
Shortcut for declaring a Type::Tiny::Union type constraint.
.ie n .IP """enum $name, \e@values""" 4
.el .IP "\f(CWenum $name, \e@values\fR" 4
.IX Item "enum $name, @values"
.PD 0
.ie n .IP """enum \e@values""" 4
.el .IP "\f(CWenum \e@values\fR" 4
.IX Item "enum @values"
.PD
Shortcut for declaring a Type::Tiny::Enum type constraint.
.ie n .IP """intersection $name, \e@constraints""" 4
.el .IP "\f(CWintersection $name, \e@constraints\fR" 4
.IX Item "intersection $name, @constraints"
.PD 0
.ie n .IP """intersection \e@constraints""" 4
.el .IP "\f(CWintersection \e@constraints\fR" 4
.IX Item "intersection @constraints"
.PD
Shortcut for declaring a Type::Tiny::Intersection type constraint.
.SS "Coercion declaration functions"
.IX Subsection "Coercion declaration functions"
Many of the following are similar to the similarly named functions described
in Moose::Util::TypeConstraints.
.ie n .IP """coerce $target, @coercions""" 4
.el .IP "\f(CWcoerce $target, @coercions\fR" 4
.IX Item "coerce $target, @coercions"
Add coercions to the target type constraint. The list of coercions is a
list of type constraint, conversion code pairs. Conversion code can be
either a string of Perl code or a coderef; in either case the value to
be converted is \f(CW$_\fR.
.ie n .IP """from $source""" 4
.el .IP "\f(CWfrom $source\fR" 4
.IX Item "from $source"
Sugar to specify a type constraint in a list of coercions:
.Sp
.Vb 2
\&   coerce EvenInt, from Int, via { $_ * 2 };  # As a coderef...
\&   coerce EvenInt, from Int, q { $_ * 2 };    # or as a string!
.Ve
.ie n .IP """via { BLOCK }""" 4
.el .IP "\f(CWvia { BLOCK }\fR" 4
.IX Item "via { BLOCK }"
Sugar to specify a coderef in a list of coercions.
.ie n .IP """declare_coercion $name, \e%opts, $type1, $code1, ...""" 4
.el .IP "\f(CWdeclare_coercion $name, \e%opts, $type1, $code1, ...\fR" 4
.IX Item "declare_coercion $name, %opts, $type1, $code1, ..."
.PD 0
.ie n .IP """declare_coercion \e%opts, $type1, $code1, ...""" 4
.el .IP "\f(CWdeclare_coercion \e%opts, $type1, $code1, ...\fR" 4
.IX Item "declare_coercion %opts, $type1, $code1, ..."
.PD
Declares a coercion that is not explicitly attached to any type in the
library. For example:
.Sp
.Vb 1
\&   declare_coercion "ArrayRefFromAny", from "Any", via { [$_] };
.Ve
.Sp
This coercion will be exportable from the library as a Type::Coercion
object, but the ArrayRef type exported by the library won't automatically
use it.
.Sp
Coercions declared this way are immutable (frozen).
.ie n .IP """to_type $type""" 4
.el .IP "\f(CWto_type $type\fR" 4
.IX Item "to_type $type"
Used with \f(CW\*(C`declare_coercion\*(C'\fR to declare the target type constraint for
a coercion, but still without explicitly attaching the coercion to the
type constraint:
.Sp
.Vb 3
\&   declare_coercion "ArrayRefFromAny",
\&      to_type "ArrayRef",
\&      from "Any", via { [$_] };
.Ve
.Sp
You should pretty much always use this when declaring an unattached
coercion because it's exceedingly useful for a type coercion to know what
it will coerce to \- this allows it to skip coercion when no coercion is
needed (e.g. avoiding coercing \f(CW\*(C`[]\*(C'\fR to \f(CW\*(C`[ [] ]\*(C'\fR) and allows
\&\f(CW\*(C`assert_coerce\*(C'\fR to work properly.
.SS "Type library management"
.IX Subsection "Type library management"
.ie n .IP """extends @libraries""" 4
.el .IP "\f(CWextends @libraries\fR" 4
.IX Item "extends @libraries"
Indicates that this type library extends other type libraries, importing
their type constraints.
.Sp
Should usually be executed in a \f(CW\*(C`BEGIN\*(C'\fR block.
.Sp
This is not exported by default because it's not fun to export it to Moo,
Moose or Mouse classes! \f(CW\*(C`use Type::Utils \-all\*(C'\fR can be used to import
it into your type library.
.SS "Other"
.IX Subsection "Other"
.ie n .IP """match_on_type $value => ($type => \e&action, ..., \e&default?)""" 4
.el .IP "\f(CWmatch_on_type $value => ($type => \e&action, ..., \e&default?)\fR" 4
.IX Item "match_on_type $value => ($type => &action, ..., &default?)"
Something like a \f(CW\*(C`switch\*(C'\fR/\f(CW\*(C`case\*(C'\fR or \f(CW\*(C`given\*(C'\fR/\f(CW\*(C`when\*(C'\fR construct. Dispatches
along different code paths depending on the type of the incoming value.
Example blatantly stolen from the Moose documentation:
.Sp
.Vb 3
\&   sub to_json
\&   {
\&      my $value = shift;
\&      
\&      return match_on_type $value => (
\&         HashRef() => sub {
\&            my $hash = shift;
\&            \*(Aq{ \*(Aq
\&               . (
\&               join ", " =>
\&               map { \*(Aq"\*(Aq . $_ . \*(Aq" : \*(Aq . to_json( $hash\->{$_} ) }
\&               sort keys %$hash
\&            ) . \*(Aq }\*(Aq;
\&         },
\&         ArrayRef() => sub {
\&            my $array = shift;
\&            \*(Aq[ \*(Aq.( join ", " => map { to_json($_) } @$array ).\*(Aq ]\*(Aq;
\&         },
\&         Num()   => q {$_},
\&         Str()   => q { \*(Aq"\*(Aq . $_ . \*(Aq"\*(Aq },
\&         Undef() => q {\*(Aqnull\*(Aq},
\&         => sub { die "$_ is not acceptable json type" },
\&      );
\&   }
.Ve
.Sp
Note that unlike Moose, code can be specified as a string instead of a
coderef. (e.g. for \f(CW\*(C`Num\*(C'\fR, \f(CW\*(C`Str\*(C'\fR and \f(CW\*(C`Undef\*(C'\fR above.)
.Sp
For improved performance, try \f(CW\*(C`compile_match_on_type\*(C'\fR.
.Sp
This function is not exported by default.
.ie n .IP """my $coderef = compile_match_on_type($type => \e&action, ..., \e&default?)""" 4
.el .IP "\f(CWmy $coderef = compile_match_on_type($type => \e&action, ..., \e&default?)\fR" 4
.IX Item "my $coderef = compile_match_on_type($type => &action, ..., &default?)"
Compile a \f(CW\*(C`match_on_type\*(C'\fR block into a coderef. The following \s-1JSON\s0
converter is about two orders of magnitude faster than the previous
example:
.Sp
.Vb 10
\&   sub to_json;
\&   *to_json = compile_match_on_type(
\&      HashRef() => sub {
\&         my $hash = shift;
\&         \*(Aq{ \*(Aq
\&            . (
\&            join ", " =>
\&            map { \*(Aq"\*(Aq . $_ . \*(Aq" : \*(Aq . to_json( $hash\->{$_} ) }
\&            sort keys %$hash
\&         ) . \*(Aq }\*(Aq;
\&      },
\&      ArrayRef() => sub {
\&         my $array = shift;
\&         \*(Aq[ \*(Aq.( join ", " => map { to_json($_) } @$array ).\*(Aq ]\*(Aq;
\&      },
\&      Num()   => q {$_},
\&      Str()   => q { \*(Aq"\*(Aq . $_ . \*(Aq"\*(Aq },
\&      Undef() => q {\*(Aqnull\*(Aq},
\&      => sub { die "$_ is not acceptable json type" },
\&   );
.Ve
.Sp
Remember to store the coderef somewhere fairly permanent so that you
don't compile it over and over. \f(CW\*(C`state\*(C'\fR variables (in Perl >= 5.10)
are good for this. (Same sort of idea as Type::Params.)
.Sp
This function is not exported by default.
.ie n .IP """my $coderef = classifier(@types)""" 4
.el .IP "\f(CWmy $coderef = classifier(@types)\fR" 4
.IX Item "my $coderef = classifier(@types)"
Returns a coderef that can be used to classify values according to their
type constraint. The coderef, when passed a value, returns a type
constraint which the value satisfies.
.Sp
.Vb 3
\&   use feature qw( say );
\&   use Type::Utils qw( classifier );
\&   use Types::Standard qw( Int Num Str Any );
\&   
\&   my $classifier = classifier(Str, Int, Num, Any);
\&   
\&   say $classifier\->( "42"  )\->name;   # Int
\&   say $classifier\->( "4.2" )\->name;   # Num
\&   say $classifier\->( []    )\->name;   # Any
.Ve
.Sp
Note that, for example, \*(L"42\*(R" satisfies Int, but it would satisfy the
type constraints Num, Str, and Any as well. In this case, the
classifier has picked the most specific type constraint that \*(L"42\*(R"
satisfies.
.Sp
If no type constraint is satisfied by the value, then the classifier
will return undef.
.ie n .IP """dwim_type($string, %options)""" 4
.el .IP "\f(CWdwim_type($string, %options)\fR" 4
.IX Item "dwim_type($string, %options)"
Given a string like \*(L"ArrayRef[Int|CodeRef]\*(R", turns it into a type constraint
object, hopefully doing what you mean.
.Sp
It uses the syntax of Type::Parser. Firstly the Type::Registry
for the caller package is consulted; if that doesn't have a match,
Types::Standard is consulted for standard type constraint names.
.Sp
If none of the above yields a type constraint, and the caller class
is a Moose-based class, then \f(CW\*(C`dwim_type\*(C'\fR attempts to look the type
constraint up in the Moose type registry. If it's a Mouse-based class,
then the Mouse type registry is used instead.
.Sp
If no type constraint can be found via these normal methods, several
fallbacks are available:
.RS 4
.ie n .IP """lookup_via_moose""" 4
.el .IP "\f(CWlookup_via_moose\fR" 4
.IX Item "lookup_via_moose"
Lookup in Moose registry even if caller is non-Moose class.
.ie n .IP """lookup_via_mouse""" 4
.el .IP "\f(CWlookup_via_mouse\fR" 4
.IX Item "lookup_via_mouse"
Lookup in Mouse registry even if caller is non-Mouse class.
.ie n .IP """make_class_type""" 4
.el .IP "\f(CWmake_class_type\fR" 4
.IX Item "make_class_type"
Create a new Type::Tiny::Class constraint.
.ie n .IP """make_role_type""" 4
.el .IP "\f(CWmake_role_type\fR" 4
.IX Item "make_role_type"
Create a new Type::Tiny::Role constraint.
.RE
.RS 4
.Sp
You can alter which should be attempted, and in which order, by passing
an option to \f(CW\*(C`dwim_type\*(C'\fR:
.Sp
.Vb 4
\&   my $type = Type::Utils::dwim_type(
\&      "ArrayRef[Int]",
\&      fallback      => [ "lookup_via_mouse" , "make_role_type" ],
\&   );
.Ve
.Sp
For historical reasons, by default the fallbacks attempted are:
.Sp
.Vb 1
\&   lookup_via_moose, lookup_via_mouse, make_class_type
.Ve
.Sp
You may set \f(CW\*(C`fallback\*(C'\fR to an empty arrayref to avoid using any of
these fallbacks.
.Sp
You can specify an alternative for the caller using the \f(CW\*(C`for\*(C'\fR option.
.Sp
.Vb 1
\&   my $type = dwim_type("ArrayRef", for => "Moose::Object");
.Ve
.Sp
While it's probably better overall to use the proper Type::Registry
interface for resolving type constraint strings, this function often does
what you want.
.Sp
It should never die if it fails to find a type constraint (but may die
if the type constraint string is syntactically malformed), preferring to
return undef.
.Sp
This function is not exported by default.
.RE
.ie n .IP """is($type, $value)""" 4
.el .IP "\f(CWis($type, $value)\fR" 4
.IX Item "is($type, $value)"
Shortcut for \f(CW\*(C`$type\->check($value)\*(C'\fR but also if \f(CW$type\fR is a string,
will look it up via \f(CW\*(C`dwim_type\*(C'\fR.
.Sp
This function is not exported by default.
This function is not even exported by \f(CW\*(C`use Type::Utils \-all\*(C'\fR.
You must request it explicitly.
.Sp
.Vb 1
\&  use Type::Utils "is";
.Ve
.Sp
Beware using this in test scripts because it has the same name as a function
exported by Test::More. Note that you can rename this function if
\&\f(CW\*(C`is\*(C'\fR will cause conflicts:
.Sp
.Vb 1
\&   use Type::Utils "is" => { \-as => "isntnt" };
.Ve
.ie n .IP """assert($type, $value)""" 4
.el .IP "\f(CWassert($type, $value)\fR" 4
.IX Item "assert($type, $value)"
Like \f(CW\*(C`is\*(C'\fR but instead of returning a boolean, returns \f(CW$value\fR and
dies if the value fails the type check.
.Sp
This function is not exported by default, but it is exported by
\&\f(CW\*(C`use Type::Utils \-all\*(C'\fR.
.ie n .IP """english_list(\e$conjunction, @items)""" 4
.el .IP "\f(CWenglish_list(\e$conjunction, @items)\fR" 4
.IX Item "english_list($conjunction, @items)"
Joins the items with commas, placing a conjunction before the final item.
The conjunction is optional, defaulting to \*(L"and\*(R".
.Sp
.Vb 2
\&   english_list(qw/foo bar baz/);       # "foo, bar, and baz"
\&   english_list(\e"or", qw/quux quuux/); # "quux or quuux"
.Ve
.Sp
This function is not exported by default.
.SH "EXPORT"
.IX Header "EXPORT"
By default, all of the functions documented above are exported, except
\&\f(CW\*(C`subtype\*(C'\fR and \f(CW\*(C`type\*(C'\fR (prefer \f(CW\*(C`declare\*(C'\fR instead), \f(CW\*(C`extends\*(C'\fR, \f(CW\*(C`dwim_type\*(C'\fR,
\&\f(CW\*(C`match_on_type\*(C'\fR/\f(CW\*(C`compile_match_on_type\*(C'\fR, \f(CW\*(C`classifier\*(C'\fR, and
\&\f(CW\*(C`english_list\*(C'\fR.
.PP
This module uses Exporter::Tiny; see the documentation of that module
for tips and tricks importing from Type::Utils.
.SH "BUGS"
.IX Header "BUGS"
Please report any bugs to
<http://rt.cpan.org/Dist/Display.html?Queue=Type\-Tiny>.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Type::Tiny::Manual.
.PP
Type::Tiny, Type::Library, Types::Standard, Type::Coercion.
.PP
Type::Tiny::Class, Type::Tiny::Role, Type::Tiny::Duck,
Type::Tiny::Enum, Type::Tiny::Union.
.PP
Moose::Util::TypeConstraints,
Mouse::Util::TypeConstraints.
.SH "AUTHOR"
.IX Header "AUTHOR"
Toby Inkster <tobyink@cpan.org>.
.SH "COPYRIGHT AND LICENCE"
.IX Header "COPYRIGHT AND LICENCE"
This software is copyright (c) 2013\-2014, 2017\-2020 by Toby Inkster.
.PP
This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.
.SH "DISCLAIMER OF WARRANTIES"
.IX Header "DISCLAIMER OF WARRANTIES"
\&\s-1THIS PACKAGE IS PROVIDED \*(L"AS IS\*(R" AND WITHOUT ANY EXPRESS OR IMPLIED
WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.\s0
