.\" Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Test2::Manual::Anatomy::EndToEnd 3"
.TH Test2::Manual::Anatomy::EndToEnd 3 "2020-10-22" "perl v5.30.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Test2::Manual::EndToEnd \- Overview of Test2 from load to finish.
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This is a high level overview of everything from loading Test2 through the end
of a test script.
.SH "WHAT HAPPENS WHEN I LOAD THE API?"
.IX Header "WHAT HAPPENS WHEN I LOAD THE API?"
.Vb 1
\&    use Test2::API qw/context/;
.Ve
.IP "A singleton instance of Test2::API::Instance is created." 4
.IX Item "A singleton instance of Test2::API::Instance is created."
You have no access to this, it is an implementation detail.
.IP "Several \s-1API\s0 functions are defined that use the singleton instance." 4
.IX Item "Several API functions are defined that use the singleton instance."
You can import these functions, or use them directly.
.IP "Then what?" 4
.IX Item "Then what?"
It waits...
.Sp
The \s-1API\s0 intentionally does as little as possible. At this point something can
still change the formatter, load Test2::IPC, or have other global effects
that need to be done before the first Test2::API::Context is created. Once
the first Test2::API::Context is created the \s-1API\s0 will finish initialization.
.Sp
See \*(L"\s-1WHAT HAPPENS WHEN I ACQUIRE A CONTEXT\s0?\*(R" for more information.
.SH "WHAT HAPPENS WHEN I USE A TOOL?"
.IX Header "WHAT HAPPENS WHEN I USE A TOOL?"
This section covers the basic workflow all tools such as \f(CW\*(C`ok()\*(C'\fR must follow.
.PP
.Vb 2
\&    sub ok($$) {
\&        my ($bool, $name) = @_;
\&
\&        my $ctx = context();
\&
\&        my $event = $ctx\->send_event(\*(AqOk\*(Aq, pass => $bool, name => $name);
\&
\&        ...
\&
\&        $ctx\->release;
\&        return $bool;
\&    }
\&
\&    ok(1, "1 is true");
.Ve
.IP "A tool function is run." 4
.IX Item "A tool function is run."
.Vb 1
\&    ok(1, "1 is true");
.Ve
.IP "The tool acquires a context object." 4
.IX Item "The tool acquires a context object."
.Vb 1
\&    my $ctx = context();
.Ve
.Sp
See \*(L"\s-1WHAT HAPPENS WHEN I ACQUIRE A CONTEXT\s0?\*(R" for more information.
.IP "The tool uses the context object to create, send, and return events." 4
.IX Item "The tool uses the context object to create, send, and return events."
See \*(L"\s-1WHAT HAPPENS WHEN I SEND AN EVENT\s0?\*(R" for more information.
.Sp
.Vb 1
\&    my $event = $ctx\->send_event(\*(AqOk\*(Aq, pass => $bool, name => $name);
.Ve
.IP "When done the tool \s-1MUST\s0 release the context." 4
.IX Item "When done the tool MUST release the context."
See \*(L"\s-1WHAT HAPPENS WHEN I RELEASE A CONTEXT\s0?\*(R" for more information.
.Sp
.Vb 1
\&    $ctx\->release();
.Ve
.IP "The tool returns." 4
.IX Item "The tool returns."
.Vb 1
\&    return $bool;
.Ve
.SH "WHAT HAPPENS WHEN I ACQUIRE A CONTEXT?"
.IX Header "WHAT HAPPENS WHEN I ACQUIRE A CONTEXT?"
.Vb 1
\&    my $ctx = context();
.Ve
.PP
These actions may not happen exactly in this order, but that is an
implementation detail. For the purposes of this document this order is used to
help the reader understand the flow.
.IP "$!, $@, $? and $^E are captured and preserved." 4
.IX Item "$!, $@, $? and $^E are captured and preserved."
Test2 makes a point to preserve the values of $!, $@, $? and $^E such that the test
tools do not modify these variables unexpectedly. They are captured first thing
so that they can be restored later.
.IP "The \s-1API\s0 state is changed to 'loaded'." 4
.IX Item "The API state is changed to 'loaded'."
The 'loaded' state means that test tools have already started running. This is
important as some plugins need to take effect before any tests are run. This
state change only happens the first time a context is acquired, and may trigger
some hooks defined by plugins to run.
.IP "The current hub is found." 4
.IX Item "The current hub is found."
A context attaches itself to the current Test2::Hub. If there is no current
hub then the root hub will be initialized. This will also initialize the hub
stack if necessary.
.IP "Context acquire hooks fire." 4
.IX Item "Context acquire hooks fire."
It is possible to create global, or hub-specific hooks that fire whenever a
context is acquired, these hooks will fire now. These hooks fire even if there
is an existing context.
.IP "Any existing context is found." 4
.IX Item "Any existing context is found."
If the current hub already has a context then a clone of it will be used
instead of a completely new context. This is important because it allows nested
tools to inherit the context used by parent tools.
.IP "Stack depth is measured." 4
.IX Item "Stack depth is measured."
Test2 makes a point to catch mistakes in how the context is used. The stack
depth is used to accomplish this. If there is an existing context the depth
will be checked against the one found here. If the old context has the same
stack depth, or a shallower one, it means a tool is misbehaving and did not
clean up the context when it was done, in which case the old context will be
cleaned up, and a warning issued.
.IP "A new context is created (if no existing context was found)" 4
.IX Item "A new context is created (if no existing context was found)"
If there is no existing context, a new one will be created using the data
collected so far.
.IP "Context init hooks fire (if no existing context was found)" 4
.IX Item "Context init hooks fire (if no existing context was found)"
If a new context was created, context-creation hooks will fire.
.IP "$!, $@, $?, and $^E are restored." 4
.IX Item "$!, $@, $?, and $^E are restored."
We make sure $!, $@, $?, and $^E are unchanged at this point so that changes we
made will not effect anything else. This is done in case something inside the
context construction accidentally changed these vars.
.IP "The context is returned." 4
.IX Item "The context is returned."
You have a shiney new context object, or a clone of the existing context.
.SH "WHAT HAPPENS WHEN I SEND AN EVENT?"
.IX Header "WHAT HAPPENS WHEN I SEND AN EVENT?"
.Vb 1
\&    my $event = $ctx\->send_event(\*(AqOk\*(Aq, pass => $bool, name => $name);
.Ve
.IP "The Test2::Event::Ok module is loaded." 4
.IX Item "The Test2::Event::Ok module is loaded."
The \f(CW\*(C`send_event()\*(C'\fR method will automatically load any Event package necessary.
Normally \f(CW\*(C`send_event()\*(C'\fR will assume the first argument is an event class
without the \f(CW\*(C`Test2::Event::\*(C'\fR prefix, which it will add for you. If you want to
use an event class that is in a different namespace you can prefix the class
name with a \f(CW\*(C`+\*(C'\fR to tell the tool that you are giving a fully qualified class
name:
.Sp
.Vb 1
\&    my $event = $ctx\->send_event(\*(Aq+Fully::Qualified::Event\*(Aq, pass => $bool, name => $name);
.Ve
.IP "A new instance of Test2::Event::Ok is created." 4
.IX Item "A new instance of Test2::Event::Ok is created."
The event object is instantiated using the provided parameters.
.IP "The event object is sent to the hub." 4
.IX Item "The event object is sent to the hub."
The hub takes over from here.
.IP "The hub runs the event through any filters." 4
.IX Item "The hub runs the event through any filters."
Filters are able to modify or remove events. Filters are run first, before the
event can modify global test state.
.IP "The global test state is updated to reflect the event." 4
.IX Item "The global test state is updated to reflect the event."
If the event effects test count then the count will be incremented. If the
event causes failure then the failure count will be incremented. There are a
couple other ways the global state can be effected as well.
.IP "The event is sent to the formatter" 4
.IX Item "The event is sent to the formatter"
After the state is changed the hub will send the event to the formatter for
rendering. This is where \s-1TAP\s0 is normally produced.
.IP "The event is sent to all listeners." 4
.IX Item "The event is sent to all listeners."
There can be any number of listeners that take action when events are
processed, this happens now.
.SH "WHAT HAPPENS WHEN I RELEASE A CONTEXT?"
.IX Header "WHAT HAPPENS WHEN I RELEASE A CONTEXT?"
.Vb 1
\&    $ctx\->release;
.Ve
.IP "The current context clone is released." 4
.IX Item "The current context clone is released."
If your tool is nested inside another, then releasing will simply destroy the
copy of the context, nothing else will happen.
.IP "If this was the canonical context, it will actually release" 4
.IX Item "If this was the canonical context, it will actually release"
When a context is created it is considered 'canon'. Any context obtained by a
nested tool will be considered a child context linked to the canonical one.
Releasing child contexts does not do anything of note (but is still required).
.IP "Release hooks are called" 4
.IX Item "Release hooks are called"
Release hooks are the main motivation behind making the \f(CW\*(C`release()\*(C'\fR method,
and making it a required action on the part of test tools. These are hooks that
we can have called when a tool is complete. This is how plugins like
Test2::Plugin::DieOnFail are implemented. If we simply had a destructor call
the hooks then we would be unable to write this plugin as a \f(CW\*(C`die\*(C'\fR inside of a
destructor is useless.
.IP "The context is cleared" 4
.IX Item "The context is cleared"
The main context data is cleared allowing the next tool to create a new
context. This is important as the next tool very likely has a new line number.
.IP "$!, $@, $?, and $^E are restored" 4
.IX Item "$!, $@, $?, and $^E are restored"
When a Test2 tool is complete it will restore $@, $!, $? and $^E to avoid action at
a distance.
.SH "WHAT HAPPENS WHEN I USE \fBdone_testing()\fP?"
.IX Header "WHAT HAPPENS WHEN I USE done_testing()?"
.Vb 1
\&    done_testing();
.Ve
.IP "Any pending \s-1IPC\s0 events will be culled." 4
.IX Item "Any pending IPC events will be culled."
If \s-1IPC\s0 is turned on, a final culling will take place.
.IP "Follow-up hooks are run" 4
.IX Item "Follow-up hooks are run"
The follow-up hooks are a way to run actions when a hub is complete. This is
useful for adding cleanup tasks, or final tests to the end of a test.
.IP "The final plan event is generated and processed." 4
.IX Item "The final plan event is generated and processed."
The final plan event will be produced using the current test count as the
number of tests planned.
.IP "The current hub is finalized." 4
.IX Item "The current hub is finalized."
This will mark the hub is complete, and will not allow new events to be
processed.
.SH "WHAT HAPPENS WHEN A TEST SCRIPT IS DONE?"
.IX Header "WHAT HAPPENS WHEN A TEST SCRIPT IS DONE?"
Test2 has some behaviors it runs in an \f(CW\*(C`END { ... }\*(C'\fR block after tests are
done running. This end block does some final checks to warn you if something
went wrong. This end block also sets the exit value of the script.
.IP "\s-1API\s0 Versions are checked." 4
.IX Item "API Versions are checked."
A warning will be produced if Test::Builder is loaded, but has a different
version compared to Test2::API. This situation can happen if you downgrade
to an older Test-Simple distribution, and is a bad situation.
.IP "Any remaining context objects are cleaned up." 4
.IX Item "Any remaining context objects are cleaned up."
If there are leftover context objects they will need to be cleaned up. A
leftover context is never a good thing, and usually requires a warning. A
leftover context could also be the result of an exception being thrown which
terminates the script, Test2 is fairly good at noticing this and not warning
in these cases as the warning would simply be noise.
.IP "Child processes are sent a 'waiting' event." 4
.IX Item "Child processes are sent a 'waiting' event."
If \s-1IPC\s0 is active, a waiting event is sent to all child processes.
.IP "The script will wait for all child processes and/or threads to complete." 4
.IX Item "The script will wait for all child processes and/or threads to complete."
This happens only when \s-1IPC\s0 is loaded, but Test::Builder is not. This behavior
is useful, but would break compatibility for legacy tests.
.IP "The hub stack is cleaned up." 4
.IX Item "The hub stack is cleaned up."
All hubs are finalized starting from the top. Leftover hubs are usually a bad
thing, so a warning is produced if any are found.
.IP "The root hub is finalized." 4
.IX Item "The root hub is finalized."
This step is a no-op if \f(CW\*(C`done_testing()\*(C'\fR was used. If needed this will mark
the root hub as finished.
.IP "Exit callbacks are called." 4
.IX Item "Exit callbacks are called."
This is a chance for plugins to modify the final exit value of the script.
.IP "The scripts exit value ($?) is set." 4
.IX Item "The scripts exit value ($?) is set."
If the test encountered any failures this will be set to a non-zero value. If
possible this will be set to the number of failures, or 255 if the number is
larger than 255 (the max value allowed).
.IP "Broken module diagnostics" 4
.IX Item "Broken module diagnostics"
Test2 is aware of many modules which were broken by Test2's release. At this
point the script will check if any known-broken modules were loaded, and warn
you if they were.
.Sp
\&\fBNote:\fR This only happens if there were test failures. No broken module
warnings are produced on a success.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Test2::Manual \- Primary index of the manual.
.SH "SOURCE"
.IX Header "SOURCE"
The source code repository for Test2\-Manual can be found at
\&\fIhttps://github.com/Test\-More/Test2\-Suite/\fR.
.SH "MAINTAINERS"
.IX Header "MAINTAINERS"
.IP "Chad Granum <exodist@cpan.org>" 4
.IX Item "Chad Granum <exodist@cpan.org>"
.SH "AUTHORS"
.IX Header "AUTHORS"
.PD 0
.IP "Chad Granum <exodist@cpan.org>" 4
.IX Item "Chad Granum <exodist@cpan.org>"
.PD
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright 2018 Chad Granum <exodist@cpan.org>.
.PP
This program is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.
.PP
See \fIhttp://dev.perl.org/licenses/\fR
