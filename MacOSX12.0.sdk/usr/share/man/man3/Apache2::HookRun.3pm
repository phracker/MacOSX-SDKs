.\" Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "install::TempContent::Objects::mod_perl-2.0.9::docs::api::Apache2::HookRun 3"
.TH install::TempContent::Objects::mod_perl-2.0.9::docs::api::Apache2::HookRun 3 "2015-06-18" "perl v5.30.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Apache2::HookRun \- Perl API for Invoking Apache HTTP phases
.SH "Synopsis"
.IX Header "Synopsis"
.Vb 2
\&  # httpd.conf
\&  PerlProcessConnectionHandler MyApache2::PseudoHTTP::handler
\&
\&  #file:MyApache2/PseudoHTTP.pm
\&  #\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&  package MyApache2::PseudoHTTP;
\&  
\&  use Apache2::HookRun ();
\&  use Apache2::RequestUtil ();
\&  use Apache2::RequestRec ();
\&  
\&  use Apache2::Const \-compile => qw(OK DECLINED DONE SERVER_ERROR);
\&  
\&  # implement the HTTP protocol cycle in protocol handler
\&  sub handler {
\&      my $c = shift;
\&      my $r = Apache2::RequestRec\->new($c);
\&  
\&      # register any custom callbacks here, e.g.:
\&      # $r\->push_handlers(PerlAccessHandler => \e&my_access);
\&  
\&      $rc = $r\->run_post_read_request();
\&      return $rc unless $rc == Apache2::Const::OK or $rc == Apache2::Const::DECLINED;
\&  
\&      $rc = $r\->run_translate_name;
\&      return $rc unless $rc == Apache2::Const::OK or $rc == Apache2::Const::DECLINED;
\&  
\&      $rc = $r\->run_map_to_storage;
\&      return $rc unless $rc == Apache2::Const::OK or $rc == Apache2::Const::DECLINED;
\&  
\&      # this must be run all a big havoc will happen in the following
\&      # phases
\&      $r\->location_merge($path);
\&  
\&      $rc = $r\->run_header_parser;
\&      return $rc unless $rc == Apache2::Const::OK or $rc == Apache2::Const::DECLINED;
\&  
\&      my $args = $r\->args || \*(Aq\*(Aq;
\&      if ($args eq \*(Aqdie\*(Aq) {
\&          $r\->die(Apache2::Const::SERVER_ERROR);
\&          return Apache2::Const::DONE;
\&      }
\&  
\&      $rc = $r\->run_access_checker;
\&      return $rc unless $rc == Apache2::Const::OK or $rc == Apache2::Const::DECLINED;
\&  
\&      $rc = $r\->run_auth_checker;
\&      return $rc unless $rc == Apache2::Const::OK or $rc == Apache2::Const::DECLINED;
\&  
\&      $rc = $r\->run_check_user_id;
\&      return $rc unless $rc == Apache2::Const::OK or $rc == Apache2::Const::DECLINED;
\&  
\&      $rc = $r\->run_type_checker;
\&      return $rc unless $rc == Apache2::Const::OK or $rc == Apache2::Const::DECLINED;
\&  
\&      $rc = $r\->run_fixups;
\&      return $rc unless $rc == Apache2::Const::OK or $rc == Apache2::Const::DECLINED;
\&  
\&      # $r\->run_handler is called internally by $r\->invoke_handler,
\&      # invoke_handler sets all kind of filters, and does a few other
\&      # things but it\*(Aqs possible to call $r\->run_handler, bypassing
\&      # invoke_handler
\&      $rc = $r\->invoke_handler;
\&      return $rc unless $rc == Apache2::Const::OK or $rc == Apache2::Const::DECLINED;
\&  
\&      $rc = $r\->run_log_transaction;
\&      return $rc unless $rc == Apache2::Const::OK or $rc == Apache2::Const::DECLINED;
\&  
\&      return Apache2::Const::OK;
\&  }
.Ve
.SH "Description"
.IX Header "Description"
\&\f(CW\*(C`Apache2::HookRun\*(C'\fR exposes parts of the Apache \s-1HTTP\s0 protocol
implementation, responsible for invoking callbacks for each \s-1HTTP\s0
Request cycle
phase.
.PP
Armed with that \s-1API,\s0 you could run some of the http protocol framework
parts when implementing your own protocols. For example see how \s-1HTTP
AAA\s0 (access, auth and authz) hooks are called from a protocol handler,
implementing a command
server, which has
nothing to do with \s-1HTTP.\s0 Also you can see in Synopsis how
to re-implement Apache \s-1HTTP\s0 cycle in the protocol handler.
.PP
Using this \s-1API\s0 you could probably also change the normal Apache
behavior (e.g. invoking some hooks earlier than normal, or later), but
before doing that you will probably need to spend some time reading
through the Apache C code. That's why some of the methods in this
document, point you to the specific functions in the Apache source
code. If you just try to use the methods from this module, without
understanding them well, don't be surprised if you will get some nasty
crashes, from which mod_perl can't protect you.
.SH "API"
.IX Header "API"
\&\f(CW\*(C`Apache2::HookRun\*(C'\fR provides the following functions and/or methods:
.ie n .SS """die"""
.el .SS "\f(CWdie\fP"
.IX Subsection "die"
Kill the current request
.PP
.Vb 1
\&  $r\->die($type);
.Ve
.ie n .IP "obj: $r ( ""Apache2::RequestRec object"" )" 4
.el .IP "obj: \f(CW$r\fR ( \f(CWApache2::RequestRec object\fR )" 4
.IX Item "obj: $r ( Apache2::RequestRec object )"
The current request
.ie n .IP "arg1: $type ( integer )" 4
.el .IP "arg1: \f(CW$type\fR ( integer )" 4
.IX Item "arg1: $type ( integer )"
Why the request is dieing. Expects an Apache status constant.
.IP "ret: no return value" 4
.IX Item "ret: no return value"
.PD 0
.IP "since: 2.0.00" 4
.IX Item "since: 2.0.00"
.PD
.PP
This method doesn't really abort the request, it just handles the
sending of the error response, logging the error and such.  You want
to take a look at the internals of \f(CW\*(C`ap_die()\*(C'\fR in
\&\fIhttpd\-2.0/modules/http/http_request.c\fR for more details.
.ie n .SS """invoke_handler"""
.el .SS "\f(CWinvoke_handler\fP"
.IX Subsection "invoke_handler"
Run the
response phase.
.PP
.Vb 1
\&  $rc = $r\->invoke_handler();
.Ve
.ie n .IP "obj: $r ( ""Apache2::RequestRec object"" )" 4
.el .IP "obj: \f(CW$r\fR ( \f(CWApache2::RequestRec object\fR )" 4
.IX Item "obj: $r ( Apache2::RequestRec object )"
The current request
.ie n .IP "ret: $rc ( integer )" 4
.el .IP "ret: \f(CW$rc\fR ( integer )" 4
.IX Item "ret: $rc ( integer )"
The status of the current phase run: \f(CW\*(C`Apache2::Const::OK\*(C'\fR,
\&\f(CW\*(C`Apache2::HTTP_...\*(C'\fR
.IP "since: 2.0.00" 4
.IX Item "since: 2.0.00"
.PP
\&\f(CW\*(C`invoke_handler()\*(C'\fR allows modules to insert filters, sets a default
handler if none is set, runs \f(CW\*(C`run_handler()\*(C'\fR and
handles some errors.
.PP
For more details see \f(CW\*(C`ap_invoke_handler()\*(C'\fR in
\&\fIhttpd\-2.0/server/config.c\fR.
.ie n .SS """run_access_checker"""
.el .SS "\f(CWrun_access_checker\fP"
.IX Subsection "run_access_checker"
Run the resource access
control phase.
.PP
.Vb 1
\&  $rc = $r\->run_access_checker();
.Ve
.ie n .IP "obj: $r ( ""Apache2::RequestRec object"" )" 4
.el .IP "obj: \f(CW$r\fR ( \f(CWApache2::RequestRec object\fR )" 4
.IX Item "obj: $r ( Apache2::RequestRec object )"
the current request
.ie n .IP "ret: $rc ( integer )" 4
.el .IP "ret: \f(CW$rc\fR ( integer )" 4
.IX Item "ret: $rc ( integer )"
The status of the current phase run: \f(CW\*(C`Apache2::Const::OK\*(C'\fR,
\&\f(CW\*(C`Apache2::Const::DECLINED\*(C'\fR, \f(CW\*(C`Apache2::HTTP_...\*(C'\fR.
.IP "since: 2.0.00" 4
.IX Item "since: 2.0.00"
.PP
This phase runs before a user is authenticated, so this hook is really
to apply additional restrictions independent of a user. It also runs
independent of '\f(CW\*(C`Require\*(C'\fR' directive usage.
.ie n .SS """run_auth_checker"""
.el .SS "\f(CWrun_auth_checker\fP"
.IX Subsection "run_auth_checker"
Run the
authentication
phase.
.PP
.Vb 1
\&  $rc = $r\->run_auth_checker();
.Ve
.ie n .IP "obj: $r ( ""Apache2::RequestRec object"" )" 4
.el .IP "obj: \f(CW$r\fR ( \f(CWApache2::RequestRec object\fR )" 4
.IX Item "obj: $r ( Apache2::RequestRec object )"
the current request
.ie n .IP "ret: $rc ( integer )" 4
.el .IP "ret: \f(CW$rc\fR ( integer )" 4
.IX Item "ret: $rc ( integer )"
The status of the current phase run: \f(CW\*(C`Apache2::Const::OK\*(C'\fR,
\&\f(CW\*(C`Apache2::Const::DECLINED\*(C'\fR, \f(CW\*(C`Apache2::HTTP_...\*(C'\fR.
.IP "since: 2.0.00" 4
.IX Item "since: 2.0.00"
.PP
This phase is used to check to see if the resource being requested is
available for the authenticated user (\f(CW\*(C`$r\->user\*(C'\fR and
\&\f(CW\*(C`$r\->ap_auth_type\*(C'\fR).
.PP
It runs after the access_checker and
check_user_id hooks.
.PP
Note that it will only be called if Apache determines that access
control has been applied to this resource (through a '\f(CW\*(C`Require\*(C'\fR'
directive).
.ie n .SS """run_check_user_id"""
.el .SS "\f(CWrun_check_user_id\fP"
.IX Subsection "run_check_user_id"
Run the
authorization
phase.
.PP
.Vb 1
\&  $rc = $r\->run_check_user_id();
.Ve
.ie n .IP "obj: $r ( ""Apache2::RequestRec object"" )" 4
.el .IP "obj: \f(CW$r\fR ( \f(CWApache2::RequestRec object\fR )" 4
.IX Item "obj: $r ( Apache2::RequestRec object )"
The current request
.ie n .IP "ret: $rc ( integer )" 4
.el .IP "ret: \f(CW$rc\fR ( integer )" 4
.IX Item "ret: $rc ( integer )"
The status of the current phase run: \f(CW\*(C`Apache2::Const::OK\*(C'\fR,
\&\f(CW\*(C`Apache2::Const::DECLINED\*(C'\fR, \f(CW\*(C`Apache2::HTTP_...\*(C'\fR.
.IP "since: 2.0.00" 4
.IX Item "since: 2.0.00"
.PP
This hook is used to analyze the request headers, authenticate the
user, and set the user information in the request record
(\f(CW\*(C`$r\->user\*(C'\fR and \f(CW\*(C`$r\->ap_auth_type\*(C'\fR).
.PP
This hook is only run when Apache determines that
authentication/authorization is required for this resource (as
determined by the '\f(CW\*(C`Require\*(C'\fR' directive).
.PP
It runs after the access_checker hook, and
before the auth_checker hook.
.ie n .SS """run_fixups"""
.el .SS "\f(CWrun_fixups\fP"
.IX Subsection "run_fixups"
Run the fixup
phase.
.PP
.Vb 1
\&  $rc = $r\->run_fixups();
.Ve
.ie n .IP "obj: $r ( ""Apache2::RequestRec object"" )" 4
.el .IP "obj: \f(CW$r\fR ( \f(CWApache2::RequestRec object\fR )" 4
.IX Item "obj: $r ( Apache2::RequestRec object )"
The current request
.ie n .IP "ret: $rc ( integer )" 4
.el .IP "ret: \f(CW$rc\fR ( integer )" 4
.IX Item "ret: $rc ( integer )"
The status of the current phase run: \f(CW\*(C`Apache2::Const::OK\*(C'\fR,
\&\f(CW\*(C`Apache2::Const::DECLINED\*(C'\fR, \f(CW\*(C`Apache2::HTTP_...\*(C'\fR.
.IP "since: 2.0.00" 4
.IX Item "since: 2.0.00"
.PP
This phase allows modules to perform module-specific fixing of \s-1HTTP\s0
header fields.  This is invoked just before the
response phase.
.ie n .SS """run_handler"""
.el .SS "\f(CWrun_handler\fP"
.IX Subsection "run_handler"
Run the
response phase.
.PP
.Vb 1
\&  $rc = $r\->run_handler();
.Ve
.ie n .IP "obj: $r ( ""Apache2::RequestRec object"" )" 4
.el .IP "obj: \f(CW$r\fR ( \f(CWApache2::RequestRec object\fR )" 4
.IX Item "obj: $r ( Apache2::RequestRec object )"
The request_rec
.ie n .IP "ret: $rc ( integer )" 4
.el .IP "ret: \f(CW$rc\fR ( integer )" 4
.IX Item "ret: $rc ( integer )"
The status of the current phase run: \f(CW\*(C`Apache2::Const::OK\*(C'\fR,
\&\f(CW\*(C`Apache2::Const::DECLINED\*(C'\fR, \f(CW\*(C`Apache2::HTTP_...\*(C'\fR.
.IP "since: 2.0.00" 4
.IX Item "since: 2.0.00"
.PP
\&\f(CW\*(C`run_handler()\*(C'\fR is called internally by
\&\f(CW\*(C`invoke_handler()\*(C'\fR. Use \f(CW\*(C`run_handler()\*(C'\fR only
if you want to bypass the extra functionality provided by
\&\f(CW\*(C`invoke_handler()\*(C'\fR.
.ie n .SS """run_header_parser"""
.el .SS "\f(CWrun_header_parser\fP"
.IX Subsection "run_header_parser"
Run the header
parser phase.
.PP
.Vb 1
\&  $rc = $r\->run_header_parser();
.Ve
.ie n .IP "obj: $r ( ""Apache2::RequestRec object"" )" 4
.el .IP "obj: \f(CW$r\fR ( \f(CWApache2::RequestRec object\fR )" 4
.IX Item "obj: $r ( Apache2::RequestRec object )"
The current request
.ie n .IP "ret: $rc ( integer )" 4
.el .IP "ret: \f(CW$rc\fR ( integer )" 4
.IX Item "ret: $rc ( integer )"
\&\f(CW\*(C`Apache2::Const::OK\*(C'\fR or \f(CW\*(C`Apache2::Const::DECLINED\*(C'\fR.
.IP "since: 2.0.00" 4
.IX Item "since: 2.0.00"
.ie n .SS """run_log_transaction"""
.el .SS "\f(CWrun_log_transaction\fP"
.IX Subsection "run_log_transaction"
Run the logging
phase.
.PP
.Vb 1
\&  $rc = $r\->run_log_transaction();
.Ve
.ie n .IP "obj: $r ( ""Apache2::RequestRec object"" )" 4
.el .IP "obj: \f(CW$r\fR ( \f(CWApache2::RequestRec object\fR )" 4
.IX Item "obj: $r ( Apache2::RequestRec object )"
The current request
.ie n .IP "ret: $rc ( integer )" 4
.el .IP "ret: \f(CW$rc\fR ( integer )" 4
.IX Item "ret: $rc ( integer )"
The status of the current phase run: \f(CW\*(C`Apache2::Const::OK\*(C'\fR,
\&\f(CW\*(C`Apache2::Const::DECLINED\*(C'\fR, \f(CW\*(C`Apache2::HTTP_...\*(C'\fR
.IP "since: 2.0.00" 4
.IX Item "since: 2.0.00"
.PP
This hook allows modules to perform any module-specific logging
activities over and above the normal server things.
.ie n .SS """run_map_to_storage"""
.el .SS "\f(CWrun_map_to_storage\fP"
.IX Subsection "run_map_to_storage"
Run the
map_to_storage
phase.
.PP
.Vb 1
\&  $rc = $r\->run_map_to_storage();
.Ve
.ie n .IP "obj: $r ( ""Apache2::RequestRec object"" )" 4
.el .IP "obj: \f(CW$r\fR ( \f(CWApache2::RequestRec object\fR )" 4
.IX Item "obj: $r ( Apache2::RequestRec object )"
The current request
.ie n .IP "ret: $rc ( integer )" 4
.el .IP "ret: \f(CW$rc\fR ( integer )" 4
.IX Item "ret: $rc ( integer )"
\&\f(CW\*(C`Apache2::Const::DONE\*(C'\fR (or \f(CW\*(C`Apache2::HTTP_*\*(C'\fR) if this contextless request was
just fulfilled (such as \f(CW\*(C`TRACE\*(C'\fR), \f(CW\*(C`Apache2::Const::OK\*(C'\fR if this is not a
file, and \f(CW\*(C`Apache2::Const::DECLINED\*(C'\fR if this is a file.  The core
map_to_storage (\f(CW\*(C`Apache2::HOOK_RUN_LAST\*(C'\fR) will \f(CW\*(C`directory_walk()\*(C'\fR and
\&\f(CW\*(C`file_walk()\*(C'\fR the \f(CW\*(C`$r\->filename\*(C'\fR (all internal C functions).
.IP "since: 2.0.00" 4
.IX Item "since: 2.0.00"
.PP
This phase allows modules to set the per_dir_config based on their own
context (such as \f(CW\*(C`<Proxy>\*(C'\fR sections) and responds to
contextless requests such as \f(CW\*(C`TRACE\*(C'\fR that need no security or
filesystem mapping based on the filesystem.
.ie n .SS """run_post_read_request"""
.el .SS "\f(CWrun_post_read_request\fP"
.IX Subsection "run_post_read_request"
Run the
post_read_request
phase.
.PP
.Vb 1
\&  $rc = $r\->run_post_read_request();
.Ve
.ie n .IP "obj: $r ( ""Apache2::RequestRec object"" )" 4
.el .IP "obj: \f(CW$r\fR ( \f(CWApache2::RequestRec object\fR )" 4
.IX Item "obj: $r ( Apache2::RequestRec object )"
The current request
.ie n .IP "ret: $rc ( integer )" 4
.el .IP "ret: \f(CW$rc\fR ( integer )" 4
.IX Item "ret: $rc ( integer )"
The status of the current phase run: \f(CW\*(C`Apache2::Const::OK\*(C'\fR or
\&\f(CW\*(C`Apache2::Const::DECLINED\*(C'\fR.
.IP "since: 2.0.00" 4
.IX Item "since: 2.0.00"
.PP
This phase is run right after \f(CW\*(C`read_request()\*(C'\fR or
\&\f(CW\*(C`internal_redirect()\*(C'\fR, and not run during any subrequests.  This hook
allows modules to affect the request immediately after the request has
been read, and before any other phases have been processes.  This
allows modules to make decisions based upon the input header fields
.ie n .SS """run_translate_name"""
.el .SS "\f(CWrun_translate_name\fP"
.IX Subsection "run_translate_name"
Run the translate
phase.
.PP
.Vb 1
\&  $rc = $r\->run_translate_name();
.Ve
.ie n .IP "obj: $r ( ""Apache2::RequestRec object"" )" 4
.el .IP "obj: \f(CW$r\fR ( \f(CWApache2::RequestRec object\fR )" 4
.IX Item "obj: $r ( Apache2::RequestRec object )"
The current request
.ie n .IP "ret: $rc ( integer )" 4
.el .IP "ret: \f(CW$rc\fR ( integer )" 4
.IX Item "ret: $rc ( integer )"
The status of the current phase run: \f(CW\*(C`Apache2::Const::OK\*(C'\fR,
\&\f(CW\*(C`Apache2::Const::DECLINED\*(C'\fR, \f(CW\*(C`Apache2::HTTP_...\*(C'\fR.
.IP "since: 2.0.00" 4
.IX Item "since: 2.0.00"
.PP
This phase gives modules an opportunity to translate the \s-1URI\s0 into an
actual filename.  If no modules do anything special, the server's
default rules will be applied.
.ie n .SS """run_type_checker"""
.el .SS "\f(CWrun_type_checker\fP"
.IX Subsection "run_type_checker"
Run the
type_checker phase.
.PP
.Vb 1
\&  $rc = $r\->run_type_checker();
.Ve
.ie n .IP "obj: $r ( ""Apache2::RequestRec object"" )" 4
.el .IP "obj: \f(CW$r\fR ( \f(CWApache2::RequestRec object\fR )" 4
.IX Item "obj: $r ( Apache2::RequestRec object )"
the current request
.ie n .IP "ret: $rc ( integer )" 4
.el .IP "ret: \f(CW$rc\fR ( integer )" 4
.IX Item "ret: $rc ( integer )"
The status of the current phase run: \f(CW\*(C`Apache2::Const::OK\*(C'\fR,
\&\f(CW\*(C`Apache2::Const::DECLINED\*(C'\fR, \f(CW\*(C`Apache2::HTTP_...\*(C'\fR.
.IP "since: 2.0.00" 4
.IX Item "since: 2.0.00"
.PP
This phase is used to determine and/or set the various document type
information bits, like \f(CW\*(C`Content\-type\*(C'\fR (via \f(CW\*(C`$r\->content_type\*(C'\fR),
language, etc.
.SH "See Also"
.IX Header "See Also"
mod_perl 2.0 documentation.
.SH "Copyright"
.IX Header "Copyright"
mod_perl 2.0 and its core modules are copyrighted under
The Apache Software License, Version 2.0.
.SH "Authors"
.IX Header "Authors"
The mod_perl development team and numerous
contributors.
