.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Moose::Manual::MooseX 3"
.TH Moose::Manual::MooseX 3 "2014-01-19" "perl v5.18.4" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Moose::Manual::MooseX \- Recommended Moose extensions
.SH "VERSION"
.IX Header "VERSION"
version 2.1202
.SH "MooseX?"
.IX Header "MooseX?"
It's easy to extend and change Moose, and this is part of what makes
Moose so powerful. You can use the \s-1MOP API\s0 to do things your own way,
add new features, and generally customize your Moose.
.PP
Writing your own extensions does require a good understanding of the
meta-model. You can start learning about this with the
Moose::Manual::MOP docs. There are also several extension recipes
in the Moose::Cookbook.
.PP
Explaining how to write extensions is beyond the scope of this
manual. Fortunately, lots of people have already written extensions
and put them on \s-1CPAN\s0 for you.
.PP
This document covers a few of the ones we like best.
.SH "MooseX::AttributeHelpers"
.IX Header "MooseX::AttributeHelpers"
The functionality of this MooseX module has been moved into Moose core.
See Moose::Meta::Attribute::Native.
.SH "Moose::Autobox"
.IX Header "Moose::Autobox"
MooseX::AttributeHelpers, but turned inside out, Moose::Autobox provides
methods on both arrays/hashes/etc. but also references to them, using
Moose roles, allowing you do to things like:
.PP
.Vb 1
\&  use Moose::Autobox;
\&
\&  $somebody_elses_object\->orders\->push($order);
.Ve
.PP
Lexically scoped and not to everybody's taste, but very handy for sugaring
up other people's APIs and your own code.
.SH "MooseX::StrictConstructor"
.IX Header "MooseX::StrictConstructor"
By default, Moose lets you pass any old junk into a class's
constructor. If you load MooseX::StrictConstructor, your class will
throw an error if it sees something it doesn't recognize;
.PP
.Vb 1
\&  package User;
\&
\&  use Moose;
\&  use MooseX::StrictConstructor;
\&
\&  has \*(Aqname\*(Aq;
\&  has \*(Aqemail\*(Aq;
\&
\&  User\->new( name => \*(AqBob\*(Aq, emali => \*(Aqbob@example.com\*(Aq );
.Ve
.PP
With MooseX::StrictConstructor, that typo (\*(L"emali\*(R") will cause a
runtime error. With plain old Moose, the \*(L"emali\*(R" attribute would be
silently ignored.
.SH "MooseX::Params::Validate"
.IX Header "MooseX::Params::Validate"
We have high hopes for the future of MooseX::Method::Signatures and
MooseX::Declare. However, these modules, while used regularly in
production by some of the more insane members of the community, are
still marked alpha just in case backwards incompatible changes need to
be made.
.PP
If you don't want to risk that, for now we recommend the decidedly more
clunky (but also faster and simpler) MooseX::Params::Validate. This
module lets you apply Moose types and coercions to any method
arguments.
.PP
.Vb 1
\&  package User;
\&
\&  use Moose;
\&  use MooseX::Params::Validate;
\&
\&  sub login {
\&      my $self = shift;
\&      my ($password)
\&          = validated_list( \e@_, password => { isa => \*(AqStr\*(Aq, required => 1 } );
\&
\&      ...
\&  }
.Ve
.SH "MooseX::Getopt"
.IX Header "MooseX::Getopt"
This is a role which adds a \f(CW\*(C`new_with_options\*(C'\fR method to your
class. This is a constructor that takes the command line options and
uses them to populate attributes.
.PP
This makes writing a command-line application as a module trivially
simple:
.PP
.Vb 1
\&  package App::Foo;
\&
\&  use Moose;
\&  with \*(AqMooseX::Getopt\*(Aq;
\&
\&  has \*(Aqinput\*(Aq => (
\&      is       => \*(Aqro\*(Aq,
\&      isa      => \*(AqStr\*(Aq,
\&      required => 1
\&  );
\&
\&  has \*(Aqoutput\*(Aq => (
\&      is       => \*(Aqro\*(Aq,
\&      isa      => \*(AqStr\*(Aq,
\&      required => 1
\&  );
\&
\&  sub run { ... }
.Ve
.PP
Then in the script that gets run we have:
.PP
.Vb 1
\&  use App::Foo;
\&
\&  App::Foo\->new_with_options\->run;
.Ve
.PP
From the command line, someone can execute the script:
.PP
.Vb 1
\&  foo@example> foo \-\-input /path/to/input \-\-output /path/to/output
.Ve
.SH "MooseX::Singleton"
.IX Header "MooseX::Singleton"
To be honest, using a singleton is just a way to have a magic global
variable in languages that don't actually have global variables.
.PP
In perl, you can just as easily use a global. However, if your
colleagues are Java-infected, they might prefer a singleton. Also, if
you have an existing class that \fIisn't\fR a singleton but should be,
using MooseX::Singleton is the easiest way to convert it.
.PP
.Vb 1
\&  package Config;
\&
\&  use MooseX::Singleton; # instead of Moose
\&
\&  has \*(Aqcache_dir\*(Aq => ( ... );
.Ve
.PP
It's that simple.
.SH "EXTENSIONS TO CONSIDER"
.IX Header "EXTENSIONS TO CONSIDER"
There are literally dozens of other extensions on \s-1CPAN.\s0 This is a list
of extensions that you might find useful, but we're not quite ready to
endorse just yet.
.SS "MooseX::Declare"
.IX Subsection "MooseX::Declare"
Extends Perl with Moose-based keywords using \f(CW\*(C`Devel::Declare\*(C'\fR. Very
cool, but still new and experimental.
.PP
.Vb 1
\&  class User {
\&
\&      has \*(Aqname\*(Aq  => ( ... );
\&      has \*(Aqemail\*(Aq => ( ... );
\&
\&      method login (Str $password) { ... }
\&  }
.Ve
.SS "MooseX::Types"
.IX Subsection "MooseX::Types"
This extension helps you build a type library for your application. It
also lets you predeclare type names and use them as barewords.
.PP
.Vb 2
\&  use MooseX::Types \-declare => [\*(AqPositiveInt\*(Aq];
\&  use MooseX::Types::Moose \*(AqInt\*(Aq;
\&
\&  subtype PositiveInt,
\&      as Int,
\&      where { $_ > 0 },
\&      message { "Int is not larger than 0" };
.Ve
.PP
One nice feature is that those bareword names are actually namespaced
in Moose's type registry, so multiple applications can use the same
bareword names, even if the type definitions differ.
.SS "MooseX::Types::Structured"
.IX Subsection "MooseX::Types::Structured"
This extension builds on top of MooseX::Types to let you declare
complex data structure types.
.PP
.Vb 3
\&  use MooseX::Types \-declare => [ qw( Name Color ) ];
\&  use MooseX::Types::Moose qw(Str Int);
\&  use MooseX::Types::Structured qw(Dict Tuple Optional);
\&
\&  subtype Name
\&      => as Dict[ first => Str, middle => Optional[Str], last => Str ];
\&
\&  subtype Color
\&      => as Tuple[ Int, Int, Int, Optional[Int] ];
.Ve
.PP
Of course, you could always use objects to represent these sorts of
things too.
.SS "MooseX::ClassAttribute"
.IX Subsection "MooseX::ClassAttribute"
This extension provides class attributes for Moose classes. The
declared class attributes are introspectable just like regular Moose
attributes.
.PP
.Vb 1
\&  package User;
\&
\&  use Moose;
\&  use MooseX::ClassAttribute;
\&
\&  has \*(Aqname\*(Aq => ( ... );
\&
\&  class_has \*(AqCache\*(Aq => ( ... );
.Ve
.PP
Note however that this class attribute does \fInot\fR inherit like a
Class::Data::Inheritable or similar attribute \- calling
.PP
.Vb 1
\&  $subclass\->Cache($cache);
.Ve
.PP
will set it for the superclass as well. Additionally, class data is usually
The Wrong Thing To Do in a strongly \s-1OO\s0 program since it makes testing a
lot harder \- consider carefully whether you'd be better off with an object
that's passed around instead.
.SS "MooseX::Daemonize"
.IX Subsection "MooseX::Daemonize"
This is a role that provides a number of methods useful for creating a
daemon, including methods for starting and stopping, managing a \s-1PID\s0
file, and signal handling.
.SS "MooseX::Role::Parameterized"
.IX Subsection "MooseX::Role::Parameterized"
If you find yourself wanting a role that customizes itself for each
consumer, this is the tool for you. With this module, you can create a
role that accepts parameters and generates attributes, methods, etc. on
a customized basis for each consumer.
.SS "MooseX::POE"
.IX Subsection "MooseX::POE"
This is a small wrapper that ties together a Moose class with
\&\f(CW\*(C`POE::Session\*(C'\fR, and gives you an \f(CW\*(C`event\*(C'\fR sugar function to declare
event handlers.
.SS "MooseX::FollowPBP"
.IX Subsection "MooseX::FollowPBP"
Automatically names all accessors \fIPerl Best Practices\fR\-style,
\&\*(L"get_size\*(R" and \*(L"set_size\*(R".
.SS "MooseX::SemiAffordanceAccessor"
.IX Subsection "MooseX::SemiAffordanceAccessor"
Automatically names all accessors with an explicit set and implicit
get, \*(L"size\*(R" and \*(L"set_size\*(R".
.SS "MooseX::NonMoose"
.IX Subsection "MooseX::NonMoose"
MooseX::NonMoose allows for easily subclassing non-Moose classes with Moose,
taking care of the annoying details connected with doing this, such as
setting up proper inheritance from Moose::Object and installing
(and inlining, at make_immutable time) a constructor that makes sure things
like \s-1BUILD\s0 methods are called.
.SH "AUTHORS"
.IX Header "AUTHORS"
.IP "\(bu" 4
Stevan Little <stevan.little@iinteractive.com>
.IP "\(bu" 4
Dave Rolsky <autarch@urth.org>
.IP "\(bu" 4
Jesse Luehrs <doy@tozt.net>
.IP "\(bu" 4
Shawn M Moore <code@sartak.org>
.IP "\(bu" 4
\&\s-1XXXX XXX\s0'\s-1XX \s0(Yuval Kogman) <nothingmuch@woobling.org>
.IP "\(bu" 4
Karen Etheridge <ether@cpan.org>
.IP "\(bu" 4
Florian Ragwitz <rafl@debian.org>
.IP "\(bu" 4
Hans Dieter Pearcey <hdp@weftsoar.net>
.IP "\(bu" 4
Chris Prather <chris@prather.org>
.IP "\(bu" 4
Matt S Trout <mst@shadowcat.co.uk>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is copyright (c) 2006 by Infinity Interactive, Inc..
.PP
This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.
