.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "CPANPLUS::Dist::Base 3pm"
.TH CPANPLUS::Dist::Base 3pm "2014-09-30" "perl v5.18.4" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
CPANPLUS::Dist::Base \- Base class for custom distribution classes
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    package CPANPLUS::Dist::MY_IMPLEMENTATION
\&
\&    use base \*(AqCPANPLUS::Dist::Base\*(Aq;
\&
\&    sub prepare {
\&        my $dist = shift;
\&
\&        ### do the \*(Aqstandard\*(Aq things
\&        $dist\->SUPER::prepare( @_ ) or return;
\&
\&        ### do MY_IMPLEMENTATION specific things
\&        ...
\&
\&        ### don\*(Aqt forget to set the status!
\&        return $dist\->status\->prepared( $SUCCESS ? 1 : 0 );
\&    }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
CPANPLUS::Dist::Base functions as a base class for all custom
distribution implementations. It does all the mundane work
\&\s-1CPANPLUS\s0 would have done without a custom distribution, so you
can override just the parts you need to make your own implementation
work.
.SH "FLOW"
.IX Header "FLOW"
Below is a brief outline when and in which order methods in this
class are called:
.PP
.Vb 1
\&    $Class\->format_available;   # can we use this class on this system?
\&
\&    $dist\->init;                # set up custom accessors, etc
\&    $dist\->prepare;             # find/write meta information
\&    $dist\->create;              # write the distribution file
\&    $dist\->install;             # install the distribution file
\&
\&    $dist\->uninstall;           # remove the distribution (OPTIONAL)
.Ve
.SH "METHODS"
.IX Header "METHODS"
.ie n .SS "@subs = $Class\->methods"
.el .SS "\f(CW@subs\fP = \f(CW$Class\fP\->methods"
.IX Subsection "@subs = $Class->methods"
Returns a list of methods that this class implements that you can
override.
.ie n .SS "$bool = $Class\->format_available"
.el .SS "\f(CW$bool\fP = \f(CW$Class\fP\->format_available"
.IX Subsection "$bool = $Class->format_available"
This method is called when someone requests a module to be installed
via the superclass. This gives you the opportunity to check if all
the needed requirements to build and install this distribution have
been met.
.PP
For example, you might need a command line program, or a certain perl
module installed to do your job. Now is the time to check.
.PP
Simply return true if the request can proceed and false if it can not.
.PP
The \f(CW\*(C`CPANPLUS::Dist::Base\*(C'\fR implementation always returns true.
.ie n .SS "$bool = $dist\->init"
.el .SS "\f(CW$bool\fP = \f(CW$dist\fP\->init"
.IX Subsection "$bool = $dist->init"
This method is called just after the new dist object is set up and
before the \f(CW\*(C`prepare\*(C'\fR method is called. This is the time to set up
the object so it can be used with your class.
.PP
For example, you might want to add extra accessors to the \f(CW\*(C`status\*(C'\fR
object, which you might do as follows:
.PP
.Vb 1
\&    $dist\->status\->mk_accessors( qw[my_implementation_accessor] );
.Ve
.PP
The \f(CW\*(C`status\*(C'\fR object is implemented as an instance of the
\&\f(CW\*(C`Object::Accessor\*(C'\fR class. Please refer to its documentation for
details.
.PP
Return true if the initialization was successful, and false if it was
not.
.PP
The \f(CW\*(C`CPANPLUS::Dist::Base\*(C'\fR implementation does not alter your object
and always returns true.
.ie n .SS "$bool = $dist\->prepare"
.el .SS "\f(CW$bool\fP = \f(CW$dist\fP\->prepare"
.IX Subsection "$bool = $dist->prepare"
This runs the preparation step of your distribution. This step is meant
to set up the environment so the \f(CW\*(C`create\*(C'\fR step can create the actual
distribution(file).
A \f(CW\*(C`prepare\*(C'\fR call in the standard \f(CW\*(C`ExtUtils::MakeMaker\*(C'\fR distribution
would, for example, run \f(CW\*(C`perl Makefile.PL\*(C'\fR to find the dependencies
for a distribution. For a \f(CW\*(C`debian\*(C'\fR distribution, this is where you
would write all the metafiles required for the \f(CW\*(C`dpkg\-*\*(C'\fR tools.
.PP
The \f(CW\*(C`CPANPLUS::Dist::Base\*(C'\fR implementation simply calls the underlying
distribution class (Typically \f(CW\*(C`CPANPLUS::Dist::MM\*(C'\fR or
\&\f(CW\*(C`CPANPLUS::Dist::Build\*(C'\fR).
.PP
Sets \f(CW\*(C`$dist\->status\->prepared\*(C'\fR to the return value of this function.
If you override this method, you should make sure to set this value.
.ie n .SS "$bool = $dist\->create"
.el .SS "\f(CW$bool\fP = \f(CW$dist\fP\->create"
.IX Subsection "$bool = $dist->create"
This runs the creation step of your distribution. This step is meant
to follow up on the \f(CW\*(C`prepare\*(C'\fR call, that set up your environment so
the \f(CW\*(C`create\*(C'\fR step can create the actual distribution(file).
A \f(CW\*(C`create\*(C'\fR call in the standard \f(CW\*(C`ExtUtils::MakeMaker\*(C'\fR distribution
would, for example, run \f(CW\*(C`make\*(C'\fR and \f(CW\*(C`make test\*(C'\fR to build and test
a distribution. For a \f(CW\*(C`debian\*(C'\fR distribution, this is where you
would create the actual \f(CW\*(C`.deb\*(C'\fR file using \f(CW\*(C`dpkg\*(C'\fR.
.PP
The \f(CW\*(C`CPANPLUS::Dist::Base\*(C'\fR implementation simply calls the underlying
distribution class (Typically \f(CW\*(C`CPANPLUS::Dist::MM\*(C'\fR or
\&\f(CW\*(C`CPANPLUS::Dist::Build\*(C'\fR).
.PP
Sets \f(CW\*(C`$dist\->status\->dist\*(C'\fR to the location of the created
distribution.
If you override this method, you should make sure to set this value.
.PP
Sets \f(CW\*(C`$dist\->status\->created\*(C'\fR to the return value of this function.
If you override this method, you should make sure to set this value.
.ie n .SS "$bool = $dist\->install"
.el .SS "\f(CW$bool\fP = \f(CW$dist\fP\->install"
.IX Subsection "$bool = $dist->install"
This runs the install step of your distribution. This step is meant
to follow up on the \f(CW\*(C`create\*(C'\fR call, which prepared a distribution(file)
to install.
A \f(CW\*(C`create\*(C'\fR call in the standard \f(CW\*(C`ExtUtils::MakeMaker\*(C'\fR distribution
would, for example, run \f(CW\*(C`make install\*(C'\fR to copy the distribution files
to their final destination. For a \f(CW\*(C`debian\*(C'\fR distribution, this is where
you would run \f(CW\*(C`dpkg \-\-install\*(C'\fR on the created \f(CW\*(C`.deb\*(C'\fR file.
.PP
The \f(CW\*(C`CPANPLUS::Dist::Base\*(C'\fR implementation simply calls the underlying
distribution class (Typically \f(CW\*(C`CPANPLUS::Dist::MM\*(C'\fR or
\&\f(CW\*(C`CPANPLUS::Dist::Build\*(C'\fR).
.PP
Sets \f(CW\*(C`$dist\->status\->installed\*(C'\fR to the return value of this function.
If you override this method, you should make sure to set this value.
.ie n .SS "$bool = $dist\->uninstall"
.el .SS "\f(CW$bool\fP = \f(CW$dist\fP\->uninstall"
.IX Subsection "$bool = $dist->uninstall"
This runs the uninstall step of your distribution. This step is meant
to remove the distribution from the file system.
A \f(CW\*(C`uninstall\*(C'\fR call in the standard \f(CW\*(C`ExtUtils::MakeMaker\*(C'\fR distribution
would, for example, run \f(CW\*(C`make uninstall\*(C'\fR to remove the distribution
files the file system. For a \f(CW\*(C`debian\*(C'\fR distribution, this is where you
would run \f(CW\*(C`dpkg \-\-uninstall PACKAGE\*(C'\fR.
.PP
The \f(CW\*(C`CPANPLUS::Dist::Base\*(C'\fR implementation simply calls the underlying
distribution class (Typically \f(CW\*(C`CPANPLUS::Dist::MM\*(C'\fR or
\&\f(CW\*(C`CPANPLUS::Dist::Build\*(C'\fR).
.PP
Sets \f(CW\*(C`$dist\->status\->uninstalled\*(C'\fR to the return value of this function.
If you override this method, you should make sure to set this value.
