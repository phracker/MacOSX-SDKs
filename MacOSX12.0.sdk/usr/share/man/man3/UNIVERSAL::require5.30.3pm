.\" Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "UNIVERSAL::require 3"
.TH UNIVERSAL::require 3 "2015-02-24" "perl v5.30.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
UNIVERSAL::require \- require() modules from a variable
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&  # This only needs to be said once in your program.
\&  require UNIVERSAL::require;
\&
\&  # Same as "require Some::Module"
\&  my $module = \*(AqSome::Module\*(Aq;
\&  $module\->require or die $@;
\&
\&  # Same as "use Some::Module"
\&  BEGIN { $module\->use or die $@ }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
If you've ever had to do this...
.PP
.Vb 1
\&    eval "require $module";
.Ve
.PP
to get around the bareword caveats on \fBrequire()\fR, this module is for
you.  It creates a universal \fBrequire()\fR class method that will work
with every Perl module and its secure.  So instead of doing some
arcane \fBeval()\fR work, you can do this:
.PP
.Vb 1
\&    $module\->require;
.Ve
.PP
It doesn't save you much typing, but it'll make a lot more sense to
someone who's not a ninth level Perl acolyte.
.SH "Methods"
.IX Header "Methods"
\fIrequire\fR
.IX Subsection "require"
.PP
.Vb 2
\&  my $return_val = $module\->require           or die $@;
\&  my $return_val = $module\->require($version) or die $@;
.Ve
.PP
This works exactly like Perl's require, except without the bareword
restriction, and it doesn't die.  Since \fBrequire()\fR is placed in the
\&\s-1UNIVERSAL\s0 namespace, it will work on \fBany\fR module.  You just have to
use UNIVERSAL::require somewhere in your code.
.PP
Should the module require fail, or not be a high enough \f(CW$version\fR, it
will simply return false and \fBnot die\fR.  The error will be in
$@ as well as \f(CW$UNIVERSAL::require::ERROR\fR.
.PP
.Vb 1
\&    $module\->require or die $@;
.Ve
.PP
\fIuse\fR
.IX Subsection "use"
.PP
.Vb 2
\&    my $require_return = $module\->use           or die $@;
\&    my $require_return = $module\->use(@imports) or die $@;
.Ve
.PP
Like \f(CW\*(C`UNIVERSAL::require\*(C'\fR, this allows you to \f(CW\*(C`use\*(C'\fR a \f(CW$module\fR without
having to eval to work around the bareword requirement.  It returns the
same as require.
.PP
Should either the require or the import fail it will return false.  The
error will be in $@.
.PP
If possible, call this inside a \s-1BEGIN\s0 block to emulate a normal \f(CW\*(C`use\*(C'\fR
as closely as possible.
.PP
.Vb 1
\&    BEGIN { $module\->use }
.Ve
.SH "SECURITY NOTES"
.IX Header "SECURITY NOTES"
UNIVERSAL::require makes use of \f(CW\*(C`eval STRING\*(C'\fR.  In previous versions
of UNIVERSAL::require it was discovered that one could craft a class
name which would result in code being executed.  This hole has been
closed.  The only variables now exposed to \f(CW\*(C`eval STRING\*(C'\fR are the
caller's package, filename and line which are not tainted.
.PP
UNIVERSAL::require is taint clean.
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright 2001, 2005 by Michael G Schwern <schwern@pobox.com>.
.PP
This program is free software; you can redistribute it and/or 
modify it under the same terms as Perl itself.
.PP
See \fIhttp://www.perl.com/perl/misc/Artistic.html\fR
.SH "AUTHOR"
.IX Header "AUTHOR"
Michael G Schwern <schwern@pobox.com>
.PP
Now maintained by Neil Bowers (\s-1NEILB\s0).
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Module::Load,  \*(L"require\*(R" in perlfunc, <http://dev.perl.org/rfc/253.pod>
