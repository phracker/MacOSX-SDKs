.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Moose::Manual::Delta 3"
.TH Moose::Manual::Delta 3 "2014-01-19" "perl v5.18.4" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Moose::Manual::Delta \- Important Changes in Moose
.SH "VERSION"
.IX Header "VERSION"
version 2.1202
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This documents any important or noteworthy changes in Moose, with a
focus on things that affect backwards compatibility. This does duplicate data
from the \fIChanges\fR file, but aims to provide more details and when possible
workarounds.
.PP
Besides helping keep up with changes, you can also use this document
for finding the lowest version of Moose that supported a given
feature.  If you encounter a problem and have a solution but don't see
it documented here, or think we missed an important feature, please
send us a patch.
.SH "2.1200"
.IX Header "2.1200"
.ie n .IP "Classes created by Moose are now registered in %INC" 4
.el .IP "Classes created by Moose are now registered in \f(CW%INC\fR" 4
.IX Item "Classes created by Moose are now registered in %INC"
This means that this will no longer die (and will also no longer try to load
\&\f(CW\*(C`Foo.pm\*(C'\fR):
.Sp
.Vb 4
\&  {
\&      package Foo;
\&      use Moose;
\&  }
\&
\&  # ...
\&
\&  use Foo;
.Ve
.Sp
If you're using the \s-1MOP,\s0 this behavior will occur when the \f(CW\*(C`create\*(C'\fR (or
\&\f(CW\*(C`create_anon_class\*(C'\fR) method is used, but not when the \f(CW\*(C`initialize\*(C'\fR method
is used.
.IP "Moose now uses Module::Runtime instead of Class::Load to load classes" 4
.IX Item "Moose now uses Module::Runtime instead of Class::Load to load classes"
Class::Load has always had some weird issues with the ways that it tries to
figure out if a class is loaded. For instance, extending an empty package was
previously impossible, because Class::Load would think that the class failed to
load, even though that is a perfectly valid thing to do. It was also difficult
to deal with modules like IO::Handle, which partially populate several other
packages when they are loaded (so calling \f(CW\*(C`load_class\*(C'\fR on \f(CW\*(AqIO::Handle\*(Aq\fR
followed by \f(CW\*(AqIO::File\*(Aq\fR could end up with a broken \f(CW\*(C`IO::File\*(C'\fR, in some
cases).
.Sp
Now, Moose uses the same mechanisms as perl itself to figure out if a class is
loaded. A class is considered to be loaded if its entry in \f(CW%INC\fR is set. Perl
sets the \f(CW%INC\fR entry for you automatically whenever a file is loaded via
\&\f(CW\*(C`use\*(C'\fR or \f(CW\*(C`require\*(C'\fR. Also, as mentioned above, Moose also now sets the \f(CW%INC\fR
entry for any classes defined with it, even if they aren't loaded from a
separate file. This does however mean that if you are trying to use Moose with
non-Moose classes defined in the same file, then you will need to set \f(CW%INC\fR
manually now, where it may have worked in the past. For instance:
.Sp
.Vb 2
\&  {
\&      package My::NonMoose;
\&
\&      sub new { bless {}, shift }
\&
\&      $INC{\*(AqMy/NonMoose.pm\*(Aq} = _\|_FILE_\|_;
\&      # alternatively:
\&      # use Module::Runtime \*(Aqmodule_notional_filename\*(Aq;
\&      # $INC{module_notional_filename(_\|_PACKAGE_\|_)} = _\|_FILE_\|_;
\&  }
\&
\&  {
\&      package My::Moose;
\&      use Moose;
\&
\&      extends \*(AqMy::NonMoose\*(Aq;
\&  }
.Ve
.Sp
If you don't do this, you will get an error message about not being able to
locate \f(CW\*(C`My::NonMoose\*(C'\fR in \f(CW@INC\fR. We hope that this case will be fairly rare.
.IP "The Class::Load wrapper functions in Class::MOP have been deprecated" 4
.IX Item "The Class::Load wrapper functions in Class::MOP have been deprecated"
\&\f(CW\*(C`Class::MOP::load_class\*(C'\fR, \f(CW\*(C`Class::MOP::is_class_loaded\*(C'\fR, and
\&\f(CW\*(C`Class::MOP::load_first_existing_class\*(C'\fR have been deprecated. They have been
undocumented and discouraged since version 2.0200. You should replace their use
with the corresponding functions in Class::Load, or just use
Module::Runtime directly.
.ie n .IP "The non-arrayref forms of ""enum"" and ""duck_type"" have been deprecated" 4
.el .IP "The non-arrayref forms of \f(CWenum\fR and \f(CWduck_type\fR have been deprecated" 4
.IX Item "The non-arrayref forms of enum and duck_type have been deprecated"
Originally, \f(CW\*(C`enum\*(C'\fR could be called like this:
.Sp
.Vb 1
\&  enum(\*(AqMyType\*(Aq => qw(foo bar baz))
.Ve
.Sp
This was confusing, however (since it was different from the syntax for
anonymous enum types), and it makes error checking more difficult (since you
can't tell just by looking whether \f(CW\*(C`enum(\*(AqFoo\*(Aq, \*(AqBar\*(Aq, \*(AqBaz\*(Aq)\*(C'\fR was intended to
be a type named \f(CW\*(C`Foo\*(C'\fR with elements of \f(CW\*(C`Bar\*(C'\fR and \f(CW\*(C`Baz\*(C'\fR, or if this was
actually a mistake where someone got the syntax for an anonymous enum type
wrong). This all also applies to \f(CW\*(C`duck_type\*(C'\fR.
.Sp
Calling \f(CW\*(C`enum\*(C'\fR and \f(CW\*(C`duck_type\*(C'\fR with a list of arguments as described above
has been undocumented since version 0.93, and is now deprecated. You should
replace
.Sp
.Vb 1
\&  enum MyType => qw(foo bar baz);
.Ve
.Sp
in your code with
.Sp
.Vb 1
\&  enum MyType => [qw(foo bar baz)];
.Ve
.IP "Moose string exceptions have been replaced by Moose exception objects" 4
.IX Item "Moose string exceptions have been replaced by Moose exception objects"
Previously, Moose threw string exceptions on error conditions, which were not
so verbose. All those string exceptions have now been converted to exception
objects, which provide very detailed information about the exceptions. These
exception objects provide a string overload that matches the previous exception
message, so in most cases you should not have to change your code.
.Sp
For learning about the usage of Moose exception objects, read
Moose::Manual::Exceptions. Individual exceptions are documented in
Moose::Manual::Exceptions::Manifest.
.Sp
This work was funded as part of the \s-1GNOME\s0 Outreach Program for Women.
.SH "2.1000"
.IX Header "2.1000"
.IP "The Num type is now stricter" 4
.IX Item "The Num type is now stricter"
The \f(CW\*(C`Num\*(C'\fR type used to accept anything that fits Perl's notion of a number,
which included Inf, NaN, and strings like \f(CW" 1234 \en"\fR.  We believe that the
type constraint should indicate \*(L"this is a number\*(R", not \*(L"this coerces to a
number\*(R".  Therefore, now Num accepts only integers, floating point numbers
(both in decimal notation and exponential notation), 0, .0, 0.0 etc.
.Sp
If you want the old behavior you can use the \f(CW\*(C`LaxNum\*(C'\fR type in
MooseX::Types::LaxNum.
.IP "You can use Specio instead of core Moose types" 4
.IX Item "You can use Specio instead of core Moose types"
The Specio distribution is an experimental new type system intended to
eventually replace the core Moose types, but yet also work with things like
Moo and Mouse and anything else. Right now this is all speculative, but
at least you can use Specio with Moose.
.SH "2.0600"
.IX Header "2.0600"
.ie n .IP """\->init_meta"" is even less reliable at loading extensions" 4
.el .IP "\f(CW\->init_meta\fR is even less reliable at loading extensions" 4
.IX Item "->init_meta is even less reliable at loading extensions"
Previously, calling \f(CW\*(C`MooseX::Foo\->init_meta(@_)\*(C'\fR (and nothing else) from
within your own \f(CW\*(C`init_meta\*(C'\fR had a decent chance of doing something useful.
This was never supported behavior, and didn't always work anyway. Due to some
implementation adjustments, this now has a smaller chance of doing something
useful, which could break code that was expecting it to continue doing useful
things. Code that does this should instead just call
\&\f(CW\*(C`MooseX::Foo\->import({ into => $into })\*(C'\fR.
.IP "All the Cookbook recipes have been renamed" 4
.IX Item "All the Cookbook recipes have been renamed"
We've given them all descriptive names, rather than numbers. This makes it
easier to talk about them, and eliminates the need to renumber recipes in
order to reorder them or delete one.
.SH "2.0400"
.IX Header "2.0400"
.IP "The parent of a union type is its components' nearest common ancestor" 4
.IX Item "The parent of a union type is its components' nearest common ancestor"
Previously, union types considered all of their component types their parent
types. This was incorrect because parent types are defined as types that must
be satisfied in order for the child type to be satisfied, but in a union,
validating as any parent type will validate against the entire union. This has
been changed to find the nearest common ancestor for all of its components. For
example, a union of \*(L"Int|ArrayRef[Int]\*(R" now has a parent of \*(L"Defined\*(R".
.ie n .IP "Union types consider all members in the ""is_subtype_of"" and ""is_a_type_of"" methods" 4
.el .IP "Union types consider all members in the \f(CWis_subtype_of\fR and \f(CWis_a_type_of\fR methods" 4
.IX Item "Union types consider all members in the is_subtype_of and is_a_type_of methods"
Previously, a union type would report itself as being of a subtype of a type if
\&\fIany\fR of its member types were subtypes of that type. This was incorrect
because any value that passes a subtype constraint must also pass a parent
constraint. This has changed so that \fIall\fR of its member types must be a
subtype of the specified type.
.IP "Enum types now work with just one value" 4
.IX Item "Enum types now work with just one value"
Previously, an \f(CW\*(C`enum\*(C'\fR type needed to have two or more values.  Nobody knew
why, so we fixed it.
.IP "Methods defined in \s-1UNIVERSAL\s0 now appear in the \s-1MOP\s0" 4
.IX Item "Methods defined in UNIVERSAL now appear in the MOP"
Any method introspection methods that look at methods from parent classes now
find methods defined in \s-1UNIVERSAL.\s0 This includes methods like \f(CW\*(C`$class\->get_all_methods\*(C'\fR and \f(CW\*(C`$class\->find_method_by_name\*(C'\fR.
.Sp
This also means that you can now apply method modifiers to these methods.
.IP "Hand-optimized type constraint code causes a deprecation warning" 4
.IX Item "Hand-optimized type constraint code causes a deprecation warning"
If you provide an optimized sub ref for a type constraint, this now causes a
deprecation warning. Typically, this comes from passing an \f(CW\*(C`optimize_as\*(C'\fR
parameter to \f(CW\*(C`subtype\*(C'\fR, but it could also happen if you create a
Moose::Meta::TypeConstraint object directly.
.Sp
Use the inlining feature (\f(CW\*(C`inline_as\*(C'\fR) added in 2.0100 instead.
.ie n .IP """Class::Load::load_class"" and ""is_class_loaded"" have been removed" 4
.el .IP "\f(CWClass::Load::load_class\fR and \f(CWis_class_loaded\fR have been removed" 4
.IX Item "Class::Load::load_class and is_class_loaded have been removed"
The \f(CW\*(C`Class::MOP::load_class\*(C'\fR and \f(CW\*(C`Class::MOP::is_class_loaded\*(C'\fR subroutines
are no longer documented, and will cause a deprecation warning in the
future. Moose now uses Class::Load to provide this functionality, and you
should do so as well.
.SH "2.0205"
.IX Header "2.0205"
.ie n .IP "Array and Hash native traits provide a ""shallow_clone"" method" 4
.el .IP "Array and Hash native traits provide a \f(CWshallow_clone\fR method" 4
.IX Item "Array and Hash native traits provide a shallow_clone method"
The Array and Hash native traits now provide a \*(L"shallow_clone\*(R" method, which
will return a reference to a new container with the same contents as the
attribute's reference.
.SH "2.0200"
.IX Header "2.0200"
.IP "Hand-optimized type constraint code is deprecated in favor of inlining" 4
.IX Item "Hand-optimized type constraint code is deprecated in favor of inlining"
Moose allows you to provide a hand-optimized version of a type constraint's
subroutine reference. This version allows type constraints to generate inline
code, and you should use this inlining instead of providing a hand-optimized
subroutine reference.
.Sp
This affects the \f(CW\*(C`optimize_as\*(C'\fR sub exported by
Moose::Util::TypeConstraints. Use \f(CW\*(C`inline_as\*(C'\fR instead.
.Sp
This will start warning in the 2.0300 release.
.SH "2.0002"
.IX Header "2.0002"
.IP "More useful type constraint error messages" 4
.IX Item "More useful type constraint error messages"
If you have Devel::PartialDump version 0.14 or higher installed, Moose's
type constraint error messages will use it to display the invalid value, rather
than just displaying it directly. This will generally be much more useful. For
instance, instead of this:
.Sp
.Vb 1
\&  Attribute (foo) does not pass the type constraint because: Validation failed for \*(AqArrayRef[Int]\*(Aq with value ARRAY(0x275eed8)
.Ve
.Sp
the error message will instead look like
.Sp
.Vb 1
\&  Attribute (foo) does not pass the type constraint because: Validation failed for \*(AqArrayRef[Int]\*(Aq with value [ "a" ]
.Ve
.Sp
Note that Devel::PartialDump can't be made a direct dependency at the
moment, because it uses Moose itself, but we're considering options to make
this easier.
.SH "2.0000"
.IX Header "2.0000"
.IP "Roles have their own default attribute metaclass" 4
.IX Item "Roles have their own default attribute metaclass"
Previously, when a role was applied to a class, it would use the attribute
metaclass defined in the class when copying over the attributes in the role.
This was wrong, because for instance, using MooseX::FollowPBP in the class
would end up renaming all of the accessors generated by the role, some of which
may be being called in the role, causing it to break. Roles now keep track of
their own attribute metaclass to use by default when being applied to a class
(defaulting to Moose::Meta::Attribute). This is modifiable using
Moose::Util::MetaRole by passing the \f(CW\*(C`applied_attribute\*(C'\fR key to the
\&\f(CW\*(C`role_metaroles\*(C'\fR option, as in:
.Sp
.Vb 9
\&    Moose::Util::MetaRole::apply_metaroles(
\&        for => _\|_PACKAGE_\|_,
\&        class_metaroles => {
\&            attribute => [\*(AqMy::Meta::Role::Attribute\*(Aq],
\&        },
\&        role_metaroles => {
\&            applied_attribute => [\*(AqMy::Meta::Role::Attribute\*(Aq],
\&        },
\&    );
.Ve
.IP "Class::MOP has been folded into the Moose dist" 4
.IX Item "Class::MOP has been folded into the Moose dist"
Moose and Class::MOP are tightly related enough that they have always had to be
kept pretty closely in step in terms of versions. Making them into a single
dist should simplify the upgrade process for users, as it should no longer be
possible to upgrade one without the other and potentially cause issues. No
functionality has changed, and this should be entirely transparent.
.IP "Moose's conflict checking is more robust and useful" 4
.IX Item "Moose's conflict checking is more robust and useful"
There are two parts to this. The most useful one right now is that Moose will
ship with a \f(CW\*(C`moose\-outdated\*(C'\fR script, which can be run at any point to list the
modules which are installed that conflict with the installed version of Moose.
After upgrading Moose, running \f(CW\*(C`moose\-outdated | cpanm\*(C'\fR should be sufficient
to ensure that all of the Moose extensions you use will continue to work.
.Sp
The other part is that Moose's \f(CW\*(C`META.json\*(C'\fR file will also specify the
conflicts under the \f(CW\*(C`x_conflicts\*(C'\fR key. We are working with the Perl tool chain
developers to try to get conflicts support added to \s-1CPAN\s0 clients, and if/when
that happens, the metadata already exists, and so the conflict checking will
become automatic.
.IP "Most deprecated APIs/features are slated for removal in Moose 2.0200" 4
.IX Item "Most deprecated APIs/features are slated for removal in Moose 2.0200"
Most of the deprecated APIs and features in Moose will start throwing an error
in Moose 2.0200. Some of the features will go away entirely, and some will
simply throw an error.
.Sp
The things on the chopping block are:
.RS 4
.IP "\(bu" 8
Old public methods in Class::MOP and Moose
.Sp
This includes things like \f(CW\*(C`Class::MOP::Class\->get_attribute_map\*(C'\fR, \f(CW\*(C`Class::MOP::Class\->construct_instance\*(C'\fR, and many others. These were
deprecated in Class::MOP 0.80_01, released on April 5, 2009.
.Sp
These methods will be removed entirely in Moose 2.0200.
.IP "\(bu" 8
Old public functions in Class::MOP
.Sp
This include \f(CW\*(C`Class::MOP::subname\*(C'\fR, \f(CW\*(C`Class::MOP::in_global_destruction\*(C'\fR, and
the \f(CW\*(C`Class::MOP::HAS_ISAREV\*(C'\fR constant. The first two were deprecated in 0.84,
and the last in 0.80. Class::MOP 0.84 was released on May 12, 2009.
.Sp
These functions will be removed entirely in Moose 2.0200.
.IP "\(bu" 8
The \f(CW\*(C`alias\*(C'\fR and \f(CW\*(C`excludes\*(C'\fR option for role composition
.Sp
These were renamed to \f(CW\*(C`\-alias\*(C'\fR and \f(CW\*(C`\-excludes\*(C'\fR in Moose 0.89, released on
August 13, 2009.
.Sp
Passing these will throw an error in Moose 2.0200.
.IP "\(bu" 8
The old Moose::Util::MetaRole \s-1API\s0
.Sp
This include the \f(CW\*(C`apply_metaclass_roles()\*(C'\fR function, as well as passing the
\&\f(CW\*(C`for_class\*(C'\fR or any key ending in \f(CW\*(C`_roles\*(C'\fR to \f(CW\*(C`apply_metaroles()\*(C'\fR. This was
deprecated in Moose 0.93_01, released on January 4, 2010.
.Sp
These will all throw an error in Moose 2.0200.
.IP "\(bu" 8
Passing plain lists to \f(CW\*(C`type()\*(C'\fR or \f(CW\*(C`subtype()\*(C'\fR
.Sp
The old \s-1API\s0 for these functions allowed you to pass a plain list of parameter,
rather than a list of hash references (which is what \f(CW\*(C`as()\*(C'\fR, \f(CW\*(C`where\*(C'\fR,
etc. return). This was deprecated in Moose 0.71_01, released on February 22,
2009.
.Sp
This will throw an error in Moose 2.0200.
.IP "\(bu" 8
The Role subtype
.Sp
This subtype was deprecated in Moose 0.84, released on June 26, 2009.
.Sp
This will be removed entirely in Moose 2.0200.
.RE
.RS 4
.RE
.SH "1.21"
.IX Header "1.21"
.IP "\(bu" 4
New release policy
.Sp
As of the 2.0 release, Moose now has an official release and support policy,
documented in Moose::Manual::Support. All \s-1API\s0 changes will now go through a
deprecation cycle of at least one year, after which the deprecated \s-1API\s0 can be
removed. Deprecations and removals will only happen in major releases.
.Sp
In between major releases, we will still make minor releases to add new
features, fix bugs, update documentation, etc.
.SH "1.16"
.IX Header "1.16"
.IP "Configurable stacktraces" 4
.IX Item "Configurable stacktraces"
Classes which use the Moose::Error::Default error class can now have
stacktraces disabled by setting the \f(CW\*(C`MOOSE_ERROR_STYLE\*(C'\fR env var to \f(CW\*(C`croak\*(C'\fR.
This is experimental, fairly incomplete, and won't work in all cases (because
Moose's error system in general is all of these things), but this should allow
for reducing at least some of the verbosity in most cases.
.SH "1.15"
.IX Header "1.15"
.IP "Native Delegations" 4
.IX Item "Native Delegations"
In previous versions of Moose, the Native delegations were created as
closures. The generated code was often quite slow compared to doing the same
thing by hand. For example, the Array's push delegation ended up doing
something like this:
.Sp
.Vb 1
\&  push @{ $self\->$reader() }, @_;
.Ve
.Sp
If the attribute was created without a reader, the \f(CW$reader\fR sub reference
followed a very slow code path. Even with a reader, this is still slower than
it needs to be.
.Sp
Native delegations are now generated as inline code, just like other
accessors, so we can access the slot directly.
.Sp
In addition, native traits now do proper constraint checking in all cases. In
particular, constraint checking has been improved for array and hash
references. Previously, only the \fIcontained\fR type (the \f(CW\*(C`Str\*(C'\fR in
\&\f(CW\*(C`HashRef[Str]\*(C'\fR) would be checked when a new value was added to the
collection. However, if there was a constraint that applied to the whole
value, this was never checked.
.Sp
In addition, coercions are now called on the whole value.
.Sp
The delegation methods now do more argument checking. All of the methods check
that a valid number of arguments were passed to the method. In addition, the
delegation methods check that the arguments are sane (array indexes, hash
keys, numbers, etc.) when applicable. We have tried to emulate the behavior of
Perl builtins as much as possible.
.Sp
Finally, triggers are called whenever the value of the attribute is changed by
a Native delegation.
.Sp
These changes are only likely to break code in a few cases.
.Sp
The inlining code may or may not preserve the original reference when changes
are made. In some cases, methods which change the value may replace it
entirely. This will break tied values.
.Sp
If you have a typed arrayref or hashref attribute where the type enforces a
constraint on the whole collection, this constraint will now be checked. It's
possible that code which previously ran without errors will now cause the
constraint to fail. However, presumably this is a good thing ;)
.Sp
If you are passing invalid arguments to a delegation which were previously
being ignored, these calls will now fail.
.Sp
If your code relied on the trigger only being called for a regular writer,
that may cause problems.
.Sp
As always, you are encouraged to test before deploying the latest version of
Moose to production.
.IP "Defaults is and default for String, Counter, and Bool" 4
.IX Item "Defaults is and default for String, Counter, and Bool"
A few native traits (String, Counter, Bool) provide default values of \*(L"is\*(R" and
\&\*(L"default\*(R" when you created an attribute. Allowing them to provide these values
is now deprecated. Supply the value yourself when creating the attribute.
.ie n .IP "The ""meta"" method" 4
.el .IP "The \f(CWmeta\fR method" 4
.IX Item "The meta method"
Moose and Class::MOP have been cleaned up internally enough to make the
\&\f(CW\*(C`meta\*(C'\fR method that you get by default optional. \f(CW\*(C`use Moose\*(C'\fR and
\&\f(CW\*(C`use Moose::Role\*(C'\fR now can take an additional \f(CW\*(C`\-meta_name\*(C'\fR option, which
tells Moose what name to use when installing the \f(CW\*(C`meta\*(C'\fR method. Passing
\&\f(CW\*(C`undef\*(C'\fR to this option suppresses generation of the \f(CW\*(C`meta\*(C'\fR method
entirely. This should be useful for users of modules which also use a \f(CW\*(C`meta\*(C'\fR
method or function, such as Curses or Rose::DB::Object.
.SH "1.09"
.IX Header "1.09"
.IP "All deprecated features now warn" 4
.IX Item "All deprecated features now warn"
Previously, deprecation mostly consisted of simply saying \*(L"X is deprecated\*(R" in
the Changes file. We were not very consistent about actually warning. Now, all
deprecated features still present in Moose actually give a warning. The
warning is issued once per calling package. See Moose::Deprecated for more
details.
.ie n .IP "You cannot pass ""coerce => 1"" unless the attribute's type constraint has a coercion" 4
.el .IP "You cannot pass \f(CWcoerce => 1\fR unless the attribute's type constraint has a coercion" 4
.IX Item "You cannot pass coerce => 1 unless the attribute's type constraint has a coercion"
Previously, this was accepted, and it sort of worked, except that if you
attempted to set the attribute after the object was created, you would get a
runtime error.
.Sp
Now you will get a warning when you attempt to define the attribute.
.ie n .IP """no Moose"", ""no Moose::Role"", and ""no Moose::Exporter"" no longer unimport strict and warnings" 4
.el .IP "\f(CWno Moose\fR, \f(CWno Moose::Role\fR, and \f(CWno Moose::Exporter\fR no longer unimport strict and warnings" 4
.IX Item "no Moose, no Moose::Role, and no Moose::Exporter no longer unimport strict and warnings"
This change was made in 1.05, and has now been reverted. We don't know if the
user has explicitly loaded strict or warnings on their own, and unimporting
them is just broken in that case.
.IP "Reversed logic when defining which options can be changed" 4
.IX Item "Reversed logic when defining which options can be changed"
Moose::Meta::Attribute now allows all options to be changed in an
overridden attribute. The previous behaviour required each option to be
whitelisted using the \f(CW\*(C`legal_options_for_inheritance\*(C'\fR method. This method has
been removed, and there is a new method, \f(CW\*(C`illegal_options_for_inheritance\*(C'\fR,
which can now be used to prevent certain options from being changeable.
.Sp
In addition, we only throw an error if the illegal option is actually
changed. If the superclass didn't specify this option at all when defining the
attribute, the subclass version can still add it as an option.
.Sp
Example of overriding this in an attribute trait:
.Sp
.Vb 2
\&  package Bar::Meta::Attribute;
\&  use Moose::Role;
\&
\&  has \*(Aqmy_illegal_option\*(Aq => (
\&      isa => \*(AqCodeRef\*(Aq,
\&      is  => \*(Aqrw\*(Aq,
\&  );
\&
\&  around illegal_options_for_inheritance => sub {
\&      return ( shift\->(@_), qw/my_illegal_option/ );
\&  };
.Ve
.SH "1.05"
.IX Header "1.05"
.ie n .IP """\s-1BUILD""\s0 in Moose::Object methods are now called when calling ""new_object""" 4
.el .IP "``\s-1BUILD''\s0 in Moose::Object methods are now called when calling \f(CWnew_object\fR" 4
.IX Item "BUILD in Moose::Object methods are now called when calling new_object"
Previously, \f(CW\*(C`BUILD\*(C'\fR methods would only be called from \f(CW\*(C`Moose::Object::new\*(C'\fR,
but now they are also called when constructing an object via
\&\f(CW\*(C`Moose::Meta::Class::new_object\*(C'\fR. \f(CW\*(C`BUILD\*(C'\fR methods are an inherent part of the
object construction process, and this should make \f(CW\*(C`$meta\->new_object\*(C'\fR
actually usable without forcing people to use \f(CW\*(C`$meta\->name\->new\*(C'\fR.
.ie n .IP """no Moose"", ""no Moose::Role"", and ""no Moose::Exporter"" now unimport strict and warnings" 4
.el .IP "\f(CWno Moose\fR, \f(CWno Moose::Role\fR, and \f(CWno Moose::Exporter\fR now unimport strict and warnings" 4
.IX Item "no Moose, no Moose::Role, and no Moose::Exporter now unimport strict and warnings"
In the interest of having \f(CW\*(C`no Moose\*(C'\fR clean up everything that \f(CW\*(C`use Moose\*(C'\fR
does in the calling scope, \f(CW\*(C`no Moose\*(C'\fR (as well as all other
Moose::Exporter\-using modules) now unimports strict and warnings.
.IP "Metaclass compatibility checking and fixing should be much more robust" 4
.IX Item "Metaclass compatibility checking and fixing should be much more robust"
The metaclass compatibility checking
and fixing algorithms have been completely rewritten, in both Class::MOP and
Moose. This should resolve many confusing errors when dealing with non-Moose
inheritance and with custom metaclasses for things like attributes,
constructors, etc. For correct code, the only thing that should require a
change is that custom error metaclasses must now inherit from
Moose::Error::Default.
.SH "1.02"
.IX Header "1.02"
.IP "Moose::Meta::TypeConstraint::Class is_subtype_of behavior" 4
.IX Item "Moose::Meta::TypeConstraint::Class is_subtype_of behavior"
Earlier versions of is_subtype_of
would incorrectly return true when called with itself, its own \s-1TC\s0 name or
its class name as an argument. (i.e. \f(CW$foo_tc\fR\->is_subtype_of('Foo') == 1) This
behavior was a caused by \f(CW\*(C`isa\*(C'\fR being checked before the class name. The old
behavior can be accessed with is_type_of
.SH "1.00"
.IX Header "1.00"
.IP "Moose::Meta::Attribute::Native::Trait::Code no longer creates reader methods by default" 4
.IX Item "Moose::Meta::Attribute::Native::Trait::Code no longer creates reader methods by default"
Earlier versions of Moose::Meta::Attribute::Native::Trait::Code created
read-only accessors for the attributes it's been applied to, even if you didn't
ask for it with \f(CW\*(C`is => \*(Aqro\*(Aq\*(C'\fR. This incorrect behaviour has now been fixed.
.SH "0.95"
.IX Header "0.95"
.IP "Moose::Util add_method_modifier behavior" 4
.IX Item "Moose::Util add_method_modifier behavior"
add_method_modifier (and subsequently the sugar functions Moose::before,
Moose::after, and Moose::around) can now accept arrayrefs, with the same
behavior as lists. Types other than arrayref and regexp result in an error.
.SH "0.93_01 and 0.94"
.IX Header "0.93_01 and 0.94"
.IP "Moose::Util::MetaRole \s-1API\s0 has changed" 4
.IX Item "Moose::Util::MetaRole API has changed"
The \f(CW\*(C`apply_metaclass_roles\*(C'\fR function is now called \f(CW\*(C`apply_metaroles\*(C'\fR. The
way arguments are supplied has been changed to force you to distinguish
between metaroles applied to Moose::Meta::Class (and helpers) versus
Moose::Meta::Role.
.Sp
The old \s-1API\s0 still works, but will warn in a future release, and eventually be
removed.
.IP "Moose::Meta::Role has real attributes" 4
.IX Item "Moose::Meta::Role has real attributes"
The attributes returned by Moose::Meta::Role are now instances of the
Moose::Meta::Role::Attribute class, instead of bare hash references.
.ie n .IP """no Moose"" now removes ""blessed"" and ""confess""" 4
.el .IP "``no Moose'' now removes \f(CWblessed\fR and \f(CWconfess\fR" 4
.IX Item "no Moose now removes blessed and confess"
Moose is now smart enough to know exactly what it exported, even when it
re-exports functions from other packages. When you unimport Moose, it will
remove these functions from your namespace unless you \fIalso\fR imported them
directly from their respective packages.
.Sp
If you have a \f(CW\*(C`no Moose\*(C'\fR in your code \fIbefore\fR you call \f(CW\*(C`blessed\*(C'\fR or
\&\f(CW\*(C`confess\*(C'\fR, your code will break. You can either move the \f(CW\*(C`no Moose\*(C'\fR call
later in your code, or explicitly import the relevant functions from the
packages that provide them.
.IP "Moose::Exporter is smarter about unimporting re-exports" 4
.IX Item "Moose::Exporter is smarter about unimporting re-exports"
The change above comes from a general improvement to Moose::Exporter. It
will now unimport any function it exports, even if that function is a
re-export from another package.
.ie n .IP "Attributes in roles can no longer override class attributes with ""+foo""" 4
.el .IP "Attributes in roles can no longer override class attributes with ``+foo''" 4
.IX Item "Attributes in roles can no longer override class attributes with +foo"
Previously, this worked more or less accidentally, because role attributes
weren't objects. This was never documented, but a few MooseX modules took
advantage of this.
.IP "The composition_class_roles attribute in Moose::Meta::Role is now a method" 4
.IX Item "The composition_class_roles attribute in Moose::Meta::Role is now a method"
This was done to make it possible for roles to alter the list of composition
class roles by applying a method modifiers. Previously, this was an attribute
and MooseX modules override it. Since that no longer works, this was made a
method.
.Sp
This \fIshould\fR be an attribute, so this may switch back to being an attribute
in the future if we can figure out how to make this work.
.SH "0.93"
.IX Header "0.93"
.ie n .IP "Calling $object\->\fInew()\fR is no longer deprecated" 4
.el .IP "Calling \f(CW$object\fR\->\fInew()\fR is no longer deprecated" 4
.IX Item "Calling $object->new() is no longer deprecated"
We decided to undeprecate this. Now it just works.
.ie n .IP "Both ""get_method_map"" and ""get_attribute_map"" is deprecated" 4
.el .IP "Both \f(CWget_method_map\fR and \f(CWget_attribute_map\fR is deprecated" 4
.IX Item "Both get_method_map and get_attribute_map is deprecated"
These metaclass methods were never meant to be public, and they are both now
deprecated. The work around if you still need the functionality they provided
is to iterate over the list of names manually.
.Sp
.Vb 1
\&    my %fields = map { $_ => $meta\->get_attribute($_) } $meta\->get_attribute_list;
.Ve
.Sp
This was actually a change in Class::MOP, but this version of Moose
requires a version of Class::MOP that includes said change.
.SH "0.90"
.IX Header "0.90"
.IP "Added Native delegation for Code refs" 4
.IX Item "Added Native delegation for Code refs"
See Moose::Meta::Attribute::Native::Trait::Code for details.
.ie n .IP "Calling $object\->\fInew()\fR is deprecated" 4
.el .IP "Calling \f(CW$object\fR\->\fInew()\fR is deprecated" 4
.IX Item "Calling $object->new() is deprecated"
Moose has long supported this, but it's never really been documented, and we
don't think this is a good practice. If you want to construct an object from
an existing object, you should provide some sort of alternate constructor like
\&\f(CW\*(C`$object\->clone\*(C'\fR.
.Sp
Calling \f(CW\*(C`$object\->new\*(C'\fR now issues a warning, and will be an error in a
future release.
.ie n .IP "Moose no longer warns if you call ""make_immutable"" for a class with mutable ancestors" 4
.el .IP "Moose no longer warns if you call \f(CWmake_immutable\fR for a class with mutable ancestors" 4
.IX Item "Moose no longer warns if you call make_immutable for a class with mutable ancestors"
While in theory this is a good thing to warn about, we found so many
exceptions to this that doing this properly became quite problematic.
.SH "0.89_02"
.IX Header "0.89_02"
.IP "New Native delegation methods from List::Util and List::MoreUtils" 4
.IX Item "New Native delegation methods from List::Util and List::MoreUtils"
In particular, we now have \f(CW\*(C`reduce\*(C'\fR, \f(CW\*(C`shuffle\*(C'\fR, \f(CW\*(C`uniq\*(C'\fR, and \f(CW\*(C`natatime\*(C'\fR.
.IP "The Moose::Exporter with_caller feature is now deprecated" 4
.IX Item "The Moose::Exporter with_caller feature is now deprecated"
Use \f(CW\*(C`with_meta\*(C'\fR instead. The \f(CW\*(C`with_caller\*(C'\fR option will start warning in a
future release.
.ie n .IP "Moose now warns if you call ""make_immutable"" for a class with mutable ancestors" 4
.el .IP "Moose now warns if you call \f(CWmake_immutable\fR for a class with mutable ancestors" 4
.IX Item "Moose now warns if you call make_immutable for a class with mutable ancestors"
This is dangerous because modifying a class after a subclass has been
immutabilized will lead to incorrect results in the subclass, due to inlining,
caching, etc. This occasionally happens accidentally, when a class loads one
of its subclasses in the middle of its class definition, so pointing out that
this may cause issues should be helpful. Metaclasses (classes that inherit
from Class::MOP::Object) are currently exempt from this check, since at the
moment we aren't very consistent about which metaclasses we immutabilize.
.ie n .IP """enum"" and ""duck_type"" now take arrayrefs for all forms" 4
.el .IP "\f(CWenum\fR and \f(CWduck_type\fR now take arrayrefs for all forms" 4
.IX Item "enum and duck_type now take arrayrefs for all forms"
Previously, calling these functions with a list would take the first element of
the list as the type constraint name, and use the remainder as the enum values
or method names. This makes the interface inconsistent with the anon-type forms
of these functions (which must take an arrayref), and a free-form list where
the first value is sometimes special is hard to validate (and harder to give
reasonable error messages for). These functions have been changed to take
arrayrefs in all their forms \- so, \f(CW\*(C`enum \*(AqMy::Type\*(Aq => [qw(foo bar)]\*(C'\fR is
now the preferred way to create an enum type constraint. The old syntax still
works for now, but it will hopefully be deprecated and removed in a future
release.
.SH "0.89_01"
.IX Header "0.89_01"
Moose::Meta::Attribute::Native has been moved into the Moose core from
MooseX::AttributeHelpers.  Major changes include:
.ie n .IP """traits"", not ""metaclass""" 4
.el .IP "\f(CWtraits\fR, not \f(CWmetaclass\fR" 4
.IX Item "traits, not metaclass"
Method providers are only available via traits.
.ie n .IP """handles"", not ""provides"" or ""curries""" 4
.el .IP "\f(CWhandles\fR, not \f(CWprovides\fR or \f(CWcurries\fR" 4
.IX Item "handles, not provides or curries"
The \f(CW\*(C`provides\*(C'\fR syntax was like core Moose \f(CW\*(C`handles => HASHREF\*(C'\fR
syntax, but with the keys and values reversed.  This was confusing,
and AttributeHelpers now uses \f(CW\*(C`handles => HASHREF\*(C'\fR in a way that
should be intuitive to anyone already familiar with how it is used for
other attributes.
.Sp
The \f(CW\*(C`curries\*(C'\fR functionality provided by AttributeHelpers has been
generalized to apply to all cases of \f(CW\*(C`handles => HASHREF\*(C'\fR, though
not every piece of functionality has been ported (currying with a
\&\s-1CODEREF\s0 is not supported).
.ie n .IP """empty"" is now ""is_empty"", and means empty, not non-empty" 4
.el .IP "\f(CWempty\fR is now \f(CWis_empty\fR, and means empty, not non-empty" 4
.IX Item "empty is now is_empty, and means empty, not non-empty"
Previously, the \f(CW\*(C`empty\*(C'\fR method provided by Arrays and Hashes returned true if
the attribute was \fBnot\fR empty (no elements).  Now it returns true if the
attribute \fBis\fR empty. It was also renamed to \f(CW\*(C`is_empty\*(C'\fR, to reflect this.
.ie n .IP """find"" was renamed to ""first"", and ""first"" and ""last"" were removed" 4
.el .IP "\f(CWfind\fR was renamed to \f(CWfirst\fR, and \f(CWfirst\fR and \f(CWlast\fR were removed" 4
.IX Item "find was renamed to first, and first and last were removed"
List::Util refers to the functionality that we used to provide under \f(CW\*(C`find\*(C'\fR
as first, so that will likely be more familiar (and will
fit in better if we decide to add more List::Util functions). \f(CW\*(C`first\*(C'\fR and
\&\f(CW\*(C`last\*(C'\fR were removed, since their functionality is easily duplicated with
curries of \f(CW\*(C`get\*(C'\fR.
.ie n .IP "Helpers that take a coderef of one argument now use $_" 4
.el .IP "Helpers that take a coderef of one argument now use \f(CW$_\fR" 4
.IX Item "Helpers that take a coderef of one argument now use $_"
Subroutines passed as the first argument to \f(CW\*(C`first\*(C'\fR, \f(CW\*(C`map\*(C'\fR, and \f(CW\*(C`grep\*(C'\fR now
receive their argument in \f(CW$_\fR rather than as a parameter to the subroutine.
Helpers that take a coderef of two or more arguments remain using the argument
list (there are technical limitations to using \f(CW$a\fR and \f(CW$b\fR like \f(CW\*(C`sort\*(C'\fR
does).
.Sp
See Moose::Meta::Attribute::Native for the new documentation.
.PP
The \f(CW\*(C`alias\*(C'\fR and \f(CW\*(C`excludes\*(C'\fR role parameters have been renamed to \f(CW\*(C`\-alias\*(C'\fR
and \f(CW\*(C`\-excludes\*(C'\fR. The old names still work, but new code should use the new
names, and eventually the old ones will be deprecated and removed.
.SH "0.89"
.IX Header "0.89"
\&\f(CW\*(C`use Moose \-metaclass => \*(AqFoo\*(Aq\*(C'\fR now does alias resolution, just like
\&\f(CW\*(C`\-traits\*(C'\fR (and the \f(CW\*(C`metaclass\*(C'\fR and \f(CW\*(C`traits\*(C'\fR options to \f(CW\*(C`has\*(C'\fR).
.PP
Added two functions \f(CW\*(C`meta_class_alias\*(C'\fR and \f(CW\*(C`meta_attribute_alias\*(C'\fR to
Moose::Util, to simplify aliasing metaclasses and metatraits. This is
a wrapper around the old
.PP
.Vb 2
\&  package Moose::Meta::Class::Custom::Trait::FooTrait;
\&  sub register_implementation { \*(AqMy::Meta::Trait\*(Aq }
.Ve
.PP
way of doing this.
.SH "0.84"
.IX Header "0.84"
When an attribute generates \fIno\fR accessors, we now warn. This is to help
users who forget the \f(CW\*(C`is\*(C'\fR option. If you really do not want any accessors,
you can use \f(CW\*(C`is => \*(Aqbare\*(Aq\*(C'\fR. You can maintain back compat with older
versions of Moose by using something like:
.PP
.Vb 1
\&    ($Moose::VERSION >= 0.84 ? is => \*(Aqbare\*(Aq : ())
.Ve
.PP
When an accessor overwrites an existing method, we now warn. To work around
this warning (if you really must have this behavior), you can explicitly
remove the method before creating it as an accessor:
.PP
.Vb 1
\&    sub foo {}
\&
\&    _\|_PACKAGE_\|_\->meta\->remove_method(\*(Aqfoo\*(Aq);
\&
\&    has foo => (
\&        is => \*(Aqro\*(Aq,
\&    );
.Ve
.PP
When an unknown option is passed to \f(CW\*(C`has\*(C'\fR, we now warn. You can silence
the warning by fixing your code. :)
.PP
The \f(CW\*(C`Role\*(C'\fR type has been deprecated. On its own, it was useless,
since it just checked \f(CW\*(C`$object\->can(\*(Aqdoes\*(Aq)\*(C'\fR. If you were using
it as a parent type, just call \f(CW\*(C`role_type(\*(AqRole::Name\*(Aq)\*(C'\fR to create an
appropriate type instead.
.SH "0.78"
.IX Header "0.78"
\&\f(CW\*(C`use Moose::Exporter;\*(C'\fR now imports \f(CW\*(C`strict\*(C'\fR and \f(CW\*(C`warnings\*(C'\fR into packages
that use it.
.SH "0.77"
.IX Header "0.77"
\&\f(CW\*(C`DEMOLISHALL\*(C'\fR and \f(CW\*(C`DEMOLISH\*(C'\fR now receive an argument indicating whether or
not we are in global destruction.
.SH "0.76"
.IX Header "0.76"
Type constraints no longer run coercions for a value that already matches the
constraint.  This may affect some (arguably buggy) edge case coercions that
rely on side effects in the \f(CW\*(C`via\*(C'\fR clause.
.SH "0.75"
.IX Header "0.75"
Moose::Exporter now accepts the \f(CW\*(C`\-metaclass\*(C'\fR option for easily
overriding the metaclass (without metaclass). This works for classes
and roles.
.SH "0.74"
.IX Header "0.74"
Added a \f(CW\*(C`duck_type\*(C'\fR sugar function to Moose::Util::TypeConstraints
to make integration with non-Moose classes easier. It simply checks if
\&\f(CW\*(C`$obj\->can()\*(C'\fR a list of methods.
.PP
A number of methods (mostly inherited from Class::MOP) have been
renamed with a leading underscore to indicate their internal-ness. The
old method names will still work for a while, but will warn that the
method has been renamed. In a few cases, the method will be removed
entirely in the future. This may affect MooseX authors who were using
these methods.
.SH "0.73"
.IX Header "0.73"
Calling \f(CW\*(C`subtype\*(C'\fR with a name as the only argument now throws an
exception. If you want an anonymous subtype do:
.PP
.Vb 1
\&    my $subtype = subtype as \*(AqFoo\*(Aq;
.Ve
.PP
This is related to the changes in version 0.71_01.
.PP
The \f(CW\*(C`is_needed\*(C'\fR method in Moose::Meta::Method::Destructor is now
only usable as a class method. Previously, it worked as a class or
object method, with a different internal implementation for each
version.
.PP
The internals of making a class immutable changed a lot in Class::MOP
0.78_02, and Moose's internals have changed along with it. The
external \f(CW\*(C`$metaclass\->make_immutable\*(C'\fR method still works the same
way.
.SH "0.72"
.IX Header "0.72"
A mutable class accepted \f(CW\*(C`Foo\->new(undef)\*(C'\fR without complaint,
while an immutable class would blow up with an unhelpful error. Now,
in both cases we throw a helpful error instead.
.PP
This \*(L"feature\*(R" was originally added to allow for cases such as this:
.PP
.Vb 1
\&  my $args;
\&
\&  if ( something() ) {
\&      $args = {...};
\&  }
\&
\&  return My::Class\->new($args);
.Ve
.PP
But we decided this is a bad idea and a little too magical, because it
can easily mask real errors.
.SH "0.71_01"
.IX Header "0.71_01"
Calling \f(CW\*(C`type\*(C'\fR or \f(CW\*(C`subtype\*(C'\fR without the sugar helpers (\f(CW\*(C`as\*(C'\fR,
\&\f(CW\*(C`where\*(C'\fR, \f(CW\*(C`message\*(C'\fR) is now deprecated.
.PP
As a side effect, this meant we ended up using Perl prototypes on
\&\f(CW\*(C`as\*(C'\fR, and code like this will no longer work:
.PP
.Vb 2
\&  use Moose::Util::TypeConstraints;
\&  use Declare::Constraints::Simple \-All;
\&
\&  subtype \*(AqArrayOfInts\*(Aq
\&      => as \*(AqArrayRef\*(Aq
\&      => IsArrayRef(IsInt);
.Ve
.PP
Instead it must be changed to this:
.PP
.Vb 6
\&  subtype(
\&      \*(AqArrayOfInts\*(Aq => {
\&          as    => \*(AqArrayRef\*(Aq,
\&          where => IsArrayRef(IsInt)
\&      }
\&  );
.Ve
.PP
If you want to maintain backwards compat with older versions of Moose,
you must explicitly test Moose's \f(CW\*(C`VERSION\*(C'\fR:
.PP
.Vb 10
\&  if ( Moose\->VERSION < 0.71_01 ) {
\&      subtype \*(AqArrayOfInts\*(Aq
\&          => as \*(AqArrayRef\*(Aq
\&          => IsArrayRef(IsInt);
\&  }
\&  else {
\&      subtype(
\&          \*(AqArrayOfInts\*(Aq => {
\&              as    => \*(AqArrayRef\*(Aq,
\&              where => IsArrayRef(IsInt)
\&          }
\&      );
\&  }
.Ve
.SH "0.70"
.IX Header "0.70"
We no longer pass the meta-attribute object as a final argument to
triggers. This actually changed for inlined code a while back, but the
non-inlined version and the docs were still out of date.
.PP
If by some chance you actually used this feature, the workaround is
simple. You fetch the attribute object from out of the \f(CW$self\fR
that is passed as the first argument to trigger, like so:
.PP
.Vb 6
\&  has \*(Aqfoo\*(Aq => (
\&      is      => \*(Aqro\*(Aq,
\&      isa     => \*(AqAny\*(Aq,
\&      trigger => sub {
\&          my ( $self, $value ) = @_;
\&          my $attr = $self\->meta\->find_attribute_by_name(\*(Aqfoo\*(Aq);
\&
\&          # ...
\&      }
\&  );
.Ve
.SH "0.66"
.IX Header "0.66"
If you created a subtype and passed a parent that Moose didn't know
about, it simply ignored the parent. Now it automatically creates the
parent as a class type. This may not be what you want, but is less
broken than before.
.PP
You could declare a name with subtype such as \*(L"Foo!Bar\*(R". Moose would
accept this allowed, but if you used it in a parameterized type such
as \*(L"ArrayRef[Foo!Bar]\*(R" it wouldn't work. We now do some vetting on
names created via the sugar functions, so that they can only contain
alphanumerics, \*(L":\*(R", and \*(L".\*(R".
.SH "0.65"
.IX Header "0.65"
Methods created via an attribute can now fulfill a \f(CW\*(C`requires\*(C'\fR
declaration for a role. Honestly we don't know why Stevan didn't make
this work originally, he was just insane or something.
.PP
Stack traces from inlined code will now report the line and file as
being in your class, as opposed to in Moose guts.
.SH "0.62_02"
.IX Header "0.62_02"
When a class does not provide all of a role's required methods, the
error thrown now mentions all of the missing methods, as opposed to
just the first missing method.
.PP
Moose will no longer inline a constructor for your class unless it
inherits its constructor from Moose::Object, and will warn when it
doesn't inline. If you want to force inlining anyway, pass
\&\f(CW\*(C`replace_constructor => 1\*(C'\fR to \f(CW\*(C`make_immutable\*(C'\fR.
.PP
If you want to get rid of the warning, pass \f(CW\*(C`inline_constructor =>
0\*(C'\fR.
.SH "0.62"
.IX Header "0.62"
Removed the (deprecated) \f(CW\*(C`make_immutable\*(C'\fR keyword.
.PP
Removing an attribute from a class now also removes delegation
(\f(CW\*(C`handles\*(C'\fR) methods installed for that attribute. This is correct
behavior, but if you were wrongly relying on it you might get bit.
.SH "0.58"
.IX Header "0.58"
Roles now add methods by calling \f(CW\*(C`add_method\*(C'\fR, not
\&\f(CW\*(C`alias_method\*(C'\fR. They make sure to always provide a method object,
which will be cloned internally. This means that it is now possible to
track the source of a method provided by a role, and even follow its
history through intermediate roles.  This means that methods added by
a role now show up when looking at a class's method list/map.
.PP
Parameter and Union args are now sorted, this makes Int|Str the same
constraint as Str|Int. Also, incoming type constraint strings are
normalized to remove all whitespace differences. This is mostly for
internals and should not affect outside code.
.PP
Moose::Exporter will no longer remove a subroutine that the
exporting package re-exports. Moose re-exports the Carp::confess
function, among others. The reasoning is that we cannot know whether
you have also explicitly imported those functions for your own use, so
we err on the safe side and always keep them.
.SH "0.56"
.IX Header "0.56"
\&\f(CW\*(C`Moose::init_meta\*(C'\fR should now be called as a method.
.PP
New modules for extension writers, Moose::Exporter and
Moose::Util::MetaRole.
.SH "0.55_01"
.IX Header "0.55_01"
Implemented metaclass traits (and wrote a recipe for it):
.PP
.Vb 1
\&  use Moose \-traits => \*(AqFoo\*(Aq
.Ve
.PP
This should make writing small Moose extensions a little
easier.
.SH "0.55"
.IX Header "0.55"
Fixed \f(CW\*(C`coerce\*(C'\fR to accept anon types just like \f(CW\*(C`subtype\*(C'\fR can.
So that you can do:
.PP
.Vb 1
\&  coerce $some_anon_type => from \*(AqStr\*(Aq => via { ... };
.Ve
.SH "0.51"
.IX Header "0.51"
Added \f(CW\*(C`BUILDARGS\*(C'\fR, a new step in \f(CW\*(C`Moose::Object\->new()\*(C'\fR.
.SH "0.49"
.IX Header "0.49"
Fixed how the \f(CW\*(C`is => (ro|rw)\*(C'\fR works with custom defined
\&\f(CW\*(C`reader\*(C'\fR, \f(CW\*(C`writer\*(C'\fR and \f(CW\*(C`accessor\*(C'\fR options. See the below table for
details:
.PP
.Vb 4
\&  is => ro, writer => _foo    # turns into (reader => foo, writer => _foo)
\&  is => rw, writer => _foo    # turns into (reader => foo, writer => _foo)
\&  is => rw, accessor => _foo  # turns into (accessor => _foo)
\&  is => ro, accessor => _foo  # error, accesor is rw
.Ve
.SH "0.45"
.IX Header "0.45"
The \f(CW\*(C`before/around/after\*(C'\fR method modifiers now support regexp
matching of method names. \s-1NOTE:\s0 this only works for classes, it is
currently not supported in roles, but, ... patches welcome.
.PP
The \f(CW\*(C`has\*(C'\fR keyword for roles now accepts the same array ref form that
Moose.pm does for classes.
.PP
A trigger on a read-only attribute is no longer an error, as it's
useful to trigger off of the constructor.
.PP
Subtypes of parameterizable types now are parameterizable types
themselves.
.SH "0.44"
.IX Header "0.44"
Fixed issue where \f(CW\*(C`DEMOLISHALL\*(C'\fR was eating the value in \f(CW$@\fR, and so
not working correctly. It still kind of eats them, but so does vanilla
perl.
.SH "0.41"
.IX Header "0.41"
Inherited attributes may now be extended without restriction on the
type ('isa', 'does').
.PP
The entire set of Moose::Meta::TypeConstraint::* classes were
refactored in this release. If you were relying on their internals you
should test your code carefully.
.SH "0.40"
.IX Header "0.40"
Documenting the use of '+name' with attributes that come from recently
composed roles. It makes sense, people are using it, and so why not
just officially support it.
.PP
The \f(CW\*(C`Moose::Meta::Class\->create\*(C'\fR method now supports roles.
.PP
It is now possible to make anonymous enum types by passing \f(CW\*(C`enum\*(C'\fR an
array reference instead of the \f(CW\*(C`enum $name => @values\*(C'\fR.
.SH "0.37"
.IX Header "0.37"
Added the \f(CW\*(C`make_immutable\*(C'\fR keyword as a shortcut to calling
\&\f(CW\*(C`make_immutable\*(C'\fR on the meta object. This eventually got removed!
.PP
Made \f(CW\*(C`init_arg => undef\*(C'\fR work in Moose. This means \*(L"do not accept
a constructor parameter for this attribute\*(R".
.PP
Type errors now use the provided message. Prior to this release they
didn't.
.SH "0.34"
.IX Header "0.34"
Moose is now a postmodern object system :)
.PP
The Role system was completely refactored. It is 100% backwards
compat, but the internals were totally changed. If you relied on the
internals then you are advised to test carefully.
.PP
Added method exclusion and aliasing for Roles in this release.
.PP
Added the Moose::Util::TypeConstraints::OptimizedConstraints
module.
.PP
Passing a list of values to an accessor (which is only expecting one
value) used to be silently ignored, now it throws an error.
.SH "0.26"
.IX Header "0.26"
Added parameterized types and did a pretty heavy refactoring of the
type constraint system.
.PP
Better framework extensibility and better support for \*(L"making your own
Moose\*(R".
.SH "0.25 or before"
.IX Header "0.25 or before"
Honestly, you shouldn't be using versions of Moose that are this old,
so many bug fixes and speed improvements have been made you would be
crazy to not upgrade.
.PP
Also, I am tired of going through the Changelog so I am stopping here,
if anyone would like to continue this please feel free.
.SH "AUTHORS"
.IX Header "AUTHORS"
.IP "\(bu" 4
Stevan Little <stevan.little@iinteractive.com>
.IP "\(bu" 4
Dave Rolsky <autarch@urth.org>
.IP "\(bu" 4
Jesse Luehrs <doy@tozt.net>
.IP "\(bu" 4
Shawn M Moore <code@sartak.org>
.IP "\(bu" 4
\&\s-1XXXX XXX\s0'\s-1XX \s0(Yuval Kogman) <nothingmuch@woobling.org>
.IP "\(bu" 4
Karen Etheridge <ether@cpan.org>
.IP "\(bu" 4
Florian Ragwitz <rafl@debian.org>
.IP "\(bu" 4
Hans Dieter Pearcey <hdp@weftsoar.net>
.IP "\(bu" 4
Chris Prather <chris@prather.org>
.IP "\(bu" 4
Matt S Trout <mst@shadowcat.co.uk>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is copyright (c) 2006 by Infinity Interactive, Inc..
.PP
This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.
