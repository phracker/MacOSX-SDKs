.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Test::Trap::Builder 3"
.TH Test::Trap::Builder 3 "2021-08-27" "perl v5.18.4" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Test::Trap::Builder \- Backend for building test traps
.SH "VERSION"
.IX Header "VERSION"
Version 0.2.3
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  package My::Test::Trap;
\&
\&  use Test::Trap::Builder;
\&  my $B = Test::Trap::Builder\->new;
\&
\&  $B\->layer( $layer_name => \e&layer_implementation );
\&  $B\->accessor( simple => [ $layer_name ] );
\&
\&  $B\->multi_layer( $multi_name => @names );
\&
\&  $B\->test( $test_name => \*(Aqtrap, predicate, name\*(Aq, \e&test_function );
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Test::Trap neither traps nor tests everything you may want to trap
or test.  So, Test::Trap::Builder provides methods to write your own
trap layers, accessors, and test callbacks \*(-- preferably for use with
your own modules (trappers).
.PP
Note that layers are methods with mangled names (names are prefixed
with \f(CW\*(C`layer:\*(C'\fR), and so inherited like any other method, while
accessors are ordinary methods.  Meanwhile, test callbacks are not
referenced in the symbol table by themselves, but only in combinations
with accessors, all methods of the form \fI\s-1ACCESSOR\s0\fR_\fI\s-1TEST\s0\fR.
.SH "EXPORTS"
.IX Header "EXPORTS"
Trappers should not inherit from Test::Trap::Builder, but may import a
few convenience methods for use in building the trap.  Do not use them
as methods of Test::Trap::Builder \*(-- they are intended to be methods
of trap objects.  (If you inherit from another trapper, you need not,
and probably should not, import these yourself \*(-- you should inherit
these methods like any other.)
.PP
Trappers may import any number of these methods, or all of them by way
of the \f(CW\*(C`:methods\*(C'\fR tag.
.PP
Layers should be implemented as methods, and while they need not call
any of these convenience methods in turn, that likely makes for more
readable code than any alternative.  Likewise, test callbacks may use
convenience methods for more readable code.
.PP
Of course, certain convenience methods may also be useful in more
generic methods messing with trap or builder objects.
.SS "Prop [\s-1PACKAGE\s0]"
.IX Subsection "Prop [PACKAGE]"
A method returning a reference to a hash, holding the \fI\s-1PACKAGE\s0\fR's (by
default the caller's) tag-on properties for the (current) trap object.
Currently, Test::Trap::Builder defines the following properties:
.IP "layers" 4
.IX Item "layers"
While the trap is springing, the queue of layers remaining.  Usually
set by the \*(L"trap\*(R" method and consumed by the \*(L"Next\*(R" method.
.IP "teardown" 4
.IX Item "teardown"
While the trap is springing, the queue of teardown actions remaining.
Usually accumulated through the \*(L"Teardown\*(R" method and invoked by
the \*(L"trap\*(R" method.
.IP "code" 4
.IX Item "code"
The user code trapped.  Usually set by the \*(L"trap\*(R" method and
invoked by the \*(L"Run\*(R" method.
.IP "exception" 4
.IX Item "exception"
An internal exception.  Usually set through the \*(L"Exception\*(R"
method and examined by the \*(L"trap\*(R" method.
.IP "on_test_failure" 4
.IX Item "on_test_failure"
A callback invoked by the \*(L"TestFailure\*(R" method.  Layers in
particular may want to set this.
.IP "test_accessor" 4
.IX Item "test_accessor"
The name and (optionally) the index of the accessor, the contents of
which we're currently testing.  Best accessed through the
\&\*(L"TestAccessor\*(R" method, and usually set by the \*(L"test\*(R" and
\&\*(L"accessor\*(R" methods, but if you are writing your own tests or
accessors directly, you just might need to set it.  Perhaps.
.PP
Be nice: Treat another module's tag-on properties as you would treat
another module's global variables.  Don't use them except as
documented.
.PP
Example:
.PP
.Vb 2
\&  # in a layer, setting the callback for TestFailure:
\&  $self\->Prop(\*(AqTest::Trap::Builder\*(Aq)\->{on_test_failure} = \e&mydiag;
.Ve
.SS "\s-1DESTROY\s0"
.IX Subsection "DESTROY"
This cleans up the tag-on properties when the trap object is
destroyed.  Don't try to make a trapper that doesn't call this; it
will get confused.
.PP
If your trapper needs its own \f(CW\*(C`DESTROY\*(C'\fR, make sure it calls this one
as well:
.PP
.Vb 6
\&  sub DESTROY {
\&    my $self = shift;
\&    # do your thing
\&    $self\->Test::Trap::Builder::DESTROY;
\&    # and more things
\&  }
.Ve
.SS "Run"
.IX Subsection "Run"
A terminating layer should call this method to run the user code.
Should only be called in a dynamic context in which layers are being
applied.
.SS "Next"
.IX Subsection "Next"
Every non-terminating layer should call this method (or an equivalent)
to progress to the next layer.  Should only be called in a dynamic
context in which layers are being applied.  Note that this method need
not return, so any tear-down actions should probably be registered with
the Teardown method (see below).
.SS "Teardown \s-1SUBS\s0"
.IX Subsection "Teardown SUBS"
If your layer wants to clean up its setup, it may use this method to
register any number of tear-down actions, to be performed (in reverse
registration order) once the user code has been executed.  Should only
be called in a dynamic context in which layers are being applied.
.SS "TestAccessor"
.IX Subsection "TestAccessor"
Returns a string of the form \f(CW"\f(CINAME\f(CW(\f(CIINDEX\f(CW)"\fR, where \fI\s-1NAME\s0\fR and
\&\fI\s-1INDEX\s0\fR are the name of the accessor and the index (if any) being
tested.  Should only be called in the dynamic context of test
callbacks.
.PP
This is intended for diagnostics:
.PP
.Vb 3
\&  diag( sprintf \*(AqExpected %s in %s; got %s\*(Aq,
\&        $expected, $self\->TestAccessor, dump($got),
\&      );
.Ve
.SS "TestFailure"
.IX Subsection "TestFailure"
Runs the \f(CW\*(C`on_test_failure\*(C'\fR tag-on property (if any) on the trap
object.  If you are writing unregistered tests, you might want to
include (some variation of) this call:
.PP
.Vb 1
\&  $ok or $self\->TestFailure;
.Ve
.SS "Exception \s-1STRINGS\s0"
.IX Subsection "Exception STRINGS"
Layer implementations may run into exceptional situations, in which
they want the entire trap to fail.  Unfortunately, another layer may
be trapping ordinary exceptions, so you need some kind of magic in
order to throw an untrappable exception.  This is one convenient way.
.PP
Should only be called in a dynamic context in which layers are being
applied.
.PP
Note: The Exception method won't work if called from outside of the
regular control flow, like inside a \s-1DESTROY\s0 method or signal handler.
If anything like this happens, CORE::exit will be called with an exit
code of 8.
.SH "METHODS"
.IX Header "METHODS"
.SS "new"
.IX Subsection "new"
Returns a singleton object.  Don't expect this module to work with a
different instance object of this class.
.SS "trap \s-1TRAPPER, GLOBREF, LAYERARRAYREF, CODE\s0"
.IX Subsection "trap TRAPPER, GLOBREF, LAYERARRAYREF, CODE"
Implements a trap for the \fI\s-1TRAPPER\s0\fR module, applying the layers of
\&\fI\s-1LAYERARRAYREF\s0\fR, trapping various outcomes of the user \fI\s-1CODE\s0\fR, and
storing the trap object into the scalar slot of \fI\s-1GLOBREF\s0\fR.
.PP
In most cases, the trapper should conveniently export a function
calling this method.
.SS "layer \s-1NAME, CODE\s0"
.IX Subsection "layer NAME, CODE"
Registers a layer by \fI\s-1NAME\s0\fR to the calling trapper.  When the layer
is applied, the \fI\s-1CODE\s0\fR will be invoked on the trap object being
built, with no arguments, and should call either the \fINext()\fR or \fIRun()\fR
method or equivalent.
.SS "output_layer \s-1NAME, GLOBREF\s0"
.IX Subsection "output_layer NAME, GLOBREF"
Registers (by \fI\s-1NAME\s0\fR and to the calling trapper) a layer for trapping
output on the file handle of the \fI\s-1GLOBREF\s0\fR, using \fI\s-1NAME\s0\fR also as the
attribute name.
.SS "output_layer_backend \s-1NAME,\s0 [\s-1CODE\s0]"
.IX Subsection "output_layer_backend NAME, [CODE]"
When called with two arguments, registers (by \fI\s-1NAME\s0\fR and globally) a
backend for output trap layers.  When called with a single argument,
looks up and returns the backend registered by \fI\s-1NAME\s0\fR (or undef).
.PP
When a layer using this backend is applied, the \fI\s-1CODE\s0\fR will be called
on the trap object, with the layer name and the output handle's fileno
and globref as arguments.
.SS "first_output_layer_backend \s-1SPEC\s0"
.IX Subsection "first_output_layer_backend SPEC"
Where \fI\s-1SPEC\s0\fR is empty, just returns.
.PP
Where \fI\s-1SPEC\s0\fR is a string of comma-or-semicolon separated backend
names, runs through the names, returning the first implementation it
finds.  Dies if no implementation is found by any of these names.
.SS "multi_layer \s-1NAME, LAYERS\s0"
.IX Subsection "multi_layer NAME, LAYERS"
Registers (by \fI\s-1NAME\s0\fR) a layer that just pushes a number of other
\&\fI\s-1LAYERS\s0\fR on the stack of layers.  If any of the \fI\s-1LAYERS\s0\fR is neither
an anonymous method nor the name of a layer registered to the caller
or a trapper it inherits from, an exception is raised.
.SS "layer_implementation \s-1TRAPPER, LAYERS\s0"
.IX Subsection "layer_implementation TRAPPER, LAYERS"
Returns the subroutines that implement the requested \fI\s-1LAYERS\s0\fR.  If
any of the \fI\s-1LAYERS\s0\fR is neither an anonymous method nor the name of a
layer registered to or inherited by the \fI\s-1TRAPPER\s0\fR, an exception is
raised.
.SS "accessor \s-1NAMED_ARGS\s0"
.IX Subsection "accessor NAMED_ARGS"
Generates and registers any number of accessors according to the
\&\fI\s-1NAMED_ARGS\s0\fR, and also generates the proper test methods for these
accessors (see below).
.PP
The following named arguments are recognized:
.IP "is_leaveby" 4
.IX Item "is_leaveby"
If true, the tests methods will generate better diagnostics if the
trap was not left as specified.  Also, a special did_\fI\s-1ACCESSOR\s0\fR test
method will be generated (unless already present), simply passing as
long as the trap was left as specified.
.IP "is_array" 4
.IX Item "is_array"
If true, the simple accessor(s) will be smart about context and
arguments, returning an arrayref on no argument (in any context), an
array slice in list context (on any number of arguments), and the
element indexed by the first argument otherwise.
.IP "simple" 4
.IX Item "simple"
Should be a reference to an array of accessor names.  For each name,
an accessor (assuming hash based trap object with accessor names as
keys), will be generated and registered.
.IP "flexible" 4
.IX Item "flexible"
Should be a reference to a hash.  For each pair, a name and an
implementation, an accessor is generated and registered.
.SS "test \s-1NAME, ARGSPEC, CODE\s0"
.IX Subsection "test NAME, ARGSPEC, CODE"
Registers a test callback by \fI\s-1NAME\s0\fR and to the calling trapper.
.PP
Trappers inherit test callbacks like methods (though they are not
implemented as such; don't expect to find them in the symbol table).
.PP
Test methods of the form \fI\s-1ACCESSOR\s0\fR_\fI\s-1TEST\s0\fR will be made available
(directly or by inheritance) to every trapper that registers or
inherits both the accessor named \fI\s-1ACCESSOR\s0\fR and the test named
\&\fI\s-1TEST\s0\fR.
.PP
(In more detail, the method will be generated in every trapper that
either (1) registers both the test and the accessor, or (2) registers
either and inherits the other.)
.PP
When the test method is called, any implicit leaveby condition will be
tested first, and if it passes (or there were none), the \fI\s-1CODE\s0\fR is
called with arguments according to the words found in the \fI\s-1ARGSPEC\s0\fR
string:
.IP "trap" 4
.IX Item "trap"
The trap object.
.IP "entirety" 4
.IX Item "entirety"
The \fI\s-1ACCESSOR\s0\fR's return value when called without arguments.
.IP "element" 4
.IX Item "element"
The \fI\s-1ACCESSOR\s0\fR's return value when called with index, if applicable
(i.e. for array accessors).  Index is not applicable to scalar
accessors, so such are still called without index.
.Sp
The index, when applicable, will be taken from the test method's
arguments.
.IP "predicate" 4
.IX Item "predicate"
What the \fI\s-1ACCESSOR\s0\fR's return value should be tested against (taken
from the test method's arguments).  (There may be any fixed number of
predicates.)
.IP "name" 4
.IX Item "name"
The test name (taken from the test method's arguments).
.SH "EXAMPLE"
.IX Header "EXAMPLE"
A complete example, implementing a \fItimeout\fR layer (depending on
Time::HiRes::ualarm being present), a \fIsimpletee\fR layer (printing the
trapped stdout/stderr to the original file handles after the trap has
sprung), and a \fIcmp_ok\fR test method template:
.PP
.Vb 3
\&  package My::Test::Trap;
\&  use base \*(AqTest::Trap\*(Aq; # for example
\&  use Test::Trap::Builder;
\&
\&  my $B = Test::Trap::Builder\->new;
\&
\&  # example (layer:timeout):
\&  use Time::HiRes qw/ualarm/;
\&  $B\->layer( timeout => $_ ) for sub {
\&    my $self = shift;
\&    eval {
\&      local $SIG{ALRM} = sub {
\&        $self\->{timeout} = 1; # simple truth
\&        $SIG{ALRM} = sub {die};
\&        die;
\&      };
\&      ualarm 1000, 1; # one second max, then die repeatedly!
\&      $self\->Next;
\&    };
\&    alarm 0;
\&    if ($self\->{timeout}) {
\&      $self\->{leaveby} = \*(Aqtimeout\*(Aq;
\&      delete $self\->{$_} for qw/ die exit return /;
\&    }
\&  };
\&  $B\->accessor( is_leaveby => 1,
\&                simple => [\*(Aqtimeout\*(Aq],
\&              );
\&
\&  # example (layer:simpletee):
\&  $B\->layer( simpletee => $_ ) for sub {
\&    my $self = shift;
\&    for (qw/ stdout stderr /) {
\&      exists $self\->{$_} or $self\->Exception("Too late to tee $_");
\&    }
\&    $self\->Teardown($_) for sub {
\&      print STDOUT $self\->{stdout} if exists $self\->{stdout};
\&      print STDERR $self\->{stderr} if exists $self\->{stderr};
\&    };
\&    $self\->Next;
\&  };
\&  # no accessor for this layer
\&
\&  $B\->multi_layer( flow => qw/ raw die exit timeout / );
\&  $B\->multi_layer( default => qw/ flow stdout stderr warn simpletee / );
\&
\&  $B\->test_method( cmp_ok => 1, 2, \e&Test::More::cmp_ok );
.Ve
.SH "CAVEATS"
.IX Header "CAVEATS"
The interface of this module is likely to remain somewhat in flux for
a while yet.
.PP
The different implementations of output trap layers have their own
caveats; see Test::Trap::Builder::Tempfile,
Test::Trap::Builder::PerlIO, Test::Trap::Builder::SystemSafe.
.PP
Multiple inheritance is not (yet?) fully supported.  If one parent has
registered a test callback \f(CW\*(C`X\*(C'\fR and another has registered an accessor
\&\f(CW\*(C`Y\*(C'\fR, the test method \f(CW\*(C`Y_X\*(C'\fR will not be generated.
.PP
Threads?  No idea.  It might even work correctly.
.SH "BUGS"
.IX Header "BUGS"
Please report any bugs or feature requests directly to the author.
.SH "AUTHOR"
.IX Header "AUTHOR"
Eirik Berg Hanssen, \f(CW\*(C`<ebhanssen@allverden.no>\*(C'\fR
.SH "COPYRIGHT & LICENSE"
.IX Header "COPYRIGHT & LICENSE"
Copyright 2006\-2012 Eirik Berg Hanssen, All Rights Reserved.
.PP
This program is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.
