.TH "MPSNNFilterNode" 3 "Mon Jul 9 2018" "Version MetalPerformanceShaders-119.3" "MetalPerformanceShaders.framework" \" -*- nroff -*-
.ad l
.nh
.SH NAME
MPSNNFilterNode
.SH SYNOPSIS
.br
.PP
.PP
\fC#import <MPSNNGraphNodes\&.h>\fP
.PP
Inherits NSObject\&.
.PP
Inherited by \fBMPSCNNBatchNormalizationNode\fP, \fBMPSCNNConvolutionNode\fP, \fBMPSCNNDilatedPoolingMaxNode\fP, \fBMPSCNNDropoutNode\fP, \fBMPSCNNInstanceNormalizationNode\fP, \fBMPSCNNLogSoftMaxNode\fP, \fBMPSCNNLossNode\fP, \fBMPSCNNNeuronNode\fP, \fBMPSCNNNormalizationNode\fP, \fBMPSCNNPoolingNode\fP, \fBMPSCNNSoftMaxNode\fP, \fBMPSCNNUpsamplingBilinearNode\fP, \fBMPSCNNUpsamplingNearestNode\fP, \fBMPSCNNYOLOLossNode\fP, \fBMPSNNBinaryArithmeticNode\fP, \fBMPSNNConcatenationNode\fP, \fBMPSNNGradientFilterNode\fP, and \fBMPSNNScaleNode\fP\&.
.SS "Instance Methods"

.in +1c
.ti -1c
.RI "(nonnull instancetype) \- \fBinit\fP"
.br
.ti -1c
.RI "(\fBMPSNNGradientFilterNode\fP *__nonnull) \- \fBgradientFilterWithSource:\fP"
.br
.ti -1c
.RI "(\fBMPSNNGradientFilterNode\fP *__nonnull) \- \fBgradientFilterWithSources:\fP"
.br
.ti -1c
.RI "(NSArray< \fBMPSNNGradientFilterNode\fP * > *__nonnull) \- \fBgradientFiltersWithSources:\fP"
.br
.ti -1c
.RI "(NSArray< \fBMPSNNGradientFilterNode\fP * > *__nonnull) \- \fBgradientFiltersWithSource:\fP"
.br
.ti -1c
.RI "(NSArray< \fBMPSNNFilterNode\fP * > *__nullable) \- \fBtrainingGraphWithSourceGradient:nodeHandler:\fP"
.br
.in -1c
.SS "Properties"

.in +1c
.ti -1c
.RI "\fBMPSNNImageNode\fP * \fBresultImage\fP"
.br
.ti -1c
.RI "\fBMPSNNStateNode\fP * \fBresultState\fP"
.br
.ti -1c
.RI "NSArray< \fBMPSNNStateNode\fP * > * \fBresultStates\fP"
.br
.ti -1c
.RI "id< \fBMPSNNPadding\fP > \fBpaddingPolicy\fP"
.br
.ti -1c
.RI "NSString * \fBlabel\fP"
.br
.in -1c
.SH "Detailed Description"
.PP 
\fBA\fP placeholder node denoting a neural network filter stage  There are as many \fBMPSNNFilterNode\fP subclasses as there are MPS neural network filter objects\&. Make one of those\&. This class defines an polymorphic interface for them\&. 
.SH "Method Documentation"
.PP 
.SS "\- (NSArray <\fBMPSNNGradientFilterNode\fP*> * __nonnull) gradientFiltersWithSource: (\fBMPSNNImageNode\fP *__nonnull) gradientImage"
Return multiple gradient versions of the filter  MPSNNFilters that consume multiple inputs generally result in multiple conjugate filters for the gradient computation at the end of training\&. For example, a single concatenation operation that concatenates multple images will result in an array of slice operators that carve out subsections of the input gradient image\&. 
.PP
Reimplemented in \fBMPSNNGradientFilterNode\fP\&.
.SS "\- (NSArray <\fBMPSNNGradientFilterNode\fP*> * __nonnull) gradientFiltersWithSources: (NSArray< \fBMPSNNImageNode\fP * > *__nonnull) gradientImages"
Return multiple gradient versions of the filter  MPSNNFilters that consume multiple inputs generally result in multiple conjugate filters for the gradient computation at the end of training\&. For example, a single concatenation operation that concatenates multple images will result in an array of slice operators that carve out subsections of the input gradient image\&. 
.PP
Reimplemented in \fBMPSNNBinaryArithmeticNode\fP, and \fBMPSNNGradientFilterNode\fP\&.
.SS "\- (\fBMPSNNGradientFilterNode\fP*__nonnull) gradientFilterWithSource: (\fBMPSNNImageNode\fP *__nonnull) gradientImage"
Return the gradient (backwards) version of this filter\&.  The backwards training version of the filter will be returned\&. The non-gradient image and state arguments for the filter are automatically obtained from the target\&. 
.PP
\fBParameters:\fP
.RS 4
\fIgradientImage\fP The gradient images corresponding with the resultImage of the target 
.RE
.PP

.PP
Reimplemented in \fBMPSNNGradientFilterNode\fP\&.
.SS "\- (\fBMPSNNGradientFilterNode\fP*__nonnull) gradientFilterWithSources: (NSArray< \fBMPSNNImageNode\fP * > *__nonnull) gradientImages"
Return the gradient (backwards) version of this filter\&.  The backwards training version of the filter will be returned\&. The non-gradient image and state arguments for the filter are automatically obtained from the target\&. 
.PP
\fBParameters:\fP
.RS 4
\fIgradientImages\fP The gradient images corresponding with the resultImage of the target 
.RE
.PP

.PP
Reimplemented in \fBMPSCNNYOLOLossNode\fP, \fBMPSNNConcatenationNode\fP, \fBMPSCNNLossNode\fP, \fBMPSNNBinaryArithmeticNode\fP, and \fBMPSNNGradientFilterNode\fP\&.
.SS "\- (nonnull instancetype) init "

.PP
Reimplemented in \fBMPSCNNNeuronGradientNode\fP, and \fBMPSCNNNeuronNode\fP\&.
.SS "\- (NSArray <\fBMPSNNFilterNode\fP*> * __nullable) trainingGraphWithSourceGradient: (\fBMPSNNImageNode\fP *__nullable) gradientImage(__nullable \fBMPSGradientNodeBlock\fP) nodeHandler"
Build training graph from inference graph  This method will iteratively build the training potion of a graph based on an inference graph\&. Self should be the last node in the inference graph\&. It is typically a loss layer, but can be anything\&. Typically, the 'inference graph' used here is the desired inference graph with a dropout node and a loss layer node appended\&.
.PP
BUG: This method can not follow links to regions of the graph that are connected to the rest of the graph solely via MPSNNStateNodes\&. \fBA\fP gradient image input is required to construct a \fBMPSNNGradientFilterNode\fP from a inference filter node\&.
.PP
\fBParameters:\fP
.RS 4
\fIgradientImage\fP The input gradient image for the first gradient node in the training section of the graph\&. If nil, self\&.resultImage is used\&. This results in a standard monolithic training graph\&. If the graph is instead divided into multiple subgraphs (potentially to allow for your custom code to appear inbetween \fBMPSNNGraph\fP segments) a new MPSImageNode* may be substituted\&. 
.br
\fInodeHandler\fP An optional block to allow for customization of gradient nodes and intermediate images as the graph is constructed\&. It may also be used to prune braches of the developing training graph\&. If nil, the default handler is used\&. It builds the full graph, and assigns any inferenceNodeSources[i]\&.handle to their gradient counterparts\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
The list of new \fBMPSNNFilterNode\fP training graph termini\&. These MPSNNFilterNodes are not necessarily all MPSNNGradientFilterNodes\&. To build a full list of nodes created, use a custom nodeHandler\&. If no nodes are created nil is returned\&. 
.RE
.PP

.SH "Property Documentation"
.PP 
.SS "\- label\fC [read]\fP, \fC [write]\fP, \fC [atomic]\fP, \fC [copy]\fP"
\fBA\fP string to help identify this object\&. 
.SS "\- (id<\fBMPSNNPadding\fP>) paddingPolicy\fC [read]\fP, \fC [write]\fP, \fC [nonatomic]\fP, \fC [retain]\fP"
The padding method used for the filter node  The padding policy configures how the filter centers the region of interest in the source image\&. It principally is responsible for setting the \fBMPSCNNKernel\&.offset\fP and the size of the image produced, and sometimes will also configure \&.sourceFeatureChannelOffset, \&.sourceFeatureChannelMaxCount, and \&.edgeMode\&. It is permitted to set any other filter properties as needed using a custom padding policy\&. The default padding policy varies per filter to conform to consensus expectation for the behavior of that filter\&. In some cases, pre-made padding policies are provided to match the behavior of common neural networking frameworks with particularly complex or unexpected behavior for specific nodes\&. See \fBMPSNNDefaultPadding\fP class methods in \fBMPSNeuralNetworkTypes\&.h\fP for more\&.
.PP
BUG: MPS doesn't provide a good way to reset the \fBMPSKernel\fP properties in the context of a \fBMPSNNGraph\fP after the kernel is finished encoding\&. These values carry on to the next time the graph is used\&. Consequently, if your custom padding policy modifies the property as a function of the previous value, e\&.g\&.: 
.PP
.nf
kernel.someProperty += 2;

.fi
.PP
.PP
then the second time the graph runs, the property may have an inconsistent value, leading to unexpected behavior\&. The default padding computation runs before the custom padding method to provide it with a sense of what is expected for the default configuration and will reinitialize the value in the case of the \&.offset\&. However, that computation usually doesn't reset other properties\&. In such cases, the custom padding policy may need to keep a record of the original value to enable consistent behavior\&. 
.SS "\- (\fBMPSNNImageNode\fP*) resultImage\fC [read]\fP, \fC [nonatomic]\fP, \fC [assign]\fP"
Get the node representing the image result of the filter  Except where otherwise noted, the precision used for the result image (see format property) is copied from the precision from the first input image node\&. 
.SS "\- (\fBMPSNNStateNode\fP*) resultState\fC [read]\fP, \fC [nonatomic]\fP, \fC [assign]\fP"
convenience method for resultStates[0]  If resultStates is nil, returns nil 
.SS "\- (NSArray<\fBMPSNNStateNode\fP*>*) resultStates\fC [read]\fP, \fC [nonatomic]\fP, \fC [assign]\fP"
Get the node representing the state result of the filter  If more than one, see description of subclass for ordering\&. 

.SH "Author"
.PP 
Generated automatically by Doxygen for MetalPerformanceShaders\&.framework from the source code\&.
