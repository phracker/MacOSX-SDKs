.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PerlIO 3pm"
.TH PerlIO 3pm "2014-09-30" "perl v5.18.4" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
PerlIO \- On demand loader for PerlIO layers and root of PerlIO::* name space
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  open($fh,"<:crlf", "my.txt"); # support platform\-native and CRLF text files
\&
\&  open($fh,"<","his.jpg");      # portably open a binary file for reading
\&  binmode($fh);
\&
\&  Shell:
\&    PERLIO=perlio perl ....
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
When an undefined layer 'foo' is encountered in an \f(CW\*(C`open\*(C'\fR or
\&\f(CW\*(C`binmode\*(C'\fR layer specification then C code performs the equivalent of:
.PP
.Vb 1
\&  use PerlIO \*(Aqfoo\*(Aq;
.Ve
.PP
The perl code in PerlIO.pm then attempts to locate a layer by doing
.PP
.Vb 1
\&  require PerlIO::foo;
.Ve
.PP
Otherwise the \f(CW\*(C`PerlIO\*(C'\fR package is a place holder for additional
PerlIO related functions.
.PP
The following layers are currently defined:
.IP ":unix" 4
.IX Item ":unix"
Lowest level layer which provides basic PerlIO operations in terms of
\&\s-1UNIX/POSIX\s0 numeric file descriptor calls
(\fIopen()\fR, \fIread()\fR, \fIwrite()\fR, \fIlseek()\fR, \fIclose()\fR).
.IP ":stdio" 4
.IX Item ":stdio"
Layer which calls \f(CW\*(C`fread\*(C'\fR, \f(CW\*(C`fwrite\*(C'\fR and \f(CW\*(C`fseek\*(C'\fR/\f(CW\*(C`ftell\*(C'\fR etc.  Note
that as this is \*(L"real\*(R" stdio it will ignore any layers beneath it and
go straight to the operating system via the C library as usual.
.IP ":perlio" 4
.IX Item ":perlio"
A from scratch implementation of buffering for PerlIO. Provides fast
access to the buffer for \f(CW\*(C`sv_gets\*(C'\fR which implements perl's readline/<>
and in general attempts to minimize data copying.
.Sp
\&\f(CW\*(C`:perlio\*(C'\fR will insert a \f(CW\*(C`:unix\*(C'\fR layer below itself to do low level \s-1IO.\s0
.IP ":crlf" 4
.IX Item ":crlf"
A layer that implements DOS/Windows like \s-1CRLF\s0 line endings.  On read
converts pairs of \s-1CR,LF\s0 to a single \*(L"\en\*(R" newline character.  On write
converts each \*(L"\en\*(R" to a \s-1CR,LF\s0 pair.  Note that this layer will silently
refuse to be pushed on top of itself.
.Sp
It currently does \fInot\fR mimic MS-DOS as far as treating of Control-Z
as being an end-of-file marker.
.Sp
Based on the \f(CW\*(C`:perlio\*(C'\fR layer.
.IP ":utf8" 4
.IX Item ":utf8"
Declares that the stream accepts perl's \fIinternal\fR encoding of
characters.  (Which really is \s-1UTF\-8\s0 on \s-1ASCII\s0 machines, but is
UTF-EBCDIC on \s-1EBCDIC\s0 machines.)  This allows any character perl can
represent to be read from or written to the stream. The UTF-X encoding
is chosen to render simple text parts (i.e.  non-accented letters,
digits and common punctuation) human readable in the encoded file.
.Sp
Here is how to write your native data out using \s-1UTF\-8 \s0(or UTF-EBCDIC)
and then read it back in.
.Sp
.Vb 3
\&        open(F, ">:utf8", "data.utf");
\&        print F $out;
\&        close(F);
\&
\&        open(F, "<:utf8", "data.utf");
\&        $in = <F>;
\&        close(F);
.Ve
.Sp
Note that this layer does not validate byte sequences. For reading
input, using \f(CW\*(C`:encoding(utf8)\*(C'\fR instead of bare \f(CW\*(C`:utf8\*(C'\fR is strongly
recommended.
.IP ":bytes" 4
.IX Item ":bytes"
This is the inverse of the \f(CW\*(C`:utf8\*(C'\fR layer. It turns off the flag
on the layer below so that data read from it is considered to
be \*(L"octets\*(R" i.e. characters in the range 0..255 only. Likewise
on output perl will warn if a \*(L"wide\*(R" character is written
to a such a stream.
.IP ":raw" 4
.IX Item ":raw"
The \f(CW\*(C`:raw\*(C'\fR layer is \fIdefined\fR as being identical to calling
\&\f(CW\*(C`binmode($fh)\*(C'\fR \- the stream is made suitable for passing binary data,
i.e. each byte is passed as-is. The stream will still be
buffered.
.Sp
In Perl 5.6 and some books the \f(CW\*(C`:raw\*(C'\fR layer (previously sometimes also
referred to as a \*(L"discipline\*(R") is documented as the inverse of the
\&\f(CW\*(C`:crlf\*(C'\fR layer. That is no longer the case \- other layers which would
alter the binary nature of the stream are also disabled.  If you want \s-1UNIX\s0
line endings on a platform that normally does \s-1CRLF\s0 translation, but still
want \s-1UTF\-8\s0 or encoding defaults, the appropriate thing to do is to add
\&\f(CW\*(C`:perlio\*(C'\fR to the \s-1PERLIO\s0 environment variable.
.Sp
The implementation of \f(CW\*(C`:raw\*(C'\fR is as a pseudo-layer which when \*(L"pushed\*(R"
pops itself and then any layers which do not declare themselves as suitable
for binary data. (Undoing :utf8 and :crlf are implemented by clearing
flags rather than popping layers but that is an implementation detail.)
.Sp
As a consequence of the fact that \f(CW\*(C`:raw\*(C'\fR normally pops layers,
it usually only makes sense to have it as the only or first element in
a layer specification.  When used as the first element it provides
a known base on which to build e.g.
.Sp
.Vb 1
\&    open($fh,":raw:utf8",...)
.Ve
.Sp
will construct a \*(L"binary\*(R" stream, but then enable \s-1UTF\-8\s0 translation.
.IP ":pop" 4
.IX Item ":pop"
A pseudo layer that removes the top-most layer. Gives perl code
a way to manipulate the layer stack. Should be considered
as experimental. Note that \f(CW\*(C`:pop\*(C'\fR only works on real layers
and will not undo the effects of pseudo layers like \f(CW\*(C`:utf8\*(C'\fR.
An example of a possible use might be:
.Sp
.Vb 5
\&    open($fh,...)
\&    ...
\&    binmode($fh,":encoding(...)");  # next chunk is encoded
\&    ...
\&    binmode($fh,":pop");            # back to un\-encoded
.Ve
.Sp
A more elegant (and safer) interface is needed.
.IP ":win32" 4
.IX Item ":win32"
On Win32 platforms this \fIexperimental\fR layer uses the native \*(L"handle\*(R" \s-1IO\s0
rather than the unix-like numeric file descriptor layer. Known to be
buggy as of perl 5.8.2.
.SS "Custom Layers"
.IX Subsection "Custom Layers"
It is possible to write custom layers in addition to the above builtin
ones, both in C/XS and Perl.  Two such layers (and one example written
in Perl using the latter) come with the Perl distribution.
.IP ":encoding" 4
.IX Item ":encoding"
Use \f(CW\*(C`:encoding(ENCODING)\*(C'\fR either in \fIopen()\fR or \fIbinmode()\fR to install
a layer that transparently does character set and encoding transformations,
for example from Shift-JIS to Unicode.  Note that under \f(CW\*(C`stdio\*(C'\fR
an \f(CW\*(C`:encoding\*(C'\fR also enables \f(CW\*(C`:utf8\*(C'\fR.  See PerlIO::encoding
for more information.
.IP ":mmap" 4
.IX Item ":mmap"
A layer which implements \*(L"reading\*(R" of files by using \f(CW\*(C`mmap()\*(C'\fR to
make a (whole) file appear in the process's address space, and then
using that as PerlIO's \*(L"buffer\*(R". This \fImay\fR be faster in certain
circumstances for large files, and may result in less physical memory
use when multiple processes are reading the same file.
.Sp
Files which are not \f(CW\*(C`mmap()\*(C'\fR\-able revert to behaving like the \f(CW\*(C`:perlio\*(C'\fR
layer. Writes also behave like the \f(CW\*(C`:perlio\*(C'\fR layer, as \f(CW\*(C`mmap()\*(C'\fR for write
needs extra house-keeping (to extend the file) which negates any advantage.
.Sp
The \f(CW\*(C`:mmap\*(C'\fR layer will not exist if the platform does not support \f(CW\*(C`mmap()\*(C'\fR.
.IP ":via" 4
.IX Item ":via"
Use \f(CW\*(C`:via(MODULE)\*(C'\fR either in \fIopen()\fR or \fIbinmode()\fR to install a layer
that does whatever transformation (for example compression /
decompression, encryption / decryption) to the filehandle.
See PerlIO::via for more information.
.SS "Alternatives to raw"
.IX Subsection "Alternatives to raw"
To get a binary stream an alternate method is to use:
.PP
.Vb 2
\&    open($fh,"whatever")
\&    binmode($fh);
.Ve
.PP
this has the advantage of being backward compatible with how such things have
had to be coded on some platforms for years.
.PP
To get an unbuffered stream specify an unbuffered layer (e.g. \f(CW\*(C`:unix\*(C'\fR)
in the open call:
.PP
.Vb 1
\&    open($fh,"<:unix",$path)
.Ve
.SS "Defaults and how to override them"
.IX Subsection "Defaults and how to override them"
If the platform is MS-DOS like and normally does \s-1CRLF\s0 to \*(L"\en\*(R"
translation for text files then the default layers are :
.PP
.Vb 1
\&  unix crlf
.Ve
.PP
(The low level \*(L"unix\*(R" layer may be replaced by a platform specific low
level layer.)
.PP
Otherwise if \f(CW\*(C`Configure\*(C'\fR found out how to do \*(L"fast\*(R" \s-1IO\s0 using the system's
stdio, then the default layers are:
.PP
.Vb 1
\&  unix stdio
.Ve
.PP
Otherwise the default layers are
.PP
.Vb 1
\&  unix perlio
.Ve
.PP
These defaults may change once perlio has been better tested and tuned.
.PP
The default can be overridden by setting the environment variable
\&\s-1PERLIO\s0 to a space separated list of layers (\f(CW\*(C`unix\*(C'\fR or platform low
level layer is always pushed first).
.PP
This can be used to see the effect of/bugs in the various layers e.g.
.PP
.Vb 3
\&  cd .../perl/t
\&  PERLIO=stdio  ./perl harness
\&  PERLIO=perlio ./perl harness
.Ve
.PP
For the various values of \s-1PERLIO\s0 see \*(L"\s-1PERLIO\*(R"\s0 in perlrun.
.SS "Querying the layers of filehandles"
.IX Subsection "Querying the layers of filehandles"
The following returns the \fBnames\fR of the PerlIO layers on a filehandle.
.PP
.Vb 1
\&   my @layers = PerlIO::get_layers($fh); # Or FH, *FH, "FH".
.Ve
.PP
The layers are returned in the order an \fIopen()\fR or \fIbinmode()\fR call would
use them.  Note that the \*(L"default stack\*(R" depends on the operating
system and on the Perl version, and both the compile-time and
runtime configurations of Perl.
.PP
The following table summarizes the default layers on UNIX-like and
DOS-like platforms and depending on the setting of \f(CW$ENV{PERLIO}\fR:
.PP
.Vb 5
\& PERLIO     UNIX\-like                   DOS\-like
\& \-\-\-\-\-\-     \-\-\-\-\-\-\-\-\-                   \-\-\-\-\-\-\-\-
\& unset / "" unix perlio / stdio [1]     unix crlf
\& stdio      unix perlio / stdio [1]     stdio
\& perlio     unix perlio                 unix perlio
\&
\& # [1] "stdio" if Configure found out how to do "fast stdio" (depends
\& # on the stdio implementation) and in Perl 5.8, otherwise "unix perlio"
.Ve
.PP
By default the layers from the input side of the filehandle are
returned; to get the output side, use the optional \f(CW\*(C`output\*(C'\fR argument:
.PP
.Vb 1
\&   my @layers = PerlIO::get_layers($fh, output => 1);
.Ve
.PP
(Usually the layers are identical on either side of a filehandle but
for example with sockets there may be differences, or if you have
been using the \f(CW\*(C`open\*(C'\fR pragma.)
.PP
There is no \fIset_layers()\fR, nor does \fIget_layers()\fR return a tied array
mirroring the stack, or anything fancy like that.  This is not
accidental or unintentional.  The PerlIO layer stack is a bit more
complicated than just a stack (see for example the behaviour of \f(CW\*(C`:raw\*(C'\fR).
You are supposed to use \fIopen()\fR and \fIbinmode()\fR to manipulate the stack.
.PP
\&\fBImplementation details follow, please close your eyes.\fR
.PP
The arguments to layers are by default returned in parentheses after
the name of the layer, and certain layers (like \f(CW\*(C`utf8\*(C'\fR) are not real
layers but instead flags on real layers; to get all of these returned
separately, use the optional \f(CW\*(C`details\*(C'\fR argument:
.PP
.Vb 1
\&   my @layer_and_args_and_flags = PerlIO::get_layers($fh, details => 1);
.Ve
.PP
The result will be up to be three times the number of layers:
the first element will be a name, the second element the arguments
(unspecified arguments will be \f(CW\*(C`undef\*(C'\fR), the third element the flags,
the fourth element a name again, and so forth.
.PP
\&\fBYou may open your eyes now.\fR
.SH "AUTHOR"
.IX Header "AUTHOR"
Nick Ing-Simmons <nick@ing\-simmons.net>
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\*(L"binmode\*(R" in perlfunc, \*(L"open\*(R" in perlfunc, perlunicode, perliol,
Encode
