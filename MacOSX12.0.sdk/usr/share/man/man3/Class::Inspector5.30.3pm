.\" Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Class::Inspector 3"
.TH Class::Inspector 3 "2019-07-19" "perl v5.30.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Class::Inspector \- Get information about a class and its structure
.SH "VERSION"
.IX Header "VERSION"
version 1.36
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use Class::Inspector;
\&  
\&  # Is a class installed and/or loaded
\&  Class::Inspector\->installed( \*(AqFoo::Class\*(Aq );
\&  Class::Inspector\->loaded( \*(AqFoo::Class\*(Aq );
\&  
\&  # Filename related information
\&  Class::Inspector\->filename( \*(AqFoo::Class\*(Aq );
\&  Class::Inspector\->resolved_filename( \*(AqFoo::Class\*(Aq );
\&  
\&  # Get subroutine related information
\&  Class::Inspector\->functions( \*(AqFoo::Class\*(Aq );
\&  Class::Inspector\->function_refs( \*(AqFoo::Class\*(Aq );
\&  Class::Inspector\->function_exists( \*(AqFoo::Class\*(Aq, \*(Aqbar\*(Aq );
\&  Class::Inspector\->methods( \*(AqFoo::Class\*(Aq, \*(Aqfull\*(Aq, \*(Aqpublic\*(Aq );
\&  
\&  # Find all loaded subclasses or something
\&  Class::Inspector\->subclasses( \*(AqFoo::Class\*(Aq );
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Class::Inspector allows you to get information about a loaded class. Most or
all of this information can be found in other ways, but they aren't always
very friendly, and usually involve a relatively high level of Perl wizardry,
or strange and unusual looking code. Class::Inspector attempts to provide
an easier, more friendly interface to this information.
.SH "METHODS"
.IX Header "METHODS"
.SS "installed"
.IX Subsection "installed"
.Vb 1
\& my $bool = Class::Inspector\->installed($class);
.Ve
.PP
The \f(CW\*(C`installed\*(C'\fR static method tries to determine if a class is installed
on the machine, or at least available to Perl. It does this by wrapping
around \f(CW\*(C`resolved_filename\*(C'\fR.
.PP
Returns true if installed/available, false if the class is not installed,
or \f(CW\*(C`undef\*(C'\fR if the class name is invalid.
.SS "loaded"
.IX Subsection "loaded"
.Vb 1
\& my $bool = Class::Inspector\->loaded($class);
.Ve
.PP
The \f(CW\*(C`loaded\*(C'\fR static method tries to determine if a class is loaded by
looking for symbol table entries.
.PP
This method it uses to determine this will work even if the class does not
have its own file, but is contained inside a single file with multiple
classes in it. Even in the case of some sort of run-time loading class
being used, these typically leave some trace in the symbol table, so an
Autoload or Class::Autouse\-based class should correctly appear
loaded.
.PP
Returns true if the class is loaded, false if not, or \f(CW\*(C`undef\*(C'\fR if the
class name is invalid.
.SS "filename"
.IX Subsection "filename"
.Vb 1
\& my $filename = Class::Inspector\->filename($class);
.Ve
.PP
For a given class, returns the base filename for the class. This will \s-1NOT\s0
be a fully resolved filename, just the part of the filename \s-1BELOW\s0 the
\&\f(CW@INC\fR entry.
.PP
.Vb 2
\&  print Class\->filename( \*(AqFoo::Bar\*(Aq );
\&  > Foo/Bar.pm
.Ve
.PP
This filename will be returned with the right separator for the local
platform, and should work on all platforms.
.PP
Returns the filename on success or \f(CW\*(C`undef\*(C'\fR if the class name is invalid.
.SS "resolved_filename"
.IX Subsection "resolved_filename"
.Vb 2
\& my $filename = Class::Inspector\->resolved_filename($class);
\& my $filename = Class::Inspector\->resolved_filename($class, @try_first);
.Ve
.PP
For a given class, the \f(CW\*(C`resolved_filename\*(C'\fR static method returns the fully
resolved filename for a class. That is, the file that the class would be
loaded from.
.PP
This is not necessarily the file that the class \s-1WAS\s0 loaded from, as the
value returned is determined each time it runs, and the \f(CW@INC\fR include
path may change.
.PP
To get the actual file for a loaded class, see the \f(CW\*(C`loaded_filename\*(C'\fR
method.
.PP
Returns the filename for the class, or \f(CW\*(C`undef\*(C'\fR if the class name is
invalid.
.SS "loaded_filename"
.IX Subsection "loaded_filename"
.Vb 1
\& my $filename = Class::Inspector\->loaded_filename($class);
.Ve
.PP
For a given loaded class, the \f(CW\*(C`loaded_filename\*(C'\fR static method determines
(via the \f(CW%INC\fR hash) the name of the file that it was originally loaded
from.
.PP
Returns a resolved file path, or false if the class did not have it's own
file.
.SS "functions"
.IX Subsection "functions"
.Vb 1
\& my $arrayref = Class::Inspector\->functions($class);
.Ve
.PP
For a loaded class, the \f(CW\*(C`functions\*(C'\fR static method returns a list of the
names of all the functions in the classes immediate namespace.
.PP
Note that this is not the \s-1METHODS\s0 of the class, just the functions.
.PP
Returns a reference to an array of the function names on success, or \f(CW\*(C`undef\*(C'\fR
if the class name is invalid or the class is not loaded.
.SS "function_refs"
.IX Subsection "function_refs"
.Vb 1
\& my $arrayref = Class::Inspector\->function_refs($class);
.Ve
.PP
For a loaded class, the \f(CW\*(C`function_refs\*(C'\fR static method returns references to
all the functions in the classes immediate namespace.
.PP
Note that this is not the \s-1METHODS\s0 of the class, just the functions.
.PP
Returns a reference to an array of \f(CW\*(C`CODE\*(C'\fR refs of the functions on
success, or \f(CW\*(C`undef\*(C'\fR if the class is not loaded.
.SS "function_exists"
.IX Subsection "function_exists"
.Vb 1
\& my $bool = Class::Inspector\->function_exists($class, $functon);
.Ve
.PP
Given a class and function name the \f(CW\*(C`function_exists\*(C'\fR static method will
check to see if the function exists in the class.
.PP
Note that this is as a function, not as a method. To see if a method
exists for a class, use the \f(CW\*(C`can\*(C'\fR method for any class or object.
.PP
Returns true if the function exists, false if not, or \f(CW\*(C`undef\*(C'\fR if the
class or function name are invalid, or the class is not loaded.
.SS "methods"
.IX Subsection "methods"
.Vb 1
\& my $arrayref = Class::Inspector\->methods($class, @options);
.Ve
.PP
For a given class name, the \f(CW\*(C`methods\*(C'\fR static method will returns \s-1ALL\s0
the methods available to that class. This includes all methods available
from every class up the class' \f(CW@ISA\fR tree.
.PP
Returns a reference to an array of the names of all the available methods
on success, or \f(CW\*(C`undef\*(C'\fR if the class name is invalid or the class is not
loaded.
.PP
A number of options are available to the \f(CW\*(C`methods\*(C'\fR method that will alter
the results returned. These should be listed after the class name, in any
order.
.PP
.Vb 2
\&  # Only get public methods
\&  my $method = Class::Inspector\->methods( \*(AqMy::Class\*(Aq, \*(Aqpublic\*(Aq );
.Ve
.IP "public" 4
.IX Item "public"
The \f(CW\*(C`public\*(C'\fR option will return only 'public' methods, as defined by the Perl
convention of prepending an underscore to any 'private' methods. The \f(CW\*(C`public\*(C'\fR
option will effectively remove any methods that start with an underscore.
.IP "private" 4
.IX Item "private"
The \f(CW\*(C`private\*(C'\fR options will return only 'private' methods, as defined by the
Perl convention of prepending an underscore to an private methods. The
\&\f(CW\*(C`private\*(C'\fR option will effectively remove an method that do not start with an
underscore.
.Sp
\&\fBNote: The \f(CB\*(C`public\*(C'\fB and \f(CB\*(C`private\*(C'\fB options are mutually exclusive\fR
.IP "full" 4
.IX Item "full"
\&\f(CW\*(C`methods\*(C'\fR normally returns just the method name. Supplying the \f(CW\*(C`full\*(C'\fR option
will cause the methods to be returned as the full names. That is, instead of
returning \f(CW\*(C`[ \*(Aqmethod1\*(Aq, \*(Aqmethod2\*(Aq, \*(Aqmethod3\*(Aq ]\*(C'\fR, you would instead get
\&\f(CW\*(C`[ \*(AqClass::method1\*(Aq, \*(AqAnotherClass::method2\*(Aq, \*(AqClass::method3\*(Aq ]\*(C'\fR.
.IP "expanded" 4
.IX Item "expanded"
The \f(CW\*(C`expanded\*(C'\fR option will cause a lot more information about method to be
returned. Instead of just the method name, you will instead get an array
reference containing the method name as a single combined name, a la \f(CW\*(C`full\*(C'\fR,
the separate class and method, and a \s-1CODE\s0 ref to the actual function ( if
available ). Please note that the function reference is not guaranteed to
be available. \f(CW\*(C`Class::Inspector\*(C'\fR is intended at some later time, to work
with modules that have some kind of common run-time loader in place ( e.g
\&\f(CW\*(C`Autoloader\*(C'\fR or \f(CW\*(C`Class::Autouse\*(C'\fR for example.
.Sp
The response from \f(CW\*(C`methods( \*(AqClass\*(Aq, \*(Aqexpanded\*(Aq )\*(C'\fR would look something like
the following.
.Sp
.Vb 5
\&  [
\&    [ \*(AqClass::method1\*(Aq,   \*(AqClass\*(Aq,   \*(Aqmethod1\*(Aq, \e&Class::method1   ],
\&    [ \*(AqAnother::method2\*(Aq, \*(AqAnother\*(Aq, \*(Aqmethod2\*(Aq, \e&Another::method2 ],
\&    [ \*(AqFoo::bar\*(Aq,         \*(AqFoo\*(Aq,     \*(Aqbar\*(Aq,     \e&Foo::bar         ],
\&  ]
.Ve
.SS "subclasses"
.IX Subsection "subclasses"
.Vb 1
\& my $arrayref = Class::Inspector\->subclasses($class);
.Ve
.PP
The \f(CW\*(C`subclasses\*(C'\fR static method will search then entire namespace (and thus
\&\fBall\fR currently loaded classes) to find all classes that are subclasses
of the class provided as a the parameter.
.PP
The actual test will be done by calling \f(CW\*(C`isa\*(C'\fR on the class as a static
method. (i.e. \f(CW\*(C`My::Class\->isa($class)\*(C'\fR.
.PP
Returns a reference to a list of the loaded classes that match the class
provided, or false is none match, or \f(CW\*(C`undef\*(C'\fR if the class name provided
is invalid.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
<http://ali.as/>, Class::Handle, Class::Inspector::Functions
.SH "AUTHOR"
.IX Header "AUTHOR"
Original author: Adam Kennedy <adamk@cpan.org>
.PP
Current maintainer: Graham Ollis <plicease@cpan.org>
.PP
Contributors:
.PP
Tom Wyant
.PP
Steffen Müller
.PP
Kivanc Yazan (\s-1KYZN\s0)
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is copyright (c) 2002\-2019 by Adam Kennedy.
.PP
This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.
