.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "IO::Socket::SSL::Utils 3"
.TH IO::Socket::SSL::Utils 3 "2019-02-21" "perl v5.18.4" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
IO::Socket::SSL::Utils \-\- loading, storing, creating certificates and keys
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 4
\&    use IO::Socket::SSL::Utils;
\&    my $cert = PEM_file2cert(\*(Aqcert.pem\*(Aq);  # load certificate from file
\&    my $string = PEM_cert2string($cert);   # convert certificate to PEM string
\&    CERT_free($cert);                      # free memory within OpenSSL
\&
\&    my $key = KEY_create_rsa(2048);        # create new 2048\-bit RSA key
\&    PEM_string2file($key,"key.pem");       # and write it to file
\&    KEY_free($key);                        # free memory within OpenSSL
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module provides various utility functions to work with certificates and
private keys, shielding some of the complexity of the underlying Net::SSLeay and
OpenSSL.
.SH "FUNCTIONS"
.IX Header "FUNCTIONS"
.IP "\(bu" 4
Functions converting between string or file and certificates and keys.
They croak if the operation cannot be completed.
.RS 4
.IP "PEM_file2cert(file) \-> cert" 8
.IX Item "PEM_file2cert(file) -> cert"
.PD 0
.IP "PEM_cert2file(cert,file)" 8
.IX Item "PEM_cert2file(cert,file)"
.IP "PEM_string2cert(string) \-> cert" 8
.IX Item "PEM_string2cert(string) -> cert"
.IP "PEM_cert2string(cert) \-> string" 8
.IX Item "PEM_cert2string(cert) -> string"
.IP "PEM_file2key(file) \-> key" 8
.IX Item "PEM_file2key(file) -> key"
.IP "PEM_key2file(key,file)" 8
.IX Item "PEM_key2file(key,file)"
.IP "PEM_string2key(string) \-> key" 8
.IX Item "PEM_string2key(string) -> key"
.IP "PEM_key2string(key) \-> string" 8
.IX Item "PEM_key2string(key) -> string"
.RE
.RS 4
.RE
.IP "\(bu" 4
.PD
Functions for cleaning up.
Each loaded or created cert and key must be freed to not leak memory.
.RS 4
.IP "CERT_free(cert)" 8
.IX Item "CERT_free(cert)"
.PD 0
.IP "KEY_free(key)" 8
.IX Item "KEY_free(key)"
.RE
.RS 4
.RE
.IP "\(bu" 4
.PD
KEY_create_rsa(bits) \-> key
.Sp
Creates an \s-1RSA\s0 key pair, bits defaults to 2048.
.IP "\(bu" 4
KEY_create_ec(curve) \-> key
.Sp
Creates an \s-1EC\s0 key, curve defaults to \f(CW\*(C`prime256v1\*(C'\fR.
.IP "\(bu" 4
CERT_asHash(cert,[digest_algo]) \-> hash
.Sp
Extracts the information from the certificate into a hash and uses the given
digest_algo (default: \s-1SHA\-256\s0) to determine digest of pubkey and cert.
The resulting hash contains:
.RS 4
.IP "subject" 8
.IX Item "subject"
Hash with the parts of the subject, e.g. commonName, countryName,
organizationName, stateOrProvinceName, localityName.
.IP "subjectAltNames" 8
.IX Item "subjectAltNames"
Array with list of alternative names. Each entry in the list is of
\&\f(CW\*(C`[type,value]\*(C'\fR, where \f(CW\*(C`type\*(C'\fR can be \s-1OTHERNAME, EMAIL, DNS, X400, DIRNAME,
EDIPARTY, URI, IP\s0 or \s-1RID.\s0
.IP "issuer" 8
.IX Item "issuer"
Hash with the parts of the issuer, e.g. commonName, countryName,
organizationName, stateOrProvinceName, localityName.
.IP "not_before, not_after" 8
.IX Item "not_before, not_after"
The time frame, where the certificate is valid, as time_t, e.g. can be converted
with localtime or similar functions.
.IP "serial" 8
.IX Item "serial"
The serial number
.IP "crl_uri" 8
.IX Item "crl_uri"
List of URIs for \s-1CRL\s0 distribution.
.IP "ocsp_uri" 8
.IX Item "ocsp_uri"
List of URIs for revocation checking using \s-1OCSP.\s0
.IP "keyusage" 8
.IX Item "keyusage"
List of keyUsage information in the certificate.
.IP "extkeyusage" 8
.IX Item "extkeyusage"
List of extended key usage information from the certificate. Each entry in
this list consists of a hash with oid, nid, ln and sn.
.IP "pubkey_digest_xxx" 8
.IX Item "pubkey_digest_xxx"
Binary digest of the pubkey using the given digest algorithm, e.g.
pubkey_digest_sha256 if (the default) \s-1SHA\-256\s0 was used.
.IP "x509_digest_xxx" 8
.IX Item "x509_digest_xxx"
Binary digest of the X.509 certificate using the given digest algorithm, e.g.
x509_digest_sha256 if (the default) \s-1SHA\-256\s0 was used.
.IP "fingerprint_xxx" 8
.IX Item "fingerprint_xxx"
Fingerprint of the certificate using the given digest algorithm, e.g.
fingerprint_sha256 if (the default) \s-1SHA\-256\s0 was used. Contrary to digest_* this
is an \s-1ASCII\s0 string with a list if hexadecimal numbers, e.g.
\&\*(L"73:59:75:5C:6D...\*(R".
.IP "signature_alg" 8
.IX Item "signature_alg"
Algorithm used to sign certificate, e.g. \f(CW\*(C`sha256WithRSAEncryption\*(C'\fR.
.IP "ext" 8
.IX Item "ext"
List of extensions.
Each entry in the list is a hash with oid, nid, sn, critical flag (boolean) and
data (string representation given by X509V3_EXT_print).
.IP "version" 8
.IX Item "version"
Certificate version, usually 2 (x509v3)
.RE
.RS 4
.RE
.IP "\(bu" 4
CERT_create(hash) \-> (cert,key)
.Sp
Creates a certificate based on the given hash.
If the issuer is not specified the certificate will be self-signed.
The following keys can be given:
.RS 4
.IP "subject" 8
.IX Item "subject"
Hash with the parts of the subject, e.g. commonName, countryName, ... as
described in \f(CW\*(C`CERT_asHash\*(C'\fR.
Default points to IO::Socket::SSL.
.IP "not_before" 8
.IX Item "not_before"
A time_t value when the certificate starts to be valid. Defaults to current
time.
.IP "not_after" 8
.IX Item "not_after"
A time_t value when the certificate ends to be valid. Defaults to current
time plus one 365 days.
.IP "serial" 8
.IX Item "serial"
The serial number. If not given a random number will be used.
.IP "version" 8
.IX Item "version"
The version of the certificate, default 2 (x509v3).
.IP "\s-1CA\s0 true|false" 8
.IX Item "CA true|false"
If true declare certificate as \s-1CA,\s0 defaults to false.
.IP "purpose string|array|hash" 8
.IX Item "purpose string|array|hash"
Set the purpose of the certificate.
The different purposes can be given as a string separated by non-word character,
as array or hash. With string or array each purpose can be prefixed with '+'
(enable) or '\-' (disable) and same can be done with the value when given as a
hash. By default enabling the purpose is assumed.
.Sp
If the \s-1CA\s0 option is given and true the defaults \*(L"ca,sslca,emailca,objca\*(R" are
assumed, but can be overridden with explicit purpose.
If the \s-1CA\s0 option is given and false the defaults \*(L"server,client\*(R" are assumed.
If no \s-1CA\s0 option and no purpose is given it defaults to \*(L"server,client\*(R".
.Sp
Purpose affects basicConstraints, keyUsage, extKeyUsage and netscapeCertType.
The following purposes are defined (case is not important):
.Sp
.Vb 4
\&    client
\&    server
\&    email
\&    objsign
\&
\&    CA
\&    sslCA
\&    emailCA
\&    objCA
\&
\&    emailProtection
\&    codeSigning
\&    timeStamping
\&
\&    digitalSignature
\&    nonRepudiation
\&    keyEncipherment
\&    dataEncipherment
\&    keyAgreement
\&    keyCertSign
\&    cRLSign
\&    encipherOnly
\&    decipherOnly
.Ve
.Sp
Examples:
.Sp
.Vb 2
\&     # root\-CA for SSL certificates
\&     purpose => \*(AqsslCA\*(Aq   # or CA => 1
\&
\&     # server certificate and CA (typically self\-signed)
\&     purpose => \*(AqsslCA,server\*(Aq
\&
\&     # client certificate
\&     purpose => \*(Aqclient\*(Aq,
.Ve
.IP "ext [{ sn => .., data => ... }, ... ]" 8
.IX Item "ext [{ sn => .., data => ... }, ... ]"
List of extensions. The type of the extension can be specified as name with
\&\f(CW\*(C`sn\*(C'\fR or as \s-1NID\s0 with \f(CW\*(C`nid\*(C'\fR and the data with \f(CW\*(C`data\*(C'\fR. These data must be in the
same syntax as expected within openssl.cnf, e.g. something like
\&\f(CW\*(C`OCSP;URI=http://...\*(C'\fR. Additionally the critical flag can be set with
\&\f(CW\*(C`critical =\*(C'\fR 1>.
.IP "key key" 8
.IX Item "key key"
use given key as key for certificate, otherwise a new one will be generated and
returned
.IP "issuer_cert cert" 8
.IX Item "issuer_cert cert"
set issuer for new certificate
.IP "issuer_key key" 8
.IX Item "issuer_key key"
sign new certificate with given key
.IP "issuer [ cert, key ]" 8
.IX Item "issuer [ cert, key ]"
Instead of giving issuer_key and issuer_cert as separate arguments they can be
given both together.
.IP "digest algorithm" 8
.IX Item "digest algorithm"
specify the algorithm used to sign the certificate, default \s-1SHA\-256.\s0
.RE
.RS 4
.RE
.SH "AUTHOR"
.IX Header "AUTHOR"
Steffen Ullrich
