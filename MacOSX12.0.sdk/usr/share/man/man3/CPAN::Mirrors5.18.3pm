.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "CPAN::Mirrors 3pm"
.TH CPAN::Mirrors 3pm "2014-09-30" "perl v5.18.4" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
CPAN::Mirrors \- Get CPAN miror information and select a fast one
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&        use CPAN::Mirrors;
\&
\&        my $mirrors = CPAN::Mirrors\->new;
\&        $mirrors\->parse_from_file( $mirrored_by_file );
\&
\&        my $seen = {};
\&
\&        my $best_continent = $mirrors\->find_best_continents( { seen => $seen } );
\&        my @mirrors        = $mirrors\->get_mirrors_by_continents( $best_continent );
\&
\&        my $callback = sub {
\&                my( $m ) = @_;
\&                printf "%s = %s\en", $m\->hostname, $m\->rtt
\&                };
\&        $mirrors\->get_mirrors_timings( \e@mirrors, $seen, $callback );
\&
\&        @mirrors = sort { $a\->rtt <=> $b\->rtt } @mirrors;
\&
\&        print "Best mirrors are ", map( { $_\->rtt } @mirrors[0..3] ), "\en";
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
.IP "new( \s-1LOCAL_FILE_NAME \s0)" 4
.IX Item "new( LOCAL_FILE_NAME )"
.PD 0
.IP "\fIcontinents()\fR" 4
.IX Item "continents()"
.PD
Return a list of continents based on those defined in \fI\s-1MIRRORED.BY\s0\fR.
.IP "countries( [\s-1CONTINENTS\s0] )" 4
.IX Item "countries( [CONTINENTS] )"
Return a list of countries based on those defined in \fI\s-1MIRRORED.BY\s0\fR.
It only returns countries for the continents you specify (as defined
in \f(CW\*(C`continents\*(C'\fR). If you don't specify any continents, it returns all
of the countries listed in \fI\s-1MIRRORED.BY\s0\fR.
.IP "mirrors( [\s-1COUNTRIES\s0] )" 4
.IX Item "mirrors( [COUNTRIES] )"
Return a list of mirrors based on those defined in \fI\s-1MIRRORED.BY\s0\fR.
It only returns mirrors for the countries you specify (as defined
in \f(CW\*(C`countries\*(C'\fR). If you don't specify any countries, it returns all
of the mirrors listed in \fI\s-1MIRRORED.BY\s0\fR.
.IP "get_mirrors_by_countries( [\s-1COUNTRIES\s0] )" 4
.IX Item "get_mirrors_by_countries( [COUNTRIES] )"
A more sensible synonym for mirrors.
.IP "get_mirrors_by_continents( [\s-1CONTINENTS\s0] )" 4
.IX Item "get_mirrors_by_continents( [CONTINENTS] )"
Return a list of mirrors for all of continents you specify. If you don't
specify any continents, it returns all of the mirrors.
.IP "get_countries_by_continents( [\s-1CONTINENTS\s0] )" 4
.IX Item "get_countries_by_continents( [CONTINENTS] )"
A more sensible synonym for countries.
.IP "best_mirrors" 4
.IX Item "best_mirrors"
\&\f(CW\*(C`best_mirrors\*(C'\fR checks for the best mirrors based on the list of
continents you pass, or, without that, all continents, as defined
by \f(CW\*(C`CPAN::Mirrored::By\*(C'\fR. It pings each mirror, up to the value of
\&\f(CW\*(C`how_many\*(C'\fR. In list context, it returns up to \f(CW\*(C`how_many\*(C'\fR mirror.
In scalar context, it returns the single best mirror.
.Sp
Arguments
.Sp
.Vb 4
\&        how_many   \- the number of mirrors to return. Default: 1
\&        callback   \- a callback for find_best_continents
\&        verbose    \- true or false on all the whining and moaning. Default: false
\&        continents \- an array ref of the continents to check
.Ve
.Sp
If you don't specify the continents, \f(CW\*(C`best_mirrors\*(C'\fR calls
\&\f(CW\*(C`find_best_continents\*(C'\fR to get the list of continents to check.
.IP "get_n_random_mirrors_by_continents( N, [\s-1CONTINENTS\s0]" 4
.IX Item "get_n_random_mirrors_by_continents( N, [CONTINENTS]"
Returns up to N random mirrors for the specified continents. Specify the
continents as an array reference.
.IP "get_mirrors_timings( \s-1MIRROR_LIST, SEEN, CALLBACK \s0);" 4
.IX Item "get_mirrors_timings( MIRROR_LIST, SEEN, CALLBACK );"
Pings the listed mirrors and returns a list of mirrors sorted
in ascending ping times.
.IP "find_best_continents( \s-1HASH_REF \s0);" 4
.IX Item "find_best_continents( HASH_REF );"
\&\f(CW\*(C`find_best_continents\*(C'\fR goes through each continent and pings \f(CW\*(C`N\*(C'\fR random
mirrors on that continent. It then orders the continents by ascending
median ping time. In list context, it returns the ordered list of
continent. In scalar context, it returns the same list as an anonymous
array.
.Sp
Arguments:
.Sp
.Vb 6
\&        n        \- the number of hosts to ping for each continent. Default: 3
\&        seen     \- a hashref of cached hostname ping times
\&        verbose  \- true or false for noisy or quiet. Default: false
\&        callback \- a subroutine to run after each ping.
\&        ping_cache_limit \- how long, in seconds, to reuse previous ping times.
\&                Default: 1 day
.Ve
.Sp
The \f(CW\*(C`seen\*(C'\fR hash has hostnames as keys and anonymous arrays as values. The
anonymous array is a triplet of a \f(CW\*(C`CPAN::Mirrored::By\*(C'\fR object, a ping
time, and the epoch time for the measurement.
.Sp
The callback subroutine gets the \f(CW\*(C`CPAN::Mirrored::By\*(C'\fR object, the ping
time, and measurement time (the same things in the \f(CW\*(C`seen\*(C'\fR hashref) as arguments.
\&\f(CW\*(C`find_best_continents\*(C'\fR doesn't care what the callback does and ignores the return
value.
.SH "AUTHOR"
.IX Header "AUTHOR"
Andreas Koenig \f(CW\*(C`<andk@cpan.org>\*(C'\fR, David Golden \f(CW\*(C`<dagolden@cpan.org>\*(C'\fR,
brian d foy \f(CW\*(C`<bdfoy@cpan.org>\*(C'\fR
.SH "LICENSE"
.IX Header "LICENSE"
This program is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.
.PP
See <http://www.perl.com/perl/misc/Artistic.html>
