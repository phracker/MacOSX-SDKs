.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "re 3pm"
.TH re 3pm "2014-09-30" "perl v5.18.4" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
re \- Perl pragma to alter regular expression behaviour
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&    use re \*(Aqtaint\*(Aq;
\&    ($x) = ($^X =~ /^(.*)$/s);     # $x is tainted here
\&
\&    $pat = \*(Aq(?{ $foo = 1 })\*(Aq;
\&    use re \*(Aqeval\*(Aq;
\&    /foo${pat}bar/;                # won\*(Aqt fail (when not under \-T
\&                                   # switch)
\&
\&    {
\&        no re \*(Aqtaint\*(Aq;             # the default
\&        ($x) = ($^X =~ /^(.*)$/s); # $x is not tainted here
\&
\&        no re \*(Aqeval\*(Aq;              # the default
\&        /foo${pat}bar/;            # disallowed (with or without \-T
\&                                   # switch)
\&    }
\&
\&    use re \*(Aq/ix\*(Aq;
\&    "FOO" =~ / foo /; # /ix implied
\&    no re \*(Aq/x\*(Aq;
\&    "FOO" =~ /foo/; # just /i implied
\&
\&    use re \*(Aqdebug\*(Aq;                # output debugging info during
\&    /^(.*)$/s;                     # compile and run time
\&
\&
\&    use re \*(Aqdebugcolor\*(Aq;           # same as \*(Aqdebug\*(Aq, but with colored
\&                                   # output
\&    ...
\&
\&    use re qw(Debug All);          # Same as "use re \*(Aqdebug\*(Aq", but you
\&                                   # can use "Debug" with things other
\&                                   # than \*(AqAll\*(Aq
\&    use re qw(Debug More);         # \*(AqAll\*(Aq plus output more details
\&    no re qw(Debug ALL);           # Turn on (almost) all re debugging
\&                                   # in this scope
\&
\&    use re qw(is_regexp regexp_pattern); # import utility functions
\&    my ($pat,$mods)=regexp_pattern(qr/foo/i);
\&    if (is_regexp($obj)) { 
\&        print "Got regexp: ",
\&            scalar regexp_pattern($obj); # just as perl would stringify
\&    }                                    # it but no hassle with blessed
\&                                         # re\*(Aqs.
.Ve
.PP
(We use $^X in these examples because it's tainted by default.)
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
.SS "'taint' mode"
.IX Subsection "'taint' mode"
When \f(CW\*(C`use re \*(Aqtaint\*(Aq\*(C'\fR is in effect, and a tainted string is the target
of a regexp, the regexp memories (or values returned by the m// operator
in list context) are tainted.  This feature is useful when regexp operations
on tainted data aren't meant to extract safe substrings, but to perform
other transformations.
.SS "'eval' mode"
.IX Subsection "'eval' mode"
When \f(CW\*(C`use re \*(Aqeval\*(Aq\*(C'\fR is in effect, a regexp is allowed to contain
\&\f(CW\*(C`(?{ ... })\*(C'\fR zero-width assertions and \f(CW\*(C`(??{ ... })\*(C'\fR postponed
subexpressions that are derived from variable interpolation, rather than
appearing literally within the regexp.  That is normally disallowed, since
it is a
potential security risk.  Note that this pragma is ignored when the regular
expression is obtained from tainted data, i.e.  evaluation is always
disallowed with tainted regular expressions.  See \*(L"(?{ code })\*(R" in perlre 
and \*(L"(??{ code })\*(R" in perlre.
.PP
For the purpose of this pragma, interpolation of precompiled regular
expressions (i.e., the result of \f(CW\*(C`qr//\*(C'\fR) is \fInot\fR considered variable
interpolation.  Thus:
.PP
.Vb 1
\&    /foo${pat}bar/
.Ve
.PP
\&\fIis\fR allowed if \f(CW$pat\fR is a precompiled regular expression, even
if \f(CW$pat\fR contains \f(CW\*(C`(?{ ... })\*(C'\fR assertions or \f(CW\*(C`(??{ ... })\*(C'\fR subexpressions.
.SS "'/flags' mode"
.IX Subsection "'/flags' mode"
When \f(CW\*(C`use re \*(Aq/flags\*(Aq\*(C'\fR is specified, the given flags are automatically
added to every regular expression till the end of the lexical scope.
.PP
\&\f(CW\*(C`no re \*(Aq/flags\*(Aq\*(C'\fR will turn off the effect of \f(CW\*(C`use re \*(Aq/flags\*(Aq\*(C'\fR for the
given flags.
.PP
For example, if you want all your regular expressions to have /msx on by
default, simply put
.PP
.Vb 1
\&    use re \*(Aq/msx\*(Aq;
.Ve
.PP
at the top of your code.
.PP
The character set /adul flags cancel each other out. So, in this example,
.PP
.Vb 4
\&    use re "/u";
\&    "ss" =~ /\exdf/;
\&    use re "/d";
\&    "ss" =~ /\exdf/;
.Ve
.PP
the second \f(CW\*(C`use re\*(C'\fR does an implicit \f(CW\*(C`no re \*(Aq/u\*(Aq\*(C'\fR.
.PP
Turning on one of the character set flags with \f(CW\*(C`use re\*(C'\fR takes precedence over the
\&\f(CW\*(C`locale\*(C'\fR pragma and the 'unicode_strings' \f(CW\*(C`feature\*(C'\fR, for regular
expressions. Turning off one of these flags when it is active reverts to
the behaviour specified by whatever other pragmata are in scope. For
example:
.PP
.Vb 4
\&    use feature "unicode_strings";
\&    no re "/u"; # does nothing
\&    use re "/l";
\&    no re "/l"; # reverts to unicode_strings behaviour
.Ve
.SS "'debug' mode"
.IX Subsection "'debug' mode"
When \f(CW\*(C`use re \*(Aqdebug\*(Aq\*(C'\fR is in effect, perl emits debugging messages when
compiling and using regular expressions.  The output is the same as that
obtained by running a \f(CW\*(C`\-DDEBUGGING\*(C'\fR\-enabled perl interpreter with the
\&\fB\-Dr\fR switch. It may be quite voluminous depending on the complexity
of the match.  Using \f(CW\*(C`debugcolor\*(C'\fR instead of \f(CW\*(C`debug\*(C'\fR enables a
form of output that can be used to get a colorful display on terminals
that understand termcap color sequences.  Set \f(CW$ENV{PERL_RE_TC}\fR to a
comma-separated list of \f(CW\*(C`termcap\*(C'\fR properties to use for highlighting
strings on/off, pre-point part on/off.
See \*(L"Debugging Regular Expressions\*(R" in perldebug for additional info.
.PP
As of 5.9.5 the directive \f(CW\*(C`use re \*(Aqdebug\*(Aq\*(C'\fR and its equivalents are
lexically scoped, as the other directives are.  However they have both 
compile-time and run-time effects.
.PP
See \*(L"Pragmatic Modules\*(R" in perlmodlib.
.SS "'Debug' mode"
.IX Subsection "'Debug' mode"
Similarly \f(CW\*(C`use re \*(AqDebug\*(Aq\*(C'\fR produces debugging output, the difference
being that it allows the fine tuning of what debugging output will be
emitted. Options are divided into three groups, those related to
compilation, those related to execution and those related to special
purposes. The options are as follows:
.IP "Compile related options" 4
.IX Item "Compile related options"
.RS 4
.PD 0
.IP "\s-1COMPILE\s0" 4
.IX Item "COMPILE"
.PD
Turns on all compile related debug options.
.IP "\s-1PARSE\s0" 4
.IX Item "PARSE"
Turns on debug output related to the process of parsing the pattern.
.IP "\s-1OPTIMISE\s0" 4
.IX Item "OPTIMISE"
Enables output related to the optimisation phase of compilation.
.IP "\s-1TRIEC\s0" 4
.IX Item "TRIEC"
Detailed info about trie compilation.
.IP "\s-1DUMP\s0" 4
.IX Item "DUMP"
Dump the final program out after it is compiled and optimised.
.RE
.RS 4
.RE
.IP "Execute related options" 4
.IX Item "Execute related options"
.RS 4
.PD 0
.IP "\s-1EXECUTE\s0" 4
.IX Item "EXECUTE"
.PD
Turns on all execute related debug options.
.IP "\s-1MATCH\s0" 4
.IX Item "MATCH"
Turns on debugging of the main matching loop.
.IP "\s-1TRIEE\s0" 4
.IX Item "TRIEE"
Extra debugging of how tries execute.
.IP "\s-1INTUIT\s0" 4
.IX Item "INTUIT"
Enable debugging of start-point optimisations.
.RE
.RS 4
.RE
.IP "Extra debugging options" 4
.IX Item "Extra debugging options"
.RS 4
.PD 0
.IP "\s-1EXTRA\s0" 4
.IX Item "EXTRA"
.PD
Turns on all \*(L"extra\*(R" debugging options.
.IP "\s-1BUFFERS\s0" 4
.IX Item "BUFFERS"
Enable debugging the capture group storage during match. Warning,
this can potentially produce extremely large output.
.IP "\s-1TRIEM\s0" 4
.IX Item "TRIEM"
Enable enhanced \s-1TRIE\s0 debugging. Enhances both \s-1TRIEE\s0
and \s-1TRIEC.\s0
.IP "\s-1STATE\s0" 4
.IX Item "STATE"
Enable debugging of states in the engine.
.IP "\s-1STACK\s0" 4
.IX Item "STACK"
Enable debugging of the recursion stack in the engine. Enabling
or disabling this option automatically does the same for debugging
states as well. This output from this can be quite large.
.IP "\s-1OPTIMISEM\s0" 4
.IX Item "OPTIMISEM"
Enable enhanced optimisation debugging and start-point optimisations.
Probably not useful except when debugging the regexp engine itself.
.IP "\s-1OFFSETS\s0" 4
.IX Item "OFFSETS"
Dump offset information. This can be used to see how regops correlate
to the pattern. Output format is
.Sp
.Vb 1
\&   NODENUM:POSITION[LENGTH]
.Ve
.Sp
Where 1 is the position of the first char in the string. Note that position
can be 0, or larger than the actual length of the pattern, likewise length
can be zero.
.IP "\s-1OFFSETSDBG\s0" 4
.IX Item "OFFSETSDBG"
Enable debugging of offsets information. This emits copious
amounts of trace information and doesn't mesh well with other
debug options.
.Sp
Almost definitely only useful to people hacking
on the offsets part of the debug engine.
.RE
.RS 4
.RE
.IP "Other useful flags" 4
.IX Item "Other useful flags"
These are useful shortcuts to save on the typing.
.RS 4
.IP "\s-1ALL\s0" 4
.IX Item "ALL"
Enable all options at once except \s-1OFFSETS, OFFSETSDBG\s0 and \s-1BUFFERS.
\&\s0(To get every single option without exception, use both \s-1ALL\s0 and \s-1EXTRA.\s0)
.IP "All" 4
.IX Item "All"
Enable \s-1DUMP\s0 and all execute options. Equivalent to:
.Sp
.Vb 1
\&  use re \*(Aqdebug\*(Aq;
.Ve
.IP "\s-1MORE\s0" 4
.IX Item "MORE"
.PD 0
.IP "More" 4
.IX Item "More"
.PD
Enable the options enabled by \*(L"All\*(R", plus \s-1STATE, TRIEC,\s0 and \s-1TRIEM.\s0
.RE
.RS 4
.RE
.PP
As of 5.9.5 the directive \f(CW\*(C`use re \*(Aqdebug\*(Aq\*(C'\fR and its equivalents are
lexically scoped, as are the other directives.  However they have both
compile-time and run-time effects.
.SS "Exportable Functions"
.IX Subsection "Exportable Functions"
As of perl 5.9.5 're' debug contains a number of utility functions that
may be optionally exported into the caller's namespace. They are listed
below.
.IP "is_regexp($ref)" 4
.IX Item "is_regexp($ref)"
Returns true if the argument is a compiled regular expression as returned
by \f(CW\*(C`qr//\*(C'\fR, false if it is not.
.Sp
This function will not be confused by overloading or blessing. In
internals terms, this extracts the regexp pointer out of the
PERL_MAGIC_qr structure so it cannot be fooled.
.IP "regexp_pattern($ref)" 4
.IX Item "regexp_pattern($ref)"
If the argument is a compiled regular expression as returned by \f(CW\*(C`qr//\*(C'\fR,
then this function returns the pattern.
.Sp
In list context it returns a two element list, the first element
containing the pattern and the second containing the modifiers used when
the pattern was compiled.
.Sp
.Vb 1
\&  my ($pat, $mods) = regexp_pattern($ref);
.Ve
.Sp
In scalar context it returns the same as perl would when stringifying a raw
\&\f(CW\*(C`qr//\*(C'\fR with the same pattern inside.  If the argument is not a compiled
reference then this routine returns false but defined in scalar context,
and the empty list in list context. Thus the following
.Sp
.Vb 1
\&    if (regexp_pattern($ref) eq \*(Aq(?^i:foo)\*(Aq)
.Ve
.Sp
will be warning free regardless of what \f(CW$ref\fR actually is.
.Sp
Like \f(CW\*(C`is_regexp\*(C'\fR this function will not be confused by overloading
or blessing of the object.
.IP "regmust($ref)" 4
.IX Item "regmust($ref)"
If the argument is a compiled regular expression as returned by \f(CW\*(C`qr//\*(C'\fR,
then this function returns what the optimiser considers to be the longest
anchored fixed string and longest floating fixed string in the pattern.
.Sp
A \fIfixed string\fR is defined as being a substring that must appear for the
pattern to match. An \fIanchored fixed string\fR is a fixed string that must
appear at a particular offset from the beginning of the match. A \fIfloating
fixed string\fR is defined as a fixed string that can appear at any point in
a range of positions relative to the start of the match. For example,
.Sp
.Vb 3
\&    my $qr = qr/here .* there/x;
\&    my ($anchored, $floating) = regmust($qr);
\&    print "anchored:\*(Aq$anchored\*(Aq\enfloating:\*(Aq$floating\*(Aq\en";
.Ve
.Sp
results in
.Sp
.Vb 2
\&    anchored:\*(Aqhere\*(Aq
\&    floating:\*(Aqthere\*(Aq
.Ve
.Sp
Because the \f(CW\*(C`here\*(C'\fR is before the \f(CW\*(C`.*\*(C'\fR in the pattern, its position
can be determined exactly. That's not true, however, for the \f(CW\*(C`there\*(C'\fR;
it could appear at any point after where the anchored string appeared.
Perl uses both for its optimisations, prefering the longer, or, if they are
equal, the floating.
.Sp
\&\fB\s-1NOTE:\s0\fR This may not necessarily be the definitive longest anchored and
floating string. This will be what the optimiser of the Perl that you
are using thinks is the longest. If you believe that the result is wrong
please report it via the perlbug utility.
.IP "regname($name,$all)" 4
.IX Item "regname($name,$all)"
Returns the contents of a named buffer of the last successful match. If
\&\f(CW$all\fR is true, then returns an array ref containing one entry per buffer,
otherwise returns the first defined buffer.
.IP "regnames($all)" 4
.IX Item "regnames($all)"
Returns a list of all of the named buffers defined in the last successful
match. If \f(CW$all\fR is true, then it returns all names defined, if not it returns
only names which were involved in the match.
.IP "\fIregnames_count()\fR" 4
.IX Item "regnames_count()"
Returns the number of distinct names defined in the pattern used
for the last successful match.
.Sp
\&\fBNote:\fR this result is always the actual number of distinct
named buffers defined, it may not actually match that which is
returned by \f(CW\*(C`regnames()\*(C'\fR and related routines when those routines
have not been called with the \f(CW$all\fR parameter set.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\*(L"Pragmatic Modules\*(R" in perlmodlib.
