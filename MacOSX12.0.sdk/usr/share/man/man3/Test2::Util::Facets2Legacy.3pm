.\" Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Test2::Util::Facets2Legacy 3pm"
.TH Test2::Util::Facets2Legacy 3pm "2019-10-21" "perl v5.30.3" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Test2::Util::Facets2Legacy \- Convert facet data to the legacy event API.
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module exports several subroutines from the older event \s-1API\s0 (see
Test2::Event). These subroutines can be used as methods on any object that
provides a custom \f(CW\*(C`facet_data()\*(C'\fR method. These subroutines can also be used as
functions that take a facet data hashref as arguments.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.SS "\s-1AS METHODS\s0"
.IX Subsection "AS METHODS"
.Vb 1
\&    package My::Event;
\&
\&    use Test2::Util::Facets2Legacy \*(Aq:ALL\*(Aq;
\&
\&    sub facet_data { return { ... } }
.Ve
.PP
Then to use it:
.PP
.Vb 1
\&    my $e = My::Event\->new(...);
\&
\&    my $causes_fail = $e\->causes_fail;
\&    my $summary     = $e\->summary;
\&    ....
.Ve
.SS "\s-1AS FUNCTIONS\s0"
.IX Subsection "AS FUNCTIONS"
.Vb 1
\&    use Test2::Util::Facets2Legacy \*(Aq:ALL\*(Aq;
\&
\&    my $f = {
\&        assert => { ... },
\&        info => [{...}, ...],
\&        control => {...},
\&        ...
\&    };
\&
\&    my $causes_fail = causes_fail($f);
\&    my $summary     = summary($f);
.Ve
.SH "NOTE ON CYCLES"
.IX Header "NOTE ON CYCLES"
When used as methods, all these subroutines call \f(CW\*(C`$e\->facet_data()\*(C'\fR. The
default \f(CW\*(C`facet_data()\*(C'\fR method in Test2::Event relies on the legacy methods
this module emulates in order to work. As a result of this it is very easy to
create infinite recursion bugs.
.PP
These methods have cycle detection and will throw an exception early if a cycle
is detected. \f(CW\*(C`uuid()\*(C'\fR is currently the only subroutine in this library that
has a fallback behavior when cycles are detected.
.SH "EXPORTS"
.IX Header "EXPORTS"
Nothing is exported by default. You must specify which methods to import, or
use the ':ALL' tag.
.ie n .IP "$bool = $e\->\fBcauses_fail()\fR" 4
.el .IP "\f(CW$bool\fR = \f(CW$e\fR\->\fBcauses_fail()\fR" 4
.IX Item "$bool = $e->causes_fail()"
.PD 0
.ie n .IP "$bool = causes_fail($f)" 4
.el .IP "\f(CW$bool\fR = causes_fail($f)" 4
.IX Item "$bool = causes_fail($f)"
.PD
Check if the event or facets result in a failing state.
.ie n .IP "$bool = $e\->\fBdiagnostics()\fR" 4
.el .IP "\f(CW$bool\fR = \f(CW$e\fR\->\fBdiagnostics()\fR" 4
.IX Item "$bool = $e->diagnostics()"
.PD 0
.ie n .IP "$bool = diagnostics($f)" 4
.el .IP "\f(CW$bool\fR = diagnostics($f)" 4
.IX Item "$bool = diagnostics($f)"
.PD
Check if the event or facets contain any diagnostics information.
.ie n .IP "$bool = $e\->\fBglobal()\fR" 4
.el .IP "\f(CW$bool\fR = \f(CW$e\fR\->\fBglobal()\fR" 4
.IX Item "$bool = $e->global()"
.PD 0
.ie n .IP "$bool = global($f)" 4
.el .IP "\f(CW$bool\fR = global($f)" 4
.IX Item "$bool = global($f)"
.PD
Check if the event or facets need to be globally processed.
.ie n .IP "$bool = $e\->\fBincrements_count()\fR" 4
.el .IP "\f(CW$bool\fR = \f(CW$e\fR\->\fBincrements_count()\fR" 4
.IX Item "$bool = $e->increments_count()"
.PD 0
.ie n .IP "$bool = increments_count($f)" 4
.el .IP "\f(CW$bool\fR = increments_count($f)" 4
.IX Item "$bool = increments_count($f)"
.PD
Check if the event or facets make an assertion.
.ie n .IP "$bool = $e\->\fBno_display()\fR" 4
.el .IP "\f(CW$bool\fR = \f(CW$e\fR\->\fBno_display()\fR" 4
.IX Item "$bool = $e->no_display()"
.PD 0
.ie n .IP "$bool = no_display($f)" 4
.el .IP "\f(CW$bool\fR = no_display($f)" 4
.IX Item "$bool = no_display($f)"
.PD
Check if the event or facets should be rendered or hidden.
.ie n .IP "($max, $directive, $reason) = $e\->\fBsets_plan()\fR" 4
.el .IP "($max, \f(CW$directive\fR, \f(CW$reason\fR) = \f(CW$e\fR\->\fBsets_plan()\fR" 4
.IX Item "($max, $directive, $reason) = $e->sets_plan()"
.PD 0
.ie n .IP "($max, $directive, $reason) = sets_plan($f)" 4
.el .IP "($max, \f(CW$directive\fR, \f(CW$reason\fR) = sets_plan($f)" 4
.IX Item "($max, $directive, $reason) = sets_plan($f)"
.PD
Check if the event or facets set a plan, and return the plan details.
.ie n .IP "$id = $e\->\fBsubtest_id()\fR" 4
.el .IP "\f(CW$id\fR = \f(CW$e\fR\->\fBsubtest_id()\fR" 4
.IX Item "$id = $e->subtest_id()"
.PD 0
.ie n .IP "$id = subtest_id($f)" 4
.el .IP "\f(CW$id\fR = subtest_id($f)" 4
.IX Item "$id = subtest_id($f)"
.PD
Get the subtest id, if any.
.ie n .IP "$string = $e\->\fBsummary()\fR" 4
.el .IP "\f(CW$string\fR = \f(CW$e\fR\->\fBsummary()\fR" 4
.IX Item "$string = $e->summary()"
.PD 0
.ie n .IP "$string = summary($f)" 4
.el .IP "\f(CW$string\fR = summary($f)" 4
.IX Item "$string = summary($f)"
.PD
Get the summary of the event or facets hash, if any.
.ie n .IP "$undef_or_int = $e\->\fBterminate()\fR" 4
.el .IP "\f(CW$undef_or_int\fR = \f(CW$e\fR\->\fBterminate()\fR" 4
.IX Item "$undef_or_int = $e->terminate()"
.PD 0
.ie n .IP "$undef_or_int = terminate($f)" 4
.el .IP "\f(CW$undef_or_int\fR = terminate($f)" 4
.IX Item "$undef_or_int = terminate($f)"
.PD
Check if the event or facets should result in process termination, if so the
exit code is returned (which could be 0). undef is returned if no termination
is requested.
.ie n .IP "$uuid = $e\->\fBuuid()\fR" 4
.el .IP "\f(CW$uuid\fR = \f(CW$e\fR\->\fBuuid()\fR" 4
.IX Item "$uuid = $e->uuid()"
.PD 0
.ie n .IP "$uuid = uuid($f)" 4
.el .IP "\f(CW$uuid\fR = uuid($f)" 4
.IX Item "$uuid = uuid($f)"
.PD
Get the \s-1UUID\s0 of the facets or event.
.Sp
\&\fBNote:\fR This will fall back to \f(CW\*(C`$e\->SUPER::uuid()\*(C'\fR if a cycle is
detected and an event is used as the argument.
.SH "SOURCE"
.IX Header "SOURCE"
The source code repository for Test2 can be found at
\&\fIhttp://github.com/Test\-More/test\-more/\fR.
.SH "MAINTAINERS"
.IX Header "MAINTAINERS"
.IP "Chad Granum <exodist@cpan.org>" 4
.IX Item "Chad Granum <exodist@cpan.org>"
.SH "AUTHORS"
.IX Header "AUTHORS"
.PD 0
.IP "Chad Granum <exodist@cpan.org>" 4
.IX Item "Chad Granum <exodist@cpan.org>"
.PD
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright 2019 Chad Granum <exodist@cpan.org>.
.PP
This program is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.
.PP
See \fIhttp://dev.perl.org/licenses/\fR
