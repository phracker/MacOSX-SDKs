.\" Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Net::DNS::Resolver::Recurse 3"
.TH Net::DNS::Resolver::Recurse 3 "2014-01-16" "perl v5.30.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Net::DNS::Resolver::Recurse \- Perform recursive dns lookups
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&  use Net::DNS::Resolver::Recurse;
\&  my $res = Net::DNS::Resolver::Recurse\->new;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module is a sub class of Net::DNS::Resolver. So the methods for
Net::DNS::Resolver still work for this module as well.  There are just a
couple methods added:
.SS "hints"
.IX Subsection "hints"
Initialize the hint servers.  Recursive queries need a starting name
server to work off of. This method takes a list of \s-1IP\s0 addresses to use
as the starting servers.  These name servers should be authoritative for
the root (.) zone.
.PP
.Vb 1
\&  $res\->hints(@ips);
.Ve
.PP
If no hints are passed, the default nameserver is asked for the hints.
Normally these IPs can be obtained from the following location:
.PP
.Vb 1
\&  ftp://ftp.internic.net/domain/named.root
.Ve
.SS "recursion_callback"
.IX Subsection "recursion_callback"
This method is takes a code reference, which is then invoked each time a
packet is received during the recursive lookup.  For example to emulate
dig's \f(CW\*(C`+trace\*(C'\fR function:
.PP
.Vb 2
\& $res\->recursion_callback(sub {
\&     my $packet = shift;
\&
\&     $_\->print for $packet\->additional;
\&
\&     printf(";; Received %d bytes from %s\en\en",
\&         $packet\->answersize,
\&         $packet\->answerfrom
\&     );
\& });
.Ve
.SS "query_dorecursion"
.IX Subsection "query_dorecursion"
This method is much like the normal \fBquery()\fR method except it disables
the recurse flag in the packet and explicitly performs the recursion.
.PP
.Vb 1
\&  $packet = $res\->query_dorecursion( "www.netscape.com.", "A");
.Ve
.SH "IPv6 transport"
.IX Header "IPv6 transport"
If the appropriate IPv6 libraries are installed the recursive resolver
will randomly choose between IPv6 and IPv4 addresses of the
nameservers it encounters during recursion.
.PP
If you want to force IPv4 transport use the \fBforce_v4()\fR method. Also see
the IPv6 transport notes in the Net::DNS::Resolver documentation.
.SH "AUTHOR"
.IX Header "AUTHOR"
Rob Brown, bbb@cpan.org
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Net::DNS::Resolver,
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (c) 2002, Rob Brown.  All rights reserved.
Portions Copyright (c) 2005, Olaf M Kolkman.
.PP
This module is free software; you can redistribute
it and/or modify it under the same terms as Perl itself.
.PP
\&\f(CW$Id:\fR Recurse.pm 1096 2012\-12\-28 13:35:15Z willem $
