.\" Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Type::Tiny::Manual::Libraries 3"
.TH Type::Tiny::Manual::Libraries 3 "2020-10-28" "perl v5.30.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Type::Tiny::Manual::Libraries \- defining your own type libraries
.SH "MANUAL"
.IX Header "MANUAL"
.SS "Defining a Type"
.IX Subsection "Defining a Type"
A type is an object and you can create a new one using the constructor:
.PP
.Vb 1
\&  use Type::Tiny;
\&  
\&  my $type = Type::Tiny\->new(%args);
.Ve
.PP
A full list of the available arguments can be found in the Type::Tiny
documentation, but the most important ones to begin with are:
.ie n .IP """name""" 4
.el .IP "\f(CWname\fR" 4
.IX Item "name"
The name of your new type. Type::Tiny uses a convention of UpperCamelCase
names for type constraints. The type name may also begin with one or two
leading underscores to indicate a type intended for internal use only.
Types using non-ASCII characters may cause problems on older versions of
Perl (pre\-5.8).
.Sp
Although this is optional and types may be anonymous, a name is required for
a type constraint to added to a type library.
.ie n .IP """constraint""" 4
.el .IP "\f(CWconstraint\fR" 4
.IX Item "constraint"
A code reference checking \f(CW$_\fR and returning a boolean. Alternatively,
a string of Perl code may be provided.
.Sp
If you've been paying attention, you can probably guess that the string of
Perl code may result in more efficient type checks.
.ie n .IP """parent""" 4
.el .IP "\f(CWparent\fR" 4
.IX Item "parent"
An existing type constraint to inherit from. A value will need to pass the
parent constraint before its own constraint would be called.
.Sp
.Vb 6
\&  my $Even = Type::Tiny\->new(
\&    name       => \*(AqEvenNumber\*(Aq,
\&    parent     => Types::Standard::Int,
\&    constraint => sub {
\&      # in this sub we don\*(Aqt need to check that $_ is an Int
\&      # because the parent will take care of that!
\&      
\&      $_ % 2 == 0
\&    },
\&  );
.Ve
.Sp
Although the \f(CW\*(C`parent\*(C'\fR is optional, it makes sense whenever possible to
inherit from an existing type constraint to benefit from any optimizations
or \s-1XS\s0 implementations they may provide.
.SS "Defining a Library"
.IX Subsection "Defining a Library"
A library is a Perl module that exports type constraints as subs.
Types::Standard, Types::Common::Numeric, and Types::Common::String
are type libraries that are bundled with Type::Tiny.
.PP
To create a type library, create a package that inherits from
Type::Library.
.PP
.Vb 2
\&  package MyTypes {
\&    use Type::Library \-base;
\&    
\&    ...; # your type definitions go here
\&  }
.Ve
.PP
The \f(CW\*(C`\-base\*(C'\fR flag is just a shortcut for:
.PP
.Vb 4
\&  package MyTypes {
\&    use Type::Library;
\&    our @ISA = \*(AqType::Library\*(Aq;
\&  }
.Ve
.PP
You can add types like this:
.PP
.Vb 2
\&  package MyTypes {
\&    use Type::Library \-base;
\&    
\&    my $Even = Type::Tiny\->new(
\&      name       => \*(AqEvenNumber\*(Aq,
\&      parent     => Types::Standard::Int,
\&      constraint => sub {
\&        # in this sub we don\*(Aqt need to check that $_ is an Int
\&        # because the parent will take care of that!
\&        
\&        $_ % 2 == 0
\&      },
\&    );
\&    
\&    _\|_PACKAGE_\|_\->add_type($Even);
\&  }
.Ve
.PP
There is a shortcut for adding types if they're going to be blessed
Type::Tiny objects and not, for example, a subclass of Type::Tiny.
You can just pass \f(CW%args\fR directly to \f(CW\*(C`add_type\*(C'\fR.
.PP
.Vb 2
\&  package MyTypes {
\&    use Type::Library \-base;
\&    
\&    _\|_PACKAGE_\|_\->add_type(
\&      name       => \*(AqEvenNumber\*(Aq,
\&      parent     => Types::Standard::Int,
\&      constraint => sub {
\&        # in this sub we don\*(Aqt need to check that $_ is an Int
\&        # because the parent will take care of that!
\&        
\&        $_ % 2 == 0
\&      },
\&    );
\&  }
.Ve
.PP
The \f(CW\*(C`add_type\*(C'\fR method returns the type it just added, so it can be stored in
a variable.
.PP
.Vb 1
\&  my $Even = _\|_PACKAGE_\|_\->add_type(...);
.Ve
.PP
This can be useful if you wish to use \f(CW$Even\fR as the parent type to some
other type you're going to define later.
.PP
Here's a bigger worked example:
.PP
.Vb 4
\&  package Example::Types {
\&    use Type::Library \-base;
\&    use Types::Standard \-types;
\&    use DateTime;
\&    
\&    # Type::Tiny::Class is a subclass of Type::Tiny for creating
\&    # InstanceOf\-like types. It\*(Aqs kind of better though because
\&    # it does cool stuff like pass through $type\->new(%args) to
\&    # the class\*(Aqs constructor.
\&    #
\&    my $dt = _\|_PACKAGE_\|_\->add_type(
\&      Type::Tiny::Class\->new(
\&        name    => \*(AqDatetime\*(Aq,
\&        class   => \*(AqDateTime\*(Aq,
\&      )
\&    );
\&   
\&    my $dth = _\|_PACKAGE_\|_\->add_type(
\&      name    => \*(AqDatetimeHash\*(Aq,
\&      parent  => Dict[
\&        year       => Int,
\&        month      => Optional[ Int ],
\&        day        => Optional[ Int ],
\&        hour       => Optional[ Int ],
\&        minute     => Optional[ Int ],
\&        second     => Optional[ Int ],
\&        nanosecond => Optional[ Int ],
\&        time_zone  => Optional[ Str ],
\&      ],
\&    );
\&   
\&    my $eph = _\|_PACKAGE_\|_\->add_type(
\&      name    => \*(AqEpochHash\*(Aq,
\&      parent  => Dict[ epoch => Int ],
\&    );
\&    
\&    # Can\*(Aqt just use "plus_coercions" method because that creates
\&    # a new anonymous child type to add the coercions to. We want
\&    # to add them to the type which exists in this library.
\&    #
\&    $dt\->coercion\->add_type_coercions(
\&      Int,    q{ DateTime\->from_epoch(epoch => $_) },
\&      Undef,  q{ DateTime\->now() },
\&      $dth,   q{ DateTime\->new(%$_) },
\&      $eph,   q{ DateTime\->from_epoch(%$_) },
\&    );
\&    
\&    _\|_PACKAGE_\|_\->make_immutable;
\&  }
.Ve
.PP
\&\f(CW\*(C`make_immutable\*(C'\fR freezes to coercions of all the types in the package,
so no outside code can tamper with the coercions, and allows Type::Tiny
to make optimizations to the coercions, knowing they won't later be
altered. You should always do this at the end.
.PP
The library will export types \fBDatetime\fR, \fBDatetimeHash\fR, and
\&\fBEpochHash\fR. The \fBDatetime\fR type will have coercions from \fBInt\fR,
\&\fBUndef\fR, \fBDatetimeHash\fR, and \fBEpochHash\fR.
.SS "Extending Libraries"
.IX Subsection "Extending Libraries"
Type::Utils provides a helpful function \f(CW\*(C`extends\*(C'\fR.
.PP
.Vb 3
\&  package My::Types {
\&    use Type::Library \-base;
\&    use Type::Utils qw( extends );
\&    
\&    BEGIN { extends("Types::Standard") };
\&    
\&    # define your own types here
\&  }
.Ve
.PP
The \f(CW\*(C`extends\*(C'\fR function (which you should usually use in a \f(CW\*(C`BEGIN { }\*(C'\fR
block not only loads another type library, but it also adds all the types
from it to your library.
.PP
This means code using the above My::Types doesn't need to do:
.PP
.Vb 2
\&  use Types::Standard qw( Str );
\&  use My::Types qw( Something );
.Ve
.PP
It can just do:
.PP
.Vb 1
\&  use My::Types qw( Str Something );
.Ve
.PP
Because all the types from Types::Standard have been copied across into
My::Types and are also available there.
.PP
\&\f(CW\*(C`extends\*(C'\fR can be passed a list of libraries; you can inherit from multiple
existing libraries. It can also recognize and import types from
MooseX::Types, MouseX::Types, and Specio::Exporter libraries.
.PP
Since Type::Library 1.012, there has been a shortcut for \f(CW\*(C`extends\*(C'\fR.
.PP
.Vb 2
\&  package My::Types {
\&    use Type::Library \-extends => [ \*(AqTypes::Standard\*(Aq ];
\&    
\&    # define your own types here
\&  }
.Ve
.PP
The \f(CW\*(C`\-extends\*(C'\fR flag takes an arrayref of type libraries to extend.
It automatically implies \f(CW\*(C`\-base\*(C'\fR so you don't need to use both.
.SS "Custom Error Messages"
.IX Subsection "Custom Error Messages"
A type constraint can have custom error messages. It's pretty simple:
.PP
.Vb 6
\&  Type::Tiny\->new(
\&    name       => \*(AqEvenNumber\*(Aq,
\&    parent     => Types::Standard::Int,
\&    constraint => sub {
\&      # in this sub we don\*(Aqt need to check that $_ is an Int
\&      # because the parent will take care of that!
\&      
\&      $_ % 2 == 0
\&    },
\&    message   => sub {
\&      sprintf \*(Aq%s is not an even number\*(Aq, Type::Tiny::_dd($_);
\&    },
\&  );
.Ve
.PP
The message coderef just takes a value in \f(CW$_\fR and returns a string.
It may use \f(CW\*(C`Type::Tiny::_dd()\*(C'\fR as a way of pretty-printing a value.
(Don't be put off by the underscore in the function name. \f(CW\*(C`_dd()\*(C'\fR
is an officially supported part of Type::Tiny's \s-1API\s0 now.)
.PP
You don't have to use \f(CW\*(C`_dd()\*(C'\fR. You can generate any error string you
like. But \f(CW\*(C`_dd()\*(C'\fR will help you make undef and the empty string look
different, and will pretty-print references, and so on.
.PP
There's no need to supply an error message coderef unless you really want
custom error messages. The default sub should be reasonable.
.SS "Inlining"
.IX Subsection "Inlining"
In Perl, sub calls are relatively expensive in terms of memory and \s-1CPU\s0 use.
The \fBPositiveInt\fR type inherits from \fBInt\fR which inherits from \fBNum\fR
which inherits from \fBStr\fR which inherits from \fBDefined\fR which inherits
from \fBItem\fR which inherits from \fBAny\fR.
.PP
So you might think that to check of \f(CW$value\fR is a \fBPositiveInt\fR,
it needs to be checked all the way up the inheritance chain. But this is
where one of Type::Tiny's big optimizations happens. Type::Tiny can glue
together a bunch of checks with a stringy eval, and get a single coderef
that can do all the checks in one go.
.PP
This is why when Type::Tiny gives you a choice of using a coderef or a
string of Perl code, you should usually choose the string of Perl code.
A single coderef can \*(L"break the chain\*(R".
.PP
But these automatically generated strings of Perl code are not always
as efficient as they could be. For example, imagine that \fBHashRef\fR is
defined as:
.PP
.Vb 10
\&  my $Defined = Type::Tiny\->new(
\&    name       => \*(AqDefined\*(Aq,
\&    constraint => \*(Aqdefined($_)\*(Aq,
\&  );
\&  my $Ref = Type::Tiny\->new(
\&    name       => \*(AqRef\*(Aq,
\&    parent     => $Defined,
\&    constraint => \*(Aqref($_)\*(Aq,
\&  );
\&  my $HashRef = Type::Tiny\->new(
\&    name       => \*(AqHashRef\*(Aq,
\&    parent     => $Ref,
\&    constraint => \*(Aqref($_) eq "HASH"\*(Aq,
\&  );
.Ve
.PP
Then the combined check is:
.PP
.Vb 1
\&  defined($_) and ref($_) and ref($_) eq "HASH"
.Ve
.PP
Actually in practice it's even more complicated, because Type::Tiny needs
to localize and set \f(CW$_\fR first.
.PP
But in practice, the following should be a sufficient check:
.PP
.Vb 1
\&  ref($_) eq "HASH"
.Ve
.PP
It is possible for the \fBHashRef\fR type to have more control over the
string of code generated.
.PP
.Vb 9
\&  my $HashRef = Type::Tiny\->new(
\&    name       => \*(AqHashRef\*(Aq,
\&    parent     => $Ref,
\&    constraint => \*(Aqref($_) eq "HASH"\*(Aq,
\&    inlined    => sub {
\&      my $varname = pop;
\&      sprintf \*(Aqref(%s) eq "HASH"\*(Aq, $varname;
\&    },
\&  );
.Ve
.PP
The inlined coderef gets passed the name of a variable to check. This could
be \f(CW\*(Aq$_\*(Aq\fR or \f(CW\*(Aq$var\*(Aq\fR or \f(CW\*(C`$some{deep}{thing}[0]\*(C'\fR. Because it
is passed the name of a variable to check, instead of always checking
\&\f(CW$_\fR, this enables very efficient checking for parameterized types.
.PP
Although in this case, the inlining coderef is just returning a string,
technically it returns a list of strings. If there's multiple strings,
Type::Tiny will join them together in a big \*(L"&&\*(R" statement.
.PP
As a special case, if the first item in the returned list of strings is
undef, then Type::Tiny will substitute the parent type constraint's inlined
string in its place. So an inlieing coderef for even numbers might be:
.PP
.Vb 9
\&  Type::Tiny\->new(
\&    name       => \*(AqEvenNumber\*(Aq,
\&    parent     => Types::Standard::Int,
\&    constraint => sub { $_ % 2 == 0 },
\&    inlined    => sub {
\&      my $varname = pop;
\&      return (undef, "$varname % 2 == 0");
\&    },
\&  );
.Ve
.PP
Even if you provide a coderef as a string, an inlining coderef has the
potential to generate more efficient code, so you should consider
providing one.
.SS "Pre-Declaring Types"
.IX Subsection "Pre-Declaring Types"
.Vb 2
\&  use Type::Library \-base,
\&    \-declare => qw( Foo Bar Baz );
.Ve
.PP
This declares types \fBFoo\fR, \fBBar\fR, and \fBBaz\fR at compile time so they can
safely be used as barewords in your type library.
.PP
This also allows recursively defined types to (mostly) work!
.PP
.Vb 3
\&  use Type::Library \-base,
\&    \-declare => qw( NumericArrayRef );
\&  use Types::Standard qw( Num ArrayRef );
\&  
\&  _\|_PACKAGE_\|_\->add_type(
\&    name     => NumericArrayRef,
\&    parent   => ArrayRef\->of( Num | NumericArrayRef ),
\&  );
.Ve
.PP
(Support for recursive type definitions added in Type::Library 1.009_000.)
.SS "Parameterizable Types"
.IX Subsection "Parameterizable Types"
This is probably the most \*(L"meta\*(R" concept that is going to be covered.
Building your own type constraint that can be parameterized like
\&\fBArrayRef\fR or \fBHasMethods\fR.
.PP
The type constraint we'll build will be \fBMultipleOf[$i]\fR which
checks that an integer is a multiple of \f(CW$i\fR.
.PP
.Vb 3
\&  _\|_PACKAGE_\|_\->add_type(
\&    name       => \*(AqMultipleOf\*(Aq,
\&    parent     => Int,
\&    
\&    # This coderef gets passed the contents of the square brackets.
\&    constraint_generator => sub {
\&      my $i = assert_Int(shift);
\&      # needs to return a coderef to use as a constraint for the
\&      # parameterized type
\&      return sub { $_ % $i == 0 };
\&    },
\&    
\&    # optional but recommended
\&    inline_generator => sub {
\&      my $i = shift;
\&      return sub {
\&        my $varname = pop;
\&        return (undef, "$varname % $i == 0");
\&      };
\&    },
\&    
\&    # probably the most complex bit
\&    coercion_generator => sub {
\&      my $i = $_[2];
\&      require Type::Coercion;
\&      return Type::Coercion\->new(
\&        type_coercion_map => [
\&          Num, qq{ int($i * int(\e$_/$i)) }
\&        ],
\&      );
\&    },
\&  );
.Ve
.PP
Now we can define an even number like this:
.PP
.Vb 5
\&  _\|_PACKAGE_\|_\->add_type(
\&    name     => \*(AqEvenNumber\*(Aq,
\&    parent   => _\|_PACKAGE_\|_\->get_type(\*(AqMultipleOf\*(Aq)\->of(2),
\&    coercion => 1,  # inherit from parent
\&  );
.Ve
.PP
Note that it is possible for a type constraint to have a \f(CW\*(C`constraint\*(C'\fR
\&\fIand\fR a \f(CW\*(C`constraint_generator\*(C'\fR.
.PP
.Vb 3
\&  BaseType          # uses the constraint
\&  BaseType[]        # constraint_generator with no arguments
\&  BaseType[$x]      # constraint_generator with an argument
.Ve
.PP
In the \fBMultipleOf\fR example above, \fBMultipleOf[]\fR with no number would
throw an error because of \f(CW\*(C`assert_Int(shift)\*(C'\fR not finding an integer.
.PP
But it is certainly possible for \fBBaseType[]\fR to be meaningful and
distinct from \f(CW\*(C`BaseType\*(C'\fR.
.PP
For example, \fBTuple\fR is just the same as \fBArrayRef\fR and accepts any
arrayref as being valid. But \fBTuple[]\fR will only accept arrayrefs
with zero elements in them. (Just like \fBTuple[Any,Any]\fR will only
accept arrayrefs with two elements.)
.SH "NEXT STEPS"
.IX Header "NEXT STEPS"
After that last example, probably have a little lie down. Once you're
recovered, here's your next step:
.IP "\(bu" 4
Type::Tiny::Manual::UsingWithMoose
.Sp
How to use Type::Tiny with Moose, including the advantages of Type::Tiny
over built-in type constraints, and Moose-specific features.
.SH "AUTHOR"
.IX Header "AUTHOR"
Toby Inkster <tobyink@cpan.org>.
.SH "COPYRIGHT AND LICENCE"
.IX Header "COPYRIGHT AND LICENCE"
This software is copyright (c) 2013\-2014, 2017\-2020 by Toby Inkster.
.PP
This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.
.SH "DISCLAIMER OF WARRANTIES"
.IX Header "DISCLAIMER OF WARRANTIES"
\&\s-1THIS PACKAGE IS PROVIDED \*(L"AS IS\*(R" AND WITHOUT ANY EXPRESS OR IMPLIED
WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.\s0
