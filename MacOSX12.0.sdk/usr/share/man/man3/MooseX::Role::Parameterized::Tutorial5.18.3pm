.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "MooseX::Role::Parameterized::Tutorial 3"
.TH MooseX::Role::Parameterized::Tutorial 3 "2012-08-14" "perl v5.18.4" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
MooseX::Role::Parameterized::Tutorial \- why and how
.SH "MOTIVATION"
.IX Header "MOTIVATION"
Roles are composable units of behavior. They are useful for factoring out
functionality common to many classes from any part of your class hierarchy. See
Moose::Cookbook::Roles::Recipe1 for an introduction to Moose::Role.
.PP
While combining roles affords you a great deal of flexibility, individual roles
have very little in the way of configurability. Core Moose provides \f(CW\*(C`\-alias\*(C'\fR
for renaming methods and \f(CW\*(C`\-excludes\*(C'\fR for ignoring methods. These options are
primarily for resolving role conflicts. Depending on how much of a purist you are,
these options are \fIsolely\fR for resolving role conflicts. See
Moose::Cookbook::Roles::Recipe2 for more about \f(CW\*(C`\-alias\*(C'\fR and \f(CW\*(C`\-excludes\*(C'\fR.
.PP
Because roles serve many different masters, they usually provide only the least
common denominator of functionality. To empower roles further, more
configurability than \f(CW\*(C`\-alias\*(C'\fR and \f(CW\*(C`\-excludes\*(C'\fR is required. Perhaps your role
needs to know which method to call when it is done processing. Or what default
value to use for its \f(CW\*(C`url\*(C'\fR attribute.
.PP
Parameterized roles offer a solution to these (and other) kinds of problems.
.SH "USAGE"
.IX Header "USAGE"
\fI\f(CI\*(C`with\*(C'\fI\fR
.IX Subsection "with"
.PP
The syntax of a class consuming a parameterized role has not changed
from the standard \f(CW\*(C`with\*(C'\fR. You pass in parameters just like you
pass in \f(CW\*(C`\-alias\*(C'\fR and \f(CW\*(C`\-excludes\*(C'\fR to ordinary roles (though your
custom parameters do not get hyphens, since these are not core Moose
composition parameters):
.PP
.Vb 4
\&    with \*(AqMyRole::InstrumentMethod\*(Aq => {
\&        method_name => \*(Aqdbh_do\*(Aq,
\&        log_to      => \*(Aqquery.log\*(Aq,
\&    };
.Ve
.PP
You can still combine parameterized roles. You just need to specify parameters
immediately after the role they belong to:
.PP
.Vb 6
\&    with (
\&        \*(AqMy::Parameterized::Role\*(Aq => {
\&            needs_better_example => 1,
\&        },
\&        \*(AqMy::Other::Role\*(Aq,
\&    );
.Ve
.PP
We, like Moose itself, use Data::OptList to make sure that a list of role
names and associated parameters is handled correctly.
.PP
\fI\f(CI\*(C`parameter\*(C'\fI\fR
.IX Subsection "parameter"
.PP
Inside your parameterized role, you specify a set of parameters. This is
exactly like specifying the attributes of a class. Instead of \*(L"has\*(R" in Moose you
use the keyword \f(CW\*(C`parameter\*(C'\fR, but your parameters can use any options to
\&\f(CW\*(C`has\*(C'\fR.
.PP
.Vb 4
\&    parameter \*(Aqdelegation\*(Aq => (
\&        isa       => \*(AqHashRef|ArrayRef|RegexpRef\*(Aq,
\&        predicate => \*(Aqhas_delegation\*(Aq,
\&    );
.Ve
.PP
You do have to declare what parameters you accept, just like you have to
declare what attributes you accept for regular Moose objects.
.PP
One departure from \f(CW\*(C`has\*(C'\fR is that we create a reader accessor for you by
default. In other words, we assume \f(CW\*(C`is => \*(Aqro\*(Aq\*(C'\fR. We create this reader for
convenience because generally the parameterized role is the only consumer of
the parameters object, so data hiding is not as important than in the general
case of \*(L"has\*(R" in Moose. If you do not want an accessor, you can use
\&\f(CW\*(C`is => \*(Aqbare\*(Aq\*(C'\fR.
.PP
\fI\f(CI\*(C`role\*(C'\fI\fR
.IX Subsection "role"
.PP
\&\f(CW\*(C`role\*(C'\fR takes a block of code that will be used to generate your role with its
parameters bound. Here is where you declare components that depend on
parameters. You can declare attributes, methods, modifiers, etc. The first
argument to the \f(CW\*(C`role\*(C'\fR is an object containing the parameters specified by
\&\f(CW\*(C`with\*(C'\fR. You can access the parameters just like regular attributes on that
object.
.PP
Each time you compose this parameterized role, the \f(CW\*(C`role {}\*(C'\fR block will be
executed. It will receive a new parameter object and produce an entirely new
role. That's the whole point, after all.
.PP
Due to limitations inherent in Perl, you must declare methods with
\&\f(CW\*(C`method name => sub { ... }\*(C'\fR instead of the usual \f(CW\*(C`sub name { ... }\*(C'\fR.
Your methods may, of course, close over the parameter object. This means that
your methods may use parameters however they wish!
.SH "USES"
.IX Header "USES"
Ideally these will become fully-explained examples in something resembling
Moose::Cookbook. But for now, only a braindump.
.IP "Configure a role's attributes" 4
.IX Item "Configure a role's attributes"
You can rename methods with core Moose, but now you can rename attributes. You
can now also choose type, default value, whether it's required, \fBtraits\fR, etc.
.Sp
.Vb 4
\&    parameter traits => (
\&        isa     => \*(AqArrayRef\*(Aq,
\&        default => sub { [] },
\&    );
\&
\&    parameter type => (
\&        isa     => \*(AqStr\*(Aq,
\&        default => \*(AqAny\*(Aq,
\&    );
\&
\&    role {
\&        my $p = shift;
\&
\&        has action => (
\&            traits => $p\->traits,
\&            isa    => $p\->type,
\&            ...
\&        );
\&    }
.Ve
.IP "Inform a role of your class' attributes and methods" 4
.IX Item "Inform a role of your class' attributes and methods"
Core roles can only require methods with specific names chosen by the role. Now
your roles can demand that the class specifies a method name you wish the role to
instrument, or which attributes to dump to a file.
.Sp
.Vb 4
\&    parameter instrument_method => (
\&        isa      => \*(AqStr\*(Aq,
\&        required => 1,
\&    );
\&
\&    role {
\&        my $p = shift;
\&        around $p\->instrument_method => sub { ... };
\&    }
.Ve
.IP "Arbitrary execution choices" 4
.IX Item "Arbitrary execution choices"
Your role may be able to provide configuration in how the role's methods
operate. For example, you can tell the role whether to save intermediate
states.
.Sp
.Vb 4
\&    parameter save_intermediate => (
\&        isa     => \*(AqBool\*(Aq,
\&        default => 0,
\&    );
\&
\&    role {
\&        my $p = shift;
\&        method process => sub {
\&            ...
\&            if ($p\->save_intermediate) { ... }
\&            ...
\&        };
\&    }
.Ve
.IP "Deciding a backend" 4
.IX Item "Deciding a backend"
Your role may be able to freeze and thaw your instances using \s-1YAML\s0, \s-1JSON\s0,
Storable. Which backend to use can be a parameter.
.Sp
.Vb 4
\&    parameter format => (
\&        isa     => (enum [\*(AqStorable\*(Aq, \*(AqYAML\*(Aq, \*(AqJSON\*(Aq]),
\&        default => \*(AqStorable\*(Aq,
\&    );
\&
\&    role {
\&        my $p = shift;
\&        if ($p\->format eq \*(AqStorable\*(Aq) {
\&            method freeze => \e&Storable::freeze;
\&            method thaw   => \e&Storable::thaw;
\&        }
\&        elsif ($p\->format eq \*(AqYAML\*(Aq) {
\&            method freeze => \e&YAML::Dump;
\&            method thaw   => \e&YAML::Load;
\&        }
\&        ...
\&    }
.Ve
.IP "Additional validation" 4
.IX Item "Additional validation"
Ordinary roles can require that its consumers have a particular list of method
names. Since parameterized roles have direct access to its consumer, you can inspect it and throw errors if the consumer does not meet your needs.
.Sp
.Vb 4
\&    role {
\&        my $p    = shift;
\&        my %args = @_;
\&        my $consumer = $args{consumer};
\&
\&        $consumer\->find_attribute_by_name(\*(Aqstack\*(Aq)
\&            or confess "You must have a \*(Aqstack\*(Aq attribute";
\&
\&        my $push = $consumer\->find_method_by_name(\*(Aqpush\*(Aq)
\&            or confess "You must have a \*(Aqpush\*(Aq method";
\&
\&        my $params = $push\->parsed_signature\->positional_params\->params;
\&        @$params == 1
\&            or confess "Your push method must take a single parameter";
\&
\&        $params\->[0]\->sigil eq \*(Aq$\*(Aq
\&            or confess "Your push parameter must be a scalar";
\&
\&        ...
\&    }
.Ve
