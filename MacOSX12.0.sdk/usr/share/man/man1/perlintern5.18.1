.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PERLINTERN 1"
.TH PERLINTERN 1 "2021-08-27" "perl v5.18.4" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
perlintern \- autogenerated documentation of purely internal
		 Perl functions
.SH "DESCRIPTION"
.IX Xref "internal Perl functions interpreter functions"
.IX Header "DESCRIPTION"
This file is the autogenerated documentation of functions in the
Perl interpreter that are documented using Perl's internal documentation
format but are not marked as part of the Perl \s-1API.\s0 In other words,
\&\fBthey are not for use in extensions\fR!
.SH "Compile-time scope hooks"
.IX Header "Compile-time scope hooks"
.IP "BhkENTRY" 8
.IX Xref "BhkENTRY"
.IX Item "BhkENTRY"
Return an entry from the \s-1BHK\s0 structure. \fIwhich\fR is a preprocessor token
indicating which entry to return. If the appropriate flag is not set
this will return \s-1NULL.\s0 The type of the return value depends on which
entry you ask for.
.Sp
\&\s-1NOTE:\s0 this function is experimental and may change or be
removed without notice.
.Sp
.Vb 1
\&        void *  BhkENTRY(BHK *hk, which)
.Ve
.IP "BhkFLAGS" 8
.IX Xref "BhkFLAGS"
.IX Item "BhkFLAGS"
Return the \s-1BHK\s0's flags.
.Sp
\&\s-1NOTE:\s0 this function is experimental and may change or be
removed without notice.
.Sp
.Vb 1
\&        U32     BhkFLAGS(BHK *hk)
.Ve
.IP "\s-1CALL_BLOCK_HOOKS \s0" 8
.IX Xref "CALL_BLOCK_HOOKS"
.IX Item "CALL_BLOCK_HOOKS "
Call all the registered block hooks for type \fIwhich\fR. \fIwhich\fR is a
preprocessing token; the type of \fIarg\fR depends on \fIwhich\fR.
.Sp
\&\s-1NOTE:\s0 this function is experimental and may change or be
removed without notice.
.Sp
.Vb 1
\&        void    CALL_BLOCK_HOOKS(which, arg)
.Ve
.SH "CV reference counts and CvOUTSIDE"
.IX Header "CV reference counts and CvOUTSIDE"
.IP "CvWEAKOUTSIDE" 8
.IX Xref "CvWEAKOUTSIDE"
.IX Item "CvWEAKOUTSIDE"
Each \s-1CV\s0 has a pointer, \f(CW\*(C`CvOUTSIDE()\*(C'\fR, to its lexically enclosing
\&\s-1CV \s0(if any). Because pointers to anonymous sub prototypes are
stored in \f(CW\*(C`&\*(C'\fR pad slots, it is a possible to get a circular reference,
with the parent pointing to the child and vice-versa. To avoid the
ensuing memory leak, we do not increment the reference count of the \s-1CV\s0
pointed to by \f(CW\*(C`CvOUTSIDE\*(C'\fR in the \fIone specific instance\fR that the parent
has a \f(CW\*(C`&\*(C'\fR pad slot pointing back to us. In this case, we set the
\&\f(CW\*(C`CvWEAKOUTSIDE\*(C'\fR flag in the child. This allows us to determine under what
circumstances we should decrement the refcount of the parent when freeing
the child.
.Sp
There is a further complication with non-closure anonymous subs (i.e. those
that do not refer to any lexicals outside that sub). In this case, the
anonymous prototype is shared rather than being cloned. This has the
consequence that the parent may be freed while there are still active
children, eg
.Sp
.Vb 1
\&    BEGIN { $a = sub { eval \*(Aq$x\*(Aq } }
.Ve
.Sp
In this case, the \s-1BEGIN\s0 is freed immediately after execution since there
are no active references to it: the anon sub prototype has
\&\f(CW\*(C`CvWEAKOUTSIDE\*(C'\fR set since it's not a closure, and \f(CW$a\fR points to the same
\&\s-1CV,\s0 so it doesn't contribute to \s-1BEGIN\s0's refcount either.  When \f(CW$a\fR is
executed, the \f(CW\*(C`eval \*(Aq$x\*(Aq\*(C'\fR causes the chain of \f(CW\*(C`CvOUTSIDE\*(C'\fRs to be followed,
and the freed \s-1BEGIN\s0 is accessed.
.Sp
To avoid this, whenever a \s-1CV\s0 and its associated pad is freed, any
\&\f(CW\*(C`&\*(C'\fR entries in the pad are explicitly removed from the pad, and if the
refcount of the pointed-to anon sub is still positive, then that
child's \f(CW\*(C`CvOUTSIDE\*(C'\fR is set to point to its grandparent. This will only
occur in the single specific case of a non-closure anon prototype
having one or more active references (such as \f(CW$a\fR above).
.Sp
One other thing to consider is that a \s-1CV\s0 may be merely undefined
rather than freed, eg \f(CW\*(C`undef &foo\*(C'\fR. In this case, its refcount may
not have reached zero, but we still delete its pad and its \f(CW\*(C`CvROOT\*(C'\fR etc.
Since various children may still have their \f(CW\*(C`CvOUTSIDE\*(C'\fR pointing at this
undefined \s-1CV,\s0 we keep its own \f(CW\*(C`CvOUTSIDE\*(C'\fR for the time being, so that
the chain of lexical scopes is unbroken. For example, the following
should print 123:
.Sp
.Vb 5
\&    my $x = 123;
\&    sub tmp { sub { eval \*(Aq$x\*(Aq } }
\&    my $a = tmp();
\&    undef &tmp;
\&    print  $a\->();
\&
\&        bool    CvWEAKOUTSIDE(CV *cv)
.Ve
.SH "Embedding Functions"
.IX Header "Embedding Functions"
.IP "cv_dump" 8
.IX Xref "cv_dump"
.IX Item "cv_dump"
dump the contents of a \s-1CV\s0
.Sp
.Vb 1
\&        void    cv_dump(CV *cv, const char *title)
.Ve
.IP "cv_forget_slab" 8
.IX Xref "cv_forget_slab"
.IX Item "cv_forget_slab"
When a \s-1CV\s0 has a reference count on its slab (CvSLABBED), it is responsible
for making sure it is freed.  (Hence, no two CVs should ever have a
reference count on the same slab.)  The \s-1CV\s0 only needs to reference the slab
during compilation.  Once it is compiled and CvROOT attached, it has
finished its job, so it can forget the slab.
.Sp
.Vb 1
\&        void    cv_forget_slab(CV *cv)
.Ve
.IP "do_dump_pad" 8
.IX Xref "do_dump_pad"
.IX Item "do_dump_pad"
Dump the contents of a padlist
.Sp
.Vb 2
\&        void    do_dump_pad(I32 level, PerlIO *file,
\&                            PADLIST *padlist, int full)
.Ve
.IP "intro_my" 8
.IX Xref "intro_my"
.IX Item "intro_my"
\&\*(L"Introduce\*(R" my variables to visible status.  This is called during parsing
at the end of each statement to make lexical variables visible to
subsequent statements.
.Sp
.Vb 1
\&        U32     intro_my()
.Ve
.IP "padlist_dup" 8
.IX Xref "padlist_dup"
.IX Item "padlist_dup"
Duplicates a pad.
.Sp
.Vb 2
\&        PADLIST * padlist_dup(PADLIST *srcpad,
\&                              CLONE_PARAMS *param)
.Ve
.IP "pad_alloc_name" 8
.IX Xref "pad_alloc_name"
.IX Item "pad_alloc_name"
Allocates a place in the currently-compiling
pad (via \*(L"pad_alloc\*(R" in perlapi) and
then stores a name for that entry.  \fInamesv\fR is adopted and becomes the
name entry; it must already contain the name string and be sufficiently
upgraded.  \fItypestash\fR and \fIourstash\fR and the \f(CW\*(C`padadd_STATE\*(C'\fR flag get
added to \fInamesv\fR.  None of the other
processing of \*(L"pad_add_name_pvn\*(R" in perlapi
is done.  Returns the offset of the allocated pad slot.
.Sp
.Vb 2
\&        PADOFFSET pad_alloc_name(SV *namesv, U32 flags,
\&                                 HV *typestash, HV *ourstash)
.Ve
.IP "pad_block_start" 8
.IX Xref "pad_block_start"
.IX Item "pad_block_start"
Update the pad compilation state variables on entry to a new block.
.Sp
.Vb 1
\&        void    pad_block_start(int full)
.Ve
.IP "pad_check_dup" 8
.IX Xref "pad_check_dup"
.IX Item "pad_check_dup"
Check for duplicate declarations: report any of:
.Sp
.Vb 3
\&     * a my in the current scope with the same name;
\&     * an our (anywhere in the pad) with the same name and the
\&       same stash as C<ourstash>
.Ve
.Sp
\&\f(CW\*(C`is_our\*(C'\fR indicates that the name to check is an 'our' declaration.
.Sp
.Vb 2
\&        void    pad_check_dup(SV *name, U32 flags,
\&                              const HV *ourstash)
.Ve
.IP "pad_findlex" 8
.IX Xref "pad_findlex"
.IX Item "pad_findlex"
Find a named lexical anywhere in a chain of nested pads. Add fake entries
in the inner pads if it's found in an outer one.
.Sp
Returns the offset in the bottom pad of the lex or the fake lex.
cv is the \s-1CV\s0 in which to start the search, and seq is the current cop_seq
to match against. If warn is true, print appropriate warnings.  The out_*
vars return values, and so are pointers to where the returned values
should be stored. out_capture, if non-null, requests that the innermost
instance of the lexical is captured; out_name_sv is set to the innermost
matched namesv or fake namesv; out_flags returns the flags normally
associated with the \s-1IVX\s0 field of a fake namesv.
.Sp
Note that \fIpad_findlex()\fR is recursive; it recurses up the chain of CVs,
then comes back down, adding fake entries as it goes. It has to be this way
because fake namesvs in anon protoypes have to store in xlow the index into
the parent pad.
.Sp
.Vb 5
\&        PADOFFSET pad_findlex(const char *namepv,
\&                              STRLEN namelen, U32 flags,
\&                              const CV* cv, U32 seq, int warn,
\&                              SV** out_capture,
\&                              SV** out_name_sv, int *out_flags)
.Ve
.IP "pad_fixup_inner_anons" 8
.IX Xref "pad_fixup_inner_anons"
.IX Item "pad_fixup_inner_anons"
For any anon CVs in the pad, change CvOUTSIDE of that \s-1CV\s0 from
old_cv to new_cv if necessary. Needed when a newly-compiled \s-1CV\s0 has to be
moved to a pre-existing \s-1CV\s0 struct.
.Sp
.Vb 2
\&        void    pad_fixup_inner_anons(PADLIST *padlist,
\&                                      CV *old_cv, CV *new_cv)
.Ve
.IP "pad_free" 8
.IX Xref "pad_free"
.IX Item "pad_free"
Free the \s-1SV\s0 at offset po in the current pad.
.Sp
.Vb 1
\&        void    pad_free(PADOFFSET po)
.Ve
.IP "pad_leavemy" 8
.IX Xref "pad_leavemy"
.IX Item "pad_leavemy"
Cleanup at end of scope during compilation: set the max seq number for
lexicals in this scope and warn of any lexicals that never got introduced.
.Sp
.Vb 1
\&        void    pad_leavemy()
.Ve
.IP "pad_push" 8
.IX Xref "pad_push"
.IX Item "pad_push"
Push a new pad frame onto the padlist, unless there's already a pad at
this depth, in which case don't bother creating a new one.  Then give
the new pad an \f(CW@_\fR in slot zero.
.Sp
.Vb 1
\&        void    pad_push(PADLIST *padlist, int depth)
.Ve
.IP "pad_reset" 8
.IX Xref "pad_reset"
.IX Item "pad_reset"
Mark all the current temporaries for reuse
.Sp
.Vb 1
\&        void    pad_reset()
.Ve
.IP "pad_swipe" 8
.IX Xref "pad_swipe"
.IX Item "pad_swipe"
Abandon the tmp in the current pad at offset po and replace with a
new one.
.Sp
.Vb 1
\&        void    pad_swipe(PADOFFSET po, bool refadjust)
.Ve
.SH "Functions in file op.c"
.IX Header "Functions in file op.c"
.IP "core_prototype" 8
.IX Xref "core_prototype"
.IX Item "core_prototype"
This function assigns the prototype of the named core function to \f(CW\*(C`sv\*(C'\fR, or
to a new mortal \s-1SV\s0 if \f(CW\*(C`sv\*(C'\fR is \s-1NULL. \s0 It returns the modified \f(CW\*(C`sv\*(C'\fR, or
\&\s-1NULL\s0 if the core function has no prototype.  \f(CW\*(C`code\*(C'\fR is a code as returned
by \f(CW\*(C`keyword()\*(C'\fR.  It must not be equal to 0 or \-KEY_CORE.
.Sp
.Vb 3
\&        SV *    core_prototype(SV *sv, const char *name,
\&                               const int code,
\&                               int * const opnum)
.Ve
.SH "Functions in file pp_ctl.c"
.IX Header "Functions in file pp_ctl.c"
.IP "docatch" 8
.IX Xref "docatch"
.IX Item "docatch"
Check for the cases 0 or 3 of cur_env.je_ret, only used inside an eval context.
.Sp
0 is used as continue inside eval,
.Sp
3 is used for a die caught by an inner eval \- continue inner loop
.Sp
See cop.h: je_mustcatch, when set at any runlevel to \s-1TRUE,\s0 means eval ops must
establish a local jmpenv to handle exception traps.
.Sp
.Vb 1
\&        OP*     docatch(OP *o)
.Ve
.SH "GV Functions"
.IX Header "GV Functions"
.IP "gv_try_downgrade" 8
.IX Xref "gv_try_downgrade"
.IX Item "gv_try_downgrade"
If the typeglob \f(CW\*(C`gv\*(C'\fR can be expressed more succinctly, by having
something other than a real \s-1GV\s0 in its place in the stash, replace it
with the optimised form.  Basic requirements for this are that \f(CW\*(C`gv\*(C'\fR
is a real typeglob, is sufficiently ordinary, and is only referenced
from its package.  This function is meant to be used when a \s-1GV\s0 has been
looked up in part to see what was there, causing upgrading, but based
on what was found it turns out that the real \s-1GV\s0 isn't required after all.
.Sp
If \f(CW\*(C`gv\*(C'\fR is a completely empty typeglob, it is deleted from the stash.
.Sp
If \f(CW\*(C`gv\*(C'\fR is a typeglob containing only a sufficiently-ordinary constant
sub, the typeglob is replaced with a scalar-reference placeholder that
more compactly represents the same thing.
.Sp
\&\s-1NOTE:\s0 this function is experimental and may change or be
removed without notice.
.Sp
.Vb 1
\&        void    gv_try_downgrade(GV* gv)
.Ve
.SH "Hash Manipulation Functions"
.IX Header "Hash Manipulation Functions"
.IP "hv_ename_add" 8
.IX Xref "hv_ename_add"
.IX Item "hv_ename_add"
Adds a name to a stash's internal list of effective names.  See
\&\f(CW\*(C`hv_ename_delete\*(C'\fR.
.Sp
This is called when a stash is assigned to a new location in the symbol
table.
.Sp
.Vb 2
\&        void    hv_ename_add(HV *hv, const char *name, U32 len,
\&                             U32 flags)
.Ve
.IP "hv_ename_delete" 8
.IX Xref "hv_ename_delete"
.IX Item "hv_ename_delete"
Removes a name from a stash's internal list of effective names.  If this is
the name returned by \f(CW\*(C`HvENAME\*(C'\fR, then another name in the list will take
its place (\f(CW\*(C`HvENAME\*(C'\fR will use it).
.Sp
This is called when a stash is deleted from the symbol table.
.Sp
.Vb 2
\&        void    hv_ename_delete(HV *hv, const char *name,
\&                                U32 len, U32 flags)
.Ve
.IP "refcounted_he_chain_2hv" 8
.IX Xref "refcounted_he_chain_2hv"
.IX Item "refcounted_he_chain_2hv"
Generates and returns a \f(CW\*(C`HV *\*(C'\fR representing the content of a
\&\f(CW\*(C`refcounted_he\*(C'\fR chain.
\&\fIflags\fR is currently unused and must be zero.
.Sp
.Vb 3
\&        HV *    refcounted_he_chain_2hv(
\&                    const struct refcounted_he *c, U32 flags
\&                )
.Ve
.IP "refcounted_he_fetch_pv" 8
.IX Xref "refcounted_he_fetch_pv"
.IX Item "refcounted_he_fetch_pv"
Like \*(L"refcounted_he_fetch_pvn\*(R", but takes a nul-terminated string
instead of a string/length pair.
.Sp
.Vb 4
\&        SV *    refcounted_he_fetch_pv(
\&                    const struct refcounted_he *chain,
\&                    const char *key, U32 hash, U32 flags
\&                )
.Ve
.IP "refcounted_he_fetch_pvn" 8
.IX Xref "refcounted_he_fetch_pvn"
.IX Item "refcounted_he_fetch_pvn"
Search along a \f(CW\*(C`refcounted_he\*(C'\fR chain for an entry with the key specified
by \fIkeypv\fR and \fIkeylen\fR.  If \fIflags\fR has the \f(CW\*(C`REFCOUNTED_HE_KEY_UTF8\*(C'\fR
bit set, the key octets are interpreted as \s-1UTF\-8,\s0 otherwise they
are interpreted as Latin\-1.  \fIhash\fR is a precomputed hash of the key
string, or zero if it has not been precomputed.  Returns a mortal scalar
representing the value associated with the key, or \f(CW&PL_sv_placeholder\fR
if there is no value associated with the key.
.Sp
.Vb 5
\&        SV *    refcounted_he_fetch_pvn(
\&                    const struct refcounted_he *chain,
\&                    const char *keypv, STRLEN keylen, U32 hash,
\&                    U32 flags
\&                )
.Ve
.IP "refcounted_he_fetch_pvs" 8
.IX Xref "refcounted_he_fetch_pvs"
.IX Item "refcounted_he_fetch_pvs"
Like \*(L"refcounted_he_fetch_pvn\*(R", but takes a literal string instead of
a string/length pair, and no precomputed hash.
.Sp
.Vb 4
\&        SV *    refcounted_he_fetch_pvs(
\&                    const struct refcounted_he *chain,
\&                    const char *key, U32 flags
\&                )
.Ve
.IP "refcounted_he_fetch_sv" 8
.IX Xref "refcounted_he_fetch_sv"
.IX Item "refcounted_he_fetch_sv"
Like \*(L"refcounted_he_fetch_pvn\*(R", but takes a Perl scalar instead of a
string/length pair.
.Sp
.Vb 4
\&        SV *    refcounted_he_fetch_sv(
\&                    const struct refcounted_he *chain, SV *key,
\&                    U32 hash, U32 flags
\&                )
.Ve
.IP "refcounted_he_free" 8
.IX Xref "refcounted_he_free"
.IX Item "refcounted_he_free"
Decrements the reference count of a \f(CW\*(C`refcounted_he\*(C'\fR by one.  If the
reference count reaches zero the structure's memory is freed, which
(recursively) causes a reduction of its parent \f(CW\*(C`refcounted_he\*(C'\fR's
reference count.  It is safe to pass a null pointer to this function:
no action occurs in this case.
.Sp
.Vb 1
\&        void    refcounted_he_free(struct refcounted_he *he)
.Ve
.IP "refcounted_he_inc" 8
.IX Xref "refcounted_he_inc"
.IX Item "refcounted_he_inc"
Increment the reference count of a \f(CW\*(C`refcounted_he\*(C'\fR.  The pointer to the
\&\f(CW\*(C`refcounted_he\*(C'\fR is also returned.  It is safe to pass a null pointer
to this function: no action occurs and a null pointer is returned.
.Sp
.Vb 3
\&        struct refcounted_he * refcounted_he_inc(
\&                                   struct refcounted_he *he
\&                               )
.Ve
.IP "refcounted_he_new_pv" 8
.IX Xref "refcounted_he_new_pv"
.IX Item "refcounted_he_new_pv"
Like \*(L"refcounted_he_new_pvn\*(R", but takes a nul-terminated string instead
of a string/length pair.
.Sp
.Vb 5
\&        struct refcounted_he * refcounted_he_new_pv(
\&                                   struct refcounted_he *parent,
\&                                   const char *key, U32 hash,
\&                                   SV *value, U32 flags
\&                               )
.Ve
.IP "refcounted_he_new_pvn" 8
.IX Xref "refcounted_he_new_pvn"
.IX Item "refcounted_he_new_pvn"
Creates a new \f(CW\*(C`refcounted_he\*(C'\fR.  This consists of a single key/value
pair and a reference to an existing \f(CW\*(C`refcounted_he\*(C'\fR chain (which may
be empty), and thus forms a longer chain.  When using the longer chain,
the new key/value pair takes precedence over any entry for the same key
further along the chain.
.Sp
The new key is specified by \fIkeypv\fR and \fIkeylen\fR.  If \fIflags\fR has
the \f(CW\*(C`REFCOUNTED_HE_KEY_UTF8\*(C'\fR bit set, the key octets are interpreted
as \s-1UTF\-8,\s0 otherwise they are interpreted as Latin\-1.  \fIhash\fR is
a precomputed hash of the key string, or zero if it has not been
precomputed.
.Sp
\&\fIvalue\fR is the scalar value to store for this key.  \fIvalue\fR is copied
by this function, which thus does not take ownership of any reference
to it, and later changes to the scalar will not be reflected in the
value visible in the \f(CW\*(C`refcounted_he\*(C'\fR.  Complex types of scalar will not
be stored with referential integrity, but will be coerced to strings.
\&\fIvalue\fR may be either null or \f(CW&PL_sv_placeholder\fR to indicate that no
value is to be associated with the key; this, as with any non-null value,
takes precedence over the existence of a value for the key further along
the chain.
.Sp
\&\fIparent\fR points to the rest of the \f(CW\*(C`refcounted_he\*(C'\fR chain to be
attached to the new \f(CW\*(C`refcounted_he\*(C'\fR.  This function takes ownership
of one reference to \fIparent\fR, and returns one reference to the new
\&\f(CW\*(C`refcounted_he\*(C'\fR.
.Sp
.Vb 6
\&        struct refcounted_he * refcounted_he_new_pvn(
\&                                   struct refcounted_he *parent,
\&                                   const char *keypv,
\&                                   STRLEN keylen, U32 hash,
\&                                   SV *value, U32 flags
\&                               )
.Ve
.IP "refcounted_he_new_pvs" 8
.IX Xref "refcounted_he_new_pvs"
.IX Item "refcounted_he_new_pvs"
Like \*(L"refcounted_he_new_pvn\*(R", but takes a literal string instead of
a string/length pair, and no precomputed hash.
.Sp
.Vb 5
\&        struct refcounted_he * refcounted_he_new_pvs(
\&                                   struct refcounted_he *parent,
\&                                   const char *key, SV *value,
\&                                   U32 flags
\&                               )
.Ve
.IP "refcounted_he_new_sv" 8
.IX Xref "refcounted_he_new_sv"
.IX Item "refcounted_he_new_sv"
Like \*(L"refcounted_he_new_pvn\*(R", but takes a Perl scalar instead of a
string/length pair.
.Sp
.Vb 5
\&        struct refcounted_he * refcounted_he_new_sv(
\&                                   struct refcounted_he *parent,
\&                                   SV *key, U32 hash, SV *value,
\&                                   U32 flags
\&                               )
.Ve
.SH "IO Functions"
.IX Header "IO Functions"
.IP "start_glob" 8
.IX Xref "start_glob"
.IX Item "start_glob"
Function called by \f(CW\*(C`do_readline\*(C'\fR to spawn a glob (or do the glob inside
perl on \s-1VMS\s0). This code used to be inline, but now perl uses \f(CW\*(C`File::Glob\*(C'\fR
this glob starter is only used by miniperl during the build process.
Moving it away shrinks pp_hot.c; shrinking pp_hot.c helps speed perl up.
.Sp
\&\s-1NOTE:\s0 this function is experimental and may change or be
removed without notice.
.Sp
.Vb 1
\&        PerlIO* start_glob(SV *tmpglob, IO *io)
.Ve
.SH "Magical Functions"
.IX Header "Magical Functions"
.IP "magic_clearhint" 8
.IX Xref "magic_clearhint"
.IX Item "magic_clearhint"
Triggered by a delete from %^H, records the key to
\&\f(CW\*(C`PL_compiling.cop_hints_hash\*(C'\fR.
.Sp
.Vb 1
\&        int     magic_clearhint(SV* sv, MAGIC* mg)
.Ve
.IP "magic_clearhints" 8
.IX Xref "magic_clearhints"
.IX Item "magic_clearhints"
Triggered by clearing %^H, resets \f(CW\*(C`PL_compiling.cop_hints_hash\*(C'\fR.
.Sp
.Vb 1
\&        int     magic_clearhints(SV* sv, MAGIC* mg)
.Ve
.IP "magic_methcall" 8
.IX Xref "magic_methcall"
.IX Item "magic_methcall"
Invoke a magic method (like \s-1FETCH\s0).
.Sp
\&\f(CW\*(C`sv\*(C'\fR and \f(CW\*(C`mg\*(C'\fR are the tied thingy and the tie magic.
.Sp
\&\f(CW\*(C`meth\*(C'\fR is the name of the method to call.
.Sp
\&\f(CW\*(C`argc\*(C'\fR is the number of args (in addition to \f(CW$self\fR) to pass to the method.
.Sp
The \f(CW\*(C`flags\*(C'\fR can be:
.Sp
.Vb 4
\&    G_DISCARD     invoke method with G_DISCARD flag and don\*(Aqt
\&                  return a value
\&    G_UNDEF_FILL  fill the stack with argc pointers to
\&                  PL_sv_undef
.Ve
.Sp
The arguments themselves are any values following the \f(CW\*(C`flags\*(C'\fR argument.
.Sp
Returns the \s-1SV \s0(if any) returned by the method, or \s-1NULL\s0 on failure.
.Sp
.Vb 3
\&        SV*     magic_methcall(SV *sv, const MAGIC *mg,
\&                               const char *meth, U32 flags,
\&                               U32 argc, ...)
.Ve
.IP "magic_sethint" 8
.IX Xref "magic_sethint"
.IX Item "magic_sethint"
Triggered by a store to %^H, records the key/value pair to
\&\f(CW\*(C`PL_compiling.cop_hints_hash\*(C'\fR.  It is assumed that hints aren't storing
anything that would need a deep copy.  Maybe we should warn if we find a
reference.
.Sp
.Vb 1
\&        int     magic_sethint(SV* sv, MAGIC* mg)
.Ve
.IP "mg_localize" 8
.IX Xref "mg_localize"
.IX Item "mg_localize"
Copy some of the magic from an existing \s-1SV\s0 to new localized version of that
\&\s-1SV.\s0 Container magic (eg \f(CW%ENV\fR, \f(CW$1\fR, tie) gets copied, value magic doesn't (eg
taint, pos).
.Sp
If setmagic is false then no set magic will be called on the new (empty) \s-1SV.\s0
This typically means that assignment will soon follow (e.g. 'local \f(CW$x\fR = \f(CW$y\fR'),
and that will handle the magic.
.Sp
.Vb 1
\&        void    mg_localize(SV* sv, SV* nsv, bool setmagic)
.Ve
.SH "MRO Functions"
.IX Header "MRO Functions"
.IP "mro_get_linear_isa_dfs" 8
.IX Xref "mro_get_linear_isa_dfs"
.IX Item "mro_get_linear_isa_dfs"
Returns the Depth-First Search linearization of \f(CW@ISA\fR
the given stash.  The return value is a read-only AV*.
\&\f(CW\*(C`level\*(C'\fR should be 0 (it is used internally in this
function's recursion).
.Sp
You are responsible for \f(CW\*(C`SvREFCNT_inc()\*(C'\fR on the
return value if you plan to store it anywhere
semi-permanently (otherwise it might be deleted
out from under you the next time the cache is
invalidated).
.Sp
.Vb 1
\&        AV*     mro_get_linear_isa_dfs(HV* stash, U32 level)
.Ve
.IP "mro_isa_changed_in" 8
.IX Xref "mro_isa_changed_in"
.IX Item "mro_isa_changed_in"
Takes the necessary steps (cache invalidations, mostly)
when the \f(CW@ISA\fR of the given package has changed.  Invoked
by the \f(CW\*(C`setisa\*(C'\fR magic, should not need to invoke directly.
.Sp
.Vb 1
\&        void    mro_isa_changed_in(HV* stash)
.Ve
.IP "mro_package_moved" 8
.IX Xref "mro_package_moved"
.IX Item "mro_package_moved"
Call this function to signal to a stash that it has been assigned to
another spot in the stash hierarchy.  \f(CW\*(C`stash\*(C'\fR is the stash that has been
assigned. \f(CW\*(C`oldstash\*(C'\fR is the stash it replaces, if any.  \f(CW\*(C`gv\*(C'\fR is the glob
that is actually being assigned to.
.Sp
This can also be called with a null first argument to
indicate that \f(CW\*(C`oldstash\*(C'\fR has been deleted.
.Sp
This function invalidates isa caches on the old stash, on all subpackages
nested inside it, and on the subclasses of all those, including
non-existent packages that have corresponding entries in \f(CW\*(C`stash\*(C'\fR.
.Sp
It also sets the effective names (\f(CW\*(C`HvENAME\*(C'\fR) on all the stashes as
appropriate.
.Sp
If the \f(CW\*(C`gv\*(C'\fR is present and is not in the symbol table, then this function
simply returns.  This checked will be skipped if \f(CW\*(C`flags & 1\*(C'\fR.
.Sp
.Vb 4
\&        void    mro_package_moved(HV * const stash,
\&                                  HV * const oldstash,
\&                                  const GV * const gv,
\&                                  U32 flags)
.Ve
.SH "Optree Manipulation Functions"
.IX Header "Optree Manipulation Functions"
.IP "finalize_optree" 8
.IX Xref "finalize_optree"
.IX Item "finalize_optree"
This function finalizes the optree. Should be called directly after
the complete optree is built. It does some additional
checking which can't be done in the normal ck_xxx functions and makes
the tree thread-safe.
.Sp
.Vb 1
\&        void    finalize_optree(OP* o)
.Ve
.SH "Pad Data Structures"
.IX Header "Pad Data Structures"
.IP "\s-1CX_CURPAD_SAVE \s0" 8
.IX Xref "CX_CURPAD_SAVE"
.IX Item "CX_CURPAD_SAVE "
Save the current pad in the given context block structure.
.Sp
.Vb 1
\&        void    CX_CURPAD_SAVE(struct context)
.Ve
.IP "\s-1CX_CURPAD_SV \s0" 8
.IX Xref "CX_CURPAD_SV"
.IX Item "CX_CURPAD_SV "
Access the \s-1SV\s0 at offset po in the saved current pad in the given
context block structure (can be used as an lvalue).
.Sp
.Vb 1
\&        SV *    CX_CURPAD_SV(struct context, PADOFFSET po)
.Ve
.IP "PadnameIsOUR" 8
.IX Xref "PadnameIsOUR"
.IX Item "PadnameIsOUR"
Whether this is an \*(L"our\*(R" variable.
.Sp
.Vb 1
\&        bool    PadnameIsOUR(PADNAME pn)
.Ve
.IP "PadnameIsSTATE" 8
.IX Xref "PadnameIsSTATE"
.IX Item "PadnameIsSTATE"
Whether this is a \*(L"state\*(R" variable.
.Sp
.Vb 1
\&        bool    PadnameIsSTATE(PADNAME pn)
.Ve
.IP "PadnameOURSTASH" 8
.IX Xref "PadnameOURSTASH"
.IX Item "PadnameOURSTASH"
The stash in which this \*(L"our\*(R" variable was declared.
.Sp
.Vb 1
\&        HV *    PadnameOURSTASH()
.Ve
.IP "PadnameOUTER" 8
.IX Xref "PadnameOUTER"
.IX Item "PadnameOUTER"
Whether this entry belongs to an outer pad.
.Sp
.Vb 1
\&        bool    PadnameOUTER(PADNAME pn)
.Ve
.IP "PadnameTYPE" 8
.IX Xref "PadnameTYPE"
.IX Item "PadnameTYPE"
The stash associated with a typed lexical.  This returns the \f(CW%Foo::\fR hash
for \f(CW\*(C`my Foo $bar\*(C'\fR.
.Sp
.Vb 1
\&        HV *    PadnameTYPE(PADNAME pn)
.Ve
.IP "\s-1PAD_BASE_SV \s0" 8
.IX Xref "PAD_BASE_SV"
.IX Item "PAD_BASE_SV "
Get the value from slot \f(CW\*(C`po\*(C'\fR in the base (DEPTH=1) pad of a padlist
.Sp
.Vb 1
\&        SV *    PAD_BASE_SV(PADLIST padlist, PADOFFSET po)
.Ve
.IP "\s-1PAD_CLONE_VARS \s0" 8
.IX Xref "PAD_CLONE_VARS"
.IX Item "PAD_CLONE_VARS "
Clone the state variables associated with running and compiling pads.
.Sp
.Vb 2
\&        void    PAD_CLONE_VARS(PerlInterpreter *proto_perl,
\&                               CLONE_PARAMS* param)
.Ve
.IP "\s-1PAD_COMPNAME_FLAGS \s0" 8
.IX Xref "PAD_COMPNAME_FLAGS"
.IX Item "PAD_COMPNAME_FLAGS "
Return the flags for the current compiling pad name
at offset \f(CW\*(C`po\*(C'\fR. Assumes a valid slot entry.
.Sp
.Vb 1
\&        U32     PAD_COMPNAME_FLAGS(PADOFFSET po)
.Ve
.IP "\s-1PAD_COMPNAME_GEN \s0" 8
.IX Xref "PAD_COMPNAME_GEN"
.IX Item "PAD_COMPNAME_GEN "
The generation number of the name at offset \f(CW\*(C`po\*(C'\fR in the current
compiling pad (lvalue). Note that \f(CW\*(C`SvUVX\*(C'\fR is hijacked for this purpose.
.Sp
.Vb 1
\&        STRLEN  PAD_COMPNAME_GEN(PADOFFSET po)
.Ve
.IP "PAD_COMPNAME_GEN_set" 8
.IX Xref "PAD_COMPNAME_GEN_set"
.IX Item "PAD_COMPNAME_GEN_set"
Sets the generation number of the name at offset \f(CW\*(C`po\*(C'\fR in the current
ling pad (lvalue) to \f(CW\*(C`gen\*(C'\fR.  Note that \f(CW\*(C`SvUV_set\*(C'\fR is hijacked for this purpose.
.Sp
.Vb 1
\&        STRLEN  PAD_COMPNAME_GEN_set(PADOFFSET po, int gen)
.Ve
.IP "\s-1PAD_COMPNAME_OURSTASH \s0" 8
.IX Xref "PAD_COMPNAME_OURSTASH"
.IX Item "PAD_COMPNAME_OURSTASH "
Return the stash associated with an \f(CW\*(C`our\*(C'\fR variable.
Assumes the slot entry is a valid \f(CW\*(C`our\*(C'\fR lexical.
.Sp
.Vb 1
\&        HV *    PAD_COMPNAME_OURSTASH(PADOFFSET po)
.Ve
.IP "\s-1PAD_COMPNAME_PV \s0" 8
.IX Xref "PAD_COMPNAME_PV"
.IX Item "PAD_COMPNAME_PV "
Return the name of the current compiling pad name
at offset \f(CW\*(C`po\*(C'\fR. Assumes a valid slot entry.
.Sp
.Vb 1
\&        char *  PAD_COMPNAME_PV(PADOFFSET po)
.Ve
.IP "\s-1PAD_COMPNAME_TYPE \s0" 8
.IX Xref "PAD_COMPNAME_TYPE"
.IX Item "PAD_COMPNAME_TYPE "
Return the type (stash) of the current compiling pad name at offset
\&\f(CW\*(C`po\*(C'\fR. Must be a valid name. Returns null if not typed.
.Sp
.Vb 1
\&        HV *    PAD_COMPNAME_TYPE(PADOFFSET po)
.Ve
.IP "pad_peg" 8
.IX Xref "pad_peg"
.IX Item "pad_peg"
When \s-1PERL_MAD\s0 is enabled, this is a small no-op function that gets called
at the start of each pad-related function.  It can be breakpointed to
track all pad operations.  The parameter is a string indicating the type
of pad operation being performed.
.Sp
\&\s-1NOTE:\s0 this function is experimental and may change or be
removed without notice.
.Sp
.Vb 1
\&        void    pad_peg(const char *s)
.Ve
.IP "\s-1PAD_RESTORE_LOCAL \s0" 8
.IX Xref "PAD_RESTORE_LOCAL"
.IX Item "PAD_RESTORE_LOCAL "
Restore the old pad saved into the local variable opad by \s-1\fIPAD_SAVE_LOCAL\s0()\fR
.Sp
.Vb 1
\&        void    PAD_RESTORE_LOCAL(PAD *opad)
.Ve
.IP "\s-1PAD_SAVE_LOCAL \s0" 8
.IX Xref "PAD_SAVE_LOCAL"
.IX Item "PAD_SAVE_LOCAL "
Save the current pad to the local variable opad, then make the
current pad equal to npad
.Sp
.Vb 1
\&        void    PAD_SAVE_LOCAL(PAD *opad, PAD *npad)
.Ve
.IP "\s-1PAD_SAVE_SETNULLPAD \s0" 8
.IX Xref "PAD_SAVE_SETNULLPAD"
.IX Item "PAD_SAVE_SETNULLPAD "
Save the current pad then set it to null.
.Sp
.Vb 1
\&        void    PAD_SAVE_SETNULLPAD()
.Ve
.IP "\s-1PAD_SETSV \s0" 8
.IX Xref "PAD_SETSV"
.IX Item "PAD_SETSV "
Set the slot at offset \f(CW\*(C`po\*(C'\fR in the current pad to \f(CW\*(C`sv\*(C'\fR
.Sp
.Vb 1
\&        SV *    PAD_SETSV(PADOFFSET po, SV* sv)
.Ve
.IP "\s-1PAD_SET_CUR \s0" 8
.IX Xref "PAD_SET_CUR"
.IX Item "PAD_SET_CUR "
Set the current pad to be pad \f(CW\*(C`n\*(C'\fR in the padlist, saving
the previous current pad. \s-1NB\s0 currently this macro expands to a string too
long for some compilers, so it's best to replace it with
.Sp
.Vb 2
\&    SAVECOMPPAD();
\&    PAD_SET_CUR_NOSAVE(padlist,n);
\&
\&
\&        void    PAD_SET_CUR(PADLIST padlist, I32 n)
.Ve
.IP "\s-1PAD_SET_CUR_NOSAVE \s0" 8
.IX Xref "PAD_SET_CUR_NOSAVE"
.IX Item "PAD_SET_CUR_NOSAVE "
like \s-1PAD_SET_CUR,\s0 but without the save
.Sp
.Vb 1
\&        void    PAD_SET_CUR_NOSAVE(PADLIST padlist, I32 n)
.Ve
.IP "\s-1PAD_SV \s0" 8
.IX Xref "PAD_SV"
.IX Item "PAD_SV "
Get the value at offset \f(CW\*(C`po\*(C'\fR in the current pad
.Sp
.Vb 1
\&        void    PAD_SV(PADOFFSET po)
.Ve
.IP "PAD_SVl" 8
.IX Xref "PAD_SVl"
.IX Item "PAD_SVl"
Lightweight and lvalue version of \f(CW\*(C`PAD_SV\*(C'\fR.
Get or set the value at offset \f(CW\*(C`po\*(C'\fR in the current pad.
Unlike \f(CW\*(C`PAD_SV\*(C'\fR, does not print diagnostics with \-DX.
For internal use only.
.Sp
.Vb 1
\&        SV *    PAD_SVl(PADOFFSET po)
.Ve
.IP "\s-1SAVECLEARSV \s0" 8
.IX Xref "SAVECLEARSV"
.IX Item "SAVECLEARSV "
Clear the pointed to pad value on scope exit. (i.e. the runtime action of 'my')
.Sp
.Vb 1
\&        void    SAVECLEARSV(SV **svp)
.Ve
.IP "\s-1SAVECOMPPAD \s0" 8
.IX Xref "SAVECOMPPAD"
.IX Item "SAVECOMPPAD "
save PL_comppad and PL_curpad
.Sp
.Vb 1
\&        void    SAVECOMPPAD()
.Ve
.IP "\s-1SAVEPADSV \s0" 8
.IX Xref "SAVEPADSV"
.IX Item "SAVEPADSV "
Save a pad slot (used to restore after an iteration)
.Sp
\&\s-1XXX DAPM\s0 it would make more sense to make the arg a \s-1PADOFFSET
\&\s0	void	\s-1SAVEPADSV\s0(\s-1PADOFFSET\s0 po)
.SH "Per-Interpreter Variables"
.IX Header "Per-Interpreter Variables"
.IP "PL_DBsingle" 8
.IX Xref "PL_DBsingle"
.IX Item "PL_DBsingle"
When Perl is run in debugging mode, with the \fB\-d\fR switch, this \s-1SV\s0 is a
boolean which indicates whether subs are being single-stepped.
Single-stepping is automatically turned on after every step.  This is the C
variable which corresponds to Perl's \f(CW$DB::single\fR variable.  See
\&\f(CW\*(C`PL_DBsub\*(C'\fR.
.Sp
.Vb 1
\&        SV *    PL_DBsingle
.Ve
.IP "PL_DBsub" 8
.IX Xref "PL_DBsub"
.IX Item "PL_DBsub"
When Perl is run in debugging mode, with the \fB\-d\fR switch, this \s-1GV\s0 contains
the \s-1SV\s0 which holds the name of the sub being debugged.  This is the C
variable which corresponds to Perl's \f(CW$DB::sub\fR variable.  See
\&\f(CW\*(C`PL_DBsingle\*(C'\fR.
.Sp
.Vb 1
\&        GV *    PL_DBsub
.Ve
.IP "PL_DBtrace" 8
.IX Xref "PL_DBtrace"
.IX Item "PL_DBtrace"
Trace variable used when Perl is run in debugging mode, with the \fB\-d\fR
switch.  This is the C variable which corresponds to Perl's \f(CW$DB::trace\fR
variable.  See \f(CW\*(C`PL_DBsingle\*(C'\fR.
.Sp
.Vb 1
\&        SV *    PL_DBtrace
.Ve
.IP "PL_dowarn" 8
.IX Xref "PL_dowarn"
.IX Item "PL_dowarn"
The C variable which corresponds to Perl's $^W warning variable.
.Sp
.Vb 1
\&        bool    PL_dowarn
.Ve
.IP "PL_last_in_gv" 8
.IX Xref "PL_last_in_gv"
.IX Item "PL_last_in_gv"
The \s-1GV\s0 which was last used for a filehandle input operation. (\f(CW\*(C`<FH>\*(C'\fR)
.Sp
.Vb 1
\&        GV*     PL_last_in_gv
.Ve
.IP "PL_ofsgv" 8
.IX Xref "PL_ofsgv"
.IX Item "PL_ofsgv"
The glob containing the output field separator \- \f(CW\*(C`*,\*(C'\fR in Perl space.
.Sp
.Vb 1
\&        GV*     PL_ofsgv
.Ve
.IP "PL_rs" 8
.IX Xref "PL_rs"
.IX Item "PL_rs"
The input record separator \- \f(CW$/\fR in Perl space.
.Sp
.Vb 1
\&        SV*     PL_rs
.Ve
.SH "Stack Manipulation Macros"
.IX Header "Stack Manipulation Macros"
.IP "djSP" 8
.IX Xref "djSP"
.IX Item "djSP"
Declare Just \f(CW\*(C`SP\*(C'\fR. This is actually identical to \f(CW\*(C`dSP\*(C'\fR, and declares
a local copy of perl's stack pointer, available via the \f(CW\*(C`SP\*(C'\fR macro.
See \f(CW\*(C`SP\*(C'\fR.  (Available for backward source code compatibility with the
old (Perl 5.005) thread model.)
.Sp
.Vb 1
\&                djSP;
.Ve
.IP "\s-1LVRET \s0" 8
.IX Xref "LVRET"
.IX Item "LVRET "
True if this op will be the return value of an lvalue subroutine
.SH "SV Manipulation Functions"
.IX Header "SV Manipulation Functions"
.IP "SvTHINKFIRST" 8
.IX Xref "SvTHINKFIRST"
.IX Item "SvTHINKFIRST"
A quick flag check to see whether an sv should be passed to sv_force_normal
to be \*(L"downgraded\*(R" before SvIVX or SvPVX can be modified directly.
.Sp
For example, if your scalar is a reference and you want to modify the SvIVX
slot, you can't just do SvROK_off, as that will leak the referent.
.Sp
This is used internally by various sv-modifying functions, such as
sv_setsv, sv_setiv and sv_pvn_force.
.Sp
One case that this does not handle is a gv without SvFAKE set.  After
.Sp
.Vb 1
\&    if (SvTHINKFIRST(gv)) sv_force_normal(gv);
.Ve
.Sp
it will still be a gv.
.Sp
SvTHINKFIRST sometimes produces false positives.  In those cases
sv_force_normal does nothing.
.Sp
.Vb 1
\&        U32     SvTHINKFIRST(SV *sv)
.Ve
.IP "sv_add_arena" 8
.IX Xref "sv_add_arena"
.IX Item "sv_add_arena"
Given a chunk of memory, link it to the head of the list of arenas,
and split it into a list of free SVs.
.Sp
.Vb 2
\&        void    sv_add_arena(char *const ptr, const U32 size,
\&                             const U32 flags)
.Ve
.IP "sv_clean_all" 8
.IX Xref "sv_clean_all"
.IX Item "sv_clean_all"
Decrement the refcnt of each remaining \s-1SV,\s0 possibly triggering a
cleanup.  This function may have to be called multiple times to free
SVs which are in complex self-referential hierarchies.
.Sp
.Vb 1
\&        I32     sv_clean_all()
.Ve
.IP "sv_clean_objs" 8
.IX Xref "sv_clean_objs"
.IX Item "sv_clean_objs"
Attempt to destroy all objects not yet freed.
.Sp
.Vb 1
\&        void    sv_clean_objs()
.Ve
.IP "sv_free_arenas" 8
.IX Xref "sv_free_arenas"
.IX Item "sv_free_arenas"
Deallocate the memory used by all arenas.  Note that all the individual \s-1SV\s0
heads and bodies within the arenas must already have been freed.
.Sp
.Vb 1
\&        void    sv_free_arenas()
.Ve
.SH "SV-Body Allocation"
.IX Header "SV-Body Allocation"
.IP "sv_2num" 8
.IX Xref "sv_2num"
.IX Item "sv_2num"
Return an \s-1SV\s0 with the numeric value of the source \s-1SV,\s0 doing any necessary
reference or overload conversion.  You must use the \f(CW\*(C`SvNUM(sv)\*(C'\fR macro to
access this function.
.Sp
\&\s-1NOTE:\s0 this function is experimental and may change or be
removed without notice.
.Sp
.Vb 1
\&        SV*     sv_2num(SV *const sv)
.Ve
.IP "sv_copypv" 8
.IX Xref "sv_copypv"
.IX Item "sv_copypv"
Copies a stringified representation of the source \s-1SV\s0 into the
destination \s-1SV. \s0 Automatically performs any necessary mg_get and
coercion of numeric values into strings.  Guaranteed to preserve
\&\s-1UTF8\s0 flag even from overloaded objects.  Similar in nature to
sv_2pv[_flags] but operates directly on an \s-1SV\s0 instead of just the
string.  Mostly uses sv_2pv_flags to do its work, except when that
would lose the \s-1UTF\-8\s0'ness of the \s-1PV.\s0
.Sp
.Vb 1
\&        void    sv_copypv(SV *const dsv, SV *const ssv)
.Ve
.IP "sv_ref" 8
.IX Xref "sv_ref"
.IX Item "sv_ref"
Returns a \s-1SV\s0 describing what the \s-1SV\s0 passed in is a reference to.
.Sp
.Vb 2
\&        SV*     sv_ref(SV *dst, const SV *const sv,
\&                       const int ob)
.Ve
.SH "Unicode Support"
.IX Header "Unicode Support"
.IP "find_uninit_var" 8
.IX Xref "find_uninit_var"
.IX Item "find_uninit_var"
Find the name of the undefined variable (if any) that caused the operator
to issue a \*(L"Use of uninitialized value\*(R" warning.
If match is true, only return a name if its value matches uninit_sv.
So roughly speaking, if a unary operator (such as \s-1OP_COS\s0) generates a
warning, then following the direct child of the op may yield an
\&\s-1OP_PADSV\s0 or \s-1OP_GV\s0 that gives the name of the undefined variable.  On the
other hand, with \s-1OP_ADD\s0 there are two branches to follow, so we only print
the variable name if we get an exact match.
.Sp
The name is returned as a mortal \s-1SV.\s0
.Sp
Assumes that PL_op is the op that originally triggered the error, and that
PL_comppad/PL_curpad points to the currently executing pad.
.Sp
\&\s-1NOTE:\s0 this function is experimental and may change or be
removed without notice.
.Sp
.Vb 3
\&        SV*     find_uninit_var(const OP *const obase,
\&                                const SV *const uninit_sv,
\&                                bool top)
.Ve
.IP "report_uninit" 8
.IX Xref "report_uninit"
.IX Item "report_uninit"
Print appropriate \*(L"Use of uninitialized variable\*(R" warning.
.Sp
.Vb 1
\&        void    report_uninit(const SV *uninit_sv)
.Ve
.SH "Undocumented functions"
.IX Header "Undocumented functions"
The following functions are currently undocumented.  If you use one of
them, you may wish to consider creating and submitting documentation for
it.
.IP "Perl_croak_memory_wrap" 4
.IX Xref "Perl_croak_memory_wrap"
.IX Item "Perl_croak_memory_wrap"
.PD 0
.IP "Slab_Alloc" 4
.IX Xref "Slab_Alloc"
.IX Item "Slab_Alloc"
.IP "Slab_Free" 4
.IX Xref "Slab_Free"
.IX Item "Slab_Free"
.IP "Slab_to_ro" 4
.IX Xref "Slab_to_ro"
.IX Item "Slab_to_ro"
.IP "Slab_to_rw" 4
.IX Xref "Slab_to_rw"
.IX Item "Slab_to_rw"
.IP "_add_range_to_invlist" 4
.IX Xref "_add_range_to_invlist"
.IX Item "_add_range_to_invlist"
.IP "_core_swash_init" 4
.IX Xref "_core_swash_init"
.IX Item "_core_swash_init"
.IP "_get_invlist_len_addr" 4
.IX Xref "_get_invlist_len_addr"
.IX Item "_get_invlist_len_addr"
.IP "_get_swash_invlist" 4
.IX Xref "_get_swash_invlist"
.IX Item "_get_swash_invlist"
.IP "_invlist_array_init" 4
.IX Xref "_invlist_array_init"
.IX Item "_invlist_array_init"
.IP "_invlist_contains_cp" 4
.IX Xref "_invlist_contains_cp"
.IX Item "_invlist_contains_cp"
.IP "_invlist_contents" 4
.IX Xref "_invlist_contents"
.IX Item "_invlist_contents"
.IP "_invlist_intersection" 4
.IX Xref "_invlist_intersection"
.IX Item "_invlist_intersection"
.IP "_invlist_intersection_maybe_complement_2nd" 4
.IX Xref "_invlist_intersection_maybe_complement_2nd"
.IX Item "_invlist_intersection_maybe_complement_2nd"
.IP "_invlist_invert" 4
.IX Xref "_invlist_invert"
.IX Item "_invlist_invert"
.IP "_invlist_invert_prop" 4
.IX Xref "_invlist_invert_prop"
.IX Item "_invlist_invert_prop"
.IP "_invlist_len" 4
.IX Xref "_invlist_len"
.IX Item "_invlist_len"
.IP "_invlist_populate_swatch" 4
.IX Xref "_invlist_populate_swatch"
.IX Item "_invlist_populate_swatch"
.IP "_invlist_search" 4
.IX Xref "_invlist_search"
.IX Item "_invlist_search"
.IP "_invlist_subtract" 4
.IX Xref "_invlist_subtract"
.IX Item "_invlist_subtract"
.IP "_invlist_union" 4
.IX Xref "_invlist_union"
.IX Item "_invlist_union"
.IP "_invlist_union_maybe_complement_2nd" 4
.IX Xref "_invlist_union_maybe_complement_2nd"
.IX Item "_invlist_union_maybe_complement_2nd"
.IP "_new_invlist" 4
.IX Xref "_new_invlist"
.IX Item "_new_invlist"
.IP "_swash_inversion_hash" 4
.IX Xref "_swash_inversion_hash"
.IX Item "_swash_inversion_hash"
.IP "_swash_to_invlist" 4
.IX Xref "_swash_to_invlist"
.IX Item "_swash_to_invlist"
.IP "_to_fold_latin1" 4
.IX Xref "_to_fold_latin1"
.IX Item "_to_fold_latin1"
.IP "_to_upper_title_latin1" 4
.IX Xref "_to_upper_title_latin1"
.IX Item "_to_upper_title_latin1"
.IP "aassign_common_vars" 4
.IX Xref "aassign_common_vars"
.IX Item "aassign_common_vars"
.IP "add_cp_to_invlist" 4
.IX Xref "add_cp_to_invlist"
.IX Item "add_cp_to_invlist"
.IP "addmad" 4
.IX Xref "addmad"
.IX Item "addmad"
.IP "alloc_maybe_populate_EXACT" 4
.IX Xref "alloc_maybe_populate_EXACT"
.IX Item "alloc_maybe_populate_EXACT"
.IP "allocmy" 4
.IX Xref "allocmy"
.IX Item "allocmy"
.IP "amagic_is_enabled" 4
.IX Xref "amagic_is_enabled"
.IX Item "amagic_is_enabled"
.IP "append_madprops" 4
.IX Xref "append_madprops"
.IX Item "append_madprops"
.IP "apply" 4
.IX Xref "apply"
.IX Item "apply"
.IP "av_extend_guts" 4
.IX Xref "av_extend_guts"
.IX Item "av_extend_guts"
.IP "av_reify" 4
.IX Xref "av_reify"
.IX Item "av_reify"
.IP "bind_match" 4
.IX Xref "bind_match"
.IX Item "bind_match"
.IP "block_end" 4
.IX Xref "block_end"
.IX Item "block_end"
.IP "block_start" 4
.IX Xref "block_start"
.IX Item "block_start"
.IP "boot_core_PerlIO" 4
.IX Xref "boot_core_PerlIO"
.IX Item "boot_core_PerlIO"
.IP "boot_core_UNIVERSAL" 4
.IX Xref "boot_core_UNIVERSAL"
.IX Item "boot_core_UNIVERSAL"
.IP "boot_core_mro" 4
.IX Xref "boot_core_mro"
.IX Item "boot_core_mro"
.IP "cando" 4
.IX Xref "cando"
.IX Item "cando"
.IP "check_utf8_print" 4
.IX Xref "check_utf8_print"
.IX Item "check_utf8_print"
.IP "ck_entersub_args_core" 4
.IX Xref "ck_entersub_args_core"
.IX Item "ck_entersub_args_core"
.IP "compute_EXACTish" 4
.IX Xref "compute_EXACTish"
.IX Item "compute_EXACTish"
.IP "convert" 4
.IX Xref "convert"
.IX Item "convert"
.IP "coresub_op" 4
.IX Xref "coresub_op"
.IX Item "coresub_op"
.IP "create_eval_scope" 4
.IX Xref "create_eval_scope"
.IX Item "create_eval_scope"
.IP "croak_no_mem" 4
.IX Xref "croak_no_mem"
.IX Item "croak_no_mem"
.IP "croak_popstack" 4
.IX Xref "croak_popstack"
.IX Item "croak_popstack"
.IP "current_re_engine" 4
.IX Xref "current_re_engine"
.IX Item "current_re_engine"
.IP "cv_ckproto_len_flags" 4
.IX Xref "cv_ckproto_len_flags"
.IX Item "cv_ckproto_len_flags"
.IP "cv_clone_into" 4
.IX Xref "cv_clone_into"
.IX Item "cv_clone_into"
.IP "cvgv_set" 4
.IX Xref "cvgv_set"
.IX Item "cvgv_set"
.IP "cvstash_set" 4
.IX Xref "cvstash_set"
.IX Item "cvstash_set"
.IP "deb_stack_all" 4
.IX Xref "deb_stack_all"
.IX Item "deb_stack_all"
.IP "delete_eval_scope" 4
.IX Xref "delete_eval_scope"
.IX Item "delete_eval_scope"
.IP "die_unwind" 4
.IX Xref "die_unwind"
.IX Item "die_unwind"
.IP "do_aexec" 4
.IX Xref "do_aexec"
.IX Item "do_aexec"
.IP "do_aexec5" 4
.IX Xref "do_aexec5"
.IX Item "do_aexec5"
.IP "do_eof" 4
.IX Xref "do_eof"
.IX Item "do_eof"
.IP "do_exec" 4
.IX Xref "do_exec"
.IX Item "do_exec"
.IP "do_exec3" 4
.IX Xref "do_exec3"
.IX Item "do_exec3"
.IP "do_execfree" 4
.IX Xref "do_execfree"
.IX Item "do_execfree"
.IP "do_ipcctl" 4
.IX Xref "do_ipcctl"
.IX Item "do_ipcctl"
.IP "do_ipcget" 4
.IX Xref "do_ipcget"
.IX Item "do_ipcget"
.IP "do_msgrcv" 4
.IX Xref "do_msgrcv"
.IX Item "do_msgrcv"
.IP "do_msgsnd" 4
.IX Xref "do_msgsnd"
.IX Item "do_msgsnd"
.IP "do_ncmp" 4
.IX Xref "do_ncmp"
.IX Item "do_ncmp"
.IP "do_op_xmldump" 4
.IX Xref "do_op_xmldump"
.IX Item "do_op_xmldump"
.IP "do_pmop_xmldump" 4
.IX Xref "do_pmop_xmldump"
.IX Item "do_pmop_xmldump"
.IP "do_print" 4
.IX Xref "do_print"
.IX Item "do_print"
.IP "do_readline" 4
.IX Xref "do_readline"
.IX Item "do_readline"
.IP "do_seek" 4
.IX Xref "do_seek"
.IX Item "do_seek"
.IP "do_semop" 4
.IX Xref "do_semop"
.IX Item "do_semop"
.IP "do_shmio" 4
.IX Xref "do_shmio"
.IX Item "do_shmio"
.IP "do_sysseek" 4
.IX Xref "do_sysseek"
.IX Item "do_sysseek"
.IP "do_tell" 4
.IX Xref "do_tell"
.IX Item "do_tell"
.IP "do_trans" 4
.IX Xref "do_trans"
.IX Item "do_trans"
.IP "do_vecget" 4
.IX Xref "do_vecget"
.IX Item "do_vecget"
.IP "do_vecset" 4
.IX Xref "do_vecset"
.IX Item "do_vecset"
.IP "do_vop" 4
.IX Xref "do_vop"
.IX Item "do_vop"
.IP "dofile" 4
.IX Xref "dofile"
.IX Item "dofile"
.IP "dump_all_perl" 4
.IX Xref "dump_all_perl"
.IX Item "dump_all_perl"
.IP "dump_packsubs_perl" 4
.IX Xref "dump_packsubs_perl"
.IX Item "dump_packsubs_perl"
.IP "dump_sub_perl" 4
.IX Xref "dump_sub_perl"
.IX Item "dump_sub_perl"
.IP "dump_sv_child" 4
.IX Xref "dump_sv_child"
.IX Item "dump_sv_child"
.IP "emulate_cop_io" 4
.IX Xref "emulate_cop_io"
.IX Item "emulate_cop_io"
.IP "feature_is_enabled" 4
.IX Xref "feature_is_enabled"
.IX Item "feature_is_enabled"
.IP "find_lexical_cv" 4
.IX Xref "find_lexical_cv"
.IX Item "find_lexical_cv"
.IP "find_runcv_where" 4
.IX Xref "find_runcv_where"
.IX Item "find_runcv_where"
.IP "find_rundefsv2" 4
.IX Xref "find_rundefsv2"
.IX Item "find_rundefsv2"
.IP "find_script" 4
.IX Xref "find_script"
.IX Item "find_script"
.IP "free_tied_hv_pool" 4
.IX Xref "free_tied_hv_pool"
.IX Item "free_tied_hv_pool"
.IP "get_and_check_backslash_N_name" 4
.IX Xref "get_and_check_backslash_N_name"
.IX Item "get_and_check_backslash_N_name"
.IP "get_db_sub" 4
.IX Xref "get_db_sub"
.IX Item "get_db_sub"
.IP "get_debug_opts" 4
.IX Xref "get_debug_opts"
.IX Item "get_debug_opts"
.IP "get_hash_seed" 4
.IX Xref "get_hash_seed"
.IX Item "get_hash_seed"
.IP "get_invlist_iter_addr" 4
.IX Xref "get_invlist_iter_addr"
.IX Item "get_invlist_iter_addr"
.IP "get_invlist_previous_index_addr" 4
.IX Xref "get_invlist_previous_index_addr"
.IX Item "get_invlist_previous_index_addr"
.IP "get_invlist_version_id_addr" 4
.IX Xref "get_invlist_version_id_addr"
.IX Item "get_invlist_version_id_addr"
.IP "get_invlist_zero_addr" 4
.IX Xref "get_invlist_zero_addr"
.IX Item "get_invlist_zero_addr"
.IP "get_no_modify" 4
.IX Xref "get_no_modify"
.IX Item "get_no_modify"
.IP "get_opargs" 4
.IX Xref "get_opargs"
.IX Item "get_opargs"
.IP "get_re_arg" 4
.IX Xref "get_re_arg"
.IX Item "get_re_arg"
.IP "getenv_len" 4
.IX Xref "getenv_len"
.IX Item "getenv_len"
.IP "grok_bslash_x" 4
.IX Xref "grok_bslash_x"
.IX Item "grok_bslash_x"
.IP "hfree_next_entry" 4
.IX Xref "hfree_next_entry"
.IX Item "hfree_next_entry"
.IP "hv_backreferences_p" 4
.IX Xref "hv_backreferences_p"
.IX Item "hv_backreferences_p"
.IP "hv_kill_backrefs" 4
.IX Xref "hv_kill_backrefs"
.IX Item "hv_kill_backrefs"
.IP "hv_undef_flags" 4
.IX Xref "hv_undef_flags"
.IX Item "hv_undef_flags"
.IP "init_argv_symbols" 4
.IX Xref "init_argv_symbols"
.IX Item "init_argv_symbols"
.IP "init_constants" 4
.IX Xref "init_constants"
.IX Item "init_constants"
.IP "init_dbargs" 4
.IX Xref "init_dbargs"
.IX Item "init_dbargs"
.IP "init_debugger" 4
.IX Xref "init_debugger"
.IX Item "init_debugger"
.IP "invert" 4
.IX Xref "invert"
.IX Item "invert"
.IP "invlist_array" 4
.IX Xref "invlist_array"
.IX Item "invlist_array"
.IP "invlist_clone" 4
.IX Xref "invlist_clone"
.IX Item "invlist_clone"
.IP "invlist_highest" 4
.IX Xref "invlist_highest"
.IX Item "invlist_highest"
.IP "invlist_is_iterating" 4
.IX Xref "invlist_is_iterating"
.IX Item "invlist_is_iterating"
.IP "invlist_iterfinish" 4
.IX Xref "invlist_iterfinish"
.IX Item "invlist_iterfinish"
.IP "invlist_iterinit" 4
.IX Xref "invlist_iterinit"
.IX Item "invlist_iterinit"
.IP "invlist_max" 4
.IX Xref "invlist_max"
.IX Item "invlist_max"
.IP "invlist_previous_index" 4
.IX Xref "invlist_previous_index"
.IX Item "invlist_previous_index"
.IP "invlist_set_len" 4
.IX Xref "invlist_set_len"
.IX Item "invlist_set_len"
.IP "invlist_set_previous_index" 4
.IX Xref "invlist_set_previous_index"
.IX Item "invlist_set_previous_index"
.IP "invlist_trim" 4
.IX Xref "invlist_trim"
.IX Item "invlist_trim"
.IP "io_close" 4
.IX Xref "io_close"
.IX Item "io_close"
.IP "isALNUM_lazy" 4
.IX Xref "isALNUM_lazy"
.IX Item "isALNUM_lazy"
.IP "isIDFIRST_lazy" 4
.IX Xref "isIDFIRST_lazy"
.IX Item "isIDFIRST_lazy"
.IP "is_utf8_char_slow" 4
.IX Xref "is_utf8_char_slow"
.IX Item "is_utf8_char_slow"
.IP "is_utf8_common" 4
.IX Xref "is_utf8_common"
.IX Item "is_utf8_common"
.IP "jmaybe" 4
.IX Xref "jmaybe"
.IX Item "jmaybe"
.IP "keyword" 4
.IX Xref "keyword"
.IX Item "keyword"
.IP "keyword_plugin_standard" 4
.IX Xref "keyword_plugin_standard"
.IX Item "keyword_plugin_standard"
.IP "list" 4
.IX Xref "list"
.IX Item "list"
.IP "localize" 4
.IX Xref "localize"
.IX Item "localize"
.IP "mad_free" 4
.IX Xref "mad_free"
.IX Item "mad_free"
.IP "madlex" 4
.IX Xref "madlex"
.IX Item "madlex"
.IP "madparse" 4
.IX Xref "madparse"
.IX Item "madparse"
.IP "magic_clear_all_env" 4
.IX Xref "magic_clear_all_env"
.IX Item "magic_clear_all_env"
.IP "magic_cleararylen_p" 4
.IX Xref "magic_cleararylen_p"
.IX Item "magic_cleararylen_p"
.IP "magic_clearenv" 4
.IX Xref "magic_clearenv"
.IX Item "magic_clearenv"
.IP "magic_clearisa" 4
.IX Xref "magic_clearisa"
.IX Item "magic_clearisa"
.IP "magic_clearpack" 4
.IX Xref "magic_clearpack"
.IX Item "magic_clearpack"
.IP "magic_clearsig" 4
.IX Xref "magic_clearsig"
.IX Item "magic_clearsig"
.IP "magic_copycallchecker" 4
.IX Xref "magic_copycallchecker"
.IX Item "magic_copycallchecker"
.IP "magic_existspack" 4
.IX Xref "magic_existspack"
.IX Item "magic_existspack"
.IP "magic_freearylen_p" 4
.IX Xref "magic_freearylen_p"
.IX Item "magic_freearylen_p"
.IP "magic_freeovrld" 4
.IX Xref "magic_freeovrld"
.IX Item "magic_freeovrld"
.IP "magic_get" 4
.IX Xref "magic_get"
.IX Item "magic_get"
.IP "magic_getarylen" 4
.IX Xref "magic_getarylen"
.IX Item "magic_getarylen"
.IP "magic_getdefelem" 4
.IX Xref "magic_getdefelem"
.IX Item "magic_getdefelem"
.IP "magic_getnkeys" 4
.IX Xref "magic_getnkeys"
.IX Item "magic_getnkeys"
.IP "magic_getpack" 4
.IX Xref "magic_getpack"
.IX Item "magic_getpack"
.IP "magic_getpos" 4
.IX Xref "magic_getpos"
.IX Item "magic_getpos"
.IP "magic_getsig" 4
.IX Xref "magic_getsig"
.IX Item "magic_getsig"
.IP "magic_getsubstr" 4
.IX Xref "magic_getsubstr"
.IX Item "magic_getsubstr"
.IP "magic_gettaint" 4
.IX Xref "magic_gettaint"
.IX Item "magic_gettaint"
.IP "magic_getuvar" 4
.IX Xref "magic_getuvar"
.IX Item "magic_getuvar"
.IP "magic_getvec" 4
.IX Xref "magic_getvec"
.IX Item "magic_getvec"
.IP "magic_killbackrefs" 4
.IX Xref "magic_killbackrefs"
.IX Item "magic_killbackrefs"
.IP "magic_nextpack" 4
.IX Xref "magic_nextpack"
.IX Item "magic_nextpack"
.IP "magic_regdata_cnt" 4
.IX Xref "magic_regdata_cnt"
.IX Item "magic_regdata_cnt"
.IP "magic_regdatum_get" 4
.IX Xref "magic_regdatum_get"
.IX Item "magic_regdatum_get"
.IP "magic_regdatum_set" 4
.IX Xref "magic_regdatum_set"
.IX Item "magic_regdatum_set"
.IP "magic_scalarpack" 4
.IX Xref "magic_scalarpack"
.IX Item "magic_scalarpack"
.IP "magic_set" 4
.IX Xref "magic_set"
.IX Item "magic_set"
.IP "magic_set_all_env" 4
.IX Xref "magic_set_all_env"
.IX Item "magic_set_all_env"
.IP "magic_setarylen" 4
.IX Xref "magic_setarylen"
.IX Item "magic_setarylen"
.IP "magic_setcollxfrm" 4
.IX Xref "magic_setcollxfrm"
.IX Item "magic_setcollxfrm"
.IP "magic_setdbline" 4
.IX Xref "magic_setdbline"
.IX Item "magic_setdbline"
.IP "magic_setdefelem" 4
.IX Xref "magic_setdefelem"
.IX Item "magic_setdefelem"
.IP "magic_setenv" 4
.IX Xref "magic_setenv"
.IX Item "magic_setenv"
.IP "magic_setisa" 4
.IX Xref "magic_setisa"
.IX Item "magic_setisa"
.IP "magic_setmglob" 4
.IX Xref "magic_setmglob"
.IX Item "magic_setmglob"
.IP "magic_setnkeys" 4
.IX Xref "magic_setnkeys"
.IX Item "magic_setnkeys"
.IP "magic_setpack" 4
.IX Xref "magic_setpack"
.IX Item "magic_setpack"
.IP "magic_setpos" 4
.IX Xref "magic_setpos"
.IX Item "magic_setpos"
.IP "magic_setregexp" 4
.IX Xref "magic_setregexp"
.IX Item "magic_setregexp"
.IP "magic_setsig" 4
.IX Xref "magic_setsig"
.IX Item "magic_setsig"
.IP "magic_setsubstr" 4
.IX Xref "magic_setsubstr"
.IX Item "magic_setsubstr"
.IP "magic_settaint" 4
.IX Xref "magic_settaint"
.IX Item "magic_settaint"
.IP "magic_setutf8" 4
.IX Xref "magic_setutf8"
.IX Item "magic_setutf8"
.IP "magic_setuvar" 4
.IX Xref "magic_setuvar"
.IX Item "magic_setuvar"
.IP "magic_setvec" 4
.IX Xref "magic_setvec"
.IX Item "magic_setvec"
.IP "magic_sizepack" 4
.IX Xref "magic_sizepack"
.IX Item "magic_sizepack"
.IP "magic_wipepack" 4
.IX Xref "magic_wipepack"
.IX Item "magic_wipepack"
.IP "malloc_good_size" 4
.IX Xref "malloc_good_size"
.IX Item "malloc_good_size"
.IP "malloced_size" 4
.IX Xref "malloced_size"
.IX Item "malloced_size"
.IP "mem_collxfrm" 4
.IX Xref "mem_collxfrm"
.IX Item "mem_collxfrm"
.IP "mode_from_discipline" 4
.IX Xref "mode_from_discipline"
.IX Item "mode_from_discipline"
.IP "more_bodies" 4
.IX Xref "more_bodies"
.IX Item "more_bodies"
.IP "mro_meta_dup" 4
.IX Xref "mro_meta_dup"
.IX Item "mro_meta_dup"
.IP "mro_meta_init" 4
.IX Xref "mro_meta_init"
.IX Item "mro_meta_init"
.IP "my_attrs" 4
.IX Xref "my_attrs"
.IX Item "my_attrs"
.IP "my_betoh16" 4
.IX Xref "my_betoh16"
.IX Item "my_betoh16"
.IP "my_betoh32" 4
.IX Xref "my_betoh32"
.IX Item "my_betoh32"
.IP "my_betoh64" 4
.IX Xref "my_betoh64"
.IX Item "my_betoh64"
.IP "my_betohi" 4
.IX Xref "my_betohi"
.IX Item "my_betohi"
.IP "my_betohl" 4
.IX Xref "my_betohl"
.IX Item "my_betohl"
.IP "my_betohs" 4
.IX Xref "my_betohs"
.IX Item "my_betohs"
.IP "my_clearenv" 4
.IX Xref "my_clearenv"
.IX Item "my_clearenv"
.IP "my_htobe16" 4
.IX Xref "my_htobe16"
.IX Item "my_htobe16"
.IP "my_htobe32" 4
.IX Xref "my_htobe32"
.IX Item "my_htobe32"
.IP "my_htobe64" 4
.IX Xref "my_htobe64"
.IX Item "my_htobe64"
.IP "my_htobei" 4
.IX Xref "my_htobei"
.IX Item "my_htobei"
.IP "my_htobel" 4
.IX Xref "my_htobel"
.IX Item "my_htobel"
.IP "my_htobes" 4
.IX Xref "my_htobes"
.IX Item "my_htobes"
.IP "my_htole16" 4
.IX Xref "my_htole16"
.IX Item "my_htole16"
.IP "my_htole32" 4
.IX Xref "my_htole32"
.IX Item "my_htole32"
.IP "my_htole64" 4
.IX Xref "my_htole64"
.IX Item "my_htole64"
.IP "my_htolei" 4
.IX Xref "my_htolei"
.IX Item "my_htolei"
.IP "my_htolel" 4
.IX Xref "my_htolel"
.IX Item "my_htolel"
.IP "my_htoles" 4
.IX Xref "my_htoles"
.IX Item "my_htoles"
.IP "my_letoh16" 4
.IX Xref "my_letoh16"
.IX Item "my_letoh16"
.IP "my_letoh32" 4
.IX Xref "my_letoh32"
.IX Item "my_letoh32"
.IP "my_letoh64" 4
.IX Xref "my_letoh64"
.IX Item "my_letoh64"
.IP "my_letohi" 4
.IX Xref "my_letohi"
.IX Item "my_letohi"
.IP "my_letohl" 4
.IX Xref "my_letohl"
.IX Item "my_letohl"
.IP "my_letohs" 4
.IX Xref "my_letohs"
.IX Item "my_letohs"
.IP "my_lstat_flags" 4
.IX Xref "my_lstat_flags"
.IX Item "my_lstat_flags"
.IP "my_stat_flags" 4
.IX Xref "my_stat_flags"
.IX Item "my_stat_flags"
.IP "my_swabn" 4
.IX Xref "my_swabn"
.IX Item "my_swabn"
.IP "my_unexec" 4
.IX Xref "my_unexec"
.IX Item "my_unexec"
.IP "newATTRSUB_flags" 4
.IX Xref "newATTRSUB_flags"
.IX Item "newATTRSUB_flags"
.IP "newGP" 4
.IX Xref "newGP"
.IX Item "newGP"
.IP "newMADPROP" 4
.IX Xref "newMADPROP"
.IX Item "newMADPROP"
.IP "newMADsv" 4
.IX Xref "newMADsv"
.IX Item "newMADsv"
.IP "newSTUB" 4
.IX Xref "newSTUB"
.IX Item "newSTUB"
.IP "newTOKEN" 4
.IX Xref "newTOKEN"
.IX Item "newTOKEN"
.IP "newXS_len_flags" 4
.IX Xref "newXS_len_flags"
.IX Item "newXS_len_flags"
.IP "new_warnings_bitfield" 4
.IX Xref "new_warnings_bitfield"
.IX Item "new_warnings_bitfield"
.IP "nextargv" 4
.IX Xref "nextargv"
.IX Item "nextargv"
.IP "oopsAV" 4
.IX Xref "oopsAV"
.IX Item "oopsAV"
.IP "oopsHV" 4
.IX Xref "oopsHV"
.IX Item "oopsHV"
.IP "op_clear" 4
.IX Xref "op_clear"
.IX Item "op_clear"
.IP "op_const_sv" 4
.IX Xref "op_const_sv"
.IX Item "op_const_sv"
.IP "op_getmad" 4
.IX Xref "op_getmad"
.IX Item "op_getmad"
.IP "op_getmad_weak" 4
.IX Xref "op_getmad_weak"
.IX Item "op_getmad_weak"
.IP "op_integerize" 4
.IX Xref "op_integerize"
.IX Item "op_integerize"
.IP "op_lvalue_flags" 4
.IX Xref "op_lvalue_flags"
.IX Item "op_lvalue_flags"
.IP "op_refcnt_dec" 4
.IX Xref "op_refcnt_dec"
.IX Item "op_refcnt_dec"
.IP "op_refcnt_inc" 4
.IX Xref "op_refcnt_inc"
.IX Item "op_refcnt_inc"
.IP "op_std_init" 4
.IX Xref "op_std_init"
.IX Item "op_std_init"
.IP "op_unscope" 4
.IX Xref "op_unscope"
.IX Item "op_unscope"
.IP "op_xmldump" 4
.IX Xref "op_xmldump"
.IX Item "op_xmldump"
.IP "opslab_force_free" 4
.IX Xref "opslab_force_free"
.IX Item "opslab_force_free"
.IP "opslab_free" 4
.IX Xref "opslab_free"
.IX Item "opslab_free"
.IP "opslab_free_nopad" 4
.IX Xref "opslab_free_nopad"
.IX Item "opslab_free_nopad"
.IP "package" 4
.IX Xref "package"
.IX Item "package"
.IP "package_version" 4
.IX Xref "package_version"
.IX Item "package_version"
.IP "padlist_store" 4
.IX Xref "padlist_store"
.IX Item "padlist_store"
.IP "parse_unicode_opts" 4
.IX Xref "parse_unicode_opts"
.IX Item "parse_unicode_opts"
.IP "parser_free" 4
.IX Xref "parser_free"
.IX Item "parser_free"
.IP "parser_free_nexttoke_ops" 4
.IX Xref "parser_free_nexttoke_ops"
.IX Item "parser_free_nexttoke_ops"
.IP "peep" 4
.IX Xref "peep"
.IX Item "peep"
.IP "pmop_xmldump" 4
.IX Xref "pmop_xmldump"
.IX Item "pmop_xmldump"
.IP "pmruntime" 4
.IX Xref "pmruntime"
.IX Item "pmruntime"
.IP "populate_isa" 4
.IX Xref "populate_isa"
.IX Item "populate_isa"
.IP "prepend_madprops" 4
.IX Xref "prepend_madprops"
.IX Item "prepend_madprops"
.IP "qerror" 4
.IX Xref "qerror"
.IX Item "qerror"
.IP "re_op_compile" 4
.IX Xref "re_op_compile"
.IX Item "re_op_compile"
.IP "reg_named_buff" 4
.IX Xref "reg_named_buff"
.IX Item "reg_named_buff"
.IP "reg_named_buff_iter" 4
.IX Xref "reg_named_buff_iter"
.IX Item "reg_named_buff_iter"
.IP "reg_numbered_buff_fetch" 4
.IX Xref "reg_numbered_buff_fetch"
.IX Item "reg_numbered_buff_fetch"
.IP "reg_numbered_buff_length" 4
.IX Xref "reg_numbered_buff_length"
.IX Item "reg_numbered_buff_length"
.IP "reg_numbered_buff_store" 4
.IX Xref "reg_numbered_buff_store"
.IX Item "reg_numbered_buff_store"
.IP "reg_qr_package" 4
.IX Xref "reg_qr_package"
.IX Item "reg_qr_package"
.IP "reg_temp_copy" 4
.IX Xref "reg_temp_copy"
.IX Item "reg_temp_copy"
.IP "regcurly" 4
.IX Xref "regcurly"
.IX Item "regcurly"
.IP "regpposixcc" 4
.IX Xref "regpposixcc"
.IX Item "regpposixcc"
.IP "regprop" 4
.IX Xref "regprop"
.IX Item "regprop"
.IP "report_evil_fh" 4
.IX Xref "report_evil_fh"
.IX Item "report_evil_fh"
.IP "report_redefined_cv" 4
.IX Xref "report_redefined_cv"
.IX Item "report_redefined_cv"
.IP "report_wrongway_fh" 4
.IX Xref "report_wrongway_fh"
.IX Item "report_wrongway_fh"
.IP "rpeep" 4
.IX Xref "rpeep"
.IX Item "rpeep"
.IP "rsignal_restore" 4
.IX Xref "rsignal_restore"
.IX Item "rsignal_restore"
.IP "rsignal_save" 4
.IX Xref "rsignal_save"
.IX Item "rsignal_save"
.IP "rxres_save" 4
.IX Xref "rxres_save"
.IX Item "rxres_save"
.IP "same_dirent" 4
.IX Xref "same_dirent"
.IX Item "same_dirent"
.IP "sawparens" 4
.IX Xref "sawparens"
.IX Item "sawparens"
.IP "scalar" 4
.IX Xref "scalar"
.IX Item "scalar"
.IP "scalarvoid" 4
.IX Xref "scalarvoid"
.IX Item "scalarvoid"
.IP "sighandler" 4
.IX Xref "sighandler"
.IX Item "sighandler"
.IP "softref2xv" 4
.IX Xref "softref2xv"
.IX Item "softref2xv"
.IP "sub_crush_depth" 4
.IX Xref "sub_crush_depth"
.IX Item "sub_crush_depth"
.IP "sv_add_backref" 4
.IX Xref "sv_add_backref"
.IX Item "sv_add_backref"
.IP "sv_catxmlpv" 4
.IX Xref "sv_catxmlpv"
.IX Item "sv_catxmlpv"
.IP "sv_catxmlpvn" 4
.IX Xref "sv_catxmlpvn"
.IX Item "sv_catxmlpvn"
.IP "sv_catxmlsv" 4
.IX Xref "sv_catxmlsv"
.IX Item "sv_catxmlsv"
.IP "sv_del_backref" 4
.IX Xref "sv_del_backref"
.IX Item "sv_del_backref"
.IP "sv_free2" 4
.IX Xref "sv_free2"
.IX Item "sv_free2"
.IP "sv_kill_backrefs" 4
.IX Xref "sv_kill_backrefs"
.IX Item "sv_kill_backrefs"
.IP "sv_len_utf8_nomg" 4
.IX Xref "sv_len_utf8_nomg"
.IX Item "sv_len_utf8_nomg"
.IP "sv_mortalcopy_flags" 4
.IX Xref "sv_mortalcopy_flags"
.IX Item "sv_mortalcopy_flags"
.IP "sv_resetpvn" 4
.IX Xref "sv_resetpvn"
.IX Item "sv_resetpvn"
.IP "sv_sethek" 4
.IX Xref "sv_sethek"
.IX Item "sv_sethek"
.IP "sv_setsv_cow" 4
.IX Xref "sv_setsv_cow"
.IX Item "sv_setsv_cow"
.IP "sv_unglob" 4
.IX Xref "sv_unglob"
.IX Item "sv_unglob"
.IP "sv_xmlpeek" 4
.IX Xref "sv_xmlpeek"
.IX Item "sv_xmlpeek"
.IP "tied_method" 4
.IX Xref "tied_method"
.IX Item "tied_method"
.IP "token_free" 4
.IX Xref "token_free"
.IX Item "token_free"
.IP "token_getmad" 4
.IX Xref "token_getmad"
.IX Item "token_getmad"
.IP "translate_substr_offsets" 4
.IX Xref "translate_substr_offsets"
.IX Item "translate_substr_offsets"
.IP "try_amagic_bin" 4
.IX Xref "try_amagic_bin"
.IX Item "try_amagic_bin"
.IP "try_amagic_un" 4
.IX Xref "try_amagic_un"
.IX Item "try_amagic_un"
.IP "unshare_hek" 4
.IX Xref "unshare_hek"
.IX Item "unshare_hek"
.IP "utilize" 4
.IX Xref "utilize"
.IX Item "utilize"
.IP "varname" 4
.IX Xref "varname"
.IX Item "varname"
.IP "vivify_defelem" 4
.IX Xref "vivify_defelem"
.IX Item "vivify_defelem"
.IP "vivify_ref" 4
.IX Xref "vivify_ref"
.IX Item "vivify_ref"
.IP "wait4pid" 4
.IX Xref "wait4pid"
.IX Item "wait4pid"
.IP "was_lvalue_sub" 4
.IX Xref "was_lvalue_sub"
.IX Item "was_lvalue_sub"
.IP "watch" 4
.IX Xref "watch"
.IX Item "watch"
.IP "win32_croak_not_implemented" 4
.IX Xref "win32_croak_not_implemented"
.IX Item "win32_croak_not_implemented"
.IP "write_to_stderr" 4
.IX Xref "write_to_stderr"
.IX Item "write_to_stderr"
.IP "xmldump_all" 4
.IX Xref "xmldump_all"
.IX Item "xmldump_all"
.IP "xmldump_all_perl" 4
.IX Xref "xmldump_all_perl"
.IX Item "xmldump_all_perl"
.IP "xmldump_eval" 4
.IX Xref "xmldump_eval"
.IX Item "xmldump_eval"
.IP "xmldump_form" 4
.IX Xref "xmldump_form"
.IX Item "xmldump_form"
.IP "xmldump_indent" 4
.IX Xref "xmldump_indent"
.IX Item "xmldump_indent"
.IP "xmldump_packsubs" 4
.IX Xref "xmldump_packsubs"
.IX Item "xmldump_packsubs"
.IP "xmldump_packsubs_perl" 4
.IX Xref "xmldump_packsubs_perl"
.IX Item "xmldump_packsubs_perl"
.IP "xmldump_sub" 4
.IX Xref "xmldump_sub"
.IX Item "xmldump_sub"
.IP "xmldump_sub_perl" 4
.IX Xref "xmldump_sub_perl"
.IX Item "xmldump_sub_perl"
.IP "xmldump_vindent" 4
.IX Xref "xmldump_vindent"
.IX Item "xmldump_vindent"
.IP "xs_apiversion_bootcheck" 4
.IX Xref "xs_apiversion_bootcheck"
.IX Item "xs_apiversion_bootcheck"
.IP "xs_version_bootcheck" 4
.IX Xref "xs_version_bootcheck"
.IX Item "xs_version_bootcheck"
.IP "yyerror" 4
.IX Xref "yyerror"
.IX Item "yyerror"
.IP "yyerror_pv" 4
.IX Xref "yyerror_pv"
.IX Item "yyerror_pv"
.IP "yyerror_pvn" 4
.IX Xref "yyerror_pvn"
.IX Item "yyerror_pvn"
.IP "yylex" 4
.IX Xref "yylex"
.IX Item "yylex"
.IP "yyparse" 4
.IX Xref "yyparse"
.IX Item "yyparse"
.IP "yyunlex" 4
.IX Xref "yyunlex"
.IX Item "yyunlex"
.PD
.SH "AUTHORS"
.IX Header "AUTHORS"
The autodocumentation system was originally added to the Perl core by
Benjamin Stuhl. Documentation is by whoever was kind enough to
document their functions.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
perlguts, perlapi
