// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 5.5 (swiftlang-1300.0.29.207 clang-1300.0.28.1)
// swift-module-flags: -target x86_64-apple-ios15.0-macabi -enable-objc-interop -autolink-force-load -enable-library-evolution -module-link-name swiftCoreData -swift-version 5 -enforce-exclusivity=checked -O -enable-experimental-concurrency -module-name CoreData
import Combine
@_exported import CoreData
import Foundation
import Swift
import _Concurrency
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension CoreData.NSAttributeDescription {
  public struct AttributeType : Swift.Hashable, Swift.Equatable, Swift.RawRepresentable {
    public var rawValue: CoreData.NSAttributeType
    public init(rawValue: CoreData.NSAttributeType)
    public typealias RawValue = CoreData.NSAttributeType
  }
  public var type: CoreData.NSAttributeDescription.AttributeType {
    get
    set
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension CoreData.NSAttributeDescription.AttributeType {
  public static let undefined: CoreData.NSAttributeDescription.AttributeType
  public static let integer16: CoreData.NSAttributeDescription.AttributeType
  public static let integer32: CoreData.NSAttributeDescription.AttributeType
  public static let integer64: CoreData.NSAttributeDescription.AttributeType
  public static let decimal: CoreData.NSAttributeDescription.AttributeType
  public static let double: CoreData.NSAttributeDescription.AttributeType
  public static let float: CoreData.NSAttributeDescription.AttributeType
  public static let string: CoreData.NSAttributeDescription.AttributeType
  public static let boolean: CoreData.NSAttributeDescription.AttributeType
  public static let date: CoreData.NSAttributeDescription.AttributeType
  public static let binaryData: CoreData.NSAttributeDescription.AttributeType
  public static let uuid: CoreData.NSAttributeDescription.AttributeType
  public static let uri: CoreData.NSAttributeDescription.AttributeType
  public static let transformable: CoreData.NSAttributeDescription.AttributeType
  public static let objectID: CoreData.NSAttributeDescription.AttributeType
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension CoreData.NSPersistentStoreCoordinator {
  public func addPersistentStore(type: CoreData.NSPersistentStore.StoreType, configuration: Swift.String? = nil, at storeURL: Foundation.URL, options: [Swift.AnyHashable : Any]? = nil) throws -> CoreData.NSPersistentStore
  public class func registerStoreClass(_ storeClass: Swift.AnyClass?, type: CoreData.NSPersistentStore.StoreType)
  public class func metadataForPersistentStore(type storeType: CoreData.NSPersistentStore.StoreType, at storeURL: Foundation.URL, options: [Swift.AnyHashable : Any]? = nil) throws -> [Swift.String : Any]
  public class func setMetadata(_ metadata: [Swift.String : Any]?, type storeType: CoreData.NSPersistentStore.StoreType, at storeURL: Foundation.URL, options: [Swift.AnyHashable : Any]? = nil) throws
  public func migratePersistentStore(_ store: CoreData.NSPersistentStore, to storeURL: Foundation.URL, options: [Swift.AnyHashable : Any]? = nil, type storeType: CoreData.NSPersistentStore.StoreType) throws -> CoreData.NSPersistentStore
  public func destroyPersistentStore(at url: Foundation.URL, type storeType: CoreData.NSPersistentStore.StoreType, options: [Swift.AnyHashable : Any]? = nil) throws
  public func replacePersistentStore(at destinationURL: Foundation.URL, destinationOptions: [Swift.AnyHashable : Any]? = nil, withPersistentStoreFrom sourceURL: Foundation.URL, sourceOptions: [Swift.AnyHashable : Any]? = nil, type sourceType: CoreData.NSPersistentStore.StoreType) throws
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension CoreData.NSPersistentStoreCoordinator {
  @available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
  public func performAndWait<T>(_ block: () throws -> T) rethrows -> T
  
  #if compiler(>=5.3) && $AsyncAwait
  @available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
  public func perform<T>(_ block: @escaping () throws -> T) async rethrows -> T
  #endif

}
@available(iOS 15.0, macOS 12.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension CoreData.NSCoreDataCoreSpotlightDelegate {
  public static let indexDidUpdateNotification: Foundation.Notification.Name
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension CoreData.NSPersistentStore {
  public struct StoreType : Swift.Hashable, Swift.Equatable, Swift.RawRepresentable {
    public var rawValue: Swift.String
    public init(rawValue: Swift.String)
    public typealias RawValue = Swift.String
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension CoreData.NSPersistentStore.StoreType {
  public static let sqlite: CoreData.NSPersistentStore.StoreType
  public static let binary: CoreData.NSPersistentStore.StoreType
  public static let inMemory: CoreData.NSPersistentStore.StoreType
}
@available(macOS 10.12, iOS 10.0, tvOS 10.0, watchOS 3.0, *)
extension CoreData.NSManagedObject {
  @_disfavoredOverload @objc dynamic public class func fetchRequest() -> CoreData.NSFetchRequest<CoreData.NSFetchRequestResult>
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension CoreData.NSManagedObject : Combine.ObservableObject {
  public var objectWillChange: Combine.ObservableObjectPublisher {
    get
  }
  public typealias ObjectWillChangePublisher = Combine.ObservableObjectPublisher
}
extension Foundation.CocoaError.Code {
  public static var managedObjectValidation: Foundation.CocoaError.Code {
    get
  }
  public static var validationMultipleErrors: Foundation.CocoaError.Code {
    get
  }
  public static var validationMissingMandatoryProperty: Foundation.CocoaError.Code {
    get
  }
  public static var validationRelationshipLacksMinimumCount: Foundation.CocoaError.Code {
    get
  }
  public static var validationRelationshipExceedsMaximumCount: Foundation.CocoaError.Code {
    get
  }
  public static var validationRelationshipDeniedDelete: Foundation.CocoaError.Code {
    get
  }
  public static var validationNumberTooLarge: Foundation.CocoaError.Code {
    get
  }
  public static var validationNumberTooSmall: Foundation.CocoaError.Code {
    get
  }
  public static var validationDateTooLate: Foundation.CocoaError.Code {
    get
  }
  public static var validationDateTooSoon: Foundation.CocoaError.Code {
    get
  }
  public static var validationInvalidDate: Foundation.CocoaError.Code {
    get
  }
  public static var validationStringTooLong: Foundation.CocoaError.Code {
    get
  }
  public static var validationStringTooShort: Foundation.CocoaError.Code {
    get
  }
  public static var validationStringPatternMatching: Foundation.CocoaError.Code {
    get
  }
  public static var managedObjectContextLocking: Foundation.CocoaError.Code {
    get
  }
  public static var persistentStoreCoordinatorLocking: Foundation.CocoaError.Code {
    get
  }
  public static var managedObjectReferentialIntegrity: Foundation.CocoaError.Code {
    get
  }
  public static var managedObjectExternalRelationship: Foundation.CocoaError.Code {
    get
  }
  public static var managedObjectMerge: Foundation.CocoaError.Code {
    get
  }
  public static var managedObjectConstraintMerge: Foundation.CocoaError.Code {
    get
  }
  public static var persistentStoreInvalidType: Foundation.CocoaError.Code {
    get
  }
  public static var persistentStoreTypeMismatch: Foundation.CocoaError.Code {
    get
  }
  public static var persistentStoreIncompatibleSchema: Foundation.CocoaError.Code {
    get
  }
  public static var persistentStoreSave: Foundation.CocoaError.Code {
    get
  }
  public static var persistentStoreIncompleteSave: Foundation.CocoaError.Code {
    get
  }
  public static var persistentStoreSaveConflicts: Foundation.CocoaError.Code {
    get
  }
  public static var coreData: Foundation.CocoaError.Code {
    get
  }
  public static var persistentStoreOperation: Foundation.CocoaError.Code {
    get
  }
  public static var persistentStoreOpen: Foundation.CocoaError.Code {
    get
  }
  public static var persistentStoreTimeout: Foundation.CocoaError.Code {
    get
  }
  public static var persistentStoreUnsupportedRequestType: Foundation.CocoaError.Code {
    get
  }
  public static var persistentStoreIncompatibleVersionHash: Foundation.CocoaError.Code {
    get
  }
  public static var migration: Foundation.CocoaError.Code {
    get
  }
  public static var migrationCancelled: Foundation.CocoaError.Code {
    get
  }
  public static var migrationMissingSourceModel: Foundation.CocoaError.Code {
    get
  }
  public static var migrationMissingMappingModel: Foundation.CocoaError.Code {
    get
  }
  public static var migrationManagerSourceStore: Foundation.CocoaError.Code {
    get
  }
  public static var migrationManagerDestinationStore: Foundation.CocoaError.Code {
    get
  }
  public static var entityMigrationPolicy: Foundation.CocoaError.Code {
    get
  }
  public static var sqlite: Foundation.CocoaError.Code {
    get
  }
  public static var inferredMappingModel: Foundation.CocoaError.Code {
    get
  }
  public static var externalRecordImport: Foundation.CocoaError.Code {
    get
  }
}
extension Foundation.CocoaError.Code {
  @available(*, deprecated, renamed: "managedObjectValidation")
  public static var managedObjectValidationError: Foundation.CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "validationMultipleErrors")
  public static var validationMultipleErrorsError: Foundation.CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "validationMissingMandatoryProperty")
  public static var validationMissingMandatoryPropertyError: Foundation.CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "validationRelationshipLacksMinimumCount")
  public static var validationRelationshipLacksMinimumCountError: Foundation.CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "validationRelationshipExceedsMaximumCount")
  public static var validationRelationshipExceedsMaximumCountError: Foundation.CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "validationRelationshipDeniedDelete")
  public static var validationRelationshipDeniedDeleteError: Foundation.CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "validationNumberTooLarge")
  public static var validationNumberTooLargeError: Foundation.CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "validationNumberTooSmall")
  public static var validationNumberTooSmallError: Foundation.CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "validationDateTooLate")
  public static var validationDateTooLateError: Foundation.CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "validationDateTooSoon")
  public static var validationDateTooSoonError: Foundation.CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "validationInvalidDate")
  public static var validationInvalidDateError: Foundation.CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "validationStringTooLong")
  public static var validationStringTooLongError: Foundation.CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "validationStringTooShort")
  public static var validationStringTooShortError: Foundation.CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "validationStringPatternMatching")
  public static var validationStringPatternMatchingError: Foundation.CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "managedObjectContextLocking")
  public static var managedObjectContextLockingError: Foundation.CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "persistentStoreCoordinatorLocking")
  public static var persistentStoreCoordinatorLockingError: Foundation.CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "managedObjectReferentialIntegrity")
  public static var managedObjectReferentialIntegrityError: Foundation.CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "managedObjectExternalRelationship")
  public static var managedObjectExternalRelationshipError: Foundation.CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "managedObjectMerge")
  public static var managedObjectMergeError: Foundation.CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "managedObjectConstraintMerge")
  public static var managedObjectConstraintMergeError: Foundation.CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "persistentStoreInvalidType")
  public static var persistentStoreInvalidTypeError: Foundation.CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "persistentStoreTypeMismatch")
  public static var persistentStoreTypeMismatchError: Foundation.CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "persistentStoreIncompatibleSchema")
  public static var persistentStoreIncompatibleSchemaError: Foundation.CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "persistentStoreSave")
  public static var persistentStoreSaveError: Foundation.CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "persistentStoreIncompleteSave")
  public static var persistentStoreIncompleteSaveError: Foundation.CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "persistentStoreSaveConflicts")
  public static var persistentStoreSaveConflictsError: Foundation.CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "coreData")
  public static var coreDataError: Foundation.CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "persistentStoreOperation")
  public static var persistentStoreOperationError: Foundation.CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "persistentStoreOpen")
  public static var persistentStoreOpenError: Foundation.CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "persistentStoreTimeout")
  public static var persistentStoreTimeoutError: Foundation.CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "persistentStoreUnsupportedRequestType")
  public static var persistentStoreUnsupportedRequestTypeError: Foundation.CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "persistentStoreIncompatibleVersionHash")
  public static var persistentStoreIncompatibleVersionHashError: Foundation.CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "migration")
  public static var migrationError: Foundation.CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "migrationCancelled")
  public static var migrationCancelledError: Foundation.CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "migrationMissingSourceModel")
  public static var migrationMissingSourceModelError: Foundation.CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "migrationMissingMappingModel")
  public static var migrationMissingMappingModelError: Foundation.CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "migrationManagerSourceStore")
  public static var migrationManagerSourceStoreError: Foundation.CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "migrationManagerDestinationStore")
  public static var migrationManagerDestinationStoreError: Foundation.CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "entityMigrationPolicy")
  public static var entityMigrationPolicyError: Foundation.CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "sqlite")
  public static var sqliteError: Foundation.CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "inferredMappingModel")
  public static var inferredMappingModelError: Foundation.CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "externalRecordImport")
  public static var externalRecordImportError: Foundation.CocoaError.Code {
    get
  }
}
extension Foundation.CocoaError {
  public static var managedObjectValidation: Foundation.CocoaError.Code {
    get
  }
  public static var validationMultipleErrors: Foundation.CocoaError.Code {
    get
  }
  public static var validationMissingMandatoryProperty: Foundation.CocoaError.Code {
    get
  }
  public static var validationRelationshipLacksMinimumCount: Foundation.CocoaError.Code {
    get
  }
  public static var validationRelationshipExceedsMaximumCount: Foundation.CocoaError.Code {
    get
  }
  public static var validationRelationshipDeniedDelete: Foundation.CocoaError.Code {
    get
  }
  public static var validationNumberTooLarge: Foundation.CocoaError.Code {
    get
  }
  public static var validationNumberTooSmall: Foundation.CocoaError.Code {
    get
  }
  public static var validationDateTooLate: Foundation.CocoaError.Code {
    get
  }
  public static var validationDateTooSoon: Foundation.CocoaError.Code {
    get
  }
  public static var validationInvalidDate: Foundation.CocoaError.Code {
    get
  }
  public static var validationStringTooLong: Foundation.CocoaError.Code {
    get
  }
  public static var validationStringTooShort: Foundation.CocoaError.Code {
    get
  }
  public static var validationStringPatternMatching: Foundation.CocoaError.Code {
    get
  }
  public static var managedObjectContextLocking: Foundation.CocoaError.Code {
    get
  }
  public static var persistentStoreCoordinatorLocking: Foundation.CocoaError.Code {
    get
  }
  public static var managedObjectReferentialIntegrity: Foundation.CocoaError.Code {
    get
  }
  public static var managedObjectExternalRelationship: Foundation.CocoaError.Code {
    get
  }
  public static var managedObjectMerge: Foundation.CocoaError.Code {
    get
  }
  public static var managedObjectConstraintMerge: Foundation.CocoaError.Code {
    get
  }
  public static var persistentStoreInvalidType: Foundation.CocoaError.Code {
    get
  }
  public static var persistentStoreTypeMismatch: Foundation.CocoaError.Code {
    get
  }
  public static var persistentStoreIncompatibleSchema: Foundation.CocoaError.Code {
    get
  }
  public static var persistentStoreSave: Foundation.CocoaError.Code {
    get
  }
  public static var persistentStoreIncompleteSave: Foundation.CocoaError.Code {
    get
  }
  public static var persistentStoreSaveConflicts: Foundation.CocoaError.Code {
    get
  }
  public static var coreData: Foundation.CocoaError.Code {
    get
  }
  public static var persistentStoreOperation: Foundation.CocoaError.Code {
    get
  }
  public static var persistentStoreOpen: Foundation.CocoaError.Code {
    get
  }
  public static var persistentStoreTimeout: Foundation.CocoaError.Code {
    get
  }
  public static var persistentStoreUnsupportedRequestType: Foundation.CocoaError.Code {
    get
  }
  public static var persistentStoreIncompatibleVersionHash: Foundation.CocoaError.Code {
    get
  }
  public static var migration: Foundation.CocoaError.Code {
    get
  }
  public static var migrationCancelled: Foundation.CocoaError.Code {
    get
  }
  public static var migrationMissingSourceModel: Foundation.CocoaError.Code {
    get
  }
  public static var migrationMissingMappingModel: Foundation.CocoaError.Code {
    get
  }
  public static var migrationManagerSourceStore: Foundation.CocoaError.Code {
    get
  }
  public static var migrationManagerDestinationStore: Foundation.CocoaError.Code {
    get
  }
  public static var entityMigrationPolicy: Foundation.CocoaError.Code {
    get
  }
  public static var sqlite: Foundation.CocoaError.Code {
    get
  }
  public static var inferredMappingModel: Foundation.CocoaError.Code {
    get
  }
  public static var externalRecordImport: Foundation.CocoaError.Code {
    get
  }
}
extension Foundation.CocoaError {
  @available(*, deprecated, renamed: "managedObjectValidation")
  public static var managedObjectValidationError: Foundation.CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "validationMultipleErrors")
  public static var validationMultipleErrorsError: Foundation.CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "validationMissingMandatoryProperty")
  public static var validationMissingMandatoryPropertyError: Foundation.CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "validationRelationshipLacksMinimumCount")
  public static var validationRelationshipLacksMinimumCountError: Foundation.CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "validationRelationshipExceedsMaximumCount")
  public static var validationRelationshipExceedsMaximumCountError: Foundation.CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "validationRelationshipDeniedDelete")
  public static var validationRelationshipDeniedDeleteError: Foundation.CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "validationNumberTooLarge")
  public static var validationNumberTooLargeError: Foundation.CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "validationNumberTooSmall")
  public static var validationNumberTooSmallError: Foundation.CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "validationDateTooLate")
  public static var validationDateTooLateError: Foundation.CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "validationDateTooSoon")
  public static var validationDateTooSoonError: Foundation.CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "validationInvalidDate")
  public static var validationInvalidDateError: Foundation.CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "validationStringTooLong")
  public static var validationStringTooLongError: Foundation.CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "validationStringTooShort")
  public static var validationStringTooShortError: Foundation.CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "validationStringPatternMatching")
  public static var validationStringPatternMatchingError: Foundation.CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "managedObjectContextLocking")
  public static var managedObjectContextLockingError: Foundation.CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "persistentStoreCoordinatorLocking")
  public static var persistentStoreCoordinatorLockingError: Foundation.CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "managedObjectReferentialIntegrity")
  public static var managedObjectReferentialIntegrityError: Foundation.CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "managedObjectExternalRelationship")
  public static var managedObjectExternalRelationshipError: Foundation.CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "managedObjectMerge")
  public static var managedObjectMergeError: Foundation.CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "managedObjectConstraintMerge")
  public static var managedObjectConstraintMergeError: Foundation.CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "persistentStoreInvalidType")
  public static var persistentStoreInvalidTypeError: Foundation.CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "persistentStoreTypeMismatch")
  public static var persistentStoreTypeMismatchError: Foundation.CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "persistentStoreIncompatibleSchema")
  public static var persistentStoreIncompatibleSchemaError: Foundation.CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "persistentStoreSave")
  public static var persistentStoreSaveError: Foundation.CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "persistentStoreIncompleteSave")
  public static var persistentStoreIncompleteSaveError: Foundation.CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "persistentStoreSaveConflicts")
  public static var persistentStoreSaveConflictsError: Foundation.CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "coreData")
  public static var coreDataError: Foundation.CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "persistentStoreOperation")
  public static var persistentStoreOperationError: Foundation.CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "persistentStoreOpen")
  public static var persistentStoreOpenError: Foundation.CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "persistentStoreTimeout")
  public static var persistentStoreTimeoutError: Foundation.CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "persistentStoreUnsupportedRequestType")
  public static var persistentStoreUnsupportedRequestTypeError: Foundation.CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "persistentStoreIncompatibleVersionHash")
  public static var persistentStoreIncompatibleVersionHashError: Foundation.CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "migration")
  public static var migrationError: Foundation.CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "migrationCancelled")
  public static var migrationCancelledError: Foundation.CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "migrationMissingSourceModel")
  public static var migrationMissingSourceModelError: Foundation.CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "migrationMissingMappingModel")
  public static var migrationMissingMappingModelError: Foundation.CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "migrationManagerSourceStore")
  public static var migrationManagerSourceStoreError: Foundation.CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "migrationManagerDestinationStore")
  public static var migrationManagerDestinationStoreError: Foundation.CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "entityMigrationPolicy")
  public static var entityMigrationPolicyError: Foundation.CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "sqlite")
  public static var sqliteError: Foundation.CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "inferredMappingModel")
  public static var inferredMappingModelError: Foundation.CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "externalRecordImport")
  public static var externalRecordImportError: Foundation.CocoaError.Code {
    get
  }
}
extension Foundation.CocoaError {
  public var validationObject: Any? {
    get
  }
  public var validationKey: Swift.String? {
    get
  }
  public var validationPredicate: Foundation.NSPredicate? {
    get
  }
  public var validationValue: Any? {
    get
  }
  public var affectedStores: [Swift.AnyObject]? {
    get
  }
  public var affectedObjects: [Swift.AnyObject]? {
    get
  }
  public var persistentStoreSaveConflicts: [CoreData.NSMergeConflict]? {
    get
  }
}
extension Foundation.CocoaError {
  @available(*, unavailable, renamed: "managedObjectValidation")
  public static var ManagedObjectValidationError: Foundation.CocoaError.Code {
    get
  }
  @available(*, unavailable, renamed: "validationMultipleErrors")
  public static var ValidationMultipleErrorsError: Foundation.CocoaError.Code {
    get
  }
  @available(*, unavailable, renamed: "validationMissingMandatoryProperty")
  public static var ValidationMissingMandatoryPropertyError: Foundation.CocoaError.Code {
    get
  }
  @available(*, unavailable, renamed: "validationRelationshipLacksMinimumCount")
  public static var ValidationRelationshipLacksMinimumCountError: Foundation.CocoaError.Code {
    get
  }
  @available(*, unavailable, renamed: "validationRelationshipExceedsMaximumCount")
  public static var ValidationRelationshipExceedsMaximumCountError: Foundation.CocoaError.Code {
    get
  }
  @available(*, unavailable, renamed: "validationRelationshipDeniedDelete")
  public static var ValidationRelationshipDeniedDeleteError: Foundation.CocoaError.Code {
    get
  }
  @available(*, unavailable, renamed: "validationNumberTooLarge")
  public static var ValidationNumberTooLargeError: Foundation.CocoaError.Code {
    get
  }
  @available(*, unavailable, renamed: "validationNumberTooSmall")
  public static var ValidationNumberTooSmallError: Foundation.CocoaError.Code {
    get
  }
  @available(*, unavailable, renamed: "validationDateTooLate")
  public static var ValidationDateTooLateError: Foundation.CocoaError.Code {
    get
  }
  @available(*, unavailable, renamed: "validationDateTooSoon")
  public static var ValidationDateTooSoonError: Foundation.CocoaError.Code {
    get
  }
  @available(*, unavailable, renamed: "validationInvalidDate")
  public static var ValidationInvalidDateError: Foundation.CocoaError.Code {
    get
  }
  @available(*, unavailable, renamed: "validationStringTooLong")
  public static var ValidationStringTooLongError: Foundation.CocoaError.Code {
    get
  }
  @available(*, unavailable, renamed: "validationStringTooShort")
  public static var ValidationStringTooShortError: Foundation.CocoaError.Code {
    get
  }
  @available(*, unavailable, renamed: "validationStringPatternMatching")
  public static var ValidationStringPatternMatchingError: Foundation.CocoaError.Code {
    get
  }
  @available(*, unavailable, renamed: "managedObjectContextLocking")
  public static var ManagedObjectContextLockingError: Foundation.CocoaError.Code {
    get
  }
  @available(*, unavailable, renamed: "persistentStoreCoordinatorLocking")
  public static var PersistentStoreCoordinatorLockingError: Foundation.CocoaError.Code {
    get
  }
  @available(*, unavailable, renamed: "managedObjectReferentialIntegrity")
  public static var ManagedObjectReferentialIntegrityError: Foundation.CocoaError.Code {
    get
  }
  @available(*, unavailable, renamed: "managedObjectExternalRelationship")
  public static var ManagedObjectExternalRelationshipError: Foundation.CocoaError.Code {
    get
  }
  @available(*, unavailable, renamed: "managedObjectMerge")
  public static var ManagedObjectMergeError: Foundation.CocoaError.Code {
    get
  }
  @available(*, unavailable, renamed: "managedObjectConstraintMerge")
  public static var ManagedObjectConstraintMergeError: Foundation.CocoaError.Code {
    get
  }
  @available(*, unavailable, renamed: "persistentStoreInvalidType")
  public static var PersistentStoreInvalidTypeError: Foundation.CocoaError.Code {
    get
  }
  @available(*, unavailable, renamed: "persistentStoreTypeMismatch")
  public static var PersistentStoreTypeMismatchError: Foundation.CocoaError.Code {
    get
  }
  @available(*, unavailable, renamed: "persistentStoreIncompatibleSchema")
  public static var PersistentStoreIncompatibleSchemaError: Foundation.CocoaError.Code {
    get
  }
  @available(*, unavailable, renamed: "persistentStoreSave")
  public static var PersistentStoreSaveError: Foundation.CocoaError.Code {
    get
  }
  @available(*, unavailable, renamed: "persistentStoreIncompleteSave")
  public static var PersistentStoreIncompleteSaveError: Foundation.CocoaError.Code {
    get
  }
  @available(*, unavailable, renamed: "persistentStoreSaveConflicts")
  public static var PersistentStoreSaveConflictsError: Foundation.CocoaError.Code {
    get
  }
  @available(*, unavailable, renamed: "coreData")
  public static var CoreDataError: Foundation.CocoaError.Code {
    get
  }
  @available(*, unavailable, renamed: "persistentStoreOperation")
  public static var PersistentStoreOperationError: Foundation.CocoaError.Code {
    get
  }
  @available(*, unavailable, renamed: "persistentStoreOpen")
  public static var PersistentStoreOpenError: Foundation.CocoaError.Code {
    get
  }
  @available(*, unavailable, renamed: "persistentStoreTimeout")
  public static var PersistentStoreTimeoutError: Foundation.CocoaError.Code {
    get
  }
  @available(*, unavailable, renamed: "persistentStoreUnsupportedRequestType")
  public static var PersistentStoreUnsupportedRequestTypeError: Foundation.CocoaError.Code {
    get
  }
  @available(*, unavailable, renamed: "persistentStoreIncompatibleVersionHash")
  public static var PersistentStoreIncompatibleVersionHashError: Foundation.CocoaError.Code {
    get
  }
  @available(*, unavailable, renamed: "migration")
  public static var MigrationError: Foundation.CocoaError.Code {
    get
  }
  @available(*, unavailable, renamed: "migrationCancelled")
  public static var MigrationCancelledError: Foundation.CocoaError.Code {
    get
  }
  @available(*, unavailable, renamed: "migrationMissingSourceModel")
  public static var MigrationMissingSourceModelError: Foundation.CocoaError.Code {
    get
  }
  @available(*, unavailable, renamed: "migrationMissingMappingModel")
  public static var MigrationMissingMappingModelError: Foundation.CocoaError.Code {
    get
  }
  @available(*, unavailable, renamed: "migrationManagerSourceStore")
  public static var MigrationManagerSourceStoreError: Foundation.CocoaError.Code {
    get
  }
  @available(*, unavailable, renamed: "migrationManagerDestinationStore")
  public static var MigrationManagerDestinationStoreError: Foundation.CocoaError.Code {
    get
  }
  @available(*, unavailable, renamed: "entityMigrationPolicy")
  public static var EntityMigrationPolicyError: Foundation.CocoaError.Code {
    get
  }
  @available(*, unavailable, renamed: "sqlite")
  public static var SQLiteError: Foundation.CocoaError.Code {
    get
  }
  @available(*, unavailable, renamed: "inferredMappingModel")
  public static var InferredMappingModelError: Foundation.CocoaError.Code {
    get
  }
  @available(*, unavailable, renamed: "externalRecordImport")
  public static var ExternalRecordImportError: Foundation.CocoaError.Code {
    get
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension CoreData.NSPersistentContainer {
  public class var defaultDirectoryURL: Foundation.URL {
    get
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension CoreData.NSPersistentContainer {
  
  #if compiler(>=5.3) && $AsyncAwait
  @available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
  public func performBackgroundTask<T>(_ block: @escaping (CoreData.NSManagedObjectContext) throws -> T) async rethrows -> T
  #endif

}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension CoreData.NSMigrationManager {
  public func migrateStore(from sourceURL: Foundation.URL, type sourceType: CoreData.NSPersistentStore.StoreType, options sourceOptions: [Swift.AnyHashable : Any]? = nil, mapping: CoreData.NSMappingModel, to destinationURL: Foundation.URL, type destinationType: CoreData.NSPersistentStore.StoreType, options destinationOptions: [Swift.AnyHashable : Any]? = nil) throws
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension CoreData.NSExpressionDescription {
  public var resultType: CoreData.NSAttributeDescription.AttributeType {
    get
    set
  }
}
extension CoreData.NSManagedObjectContext {
  public func fetch<T>(_ request: CoreData.NSFetchRequest<T>) throws -> [T] where T : CoreData.NSFetchRequestResult
  @_disfavoredOverload public func fetch(_ request: CoreData.NSFetchRequest<CoreData.NSFetchRequestResult>) throws -> [Any]
  public func count<T>(for request: CoreData.NSFetchRequest<T>) throws -> Swift.Int where T : CoreData.NSFetchRequestResult
}
@available(iOS 14.0, *)
extension CoreData.NSManagedObjectContext {
  public static let willSaveObjectsNotification: Foundation.Notification.Name
  public static let didSaveObjectsNotification: Foundation.Notification.Name
  public static let didChangeObjectsNotification: Foundation.Notification.Name
  public static let didSaveObjectIDsNotification: Foundation.Notification.Name
  public static let didMergeChangesObjectIDsNotification: Foundation.Notification.Name
  public enum NotificationKey : Swift.String {
    case queryGeneration
    case invalidatedAllObjects
    case insertedObjects
    case updatedObjects
    case deletedObjects
    case refreshedObjects
    case invalidatedObjects
    case insertedObjectIDs
    case updatedObjectIDs
    case deletedObjectIDs
    case refreshedObjectIDs
    case invalidatedObjectIDs
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension CoreData.NSManagedObjectContext.ConcurrencyType {
  public static let privateQueue: CoreData.NSManagedObjectContext.ConcurrencyType
  public static let mainQueue: CoreData.NSManagedObjectContext.ConcurrencyType
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension CoreData.NSManagedObjectContext {
  public struct ConcurrencyType : Swift.Hashable, Swift.Equatable, Swift.RawRepresentable {
    public var rawValue: CoreData.NSManagedObjectContextConcurrencyType
    public init(rawValue: CoreData.NSManagedObjectContextConcurrencyType)
    public typealias RawValue = CoreData.NSManagedObjectContextConcurrencyType
  }
  public enum ScheduledTaskType {
    case immediate
    case enqueued
    public static func == (a: CoreData.NSManagedObjectContext.ScheduledTaskType, b: CoreData.NSManagedObjectContext.ScheduledTaskType) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  convenience public init(_ type: CoreData.NSManagedObjectContext.ConcurrencyType)
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension CoreData.NSManagedObjectContext {
  public func performAndWait<T>(_ block: () throws -> T) rethrows -> T
  
  #if compiler(>=5.3) && $AsyncAwait
  public func perform<T>(schedule: CoreData.NSManagedObjectContext.ScheduledTaskType = .immediate, _ block: @escaping () throws -> T) async rethrows -> T
  #endif

}
@available(iOS 14.0, *)
extension CoreData.NSManagedObjectContext.NotificationKey : Swift.Equatable {}
@available(iOS 14.0, *)
extension CoreData.NSManagedObjectContext.NotificationKey : Swift.Hashable {}
@available(iOS 14.0, *)
extension CoreData.NSManagedObjectContext.NotificationKey : Swift.RawRepresentable {}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension CoreData.NSManagedObjectContext.ScheduledTaskType : Swift.Equatable {}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension CoreData.NSManagedObjectContext.ScheduledTaskType : Swift.Hashable {}
