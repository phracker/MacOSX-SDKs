// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 5.5 (swiftlang-1300.0.29.207 clang-1300.0.28.1)
// swift-module-flags: -target arm64e-apple-ios15.0-macabi -enable-objc-interop -autolink-force-load -enable-library-evolution -module-link-name swiftUIKit -swift-version 5 -enforce-exclusivity=checked -O -module-name UIKit
@_exported import Accessibility
import CoreGraphics
import DataDetection
import Dispatch
import Foundation
import Swift
@_exported import UIKit
@_exported import _Concurrency
@available(swift 5.1)
@available(iOS 15, tvOS 15, *)
public protocol UIViewInvalidating {
  func invalidate(view: UIKit.UIView)
}
extension UIKit.UIView {
  @available(swift 5.1)
  @available(iOS 15, tvOS 15, *)
  @propertyWrapper public struct Invalidating<Value, InvalidationType> where Value : Swift.Equatable, InvalidationType : UIKit.UIViewInvalidating {
    @available(*, unavailable, message: "@UIView.Invalidating can only be used on subclasses of UIView")
    public var wrappedValue: Value {
      get
      set
    }
    public init(wrappedValue: Value, _ invalidation: InvalidationType)
    public init<InvalidationType1, InvalidationType2>(wrappedValue: Value, _ invalidation1: InvalidationType1, _ invalidation2: InvalidationType2) where InvalidationType == UIKit.UIView.Invalidations.Tuple<InvalidationType1, InvalidationType2>, InvalidationType1 : UIKit.UIViewInvalidating, InvalidationType2 : UIKit.UIViewInvalidating
    public init<InvalidationType1, InvalidationType2, InvalidationType3>(wrappedValue: Value, _ invalidation1: InvalidationType1, _ invalidation2: InvalidationType2, _ invalidation3: InvalidationType3) where InvalidationType == UIKit.UIView.Invalidations.Tuple<UIKit.UIView.Invalidations.Tuple<InvalidationType1, InvalidationType2>, InvalidationType3>, InvalidationType1 : UIKit.UIViewInvalidating, InvalidationType2 : UIKit.UIViewInvalidating, InvalidationType3 : UIKit.UIViewInvalidating
    public init<InvalidationType1, InvalidationType2, InvalidationType3, InvalidationType4>(wrappedValue: Value, _ invalidation1: InvalidationType1, _ invalidation2: InvalidationType2, _ invalidation3: InvalidationType3, _ invalidation4: InvalidationType4) where InvalidationType == UIKit.UIView.Invalidations.Tuple<UIKit.UIView.Invalidations.Tuple<InvalidationType1, InvalidationType2>, UIKit.UIView.Invalidations.Tuple<InvalidationType3, InvalidationType4>>, InvalidationType1 : UIKit.UIViewInvalidating, InvalidationType2 : UIKit.UIViewInvalidating, InvalidationType3 : UIKit.UIViewInvalidating, InvalidationType4 : UIKit.UIViewInvalidating
    public init<InvalidationType1, InvalidationType2, InvalidationType3, InvalidationType4, InvalidationType5>(wrappedValue: Value, _ invalidation1: InvalidationType1, _ invalidation2: InvalidationType2, _ invalidation3: InvalidationType3, _ invalidation4: InvalidationType4, _ invalidation5: InvalidationType5) where InvalidationType == UIKit.UIView.Invalidations.Tuple<UIKit.UIView.Invalidations.Tuple<UIKit.UIView.Invalidations.Tuple<InvalidationType1, InvalidationType2>, UIKit.UIView.Invalidations.Tuple<InvalidationType3, InvalidationType4>>, InvalidationType5>, InvalidationType1 : UIKit.UIViewInvalidating, InvalidationType2 : UIKit.UIViewInvalidating, InvalidationType3 : UIKit.UIViewInvalidating, InvalidationType4 : UIKit.UIViewInvalidating, InvalidationType5 : UIKit.UIViewInvalidating
    public init<InvalidationType1, InvalidationType2, InvalidationType3, InvalidationType4, InvalidationType5, InvalidationType6>(wrappedValue: Value, _ invalidation1: InvalidationType1, _ invalidation2: InvalidationType2, _ invalidation3: InvalidationType3, _ invalidation4: InvalidationType4, _ invalidation5: InvalidationType5, _ invalidation6: InvalidationType6) where InvalidationType == UIKit.UIView.Invalidations.Tuple<UIKit.UIView.Invalidations.Tuple<UIKit.UIView.Invalidations.Tuple<InvalidationType1, InvalidationType2>, UIKit.UIView.Invalidations.Tuple<InvalidationType3, InvalidationType4>>, UIKit.UIView.Invalidations.Tuple<InvalidationType5, InvalidationType6>>, InvalidationType1 : UIKit.UIViewInvalidating, InvalidationType2 : UIKit.UIViewInvalidating, InvalidationType3 : UIKit.UIViewInvalidating, InvalidationType4 : UIKit.UIViewInvalidating, InvalidationType5 : UIKit.UIViewInvalidating, InvalidationType6 : UIKit.UIViewInvalidating
    public init<InvalidationType1, InvalidationType2, InvalidationType3, InvalidationType4, InvalidationType5, InvalidationType6, InvalidationType7>(wrappedValue: Value, _ invalidation1: InvalidationType1, _ invalidation2: InvalidationType2, _ invalidation3: InvalidationType3, _ invalidation4: InvalidationType4, _ invalidation5: InvalidationType5, _ invalidation6: InvalidationType6, _ invalidation7: InvalidationType7) where InvalidationType == UIKit.UIView.Invalidations.Tuple<UIKit.UIView.Invalidations.Tuple<UIKit.UIView.Invalidations.Tuple<InvalidationType1, InvalidationType2>, UIKit.UIView.Invalidations.Tuple<InvalidationType3, InvalidationType4>>, UIKit.UIView.Invalidations.Tuple<UIKit.UIView.Invalidations.Tuple<InvalidationType5, InvalidationType6>, InvalidationType7>>, InvalidationType1 : UIKit.UIViewInvalidating, InvalidationType2 : UIKit.UIViewInvalidating, InvalidationType3 : UIKit.UIViewInvalidating, InvalidationType4 : UIKit.UIViewInvalidating, InvalidationType5 : UIKit.UIViewInvalidating, InvalidationType6 : UIKit.UIViewInvalidating, InvalidationType7 : UIKit.UIViewInvalidating
    public init<InvalidationType1, InvalidationType2, InvalidationType3, InvalidationType4, InvalidationType5, InvalidationType6, InvalidationType7, InvalidationType8>(wrappedValue: Value, _ invalidation1: InvalidationType1, _ invalidation2: InvalidationType2, _ invalidation3: InvalidationType3, _ invalidation4: InvalidationType4, _ invalidation5: InvalidationType5, _ invalidation6: InvalidationType6, _ invalidation7: InvalidationType7, _ invalidation8: InvalidationType8) where InvalidationType == UIKit.UIView.Invalidations.Tuple<UIKit.UIView.Invalidations.Tuple<UIKit.UIView.Invalidations.Tuple<InvalidationType1, InvalidationType2>, UIKit.UIView.Invalidations.Tuple<InvalidationType3, InvalidationType4>>, UIKit.UIView.Invalidations.Tuple<UIKit.UIView.Invalidations.Tuple<InvalidationType5, InvalidationType6>, UIKit.UIView.Invalidations.Tuple<InvalidationType7, InvalidationType8>>>, InvalidationType1 : UIKit.UIViewInvalidating, InvalidationType2 : UIKit.UIViewInvalidating, InvalidationType3 : UIKit.UIViewInvalidating, InvalidationType4 : UIKit.UIViewInvalidating, InvalidationType5 : UIKit.UIViewInvalidating, InvalidationType6 : UIKit.UIViewInvalidating, InvalidationType7 : UIKit.UIViewInvalidating, InvalidationType8 : UIKit.UIViewInvalidating
    public init<InvalidationType1, InvalidationType2, InvalidationType3, InvalidationType4, InvalidationType5, InvalidationType6, InvalidationType7, InvalidationType8, InvalidationType9>(wrappedValue: Value, _ invalidation1: InvalidationType1, _ invalidation2: InvalidationType2, _ invalidation3: InvalidationType3, _ invalidation4: InvalidationType4, _ invalidation5: InvalidationType5, _ invalidation6: InvalidationType6, _ invalidation7: InvalidationType7, _ invalidation8: InvalidationType8, _ invalidation9: InvalidationType9) where InvalidationType == UIKit.UIView.Invalidations.Tuple<UIKit.UIView.Invalidations.Tuple<UIKit.UIView.Invalidations.Tuple<UIKit.UIView.Invalidations.Tuple<InvalidationType1, InvalidationType2>, UIKit.UIView.Invalidations.Tuple<InvalidationType3, InvalidationType4>>, UIKit.UIView.Invalidations.Tuple<UIKit.UIView.Invalidations.Tuple<InvalidationType5, InvalidationType6>, UIKit.UIView.Invalidations.Tuple<InvalidationType7, InvalidationType8>>>, InvalidationType9>, InvalidationType1 : UIKit.UIViewInvalidating, InvalidationType2 : UIKit.UIViewInvalidating, InvalidationType3 : UIKit.UIViewInvalidating, InvalidationType4 : UIKit.UIViewInvalidating, InvalidationType5 : UIKit.UIViewInvalidating, InvalidationType6 : UIKit.UIViewInvalidating, InvalidationType7 : UIKit.UIViewInvalidating, InvalidationType8 : UIKit.UIViewInvalidating, InvalidationType9 : UIKit.UIViewInvalidating
    public init<InvalidationType1, InvalidationType2, InvalidationType3, InvalidationType4, InvalidationType5, InvalidationType6, InvalidationType7, InvalidationType8, InvalidationType9, InvalidationType10>(wrappedValue: Value, _ invalidation1: InvalidationType1, _ invalidation2: InvalidationType2, _ invalidation3: InvalidationType3, _ invalidation4: InvalidationType4, _ invalidation5: InvalidationType5, _ invalidation6: InvalidationType6, _ invalidation7: InvalidationType7, _ invalidation8: InvalidationType8, _ invalidation9: InvalidationType9, _ invalidation10: InvalidationType10) where InvalidationType == UIKit.UIView.Invalidations.Tuple<UIKit.UIView.Invalidations.Tuple<UIKit.UIView.Invalidations.Tuple<UIKit.UIView.Invalidations.Tuple<InvalidationType1, InvalidationType2>, UIKit.UIView.Invalidations.Tuple<InvalidationType3, InvalidationType4>>, UIKit.UIView.Invalidations.Tuple<UIKit.UIView.Invalidations.Tuple<InvalidationType5, InvalidationType6>, UIKit.UIView.Invalidations.Tuple<InvalidationType7, InvalidationType8>>>, UIKit.UIView.Invalidations.Tuple<InvalidationType9, InvalidationType10>>, InvalidationType1 : UIKit.UIViewInvalidating, InvalidationType2 : UIKit.UIViewInvalidating, InvalidationType3 : UIKit.UIViewInvalidating, InvalidationType4 : UIKit.UIViewInvalidating, InvalidationType5 : UIKit.UIViewInvalidating, InvalidationType6 : UIKit.UIViewInvalidating, InvalidationType7 : UIKit.UIViewInvalidating, InvalidationType8 : UIKit.UIViewInvalidating, InvalidationType9 : UIKit.UIViewInvalidating, InvalidationType10 : UIKit.UIViewInvalidating
    public static subscript<EnclosingSelf>(_enclosingInstance observed: EnclosingSelf, wrapped wrappedKeyPath: Swift.ReferenceWritableKeyPath<EnclosingSelf, Value>, storage storageKeyPath: Swift.ReferenceWritableKeyPath<EnclosingSelf, UIKit.UIView.Invalidating<Value, InvalidationType>>) -> Value where EnclosingSelf : UIKit.UIView {
      get
      set
    }
  }
}
@available(swift 5.1)
@available(iOS 15, tvOS 15, *)
extension UIKit.UIViewInvalidating where Self == UIKit.UIView.Invalidations.Display {
  @_alwaysEmitIntoClient public static var display: UIKit.UIView.Invalidations.Display {
    get { return .init() }
  }
}
@available(swift 5.1)
@available(iOS 15, tvOS 15, *)
extension UIKit.UIViewInvalidating where Self == UIKit.UIView.Invalidations.Layout {
  @_alwaysEmitIntoClient public static var layout: UIKit.UIView.Invalidations.Layout {
    get { return .init() }
  }
}
@available(swift 5.1)
@available(iOS 15, tvOS 15, *)
extension UIKit.UIViewInvalidating where Self == UIKit.UIView.Invalidations.Constraints {
  @_alwaysEmitIntoClient public static var constraints: UIKit.UIView.Invalidations.Constraints {
    get { return .init() }
  }
}
@available(swift 5.1)
@available(iOS 15, tvOS 15, *)
extension UIKit.UIViewInvalidating where Self == UIKit.UIView.Invalidations.IntrinsicContentSize {
  @_alwaysEmitIntoClient public static var intrinsicContentSize: UIKit.UIView.Invalidations.IntrinsicContentSize {
    get { return .init() }
  }
}
@available(swift 5.1)
@available(iOS 15, tvOS 15, *)
extension UIKit.UIViewInvalidating where Self == UIKit.UIView.Invalidations.Configuration {
  @_alwaysEmitIntoClient public static var configuration: UIKit.UIView.Invalidations.Configuration {
    get { return .init() }
  }
}
extension UIKit.UIView {
  @available(swift 5.1)
  @available(iOS 15, tvOS 15, *)
  public enum Invalidations {
    public struct Display : UIKit.UIViewInvalidating {
      public init()
      public func invalidate(view: UIKit.UIView)
    }
    public struct Layout : UIKit.UIViewInvalidating {
      public init()
      public func invalidate(view: UIKit.UIView)
    }
    public struct Constraints : UIKit.UIViewInvalidating {
      public init()
      public func invalidate(view: UIKit.UIView)
    }
    public struct IntrinsicContentSize : UIKit.UIViewInvalidating {
      public init()
      public func invalidate(view: UIKit.UIView)
    }
    public struct Configuration : UIKit.UIViewInvalidating {
      public init()
      public func invalidate(view: UIKit.UIView)
    }
    public struct Tuple<Invalidation1, Invalidation2> : UIKit.UIViewInvalidating where Invalidation1 : UIKit.UIViewInvalidating, Invalidation2 : UIKit.UIViewInvalidating {
      public init(_ invalidation1: Invalidation1, _ invalidation2: Invalidation2)
      public func invalidate(view: UIKit.UIView)
    }
  }
}
extension UIKit.UIPasteboard {
  @available(iOS 15.0, *)
  public struct DetectedValues {
    public var patterns: Swift.Set<Swift.PartialKeyPath<UIKit.UIPasteboard.DetectedValues>> {
      get
    }
    public var probableWebURL: Swift.String {
      get
    }
    public var probableWebSearch: Swift.String {
      get
    }
    public var number: Swift.Double? {
      get
    }
    public var links: [DataDetection.DDMatchLink] {
      get
    }
    public var phoneNumbers: [DataDetection.DDMatchPhoneNumber] {
      get
    }
    public var emailAddresses: [DataDetection.DDMatchEmailAddress] {
      get
    }
    public var postalAddresses: [DataDetection.DDMatchPostalAddress] {
      get
    }
    public var calendarEvents: [DataDetection.DDMatchCalendarEvent] {
      get
    }
    public var shipmentTrackingNumbers: [DataDetection.DDMatchShipmentTrackingNumber] {
      get
    }
    public var flightNumbers: [DataDetection.DDMatchFlightNumber] {
      get
    }
    public var moneyAmounts: [DataDetection.DDMatchMoneyAmount] {
      get
    }
  }
}
extension UIKit.UIPasteboard {
  @available(iOS, introduced: 14.0, deprecated: 15.0)
  open func detectPatterns(for patterns: Swift.Set<UIKit.UIPasteboard.DetectionPattern>, completionHandler: @escaping (Swift.Result<Swift.Set<UIKit.UIPasteboard.DetectionPattern>, Swift.Error>) -> ())
  @available(iOS 15.0, *)
  open func detectPatterns(for keyPaths: Swift.Set<Swift.PartialKeyPath<UIKit.UIPasteboard.DetectedValues>>, completionHandler: @escaping (Swift.Result<Swift.Set<Swift.PartialKeyPath<UIKit.UIPasteboard.DetectedValues>>, Swift.Error>) -> ())
  
  #if compiler(>=5.3) && $AsyncAwait
  @available(iOS 15.0, *)
  open func detectedPatterns(for keyPaths: Swift.Set<Swift.PartialKeyPath<UIKit.UIPasteboard.DetectedValues>>) async throws -> Swift.Set<Swift.PartialKeyPath<UIKit.UIPasteboard.DetectedValues>>
  #endif

  @available(iOS, introduced: 14.0, deprecated: 15.0)
  open func detectPatterns(for patterns: Swift.Set<UIKit.UIPasteboard.DetectionPattern>, inItemSet itemSet: Foundation.IndexSet?, completionHandler: @escaping (Swift.Result<[Swift.Set<UIKit.UIPasteboard.DetectionPattern>], Swift.Error>) -> ())
  @available(iOS 15.0, *)
  open func detectPatterns(for keyPaths: Swift.Set<Swift.PartialKeyPath<UIKit.UIPasteboard.DetectedValues>>, inItemSet itemSet: Foundation.IndexSet?, completionHandler: @escaping (Swift.Result<[Swift.Set<Swift.PartialKeyPath<UIKit.UIPasteboard.DetectedValues>>], Swift.Error>) -> ())
  
  #if compiler(>=5.3) && $AsyncAwait
  @available(iOS 15.0, *)
  open func detectedPatterns(for keyPaths: Swift.Set<Swift.PartialKeyPath<UIKit.UIPasteboard.DetectedValues>>, inItemSet itemSet: Foundation.IndexSet?) async throws -> [Swift.Set<Swift.PartialKeyPath<UIKit.UIPasteboard.DetectedValues>>]
  #endif

  @available(iOS, introduced: 14.0, deprecated: 15.0)
  open func detectValues(for patterns: Swift.Set<UIKit.UIPasteboard.DetectionPattern>, completionHandler: @escaping (Swift.Result<[UIKit.UIPasteboard.DetectionPattern : Any], Swift.Error>) -> ())
  @available(iOS 15.0, *)
  open func detectValues(for keyPaths: Swift.Set<Swift.PartialKeyPath<UIKit.UIPasteboard.DetectedValues>>, completionHandler: @escaping (Swift.Result<UIKit.UIPasteboard.DetectedValues, Swift.Error>) -> ())
  
  #if compiler(>=5.3) && $AsyncAwait
  @available(iOS 15.0, *)
  open func detectedValues(for keyPaths: Swift.Set<Swift.PartialKeyPath<UIKit.UIPasteboard.DetectedValues>>) async throws -> UIKit.UIPasteboard.DetectedValues
  #endif

  @available(iOS, introduced: 14.0, deprecated: 15.0)
  open func detectValues(for patterns: Swift.Set<UIKit.UIPasteboard.DetectionPattern>, inItemSet itemSet: Foundation.IndexSet?, completionHandler: @escaping (Swift.Result<[[UIKit.UIPasteboard.DetectionPattern : Any]], Swift.Error>) -> ())
  @available(iOS 15.0, *)
  open func detectValues(for keyPaths: Swift.Set<Swift.PartialKeyPath<UIKit.UIPasteboard.DetectedValues>>, inItemSet itemSet: Foundation.IndexSet?, completionHandler: @escaping (Swift.Result<[UIKit.UIPasteboard.DetectedValues], Swift.Error>) -> ())
  
  #if compiler(>=5.3) && $AsyncAwait
  @available(iOS 15.0, *)
  open func detectedValues(for keyPaths: Swift.Set<Swift.PartialKeyPath<UIKit.UIPasteboard.DetectedValues>>, inItemSet itemSet: Foundation.IndexSet?) async throws -> [UIKit.UIPasteboard.DetectedValues]
  #endif

}
@available(iOS 14.0, tvOS 14.0, *)
public struct NSDiffableDataSourceSectionSnapshot<ItemIdentifierType> where ItemIdentifierType : Swift.Hashable {
  public init()
  public init(_ snapshot: UIKit.NSDiffableDataSourceSectionSnapshot<ItemIdentifierType>)
  public mutating func append(_ items: [ItemIdentifierType], to parent: ItemIdentifierType? = nil)
  public mutating func insert(_ items: [ItemIdentifierType], before item: ItemIdentifierType)
  public mutating func insert(_ items: [ItemIdentifierType], after item: ItemIdentifierType)
  public mutating func delete(_ items: [ItemIdentifierType])
  public mutating func deleteAll()
  public mutating func expand(_ items: [ItemIdentifierType])
  public mutating func collapse(_ items: [ItemIdentifierType])
  public mutating func replace(childrenOf parent: ItemIdentifierType, using snapshot: UIKit.NSDiffableDataSourceSectionSnapshot<ItemIdentifierType>)
  public mutating func insert(_ snapshot: UIKit.NSDiffableDataSourceSectionSnapshot<ItemIdentifierType>, before item: (ItemIdentifierType))
  public mutating func insert(_ snapshot: UIKit.NSDiffableDataSourceSectionSnapshot<ItemIdentifierType>, after item: (ItemIdentifierType))
  public func isExpanded(_ item: ItemIdentifierType) -> Swift.Bool
  public func isVisible(_ item: ItemIdentifierType) -> Swift.Bool
  public func contains(_ item: ItemIdentifierType) -> Swift.Bool
  public func level(of item: ItemIdentifierType) -> Swift.Int
  public func index(of item: ItemIdentifierType) -> Swift.Int?
  public func parent(of child: ItemIdentifierType) -> ItemIdentifierType?
  public func snapshot(of parent: ItemIdentifierType, includingParent: Swift.Bool = false) -> UIKit.NSDiffableDataSourceSectionSnapshot<ItemIdentifierType>
  public var items: [ItemIdentifierType] {
    get
  }
  public var rootItems: [ItemIdentifierType] {
    get
  }
  public var visibleItems: [ItemIdentifierType] {
    get
  }
  public func visualDescription() -> Swift.String
}
@available(iOS 14.0, tvOS 14.0, *)
extension UIKit.UICollectionViewDiffableDataSource {
  nonisolated public func apply(_ snapshot: UIKit.NSDiffableDataSourceSectionSnapshot<ItemIdentifierType>, to section: SectionIdentifierType, animatingDifferences: Swift.Bool = true, completion: (() -> Swift.Void)? = nil)
  
  #if compiler(>=5.3) && $AsyncAwait
  @available(iOS 15.0, tvOS 15.0, *)
  nonisolated public func apply(_ snapshot: UIKit.NSDiffableDataSourceSectionSnapshot<ItemIdentifierType>, to section: SectionIdentifierType, animatingDifferences: Swift.Bool = true) async
  #endif

  nonisolated public func snapshot(for section: SectionIdentifierType) -> UIKit.NSDiffableDataSourceSectionSnapshot<ItemIdentifierType>
}
@available(iOS 14.0, tvOS 14.0, *)
extension UIKit.NSDiffableDataSourceSectionSnapshot : Swift._ObjectiveCBridgeable {
  @_semantics("convertToObjectiveC") public func _bridgeToObjectiveC() -> UIKit.NSDiffableDataSourceSectionSnapshotReference
  public static func _forceBridgeFromObjectiveC(_ input: UIKit.NSDiffableDataSourceSectionSnapshotReference, result: inout UIKit.NSDiffableDataSourceSectionSnapshot<ItemIdentifierType>?)
  public static func _conditionallyBridgeFromObjectiveC(_ input: UIKit.NSDiffableDataSourceSectionSnapshotReference, result: inout UIKit.NSDiffableDataSourceSectionSnapshot<ItemIdentifierType>?) -> Swift.Bool
  @_effects(readonly) public static func _unconditionallyBridgeFromObjectiveC(_ snapshot: UIKit.NSDiffableDataSourceSectionSnapshotReference?) -> UIKit.NSDiffableDataSourceSectionSnapshot<ItemIdentifierType>
  public typealias _ObjectiveCType = UIKit.NSDiffableDataSourceSectionSnapshotReference
}
@available(iOS 14.0, tvOS 14.0, *)
extension UIKit.UICollectionViewCell {
  @available(iOS 14.0, tvOS 14.0, *)
  @_Concurrency.MainActor(unsafe) public var contentConfiguration: UIKit.UIContentConfiguration? {
    get
    set(config)
  }
}
@available(iOS 14.0, tvOS 14.0, *)
extension UIKit.UICollectionViewListCell {
  @available(iOS 14.0, tvOS 14.0, *)
  @_Concurrency.MainActor(unsafe) public func defaultContentConfiguration() -> UIKit.UIListContentConfiguration
}
@available(iOS 14.0, tvOS 14.0, *)
extension UIKit.UITableViewCell {
  @available(iOS 14.0, tvOS 14.0, *)
  @_Concurrency.MainActor(unsafe) public var contentConfiguration: UIKit.UIContentConfiguration? {
    get
    set(config)
  }
  @available(iOS 14.0, tvOS 14.0, *)
  @_Concurrency.MainActor(unsafe) public func defaultContentConfiguration() -> UIKit.UIListContentConfiguration
}
@available(iOS 14.0, tvOS 14.0, *)
extension UIKit.UITableViewHeaderFooterView {
  @available(iOS 14.0, tvOS 14.0, *)
  @_Concurrency.MainActor(unsafe) public var contentConfiguration: UIKit.UIContentConfiguration? {
    get
    set(config)
  }
  @available(iOS 14.0, tvOS 14.0, *)
  @_Concurrency.MainActor(unsafe) public func defaultContentConfiguration() -> UIKit.UIListContentConfiguration
}
@available(iOS 14.0, tvOS 14.0, *)
extension UIKit.UIListContentView : UIKit.UIContentView {
  @available(iOS 14.0, tvOS 14.0, *)
  @_Concurrency.MainActor(unsafe) public var configuration: UIKit.UIContentConfiguration {
    get
    set(config)
  }
  @available(iOS 14.0, tvOS 14.0, *)
  @_Concurrency.MainActor(unsafe) convenience public init(configuration: UIKit.UIListContentConfiguration)
}
@available(iOS 14.0, tvOS 14.0, *)
public protocol UIContentView : ObjectiveC.NSObjectProtocol {
  var configuration: UIKit.UIContentConfiguration { get set }
}
@available(iOS 14.0, tvOS 14.0, *)
public protocol UIContentConfiguration {
  func makeContentView() -> UIKit.UIView & UIKit.UIContentView
  func updated(for state: UIKit.UIConfigurationState) -> Self
}
@available(iOS 14.0, tvOS 14.0, *)
public struct UIListContentConfiguration : UIKit.UIContentConfiguration, Swift.Hashable {
  public struct ImageProperties : Swift.Hashable {
    public var preferredSymbolConfiguration: UIKit.UIImage.SymbolConfiguration? {
      get
      set(preferredSymbolConfiguration)
    }
    public var tintColor: UIKit.UIColor? {
      get
      set(tintColor)
    }
    public var tintColorTransformer: UIKit.UIConfigurationColorTransformer? {
      get
      set(tintColorTransformer)
    }
    public func resolvedTintColor(for tintColor: UIKit.UIColor) -> UIKit.UIColor
    public var cornerRadius: CoreGraphics.CGFloat {
      get
      set(cornerRadius)
    }
    public var maximumSize: CoreGraphics.CGSize {
      get
      set(maximumSize)
    }
    public var reservedLayoutSize: CoreGraphics.CGSize {
      get
      set(reservedLayoutSize)
    }
    public var accessibilityIgnoresInvertColors: Swift.Bool {
      get
      set(accessibilityIgnoresInvertColors)
    }
    public static let standardDimension: CoreGraphics.CGFloat
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: UIKit.UIListContentConfiguration.ImageProperties, b: UIKit.UIListContentConfiguration.ImageProperties) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
  }
  public struct TextProperties : Swift.Hashable {
    public enum TextAlignment : Swift.Hashable {
      case natural
      case center
      case justified
      public static func == (a: UIKit.UIListContentConfiguration.TextProperties.TextAlignment, b: UIKit.UIListContentConfiguration.TextProperties.TextAlignment) -> Swift.Bool
      public func hash(into hasher: inout Swift.Hasher)
      public var hashValue: Swift.Int {
        get
      }
    }
    public enum TextTransform : Swift.Hashable {
      case none
      case uppercase
      case lowercase
      case capitalized
      public static func == (a: UIKit.UIListContentConfiguration.TextProperties.TextTransform, b: UIKit.UIListContentConfiguration.TextProperties.TextTransform) -> Swift.Bool
      public func hash(into hasher: inout Swift.Hasher)
      public var hashValue: Swift.Int {
        get
      }
    }
    public var font: UIKit.UIFont {
      get
      set(font)
    }
    public var color: UIKit.UIColor {
      get
      set(color)
    }
    public var colorTransformer: UIKit.UIConfigurationColorTransformer? {
      get
      set(colorTransformer)
    }
    public func resolvedColor() -> UIKit.UIColor
    public var alignment: UIKit.UIListContentConfiguration.TextProperties.TextAlignment {
      get
      set(alignment)
    }
    public var lineBreakMode: UIKit.NSLineBreakMode {
      get
      set(lineBreakMode)
    }
    public var numberOfLines: Swift.Int {
      get
      set(numberOfLines)
    }
    public var adjustsFontSizeToFitWidth: Swift.Bool {
      get
      set(adjustsFontSizeToFitWidth)
    }
    public var minimumScaleFactor: CoreGraphics.CGFloat {
      get
      set(minimumScaleFactor)
    }
    public var allowsDefaultTighteningForTruncation: Swift.Bool {
      get
      set(allowsDefaultTighteningForTruncation)
    }
    public var adjustsFontForContentSizeCategory: Swift.Bool {
      get
      set(adjustsFontForContentSizeCategory)
    }
    public var transform: UIKit.UIListContentConfiguration.TextProperties.TextTransform {
      get
      set(transform)
    }
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: UIKit.UIListContentConfiguration.TextProperties, b: UIKit.UIListContentConfiguration.TextProperties) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
  }
  public static func cell() -> UIKit.UIListContentConfiguration
  public static func subtitleCell() -> UIKit.UIListContentConfiguration
  public static func valueCell() -> UIKit.UIListContentConfiguration
  public static func plainHeader() -> UIKit.UIListContentConfiguration
  public static func plainFooter() -> UIKit.UIListContentConfiguration
  public static func groupedHeader() -> UIKit.UIListContentConfiguration
  public static func groupedFooter() -> UIKit.UIListContentConfiguration
  @available(iOS 15.0, *)
  public static func prominentInsetGroupedHeader() -> UIKit.UIListContentConfiguration
  @available(iOS 15.0, *)
  public static func extraProminentInsetGroupedHeader() -> UIKit.UIListContentConfiguration
  public static func sidebarCell() -> UIKit.UIListContentConfiguration
  public static func sidebarSubtitleCell() -> UIKit.UIListContentConfiguration
  public static func accompaniedSidebarCell() -> UIKit.UIListContentConfiguration
  public static func accompaniedSidebarSubtitleCell() -> UIKit.UIListContentConfiguration
  public static func sidebarHeader() -> UIKit.UIListContentConfiguration
  public func makeContentView() -> UIKit.UIView & UIKit.UIContentView
  public func updated(for state: UIKit.UIConfigurationState) -> UIKit.UIListContentConfiguration
  public var image: UIKit.UIImage? {
    get
    set(image)
  }
  public var imageProperties: UIKit.UIListContentConfiguration.ImageProperties {
    get
    set(imageProperties)
  }
  public var text: Swift.String? {
    get
    set(text)
  }
  public var attributedText: Foundation.NSAttributedString? {
    get
    set(attributedText)
  }
  public var textProperties: UIKit.UIListContentConfiguration.TextProperties {
    get
    set(textProperties)
  }
  public var secondaryText: Swift.String? {
    get
    set(secondaryText)
  }
  public var secondaryAttributedText: Foundation.NSAttributedString? {
    get
    set(secondaryAttributedText)
  }
  public var secondaryTextProperties: UIKit.UIListContentConfiguration.TextProperties {
    get
    set(secondaryTextProperties)
  }
  public var axesPreservingSuperviewLayoutMargins: UIKit.UIAxis {
    get
    set(axesPreservingSuperviewLayoutMargins)
  }
  public var directionalLayoutMargins: UIKit.NSDirectionalEdgeInsets {
    get
    set(directionalLayoutMargins)
  }
  public var prefersSideBySideTextAndSecondaryText: Swift.Bool {
    get
    set(prefersSideBySideTextAndSecondaryText)
  }
  public var imageToTextPadding: CoreGraphics.CGFloat {
    get
    set(imageToTextPadding)
  }
  public var textToSecondaryTextHorizontalPadding: CoreGraphics.CGFloat {
    get
    set(textToSecondaryTextHorizontalPadding)
  }
  public var textToSecondaryTextVerticalPadding: CoreGraphics.CGFloat {
    get
    set(textToSecondaryTextVerticalPadding)
  }
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: UIKit.UIListContentConfiguration, b: UIKit.UIListContentConfiguration) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
@available(iOS 14.0, tvOS 14.0, *)
extension UIKit.UIListContentConfiguration.ImageProperties : Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible, Swift.CustomReflectable {
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
  public var customMirror: Swift.Mirror {
    get
  }
}
@available(iOS 14.0, tvOS 14.0, *)
extension UIKit.UIListContentConfiguration.TextProperties : Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible, Swift.CustomReflectable {
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
  public var customMirror: Swift.Mirror {
    get
  }
}
@available(iOS 14.0, tvOS 14.0, *)
extension UIKit.UIListContentConfiguration : Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible, Swift.CustomReflectable {
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
  public var customMirror: Swift.Mirror {
    get
  }
}
@available(iOS 13.4, *)
public enum UIPointerShape {
  case path(_: UIKit.UIBezierPath)
  case roundedRect(_: CoreGraphics.CGRect, radius: CoreGraphics.CGFloat = UIPointerShape.defaultCornerRadius)
  case verticalBeam(length: CoreGraphics.CGFloat)
  case horizontalBeam(length: CoreGraphics.CGFloat)
  public static let defaultCornerRadius: CoreGraphics.CGFloat
}
@available(iOS 13.4, *)
public enum UIPointerEffect {
  public enum TintMode {
    case none, overlay, underlay
    public static func == (a: UIKit.UIPointerEffect.TintMode, b: UIKit.UIPointerEffect.TintMode) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  case automatic(_: UIKit.UITargetedPreview)
  case highlight(_: UIKit.UITargetedPreview)
  case lift(_: UIKit.UITargetedPreview)
  case hover(_: UIKit.UITargetedPreview, preferredTintMode: UIKit.UIPointerEffect.TintMode = .overlay, prefersShadow: Swift.Bool = false, prefersScaledContent: Swift.Bool = true)
  public var preview: UIKit.UITargetedPreview {
    get
  }
}
@available(iOS 15.0, *)
extension UIKit.UIPointerAccessory {
  public struct Position {
    public static let defaultOffset: CoreGraphics.CGFloat
    public var offset: CoreGraphics.CGFloat
    public var angle: CoreGraphics.CGFloat
    public init(offset: CoreGraphics.CGFloat = Position.defaultOffset, angle: CoreGraphics.CGFloat = 0)
    public static var top: UIKit.UIPointerAccessory.Position {
      get
    }
    public static var topRight: UIKit.UIPointerAccessory.Position {
      get
    }
    public static var right: UIKit.UIPointerAccessory.Position {
      get
    }
    public static var bottomRight: UIKit.UIPointerAccessory.Position {
      get
    }
    public static var bottom: UIKit.UIPointerAccessory.Position {
      get
    }
    public static var bottomLeft: UIKit.UIPointerAccessory.Position {
      get
    }
    public static var left: UIKit.UIPointerAccessory.Position {
      get
    }
    public static var topLeft: UIKit.UIPointerAccessory.Position {
      get
    }
  }
  @_Concurrency.MainActor(unsafe) convenience public init(_ shape: UIKit.UIPointerShape, position: UIKit.UIPointerAccessory.Position)
  @_Concurrency.MainActor(unsafe) public class func arrow(_ position: UIKit.UIPointerAccessory.Position) -> Self
  @_Concurrency.MainActor(unsafe) public var shape: UIKit.UIPointerShape {
    get
  }
}
@available(iOS 13.4, *)
extension UIKit.UIPointerStyle {
  @_Concurrency.MainActor(unsafe) convenience public init(effect: UIKit.UIPointerEffect, shape: UIKit.UIPointerShape? = nil)
  @_Concurrency.MainActor(unsafe) convenience public init(shape: UIKit.UIPointerShape, constrainedAxes: UIKit.UIAxis = [])
}
@available(iOS 13.4, *)
extension UIKit.UIPointerRegion {
  @_Concurrency.MainActor(unsafe) convenience public init(rect: CoreGraphics.CGRect, identifier: Swift.AnyHashable? = nil)
  @_Concurrency.MainActor(unsafe) public var identifier: Swift.AnyHashable? {
    get
  }
}
@available(iOS 13.4, *)
extension UIKit.UIButton {
  public typealias PointerStyleProvider = (_ button: UIKit.UIButton, _ proposedEffect: UIKit.UIPointerEffect, _ proposedShape: UIKit.UIPointerShape) -> UIKit.UIPointerStyle?
  @_Concurrency.MainActor(unsafe) public var pointerStyleProvider: UIKit.UIButton.PointerStyleProvider? {
    get
    set
  }
}
@available(iOS 13.4, *)
extension UIKit.UIPointerEffect : Swift._ObjectiveCBridgeable {
  @_semantics("convertToObjectiveC") public func _bridgeToObjectiveC() -> UIKit.__UIPointerEffect
  public static func _forceBridgeFromObjectiveC(_ input: UIKit.__UIPointerEffect, result: inout UIKit.UIPointerEffect?)
  public static func _conditionallyBridgeFromObjectiveC(_ input: UIKit.__UIPointerEffect, result: inout UIKit.UIPointerEffect?) -> Swift.Bool
  @_effects(readonly) public static func _unconditionallyBridgeFromObjectiveC(_ internalEffect: UIKit.__UIPointerEffect?) -> UIKit.UIPointerEffect
  public typealias _ObjectiveCType = UIKit.__UIPointerEffect
}
@available(iOS 13.4, *)
extension UIKit.UIPointerShape : Swift._ObjectiveCBridgeable {
  @_semantics("convertToObjectiveC") public func _bridgeToObjectiveC() -> UIKit.__UIPointerShape
  public static func _forceBridgeFromObjectiveC(_ input: UIKit.__UIPointerShape, result: inout UIKit.UIPointerShape?)
  public static func _conditionallyBridgeFromObjectiveC(_ input: UIKit.__UIPointerShape, result: inout UIKit.UIPointerShape?) -> Swift.Bool
  @_effects(readonly) public static func _unconditionallyBridgeFromObjectiveC(_ _effect: UIKit.__UIPointerShape?) -> UIKit.UIPointerShape
  public typealias _ObjectiveCType = UIKit.__UIPointerShape
}
@available(iOS 15.0, *)
extension UIKit.UIBandSelectionInteraction {
  @_Concurrency.MainActor(unsafe) public var selectionRect: CoreGraphics.CGRect? {
    get
  }
}
@available(iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.AttributeScopes {
  public var uiKit: Foundation.AttributeScopes.UIKitAttributes.Type {
    get
  }
  public struct UIKitAttributes : Foundation.AttributeScope {
    public let font: Foundation.AttributeScopes.UIKitAttributes.FontAttribute
    public let paragraphStyle: Foundation.AttributeScopes.UIKitAttributes.ParagraphStyleAttribute
    public let foregroundColor: Foundation.AttributeScopes.UIKitAttributes.ForegroundColorAttribute
    public let backgroundColor: Foundation.AttributeScopes.UIKitAttributes.BackgroundColorAttribute
    public let ligature: Foundation.AttributeScopes.UIKitAttributes.LigatureAttribute
    public let kern: Foundation.AttributeScopes.UIKitAttributes.KernAttribute
    public let tracking: Foundation.AttributeScopes.UIKitAttributes.TrackingAttribute
    public let strikethroughStyle: Foundation.AttributeScopes.UIKitAttributes.StrikethroughStyleAttribute
    public let underlineStyle: Foundation.AttributeScopes.UIKitAttributes.UnderlineStyleAttribute
    public let strokeColor: Foundation.AttributeScopes.UIKitAttributes.StrokeColorAttribute
    public let strokeWidth: Foundation.AttributeScopes.UIKitAttributes.StrokeWidthAttribute
    public let shadow: Foundation.AttributeScopes.UIKitAttributes.ShadowAttribute
    public let textEffect: Foundation.AttributeScopes.UIKitAttributes.TextEffectAttribute
    public let baselineOffset: Foundation.AttributeScopes.UIKitAttributes.BaselineOffsetAttribute
    public let underlineColor: Foundation.AttributeScopes.UIKitAttributes.UnderlineColorAttribute
    public let strikethroughColor: Foundation.AttributeScopes.UIKitAttributes.StrikethroughColorAttribute
    public let obliqueness: Foundation.AttributeScopes.UIKitAttributes.ObliquenessAttribute
    public let expansion: Foundation.AttributeScopes.UIKitAttributes.ExpansionAttribute
    @available(watchOS, unavailable)
    public let attachment: Foundation.AttributeScopes.UIKitAttributes.AttachmentAttribute
    public let accessibility: Foundation.AttributeScopes.AccessibilityAttributes
    public let foundation: Foundation.AttributeScopes.FoundationAttributes
    public typealias DecodingConfiguration = Foundation.AttributeScopeCodableConfiguration
    public typealias EncodingConfiguration = Foundation.AttributeScopeCodableConfiguration
  }
}
@available(iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.AttributeDynamicLookup {
  @_disfavoredOverload public subscript<T>(dynamicMember keyPath: Swift.KeyPath<Foundation.AttributeScopes.UIKitAttributes, T>) -> T where T : Foundation.AttributedStringKey {
    get
  }
}
@available(iOS 15, tvOS 15, watchOS 8, *)
extension UIKit.NSUnderlineStyle : Swift.Hashable {
}
@available(iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.AttributeScopes.UIKitAttributes {
  @frozen public enum FontAttribute : Foundation.CodableAttributedStringKey {
    public typealias Value = UIKit.UIFont
    public static let name: Swift.String
  }
  @frozen public enum ParagraphStyleAttribute : Foundation.CodableAttributedStringKey {
    public typealias Value = UIKit.NSParagraphStyle
    public static let name: Swift.String
  }
  @frozen public enum ForegroundColorAttribute : Foundation.CodableAttributedStringKey {
    public typealias Value = UIKit.UIColor
    public static let name: Swift.String
  }
  @frozen public enum BackgroundColorAttribute : Foundation.CodableAttributedStringKey {
    public typealias Value = UIKit.UIColor
    public static let name: Swift.String
  }
  @frozen public enum LigatureAttribute : Foundation.CodableAttributedStringKey {
    public typealias Value = Swift.Int
    public static let name: Swift.String
  }
  @frozen public enum KernAttribute : Foundation.CodableAttributedStringKey {
    public typealias Value = CoreGraphics.CGFloat
    public static let name: Swift.String
  }
  @frozen public enum TrackingAttribute : Foundation.CodableAttributedStringKey {
    public typealias Value = CoreGraphics.CGFloat
    public static let name: Swift.String
  }
  @frozen public enum StrikethroughStyleAttribute : Foundation.CodableAttributedStringKey, Foundation.ObjectiveCConvertibleAttributedStringKey {
    public typealias Value = UIKit.NSUnderlineStyle
    public typealias ObjectiveCValue = Foundation.NSNumber
    public static let name: Swift.String
    public static func encode(_ value: UIKit.NSUnderlineStyle, to encoder: Swift.Encoder) throws
    public static func decode(from decoder: Swift.Decoder) throws -> UIKit.NSUnderlineStyle
  }
  @frozen public enum UnderlineStyleAttribute : Foundation.CodableAttributedStringKey, Foundation.ObjectiveCConvertibleAttributedStringKey {
    public typealias Value = UIKit.NSUnderlineStyle
    public typealias ObjectiveCValue = Foundation.NSNumber
    public static let name: Swift.String
    public static func encode(_ value: UIKit.NSUnderlineStyle, to encoder: Swift.Encoder) throws
    public static func decode(from decoder: Swift.Decoder) throws -> UIKit.NSUnderlineStyle
  }
  @frozen public enum StrokeColorAttribute : Foundation.CodableAttributedStringKey {
    public typealias Value = UIKit.UIColor
    public static let name: Swift.String
  }
  @frozen public enum StrokeWidthAttribute : Foundation.CodableAttributedStringKey {
    public typealias Value = CoreGraphics.CGFloat
    public static let name: Swift.String
  }
  @frozen public enum ShadowAttribute : Foundation.CodableAttributedStringKey {
    public typealias Value = UIKit.NSShadow
    public static let name: Swift.String
  }
  @frozen public enum TextEffectAttribute : Foundation.CodableAttributedStringKey {
    public typealias Value = Foundation.NSAttributedString.TextEffectStyle
    public static let name: Swift.String
    public static func encode(_ value: Foundation.NSAttributedString.TextEffectStyle, to encoder: Swift.Encoder) throws
    public static func decode(from decoder: Swift.Decoder) throws -> Foundation.NSAttributedString.TextEffectStyle
  }
  @available(watchOS, unavailable)
  @frozen public enum AttachmentAttribute : Foundation.CodableAttributedStringKey {
    public typealias Value = UIKit.NSTextAttachment
    public static let name: Swift.String
  }
  @frozen public enum BaselineOffsetAttribute : Foundation.CodableAttributedStringKey {
    public typealias Value = CoreGraphics.CGFloat
    public static let name: Swift.String
  }
  @frozen public enum UnderlineColorAttribute : Foundation.CodableAttributedStringKey {
    public typealias Value = UIKit.UIColor
    public static let name: Swift.String
  }
  @frozen public enum StrikethroughColorAttribute : Foundation.CodableAttributedStringKey {
    public typealias Value = UIKit.UIColor
    public static let name: Swift.String
  }
  @frozen public enum ObliquenessAttribute : Foundation.CodableAttributedStringKey {
    public typealias Value = CoreGraphics.CGFloat
    public static let name: Swift.String
  }
  @frozen public enum ExpansionAttribute : Foundation.CodableAttributedStringKey {
    public typealias Value = CoreGraphics.CGFloat
    public static let name: Swift.String
  }
}
@available(iOS 15.0, *)
extension UIKit.UISheetPresentationController {
  @available(iOS 15.0, *)
  @_Concurrency.MainActor(unsafe) public var preferredCornerRadius: CoreGraphics.CGFloat? {
    get
    set
  }
}
extension UIKit.UIBarButtonItem {
  @available(iOS 14.0, *)
  @_Concurrency.MainActor(unsafe) convenience public init(systemItem: UIKit.UIBarButtonItem.SystemItem, primaryAction: UIKit.UIAction? = nil, menu: UIKit.UIMenu? = nil)
  @available(iOS 14.0, *)
  @_Concurrency.MainActor(unsafe) convenience public init(title: Swift.String? = nil, image: UIKit.UIImage? = nil, primaryAction: UIKit.UIAction? = nil, menu: UIKit.UIMenu? = nil)
}
extension UIKit.UIControl {
  @available(iOS 14.0, *)
  @_Concurrency.MainActor(unsafe) public func enumerateEventHandlers(_ iterator: (UIKit.UIAction?, (Any?, ObjectiveC.Selector)?, UIKit.UIControl.Event, inout Swift.Bool) -> Swift.Void)
}
extension UIKit.UIButton {
  @available(iOS 14.0, *)
  @_Concurrency.MainActor(unsafe) convenience public init(type buttonType: UIKit.UIButton.ButtonType = .system, primaryAction: UIKit.UIAction?)
}
@available(iOS 14.0, tvOS 14.0, *)
extension UIKit.UICollectionViewCell {
  @available(iOS 14.0, tvOS 14.0, *)
  @_Concurrency.MainActor(unsafe) public var backgroundConfiguration: UIKit.UIBackgroundConfiguration? {
    get
    set(backgroundConfiguration)
  }
}
@available(iOS 14.0, tvOS 14.0, *)
extension UIKit.UITableViewCell {
  @available(iOS 14.0, tvOS 14.0, *)
  @_Concurrency.MainActor(unsafe) public var backgroundConfiguration: UIKit.UIBackgroundConfiguration? {
    get
    set(backgroundConfiguration)
  }
}
@available(iOS 14.0, tvOS 14.0, *)
extension UIKit.UITableViewHeaderFooterView {
  @available(iOS 14.0, tvOS 14.0, *)
  @_Concurrency.MainActor(unsafe) public var backgroundConfiguration: UIKit.UIBackgroundConfiguration? {
    get
    set(backgroundConfiguration)
  }
}
@available(iOS 14.0, tvOS 14.0, *)
public struct UIConfigurationColorTransformer {
  public let transform: (UIKit.UIColor) -> UIKit.UIColor
  public init(_ transform: @escaping (UIKit.UIColor) -> UIKit.UIColor)
  public func callAsFunction(_ input: UIKit.UIColor) -> UIKit.UIColor
  public static let grayscale: UIKit.UIConfigurationColorTransformer
  public static let preferredTint: UIKit.UIConfigurationColorTransformer
  public static let monochromeTint: UIKit.UIConfigurationColorTransformer
}
@available(iOS 14.0, tvOS 14.0, *)
public struct UIBackgroundConfiguration : Swift.Hashable {
  public static func clear() -> UIKit.UIBackgroundConfiguration
  public static func listPlainCell() -> UIKit.UIBackgroundConfiguration
  public static func listPlainHeaderFooter() -> UIKit.UIBackgroundConfiguration
  public static func listGroupedCell() -> UIKit.UIBackgroundConfiguration
  public static func listGroupedHeaderFooter() -> UIKit.UIBackgroundConfiguration
  public static func listSidebarHeader() -> UIKit.UIBackgroundConfiguration
  public static func listSidebarCell() -> UIKit.UIBackgroundConfiguration
  public static func listAccompaniedSidebarCell() -> UIKit.UIBackgroundConfiguration
  public func updated(for state: UIKit.UIConfigurationState) -> UIKit.UIBackgroundConfiguration
  public var customView: UIKit.UIView? {
    get
    set(view)
  }
  public var cornerRadius: CoreGraphics.CGFloat {
    get
    set(cornerRadius)
  }
  public var backgroundInsets: UIKit.NSDirectionalEdgeInsets {
    get
    set(backgroundInsets)
  }
  public var edgesAddingLayoutMarginsToBackgroundInsets: UIKit.NSDirectionalRectEdge {
    get
    set(backgroundInsets)
  }
  public var backgroundColor: UIKit.UIColor? {
    get
    set(backgroundColor)
  }
  public var backgroundColorTransformer: UIKit.UIConfigurationColorTransformer? {
    get
    set(backgroundColorTransformer)
  }
  public func resolvedBackgroundColor(for tintColor: UIKit.UIColor) -> UIKit.UIColor
  public var visualEffect: UIKit.UIVisualEffect? {
    get
    set(visualEffect)
  }
  @available(iOS 15.0, tvOS 15.0, *)
  public var image: UIKit.UIImage? {
    get
    set(image)
  }
  @available(iOS 15.0, tvOS 15.0, *)
  public var imageContentMode: UIKit.UIView.ContentMode {
    get
    set(imageContentMode)
  }
  public var strokeColor: UIKit.UIColor? {
    get
    set(strokeColor)
  }
  public var strokeColorTransformer: UIKit.UIConfigurationColorTransformer? {
    get
    set(strokeColorTransformer)
  }
  public func resolvedStrokeColor(for tintColor: UIKit.UIColor) -> UIKit.UIColor
  public var strokeWidth: CoreGraphics.CGFloat {
    get
    set(strokeWidth)
  }
  public var strokeOutset: CoreGraphics.CGFloat {
    get
    set(strokeOutset)
  }
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: UIKit.UIBackgroundConfiguration, b: UIKit.UIBackgroundConfiguration) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
@available(iOS 14.0, tvOS 14.0, *)
extension UIKit.UIBackgroundConfiguration : Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible, Swift.CustomReflectable {
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
  public var customMirror: Swift.Mirror {
    get
  }
}
@available(iOS 14.0, *)
@_Concurrency.MainActor(unsafe) open class UIIndirectScribbleInteraction<Delegate> : ObjectiveC.NSObject, UIKit.UIInteraction where Delegate : UIKit.UIIndirectScribbleInteractionDelegate {
  @_Concurrency.MainActor(unsafe) @objc weak public var view: UIKit.UIView? {
    get
  }
  @_Concurrency.MainActor(unsafe) weak public var delegate: Delegate? {
    get
  }
  @_Concurrency.MainActor(unsafe) @objc public func willMove(to view: UIKit.UIView?)
  @_Concurrency.MainActor(unsafe) @objc public func didMove(to view: UIKit.UIView?)
  @_Concurrency.MainActor(unsafe) public init(delegate: Delegate)
  @_Concurrency.MainActor(unsafe) public var isHandlingWriting: Swift.Bool {
    get
  }
  @objc deinit
}
@available(iOS 14.0, *)
public protocol UIIndirectScribbleInteractionDelegate : ObjectiveC.NSObjectProtocol {
  associatedtype ElementIdentifier : Swift.Hashable = Swift.String
  func indirectScribbleInteraction(_ interaction: UIKit.UIInteraction, requestElementsIn rect: CoreGraphics.CGRect, completion: @escaping ([Self.ElementIdentifier]) -> Swift.Void)
  
  #if compiler(>=5.3) && $AsyncAwait
  @available(iOS 15.0, *)
  @_Concurrency.MainActor func indirectScribbleInteraction(_ interaction: UIKit.UIInteraction, requestElementsIn rect: CoreGraphics.CGRect) async -> [Self.ElementIdentifier]
  #endif

  func indirectScribbleInteraction(_ interaction: UIKit.UIInteraction, isElementFocused elementIdentifier: Self.ElementIdentifier) -> Swift.Bool
  func indirectScribbleInteraction(_ interaction: UIKit.UIInteraction, frameForElement elementIdentifier: Self.ElementIdentifier) -> CoreGraphics.CGRect
  func indirectScribbleInteraction(_ interaction: UIKit.UIInteraction, focusElementIfNeeded elementIdentifier: Self.ElementIdentifier, referencePoint focusReferencePoint: CoreGraphics.CGPoint, completion: @escaping ((UIKit.UIResponder & UIKit.UITextInput)?) -> Swift.Void)
  
  #if compiler(>=5.3) && $AsyncAwait
  @available(iOS 15.0, *)
  @_Concurrency.MainActor func indirectScribbleInteraction(_ interaction: UIKit.UIInteraction, focusElementIfNeeded elementIdentifier: Self.ElementIdentifier, referencePoint focusReferencePoint: CoreGraphics.CGPoint) async -> (UIKit.UIResponder & UIKit.UITextInput)?
  #endif

  func indirectScribbleInteraction(_ interaction: UIKit.UIInteraction, shouldDelayFocusForElement elementIdentifier: Self.ElementIdentifier) -> Swift.Bool
  func indirectScribbleInteraction(_ interaction: UIKit.UIInteraction, willBeginWritingInElement elementIdentifier: Self.ElementIdentifier)
  func indirectScribbleInteraction(_ interaction: UIKit.UIInteraction, didFinishWritingInElement elementIdentifier: Self.ElementIdentifier)
}
@available(iOS 14.0, *)
extension UIKit.UIIndirectScribbleInteractionDelegate {
  public func indirectScribbleInteraction(_ interaction: UIKit.UIInteraction, willBeginWritingInElement elementIdentifier: Self.ElementIdentifier)
  public func indirectScribbleInteraction(_ interaction: UIKit.UIInteraction, didFinishWritingInElement elementIdentifier: Self.ElementIdentifier)
  public func indirectScribbleInteraction(_ interaction: UIKit.UIInteraction, shouldDelayFocusForElement elementIdentifier: Self.ElementIdentifier) -> Swift.Bool
}
@available(iOS 15.0, *)
extension UIKit.UIIndirectScribbleInteractionDelegate {
  
  #if compiler(>=5.3) && $AsyncAwait
  @_Concurrency.MainActor public func indirectScribbleInteraction(_ interaction: UIKit.UIInteraction, requestElementsIn rect: CoreGraphics.CGRect) async -> [Self.ElementIdentifier]
  #endif

  
  #if compiler(>=5.3) && $AsyncAwait
  @_Concurrency.MainActor public func indirectScribbleInteraction(_ interaction: UIKit.UIInteraction, focusElementIfNeeded elementIdentifier: Self.ElementIdentifier, referencePoint focusReferencePoint: CoreGraphics.CGPoint) async -> (UIKit.UIResponder & UIKit.UITextInput)?
  #endif

}
@available(iOS 15.0, *)
@available(tvOS, unavailable)
extension UIKit.UIToolTipConfiguration {
  public var sourceRect: CoreGraphics.CGRect? {
    get
  }
}
extension UIKit.UIEdgeInsets : Swift.Equatable {
  @_transparent public static func == (lhs: UIKit.UIEdgeInsets, rhs: UIKit.UIEdgeInsets) -> Swift.Bool {
    return lhs.top == rhs.top &&
           lhs.left == rhs.left &&
           lhs.bottom == rhs.bottom &&
           lhs.right == rhs.right
  }
}
@available(iOS 11.0, tvOS 11.0, watchOS 4.0, *)
extension UIKit.NSDirectionalEdgeInsets : Swift.Equatable {
  @_transparent public static func == (lhs: UIKit.NSDirectionalEdgeInsets, rhs: UIKit.NSDirectionalEdgeInsets) -> Swift.Bool {
    return lhs.top == rhs.top &&
           lhs.leading == rhs.leading &&
           lhs.bottom == rhs.bottom &&
           lhs.trailing == rhs.trailing
  }
}
extension UIKit.UIOffset : Swift.Equatable {
  @_transparent public static func == (lhs: UIKit.UIOffset, rhs: UIKit.UIOffset) -> Swift.Bool {
    return lhs.horizontal == rhs.horizontal &&
           lhs.vertical == rhs.vertical
  }
}
extension UIKit.UIFloatRange : Swift.Equatable {
  @_transparent public static func == (lhs: UIKit.UIFloatRange, rhs: UIKit.UIFloatRange) -> Swift.Bool {
    return lhs.minimum == rhs.minimum &&
           lhs.maximum == rhs.maximum
  }
}
@available(swift, deprecated: 4.2, message: "Use == operator instead.")
public func UIEdgeInsetsEqualToEdgeInsets(_ insets1: UIKit.UIEdgeInsets, _ insets2: UIKit.UIEdgeInsets) -> Swift.Bool
@available(swift, deprecated: 4.2, message: "Use == operator instead.")
public func UIOffsetEqualToOffset(_ offset1: UIKit.UIOffset, _ offset2: UIKit.UIOffset) -> Swift.Bool
@available(swift, deprecated: 4.2, message: "Use == operator instead.")
public func UIFloatRangeIsEqualToRange(_ range: UIKit.UIFloatRange, _ otherRange: UIKit.UIFloatRange) -> Swift.Bool
extension UIKit.UIEdgeInsets : Swift.Codable {
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
@available(iOS 11.0, tvOS 11.0, watchOS 4.0, *)
extension UIKit.NSDirectionalEdgeInsets : Swift.Codable {
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
extension UIKit.UIOffset : Swift.Codable {
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
extension UIKit.UIFloatRange : Swift.Codable {
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
@available(swift 4)
public protocol _UIKitNumericRawRepresentable : Swift.Comparable, Swift.RawRepresentable where Self.RawValue : Swift.Comparable, Self.RawValue : Swift.Numeric {
}
extension UIKit._UIKitNumericRawRepresentable {
  public static func < (lhs: Self, rhs: Self) -> Swift.Bool
  public static func + (lhs: Self, rhs: Self.RawValue) -> Self
  public static func + (lhs: Self.RawValue, rhs: Self) -> Self
  public static func - (lhs: Self, rhs: Self.RawValue) -> Self
  public static func - (lhs: Self, rhs: Self) -> Self.RawValue
  public static func += (lhs: inout Self, rhs: Self.RawValue)
  public static func -= (lhs: inout Self, rhs: Self.RawValue)
}
extension UIKit.UIFont.Weight : UIKit._UIKitNumericRawRepresentable {
}
extension UIKit.UILayoutPriority : UIKit._UIKitNumericRawRepresentable {
}
extension UIKit.UIWindow.Level : UIKit._UIKitNumericRawRepresentable {
}
@available(swift, obsoleted: 4.2, renamed: "getter:UIDeviceOrientation.isLandscape(self:)")
public func UIDeviceOrientationIsLandscape(_ orientation: UIKit.UIDeviceOrientation) -> Swift.Bool
@available(swift, obsoleted: 4.2, renamed: "getter:UIDeviceOrientation.isPortrait(self:)")
public func UIDeviceOrientationIsPortrait(_ orientation: UIKit.UIDeviceOrientation) -> Swift.Bool
@available(swift, obsoleted: 4.2, renamed: "getter:UIDeviceOrientation.isValidInterfaceOrientation(self:)")
public func UIDeviceOrientationIsValidInterfaceOrientation(_ orientation: UIKit.UIDeviceOrientation) -> Swift.Bool
@available(swift, obsoleted: 4.2, renamed: "getter:UIInterfaceOrientation.isPortrait(self:)")
public func UIInterfaceOrientationIsPortrait(_ orientation: UIKit.UIInterfaceOrientation) -> Swift.Bool
@available(swift, obsoleted: 4.2, renamed: "getter:UIInterfaceOrientation.isLandscape(self:)")
public func UIInterfaceOrientationIsLandscape(_ orientation: UIKit.UIInterfaceOrientation) -> Swift.Bool
extension UIKit.UIActionSheet {
  @_Concurrency.MainActor(unsafe) convenience public init(title: Swift.String?, delegate: UIKit.UIActionSheetDelegate?, cancelButtonTitle: Swift.String?, destructiveButtonTitle: Swift.String?, otherButtonTitles firstButtonTitle: Swift.String, _ moreButtonTitles: Swift.String...)
}
extension UIKit.UIAlertView {
  @_Concurrency.MainActor(unsafe) convenience public init(title: Swift.String, message: Swift.String, delegate: UIKit.UIAlertViewDelegate?, cancelButtonTitle: Swift.String?, otherButtonTitles firstButtonTitle: Swift.String, _ moreButtonTitles: Swift.String...)
}
extension UIKit.UIView : Swift.__DefaultCustomPlaygroundQuickLookable {
  @available(*, deprecated, message: "UIView._defaultCustomPlaygroundQuickLook will be removed in a future Swift version")
  @_Concurrency.MainActor(unsafe) public var _defaultCustomPlaygroundQuickLook: Swift.PlaygroundQuickLook {
    get
  }
}
extension UIKit.UIColor : Swift._ExpressibleByColorLiteral {
  @nonobjc required convenience public init(_colorLiteralRed red: Swift.Float, green: Swift.Float, blue: Swift.Float, alpha: Swift.Float)
}
public typealias _ColorLiteralType = UIKit.UIColor
extension UIKit.UIImage : Swift._ExpressibleByImageLiteral {
  required convenience public init(imageLiteralResourceName name: Swift.String)
}
public typealias _ImageLiteralType = UIKit.UIImage
extension UIKit.UIFont.TextStyle {
  @available(iOS 11.0, watchOS 4.0, tvOS 11.0, *)
  public var metrics: UIKit.UIFontMetrics {
    get
  }
}
extension UIKit.UIContentSizeCategory {
  @available(iOS 11.0, tvOS 11.0, *)
  public var isAccessibilityCategory: Swift.Bool {
    get
  }
  @available(iOS 11.0, tvOS 11.0, *)
  public static func < (left: UIKit.UIContentSizeCategory, right: UIKit.UIContentSizeCategory) -> Swift.Bool
  @available(iOS 11.0, tvOS 11.0, *)
  public static func <= (left: UIKit.UIContentSizeCategory, right: UIKit.UIContentSizeCategory) -> Swift.Bool
  @available(iOS 11.0, tvOS 11.0, *)
  public static func > (left: UIKit.UIContentSizeCategory, right: UIKit.UIContentSizeCategory) -> Swift.Bool
  @available(iOS 11.0, tvOS 11.0, *)
  public static func >= (left: UIKit.UIContentSizeCategory, right: UIKit.UIContentSizeCategory) -> Swift.Bool
}
@available(iOS 11.0, tvOS 11.0, *)
extension UIKit.UIFocusEnvironment {
  @available(iOS 11.0, tvOS 11.0, *)
  @_Concurrency.MainActor(unsafe) public func contains(_ environment: UIKit.UIFocusEnvironment) -> Swift.Bool
}
@available(iOS 11.0, tvOS 11.0, *)
extension UIKit.UIFocusItem {
  @available(iOS 11.0, tvOS 11.0, *)
  @_Concurrency.MainActor(unsafe) public var isFocused: Swift.Bool {
    get
  }
}
@available(iOS 11.0, *)
extension UIKit.UIDragDropSession {
  @available(iOS 11.0, *)
  @_Concurrency.MainActor(unsafe) public func canLoadObjects<T>(ofClass: T.Type) -> Swift.Bool where T : Swift._ObjectiveCBridgeable, T._ObjectiveCType : Foundation.NSItemProviderReading
}
@available(iOS 11.0, *)
extension UIKit.UIDropSession {
  @available(iOS 11.0, *)
  @_Concurrency.MainActor(unsafe) public func loadObjects<T>(ofClass: T.Type, completion: @escaping ([T]) -> Swift.Void) -> Foundation.Progress where T : Swift._ObjectiveCBridgeable, T._ObjectiveCType : Foundation.NSItemProviderReading
}
@available(iOS 11.0, *)
extension UIKit.UIPasteConfiguration {
  @available(iOS 11.0, *)
  @_Concurrency.MainActor(unsafe) convenience public init<T>(forAccepting _: T.Type) where T : Swift._ObjectiveCBridgeable, T._ObjectiveCType : Foundation.NSItemProviderReading
  @available(iOS 11.0, *)
  @_Concurrency.MainActor(unsafe) public func addTypeIdentifiers<T>(forAccepting aClass: T.Type) where T : Swift._ObjectiveCBridgeable, T._ObjectiveCType : Foundation.NSItemProviderReading
}
extension UIKit.UIPasteboard {
  @available(iOS 11.0, *)
  public func setObjects<T>(_ objects: [T]) where T : Swift._ObjectiveCBridgeable, T._ObjectiveCType : Foundation.NSItemProviderWriting
  @available(iOS 11.0, *)
  public func setObjects<T>(_ objects: [T], localOnly: Swift.Bool, expirationDate: Foundation.Date?) where T : Swift._ObjectiveCBridgeable, T._ObjectiveCType : Foundation.NSItemProviderWriting
}
@available(swift, obsoleted: 4.2, renamed: "UIPrintError.Code.notAvailable.rawValue")
public let UIPrintingNotAvailableError: Swift.Int
@available(swift, obsoleted: 4.2, renamed: "UIPrintError.Code.noContent.rawValue")
public let UIPrintNoContentError: Swift.Int
@available(swift, obsoleted: 4.2, renamed: "UIPrintError.Code.unknownImageFormat.rawValue")
public let UIPrintUnknownImageFormatError: Swift.Int
@available(swift, obsoleted: 4.2, renamed: "UIPrintError.Code.jobFailed.rawValue")
public let UIPrintJobFailedError: Swift.Int
@available(swift, deprecated: 4.2, message: "Use the overload of UIApplicationMain where the type of the second parameter is UnsafeMutablePointer<UnsafeMutablePointer<Int8>?>, which is the same as the type of CommandLine.unsafeArgv.")
public func UIApplicationMain(_ argc: Swift.Int32, _ argv: Swift.UnsafeMutablePointer<Swift.UnsafeMutablePointer<Swift.Int8>>!, _ principalClassName: Swift.String?, _ delegateClassName: Swift.String?) -> Swift.Int32
extension UIKit.UIApplicationDelegate {
  @_alwaysEmitIntoClient @_Concurrency.MainActor(unsafe) public static func main() {
    // Explicitly use the version of UIApplicationMain that was deprecated in Swift 4.2
    typealias _MainFunction =
      (Int32, UnsafeMutablePointer<UnsafeMutablePointer<Int8>>, String?, String?) -> Int32
    let _main = UIApplicationMain as _MainFunction
    
    // Convert the argument vector to `UnsafeMutablePointer<UnsafeMutablePointer<Int8>>`
    // This is a no-op for Swift versions < 4.2
    let argv = UnsafeMutableRawPointer(CommandLine.unsafeArgv)
      .bindMemory(to: UnsafeMutablePointer<Int8>.self, capacity: Int(CommandLine.argc))
    exit(_main(CommandLine.argc, argv, nil, NSStringFromClass(self)))
  }
}
extension UIKit.UIStoryboard {
  @available(iOS 13.0, tvOS 13.0, *)
  @_Concurrency.MainActor(unsafe) public func instantiateInitialViewController<ViewController>(creator: ((Foundation.NSCoder) -> ViewController?)? = nil) -> ViewController? where ViewController : UIKit.UIViewController
  @available(iOS 13.0, tvOS 13.0, *)
  @_Concurrency.MainActor(unsafe) public func instantiateViewController<ViewController>(identifier: Swift.String, creator: ((Foundation.NSCoder) -> ViewController?)? = nil) -> ViewController where ViewController : UIKit.UIViewController
}
extension UIKit.UIAccessibilityTraits : Swift.OptionSet {
  public typealias ArrayLiteralElement = UIKit.UIAccessibilityTraits
  public typealias Element = UIKit.UIAccessibilityTraits
}
extension UIKit.UITextDirection {
  public static func storage(_ direction: UIKit.UITextStorageDirection) -> UIKit.UITextDirection
  public static func layout(_ direction: UIKit.UITextLayoutDirection) -> UIKit.UITextDirection
}
@available(iOS 13.0, tvOS 13.0, *)
public struct NSDiffableDataSourceSnapshot<SectionIdentifierType, ItemIdentifierType> where SectionIdentifierType : Swift.Hashable, ItemIdentifierType : Swift.Hashable {
  public init()
  public var numberOfItems: Swift.Int {
    get
  }
  public var numberOfSections: Swift.Int {
    get
  }
  public var sectionIdentifiers: [SectionIdentifierType] {
    get
  }
  public var itemIdentifiers: [ItemIdentifierType] {
    get
  }
  @available(iOS 15.0, tvOS 15.0, *)
  public var reloadedSectionIdentifiers: [SectionIdentifierType] {
    get
  }
  @available(iOS 15.0, tvOS 15.0, *)
  public var reloadedItemIdentifiers: [ItemIdentifierType] {
    get
  }
  @available(iOS 15.0, tvOS 15.0, *)
  public var reconfiguredItemIdentifiers: [ItemIdentifierType] {
    get
  }
  public func numberOfItems(inSection identifier: SectionIdentifierType) -> Swift.Int
  public func itemIdentifiers(inSection identifier: SectionIdentifierType) -> [ItemIdentifierType]
  public func sectionIdentifier(containingItem identifier: ItemIdentifierType) -> SectionIdentifierType?
  public func indexOfItem(_ identifier: ItemIdentifierType) -> Swift.Int?
  public func indexOfSection(_ identifier: SectionIdentifierType) -> Swift.Int?
  public mutating func appendItems(_ identifiers: [ItemIdentifierType], toSection sectionIdentifier: SectionIdentifierType? = nil)
  public mutating func insertItems(_ identifiers: [ItemIdentifierType], beforeItem beforeIdentifier: ItemIdentifierType)
  public mutating func insertItems(_ identifiers: [ItemIdentifierType], afterItem afterIdentifier: ItemIdentifierType)
  public mutating func deleteItems(_ identifiers: [ItemIdentifierType])
  public mutating func deleteAllItems()
  public mutating func moveItem(_ identifier: ItemIdentifierType, beforeItem toIdentifier: ItemIdentifierType)
  public mutating func moveItem(_ identifier: ItemIdentifierType, afterItem toIdentifier: ItemIdentifierType)
  public mutating func reloadItems(_ identifiers: [ItemIdentifierType])
  @available(iOS 15.0, tvOS 15.0, *)
  public mutating func reconfigureItems(_ identifiers: [ItemIdentifierType])
  public mutating func appendSections(_ identifiers: [SectionIdentifierType])
  public mutating func insertSections(_ identifiers: [SectionIdentifierType], beforeSection toIdentifier: SectionIdentifierType)
  public mutating func insertSections(_ identifiers: [SectionIdentifierType], afterSection toIdentifier: SectionIdentifierType)
  public mutating func deleteSections(_ identifiers: [SectionIdentifierType])
  public mutating func moveSection(_ identifier: SectionIdentifierType, beforeSection toIdentifier: SectionIdentifierType)
  public mutating func moveSection(_ identifier: SectionIdentifierType, afterSection toIdentifier: SectionIdentifierType)
  public mutating func reloadSections(_ identifiers: [SectionIdentifierType])
}
@available(iOS 13.0, tvOS 13.0, *)
extension UIKit.NSDiffableDataSourceSnapshot : Swift._ObjectiveCBridgeable {
  @_semantics("convertToObjectiveC") public func _bridgeToObjectiveC() -> UIKit.NSDiffableDataSourceSnapshotReference
  public static func _forceBridgeFromObjectiveC(_ input: UIKit.NSDiffableDataSourceSnapshotReference, result: inout UIKit.NSDiffableDataSourceSnapshot<SectionIdentifierType, ItemIdentifierType>?)
  public static func _conditionallyBridgeFromObjectiveC(_ input: UIKit.NSDiffableDataSourceSnapshotReference, result: inout UIKit.NSDiffableDataSourceSnapshot<SectionIdentifierType, ItemIdentifierType>?) -> Swift.Bool
  @_effects(readonly) public static func _unconditionallyBridgeFromObjectiveC(_ snapshot: UIKit.NSDiffableDataSourceSnapshotReference?) -> UIKit.NSDiffableDataSourceSnapshot<SectionIdentifierType, ItemIdentifierType>
  public typealias _ObjectiveCType = UIKit.NSDiffableDataSourceSnapshotReference
}
@available(iOS 13.0, tvOS 13.0, *)
@_Concurrency.MainActor(unsafe) open class UICollectionViewDiffableDataSource<SectionIdentifierType, ItemIdentifierType> : ObjectiveC.NSObject, UIKit.UICollectionViewDataSource where SectionIdentifierType : Swift.Hashable, ItemIdentifierType : Swift.Hashable {
  public typealias CellProvider = (_ collectionView: UIKit.UICollectionView, _ indexPath: Foundation.IndexPath, _ itemIdentifier: ItemIdentifierType) -> UIKit.UICollectionViewCell?
  public typealias SupplementaryViewProvider = (_ collectionView: UIKit.UICollectionView, _ elementKind: Swift.String, _ indexPath: Foundation.IndexPath) -> UIKit.UICollectionReusableView?
  @_Concurrency.MainActor(unsafe) public var supplementaryViewProvider: UIKit.UICollectionViewDiffableDataSource<SectionIdentifierType, ItemIdentifierType>.SupplementaryViewProvider? {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) public init(collectionView: UIKit.UICollectionView, cellProvider: @escaping UIKit.UICollectionViewDiffableDataSource<SectionIdentifierType, ItemIdentifierType>.CellProvider)
  nonisolated open func apply(_ snapshot: UIKit.NSDiffableDataSourceSnapshot<SectionIdentifierType, ItemIdentifierType>, animatingDifferences: Swift.Bool = true, completion: (() -> Swift.Void)? = nil)
  
  #if compiler(>=5.3) && $AsyncAwait
  @available(iOS 15.0, tvOS 15.0, *)
  nonisolated open func apply(_ snapshot: UIKit.NSDiffableDataSourceSnapshot<SectionIdentifierType, ItemIdentifierType>, animatingDifferences: Swift.Bool = true) async
  #endif

  @available(iOS 15.0, tvOS 15.0, *)
  nonisolated open func applySnapshotUsingReloadData(_ snapshot: UIKit.NSDiffableDataSourceSnapshot<SectionIdentifierType, ItemIdentifierType>, completion: (() -> Swift.Void)? = nil)
  
  #if compiler(>=5.3) && $AsyncAwait
  @available(iOS 15.0, tvOS 15.0, *)
  nonisolated open func applySnapshotUsingReloadData(_ snapshot: UIKit.NSDiffableDataSourceSnapshot<SectionIdentifierType, ItemIdentifierType>) async
  #endif

  nonisolated open func snapshot() -> UIKit.NSDiffableDataSourceSnapshot<SectionIdentifierType, ItemIdentifierType>
  @available(iOS 15.0, tvOS 15.0, *)
  @_Concurrency.MainActor(unsafe) open func sectionIdentifier(for index: Swift.Int) -> SectionIdentifierType?
  @available(iOS 15.0, tvOS 15.0, *)
  @_Concurrency.MainActor(unsafe) open func index(for sectionIdentifier: SectionIdentifierType) -> Swift.Int?
  @_Concurrency.MainActor(unsafe) open func itemIdentifier(for indexPath: Foundation.IndexPath) -> ItemIdentifierType?
  @_Concurrency.MainActor(unsafe) open func indexPath(for itemIdentifier: ItemIdentifierType) -> Foundation.IndexPath?
  @_Concurrency.MainActor(unsafe) @objc open func numberOfSections(in collectionView: UIKit.UICollectionView) -> Swift.Int
  @_Concurrency.MainActor(unsafe) @objc open func collectionView(_ collectionView: UIKit.UICollectionView, numberOfItemsInSection section: Swift.Int) -> Swift.Int
  @_Concurrency.MainActor(unsafe) @objc open func collectionView(_ collectionView: UIKit.UICollectionView, cellForItemAt indexPath: Foundation.IndexPath) -> UIKit.UICollectionViewCell
  @_Concurrency.MainActor(unsafe) @objc open func collectionView(_ collectionView: UIKit.UICollectionView, viewForSupplementaryElementOfKind kind: Swift.String, at indexPath: Foundation.IndexPath) -> UIKit.UICollectionReusableView
  @_Concurrency.MainActor(unsafe) @objc open func collectionView(_ collectionView: UIKit.UICollectionView, canMoveItemAt indexPath: Foundation.IndexPath) -> Swift.Bool
  @_Concurrency.MainActor(unsafe) @objc open func collectionView(_ collectionView: UIKit.UICollectionView, moveItemAt sourceIndexPath: Foundation.IndexPath, to destinationIndexPath: Foundation.IndexPath)
  @_Concurrency.MainActor(unsafe) @objc open func indexTitles(for collectionView: UIKit.UICollectionView) -> [Swift.String]?
  @_Concurrency.MainActor(unsafe) @objc open func collectionView(_ collectionView: UIKit.UICollectionView, indexPathForIndexTitle title: Swift.String, at index: Swift.Int) -> Foundation.IndexPath
  @_Concurrency.MainActor(unsafe) public func description() -> Swift.String
  @objc deinit
}
@available(iOS 13.0, tvOS 13.0, *)
@_Concurrency.MainActor(unsafe) open class UITableViewDiffableDataSource<SectionIdentifierType, ItemIdentifierType> : ObjectiveC.NSObject, UIKit.UITableViewDataSource where SectionIdentifierType : Swift.Hashable, ItemIdentifierType : Swift.Hashable {
  public typealias CellProvider = (_ tableView: UIKit.UITableView, _ indexPath: Foundation.IndexPath, _ itemIdentifier: ItemIdentifierType) -> UIKit.UITableViewCell?
  @_Concurrency.MainActor(unsafe) public init(tableView: UIKit.UITableView, cellProvider: @escaping UIKit.UITableViewDiffableDataSource<SectionIdentifierType, ItemIdentifierType>.CellProvider)
  nonisolated open func apply(_ snapshot: UIKit.NSDiffableDataSourceSnapshot<SectionIdentifierType, ItemIdentifierType>, animatingDifferences: Swift.Bool = true, completion: (() -> Swift.Void)? = nil)
  
  #if compiler(>=5.3) && $AsyncAwait
  @available(iOS 15.0, tvOS 15.0, *)
  nonisolated open func apply(_ snapshot: UIKit.NSDiffableDataSourceSnapshot<SectionIdentifierType, ItemIdentifierType>, animatingDifferences: Swift.Bool = true) async
  #endif

  @available(iOS 15.0, tvOS 15.0, *)
  nonisolated open func applySnapshotUsingReloadData(_ snapshot: UIKit.NSDiffableDataSourceSnapshot<SectionIdentifierType, ItemIdentifierType>, completion: (() -> Swift.Void)? = nil)
  
  #if compiler(>=5.3) && $AsyncAwait
  @available(iOS 15.0, tvOS 15.0, *)
  nonisolated open func applySnapshotUsingReloadData(_ snapshot: UIKit.NSDiffableDataSourceSnapshot<SectionIdentifierType, ItemIdentifierType>) async
  #endif

  nonisolated open func snapshot() -> UIKit.NSDiffableDataSourceSnapshot<SectionIdentifierType, ItemIdentifierType>
  @available(iOS 15.0, tvOS 15.0, *)
  @_Concurrency.MainActor(unsafe) open func sectionIdentifier(for index: Swift.Int) -> SectionIdentifierType?
  @available(iOS 15.0, tvOS 15.0, *)
  @_Concurrency.MainActor(unsafe) open func index(for sectionIdentifier: SectionIdentifierType) -> Swift.Int?
  @_Concurrency.MainActor(unsafe) open func itemIdentifier(for indexPath: Foundation.IndexPath) -> ItemIdentifierType?
  @_Concurrency.MainActor(unsafe) open func indexPath(for itemIdentifier: ItemIdentifierType) -> Foundation.IndexPath?
  @_Concurrency.MainActor(unsafe) public var defaultRowAnimation: UIKit.UITableView.RowAnimation {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) @objc open func numberOfSections(in tableView: UIKit.UITableView) -> Swift.Int
  @_Concurrency.MainActor(unsafe) @objc open func tableView(_ tableView: UIKit.UITableView, numberOfRowsInSection section: Swift.Int) -> Swift.Int
  @_Concurrency.MainActor(unsafe) @objc open func tableView(_ tableView: UIKit.UITableView, cellForRowAt indexPath: Foundation.IndexPath) -> UIKit.UITableViewCell
  @_Concurrency.MainActor(unsafe) @objc open func tableView(_ tableView: UIKit.UITableView, titleForHeaderInSection section: Swift.Int) -> Swift.String?
  @_Concurrency.MainActor(unsafe) @objc open func tableView(_ tableView: UIKit.UITableView, titleForFooterInSection section: Swift.Int) -> Swift.String?
  @_Concurrency.MainActor(unsafe) @objc open func tableView(_ tableView: UIKit.UITableView, canEditRowAt indexPath: Foundation.IndexPath) -> Swift.Bool
  @_Concurrency.MainActor(unsafe) @objc open func tableView(_ tableView: UIKit.UITableView, commit editingStyle: UIKit.UITableViewCell.EditingStyle, forRowAt indexPath: Foundation.IndexPath)
  @_Concurrency.MainActor(unsafe) @objc open func tableView(_ tableView: UIKit.UITableView, canMoveRowAt indexPath: Foundation.IndexPath) -> Swift.Bool
  @_Concurrency.MainActor(unsafe) @objc open func tableView(_ tableView: UIKit.UITableView, moveRowAt sourceIndexPath: Foundation.IndexPath, to destinationIndexPath: Foundation.IndexPath)
  @_Concurrency.MainActor(unsafe) @objc open func sectionIndexTitles(for tableView: UIKit.UITableView) -> [Swift.String]?
  @_Concurrency.MainActor(unsafe) @objc open func tableView(_ tableView: UIKit.UITableView, sectionForSectionIndexTitle title: Swift.String, at index: Swift.Int) -> Swift.Int
  @_Concurrency.MainActor(unsafe) public func description() -> Swift.String
  @objc deinit
}
@available(iOS 13.0, *)
extension UIKit.UICommand {
  @_disfavoredOverload @_Concurrency.MainActor(unsafe) convenience public init(title: Swift.String = "", image: UIKit.UIImage? = nil, action: ObjectiveC.Selector, propertyList: Any? = nil, alternates: [UIKit.UICommandAlternate] = [], discoverabilityTitle: Swift.String? = nil, attributes: UIKit.UIMenuElement.Attributes = [], state: UIKit.UIMenuElement.State = .off)
  @available(iOS 15.0, tvOS 15.0, *)
  @_Concurrency.MainActor(unsafe) convenience public init(title: Swift.String = "", subtitle: Swift.String? = nil, image: UIKit.UIImage? = nil, action: ObjectiveC.Selector, propertyList: Any? = nil, alternates: [UIKit.UICommandAlternate] = [], discoverabilityTitle: Swift.String? = nil, attributes: UIKit.UIMenuElement.Attributes = [], state: UIKit.UIMenuElement.State = .off)
}
@available(iOS 13.0, *)
extension UIKit.UIKeyCommand {
  @_Concurrency.MainActor(unsafe) convenience public init(title: Swift.String = "", image: UIKit.UIImage? = nil, action: ObjectiveC.Selector, input: Swift.String, modifierFlags: UIKit.UIKeyModifierFlags = [], propertyList: Any? = nil, alternates: [UIKit.UICommandAlternate] = [], discoverabilityTitle: Swift.String? = nil, attributes: UIKit.UIMenuElement.Attributes = [], state: UIKit.UIMenuElement.State = .off)
}
@available(iOS 13.0, tvOS 14.0, *)
extension UIKit.UIAction {
  @_disfavoredOverload @_Concurrency.MainActor(unsafe) convenience public init(title: Swift.String = "", image: UIKit.UIImage? = nil, identifier: UIKit.UIAction.Identifier? = nil, discoverabilityTitle: Swift.String? = nil, attributes: UIKit.UIMenuElement.Attributes = [], state: UIKit.UIMenuElement.State = .off, handler: @escaping UIKit.UIActionHandler)
  @available(iOS 15.0, tvOS 15.0, *)
  @_Concurrency.MainActor(unsafe) convenience public init(title: Swift.String = "", subtitle: Swift.String? = nil, image: UIKit.UIImage? = nil, identifier: UIKit.UIAction.Identifier? = nil, discoverabilityTitle: Swift.String? = nil, attributes: UIKit.UIMenuElement.Attributes = [], state: UIKit.UIMenuElement.State = .off, handler: @escaping UIKit.UIActionHandler)
}
@available(iOS 13.0, tvOS 14.0, *)
extension UIKit.UIMenu {
  @_disfavoredOverload @_Concurrency.MainActor(unsafe) convenience public init(title: Swift.String = "", image: UIKit.UIImage? = nil, identifier: UIKit.UIMenu.Identifier? = nil, options: UIKit.UIMenu.Options = [], children: [UIKit.UIMenuElement] = [])
  @available(iOS 15.0, tvOS 15.0, *)
  @_Concurrency.MainActor(unsafe) convenience public init(title: Swift.String = "", subtitle: Swift.String? = nil, image: UIKit.UIImage? = nil, identifier: UIKit.UIMenu.Identifier? = nil, options: UIKit.UIMenu.Options = [], children: [UIKit.UIMenuElement] = [])
}
@available(iOS 13.0, tvOS 14.0, *)
extension UIKit.UIMenuBuilder {
  @_Concurrency.MainActor(unsafe) public func command(for action: ObjectiveC.Selector, propertyList: Any? = nil) -> UIKit.UICommand?
}
@available(iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension UIKit.UIImage {
  public var baselineOffsetFromBottom: CoreGraphics.CGFloat? {
    get
  }
}
@available(iOS 15.0, *)
extension UIKit.UIWindowScene.ActivationConfiguration {
  convenience public init(userActivity: Foundation.NSUserActivity, options: UIKit.UIWindowScene.ActivationRequestOptions? = nil, preview: UIKit.UITargetedPreview? = nil)
}
@available(iOS 15.0, *)
extension UIKit.UIWindowScene.ActivationAction {
  @_Concurrency.MainActor(unsafe) convenience public init(title: Swift.String? = nil, subtitle: Swift.String? = nil, image: UIKit.UIImage? = nil, identifier: UIKit.UIAction.Identifier? = nil, discoverabilityTitle: Swift.String? = nil, attributes: UIKit.UIMenuElement.Attributes = [], alternate: UIKit.UIAction? = nil, _ configuration: @escaping UIKit.UIWindowScene.ActivationAction.ConfigurationProvider)
}
@available(iOS 14.5, *)
@available(tvOS, unavailable)
public struct UIListSeparatorConfiguration : Swift.Hashable {
  public enum Visibility : Swift.Hashable {
    case automatic
    case visible
    case hidden
    public static func == (a: UIKit.UIListSeparatorConfiguration.Visibility, b: UIKit.UIListSeparatorConfiguration.Visibility) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public var topSeparatorVisibility: UIKit.UIListSeparatorConfiguration.Visibility {
    get
    set
  }
  public var bottomSeparatorVisibility: UIKit.UIListSeparatorConfiguration.Visibility {
    get
    set
  }
  public static let automaticInsets: UIKit.NSDirectionalEdgeInsets
  public var topSeparatorInsets: UIKit.NSDirectionalEdgeInsets {
    get
    set
  }
  public var bottomSeparatorInsets: UIKit.NSDirectionalEdgeInsets {
    get
    set
  }
  public var color: UIKit.UIColor {
    get
    set
  }
  public var multipleSelectionColor: UIKit.UIColor {
    get
    set
  }
  @available(iOS 15.0, *)
  @available(tvOS, unavailable)
  public var visualEffect: UIKit.UIVisualEffect? {
    get
    set(visualEffect)
  }
  public init(listAppearance: UIKit.UICollectionLayoutListConfiguration.Appearance)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: UIKit.UIListSeparatorConfiguration, b: UIKit.UIListSeparatorConfiguration) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
@available(iOS 14.5, *)
@available(tvOS, unavailable)
extension UIKit.UIListSeparatorConfiguration : Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible, Swift.CustomReflectable {
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
  public var customMirror: Swift.Mirror {
    get
  }
}
@available(iOS 14.5, *)
@available(tvOS, unavailable)
extension UIKit.UIListSeparatorConfiguration : Swift._ObjectiveCBridgeable {
  @_semantics("convertToObjectiveC") public func _bridgeToObjectiveC() -> UIKit.__UIListSeparatorConfiguration
  public static func _forceBridgeFromObjectiveC(_ source: UIKit.__UIListSeparatorConfiguration, result: inout UIKit.UIListSeparatorConfiguration?)
  public static func _conditionallyBridgeFromObjectiveC(_ input: UIKit.__UIListSeparatorConfiguration, result: inout UIKit.UIListSeparatorConfiguration?) -> Swift.Bool
  @_effects(readonly) public static func _unconditionallyBridgeFromObjectiveC(_ _configuration: UIKit.__UIListSeparatorConfiguration?) -> UIKit.UIListSeparatorConfiguration
  public typealias _ObjectiveCType = UIKit.__UIListSeparatorConfiguration
}
@available(iOS 14.0, tvOS 14.0, *)
extension UIKit.UICollectionView {
  public struct CellRegistration<Cell, Item> where Cell : UIKit.UICollectionViewCell {
    public typealias Handler = (_ cell: Cell, _ indexPath: Foundation.IndexPath, _ itemIdentifier: Item) -> Swift.Void
    public init(handler: @escaping UIKit.UICollectionView.CellRegistration<Cell, Item>.Handler)
    public init(cellNib: UIKit.UINib, handler: @escaping UIKit.UICollectionView.CellRegistration<Cell, Item>.Handler)
  }
  public struct SupplementaryRegistration<Supplementary> where Supplementary : UIKit.UICollectionReusableView {
    public typealias Handler = (_ supplementaryView: Supplementary, _ elementKind: Swift.String, _ indexPath: Foundation.IndexPath) -> Swift.Void
    public init(elementKind: Swift.String, handler: @escaping UIKit.UICollectionView.SupplementaryRegistration<Supplementary>.Handler)
    public init(supplementaryNib: UIKit.UINib, elementKind: Swift.String, handler: @escaping UIKit.UICollectionView.SupplementaryRegistration<Supplementary>.Handler)
  }
  @_Concurrency.MainActor(unsafe) public func dequeueConfiguredReusableCell<Cell, Item>(using registration: UIKit.UICollectionView.CellRegistration<Cell, Item>, for indexPath: Foundation.IndexPath, item: Item?) -> Cell where Cell : UIKit.UICollectionViewCell
  @_Concurrency.MainActor(unsafe) public func dequeueConfiguredReusableSupplementary<Supplementary>(using registration: UIKit.UICollectionView.SupplementaryRegistration<Supplementary>, for indexPath: Foundation.IndexPath) -> Supplementary where Supplementary : UIKit.UICollectionReusableView
}
@available(iOS 15.0, tvOS 15.0, *)
public struct UIConfigurationTextAttributesTransformer {
  public let transform: (Foundation.AttributeContainer) -> Foundation.AttributeContainer
  public init(_ transform: @escaping (Foundation.AttributeContainer) -> Foundation.AttributeContainer)
  public func callAsFunction(_ input: Foundation.AttributeContainer) -> Foundation.AttributeContainer
}
@available(iOS 15.0, tvOS 15.0, *)
extension UIKit.UIButton {
  public struct Configuration : Swift.Hashable {
    public enum Size {
      case mini
      case small
      case medium
      case large
      public static func == (a: UIKit.UIButton.Configuration.Size, b: UIKit.UIButton.Configuration.Size) -> Swift.Bool
      public func hash(into hasher: inout Swift.Hasher)
      public var hashValue: Swift.Int {
        get
      }
    }
    public enum TitleAlignment {
      case automatic
      case leading
      case center
      case trailing
      public static func == (a: UIKit.UIButton.Configuration.TitleAlignment, b: UIKit.UIButton.Configuration.TitleAlignment) -> Swift.Bool
      public func hash(into hasher: inout Swift.Hasher)
      public var hashValue: Swift.Int {
        get
      }
    }
    public enum CornerStyle {
      case fixed
      case dynamic
      case small
      case medium
      case large
      case capsule
      public static func == (a: UIKit.UIButton.Configuration.CornerStyle, b: UIKit.UIButton.Configuration.CornerStyle) -> Swift.Bool
      public func hash(into hasher: inout Swift.Hasher)
      public var hashValue: Swift.Int {
        get
      }
    }
    public enum MacIdiomStyle {
      case automatic
      case bordered
      case borderless
      case borderlessTinted
      public static func == (a: UIKit.UIButton.Configuration.MacIdiomStyle, b: UIKit.UIButton.Configuration.MacIdiomStyle) -> Swift.Bool
      public func hash(into hasher: inout Swift.Hasher)
      public var hashValue: Swift.Int {
        get
      }
    }
    public static func plain() -> UIKit.UIButton.Configuration
    public static func tinted() -> UIKit.UIButton.Configuration
    public static func gray() -> UIKit.UIButton.Configuration
    public static func filled() -> UIKit.UIButton.Configuration
    public static func borderless() -> UIKit.UIButton.Configuration
    public static func bordered() -> UIKit.UIButton.Configuration
    public static func borderedTinted() -> UIKit.UIButton.Configuration
    public static func borderedProminent() -> UIKit.UIButton.Configuration
    public func updated(for button: UIKit.UIButton) -> UIKit.UIButton.Configuration
    public var background: UIKit.UIBackgroundConfiguration {
      get
      set
    }
    public var cornerStyle: UIKit.UIButton.Configuration.CornerStyle {
      get
      set
    }
    public var buttonSize: UIKit.UIButton.Configuration.Size {
      get
      set
    }
    public var macIdiomStyle: UIKit.UIButton.Configuration.MacIdiomStyle {
      get
      set
    }
    public var baseForegroundColor: UIKit.UIColor? {
      get
      set
    }
    public var baseBackgroundColor: UIKit.UIColor? {
      get
      set
    }
    public var image: UIKit.UIImage? {
      get
      set
    }
    public var imageColorTransformer: UIKit.UIConfigurationColorTransformer? {
      get
      set
    }
    public var preferredSymbolConfigurationForImage: UIKit.UIImage.SymbolConfiguration? {
      get
      set
    }
    public var showsActivityIndicator: Swift.Bool {
      get
      set
    }
    public var activityIndicatorColorTransformer: UIKit.UIConfigurationColorTransformer? {
      get
      set
    }
    public var title: Swift.String? {
      get
      set
    }
    public var attributedTitle: Foundation.AttributedString? {
      get
      set
    }
    public var titleTextAttributesTransformer: UIKit.UIConfigurationTextAttributesTransformer? {
      get
      set
    }
    public var subtitle: Swift.String? {
      get
      set
    }
    public var attributedSubtitle: Foundation.AttributedString? {
      get
      set
    }
    public var subtitleTextAttributesTransformer: UIKit.UIConfigurationTextAttributesTransformer? {
      get
      set
    }
    public var contentInsets: UIKit.NSDirectionalEdgeInsets {
      get
      set
    }
    public mutating func setDefaultContentInsets()
    public var imagePlacement: UIKit.NSDirectionalRectEdge {
      get
      set
    }
    public var imagePadding: CoreGraphics.CGFloat {
      get
      set
    }
    public var titlePadding: CoreGraphics.CGFloat {
      get
      set
    }
    public var titleAlignment: UIKit.UIButton.Configuration.TitleAlignment {
      get
      set
    }
    public var automaticallyUpdateForSelection: Swift.Bool {
      get
      set
    }
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: UIKit.UIButton.Configuration, b: UIKit.UIButton.Configuration) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
  }
  @_Concurrency.MainActor(unsafe) convenience public init(configuration: UIKit.UIButton.Configuration, primaryAction: UIKit.UIAction? = nil)
  @_Concurrency.MainActor(unsafe) public var configuration: UIKit.UIButton.Configuration? {
    get
    set
  }
}
@available(iOS 15.0, tvOS 15.0, *)
extension UIKit.UIButton.Configuration : Swift._ObjectiveCBridgeable {
  @_semantics("convertToObjectiveC") public func _bridgeToObjectiveC() -> UIKit.__UIButtonConfiguration
  public static func _forceBridgeFromObjectiveC(_ input: UIKit.__UIButtonConfiguration, result: inout UIKit.UIButton.Configuration?)
  public static func _conditionallyBridgeFromObjectiveC(_ input: UIKit.__UIButtonConfiguration, result: inout UIKit.UIButton.Configuration?) -> Swift.Bool
  @_effects(readonly) public static func _unconditionallyBridgeFromObjectiveC(_ _config: UIKit.__UIButtonConfiguration?) -> UIKit.UIButton.Configuration
  public typealias _ObjectiveCType = UIKit.__UIButtonConfiguration
}
extension UIKit.UIViewController {
  @available(iOS 15.0, tvOS 15.0, *)
  @_Concurrency.MainActor(unsafe) public func setContentScrollView(_ scrollView: UIKit.UIScrollView?)
}
@available(iOS 14.0, tvOS 14.0, *)
extension UIKit.UICollectionViewListCell {
  @available(iOS 14.0, tvOS 14.0, *)
  @_Concurrency.MainActor(unsafe) public var accessories: [UIKit.UICellAccessory] {
    get
    set
  }
}
@available(iOS 14.0, tvOS 14.0, *)
public struct UICellAccessory {
  public typealias ActionHandler = () -> Swift.Void
  public enum DisplayedState {
    case always
    case whenEditing
    case whenNotEditing
    public static func == (a: UIKit.UICellAccessory.DisplayedState, b: UIKit.UICellAccessory.DisplayedState) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public enum LayoutDimension {
    case actual
    case standard
    case custom(CoreGraphics.CGFloat)
  }
  public struct DisclosureIndicatorOptions {
    public var isHidden: Swift.Bool
    public var reservedLayoutWidth: UIKit.UICellAccessory.LayoutDimension
    public var tintColor: UIKit.UIColor?
    public init(isHidden: Swift.Bool? = nil, reservedLayoutWidth: UIKit.UICellAccessory.LayoutDimension? = nil, tintColor: UIKit.UIColor? = nil)
  }
  public static func disclosureIndicator(displayed: UIKit.UICellAccessory.DisplayedState = .always, options: UIKit.UICellAccessory.DisclosureIndicatorOptions = DisclosureIndicatorOptions()) -> UIKit.UICellAccessory
  public struct CheckmarkOptions {
    public var isHidden: Swift.Bool
    public var reservedLayoutWidth: UIKit.UICellAccessory.LayoutDimension
    public var tintColor: UIKit.UIColor?
    public init(isHidden: Swift.Bool? = nil, reservedLayoutWidth: UIKit.UICellAccessory.LayoutDimension? = nil, tintColor: UIKit.UIColor? = nil)
  }
  public static func checkmark(displayed: UIKit.UICellAccessory.DisplayedState = .always, options: UIKit.UICellAccessory.CheckmarkOptions = CheckmarkOptions()) -> UIKit.UICellAccessory
  public struct DeleteOptions {
    public var isHidden: Swift.Bool
    public var reservedLayoutWidth: UIKit.UICellAccessory.LayoutDimension
    public var tintColor: UIKit.UIColor?
    public var backgroundColor: UIKit.UIColor?
    public init(isHidden: Swift.Bool? = nil, reservedLayoutWidth: UIKit.UICellAccessory.LayoutDimension? = nil, tintColor: UIKit.UIColor? = nil, backgroundColor: UIKit.UIColor? = nil)
  }
  public static func delete(displayed: UIKit.UICellAccessory.DisplayedState = .whenEditing, options: UIKit.UICellAccessory.DeleteOptions = DeleteOptions(), actionHandler: UIKit.UICellAccessory.ActionHandler? = nil) -> UIKit.UICellAccessory
  public struct InsertOptions {
    public var isHidden: Swift.Bool
    public var reservedLayoutWidth: UIKit.UICellAccessory.LayoutDimension
    public var tintColor: UIKit.UIColor?
    public var backgroundColor: UIKit.UIColor?
    public init(isHidden: Swift.Bool? = nil, reservedLayoutWidth: UIKit.UICellAccessory.LayoutDimension? = nil, tintColor: UIKit.UIColor? = nil, backgroundColor: UIKit.UIColor? = nil)
  }
  public static func insert(displayed: UIKit.UICellAccessory.DisplayedState = .whenEditing, options: UIKit.UICellAccessory.InsertOptions = InsertOptions(), actionHandler: UIKit.UICellAccessory.ActionHandler? = nil) -> UIKit.UICellAccessory
  public struct ReorderOptions {
    public var isHidden: Swift.Bool
    public var reservedLayoutWidth: UIKit.UICellAccessory.LayoutDimension
    public var tintColor: UIKit.UIColor?
    public var showsVerticalSeparator: Swift.Bool
    public init(isHidden: Swift.Bool? = nil, reservedLayoutWidth: UIKit.UICellAccessory.LayoutDimension? = nil, tintColor: UIKit.UIColor? = nil, showsVerticalSeparator: Swift.Bool? = nil)
  }
  public static func reorder(displayed: UIKit.UICellAccessory.DisplayedState = .whenEditing, options: UIKit.UICellAccessory.ReorderOptions = ReorderOptions()) -> UIKit.UICellAccessory
  public struct MultiselectOptions {
    public var isHidden: Swift.Bool
    public var reservedLayoutWidth: UIKit.UICellAccessory.LayoutDimension
    public var tintColor: UIKit.UIColor?
    public var backgroundColor: UIKit.UIColor?
    public init(isHidden: Swift.Bool? = nil, reservedLayoutWidth: UIKit.UICellAccessory.LayoutDimension? = nil, tintColor: UIKit.UIColor? = nil, backgroundColor: UIKit.UIColor? = nil)
  }
  public static func multiselect(displayed: UIKit.UICellAccessory.DisplayedState = .whenEditing, options: UIKit.UICellAccessory.MultiselectOptions = MultiselectOptions()) -> UIKit.UICellAccessory
  public struct OutlineDisclosureOptions {
    public enum Style {
      case automatic
      case header
      case cell
      public static func == (a: UIKit.UICellAccessory.OutlineDisclosureOptions.Style, b: UIKit.UICellAccessory.OutlineDisclosureOptions.Style) -> Swift.Bool
      public func hash(into hasher: inout Swift.Hasher)
      public var hashValue: Swift.Int {
        get
      }
    }
    public var style: UIKit.UICellAccessory.OutlineDisclosureOptions.Style
    public var isHidden: Swift.Bool
    public var reservedLayoutWidth: UIKit.UICellAccessory.LayoutDimension
    public var tintColor: UIKit.UIColor?
    public init(style: UIKit.UICellAccessory.OutlineDisclosureOptions.Style? = nil, isHidden: Swift.Bool? = nil, reservedLayoutWidth: UIKit.UICellAccessory.LayoutDimension? = nil, tintColor: UIKit.UIColor? = nil)
  }
  public static func outlineDisclosure(displayed: UIKit.UICellAccessory.DisplayedState = .always, options: UIKit.UICellAccessory.OutlineDisclosureOptions = OutlineDisclosureOptions(), actionHandler: UIKit.UICellAccessory.ActionHandler? = nil) -> UIKit.UICellAccessory
  public struct LabelOptions {
    public var isHidden: Swift.Bool
    public var reservedLayoutWidth: UIKit.UICellAccessory.LayoutDimension
    public var tintColor: UIKit.UIColor?
    public var font: UIKit.UIFont
    public var adjustsFontForContentSizeCategory: Swift.Bool
    public init(isHidden: Swift.Bool? = nil, reservedLayoutWidth: UIKit.UICellAccessory.LayoutDimension? = nil, tintColor: UIKit.UIColor? = nil, font: UIKit.UIFont? = nil, adjustsFontForContentSizeCategory: Swift.Bool? = nil)
  }
  public static func label(text: Swift.String, displayed: UIKit.UICellAccessory.DisplayedState = .always, options: UIKit.UICellAccessory.LabelOptions = LabelOptions()) -> UIKit.UICellAccessory
  public enum Placement {
    public typealias Position = (_ accessories: [UIKit.UICellAccessory]) -> Swift.Int
    public static func position(before accessory: UIKit.UICellAccessory) -> UIKit.UICellAccessory.Placement.Position
    public static func position(after accessory: UIKit.UICellAccessory) -> UIKit.UICellAccessory.Placement.Position
    case leading(displayed: UIKit.UICellAccessory.DisplayedState = .always, at: UIKit.UICellAccessory.Placement.Position = { $0.count })
    case trailing(displayed: UIKit.UICellAccessory.DisplayedState = .always, at: UIKit.UICellAccessory.Placement.Position = { _ in 0 })
  }
  public struct CustomViewConfiguration {
    public let customView: UIKit.UIView
    public let placement: UIKit.UICellAccessory.Placement
    public var isHidden: Swift.Bool
    public var reservedLayoutWidth: UIKit.UICellAccessory.LayoutDimension
    public var tintColor: UIKit.UIColor?
    public var maintainsFixedSize: Swift.Bool
    public init(customView: UIKit.UIView, placement: UIKit.UICellAccessory.Placement, isHidden: Swift.Bool? = nil, reservedLayoutWidth: UIKit.UICellAccessory.LayoutDimension? = nil, tintColor: UIKit.UIColor? = nil, maintainsFixedSize: Swift.Bool? = nil)
  }
  public static func customView(configuration: UIKit.UICellAccessory.CustomViewConfiguration) -> UIKit.UICellAccessory
  public enum AccessoryType : Swift.Hashable {
    case disclosureIndicator
    case outlineDisclosure
    case checkmark
    case delete
    case insert
    case reorder
    case multiselect
    case label
    case customView(UIKit.UIView)
    public static func == (lhs: UIKit.UICellAccessory.AccessoryType, rhs: UIKit.UICellAccessory.AccessoryType) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public let accessoryType: UIKit.UICellAccessory.AccessoryType
}
@available(iOS 15.0, tvOS 15.0, *)
extension UIKit.UIFocusSystem {
  @_Concurrency.MainActor(unsafe) public class func focusSystem(for environment: UIKit.UIFocusEnvironment) -> UIKit.UIFocusSystem?
}
@available(iOS 14.0, tvOS 14.0, *)
public struct UICollectionLayoutListConfiguration {
  public enum Appearance {
    case plain
    case grouped
    @available(tvOS, unavailable)
    case insetGrouped
    @available(tvOS, unavailable)
    case sidebar
    @available(tvOS, unavailable)
    case sidebarPlain
    public static func == (a: UIKit.UICollectionLayoutListConfiguration.Appearance, b: UIKit.UICollectionLayoutListConfiguration.Appearance) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public enum HeaderMode {
    case none, supplementary, firstItemInSection
    public static func == (a: UIKit.UICollectionLayoutListConfiguration.HeaderMode, b: UIKit.UICollectionLayoutListConfiguration.HeaderMode) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public enum FooterMode {
    case none, supplementary
    public static func == (a: UIKit.UICollectionLayoutListConfiguration.FooterMode, b: UIKit.UICollectionLayoutListConfiguration.FooterMode) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  @available(tvOS, unavailable)
  public typealias SwipeActionsConfigurationProvider = (_ indexPath: Foundation.IndexPath) -> UIKit.UISwipeActionsConfiguration?
  @available(iOS 14.5, *)
  @available(tvOS, unavailable)
  public typealias ItemSeparatorHandler = (_ itemIndexPath: Foundation.IndexPath, _ sectionSeparatorConfiguration: UIKit.UIListSeparatorConfiguration) -> UIKit.UIListSeparatorConfiguration
  public init(appearance: UIKit.UICollectionLayoutListConfiguration.Appearance)
  public var appearance: UIKit.UICollectionLayoutListConfiguration.Appearance {
    get
  }
  @available(tvOS, unavailable)
  public var showsSeparators: Swift.Bool {
    get
    set(showsSeparators)
  }
  @available(iOS 14.5, *)
  @available(tvOS, unavailable)
  public var separatorConfiguration: UIKit.UIListSeparatorConfiguration {
    get
    set(separatorConfiguration)
  }
  @available(iOS 14.5, *)
  @available(tvOS, unavailable)
  public var itemSeparatorHandler: UIKit.UICollectionLayoutListConfiguration.ItemSeparatorHandler? {
    get
    set
  }
  public var backgroundColor: UIKit.UIColor? {
    get
    set(color)
  }
  @available(tvOS, unavailable)
  public var leadingSwipeActionsConfigurationProvider: UIKit.UICollectionLayoutListConfiguration.SwipeActionsConfigurationProvider? {
    get
    set(provider)
  }
  @available(tvOS, unavailable)
  public var trailingSwipeActionsConfigurationProvider: UIKit.UICollectionLayoutListConfiguration.SwipeActionsConfigurationProvider? {
    get
    set(provider)
  }
  public var headerMode: UIKit.UICollectionLayoutListConfiguration.HeaderMode {
    get
    set(mode)
  }
  public var footerMode: UIKit.UICollectionLayoutListConfiguration.FooterMode {
    get
    set(mode)
  }
  @available(iOS 15.0, tvOS 15.0, *)
  public var headerTopPadding: CoreGraphics.CGFloat? {
    get
    set
  }
}
@available(iOS 14.0, tvOS 14.0, *)
extension UIKit.UICollectionViewCompositionalLayout {
  @_Concurrency.MainActor(unsafe) public static func list(using configuration: UIKit.UICollectionLayoutListConfiguration) -> UIKit.UICollectionViewCompositionalLayout
}
@available(iOS 14.0, tvOS 14.0, *)
extension UIKit.NSCollectionLayoutSection {
  @_Concurrency.MainActor(unsafe) public static func list(using configuration: UIKit.UICollectionLayoutListConfiguration, layoutEnvironment: UIKit.NSCollectionLayoutEnvironment) -> UIKit.NSCollectionLayoutSection
}
extension Foundation.IndexPath {
  public init(row: Swift.Int, section: Swift.Int)
  public init(item: Swift.Int, section: Swift.Int)
  public var section: Swift.Int {
    get
    set
  }
  public var row: Swift.Int {
    get
    set
  }
  public var item: Swift.Int {
    get
    set
  }
}
extension Foundation.URLResourceValues {
  @available(iOS 8.0, *)
  public var thumbnailDictionary: [Foundation.URLThumbnailDictionaryItem : UIKit.UIImage]? {
    get
  }
}
extension UIKit.UIEdgeInsets : Swift._ObjectiveCBridgeable {
  public func _bridgeToObjectiveC() -> Foundation.NSValue
  public static func _forceBridgeFromObjectiveC(_ source: Foundation.NSValue, result: inout UIKit.UIEdgeInsets?)
  public static func _conditionallyBridgeFromObjectiveC(_ source: Foundation.NSValue, result: inout UIKit.UIEdgeInsets?) -> Swift.Bool
  public static func _unconditionallyBridgeFromObjectiveC(_ source: Foundation.NSValue?) -> UIKit.UIEdgeInsets
  public typealias _ObjectiveCType = Foundation.NSValue
}
@available(iOS 11.0, tvOS 11.0, watchOS 4.0, *)
extension UIKit.NSDirectionalEdgeInsets : Swift._ObjectiveCBridgeable {
  public func _bridgeToObjectiveC() -> Foundation.NSValue
  public static func _forceBridgeFromObjectiveC(_ source: Foundation.NSValue, result: inout UIKit.NSDirectionalEdgeInsets?)
  public static func _conditionallyBridgeFromObjectiveC(_ source: Foundation.NSValue, result: inout UIKit.NSDirectionalEdgeInsets?) -> Swift.Bool
  public static func _unconditionallyBridgeFromObjectiveC(_ source: Foundation.NSValue?) -> UIKit.NSDirectionalEdgeInsets
  public typealias _ObjectiveCType = Foundation.NSValue
}
extension UIKit.UIOffset : Swift._ObjectiveCBridgeable {
  public func _bridgeToObjectiveC() -> Foundation.NSValue
  public static func _forceBridgeFromObjectiveC(_ source: Foundation.NSValue, result: inout UIKit.UIOffset?)
  public static func _conditionallyBridgeFromObjectiveC(_ source: Foundation.NSValue, result: inout UIKit.UIOffset?) -> Swift.Bool
  public static func _unconditionallyBridgeFromObjectiveC(_ source: Foundation.NSValue?) -> UIKit.UIOffset
  public typealias _ObjectiveCType = Foundation.NSValue
}
@available(iOS 14.0, tvOS 14.0, *)
extension UIKit.UICollectionViewCell {
  @available(iOS 14.0, tvOS 14.0, *)
  @objc(_bridgedConfigurationState) @_Concurrency.MainActor(unsafe) dynamic open var configurationState: UIKit.UICellConfigurationState {
    @objc get
  }
  @available(iOS 14.0, tvOS 14.0, *)
  @objc(_bridgedUpdateConfigurationUsingState:) @_Concurrency.MainActor(unsafe) dynamic open func updateConfiguration(using state: UIKit.UICellConfigurationState)
  @available(iOS 15.0, tvOS 15.0, *)
  public typealias ConfigurationUpdateHandler = (_ cell: UIKit.UICollectionViewCell, _ state: UIKit.UICellConfigurationState) -> Swift.Void
  @available(iOS 15.0, tvOS 15.0, *)
  @_Concurrency.MainActor(unsafe) public var configurationUpdateHandler: UIKit.UICollectionViewCell.ConfigurationUpdateHandler? {
    get
    set
  }
}
@available(iOS 14.0, tvOS 14.0, *)
extension UIKit.UITableViewCell {
  @available(iOS 14.0, tvOS 14.0, *)
  @objc(_bridgedConfigurationState) @_Concurrency.MainActor(unsafe) dynamic open var configurationState: UIKit.UICellConfigurationState {
    @objc get
  }
  @available(iOS 14.0, tvOS 14.0, *)
  @objc(_bridgedUpdateConfigurationUsingState:) @_Concurrency.MainActor(unsafe) dynamic open func updateConfiguration(using state: UIKit.UICellConfigurationState)
  @available(iOS 15.0, tvOS 15.0, *)
  public typealias ConfigurationUpdateHandler = (_ cell: UIKit.UITableViewCell, _ state: UIKit.UICellConfigurationState) -> Swift.Void
  @available(iOS 15.0, tvOS 15.0, *)
  @_Concurrency.MainActor(unsafe) public var configurationUpdateHandler: UIKit.UITableViewCell.ConfigurationUpdateHandler? {
    get
    set
  }
}
@available(iOS 14.0, tvOS 14.0, *)
extension UIKit.UITableViewHeaderFooterView {
  @available(iOS 14.0, tvOS 14.0, *)
  @objc(_bridgedConfigurationState) @_Concurrency.MainActor(unsafe) dynamic open var configurationState: UIKit.UIViewConfigurationState {
    @objc get
  }
  @available(iOS 14.0, tvOS 14.0, *)
  @objc(_bridgedUpdateConfigurationUsingState:) @_Concurrency.MainActor(unsafe) dynamic open func updateConfiguration(using state: UIKit.UIViewConfigurationState)
  @available(iOS 15.0, tvOS 15.0, *)
  public typealias ConfigurationUpdateHandler = (_ headerFooterView: UIKit.UITableViewHeaderFooterView, _ state: UIKit.UIViewConfigurationState) -> Swift.Void
  @available(iOS 15.0, tvOS 15.0, *)
  @_Concurrency.MainActor(unsafe) public var configurationUpdateHandler: UIKit.UITableViewHeaderFooterView.ConfigurationUpdateHandler? {
    get
    set
  }
}
@available(iOS 14.0, tvOS 14.0, *)
public protocol UIConfigurationState {
  init(traitCollection: UIKit.UITraitCollection)
  var traitCollection: UIKit.UITraitCollection { get set }
  subscript(key: UIKit.UIConfigurationStateCustomKey) -> Swift.AnyHashable? { get set }
}
@available(iOS 14.0, tvOS 14.0, *)
public struct UIViewConfigurationState : UIKit.UIConfigurationState, Swift.Hashable {
  public var traitCollection: UIKit.UITraitCollection {
    get
    set
  }
  public var isDisabled: Swift.Bool {
    get
    set
  }
  public var isHighlighted: Swift.Bool {
    get
    set
  }
  public var isSelected: Swift.Bool {
    get
    set
  }
  public var isFocused: Swift.Bool {
    get
    set
  }
  @available(iOS 15.0, tvOS 15.0, *)
  public var isPinned: Swift.Bool {
    get
    set
  }
  public subscript(key: UIKit.UIConfigurationStateCustomKey) -> Swift.AnyHashable? {
    get
    set
  }
  public init(traitCollection: UIKit.UITraitCollection)
  public static func == (lhs: UIKit.UIViewConfigurationState, rhs: UIKit.UIViewConfigurationState) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@available(iOS 14.0, tvOS 14.0, *)
public struct UICellConfigurationState : UIKit.UIConfigurationState, Swift.Hashable {
  @available(iOS 14.0, *)
  public enum DragState : Swift.Hashable {
    case none
    case lifting
    case dragging
    public static func == (a: UIKit.UICellConfigurationState.DragState, b: UIKit.UICellConfigurationState.DragState) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  @available(iOS 14.0, *)
  public enum DropState : Swift.Hashable {
    case none
    case notTargeted
    case targeted
    public static func == (a: UIKit.UICellConfigurationState.DropState, b: UIKit.UICellConfigurationState.DropState) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public var traitCollection: UIKit.UITraitCollection {
    get
    set
  }
  public var isDisabled: Swift.Bool {
    get
    set
  }
  public var isHighlighted: Swift.Bool {
    get
    set
  }
  public var isSelected: Swift.Bool {
    get
    set
  }
  public var isFocused: Swift.Bool {
    get
    set
  }
  @available(iOS 15.0, tvOS 15.0, *)
  public var isPinned: Swift.Bool {
    get
    set
  }
  public var isEditing: Swift.Bool {
    get
    set
  }
  public var isExpanded: Swift.Bool {
    get
    set
  }
  public var isSwiped: Swift.Bool {
    get
    set
  }
  public var isReordering: Swift.Bool {
    get
    set
  }
  public var cellDragState: UIKit.UICellConfigurationState.DragState {
    get
    set
  }
  public var cellDropState: UIKit.UICellConfigurationState.DropState {
    get
    set
  }
  public subscript(key: UIKit.UIConfigurationStateCustomKey) -> Swift.AnyHashable? {
    get
    set
  }
  public init(traitCollection: UIKit.UITraitCollection)
  public static func == (lhs: UIKit.UICellConfigurationState, rhs: UIKit.UICellConfigurationState) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@available(iOS 14.0, tvOS 14.0, *)
extension UIKit.UIViewConfigurationState : Swift._ObjectiveCBridgeable {
  @_semantics("convertToObjectiveC") public func _bridgeToObjectiveC() -> UIKit.__UIViewConfigurationState
  public static func _forceBridgeFromObjectiveC(_ input: UIKit.__UIViewConfigurationState, result: inout UIKit.UIViewConfigurationState?)
  public static func _conditionallyBridgeFromObjectiveC(_ input: UIKit.__UIViewConfigurationState, result: inout UIKit.UIViewConfigurationState?) -> Swift.Bool
  @_effects(readonly) public static func _unconditionallyBridgeFromObjectiveC(_ _state: UIKit.__UIViewConfigurationState?) -> UIKit.UIViewConfigurationState
  public typealias _ObjectiveCType = UIKit.__UIViewConfigurationState
}
@available(iOS 14.0, tvOS 14.0, *)
extension UIKit.UICellConfigurationState : Swift._ObjectiveCBridgeable {
  @_semantics("convertToObjectiveC") public func _bridgeToObjectiveC() -> UIKit.__UICellConfigurationState
  public static func _forceBridgeFromObjectiveC(_ input: UIKit.__UICellConfigurationState, result: inout UIKit.UICellConfigurationState?)
  public static func _conditionallyBridgeFromObjectiveC(_ input: UIKit.__UICellConfigurationState, result: inout UIKit.UICellConfigurationState?) -> Swift.Bool
  @_effects(readonly) public static func _unconditionallyBridgeFromObjectiveC(_ _state: UIKit.__UICellConfigurationState?) -> UIKit.UICellConfigurationState
  public typealias _ObjectiveCType = UIKit.__UICellConfigurationState
}
@available(iOS 14.0, tvOS 14.0, *)
extension UIKit.UIViewConfigurationState : Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible, Swift.CustomReflectable {
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
  public var customMirror: Swift.Mirror {
    get
  }
}
@available(iOS 14.0, tvOS 14.0, *)
extension UIKit.UICellConfigurationState : Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible, Swift.CustomReflectable {
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
  public var customMirror: Swift.Mirror {
    get
  }
}
@available(iOS 14.0, tvOS 14.0, *)
public struct NSDiffableDataSourceSectionTransaction<SectionIdentifierType, ItemIdentifierType> where SectionIdentifierType : Swift.Hashable, ItemIdentifierType : Swift.Hashable {
  public var sectionIdentifier: SectionIdentifierType {
    get
  }
  public var initialSnapshot: UIKit.NSDiffableDataSourceSectionSnapshot<ItemIdentifierType> {
    get
  }
  public var finalSnapshot: UIKit.NSDiffableDataSourceSectionSnapshot<ItemIdentifierType> {
    get
  }
  public var difference: Swift.CollectionDifference<ItemIdentifierType> {
    get
  }
}
@available(iOS 14.0, tvOS 14.0, *)
public struct NSDiffableDataSourceTransaction<SectionIdentifierType, ItemIdentifierType> where SectionIdentifierType : Swift.Hashable, ItemIdentifierType : Swift.Hashable {
  public var initialSnapshot: UIKit.NSDiffableDataSourceSnapshot<SectionIdentifierType, ItemIdentifierType> {
    get
  }
  public var finalSnapshot: UIKit.NSDiffableDataSourceSnapshot<SectionIdentifierType, ItemIdentifierType> {
    get
  }
  public var difference: Swift.CollectionDifference<ItemIdentifierType> {
    get
  }
  public var sectionTransactions: [UIKit.NSDiffableDataSourceSectionTransaction<SectionIdentifierType, ItemIdentifierType>] {
    get
  }
}
@available(iOS 14.0, tvOS 14.0, *)
extension UIKit.UICollectionViewDiffableDataSource {
  public struct ReorderingHandlers {
    public var canReorderItem: ((ItemIdentifierType) -> Swift.Bool)? {
      get
      set(handler)
    }
    public var willReorder: ((UIKit.NSDiffableDataSourceTransaction<SectionIdentifierType, ItemIdentifierType>) -> Swift.Void)? {
      get
      set(handler)
    }
    public var didReorder: ((UIKit.NSDiffableDataSourceTransaction<SectionIdentifierType, ItemIdentifierType>) -> Swift.Void)? {
      get
      set(handler)
    }
    public init()
  }
  @_Concurrency.MainActor(unsafe) public var reorderingHandlers: UIKit.UICollectionViewDiffableDataSource<SectionIdentifierType, ItemIdentifierType>.ReorderingHandlers {
    get
    set(handlers)
  }
}
@available(iOS 14.0, tvOS 14.0, *)
extension UIKit.UICollectionViewDiffableDataSource {
  public struct SectionSnapshotHandlers<ItemIdentifierType> where ItemIdentifierType : Swift.Hashable {
    public var shouldExpandItem: ((ItemIdentifierType) -> Swift.Bool)? {
      get
      set(handler)
    }
    public var willExpandItem: ((ItemIdentifierType) -> Swift.Void)? {
      get
      set(handler)
    }
    public var shouldCollapseItem: ((ItemIdentifierType) -> Swift.Bool)? {
      get
      set(handler)
    }
    public var willCollapseItem: ((ItemIdentifierType) -> Swift.Void)? {
      get
      set(handler)
    }
    public var snapshotForExpandingParent: ((ItemIdentifierType, UIKit.NSDiffableDataSourceSectionSnapshot<ItemIdentifierType>) -> UIKit.NSDiffableDataSourceSectionSnapshot<ItemIdentifierType>)? {
      get
      set(handler)
    }
    public init()
  }
  @_Concurrency.MainActor(unsafe) public var sectionSnapshotHandlers: UIKit.UICollectionViewDiffableDataSource<SectionIdentifierType, ItemIdentifierType>.SectionSnapshotHandlers<ItemIdentifierType> {
    get
    set(handlers)
  }
}
@available(iOS 13.4, *)
extension UIKit.UIPointerEffect.TintMode : Swift.Equatable {}
@available(iOS 13.4, *)
extension UIKit.UIPointerEffect.TintMode : Swift.Hashable {}
@available(iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.AttributeScopes.UIKitAttributes.FontAttribute : Swift.Sendable {}
@available(iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.AttributeScopes.UIKitAttributes.ParagraphStyleAttribute : Swift.Sendable {}
@available(iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.AttributeScopes.UIKitAttributes.ForegroundColorAttribute : Swift.Sendable {}
@available(iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.AttributeScopes.UIKitAttributes.BackgroundColorAttribute : Swift.Sendable {}
@available(iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.AttributeScopes.UIKitAttributes.LigatureAttribute : Swift.Sendable {}
@available(iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.AttributeScopes.UIKitAttributes.KernAttribute : Swift.Sendable {}
@available(iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.AttributeScopes.UIKitAttributes.TrackingAttribute : Swift.Sendable {}
@available(iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.AttributeScopes.UIKitAttributes.StrikethroughStyleAttribute : Swift.Sendable {}
@available(iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.AttributeScopes.UIKitAttributes.UnderlineStyleAttribute : Swift.Sendable {}
@available(iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.AttributeScopes.UIKitAttributes.StrokeColorAttribute : Swift.Sendable {}
@available(iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.AttributeScopes.UIKitAttributes.StrokeWidthAttribute : Swift.Sendable {}
@available(iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.AttributeScopes.UIKitAttributes.ShadowAttribute : Swift.Sendable {}
@available(iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.AttributeScopes.UIKitAttributes.TextEffectAttribute : Swift.Sendable {}
@available(iOS 15, tvOS 15, *)
@available(watchOS, unavailable)
extension Foundation.AttributeScopes.UIKitAttributes.AttachmentAttribute : Swift.Sendable {}
@available(iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.AttributeScopes.UIKitAttributes.BaselineOffsetAttribute : Swift.Sendable {}
@available(iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.AttributeScopes.UIKitAttributes.UnderlineColorAttribute : Swift.Sendable {}
@available(iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.AttributeScopes.UIKitAttributes.StrikethroughColorAttribute : Swift.Sendable {}
@available(iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.AttributeScopes.UIKitAttributes.ObliquenessAttribute : Swift.Sendable {}
@available(iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.AttributeScopes.UIKitAttributes.ExpansionAttribute : Swift.Sendable {}
@available(iOS 15.0, tvOS 15.0, *)
extension UIKit.UIButton.Configuration.Size : Swift.Equatable {}
@available(iOS 15.0, tvOS 15.0, *)
extension UIKit.UIButton.Configuration.Size : Swift.Hashable {}
@available(iOS 15.0, tvOS 15.0, *)
extension UIKit.UIButton.Configuration.TitleAlignment : Swift.Equatable {}
@available(iOS 15.0, tvOS 15.0, *)
extension UIKit.UIButton.Configuration.TitleAlignment : Swift.Hashable {}
@available(iOS 15.0, tvOS 15.0, *)
extension UIKit.UIButton.Configuration.CornerStyle : Swift.Equatable {}
@available(iOS 15.0, tvOS 15.0, *)
extension UIKit.UIButton.Configuration.CornerStyle : Swift.Hashable {}
@available(iOS 15.0, tvOS 15.0, *)
extension UIKit.UIButton.Configuration.MacIdiomStyle : Swift.Equatable {}
@available(iOS 15.0, tvOS 15.0, *)
extension UIKit.UIButton.Configuration.MacIdiomStyle : Swift.Hashable {}
@available(iOS 14.0, tvOS 14.0, *)
extension UIKit.UICellAccessory.DisplayedState : Swift.Equatable {}
@available(iOS 14.0, tvOS 14.0, *)
extension UIKit.UICellAccessory.DisplayedState : Swift.Hashable {}
@available(iOS 14.0, tvOS 14.0, *)
extension UIKit.UICellAccessory.OutlineDisclosureOptions.Style : Swift.Equatable {}
@available(iOS 14.0, tvOS 14.0, *)
extension UIKit.UICellAccessory.OutlineDisclosureOptions.Style : Swift.Hashable {}
@available(iOS 14.0, tvOS 14.0, *)
extension UIKit.UICollectionLayoutListConfiguration.Appearance : Swift.Equatable {}
@available(iOS 14.0, tvOS 14.0, *)
extension UIKit.UICollectionLayoutListConfiguration.Appearance : Swift.Hashable {}
@available(iOS 14.0, tvOS 14.0, *)
extension UIKit.UICollectionLayoutListConfiguration.HeaderMode : Swift.Equatable {}
@available(iOS 14.0, tvOS 14.0, *)
extension UIKit.UICollectionLayoutListConfiguration.HeaderMode : Swift.Hashable {}
@available(iOS 14.0, tvOS 14.0, *)
extension UIKit.UICollectionLayoutListConfiguration.FooterMode : Swift.Equatable {}
@available(iOS 14.0, tvOS 14.0, *)
extension UIKit.UICollectionLayoutListConfiguration.FooterMode : Swift.Hashable {}
