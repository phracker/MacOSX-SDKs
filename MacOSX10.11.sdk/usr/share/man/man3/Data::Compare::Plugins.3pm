.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Data::Compare::Plugins 3"
.TH Data::Compare::Plugins 3 "2011-07-23" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Data::Compare::Plugins \- how to extend Data::Compare
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Data::Compare natively handles several built-in data types \- scalars,
references to scalars,
references to arrays, references to hashes, references to
subroutines, compiled regular expressions, and globs.  For objects,
it tries to Do The Right Thing and compares the underlying data type.
However, this is not always what you want.  This is especially true if
you have complex objects which overload stringification and/or
numification.
.PP
Hence we allow for plugins.
.SH "FINDING PLUGINS"
.IX Header "FINDING PLUGINS"
Data::Compare will try to load any module installed on your system under
the various \f(CW@INC\fR/Data/Compare/Plugins/ directories.  If there is a problem
loading any of them, an appropriate warning will be issued.
.PP
Because of how we find plugins, no plugins are available when running in
\&\*(L"taint\*(R" mode.
.SH "WRITING PLUGINS"
.IX Header "WRITING PLUGINS"
Internally, plugins are \f(CW\*(C`require\*(C'\fRd into Data::Compare.  This means that
they need to evaluate to true.  We make use of that true value.  Where
normally you just put:
.PP
.Vb 1
\&    1;
.Ve
.PP
at the end of an included file, you should instead ensure that you return
a reference to an array.  This is treated as being true so satisfies perl,
and is a damned sight more useful.
.PP
Inside that array should be either a description of what this plugin is to
do, or references to several arrays containing such descriptions.  A
description consists of two or three items.  First a string telling
us what the first data-type handled by your plugin is.  Second, (and
optional, defaulting to the same as the first) the second data-type
to compare.  To handle comparisons to ordinary scalars, give the empty string
for the data-type, ie:
.PP
.Vb 1
\&    [\*(AqMyType\*(Aq, \*(Aq\*(Aq, sub { ...}]
.Ve
.PP
Third and last, we need a reference to the
subroutine which does the comparison.
That subroutine should expect to take two parameters, which will be of
the specified type.  It should return 1 if they compare
the same, or 0 if they compare different.
.PP
Be aware that while you might give a description like:
.PP
.Vb 1
\&    [\*(AqType1\*(Aq, \*(AqType2\*(Aq, sub { ... }]
.Ve
.PP
this will handle both comparing Type1 to Type2, and comparing Type2 to
Type1.  ie, comparison is commutative.
.PP
If you want to use Data::Compare's own comparison function from within
your handler (to, for example, compare a data structure that you have
stored somewhere in your object) then you will need to call it as
Data::Compare::Compare.  However, you must be careful to avoid infinite
recursion by calling D::C::Compare which in turn calls back to your
handler.
.PP
The name of
your plugins does not matter, only that it lives in one of those directories.
Of course, giving it a sensible name means that the usual installation
mechanisms will put it in the right place, and meaningful names will make
it easier to debug your code.
.PP
For an example, look at the plugin that handles Scalar::Properties
objects, which is distributed with Data::Compare.
.SH "DISTRIBUTION"
.IX Header "DISTRIBUTION"
Provided that the above rules are followed I see no reason for you to not
upload your plugin to the \s-1CPAN\s0 yourself.  You will need to make Data::Compare
a pre-requisite, so that the \s-1CPAN\s0.pm installer does the right thing.
.PP
Alternatively, if you would prefer me to roll your plugin in with the
Data::Compare distribution, I'd be happy to do so provided that the code
is clear and well-commented, and that you include tests and documentation.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Data::Compare
.PP
Data::Compare::Plugins::Scalar::Properties
.SH "AUTHOR"
.IX Header "AUTHOR"
Copyright (c) 2004 David Cantrell <david@cantrell.org.uk>.
All rights reserved.
This program is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.
