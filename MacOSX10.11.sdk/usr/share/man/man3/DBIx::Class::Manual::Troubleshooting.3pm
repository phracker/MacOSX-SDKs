.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "DBIx::Class::Manual::Troubleshooting 3"
.TH DBIx::Class::Manual::Troubleshooting 3 "2013-12-16" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
DBIx::Class::Manual::Troubleshooting \- Got a problem? Shoot it.
.ie n .SS """Can't locate storage blabla"""
.el .SS "``Can't locate storage blabla''"
.IX Subsection "Can't locate storage blabla"
You're trying to make a query on a non-connected schema. Make sure you got
the current resultset from \f(CW$schema\fR\->resultset('Artist') on a schema object
you got back from \fIconnect()\fR.
.SS "Tracing \s-1SQL\s0"
.IX Subsection "Tracing SQL"
The \f(CW\*(C`DBIC_TRACE\*(C'\fR environment variable controls
\&\s-1SQL\s0 tracing, so to see what is happening try
.PP
.Vb 1
\&  export DBIC_TRACE=1
.Ve
.PP
Alternatively use the \f(CW\*(C`storage\->debug\*(C'\fR class method:\-
.PP
.Vb 1
\&  $schema\->storage\->debug(1);
.Ve
.PP
To send the output somewhere else set debugfh:\-
.PP
.Vb 1
\&  $schema\->storage\->debugfh(IO::File\->new(\*(Aq/tmp/trace.out\*(Aq, \*(Aqw\*(Aq);
.Ve
.PP
Alternatively you can do this with the environment variable, too:\-
.PP
.Vb 1
\&  export DBIC_TRACE="1=/tmp/trace.out"
.Ve
.SS "Can't locate method result_source_instance"
.IX Subsection "Can't locate method result_source_instance"
For some reason the table class in question didn't load fully, so the
ResultSource object for it hasn't been created. Debug this class in
isolation, then try loading the full schema again.
.SS "Can't get last insert \s-1ID\s0 under Postgres with serial primary keys"
.IX Subsection "Can't get last insert ID under Postgres with serial primary keys"
Older \s-1DBI\s0 and DBD::Pg versions do not handle \f(CW\*(C`last_insert_id\*(C'\fR
correctly, causing code that uses auto-incrementing primary key
columns to fail with a message such as:
.PP
.Vb 1
\&  Can\*(Aqt get last insert id at /.../DBIx/Class/Row.pm line 95
.Ve
.PP
In particular the \s-1RHEL 4\s0 and \s-1FC3\s0 Linux distributions both ship with
combinations of \s-1DBI\s0 and DBD::Pg modules that do not work
correctly.
.PP
\&\s-1DBI\s0 version 1.50 and DBD::Pg 1.43 are known to work.
.ie n .SS "Can't locate object method ""source_name"" via package"
.el .SS "Can't locate object method ``source_name'' via package"
.IX Subsection "Can't locate object method source_name via package"
There's likely a syntax error in the table class referred to elsewhere
in this error message.  In particular make sure that the package
declaration is correct. For example, for a schema \f(CW\*(C` MySchema \*(C'\fR
you need to specify a fully qualified namespace: \f(CW\*(C` package MySchema::MyTable; \*(C'\fR.
.ie n .SS "syntax error at or near ""<something>"" ..."
.el .SS "syntax error at or near ``<something>'' ..."
.IX Subsection "syntax error at or near <something> ..."
This can happen if you have a relation whose name is a word reserved by your
database, e.g. \*(L"user\*(R":
.PP
.Vb 7
\&  package My::Schema::User;
\&  ...
\&  _\|_PACKAGE_\|_\->table(\*(Aqusers\*(Aq);
\&  _\|_PACKAGE_\|_\->add_columns(qw/ id name /);
\&  _\|_PACKAGE_\|_\->set_primary_key(\*(Aqid\*(Aq);
\&  ...
\&  1;
\&
\&  package My::Schema::ACL;
\&  ...
\&  _\|_PACKAGE_\|_\->table(\*(Aqacl\*(Aq);
\&  _\|_PACKAGE_\|_\->add_columns(qw/ user_id /);
\&  _\|_PACKAGE_\|_\->belongs_to( \*(Aquser\*(Aq => \*(AqMy::Schema::User\*(Aq, \*(Aquser_id\*(Aq );
\&  ...
\&  1;
\&
\&  $schema\->resultset(\*(AqACL\*(Aq)\->search(
\&    {},
\&    {
\&      join => [qw/ user /],
\&      \*(Aq+select\*(Aq => [ \*(Aquser.name\*(Aq ]
\&    }
\&  );
.Ve
.PP
The \s-1SQL\s0 generated would resemble something like:
.PP
.Vb 2
\&  SELECT me.user_id, user.name FROM acl me
\&  JOIN users user ON me.user_id = user.id
.Ve
.PP
If, as is likely, your database treats \*(L"user\*(R" as a reserved word, you'd end
up with the following errors:
.PP
1) syntax error at or near \*(L".\*(R" \- due to \*(L"user.name\*(R" in the \s-1SELECT\s0 clause
.PP
2) syntax error at or near \*(L"user\*(R" \- due to \*(L"user\*(R" in the \s-1JOIN\s0 clause
.PP
The solution is to enable quoting \- see
\&\*(L"Setting quoting for the generated \s-1SQL\*(R"\s0 in DBIx::Class::Manual::Cookbook for
details.
.ie n .SS "column ""foo \s-1DESC""\s0 does not exist ..."
.el .SS "column ``foo \s-1DESC''\s0 does not exist ..."
.IX Subsection "column foo DESC does not exist ..."
This can happen if you are still using the obsolete order hack, and also
happen to turn on SQL-quoting.
.PP
.Vb 1
\&  $rs\->search( {}, { order_by => [ \*(Aqname DESC\*(Aq ] } );
.Ve
.PP
Since DBIx::Class >= 0.08100 and SQL::Abstract >= 1.50 the above
should be written as:
.PP
.Vb 1
\&  $rs\->search( {}, { order_by => { \-desc => \*(Aqname\*(Aq } } );
.Ve
.PP
For more ways to express order clauses refer to
\&\*(L"\s-1ORDER BY CLAUSES\*(R"\s0 in SQL::Abstract
.SS "Perl Performance Issues on Red Hat Systems"
.IX Subsection "Perl Performance Issues on Red Hat Systems"
There is a problem with slow performance of certain DBIx::Class
operations using the system perl on some Fedora and Red Hat Enterprise
Linux system (as well as their derivative distributions such as Centos,
White Box and Scientific Linux).
.PP
Distributions affected include Fedora 5 through to Fedora 8 and \s-1RHEL5\s0
upto and including \s-1RHEL5\s0 Update 2. Fedora 9 (which uses perl 5.10) has
never been affected \- this is purely a perl 5.8.8 issue.
.PP
As of September 2008 the following packages are known to be fixed and so
free of this performance issue (this means all Fedora and \s-1RHEL5\s0 systems
with full current updates will not be subject to this problem):\-
.PP
.Vb 2
\&  Fedora 8     \- perl\-5.8.8\-41.fc8
\&  RHEL5        \- perl\-5.8.8\-15.el5_2.1
.Ve
.PP
This issue is due to perl doing an exhaustive search of blessed objects
under certain circumstances.  The problem shows up as performance
degradation exponential to the number of DBIx::Class result objects in
memory, so can be unnoticeable with certain data sets, but with huge
performance impacts on other datasets.
.PP
A pair of tests for susceptibility to the issue and performance effects
of the bless/overload problem can be found in the DBIx::Class test
suite, in the \f(CW\*(C`t/99rh_perl_perf_bug.t\*(C'\fR file.
.PP
Further information on this issue can be found in
<https://bugzilla.redhat.com/show_bug.cgi?id=379791>,
<https://bugzilla.redhat.com/show_bug.cgi?id=460308> and
<http://rhn.redhat.com/errata/RHBA\-2008\-0876.html>
.SS "Excessive Memory Allocation with TEXT/BLOB/etc. Columns and Large LongReadLen"
.IX Subsection "Excessive Memory Allocation with TEXT/BLOB/etc. Columns and Large LongReadLen"
It has been observed, using \s-1DBD::ODBC\s0, that creating a DBIx::Class::Row
object which includes a column of data type TEXT/BLOB/etc. will allocate
LongReadLen bytes.  This allocation does not leak, but if LongReadLen
is large in size, and many such result objects are created, e.g. as the
output of a ResultSet query, the memory footprint of the Perl interpreter
can grow very large.
.PP
The solution is to use the smallest practical value for LongReadLen.
