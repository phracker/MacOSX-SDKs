.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "open 3pm"
.TH open 3pm "2013-11-04" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
open \- perl pragma to set default PerlIO layers for input and output
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 3
\&    use open IN  => ":crlf", OUT => ":bytes";
\&    use open OUT => \*(Aq:utf8\*(Aq;
\&    use open IO  => ":encoding(iso\-8859\-7)";
\&
\&    use open IO  => \*(Aq:locale\*(Aq;
\&
\&    use open \*(Aq:encoding(utf8)\*(Aq;
\&    use open \*(Aq:locale\*(Aq;
\&    use open \*(Aq:encoding(iso\-8859\-7)\*(Aq;
\&
\&    use open \*(Aq:std\*(Aq;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Full-fledged support for I/O layers is now implemented provided
Perl is configured to use PerlIO as its \s-1IO\s0 system (which is now the
default).
.PP
The \f(CW\*(C`open\*(C'\fR pragma serves as one of the interfaces to declare default
\&\*(L"layers\*(R" (also known as \*(L"disciplines\*(R") for all I/O. Any two-argument
\&\fIopen()\fR, \fIreadpipe()\fR (aka qx//) and similar operators found within the
lexical scope of this pragma will use the declared defaults.
Even three-argument opens may be affected by this pragma
when they don't specify \s-1IO\s0 layers in \s-1MODE.\s0
.PP
With the \f(CW\*(C`IN\*(C'\fR subpragma you can declare the default layers
of input streams, and with the \f(CW\*(C`OUT\*(C'\fR subpragma you can declare
the default layers of output streams.  With the \f(CW\*(C`IO\*(C'\fR  subpragma
you can control both input and output streams simultaneously.
.PP
If you have a legacy encoding, you can use the \f(CW\*(C`:encoding(...)\*(C'\fR tag.
.PP
If you want to set your encoding layers based on your
locale environment variables, you can use the \f(CW\*(C`:locale\*(C'\fR tag.
For example:
.PP
.Vb 9
\&    $ENV{LANG} = \*(Aqru_RU.KOI8\-R\*(Aq;
\&    # the :locale will probe the locale environment variables like LANG
\&    use open OUT => \*(Aq:locale\*(Aq;
\&    open(O, ">koi8");
\&    print O chr(0x430); # Unicode CYRILLIC SMALL LETTER A = KOI8\-R 0xc1
\&    close O;
\&    open(I, "<koi8");
\&    printf "%#x\en", ord(<I>), "\en"; # this should print 0xc1
\&    close I;
.Ve
.PP
These are equivalent
.PP
.Vb 2
\&    use open \*(Aq:encoding(utf8)\*(Aq;
\&    use open IO => \*(Aq:encoding(utf8)\*(Aq;
.Ve
.PP
as are these
.PP
.Vb 2
\&    use open \*(Aq:locale\*(Aq;
\&    use open IO => \*(Aq:locale\*(Aq;
.Ve
.PP
and these
.PP
.Vb 2
\&    use open \*(Aq:encoding(iso\-8859\-7)\*(Aq;
\&    use open IO => \*(Aq:encoding(iso\-8859\-7)\*(Aq;
.Ve
.PP
The matching of encoding names is loose: case does not matter, and
many encodings have several aliases.  See Encode::Supported for
details and the list of supported locales.
.PP
When \fIopen()\fR is given an explicit list of layers (with the three-arg
syntax), they override the list declared using this pragma.  \fIopen()\fR can
also be given a single colon (:) for a layer name, to override this pragma
and use the default (\f(CW\*(C`:raw\*(C'\fR on Unix, \f(CW\*(C`:crlf\*(C'\fR on Windows).
.PP
The \f(CW\*(C`:std\*(C'\fR subpragma on its own has no effect, but if combined with
the \f(CW\*(C`:utf8\*(C'\fR or \f(CW\*(C`:encoding\*(C'\fR subpragmas, it converts the standard
filehandles (\s-1STDIN, STDOUT, STDERR\s0) to comply with encoding selected
for input/output handles.  For example, if both input and out are
chosen to be \f(CW\*(C`:encoding(utf8)\*(C'\fR, a \f(CW\*(C`:std\*(C'\fR will mean that \s-1STDIN, STDOUT,\s0
and \s-1STDERR\s0 are also in \f(CW\*(C`:encoding(utf8)\*(C'\fR.  On the other hand, if only
output is chosen to be in \f(CW\*(C`:encoding(koi8r)\*(C'\fR, a \f(CW\*(C`:std\*(C'\fR will cause
only the \s-1STDOUT\s0 and \s-1STDERR\s0 to be in \f(CW\*(C`koi8r\*(C'\fR.  The \f(CW\*(C`:locale\*(C'\fR subpragma
implicitly turns on \f(CW\*(C`:std\*(C'\fR.
.PP
The logic of \f(CW\*(C`:locale\*(C'\fR is described in full in encoding,
but in short it is first trying nl_langinfo(\s-1CODESET\s0) and then
guessing from the \s-1LC_ALL\s0 and \s-1LANG\s0 locale environment variables.
.PP
Directory handles may also support PerlIO layers in the future.
.SH "NONPERLIO FUNCTIONALITY"
.IX Header "NONPERLIO FUNCTIONALITY"
If Perl is not built to use PerlIO as its \s-1IO\s0 system then only the two
pseudo-layers \f(CW\*(C`:bytes\*(C'\fR and \f(CW\*(C`:crlf\*(C'\fR are available.
.PP
The \f(CW\*(C`:bytes\*(C'\fR layer corresponds to \*(L"binary mode\*(R" and the \f(CW\*(C`:crlf\*(C'\fR
layer corresponds to \*(L"text mode\*(R" on platforms that distinguish
between the two modes when opening files (which is many DOS-like
platforms, including Windows).  These two layers are no-ops on
platforms where \fIbinmode()\fR is a no-op, but perform their functions
everywhere if PerlIO is enabled.
.SH "IMPLEMENTATION DETAILS"
.IX Header "IMPLEMENTATION DETAILS"
There is a class method in \f(CW\*(C`PerlIO::Layer\*(C'\fR \f(CW\*(C`find\*(C'\fR which is
implemented as \s-1XS\s0 code.  It is called by \f(CW\*(C`import\*(C'\fR to validate the
layers:
.PP
.Vb 1
\&   PerlIO::Layer::\->find("perlio")
.Ve
.PP
The return value (if defined) is a Perl object, of class
\&\f(CW\*(C`PerlIO::Layer\*(C'\fR which is created by the C code in \fIperlio.c\fR.  As
yet there is nothing useful you can do with the object at the perl
level.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\*(L"binmode\*(R" in perlfunc, \*(L"open\*(R" in perlfunc, perlunicode, PerlIO,
encoding
