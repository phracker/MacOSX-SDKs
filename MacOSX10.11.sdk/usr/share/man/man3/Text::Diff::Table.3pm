.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Text::Diff::Table 3"
.TH Text::Diff::Table 3 "2011-04-16" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
.Vb 1
\&  Text::Diff::Table \- Text::Diff plugin to generate "table" format output
.Ve
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use Text::Diff;
\&  
\&  diff \e@a, $b { STYLE => "Table" };
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This is a plugin output formatter for Text::Diff that generates \*(L"table\*(R" style
diffs:
.PP
.Vb 10
\&  +\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+
\&  |  |../Test\-Differences\-0.2/MANIFEST  |  |../Test\-Differences/MANIFEST  |
\&  |  |Thu Dec 13 15:38:49 2001          |  |Sat Dec 15 02:09:44 2001      |
\&  +\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+
\&  |  |                                  * 1|Changes                       *
\&  | 1|Differences.pm                    | 2|Differences.pm                |
\&  | 2|MANIFEST                          | 3|MANIFEST                      |
\&  |  |                                  * 4|MANIFEST.SKIP                 *
\&  | 3|Makefile.PL                       | 5|Makefile.PL                   |
\&  |  |                                  * 6|t/00escape.t                  *
\&  | 4|t/00flatten.t                     | 7|t/00flatten.t                 |
\&  | 5|t/01text_vs_data.t                | 8|t/01text_vs_data.t            |
\&  | 6|t/10test.t                        | 9|t/10test.t                    |
\&  +\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+
.Ve
.PP
This format also goes to some pains to highlight \*(L"invisible\*(R" characters on
differing elements by selectively escaping whitespace.  Each element is split
in to three segments (leading whitespace, body, trailing whitespace).  If
whitespace differs in a segement, that segment is whitespace escaped.
.PP
Here is an example of the selective whitespace.
.PP
.Vb 10
\&  +\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+
\&  |  |demo_ws_A.txt             |demo_ws_B.txt             |
\&  |  |Fri Dec 21 08:36:32 2001  |Fri Dec 21 08:36:50 2001  |
\&  +\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+
\&  | 1|identical                 |identical                 |
\&  * 2|        spaced in         |        also spaced in    *
\&  * 3|embedded space            |embedded        tab       *
\&  | 4|identical                 |identical                 |
\&  * 5|        spaced in         |\ettabbed in               *
\&  * 6|trailing spaces\es\es\en     |trailing tabs\et\et\en       *
\&  | 7|identical                 |identical                 |
\&  * 8|lf line\en                 |crlf line\er\en             *
\&  * 9|embedded ws               |embedded\etws              *
\&  +\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+
.Ve
.PP
Here's why the lines do or do not have whitespace escaped:
.IP "lines 1, 4, 7 don't differ, no need." 4
.IX Item "lines 1, 4, 7 don't differ, no need."
.PD 0
.IP "lines 2, 3 differ in non-whitespace, no need." 4
.IX Item "lines 2, 3 differ in non-whitespace, no need."
.IP "lines 5, 6, 8, 9 all have subtle ws changes." 4
.IX Item "lines 5, 6, 8, 9 all have subtle ws changes."
.PD
.PP
Whether or not line 3 should have that tab character escaped is a judgement
call; so far I'm choosing not to.
.SH "UNICODE"
.IX Header "UNICODE"
To output the raw unicode chracters consult the documentation of
Text::Diff::Config. You can set the \f(CW\*(C`DIFF_OUTPUT_UNICODE\*(C'\fR environment
variable to 1 to output it from the command line. For more information,
consult this bug: <https://rt.cpan.org/Ticket/Display.html?id=54214> .
.SH "LIMITATIONS"
.IX Header "LIMITATIONS"
Table formatting requires buffering the entire diff in memory in order to
calculate column widths.  This format should only be used for smaller
diffs.
.PP
Assumes tab stops every 8 characters, as \f(CW$DIETY\fR intended.
.PP
Assumes all character codes >= 127 need to be escaped as hex codes, ie that the
user's terminal is \s-1ASCII,\s0 and not even \*(L"high bit \s-1ASCII\*(R",\s0 capable.  This can be
made an option when the need arises.
.PP
Assumes that control codes (character codes 0..31) that don't have slash-letter
escapes (\*(L"\en\*(R", \*(L"\er\*(R", etc) in Perl are best presented as hex escapes (\*(L"\ex01\*(R")
instead of octal (\*(L"\e001\*(R") or control-code (\*(L"\ecA\*(R") escapes.
.SH "AUTHOR"
.IX Header "AUTHOR"
Barrie Slaymaker <barries@slaysys.com>
.SH "LICENSE"
.IX Header "LICENSE"
Copyright 2001 Barrie Slaymaker, All Rights Reserved.
.PP
You may use this software under the terms of the \s-1GNU\s0 public license, any
version, or the Artistic license.
