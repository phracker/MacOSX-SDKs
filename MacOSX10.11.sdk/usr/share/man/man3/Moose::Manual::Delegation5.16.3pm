.\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Moose::Manual::Delegation 3"
.TH Moose::Manual::Delegation 3 "2012-09-19" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Moose::Manual::Delegation \- Attribute delegation
.SH "VERSION"
.IX Header "VERSION"
version 2.0604
.SH "WHAT IS DELEGATION?"
.IX Header "WHAT IS DELEGATION?"
Delegation is a feature that lets you create \*(L"proxy\*(R" methods that do nothing
more than call some other method on an attribute. This lets you simplify a
complex set of \*(L"has-a\*(R" relationships and present a single unified \s-1API\s0 from one
class.
.PP
With delegation, consumers of a class don't need to know about all the
objects it contains, reducing the amount of \s-1API\s0 they need to learn.
.PP
Delegations are defined as a mapping between one or more methods
provided by the \*(L"real\*(R" class (the delegatee), and a set of
corresponding methods in the delegating class. The delegating class
can re-use the method names provided by the delegatee or provide its
own names.
.PP
Delegation is also a great way to wrap an existing class, especially a
non-Moose class or one that is somehow hard (or impossible) to
subclass.
.SH "DEFINING A MAPPING"
.IX Header "DEFINING A MAPPING"
Moose offers a number of options for defining a delegation's mapping,
ranging from simple to complex.
.PP
The simplest form is to simply specify a list of methods:
.PP
.Vb 1
\&  package Website;
\&
\&  use Moose;
\&
\&  has \*(Aquri\*(Aq => (
\&      is      => \*(Aqro\*(Aq,
\&      isa     => \*(AqURI\*(Aq,
\&      handles => [qw( host path )],
\&  );
.Ve
.PP
With this definition, we can call \f(CW\*(C`$website\->host\*(C'\fR and it \*(L"just
works\*(R". Under the hood, Moose will call \f(CW\*(C`$website\->uri\->host\*(C'\fR for
you. Note that \f(CW$website\fR is not automatically passed to the \f(CW\*(C`host\*(C'\fR
method; the invocant is \f(CW\*(C`$website\->uri\*(C'\fR.
.PP
We can also define a mapping as a hash reference. This allows you to
rename methods as part of the mapping:
.PP
.Vb 1
\&  package Website;
\&
\&  use Moose;
\&
\&  has \*(Aquri\*(Aq => (
\&      is      => \*(Aqro\*(Aq,
\&      isa     => \*(AqURI\*(Aq,
\&      handles => {
\&          hostname => \*(Aqhost\*(Aq,
\&          path     => \*(Aqpath\*(Aq,
\&      },
\&  );
.Ve
.PP
In this example, we've created a \f(CW\*(C`$website\->hostname\*(C'\fR method,
rather than using \f(CW\*(C`URI.pm\*(C'\fR's name, \f(CW\*(C`host\*(C'\fR.
.PP
These two mapping forms are the ones you will use most often. The
remaining methods are a bit more complex.
.PP
.Vb 5
\&  has \*(Aquri\*(Aq => (
\&      is      => \*(Aqro\*(Aq,
\&      isa     => \*(AqURI\*(Aq,
\&      handles => qr/^(?:host|path|query.*)/,
\&  );
.Ve
.PP
This is similar to the array version, except it uses the regex to
match against all the methods provided by the delegatee. In order for
this to work, you must provide an \f(CW\*(C`isa\*(C'\fR parameter for the attribute,
and it must be a class. Moose uses this to introspect the delegatee
class and determine what methods it provides.
.PP
You can use a role name as the value of \f(CW\*(C`handles\*(C'\fR:
.PP
.Vb 5
\&  has \*(Aquri\*(Aq => (
\&      is      => \*(Aqro\*(Aq,
\&      isa     => \*(AqURI\*(Aq,
\&      handles => \*(AqHasURI\*(Aq,
\&  );
.Ve
.PP
Moose will introspect the role to determine what methods it provides
and create a mapping for each of those methods.
.PP
Finally, you can also provide a sub reference to \fIgenerate\fR a
mapping. You probably won't need this version often (if ever). See the
Moose docs for more details on exactly how this works.
.SH "NATIVE DELEGATION"
.IX Header "NATIVE DELEGATION"
Native delegations allow you to delegate to standard Perl data structures as
if they were objects.
.PP
.Vb 9
\&  has \*(Aqqueue\*(Aq => (
\&      traits  => [\*(AqArray\*(Aq],
\&      isa     => \*(AqArrayRef[Item]\*(Aq,
\&      default => sub { [ ] },
\&      handles => {
\&          add_item  => \*(Aqpush\*(Aq,
\&          next_item => \*(Aqshift\*(Aq,
\&      },
\&  )
.Ve
.PP
The \f(CW\*(C`Array\*(C'\fR trait in the \f(CW\*(C`traits\*(C'\fR parameter tells Moose that you would like
to use the set of Array helpers. Moose will then create \f(CW\*(C`add_item\*(C'\fR and
\&\f(CW\*(C`next_item\*(C'\fR methods that \*(L"just work\*(R". Behind the scenes \f(CW\*(C`add_item\*(C'\fR is
something like
.PP
.Vb 2
\&  sub add_item {
\&      my ($self, @items) = @_;
\&
\&      for my $item (@items) {
\&          $Item_TC\->validate($item);
\&      }
\&
\&      push @{ $self\->queue }, @items;
\&  }
.Ve
.PP
Moose includes the following traits for native delegation:
.IP "\(bu" 4
Array
.IP "\(bu" 4
Bool
.IP "\(bu" 4
Code
.IP "\(bu" 4
Counter
.IP "\(bu" 4
Hash
.IP "\(bu" 4
Number
.IP "\(bu" 4
String
.SH "CURRYING"
.IX Header "CURRYING"
Currying allows you to create a method with some pre-set parameters. You can
create a curried delegation method:
.PP
.Vb 2
\&    package Spider;
\&    use Moose;
\&
\&    has request => (
\&        is      => \*(Aqro\*(Aq
\&        isa     => \*(AqHTTP::Request\*(Aq,
\&        handles => {
\&            set_user_agent => [ header => \*(AqUserAgent\*(Aq ],
\&        },
\&    )
.Ve
.PP
With this definition, calling \f(CW\*(C`$spider\->set_user_agent(\*(AqMyClient\*(Aq)\*(C'\fR will
call \f(CW\*(C`$spider\->request\->header(\*(AqUserAgent\*(Aq, \*(AqMyClient\*(Aq)\*(C'\fR behind the
scenes.
.PP
Note that with currying, the currying always starts with the first parameter to
a method (\f(CW$_[0]\fR). Any arguments you pass to the delegation come after the
curried arguments.
.SH "MISSING ATTRIBUTES"
.IX Header "MISSING ATTRIBUTES"
It is perfectly valid to delegate methods to an attribute which is not
required or can be undefined. When a delegated method is called, Moose
will throw a runtime error if the attribute does not contain an
object.
.SH "AUTHOR"
.IX Header "AUTHOR"
Moose is maintained by the Moose Cabal, along with the help of many contributors. See \*(L"\s-1CABAL\s0\*(R" in Moose and \*(L"\s-1CONTRIBUTORS\s0\*(R" in Moose for details.
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is copyright (c) 2012 by Infinity Interactive, Inc..
.PP
This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.
