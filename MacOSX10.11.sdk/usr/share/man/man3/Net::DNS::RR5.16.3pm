.\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Net::DNS::RR 3"
.TH Net::DNS::RR 3 "2012-01-27" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Net::DNS::RR \- DNS Resource Record base class
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
use Net::DNS;
.PP
.Vb 1
\&    $rr = new Net::DNS::RR(\*(Aqexample.com IN A 192.0.2.99\*(Aq);
\&
\&    $rr = new Net::DNS::RR(
\&            name    => \*(Aqexample.com\*(Aq
\&            type    => \*(AqA\*(Aq,
\&            address => \*(Aq192.0.2.99\*(Aq
\&            );
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\f(CW\*(C`Net::DNS::RR\*(C'\fR is the base class for \s-1DNS\s0 Resource Record (\s-1RR\s0) objects.
See also the manual pages for each \s-1RR\s0 type.
.SH "METHODS"
.IX Header "METHODS"
\&\fB\s-1WARNING\s0!!!\fR  Do not assume the \s-1RR\s0 objects you receive from a query
are of a particular type \*(-- always check the object type before calling
any of its methods.  If you call an unknown method, you will get an
error message and execution will be terminated.
.SS "new (from string)"
.IX Subsection "new (from string)"
.Vb 4
\& $a     = Net::DNS::RR\->new("foo.example.com. 86400 A 10.1.2.3");
\& $mx    = Net::DNS::RR\->new("example.com. 7200 MX 10 mailhost.example.com.");
\& $cname = Net::DNS::RR\->new("www.example.com 300 IN CNAME www1.example.com");
\& $txt   = Net::DNS::RR\->new(\*(Aqbaz.example.com 3600 HS TXT "text record"\*(Aq);
.Ve
.PP
Returns a \f(CW\*(C`Net::DNS::RR\*(C'\fR object of the appropriate type and
initialized from the string passed by the user.  The format of the
string is that used in zone files, and is compatible with the string
returned by \f(CW\*(C`Net::DNS::RR\->string\*(C'\fR.
.PP
The name and \s-1RR\s0 type are required; all other information is optional.
If omitted, the \s-1TTL\s0 defaults to 0 and the \s-1RR\s0 class defaults to \s-1IN\s0.
Omitting the optional fields is useful for creating the empty \s-1RDATA\s0
sections required for certain dynamic update operations.  See the
\&\f(CW\*(C`Net::DNS::Update\*(C'\fR manual page for additional examples.
.PP
All names must be fully qualified.  The trailing dot (.) is optional.
.SS "new (from hash)"
.IX Subsection "new (from hash)"
.Vb 7
\& $rr = Net::DNS::RR\->new(
\&         name    => "foo.example.com",
\&         ttl     => 86400,
\&         class   => "IN",
\&         type    => "A",
\&         address => "10.1.2.3",
\& );
\&
\& $rr = Net::DNS::RR\->new(
\&         name => "foo.example.com",
\&         type => "A",
\& );
.Ve
.PP
Returns an \s-1RR\s0 object of the appropriate type, or a \f(CW\*(C`Net::DNS::RR\*(C'\fR
object if the type isn't implemented.  See the manual pages for
each \s-1RR\s0 type to see what fields the type requires.
.PP
The \f(CW\*(C`Name\*(C'\fR and \f(CW\*(C`Type\*(C'\fR fields are required; all others are optional.
If omitted, \f(CW\*(C`TTL\*(C'\fR defaults to 0 and \f(CW\*(C`Class\*(C'\fR defaults to \s-1IN\s0.  Omitting
the optional fields is useful for creating the empty \s-1RDATA\s0 sections
required for certain dynamic update operations.
.PP
The fields are case-insensitive, but starting each with uppercase
is recommended.
.SS "decode"
.IX Subsection "decode"
.Vb 1
\&    ($rrobj, $offset) = Net::DNS::RR\->decode(\e$data, $offset);
.Ve
.PP
Decodes a \s-1DNS\s0 resource record at the specified location within a \s-1DNS\s0 packet.
The first argument is a reference to the packet data.
The second argument is the offset within the packet where the resource record begins.
.PP
Returns a Net::DNS::RR object and the offset of the next location in the packet.
.PP
Decoding is aborted if the object could not be created (e.g., corrupt or insufficient data).
.SS "print"
.IX Subsection "print"
.Vb 1
\&    $rr\->print;
.Ve
.PP
Prints the record to the standard output.  Calls the \fBstring\fR method
to get the \s-1RR\s0's string representation.
.SS "string"
.IX Subsection "string"
.Vb 1
\&    print $rr\->string, "\en";
.Ve
.PP
Returns a string representation of the \s-1RR\s0.  Calls the \fBrdatastr\fR
method to get the RR-specific data. Domain names arereturned in
\&\s-1RFC1035\s0 format, i.e. all non letter, digit, hyphen characters are
represented as \eDDD. Besides, all domain names are expanded to fully
qualified domain names, with trailing dot.  This is in contrast to
accessor methods of individual data elements in \s-1RR\s0 objects, like
\&\fBname\fR, which will not return the trailing dot.
.SS "rdatastr"
.IX Subsection "rdatastr"
.Vb 1
\&    $s = $rr\->rdatastr;
.Ve
.PP
Returns a string containing RR-specific data.  Subclasses will need
to implement this method.
.SS "name"
.IX Subsection "name"
.Vb 1
\&    $name = $rr\->name;
.Ve
.PP
Returns the record's domain name.
.SS "type"
.IX Subsection "type"
.Vb 1
\&    $type = $rr\->type;
.Ve
.PP
Returns the record's type.
.SS "class"
.IX Subsection "class"
.Vb 1
\&    $class = $rr\->class;
.Ve
.PP
Returns the record's class.
.SS "ttl"
.IX Subsection "ttl"
.Vb 1
\&    $ttl = $rr\->ttl;
.Ve
.PP
Returns the record's time-to-live (\s-1TTL\s0).
.SS "rdlength"
.IX Subsection "rdlength"
.Vb 1
\&    $rdlength = $rr\->rdlength;
.Ve
.PP
Returns the length of the record's data section.
.SS "rdata"
.IX Subsection "rdata"
.Vb 1
\&    $rdata = $rr\->rdata
.Ve
.PP
Returns the record's data section as binary data.
.SH "Sorting of RR arrays"
.IX Header "Sorting of RR arrays"
As of version 0.55 there is functionality to help you sort \s-1RR\s0
arrays. The sorting is done by \fINet::DNS::rrsort()\fR, see the
Net::DNS documentation. This package provides class methods to set
the sorting functions used for a particular \s-1RR\s0 based on a particular
attribute.
.SS "set_rrsort_func"
.IX Subsection "set_rrsort_func"
Net::DNS::RR::SRV\->set_rrsort_func(\*(L"priority\*(R",
			       sub {
				   my ($a,$b)=($Net::DNS::a,$Net::DNS::b);
				   \f(CW$a\fR\->priority <=> \f(CW$b\fR\->priority
				   ||
				   \f(CW$b\fR\->weight <=> \f(CW$a\fR\->weight
                     }
.PP
Net::DNS::RR::SRV\->set_rrsort_func(\*(L"default_sort\*(R",
			       sub {
				   my ($a,$b)=($Net::DNS::a,$Net::DNS::b);
				   \f(CW$a\fR\->priority <=> \f(CW$b\fR\->priority
				   ||
				   \f(CW$b\fR\->weight <=> \f(CW$a\fR\->weight
                     }
.PP
set_rrsort_func needs to be called as a class method. The first
argument is the attribute name on which the sorting will need to take
place. If you specify \*(L"default_sort\*(R" than that is the sort algorithm
that will be used in the case that \fIrrsort()\fR is called without an \s-1RR\s0
attribute as argument.
.PP
The second argument is a reference to a function that uses the
variables \f(CW$a\fR and \f(CW$b\fR global to the \f(CW\*(C`from Net::DNS\*(C'\fR(!!)package for the
sorting. During the sorting \f(CW$a\fR and \f(CW$b\fR will contain references to
objects from the class you called the set_prop_sort from. In other
words, you can rest assured that the above sorting function will only
get Net::DNS::RR::SRV objects.
.PP
The above example is the sorting function that actually is implemented in
\&\s-1SRV\s0.
.SH "BUGS"
.IX Header "BUGS"
This version of \f(CW\*(C`Net::DNS::RR\*(C'\fR does little sanity checking on user-created
\&\s-1RR\s0 objects.
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (c)1997\-2002 Michael Fuhr.
.PP
Portions Copyright (c)2002\-2004 Chris Reinhardt.
.PP
Portions Copyright (c)2005\-2007 Olaf Kolkman
.PP
Portions Copyright (c)2007 Dick Franks
.PP
All rights reserved.
.PP
This program is free software; you may redistribute it and/or
modify it under the same terms as Perl itself.
.PP
\&\s-1EDNS0\s0 extensions by Olaf Kolkman.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
perl, Net::DNS, Net::DNS::Resolver, Net::DNS::Packet,
Net::DNS::Update, Net::DNS::Header, Net::DNS::Question,
\&\s-1RFC\s0 1035 Section 4.1.3
