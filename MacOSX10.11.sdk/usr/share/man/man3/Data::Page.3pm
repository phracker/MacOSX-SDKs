.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Data::Page 3"
.TH Data::Page 3 "2015-08-22" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Data::Page \- help when paging through sets of results
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use Data::Page;
\&
\&  my $page = Data::Page\->new();
\&  $page\->total_entries($total_entries);
\&  $page\->entries_per_page($entries_per_page);
\&  $page\->current_page($current_page);
\&
\&  print "         First page: ", $page\->first_page, "\en";
\&  print "          Last page: ", $page\->last_page, "\en";
\&  print "First entry on page: ", $page\->first, "\en";
\&  print " Last entry on page: ", $page\->last, "\en";
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
When searching through large amounts of data, it is often the case
that a result set is returned that is larger than we want to display
on one page. This results in wanting to page through various pages of
data. The maths behind this is unfortunately fiddly, hence this
module.
.PP
The main concept is that you pass in the number of total entries, the
number of entries per page, and the current page number. You can then
call methods to find out how many pages of information there are, and
what number the first and last entries on the current page really are.
.PP
For example, say we wished to page through the integers from 1 to 100
with 20 entries per page. The first page would consist of 1\-20, the
second page from 21\-40, the third page from 41\-60, the fourth page
from 61\-80 and the fifth page from 81\-100. This module would help you
work this out.
.SH "METHODS"
.IX Header "METHODS"
.SS "new"
.IX Subsection "new"
This is the constructor, which takes no arguments.
.PP
.Vb 1
\&  my $page = Data::Page\->new();
.Ve
.PP
There is also an old, deprecated constructor, which currently takes
two mandatory arguments, the total number of entries and the number of
entries per page. It also optionally takes the current page number:
.PP
.Vb 1
\&  my $page = Data::Page\->new($total_entries, $entries_per_page, $current_page);
.Ve
.SS "total_entries"
.IX Subsection "total_entries"
This method get or sets the total number of entries:
.PP
.Vb 1
\&  print "Entries:", $page\->total_entries, "\en";
.Ve
.SS "entries_per_page"
.IX Subsection "entries_per_page"
This method gets or sets the total number of entries per page (which
defaults to 10):
.PP
.Vb 1
\&  print "Per page:", $page\->entries_per_page, "\en";
.Ve
.SS "current_page"
.IX Subsection "current_page"
This method gets or sets the current page number (which defaults to 1):
.PP
.Vb 1
\&  print "Page: ", $page\->current_page, "\en";
.Ve
.SS "entries_on_this_page"
.IX Subsection "entries_on_this_page"
This methods returns the number of entries on the current page:
.PP
.Vb 1
\&  print "There are ", $page\->entries_on_this_page, " entries displayed\en";
.Ve
.SS "first_page"
.IX Subsection "first_page"
This method returns the first page. This is put in for reasons of
symmetry with last_page, as it always returns 1:
.PP
.Vb 1
\&  print "Pages range from: ", $page\->first_page, "\en";
.Ve
.SS "last_page"
.IX Subsection "last_page"
This method returns the total number of pages of information:
.PP
.Vb 1
\&  print "Pages range to: ", $page\->last_page, "\en";
.Ve
.SS "first"
.IX Subsection "first"
This method returns the number of the first entry on the current page:
.PP
.Vb 1
\&  print "Showing entries from: ", $page\->first, "\en";
.Ve
.SS "last"
.IX Subsection "last"
This method returns the number of the last entry on the current page:
.PP
.Vb 1
\&  print "Showing entries to: ", $page\->last, "\en";
.Ve
.SS "previous_page"
.IX Subsection "previous_page"
This method returns the previous page number, if one exists. Otherwise
it returns undefined:
.PP
.Vb 3
\&  if ($page\->previous_page) {
\&    print "Previous page number: ", $page\->previous_page, "\en";
\&  }
.Ve
.SS "next_page"
.IX Subsection "next_page"
This method returns the next page number, if one exists. Otherwise
it returns undefined:
.PP
.Vb 3
\&  if ($page\->next_page) {
\&    print "Next page number: ", $page\->next_page, "\en";
\&  }
.Ve
.SS "splice"
.IX Subsection "splice"
This method takes in a listref, and returns only the values which are
on the current page:
.PP
.Vb 1
\&  @visible_holidays = $page\->splice(\e@holidays);
.Ve
.SS "skipped"
.IX Subsection "skipped"
This method is useful paging through data in a database using \s-1SQL
LIMIT\s0 clauses. It is simply \f(CW$page\fR\->first \- 1:
.PP
.Vb 4
\&  $sth = $dbh\->prepare(
\&    q{SELECT * FROM table ORDER BY rec_date LIMIT ?, ?}
\&  );
\&  $sth\->execute($page\->skipped, $page\->entries_per_page);
.Ve
.SS "change_entries_per_page"
.IX Subsection "change_entries_per_page"
This method changes the number of entries per page and the current page number
such that the first item on the current page will be present on the new page.
.PP
.Vb 6
\& $page\->total_entries(50);
\& $page\->entries_per_page(20);
\& $page\->current_page(3);
\& print $page\->first; # 41
\& $page\->change_entries_per_page(30);
\& print $page\->current_page; # 2 \- the page that item 41 will show in
.Ve
.SH "NOTES"
.IX Header "NOTES"
It has been said before that this code is \*(L"too simple\*(R" for \s-1CPAN,\s0 but I
must disagree. I have seen people write this kind of code over and
over again and they always get it wrong. Perhaps now they will spend
more time getting the rest of their code right...
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Related modules which may be of interest: Data::Pageset,
Data::Page::Tied, Data::SpreadPagination.
.SH "AUTHOR"
.IX Header "AUTHOR"
Based on code originally by Leo Lapworth, with many changes added by
by Leon Brocard <acme@astray.com>.
.SH "CONTRIBUTORS"
.IX Header "CONTRIBUTORS"
James Laver (\s-1ELPENGUIN\s0)
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (C) 2000\-9, Leon Brocard
.SH "LICENSE"
.IX Header "LICENSE"
This module is free software; you can redistribute it or modify it
under the same terms as Perl itself.
