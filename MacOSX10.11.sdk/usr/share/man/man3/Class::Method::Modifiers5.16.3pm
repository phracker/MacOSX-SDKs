.\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Class::Method::Modifiers 3"
.TH Class::Method::Modifiers 3 "2012-10-21" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Class::Method::Modifiers \- provides Moose\-like method modifiers
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 3
\&    package Child;
\&    use parent \*(AqParent\*(Aq;
\&    use Class::Method::Modifiers;
\&
\&    sub new_method { }
\&
\&    before \*(Aqold_method\*(Aq => sub {
\&        carp "old_method is deprecated, use new_method";
\&    };
\&
\&    around \*(Aqother_method\*(Aq => sub {
\&        my $orig = shift;
\&        my $ret = $orig\->(@_);
\&        return $ret =~ /\ed/ ? $ret : lc $ret;
\&    };
\&
\&    after \*(Aqprivate\*(Aq, \*(Aqprotected\*(Aq => sub {
\&        debug "finished calling a dangerous method";
\&    };
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Method modifiers are a convenient feature from the \s-1CLOS\s0 (Common Lisp Object
System) world.
.PP
In its most basic form, a method modifier is just a method that calls
\&\f(CW\*(C`$self\->SUPER::foo(@_)\*(C'\fR. I for one have trouble remembering that exact
invocation, so my classes seldom re-dispatch to their base classes. Very bad!
.PP
\&\f(CW\*(C`Class::Method::Modifiers\*(C'\fR provides three modifiers: \f(CW\*(C`before\*(C'\fR, \f(CW\*(C`around\*(C'\fR, and
\&\f(CW\*(C`after\*(C'\fR. \f(CW\*(C`before\*(C'\fR and \f(CW\*(C`after\*(C'\fR are run just before and after the method they
modify, but can not really affect that original method. \f(CW\*(C`around\*(C'\fR is run in
place of the original method, with a hook to easily call that original method.
See the \f(CW\*(C`MODIFIERS\*(C'\fR section for more details on how the particular modifiers
work.
.PP
One clear benefit of using \f(CW\*(C`Class::Method::Modifiers\*(C'\fR is that you can define
multiple modifiers in a single namespace. These separate modifiers don't need
to know about each other. This makes top-down design easy. Have a base class
that provides the skeleton methods of each operation, and have plugins modify
those methods to flesh out the specifics.
.PP
Parent classes need not know about \f(CW\*(C`Class::Method::Modifiers\*(C'\fR. This means you
should be able to modify methods in \fIany\fR subclass. See
Term::VT102::ZeroBased for an example of subclassing with \s-1CMM\s0.
.PP
In short, \f(CW\*(C`Class::Method::Modifiers\*(C'\fR solves the problem of making sure you
call \f(CW\*(C`$self\->SUPER::foo(@_)\*(C'\fR, and provides a cleaner interface for it.
.PP
As of version 1.00, \f(CW\*(C`Class::Method::Modifiers\*(C'\fR is faster in some cases than
Moose. See \f(CW\*(C`benchmark/method_modifiers.pl\*(C'\fR in the Moose distribution.
.SH "MODIFIERS"
.IX Header "MODIFIERS"
.SS "before method(s) => sub { ... }"
.IX Subsection "before method(s) => sub { ... }"
\&\f(CW\*(C`before\*(C'\fR is called before the method it is modifying. Its return value is
totally ignored. It receives the same \f(CW@_\fR as the the method it is modifying
would have received. You can modify the \f(CW@_\fR the original method will receive
by changing \f(CW$_[0]\fR and friends (or by changing anything inside a reference).
This is a feature!
.SS "after method(s) => sub { ... }"
.IX Subsection "after method(s) => sub { ... }"
\&\f(CW\*(C`after\*(C'\fR is called after the method it is modifying. Its return value is
totally ignored. It receives the same \f(CW@_\fR as the the method it is modifying
received, mostly. The original method can modify \f(CW@_\fR (such as by changing
\&\f(CW$_[0]\fR or references) and \f(CW\*(C`after\*(C'\fR will see the modified version. If you
don't like this behavior, specify both a \f(CW\*(C`before\*(C'\fR and \f(CW\*(C`after\*(C'\fR, and copy the
\&\f(CW@_\fR during \f(CW\*(C`before\*(C'\fR for \f(CW\*(C`after\*(C'\fR to use.
.SS "around method(s) => sub { ... }"
.IX Subsection "around method(s) => sub { ... }"
\&\f(CW\*(C`around\*(C'\fR is called instead of the method it is modifying. The method you're
overriding is passed in as the first argument (called \f(CW$orig\fR by convention).
Watch out for contextual return values of \f(CW$orig\fR.
.PP
You can use \f(CW\*(C`around\*(C'\fR to:
.ie n .IP "Pass $orig a different @_" 4
.el .IP "Pass \f(CW$orig\fR a different \f(CW@_\fR" 4
.IX Item "Pass $orig a different @_"
.Vb 5
\&    around \*(Aqmethod\*(Aq => sub {
\&        my $orig = shift;
\&        my $self = shift;
\&        $orig\->($self, reverse @_);
\&    };
.Ve
.ie n .IP "Munge the return value of $orig" 4
.el .IP "Munge the return value of \f(CW$orig\fR" 4
.IX Item "Munge the return value of $orig"
.Vb 4
\&    around \*(Aqmethod\*(Aq => sub {
\&        my $orig = shift;
\&        ucfirst $orig\->(@_);
\&    };
.Ve
.ie n .IP "Avoid calling $orig \*(-- conditionally" 4
.el .IP "Avoid calling \f(CW$orig\fR \*(-- conditionally" 4
.IX Item "Avoid calling $orig  conditionally"
.Vb 5
\&    around \*(Aqmethod\*(Aq => sub {
\&        my $orig = shift;
\&        return $orig\->(@_) if time() % 2;
\&        return "no dice, captain";
\&    };
.Ve
.ie n .SS "install_modifier $package, $type, @names, sub { ... }"
.el .SS "install_modifier \f(CW$package\fP, \f(CW$type\fP, \f(CW@names\fP, sub { ... }"
.IX Subsection "install_modifier $package, $type, @names, sub { ... }"
\&\f(CW\*(C`install_modifier\*(C'\fR is like \f(CW\*(C`before\*(C'\fR, \f(CW\*(C`after\*(C'\fR, and \f(CW\*(C`around\*(C'\fR but it also
lets you dynamically select the modifier type ('before', 'after', 'around')
and package that the method modifiers are installed into. This expert-level
function is exported only when you ask for it specifically, or for \f(CW\*(C`:all\*(C'\fR.
.SH "NOTES"
.IX Header "NOTES"
All three normal modifiers; \f(CW\*(C`before\*(C'\fR, \f(CW\*(C`after\*(C'\fR, and \f(CW\*(C`around\*(C'\fR; are exported
into your namespace by default. You may \f(CW\*(C`use Class::Method::Modifiers ()\*(C'\fR to
avoid thrashing your namespace. I may steal more features from Moose, namely
\&\f(CW\*(C`super\*(C'\fR, \f(CW\*(C`override\*(C'\fR, \f(CW\*(C`inner\*(C'\fR, \f(CW\*(C`augment\*(C'\fR, and whatever the Moose folks
come up with next.
.PP
Note that the syntax and semantics for these modifiers is directly borrowed
from Moose (the implementations, however, are not).
.PP
Class::Trigger shares a few similarities with \f(CW\*(C`Class::Method::Modifiers\*(C'\fR,
and they even have some overlap in purpose \*(-- both can be used to implement
highly pluggable applications. The difference is that Class::Trigger
provides a mechanism for easily letting parent classes to invoke hooks defined
by other code. \f(CW\*(C`Class::Method::Modifiers\*(C'\fR provides a way of
overriding/augmenting methods safely, and the parent class need not know about
it.
.SH "CAVEATS"
.IX Header "CAVEATS"
It is erroneous to modify a method that doesn't exist in your class's
inheritance hierarchy. If this occurs, an exception will be thrown when
the modifier is defined.
.PP
It doesn't yet play well with \f(CW\*(C`caller\*(C'\fR. There are some todo tests for this.
Don't get your hopes up though!
.SH "VERSION"
.IX Header "VERSION"
This module was bumped to 1.00 following a complete reimplementation, to
indicate breaking backwards compatibility. The \*(L"guard\*(R" modifier was removed,
and the internals are completely different.
.PP
The new version is a few times faster with half the code. It's now even faster
than Moose.
.PP
Any code that just used modifiers should not change in behavior, except to
become more correct. And, of course, faster. :)
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Class::Method::Modifiers::Fast
Moose, Class::Trigger, Class::MOP::Method::Wrapped, MRO::Compat,
\&\s-1CLOS\s0
.SH "AUTHOR"
.IX Header "AUTHOR"
Shawn M Moore, \f(CW\*(C`sartak@gmail.com\*(C'\fR
.SH "ACKNOWLEDGEMENTS"
.IX Header "ACKNOWLEDGEMENTS"
Thanks to Stevan Little for Moose, I would never have known about
method modifiers otherwise.
.PP
Thanks to Matt Trout and Stevan Little for their advice.
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright 2007\-2009 Shawn M Moore.
.PP
This program is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.
