.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "String 3"
.TH String 3 "2005-12-05" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
IO::String \- Emulate file interface for in\-core strings
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 4
\& use IO::String;
\& $io = IO::String\->new;
\& $io = IO::String\->new($var);
\& tie *IO, \*(AqIO::String\*(Aq;
\&
\& # read data
\& <$io>;
\& $io\->getline;
\& read($io, $buf, 100);
\&
\& # write data
\& print $io "string\en";
\& $io\->print(@data);
\& syswrite($io, $buf, 100);
\&
\& select $io;
\& printf "Some text %s\en", $str;
\&
\& # seek
\& $pos = $io\->getpos;
\& $io\->setpos(0);        # rewind
\& $io\->seek(\-30, \-1);
\& seek($io, 0, 0);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The \f(CW\*(C`IO::String\*(C'\fR module provides the \f(CW\*(C`IO::File\*(C'\fR interface for in-core
strings.  An \f(CW\*(C`IO::String\*(C'\fR object can be attached to a string, and
makes it possible to use the normal file operations for reading or
writing data, as well as for seeking to various locations of the string.
This is useful when you want to use a library module that only
provides an interface to file handles on data that you have in a string
variable.
.PP
Note that perl\-5.8 and better has built-in support for \*(L"in memory\*(R"
files, which are set up by passing a reference instead of a filename
to the \fIopen()\fR call. The reason for using this module is that it
makes the code backwards compatible with older versions of Perl.
.PP
The \f(CW\*(C`IO::String\*(C'\fR module provides an interface compatible with
\&\f(CW\*(C`IO::File\*(C'\fR as distributed with \fI\s-1IO\-1.20\s0\fR, but the following methods
are not available: new_from_fd, fdopen, format_write,
format_page_number, format_lines_per_page, format_lines_left,
format_name, format_top_name.
.PP
The following methods are specific to the \f(CW\*(C`IO::String\*(C'\fR class:
.ie n .IP "$io = IO::String\->new" 4
.el .IP "\f(CW$io\fR = IO::String\->new" 4
.IX Item "$io = IO::String->new"
.PD 0
.ie n .IP "$io = IO::String\->new( $string )" 4
.el .IP "\f(CW$io\fR = IO::String\->new( \f(CW$string\fR )" 4
.IX Item "$io = IO::String->new( $string )"
.PD
The constructor returns a newly-created \f(CW\*(C`IO::String\*(C'\fR object.  It
takes an optional argument, which is the string to read from or write
into.  If no \f(CW$string\fR argument is given, then an internal buffer
(initially empty) is allocated.
.Sp
The \f(CW\*(C`IO::String\*(C'\fR object returned is tied to itself.  This means
that you can use most Perl I/O built-ins on it too: readline, <>, getc,
print, printf, syswrite, sysread, close.
.ie n .IP "$io\->open" 4
.el .IP "\f(CW$io\fR\->open" 4
.IX Item "$io->open"
.PD 0
.ie n .IP "$io\->open( $string )" 4
.el .IP "\f(CW$io\fR\->open( \f(CW$string\fR )" 4
.IX Item "$io->open( $string )"
.PD
Attaches an existing IO::String object to some other \f(CW$string\fR, or
allocates a new internal buffer (if no argument is given).  The
position is reset to 0.
.ie n .IP "$io\->string_ref" 4
.el .IP "\f(CW$io\fR\->string_ref" 4
.IX Item "$io->string_ref"
Returns a reference to the string that is attached to
the \f(CW\*(C`IO::String\*(C'\fR object.  Most useful when you let the \f(CW\*(C`IO::String\*(C'\fR
create an internal buffer to write into.
.ie n .IP "$io\->pad" 4
.el .IP "\f(CW$io\fR\->pad" 4
.IX Item "$io->pad"
.PD 0
.ie n .IP "$io\->pad( $char )" 4
.el .IP "\f(CW$io\fR\->pad( \f(CW$char\fR )" 4
.IX Item "$io->pad( $char )"
.PD
Specifies the padding to use if
the string is extended by either the \fIseek()\fR or \fItruncate()\fR methods.  It
is a single character and defaults to \*(L"\e0\*(R".
.ie n .IP "$io\->pos" 4
.el .IP "\f(CW$io\fR\->pos" 4
.IX Item "$io->pos"
.PD 0
.ie n .IP "$io\->pos( $newpos )" 4
.el .IP "\f(CW$io\fR\->pos( \f(CW$newpos\fR )" 4
.IX Item "$io->pos( $newpos )"
.PD
Yet another interface for reading and setting the current read/write
position within the string (the normal getpos/setpos/tell/seek
methods are also available).  The \fIpos()\fR method always returns the
old position, and if you pass it an argument it sets the new
position.
.Sp
There is (deliberately) a difference between the \fIsetpos()\fR and \fIseek()\fR
methods in that \fIseek()\fR extends the string (with the specified
padding) if you go to a location past the end, whereas \fIsetpos()\fR
just snaps back to the end.  If \fItruncate()\fR is used to extend the string,
then it works as \fIseek()\fR.
.SH "BUGS"
.IX Header "BUGS"
In Perl versions < 5.6, the \s-1TIEHANDLE\s0 interface was incomplete.
If you use such a Perl, then \fIseek()\fR, \fItell()\fR, \fIeof()\fR, \fIfileno()\fR, \fIbinmode()\fR will
not do anything on an \f(CW\*(C`IO::String\*(C'\fR handle.  See perltie for
details.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
IO::File, IO::Stringy, \*(L"open\*(R" in perlfunc
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright 1998\-2005 Gisle Aas.
.PP
This library is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.
