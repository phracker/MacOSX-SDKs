.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Net::Server::PreFork 3"
.TH Net::Server::PreFork 3 "2013-01-09" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Net::Server::PreFork \- Net::Server personality
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use base qw(Net::Server::PreFork);
\&
\&    sub process_request {
\&        #...code...
\&    }
\&
\&    _\|_PACKAGE_\|_\->run();
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Please read the pod on Net::Server and Net::Server::PreForkSimple
first.  This module is a personality, or extension, or sub class, of
the Net::Server::PreForkSimple class which is a sub class of
Net::Server.  See Net::Server::PreForkSimple.
.PP
This personality binds to one or more ports and then forks
\&\f(CW\*(C`min_servers\*(C'\fR child process.  The server will make sure that at any
given time there are \f(CW\*(C`min_spare_servers\*(C'\fR available to receive a
client request, up to \f(CW\*(C`max_servers\*(C'\fR.  Each of these children will
process up to \f(CW\*(C`max_requests\*(C'\fR client connections.  This type is good
for a heavily hit site, and should scale well for most applications.
(Multi port accept is accomplished using flock to serialize the
children).
.PP
At this time, it does not appear that this module will pass tests on
Win32 systems.  Any ideas or patches for making the tests pass would
be welcome.
.SH "SAMPLE CODE"
.IX Header "SAMPLE CODE"
Please see the sample listed in Net::Server.
.SH "COMMAND LINE ARGUMENTS"
.IX Header "COMMAND LINE ARGUMENTS"
In addition to the command line arguments of the Net::Server base
class and the Net::Server::PreForkSimple parent class,
Net::Server::PreFork contains several other configurable parameters.
You really should also see Net::Server::PreForkSimple.
.PP
.Vb 6
\&    Key                 Value                   Default
\&    min_servers         \ed+                     5
\&    min_spare_servers   \ed+                     2
\&    max_spare_servers   \ed+                     10
\&    max_servers         \ed+                     50
\&    max_requests        \ed+                     1000
\&
\&    serialize           (flock|semaphore
\&                         |pipe|none)            undef
\&    # serialize defaults to flock on multi_port or on Solaris
\&    lock_file           "filename"              File::Temp::tempfile or POSIX::tmpnam
\&
\&    check_for_dead      \ed+                     30
\&    check_for_waiting   \ed+                     10
\&
\&    max_dequeue         \ed+                     undef
\&    check_for_dequeue   \ed+                     undef
\&
\&    child_communication 1                       undef
.Ve
.IP "min_servers" 4
.IX Item "min_servers"
The minimum number of servers to keep running.
.IP "min_spare_servers" 4
.IX Item "min_spare_servers"
The minimum number of servers to have waiting for requests.  Minimum
and maximum numbers should not be set to close to each other or the
server will fork and kill children too often.
.IP "max_spare_servers" 4
.IX Item "max_spare_servers"
The maximum number of servers to have waiting for requests.  See
\&\fImin_spare_servers\fR.
.IP "max_servers" 4
.IX Item "max_servers"
The maximum number of child servers to start.  This does not apply to
dequeue processes.
.IP "check_for_waiting" 4
.IX Item "check_for_waiting"
Seconds to wait before checking to see if we can kill off some waiting
servers.
.IP "check_for_spawn" 4
.IX Item "check_for_spawn"
Seconds between checking to see if we need to spawn more children
.IP "min_child_ttl" 4
.IX Item "min_child_ttl"
Minimum number of seconds between starting children and killing a
child process
.IP "child_communication" 4
.IX Item "child_communication"
Enable child communication to parent via unix sockets.  If set to
true, will let children write to the socket contained in
\&\f(CW$self\fR\->{'server'}\->{'parent_sock'}.  The parent will be notified
through child_is_talking_hook where the first argument is the socket
to the child.  The child's socket is stored in
\&\f(CW$self\fR\->{'server'}\->{'children'}\->{$child_pid}\->{'sock'}.
.IP "serialize" 4
.IX Item "serialize"
See the documentation under Net::Server::PreForkSimple.
.SH "CONFIGURATION FILE"
.IX Header "CONFIGURATION FILE"
\&\f(CW\*(C`Net::Server::PreFork\*(C'\fR allows for the use of a configuration file to
read in server parameters.  The format of this conf file is simple key
value pairs.  Comments and white space are ignored.
.PP
.Vb 1
\&    #\-\-\-\-\-\-\-\-\-\-\-\-\-\- file test.conf \-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&
\&    ### server information
\&    min_servers   20
\&    max_servers   80
\&    min_spare_servers 10
\&    min_spare_servers 15
\&
\&    max_requests  1000
\&
\&    ### user and group to become
\&    user        somebody
\&    group       everybody
\&
\&    ### logging ?
\&    log_file    /var/log/server.log
\&    log_level   3
\&    pid_file    /tmp/server.pid
\&
\&    ### access control
\&    allow       .+\e.(net|com)
\&    allow       domain\e.com
\&    deny        a.+
\&
\&    ### background the process?
\&    background  1
\&
\&    ### ports to bind
\&    host        127.0.0.1
\&    port        localhost:20204
\&    port        20205
\&
\&    ### reverse lookups ?
\&    # reverse_lookups on
\&
\&    ### enable child communication ?
\&    # child_communication
\&
\&    #\-\-\-\-\-\-\-\-\-\-\-\-\-\- file test.conf \-\-\-\-\-\-\-\-\-\-\-\-\-\-
.Ve
.SH "PROCESS FLOW"
.IX Header "PROCESS FLOW"
Process flow follows Net::Server until the loop phase.  At this point
\&\f(CW\*(C`min_servers\*(C'\fR are forked and wait for connections.  When a child
accepts a connection, finishs processing a client, or exits, it relays
that information to the parent, which keeps track and makes sure there
are enough children to fulfill \f(CW\*(C`min_servers\*(C'\fR, \f(CW\*(C`min_spare_servers\*(C'\fR,
\&\f(CW\*(C`max_spare_servers\*(C'\fR, and \f(CW\*(C`max_servers\*(C'\fR.
.SH "HOOKS"
.IX Header "HOOKS"
The PreFork server has the following hooks in addition to the hooks
provided by PreForkSimple.  See Net::Server::PreForkSimple.
.ie n .IP """$self\->run_n_children_hook()""" 4
.el .IP "\f(CW$self\->run_n_children_hook()\fR" 4
.IX Item "$self->run_n_children_hook()"
This hook occurs at the top of run_n_children which is called each
time the server goes to start more child processes.  This gives the
parent to do a little of its own accountting (as desired).  Idea for
this hook came from James FitzGibbon.
.ie n .IP """$self\->parent_read_hook()""" 4
.el .IP "\f(CW$self\->parent_read_hook()\fR" 4
.IX Item "$self->parent_read_hook()"
This hook occurs any time that the parent reads information from the
child.  The line from the child is sent as an argument.
.ie n .IP """$self\->child_is_talking_hook()""" 4
.el .IP "\f(CW$self\->child_is_talking_hook()\fR" 4
.IX Item "$self->child_is_talking_hook()"
This hook occurs if child_communication is true and the child has
written to \f(CW$self\fR\->{'server'}\->{'parent_sock'}.  The first argument
will be the open socket to the child.
.ie n .IP """$self\->idle_loop_hook()""" 4
.el .IP "\f(CW$self\->idle_loop_hook()\fR" 4
.IX Item "$self->idle_loop_hook()"
This hook is called in every pass through the main process wait loop,
every \f(CW\*(C`check_for_waiting\*(C'\fR seconds.  The first argument is a reference
to an array of file descriptors that can be read at the moment.
.SH "HOT DEPLOY"
.IX Header "HOT DEPLOY"
Since version 2.000, the PreFork server has accepted the \s-1TTIN\s0 and \s-1TTOU\s0
signals.  When a \s-1TTIN\s0 is received, the min and max_servers are
increased by 1.  If a \s-1TTOU\s0 signal is received the min max_servers are
decreased by 1.  This allows for adjusting the number of handling
processes without having to restart the server.
.SH "BUGS"
.IX Header "BUGS"
Tests don't seem to work on Win32.  Any ideas or patches would be
welcome.
.SH "TO DO"
.IX Header "TO DO"
See Net::Server
.SH "AUTHOR"
.IX Header "AUTHOR"
Paul T. Seamons paul@seamons.com
.SH "THANKS"
.IX Header "THANKS"
See Net::Server
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Please see also
Net::Server::Fork,
Net::Server::INET,
Net::Server::PreForkSimple,
Net::Server::MultiType,
Net::Server::Single
Net::Server::SIG
Net::Server::Daemonize
Net::Server::Proto
