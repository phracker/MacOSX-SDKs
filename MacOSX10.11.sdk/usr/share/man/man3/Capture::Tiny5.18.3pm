.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Capture::Tiny 3"
.TH Capture::Tiny 3 "2013-10-20" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Capture::Tiny \- Capture STDOUT and STDERR from Perl, XS or external programs
.SH "VERSION"
.IX Header "VERSION"
version 0.23
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&   use Capture::Tiny \*(Aq:all\*(Aq;
\& 
\&   # capture from external command
\& 
\&   ($stdout, $stderr, $exit) = capture {
\&     system( $cmd, @args );
\&   };
\& 
\&   # capture from arbitrary code (Perl or external)
\& 
\&   ($stdout, $stderr, @result) = capture {
\&     # your code here
\&   };
\& 
\&   # capture partial or merged output
\& 
\&   $stdout = capture_stdout { ... };
\&   $stderr = capture_stderr { ... };
\&   $merged = capture_merged { ... };
\& 
\&   # tee output
\& 
\&   ($stdout, $stderr) = tee {
\&     # your code here
\&   };
\& 
\&   $stdout = tee_stdout { ... };
\&   $stderr = tee_stderr { ... };
\&   $merged = tee_merged { ... };
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Capture::Tiny provides a simple, portable way to capture almost anything sent
to \s-1STDOUT\s0 or \s-1STDERR,\s0 regardless of whether it comes from Perl, from \s-1XS\s0 code or
from an external program.  Optionally, output can be teed so that it is
captured while being passed through to the original filehandles.  Yes, it even
works on Windows (usually).  Stop guessing which of a dozen capturing modules
to use in any particular situation and just use this one.
.SH "USAGE"
.IX Header "USAGE"
The following functions are available.  None are exported by default.
.SS "capture"
.IX Subsection "capture"
.Vb 2
\&   ($stdout, $stderr, @result) = capture \e&code;
\&   $stdout = capture \e&code;
.Ve
.PP
The \f(CW\*(C`capture\*(C'\fR function takes a code reference and returns what is sent to
\&\s-1STDOUT\s0 and \s-1STDERR\s0 as well as any return values from the code reference.  In
scalar context, it returns only \s-1STDOUT. \s0 If no output was received for a
filehandle, it returns an empty string for that filehandle.  Regardless of calling
context, all output is captured \*(-- nothing is passed to the existing filehandles.
.PP
It is prototyped to take a subroutine reference as an argument. Thus, it
can be called in block form:
.PP
.Vb 3
\&   ($stdout, $stderr) = capture {
\&     # your code here ...
\&   };
.Ve
.PP
Note that the coderef is evaluated in list context.  If you wish to force
scalar context on the return value, you must use the \f(CW\*(C`scalar\*(C'\fR keyword.
.PP
.Vb 4
\&   ($stdout, $stderr, $count) = capture {
\&     my @list = qw/one two three/;
\&     return scalar @list; # $count will be 3
\&   };
.Ve
.PP
Also note that within the coderef, the \f(CW@_\fR variable will be empty.  So don't
use arguments from a surrounding subroutine without copying them to an array
first:
.PP
.Vb 4
\&   sub wont_work {
\&     my ($stdout, $stderr) = capture { do_stuff( @_ ) };    # WRONG
\&     ...
\&   }
\& 
\&   sub will_work {
\&     my @args = @_;
\&     my ($stdout, $stderr) = capture { do_stuff( @args ) }; # RIGHT
\&     ...
\&   }
.Ve
.PP
Captures are normally done to an anonymous temporary filehandle.  To
capture via a named file (e.g. to externally monitor a long-running capture),
provide custom filehandles as a trailing list of option pairs:
.PP
.Vb 3
\&   my $out_fh = IO::File\->new("out.txt", "w+");
\&   my $err_fh = IO::File\->new("out.txt", "w+");
\&   capture { ... } stdout => $out_fh, stderr => $err_fh;
.Ve
.PP
The filehandles must be read/write and seekable.  Modifying the files or
filehandles during a capture operation will give unpredictable results.
Existing \s-1IO\s0 layers on them may be changed by the capture.
.PP
When called in void context, \f(CW\*(C`capture\*(C'\fR saves memory and time by
not reading back from the capture handles.
.SS "capture_stdout"
.IX Subsection "capture_stdout"
.Vb 2
\&   ($stdout, @result) = capture_stdout \e&code;
\&   $stdout = capture_stdout \e&code;
.Ve
.PP
The \f(CW\*(C`capture_stdout\*(C'\fR function works just like \f(CW\*(C`capture\*(C'\fR except only
\&\s-1STDOUT\s0 is captured.  \s-1STDERR\s0 is not captured.
.SS "capture_stderr"
.IX Subsection "capture_stderr"
.Vb 2
\&   ($stderr, @result) = capture_stderr \e&code;
\&   $stderr = capture_stderr \e&code;
.Ve
.PP
The \f(CW\*(C`capture_stderr\*(C'\fR function works just like \f(CW\*(C`capture\*(C'\fR except only
\&\s-1STDERR\s0 is captured.  \s-1STDOUT\s0 is not captured.
.SS "capture_merged"
.IX Subsection "capture_merged"
.Vb 2
\&   ($merged, @result) = capture_merged \e&code;
\&   $merged = capture_merged \e&code;
.Ve
.PP
The \f(CW\*(C`capture_merged\*(C'\fR function works just like \f(CW\*(C`capture\*(C'\fR except \s-1STDOUT\s0 and
\&\s-1STDERR\s0 are merged. (Technically, \s-1STDERR\s0 is redirected to the same capturing
handle as \s-1STDOUT\s0 before executing the function.)
.PP
Caution: \s-1STDOUT\s0 and \s-1STDERR\s0 output in the merged result are not guaranteed to be
properly ordered due to buffering.
.SS "tee"
.IX Subsection "tee"
.Vb 2
\&   ($stdout, $stderr, @result) = tee \e&code;
\&   $stdout = tee \e&code;
.Ve
.PP
The \f(CW\*(C`tee\*(C'\fR function works just like \f(CW\*(C`capture\*(C'\fR, except that output is captured
as well as passed on to the original \s-1STDOUT\s0 and \s-1STDERR.\s0
.PP
When called in void context, \f(CW\*(C`tee\*(C'\fR saves memory and time by
not reading back from the capture handles, except when the
original \s-1STDOUT OR STDERR\s0 were tied or opened to a scalar
handle.
.SS "tee_stdout"
.IX Subsection "tee_stdout"
.Vb 2
\&   ($stdout, @result) = tee_stdout \e&code;
\&   $stdout = tee_stdout \e&code;
.Ve
.PP
The \f(CW\*(C`tee_stdout\*(C'\fR function works just like \f(CW\*(C`tee\*(C'\fR except only
\&\s-1STDOUT\s0 is teed.  \s-1STDERR\s0 is not teed (output goes to \s-1STDERR\s0 as usual).
.SS "tee_stderr"
.IX Subsection "tee_stderr"
.Vb 2
\&   ($stderr, @result) = tee_stderr \e&code;
\&   $stderr = tee_stderr \e&code;
.Ve
.PP
The \f(CW\*(C`tee_stderr\*(C'\fR function works just like \f(CW\*(C`tee\*(C'\fR except only
\&\s-1STDERR\s0 is teed.  \s-1STDOUT\s0 is not teed (output goes to \s-1STDOUT\s0 as usual).
.SS "tee_merged"
.IX Subsection "tee_merged"
.Vb 2
\&   ($merged, @result) = tee_merged \e&code;
\&   $merged = tee_merged \e&code;
.Ve
.PP
The \f(CW\*(C`tee_merged\*(C'\fR function works just like \f(CW\*(C`capture_merged\*(C'\fR except that output
is captured as well as passed on to \s-1STDOUT.\s0
.PP
Caution: \s-1STDOUT\s0 and \s-1STDERR\s0 output in the merged result are not guaranteed to be
properly ordered due to buffering.
.SH "LIMITATIONS"
.IX Header "LIMITATIONS"
.SS "Portability"
.IX Subsection "Portability"
Portability is a goal, not a guarantee.  \f(CW\*(C`tee\*(C'\fR requires fork, except on
Windows where \f(CW\*(C`system(1, @cmd)\*(C'\fR is used instead.  Not tested on any
particularly esoteric platforms yet.  See the
\&\s-1CPAN\s0 Testers Matrix <http://matrix.cpantesters.org/?dist=Capture-Tiny>
for test result by platform.
.SS "PerlIO layers"
.IX Subsection "PerlIO layers"
Capture::Tiny does it's best to preserve PerlIO layers such as ':utf8' or
\&':crlf' when capturing (only for Perl 5.8.1+) .  Layers should be applied to
\&\s-1STDOUT\s0 or \s-1STDERR \s0\fIbefore\fR the call to \f(CW\*(C`capture\*(C'\fR or \f(CW\*(C`tee\*(C'\fR.  This may not work
for tied filehandles (see below).
.SS "Modifying filehandles before capturing"
.IX Subsection "Modifying filehandles before capturing"
Generally speaking, you should do little or no manipulation of the standard \s-1IO\s0
filehandles prior to using Capture::Tiny.  In particular, closing, reopening,
localizing or tying standard filehandles prior to capture may cause a variety of
unexpected, undesirable and/or unreliable behaviors, as described below.
Capture::Tiny does its best to compensate for these situations, but the
results may not be what you desire.
.PP
\&\fBClosed filehandles\fR
.PP
Capture::Tiny will work even if \s-1STDIN, STDOUT\s0 or \s-1STDERR\s0 have been previously
closed.  However, since they will be reopened to capture or tee output, any
code within the captured block that depends on finding them closed will, of
course, not find them to be closed.  If they started closed, Capture::Tiny will
close them again when the capture block finishes.
.PP
Note that this reopening will happen even for \s-1STDIN\s0 or a filehandle not being
captured to ensure that the filehandle used for capture is not opened to file
descriptor 0, as this causes problems on various platforms.
.PP
Prior to Perl 5.12, closed \s-1STDIN\s0 combined with PERL_UNICODE=D leaks filehandles
and also breaks \fItee()\fR for undiagnosed reasons.  So don't do that.
.PP
\&\fBLocalized filehandles\fR
.PP
If code localizes any of Perl's standard filehandles before capturing, the capture
will affect the localized filehandles and not the original ones.  External system
calls are not affected by localizing a filehandle in Perl and will continue
to send output to the original filehandles (which will thus not be captured).
.PP
\&\fBScalar filehandles\fR
.PP
If \s-1STDOUT\s0 or \s-1STDERR\s0 are reopened to scalar filehandles prior to the call to
\&\f(CW\*(C`capture\*(C'\fR or \f(CW\*(C`tee\*(C'\fR, then Capture::Tiny will override the output filehandle for
the duration of the \f(CW\*(C`capture\*(C'\fR or \f(CW\*(C`tee\*(C'\fR call and then, for \f(CW\*(C`tee\*(C'\fR, send captured
output to the output filehandle after the capture is complete.  (Requires Perl
5.8)
.PP
Capture::Tiny attempts to preserve the semantics of \s-1STDIN\s0 opened to a scalar
reference, but note that external processes will not be able to read from such
a handle.  Capture::Tiny tries to ensure that external processes will read from
the null device instead, but this is not guaranteed.
.PP
\&\fBTied output filehandles\fR
.PP
If \s-1STDOUT\s0 or \s-1STDERR\s0 are tied prior to the call to \f(CW\*(C`capture\*(C'\fR or \f(CW\*(C`tee\*(C'\fR, then
Capture::Tiny will attempt to override the tie for the duration of the
\&\f(CW\*(C`capture\*(C'\fR or \f(CW\*(C`tee\*(C'\fR call and then send captured output to the tied filehandle after
the capture is complete.  (Requires Perl 5.8)
.PP
Capture::Tiny may not succeed resending \s-1UTF\-8\s0 encoded data to a tied
\&\s-1STDOUT\s0 or \s-1STDERR\s0 filehandle.  Characters may appear as bytes.  If the tied filehandle
is based on Tie::StdHandle, then Capture::Tiny will attempt to determine
appropriate layers like \f(CW\*(C`:utf8\*(C'\fR from the underlying filehandle and do the right
thing.
.PP
\&\fBTied input filehandle\fR
.PP
Capture::Tiny attempts to preserve the semantics of tied \s-1STDIN,\s0 but this
requires Perl 5.8 and is not entirely predictable.  External processes
will not be able to read from such a handle.
.PP
Unless having \s-1STDIN\s0 tied is crucial, it may be safest to localize \s-1STDIN\s0 when
capturing:
.PP
.Vb 1
\&   my ($out, $err) = do { local *STDIN; capture { ... } };
.Ve
.SS "Modifying filehandles during a capture"
.IX Subsection "Modifying filehandles during a capture"
Attempting to modify \s-1STDIN, STDOUT\s0 or \s-1STDERR \s0\fIduring\fR \f(CW\*(C`capture\*(C'\fR or \f(CW\*(C`tee\*(C'\fR is
almost certainly going to cause problems.  Don't do that.
.SS "No support for Perl 5.8.0"
.IX Subsection "No support for Perl 5.8.0"
It's just too buggy when it comes to layers and \s-1UTF\-8. \s0 Perl 5.8.1 or later
is recommended.
.SS "Limited support for Perl 5.6"
.IX Subsection "Limited support for Perl 5.6"
Perl 5.6 predates PerlIO.  \s-1UTF\-8\s0 data may not be captured correctly.
.SH "ENVIRONMENT"
.IX Header "ENVIRONMENT"
.SS "\s-1PERL_CAPTURE_TINY_TIMEOUT\s0"
.IX Subsection "PERL_CAPTURE_TINY_TIMEOUT"
Capture::Tiny uses subprocesses for \f(CW\*(C`tee\*(C'\fR.  By default, Capture::Tiny will
timeout with an error if the subprocesses are not ready to receive data within
30 seconds (or whatever is the value of \f(CW$Capture::Tiny::TIMEOUT\fR).  An
alternate timeout may be specified by setting the \f(CW\*(C`PERL_CAPTURE_TINY_TIMEOUT\*(C'\fR
environment variable.  Setting it to zero will disable timeouts.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
This module was, inspired by IO::CaptureOutput, which provides
similar functionality without the ability to tee output and with more
complicated code and \s-1API.  \s0IO::CaptureOutput does not handle layers
or most of the unusual cases described in the \*(L"Limitations\*(R" section and
I no longer recommend it.
.PP
There are many other \s-1CPAN\s0 modules that provide some sort of output capture,
albeit with various limitations that make them appropriate only in particular
circumstances.  I'm probably missing some.  The long list is provided to show
why I felt Capture::Tiny was necessary.
.IP "\(bu" 4
IO::Capture
.IP "\(bu" 4
IO::Capture::Extended
.IP "\(bu" 4
IO::CaptureOutput
.IP "\(bu" 4
IPC::Capture
.IP "\(bu" 4
IPC::Cmd
.IP "\(bu" 4
IPC::Open2
.IP "\(bu" 4
IPC::Open3
.IP "\(bu" 4
IPC::Open3::Simple
.IP "\(bu" 4
IPC::Open3::Utils
.IP "\(bu" 4
IPC::Run
.IP "\(bu" 4
IPC::Run::SafeHandles
.IP "\(bu" 4
IPC::Run::Simple
.IP "\(bu" 4
IPC::Run3
.IP "\(bu" 4
IPC::System::Simple
.IP "\(bu" 4
Tee
.IP "\(bu" 4
IO::Tee
.IP "\(bu" 4
File::Tee
.IP "\(bu" 4
Filter::Handle
.IP "\(bu" 4
Tie::STDERR
.IP "\(bu" 4
Tie::STDOUT
.IP "\(bu" 4
Test::Output
.SH "SUPPORT"
.IX Header "SUPPORT"
.SS "Bugs / Feature Requests"
.IX Subsection "Bugs / Feature Requests"
Please report any bugs or feature requests through the issue tracker
at <https://github.com/dagolden/Capture\-Tiny/issues>.
You will be notified automatically of any progress on your issue.
.SS "Source Code"
.IX Subsection "Source Code"
This is open source software.  The code repository is available for
public review and contribution under the terms of the license.
.PP
<https://github.com/dagolden/Capture\-Tiny>
.PP
.Vb 1
\&  git clone https://github.com/dagolden/Capture\-Tiny.git
.Ve
.SH "AUTHOR"
.IX Header "AUTHOR"
David Golden <dagolden@cpan.org>
.SH "CONTRIBUTOR"
.IX Header "CONTRIBUTOR"
Dagfinn Ilmari Mannsa\*oker <ilmari@ilmari.org>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is Copyright (c) 2009 by David Golden.
.PP
This is free software, licensed under:
.PP
.Vb 1
\&  The Apache License, Version 2.0, January 2004
.Ve
