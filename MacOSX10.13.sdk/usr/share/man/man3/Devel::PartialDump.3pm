.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Devel::PartialDump 3pm"
.TH Devel::PartialDump 3pm "2013-11-30" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Devel::PartialDump \- Partial dumping of data structures, optimized for argument printing.
.SH "VERSION"
.IX Header "VERSION"
version 0.17
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use Devel::PartialDump;
\&
\&    sub foo {
\&        print "foo called with args: " . Devel::PartialDump\->new\->dump(@_);
\&    }
\&
\&    use Devel::PartialDump qw(warn);
\&
\&    # warn is overloaded to create a concise dump instead of stringifying $some_bad_data
\&    warn "this made a boo boo: ", $some_bad_data
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module is a data dumper optimized for logging of arbitrary parameters.
.PP
It attempts to truncate overly verbose data, in a way that is hopefully more
useful for diagnostics warnings than
.PP
.Vb 1
\&    warn Dumper(@stuff);
.Ve
.PP
Unlike other data dumping modules there are no attempts at correctness or cross
referencing, this is only meant to provide a slightly deeper look into the data
in question.
.PP
There is a default recursion limit, and a default truncation of long lists, and
the dump is formatted on one line (new lines in strings are escaped), to aid in
readability.
.PP
You can enable it temporarily by importing functions like \f(CW\*(C`warn\*(C'\fR, \f(CW\*(C`croak\*(C'\fR etc
to get more informative errors during development, or even use it as:
.PP
.Vb 1
\&    BEGIN { local $@; eval "use Devel::PartialDump qw(...)" }
.Ve
.PP
to get \s-1DWIM\s0 formatting only if it's installed, without introducing a
dependency.
.SH "SAMPLE OUTPUT"
.IX Header "SAMPLE OUTPUT"
.ie n .IP """foo""" 4
.el .IP "\f(CW``foo''\fR" 4
.IX Item """foo"""
.Vb 1
\&    "foo"
.Ve
.ie n .IP """foo"" => ""bar""" 4
.el .IP "\f(CW``foo'' => ``bar''\fR" 4
.IX Item """foo"" => ""bar"""
.Vb 1
\&    foo: "bar"
.Ve
.ie n .IP """foo => ""bar"", gorch => [ 1, ""bah"" ]""" 4
.el .IP "\f(CWfoo => ``bar'', gorch => [ 1, ``bah'' ]\fR" 4
.IX Item "foo => ""bar"", gorch => [ 1, ""bah"" ]"
.Vb 1
\&    foo: "bar", gorch: [ 1, "bah" ]
.Ve
.ie n .IP """[ { foo => [""bar""] } ]""" 4
.el .IP "\f(CW[ { foo => [``bar''] } ]\fR" 4
.IX Item "[ { foo => [""bar""] } ]"
.Vb 1
\&    [ { foo: ARRAY(0x9b265d0) } ]
.Ve
.ie n .IP """[ 1 .. 10 ]""" 4
.el .IP "\f(CW[ 1 .. 10 ]\fR" 4
.IX Item "[ 1 .. 10 ]"
.Vb 1
\&    [ 1, 2, 3, 4, 5, 6, ... ]
.Ve
.ie n .IP """foo\enbar""" 4
.el .IP "\f(CW``foo\enbar''\fR" 4
.IX Item """foonbar"""
.Vb 1
\&    "foo\enbar"
.Ve
.ie n .IP """""foo"" . chr(1)""" 4
.el .IP "\f(CW``foo'' . chr(1)\fR" 4
.IX Item """foo"" . chr(1)"
.Vb 1
\&    "foo\ex{1}"
.Ve
.SH "ATTRIBUTES"
.IX Header "ATTRIBUTES"
.IP "max_length" 4
.IX Item "max_length"
The maximum character length of the dump.
.Sp
Anything bigger than this will be truncated.
.Sp
Not defined by default.
.IP "max_elements" 4
.IX Item "max_elements"
The maximum number of elements (array elements or pairs in a hash) to print.
.Sp
Defaults to 6.
.IP "max_depth" 4
.IX Item "max_depth"
The maximum level of recursion.
.Sp
Defaults to 2.
.IP "stringify" 4
.IX Item "stringify"
Whether or not to let objects stringify themselves, instead of using
\&\*(L"StrVal\*(R" in overload to avoid side effects.
.Sp
Defaults to false (no overloading).
.IP "pairs" 4
.IX Item "pairs"
Whether or not to autodetect named args as pairs in the main \f(CW\*(C`dump\*(C'\fR function.
If this attribute is true, and the top level value list is even sized, and
every odd element is not a reference, then it will dumped as pairs instead of a
list.
.SH "EXPORTS"
.IX Header "EXPORTS"
All exports are optional, nothing is exported by default.
.PP
This module uses Sub::Exporter, so exports can be renamed, curried, etc.
.IP "warn" 4
.IX Item "warn"
.PD 0
.IP "show" 4
.IX Item "show"
.IP "show_scalar" 4
.IX Item "show_scalar"
.IP "croak" 4
.IX Item "croak"
.IP "carp" 4
.IX Item "carp"
.IP "confess" 4
.IX Item "confess"
.IP "cluck" 4
.IX Item "cluck"
.IP "dump" 4
.IX Item "dump"
.PD
See the various methods for behavior documentation.
.Sp
These methods will use \f(CW$Devel::PartialDump::default_dumper\fR as the invocant if the
first argument is not blessed and \f(CW\*(C`isa\*(C'\fR Devel::PartialDump, so they can be
used as functions too.
.Sp
Particularly \f(CW\*(C`warn\*(C'\fR can be used as a drop in replacement for the built in
warn:
.Sp
.Vb 1
\&    warn "blah blah: ", $some_data;
.Ve
.Sp
by importing
.Sp
.Vb 1
\&    use Devel::PartialDump qw(warn);
.Ve
.Sp
\&\f(CW$some_data\fR will be have some of it's data dumped.
.ie n .IP "$default_dumper" 4
.el .IP "\f(CW$default_dumper\fR" 4
.IX Item "$default_dumper"
The default dumper object to use for export style calls.
.Sp
Can be assigned to to alter behavior globally.
.Sp
This is generally useful when using the \f(CW\*(C`warn\*(C'\fR export as a drop in replacement
for \f(CW\*(C`CORE::warn\*(C'\fR.
.SH "METHODS"
.IX Header "METHODS"
.ie n .IP "warn @blah" 4
.el .IP "warn \f(CW@blah\fR" 4
.IX Item "warn @blah"
A wrapper for \f(CW\*(C`dump\*(C'\fR that prints strings plainly.
.ie n .IP "show @blah" 4
.el .IP "show \f(CW@blah\fR" 4
.IX Item "show @blah"
.PD 0
.ie n .IP "show_scalar $x" 4
.el .IP "show_scalar \f(CW$x\fR" 4
.IX Item "show_scalar $x"
.PD
Like \f(CW\*(C`warn\*(C'\fR, but instead of returning the value from \f(CW\*(C`warn\*(C'\fR it returns its
arguments, so it can be used in the middle of an expression.
.Sp
Note that
.Sp
.Vb 1
\&    my $x = show foo();
.Ve
.Sp
will actually evaluate \f(CW\*(C`foo\*(C'\fR in list context, so if you only want to dump a
single element and retain scalar context use
.Sp
.Vb 1
\&    my $x = show_scalar foo();
.Ve
.Sp
which has a prototype of \f(CW\*(C`$\*(C'\fR (as opposed to taking a list).
.Sp
This is similar to the venerable Ingy's fabulous and amazing \s-1XXX\s0 module.
.IP "carp" 4
.IX Item "carp"
.PD 0
.IP "croak" 4
.IX Item "croak"
.IP "confess" 4
.IX Item "confess"
.IP "cluck" 4
.IX Item "cluck"
.PD
Drop in replacements for Carp exports, that format their arguments like
\&\f(CW\*(C`warn\*(C'\fR.
.ie n .IP "dump @stuff" 4
.el .IP "dump \f(CW@stuff\fR" 4
.IX Item "dump @stuff"
Returns a one line, human readable, concise dump of \f(CW@stuff\fR.
.Sp
If called in void context, will \f(CW\*(C`warn\*(C'\fR with the dump.
.Sp
Truncates the dump according to \f(CW\*(C`max_length\*(C'\fR if specified.
.ie n .IP "dump_as_list $depth, @stuff" 4
.el .IP "dump_as_list \f(CW$depth\fR, \f(CW@stuff\fR" 4
.IX Item "dump_as_list $depth, @stuff"
.PD 0
.ie n .IP "dump_as_pairs $depth, @stuff" 4
.el .IP "dump_as_pairs \f(CW$depth\fR, \f(CW@stuff\fR" 4
.IX Item "dump_as_pairs $depth, @stuff"
.PD
Dump \f(CW@stuff\fR using the various formatting functions.
.Sp
Dump as pairs returns comma delimited pairs with \f(CW\*(C`=>\*(C'\fR between the key and the value.
.Sp
Dump as list returns a comma delimited dump of the values.
.ie n .IP "format $depth, $value" 4
.el .IP "format \f(CW$depth\fR, \f(CW$value\fR" 4
.IX Item "format $depth, $value"
.PD 0
.ie n .IP "format_key $depth, $key" 4
.el .IP "format_key \f(CW$depth\fR, \f(CW$key\fR" 4
.IX Item "format_key $depth, $key"
.ie n .IP "format_object $depth, $object" 4
.el .IP "format_object \f(CW$depth\fR, \f(CW$object\fR" 4
.IX Item "format_object $depth, $object"
.ie n .IP "format_ref $depth, $Ref" 4
.el .IP "format_ref \f(CW$depth\fR, \f(CW$Ref\fR" 4
.IX Item "format_ref $depth, $Ref"
.ie n .IP "format_array $depth, $array_ref" 4
.el .IP "format_array \f(CW$depth\fR, \f(CW$array_ref\fR" 4
.IX Item "format_array $depth, $array_ref"
.ie n .IP "format_hash $depth, $hash_ref" 4
.el .IP "format_hash \f(CW$depth\fR, \f(CW$hash_ref\fR" 4
.IX Item "format_hash $depth, $hash_ref"
.ie n .IP "format_undef $depth, undef" 4
.el .IP "format_undef \f(CW$depth\fR, undef" 4
.IX Item "format_undef $depth, undef"
.ie n .IP "format_string $depth, $string" 4
.el .IP "format_string \f(CW$depth\fR, \f(CW$string\fR" 4
.IX Item "format_string $depth, $string"
.ie n .IP "format_number $depth, $number" 4
.el .IP "format_number \f(CW$depth\fR, \f(CW$number\fR" 4
.IX Item "format_number $depth, $number"
.ie n .IP "quote $string" 4
.el .IP "quote \f(CW$string\fR" 4
.IX Item "quote $string"
.PD
The various formatting methods.
.Sp
You can override these to provide a custom format.
.Sp
\&\f(CW\*(C`format_array\*(C'\fR and \f(CW\*(C`format_hash\*(C'\fR recurse with \f(CW\*(C`$depth + 1\*(C'\fR into
\&\f(CW\*(C`dump_as_list\*(C'\fR and \f(CW\*(C`dump_as_pairs\*(C'\fR respectively.
.Sp
\&\f(CW\*(C`format_ref\*(C'\fR delegates to \f(CW\*(C`format_array\*(C'\fR and \f(CW\*(C`format_hash\*(C'\fR and does the
\&\f(CW\*(C`max_depth\*(C'\fR tracking. It will simply stringify the ref if the recursion limit
has been reached.
.SH "AUTHOR"
.IX Header "AUTHOR"
\&\s-1XXXX XXX\s0'\s-1XX \s0(Yuval Kogman) <nothingmuch@woobling.org>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is copyright (c) 2008 by \s-1XXXX XXX\s0'\s-1XX \s0(Yuval Kogman).
.PP
This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.
.SH "CONTRIBUTORS"
.IX Header "CONTRIBUTORS"
.IP "\(bu" 4
David Golden <dagolden@cpan.org>
.IP "\(bu" 4
Florian Ragwitz <rafl@debian.org>
.IP "\(bu" 4
Jesse Luehrs <doy@tozt.net>
.IP "\(bu" 4
Karen Etheridge <ether@cpan.org>
.IP "\(bu" 4
Leo Lapworth <web@web\-teams\-computer.local>
.IP "\(bu" 4
Steven Lee <stevenwh.lee@gmail.com>
