.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "DBIx::Class::Relationship 3"
.TH DBIx::Class::Relationship 3 "2014-01-22" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
DBIx::Class::Relationship \- Inter\-table relationships
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 7
\&  ## Creating relationships
\&  MyApp::Schema::Actor\->has_many(\*(Aqactorroles\*(Aq => \*(AqMyApp::Schema::ActorRole\*(Aq,
\&                                \*(Aqactor\*(Aq);
\&  MyApp::Schema::Role\->has_many(\*(Aqactorroles\*(Aq => \*(AqMyApp::Schema::ActorRole\*(Aq,
\&                                \*(Aqrole\*(Aq);
\&  MyApp::Schema::ActorRole\->belongs_to(\*(Aqrole\*(Aq => \*(AqMyApp::Schema::Role\*(Aq);
\&  MyApp::Schema::ActorRole\->belongs_to(\*(Aqactor\*(Aq => \*(AqMyApp::Schema::Actor\*(Aq);
\&
\&  MyApp::Schema::Role\->many_to_many(\*(Aqactors\*(Aq => \*(Aqactorroles\*(Aq, \*(Aqactor\*(Aq);
\&  MyApp::Schema::Actor\->many_to_many(\*(Aqroles\*(Aq => \*(Aqactorroles\*(Aq, \*(Aqrole\*(Aq);
\&
\&  ## Using relationships
\&  $schema\->resultset(\*(AqActor\*(Aq)\->find({ id => 1})\->roles();
\&  $schema\->resultset(\*(AqRole\*(Aq)\->find({ id => 1 })\->actorroles\->search_related(\*(Aqactor\*(Aq, { Name => \*(AqFred\*(Aq });
\&  $schema\->resultset(\*(AqActor\*(Aq)\->add_to_roles({ Name => \*(AqSherlock Holmes\*(Aq});
.Ve
.PP
See DBIx::Class::Manual::Cookbook for more.
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The word \fIRelationship\fR has a specific meaning in DBIx::Class, see
the definition in the Glossary.
.PP
This class provides methods to set up relationships between the tables
in your database model. Relationships are the most useful and powerful
technique that DBIx::Class provides. To create efficient database queries,
create relationships between any and all tables that have something in
common, for example if you have a table Authors:
.PP
.Vb 4
\&  ID  | Name | Age
\& \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&   1  | Fred | 30
\&   2  | Joe  | 32
.Ve
.PP
and a table Books:
.PP
.Vb 4
\&  ID  | Author | Name
\& \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&   1  |      1 | Rulers of the universe
\&   2  |      1 | Rulers of the galaxy
.Ve
.PP
Then without relationships, the method of getting all books by Fred goes like
this:
.PP
.Vb 2
\& my $fred = $schema\->resultset(\*(AqAuthor\*(Aq)\->find({ Name => \*(AqFred\*(Aq });
\& my $fredsbooks = $schema\->resultset(\*(AqBook\*(Aq)\->search({ Author => $fred\->ID });
.Ve
.PP
With a has_many relationship called \*(L"books\*(R" on Author (see below for details),
we can do this instead:
.PP
.Vb 1
\& my $fredsbooks = $schema\->resultset(\*(AqAuthor\*(Aq)\->find({ Name => \*(AqFred\*(Aq })\->books;
.Ve
.PP
Each relationship sets up an accessor method on the
Result objects that represent the items
of your table. From ResultSet objects,
the relationships can be searched using the \*(L"search_related\*(R" method.
In list context, each returns a list of Result objects for the related class,
in scalar context, a new ResultSet representing the joined tables is
returned. Thus, the calls can be chained to produce complex queries.
Since the database is not actually queried until you attempt to retrieve
the data for an actual item, no time is wasted producing them.
.PP
.Vb 5
\& my $cheapfredbooks = $schema\->resultset(\*(AqAuthor\*(Aq)\->find({
\&   Name => \*(AqFred\*(Aq,
\& })\->books\->search_related(\*(Aqprices\*(Aq, {
\&   Price => { \*(Aq<=\*(Aq => \*(Aq5.00\*(Aq },
\& });
.Ve
.PP
will produce a query something like:
.PP
.Vb 4
\& SELECT * FROM Author me
\& LEFT JOIN Books books ON books.author = me.id
\& LEFT JOIN Prices prices ON prices.book = books.id
\& WHERE prices.Price <= 5.00
.Ve
.PP
all without needing multiple fetches.
.PP
Only the helper methods for setting up standard relationship types
are documented here. For the basic, lower-level methods, and a description
of all the useful *_related methods that you get for free, see
DBIx::Class::Relationship::Base.
.SH "METHODS"
.IX Header "METHODS"
All helper methods are called similar to the following template:
.PP
.Vb 1
\&  _\|_PACKAGE_\|_\->$method_name(\*(Aqrelname\*(Aq, \*(AqForeign::Class\*(Aq, \e%cond|\e@cond|\e&cond?, \e%attrs?);
.Ve
.PP
Both \f(CW\*(C`cond\*(C'\fR and \f(CW\*(C`attrs\*(C'\fR are optional. Pass \f(CW\*(C`undef\*(C'\fR for \f(CW\*(C`cond\*(C'\fR if
you want to use the default value for it, but still want to set \f(CW\*(C`attrs\*(C'\fR.
.PP
See \*(L"condition\*(R" in DBIx::Class::Relationship::Base for full documentation on
definition of the \f(CW\*(C`cond\*(C'\fR argument.
.PP
See \*(L"attributes\*(R" in DBIx::Class::Relationship::Base for documentation on the
attributes that are allowed in the \f(CW\*(C`attrs\*(C'\fR argument.
.SS "belongs_to"
.IX Subsection "belongs_to"
.ie n .IP "Arguments: $accessor_name, $related_class, $our_fk_column|\e%cond|\e@cond|\e$cond?, \e%attrs?" 4
.el .IP "Arguments: \f(CW$accessor_name\fR, \f(CW$related_class\fR, \f(CW$our_fk_column\fR|\e%cond|\e@cond|\e$cond?, \e%attrs?" 4
.IX Item "Arguments: $accessor_name, $related_class, $our_fk_column|%cond|@cond|$cond?, %attrs?"
.PP
Creates a relationship where the calling class stores the foreign
class's primary key in one (or more) of the calling class columns.
This relationship defaults to using \f(CW$accessor_name\fR as the column
name in this class to resolve the join against the primary key from
\&\f(CW$related_class\fR, unless \f(CW$our_fk_column\fR specifies the foreign key column
in this class or \f(CW\*(C`cond\*(C'\fR specifies a reference to a join condition.
.IP "accessor_name" 4
.IX Item "accessor_name"
This argument is the name of the method you can call on a
Result object to retrieve the instance of the foreign
class matching this relationship. This is often called the
\&\f(CW\*(C`relation(ship) name\*(C'\fR.
.Sp
Use this accessor_name in \*(L"join\*(R" in DBIx::Class::ResultSet
or \*(L"prefetch\*(R" in DBIx::Class::ResultSet to join to the foreign table
indicated by this relationship.
.IP "related_class" 4
.IX Item "related_class"
This is the class name of the table referenced by the foreign key in
this class.
.IP "our_fk_column" 4
.IX Item "our_fk_column"
The column name on this class that contains the foreign key.
.Sp
\&\s-1OR\s0
.IP "cond" 4
.IX Item "cond"
A hashref, arrayref or coderef specifying a custom join expression. For
more info see \*(L"condition\*(R" in DBIx::Class::Relationship::Base.
.PP
.Vb 6
\&  # in a Book class (where Author has many Books)
\&  My::DBIC::Schema::Book\->belongs_to(
\&    author =>
\&    \*(AqMy::DBIC::Schema::Author\*(Aq,
\&    \*(Aqauthor_id\*(Aq
\&  );
\&
\&  # OR (same result)
\&  My::DBIC::Schema::Book\->belongs_to(
\&    author =>
\&    \*(AqMy::DBIC::Schema::Author\*(Aq,
\&    { \*(Aqforeign.author_id\*(Aq => \*(Aqself.author_id\*(Aq }
\&  );
\&
\&  # OR (similar result but uglier accessor name)
\&  My::DBIC::Schema::Book\->belongs_to(
\&    author_id =>
\&    \*(AqMy::DBIC::Schema::Author\*(Aq
\&  );
\&
\&  # Usage
\&  my $author_obj = $book\->author; # get author object
\&  $book\->author( $new_author_obj ); # set author object
\&  $book\->author_id(); # get the plain id
\&
\&  # To retrieve the plain id if you used the ugly version:
\&  $book\->get_column(\*(Aqauthor_id\*(Aq);
.Ve
.PP
If some of the foreign key columns are
nullable you probably want to set
the join_type attribute to
\&\f(CW\*(C`left\*(C'\fR explicitly so that \s-1SQL\s0 expressing this relation is composed with
a \f(CW\*(C`LEFT JOIN\*(C'\fR (as opposed to \f(CW\*(C`INNER JOIN\*(C'\fR which is default for
\&\*(L"belongs_to\*(R" relationships). This ensures that relationship traversal
works consistently in all situations. (i.e. resultsets involving
join or
prefetch).
The modified declaration is shown below:
.PP
.Vb 7
\&  # in a Book class (where Author has_many Books)
\&  _\|_PACKAGE_\|_\->belongs_to(
\&    author =>
\&    \*(AqMy::DBIC::Schema::Author\*(Aq,
\&    \*(Aqauthor\*(Aq,
\&    { join_type => \*(Aqleft\*(Aq }
\&  );
.Ve
.PP
Cascading deletes are off by default on a \f(CW\*(C`belongs_to\*(C'\fR
relationship. To turn them on, pass \f(CW\*(C`cascade_delete => 1\*(C'\fR
in the \f(CW$attr\fR hashref.
.PP
By default, \s-1DBIC\s0 will return undef and avoid querying the database if a
\&\f(CW\*(C`belongs_to\*(C'\fR accessor is called when any part of the foreign key \s-1IS NULL.\s0 To
disable this behavior, pass \f(CW\*(C`undef_on_null_fk => 0\*(C'\fR in the \f(CW\*(C`\e%attrs\*(C'\fR
hashref.
.PP
\&\s-1NOTE:\s0 If you are used to Class::DBI relationships, this is the equivalent
of \f(CW\*(C`has_a\*(C'\fR.
.PP
See \*(L"attributes\*(R" in DBIx::Class::Relationship::Base for documentation on relationship
methods and valid relationship attributes. Also see DBIx::Class::ResultSet
for a list of standard resultset attributes
which can be assigned to relationships as well.
.SS "has_many"
.IX Subsection "has_many"
.ie n .IP "Arguments: $accessor_name, $related_class, $their_fk_column|\e%cond|\e@cond|\e&cond?, \e%attrs?" 4
.el .IP "Arguments: \f(CW$accessor_name\fR, \f(CW$related_class\fR, \f(CW$their_fk_column\fR|\e%cond|\e@cond|\e&cond?, \e%attrs?" 4
.IX Item "Arguments: $accessor_name, $related_class, $their_fk_column|%cond|@cond|&cond?, %attrs?"
.PP
Creates a one-to-many relationship where the foreign class refers to
this class's primary key. This relationship refers to zero or more
records in the foreign table (e.g. a \f(CW\*(C`LEFT JOIN\*(C'\fR). This relationship
defaults to using the end of this classes namespace as the foreign key
in \f(CW$related_class\fR to resolve the join, unless \f(CW$their_fk_column\fR
specifies the foreign key column in \f(CW$related_class\fR or \f(CW\*(C`cond\*(C'\fR
specifies a reference to a join condition.
.IP "accessor_name" 4
.IX Item "accessor_name"
This argument is the name of the method you can call on a
Result object to retrieve a resultset of the related
class restricted to the ones related to the result object. In list
context it returns the result objects. This is often called the
\&\f(CW\*(C`relation(ship) name\*(C'\fR.
.Sp
Use this accessor_name in \*(L"join\*(R" in DBIx::Class::ResultSet
or \*(L"prefetch\*(R" in DBIx::Class::ResultSet to join to the foreign table
indicated by this relationship.
.IP "related_class" 4
.IX Item "related_class"
This is the class name of the table which contains a foreign key
column containing \s-1PK\s0 values of this class.
.IP "their_fk_column" 4
.IX Item "their_fk_column"
The column name on the related class that contains the foreign key.
.Sp
\&\s-1OR\s0
.IP "cond" 4
.IX Item "cond"
A hashref, arrayref  or coderef specifying a custom join expression. For
more info see \*(L"condition\*(R" in DBIx::Class::Relationship::Base.
.PP
.Vb 7
\&  # in an Author class (where Author has_many Books)
\&  # assuming related class is storing our PK in "author_id"
\&  My::DBIC::Schema::Author\->has_many(
\&    books =>
\&    \*(AqMy::DBIC::Schema::Book\*(Aq,
\&    \*(Aqauthor_id\*(Aq
\&  );
\&
\&  # OR (same result)
\&  My::DBIC::Schema::Author\->has_many(
\&    books =>
\&    \*(AqMy::DBIC::Schema::Book\*(Aq,
\&    { \*(Aqforeign.author_id\*(Aq => \*(Aqself.id\*(Aq },
\&  );
\&
\&  # OR (similar result, assuming related_class is storing our PK, in "author")
\&  # (the "author" is guessed at from "Author" in the class namespace)
\&  My::DBIC::Schema::Author\->has_many(
\&    books =>
\&    \*(AqMy::DBIC::Schema::Book\*(Aq,
\&  );
\&
\&
\&  # Usage
\&  # resultset of Books belonging to author
\&  my $booklist = $author\->books;
\&
\&  # resultset of Books belonging to author, restricted by author name
\&  my $booklist = $author\->books({
\&    name => { LIKE => \*(Aq%macaroni%\*(Aq },
\&    { prefetch => [qw/book/],
\&  });
\&
\&  # array of Book objects belonging to author
\&  my @book_objs = $author\->books;
\&
\&  # force resultset even in list context
\&  my $books_rs = $author\->books;
\&  ( $books_rs ) = $obj\->books_rs;
\&
\&  # create a new book for this author, the relation fields are auto\-filled
\&  $author\->create_related(\*(Aqbooks\*(Aq, \e%col_data);
\&  # alternative method for the above
\&  $author\->add_to_books(\e%col_data);
.Ve
.PP
Three methods are created when you create a has_many relationship.
The first method is the expected accessor method, \f(CW\*(C`$accessor_name()\*(C'\fR.
The second is almost exactly the same as the accessor method but \*(L"_rs\*(R"
is added to the end of the method name, eg \f(CW\*(C`$accessor_name_rs()\*(C'\fR.
This method works just like the normal accessor, except that it always
returns a resultset, even in list context. The third method, named \f(CW\*(C`add_to_$relname\*(C'\fR, will also be added to your Row items; this allows
you to insert new related items, using the same mechanism as in
\&\*(L"create_related\*(R" in DBIx::Class::Relationship::Base.
.PP
If you delete an object in a class with a \f(CW\*(C`has_many\*(C'\fR relationship, all
the related objects will be deleted as well.  To turn this behaviour off,
pass \f(CW\*(C`cascade_delete => 0\*(C'\fR in the \f(CW$attr\fR hashref.
.PP
The cascaded operations are performed after the requested delete or
update, so if your database has a constraint on the relationship, it
will have deleted/updated the related records or raised an exception
before DBIx::Class gets to perform the cascaded operation.
.PP
If you copy an object in a class with a \f(CW\*(C`has_many\*(C'\fR relationship, all
the related objects will be copied as well. To turn this behaviour off,
pass \f(CW\*(C`cascade_copy => 0\*(C'\fR in the \f(CW$attr\fR hashref. The behaviour
defaults to \f(CW\*(C`cascade_copy => 1\*(C'\fR.
.PP
See \*(L"attributes\*(R" in DBIx::Class::Relationship::Base for documentation on
relationship methods and valid relationship attributes. Also see
DBIx::Class::ResultSet for a list of standard resultset
attributes which can be assigned to
relationships as well.
.SS "might_have"
.IX Subsection "might_have"
.ie n .IP "Arguments: $accessor_name, $related_class, $their_fk_column|\e%cond|\e@cond|\e&cond?, \e%attrs?" 4
.el .IP "Arguments: \f(CW$accessor_name\fR, \f(CW$related_class\fR, \f(CW$their_fk_column\fR|\e%cond|\e@cond|\e&cond?, \e%attrs?" 4
.IX Item "Arguments: $accessor_name, $related_class, $their_fk_column|%cond|@cond|&cond?, %attrs?"
.PP
Creates an optional one-to-one relationship with a class. This relationship
defaults to using \f(CW$accessor_name\fR as the foreign key in \f(CW$related_class\fR to
resolve the join, unless \f(CW$their_fk_column\fR specifies the foreign key
column in \f(CW$related_class\fR or \f(CW\*(C`cond\*(C'\fR specifies a reference to a join
condition.
.IP "accessor_name" 4
.IX Item "accessor_name"
This argument is the name of the method you can call on a
Result object to retrieve the instance of the foreign
class matching this relationship. This is often called the
\&\f(CW\*(C`relation(ship) name\*(C'\fR.
.Sp
Use this accessor_name in \*(L"join\*(R" in DBIx::Class::ResultSet
or \*(L"prefetch\*(R" in DBIx::Class::ResultSet to join to the foreign table
indicated by this relationship.
.IP "related_class" 4
.IX Item "related_class"
This is the class name of the table which contains a foreign key
column containing \s-1PK\s0 values of this class.
.IP "their_fk_column" 4
.IX Item "their_fk_column"
The column name on the related class that contains the foreign key.
.Sp
\&\s-1OR\s0
.IP "cond" 4
.IX Item "cond"
A hashref, arrayref  or coderef specifying a custom join expression. For
more info see \*(L"condition\*(R" in DBIx::Class::Relationship::Base.
.PP
.Vb 6
\&  # Author may have an entry in the pseudonym table
\&  My::DBIC::Schema::Author\->might_have(
\&    pseudonym =>
\&    \*(AqMy::DBIC::Schema::Pseudonym\*(Aq,
\&    \*(Aqauthor_id\*(Aq,
\&  );
\&
\&  # OR (same result, assuming the related_class stores our PK)
\&  My::DBIC::Schema::Author\->might_have(
\&    pseudonym =>
\&    \*(AqMy::DBIC::Schema::Pseudonym\*(Aq,
\&  );
\&
\&  # OR (same result)
\&  My::DBIC::Schema::Author\->might_have(
\&    pseudonym =>
\&    \*(AqMy::DBIC::Schema::Pseudonym\*(Aq,
\&    { \*(Aqforeign.author_id\*(Aq => \*(Aqself.id\*(Aq },
\&  );
\&
\&  # Usage
\&  my $pname = $author\->pseudonym; # to get the Pseudonym object
.Ve
.PP
If you update or delete an object in a class with a \f(CW\*(C`might_have\*(C'\fR
relationship, the related object will be updated or deleted as well. To
turn off this behavior, add \f(CW\*(C`cascade_delete => 0\*(C'\fR to the \f(CW$attr\fR
hashref.
.PP
The cascaded operations are performed after the requested delete or
update, so if your database has a constraint on the relationship, it
will have deleted/updated the related records or raised an exception
before DBIx::Class gets to perform the cascaded operation.
.PP
See \*(L"attributes\*(R" in DBIx::Class::Relationship::Base for documentation on
relationship methods and valid relationship attributes. Also see
DBIx::Class::ResultSet for a list of standard resultset
attributes which can be assigned to
relationships as well.
.PP
Note that if you supply a condition on which to join, and the column in the
current table allows nulls (i.e., has the \f(CW\*(C`is_nullable\*(C'\fR attribute set to a
true value), than \f(CW\*(C`might_have\*(C'\fR will warn about this because it's naughty and
you shouldn't do that. The warning will look something like:
.PP
.Vb 1
\&  "might_have/has_one" must not be on columns with is_nullable set to true (MySchema::SomeClass/key)
.Ve
.PP
If you must be naughty, you can suppress the warning by setting
\&\f(CW\*(C`DBIC_DONT_VALIDATE_RELS\*(C'\fR environment variable to a true value.  Otherwise,
you probably just meant to use \f(CW\*(C`DBIx::Class::Relationship/belongs_to\*(C'\fR.
.SS "has_one"
.IX Subsection "has_one"
.ie n .IP "Arguments: $accessor_name, $related_class, $their_fk_column|\e%cond|\e@cond|\e&cond?, \e%attrs?" 4
.el .IP "Arguments: \f(CW$accessor_name\fR, \f(CW$related_class\fR, \f(CW$their_fk_column\fR|\e%cond|\e@cond|\e&cond?, \e%attrs?" 4
.IX Item "Arguments: $accessor_name, $related_class, $their_fk_column|%cond|@cond|&cond?, %attrs?"
.PP
Creates a one-to-one relationship with a class. This relationship
defaults to using \f(CW$accessor_name\fR as the foreign key in \f(CW$related_class\fR to
resolve the join, unless \f(CW$their_fk_column\fR specifies the foreign key
column in \f(CW$related_class\fR or \f(CW\*(C`cond\*(C'\fR specifies a reference to a join
condition.
.IP "accessor_name" 4
.IX Item "accessor_name"
This argument is the name of the method you can call on a
Result object to retrieve the instance of the foreign
class matching this relationship. This is often called the
\&\f(CW\*(C`relation(ship) name\*(C'\fR.
.Sp
Use this accessor_name in \*(L"join\*(R" in DBIx::Class::ResultSet
or \*(L"prefetch\*(R" in DBIx::Class::ResultSet to join to the foreign table
indicated by this relationship.
.IP "related_class" 4
.IX Item "related_class"
This is the class name of the table which contains a foreign key
column containing \s-1PK\s0 values of this class.
.IP "their_fk_column" 4
.IX Item "their_fk_column"
The column name on the related class that contains the foreign key.
.Sp
\&\s-1OR\s0
.IP "cond" 4
.IX Item "cond"
A hashref, arrayref  or coderef specifying a custom join expression. For
more info see \*(L"condition\*(R" in DBIx::Class::Relationship::Base.
.PP
.Vb 6
\&  # Every book has exactly one ISBN
\&  My::DBIC::Schema::Book\->has_one(
\&    isbn =>
\&    \*(AqMy::DBIC::Schema::ISBN\*(Aq,
\&    \*(Aqbook_id\*(Aq,
\&  );
\&
\&  # OR (same result, assuming related_class stores our PK)
\&  My::DBIC::Schema::Book\->has_one(
\&    isbn =>
\&    \*(AqMy::DBIC::Schema::ISBN\*(Aq,
\&  );
\&
\&  # OR (same result)
\&  My::DBIC::Schema::Book\->has_one(
\&    isbn =>
\&    \*(AqMy::DBIC::Schema::ISBN\*(Aq,
\&    { \*(Aqforeign.book_id\*(Aq => \*(Aqself.id\*(Aq },
\&  );
\&
\&  # Usage
\&  my $isbn_obj = $book\->isbn; # to get the ISBN object
.Ve
.PP
Creates a one-to-one relationship with another class. This is just
like \f(CW\*(C`might_have\*(C'\fR, except the implication is that the other object is
always present. The only difference between \f(CW\*(C`has_one\*(C'\fR and
\&\f(CW\*(C`might_have\*(C'\fR is that \f(CW\*(C`has_one\*(C'\fR uses an (ordinary) inner join,
whereas \f(CW\*(C`might_have\*(C'\fR defaults to a left join.
.PP
The has_one relationship should be used when a row in the table must
have exactly one related row in another table. If the related row
might not exist in the foreign table, use the
\&\*(L"might_have\*(R" in DBIx::Class::Relationship relationship.
.PP
In the above example, each Book in the database is associated with exactly one
\&\s-1ISBN\s0 object.
.PP
See \*(L"attributes\*(R" in DBIx::Class::Relationship::Base for documentation on
relationship methods and valid relationship attributes. Also see
DBIx::Class::ResultSet for a list of standard resultset
attributes which can be assigned to
relationships as well.
.PP
Note that if you supply a condition on which to join, if the column in the
current table allows nulls (i.e., has the \f(CW\*(C`is_nullable\*(C'\fR attribute set to a
true value), than warnings might apply just as with
\&\*(L"might_have\*(R" in DBIx::Class::Relationship.
.SS "many_to_many"
.IX Subsection "many_to_many"
.ie n .IP "Arguments: $accessor_name, $link_rel_name, $foreign_rel_name, \e%attrs?" 4
.el .IP "Arguments: \f(CW$accessor_name\fR, \f(CW$link_rel_name\fR, \f(CW$foreign_rel_name\fR, \e%attrs?" 4
.IX Item "Arguments: $accessor_name, $link_rel_name, $foreign_rel_name, %attrs?"
.PP
\&\f(CW\*(C`many_to_many\*(C'\fR is a \fIRelationship bridge\fR which has a specific
meaning in DBIx::Class, see the definition in the
Glossary.
.PP
\&\f(CW\*(C`many_to_many\*(C'\fR is not strictly a relationship in its own right. Instead, it is
a bridge between two resultsets which provide the same kind of convenience
accessors as true relationships provide. Although the accessor will return a
resultset or collection of objects just like has_many does, you cannot call
\&\f(CW\*(C`related_resultset\*(C'\fR and similar methods which operate on true relationships.
.IP "accessor_name" 4
.IX Item "accessor_name"
This argument is the name of the method you can call on a
Result object to retrieve the rows matching this
relationship.
.Sp
On a many_to_many, unlike other relationships, this cannot be used in
\&\*(L"search\*(R" in DBIx::Class::ResultSet to join tables. Use the relations
bridged across instead.
.IP "link_rel_name" 4
.IX Item "link_rel_name"
This is the accessor_name from the has_many relationship we are
bridging from.
.IP "foreign_rel_name" 4
.IX Item "foreign_rel_name"
This is the accessor_name of the belongs_to relationship in the link
table that we are bridging across (which gives us the table we are
bridging to).
.PP
To create a many_to_many relationship from Actor to Role:
.PP
.Vb 7
\&  My::DBIC::Schema::Actor\->has_many( actor_roles =>
\&                                     \*(AqMy::DBIC::Schema::ActorRoles\*(Aq,
\&                                     \*(Aqactor\*(Aq );
\&  My::DBIC::Schema::ActorRoles\->belongs_to( role =>
\&                                            \*(AqMy::DBIC::Schema::Role\*(Aq );
\&  My::DBIC::Schema::ActorRoles\->belongs_to( actor =>
\&                                            \*(AqMy::DBIC::Schema::Actor\*(Aq );
\&
\&  My::DBIC::Schema::Actor\->many_to_many( roles => \*(Aqactor_roles\*(Aq,
\&                                         \*(Aqrole\*(Aq );
.Ve
.PP
And, for the reverse relationship, from Role to Actor:
.PP
.Vb 3
\&  My::DBIC::Schema::Role\->has_many( actor_roles =>
\&                                    \*(AqMy::DBIC::Schema::ActorRoles\*(Aq,
\&                                    \*(Aqrole\*(Aq );
\&
\&  My::DBIC::Schema::Role\->many_to_many( actors => \*(Aqactor_roles\*(Aq, \*(Aqactor\*(Aq );
.Ve
.PP
To add a role for your actor, and fill in the year of the role in the
actor_roles table:
.PP
.Vb 1
\&  $actor\->add_to_roles($role, { year => 1995 });
.Ve
.PP
In the above example, ActorRoles is the link table class, and Role is the
foreign class. The \f(CW$link_rel_name\fR parameter is the name of the accessor for
the has_many relationship from this table to the link table, and the
\&\f(CW$foreign_rel_name\fR parameter is the accessor for the belongs_to relationship
from the link table to the foreign table.
.PP
To use many_to_many, existing relationships from the original table to the link
table, and from the link table to the end table must already exist, these
relation names are then used in the many_to_many call.
.PP
In the above example, the Actor class will have 3 many_to_many accessor methods
set: \f(CW\*(C`roles\*(C'\fR, \f(CW\*(C`add_to_roles\*(C'\fR, \f(CW\*(C`set_roles\*(C'\fR, and similarly named accessors
will be created for the Role class for the \f(CW\*(C`actors\*(C'\fR many_to_many
relationship.
.PP
See \*(L"attributes\*(R" in DBIx::Class::Relationship::Base for documentation on
relationship methods and valid relationship attributes. Also see
DBIx::Class::ResultSet for a list of standard resultset
attributes which can be assigned to
relationships as well.
.SH "AUTHOR AND CONTRIBUTORS"
.IX Header "AUTHOR AND CONTRIBUTORS"
See \s-1AUTHOR\s0 and \s-1CONTRIBUTORS\s0 in DBIx::Class
.SH "LICENSE"
.IX Header "LICENSE"
You may distribute this code under the same terms as Perl itself.
