.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Compress::Zlib 3pm"
.TH Compress::Zlib 3pm "2014-01-06" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Compress::Zlib \- Interface to zlib compression library
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use Compress::Zlib ;
\&
\&    ($d, $status) = deflateInit( [OPT] ) ;
\&    $status = $d\->deflate($input, $output) ;
\&    $status = $d\->flush([$flush_type]) ;
\&    $d\->deflateParams(OPTS) ;
\&    $d\->deflateTune(OPTS) ;
\&    $d\->dict_adler() ;
\&    $d\->crc32() ;
\&    $d\->adler32() ;
\&    $d\->total_in() ;
\&    $d\->total_out() ;
\&    $d\->msg() ;
\&    $d\->get_Strategy();
\&    $d\->get_Level();
\&    $d\->get_BufSize();
\&
\&    ($i, $status) = inflateInit( [OPT] ) ;
\&    $status = $i\->inflate($input, $output [, $eof]) ;
\&    $status = $i\->inflateSync($input) ;
\&    $i\->dict_adler() ;
\&    $d\->crc32() ;
\&    $d\->adler32() ;
\&    $i\->total_in() ;
\&    $i\->total_out() ;
\&    $i\->msg() ;
\&    $d\->get_BufSize();
\&
\&    $dest = compress($source) ;
\&    $dest = uncompress($source) ;
\&
\&    $gz = gzopen($filename or filehandle, $mode) ;
\&    $bytesread = $gz\->gzread($buffer [,$size]) ;
\&    $bytesread = $gz\->gzreadline($line) ;
\&    $byteswritten = $gz\->gzwrite($buffer) ;
\&    $status = $gz\->gzflush($flush) ;
\&    $offset = $gz\->gztell() ;
\&    $status = $gz\->gzseek($offset, $whence) ;
\&    $status = $gz\->gzclose() ;
\&    $status = $gz\->gzeof() ;
\&    $status = $gz\->gzsetparams($level, $strategy) ;
\&    $errstring = $gz\->gzerror() ; 
\&    $gzerrno
\&
\&    $dest = Compress::Zlib::memGzip($buffer) ;
\&    $dest = Compress::Zlib::memGunzip($buffer) ;
\&
\&    $crc = adler32($buffer [,$crc]) ;
\&    $crc = crc32($buffer [,$crc]) ;
\&
\&    $crc = adler32_combine($crc1, $crc2, $len2)l
\&    $crc = crc32_combine($adler1, $adler2, $len2)
\&
\&    my $version = Compress::Raw::Zlib::zlib_version();
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The \fICompress::Zlib\fR module provides a Perl interface to the \fIzlib\fR
compression library (see \*(L"\s-1AUTHOR\*(R"\s0 for details about where to get
\&\fIzlib\fR).
.PP
The \f(CW\*(C`Compress::Zlib\*(C'\fR module can be split into two general areas of
functionality, namely a simple read/write interface to \fIgzip\fR files
and a low-level in-memory compression/decompression interface.
.PP
Each of these areas will be discussed in the following sections.
.SS "Notes for users of Compress::Zlib version 1"
.IX Subsection "Notes for users of Compress::Zlib version 1"
The main change in \f(CW\*(C`Compress::Zlib\*(C'\fR version 2.x is that it does not now
interface directly to the zlib library. Instead it uses the
\&\f(CW\*(C`IO::Compress::Gzip\*(C'\fR and \f(CW\*(C`IO::Uncompress::Gunzip\*(C'\fR modules for
reading/writing gzip files, and the \f(CW\*(C`Compress::Raw::Zlib\*(C'\fR module for some
low-level zlib access.
.PP
The interface provided by version 2 of this module should be 100% backward
compatible with version 1. If you find a difference in the expected
behaviour please contact the author (See \*(L"\s-1AUTHOR\*(R"\s0). See \*(L"\s-1GZIP INTERFACE\*(R"\s0
.PP
With the creation of the \f(CW\*(C`IO::Compress\*(C'\fR and \f(CW\*(C`IO::Uncompress\*(C'\fR modules no
new features are planned for \f(CW\*(C`Compress::Zlib\*(C'\fR \- the new modules do
everything that \f(CW\*(C`Compress::Zlib\*(C'\fR does and then some. Development on
\&\f(CW\*(C`Compress::Zlib\*(C'\fR will be limited to bug fixes only.
.PP
If you are writing new code, your first port of call should be one of the
new \f(CW\*(C`IO::Compress\*(C'\fR or \f(CW\*(C`IO::Uncompress\*(C'\fR modules.
.SH "GZIP INTERFACE"
.IX Header "GZIP INTERFACE"
A number of functions are supplied in \fIzlib\fR for reading and writing
\&\fIgzip\fR files that conform to \s-1RFC 1952.\s0 This module provides an interface
to most of them.
.PP
If you have previously used \f(CW\*(C`Compress::Zlib\*(C'\fR 1.x, the following
enhancements/changes have been made to the \f(CW\*(C`gzopen\*(C'\fR interface:
.IP "1." 5
If you want to open either \s-1STDIN\s0 or \s-1STDOUT\s0 with \f(CW\*(C`gzopen\*(C'\fR, you can now
optionally use the special filename "\f(CW\*(C`\-\*(C'\fR" as a synonym for \f(CW\*(C`\e*STDIN\*(C'\fR and
\&\f(CW\*(C`\e*STDOUT\*(C'\fR.
.IP "2." 5
In \f(CW\*(C`Compress::Zlib\*(C'\fR version 1.x, \f(CW\*(C`gzopen\*(C'\fR used the zlib library to open
the underlying file. This made things especially tricky when a Perl
filehandle was passed to \f(CW\*(C`gzopen\*(C'\fR. Behind the scenes the numeric C file
descriptor had to be extracted from the Perl filehandle and this passed to
the zlib library.
.Sp
Apart from being non-portable to some operating systems, this made it
difficult to use \f(CW\*(C`gzopen\*(C'\fR in situations where you wanted to extract/create
a gzip data stream that is embedded in a larger file, without having to
resort to opening and closing the file multiple times.
.Sp
It also made it impossible to pass a perl filehandle that wasn't associated
with a real filesystem file, like, say, an \f(CW\*(C`IO::String\*(C'\fR.
.Sp
In \f(CW\*(C`Compress::Zlib\*(C'\fR version 2.x, the \f(CW\*(C`gzopen\*(C'\fR interface has been
completely rewritten to use the IO::Compress::Gzip
for writing gzip files and IO::Uncompress::Gunzip
for reading gzip files. None of the limitations mentioned above apply.
.IP "3." 5
Addition of \f(CW\*(C`gzseek\*(C'\fR to provide a restricted \f(CW\*(C`seek\*(C'\fR interface.
.IP "4." 5
Added \f(CW\*(C`gztell\*(C'\fR.
.PP
A more complete and flexible interface for reading/writing gzip
files/buffers is included with the module \f(CW\*(C`IO\-Compress\-Zlib\*(C'\fR. See
IO::Compress::Gzip and
IO::Uncompress::Gunzip for more details.
.ie n .IP "\fB\fB$gz\fB = gzopen($filename, \f(BI$mode\fB)\fR" 5
.el .IP "\fB\f(CB$gz\fB = gzopen($filename, \f(CB$mode\fB)\fR" 5
.IX Item "$gz = gzopen($filename, $mode)"
.PD 0
.ie n .IP "\fB\fB$gz\fB = gzopen($filehandle, \f(BI$mode\fB)\fR" 5
.el .IP "\fB\f(CB$gz\fB = gzopen($filehandle, \f(CB$mode\fB)\fR" 5
.IX Item "$gz = gzopen($filehandle, $mode)"
.PD
This function opens either the \fIgzip\fR file \f(CW$filename\fR for reading or
writing or attaches to the opened filehandle, \f(CW$filehandle\fR. 
It returns an object on success and \f(CW\*(C`undef\*(C'\fR on failure.
.Sp
When writing a gzip file this interface will \fIalways\fR create the smallest
possible gzip header (exactly 10 bytes). If you want greater control over
what gets stored in the gzip header (like the original filename or a
comment) use IO::Compress::Gzip instead. Similarly if
you want to read the contents of the gzip header use
IO::Uncompress::Gunzip.
.Sp
The second parameter, \f(CW$mode\fR, is used to specify whether the file is
opened for reading or writing and to optionally specify a compression
level and compression strategy when writing. The format of the \f(CW$mode\fR
parameter is similar to the mode parameter to the 'C' function \f(CW\*(C`fopen\*(C'\fR,
so \*(L"rb\*(R" is used to open for reading, \*(L"wb\*(R" for writing and \*(L"ab\*(R" for
appending (writing at the end of the file).
.Sp
To specify a compression level when writing, append a digit between 0
and 9 to the mode string \*(-- 0 means no compression and 9 means maximum
compression.
If no compression level is specified Z_DEFAULT_COMPRESSION is used.
.Sp
To specify the compression strategy when writing, append 'f' for filtered
data, 'h' for Huffman only compression, or 'R' for run-length encoding.
If no strategy is specified Z_DEFAULT_STRATEGY is used.
.Sp
So, for example, \*(L"wb9\*(R" means open for writing with the maximum compression
using the default strategy and \*(L"wb4R\*(R" means open for writing with compression
level 4 and run-length encoding.
.Sp
Refer to the \fIzlib\fR documentation for the exact format of the \f(CW$mode\fR
parameter.
.ie n .IP "\fB\fB$bytesread\fB = \f(BI$gz\fB\->gzread($buffer [, \f(CB$size\fB]) ;\fR" 5
.el .IP "\fB\f(CB$bytesread\fB = \f(CB$gz\fB\->gzread($buffer [, \f(CB$size\fB]) ;\fR" 5
.IX Item "$bytesread = $gz->gzread($buffer [, $size]) ;"
Reads \f(CW$size\fR bytes from the compressed file into \f(CW$buffer\fR. If
\&\f(CW$size\fR is not specified, it will default to 4096. If the scalar
\&\f(CW$buffer\fR is not large enough, it will be extended automatically.
.Sp
Returns the number of bytes actually read. On \s-1EOF\s0 it returns 0 and in
the case of an error, \-1.
.ie n .IP "\fB\fB$bytesread\fB = \f(BI$gz\fB\->gzreadline($line) ;\fR" 5
.el .IP "\fB\f(CB$bytesread\fB = \f(CB$gz\fB\->gzreadline($line) ;\fR" 5
.IX Item "$bytesread = $gz->gzreadline($line) ;"
Reads the next line from the compressed file into \f(CW$line\fR.
.Sp
Returns the number of bytes actually read. On \s-1EOF\s0 it returns 0 and in
the case of an error, \-1.
.Sp
It is legal to intermix calls to \f(CW\*(C`gzread\*(C'\fR and \f(CW\*(C`gzreadline\*(C'\fR.
.Sp
To maintain backward compatibility with version 1.x of this module
\&\f(CW\*(C`gzreadline\*(C'\fR ignores the \f(CW$/\fR variable \- it \fIalways\fR uses the string
\&\f(CW"\en"\fR as the line delimiter.
.Sp
If you want to read a gzip file a line at a time and have it respect the
\&\f(CW$/\fR variable (or \f(CW$INPUT_RECORD_SEPARATOR\fR, or \f(CW$RS\fR when \f(CW\*(C`English\*(C'\fR is
in use) see IO::Uncompress::Gunzip.
.ie n .IP "\fB\fB$byteswritten\fB = \f(BI$gz\fB\->gzwrite($buffer) ;\fR" 5
.el .IP "\fB\f(CB$byteswritten\fB = \f(CB$gz\fB\->gzwrite($buffer) ;\fR" 5
.IX Item "$byteswritten = $gz->gzwrite($buffer) ;"
Writes the contents of \f(CW$buffer\fR to the compressed file. Returns the
number of bytes actually written, or 0 on error.
.ie n .IP "\fB\fB$status\fB = \f(BI$gz\fB\->gzflush($flush_type) ;\fR" 5
.el .IP "\fB\f(CB$status\fB = \f(CB$gz\fB\->gzflush($flush_type) ;\fR" 5
.IX Item "$status = $gz->gzflush($flush_type) ;"
Flushes all pending output into the compressed file.
.Sp
This method takes an optional parameter, \f(CW$flush_type\fR, that controls
how the flushing will be carried out. By default the \f(CW$flush_type\fR
used is \f(CW\*(C`Z_FINISH\*(C'\fR. Other valid values for \f(CW$flush_type\fR are
\&\f(CW\*(C`Z_NO_FLUSH\*(C'\fR, \f(CW\*(C`Z_SYNC_FLUSH\*(C'\fR, \f(CW\*(C`Z_FULL_FLUSH\*(C'\fR and \f(CW\*(C`Z_BLOCK\*(C'\fR. It is
strongly recommended that you only set the \f(CW\*(C`flush_type\*(C'\fR parameter if
you fully understand the implications of what it does \- overuse of \f(CW\*(C`flush\*(C'\fR
can seriously degrade the level of compression achieved. See the \f(CW\*(C`zlib\*(C'\fR
documentation for details.
.Sp
Returns 0 on success.
.ie n .IP "\fB\fB$offset\fB = \f(BI$gz\fB\->\f(BIgztell()\fB ;\fR" 5
.el .IP "\fB\f(CB$offset\fB = \f(CB$gz\fB\->\f(BIgztell()\fB ;\fR" 5
.IX Item "$offset = $gz->gztell() ;"
Returns the uncompressed file offset.
.ie n .IP "\fB\fB$status\fB = \f(BI$gz\fB\->gzseek($offset, \f(CB$whence\fB) ;\fR" 5
.el .IP "\fB\f(CB$status\fB = \f(CB$gz\fB\->gzseek($offset, \f(CB$whence\fB) ;\fR" 5
.IX Item "$status = $gz->gzseek($offset, $whence) ;"
Provides a sub-set of the \f(CW\*(C`seek\*(C'\fR functionality, with the restriction
that it is only legal to seek forward in the compressed file.
It is a fatal error to attempt to seek backward.
.Sp
When opened for writing, empty parts of the file will have \s-1NULL \s0(0x00)
bytes written to them.
.Sp
The \f(CW$whence\fR parameter should be one of \s-1SEEK_SET, SEEK_CUR\s0 or \s-1SEEK_END.\s0
.Sp
Returns 1 on success, 0 on failure.
.ie n .IP "\fB\fB$gz\fB\->gzclose\fR" 5
.el .IP "\fB\f(CB$gz\fB\->gzclose\fR" 5
.IX Item "$gz->gzclose"
Closes the compressed file. Any pending data is flushed to the file
before it is closed.
.Sp
Returns 0 on success.
.ie n .IP "\fB\fB$gz\fB\->gzsetparams($level, \f(BI$strategy\fB\fR" 5
.el .IP "\fB\f(CB$gz\fB\->gzsetparams($level, \f(CB$strategy\fB\fR" 5
.IX Item "$gz->gzsetparams($level, $strategy"
Change settings for the deflate stream \f(CW$gz\fR.
.Sp
The list of the valid options is shown below. Options not specified
will remain unchanged.
.Sp
Note: This method is only available if you are running zlib 1.0.6 or better.
.RS 5
.ie n .IP "\fB\fB$level\fB\fR" 5
.el .IP "\fB\f(CB$level\fB\fR" 5
.IX Item "$level"
Defines the compression level. Valid values are 0 through 9,
\&\f(CW\*(C`Z_NO_COMPRESSION\*(C'\fR, \f(CW\*(C`Z_BEST_SPEED\*(C'\fR, \f(CW\*(C`Z_BEST_COMPRESSION\*(C'\fR, and
\&\f(CW\*(C`Z_DEFAULT_COMPRESSION\*(C'\fR.
.ie n .IP "\fB\fB$strategy\fB\fR" 5
.el .IP "\fB\f(CB$strategy\fB\fR" 5
.IX Item "$strategy"
Defines the strategy used to tune the compression. The valid values are
\&\f(CW\*(C`Z_DEFAULT_STRATEGY\*(C'\fR, \f(CW\*(C`Z_FILTERED\*(C'\fR and \f(CW\*(C`Z_HUFFMAN_ONLY\*(C'\fR.
.RE
.RS 5
.RE
.ie n .IP "\fB\fB$gz\fB\->gzerror\fR" 5
.el .IP "\fB\f(CB$gz\fB\->gzerror\fR" 5
.IX Item "$gz->gzerror"
Returns the \fIzlib\fR error message or number for the last operation
associated with \f(CW$gz\fR. The return value will be the \fIzlib\fR error
number when used in a numeric context and the \fIzlib\fR error message
when used in a string context. The \fIzlib\fR error number constants,
shown below, are available for use.
.Sp
.Vb 7
\&    Z_OK
\&    Z_STREAM_END
\&    Z_ERRNO
\&    Z_STREAM_ERROR
\&    Z_DATA_ERROR
\&    Z_MEM_ERROR
\&    Z_BUF_ERROR
.Ve
.ie n .IP "\fB\fB$gzerrno\fB\fR" 5
.el .IP "\fB\f(CB$gzerrno\fB\fR" 5
.IX Item "$gzerrno"
The \f(CW$gzerrno\fR scalar holds the error code associated with the most
recent \fIgzip\fR routine. Note that unlike \f(CW\*(C`gzerror()\*(C'\fR, the error is
\&\fInot\fR associated with a particular file.
.Sp
As with \f(CW\*(C`gzerror()\*(C'\fR it returns an error number in numeric context and
an error message in string context. Unlike \f(CW\*(C`gzerror()\*(C'\fR though, the
error message will correspond to the \fIzlib\fR message when the error is
associated with \fIzlib\fR itself, or the \s-1UNIX\s0 error message when it is
not (i.e. \fIzlib\fR returned \f(CW\*(C`Z_ERRORNO\*(C'\fR).
.Sp
As there is an overlap between the error numbers used by \fIzlib\fR and
\&\s-1UNIX, \s0\f(CW$gzerrno\fR should only be used to check for the presence of
\&\fIan\fR error in numeric context. Use \f(CW\*(C`gzerror()\*(C'\fR to check for specific
\&\fIzlib\fR errors. The \fIgzcat\fR example below shows how the variable can
be used safely.
.SS "Examples"
.IX Subsection "Examples"
Here is an example script which uses the interface. It implements a
\&\fIgzcat\fR function.
.PP
.Vb 2
\&    use strict ;
\&    use warnings ;
\&    
\&    use Compress::Zlib ;
\&    
\&    # use stdin if no files supplied
\&    @ARGV = \*(Aq\-\*(Aq unless @ARGV ;
\&    
\&    foreach my $file (@ARGV) {
\&        my $buffer ;
\&    
\&        my $gz = gzopen($file, "rb") 
\&             or die "Cannot open $file: $gzerrno\en" ;
\&    
\&        print $buffer while $gz\->gzread($buffer) > 0 ;
\&    
\&        die "Error reading from $file: $gzerrno" . ($gzerrno+0) . "\en" 
\&            if $gzerrno != Z_STREAM_END ;
\&        
\&        $gz\->gzclose() ;
\&    }
.Ve
.PP
Below is a script which makes use of \f(CW\*(C`gzreadline\*(C'\fR. It implements a
very simple \fIgrep\fR like script.
.PP
.Vb 2
\&    use strict ;
\&    use warnings ;
\&    
\&    use Compress::Zlib ;
\&    
\&    die "Usage: gzgrep pattern [file...]\en"
\&        unless @ARGV >= 1;
\&    
\&    my $pattern = shift ;
\&    
\&    # use stdin if no files supplied
\&    @ARGV = \*(Aq\-\*(Aq unless @ARGV ;
\&    
\&    foreach my $file (@ARGV) {
\&        my $gz = gzopen($file, "rb") 
\&             or die "Cannot open $file: $gzerrno\en" ;
\&    
\&        while ($gz\->gzreadline($_) > 0) {
\&            print if /$pattern/ ;
\&        }
\&    
\&        die "Error reading from $file: $gzerrno\en" 
\&            if $gzerrno != Z_STREAM_END ;
\&        
\&        $gz\->gzclose() ;
\&    }
.Ve
.PP
This script, \fIgzstream\fR, does the opposite of the \fIgzcat\fR script
above. It reads from standard input and writes a gzip data stream to
standard output.
.PP
.Vb 2
\&    use strict ;
\&    use warnings ;
\&    
\&    use Compress::Zlib ;
\&    
\&    binmode STDOUT;  # gzopen only sets it on the fd
\&    
\&    my $gz = gzopen(\e*STDOUT, "wb")
\&          or die "Cannot open stdout: $gzerrno\en" ;
\&    
\&    while (<>) {
\&        $gz\->gzwrite($_) 
\&          or die "error writing: $gzerrno\en" ;
\&    }
\&
\&    $gz\->gzclose ;
.Ve
.SS "Compress::Zlib::memGzip"
.IX Subsection "Compress::Zlib::memGzip"
This function is used to create an in-memory gzip file with the minimum
possible gzip header (exactly 10 bytes).
.PP
.Vb 2
\&    $dest = Compress::Zlib::memGzip($buffer) 
\&        or die "Cannot compress: $gzerrno\en";
.Ve
.PP
If successful, it returns the in-memory gzip file. Otherwise it returns
\&\f(CW\*(C`undef\*(C'\fR and the \f(CW$gzerrno\fR variable will store the zlib error code.
.PP
The \f(CW$buffer\fR parameter can either be a scalar or a scalar reference.
.PP
See IO::Compress::Gzip for an alternative way to
carry out in-memory gzip compression.
.SS "Compress::Zlib::memGunzip"
.IX Subsection "Compress::Zlib::memGunzip"
This function is used to uncompress an in-memory gzip file.
.PP
.Vb 2
\&    $dest = Compress::Zlib::memGunzip($buffer) 
\&        or die "Cannot uncompress: $gzerrno\en";
.Ve
.PP
If successful, it returns the uncompressed gzip file. Otherwise it
returns \f(CW\*(C`undef\*(C'\fR and the \f(CW$gzerrno\fR variable will store the zlib error
code.
.PP
The \f(CW$buffer\fR parameter can either be a scalar or a scalar reference. The
contents of the \f(CW$buffer\fR parameter are destroyed after calling this function.
.PP
If \f(CW$buffer\fR consists of multiple concatenated gzip data streams only the
first will be uncompressed. Use \f(CW\*(C`gunzip\*(C'\fR with the \f(CW\*(C`MultiStream\*(C'\fR option in
the \f(CW\*(C`IO::Uncompress::Gunzip\*(C'\fR module if you need to deal with concatenated
data streams.
.PP
See IO::Uncompress::Gunzip for an alternative way
to carry out in-memory gzip uncompression.
.SH "COMPRESS/UNCOMPRESS"
.IX Header "COMPRESS/UNCOMPRESS"
Two functions are provided to perform in-memory compression/uncompression of
\&\s-1RFC 1950\s0 data streams. They are called \f(CW\*(C`compress\*(C'\fR and \f(CW\*(C`uncompress\*(C'\fR.
.ie n .IP "\fB\fB$dest\fB = compress($source [, \f(BI$level\fB] ) ;\fR" 5
.el .IP "\fB\f(CB$dest\fB = compress($source [, \f(CB$level\fB] ) ;\fR" 5
.IX Item "$dest = compress($source [, $level] ) ;"
Compresses \f(CW$source\fR. If successful it returns the compressed
data. Otherwise it returns \fIundef\fR.
.Sp
The source buffer, \f(CW$source\fR, can either be a scalar or a scalar
reference.
.Sp
The \f(CW$level\fR parameter defines the compression level. Valid values are
0 through 9, \f(CW\*(C`Z_NO_COMPRESSION\*(C'\fR, \f(CW\*(C`Z_BEST_SPEED\*(C'\fR,
\&\f(CW\*(C`Z_BEST_COMPRESSION\*(C'\fR, and \f(CW\*(C`Z_DEFAULT_COMPRESSION\*(C'\fR.
If \f(CW$level\fR is not specified \f(CW\*(C`Z_DEFAULT_COMPRESSION\*(C'\fR will be used.
.ie n .IP "\fB\fB$dest\fB = uncompress($source) ;\fR" 5
.el .IP "\fB\f(CB$dest\fB = uncompress($source) ;\fR" 5
.IX Item "$dest = uncompress($source) ;"
Uncompresses \f(CW$source\fR. If successful it returns the uncompressed
data. Otherwise it returns \fIundef\fR.
.Sp
The source buffer can either be a scalar or a scalar reference.
.PP
Please note: the two functions defined above are \fInot\fR compatible with
the Unix commands of the same name.
.PP
See IO::Deflate and IO::Inflate included with
this distribution for an alternative interface for reading/writing \s-1RFC 1950\s0
files/buffers.
.SH "Deflate Interface"
.IX Header "Deflate Interface"
This section defines an interface that allows in-memory compression using
the \fIdeflate\fR interface provided by zlib.
.PP
Here is a definition of the interface available:
.ie n .SS "\fB($d, \fP\fB$status\fP\fB) = deflateInit( [\s-1OPT\s0] )\fP"
.el .SS "\fB($d, \fP\f(CB$status\fP\fB) = deflateInit( [\s-1OPT\s0] )\fP"
.IX Subsection "($d, $status) = deflateInit( [OPT] )"
Initialises a deflation stream.
.PP
It combines the features of the \fIzlib\fR functions \f(CW\*(C`deflateInit\*(C'\fR,
\&\f(CW\*(C`deflateInit2\*(C'\fR and \f(CW\*(C`deflateSetDictionary\*(C'\fR.
.PP
If successful, it will return the initialised deflation stream, \f(CW$d\fR
and \f(CW$status\fR of \f(CW\*(C`Z_OK\*(C'\fR in a list context. In scalar context it
returns the deflation stream, \f(CW$d\fR, only.
.PP
If not successful, the returned deflation stream (\f(CW$d\fR) will be
\&\fIundef\fR and \f(CW$status\fR will hold the exact \fIzlib\fR error code.
.PP
The function optionally takes a number of named options specified as
\&\f(CW\*(C`\-Name=>value\*(C'\fR pairs. This allows individual options to be
tailored without having to specify them all in the parameter list.
.PP
For backward compatibility, it is also possible to pass the parameters
as a reference to a hash containing the name=>value pairs.
.PP
The function takes one optional parameter, a reference to a hash.  The
contents of the hash allow the deflation interface to be tailored.
.PP
Here is a list of the valid options:
.IP "\fB\-Level\fR" 5
.IX Item "-Level"
Defines the compression level. Valid values are 0 through 9,
\&\f(CW\*(C`Z_NO_COMPRESSION\*(C'\fR, \f(CW\*(C`Z_BEST_SPEED\*(C'\fR, \f(CW\*(C`Z_BEST_COMPRESSION\*(C'\fR, and
\&\f(CW\*(C`Z_DEFAULT_COMPRESSION\*(C'\fR.
.Sp
The default is Z_DEFAULT_COMPRESSION.
.IP "\fB\-Method\fR" 5
.IX Item "-Method"
Defines the compression method. The only valid value at present (and
the default) is Z_DEFLATED.
.IP "\fB\-WindowBits\fR" 5
.IX Item "-WindowBits"
To create an \s-1RFC 1950\s0 data stream, set \f(CW\*(C`WindowBits\*(C'\fR to a positive number.
.Sp
To create an \s-1RFC 1951\s0 data stream, set \f(CW\*(C`WindowBits\*(C'\fR to \f(CW\*(C`\-MAX_WBITS\*(C'\fR.
.Sp
For a full definition of the meaning and valid values for \f(CW\*(C`WindowBits\*(C'\fR refer
to the \fIzlib\fR documentation for \fIdeflateInit2\fR.
.Sp
Defaults to \s-1MAX_WBITS.\s0
.IP "\fB\-MemLevel\fR" 5
.IX Item "-MemLevel"
For a definition of the meaning and valid values for \f(CW\*(C`MemLevel\*(C'\fR
refer to the \fIzlib\fR documentation for \fIdeflateInit2\fR.
.Sp
Defaults to \s-1MAX_MEM_LEVEL.\s0
.IP "\fB\-Strategy\fR" 5
.IX Item "-Strategy"
Defines the strategy used to tune the compression. The valid values are
\&\f(CW\*(C`Z_DEFAULT_STRATEGY\*(C'\fR, \f(CW\*(C`Z_FILTERED\*(C'\fR and \f(CW\*(C`Z_HUFFMAN_ONLY\*(C'\fR.
.Sp
The default is Z_DEFAULT_STRATEGY.
.IP "\fB\-Dictionary\fR" 5
.IX Item "-Dictionary"
When a dictionary is specified \fICompress::Zlib\fR will automatically
call \f(CW\*(C`deflateSetDictionary\*(C'\fR directly after calling \f(CW\*(C`deflateInit\*(C'\fR. The
Adler32 value for the dictionary can be obtained by calling the method 
\&\f(CW\*(C`$d\-\*(C'\fR\fIdict_adler()\fR>.
.Sp
The default is no dictionary.
.IP "\fB\-Bufsize\fR" 5
.IX Item "-Bufsize"
Sets the initial size for the deflation buffer. If the buffer has to be
reallocated to increase the size, it will grow in increments of
\&\f(CW\*(C`Bufsize\*(C'\fR.
.Sp
The default is 4096.
.PP
Here is an example of using the \f(CW\*(C`deflateInit\*(C'\fR optional parameter list
to override the default buffer size and compression level. All other
options will take their default values.
.PP
.Vb 2
\&    deflateInit( \-Bufsize => 300, 
\&                 \-Level => Z_BEST_SPEED  ) ;
.Ve
.ie n .SS "\fB($out, \fP\fB$status\fP\fB) = \fP\fB$d\fP\fB\->deflate($buffer)\fP"
.el .SS "\fB($out, \fP\f(CB$status\fP\fB) = \fP\f(CB$d\fP\fB\->deflate($buffer)\fP"
.IX Subsection "($out, $status) = $d->deflate($buffer)"
Deflates the contents of \f(CW$buffer\fR. The buffer can either be a scalar
or a scalar reference.  When finished, \f(CW$buffer\fR will be
completely processed (assuming there were no errors). If the deflation
was successful it returns the deflated output, \f(CW$out\fR, and a status
value, \f(CW$status\fR, of \f(CW\*(C`Z_OK\*(C'\fR.
.PP
On error, \f(CW$out\fR will be \fIundef\fR and \f(CW$status\fR will contain the
\&\fIzlib\fR error code.
.PP
In a scalar context \f(CW\*(C`deflate\*(C'\fR will return \f(CW$out\fR only.
.PP
As with the \fIdeflate\fR function in \fIzlib\fR, it is not necessarily the
case that any output will be produced by this method. So don't rely on
the fact that \f(CW$out\fR is empty for an error test.
.ie n .SS "\fB($out, \fP\fB$status\fP\fB) = \fP\fB$d\fP\fB\->\fP\f(BIflush()\fP\fB\fP =head2 \fB($out, \fP\fB$status\fP\fB) = \fP\fB$d\fP\fB\->flush($flush_type)\fP"
.el .SS "\fB($out, \fP\f(CB$status\fP\fB) = \fP\f(CB$d\fP\fB\->\fP\f(BIflush()\fP\fB\fP =head2 \fB($out, \fP\f(CB$status\fP\fB) = \fP\f(CB$d\fP\fB\->flush($flush_type)\fP"
.IX Subsection "($out, $status) = $d->flush() =head2 ($out, $status) = $d->flush($flush_type)"
Typically used to finish the deflation. Any pending output will be
returned via \f(CW$out\fR.
\&\f(CW$status\fR will have a value \f(CW\*(C`Z_OK\*(C'\fR if successful.
.PP
In a scalar context \f(CW\*(C`flush\*(C'\fR will return \f(CW$out\fR only.
.PP
Note that flushing can seriously degrade the compression ratio, so it
should only be used to terminate a decompression (using \f(CW\*(C`Z_FINISH\*(C'\fR) or
when you want to create a \fIfull flush point\fR (using \f(CW\*(C`Z_FULL_FLUSH\*(C'\fR).
.PP
By default the \f(CW\*(C`flush_type\*(C'\fR used is \f(CW\*(C`Z_FINISH\*(C'\fR. Other valid values
for \f(CW\*(C`flush_type\*(C'\fR are \f(CW\*(C`Z_NO_FLUSH\*(C'\fR, \f(CW\*(C`Z_PARTIAL_FLUSH\*(C'\fR, \f(CW\*(C`Z_SYNC_FLUSH\*(C'\fR
and \f(CW\*(C`Z_FULL_FLUSH\*(C'\fR. It is strongly recommended that you only set the
\&\f(CW\*(C`flush_type\*(C'\fR parameter if you fully understand the implications of
what it does. See the \f(CW\*(C`zlib\*(C'\fR documentation for details.
.ie n .SS "\fB\fP\fB$status\fP\fB = \fP\fB$d\fP\fB\->deflateParams([\s-1OPT\s0])\fP"
.el .SS "\fB\fP\f(CB$status\fP\fB = \fP\f(CB$d\fP\fB\->deflateParams([\s-1OPT\s0])\fP"
.IX Subsection "$status = $d->deflateParams([OPT])"
Change settings for the deflate stream \f(CW$d\fR.
.PP
The list of the valid options is shown below. Options not specified
will remain unchanged.
.IP "\fB\-Level\fR" 5
.IX Item "-Level"
Defines the compression level. Valid values are 0 through 9,
\&\f(CW\*(C`Z_NO_COMPRESSION\*(C'\fR, \f(CW\*(C`Z_BEST_SPEED\*(C'\fR, \f(CW\*(C`Z_BEST_COMPRESSION\*(C'\fR, and
\&\f(CW\*(C`Z_DEFAULT_COMPRESSION\*(C'\fR.
.IP "\fB\-Strategy\fR" 5
.IX Item "-Strategy"
Defines the strategy used to tune the compression. The valid values are
\&\f(CW\*(C`Z_DEFAULT_STRATEGY\*(C'\fR, \f(CW\*(C`Z_FILTERED\*(C'\fR and \f(CW\*(C`Z_HUFFMAN_ONLY\*(C'\fR.
.ie n .SS "\fB\fP\fB$d\fP\fB\->\fP\f(BIdict_adler()\fP\fB\fP"
.el .SS "\fB\fP\f(CB$d\fP\fB\->\fP\f(BIdict_adler()\fP\fB\fP"
.IX Subsection "$d->dict_adler()"
Returns the adler32 value for the dictionary.
.ie n .SS "\fB\fP\fB$d\fP\fB\->\fP\f(BImsg()\fP\fB\fP"
.el .SS "\fB\fP\f(CB$d\fP\fB\->\fP\f(BImsg()\fP\fB\fP"
.IX Subsection "$d->msg()"
Returns the last error message generated by zlib.
.ie n .SS "\fB\fP\fB$d\fP\fB\->\fP\f(BItotal_in()\fP\fB\fP"
.el .SS "\fB\fP\f(CB$d\fP\fB\->\fP\f(BItotal_in()\fP\fB\fP"
.IX Subsection "$d->total_in()"
Returns the total number of bytes uncompressed bytes input to deflate.
.ie n .SS "\fB\fP\fB$d\fP\fB\->\fP\f(BItotal_out()\fP\fB\fP"
.el .SS "\fB\fP\f(CB$d\fP\fB\->\fP\f(BItotal_out()\fP\fB\fP"
.IX Subsection "$d->total_out()"
Returns the total number of compressed bytes output from deflate.
.SS "Example"
.IX Subsection "Example"
Here is a trivial example of using \f(CW\*(C`deflate\*(C'\fR. It simply reads standard
input, deflates it and writes it to standard output.
.PP
.Vb 2
\&    use strict ;
\&    use warnings ;
\&
\&    use Compress::Zlib ;
\&
\&    binmode STDIN;
\&    binmode STDOUT;
\&    my $x = deflateInit()
\&       or die "Cannot create a deflation stream\en" ;
\&
\&    my ($output, $status) ;
\&    while (<>)
\&    {
\&        ($output, $status) = $x\->deflate($_) ;
\&    
\&        $status == Z_OK
\&            or die "deflation failed\en" ;
\&    
\&        print $output ;
\&    }
\&    
\&    ($output, $status) = $x\->flush() ;
\&    
\&    $status == Z_OK
\&        or die "deflation failed\en" ;
\&    
\&    print $output ;
.Ve
.SH "Inflate Interface"
.IX Header "Inflate Interface"
This section defines the interface available that allows in-memory
uncompression using the \fIdeflate\fR interface provided by zlib.
.PP
Here is a definition of the interface:
.ie n .SS "\fB($i, \fP\fB$status\fP\fB) = \fP\f(BIinflateInit()\fP\fB\fP"
.el .SS "\fB($i, \fP\f(CB$status\fP\fB) = \fP\f(BIinflateInit()\fP\fB\fP"
.IX Subsection "($i, $status) = inflateInit()"
Initialises an inflation stream.
.PP
In a list context it returns the inflation stream, \f(CW$i\fR, and the
\&\fIzlib\fR status code in \f(CW$status\fR. In a scalar context it returns the
inflation stream only.
.PP
If successful, \f(CW$i\fR will hold the inflation stream and \f(CW$status\fR will
be \f(CW\*(C`Z_OK\*(C'\fR.
.PP
If not successful, \f(CW$i\fR will be \fIundef\fR and \f(CW$status\fR will hold the
\&\fIzlib\fR error code.
.PP
The function optionally takes a number of named options specified as
\&\f(CW\*(C`\-Name=>value\*(C'\fR pairs. This allows individual options to be
tailored without having to specify them all in the parameter list.
.PP
For backward compatibility, it is also possible to pass the parameters
as a reference to a hash containing the name=>value pairs.
.PP
The function takes one optional parameter, a reference to a hash.  The
contents of the hash allow the deflation interface to be tailored.
.PP
Here is a list of the valid options:
.IP "\fB\-WindowBits\fR" 5
.IX Item "-WindowBits"
To uncompress an \s-1RFC 1950\s0 data stream, set \f(CW\*(C`WindowBits\*(C'\fR to a positive number.
.Sp
To uncompress an \s-1RFC 1951\s0 data stream, set \f(CW\*(C`WindowBits\*(C'\fR to \f(CW\*(C`\-MAX_WBITS\*(C'\fR.
.Sp
For a full definition of the meaning and valid values for \f(CW\*(C`WindowBits\*(C'\fR refer
to the \fIzlib\fR documentation for \fIinflateInit2\fR.
.Sp
Defaults to \s-1MAX_WBITS.\s0
.IP "\fB\-Bufsize\fR" 5
.IX Item "-Bufsize"
Sets the initial size for the inflation buffer. If the buffer has to be
reallocated to increase the size, it will grow in increments of
\&\f(CW\*(C`Bufsize\*(C'\fR.
.Sp
Default is 4096.
.IP "\fB\-Dictionary\fR" 5
.IX Item "-Dictionary"
The default is no dictionary.
.PP
Here is an example of using the \f(CW\*(C`inflateInit\*(C'\fR optional parameter to
override the default buffer size.
.PP
.Vb 1
\&    inflateInit( \-Bufsize => 300 ) ;
.Ve
.ie n .SS "\fB($out, \fP\fB$status\fP\fB) = \fP\fB$i\fP\fB\->inflate($buffer)\fP"
.el .SS "\fB($out, \fP\f(CB$status\fP\fB) = \fP\f(CB$i\fP\fB\->inflate($buffer)\fP"
.IX Subsection "($out, $status) = $i->inflate($buffer)"
Inflates the complete contents of \f(CW$buffer\fR. The buffer can either be
a scalar or a scalar reference.
.PP
Returns \f(CW\*(C`Z_OK\*(C'\fR if successful and \f(CW\*(C`Z_STREAM_END\*(C'\fR if the end of the
compressed data has been successfully reached. 
If not successful, \f(CW$out\fR will be \fIundef\fR and \f(CW$status\fR will hold
the \fIzlib\fR error code.
.PP
The \f(CW$buffer\fR parameter is modified by \f(CW\*(C`inflate\*(C'\fR. On completion it
will contain what remains of the input buffer after inflation. This
means that \f(CW$buffer\fR will be an empty string when the return status is
\&\f(CW\*(C`Z_OK\*(C'\fR. When the return status is \f(CW\*(C`Z_STREAM_END\*(C'\fR the \f(CW$buffer\fR
parameter will contains what (if anything) was stored in the input
buffer after the deflated data stream.
.PP
This feature is useful when processing a file format that encapsulates
a  compressed data stream (e.g. gzip, zip).
.ie n .SS "\fB\fP\fB$status\fP\fB = \fP\fB$i\fP\fB\->inflateSync($buffer)\fP"
.el .SS "\fB\fP\f(CB$status\fP\fB = \fP\f(CB$i\fP\fB\->inflateSync($buffer)\fP"
.IX Subsection "$status = $i->inflateSync($buffer)"
Scans \f(CW$buffer\fR until it reaches either a \fIfull flush point\fR or the
end of the buffer.
.PP
If a \fIfull flush point\fR is found, \f(CW\*(C`Z_OK\*(C'\fR is returned and \f(CW$buffer\fR
will be have all data up to the flush point removed. This can then be
passed to the \f(CW\*(C`deflate\*(C'\fR method.
.PP
Any other return code means that a flush point was not found. If more
data is available, \f(CW\*(C`inflateSync\*(C'\fR can be called repeatedly with more
compressed data until the flush point is found.
.ie n .SS "\fB\fP\fB$i\fP\fB\->\fP\f(BIdict_adler()\fP\fB\fP"
.el .SS "\fB\fP\f(CB$i\fP\fB\->\fP\f(BIdict_adler()\fP\fB\fP"
.IX Subsection "$i->dict_adler()"
Returns the adler32 value for the dictionary.
.ie n .SS "\fB\fP\fB$i\fP\fB\->\fP\f(BImsg()\fP\fB\fP"
.el .SS "\fB\fP\f(CB$i\fP\fB\->\fP\f(BImsg()\fP\fB\fP"
.IX Subsection "$i->msg()"
Returns the last error message generated by zlib.
.ie n .SS "\fB\fP\fB$i\fP\fB\->\fP\f(BItotal_in()\fP\fB\fP"
.el .SS "\fB\fP\f(CB$i\fP\fB\->\fP\f(BItotal_in()\fP\fB\fP"
.IX Subsection "$i->total_in()"
Returns the total number of bytes compressed bytes input to inflate.
.ie n .SS "\fB\fP\fB$i\fP\fB\->\fP\f(BItotal_out()\fP\fB\fP"
.el .SS "\fB\fP\f(CB$i\fP\fB\->\fP\f(BItotal_out()\fP\fB\fP"
.IX Subsection "$i->total_out()"
Returns the total number of uncompressed bytes output from inflate.
.SS "Example"
.IX Subsection "Example"
Here is an example of using \f(CW\*(C`inflate\*(C'\fR.
.PP
.Vb 2
\&    use strict ;
\&    use warnings ;
\&    
\&    use Compress::Zlib ;
\&    
\&    my $x = inflateInit()
\&       or die "Cannot create a inflation stream\en" ;
\&    
\&    my $input = \*(Aq\*(Aq ;
\&    binmode STDIN;
\&    binmode STDOUT;
\&    
\&    my ($output, $status) ;
\&    while (read(STDIN, $input, 4096))
\&    {
\&        ($output, $status) = $x\->inflate(\e$input) ;
\&    
\&        print $output 
\&            if $status == Z_OK or $status == Z_STREAM_END ;
\&    
\&        last if $status != Z_OK ;
\&    }
\&    
\&    die "inflation failed\en"
\&        unless $status == Z_STREAM_END ;
.Ve
.SH "CHECKSUM FUNCTIONS"
.IX Header "CHECKSUM FUNCTIONS"
Two functions are provided by \fIzlib\fR to calculate checksums. For the
Perl interface, the order of the two parameters in both functions has
been reversed. This allows both running checksums and one off
calculations to be done.
.PP
.Vb 2
\&    $crc = adler32($buffer [,$crc]) ;
\&    $crc = crc32($buffer [,$crc]) ;
.Ve
.PP
The buffer parameters can either be a scalar or a scalar reference.
.PP
If the \f(CW$crc\fR parameters is \f(CW\*(C`undef\*(C'\fR, the crc value will be reset.
.PP
If you have built this module with zlib 1.2.3 or better, two more
CRC-related functions are available.
.PP
.Vb 2
\&    $crc = adler32_combine($crc1, $crc2, $len2)l
\&    $crc = crc32_combine($adler1, $adler2, $len2)
.Ve
.PP
These functions allow checksums to be merged.
.SH "Misc"
.IX Header "Misc"
.ie n .SS "my $version = \fICompress::Zlib::zlib_version()\fP;"
.el .SS "my \f(CW$version\fP = \fICompress::Zlib::zlib_version()\fP;"
.IX Subsection "my $version = Compress::Zlib::zlib_version();"
Returns the version of the zlib library.
.SH "CONSTANTS"
.IX Header "CONSTANTS"
All the \fIzlib\fR constants are automatically imported when you make use
of \fICompress::Zlib\fR.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
IO::Compress::Gzip, IO::Uncompress::Gunzip, IO::Compress::Deflate, IO::Uncompress::Inflate, IO::Compress::RawDeflate, IO::Uncompress::RawInflate, IO::Compress::Bzip2, IO::Uncompress::Bunzip2, IO::Compress::Lzma, IO::Uncompress::UnLzma, IO::Compress::Xz, IO::Uncompress::UnXz, IO::Compress::Lzop, IO::Uncompress::UnLzop, IO::Compress::Lzf, IO::Uncompress::UnLzf, IO::Uncompress::AnyInflate, IO::Uncompress::AnyUncompress
.PP
IO::Compress::FAQ
.PP
File::GlobMapper, Archive::Zip,
Archive::Tar,
IO::Zlib
.PP
For \s-1RFC 1950, 1951\s0 and 1952 see 
\&\fIhttp://www.faqs.org/rfcs/rfc1950.html\fR,
\&\fIhttp://www.faqs.org/rfcs/rfc1951.html\fR and
\&\fIhttp://www.faqs.org/rfcs/rfc1952.html\fR
.PP
The \fIzlib\fR compression library was written by Jean-loup Gailly
\&\fIgzip@prep.ai.mit.edu\fR and Mark Adler \fImadler@alumni.caltech.edu\fR.
.PP
The primary site for the \fIzlib\fR compression library is
\&\fIhttp://www.zlib.org\fR.
.PP
The primary site for gzip is \fIhttp://www.gzip.org\fR.
.SH "AUTHOR"
.IX Header "AUTHOR"
This module was written by Paul Marquess, \fIpmqs@cpan.org\fR.
.SH "MODIFICATION HISTORY"
.IX Header "MODIFICATION HISTORY"
See the Changes file.
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright (c) 1995\-2013 Paul Marquess. All rights reserved.
.PP
This program is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.
