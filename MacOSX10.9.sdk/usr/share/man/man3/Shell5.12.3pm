.\" Automatically generated by Pod::Man 2.23 (Pod::Simple 3.14)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Shell 3pm"
.TH Shell 3pm "2012-11-03" "perl v5.12.5" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Shell \- run shell commands transparently within perl
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 4
\&   use Shell qw(cat ps cp);
\&   $passwd = cat(\*(Aq</etc/passwd\*(Aq);
\&   @pslines = ps(\*(Aq\-ww\*(Aq),
\&   cp("/etc/passwd", "/tmp/passwd");
\&
\&   # object oriented 
\&   my $sh = Shell\->new;
\&   print $sh\->ls(\*(Aq\-l\*(Aq);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
.SS "Caveats"
.IX Subsection "Caveats"
This package is included as a show case, illustrating a few Perl features.
It shouldn't be used for production programs. Although it does provide a 
simple interface for obtaining the standard output of arbitrary commands,
there may be better ways of achieving what you need.
.PP
Running shell commands while obtaining standard output can be done with the
\&\f(CW\*(C`qx/STRING/\*(C'\fR operator, or by calling \f(CW\*(C`open\*(C'\fR with a filename expression that
ends with \f(CW\*(C`|\*(C'\fR, giving you the option to process one line at a time.
If you don't need to process standard output at all, you might use \f(CW\*(C`system\*(C'\fR
(in preference of doing a print with the collected standard output).
.PP
Since Shell.pm and all of the aforementioned techniques use your system's
shell to call some local command, none of them is portable across different 
systems. Note, however, that there are several built in functions and 
library packages providing portable implementations of functions operating
on files, such as: \f(CW\*(C`glob\*(C'\fR, \f(CW\*(C`link\*(C'\fR and \f(CW\*(C`unlink\*(C'\fR, \f(CW\*(C`mkdir\*(C'\fR and \f(CW\*(C`rmdir\*(C'\fR, 
\&\f(CW\*(C`rename\*(C'\fR, \f(CW\*(C`File::Compare\*(C'\fR, \f(CW\*(C`File::Copy\*(C'\fR, \f(CW\*(C`File::Find\*(C'\fR etc.
.PP
Using Shell.pm while importing \f(CW\*(C`foo\*(C'\fR creates a subroutine \f(CW\*(C`foo\*(C'\fR in the
namespace of the importing package. Calling \f(CW\*(C`foo\*(C'\fR with arguments \f(CW\*(C`arg1\*(C'\fR,
\&\f(CW\*(C`arg2\*(C'\fR,... results in a shell command \f(CW\*(C`foo arg1 arg2...\*(C'\fR, where the 
function name and the arguments are joined with a blank. (See the subsection 
on Escaping magic characters.) Since the result is essentially a command
line to be passed to the shell, your notion of arguments to the Perl
function is not necessarily identical to what the shell treats as a
command line token, to be passed as an individual argument to the program.
Furthermore, note that this implies that \f(CW\*(C`foo\*(C'\fR is callable by file name
only, which frequently depends on the setting of the program's environment.
.PP
Creating a Shell object gives you the opportunity to call any command
in the usual \s-1OO\s0 notation without requiring you to announce it in the
\&\f(CW\*(C`use Shell\*(C'\fR statement. Don't assume any additional semantics being
associated with a Shell object: in no way is it similar to a shell
process with its environment or current working directory or any
other setting.
.SS "Escaping Magic Characters"
.IX Subsection "Escaping Magic Characters"
It is, in general, impossible to take care of quoting the shell's
magic characters. For some obscure reason, however, Shell.pm quotes
apostrophes (\f(CW\*(C`\*(Aq\*(C'\fR) and backslashes (\f(CW\*(C`\e\*(C'\fR) on \s-1UNIX\s0, and spaces and
quotes (\f(CW\*(C`"\*(C'\fR) on Windows.
.SS "Configuration"
.IX Subsection "Configuration"
If you set \f(CW$Shell::capture_stderr\fR to 1, the module will attempt to
capture the standard error output of the process as well. This is
done by adding \f(CW\*(C`2>&1\*(C'\fR to the command line, so don't try this on
a system not supporting this redirection.
.PP
Setting \f(CW$Shell::capture_stderr\fR to \-1 will send standard error to the
bit bucket (i.e., the equivalent of adding \f(CW\*(C`2>/dev/null\*(C'\fR to the
command line).  The same caveat regarding redirection applies.
.PP
If you set \f(CW$Shell::raw\fR to true no quoting whatsoever is done.
.SH "BUGS"
.IX Header "BUGS"
Quoting should be off by default.
.PP
It isn't possible to call shell built in commands, but it can be
done by using a workaround, e.g. shell( '\-c', 'set' ).
.PP
Capturing standard error does not work on some systems (e.g. \s-1VMS\s0).
.SH "AUTHOR"
.IX Header "AUTHOR"
.Vb 5
\&  Date: Thu, 22 Sep 94 16:18:16 \-0700
\&  Message\-Id: <9409222318.AA17072@scalpel.netlabs.com>
\&  To: perl5\-porters@isu.edu
\&  From: Larry Wall <lwall@scalpel.netlabs.com>
\&  Subject: a new module I just wrote
.Ve
.PP
Here's one that'll whack your mind a little out.
.PP
.Vb 1
\&    #!/usr/bin/perl
\&
\&    use Shell;
\&
\&    $foo = echo("howdy", "<funny>", "world");
\&    print $foo;
\&
\&    $passwd = cat("</etc/passwd");
\&    print $passwd;
\&
\&    sub ps;
\&    print ps \-ww;
\&
\&    cp("/etc/passwd", "/etc/passwd.orig");
.Ve
.PP
That's maybe too gonzo.  It actually exports an \s-1AUTOLOAD\s0 to the current
package (and uncovered a bug in Beta 3, by the way).  Maybe the usual
usage should be
.PP
.Vb 1
\&    use Shell qw(echo cat ps cp);
.Ve
.PP
Larry Wall
.PP
Changes by Jenda@Krynicky.cz and Dave Cottle <d.cottle@csc.canterbury.ac.nz>.
.PP
Changes for \s-1OO\s0 syntax and bug fixes by Casey West <casey@geeknest.com>.
.PP
\&\f(CW$Shell::raw\fR and pod rewrite by Wolfgang Laun.
.PP
Rewritten to use closures rather than \f(CW\*(C`eval "string"\*(C'\fR by Adriano Ferreira.
