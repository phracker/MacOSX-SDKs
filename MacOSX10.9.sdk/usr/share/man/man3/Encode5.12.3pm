.\" Automatically generated by Pod::Man 2.23 (Pod::Simple 3.14)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Encode 3pm"
.TH Encode 3pm "2012-11-03" "perl v5.12.5" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Encode \- character encodings
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use Encode;
.Ve
.SS "Table of Contents"
.IX Subsection "Table of Contents"
Encode consists of a collection of modules whose details are too big
to fit in one document.  This \s-1POD\s0 itself explains the top-level APIs
and general topics at a glance.  For other topics and more details,
see the PODs below:
.PP
.Vb 10
\&  Name                          Description
\&  \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&  Encode::Alias         Alias definitions to encodings
\&  Encode::Encoding      Encode Implementation Base Class
\&  Encode::Supported     List of Supported Encodings
\&  Encode::CN            Simplified Chinese Encodings
\&  Encode::JP            Japanese Encodings
\&  Encode::KR            Korean Encodings
\&  Encode::TW            Traditional Chinese Encodings
\&  \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The \f(CW\*(C`Encode\*(C'\fR module provides the interfaces between Perl's strings
and the rest of the system.  Perl strings are sequences of
\&\fBcharacters\fR.
.PP
The repertoire of characters that Perl can represent is at least that
defined by the Unicode Consortium. On most platforms the ordinal
values of the characters (as returned by \f(CW\*(C`ord(ch)\*(C'\fR) is the \*(L"Unicode
codepoint\*(R" for the character (the exceptions are those platforms where
the legacy encoding is some variant of \s-1EBCDIC\s0 rather than a super-set
of \s-1ASCII\s0 \- see perlebcdic).
.PP
Traditionally, computer data has been moved around in 8\-bit chunks
often called \*(L"bytes\*(R". These chunks are also known as \*(L"octets\*(R" in
networking standards. Perl is widely used to manipulate data of many
types \- not only strings of characters representing human or computer
languages but also \*(L"binary\*(R" data being the machine's representation of
numbers, pixels in an image \- or just about anything.
.PP
When Perl is processing \*(L"binary data\*(R", the programmer wants Perl to
process \*(L"sequences of bytes\*(R". This is not a problem for Perl \- as a
byte has 256 possible values, it easily fits in Perl's much larger
\&\*(L"logical character\*(R".
.SS "\s-1TERMINOLOGY\s0"
.IX Subsection "TERMINOLOGY"
.IP "\(bu" 2
\&\fIcharacter\fR: a character in the range 0..(2**32\-1) (or more).
(What Perl's strings are made of.)
.IP "\(bu" 2
\&\fIbyte\fR: a character in the range 0..255
(A special case of a Perl character.)
.IP "\(bu" 2
\&\fIoctet\fR: 8 bits of data, with ordinal values 0..255
(Term for bytes passed to or from a non-Perl context, e.g. a disk file.)
.SH "PERL ENCODING API"
.IX Header "PERL ENCODING API"
.ie n .IP "$octets  = encode(\s-1ENCODING\s0, $string [, \s-1CHECK\s0])" 2
.el .IP "\f(CW$octets\fR  = encode(\s-1ENCODING\s0, \f(CW$string\fR [, \s-1CHECK\s0])" 2
.IX Item "$octets  = encode(ENCODING, $string [, CHECK])"
Encodes a string from Perl's internal form into \fI\s-1ENCODING\s0\fR and returns
a sequence of octets.  \s-1ENCODING\s0 can be either a canonical name or
an alias.  For encoding names and aliases, see \*(L"Defining Aliases\*(R".
For \s-1CHECK\s0, see \*(L"Handling Malformed Data\*(R".
.Sp
For example, to convert a string from Perl's internal format to
iso\-8859\-1 (also known as Latin1),
.Sp
.Vb 1
\&  $octets = encode("iso\-8859\-1", $string);
.Ve
.Sp
\&\fB\s-1CAVEAT\s0\fR: When you run \f(CW\*(C`$octets = encode("utf8", $string)\*(C'\fR, then
\&\f(CW$octets\fR \fBmay not be equal to\fR \f(CW$string\fR.  Though they both contain the
same data, the \s-1UTF8\s0 flag for \f(CW$octets\fR is \fBalways\fR off.  When you
encode anything, \s-1UTF8\s0 flag of the result is always off, even when it
contains completely valid utf8 string. See \*(L"The \s-1UTF8\s0 flag\*(R" below.
.Sp
If the \f(CW$string\fR is \f(CW\*(C`undef\*(C'\fR then \f(CW\*(C`undef\*(C'\fR is returned.
.ie n .IP "$string = decode(\s-1ENCODING\s0, $octets [, \s-1CHECK\s0])" 2
.el .IP "\f(CW$string\fR = decode(\s-1ENCODING\s0, \f(CW$octets\fR [, \s-1CHECK\s0])" 2
.IX Item "$string = decode(ENCODING, $octets [, CHECK])"
Decodes a sequence of octets assumed to be in \fI\s-1ENCODING\s0\fR into Perl's
internal form and returns the resulting string.  As in \fIencode()\fR,
\&\s-1ENCODING\s0 can be either a canonical name or an alias. For encoding names
and aliases, see \*(L"Defining Aliases\*(R".  For \s-1CHECK\s0, see
\&\*(L"Handling Malformed Data\*(R".
.Sp
For example, to convert \s-1ISO\-8859\-1\s0 data to a string in Perl's internal format:
.Sp
.Vb 1
\&  $string = decode("iso\-8859\-1", $octets);
.Ve
.Sp
\&\fB\s-1CAVEAT\s0\fR: When you run \f(CW\*(C`$string = decode("utf8", $octets)\*(C'\fR, then \f(CW$string\fR
\&\fBmay not be equal to\fR \f(CW$octets\fR.  Though they both contain the same data,
the \s-1UTF8\s0 flag for \f(CW$string\fR is on unless \f(CW$octets\fR entirely consists of
\&\s-1ASCII\s0 data (or \s-1EBCDIC\s0 on \s-1EBCDIC\s0 machines).  See \*(L"The \s-1UTF8\s0 flag\*(R"
below.
.Sp
If the \f(CW$string\fR is \f(CW\*(C`undef\*(C'\fR then \f(CW\*(C`undef\*(C'\fR is returned.
.IP "[$obj =] find_encoding(\s-1ENCODING\s0)" 2
.IX Item "[$obj =] find_encoding(ENCODING)"
Returns the \fIencoding object\fR corresponding to \s-1ENCODING\s0.  Returns
undef if no matching \s-1ENCODING\s0 is find.
.Sp
This object is what actually does the actual (en|de)coding.
.Sp
.Vb 1
\&  $utf8 = decode($name, $bytes);
.Ve
.Sp
is in fact
.Sp
.Vb 5
\&  $utf8 = do{
\&    $obj = find_encoding($name);
\&    croak qq(encoding "$name" not found) unless ref $obj;
\&    $obj\->decode($bytes)
\&  };
.Ve
.Sp
with more error checking.
.Sp
Therefore you can save time by reusing this object as follows;
.Sp
.Vb 5
\&  my $enc = find_encoding("iso\-8859\-1");
\&  while(<>){
\&     my $utf8 = $enc\->decode($_);
\&     # and do someting with $utf8;
\&  }
.Ve
.Sp
Besides \f(CW\*(C`\->decode\*(C'\fR and \f(CW\*(C`\->encode\*(C'\fR, other methods are
available as well.  For instance, \f(CW\*(C`\-> name\*(C'\fR returns the canonical
name of the encoding object.
.Sp
.Vb 1
\&  find_encoding("latin1")\->name; # iso\-8859\-1
.Ve
.Sp
See Encode::Encoding for details.
.IP "[$length =] from_to($octets, \s-1FROM_ENC\s0, \s-1TO_ENC\s0 [, \s-1CHECK\s0])" 2
.IX Item "[$length =] from_to($octets, FROM_ENC, TO_ENC [, CHECK])"
Converts \fBin-place\fR data between two encodings. The data in \f(CW$octets\fR
must be encoded as octets and not as characters in Perl's internal
format. For example, to convert \s-1ISO\-8859\-1\s0 data to Microsoft's \s-1CP1250\s0
encoding:
.Sp
.Vb 1
\&  from_to($octets, "iso\-8859\-1", "cp1250");
.Ve
.Sp
and to convert it back:
.Sp
.Vb 1
\&  from_to($octets, "cp1250", "iso\-8859\-1");
.Ve
.Sp
Note that because the conversion happens in place, the data to be
converted cannot be a string constant; it must be a scalar variable.
.Sp
\&\fIfrom_to()\fR returns the length of the converted string in octets on
success, \fIundef\fR on error.
.Sp
\&\fB\s-1CAVEAT\s0\fR: The following operations look the same but are not quite so;
.Sp
.Vb 2
\&  from_to($data, "iso\-8859\-1", "utf8"); #1
\&  $data = decode("iso\-8859\-1", $data);  #2
.Ve
.Sp
Both #1 and #2 make \f(CW$data\fR consist of a completely valid \s-1UTF\-8\s0 string
but only #2 turns \s-1UTF8\s0 flag on.  #1 is equivalent to
.Sp
.Vb 1
\&  $data = encode("utf8", decode("iso\-8859\-1", $data));
.Ve
.Sp
See \*(L"The \s-1UTF8\s0 flag\*(R" below.
.Sp
Also note that
.Sp
.Vb 1
\&  from_to($octets, $from, $to, $check);
.Ve
.Sp
is equivalent to
.Sp
.Vb 1
\&  $octets = encode($to, decode($from, $octets), $check);
.Ve
.Sp
Yes, it does not respect the \f(CW$check\fR during decoding.  It is
deliberately done that way.  If you need minute control, \f(CW\*(C`decode\*(C'\fR
then \f(CW\*(C`encode\*(C'\fR as follows;
.Sp
.Vb 1
\&  $octets = encode($to, decode($from, $octets, $check_from), $check_to);
.Ve
.ie n .IP "$octets = encode_utf8($string);" 2
.el .IP "\f(CW$octets\fR = encode_utf8($string);" 2
.IX Item "$octets = encode_utf8($string);"
Equivalent to \f(CW\*(C`$octets = encode("utf8", $string);\*(C'\fR The characters
that comprise \f(CW$string\fR are encoded in Perl's internal format and the
result is returned as a sequence of octets. All possible
characters have a \s-1UTF\-8\s0 representation so this function cannot fail.
.ie n .IP "$string = decode_utf8($octets [, \s-1CHECK\s0]);" 2
.el .IP "\f(CW$string\fR = decode_utf8($octets [, \s-1CHECK\s0]);" 2
.IX Item "$string = decode_utf8($octets [, CHECK]);"
equivalent to \f(CW\*(C`$string = decode("utf8", $octets [, CHECK])\*(C'\fR.
The sequence of octets represented by
\&\f(CW$octets\fR is decoded from \s-1UTF\-8\s0 into a sequence of logical
characters. Not all sequences of octets form valid \s-1UTF\-8\s0 encodings, so
it is possible for this call to fail.  For \s-1CHECK\s0, see
\&\*(L"Handling Malformed Data\*(R".
.SS "Listing available encodings"
.IX Subsection "Listing available encodings"
.Vb 2
\&  use Encode;
\&  @list = Encode\->encodings();
.Ve
.PP
Returns a list of the canonical names of the available encodings that
are loaded.  To get a list of all available encodings including the
ones that are not loaded yet, say
.PP
.Vb 1
\&  @all_encodings = Encode\->encodings(":all");
.Ve
.PP
Or you can give the name of a specific module.
.PP
.Vb 1
\&  @with_jp = Encode\->encodings("Encode::JP");
.Ve
.PP
When \*(L"::\*(R" is not in the name, \*(L"Encode::\*(R" is assumed.
.PP
.Vb 1
\&  @ebcdic = Encode\->encodings("EBCDIC");
.Ve
.PP
To find out in detail which encodings are supported by this package,
see Encode::Supported.
.SS "Defining Aliases"
.IX Subsection "Defining Aliases"
To add a new alias to a given encoding, use:
.PP
.Vb 3
\&  use Encode;
\&  use Encode::Alias;
\&  define_alias(newName => ENCODING);
.Ve
.PP
After that, newName can be used as an alias for \s-1ENCODING\s0.
\&\s-1ENCODING\s0 may be either the name of an encoding or an
\&\fIencoding object\fR
.PP
But before you do so, make sure the alias is nonexistent with
\&\f(CW\*(C`resolve_alias()\*(C'\fR, which returns the canonical name thereof.
i.e.
.PP
.Vb 3
\&  Encode::resolve_alias("latin1") eq "iso\-8859\-1" # true
\&  Encode::resolve_alias("iso\-8859\-12")   # false; nonexistent
\&  Encode::resolve_alias($name) eq $name  # true if $name is canonical
.Ve
.PP
\&\fIresolve_alias()\fR does not need \f(CW\*(C`use Encode::Alias\*(C'\fR; it can be
exported via \f(CW\*(C`use Encode qw(resolve_alias)\*(C'\fR.
.PP
See Encode::Alias for details.
.SS "Finding \s-1IANA\s0 Character Set Registry names"
.IX Subsection "Finding IANA Character Set Registry names"
The canonical name of a given encoding does not necessarily agree with
\&\s-1IANA\s0 \s-1IANA\s0 Character Set Registry, commonly seen as \f(CW\*(C`Content\-Type:
text/plain; charset=\f(CIwhatever\f(CW\*(C'\fR.  For most cases canonical names
work but sometimes it does not (notably 'utf\-8\-strict').
.PP
Therefore as of Encode version 2.21, a new method \f(CW\*(C`mime_name()\*(C'\fR is added.
.PP
.Vb 4
\&  use Encode;
\&  my $enc = find_encoding(\*(AqUTF\-8\*(Aq);
\&  warn $enc\->name;      # utf\-8\-strict
\&  warn $enc\->mime_name; # UTF\-8
.Ve
.PP
See also:  Encode::Encoding
.SH "Encoding via PerlIO"
.IX Header "Encoding via PerlIO"
If your perl supports \fIPerlIO\fR (which is the default), you can use a
PerlIO layer to decode and encode directly via a filehandle.  The
following two examples are totally identical in their functionality.
.PP
.Vb 4
\&  # via PerlIO
\&  open my $in,  "<:encoding(shiftjis)", $infile  or die;
\&  open my $out, ">:encoding(euc\-jp)",   $outfile or die;
\&  while(<$in>){ print $out $_; }
\&
\&  # via from_to
\&  open my $in,  "<", $infile  or die;
\&  open my $out, ">", $outfile or die;
\&  while(<$in>){
\&    from_to($_, "shiftjis", "euc\-jp", 1);
\&    print $out $_;
\&  }
.Ve
.PP
Unfortunately, it may be that encodings are PerlIO-savvy.  You can check
if your encoding is supported by PerlIO by calling the \f(CW\*(C`perlio_ok\*(C'\fR
method.
.PP
.Vb 2
\&  Encode::perlio_ok("hz");             # False
\&  find_encoding("euc\-cn")\->perlio_ok;  # True where PerlIO is available
\&
\&  use Encode qw(perlio_ok);            # exported upon request
\&  perlio_ok("euc\-jp")
.Ve
.PP
Fortunately, all encodings that come with Encode core are PerlIO-savvy
except for hz and ISO\-2022\-kr.  For gory details, see
Encode::Encoding and Encode::PerlIO.
.SH "Handling Malformed Data"
.IX Header "Handling Malformed Data"
The optional \fI\s-1CHECK\s0\fR argument tells Encode what to do when it
encounters malformed data.  Without \s-1CHECK\s0, Encode::FB_DEFAULT ( == 0 )
is assumed.
.PP
As of version 2.12 Encode supports coderef values for \s-1CHECK\s0.  See below.
.IP "\fB\s-1NOTE:\s0\fR Not all encoding support this feature" 2
.IX Item "NOTE: Not all encoding support this feature"
Some encodings ignore \fI\s-1CHECK\s0\fR argument.  For example,
Encode::Unicode ignores \fI\s-1CHECK\s0\fR and it always croaks on error.
.PP
Now here is the list of \fI\s-1CHECK\s0\fR values available
.IP "\fI\s-1CHECK\s0\fR = Encode::FB_DEFAULT ( == 0)" 2
.IX Item "CHECK = Encode::FB_DEFAULT ( == 0)"
If \fI\s-1CHECK\s0\fR is 0, (en|de)code will put a \fIsubstitution character\fR in
place of a malformed character.  When you encode, <subchar>
will be used.  When you decode the code point \f(CW0xFFFD\fR is used.  If
the data is supposed to be \s-1UTF\-8\s0, an optional lexical warning
(category utf8) is given.
.IP "\fI\s-1CHECK\s0\fR = Encode::FB_CROAK ( == 1)" 2
.IX Item "CHECK = Encode::FB_CROAK ( == 1)"
If \fI\s-1CHECK\s0\fR is 1, methods will die on error immediately with an error
message.  Therefore, when \fI\s-1CHECK\s0\fR is set to 1,  you should trap the
error with eval{} unless you really want to let it die.
.IP "\fI\s-1CHECK\s0\fR = Encode::FB_QUIET" 2
.IX Item "CHECK = Encode::FB_QUIET"
If \fI\s-1CHECK\s0\fR is set to Encode::FB_QUIET, (en|de)code will immediately
return the portion of the data that has been processed so far when an
error occurs. The data argument will be overwritten with everything
after that point (that is, the unprocessed part of data).  This is
handy when you have to call decode repeatedly in the case where your
source data may contain partial multi-byte character sequences,
(i.e. you are reading with a fixed-width buffer). Here is a sample
code that does exactly this:
.Sp
.Vb 5
\&  my $buffer = \*(Aq\*(Aq; my $string = \*(Aq\*(Aq;
\&  while(read $fh, $buffer, 256, length($buffer)){
\&    $string .= decode($encoding, $buffer, Encode::FB_QUIET);
\&    # $buffer now contains the unprocessed partial character
\&  }
.Ve
.IP "\fI\s-1CHECK\s0\fR = Encode::FB_WARN" 2
.IX Item "CHECK = Encode::FB_WARN"
This is the same as above, except that it warns on error.  Handy when
you are debugging the mode above.
.IP "perlqq mode (\fI\s-1CHECK\s0\fR = Encode::FB_PERLQQ)" 2
.IX Item "perlqq mode (CHECK = Encode::FB_PERLQQ)"
.PD 0
.IP "\s-1HTML\s0 charref mode (\fI\s-1CHECK\s0\fR = Encode::FB_HTMLCREF)" 2
.IX Item "HTML charref mode (CHECK = Encode::FB_HTMLCREF)"
.IP "\s-1XML\s0 charref mode (\fI\s-1CHECK\s0\fR = Encode::FB_XMLCREF)" 2
.IX Item "XML charref mode (CHECK = Encode::FB_XMLCREF)"
.PD
For encodings that are implemented by Encode::XS, \s-1CHECK\s0 ==
Encode::FB_PERLQQ turns (en|de)code into \f(CW\*(C`perlqq\*(C'\fR fallback mode.
.Sp
When you decode, \f(CW\*(C`\ex\f(CIHH\f(CW\*(C'\fR will be inserted for a malformed character,
where \fI\s-1HH\s0\fR is the hex representation of the octet  that could not be
decoded to utf8.  And when you encode, \f(CW\*(C`\ex{\f(CIHHHH\f(CW}\*(C'\fR will be inserted,
where \fI\s-1HHHH\s0\fR is the Unicode \s-1ID\s0 of the character that cannot be found
in the character repertoire of the encoding.
.Sp
\&\s-1HTML/XML\s0 character reference modes are about the same, in place of
\&\f(CW\*(C`\ex{\f(CIHHHH\f(CW}\*(C'\fR, \s-1HTML\s0 uses \f(CW\*(C`&#\f(CINNN\f(CW;\*(C'\fR where \fI\s-1NNN\s0\fR is a decimal number and
\&\s-1XML\s0 uses \f(CW\*(C`&#x\f(CIHHHH\f(CW;\*(C'\fR where \fI\s-1HHHH\s0\fR is the hexadecimal number.
.Sp
In Encode 2.10 or later, \f(CW\*(C`LEAVE_SRC\*(C'\fR is also implied.
.IP "The bitmask" 2
.IX Item "The bitmask"
These modes are actually set via a bitmask.  Here is how the \s-1FB_XX\s0
constants are laid out.  You can import the \s-1FB_XX\s0 constants via
\&\f(CW\*(C`use Encode qw(:fallbacks)\*(C'\fR; you can import the generic bitmask
constants via \f(CW\*(C`use Encode qw(:fallback_all)\*(C'\fR.
.Sp
.Vb 8
\&                     FB_DEFAULT FB_CROAK FB_QUIET FB_WARN  FB_PERLQQ
\& DIE_ON_ERR    0x0001             X
\& WARN_ON_ERR   0x0002                               X
\& RETURN_ON_ERR 0x0004                      X        X
\& LEAVE_SRC     0x0008                                        X
\& PERLQQ        0x0100                                        X
\& HTMLCREF      0x0200
\& XMLCREF       0x0400
.Ve
.IP "Encode::LEAVE_SRC" 2
.IX Item "Encode::LEAVE_SRC"
If the \f(CW\*(C`Encode::LEAVE_SRC\*(C'\fR bit is not set, but \fI\s-1CHECK\s0\fR is, then the second
argument to \f(CW\*(C`encode()\*(C'\fR or \f(CW\*(C`decode()\*(C'\fR may be assigned to by the functions. If
you're not interested in this, then bitwise-or the bitmask with it.
.SS "coderef for \s-1CHECK\s0"
.IX Subsection "coderef for CHECK"
As of Encode 2.12 \s-1CHECK\s0 can also be a code reference which takes the
ord value of unmapped caharacter as an argument and returns a string
that represents the fallback character.  For instance,
.PP
.Vb 1
\&  $ascii = encode("ascii", $utf8, sub{ sprintf "<U+%04X>", shift });
.Ve
.PP
Acts like \s-1FB_PERLQQ\s0 but <U+\fI\s-1XXXX\s0\fR> is used instead of
\&\ex{\fI\s-1XXXX\s0\fR}.
.SH "Defining Encodings"
.IX Header "Defining Encodings"
To define a new encoding, use:
.PP
.Vb 2
\&    use Encode qw(define_encoding);
\&    define_encoding($object, \*(AqcanonicalName\*(Aq [, alias...]);
.Ve
.PP
\&\fIcanonicalName\fR will be associated with \fI\f(CI$object\fI\fR.  The object
should provide the interface described in Encode::Encoding.
If more than two arguments are provided then additional
arguments are taken as aliases for \fI\f(CI$object\fI\fR.
.PP
See Encode::Encoding for more details.
.SH "The UTF8 flag"
.IX Header "The UTF8 flag"
Before the introduction of Unicode support in perl, The \f(CW\*(C`eq\*(C'\fR operator
just compared the strings represented by two scalars. Beginning with
perl 5.8, \f(CW\*(C`eq\*(C'\fR compares two strings with simultaneous consideration of
\&\fIthe \s-1UTF8\s0 flag\fR. To explain why we made it so, I will quote page 402 of
\&\f(CW\*(C`Programming Perl, 3rd ed.\*(C'\fR
.IP "Goal #1:" 2
.IX Item "Goal #1:"
Old byte-oriented programs should not spontaneously break on the old
byte-oriented data they used to work on.
.IP "Goal #2:" 2
.IX Item "Goal #2:"
Old byte-oriented programs should magically start working on the new
character-oriented data when appropriate.
.IP "Goal #3:" 2
.IX Item "Goal #3:"
Programs should run just as fast in the new character-oriented mode
as in the old byte-oriented mode.
.IP "Goal #4:" 2
.IX Item "Goal #4:"
Perl should remain one language, rather than forking into a
byte-oriented Perl and a character-oriented Perl.
.PP
Back when \f(CW\*(C`Programming Perl, 3rd ed.\*(C'\fR was written, not even Perl 5.6.0
was born and many features documented in the book remained
unimplemented for a long time.  Perl 5.8 corrected this and the introduction
of the \s-1UTF8\s0 flag is one of them.  You can think of this perl notion as of a
byte-oriented mode (\s-1UTF8\s0 flag off) and a character-oriented mode (\s-1UTF8\s0
flag on).
.PP
Here is how Encode takes care of the \s-1UTF8\s0 flag.
.IP "\(bu" 2
When you encode, the resulting \s-1UTF8\s0 flag is always off.
.IP "\(bu" 2
When you decode, the resulting \s-1UTF8\s0 flag is on unless you can
unambiguously represent data.  Here is the definition of
dis-ambiguity.
.Sp
After \f(CW\*(C`$utf8 = decode(\*(Aqfoo\*(Aq, $octet);\*(C'\fR,
.Sp
.Vb 6
\&  When $octet is...   The UTF8 flag in $utf8 is
\&  \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&  In ASCII only (or EBCDIC only)            OFF
\&  In ISO\-8859\-1                              ON
\&  In any other Encoding                      ON
\&  \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
.Ve
.Sp
As you see, there is one exception, In \s-1ASCII\s0.  That way you can assume
Goal #1.  And with Encode Goal #2 is assumed but you still have to be
careful in such cases mentioned in \fB\s-1CAVEAT\s0\fR paragraphs.
.Sp
This \s-1UTF8\s0 flag is not visible in perl scripts, exactly for the same
reason you cannot (or you \fIdon't have to\fR) see if a scalar contains a
string, integer, or floating point number.   But you can still peek
and poke these if you will.  See the section below.
.SS "Messing with Perl's Internals"
.IX Subsection "Messing with Perl's Internals"
The following \s-1API\s0 uses parts of Perl's internals in the current
implementation.  As such, they are efficient but may change.
.IP "is_utf8(\s-1STRING\s0 [, \s-1CHECK\s0])" 2
.IX Item "is_utf8(STRING [, CHECK])"
[\s-1INTERNAL\s0] Tests whether the \s-1UTF8\s0 flag is turned on in the \s-1STRING\s0.
If \s-1CHECK\s0 is true, also checks the data in \s-1STRING\s0 for being well-formed
\&\s-1UTF\-8\s0.  Returns true if successful, false otherwise.
.Sp
As of perl 5.8.1, utf8 also has \fIutf8::is_utf8()\fR.
.IP "_utf8_on(\s-1STRING\s0)" 2
.IX Item "_utf8_on(STRING)"
[\s-1INTERNAL\s0] Turns on the \s-1UTF8\s0 flag in \s-1STRING\s0.  The data in \s-1STRING\s0 is
\&\fBnot\fR checked for being well-formed \s-1UTF\-8\s0.  Do not use unless you
\&\fBknow\fR that the \s-1STRING\s0 is well-formed \s-1UTF\-8\s0.  Returns the previous
state of the \s-1UTF8\s0 flag (so please don't treat the return value as
indicating success or failure), or \f(CW\*(C`undef\*(C'\fR if \s-1STRING\s0 is not a string.
.Sp
This function does not work on tainted values.
.IP "_utf8_off(\s-1STRING\s0)" 2
.IX Item "_utf8_off(STRING)"
[\s-1INTERNAL\s0] Turns off the \s-1UTF8\s0 flag in \s-1STRING\s0.  Do not use frivolously.
Returns the previous state of the \s-1UTF8\s0 flag (so please don't treat the
return value as indicating success or failure), or \f(CW\*(C`undef\*(C'\fR if \s-1STRING\s0 is
not a string.
.Sp
This function does not work on tainted values.
.SH "UTF\-8 vs. utf8 vs. UTF8"
.IX Header "UTF-8 vs. utf8 vs. UTF8"
.Vb 3
\&  ....We now view strings not as sequences of bytes, but as sequences
\&  of numbers in the range 0 .. 2**32\-1 (or in the case of 64\-bit
\&  computers, 0 .. 2**64\-1) \-\- Programming Perl, 3rd ed.
.Ve
.PP
That has been the perl's notion of \s-1UTF\-8\s0 but official \s-1UTF\-8\s0 is more
strict; Its ranges is much narrower (0 .. 10FFFF), some sequences are
not allowed (i.e. Those used in the surrogate pair, 0xFFFE, et al).
.PP
Now that is overruled by Larry Wall himself.
.PP
.Vb 5
\&  From: Larry Wall <larry@wall.org>
\&  Date: December 04, 2004 11:51:58 JST
\&  To: perl\-unicode@perl.org
\&  Subject: Re: Make Encode.pm support the real UTF\-8
\&  Message\-Id: <20041204025158.GA28754@wall.org>
\&  
\&  On Fri, Dec 03, 2004 at 10:12:12PM +0000, Tim Bunce wrote:
\&  : I\*(Aqve no problem with \*(Aqutf8\*(Aq being perl\*(Aqs unrestricted uft8 encoding,
\&  : but "UTF\-8" is the name of the standard and should give the
\&  : corresponding behaviour.
\&  
\&  For what it\*(Aqs worth, that\*(Aqs how I\*(Aqve always kept them straight in my
\&  head.
\&  
\&  Also for what it\*(Aqs worth, Perl 6 will mostly default to strict but
\&  make it easy to switch back to lax.
\&  
\&  Larry
.Ve
.PP
Do you copy?  As of Perl 5.8.7, \fB\s-1UTF\-8\s0\fR means strict, official \s-1UTF\-8\s0
while \fButf8\fR means liberal, lax, version thereof.  And Encode version
2.10 or later thus groks the difference between \f(CW\*(C`UTF\-8\*(C'\fR and C\*(L"utf8\*(R".
.PP
.Vb 2
\&  encode("utf8",  "\ex{FFFF_FFFF}", 1); # okay
\&  encode("UTF\-8", "\ex{FFFF_FFFF}", 1); # croaks
.Ve
.PP
\&\f(CW\*(C`UTF\-8\*(C'\fR in Encode is actually a canonical name for \f(CW\*(C`utf\-8\-strict\*(C'\fR.
Yes, the hyphen between \*(L"\s-1UTF\s0\*(R" and \*(L"8\*(R" is important.  Without it Encode
goes \*(L"liberal\*(R"
.PP
.Vb 4
\&  find_encoding("UTF\-8")\->name # is \*(Aqutf\-8\-strict\*(Aq
\&  find_encoding("utf\-8")\->name # ditto. names are case insensitive
\&  find_encoding("utf_8")\->name  # ditto. "_" are treated as "\-"
\&  find_encoding("UTF8")\->name  # is \*(Aqutf8\*(Aq.
.Ve
.PP
The \s-1UTF8\s0 flag is internally called \s-1UTF8\s0, without a hyphen. It indicates
whether a string is internally encoded as utf8, also without a hypen.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Encode::Encoding,
Encode::Supported,
Encode::PerlIO,
encoding,
perlebcdic,
\&\*(L"open\*(R" in perlfunc,
perlunicode, perluniintro, perlunifaq, perlunitut
utf8,
the Perl Unicode Mailing List <perl\-unicode@perl.org>
.SH "MAINTAINER"
.IX Header "MAINTAINER"
This project was originated by Nick Ing-Simmons and later maintained
by Dan Kogai <dankogai@dan.co.jp>.  See \s-1AUTHORS\s0 for a full
list of people involved.  For any questions, use
<perl\-unicode@perl.org> so we can all share.
.PP
While Dan Kogai retains the copyright as a maintainer, the credit
should go to all those involoved.  See \s-1AUTHORS\s0 for those submitted
codes.
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright 2002\-2006 Dan Kogai <dankogai@dan.co.jp>
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.
