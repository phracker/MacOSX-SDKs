.\" Automatically generated by Pod::Man 2.23 (Pod::Simple 3.14)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "charnames 3pm"
.TH charnames 3pm "2012-11-03" "perl v5.12.5" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
charnames \- define character names for "\eN{named}" string literal escapes
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&  use charnames \*(Aq:full\*(Aq;
\&  print "\eN{GREEK SMALL LETTER SIGMA} is called sigma.\en";
\&
\&  use charnames \*(Aq:short\*(Aq;
\&  print "\eN{greek:Sigma} is an upper\-case sigma.\en";
\&
\&  use charnames qw(cyrillic greek);
\&  print "\eN{sigma} is Greek sigma, and \eN{be} is Cyrillic b.\en";
\&
\&  use charnames ":full", ":alias" => {
\&    e_ACUTE => "LATIN SMALL LETTER E WITH ACUTE",
\&  };
\&  print "\eN{e_ACUTE} is a small letter e with an acute.\en";
\&
\&  use charnames ();
\&  print charnames::viacode(0x1234); # prints "ETHIOPIC SYLLABLE SEE"
\&  printf "%04X", charnames::vianame("GOTHIC LETTER AHSA"); # prints "10330"
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Pragma \f(CW\*(C`use charnames\*(C'\fR supports arguments \f(CW\*(C`:full\*(C'\fR, \f(CW\*(C`:short\*(C'\fR, script
names and customized aliases.  If \f(CW\*(C`:full\*(C'\fR is present, for expansion of
\&\f(CW\*(C`\eN{CHARNAME}\*(C'\fR, the string \f(CW\*(C`CHARNAME\*(C'\fR is first looked up in the list of
standard Unicode character names.  If \f(CW\*(C`:short\*(C'\fR is present, and
\&\f(CW\*(C`CHARNAME\*(C'\fR has the form \f(CW\*(C`SCRIPT:CNAME\*(C'\fR, then \f(CW\*(C`CNAME\*(C'\fR is looked up
as a letter in script \f(CW\*(C`SCRIPT\*(C'\fR.  If pragma \f(CW\*(C`use charnames\*(C'\fR is used
with script name arguments, then for \f(CW\*(C`\eN{CHARNAME}\*(C'\fR the name
\&\f(CW\*(C`CHARNAME\*(C'\fR is looked up as a letter in the given scripts (in the
specified order). Customized aliases are explained in \*(L"\s-1CUSTOM\s0 \s-1ALIASES\s0\*(R".
.PP
For lookup of \f(CW\*(C`CHARNAME\*(C'\fR inside a given script \f(CW\*(C`SCRIPTNAME\*(C'\fR
this pragma looks for the names
.PP
.Vb 3
\&  SCRIPTNAME CAPITAL LETTER CHARNAME
\&  SCRIPTNAME SMALL LETTER CHARNAME
\&  SCRIPTNAME LETTER CHARNAME
.Ve
.PP
in the table of standard Unicode names.  If \f(CW\*(C`CHARNAME\*(C'\fR is lowercase,
then the \f(CW\*(C`CAPITAL\*(C'\fR variant is ignored, otherwise the \f(CW\*(C`SMALL\*(C'\fR variant
is ignored.
.PP
Note that \f(CW\*(C`\eN{...}\*(C'\fR is compile-time, it's a special form of string
constant used inside double-quoted strings: in other words, you cannot
use variables inside the \f(CW\*(C`\eN{...}\*(C'\fR.  If you want similar run-time
functionality, use \fIcharnames::vianame()\fR.
.PP
For the C0 and C1 control characters (U+0000..U+001F, U+0080..U+009F)
as of Unicode 3.1, there are no official Unicode names but you can use
instead the \s-1ISO\s0 6429 names (\s-1LINE\s0 \s-1FEED\s0, \s-1ESCAPE\s0, and so forth).  In
Unicode 3.2 (as of Perl 5.8) some naming changes take place \s-1ISO\s0 6429
has been updated, see \*(L"\s-1ALIASES\s0\*(R".  Also note that the U+UU80, U+0081,
U+0084, and U+0099 do not have names even in \s-1ISO\s0 6429.
.PP
Since the Unicode standard uses \*(L"U+HHHH\*(R", so can you: \*(L"\eN{U+263a}\*(R"
is the Unicode smiley face, or \*(L"\eN{\s-1WHITE\s0 \s-1SMILING\s0 \s-1FACE\s0}\*(R".
.SH "ALIASES"
.IX Header "ALIASES"
A few aliases have been defined for convenience: instead of having
to use the official names
.PP
.Vb 4
\&    LINE FEED (LF)
\&    FORM FEED (FF)
\&    CARRIAGE RETURN (CR)
\&    NEXT LINE (NEL)
.Ve
.PP
(yes, with parentheses) one can use
.PP
.Vb 8
\&    LINE FEED
\&    FORM FEED
\&    CARRIAGE RETURN
\&    NEXT LINE
\&    LF
\&    FF
\&    CR
\&    NEL
.Ve
.PP
One can also use
.PP
.Vb 2
\&    BYTE ORDER MARK
\&    BOM
.Ve
.PP
and
.PP
.Vb 2
\&    ZWNJ
\&    ZWJ
.Ve
.PP
for \s-1ZERO\s0 \s-1WIDTH\s0 NON-JOINER and \s-1ZERO\s0 \s-1WIDTH\s0 \s-1JOINER\s0.
.PP
For backward compatibility one can use the old names for
certain C0 and C1 controls
.PP
.Vb 1
\&    old                         new
\&
\&    HORIZONTAL TABULATION       CHARACTER TABULATION
\&    VERTICAL TABULATION         LINE TABULATION
\&    FILE SEPARATOR              INFORMATION SEPARATOR FOUR
\&    GROUP SEPARATOR             INFORMATION SEPARATOR THREE
\&    RECORD SEPARATOR            INFORMATION SEPARATOR TWO
\&    UNIT SEPARATOR              INFORMATION SEPARATOR ONE
\&    PARTIAL LINE DOWN           PARTIAL LINE FORWARD
\&    PARTIAL LINE UP             PARTIAL LINE BACKWARD
.Ve
.PP
but the old names in addition to giving the character
will also give a warning about being deprecated.
.SH "CUSTOM ALIASES"
.IX Header "CUSTOM ALIASES"
This version of charnames supports three mechanisms of adding local
or customized aliases to standard Unicode naming conventions (:full).
.PP
Note that an alias should not be something that is a legal curly
brace-enclosed quantifier (see \*(L"\s-1QUANTIFIERS\s0\*(R" in perlreref).  For example
\&\f(CW\*(C`\eN{123}\*(C'\fR means to match 123 non-newline characters, and is not treated as an
alias.  Aliases are discouraged from beginning with anything other than an
alphabetic character and from containing anything other than alphanumerics,
spaces, dashes, colons, parentheses, and underscores.  Currently they must be
\&\s-1ASCII\s0.
.SS "Anonymous hashes"
.IX Subsection "Anonymous hashes"
.Vb 4
\&    use charnames ":full", ":alias" => {
\&        e_ACUTE => "LATIN SMALL LETTER E WITH ACUTE",
\&        };
\&    my $str = "\eN{e_ACUTE}";
.Ve
.SS "Alias file"
.IX Subsection "Alias file"
.Vb 1
\&    use charnames ":full", ":alias" => "pro";
\&
\&    will try to read "unicore/pro_alias.pl" from the @INC path. This
\&    file should return a list in plain perl:
\&
\&    (
\&    A_GRAVE         => "LATIN CAPITAL LETTER A WITH GRAVE",
\&    A_CIRCUM        => "LATIN CAPITAL LETTER A WITH CIRCUMFLEX",
\&    A_DIAERES       => "LATIN CAPITAL LETTER A WITH DIAERESIS",
\&    A_TILDE         => "LATIN CAPITAL LETTER A WITH TILDE",
\&    A_BREVE         => "LATIN CAPITAL LETTER A WITH BREVE",
\&    A_RING          => "LATIN CAPITAL LETTER A WITH RING ABOVE",
\&    A_MACRON        => "LATIN CAPITAL LETTER A WITH MACRON",
\&    );
.Ve
.SS "Alias shortcut"
.IX Subsection "Alias shortcut"
.Vb 1
\&    use charnames ":alias" => ":pro";
\&
\&    works exactly the same as the alias pairs, only this time,
\&    ":full" is inserted automatically as first argument (if no
\&    other argument is given).
.Ve
.SH "charnames::viacode(code)"
.IX Header "charnames::viacode(code)"
Returns the full name of the character indicated by the numeric code.
The example
.PP
.Vb 1
\&    print charnames::viacode(0x2722);
.Ve
.PP
prints \*(L"\s-1FOUR\s0 TEARDROP-SPOKED \s-1ASTERISK\s0\*(R".
.PP
Returns undef if no name is known for the code.
.PP
This works only for the standard names, and does not yet apply
to custom translators.
.PP
Notice that the name returned for of U+FEFF is \*(L"\s-1ZERO\s0 \s-1WIDTH\s0 NO-BREAK
\&\s-1SPACE\s0\*(R", not \*(L"\s-1BYTE\s0 \s-1ORDER\s0 \s-1MARK\s0\*(R".
.SH "charnames::vianame(name)"
.IX Header "charnames::vianame(name)"
Returns the code point indicated by the name.
The example
.PP
.Vb 1
\&    printf "%04X", charnames::vianame("FOUR TEARDROP\-SPOKED ASTERISK");
.Ve
.PP
prints \*(L"2722\*(R".
.PP
Returns undef if the name is unknown.
.PP
This works only for the standard names, and does not yet apply
to custom translators.
.SH "CUSTOM TRANSLATORS"
.IX Header "CUSTOM TRANSLATORS"
The mechanism of translation of \f(CW\*(C`\eN{...}\*(C'\fR escapes is general and not
hardwired into \fIcharnames.pm\fR.  A module can install custom
translations (inside the scope which \f(CW\*(C`use\*(C'\fRs the module) with the
following magic incantation:
.PP
.Vb 4
\&    sub import {
\&        shift;
\&        $^H{charnames} = \e&translator;
\&    }
.Ve
.PP
Here \fItranslator()\fR is a subroutine which takes \f(CW\*(C`CHARNAME\*(C'\fR as an
argument, and returns text to insert into the string instead of the
\&\f(CW\*(C`\eN{CHARNAME}\*(C'\fR escape.  Since the text to insert should be different
in \f(CW\*(C`bytes\*(C'\fR mode and out of it, the function should check the current
state of \f(CW\*(C`bytes\*(C'\fR\-flag as in:
.PP
.Vb 9
\&    use bytes ();                       # for $bytes::hint_bits
\&    sub translator {
\&        if ($^H & $bytes::hint_bits) {
\&            return bytes_translator(@_);
\&        }
\&        else {
\&            return utf8_translator(@_);
\&        }
\&    }
.Ve
.PP
See \*(L"\s-1CUSTOM\s0 \s-1ALIASES\s0\*(R" above for restrictions on \f(CW\*(C`CHARNAME\*(C'\fR.
.SH "ILLEGAL CHARACTERS"
.IX Header "ILLEGAL CHARACTERS"
If you ask by name for a character that does not exist, a warning is given and
the Unicode \fIreplacement character\fR \*(L"\ex{\s-1FFFD\s0}\*(R" is returned.
.PP
If you ask by code for a character that is unassigned, no warning is
given and \f(CW\*(C`undef\*(C'\fR is returned.  (Though if you ask for a code point
past U+10FFFF you do get a warning.)  See \*(L"\s-1BUGS\s0\*(R" below.
.SH "BUGS"
.IX Header "BUGS"
viacode should return an empty string for unassigned in-range Unicode code
points, as that is their correct current name.
.PP
\&\fIviacode\fR\|(0) doesn't return \f(CW\*(C`NULL\*(C'\fR, but \f(CW\*(C`undef\*(C'\fR
.PP
vianame returns a chr if the input name is of the form \f(CW\*(C`U+...\*(C'\fR, and an ord
otherwise.  It is planned to change this to always return an ord.
.PP
None of the functions work on almost all the Hangul syllable and \s-1CJK\s0 Unicode
characters that have their code points as part of their names.
.PP
Names must be \s-1ASCII\s0 characters only.
.PP
Unicode standard named sequences are not recognized, such as
\&\f(CW\*(C`LATIN CAPITAL LETTER A WITH MACRON AND GRAVE\*(C'\fR
(which should mean \f(CW\*(C`LATIN CAPITAL LETTER A WITH MACRON\*(C'\fR with an additional
\&\f(CW\*(C`COMBINING GRAVE ACCENT\*(C'\fR).
.PP
Since evaluation of the translation function happens in the middle of
compilation (of a string literal), the translation function should not
do any \f(CW\*(C`eval\*(C'\fRs or \f(CW\*(C`require\*(C'\fRs.  This restriction should be lifted in
a future version of Perl.
