.\" Automatically generated by Pod::Man 4.10 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "DBD::SQLite::VirtualTable 3"
.TH DBD::SQLite::VirtualTable 3 "2019-08-12" "perl v5.28.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
DBD::SQLite::VirtualTable \-\- SQLite virtual tables implemented in Perl
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&  # register the virtual table module within sqlite
\&  $dbh\->sqlite_create_module(mod_name => "DBD::SQLite::VirtualTable::Subclass");
\&
\&  # create a virtual table
\&  $dbh\->do("CREATE VIRTUAL TABLE vtbl USING mod_name(arg1, arg2, ...)")
\&
\&  # use it as any regular table
\&  my $sth = $dbh\->prepare("SELECT * FROM vtbl WHERE ...");
.Ve
.PP
\&\fBNote\fR : VirtualTable subclasses or instances are not called
directly from Perl code; everything happens indirectly through \s-1SQL\s0
statements within SQLite.
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module is an abstract class for implementing SQLite virtual tables,
written in Perl. Such tables look like regular tables, and are accessed
through regular \s-1SQL\s0 instructions and regular \s-1DBI\s0 \s-1API\s0; but the implementation
is done through hidden calls to a Perl class. 
This is the same idea as Perl's tied variables, but
at the SQLite level.
.PP
The current abstract class cannot be used directly, so the
synopsis above is just to give a general idea. Concrete, usable
classes bundled with the present distribution are :
.IP "\(bu" 4
DBD::SQLite::VirtualTable::FileContent : implements a virtual
column that exposes file contents. This is especially useful
in conjunction with a fulltext index; see DBD::SQLite::Fulltext_search.
.IP "\(bu" 4
DBD::SQLite::VirtualTable::PerlData : binds to a Perl array
within the Perl program. This can be used for simple import/export
operations, for debugging purposes, for joining data from different
sources, etc.
.PP
Other Perl virtual tables may also be published separately on \s-1CPAN.\s0
.PP
The following chapters document the structure of the abstract class
and explain how to write new subclasses; this is meant for 
\&\fBmodule authors\fR, not for end users. If you just need to use a
virtual table module, refer to that module's documentation.
.SH "ARCHITECTURE"
.IX Header "ARCHITECTURE"
.SS "Classes"
.IX Subsection "Classes"
A virtual table module for SQLite is implemented through a pair
of classes :
.IP "\(bu" 4
the \fBtable\fR class implements methods for creating or connecting
a virtual table, for destroying it, for opening new searches, etc.
.IP "\(bu" 4
the \fBcursor\fR class implements methods for performing a specific
\&\s-1SQL\s0 statement
.SS "Methods"
.IX Subsection "Methods"
Most methods in both classes are not called directly from Perl
code : instead, they are callbacks, called from the sqlite kernel.
Following common Perl conventions, such methods have names in
uppercase.
.SH "TABLE METHODS"
.IX Header "TABLE METHODS"
.SS "Class methods for registering the module"
.IX Subsection "Class methods for registering the module"
\fI\s-1CREATE_MODULE\s0\fR
.IX Subsection "CREATE_MODULE"
.PP
.Vb 1
\&  $class\->CREATE_MODULE($sqlite_module_name);
.Ve
.PP
Called when the client code invokes
.PP
.Vb 1
\&  $dbh\->sqlite_create_module($sqlite_module_name => $class);
.Ve
.PP
The default implementation is empty.
.PP
\fI\s-1DESTROY_MODULE\s0\fR
.IX Subsection "DESTROY_MODULE"
.PP
.Vb 1
\&  $class\->DESTROY_MODULE();
.Ve
.PP
Called automatically when the database handle is disconnected.
The default implementation is empty.
.SS "Class methods for creating a vtable instance"
.IX Subsection "Class methods for creating a vtable instance"
\fI\s-1CREATE\s0\fR
.IX Subsection "CREATE"
.PP
.Vb 1
\&  $class\->CREATE($dbh_ref, $module_name, $db_name, $vtab_name, @args);
.Ve
.PP
Called when sqlite receives a statement
.PP
.Vb 1
\&  CREATE VIRTUAL TABLE $db_name.$vtab_name USING $module_name(@args)
.Ve
.PP
The default implementation just calls \*(L"\s-1NEW\*(R"\s0.
.PP
\fI\s-1CONNECT\s0\fR
.IX Subsection "CONNECT"
.PP
.Vb 1
\&  $class\->CONNECT($dbh_ref, $module_name, $db_name, $vtab_name, @args);
.Ve
.PP
Called when attempting to access a virtual table that had been created
during previous database connection. The creation arguments were stored
within the sqlite database and are passed again to the \s-1CONNECT\s0 method.
.PP
The default implementation just calls \*(L"\s-1NEW\*(R"\s0.
.PP
\fI_PREPARE_SELF\fR
.IX Subsection "_PREPARE_SELF"
.PP
.Vb 1
\&  $class\->_PREPARE_SELF($dbh_ref, $module_name, $db_name, $vtab_name, @args);
.Ve
.PP
Prepares the datastructure for a virtual table instance.  \f(CW@args\fR is
 just the collection of strings (comma-separated) that were given
 within the \f(CW\*(C`CREATE VIRTUAL TABLE\*(C'\fR statement; each subclass should
 decide what to do with this information,
.PP
The method parses \f(CW@args\fR to differentiate between \fIoptions\fR
(strings of shape \f(CW$key\fR=\f(CW$value\fR or \f(CW$key\fR=\f(CW"$value"\fR, stored in
\&\f(CW\*(C`$self\->{options}\*(C'\fR), and \fIcolumns\fR (other \f(CW@args\fR, stored in
\&\f(CW\*(C`$self\->{columns}\*(C'\fR). It creates a hashref with the following fields :
.ie n .IP """dbh_ref""" 4
.el .IP "\f(CWdbh_ref\fR" 4
.IX Item "dbh_ref"
a weak reference to the \f(CW$dbh\fR database handle (see
Scalar::Util for an explanation of weak references).
.ie n .IP """module_name""" 4
.el .IP "\f(CWmodule_name\fR" 4
.IX Item "module_name"
name of the module as declared to sqlite (not to be confounded
with the Perl class name).
.ie n .IP """db_name""" 4
.el .IP "\f(CWdb_name\fR" 4
.IX Item "db_name"
name of the database (usuallly \f(CW\*(Aqmain\*(Aq\fR or \f(CW\*(Aqtemp\*(Aq\fR), but it
may also be an attached database
.ie n .IP """vtab_name""" 4
.el .IP "\f(CWvtab_name\fR" 4
.IX Item "vtab_name"
name of the virtual table
.ie n .IP """columns""" 4
.el .IP "\f(CWcolumns\fR" 4
.IX Item "columns"
arrayref of column declarations
.ie n .IP """options""" 4
.el .IP "\f(CWoptions\fR" 4
.IX Item "options"
hashref of option declarations
.PP
This method should not be redefined, since it performs
general work which is supposed to be useful for all subclasses.
Instead, subclasses may override the \*(L"\s-1NEW\*(R"\s0 method.
.PP
\fI\s-1NEW\s0\fR
.IX Subsection "NEW"
.PP
.Vb 1
\&  $class\->NEW($dbh_ref, $module_name, $db_name, $vtab_name, @args);
.Ve
.PP
Instantiates a virtual table.
.SS "Instance methods called from the sqlite kernel"
.IX Subsection "Instance methods called from the sqlite kernel"
\fI\s-1DROP\s0\fR
.IX Subsection "DROP"
.PP
Called whenever a virtual table is destroyed from the
database through the \f(CW\*(C`DROP TABLE\*(C'\fR \s-1SQL\s0 instruction.
.PP
Just after the \f(CW\*(C`DROP()\*(C'\fR call, the Perl instance
will be destroyed (and will therefore automatically
call the \f(CW\*(C`DESTROY()\*(C'\fR method if such a method is present).
.PP
The default implementation for \s-1DROP\s0 is empty.
.PP
\&\fBNote\fR : this corresponds to the \f(CW\*(C`xDestroy\*(C'\fR method
in the SQLite documentation; here it was not named
\&\f(CW\*(C`DESTROY\*(C'\fR, to avoid any confusion with the standard
Perl method \f(CW\*(C`DESTROY\*(C'\fR for object destruction.
.PP
\fI\s-1DISCONNECT\s0\fR
.IX Subsection "DISCONNECT"
.PP
Called for every virtual table just before the database handle
is disconnected.
.PP
Just after the \f(CW\*(C`DISCONNECT()\*(C'\fR call, the Perl instance
will be destroyed (and will therefore automatically
call the \f(CW\*(C`DESTROY()\*(C'\fR method if such a method is present).
.PP
The default implementation for \s-1DISCONNECT\s0 is empty.
.PP
\fI\s-1VTAB_TO_DECLARE\s0\fR
.IX Subsection "VTAB_TO_DECLARE"
.PP
This method is called automatically just after \*(L"\s-1CREATE\*(R"\s0 or \*(L"\s-1CONNECT\*(R"\s0,
to register the columns of the virtual table within the sqlite kernel.
The method should return a string containing a \s-1SQL\s0 \f(CW\*(C`CREATE TABLE\*(C'\fR statement;
but only the column declaration parts will be considered.
Columns may be declared with the special keyword \*(L"\s-1HIDDEN\*(R",\s0 which means that
they are used internally for the the virtual table implementation, and are
not visible to users \*(-- see <http://sqlite.org/c3ref/declare_vtab.html>
and <http://www.sqlite.org/vtab.html#hiddencol> for detailed explanations.
.PP
The default implementation returns:
.PP
.Vb 1
\&  CREATE TABLE $self\->{vtab_name}(@{$self\->{columns}})
.Ve
.PP
\fI\s-1BEST_INDEX\s0\fR
.IX Subsection "BEST_INDEX"
.PP
.Vb 1
\&  my $index_info = $vtab\->BEST_INDEX($constraints, $order_by)
.Ve
.PP
This is the most complex method to redefined in subclasses.
This method will be called at the beginning of a new query on the
virtual table; the job of the method is to assemble some information
that will be used
.IP "a)" 4
.IX Item "a)"
by the sqlite kernel to decide about the best search strategy
.IP "b)" 4
.IX Item "b)"
by the cursor \*(L"\s-1FILTER\*(R"\s0 method to produce the desired subset
of rows from the virtual table.
.PP
By calling this method, the SQLite core is saying to the virtual table
that it needs to access some subset of the rows in the virtual table
and it wants to know the most efficient way to do that access. The
\&\f(CW\*(C`BEST_INDEX\*(C'\fR method replies with information that the SQLite core can
then use to conduct an efficient search of the virtual table.
.PP
The method takes as input a list of \f(CW$constraints\fR and a list
of \f(CW$order_by\fR instructions. It returns a hashref of indexing
properties, described below; furthermore, the method also adds
supplementary information within the input \f(CW$constraints\fR.
Detailed explanations are given in
<http://sqlite.org/vtab.html#xbestindex>.
.PP
Input constraints
.IX Subsection "Input constraints"
.PP
Elements of the \f(CW$constraints\fR arrayref correspond to
specific clauses of the \f(CW\*(C`WHERE ...\*(C'\fR part of the \s-1SQL\s0 query.
Each constraint is a hashref with keys :
.ie n .IP """col""" 4
.el .IP "\f(CWcol\fR" 4
.IX Item "col"
the integer index of the column on the left-hand side of the constraint
.ie n .IP """op""" 4
.el .IP "\f(CWop\fR" 4
.IX Item "op"
the comparison operator, expressed as string containing
\&\f(CW\*(Aq=\*(Aq\fR, \f(CW\*(Aq>\*(Aq\fR, \f(CW\*(Aq>=\*(Aq\fR, \f(CW\*(Aq<\*(Aq\fR, \f(CW\*(Aq<=\*(Aq\fR or \f(CW\*(AqMATCH\*(Aq\fR.
.ie n .IP """usable""" 4
.el .IP "\f(CWusable\fR" 4
.IX Item "usable"
a boolean indicating if that constraint is usable; some constraints
might not be usable because of the way tables are ordered in a join.
.PP
The \f(CW$constraints\fR arrayref is used both for input and for output.
While iterating over the array, the method should
add the following keys into usable constraints :
.ie n .IP """argvIndex""" 4
.el .IP "\f(CWargvIndex\fR" 4
.IX Item "argvIndex"
An index into the \f(CW@values\fR array that will be passed to
the cursor's \*(L"\s-1FILTER\*(R"\s0 method. In other words, if the current
constraint corresponds to the \s-1SQL\s0 fragment \f(CW\*(C`WHERE ... AND foo < 123 ...\*(C'\fR,
and the corresponding \f(CW\*(C`argvIndex\*(C'\fR takes value 5, this means that
the \f(CW\*(C`FILTER\*(C'\fR method will receive \f(CW123\fR in \f(CW$values[5]\fR.
.ie n .IP """omit""" 4
.el .IP "\f(CWomit\fR" 4
.IX Item "omit"
A boolean telling to the sqlite core that it can safely omit
to double check that constraint before returning the resultset
to the calling program; this means that the \s-1FILTER\s0 method has fulfilled
the filtering job on that constraint and there is no need to do any
further checking.
.PP
The \f(CW\*(C`BEST_INDEX\*(C'\fR method will not necessarily receive all constraints
from the \s-1SQL\s0 \f(CW\*(C`WHERE\*(C'\fR clause : for example a constraint like
\&\f(CW\*(C`col1 < col2 + col3\*(C'\fR cannot be handled at this level.
Furthemore, the \f(CW\*(C`BEST_INDEX\*(C'\fR might decide to ignore some of the 
received constraints. This is why a second pass over the results
will be performed by the sqlite core.
.PP
\*(L"order_by\*(R" input information
.IX Subsection "order_by input information"
.PP
The \f(CW$order_by\fR arrayref corresponds to the \f(CW\*(C`ORDER BY\*(C'\fR clauses
in the \s-1SQL\s0 query. Each entry is a hashref with keys :
.ie n .IP """col""" 4
.el .IP "\f(CWcol\fR" 4
.IX Item "col"
the integer index of the column being ordered
.ie n .IP """desc""" 4
.el .IP "\f(CWdesc\fR" 4
.IX Item "desc"
a boolean telling of the ordering is DESCending or ascending
.PP
This information could be used by some subclasses for
optimizing the query strategfy; but usually the sqlite core will
perform another sorting pass once all results are gathered.
.PP
Hashref information returned by \s-1BEST_INDEX\s0
.IX Subsection "Hashref information returned by BEST_INDEX"
.PP
The method should return a hashref with the following keys :
.ie n .IP """idxNum""" 4
.el .IP "\f(CWidxNum\fR" 4
.IX Item "idxNum"
An arbitrary integer associated with that index; this information will
be passed back to \*(L"\s-1FILTER\*(R"\s0.
.ie n .IP """idxStr""" 4
.el .IP "\f(CWidxStr\fR" 4
.IX Item "idxStr"
An arbitrary str associated with that index; this information will
be passed back to \*(L"\s-1FILTER\*(R"\s0.
.ie n .IP """orderByConsumed""" 4
.el .IP "\f(CWorderByConsumed\fR" 4
.IX Item "orderByConsumed"
A boolean telling the sqlite core if the \f(CW$order_by\fR information
has been taken into account or not.
.ie n .IP """estimatedCost""" 4
.el .IP "\f(CWestimatedCost\fR" 4
.IX Item "estimatedCost"
A float that should be set to the estimated number of disk access
operations required to execute this query against the virtual
table. The SQLite core will often call \s-1BEST_INDEX\s0 multiple times with
different constraints, obtain multiple cost estimates, then choose the
query plan that gives the lowest estimate.
.ie n .IP """estimatedRows""" 4
.el .IP "\f(CWestimatedRows\fR" 4
.IX Item "estimatedRows"
An integer giving the estimated number of rows returned by that query.
.PP
\fI\s-1OPEN\s0\fR
.IX Subsection "OPEN"
.PP
Called to instantiate a new cursor.
The default implementation appends \f(CW"::Cursor"\fR to the current
classname and calls \f(CW\*(C`NEW()\*(C'\fR within that cursor class.
.PP
\fI_SQLITE_UPDATE\fR
.IX Subsection "_SQLITE_UPDATE"
.PP
This is the dispatch method implementing the \f(CW\*(C`xUpdate()\*(C'\fR callback
for virtual tables. The default implementation applies the algorithm
described in <http://sqlite.org/vtab.html#xupdate> to decide
to call \*(L"\s-1INSERT\*(R"\s0, \*(L"\s-1DELETE\*(R"\s0 or \*(L"\s-1UPDATE\*(R"\s0; so there is no reason
to override this method in subclasses.
.PP
\fI\s-1INSERT\s0\fR
.IX Subsection "INSERT"
.PP
.Vb 1
\&  my $rowid = $vtab\->INSERT($new_rowid, @values);
.Ve
.PP
This method should be overridden in subclasses to implement
insertion of a new row into the virtual table.
The size of the \f(CW@values\fR array corresponds to the
number of columns declared through \*(L"\s-1VTAB_TO_DECLARE\*(R"\s0.
The \f(CW$new_rowid\fR may be explicitly given, or it may be
\&\f(CW\*(C`undef\*(C'\fR, in which case the method must compute a new id
and return it as the result of the method call.
.PP
\fI\s-1DELETE\s0\fR
.IX Subsection "DELETE"
.PP
.Vb 1
\&  $vtab\->INSERT($old_rowid);
.Ve
.PP
This method should be overridden in subclasses to implement
deletion of a row from the virtual table.
.PP
\fI\s-1UPDATE\s0\fR
.IX Subsection "UPDATE"
.PP
.Vb 1
\&  $vtab\->UPDATE($old_rowid, $new_rowid, @values);
.Ve
.PP
This method should be overridden in subclasses to implement
a row update within the virtual table. Usually \f(CW$old_rowid\fR is equal
to \f(CW$new_rowid\fR, which is a regular update; however, the rowid
could be changed from a \s-1SQL\s0 statement such as
.PP
.Vb 1
\&  UPDATE table SET rowid=rowid+1 WHERE ...;
.Ve
.PP
\fI\s-1FIND_FUNCTION\s0\fR
.IX Subsection "FIND_FUNCTION"
.PP
.Vb 1
\&  $vtab\->FIND_FUNCTION($num_args, $func_name);
.Ve
.PP
When a function uses a column from a virtual table as its first
argument, this method is called to see if the virtual table would like
to overload the function. Parameters are the number of arguments to
the function, and the name of the function. If no overloading is
desired, this method should return false. To overload the function,
this method should return a coderef to the function implementation.
.PP
Each virtual table keeps a cache of results from \s-1FIND_FUNCTION\s0 calls,
so the method will be called only once for each pair 
\&\f(CW\*(C`($num_args, $func_name)\*(C'\fR.
.PP
\fI\s-1BEGIN_TRANSACTION\s0\fR
.IX Subsection "BEGIN_TRANSACTION"
.PP
Called to begin a transaction on the virtual table.
.PP
\fI\s-1SYNC_TRANSACTION\s0\fR
.IX Subsection "SYNC_TRANSACTION"
.PP
Called to signal the start of a two-phase commit on the virtual table.
.PP
\fI\s-1SYNC_TRANSACTION\s0\fR
.IX Subsection "SYNC_TRANSACTION"
.PP
Called to commit a virtual table transaction.
.PP
\fI\s-1ROLLBACK_TRANSACTION\s0\fR
.IX Subsection "ROLLBACK_TRANSACTION"
.PP
Called to rollback a virtual table transaction.
.PP
\fI\s-1RENAME\s0\fR
.IX Subsection "RENAME"
.PP
.Vb 1
\&  $vtab\->RENAME($new_name)
.Ve
.PP
Called to rename a virtual table.
.PP
\fI\s-1SAVEPOINT\s0\fR
.IX Subsection "SAVEPOINT"
.PP
.Vb 1
\&  $vtab\->SAVEPOINT($savepoint)
.Ve
.PP
Called to signal the virtual table to save its current state
at savepoint \f(CW$savepoint\fR (an integer).
.PP
\fI\s-1ROLLBACK_TO\s0\fR
.IX Subsection "ROLLBACK_TO"
.PP
.Vb 1
\&  $vtab\->ROLLBACK_TO($savepoint)
.Ve
.PP
Called to signal the virtual table to return to the state
\&\f(CW$savepoint\fR.  This will invalidate all savepoints with values
greater than \f(CW$savepoint\fR.
.PP
\fI\s-1RELEASE\s0\fR
.IX Subsection "RELEASE"
.PP
.Vb 1
\&  $vtab\->RELEASE($savepoint)
.Ve
.PP
Called to invalidate all savepoints with values
greater or equal to \f(CW$savepoint\fR.
.SS "Utility instance methods"
.IX Subsection "Utility instance methods"
Methods in this section are in lower case, because they
are not called directly from the sqlite kernel; these
are utility methods to be called from other methods
described above.
.PP
\fIdbh\fR
.IX Subsection "dbh"
.PP
This method returns the database handle (\f(CW$dbh\fR) associated with
the current virtual table.
.SH "CURSOR METHODS"
.IX Header "CURSOR METHODS"
.SS "Class methods"
.IX Subsection "Class methods"
\fI\s-1NEW\s0\fR
.IX Subsection "NEW"
.PP
.Vb 1
\&  my $cursor = $cursor_class\->NEW($vtable, @args)
.Ve
.PP
Instantiates a new cursor. 
The default implementation just returns a blessed hashref
with keys \f(CW\*(C`vtable\*(C'\fR and \f(CW\*(C`args\*(C'\fR.
.SS "Instance methods"
.IX Subsection "Instance methods"
\fI\s-1FILTER\s0\fR
.IX Subsection "FILTER"
.PP
.Vb 1
\&  $cursor\->FILTER($idxNum, $idxStr, @values);
.Ve
.PP
This method begins a search of a virtual table.
.PP
The \f(CW$idxNum\fR and \f(CW$idxStr\fR arguments correspond to values returned
by \*(L"\s-1BEST_INDEX\*(R"\s0 for the chosen index. The specific meanings of
those values are unimportant to SQLite, as long as \f(CW\*(C`BEST_INDEX\*(C'\fR and
\&\f(CW\*(C`FILTER\*(C'\fR agree on what that meaning is.
.PP
The \f(CW\*(C`BEST_INDEX\*(C'\fR method may have requested the values of certain
expressions using the \f(CW\*(C`argvIndex\*(C'\fR values of the
\&\f(CW$constraints\fR list. Those values are passed to \f(CW\*(C`FILTER\*(C'\fR through
the \f(CW@values\fR array.
.PP
If the virtual table contains one or more rows that match the search
criteria, then the cursor must be left point at the first
row. Subsequent calls to \*(L"\s-1EOF\*(R"\s0 must return false. If there are
no rows match, then the cursor must be left in a state that will cause
\&\*(L"\s-1EOF\*(R"\s0 to return true. The SQLite engine will use the
\&\*(L"\s-1COLUMN\*(R"\s0 and \*(L"\s-1ROWID\*(R"\s0 methods to access that row content. The \*(L"\s-1NEXT\*(R"\s0
method will be used to advance to the next row.
.PP
\fI\s-1EOF\s0\fR
.IX Subsection "EOF"
.PP
This method must return false if the cursor currently points to a
valid row of data, or true otherwise. This method is called by the \s-1SQL\s0
engine immediately after each \*(L"\s-1FILTER\*(R"\s0 and \*(L"\s-1NEXT\*(R"\s0 invocation.
.PP
\fI\s-1NEXT\s0\fR
.IX Subsection "NEXT"
.PP
This method advances the cursor to the next row of a
result set initiated by \*(L"\s-1FILTER\*(R"\s0. If the cursor is already pointing at
the last row when this method is called, then the cursor no longer
points to valid data and a subsequent call to the \*(L"\s-1EOF\*(R"\s0 method must
return true. If the cursor is successfully advanced to
another row of content, then subsequent calls to \*(L"\s-1EOF\*(R"\s0 must return
false.
.PP
\fI\s-1COLUMN\s0\fR
.IX Subsection "COLUMN"
.PP
.Vb 1
\&  my $value = $cursor\->COLUMN($idxCol);
.Ve
.PP
The SQLite core invokes this method in order to find the value for the
N\-th column of the current row. N is zero-based so the first column is
numbered 0.
.PP
\fI\s-1ROWID\s0\fR
.IX Subsection "ROWID"
.PP
.Vb 1
\&  my $value = $cursor\->ROWID;
.Ve
.PP
Returns the \fIrowid\fR of row that the cursor is currently pointing at.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
SQLite::VirtualTable is another module for virtual tables written
in Perl, but designed for the reverse use case : instead of starting a
Perl program, and embedding the SQLite library into it, the intended
use is to start an sqlite program, and embed the Perl interpreter
into it.
.SH "AUTHOR"
.IX Header "AUTHOR"
Laurent Dami <dami@cpan.org>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright Laurent Dami, 2014.
.PP
Parts of the code are borrowed from SQLite::VirtualTable,
copyright (C) 2006, 2009 by Qindel Formacion y Servicios, S. L.
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.
