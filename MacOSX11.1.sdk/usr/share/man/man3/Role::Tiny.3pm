.\" Automatically generated by Pod::Man 4.10 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Role::Tiny 3"
.TH Role::Tiny 3 "2019-10-25" "perl v5.28.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Role::Tiny \- Roles: a nouvelle cuisine portion size slice of Moose
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& package Some::Role;
\&
\& use Role::Tiny;
\&
\& sub foo { ... }
\&
\& sub bar { ... }
\&
\& around baz => sub { ... };
\&
\& 1;
.Ve
.PP
elsewhere
.PP
.Vb 1
\& package Some::Class;
\&
\& use Role::Tiny::With;
\&
\& # bar gets imported, but not foo
\& with \*(AqSome::Role\*(Aq;
\&
\& sub foo { ... }
\&
\& # baz is wrapped in the around modifier by Class::Method::Modifiers
\& sub baz { ... }
\&
\& 1;
.Ve
.PP
If you wanted attributes as well, look at Moo::Role.
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\f(CW\*(C`Role::Tiny\*(C'\fR is a minimalist role composition tool.
.SH "ROLE COMPOSITION"
.IX Header "ROLE COMPOSITION"
Role composition can be thought of as much more clever and meaningful multiple
inheritance.  The basics of this implementation of roles is:
.IP "\(bu" 2
If a method is already defined on a class, that method will not be composed in
from the role. A method inherited by a class gets overridden by the role's
method of the same name, though.
.IP "\(bu" 2
If a method that the role \*(L"requires\*(R" to be implemented is not implemented,
role application will fail loudly.
.PP
Unlike Class::C3, where the \fBlast\fR class inherited from \*(L"wins,\*(R" role
composition is the other way around, where the class wins. If multiple roles
are applied in a single call (single with statement), then if any of their
provided methods clash, an exception is raised unless the class provides
a method since this conflict indicates a potential problem.
.SH "IMPORTED SUBROUTINES"
.IX Header "IMPORTED SUBROUTINES"
.SS "requires"
.IX Subsection "requires"
.Vb 1
\& requires qw(foo bar);
.Ve
.PP
Declares a list of methods that must be defined to compose role.
.SS "with"
.IX Subsection "with"
.Vb 1
\& with \*(AqSome::Role1\*(Aq;
\&
\& with \*(AqSome::Role1\*(Aq, \*(AqSome::Role2\*(Aq;
.Ve
.PP
Composes another role into the current role (or class via Role::Tiny::With).
.PP
If you have conflicts and want to resolve them in favour of Some::Role1 you
can instead write:
.PP
.Vb 2
\& with \*(AqSome::Role1\*(Aq;
\& with \*(AqSome::Role2\*(Aq;
.Ve
.PP
If you have conflicts and want to resolve different conflicts in favour of
different roles, please refactor your codebase.
.SS "before"
.IX Subsection "before"
.Vb 1
\& before foo => sub { ... };
.Ve
.PP
See \*(L"before method(s) => sub { ... }\*(R" in Class::Method::Modifiers for full
documentation.
.PP
Note that since you are not required to use method modifiers,
Class::Method::Modifiers is lazily loaded and we do not declare it as
a dependency. If your Role::Tiny role uses modifiers you must depend on
both Class::Method::Modifiers and Role::Tiny.
.SS "around"
.IX Subsection "around"
.Vb 1
\& around foo => sub { ... };
.Ve
.PP
See \*(L"around method(s) => sub { ... }\*(R" in Class::Method::Modifiers for full
documentation.
.PP
Note that since you are not required to use method modifiers,
Class::Method::Modifiers is lazily loaded and we do not declare it as
a dependency. If your Role::Tiny role uses modifiers you must depend on
both Class::Method::Modifiers and Role::Tiny.
.SS "after"
.IX Subsection "after"
.Vb 1
\& after foo => sub { ... };
.Ve
.PP
See \*(L"after method(s) => sub { ... }\*(R" in Class::Method::Modifiers for full
documentation.
.PP
Note that since you are not required to use method modifiers,
Class::Method::Modifiers is lazily loaded and we do not declare it as
a dependency. If your Role::Tiny role uses modifiers you must depend on
both Class::Method::Modifiers and Role::Tiny.
.SS "Strict and Warnings"
.IX Subsection "Strict and Warnings"
In addition to importing subroutines, using \f(CW\*(C`Role::Tiny\*(C'\fR applies strict and
warnings to the caller.
.SH "SUBROUTINES"
.IX Header "SUBROUTINES"
.SS "does_role"
.IX Subsection "does_role"
.Vb 3
\& if (Role::Tiny::does_role($foo, \*(AqSome::Role\*(Aq)) {
\&   ...
\& }
.Ve
.PP
Returns true if class has been composed with role.
.PP
This subroutine is also installed as \->does on any class a Role::Tiny is
composed into unless that class already has an \->does method, so
.PP
.Vb 3
\&  if ($foo\->does(\*(AqSome::Role\*(Aq)) {
\&    ...
\&  }
.Ve
.PP
will work for classes but to test a role, one must use ::does_role directly.
.PP
Additionally, Role::Tiny will override the standard Perl \f(CW\*(C`DOES\*(C'\fR method
for your class. However, if \f(CW\*(C`any\*(C'\fR class in your class' inheritance
hierarchy provides \f(CW\*(C`DOES\*(C'\fR, then Role::Tiny will not override it.
.SH "METHODS"
.IX Header "METHODS"
.SS "make_role"
.IX Subsection "make_role"
.Vb 1
\& Role::Tiny\->make_role(\*(AqSome::Role\*(Aq);
.Ve
.PP
Makes a package into a role, but does not export any subs into it.
.SS "apply_roles_to_package"
.IX Subsection "apply_roles_to_package"
.Vb 3
\& Role::Tiny\->apply_roles_to_package(
\&   \*(AqSome::Package\*(Aq, \*(AqSome::Role\*(Aq, \*(AqSome::Other::Role\*(Aq
\& );
.Ve
.PP
Composes role with package.  See also Role::Tiny::With.
.SS "apply_roles_to_object"
.IX Subsection "apply_roles_to_object"
.Vb 1
\& Role::Tiny\->apply_roles_to_object($foo, qw(Some::Role1 Some::Role2));
.Ve
.PP
Composes roles in order into object directly. Object is reblessed into the
resulting class. Note that the object's methods get overridden by the role's
ones with the same names.
.SS "create_class_with_roles"
.IX Subsection "create_class_with_roles"
.Vb 1
\& Role::Tiny\->create_class_with_roles(\*(AqSome::Base\*(Aq, qw(Some::Role1 Some::Role2));
.Ve
.PP
Creates a new class based on base, with the roles composed into it in order.
New class is returned.
.SS "is_role"
.IX Subsection "is_role"
.Vb 1
\& Role::Tiny\->is_role(\*(AqSome::Role1\*(Aq)
.Ve
.PP
Returns true if the given package is a role.
.SH "CAVEATS"
.IX Header "CAVEATS"
.IP "\(bu" 4
On perl 5.8.8 and earlier, applying a role to an object won't apply any
overloads from the role to other copies of the object.
.IP "\(bu" 4
On perl 5.16 and earlier, applying a role to a class won't apply any
overloads from the role to any existing instances of the class.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Role::Tiny is the attribute-less subset of Moo::Role; Moo::Role is
a meta-protocol-less subset of the king of role systems, Moose::Role.
.PP
Ovid's Role::Basic provides roles with a similar scope, but without method
modifiers, and having some extra usage restrictions.
.SH "AUTHOR"
.IX Header "AUTHOR"
mst \- Matt S. Trout (cpan:MSTROUT) <mst@shadowcat.co.uk>
.SH "CONTRIBUTORS"
.IX Header "CONTRIBUTORS"
dg \- David Leadbeater (cpan:DGL) <dgl@dgl.cx>
.PP
frew \- Arthur Axel \*(L"fREW\*(R" Schmidt (cpan:FREW) <frioux@gmail.com>
.PP
hobbs \- Andrew Rodland (cpan:ARODLAND) <arodland@cpan.org>
.PP
jnap \- John Napiorkowski (cpan:JJNAPIORK) <jjn1056@yahoo.com>
.PP
ribasushi \- Peter Rabbitson (cpan:RIBASUSHI) <ribasushi@cpan.org>
.PP
chip \- Chip Salzenberg (cpan:CHIPS) <chip@pobox.com>
.PP
ajgb \- Alex J. G. Burzyński (cpan:AJGB) <ajgb@cpan.org>
.PP
doy \- Jesse Luehrs (cpan:DOY) <doy at tozt dot net>
.PP
perigrin \- Chris Prather (cpan:PERIGRIN) <chris@prather.org>
.PP
Mithaldu \- Christian Walde (cpan:MITHALDU) <walde.christian@googlemail.com>
.PP
ilmari \- Dagfinn Ilmari Mannsåker (cpan:ILMARI) <ilmari@ilmari.org>
.PP
tobyink \- Toby Inkster (cpan:TOBYINK) <tobyink@cpan.org>
.PP
haarg \- Graham Knop (cpan:HAARG) <haarg@haarg.org>
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (c) 2010\-2012 the Role::Tiny \*(L"\s-1AUTHOR\*(R"\s0 and \*(L"\s-1CONTRIBUTORS\*(R"\s0
as listed above.
.SH "LICENSE"
.IX Header "LICENSE"
This library is free software and may be distributed under the same terms
as perl itself.
