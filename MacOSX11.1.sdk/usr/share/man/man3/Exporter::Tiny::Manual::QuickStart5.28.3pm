.\" Automatically generated by Pod::Man 4.10 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Exporter::Tiny::Manual::QuickStart 3"
.TH Exporter::Tiny::Manual::QuickStart 3 "2020-04-24" "perl v5.28.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Exporter::Tiny::Manual::QuickStart \- the quickest way to get up and running with Exporter::Tiny
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&   package MyUtils;
\&   
\&   use Exporter::Shiny qw( frobnicate );
\&   
\&   sub frobnicate {
\&      ...;   # your code here
\&   }
\&   
\&   1;
.Ve
.PP
Now people can use your module like this:
.PP
.Vb 1
\&   use MyUtils "frobnicate";
\&   
\&   frobnicate(42);
.Ve
.PP
Or like this:
.PP
.Vb 1
\&   use MyUtils "frobnicate" => { \-as => "frob" };
\&   
\&   frob(42);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
See the synopsis. Yes, it's that simple.
.SS "Next steps"
.IX Subsection "Next steps"
\fIDefault exports\fR
.IX Subsection "Default exports"
.PP
Note that the module in the synopsis doesn't export anything by default.
If people load \f(CW\*(C`MyUtils\*(C'\fR like this:
.PP
.Vb 1
\&   use MyUtils;
.Ve
.PP
Then they haven't imported any functions. You can specify a default set
of functions to be exported like this:
.PP
.Vb 1
\&   package MyUtils;
\&   
\&   use Exporter::Shiny qw( frobnicate );
\&   
\&   our @EXPORT = qw( frobnicate );
\&   
\&   sub frobnicate { ... }
\&   
\&   1;
.Ve
.PP
Or, if you want to be a superstar rock god:
.PP
.Vb 1
\&   package MyUtils;
\&   
\&   use Exporter::Shiny our @EXPORT = qw( frobnicate );
\&   
\&   sub frobnicate { ... }
\&   
\&   1;
.Ve
.PP
\fITags\fR
.IX Subsection "Tags"
.PP
You can provide tags for people to use:
.PP
.Vb 1
\&   package MyUtils;
\&   
\&   use Exporter::Shiny qw( frobnicate red green blue );
\&   
\&   our %EXPORT_TAGS = (
\&      utils   => [qw/ frobnicate /],
\&      colours => [qw/ red green blue /],
\&   );
\&   
\&   sub frobnicate { ... }
\&   sub red        { ... }
\&   sub green      { ... }
\&   sub blue       { ... }
\&   
\&   1;
.Ve
.PP
And people can now import your functions like this:
.PP
.Vb 1
\&   use MyUtils ":colours";
.Ve
.PP
Or this:
.PP
.Vb 1
\&   use MyUtils "\-colours";
.Ve
.PP
Or take advantage of the fact that Perl magically quotes barewords
preceded by a hyphen:
.PP
.Vb 1
\&   use MyUtils \-colours;
.Ve
.PP
Two tags are automatically defined for you: \f(CW\*(C`\-default\*(C'\fR (which is
just the same as \f(CW@EXPORT\fR) and \f(CW\*(C`\-all\*(C'\fR (which is the union of
\&\f(CW@EXPORT\fR and \f(CW@EXPORT_OK\fR). If you don't like them, then you
can override them:
.PP
.Vb 4
\&   our %EXPORT_TAGS = (
\&      default => \e@some_other_stuff,
\&      all     => \e@more_stuff,
\&   );
.Ve
.PP
\fIGenerators\fR
.IX Subsection "Generators"
.PP
Exporting normally just works by copying a sub from your package into
your caller's package. But sometimes it's useful instead to generate
a \fIcustom\fR sub to insert into your caller's package. This is pretty
easy to do.
.PP
.Vb 1
\&   package MyUtils;
\&   
\&   use Exporter::Shiny qw( frobnicate );
\&   
\&   sub _generate_frobnicate {
\&      my $me     = shift;
\&      my $caller = caller;
\&      my ($name, $args) = @_;
\&      
\&      return sub {
\&          ...;  # your code here
\&      };
\&   }
\&   
\&   1;
.Ve
.PP
The parameter \f(CW$me\fR here is a string containing the package name
which is being imported from; \f(CW$caller\fR is the destination package;
\&\f(CW$name\fR is the name of the sub (in this case \*(L"frobnicate\*(R"); and
\&\f(CW$args\fR is a hashref of custom arguments for this function.
.PP
.Vb 3
\&   # The hashref { foo => 42 } is $args above.
\&   #
\&   use MyUtils "frobnicate" => { foo => 42 };
.Ve
.SS "Avoiding Exporter::Shiny"
.IX Subsection "Avoiding Exporter::Shiny"
Exporter::Shiny is a tiny shim around Exporter::Tiny. It should mostly
do what you want, but you may sometimes prefer to use Exporter::Tiny
directly.
.PP
The example in the synopsis could have been written as:
.PP
.Vb 1
\&   package MyUtils;
\&   
\&   use parent "Exporter::Tiny";
\&   our @EXPORT_OK = qw( frobnicate );
\&   
\&   sub frobnicate {
\&      ...;   # your code here
\&   }
\&   
\&   1;
.Ve
.PP
What Exporter::Shiny does is mostly just to set \f(CW@EXPORT_OK\fR for
you and set up inheritance from the base class (Exporter::Tiny).
.PP
Exporter::Shiny also sets \f(CW$INC{\*(AqMyUtils.pm}\fR for you, which in
usually makes little difference, but is useful in some edge cases.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Exporter::Shiny,
Exporter::Tiny.
.PP
For more advanced information, see
Exporter::Tiny::Manual::Exporting.
.SH "AUTHOR"
.IX Header "AUTHOR"
Toby Inkster <tobyink@cpan.org>.
.SH "COPYRIGHT AND LICENCE"
.IX Header "COPYRIGHT AND LICENCE"
This software is copyright (c) 2013\-2014, 2017 by Toby Inkster.
.PP
This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.
.SH "DISCLAIMER OF WARRANTIES"
.IX Header "DISCLAIMER OF WARRANTIES"
\&\s-1THIS PACKAGE IS PROVIDED \*(L"AS IS\*(R" AND WITHOUT ANY EXPRESS OR IMPLIED
WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.\s0
