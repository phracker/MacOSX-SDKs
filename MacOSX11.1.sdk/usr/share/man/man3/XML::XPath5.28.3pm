.\" Automatically generated by Pod::Man 4.10 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "XML::XPath 3"
.TH XML::XPath 3 "2018-10-11" "perl v5.28.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
XML::XPath \- Parse and evaluate XPath statements.
.SH "VERSION"
.IX Header "VERSION"
Version 1.44
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module aims to comply exactly to the XPath specification at http://www.w3.org/TR/xpath
and yet allow extensions to be added in the form of functions.Modules such as \s-1XSLT\s0
and XPointer may need to do this as they support functionality beyond XPath.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&    use XML::XPath;
\&    use XML::XPath::XMLParser;
\&
\&    my $xp = XML::XPath\->new(filename => \*(Aqtest.xhtml\*(Aq);
\&
\&    my $nodeset = $xp\->find(\*(Aq/html/body/p\*(Aq); # find all paragraphs
\&
\&    foreach my $node ($nodeset\->get_nodelist) {
\&        print "FOUND\en\en",
\&            XML::XPath::XMLParser::as_string($node),
\&            "\en\en";
\&    }
.Ve
.SH "DETAILS"
.IX Header "DETAILS"
There is an awful lot to  all  of  this, so bear with it \- if you stick it out it
should be worth it. Please get a good understanding of XPath by reading  the spec
before asking me questions. All of the classes and parts  herein are named to  be
synonymous  with  the  names in  the  specification, so consult that if you don't
understand why I'm doing something in the code.
.SH "METHODS"
.IX Header "METHODS"
The \s-1API\s0 of XML::XPath itself is extremely simple to allow you to get going almost
immediately. The deeper \s-1API\s0's are more complex, but you  shouldn't  have to touch
most of that.
.SS "\fBnew()\fP"
.IX Subsection "new()"
This  constructor follows  the often seen named parameter method call. Parameters
you can use are: filename, parser, xml, ioref and context. The filename parameter
specifies  an  \s-1XML\s0  file to parse. The xml parameter specifies a string to parse,
and the ioref parameter specifies  an ioref to  parse. The context  option allows
you to specify a context node. The context node has to be in the format of a node
as specified in XML::XPath::XMLParser. The 4  parameters  filename, xml, ioref
and context are mutually exclusive \- you should only  specify one (if you specify
anything other than context, the context node is the root of your document).  The
parser  option  allows  you to pass in an already prepared XML::Parser object, to
save you having to create more than one in your application (if, for example, you
are doing more than just XPath).
.PP
.Vb 1
\&    my $xp = XML::XPath\->new( context => $node );
.Ve
.PP
It is very much recommended that you use only 1 XPath object  throughout the life
of  your  application. This is because the object (and it's sub-objects) maintain
certain  bits  of state information that will be useful (such as XPath variables)
to later  calls  to \fBfind()\fR.  It's also a good idea because you'll use less memory
this way.
.SS "find($path, [$context])"
.IX Subsection "find($path, [$context])"
The find function takes an XPath expression (a string) and returns either an XML::XPath::NodeSet
object  containing the nodes it found (or empty if no nodes matched the path), or
one of XML::XPath::Literal (a string), XML::XPath::Number or XML::XPath::Boolean.
It should always return something \- and you can use \->\fBisa()\fR  to find out  what it
returned. If you need to check how many nodes it found you should check \f(CW$nodeset\fR\->size.
See XML::XPath::NodeSet. An optional second parameter of a context node allows
you to use this method repeatedly, for example \s-1XSLT\s0 needs to do this.
.SS "findnodes($path, [$context])"
.IX Subsection "findnodes($path, [$context])"
Returns a list of nodes found by \f(CW$path\fR, optionally in context \f(CW$context\fR. In scalar
context returns an XML::XPath::NodeSet object.
.ie n .SS "matches($node, $path, [$context])"
.el .SS "matches($node, \f(CW$path\fP, [$context])"
.IX Subsection "matches($node, $path, [$context])"
Returns true if the node matches the path (optionally in context \f(CW$context\fR).
.SS "findnodes_as_string($path, [$context])"
.IX Subsection "findnodes_as_string($path, [$context])"
Returns the nodes found reproduced as \s-1XML\s0.The result isn't guaranteed to be valid
\&\s-1XML\s0 though.
.SS "findvalue($path, [$context])"
.IX Subsection "findvalue($path, [$context])"
Returns either a \f(CW\*(C`XML::XPath::Literal\*(C'\fR, a \f(CW\*(C`XML::XPath::Boolean\*(C'\fR or a \f(CW\*(C`XML::XPath::Number\*(C'\fR
object.If the path returns a NodeSet,$nodeset\->to_literal is called automatically
for you (and thus a \f(CW\*(C`XML::XPath::Literal\*(C'\fR is returned).Note that for each of the
objects stringification is overloaded, so you can just print the  value found, or
manipulate it in the ways you would a normal perl value (e.g. using regular expressions).
.SS "exists($path, [$context])"
.IX Subsection "exists($path, [$context])"
Returns true if the given path exists.
.SS "getNodeText($path)"
.IX Subsection "getNodeText($path)"
Returns the XML::XPath::Literal for a particular \s-1XML\s0 node. Returns a string if
exists or '' (empty string) if the node doesn't exist.
.ie n .SS "setNodeText($path, $text)"
.el .SS "setNodeText($path, \f(CW$text\fP)"
.IX Subsection "setNodeText($path, $text)"
Sets the text string for a particular \s-1XML\s0 node.  The node can be an element or an
attribute. If the node to be set is an attribute, and the attribute node does not
exist, it will be created automatically.
.SS "createNode($path)"
.IX Subsection "createNode($path)"
Creates the node matching the \f(CW$path\fR given. If part of the path given or all of
the path do not exist, the necessary nodes will be created automatically.
.ie n .SS "set_namespace($prefix, $uri)"
.el .SS "set_namespace($prefix, \f(CW$uri\fP)"
.IX Subsection "set_namespace($prefix, $uri)"
Sets the namespace prefix mapping to the uri.
.PP
Normally in \f(CW\*(C`XML::XPath\*(C'\fR the prefixes in XPath node test take their context from
the current node. This means that foo:bar will always match an element  <foo:bar>
regardless  of  the  namespace that the prefix foo is mapped to (which might even
change  within  the document, resulting  in unexpected results). In order to make
prefixes in XPath node tests actually map  to a real \s-1URI,\s0 you need to enable that
via a call to the set_namespace method of your \f(CW\*(C`XML::XPath\*(C'\fR object.
.SS "\fBclear_namespaces()\fP"
.IX Subsection "clear_namespaces()"
Clears all previously set namespace mappings.
.ie n .SS "$XML::XPath::Namespaces"
.el .SS "\f(CW$XML::XPath::Namespaces\fP"
.IX Subsection "$XML::XPath::Namespaces"
Set this to 0  if you \fIdon't\fR want namespace processing to occur. This will make
everything a little (tiny) bit faster, but you'll suffer for it, probably.
.SH "Node Object Model"
.IX Header "Node Object Model"
See XML::XPath::Node, XML::XPath::Node::Element,
XML::XPath::Node::Text, XML::XPath::Node::Comment,
XML::XPath::Node::Attribute, XML::XPath::Node::Namespace,
and XML::XPath::Node::PI.
.SH "On Garbage Collection"
.IX Header "On Garbage Collection"
XPath nodes  work in a special way that allows circular references, and yet still
lets Perl's reference counting garbage collector to clean up the nodes after use.
This should  be  totally  transparent to the user, with one caveat: \fBIf you free
your tree before letting go of a sub\-tree,consider that playing with fire and you
may get burned\fR. What does this mean to the average user?  Not much. Provided you
don't free (or let go out of scope) either the tree you passed to XML::XPath\->new,
or if you didn't  pass a tree, and passed a filename or IO-ref, then provided you
don't  let the XML::XPath object go out of scope before you let results of \fBfind()\fR
and its  friends  go out of scope, then you'll be fine. Even if you \fBdo\fR let the
tree go out of scope before results, you'll probably still be fine. The only case
where  you  may  get  stung is when the last part of your path/query is either an
ancestor or parent axis. In that case the worst that will happen is you'll end up
with  a  circular  reference that won't get cleared until interpreter destruction
time.You can get around that by explicitly calling \f(CW$node\fR\->\s-1DESTROY\s0 on each of your
result nodes, if you really need to do that.
.PP
Mail me direct if that's not clear. Note that it's not doom and gloom. It's by no
means perfect,but the worst that will happen is a long running process could leak
memory. Most  long  running  processes  will  therefore  be able to explicitly be
careful not to free the tree (or XML::XPath object) before freeing results.AxKit,
an application  that  uses XML::XPath,  does  this  and I didn't have to make any
changes to the code \- it's already sensible programming.
.PP
If you \fIreally\fR don't want all this to happen, then set the variable \f(CW$XML::XPath::SafeMode\fR,
and call \f(CW$xp\fR\->\fBcleanup()\fR on the XML::XPath object when you're finished, or \f(CW$tree\fR\->\fBdispose()\fR
if you have a tree instead.
.SH "Example"
.IX Header "Example"
Please see the test files in t/ for examples on how to use XPath.
.SH "AUTHOR"
.IX Header "AUTHOR"
Original author Matt Sergeant, \f(CW\*(C`<matt at sergeant.org>\*(C'\fR
.PP
Currently maintained by Mohammad S Anwar, \f(CW\*(C`<mohammad.anwar at yahoo.com>\*(C'\fR
.SH "SEE ALSO"
.IX Header "SEE ALSO"
XML::XPath::Literal, XML::XPath::Boolean, XML::XPath::Number,
XML::XPath::XMLParser, XML::XPath::NodeSet, XML::XPath::PerlSAX,
XML::XPath::Builder.
.SH "LICENSE AND COPYRIGHT"
.IX Header "LICENSE AND COPYRIGHT"
This module is  copyright  2000 AxKit.com Ltd. This is free software, and as such
comes with \s-1NO WARRANTY.\s0 No dates are used in this module. You may distribute this
module under the terms  of either the Gnu \s-1GPL,\s0  or the Artistic License (the same
terms as Perl itself).
.PP
For support, please subscribe to the Perl-XML <http://listserv.activestate.com/mailman/listinfo/perl-xml>
mailing list at the \s-1URL\s0
