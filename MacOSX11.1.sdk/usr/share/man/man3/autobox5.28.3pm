.\" Automatically generated by Pod::Man 4.10 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "autobox 3"
.TH autobox 3 "2018-05-05" "perl v5.28.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
autobox \- call methods on native types
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use autobox;
\&
\&    # integers
\&
\&        my $range = 10\->to(1); # [ 10, 9, 8, 7, 6, 5, 4, 3, 2, 1 ]
\&
\&    # floats
\&
\&        my $error = 3.1415927\->minus(22/7)\->abs();
\&
\&    # strings
\&
\&        my @list = \*(AqSELECT * FROM foo\*(Aq\->list();
\&        my $greeting = "Hello, world!"\->upper(); # "HELLO, WORLD!"
\&
\&        $greeting\->for_each(\e&character_handler);
\&
\&    # arrays and array refs
\&
\&        my $schwartzian = @_\->map(...)\->sort(...)\->map(...);
\&        my $hash = [ \*(AqSELECT * FROM foo WHERE id IN (?, ?)\*(Aq, 1, 2 ]\->hash();
\&
\&    # hashes and hash refs
\&
\&        { alpha => \*(Aqbeta\*(Aq, gamma => \*(Aqvlissides\*(Aq }\->for_each(...);
\&        %hash\->keys();
\&
\&    # code refs
\&
\&        my $plus_five = (\e&add)\->curry()\->(5);
\&        my $minus_three = sub { $_[0] \- $_[1] }\->reverse\->curry\->(3);
\&
\&    # can, isa, VERSION, import and unimport can be accessed via autobox_class
\&
\&        42\->autobox_class\->isa(\*(AqMyNumber\*(Aq)
\&        say []\->autobox_class\->VERSION
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The autobox pragma allows methods to be called on integers, floats, strings, arrays,
hashes, and code references in exactly the same manner as blessed references.
.PP
Autoboxing is transparent: values are not blessed into their (user-defined)
implementation class (unless the method elects to bestow such a blessing) \- they simply
use its methods as though they are.
.PP
The classes (packages) into which the native types are boxed are fully configurable.
By default, a method invoked on a non-object value is assumed to be
defined in a class whose name corresponds to the \f(CW\*(C`ref()\*(C'\fR type of that
value \- or \s-1SCALAR\s0 if the value is a non-reference.
.PP
This mapping can be overridden by passing key/value pairs to the \f(CW\*(C`use autobox\*(C'\fR
statement, in which the keys represent native types, and the values
their associated classes.
.PP
As with regular objects, autoboxed values are passed as the first argument of the specified method.
Consequently, given a vanilla \f(CW\*(C`use autobox\*(C'\fR:
.PP
.Vb 1
\&    "Hello, world!"\->upper()
.Ve
.PP
is invoked as:
.PP
.Vb 1
\&    SCALAR::upper("hello, world!")
.Ve
.PP
while:
.PP
.Vb 1
\&    [ 1 .. 10 ]\->for_each(sub { ... })
.Ve
.PP
resolves to:
.PP
.Vb 1
\&    ARRAY::for_each([ 1 .. 10 ], sub { ... })
.Ve
.PP
Values beginning with the array \f(CW\*(C`@\*(C'\fR and hash \f(CW\*(C`%\*(C'\fR sigils are passed by reference, i.e. under the default bindings:
.PP
.Vb 4
\&    @array\->join(\*(Aq, \*(Aq)
\&    @{ ... }\->length()
\&    %hash\->keys()
\&    %$hash\->values()
.Ve
.PP
are equivalent to:
.PP
.Vb 4
\&    ARRAY::join(\e@array, \*(Aq, \*(Aq)
\&    ARRAY::length(\e@{ ... })
\&    HASH::keys(\e%hash)
\&    HASH::values(\e%$hash)
.Ve
.PP
Multiple \f(CW\*(C`use autobox\*(C'\fR statements can appear in the same scope. These are merged both \*(L"horizontally\*(R" (i.e.
multiple classes can be associated with a particular type) and \*(L"vertically\*(R" (i.e. multiple classes can be associated
with multiple types).
.PP
Thus:
.PP
.Vb 2
\&    use autobox SCALAR => \*(AqFoo\*(Aq;
\&    use autobox SCALAR => \*(AqBar\*(Aq;
.Ve
.PP
\&\- associates \s-1SCALAR\s0 types with a synthetic class whose \f(CW@ISA\fR includes both Foo and Bar (in that order).
.PP
Likewise:
.PP
.Vb 3
\&    use autobox SCALAR => \*(AqFoo\*(Aq;
\&    use autobox SCALAR => \*(AqBar\*(Aq;
\&    use autobox ARRAY  => \*(AqBaz\*(Aq;
.Ve
.PP
and
.PP
.Vb 2
\&    use autobox SCALAR => [ \*(AqFoo\*(Aq, \*(AqBar\*(Aq ];
\&    use autobox ARRAY  => \*(AqBaz\*(Aq;
.Ve
.PP
\&\- bind \s-1SCALAR\s0 types to the Foo and Bar classes and \s-1ARRAY\s0 types to Baz.
.PP
autobox is lexically scoped, and bindings for an outer scope
can be extended or countermanded in a nested scope:
.PP
.Vb 3
\&    {
\&        use autobox; # default bindings: autobox all native types
\&        ...
\&
\&        {
\&            # appends \*(AqMyScalar\*(Aq to the @ISA associated with SCALAR types
\&            use autobox SCALAR => \*(AqMyScalar\*(Aq;
\&            ...
\&        }
\&
\&        # back to the default (no MyScalar)
\&        ...
\&    }
.Ve
.PP
Autoboxing can be turned off entirely by using the \f(CW\*(C`no\*(C'\fR syntax:
.PP
.Vb 6
\&    {
\&        use autobox;
\&        ...
\&        no autobox;
\&        ...
\&    }
.Ve
.PP
\&\- or can be selectively disabled by passing arguments to the \f(CW\*(C`no autobox\*(C'\fR statement:
.PP
.Vb 1
\&    use autobox; # default bindings
\&
\&    no autobox qw(SCALAR);
\&
\&    []\->foo(); # OK: ARRAY::foo([])
\&
\&    "Hello, world!"\->bar(); # runtime error
.Ve
.PP
Autoboxing is not performed for barewords i.e.
.PP
.Vb 1
\&    my $foo = Foo\->new();
.Ve
.PP
and:
.PP
.Vb 1
\&    my $foo = new Foo;
.Ve
.PP
behave as expected.
.PP
Methods are called on native types by means of the arrow operator. As with
regular objects, the right hand side of the operator can either be a bare method name or a variable containing
a method name or subroutine reference. Thus the following are all valid:
.PP
.Vb 4
\&    sub method1 { ... }
\&    my $method2 = \*(Aqsome_method\*(Aq;
\&    my $method3 = sub { ... };
\&    my $method4 = \e&some_method;
\&
\&    " ... "\->method1();
\&    [ ... ]\->$method2();
\&    { ... }\->$method3();
\&    sub { ... }\->$method4();
.Ve
.PP
A native type is only associated with a class if the type => class mapping
is supplied in the \f(CW\*(C`use autobox\*(C'\fR statement. Thus the following will not work:
.PP
.Vb 1
\&    use autobox SCALAR => \*(AqMyScalar\*(Aq;
\&
\&    @array\->some_array_method();
.Ve
.PP
\&\- as no class is specified for the \s-1ARRAY\s0 type. Note: the result of calling a method
on a native type that is not associated with a class is the usual runtime error message:
.PP
.Vb 1
\&    Can\*(Aqt call method "some_array_method" on unblessed reference at ...
.Ve
.PP
As a convenience, there is one exception to this rule. If \f(CW\*(C`use autobox\*(C'\fR is invoked with no arguments
(ignoring the \s-1DEBUG\s0 option) the four main native types are associated with classes of the same name.
.PP
Thus:
.PP
.Vb 1
\&    use autobox;
.Ve
.PP
\&\- is equivalent to:
.PP
.Vb 6
\&    use autobox {
\&        SCALAR => \*(AqSCALAR\*(Aq,
\&        ARRAY  => \*(AqARRAY\*(Aq,
\&        HASH   => \*(AqHASH\*(Aq,
\&        CODE   => \*(AqCODE\*(Aq,
\&    }
.Ve
.PP
This facilitates one-liners and prototypes:
.PP
.Vb 1
\&    use autobox;
\&
\&    sub SCALAR::split { [ split \*(Aq\*(Aq, $_[0] ] }
\&    sub ARRAY::length { scalar @{$_[0]} }
\&
\&    print "Hello, world!"\->split\->length();
.Ve
.PP
However, using these default bindings is not recommended as there's no guarantee that another
piece of code won't trample over the same namespace/methods.
.SH "OPTIONS"
.IX Header "OPTIONS"
A mapping from native types to their user-defined classes can be specified
by passing a hashref or a list of key/value pairs to the \f(CW\*(C`use autobox\*(C'\fR statement.
.PP
The following example shows the range of valid arguments:
.PP
.Vb 10
\&    use autobox {
\&        SCALAR    => \*(AqMyScalar\*(Aq                     # class name
\&        ARRAY     => \*(AqMyNamespace::\*(Aq,               # class prefix (ending in \*(Aq::\*(Aq)
\&        HASH      => [ \*(AqMyHash\*(Aq, \*(AqMyNamespace::\*(Aq ], # one or more class names and/or prefixes
\&        CODE      => ...,                           # any of the 3 value types above
\&        INTEGER   => ...,                           # any of the 3 value types above
\&        FLOAT     => ...,                           # any of the 3 value types above
\&        NUMBER    => ...,                           # any of the 3 value types above
\&        STRING    => ...,                           # any of the 3 value types above
\&        UNDEF     => ...,                           # any of the 3 value types above
\&        UNIVERSAL => ...,                           # any of the 3 value types above
\&        DEFAULT   => ...,                           # any of the 3 value types above
\&        DEBUG     => ...                            # boolean or coderef
\&    }
.Ve
.PP
The \s-1INTEGER, FLOAT, NUMBER, STRING, SCALAR, ARRAY, HASH, CODE, UNDEF, DEFAULT\s0 and \s-1UNIVERSAL\s0 options can take
three different types of value:
.IP "\(bu" 4
A class name e.g.
.Sp
.Vb 1
\&    use autobox INTEGER => \*(AqMyInt\*(Aq;
.Ve
.Sp
This binds the specified native type to the specified class. All methods invoked on
values of type \f(CW\*(C`key\*(C'\fR will be dispatched as methods of the class specified in
the corresponding \f(CW\*(C`value\*(C'\fR.
.IP "\(bu" 4
A namespace: this is a class prefix (up to and including the final '::')
to which the specified type name (\s-1INTEGER, FLOAT, STRING\s0 &c.) will be appended:
.Sp
Thus:
.Sp
.Vb 1
\&    use autobox ARRAY => \*(AqPrelude::\*(Aq;
.Ve
.Sp
is equivalent to:
.Sp
.Vb 1
\&    use autobox ARRAY => \*(AqPrelude::ARRAY\*(Aq;
.Ve
.IP "\(bu" 4
A reference to an array of class names and/or namespaces. This associates multiple classes with the
specified type.
.SS "\s-1DEFAULT\s0"
.IX Subsection "DEFAULT"
The \f(CW\*(C`DEFAULT\*(C'\fR option specifies bindings for any of the four default types (\s-1SCALAR, ARRAY, HASH\s0 and \s-1CODE\s0)
not supplied in the \f(CW\*(C`use autobox\*(C'\fR statement. As with the other options, the \f(CW\*(C`value\*(C'\fR corresponding to
the \f(CW\*(C`DEFAULT\*(C'\fR \f(CW\*(C`key\*(C'\fR can be a class name, a namespace, or a reference to an array containing one or
more class names and/or namespaces.
.PP
Thus:
.PP
.Vb 4
\&    use autobox {
\&        STRING  => \*(AqMyString\*(Aq,
\&        DEFAULT => \*(AqMyDefault\*(Aq,
\&    }
.Ve
.PP
is equivalent to:
.PP
.Vb 7
\&    use autobox {
\&        STRING  => \*(AqMyString\*(Aq,
\&        SCALAR  => \*(AqMyDefault\*(Aq,
\&        ARRAY   => \*(AqMyDefault\*(Aq,
\&        HASH    => \*(AqMyDefault\*(Aq,
\&        CODE    => \*(AqMyDefault\*(Aq,
\&    }
.Ve
.PP
Which in turn is equivalent to:
.PP
.Vb 8
\&    use autobox {
\&        INTEGER => \*(AqMyDefault\*(Aq,
\&        FLOAT   => \*(AqMyDefault\*(Aq,
\&        STRING  => [ \*(AqMyString\*(Aq, \*(AqMyDefault\*(Aq ],
\&        ARRAY   => \*(AqMyDefault\*(Aq,
\&        HASH    => \*(AqMyDefault\*(Aq,
\&        CODE    => \*(AqMyDefault\*(Aq,
\&    }
.Ve
.PP
Namespaces in \s-1DEFAULT\s0 values have the default type name appended, which, in the case of defaulted \s-1SCALAR\s0 types,
is \s-1SCALAR\s0 rather than \s-1INTEGER, FLOAT\s0 &c.
.PP
Thus:
.PP
.Vb 6
\&    use autobox {
\&        ARRAY   => \*(AqMyArray\*(Aq,
\&        HASH    => \*(AqMyHash\*(Aq,
\&        CODE    => \*(AqMyCode\*(Aq,
\&        DEFAULT => \*(AqMyNamespace::\*(Aq,
\&    }
.Ve
.PP
is equivalent to:
.PP
.Vb 8
\&    use autobox {
\&        INTEGER => \*(AqMyNamespace::SCALAR\*(Aq,
\&        FLOAT   => \*(AqMyNamespace::SCALAR\*(Aq,
\&        STRING  => \*(AqMyNamespace::SCALAR\*(Aq,
\&        ARRAY   => \*(AqMyArray\*(Aq,
\&        HASH    => \*(AqMyArray\*(Aq,
\&        CODE    => \*(AqMyCode\*(Aq,
\&    }
.Ve
.PP
Any of the four default types can be exempted from defaulting to the \s-1DEFAULT\s0 value by supplying a value of undef:
.PP
.Vb 4
\&    use autobox {
\&        HASH    => undef,
\&        DEFAULT => \*(AqMyDefault\*(Aq,
\&    }
\&
\&    42\->foo # ok: MyDefault::foo
\&    []\->bar # ok: MyDefault::bar
\&
\&    %INC\->baz # not ok: runtime error
.Ve
.SS "\s-1UNDEF\s0"
.IX Subsection "UNDEF"
The pseudotype, \s-1UNDEF,\s0 can be used to autobox undefined values. These are not autoboxed by default.
.PP
This doesn't work:
.PP
.Vb 1
\&    use autobox;
\&
\&    undef\->foo() # runtime error
.Ve
.PP
This works:
.PP
.Vb 1
\&    use autobox UNDEF => \*(AqMyUndef\*(Aq;
\&
\&    undef\->foo(); # ok
.Ve
.PP
So does this:
.PP
.Vb 1
\&    use autobox UNDEF => \*(AqMyNamespace::\*(Aq;
\&
\&    undef\->foo(); # ok
.Ve
.SS "\s-1NUMBER, SCALAR\s0 and \s-1UNIVERSAL\s0"
.IX Subsection "NUMBER, SCALAR and UNIVERSAL"
The virtual types \s-1NUMBER, SCALAR\s0 and \s-1UNIVERSAL\s0 function as macros or shortcuts which create
bindings for their subtypes. The type hierarchy is as follows:
.PP
.Vb 10
\&  UNIVERSAL \-+
\&             |
\&             +\- SCALAR \-+
\&             |          |
\&             |          +\- NUMBER \-+
\&             |          |          |
\&             |          |          +\- INTEGER
\&             |          |          |
\&             |          |          +\- FLOAT
\&             |          |
\&             |          +\- STRING
\&             |
\&             +\- ARRAY
\&             |
\&             +\- HASH
\&             |
\&             +\- CODE
.Ve
.PP
Thus:
.PP
.Vb 1
\&    use autobox NUMBER => \*(AqMyNumber\*(Aq;
.Ve
.PP
is equivalent to:
.PP
.Vb 4
\&    use autobox {
\&        INTEGER => \*(AqMyNumber\*(Aq,
\&        FLOAT   => \*(AqMyNumber\*(Aq,
\&    }
.Ve
.PP
And:
.PP
.Vb 1
\&    use autobox SCALAR => \*(AqMyScalar\*(Aq;
.Ve
.PP
is equivalent to:
.PP
.Vb 5
\&    use autobox {
\&        INTEGER => \*(AqMyScalar\*(Aq,
\&        FLOAT   => \*(AqMyScalar\*(Aq,
\&        STRING  => \*(AqMyScalar\*(Aq,
\&    }
.Ve
.PP
Virtual types can also be passed to \f(CW\*(C`unimport\*(C'\fR via the \f(CW\*(C`no autobox\*(C'\fR syntax. This disables autoboxing
for the corresponding subtypes e.g.
.PP
.Vb 1
\&    no autobox qw(NUMBER);
.Ve
.PP
is equivalent to:
.PP
.Vb 1
\&    no autobox qw(INTEGER FLOAT);
.Ve
.PP
Virtual type bindings can be mixed with ordinary bindings to provide fine-grained control over
inheritance and delegation. For instance:
.PP
.Vb 5
\&    use autobox {
\&        INTEGER => \*(AqMyInteger\*(Aq,
\&        NUMBER  => \*(AqMyNumber\*(Aq,
\&        SCALAR  => \*(AqMyScalar\*(Aq,
\&    }
.Ve
.PP
would result in the following bindings:
.PP
.Vb 3
\&    42\->foo              \-> [ MyInteger, MyNumber, MyScalar ]
\&    3.1415927\->bar       \-> [ MyNumber, MyScalar ]
\&    "Hello, world!"\->baz \-> [ MyScalar ]
.Ve
.PP
Note that \s-1DEFAULT\s0 bindings take precedence over virtual type bindings i.e.
.PP
.Vb 4
\&    use autobox {
\&        UNIVERSAL => \*(AqMyUniversal\*(Aq,
\&        DEFAULT   => \*(AqMyDefault\*(Aq, # default SCALAR, ARRAY, HASH and CODE before UNIVERSAL
\&    }
.Ve
.PP
is equivalent to:
.PP
.Vb 4
\&  use autobox {
\&      INTEGER => [ \*(AqMyDefault\*(Aq, \*(AqMyUniversal\*(Aq ],
\&      FLOAT   => [ \*(AqMyDefault\*(Aq, \*(AqMyUniversal\*(Aq ], # ... &c.
\&  }
.Ve
.SS "\s-1DEBUG\s0"
.IX Subsection "DEBUG"
\&\f(CW\*(C`DEBUG\*(C'\fR allows the autobox bindings for the current scope to be inspected,
either by dumping them to the console or passing them to a callback function.
This allows the computed bindings to be seen in \*(L"longhand\*(R".
.PP
The option is ignored if the value corresponding to the \f(CW\*(C`DEBUG\*(C'\fR key is false.
.PP
If the value is a \s-1CODE\s0 ref, it is called with a reference to the hash
containing the computed bindings for the current scope.
.PP
Finally, if \f(CW\*(C`DEBUG\*(C'\fR is true but not a \s-1CODE\s0 ref, the bindings are dumped
to \s-1STDERR.\s0
.PP
Thus:
.PP
.Vb 1
\&    use autobox DEBUG => 1, ...
.Ve
.PP
or
.PP
.Vb 1
\&    use autobox DEBUG => sub { ... }, ...
.Ve
.PP
or
.PP
.Vb 4
\&    sub my_callback ($) {
\&        my $hashref = shift;
\&        ...
\&    }
\&
\&    use autobox DEBUG => \e&my_callback, ...
.Ve
.SH "METHODS"
.IX Header "METHODS"
.SS "import"
.IX Subsection "import"
This method sets up autobox bindings for the current lexical scope. It can be used to implement
autobox extensions i.e. lexically-scoped modules that provide autobox bindings for one or more
native types without requiring calling code to \f(CW\*(C`use autobox\*(C'\fR.
.PP
This is done by subclassing autobox and overriding \f(CW\*(C`import\*(C'\fR. This allows extensions to effectively
translate \f(CW\*(C`use MyModule\*(C'\fR into a bespoke \f(CW\*(C`use autobox\*(C'\fR call e.g.:
.PP
.Vb 1
\&    package String::Trim;
\&
\&    use base qw(autobox);
\&
\&    sub import {
\&        my $class = shift;
\&
\&        $class\->SUPER::import(
\&            STRING => \*(AqString::Trim::String\*(Aq
\&        );
\&    }
\&
\&    package String::Trim::String;
\&
\&    sub trim {
\&        my $string = shift;
\&        $string =~ s/^\es+//;
\&        $string =~ s/\es+$//;
\&        $string;
\&    }
\&
\&    1;
.Ve
.PP
Note that \f(CW\*(C`trim\*(C'\fR is defined in an auxiliary class rather than in String::Trim itself to prevent
String::Trim's own methods (i.e. the methods it inherits from autobox) being exposed to \f(CW\*(C`STRING\*(C'\fR types.
.PP
This module can now be used without a \f(CW\*(C`use autobox\*(C'\fR statement to enable the \f(CW\*(C`trim\*(C'\fR method in the current
lexical scope e.g.:
.PP
.Vb 1
\&    #!/usr/bin/env perl
\&
\&    use String::Trim;
\&
\&    print "  Hello, world!  "\->trim();
.Ve
.SH "UNIVERSAL METHODS FOR AUTOBOXED TYPES"
.IX Header "UNIVERSAL METHODS FOR AUTOBOXED TYPES"
.SS "autobox_class"
.IX Subsection "autobox_class"
autobox adds a single method to all autoboxed types: \f(CW\*(C`autobox_class\*(C'\fR. This can be used to
call \s-1UNIVERSAL\s0 methods i.e. \f(CW\*(C`can\*(C'\fR, \f(CW\*(C`DOES\*(C'\fR, \f(CW\*(C`import\*(C'\fR, \f(CW\*(C`isa\*(C'\fR, \f(CW\*(C`unimport\*(C'\fR and \f(CW\*(C`VERSION\*(C'\fR e.g.
.PP
.Vb 2
\&    if (sub { ... }\->autobox_class\->can(\*(Aqcurry\*(Aq)) ...
\&    if (42\->autobox_class\->isa(\*(AqSCALAR\*(Aq)) ...
.Ve
.PP
Note: \f(CW\*(C`autobox_class\*(C'\fR must \fBalways\fR be used when calling these methods. Calling them
directly on native types produces the same results as calling them with autobox disabled
e.g.:
.PP
.Vb 2
\&    42\->isa(\*(AqNUMBER\*(Aq) # "" (interpeted as "42"\->isa("NUMBER"))
\&    []\->can(\*(Aqpush\*(Aq)   # Error: Can\*(Aqt call method "can" on unblessed reference
.Ve
.SH "EXPORTS"
.IX Header "EXPORTS"
.SS "type"
.IX Subsection "type"
autobox includes an additional module, autobox::universal, which exports a single subroutine, \f(CW\*(C`type\*(C'\fR.
.PP
This sub returns the type of its argument within autobox (which is essentially longhand for the type names
used within perl). This value is used by autobox to associate a method invocant with its designated classes e.g.
.PP
.Vb 1
\&    use autobox::universal qw(type);
\&
\&    type("42")  # STRING
\&    type(42)    # INTEGER
\&    type(42.0)  # FLOAT
\&    type(undef) # UNDEF
.Ve
.PP
autobox::universal is loaded automatically by autobox, and, as its name suggests, can be used to install
a universal \f(CW\*(C`type\*(C'\fR method for autoboxed values e.g.
.PP
.Vb 1
\&    use autobox UNIVERSAL => \*(Aqautobox::universal\*(Aq;
\&
\&    42\->type        # INTEGER
\&    3.1415927\->type # FLOAT
\&    %ENV\->type      # HASH
.Ve
.SH "CAVEATS"
.IX Header "CAVEATS"
.SS "Performance"
.IX Subsection "Performance"
Calling
.PP
.Vb 1
\&    "Hello, world!"\->length()
.Ve
.PP
is slightly slower than the equivalent method call on a string-like object, and significantly slower than
.PP
.Vb 1
\&    length("Hello, world!")
.Ve
.SS "Gotchas"
.IX Subsection "Gotchas"
\fIPrecedence\fR
.IX Subsection "Precedence"
.PP
Due to Perl's precedence rules, some autoboxed literals may need to be parenthesized:
.PP
For instance, while this works:
.PP
.Vb 1
\&    my $curried = sub { ... }\->curry();
.Ve
.PP
this doesn't:
.PP
.Vb 1
\&    my $curried = \e&foo\->curry();
.Ve
.PP
The solution is to wrap the reference in parentheses:
.PP
.Vb 1
\&    my $curried = (\e&foo)\->curry();
.Ve
.PP
The same applies for signed integer and float literals:
.PP
.Vb 2
\&    # this works
\&    my $range = 10\->to(1);
\&
\&    # this doesn\*(Aqt work
\&    my $range = \-10\->to(10);
\&
\&    # this works
\&    my $range = (\-10)\->to(10);
.Ve
.PP
\fIprint \s-1BLOCK\s0\fR
.IX Subsection "print BLOCK"
.PP
Perl's special-casing for the \f(CW\*(C`print BLOCK ...\*(C'\fR syntax (see perlsub) means that \f(CW\*(C`print { expression() } ...\*(C'\fR
(where the curly brackets denote an anonymous \s-1HASH\s0 ref) may require some further disambiguation:
.PP
.Vb 2
\&    # this works
\&    print { foo => \*(Aqbar\*(Aq }\->foo();
\&
\&    # and this
\&    print { \*(Aqfoo\*(Aq, \*(Aqbar\*(Aq }\->foo();
\&
\&    # and even this
\&    print { \*(Aqfoo\*(Aq, \*(Aqbar\*(Aq, @_ }\->foo();
\&
\&    # but this doesn\*(Aqt
\&    print { @_ }\->foo() ? 1 : 0
.Ve
.PP
In the latter case, the solution is to supply something
other than a \s-1HASH\s0 ref literal as the first argument
to \f(CW\*(C`print()\*(C'\fR:
.PP
.Vb 2
\&    # e.g.
\&    print STDOUT { @_ }\->foo() ? 1 : 0;
\&
\&    # or
\&    my $hashref = { @_ };
\&    print $hashref\->foo() ? 1 : 0;
\&
\&    # or
\&    print \*(Aq\*(Aq, { @_ }\->foo() ? 1 : 0;
\&
\&    # or
\&    print \*(Aq\*(Aq . { @_ }\->foo() ? 1 : 0;
\&
\&    # or even
\&    { @_ }\->print_if_foo(1, 0);
.Ve
.PP
\fIeval \s-1EXPR\s0\fR
.IX Subsection "eval EXPR"
.PP
Like most pragmas, autobox performs operations at compile time, and,
as a result, runtime string \f(CW\*(C`eval\*(C'\fRs are not executed within its scope i.e. this
doesn't work:
.PP
.Vb 1
\&    use autobox;
\&
\&    eval "42\->foo";
.Ve
.PP
The workaround is to use autobox within the \f(CW\*(C`eval\*(C'\fR e.g.
.PP
.Vb 4
\&    eval <<\*(AqEOS\*(Aq;
\&        use autobox;
\&        42\->foo();
\&    EOS
.Ve
.PP
Note that the \f(CW\*(C`eval BLOCK\*(C'\fR form works as expected:
.PP
.Vb 1
\&    use autobox;
\&
\&    eval { 42\->foo() }; # OK
.Ve
.PP
\fIOperator Overloading\fR
.IX Subsection "Operator Overloading"
.PP
Operator overloading via the overload pragma doesn't (automatically) work.
autobox works by lexically overriding the arrow operator.
It doesn't bless native types into objects, so overloading \- or any other kind of \*(L"magic\*(R"
which depends on values being blessed \- doesn't apply.
.SH "VERSION"
.IX Header "VERSION"
3.0.1
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.IP "\(bu" 4
autobox::Core
.IP "\(bu" 4
Moose::Autobox
.IP "\(bu" 4
perl5i
.IP "\(bu" 4
Scalar::Properties
.SH "AUTHOR"
.IX Header "AUTHOR"
chocolateboy <chocolate@cpan.org>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright (c) 2003\-2018 by chocolateboy.
.PP
This library is free software; you can redistribute it and/or modify it under the
terms of the Artistic License 2.0 <http://www.opensource.org/licenses/artistic-license-2.0.php>.
