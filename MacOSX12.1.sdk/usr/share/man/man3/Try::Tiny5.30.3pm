.\" Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Try::Tiny 3"
.TH Try::Tiny 3 "2017-12-21" "perl v5.30.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Try::Tiny \- Minimal try/catch with proper preservation of $@
.SH "VERSION"
.IX Header "VERSION"
version 0.30
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
You can use Try::Tiny's \f(CW\*(C`try\*(C'\fR and \f(CW\*(C`catch\*(C'\fR to expect and handle exceptional
conditions, avoiding quirks in Perl and common mistakes:
.PP
.Vb 6
\&  # handle errors with a catch handler
\&  try {
\&    die "foo";
\&  } catch {
\&    warn "caught error: $_"; # not $@
\&  };
.Ve
.PP
You can also use it like a standalone \f(CW\*(C`eval\*(C'\fR to catch and ignore any error
conditions.  Obviously, this is an extreme measure not to be undertaken
lightly:
.PP
.Vb 4
\&  # just silence errors
\&  try {
\&    die "foo";
\&  };
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module provides bare bones \f(CW\*(C`try\*(C'\fR/\f(CW\*(C`catch\*(C'\fR/\f(CW\*(C`finally\*(C'\fR statements that are designed to
minimize common mistakes with eval blocks, and \s-1NOTHING\s0 else.
.PP
This is unlike TryCatch which provides a nice syntax and avoids adding
another call stack layer, and supports calling \f(CW\*(C`return\*(C'\fR from the \f(CW\*(C`try\*(C'\fR block to
return from the parent subroutine. These extra features come at a cost of a few
dependencies, namely Devel::Declare and Scope::Upper which are
occasionally problematic, and the additional catch filtering uses Moose
type constraints which may not be desirable either.
.PP
The main focus of this module is to provide simple and reliable error handling
for those having a hard time installing TryCatch, but who still want to
write correct \f(CW\*(C`eval\*(C'\fR blocks without 5 lines of boilerplate each time.
.PP
It's designed to work as correctly as possible in light of the various
pathological edge cases (see \*(L"\s-1BACKGROUND\*(R"\s0) and to be compatible with any style
of error values (simple strings, references, objects, overloaded objects, etc).
.PP
If the \f(CW\*(C`try\*(C'\fR block dies, it returns the value of the last statement executed in
the \f(CW\*(C`catch\*(C'\fR block, if there is one. Otherwise, it returns \f(CW\*(C`undef\*(C'\fR in scalar
context or the empty list in list context. The following examples all
assign \f(CW"bar"\fR to \f(CW$x\fR:
.PP
.Vb 3
\&  my $x = try { die "foo" } catch { "bar" };
\&  my $x = try { die "foo" } || "bar";
\&  my $x = (try { die "foo" }) // "bar";
\&
\&  my $x = eval { die "foo" } || "bar";
.Ve
.PP
You can add \f(CW\*(C`finally\*(C'\fR blocks, yielding the following:
.PP
.Vb 3
\&  my $x;
\&  try { die \*(Aqfoo\*(Aq } finally { $x = \*(Aqbar\*(Aq };
\&  try { die \*(Aqfoo\*(Aq } catch { warn "Got a die: $_" } finally { $x = \*(Aqbar\*(Aq };
.Ve
.PP
\&\f(CW\*(C`finally\*(C'\fR blocks are always executed making them suitable for cleanup code
which cannot be handled using local.  You can add as many \f(CW\*(C`finally\*(C'\fR blocks to a
given \f(CW\*(C`try\*(C'\fR block as you like.
.PP
Note that adding a \f(CW\*(C`finally\*(C'\fR block without a preceding \f(CW\*(C`catch\*(C'\fR block
suppresses any errors. This behaviour is consistent with using a standalone
\&\f(CW\*(C`eval\*(C'\fR, but it is not consistent with \f(CW\*(C`try\*(C'\fR/\f(CW\*(C`finally\*(C'\fR patterns found in
other programming languages, such as Java, Python, Javascript or C#. If you
learnt the \f(CW\*(C`try\*(C'\fR/\f(CW\*(C`finally\*(C'\fR pattern from one of these languages, watch out for
this.
.SH "EXPORTS"
.IX Header "EXPORTS"
All functions are exported by default using Exporter.
.PP
If you need to rename the \f(CW\*(C`try\*(C'\fR, \f(CW\*(C`catch\*(C'\fR or \f(CW\*(C`finally\*(C'\fR keyword consider using
Sub::Import to get Sub::Exporter's flexibility.
.IP "try (&;@)" 4
.IX Item "try (&;@)"
Takes one mandatory \f(CW\*(C`try\*(C'\fR subroutine, an optional \f(CW\*(C`catch\*(C'\fR subroutine and \f(CW\*(C`finally\*(C'\fR
subroutine.
.Sp
The mandatory subroutine is evaluated in the context of an \f(CW\*(C`eval\*(C'\fR block.
.Sp
If no error occurred the value from the first block is returned, preserving
list/scalar context.
.Sp
If there was an error and the second subroutine was given it will be invoked
with the error in \f(CW$_\fR (localized) and as that block's first and only
argument.
.Sp
\&\f(CW$@\fR does \fBnot\fR contain the error. Inside the \f(CW\*(C`catch\*(C'\fR block it has the same
value it had before the \f(CW\*(C`try\*(C'\fR block was executed.
.Sp
Note that the error may be false, but if that happens the \f(CW\*(C`catch\*(C'\fR block will
still be invoked.
.Sp
Once all execution is finished then the \f(CW\*(C`finally\*(C'\fR block, if given, will execute.
.IP "catch (&;@)" 4
.IX Item "catch (&;@)"
Intended to be used in the second argument position of \f(CW\*(C`try\*(C'\fR.
.Sp
Returns a reference to the subroutine it was given but blessed as
\&\f(CW\*(C`Try::Tiny::Catch\*(C'\fR which allows try to decode correctly what to do
with this code reference.
.Sp
.Vb 1
\&  catch { ... }
.Ve
.Sp
Inside the \f(CW\*(C`catch\*(C'\fR block the caught error is stored in \f(CW$_\fR, while previous
value of \f(CW$@\fR is still available for use.  This value may or may not be
meaningful depending on what happened before the \f(CW\*(C`try\*(C'\fR, but it might be a good
idea to preserve it in an error stack.
.Sp
For code that captures \f(CW$@\fR when throwing new errors (i.e.
Class::Throwable), you'll need to do:
.Sp
.Vb 1
\&  local $@ = $_;
.Ve
.IP "finally (&;@)" 4
.IX Item "finally (&;@)"
.Vb 3
\&  try     { ... }
\&  catch   { ... }
\&  finally { ... };
.Ve
.Sp
Or
.Sp
.Vb 2
\&  try     { ... }
\&  finally { ... };
.Ve
.Sp
Or even
.Sp
.Vb 3
\&  try     { ... }
\&  finally { ... }
\&  catch   { ... };
.Ve
.Sp
Intended to be the second or third element of \f(CW\*(C`try\*(C'\fR. \f(CW\*(C`finally\*(C'\fR blocks are always
executed in the event of a successful \f(CW\*(C`try\*(C'\fR or if \f(CW\*(C`catch\*(C'\fR is run. This allows
you to locate cleanup code which cannot be done via \f(CW\*(C`local()\*(C'\fR e.g. closing a file
handle.
.Sp
When invoked, the \f(CW\*(C`finally\*(C'\fR block is passed the error that was caught.  If no
error was caught, it is passed nothing.  (Note that the \f(CW\*(C`finally\*(C'\fR block does not
localize \f(CW$_\fR with the error, since unlike in a \f(CW\*(C`catch\*(C'\fR block, there is no way
to know if \f(CW\*(C`$_ == undef\*(C'\fR implies that there were no errors.) In other words,
the following code does just what you would expect:
.Sp
.Vb 11
\&  try {
\&    die_sometimes();
\&  } catch {
\&    # ...code run in case of error
\&  } finally {
\&    if (@_) {
\&      print "The try block died with: @_\en";
\&    } else {
\&      print "The try block ran without error.\en";
\&    }
\&  };
.Ve
.Sp
\&\fBYou must always do your own error handling in the \f(CB\*(C`finally\*(C'\fB block\fR. \f(CW\*(C`Try::Tiny\*(C'\fR will
not do anything about handling possible errors coming from code located in these
blocks.
.Sp
Furthermore \fBexceptions in \f(CB\*(C`finally\*(C'\fB blocks are not trappable and are unable
to influence the execution of your program\fR. This is due to limitation of
\&\f(CW\*(C`DESTROY\*(C'\fR\-based scope guards, which \f(CW\*(C`finally\*(C'\fR is implemented on top of. This
may change in a future version of Try::Tiny.
.Sp
In the same way \f(CW\*(C`catch()\*(C'\fR blesses the code reference this subroutine does the same
except it bless them as \f(CW\*(C`Try::Tiny::Finally\*(C'\fR.
.SH "BACKGROUND"
.IX Header "BACKGROUND"
There are a number of issues with \f(CW\*(C`eval\*(C'\fR.
.SS "Clobbering $@"
.IX Subsection "Clobbering $@"
When you run an \f(CW\*(C`eval\*(C'\fR block and it succeeds, \f(CW$@\fR will be cleared, potentially
clobbering an error that is currently being caught.
.PP
This causes action at a distance, clearing previous errors your caller may have
not yet handled.
.PP
\&\f(CW$@\fR must be properly localized before invoking \f(CW\*(C`eval\*(C'\fR in order to avoid this
issue.
.PP
More specifically,
before Perl version 5.14.0
\&\f(CW$@\fR was clobbered at the beginning of the \f(CW\*(C`eval\*(C'\fR, which
also made it impossible to capture the previous error before you die (for
instance when making exception objects with error stacks).
.PP
For this reason \f(CW\*(C`try\*(C'\fR will actually set \f(CW$@\fR to its previous value (the one
available before entering the \f(CW\*(C`try\*(C'\fR block) in the beginning of the \f(CW\*(C`eval\*(C'\fR
block.
.SS "Localizing $@ silently masks errors"
.IX Subsection "Localizing $@ silently masks errors"
Inside an \f(CW\*(C`eval\*(C'\fR block, \f(CW\*(C`die\*(C'\fR behaves sort of like:
.PP
.Vb 4
\&  sub die {
\&    $@ = $_[0];
\&    return_undef_from_eval();
\&  }
.Ve
.PP
This means that if you were polite and localized \f(CW$@\fR you can't die in that
scope, or your error will be discarded (printing \*(L"Something's wrong\*(R" instead).
.PP
The workaround is very ugly:
.PP
.Vb 5
\&  my $error = do {
\&    local $@;
\&    eval { ... };
\&    $@;
\&  };
\&
\&  ...
\&  die $error;
.Ve
.SS "$@ might not be a true value"
.IX Subsection "$@ might not be a true value"
This code is wrong:
.PP
.Vb 3
\&  if ( $@ ) {
\&    ...
\&  }
.Ve
.PP
because due to the previous caveats it may have been unset.
.PP
\&\f(CW$@\fR could also be an overloaded error object that evaluates to false, but
that's asking for trouble anyway.
.PP
The classic failure mode (fixed in Perl 5.14.0) is:
.PP
.Vb 3
\&  sub Object::DESTROY {
\&    eval { ... }
\&  }
\&
\&  eval {
\&    my $obj = Object\->new;
\&
\&    die "foo";
\&  };
\&
\&  if ( $@ ) {
\&
\&  }
.Ve
.PP
In this case since \f(CW\*(C`Object::DESTROY\*(C'\fR is not localizing \f(CW$@\fR but still uses
\&\f(CW\*(C`eval\*(C'\fR, it will set \f(CW$@\fR to \f(CW""\fR.
.PP
The destructor is called when the stack is unwound, after \f(CW\*(C`die\*(C'\fR sets \f(CW$@\fR to
\&\f(CW"foo at Foo.pm line 42\en"\fR, so by the time \f(CW\*(C`if ( $@ )\*(C'\fR is evaluated it has
been cleared by \f(CW\*(C`eval\*(C'\fR in the destructor.
.PP
The workaround for this is even uglier than the previous ones. Even though we
can't save the value of \f(CW$@\fR from code that doesn't localize, we can at least
be sure the \f(CW\*(C`eval\*(C'\fR was aborted due to an error:
.PP
.Vb 2
\&  my $failed = not eval {
\&    ...
\&
\&    return 1;
\&  };
.Ve
.PP
This is because an \f(CW\*(C`eval\*(C'\fR that caught a \f(CW\*(C`die\*(C'\fR will always return a false
value.
.SH "ALTERNATE SYNTAX"
.IX Header "ALTERNATE SYNTAX"
Using Perl 5.10 you can use \*(L"Switch statements\*(R" in perlsyn (but please don't,
because that syntax has since been deprecated because there was too much
unexpected magical behaviour).
.PP
The \f(CW\*(C`catch\*(C'\fR block is invoked in a topicalizer context (like a \f(CW\*(C`given\*(C'\fR block),
but note that you can't return a useful value from \f(CW\*(C`catch\*(C'\fR using the \f(CW\*(C`when\*(C'\fR
blocks without an explicit \f(CW\*(C`return\*(C'\fR.
.PP
This is somewhat similar to Perl 6's \f(CW\*(C`CATCH\*(C'\fR blocks. You can use it to
concisely match errors:
.PP
.Vb 6
\&  try {
\&    require Foo;
\&  } catch {
\&    when (/^Can\*(Aqt locate .*?\e.pm in \e@INC/) { } # ignore
\&    default { die $_ }
\&  };
.Ve
.SH "CAVEATS"
.IX Header "CAVEATS"
.IP "\(bu" 4
\&\f(CW@_\fR is not available within the \f(CW\*(C`try\*(C'\fR block, so you need to copy your
argument list. In case you want to work with argument values directly via \f(CW@_\fR
aliasing (i.e. allow \f(CW\*(C`$_[1] = "foo"\*(C'\fR), you need to pass \f(CW@_\fR by reference:
.Sp
.Vb 4
\&  sub foo {
\&    my ( $self, @args ) = @_;
\&    try { $self\->bar(@args) }
\&  }
.Ve
.Sp
or
.Sp
.Vb 5
\&  sub bar_in_place {
\&    my $self = shift;
\&    my $args = \e@_;
\&    try { $_ = $self\->bar($_) for @$args }
\&  }
.Ve
.IP "\(bu" 4
\&\f(CW\*(C`return\*(C'\fR returns from the \f(CW\*(C`try\*(C'\fR block, not from the parent sub (note that
this is also how \f(CW\*(C`eval\*(C'\fR works, but not how TryCatch works):
.Sp
.Vb 7
\&  sub parent_sub {
\&    try {
\&      die;
\&    }
\&    catch {
\&      return;
\&    };
\&
\&    say "this text WILL be displayed, even though an exception is thrown";
\&  }
.Ve
.Sp
Instead, you should capture the return value:
.Sp
.Vb 6
\&  sub parent_sub {
\&    my $success = try {
\&      die;
\&      1;
\&    };
\&    return unless $success;
\&
\&    say "This text WILL NEVER appear!";
\&  }
\&  # OR
\&  sub parent_sub_with_catch {
\&    my $success = try {
\&      die;
\&      1;
\&    }
\&    catch {
\&      # do something with $_
\&      return undef; #see note
\&    };
\&    return unless $success;
\&
\&    say "This text WILL NEVER appear!";
\&  }
.Ve
.Sp
Note that if you have a \f(CW\*(C`catch\*(C'\fR block, it must return \f(CW\*(C`undef\*(C'\fR for this to work,
since if a \f(CW\*(C`catch\*(C'\fR block exists, its return value is returned in place of \f(CW\*(C`undef\*(C'\fR
when an exception is thrown.
.IP "\(bu" 4
\&\f(CW\*(C`try\*(C'\fR introduces another caller stack frame. Sub::Uplevel is not used. Carp
will not report this when using full stack traces, though, because
\&\f(CW%Carp::Internal\fR is used. This lack of magic is considered a feature.
.IP "\(bu" 4
The value of \f(CW$_\fR in the \f(CW\*(C`catch\*(C'\fR block is not guaranteed to be the value of
the exception thrown (\f(CW$@\fR) in the \f(CW\*(C`try\*(C'\fR block.  There is no safe way to
ensure this, since \f(CW\*(C`eval\*(C'\fR may be used unhygienically in destructors.  The only
guarantee is that the \f(CW\*(C`catch\*(C'\fR will be called if an exception is thrown.
.IP "\(bu" 4
The return value of the \f(CW\*(C`catch\*(C'\fR block is not ignored, so if testing the result
of the expression for truth on success, be sure to return a false value from
the \f(CW\*(C`catch\*(C'\fR block:
.Sp
.Vb 4
\&  my $obj = try {
\&    MightFail\->new;
\&  } catch {
\&    ...
\&
\&    return; # avoid returning a true value;
\&  };
\&
\&  return unless $obj;
.Ve
.IP "\(bu" 4
\&\f(CW$SIG{_\|_DIE_\|_}\fR is still in effect.
.Sp
Though it can be argued that \f(CW$SIG{_\|_DIE_\|_}\fR should be disabled inside of
\&\f(CW\*(C`eval\*(C'\fR blocks, since it isn't people have grown to rely on it. Therefore in
the interests of compatibility, \f(CW\*(C`try\*(C'\fR does not disable \f(CW$SIG{_\|_DIE_\|_}\fR for
the scope of the error throwing code.
.IP "\(bu" 4
Lexical \f(CW$_\fR may override the one set by \f(CW\*(C`catch\*(C'\fR.
.Sp
For example Perl 5.10's \f(CW\*(C`given\*(C'\fR form uses a lexical \f(CW$_\fR, creating some
confusing behavior:
.Sp
.Vb 10
\&  given ($foo) {
\&    when (...) {
\&      try {
\&        ...
\&      } catch {
\&        warn $_; # will print $foo, not the error
\&        warn $_[0]; # instead, get the error like this
\&      }
\&    }
\&  }
.Ve
.Sp
Note that this behavior was changed once again in
Perl5 version 18 <https://metacpan.org/module/perldelta#given-now-aliases-the-global-_>.
However, since the entirety of lexical \f(CW$_\fR is now considered experimental
 <https://metacpan.org/module/perldelta#Lexical-_-is-now-experimental>, it
is unclear whether the new version 18 behavior is final.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.IP "TryCatch" 4
.IX Item "TryCatch"
Much more feature complete, more convenient semantics, but at the cost of
implementation complexity.
.IP "autodie" 4
.IX Item "autodie"
Automatic error throwing for builtin functions and more. Also designed to
work well with \f(CW\*(C`given\*(C'\fR/\f(CW\*(C`when\*(C'\fR.
.IP "Throwable" 4
.IX Item "Throwable"
A lightweight role for rolling your own exception classes.
.IP "Error" 4
.IX Item "Error"
Exception object implementation with a \f(CW\*(C`try\*(C'\fR statement. Does not localize
\&\f(CW$@\fR.
.IP "Exception::Class::TryCatch" 4
.IX Item "Exception::Class::TryCatch"
Provides a \f(CW\*(C`catch\*(C'\fR statement, but properly calling \f(CW\*(C`eval\*(C'\fR is your
responsibility.
.Sp
The \f(CW\*(C`try\*(C'\fR keyword pushes \f(CW$@\fR onto an error stack, avoiding some of the
issues with \f(CW$@\fR, but you still need to localize to prevent clobbering.
.SH "LIGHTNING TALK"
.IX Header "LIGHTNING TALK"
I gave a lightning talk about this module, you can see the slides (Firefox
only):
.PP
<http://web.archive.org/web/20100628040134/http://nothingmuch.woobling.org/talks/takahashi.xul>
.PP
Or read the source:
.PP
<http://web.archive.org/web/20100305133605/http://nothingmuch.woobling.org/talks/yapc_asia_2009/try_tiny.yml>
.SH "SUPPORT"
.IX Header "SUPPORT"
Bugs may be submitted through the \s-1RT\s0 bug tracker <https://rt.cpan.org/Public/Dist/Display.html?Name=Try-Tiny>
(or bug\-Try\-Tiny@rt.cpan.org <mailto:bug-Try-Tiny@rt.cpan.org>).
.SH "AUTHORS"
.IX Header "AUTHORS"
.IP "\(bu" 4
יובל קוג'מן (Yuval Kogman) <nothingmuch@woobling.org>
.IP "\(bu" 4
Jesse Luehrs <doy@tozt.net>
.SH "CONTRIBUTORS"
.IX Header "CONTRIBUTORS"
.IP "\(bu" 4
Karen Etheridge <ether@cpan.org>
.IP "\(bu" 4
Peter Rabbitson <ribasushi@cpan.org>
.IP "\(bu" 4
Ricardo Signes <rjbs@cpan.org>
.IP "\(bu" 4
Mark Fowler <mark@twoshortplanks.com>
.IP "\(bu" 4
Graham Knop <haarg@haarg.org>
.IP "\(bu" 4
Lukas Mai <l.mai@web.de>
.IP "\(bu" 4
Aristotle Pagaltzis <pagaltzis@gmx.de>
.IP "\(bu" 4
Dagfinn Ilmari Mannsåker <ilmari@ilmari.org>
.IP "\(bu" 4
Paul Howarth <paul@city\-fan.org>
.IP "\(bu" 4
Rudolf Leermakers <rudolf@hatsuseno.org>
.IP "\(bu" 4
anaxagoras <walkeraj@gmail.com>
.IP "\(bu" 4
awalker <awalker@sourcefire.com>
.IP "\(bu" 4
chromatic <chromatic@wgz.org>
.IP "\(bu" 4
Alex <alex@koban.(none)>
.IP "\(bu" 4
cm-perl <cm\-perl@users.noreply.github.com>
.IP "\(bu" 4
Andrew Yates <ayates@haddock.local>
.IP "\(bu" 4
David Lowe <davidl@lokku.com>
.IP "\(bu" 4
Glenn Fowler <cebjyre@cpan.org>
.IP "\(bu" 4
Hans Dieter Pearcey <hdp@weftsoar.net>
.IP "\(bu" 4
Jens Berthold <jens@jebecs.de>
.IP "\(bu" 4
Jonathan Yu <JAWNSY@cpan.org>
.IP "\(bu" 4
Marc Mims <marc@questright.com>
.IP "\(bu" 4
Mark Stosberg <mark@stosberg.com>
.IP "\(bu" 4
Pali <pali@cpan.org>
.SH "COPYRIGHT AND LICENCE"
.IX Header "COPYRIGHT AND LICENCE"
This software is Copyright (c) 2009 by יובל קוג'מן (Yuval Kogman).
.PP
This is free software, licensed under:
.PP
.Vb 1
\&  The MIT (X11) License
.Ve
