.\" Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Test::Base 3"
.TH Test::Base 3 "2018-04-19" "perl v5.30.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Test::Base \- A Data Driven Testing Framework
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
A new test module:
.PP
.Vb 3
\&    # lib/MyProject/Test.pm
\&    package MyProject::Test;
\&    use Test::Base \-Base;
\&
\&    use MyProject;
\&
\&    package MyProject::Test::Filter;
\&    use Test::Base::Filter \-base;
\&
\&    sub my_filter {
\&        return MyProject\->do_something(shift);
\&    }
.Ve
.PP
A sample test:
.PP
.Vb 2
\&    # t/sample.t
\&    use MyProject::Test;
\&
\&    plan tests => 1 * blocks;
\&
\&    run_is input => \*(Aqexpected\*(Aq;
\&
\&    sub local_filter {
\&        s/my/your/;
\&    }
\&
\&    _\|_END_\|_
\&
\&    === Test one (the name of the test)
\&    \-\-\- input my_filter local_filter
\&    my
\&    input
\&    lines
\&    \-\-\- expected
\&    expected
\&    output
\&
\&    === Test two
\&    This is an optional description
\&    of this particular test.
\&    \-\-\- input my_filter
\&    other
\&    input
\&    lines
\&    \-\-\- expected
\&    other expected
\&    output
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Testing is usually the ugly part of Perl module authoring. Perl gives you a
standard way to run tests with Test::Harness, and basic testing primitives
with Test::More. After that you are pretty much on your own to develop a
testing framework and philosophy. Test::More encourages you to make your own
framework by subclassing Test::Builder, but that is not trivial.
.PP
Test::Base gives you a way to write your own test framework base class that
\&\fIis\fR trivial. In fact it is as simple as two lines:
.PP
.Vb 2
\&    package MyTestFramework;
\&    use Test::Base \-Base;
.Ve
.PP
A module called \f(CW\*(C`MyTestFramework.pm\*(C'\fR containing those two lines, will give
all the power of Test::More and all the power of Test::Base to every test file
that uses it. As you build up the capabilities of \f(CW\*(C`MyTestFramework\*(C'\fR, your
tests will have all of that power as well.
.PP
\&\f(CW\*(C`MyTestFramework\*(C'\fR becomes a place for you to put all of your reusable testing
bits. As you write tests, you will see patterns and duplication, and you can
\&\*(L"upstream\*(R" them into \f(CW\*(C`MyTestFramework\*(C'\fR. Of course, you don't have to subclass
Test::Base at all. You can use it directly in many applications, including
everywhere you would use Test::More.
.PP
Test::Base concentrates on offering reusable data driven patterns, so that you
can write tests with a minimum of code. At the heart of all testing you have
inputs, processes and expected outputs. Test::Base provides some clean ways
for you to express your input and expected output data, so you can spend your
.PP
.Vb 1
\&      time focusing on that rather than your code scaffolding.
.Ve
.SH "EXPORTED FUNCTIONS"
.IX Header "EXPORTED FUNCTIONS"
Test::Base extends Test::More and exports all of its functions. So you can
basically write your tests the same as Test::More. Test::Base also exports
many functions of its own:
.ie n .IP """is(actual, expected, [test\-name])""" 4
.el .IP "\f(CWis(actual, expected, [test\-name])\fR" 4
.IX Item "is(actual, expected, [test-name])"
This is the equivalent of Test::More's \f(CW\*(C`is\*(C'\fR function with one interesting
twist. If your actual and expected results differ and the output is multi\-
line, this function will show you a unified diff format of output. Consider
the benefit when looking for the one character that is different in hundreds
of lines of output!
.Sp
Diff output requires the optional \f(CW\*(C`Text::Diff\*(C'\fR \s-1CPAN\s0 module. If you don't have
this module, the \f(CW\*(C`is()\*(C'\fR function will simply give you normal Test::More
output. To disable diffing altogether, set the \f(CW\*(C`TEST_SHOW_NO_DIFFS\*(C'\fR
environment variable (or \f(CW$ENV{TEST_SHOW_NO_DIFFS}\fR) to a true value. You can
also call the \f(CW\*(C`no_diff\*(C'\fR function as a shortcut.
.ie n .IP """blocks( [data\-section\-name] )""" 4
.el .IP "\f(CWblocks( [data\-section\-name] )\fR" 4
.IX Item "blocks( [data-section-name] )"
The most important function is \f(CW\*(C`blocks\*(C'\fR. In list context it returns a list of
\&\f(CW\*(C`Test::Base::Block\*(C'\fR objects that are generated from the test specification in
the \f(CW\*(C`DATA\*(C'\fR section of your test file. In scalar context it returns the number
of objects. This is useful to calculate your Test::More plan.
.Sp
Each Test::Base::Block object has methods that correspond to the names of that
object's data sections. There is also a \f(CW\*(C`name\*(C'\fR and a \f(CW\*(C`description\*(C'\fR method
for accessing those parts of the block if they were specified.
.Sp
The \f(CW\*(C`blocks\*(C'\fR function can take an optional single argument, that indicates to
only return the blocks that contain a particular named data section. Otherwise
\&\f(CW\*(C`blocks\*(C'\fR returns all blocks.
.Sp
.Vb 1
\&    my @all_of_my_blocks = blocks;
\&
\&    my @just_the_foo_blocks = blocks(\*(Aqfoo\*(Aq);
.Ve
.ie n .IP """next_block()""" 4
.el .IP "\f(CWnext_block()\fR" 4
.IX Item "next_block()"
You can use the next_block function to iterate over all the blocks.
.Sp
.Vb 3
\&    while (my $block = next_block) {
\&        ...
\&    }
.Ve
.Sp
It returns undef after all blocks have been iterated over. It can then be
called again to reiterate.
.ie n .IP """first_block()""" 4
.el .IP "\f(CWfirst_block()\fR" 4
.IX Item "first_block()"
Returns the first block or undef if there are none. It resets the iterator to
the \f(CW\*(C`next_block\*(C'\fR function.
.ie n .IP """run(&subroutine)""" 4
.el .IP "\f(CWrun(&subroutine)\fR" 4
.IX Item "run(&subroutine)"
There are many ways to write your tests. You can reference each block
individually or you can loop over all the blocks and perform a common
operation. The \f(CW\*(C`run\*(C'\fR function does the looping for you, so all you need to do
is pass it a code block to execute for each block.
.Sp
The \f(CW\*(C`run\*(C'\fR function takes a subroutine as an argument, and calls the sub one
time for each block in the specification. It passes the current block object
to the subroutine.
.Sp
.Vb 4
\&    run {
\&        my $block = shift;
\&        is(process($block\->foo), $block\->bar, $block\->name);
\&    };
.Ve
.ie n .IP """run_is([data_name1, data_name2])""" 4
.el .IP "\f(CWrun_is([data_name1, data_name2])\fR" 4
.IX Item "run_is([data_name1, data_name2])"
Many times you simply want to see if two data sections are equivalent in
every block, probably after having been run through one or more filters. With
the \f(CW\*(C`run_is\*(C'\fR function, you can just pass the names of any two data sections
that exist in every block, and it will loop over every block comparing the
two sections.
.Sp
.Vb 1
\&    run_is \*(Aqfoo\*(Aq, \*(Aqbar\*(Aq;
.Ve
.Sp
If no data sections are given \f(CW\*(C`run_is\*(C'\fR will try to detect them automatically.
.Sp
\&\s-1NOTE:\s0 Test::Base will silently ignore any blocks that don't contain
      both sections.
.ie n .IP """is_deep($data1, $data2, $test_name)""" 4
.el .IP "\f(CWis_deep($data1, $data2, $test_name)\fR" 4
.IX Item "is_deep($data1, $data2, $test_name)"
Like Test::More's \f(CW\*(C`is_deeply\*(C'\fR but uses the more correct Test::Deep module.
.ie n .IP """run_is_deeply([data_name1, data_name2])""" 4
.el .IP "\f(CWrun_is_deeply([data_name1, data_name2])\fR" 4
.IX Item "run_is_deeply([data_name1, data_name2])"
Like \f(CW\*(C`run_is_deeply\*(C'\fR but uses \f(CW\*(C`is_deep\*(C'\fR which uses the more correct
Test::Deep.
.ie n .IP """run_is_deeply([data_name1, data_name2])""" 4
.el .IP "\f(CWrun_is_deeply([data_name1, data_name2])\fR" 4
.IX Item "run_is_deeply([data_name1, data_name2])"
Like \f(CW\*(C`run_is\*(C'\fR but uses \f(CW\*(C`is_deeply\*(C'\fR for complex data structure comparison.
.ie n .IP """run_is_deeply([data_name1, data_name2])""" 4
.el .IP "\f(CWrun_is_deeply([data_name1, data_name2])\fR" 4
.IX Item "run_is_deeply([data_name1, data_name2])"
Like \f(CW\*(C`run_is_deeply\*(C'\fR but uses \f(CW\*(C`is_deep\*(C'\fR which uses the more correct
Test::Deep.
.ie n .IP """run_like([data_name, regexp | data_name]);""" 4
.el .IP "\f(CWrun_like([data_name, regexp | data_name]);\fR" 4
.IX Item "run_like([data_name, regexp | data_name]);"
The \f(CW\*(C`run_like\*(C'\fR function is similar to \f(CW\*(C`run_is\*(C'\fR except the second argument is
a regular expression. The regexp can either be a \f(CW\*(C`qr{}\*(C'\fR object or a data
section that has been filtered into a regular expression.
.Sp
.Vb 2
\&    run_like \*(Aqfoo\*(Aq, qr{<html.*};
\&    run_like \*(Aqfoo\*(Aq, \*(Aqmatch\*(Aq;
.Ve
.ie n .IP """run_unlike([data_name, regexp | data_name]);""" 4
.el .IP "\f(CWrun_unlike([data_name, regexp | data_name]);\fR" 4
.IX Item "run_unlike([data_name, regexp | data_name]);"
The \f(CW\*(C`run_unlike\*(C'\fR function is similar to \f(CW\*(C`run_like\*(C'\fR, except the opposite.
.Sp
.Vb 2
\&    run_unlike \*(Aqfoo\*(Aq, qr{<html.*};
\&    run_unlike \*(Aqfoo\*(Aq, \*(Aqno_match\*(Aq;
.Ve
.ie n .IP """run_compare(data_name1, data_name2)""" 4
.el .IP "\f(CWrun_compare(data_name1, data_name2)\fR" 4
.IX Item "run_compare(data_name1, data_name2)"
The \f(CW\*(C`run_compare\*(C'\fR function is like the \f(CW\*(C`run_is\*(C'\fR, \f(CW\*(C`run_is_deeply\*(C'\fR and the
\&\f(CW\*(C`run_like\*(C'\fR functions all rolled into one. It loops over each relevant block
and determines what type of comparison to do.
.Sp
\&\s-1NOTE:\s0 If you do not specify either a plan, or run any tests, the
      \f(CW\*(C`run_compare\*(C'\fR function will automatically be run.
.ie n .IP """delimiters($block_delimiter, $data_delimiter)""" 4
.el .IP "\f(CWdelimiters($block_delimiter, $data_delimiter)\fR" 4
.IX Item "delimiters($block_delimiter, $data_delimiter)"
Override the default delimiters of \f(CW\*(C`===\*(C'\fR and \f(CW\*(C`\-\-\-\*(C'\fR.
.ie n .IP """spec_file($file_name)""" 4
.el .IP "\f(CWspec_file($file_name)\fR" 4
.IX Item "spec_file($file_name)"
By default, Test::Base reads its input from the \s-1DATA\s0 section. This function
tells it to get the spec from a file instead.
.ie n .IP """spec_string($test_data)""" 4
.el .IP "\f(CWspec_string($test_data)\fR" 4
.IX Item "spec_string($test_data)"
By default, Test::Base reads its input from the \s-1DATA\s0 section. This function
tells it to get the spec from a string that has been prepared somehow.
.ie n .IP """filters( @filters_list or $filters_hashref )""" 4
.el .IP "\f(CWfilters( @filters_list or $filters_hashref )\fR" 4
.IX Item "filters( @filters_list or $filters_hashref )"
Specify a list of additional filters to be applied to all blocks. See
\&\f(CW\*(C`FILTERS\*(C'\fR below.
.Sp
You can also specify a hash ref that maps data section names to an array ref
of filters for that data type.
.Sp
.Vb 5
\&    filters {
\&        xxx => [qw(chomp lines)],
\&        yyy => [\*(Aqyaml\*(Aq],
\&        zzz => \*(Aqeval\*(Aq,
\&    };
.Ve
.Sp
If a filters list has only one element, the array ref is optional.
.ie n .IP """filters_delay( [1 | 0] );""" 4
.el .IP "\f(CWfilters_delay( [1 | 0] );\fR" 4
.IX Item "filters_delay( [1 | 0] );"
By default Test::Base::Block objects are have all their filters run ahead of
time. There are testing situations in which it is advantageous to delay the
filtering. Calling this function with no arguments or a true value, causes the
filtering to be delayed.
.Sp
.Vb 9
\&    use Test::Base;
\&    filters_delay;
\&    plan tests => 1 * blocks;
\&    for my $block (blocks) {
\&        ...
\&        $block\->run_filters;
\&        ok($block\->is_filtered);
\&        ...
\&    }
.Ve
.Sp
In the code above, the filters are called manually, using the \f(CW\*(C`run_filters\*(C'\fR
method of Test::Base::Block. In functions like \f(CW\*(C`run_is\*(C'\fR, where the tests are
run automatically, filtering is delayed until right before the test.
.ie n .IP """filter_arguments()""" 4
.el .IP "\f(CWfilter_arguments()\fR" 4
.IX Item "filter_arguments()"
Return the arguments after the equals sign on a filter.
.Sp
.Vb 5
\&    sub my_filter {
\&        my $args = filter_arguments;
\&        # is($args, \*(Aqwhazzup\*(Aq);
\&        ...
\&    }
\&
\&    _\|_DATA_\|_
\&    === A test
\&    \-\-\- data my_filter=whazzup
.Ve
.ie n .IP """tie_output()""" 4
.el .IP "\f(CWtie_output()\fR" 4
.IX Item "tie_output()"
You can capture \s-1STDOUT\s0 and \s-1STDERR\s0 for operations with this function:
.Sp
.Vb 6
\&    my $out = \*(Aq\*(Aq;
\&    tie_output(*STDOUT, $out);
\&    print "Hey!\en";
\&    print "Che!\en";
\&    untie *STDOUT;
\&    is($out, "Hey!\enChe!\en");
.Ve
.ie n .IP """no_diff()""" 4
.el .IP "\f(CWno_diff()\fR" 4
.IX Item "no_diff()"
Turn off diff support for \fBis()\fR in a test file.
.ie n .IP """default_object()""" 4
.el .IP "\f(CWdefault_object()\fR" 4
.IX Item "default_object()"
Returns the default Test::Base object. This is useful if you feel the need to
do an \s-1OO\s0 operation in otherwise functional test code. See \s-1OO\s0 below.
.ie n .IP """WWW() XXX() YYY() ZZZ()""" 4
.el .IP "\f(CWWWW() XXX() YYY() ZZZ()\fR" 4
.IX Item "WWW() XXX() YYY() ZZZ()"
These debugging functions are exported from the Spiffy.pm module. See
Spiffy for more info.
.ie n .IP """croak() carp() cluck() confess()""" 4
.el .IP "\f(CWcroak() carp() cluck() confess()\fR" 4
.IX Item "croak() carp() cluck() confess()"
You can use the functions from the Carp module without needing to import them.
Test::Base does it for you by default.
.SH "TEST SPECIFICATION"
.IX Header "TEST SPECIFICATION"
Test::Base allows you to specify your test data in an external file, the
\&\s-1DATA\s0 section of your program or from a scalar variable containing all the
text input.
.PP
A \fItest specification\fR is a series of text lines. Each test (or block) is
separated by a line containing the block delimiter and an optional test
\&\f(CW\*(C`name\*(C'\fR. Each block is further subdivided into named sections with a line
containing the data delimiter and the data section name. A \f(CW\*(C`description\*(C'\fR
of the test can go on lines after the block delimiter but before the first
data section.
.PP
Here is the basic layout of a specification:
.PP
.Vb 8
\&    === <block name 1>
\&    <optional block description lines>
\&    \-\-\- <data section name 1> <filter\-1> <filter\-2> <filter\-n>
\&    <test data lines>
\&    \-\-\- <data section name 2> <filter\-1> <filter\-2> <filter\-n>
\&    <test data lines>
\&    \-\-\- <data section name n> <filter\-1> <filter\-2> <filter\-n>
\&    <test data lines>
\&
\&    === <block name 2>
\&    <optional block description lines>
\&    \-\-\- <data section name 1> <filter\-1> <filter\-2> <filter\-n>
\&    <test data lines>
\&    \-\-\- <data section name 2> <filter\-1> <filter\-2> <filter\-n>
\&    <test data lines>
\&    \-\-\- <data section name n> <filter\-1> <filter\-2> <filter\-n>
\&    <test data lines>
.Ve
.PP
Here is a code example:
.PP
.Vb 1
\&    use Test::Base;
\&
\&    delimiters qw(### :::);
\&
\&    # test code here
\&
\&    _\|_END_\|_
\&
\&    ### Test One
\&    We want to see if foo and bar
\&    are really the same...
\&    ::: foo
\&    a foo line
\&    another foo line
\&
\&    ::: bar
\&    a bar line
\&    another bar line
\&
\&    ### Test Two
\&
\&    ::: foo
\&    some foo line
\&    some other foo line
\&
\&    ::: bar
\&    some bar line
\&    some other bar line
\&
\&    ::: baz
\&    some baz line
\&    some other baz line
.Ve
.PP
This example specifies two blocks. They both have foo and bar data sections.
The second block has a baz component. The block delimiter is \f(CW\*(C`###\*(C'\fR and the
data delimiter is \f(CW\*(C`:::\*(C'\fR.
.PP
The default block delimiter is \f(CW\*(C`===\*(C'\fR and the default data delimiter is \f(CW\*(C`\-\-\-
\&\*(C'\fR.
.PP
There are some special data section names used for control purposes:
.PP
.Vb 3
\&    \-\-\- SKIP
\&    \-\-\- ONLY
\&    \-\-\- LAST
.Ve
.PP
A block with a \s-1SKIP\s0 section causes that test to be ignored. This is useful to
disable a test temporarily.
.PP
A block with an \s-1ONLY\s0 section causes only that block to be used. This is useful
when you are concentrating on getting a single test to pass. If there is more
than one block with \s-1ONLY,\s0 the first one will be chosen.
.PP
Because \s-1ONLY\s0 is very useful for debugging and sometimes you forgot to remove
the \s-1ONLY\s0 flag before committing to the \s-1VCS\s0 or uploading to \s-1CPAN,\s0 Test::Base by
default gives you a diag message saying \fII found \s-1ONLY ...\s0 maybe you're
debugging?\fR. If you don't like it, use \f(CW\*(C`no_diag_on_only\*(C'\fR.
.PP
A block with a \s-1LAST\s0 section makes that block the last one in the
specification. All following blocks will be ignored.
.SH "FILTERS"
.IX Header "FILTERS"
The real power in writing tests with Test::Base comes from its filtering
capabilities. Test::Base comes with an ever growing set of useful generic
filters than you can sequence and apply to various test blocks. That means you
can specify the block serialization in the most readable format you can find,
and let the filters translate it into what you really need for a test. It is
easy to write your own filters as well.
.PP
Test::Base allows you to specify a list of filters to each data section of
each block. The default filters are \f(CW\*(C`norm\*(C'\fR and \f(CW\*(C`trim\*(C'\fR. These filters will be
applied (in order) to the data after it has been parsed from the specification
and before it is set into its Test::Base::Block object.
.PP
You can add to the default filter list with the \f(CW\*(C`filters\*(C'\fR function. You can
specify additional filters to a specific block by listing them after the
section name on a data section delimiter line.
.PP
Example:
.PP
.Vb 1
\&    use Test::Base;
\&
\&    filters qw(foo bar);
\&    filters { perl => \*(Aqstrict\*(Aq };
\&
\&    sub upper { uc(shift) }
\&
\&    _\|_END_\|_
\&
\&    === Test one
\&    \-\-\- foo trim chomp upper
\&    ...
\&
\&    \-\-\- bar \-norm
\&    ...
\&
\&    \-\-\- perl eval dumper
\&    my @foo = map {
\&        \- $_;
\&    } 1..10;
\&    \e @foo;
.Ve
.PP
Putting a \f(CW\*(C`\-\*(C'\fR before a filter on a delimiter line, disables that filter.
.SS "Scalar vs List"
.IX Subsection "Scalar vs List"
Each filter can take either a scalar or a list as input, and will return
either a scalar or a list. Since filters are chained together, it is
important to learn which filters expect which kind of input and return which
kind of output.
.PP
For example, consider the following filter list:
.PP
.Vb 1
\&    norm trim lines chomp array dumper eval
.Ve
.PP
The data always starts out as a single scalar string. \f(CW\*(C`norm\*(C'\fR takes a scalar
and returns a scalar. \f(CW\*(C`trim\*(C'\fR takes a list and returns a list, but a scalar is
a valid list. \f(CW\*(C`lines\*(C'\fR takes a scalar and returns a list. \f(CW\*(C`chomp\*(C'\fR takes a
list and returns a list. \f(CW\*(C`array\*(C'\fR takes a list and returns a scalar (an
anonymous array reference containing the list elements). \f(CW\*(C`dumper\*(C'\fR takes a
list and returns a scalar. \f(CW\*(C`eval\*(C'\fR takes a scalar and creates a list.
.PP
A list of exactly one element works fine as input to a filter requiring a
scalar, but any other list will cause an exception. A scalar in list context
is considered a list of one element.
.PP
Data accessor methods for blocks will return a list of values when used in
list context, and the first element of the list in scalar context. This is
usually \*(L"the right thing\*(R", but be aware.
.SS "The Stock Filters"
.IX Subsection "The Stock Filters"
Test::Base comes with large set of stock filters. They are in the
\&\f(CW\*(C`Test::Base::Filter\*(C'\fR module. See Test::Base::Filter for a listing and
description of these filters.
.SS "Rolling Your Own Filters"
.IX Subsection "Rolling Your Own Filters"
Creating filter extensions is very simple. You can either write a \fIfunction\fR
in the \f(CW\*(C`main\*(C'\fR namespace, or a \fImethod\fR in the \f(CW\*(C`Test::Base::Filter\*(C'\fR
namespace or a subclass of it. In either case the text and any extra arguments
are passed in and you return whatever you want the new value to be.
.PP
Here is a self explanatory example:
.PP
.Vb 1
\&    use Test::Base;
\&
\&    filters \*(Aqfoo\*(Aq, \*(Aqbar=xyz\*(Aq;
\&
\&    sub foo {
\&        transform(shift);
\&    }
\&
\&    sub Test::Base::Filter::bar {
\&        my $self = shift;       # The Test::Base::Filter object
\&        my $data = shift;
\&        my $args = $self\->current_arguments;
\&        my $current_block_object = $self\->block;
\&        # transform $data in a barish manner
\&        return $data;
\&    }
.Ve
.PP
If you use the method interface for a filter, you can access the block
internals by calling the \f(CW\*(C`block\*(C'\fR method on the filter object.
.PP
Normally you'll probably just use the functional interface, although all the
builtin filters are methods.
.PP
Note that filters defined in the \f(CW\*(C`main\*(C'\fR namespace can look like:
.PP
.Vb 3
\&    sub filter9 {
\&        s/foo/bar/;
\&    }
.Ve
.PP
since Test::Base automatically munges the input string into \f(CW$_\fR variable and
checks the return value of the function to see if it looks like a number.
If you must define a filter that returns just a single number, do it in a
different namespace as a method. These filters don't allow the simplistic
\&\f(CW$_\fR munging.
.SH "OO"
.IX Header "OO"
Test::Base has a nice functional interface for simple usage. Under the hood
everything is object oriented. A default Test::Base object is created and all
the functions are really just method calls on it.
.PP
This means if you need to get fancy, you can use all the object oriented stuff
too. Just create new Test::Base objects and use the functions as methods.
.PP
.Vb 3
\&    use Test::Base;
\&    my $blocks1 = Test::Base\->new;
\&    my $blocks2 = Test::Base\->new;
\&
\&    $blocks1\->delimiters(qw(!!! @@@))\->spec_file(\*(Aqtest1.txt\*(Aq);
\&    $blocks2\->delimiters(qw(### $$$))\->spec_string($test_data);
\&
\&    plan tests => $blocks1\->blocks + $blocks2\->blocks;
\&
\&    # ... etc
.Ve
.ie n .SH "THE ""TEST::BASE::BLOCK"" CLASS"
.el .SH "THE \f(CWTEST::BASE::BLOCK\fP CLASS"
.IX Header "THE TEST::BASE::BLOCK CLASS"
In Test::Base, blocks are exposed as Test::Base::Block objects. This section
lists the methods that can be called on a Test::Base::Block object. Of course,
each data section name is also available as a method.
.ie n .IP """name()""" 4
.el .IP "\f(CWname()\fR" 4
.IX Item "name()"
This is the optional short description of a block, that is specified on the
block separator line.
.ie n .IP """description()""" 4
.el .IP "\f(CWdescription()\fR" 4
.IX Item "description()"
This is an optional long description of the block. It is the text taken from
between the block separator and the first data section.
.ie n .IP """seq_num()""" 4
.el .IP "\f(CWseq_num()\fR" 4
.IX Item "seq_num()"
Returns a sequence number for this block. Sequence numbers begin with 1.
.ie n .IP """blocks_object()""" 4
.el .IP "\f(CWblocks_object()\fR" 4
.IX Item "blocks_object()"
Returns the Test::Base object that owns this block.
.ie n .IP """run_filters()""" 4
.el .IP "\f(CWrun_filters()\fR" 4
.IX Item "run_filters()"
Run the filters on the data sections of the blocks. You don't need to use this
method unless you also used the \f(CW\*(C`filters_delay\*(C'\fR function.
.ie n .IP """is_filtered()""" 4
.el .IP "\f(CWis_filtered()\fR" 4
.IX Item "is_filtered()"
Returns true if filters have already been run for this block.
.ie n .IP """original_values()""" 4
.el .IP "\f(CWoriginal_values()\fR" 4
.IX Item "original_values()"
Returns a hash of the original, unfiltered values of each data section.
.SH "SUBCLASSING"
.IX Header "SUBCLASSING"
One of the nicest things about Test::Base is that it is easy to subclass. This
is very important, because in your personal project, you will likely want to
extend Test::Base with your own filters and other reusable pieces of your test
framework.
.PP
Here is an example of a subclass:
.PP
.Vb 2
\&    package MyTestStuff;
\&    use Test::Base \-Base;
\&
\&    our @EXPORT = qw(some_func);
\&
\&    sub some_func {
\&        (my ($self), @_) = find_my_self(@_);
\&        ...
\&    }
\&
\&    package MyTestStuff::Block;
\&    use base \*(AqTest::Base::Block\*(Aq;
\&
\&    sub desc {
\&        $self\->description(@_);
\&    }
\&
\&    package MyTestStuff::Filter;
\&    use base \*(AqTest::Base::Filter\*(Aq;
\&
\&    sub upper {
\&        $self\->assert_scalar(@_);
\&        uc(shift);
\&    }
.Ve
.PP
Note that you don't have to re-Export all the functions from Test::Base. That
happens automatically, due to the powers of Spiffy.
.PP
The first line in \f(CW\*(C`some_func\*(C'\fR allows it to be called as either a function or
a method in the test code.
.SH "DISTRIBUTION SUPPORT"
.IX Header "DISTRIBUTION SUPPORT"
You might be thinking that you do not want to use Test::Base in you modules,
because it adds an installation dependency. Fear not.
Module::Install::TestBase takes care of that.
.PP
Just write a Makefile.PL that looks something like this:
.PP
.Vb 1
\&    use inc::Module::Install;
\&
\&    name            \*(AqFoo\*(Aq;
\&    all_from        \*(Aqlib/Foo.pm\*(Aq;
\&
\&    use_test_base;
\&
\&    WriteAll;
.Ve
.PP
The line with \f(CW\*(C`use_test_base\*(C'\fR will automatically bundle all the code the user
needs to run Test::Base based tests.
.SH "OTHER COOL FEATURES"
.IX Header "OTHER COOL FEATURES"
Test::Base automatically adds:
.PP
.Vb 2
\&    use strict;
\&    use warnings;
.Ve
.PP
to all of your test scripts and Test::Base subclasses. A Spiffy feature
indeed.
.SH "HISTORY"
.IX Header "HISTORY"
This module started its life with the horrible and ridicule inducing name
\&\f(CW\*(C`Test::Chunks\*(C'\fR. It was renamed to \f(CW\*(C`Test::Base\*(C'\fR with the hope that it would
be seen for the very useful module that it has become. If you are switching
from \f(CW\*(C`Test::Chunks\*(C'\fR to \f(CW\*(C`Test::Base\*(C'\fR, simply substitute the concept and usage
of \f(CW\*(C`chunks\*(C'\fR to \f(CW\*(C`blocks\*(C'\fR.
.SH "AUTHOR"
.IX Header "AUTHOR"
Ingy döt Net <ingy@cpan.org>
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright 2005\-2018. Ingy döt Net.
.PP
This program is free software; you can redistribute it and/or modify it under
the same terms as Perl itself.
.PP
See <http://www.perl.com/perl/misc/Artistic.html>
