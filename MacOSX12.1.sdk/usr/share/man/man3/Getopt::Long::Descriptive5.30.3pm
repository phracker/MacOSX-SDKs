.\" Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Getopt::Long::Descriptive 3"
.TH Getopt::Long::Descriptive 3 "2020-02-25" "perl v5.30.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Getopt::Long::Descriptive \- Getopt::Long, but simpler and more powerful
.SH "VERSION"
.IX Header "VERSION"
version 0.105
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use Getopt::Long::Descriptive;
\&
\&  my ($opt, $usage) = describe_options(
\&    \*(Aqmy\-program %o <some\-arg>\*(Aq,
\&    [ \*(Aqserver|s=s\*(Aq, "the server to connect to", { required => 1  } ],
\&    [ \*(Aqport|p=i\*(Aq,   "the port to connect to",   { default  => 79 } ],
\&    [],
\&    [ \*(Aqverbose|v\*(Aq,  "print extra stuff"            ],
\&    [ \*(Aqhelp\*(Aq,       "print usage message and exit", { shortcircuit => 1 } ],
\&  );
\&
\&  print($usage\->text), exit if $opt\->help;
\&
\&  Client\->connect( $opt\->server, $opt\->port );
\&
\&  print "Connected!\en" if $opt\->verbose;
.Ve
.PP
\&...and running \f(CW\*(C`my\-program \-\-help\*(C'\fR will produce:
.PP
.Vb 3
\&  my\-program [\-psv] [long options...] <some\-arg>
\&    \-s \-\-server     the server to connect to
\&    \-p \-\-port       the port to connect to
\&
\&    \-v \-\-verbose    print extra stuff
\&    \-\-help          print usage message and exit
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Getopt::Long::Descriptive is yet another Getopt library.  It's built atop
Getopt::Long, and gets a lot of its features, but tries to avoid making you
think about its huge array of options.
.PP
It also provides usage (help) messages, data validation, and a few other useful
features.
.SH "FUNCTIONS"
.IX Header "FUNCTIONS"
Getopt::Long::Descriptive only exports one routine by default:
\&\f(CW\*(C`describe_options\*(C'\fR.  All \s-1GLD\s0's exports are exported by Sub::Exporter.
.SS "describe_options"
.IX Subsection "describe_options"
.Vb 1
\&  my ($opt, $usage) = describe_options($usage_desc, @opt_spec, \e%arg);
.Ve
.PP
This routine inspects \f(CW@ARGV\fR for options that match the supplied spec. If all
the options are valid then it returns the options given and an object for
generating usage messages; if not then it dies with an explanation of what was
wrong and a usage message.
.PP
The \f(CW$opt\fR object will be a dynamically-generated subclass of
Getopt::Long::Descriptive::Opts.  In brief, each of the options in
\&\f(CW@opt_spec\fR becomes an accessor method on the object, using the first-given
name, with dashes converted to underscores.  For more information, see the
documentation for the Opts class.
.PP
The \f(CW$usage\fR object will be a Getopt::Long::Descriptive::Usage object,
which provides a \f(CW\*(C`text\*(C'\fR method to get the text of the usage message and \f(CW\*(C`die\*(C'\fR
to die with it.  For more methods and options, consults the documentation for
the Usage class.
.PP
\fI\f(CI$usage_desc\fI\fR
.IX Subsection "$usage_desc"
.PP
The \f(CW$usage_desc\fR parameter to \f(CW\*(C`describe_options\*(C'\fR is a \f(CW\*(C`sprintf\*(C'\fR\-like string
that is used in generating the first line of the usage message.  It's a
one-line summary of how the command is to be invoked.  A typical usage
description might be:
.PP
.Vb 1
\&  $usage_desc = "%c %o <source> <desc>";
.Ve
.PP
\&\f(CW%c\fR will be replaced with what Getopt::Long::Descriptive thinks is the
program name (it's computed from \f(CW$0\fR, see \*(L"prog_name\*(R").
.PP
\&\f(CW%o\fR will be replaced with a list of the short options, as well as the text
\&\*(L"[long options...]\*(R" if any have been defined.
.PP
The rest of the usage description can be used to summarize what arguments are
expected to follow the program's options, and is entirely free-form.
.PP
Literal \f(CW\*(C`%\*(C'\fR characters will need to be written as \f(CW\*(C`%%\*(C'\fR, just like with
\&\f(CW\*(C`sprintf\*(C'\fR.
.PP
\fI\f(CI@opt_spec\fI\fR
.IX Subsection "@opt_spec"
.PP
The \f(CW@opt_spec\fR part of the args to \f(CW\*(C`describe_options\*(C'\fR is used to configure
option parsing and to produce the usage message.  Each entry in the list is an
arrayref describing one option, like this:
.PP
.Vb 4
\&  @opt_spec = (
\&    [ "verbose|V" => "be noisy"       ],
\&    [ "logfile=s" => "file to log to" ],
\&  );
.Ve
.PP
The first value in the arrayref is a Getopt::Long\-style option specification.
In brief, they work like this:  each one is a pipe-delimited list of names,
optionally followed by a type declaration.  Type declarations are '=x' or ':x',
where \f(CW\*(C`=\*(C'\fR means a value is required and \f(CW\*(C`:\*(C'\fR means it is optional.  \fIx\fR may
be 's' to indicate a string is required, 'i' for an integer, or 'f' for a
number with a fractional part.  The type spec may end in \f(CW\*(C`@\*(C'\fR to indicate that
the option may appear multiple times.
.PP
For more information on how these work, see the Getopt::Long documentation.
.PP
The first name given should be the canonical name, as it will be used as the
accessor method on the \f(CW$opt\fR object.  Dashes in the name will be converted to
underscores, and all letters will be lowercased.  For this reason, all options
should generally have a long-form name.
.PP
The second value in the arrayref is a description of the option, for use in the
usage message.
.PP
Special Option Specifications
.IX Subsection "Special Option Specifications"
.PP
If the option specification (arrayref) is empty, it will have no effect other
than causing a blank line to appear in the usage message.
.PP
If the option specification contains only one element, it will be printed in
the usage message with no other effect.  If the element is a reference, its
referent will be printed as-is.  Otherwise, it will be reformatted like other
text in the usage message.
.PP
If the option specification contains a third element, it adds extra constraints
or modifiers to the interpretation and validation of the value.  These are the
keys that may be present in that hashref, and how they behave:
.IP "implies" 4
.IX Item "implies"
.Vb 3
\&  implies => \*(Aqbar\*(Aq
\&  implies => [qw(foo bar)]
\&  implies => { foo => 1, bar => 2 }
.Ve
.Sp
If option \fIA\fR has an \*(L"implies\*(R" entry, then if \fIA\fR is given, other options
will be enabled.  The value may be a single option to set, an arrayref of
options to set, or a hashref of options to set to specific values.
.IP "required" 4
.IX Item "required"
.Vb 1
\&  required => 1
.Ve
.Sp
If an option is required, failure to provide the option will result in
\&\f(CW\*(C`describe_options\*(C'\fR printing the usage message and exiting.
.IP "hidden" 4
.IX Item "hidden"
.Vb 1
\&  hidden => 1
.Ve
.Sp
This option will not show up in the usage text.
.Sp
You can achieve the same behavior by using the string \*(L"hidden\*(R" for the option's
description.
.IP "one_of" 4
.IX Item "one_of"
.Vb 1
\&  one_of => \e@subopt_specs
.Ve
.Sp
This is useful for a group of options that are related.  Each option
spec is added to the list for normal parsing and validation.
.Sp
Your option name will end up with a value of the name of the
option that was chosen.  For example, given the following spec:
.Sp
.Vb 5
\&  [ "mode" => hidden => { one_of => [
\&    [ "get|g"  => "get the value" ],
\&    [ "set|s"  => "set the value" ],
\&    [ "delete" => "delete it" ],
\&  ] } ],
.Ve
.Sp
No usage text for 'mode' will be displayed, but text for get, set, and delete
will be displayed.
.Sp
If more than one of get, set, or delete is given, an error will be thrown.
.Sp
So, given the \f(CW@opt_spec\fR above, and an \f(CW@ARGV\fR of \f(CW\*(C`(\*(Aq\-\-get\*(Aq)\*(C'\fR, the
following would be true:
.Sp
.Vb 1
\&  $opt\->get == 1;
\&
\&  $opt\->mode eq \*(Aqget\*(Aq;
.Ve
.Sp
\&\fBNote\fR: \f(CW\*(C`get\*(C'\fR would not be set if \f(CW\*(C`mode\*(C'\fR defaulted to 'get' and no arguments
were passed in.
.Sp
Even though the option sub-specs for \f(CW\*(C`one_of\*(C'\fR are meant to be 'first
class' specs, some options don't make sense with them, e.g. \f(CW\*(C`required\*(C'\fR.
.Sp
As a further shorthand, you may specify \f(CW\*(C`one_of\*(C'\fR options using this form:
.Sp
.Vb 1
\&  [ mode => \e@option_specs, \e%constraints ]
.Ve
.IP "shortcircuit" 4
.IX Item "shortcircuit"
.Vb 1
\&  shortcircuit => 1
.Ve
.Sp
If this option is present no other options will be returned.  Other
options present will be checked for proper types, but \fInot\fR for
constraints.  This provides a way of specifying \f(CW\*(C`\-\-help\*(C'\fR style options.
.IP "Params::Validate" 4
.IX Item "Params::Validate"
In addition, any constraint understood by Params::Validate may be used.
.Sp
For example, to accept positive integers:
.Sp
.Vb 2
\&  [ \*(Aqmax\-iterations=i\*(Aq, "maximum number of iterations",
\&    { callbacks => { positive => sub { shift() > 0 } } } ],
.Ve
.Sp
(Internally, all constraints are translated into Params::Validate options or
callbacks.)
.PP
\fI\f(CI%arg\fI\fR
.IX Subsection "%arg"
.PP
The \f(CW%arg\fR to \f(CW\*(C`describe_options\*(C'\fR is optional.  If the last parameter is a
hashref, it contains extra arguments to modify the way \f(CW\*(C`describe_options\*(C'\fR
works.  Valid arguments are:
.PP
.Vb 4
\&  getopt_conf   \- an arrayref of strings, passed to Getopt::Long::Configure
\&  show_defaults \- a boolean which controls whether an option\*(Aqs default
\&                  value (if applicable) is shown as part of the usage message
\&                  (for backward compatibility this defaults to false)
.Ve
.SS "prog_name"
.IX Subsection "prog_name"
This routine, exported on demand, returns the basename of \f(CW$0\fR, grabbed at
compile-time.  You can override this guess by calling \f(CW\*(C`prog_name($string)\*(C'\fR
yourself.
.SH "OTHER EXPORTS"
.IX Header "OTHER EXPORTS"
.ie n .SS """\-types"""
.el .SS "\f(CW\-types\fP"
.IX Subsection "-types"
Any of the Params::Validate type constants (\f(CW\*(C`SCALAR\*(C'\fR, etc.) can be imported as
well.  You can get all of them at once by importing \f(CW\*(C`\-types\*(C'\fR.
.ie n .SS """\-all"""
.el .SS "\f(CW\-all\fP"
.IX Subsection "-all"
This import group will import \f(CW\*(C`\-type\*(C'\fR, \f(CW\*(C`describe_options\*(C'\fR, and \f(CW\*(C`prog_name\*(C'\fR.
.SH "CUSTOMIZING"
.IX Header "CUSTOMIZING"
Getopt::Long::Descriptive uses Sub::Exporter to build and
export the \f(CW\*(C`describe_options\*(C'\fR routine.  By writing a new class that extends
Getopt::Long::Descriptive, the behavior of the constructed \f(CW\*(C`describe_options\*(C'\fR
routine can be changed.
.PP
The following methods can be overridden:
.SS "usage_class"
.IX Subsection "usage_class"
.Vb 1
\&  my $class = Getopt::Long::Descriptive\->usage_class;
.Ve
.PP
This returns the class to be used for constructing a Usage object, and defaults
to Getopt::Long::Descriptive::Usage.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.IP "\(bu" 4
Getopt::Long
.IP "\(bu" 4
Params::Validate
.SH "AUTHORS"
.IX Header "AUTHORS"
.IP "\(bu" 4
Hans Dieter Pearcey <hdp@cpan.org>
.IP "\(bu" 4
Ricardo Signes <rjbs@cpan.org>
.SH "CONTRIBUTORS"
.IX Header "CONTRIBUTORS"
.IP "\(bu" 4
Arthur Axel 'fREW' Schmidt <frioux@gmail.com>
.IP "\(bu" 4
Dave Rolsky <autarch@urth.org>
.IP "\(bu" 4
Diab Jerius <djerius@cfa.harvard.edu>
.IP "\(bu" 4
Hans Dieter Pearcey <hdp@pobox.com>
.IP "\(bu" 4
Hans Dieter Pearcey <hdp@weftsoar.net>
.IP "\(bu" 4
Harley Pig <harleypig@gmail.com>
.IP "\(bu" 4
hdp@cpan.org <hdp@cpan.org@fc0e91e4\-031c\-0410\-8307\-be39b06d7656>
.IP "\(bu" 4
Karen Etheridge <ether@cpan.org>
.IP "\(bu" 4
Michael McClimon <michael@mcclimon.org>
.IP "\(bu" 4
Niels Thykier <niels@thykier.net>
.IP "\(bu" 4
Olaf Alders <olaf@wundersolutions.com>
.IP "\(bu" 4
Roman Hubacek <roman.hubacek@centrum.cz>
.IP "\(bu" 4
Smylers <SMYLERS@cpan.fsck.com>
.IP "\(bu" 4
Thomas Neumann <blacky+perl@fluffbunny.de>
.IP "\(bu" 4
zhouzhen1 <zhouzhen1@gmail.com>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is copyright (c) 2005 by Hans Dieter Pearcey.
.PP
This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.
