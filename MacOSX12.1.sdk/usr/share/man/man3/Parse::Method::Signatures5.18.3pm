.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Parse::Method::Signatures 3"
.TH Parse::Method::Signatures 3 "2014-01-12" "perl v5.18.4" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Parse::Method::Signatures \- Perl6 like method signature parser
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Inspired by Perl6::Signature but streamlined to just support the subset
deemed useful for TryCatch and MooseX::Method::Signatures.
.SH "TODO"
.IX Header "TODO"
.IP "\(bu" 4
Document the parameter return types.
.IP "\(bu" 4
Probably lots of other things
.SH "METHODS"
.IX Header "METHODS"
There are only two public methods to this module, both of which should be
called as class methods. Both methods accept  either a single (non-ref) scalar
as the value for the \*(L"input\*(R" attribute, or normal new style arguments (hash
or hash-ref).
.SS "signature"
.IX Subsection "signature"
.Vb 1
\& my $sig = Parse::Method::Signatures\->signature( \*(Aq(Str $foo)\*(Aq )
.Ve
.PP
Attempts to parse the (bracketed) method signature. Returns a value or croaks
on error.
.SS "param"
.IX Subsection "param"
.Vb 1
\&  my $param = Parse::Method::Signatures\->param( \*(AqStr $foo where { length($_) < 10 }\*(Aq)
.Ve
.PP
Attempts to parse the specification for a single parameter. Returns value or
croaks on error.
.SH "ATTRIBUTES"
.IX Header "ATTRIBUTES"
All the attributes on this class are read-only.
.SS "input"
.IX Subsection "input"
\&\fBType:\fR Str
.PP
The string to parse.
.SS "offset"
.IX Subsection "offset"
\&\fBType:\fR Int
.PP
Offset into \*(L"input\*(R" at which to start parsing. Useful for using with
Devel::Declare linestring
.SS "signature_class"
.IX Subsection "signature_class"
\&\fBDefault:\fR Parse::Method::Signatures::Sig
.PP
\&\fBType:\fR Str (loaded on demand class name)
.SS "param_class"
.IX Subsection "param_class"
\&\fBDefault:\fR Parse::Method::Signatures::Param
.PP
\&\fBType:\fR Str (loaded on demand class name)
.SS "type_constraint_class"
.IX Subsection "type_constraint_class"
\&\fBDefault:\fR Parse::Method::Signatures::TypeConstraint
.PP
\&\fBType:\fR Str (loaded on demand class name)
.PP
Class that is used to turn the parsed type constraint into an actual
Moose::Meta::TypeConstraint object.
.SS "from_namespace"
.IX Subsection "from_namespace"
\&\fBType:\fR ClassName
.PP
Let this module know which package it is parsing signatures form. This is
entirely optional, and the only effect is has is on parsing type constraints.
.PP
If this attribute is set it is passed to \*(L"type_constraint_class\*(R" which can
use it to introspect the package (commonly for MooseX::Types exported
types). See
\&\*(L"find_registered_constraint\*(R" in Parse::Method::Signature::TypeConstraints for
more details.
.SS "type_constraint_callback"
.IX Subsection "type_constraint_callback"
\&\fBType:\fR CodeRef
.PP
Passed to the constructor of \*(L"type_constraint_class\*(R". Default implementation
of this callback asks Moose for a type constrain matching the name passed in.
If you have more complex requirements, such as parsing types created by
MooseX::Types then you will want a callback similar to this:
.PP
.Vb 7
\& # my $target_package defined elsewhere.
\& my $tc_cb = sub {
\&   my ($pms_tc, $name) = @_;
\&   my $code = $target_package\->can($name);
\&   $code ? eval { $code\->() } 
\&         : $pms_tc\->find_registered_constraint($name);
\& }
.Ve
.PP
Note that the above example is better provided by providing the
\&\*(L"from_namespace\*(R" attribute.
.SH "CAVEATS"
.IX Header "CAVEATS"
Like Perl6::Signature, the parsing of certain constructs is currently only a
\&'best effort' \- specifically default values and where code blocks might not
successfully for certain complex cases. Patches/Failing tests welcome.
.PP
Additionally, default value specifications are not evaluated which means that
no such lexical or similar errors will not be produced by this module.
Constant folding will also not be performed.
.PP
There are certain constructs that are simply too much hassle to avoid when the
work around is simple. Currently the only cases that are known to parse wrong
are when using anonymous variables (i.e. just sigils) in unpacked arrays. Take
the following example:
.PP
.Vb 1
\& method foo (ArrayRef [$, $], $some_value_we_care_about) {
.Ve
.PP
In this case the \f(CW$]\fR is treated as one of perl's magic variables
(specifically, the patch level of the Perl interpreter) rather than a \f(CW\*(C`$\*(C'\fR
followed by a \f(CW\*(C`]\*(C'\fR as was almost certainly intended. The work around for this
is simple: introduce a space between the characters:
.PP
.Vb 1
\& method foo (ArrayRef [ $, $ ], $some_value_we_care_about) {
.Ve
.PP
The same applies
.SH "AUTHOR"
.IX Header "AUTHOR"
Ash Berlin <ash@cpan.org>.
.PP
Thanks to Florian Ragwitz <rafl@debian.org>.
.PP
Many thanks to Piers Cawley to showing me the way to refactor my spaghetti
code into something more manageable.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Devel::Declare which is used by most modules that use this (currently by
all modules known to the author.)
.PP
<http://github.com/ashb/trycatch/tree>.
.SH "LICENSE"
.IX Header "LICENSE"
Licensed under the same terms as Perl itself.
.PP
This distribution copyright 2008\-2009, Ash Berlin <ash@cpan.org>
