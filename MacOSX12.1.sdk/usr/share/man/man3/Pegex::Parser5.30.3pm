.\" Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Pegex::Parser 3"
.TH Pegex::Parser 3 "2020-02-13" "perl v5.30.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Pegex::Parser \- Pegex Parser Runtime
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 3
\&    use Pegex::Parser;
\&    use SomeGrammarClass;
\&    use SomeReceiverClass;
\&
\&    my $parser = Pegex::Parser\->new(
\&        grammar => SomeGrammarClass\->new,
\&        receiver => SomeReceiverClass\->new,
\&    );
\&
\&    my $result = $parser\->parse($SomeInputText);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Pegex::Parser is the Pegex component that provides the parsing engine
runtime. It requires a Grammar object and a Receiver object. It's \f(CW\*(C`parse()\*(C'\fR
method takes an input that is expected to be matched by the grammar, and
applies the grammar rules to the input. As the grammar is applied, the
receiver is notified of matches. The receiver is free to do whatever it
wishes, but often times it builds the data into a structure that is commonly
known as a Parse Tree.
.PP
When the parse method is complete it returns whatever object the receiver
has provided as the final result. If the grammar fails to match the input
along the way, the parse method will throw an error with much information
about the failure.
.SH "ATTRIBUTES"
.IX Header "ATTRIBUTES"
The Pegex::Parser \f(CW\*(C`new\*(C'\fR object constructor takes these attributes:
.ie n .IP """grammar""" 4
.el .IP "\f(CWgrammar\fR" 4
.IX Item "grammar"
A Pegex::Grammar object. Required.
.ie n .IP """receiver""" 4
.el .IP "\f(CWreceiver\fR" 4
.IX Item "receiver"
A Pegex::Receiver object.
.ie n .IP """debug""" 4
.el .IP "\f(CWdebug\fR" 4
.IX Item "debug"
Boolean. Turn on debugging. Default false.
.ie n .IP """recursion_limit""" 4
.el .IP "\f(CWrecursion_limit\fR" 4
.IX Item "recursion_limit"
Integer. Recursion level to terminate on. Default 0 (off).
.ie n .IP """recursion_warn_limit""" 4
.el .IP "\f(CWrecursion_warn_limit\fR" 4
.IX Item "recursion_warn_limit"
Integer. Recursion level to warn on. Default 0 (off).
.ie n .IP """iteration_limit""" 4
.el .IP "\f(CWiteration_limit\fR" 4
.IX Item "iteration_limit"
Integer. Number of matches to try before terminating. Default 0 (off).
.SH "DEBUGGING"
.IX Header "DEBUGGING"
Pegex::Parser currently has 4 settings that are useful for debugging. These
can be set as Pegex::Parser object attributes, global variables or environment
variables:
.ie n .IP """debug"" or $Pegex::Parser::Debug or $ENV{PERL_PEGEX_DEBUG}" 4
.el .IP "\f(CWdebug\fR or \f(CW$Pegex::Parser::Debug\fR or \f(CW$ENV{PERL_PEGEX_DEBUG}\fR" 4
.IX Item "debug or $Pegex::Parser::Debug or $ENV{PERL_PEGEX_DEBUG}"
If set to a true value, it enables very useful trace messages for every
internal match operation.
.ie n .IP """recursion_limit"" or ""Pegex::Parser::RecursionLimit"" or $ENV{PERL_PEGEX_RECURSION_LIMIT}" 4
.el .IP "\f(CWrecursion_limit\fR or \f(CWPegex::Parser::RecursionLimit\fR or \f(CW$ENV{PERL_PEGEX_RECURSION_LIMIT}\fR" 4
.IX Item "recursion_limit or Pegex::Parser::RecursionLimit or $ENV{PERL_PEGEX_RECURSION_LIMIT}"
If set to a number greater than 0, Pegex::Parser will terminate after that
recursion level number is reached.
.ie n .IP """recursion_warn_limit"" or ""Pegex::Parser::RecursionWarnLimit"" or $ENV{PERL_PEGEX_RECURSION_WARN_LIMIT}" 4
.el .IP "\f(CWrecursion_warn_limit\fR or \f(CWPegex::Parser::RecursionWarnLimit\fR or \f(CW$ENV{PERL_PEGEX_RECURSION_WARN_LIMIT}\fR" 4
.IX Item "recursion_warn_limit or Pegex::Parser::RecursionWarnLimit or $ENV{PERL_PEGEX_RECURSION_WARN_LIMIT}"
If set to a number greater than 0, Pegex::Parser will issue a warning every
time that recursion level number is reached.
.ie n .IP """iteration_limit"" or ""Pegex::Parser::IterationLimit"" or $ENV{PERL_PEGEX_ITERATION_LIMIT}" 4
.el .IP "\f(CWiteration_limit\fR or \f(CWPegex::Parser::IterationLimit\fR or \f(CW$ENV{PERL_PEGEX_ITERATION_LIMIT}\fR" 4
.IX Item "iteration_limit or Pegex::Parser::IterationLimit or $ENV{PERL_PEGEX_ITERATION_LIMIT}"
If set to a number greater than 0, Pegex::Parser will terminate after that
number of matches has been attempted.
.ie n .IP """debug_indent"" or $Pegex::Parser::DebugIndent or $ENV{PERL_PEGEX_DEBUG_INDENT}" 4
.el .IP "\f(CWdebug_indent\fR or \f(CW$Pegex::Parser::DebugIndent\fR or \f(CW$ENV{PERL_PEGEX_DEBUG_INDENT}\fR" 4
.IX Item "debug_indent or $Pegex::Parser::DebugIndent or $ENV{PERL_PEGEX_DEBUG_INDENT}"
Tells the parser how many spaces should be used for indenting debugging
output. Default is 1.
.ie n .IP """debug_color"" or $Pegex::Parser::DebugColor or $ENV{PERL_PEGEX_DEBUG_COLOR}" 4
.el .IP "\f(CWdebug_color\fR or \f(CW$Pegex::Parser::DebugColor\fR or \f(CW$ENV{PERL_PEGEX_DEBUG_COLOR}\fR" 4
.IX Item "debug_color or $Pegex::Parser::DebugColor or $ENV{PERL_PEGEX_DEBUG_COLOR}"
If enabled, it will color \f(CW\*(C`got\*(C'\fR and \f(CW\*(C`not\*(C'\fR events in the debugging output
(\f(CW\*(C`bright_green\*(C'\fR and \f(CW\*(C`bright_red\*(C'\fR respectively). Color will be enabled by
default for debugging. It requires Term::ANSIColor.
.RS 4
.ie n .IP """always"" or 1" 4
.el .IP "\f(CWalways\fR or \f(CW1\fR" 4
.IX Item "always or 1"
Color is enabled.
.ie n .IP """auto""" 4
.el .IP "\f(CWauto\fR" 4
.IX Item "auto"
Color is enabled when \s-1STDERR\s0 is a tty.
.ie n .IP """never"" or 0" 4
.el .IP "\f(CWnever\fR or 0" 4
.IX Item "never or 0"
Color is disabled.
.RE
.RS 4
.Sp
You can configure the specific colors used by appending them like this:
.Sp
.Vb 1
\&    PERL_PEGEX_DEBUG_COLOR=\*(Aqalways, cyan bold, black on_yellow\*(Aq
.Ve
.Sp
For available colors, see Term::ANSIColor
.RE
.PP
Note: Using these variables incurs a slight performance hit, but if you don't
      use them all the debugging code is optimized away.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.IP "\(bu" 4
Pegex::Grammar
.IP "\(bu" 4
Pegex::Receiver
.SH "AUTHOR"
.IX Header "AUTHOR"
Ingy döt Net <ingy@cpan.org>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright 2010\-2020. Ingy döt Net.
.PP
This program is free software; you can redistribute it and/or modify it under
the same terms as Perl itself.
.PP
See <http://www.perl.com/perl/misc/Artistic.html>
