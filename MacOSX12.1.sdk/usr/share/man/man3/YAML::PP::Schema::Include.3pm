.\" Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "YAML::PP::Schema::Include 3"
.TH YAML::PP::Schema::Include 3 "2020-09-10" "perl v5.30.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
YAML::PP::Schema::Include \- Include YAML files
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 3
\&    # /path/to/file.yaml
\&    # \-\-\-
\&    # included: !include include/file2.yaml
\&
\&    # /path/to/include/file2.yaml
\&    # \-\-\-
\&    # a: b
\&
\&    my $include = YAML::PP::Schema::Include\->new;
\&
\&    my $yp = YAML::PP\->new( schema => [\*(AqJSON\*(Aq, $include] );
\&    # we need the original YAML::PP object for getting the current filename
\&    # and for loading another file
\&    $include\->yp($yp);
\&
\&    my ($data) = $yp\->load_file("/path/to/file.yaml");
\&
\&    # The result will be:
\&    $data = {
\&        included => { a => \*(Aqb\*(Aq }
\&    };
.Ve
.PP
Allow absolute filenames and upwards \f(CW\*(Aq..\*(Aq\fR:
.PP
.Vb 3
\&    my $include = YAML::PP::Schema::Include\->new(
\&        allow_absolute => 1, # default: 0
\&    );
.Ve
.PP
Specify paths to search for includes:
.PP
.Vb 6
\&    my @include_paths = ("/path/to/include/yaml/1", "/path/to/include/yaml/2");
\&    my $include = YAML::PP::Schema::Include\->new(
\&        paths => \e@include_paths,
\&    );
\&    my $yp = YAML::PP\->new( schema => [\*(AqJSON\*(Aq, $include] );
\&    $include\->yp($yp);
\&
\&    # /path/to/include/yaml/1/file1.yaml
\&    # \-\-\-
\&    # a: b
\&
\&    my $yaml = <<\*(AqEOM\*(Aq;
\&    \- included: !include file1.yaml
\&    EOM
\&    my ($data) = $yp\->load_string($yaml);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This plugin allows you to split a large \s-1YAML\s0 file into smaller ones.
You can then include these files with the \f(CW\*(C`!include\*(C'\fR tag.
.PP
It will search for the specified filename relative to the currently processed
filename.
.PP
You can also specify the paths where to search for files to include. It iterates
through the paths and returns the first filename that exists.
.PP
By default, only relative paths are allowed. Any \f(CW\*(C`../\*(C'\fR in the path will be
removed. You can change that behaviour by setting the option \f(CW\*(C`allow_absolute\*(C'\fR
to true.
.PP
If the included file contains more than one document, only the first one
will be included.
.PP
I will probably add a possibility to return all documents as an arrayref.
.PP
The included \s-1YAML\s0 file will be loaded by creating a new \s-1YAML::PP\s0 object
with the schema from the existing object. This way you can recursively include
files.
.PP
You can even reuse the same include via an alias:
.PP
.Vb 4
\&    \-\-\-
\&    invoice:
\&        shipping address: &address !include address.yaml
\&        billing address: *address
.Ve
.PP
Circular includes will be detected, and will be fatal.
.PP
It's possible to specify what to do with the included file:
.PP
.Vb 12
\&    my $include = YAML::PP::Schema::Include\->new(
\&        loader => sub {
\&            my ($yp, $filename);
\&            if ($filename =~ m/\e.txt$/) {
\&                # open file and just return text
\&            }
\&            else {
\&                # default behaviour
\&                return $yp\->load_file($filename);
\&            }
\&        },
\&    );
.Ve
.PP
For example, \s-1RAML\s0 defines an \f(CW\*(C`!include\*(C'\fR tag which depends on the file
content. If it contains a special \s-1RAML\s0 directive, it will be loaded as
\&\s-1YAML,\s0 otherwise the content of the file will be included as a string.
.PP
So with this plugin you are able to read \s-1RAML\s0 specifications.
