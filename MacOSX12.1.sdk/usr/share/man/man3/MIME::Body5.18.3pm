.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "MIME::Body 3"
.TH MIME::Body 3 "2013-11-14" "perl v5.18.4" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
MIME::Body \- the body of a MIME message
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
Before reading further, you should see MIME::Tools to make sure that
you understand where this module fits into the grand scheme of things.
Go on, do it now.  I'll wait.
.PP
Ready?  Ok...
.SS "Obtaining bodies"
.IX Subsection "Obtaining bodies"
.Vb 2
\&   ### Get the bodyhandle of a MIME::Entity object:
\&   $body = $entity\->bodyhandle;
\&
\&   ### Create a body which stores data in a disk file:
\&   $body = new MIME::Body::File "/path/to/file";
\&
\&   ### Create a body which stores data in an in\-core array:
\&   $body = new MIME::Body::InCore \e@strings;
.Ve
.SS "Opening, closing, and using \s-1IO\s0 handles"
.IX Subsection "Opening, closing, and using IO handles"
.Vb 4
\&   ### Write data to the body:
\&   $IO = $body\->open("w")      || die "open body: $!";
\&   $IO\->print($message);
\&   $IO\->close                  || die "close I/O handle: $!";
\&
\&   ### Read data from the body (in this case, line by line):
\&   $IO = $body\->open("r")      || die "open body: $!";
\&   while (defined($_ = $IO\->getline)) {
\&       ### do stuff
\&   }
\&   $IO\->close                  || die "close I/O handle: $!";
.Ve
.SS "Other I/O"
.IX Subsection "Other I/O"
.Vb 2
\&   ### Dump the ENCODED body data to a filehandle:
\&   $body\->print(\e*STDOUT);
\&
\&   ### Slurp all the UNENCODED data in, and put it in a scalar:
\&   $string = $body\->as_string;
\&
\&   ### Slurp all the UNENCODED data in, and put it in an array of lines:
\&   @lines = $body\->as_lines;
.Ve
.SS "Working directly with paths to underlying files"
.IX Subsection "Working directly with paths to underlying files"
.Vb 7
\&   ### Where\*(Aqs the data?
\&   if (defined($body\->path)) {   ### data is on disk:
\&       print "data is stored externally, in ", $body\->path;
\&   }
\&   else {                        ### data is in core:
\&       print "data is already in core, and is...\en", $body\->as_string;
\&   }
\&
\&   ### Get rid of anything on disk:
\&   $body\->purge;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\s-1MIME\s0 messages can be very long (e.g., tar files, MPEGs, etc.) or very
short (short textual notes, as in ordinary mail).  Long messages
are best stored in files, while short ones are perhaps best stored
in core.
.PP
This class is an attempt to define a common interface for objects
which contain message data, regardless of how the data is
physically stored.  The lifespan of a \*(L"body\*(R" object
usually looks like this:
.IP "1." 4
\&\fBBody object is created by a MIME::Parser during parsing.\fR
It's at this point that the actual MIME::Body subclass is chosen,
and \fInew()\fR is invoked.  (For example: if the body data is going to
a file, then it is at this point that the class MIME::Body::File,
and the filename, is chosen).
.IP "2." 4
\&\fBData is written to the body\fR (usually by the \s-1MIME\s0 parser) like this:
The body is opened for writing, via \f(CW\*(C`open("w")\*(C'\fR.  This will trash any
previous contents, and return an \*(L"I/O handle\*(R" opened for writing.
Data is written to this I/O handle, via \fIprint()\fR.
Then the I/O handle is closed, via \fIclose()\fR.
.IP "3." 4
\&\fBData is read from the body\fR (usually by the user application) like this:
The body is opened for reading by a user application, via \f(CW\*(C`open("r")\*(C'\fR.
This will return an \*(L"I/O handle\*(R" opened for reading.
Data is read from the I/O handle, via \fIread()\fR, \fIgetline()\fR, or \fIgetlines()\fR.
Then the I/O handle is closed, via \fIclose()\fR.
.IP "4." 4
\&\fBBody object is destructed.\fR
.PP
You can write your own subclasses, as long as they follow the
interface described below.  Implementers of subclasses should assume
that steps 2 and 3 may be repeated any number of times, and in
different orders (e.g., 1\-2\-2\-3\-2\-3\-3\-3\-3\-3\-2\-4).
.PP
In any case, once a MIME::Body has been created, you ask to open it
for reading or writing, which gets you an \*(L"i/o handle\*(R": you then use
the same mechanisms for reading from or writing to that handle, no matter
what class it is.
.PP
Beware: unless you know for certain what kind of body you have, you
should \fInot\fR assume that the body has an underlying filehandle.
.SH "PUBLIC INTERFACE"
.IX Header "PUBLIC INTERFACE"
.IP "new \s-1ARGS...\s0" 4
.IX Item "new ARGS..."
\&\fIClass method, constructor.\fR
Create a new body.  Any \s-1ARGS\s0 are sent to \fIinit()\fR.
.IP "init \s-1ARGS...\s0" 4
.IX Item "init ARGS..."
\&\fIInstance method, abstract, initiallizer.\fR
This is called automatically by \f(CW\*(C`new()\*(C'\fR, with the arguments given
to \f(CW\*(C`new()\*(C'\fR.  The arguments are optional, and entirely up to the
subclass.  The default method does nothing,
.IP "as_lines" 4
.IX Item "as_lines"
\&\fIInstance method.\fR
Return the contents of the body as an array of lines (each terminated
by a newline, with the possible exception of the final one).
Returns empty on failure (\s-1NB:\s0 indistinguishable from an empty body!).
.Sp
Note: the default method gets the data via
repeated \fIgetline()\fR calls; your subclass might wish to override this.
.IP "as_string" 4
.IX Item "as_string"
\&\fIInstance method.\fR
Return the body data as a string (slurping it into core if necessary).
Best not to do this unless you're \fIsure\fR that the body is reasonably small!
Returns empty string for an empty body, and undef on failure.
.Sp
Note: the default method uses \fIprint()\fR, which gets the data via
repeated \fIread()\fR calls; your subclass might wish to override this.
.IP "binmode [\s-1ONOFF\s0]" 4
.IX Item "binmode [ONOFF]"
\&\fIInstance method.\fR
With argument, flags whether or not \fIopen()\fR should return an I/O handle
which has \fIbinmode()\fR activated.  With no argument, just returns the
current value.
.IP "is_encoded [\s-1ONOFF\s0]" 4
.IX Item "is_encoded [ONOFF]"
\&\fIInstance method.\fR
If set to yes, no decoding is applied on output. This flag is set
by MIME::Parser, if the parser runs in \fIdecode_bodies\fR\|(0) mode, so the
content is handled unmodified.
.IP "dup" 4
.IX Item "dup"
\&\fIInstance method.\fR
Duplicate the bodyhandle.
.Sp
\&\fIBeware:\fR external data in bodyhandles is \fInot\fR copied to new files!
Changing the data in one body's data file, or purging that body,
\&\fIwill\fR affect its duplicate.  Bodies with in-core data probably need
not worry.
.IP "open \s-1READWRITE\s0" 4
.IX Item "open READWRITE"
\&\fIInstance method, abstract.\fR
This should do whatever is necessary to open the body for either
writing (if \s-1READWRITE\s0 is \*(L"w\*(R") or reading (if mode is \*(L"r\*(R").
.Sp
This method is expected to return an \*(L"I/O handle\*(R" object on success,
and undef on error.  An I/O handle can be any object that supports a
small set of standard methods for reading/writing data.
See the IO::Handle class for an example.
.IP "path [\s-1PATH\s0]" 4
.IX Item "path [PATH]"
\&\fIInstance method.\fR
If you're storing the body data externally (e.g., in a disk file), you'll
want to give applications the ability to get at that data, for cleanup.
This method should return the path to the data, or undef if there is none.
.Sp
Where appropriate, the path \fIshould\fR be a simple string, like a filename.
With argument, sets the \s-1PATH,\s0 which should be undef if there is none.
.IP "print \s-1FILEHANDLE\s0" 4
.IX Item "print FILEHANDLE"
\&\fIInstance method.\fR
Output the body data to the given filehandle, or to the currently-selected
one if none is given.
.IP "purge" 4
.IX Item "purge"
\&\fIInstance method, abstract.\fR
Remove any data which resides external to the program (e.g., in disk files).
Immediately after a \fIpurge()\fR, the \fIpath()\fR should return undef to indicate
that the external data is no longer available.
.SH "SUBCLASSES"
.IX Header "SUBCLASSES"
The following built-in classes are provided:
.PP
.Vb 6
\&   Body                 Stores body     When open()ed,
\&   class:               data in:        returns:
\&   \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&   MIME::Body::File     disk file       IO::Handle
\&   MIME::Body::Scalar   scalar          IO::Handle
\&   MIME::Body::InCore   scalar array    IO::Handle
.Ve
.SS "MIME::Body::File"
.IX Subsection "MIME::Body::File"
A body class that stores the data in a disk file.  Invoke the
constructor as:
.PP
.Vb 1
\&    $body = new MIME::Body::File "/path/to/file";
.Ve
.PP
In this case, the \f(CW\*(C`path()\*(C'\fR method would return the given path,
so you \fIcould\fR say:
.PP
.Vb 7
\&    if (defined($body\->path)) {
\&        open BODY, $body\->path or die "open: $!";
\&        while (<BODY>) {
\&            ### do stuff
\&        }
\&        close BODY;
\&    }
.Ve
.PP
But you're best off not doing this.
.SS "MIME::Body::Scalar"
.IX Subsection "MIME::Body::Scalar"
A body class that stores the data in-core, in a simple scalar.
Invoke the constructor as:
.PP
.Vb 1
\&    $body = new MIME::Body::Scalar \e$string;
.Ve
.PP
A single scalar argument sets the body to that value, exactly as though
you'd opened for the body for writing, written the value,
and closed the body again:
.PP
.Vb 1
\&    $body = new MIME::Body::Scalar "Line 1\enLine 2\enLine 3";
.Ve
.PP
A single array reference sets the body to the result of joining all the
elements of that array together:
.PP
.Vb 3
\&    $body = new MIME::Body::Scalar ["Line 1\en",
\&                                    "Line 2\en",
\&                                    "Line 3"];
.Ve
.SS "MIME::Body::InCore"
.IX Subsection "MIME::Body::InCore"
A body class that stores the data in-core.
Invoke the constructor as:
.PP
.Vb 3
\&    $body = new MIME::Body::InCore \e$string;
\&    $body = new MIME::Body::InCore  $string;
\&    $body = new MIME::Body::InCore \e@stringarray
.Ve
.PP
A simple scalar argument sets the body to that value, exactly as though
you'd opened for the body for writing, written the value,
and closed the body again:
.PP
.Vb 1
\&    $body = new MIME::Body::InCore "Line 1\enLine 2\enLine 3";
.Ve
.PP
A single array reference sets the body to the concatenation of all
scalars that it holds:
.PP
.Vb 3
\&    $body = new MIME::Body::InCore ["Line 1\en",
\&                                    "Line 2\en",
\&                                    "Line 3"];
.Ve
.SS "Defining your own subclasses"
.IX Subsection "Defining your own subclasses"
So you're not happy with files and scalar-arrays?
No problem: just define your own MIME::Body subclass, and make a subclass
of MIME::Parser or MIME::ParserBase which returns an instance of your
body class whenever appropriate in the \f(CW\*(C`new_body_for(head)\*(C'\fR method.
.PP
Your \*(L"body\*(R" class must inherit from MIME::Body (or some subclass of it),
and it must either provide (or inherit the default for) the following
methods...
.PP
The default inherited method \fIshould suffice\fR for all these:
.PP
.Vb 3
\&    new
\&    binmode [ONOFF]
\&    path
.Ve
.PP
The default inherited method \fImay suffice\fR for these, but perhaps
there's a better implementation for your subclass.
.PP
.Vb 6
\&    init ARGS...
\&    as_lines
\&    as_string
\&    dup
\&    print
\&    purge
.Ve
.PP
The default inherited method \fIwill probably not suffice\fR for these:
.PP
.Vb 1
\&    open
.Ve
.SH "NOTES"
.IX Header "NOTES"
One reason I didn't just use IO::Handle objects for message bodies was
that I wanted a \*(L"body\*(R" object to be a form of completely encapsulated
program-persistent storage; that is, I wanted users to be able to write
code like this...
.PP
.Vb 7
\&   ### Get body handle from this MIME message, and read its data:
\&   $body = $entity\->bodyhandle;
\&   $IO = $body\->open("r");
\&   while (defined($_ = $IO\->getline)) {
\&       print STDOUT $_;
\&   }
\&   $IO\->close;
.Ve
.PP
\&...without requiring that they know anything more about how the
\&\f(CW$body\fR object is actually storing its data (disk file, scalar variable,
array variable, or whatever).
.PP
Storing the body of each \s-1MIME\s0 message in a persistently-open
IO::Handle was a possibility, but it seemed like a bad idea,
considering that a single multipart \s-1MIME\s0 message could easily suck up
all the available file descriptors on some systems.  This risk increases
if the user application is processing more than one \s-1MIME\s0 entity at a time.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
MIME::Tools
.SH "AUTHOR"
.IX Header "AUTHOR"
Eryq (\fIeryq@zeegee.com\fR), ZeeGee Software Inc (\fIhttp://www.zeegee.com\fR).
David F. Skoll (dfs@roaringpenguin.com) http://www.roaringpenguin.com
.PP
All rights reserved.  This program is free software; you can redistribute
it and/or modify it under the same terms as Perl itself.
.PP
Thanks to Achim Bohnet for suggesting that MIME::Parser not be restricted
to the use of FileHandles.
.PP
#\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
1;
