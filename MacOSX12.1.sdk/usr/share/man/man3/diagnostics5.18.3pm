.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "diagnostics 3pm"
.TH diagnostics 3pm "2014-09-30" "perl v5.18.4" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
diagnostics, splain \- produce verbose warning diagnostics
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
Using the \f(CW\*(C`diagnostics\*(C'\fR pragma:
.PP
.Vb 2
\&    use diagnostics;
\&    use diagnostics \-verbose;
\&
\&    enable  diagnostics;
\&    disable diagnostics;
.Ve
.PP
Using the \f(CW\*(C`splain\*(C'\fR standalone filter program:
.PP
.Vb 2
\&    perl program 2>diag.out
\&    splain [\-v] [\-p] diag.out
.Ve
.PP
Using diagnostics to get stack traces from a misbehaving script:
.PP
.Vb 1
\&    perl \-Mdiagnostics=\-traceonly my_script.pl
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
.ie n .SS "The ""diagnostics"" Pragma"
.el .SS "The \f(CWdiagnostics\fP Pragma"
.IX Subsection "The diagnostics Pragma"
This module extends the terse diagnostics normally emitted by both the
perl compiler and the perl interpreter (from running perl with a \-w 
switch or \f(CW\*(C`use warnings\*(C'\fR), augmenting them with the more
explicative and endearing descriptions found in perldiag.  Like the
other pragmata, it affects the compilation phase of your program rather
than merely the execution phase.
.PP
To use in your program as a pragma, merely invoke
.PP
.Vb 1
\&    use diagnostics;
.Ve
.PP
at the start (or near the start) of your program.  (Note 
that this \fIdoes\fR enable perl's \fB\-w\fR flag.)  Your whole
compilation will then be subject(ed :\-) to the enhanced diagnostics.
These still go out \fB\s-1STDERR\s0\fR.
.PP
Due to the interaction between runtime and compiletime issues,
and because it's probably not a very good idea anyway,
you may not use \f(CW\*(C`no diagnostics\*(C'\fR to turn them off at compiletime.
However, you may control their behaviour at runtime using the 
\&\fIdisable()\fR and \fIenable()\fR methods to turn them off and on respectively.
.PP
The \fB\-verbose\fR flag first prints out the perldiag introduction before
any other diagnostics.  The \f(CW$diagnostics::PRETTY\fR variable can generate nicer
escape sequences for pagers.
.PP
Warnings dispatched from perl itself (or more accurately, those that match
descriptions found in perldiag) are only displayed once (no duplicate
descriptions).  User code generated warnings a la \fIwarn()\fR are unaffected,
allowing duplicate user messages to be displayed.
.PP
This module also adds a stack trace to the error message when perl dies.
This is useful for pinpointing what
caused the death.  The \fB\-traceonly\fR (or
just \fB\-t\fR) flag turns off the explanations of warning messages leaving just
the stack traces.  So if your script is dieing, run it again with
.PP
.Vb 1
\&  perl \-Mdiagnostics=\-traceonly my_bad_script
.Ve
.PP
to see the call stack at the time of death.  By supplying the \fB\-warntrace\fR
(or just \fB\-w\fR) flag, any warnings emitted will also come with a stack
trace.
.SS "The \fIsplain\fP Program"
.IX Subsection "The splain Program"
While apparently a whole nuther program, \fIsplain\fR is actually nothing
more than a link to the (executable) \fIdiagnostics.pm\fR module, as well as
a link to the \fIdiagnostics.pod\fR documentation.  The \fB\-v\fR flag is like
the \f(CW\*(C`use diagnostics \-verbose\*(C'\fR directive.
The \fB\-p\fR flag is like the
\&\f(CW$diagnostics::PRETTY\fR variable.  Since you're post-processing with 
\&\fIsplain\fR, there's no sense in being able to \fIenable()\fR or \fIdisable()\fR processing.
.PP
Output from \fIsplain\fR is directed to \fB\s-1STDOUT\s0\fR, unlike the pragma.
.SH "EXAMPLES"
.IX Header "EXAMPLES"
The following file is certain to trigger a few errors at both
runtime and compiletime:
.PP
.Vb 8
\&    use diagnostics;
\&    print NOWHERE "nothing\en";
\&    print STDERR "\en\etThis message should be unadorned.\en";
\&    warn "\etThis is a user warning";
\&    print "\enDIAGNOSTIC TESTER: Please enter a <CR> here: ";
\&    my $a, $b = scalar <STDIN>;
\&    print "\en";
\&    print $x/$y;
.Ve
.PP
If you prefer to run your program first and look at its problem
afterwards, do this:
.PP
.Vb 2
\&    perl \-w test.pl 2>test.out
\&    ./splain < test.out
.Ve
.PP
Note that this is not in general possible in shells of more dubious heritage, 
as the theoretical
.PP
.Vb 2
\&    (perl \-w test.pl >/dev/tty) >& test.out
\&    ./splain < test.out
.Ve
.PP
Because you just moved the existing \fBstdout\fR to somewhere else.
.PP
If you don't want to modify your source code, but still have on-the-fly
warnings, do this:
.PP
.Vb 1
\&    exec 3>&1; perl \-w test.pl 2>&1 1>&3 3>&\- | splain 1>&2 3>&\-
.Ve
.PP
Nifty, eh?
.PP
If you want to control warnings on the fly, do something like this.
Make sure you do the \f(CW\*(C`use\*(C'\fR first, or you won't be able to get
at the \fIenable()\fR or \fIdisable()\fR methods.
.PP
.Vb 4
\&    use diagnostics; # checks entire compilation phase 
\&        print "\entime for 1st bogus diags: SQUAWKINGS\en";
\&        print BOGUS1 \*(Aqnada\*(Aq;
\&        print "done with 1st bogus\en";
\&
\&    disable diagnostics; # only turns off runtime warnings
\&        print "\entime for 2nd bogus: (squelched)\en";
\&        print BOGUS2 \*(Aqnada\*(Aq;
\&        print "done with 2nd bogus\en";
\&
\&    enable diagnostics; # turns back on runtime warnings
\&        print "\entime for 3rd bogus: SQUAWKINGS\en";
\&        print BOGUS3 \*(Aqnada\*(Aq;
\&        print "done with 3rd bogus\en";
\&
\&    disable diagnostics;
\&        print "\entime for 4th bogus: (squelched)\en";
\&        print BOGUS4 \*(Aqnada\*(Aq;
\&        print "done with 4th bogus\en";
.Ve
.SH "INTERNALS"
.IX Header "INTERNALS"
Diagnostic messages derive from the \fIperldiag.pod\fR file when available at
runtime.  Otherwise, they may be embedded in the file itself when the
splain package is built.   See the \fIMakefile\fR for details.
.PP
If an extant \f(CW$SIG\fR{_\|_WARN_\|_} handler is discovered, it will continue
to be honored, but only after the \fIdiagnostics::splainthis()\fR function 
(the module's \f(CW$SIG\fR{_\|_WARN_\|_} interceptor) has had its way with your
warnings.
.PP
There is a \f(CW$diagnostics::DEBUG\fR variable you may set if you're desperately
curious what sorts of things are being intercepted.
.PP
.Vb 1
\&    BEGIN { $diagnostics::DEBUG = 1 }
.Ve
.SH "BUGS"
.IX Header "BUGS"
Not being able to say \*(L"no diagnostics\*(R" is annoying, but may not be
insurmountable.
.PP
The \f(CW\*(C`\-pretty\*(C'\fR directive is called too late to affect matters.
You have to do this instead, and \fIbefore\fR you load the module.
.PP
.Vb 1
\&    BEGIN { $diagnostics::PRETTY = 1 }
.Ve
.PP
I could start up faster by delaying compilation until it should be
needed, but this gets a \*(L"panic: top_level\*(R" when using the pragma form
in Perl 5.001e.
.PP
While it's true that this documentation is somewhat subserious, if you use
a program named \fIsplain\fR, you should expect a bit of whimsy.
.SH "AUTHOR"
.IX Header "AUTHOR"
Tom Christiansen <\fItchrist@mox.perl.com\fR>, 25 June 1995.
