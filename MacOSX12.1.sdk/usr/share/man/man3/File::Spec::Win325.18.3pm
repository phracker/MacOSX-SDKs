.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "File::Spec::Win32 3pm"
.TH File::Spec::Win32 3pm "2014-09-30" "perl v5.18.4" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
File::Spec::Win32 \- methods for Win32 file specs
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& require File::Spec::Win32; # Done internally by File::Spec if needed
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
See File::Spec::Unix for a documentation of the methods provided
there. This package overrides the implementation of these methods, not
the semantics.
.IP "devnull" 4
.IX Item "devnull"
Returns a string representation of the null device.
.IP "tmpdir" 4
.IX Item "tmpdir"
Returns a string representation of the first existing directory
from the following list:
.Sp
.Vb 8
\&    $ENV{TMPDIR}
\&    $ENV{TEMP}
\&    $ENV{TMP}
\&    SYS:/temp
\&    C:\esystem\etemp
\&    C:/temp
\&    /tmp
\&    /
.Ve
.Sp
The SYS:/temp is preferred in Novell NetWare and the C:\esystem\etemp
for Symbian (the File::Spec::Win32 is used also for those platforms).
.Sp
Since Perl 5.8.0, if running under taint mode, and if the environment
variables are tainted, they are not used.
.IP "case_tolerant" 4
.IX Item "case_tolerant"
MSWin32 case-tolerance depends on \fIGetVolumeInformation()\fR \f(CW$ouFsFlags\fR == \s-1FS_CASE_SENSITIVE,\s0
indicating the case significance when comparing file specifications.
Since \s-1XP FS_CASE_SENSITIVE\s0 is effectively disabled for the \s-1NT\s0 subsubsystem.
See http://cygwin.com/ml/cygwin/2007\-07/msg00891.html
Default: 1
.IP "file_name_is_absolute" 4
.IX Item "file_name_is_absolute"
As of right now, this returns 2 if the path is absolute with a
volume, 1 if it's absolute with no volume, 0 otherwise.
.IP "catfile" 4
.IX Item "catfile"
Concatenate one or more directory names and a filename to form a
complete path ending with a filename
.IP "canonpath" 4
.IX Item "canonpath"
No physical check on the filesystem, but a logical cleanup of a
path. On \s-1UNIX\s0 eliminated successive slashes and successive \*(L"/.\*(R".
On Win32 makes
.Sp
.Vb 2
\&        dir1\edir2\edir3\e..\e..\edir4 \-> \edir\edir4 and even
\&        dir1\edir2\edir3\e...\edir4   \-> \edir\edir4
.Ve
.IP "splitpath" 4
.IX Item "splitpath"
.Vb 3
\&    ($volume,$directories,$file) = File::Spec\->splitpath( $path );
\&    ($volume,$directories,$file) = File::Spec\->splitpath( $path,
\&                                                          $no_file );
.Ve
.Sp
Splits a path into volume, directory, and filename portions. Assumes that 
the last file is a path unless the path ends in '\e\e', '\e\e.', '\e\e..'
or \f(CW$no_file\fR is true.  On Win32 this means that \f(CW$no_file\fR true makes this return 
( \f(CW$volume\fR, \f(CW$path\fR, '' ).
.Sp
Separators accepted are \e and /.
.Sp
Volumes can be drive letters or \s-1UNC\s0 sharenames (\e\eserver\eshare).
.Sp
The results can be passed to \*(L"catpath\*(R" to get back a path equivalent to
(usually identical to) the original path.
.IP "splitdir" 4
.IX Item "splitdir"
The opposite of \fIcatdir()\fR.
.Sp
.Vb 1
\&    @dirs = File::Spec\->splitdir( $directories );
.Ve
.Sp
\&\f(CW$directories\fR must be only the directory portion of the path on systems 
that have the concept of a volume or that have path syntax that differentiates
files from directories.
.Sp
Unlike just splitting the directories on the separator, leading empty and 
trailing directory entries can be returned, because these are significant
on some OSs. So,
.Sp
.Vb 1
\&    File::Spec\->splitdir( "/a/b/c" );
.Ve
.Sp
Yields:
.Sp
.Vb 1
\&    ( \*(Aq\*(Aq, \*(Aqa\*(Aq, \*(Aqb\*(Aq, \*(Aq\*(Aq, \*(Aqc\*(Aq, \*(Aq\*(Aq )
.Ve
.IP "catpath" 4
.IX Item "catpath"
Takes volume, directory and file portions and returns an entire path. Under
Unix, \f(CW$volume\fR is ignored, and this is just like \fIcatfile()\fR. On other OSs,
the \f(CW$volume\fR become significant.
.SS "Note For File::Spec::Win32 Maintainers"
.IX Subsection "Note For File::Spec::Win32 Maintainers"
Novell NetWare inherits its File::Spec behaviour from File::Spec::Win32.
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (c) 2004,2007 by the Perl 5 Porters.  All rights reserved.
.PP
This program is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
See File::Spec and File::Spec::Unix.  This package overrides the
implementation of these methods, not the semantics.
