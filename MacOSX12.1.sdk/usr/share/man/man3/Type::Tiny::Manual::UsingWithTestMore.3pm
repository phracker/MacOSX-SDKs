.\" Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Type::Tiny::Manual::UsingWithTestMore 3"
.TH Type::Tiny::Manual::UsingWithTestMore 3 "2020-10-28" "perl v5.30.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Type::Tiny::Manual::UsingWithTestMore \- Type::Tiny for test suites
.SH "MANUAL"
.IX Header "MANUAL"
.SS "Test::TypeTiny"
.IX Subsection "Test::TypeTiny"
This is a module for testing that types you've defined accept and reject
the values you think they should.
.PP
.Vb 2
\& should_pass($value, $type);
\& should_fail($othervalue, $type);
.Ve
.PP
Easy. (But yeah, I always forget whether the type goes first or second!)
.PP
There's also a function to test that subtype/supertype relationships are
working okay.
.PP
.Vb 1
\& ok_subtype($type, @subtypes);
.Ve
.PP
Of course you can just check a type like this:
.PP
.Vb 1
\& ok( $type\->check($value) );
.Ve
.PP
But the advantage of \f(CW\*(C`should_pass\*(C'\fR is that if the \f(CW\*(C`EXTENDED_TESTING\*(C'\fR
environment variable is set to true, \f(CW\*(C`should_pass\*(C'\fR will also perform a
strict check on the value, which involves climbing up the type's
inheritance tree (its parent, its parent's parent, etc) to make sure
the value passes all their constraints.
.PP
If a normal check and strict check differ, this is usually a problem
in the inlining code somewhere.
.PP
See Test::TypeTiny for more information.
.SS "Type::Tiny as a Replacement for Test::Deep"
.IX Subsection "Type::Tiny as a Replacement for Test::Deep"
Here's one of the examples from the Test::Deep documentation:
.PP
.Vb 10
\& my $name_re = re(\*(Aq^(Mr|Mrs|Miss) \ew+ \ew+$\*(Aq);
\& cmp_deeply(
\&   $person,
\&   {
\&     Name       => $name_re,
\&     Phone      => re(\*(Aq^0d{6}$\*(Aq),
\&     ChildNames => array_each($name_re)
\&   },
\&   "person ok"
\& );
.Ve
.PP
It's pretty easy to rewrite this to use Types::Standard:
.PP
.Vb 9
\& my $name = StrMatch[ qr/^(Mr|Mrs|Miss) \ew+ \ew+$/ ];
\& should_pass(
\&   $person,
\&   Dict[
\&     Name         => $name,
\&     Phone        => StrMatch[ qr/^0d{6}$/ ],
\&     ChildNames   => ArrayRef[$name]
\&   ]
\& );
.Ve
.PP
There's nothing especially wrong with Test::Deep, but if you're already
familiar with Type::Tiny's built-in types and you've maybe written your
own type libraries too, it will save you having to switch between using two
separate systems of checks.
.SH "NEXT STEPS"
.IX Header "NEXT STEPS"
Here's your next step:
.IP "\(bu" 4
Type::Tiny::Manual::Params
.Sp
Advanced information on Type::Params, and using Type::Tiny with other
signature modules like Function::Parameters and Kavorka.
.SH "AUTHOR"
.IX Header "AUTHOR"
Toby Inkster <tobyink@cpan.org>.
.SH "COPYRIGHT AND LICENCE"
.IX Header "COPYRIGHT AND LICENCE"
This software is copyright (c) 2013\-2014, 2017\-2020 by Toby Inkster.
.PP
This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.
.SH "DISCLAIMER OF WARRANTIES"
.IX Header "DISCLAIMER OF WARRANTIES"
\&\s-1THIS PACKAGE IS PROVIDED \*(L"AS IS\*(R" AND WITHOUT ANY EXPRESS OR IMPLIED
WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.\s0
