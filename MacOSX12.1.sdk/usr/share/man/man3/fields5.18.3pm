.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "fields 3pm"
.TH fields 3pm "2014-09-30" "perl v5.18.4" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
fields \- compile\-time class fields
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 10
\&    {
\&        package Foo;
\&        use fields qw(foo bar _Foo_private);
\&        sub new {
\&            my Foo $self = shift;
\&            unless (ref $self) {
\&                $self = fields::new($self);
\&                $self\->{_Foo_private} = "this is Foo\*(Aqs secret";
\&            }
\&            $self\->{foo} = 10;
\&            $self\->{bar} = 20;
\&            return $self;
\&        }
\&    }
\&
\&    my $var = Foo\->new;
\&    $var\->{foo} = 42;
\&
\&    # this will generate an error
\&    $var\->{zap} = 42;
\&
\&    # subclassing
\&    {
\&        package Bar;
\&        use base \*(AqFoo\*(Aq;
\&        use fields qw(baz _Bar_private);        # not shared with Foo
\&        sub new {
\&            my $class = shift;
\&            my $self = fields::new($class);
\&            $self\->SUPER::new();                # init base fields
\&            $self\->{baz} = 10;                  # init own fields
\&            $self\->{_Bar_private} = "this is Bar\*(Aqs secret";
\&            return $self;
\&        }
\&    }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The \f(CW\*(C`fields\*(C'\fR pragma enables compile-time verified class fields.
.PP
\&\s-1NOTE:\s0 The current implementation keeps the declared fields in the \f(CW%FIELDS\fR
hash of the calling package, but this may change in future versions.
Do \fBnot\fR update the \f(CW%FIELDS\fR hash directly, because it must be created
at compile-time for it to be fully useful, as is done by this pragma.
.PP
\&\fBOnly valid for perl before 5.9.0:\fR
.PP
If a typed lexical variable holding a reference is used to access a
hash element and a package with the same name as the type has
declared class fields using this pragma, then the operation is
turned into an array access at compile time.
.PP
The related \f(CW\*(C`base\*(C'\fR pragma will combine fields from base classes and any
fields declared using the \f(CW\*(C`fields\*(C'\fR pragma.  This enables field
inheritance to work properly.
.PP
Field names that start with an underscore character are made private to
the class and are not visible to subclasses.  Inherited fields can be
overridden but will generate a warning if used together with the \f(CW\*(C`\-w\*(C'\fR
switch.
.PP
\&\fBOnly valid for perls before 5.9.0:\fR
.PP
The effect of all this is that you can have objects with named
fields which are as compact and as fast arrays to access. This only
works as long as the objects are accessed through properly typed
variables. If the objects are not typed, access is only checked at
run time.
.PP
The following functions are supported:
.IP "new" 4
.IX Item "new"
\&\fB perl before 5.9.0: \fR \fIfields::new()\fR creates and blesses a
pseudo-hash comprised of the fields declared using the \f(CW\*(C`fields\*(C'\fR
pragma into the specified class.
.Sp
\&\fB perl 5.9.0 and higher: \fR \fIfields::new()\fR creates and blesses a
restricted-hash comprised of the fields declared using the \f(CW\*(C`fields\*(C'\fR
pragma into the specified class.
.Sp
This function is usable with or without pseudo-hashes.  It is the
recommended way to construct a fields-based object.
.Sp
This makes it possible to write a constructor like this:
.Sp
.Vb 2
\&    package Critter::Sounds;
\&    use fields qw(cat dog bird);
\&
\&    sub new {
\&        my $self = shift;
\&        $self = fields::new($self) unless ref $self;
\&        $self\->{cat} = \*(Aqmeow\*(Aq;                      # scalar element
\&        @$self{\*(Aqdog\*(Aq,\*(Aqbird\*(Aq} = (\*(Aqbark\*(Aq,\*(Aqtweet\*(Aq);    # slice
\&        return $self;
\&    }
.Ve
.IP "phash" 4
.IX Item "phash"
\&\fB before perl 5.9.0: \fR
.Sp
\&\fIfields::phash()\fR can be used to create and initialize a plain (unblessed)
pseudo-hash.  This function should always be used instead of creating
pseudo-hashes directly.
.Sp
If the first argument is a reference to an array, the pseudo-hash will
be created with keys from that array.  If a second argument is supplied,
it must also be a reference to an array whose elements will be used as
the values.  If the second array contains less elements than the first,
the trailing elements of the pseudo-hash will not be initialized.
This makes it particularly useful for creating a pseudo-hash from
subroutine arguments:
.Sp
.Vb 3
\&    sub dogtag {
\&       my $tag = fields::phash([qw(name rank ser_num)], [@_]);
\&    }
.Ve
.Sp
\&\fIfields::phash()\fR also accepts a list of key-value pairs that will
be used to construct the pseudo hash.  Examples:
.Sp
.Vb 3
\&    my $tag = fields::phash(name => "Joe",
\&                            rank => "captain",
\&                            ser_num => 42);
\&
\&    my $pseudohash = fields::phash(%args);
.Ve
.Sp
\&\fB perl 5.9.0 and higher: \fR
.Sp
Pseudo-hashes have been removed from Perl as of 5.10.  Consider using
restricted hashes or \fIfields::new()\fR instead.  Using \fIfields::phash()\fR
will cause an error.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
base
