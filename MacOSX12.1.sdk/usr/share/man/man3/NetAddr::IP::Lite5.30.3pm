.\" Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Lite 3"
.TH Lite 3 "2016-03-26" "perl v5.30.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
NetAddr::IP::Lite \- Manages IPv4 and IPv6 addresses and subnets
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 11
\&  use NetAddr::IP::Lite qw(
\&        Zeros
\&        Ones
\&        V4mask
\&        V4net
\&        :aton           DEPRECATED !
\&        :old_nth
\&        :upper
\&        :lower
\&        :nofqdn
\&  );
\&
\&  my $ip = new NetAddr::IP::Lite \*(Aq127.0.0.1\*(Aq;
\&        or if your prefer
\&  my $ip = NetAddr::IP::Lite\->new(\*(Aq127.0.0.1);
\&        or from a packed IPv4 address
\&  my $ip = new_from_aton NetAddr::IP::Lite (inet_aton(\*(Aq127.0.0.1\*(Aq));
\&        or from an octal filtered IPv4 address
\&  my $ip = new_no NetAddr::IP::Lite \*(Aq127.012.0.0\*(Aq;
\&
\&  print "The address is ", $ip\->addr, " with mask ", $ip\->mask, "\en" ;
\&
\&  if ($ip\->within(new NetAddr::IP::Lite "127.0.0.0", "255.0.0.0")) {
\&      print "Is a loopback address\en";
\&  }
\&
\&                                # This prints 127.0.0.1/32
\&  print "You can also say $ip...\en";
\&
\&  The following four functions return ipV6 representations of:
\&
\&  ::                                       = Zeros();
\&  FFFF:FFFF:FFFF:FFFF:FFFF:FFFF:FFFF:FFFF  = Ones();
\&  FFFF:FFFF:FFFF:FFFF:FFFF:FFFF::          = V4mask();
\&  ::FFFF:FFFF                              = V4net();
\&
\&  Will also return an ipV4 or ipV6 representation of a
\&  resolvable Fully Qualified Domanin Name (FQDN).
.Ve
.SH "INSTALLATION"
.IX Header "INSTALLATION"
Un-tar the distribution in an appropriate directory and type:
.PP
.Vb 4
\&        perl Makefile.PL
\&        make
\&        make test
\&        make install
.Ve
.PP
\&\fBNetAddr::IP::Lite\fR depends on \fBNetAddr::IP::Util\fR which installs by default with its primary functions compiled
using Perl's \s-1XS\s0 extensions to build a 'C' library. If you do not have a 'C'
complier available or would like the slower Pure Perl version for some other
reason, then type:
.PP
.Vb 4
\&        perl Makefile.PL \-noxs
\&        make
\&        make test
\&        make install
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module provides an object-oriented abstraction on top of \s-1IP\s0
addresses or \s-1IP\s0 subnets, that allows for easy manipulations. Most of the
operations of NetAddr::IP are supported. This module will work with older
versions of Perl and is compatible with Math::BigInt.
.PP
* By default \fBNetAddr::IP\fR functions and methods return string IPv6
addresses in uppercase.  To change that to lowercase:
.PP
\&\s-1NOTE:\s0 the \s-1AUGUST 2010 RFC5952\s0 states:
.PP
.Vb 1
\&    4.3. Lowercase
\&
\&      The characters "a", "b", "c", "d", "e", and "f" in an IPv6
\&      address MUST be represented in lowercase.
.Ve
.PP
It is recommended that all \s-1NEW\s0 applications using NetAddr::IP::Lite be
invoked as shown on the next line.
.PP
.Vb 1
\&  use NetAddr::IP::Lite qw(:lower);
.Ve
.PP
* To ensure the current IPv6 string case behavior even if the default changes:
.PP
.Vb 1
\&  use NetAddr::IP::Lite qw(:upper);
.Ve
.PP
The internal representation of all \s-1IP\s0 objects is in 128 bit IPv6 notation.
IPv4 and IPv6 objects may be freely mixed.
.PP
The supported operations are described below:
.SS "Overloaded Operators"
.IX Subsection "Overloaded Operators"
.ie n .IP "\fBAssignment (\f(CB""=""\fB)\fR" 4
.el .IP "\fBAssignment (\f(CB=\fB)\fR" 4
.IX Item "Assignment (=)"
Has been optimized to copy one NetAddr::IP::Lite object to another very quickly.
.ie n .IP "\fB\f(CB""\->copy()""\fB\fR" 4
.el .IP "\fB\f(CB\->copy()\fB\fR" 4
.IX Item "->copy()"
The \fBassignment (\f(CB\*(C`=\*(C'\fB)\fR operation is only put in to operation when the
copied object is further mutated by another overloaded operation. See
overload \fB\s-1SPECIAL SYMBOLS FOR\s0 \*(L"use overload\*(R"\fR for details.
.Sp
\&\fB\f(CB\*(C`\->copy()\*(C'\fB\fR actually creates a new object when called.
.IP "\fBStringification\fR" 4
.IX Item "Stringification"
An object can be used just as a string. For instance, the following code
.Sp
.Vb 2
\&        my $ip = new NetAddr::IP::Lite \*(Aq192.168.1.123\*(Aq;
\&        print "$ip\en";
.Ve
.Sp
Will print the string 192.168.1.123/32.
.Sp
.Vb 2
\&        my $ip = new6 NetAddr::IP::Lite \*(Aq192.168.1.123\*(Aq;
\&        print "$ip\en";
.Ve
.Sp
Will print the string 0:0:0:0:0:0:C0A8:17B/128
.IP "\fBEquality\fR" 4
.IX Item "Equality"
You can test for equality with either \f(CW\*(C`eq\*(C'\fR, \f(CW\*(C`ne\*(C'\fR, \f(CW\*(C`==\*(C'\fR or \f(CW\*(C`!=\*(C'\fR. \f(CW\*(C`eq\*(C'\fR, \f(CW\*(C`ne\*(C'\fR allows the
comparison with arbitrary strings as well as NetAddr::IP::Lite objects. The
following example:
.Sp
.Vb 2
\&    if (NetAddr::IP::Lite\->new(\*(Aq127.0.0.1\*(Aq,\*(Aq255.0.0.0\*(Aq) eq \*(Aq127.0.0.1/8\*(Aq)
\&       { print "Yes\en"; }
.Ve
.Sp
Will print out \*(L"Yes\*(R".
.Sp
Comparison with \f(CW\*(C`==\*(C'\fR and \f(CW\*(C`!=\*(C'\fR requires both operands to be NetAddr::IP::Lite objects.
.ie n .IP "\fBComparison via >, <, >=, <=, <=> and \f(CB""cmp""\fB\fR" 4
.el .IP "\fBComparison via >, <, >=, <=, <=> and \f(CBcmp\fB\fR" 4
.IX Item "Comparison via >, <, >=, <=, <=> and cmp"
Internally, all network objects are represented in 128 bit format.
The numeric representation of the network is compared through the
corresponding operation. Comparisons are tried first on the address portion
of the object and if that is equal then the \s-1NUMERIC\s0 cidr portion of the
masks are compared. This leads to the counterintuitive result that
.Sp
.Vb 1
\&        /24 > /16
.Ve
.Sp
Comparison should not be done on netaddr objects with different \s-1CIDR\s0 as
this may produce indeterminate \- unexpected results,
rather the determination of which netblock is larger or smaller should be
done by comparing
.Sp
.Vb 1
\&        $ip1\->masklen <=> $ip2\->masklen
.Ve
.ie n .IP "\fBAddition of a constant (\f(CB""+""\fB)\fR" 4
.el .IP "\fBAddition of a constant (\f(CB+\fB)\fR" 4
.IX Item "Addition of a constant (+)"
Add a 32 bit signed constant to the address part of a NetAddr object.
This operation changes the address part to point so many hosts above the
current objects start address. For instance, this code:
.Sp
.Vb 1
\&    print NetAddr::IP::Lite\->new(\*(Aq127.0.0.1/8\*(Aq) + 5;
.Ve
.Sp
will output 127.0.0.6/8. The address will wrap around at the broadcast
back to the network address. This code:
.Sp
.Vb 1
\&    print NetAddr::IP::Lite\->new(\*(Aq10.0.0.1/24\*(Aq) + 255;
.Ve
.Sp
outputs 10.0.0.0/24.
.Sp
Returns the the unchanged object when the constant is missing or out of range.
.Sp
.Vb 1
\&    2147483647 <= constant >= \-2147483648
.Ve
.ie n .IP "\fBSubtraction of a constant (\f(CB""\-""\fB)\fR" 4
.el .IP "\fBSubtraction of a constant (\f(CB\-\fB)\fR" 4
.IX Item "Subtraction of a constant (-)"
The complement of the addition of a constant.
.ie n .IP "\fBDifference (\f(CB""\-""\fB)\fR" 4
.el .IP "\fBDifference (\f(CB\-\fB)\fR" 4
.IX Item "Difference (-)"
Returns the difference between the address parts of two NetAddr::IP::Lite
objects address parts as a 32 bit signed number.
.Sp
Returns \fBundef\fR if the difference is out of range.
.IP "\fBAuto-increment\fR" 4
.IX Item "Auto-increment"
Auto-incrementing a NetAddr::IP::Lite object causes the address part to be
adjusted to the next host address within the subnet. It will wrap at
the broadcast address and start again from the network address.
.IP "\fBAuto-decrement\fR" 4
.IX Item "Auto-decrement"
Auto-decrementing a NetAddr::IP::Lite object performs exactly the opposite
of auto-incrementing it, as you would expect.
.SS "Methods"
.IX Subsection "Methods"
.ie n .IP """\->new([$addr, [ $mask|IPv6 ]])""" 4
.el .IP "\f(CW\->new([$addr, [ $mask|IPv6 ]])\fR" 4
.IX Item "->new([$addr, [ $mask|IPv6 ]])"
.PD 0
.ie n .IP """\->new6([$addr, [ $mask]])""" 4
.el .IP "\f(CW\->new6([$addr, [ $mask]])\fR" 4
.IX Item "->new6([$addr, [ $mask]])"
.ie n .IP """\->new6FFFF([$addr, [ $mask]])""" 4
.el .IP "\f(CW\->new6FFFF([$addr, [ $mask]])\fR" 4
.IX Item "->new6FFFF([$addr, [ $mask]])"
.ie n .IP """\->new_no([$addr, [ $mask]])""" 4
.el .IP "\f(CW\->new_no([$addr, [ $mask]])\fR" 4
.IX Item "->new_no([$addr, [ $mask]])"
.ie n .IP """\->new_from_aton($netaddr)""" 4
.el .IP "\f(CW\->new_from_aton($netaddr)\fR" 4
.IX Item "->new_from_aton($netaddr)"
.IP "new_cis and new_cis6 are \s-1DEPRECATED\s0" 4
.IX Item "new_cis and new_cis6 are DEPRECATED"
.ie n .IP """\->new_cis(""$addr $mask)""" 4
.el .IP "\f(CW\->new_cis(""$addr $mask)\fR" 4
.IX Item "->new_cis(""$addr $mask)"
.ie n .IP """\->new_cis6(""$addr $mask)""" 4
.el .IP "\f(CW\->new_cis6(""$addr $mask)\fR" 4
.IX Item "->new_cis6(""$addr $mask)"
.PD
The first three methods create a new address with the supplied address in
\&\f(CW$addr\fR and an optional netmask \f(CW$mask\fR, which can be omitted to get 
a /32 or /128 netmask for IPv4 / IPv6 addresses respectively.
.Sp
new6FFFF specifically returns an IPv4 address in IPv6 format according to \s-1RFC4291\s0
.Sp
.Vb 2
\&  new6               ::xxxx:xxxx
\&  new6FFFF      ::FFFF:xxxx:xxxx
.Ve
.Sp
The third method \f(CW\*(C`new_no\*(C'\fR is exclusively for IPv4 addresses and filters
improperly formatted
dot quad strings for leading 0's that would normally be interpreted as octal
format by NetAddr per the specifications for inet_aton.
.Sp
\&\fBnew_from_aton\fR takes a packed IPv4 address and assumes a /32 mask. This
function replaces the \s-1DEPRECATED\s0 :aton functionality which is fundamentally
broken.
.Sp
The last two methods \fBnew_cis\fR and \fBnew_cis6\fR differ from \fBnew\fR and
\&\fBnew6\fR only in that they except the common Cisco address notation for
address/mask pairs with a \fBspace\fR as a separator instead of a slash (/)
.Sp
These methods are \s-1DEPRECATED\s0 because the functionality is now included
in the other \*(L"new\*(R" methods
.Sp
.Vb 3
\&  i.e.  \->new_cis(\*(Aq1.2.3.0 24\*(Aq)
\&        or
\&        \->new_cis6(\*(Aq::1.2.3.0 120\*(Aq)
.Ve
.Sp
\&\f(CW\*(C`\->new6\*(C'\fR and
\&\f(CW\*(C`\->new_cis6\*(C'\fR mark the address as being in ipV6 address space even
if the format would suggest otherwise.
.Sp
.Vb 1
\&  i.e.  \->new6(\*(Aq1.2.3.4\*(Aq) will result in ::102:304
\&
\&  addresses submitted to \->new in ipV6 notation will
\&  remain in that notation permanently. i.e.
\&        \->new(\*(Aq::1.2.3.4\*(Aq) will result in ::102:304
\&  whereas new(\*(Aq1.2.3.4\*(Aq) would print out as 1.2.3.4
\&
\&  See "STRINGIFICATION" below.
.Ve
.Sp
\&\f(CW$addr\fR can be almost anything that can be resolved to an \s-1IP\s0 address
in all the notations I have seen over time. It can optionally contain
the mask in \s-1CIDR\s0 notation. If the \s-1OPTIONAL\s0 perl module Socket6 is
available in the local library it will autoload and ipV6 host6 
names will be resolved as well as ipV4 hostnames.
.Sp
\&\fBprefix\fR notation is understood, with the limitation that the range
specified by the prefix must match with a valid subnet.
.Sp
Addresses in the same format returned by \f(CW\*(C`inet_aton\*(C'\fR or
\&\f(CW\*(C`gethostbyname\*(C'\fR can also be understood, although no mask can be
specified for them. The default is to not attempt to recognize this
format, as it seems to be seldom used.
.Sp
###### \s-1DEPRECATED,\s0 will be remove in version 5 ############
To accept addresses in that format, invoke the module as in
.Sp
.Vb 1
\&  use NetAddr::IP::Lite \*(Aq:aton\*(Aq
.Ve
.Sp
###### \s-1USE\s0 new_from_aton instead ##########################
.Sp
If called with no arguments, 'default' is assumed.
.Sp
If called with an empty string as the argument, returns 'undef'
.Sp
\&\f(CW$addr\fR can be any of the following and possibly more...
.Sp
.Vb 10
\&  n.n
\&  n.n/mm
\&  n.n mm
\&  n.n.n
\&  n.n.n/mm
\&  n.n.n mm
\&  n.n.n.n
\&  n.n.n.n/mm            32 bit cidr notation
\&  n.n.n.n mm
\&  n.n.n.n/m.m.m.m
\&  n.n.n.n m.m.m.m
\&  loopback, localhost, broadcast, any, default
\&  x.x.x.x/host
\&  0xABCDEF, 0b111111000101011110, (or a bcd number)
\&  a netaddr as returned by \*(Aqinet_aton\*(Aq
.Ve
.Sp
Any \s-1RFC1884\s0 notation
.Sp
.Vb 10
\&  ::n.n.n.n
\&  ::n.n.n.n/mmm         128 bit cidr notation
\&  ::n.n.n.n/::m.m.m.m
\&  ::x:x
\&  ::x:x/mmm
\&  x:x:x:x:x:x:x:x
\&  x:x:x:x:x:x:x:x/mmm
\&  x:x:x:x:x:x:x:x/m:m:m:m:m:m:m:m any RFC1884 notation
\&  loopback, localhost, unspecified, any, default
\&  ::x:x/host
\&  0xABCDEF, 0b111111000101011110 within the limits
\&  of perl\*(Aqs number resolution
\&  123456789012  a \*(Aqbig\*(Aq bcd number (bigger than perl likes)
\&  and Math::BigInt
.Ve
.Sp
A Fully Qualified Domain Name which returns an ipV4 address or an ipV6
address, embodied in that order. This previously undocumented feature
may be disabled with:
.Sp
.Vb 1
\&        use NetAddr::IP::Lite \*(Aq:nofqdn\*(Aq;
.Ve
.Sp
If called with no arguments, 'default' is assumed.
.Sp
If called with and empty string as the argument, 'undef' is returned;
.ie n .IP """\->broadcast()""" 4
.el .IP "\f(CW\->broadcast()\fR" 4
.IX Item "->broadcast()"
Returns a new object referring to the broadcast address of a given
subnet. The broadcast address has all ones in all the bit positions
where the netmask has zero bits. This is normally used to address all
the hosts in a given subnet.
.ie n .IP """\->network()""" 4
.el .IP "\f(CW\->network()\fR" 4
.IX Item "->network()"
Returns a new object referring to the network address of a given
subnet. A network address has all zero bits where the bits of the
netmask are zero. Normally this is used to refer to a subnet.
.ie n .IP """\->addr()""" 4
.el .IP "\f(CW\->addr()\fR" 4
.IX Item "->addr()"
Returns a scalar with the address part of the object as an IPv4 or IPv6 text
string as appropriate. This is useful for printing or for passing the address
part of the NetAddr::IP::Lite object to other components that expect an \s-1IP\s0
address. If the object is an ipV6 address or was created using \->new6($ip)
it will be reported in ipV6 hex format otherwise it will be reported in dot
quad format only if it resides in ipV4 address space.
.ie n .IP """\->mask()""" 4
.el .IP "\f(CW\->mask()\fR" 4
.IX Item "->mask()"
Returns a scalar with the mask as an IPv4 or IPv6 text string as
described above.
.ie n .IP """\->masklen()""" 4
.el .IP "\f(CW\->masklen()\fR" 4
.IX Item "->masklen()"
Returns a scalar the number of one bits in the mask.
.ie n .IP """\->bits()""" 4
.el .IP "\f(CW\->bits()\fR" 4
.IX Item "->bits()"
Returns the width of the address in bits. Normally 32 for v4 and 128 for v6.
.ie n .IP """\->version()""" 4
.el .IP "\f(CW\->version()\fR" 4
.IX Item "->version()"
Returns the version of the address or subnet. Currently this can be
either 4 or 6.
.ie n .IP """\->cidr()""" 4
.el .IP "\f(CW\->cidr()\fR" 4
.IX Item "->cidr()"
Returns a scalar with the address and mask in \s-1CIDR\s0 notation. A
NetAddr::IP::Lite object \fIstringifies\fR to the result of this function.
(see comments about \->\fBnew6()\fR and \->\fBaddr()\fR for output formats)
.ie n .IP """\->aton()""" 4
.el .IP "\f(CW\->aton()\fR" 4
.IX Item "->aton()"
Returns the address part of the NetAddr::IP::Lite object in the same format
as the \f(CW\*(C`inet_aton()\*(C'\fR or \f(CW\*(C`ipv6_aton\*(C'\fR function respectively. If the object
was created using \->new6($ip), the address returned will always be in ipV6
format, even for addresses in ipV4 address space.
.ie n .IP """\->range()""" 4
.el .IP "\f(CW\->range()\fR" 4
.IX Item "->range()"
Returns a scalar with the base address and the broadcast address
separated by a dash and spaces. This is called range notation.
.ie n .IP """\->numeric()""" 4
.el .IP "\f(CW\->numeric()\fR" 4
.IX Item "->numeric()"
When called in a scalar context, will return a numeric representation
of the address part of the \s-1IP\s0 address. When called in an array
context, it returns a list of two elements. The first element is as
described, the second element is the numeric representation of the
netmask.
.Sp
This method is essential for serializing the representation of a
subnet.
.ie n .IP """\->bigint()""" 4
.el .IP "\f(CW\->bigint()\fR" 4
.IX Item "->bigint()"
When called in a scalar context, will return a Math::BigInt representation
of the address part of the \s-1IP\s0 address. When called in an array
contest, it returns a list of two elements. The first element is as
described, the second element is the Math::BigInt  representation of the
netmask.
.ie n .IP """$me\->contains($other)""" 4
.el .IP "\f(CW$me\->contains($other)\fR" 4
.IX Item "$me->contains($other)"
Returns true when \f(CW$me\fR completely contains \f(CW$other\fR. False is
returned otherwise and \f(CW\*(C`undef\*(C'\fR is returned if \f(CW$me\fR and \f(CW$other\fR
are not both \f(CW\*(C`NetAddr::IP::Lite\*(C'\fR objects.
.ie n .IP """$me\->within($other)""" 4
.el .IP "\f(CW$me\->within($other)\fR" 4
.IX Item "$me->within($other)"
The complement of \f(CW\*(C`\->contains()\*(C'\fR. Returns true when \f(CW$me\fR is
completely contained within \f(CW$other\fR, undef if \f(CW$me\fR and \f(CW$other\fR
are not both \f(CW\*(C`NetAddr::IP::Lite\*(C'\fR objects.
.IP "C\->\fBis_rfc1918()\fR>" 4
.IX Item "C->is_rfc1918()>"
Returns true when \f(CW$me\fR is an \s-1RFC 1918\s0 address.
.Sp
.Vb 3
\&     10.0.0.0        \-   10.255.255.255  (10/8 prefix)
\&     172.16.0.0      \-   172.31.255.255  (172.16/12 prefix)
\&     192.168.0.0     \-   192.168.255.255 (192.168/16 prefix)
.Ve
.ie n .IP """\->is_local()""" 4
.el .IP "\f(CW\->is_local()\fR" 4
.IX Item "->is_local()"
Returns true when \f(CW$me\fR is a local network address.
.Sp
.Vb 2
\&        i.e.    ipV4    127.0.0.0 \- 127.255.255.255
\&  or            ipV6    === ::1
.Ve
.ie n .IP """\->first()""" 4
.el .IP "\f(CW\->first()\fR" 4
.IX Item "->first()"
Returns a new object representing the first usable \s-1IP\s0 address within
the subnet (ie, the first host address).
.ie n .IP """\->last()""" 4
.el .IP "\f(CW\->last()\fR" 4
.IX Item "->last()"
Returns a new object representing the last usable \s-1IP\s0 address within
the subnet (ie, one less than the broadcast address).
.ie n .IP """\->nth($index)""" 4
.el .IP "\f(CW\->nth($index)\fR" 4
.IX Item "->nth($index)"
Returns a new object representing the \fIn\fR\-th usable \s-1IP\s0 address within
the subnet (ie, the \fIn\fR\-th host address).  If no address is available
(for example, when the network is too small for \f(CW$index\fR hosts),
\&\f(CW\*(C`undef\*(C'\fR is returned.
.Sp
Version 4.00 of NetAddr::IP and version 1.00 of NetAddr::IP::Lite implements
\&\f(CW\*(C`\->nth($index)\*(C'\fR and \f(CW\*(C`\->num()\*(C'\fR exactly as the documentation states.
Previous versions behaved slightly differently and not in a consistent
manner.
.Sp
To use the old behavior for \f(CW\*(C`\->nth($index)\*(C'\fR and \f(CW\*(C`\->num()\*(C'\fR:
.Sp
.Vb 1
\&  use NetAddr::IP::Lite qw(:old_nth);
\&
\&  old behavior:
\&  NetAddr::IP\->new(\*(Aq10/32\*(Aq)\->nth(0) == undef
\&  NetAddr::IP\->new(\*(Aq10/32\*(Aq)\->nth(1) == undef
\&  NetAddr::IP\->new(\*(Aq10/31\*(Aq)\->nth(0) == undef
\&  NetAddr::IP\->new(\*(Aq10/31\*(Aq)\->nth(1) == 10.0.0.1/31
\&  NetAddr::IP\->new(\*(Aq10/30\*(Aq)\->nth(0) == undef
\&  NetAddr::IP\->new(\*(Aq10/30\*(Aq)\->nth(1) == 10.0.0.1/30
\&  NetAddr::IP\->new(\*(Aq10/30\*(Aq)\->nth(2) == 10.0.0.2/30
\&  NetAddr::IP\->new(\*(Aq10/30\*(Aq)\->nth(3) == 10.0.0.3/30
.Ve
.Sp
Note that in each case, the broadcast address is represented in the
output set and that the 'zero'th index is alway undef except for
a point-to-point /31 or /127 network where there are exactly two
addresses in the network.
.Sp
.Vb 8
\&  new behavior:
\&  NetAddr::IP\->new(\*(Aq10/32\*(Aq)\->nth(0)  == 10.0.0.0/32
\&  NetAddr::IP\->new(\*(Aq10.1/32\*(Aq\->nth(0) == 10.0.0.1/32
\&  NetAddr::IP\->new(\*(Aq10/31\*(Aq)\->nth(0)  == 10.0.0.0/32
\&  NetAddr::IP\->new(\*(Aq10/31\*(Aq)\->nth(1)  == 10.0.0.1/32
\&  NetAddr::IP\->new(\*(Aq10/30\*(Aq)\->nth(0) == 10.0.0.1/30
\&  NetAddr::IP\->new(\*(Aq10/30\*(Aq)\->nth(1) == 10.0.0.2/30
\&  NetAddr::IP\->new(\*(Aq10/30\*(Aq)\->nth(2) == undef
.Ve
.Sp
Note that a /32 net always has 1 usable address while a /31 has exactly 
two usable addresses for point-to-point addressing. The first
index (0) returns the address immediately following the network address 
except for a /31 or /127 when it return the network address.
.ie n .IP """\->num()""" 4
.el .IP "\f(CW\->num()\fR" 4
.IX Item "->num()"
As of version 4.42 of NetAddr::IP and version 1.27 of NetAddr::IP::Lite
a /31 and /127 with return a net \fBnum\fR value of 2 instead of 0 (zero)
for point-to-point networks.
.Sp
Version 4.00 of NetAddr::IP and version 1.00 of NetAddr::IP::Lite
return the number of usable \s-1IP\s0 addresses within the subnet, 
not counting the broadcast or network address.
.Sp
Previous versions worked only for ipV4 addresses, returned a    
maximum span of 2**32 and returned the number of \s-1IP\s0 addresses 
not counting the broadcast address.
	(one greater than the new behavior)
.Sp
To use the old behavior for \f(CW\*(C`\->nth($index)\*(C'\fR and \f(CW\*(C`\->num()\*(C'\fR:
.Sp
.Vb 1
\&  use NetAddr::IP::Lite qw(:old_nth);
.Ve
.Sp
\&\s-1WARNING:\s0
.Sp
NetAddr::IP will calculate and return a numeric string for network 
ranges as large as 2**128. These values are \s-1TEXT\s0 strings and perl
can treat them as integers for numeric calculations.
.Sp
Perl on 32 bit platforms only handles integer numbers up to 2**32 
and on 64 bit platforms to 2**64.
.Sp
If you wish to manipulate numeric strings returned by NetAddr::IP
that are larger than 2**32 or 2**64, respectively,  you must load 
additional modules such as Math::BigInt, bignum or some similar 
package to do the integer math.
.SH "EXPORT_OK"
.IX Header "EXPORT_OK"
.Vb 9
\&        Zeros
\&        Ones
\&        V4mask
\&        V4net
\&        :aton           DEPRECATED
\&        :old_nth
\&        :upper
\&        :lower
\&        :nofqdn
.Ve
.SH "AUTHORS"
.IX Header "AUTHORS"
Luis E. Muñoz <luismunoz@cpan.org>,
Michael Robinton <michael@bizsystems.com>
.SH "WARRANTY"
.IX Header "WARRANTY"
This software comes with the  same warranty as perl itself (ie, none),
so by using it you accept any and all the liability.
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
.Vb 2
\& This software is (c) Luis E. Muñoz, 1999 \- 2005
\& and (c) Michael Robinton, 2006 \- 2014.
.Ve
.PP
All rights reserved.
.PP
This program is free software; you can redistribute it and/or modify
it under the terms of either:
.PP
.Vb 3
\&  a) the GNU General Public License as published by the Free
\&  Software Foundation; either version 2, or (at your option) any
\&  later version, or
\&
\&  b) the "Artistic License" which comes with this distribution.
.Ve
.PP
This program is distributed in the hope that it will be useful,
but \s-1WITHOUT ANY WARRANTY\s0; without even the implied warranty of
\&\s-1MERCHANTABILITY\s0 or \s-1FITNESS FOR A PARTICULAR PURPOSE.\s0  See either
the \s-1GNU\s0 General Public License or the Artistic License for more details.
.PP
You should have received a copy of the Artistic License with this
distribution, in the file named \*(L"Artistic\*(R".  If not, I'll be glad to provide
one.
.PP
You should also have received a copy of the \s-1GNU\s0 General Public License
along with this program in the file named \*(L"Copying\*(R". If not, write to the
.PP
.Vb 3
\&        Free Software Foundation, Inc.,
\&        51 Franklin Street, Fifth Floor
\&        Boston, MA 02110\-1301 USA
.Ve
.PP
or visit their web page on the internet at:
.PP
.Vb 1
\&        http://www.gnu.org/copyleft/gpl.html.
.Ve
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fBNetAddr::IP\fR\|(3), \fBNetAddr::IP::Util\fR\|(3), \fBNetAddr::IP::InetBase\fR\|(3)
