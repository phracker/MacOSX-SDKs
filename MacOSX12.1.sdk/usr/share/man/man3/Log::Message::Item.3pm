.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Log::Message::Item 3pm"
.TH Log::Message::Item 3pm "2014-09-30" "perl v5.18.4" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Log::Message::Item  \- Message objects for Log::Message
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    # Implicitly used by Log::Message to create Log::Message::Item objects
\&
\&    print "this is the message\*(Aqs id: ",     $item\->id;
\&
\&    print "this is the message stored: ",   $item\->message;
\&
\&    print "this is when it happened: ",     $item\->when;
\&
\&    print "the message was tagged: ",       $item\->tag;
\&
\&    print "this was the severity level: ",  $item\->level;
\&
\&    $item\->remove;  # delete the item from the stack it was on
\&
\&    # Besides these methods, you can also call the handlers on
\&    # the object specifically.
\&    # See the Log::Message::Handlers manpage for documentation on what
\&    # handlers are available by default and how to add your own
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Log::Message::Item is a class that generates generic Log items.
These items are stored on a Log::Message stack, so see the Log::Message
manpage about details how to retrieve them.
.PP
You should probably not create new items by yourself, but use the
storing mechanism provided by Log::Message.
.PP
However, the accessors and handlers are of interest if you want to do
fine tuning of how your messages are handled.
.PP
The accessors and methods are described below, the handlers are
documented in the Log::Message::Handlers manpage.
.SH "Methods and Accessors"
.IX Header "Methods and Accessors"
.SS "remove"
.IX Subsection "remove"
Calling remove will remove the object from the stack it was on, so it
will not show up any more in subsequent fetches of messages.
.PP
You can still call accessors and handlers on it however, to handle it
as you will.
.SS "id"
.IX Subsection "id"
Returns the internal \s-1ID\s0 of the item. This may be useful for comparing
since the \s-1ID\s0 is incremented each time a new item is created.
Therefore, an item with \s-1ID 4\s0 must have been logged before an item with
\&\s-1ID 9.\s0
.SS "when"
.IX Subsection "when"
Returns the timestamp of when the message was logged
.SS "message"
.IX Subsection "message"
The actual message that was stored
.SS "level"
.IX Subsection "level"
The severity type of this message, as well as the name of the handler
that was called upon storing it.
.SS "tag"
.IX Subsection "tag"
Returns the identification tag that was put on the message.
.SS "shortmess"
.IX Subsection "shortmess"
Returns the equivalent of a \f(CW\*(C`Carp::shortmess\*(C'\fR for this item.
See the \f(CW\*(C`Carp\*(C'\fR manpage for details.
.SS "longmess"
.IX Subsection "longmess"
Returns the equivalent of a \f(CW\*(C`Carp::longmess\*(C'\fR for this item, which
is essentially a stack trace.
See the \f(CW\*(C`Carp\*(C'\fR manpage for details.
.SS "parent"
.IX Subsection "parent"
Returns a reference to the Log::Message object that stored this item.
This is useful if you want to have access to the full stack in a
handler.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Log::Message, Log::Message::Handlers, Log::Message::Config
.SH "AUTHOR"
.IX Header "AUTHOR"
This module by
Jos Boumans <kane@cpan.org>.
.SH "Acknowledgements"
.IX Header "Acknowledgements"
Thanks to Ann Barcomb for her suggestions.
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
This module is
copyright (c) 2002 Jos Boumans <kane@cpan.org>.
All rights reserved.
.PP
This library is free software;
you may redistribute and/or modify it under the same
terms as Perl itself.
