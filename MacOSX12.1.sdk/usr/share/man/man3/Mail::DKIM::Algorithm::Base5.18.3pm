.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Mail::DKIM::Algorithm::Base 3"
.TH Mail::DKIM::Algorithm::Base 3 "2012-11-28" "perl v5.18.4" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Mail::DKIM::Algorithm::Base \- base class for DKIM "algorithms"
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 3
\&  my $algorithm = new Mail::DKIM::Algorithm::rsa_sha1(
\&                      Signature => $dkim_signature
\&                  );
\&
\&  # add headers
\&  $algorithm\->add_header("Subject: this is the subject\e015\e012");
\&  $algorithm\->finish_header;
\&
\&  # add body
\&  $algorithm\->add_body("This is the body.\e015\e012");
\&  $algorithm\->add_body("Another line of the body.\e015\e012");
\&  $algorithm\->finish_body;
\&
\&  # now sign or verify...
\&  # TODO...
.Ve
.SH "CONSTRUCTOR"
.IX Header "CONSTRUCTOR"
You should not create an object of this class directly. Instead, use one
of the \s-1DKIM\s0 algorithm implementation classes, such as rsa_sha1:
.PP
.Vb 3
\&  my $algorithm = new Mail::DKIM::Algorithm::rsa_sha1(
\&                      Signature => $dkim_signature
\&                  );
.Ve
.SH "METHODS"
.IX Header "METHODS"
.SS "\fIadd_body()\fP \- feeds part of the body into the algorithm/canonicalization"
.IX Subsection "add_body() - feeds part of the body into the algorithm/canonicalization"
.Vb 2
\&  $algorithm\->add_body("This is the body.\e015\e012");
\&  $algorithm\->add_body("Another line of the body.\e015\e012");
.Ve
.PP
The body should be fed one \*(L"line\*(R" at a time.
.SS "\fIadd_header()\fP \- feeds a header field into the algorithm/canonicalization"
.IX Subsection "add_header() - feeds a header field into the algorithm/canonicalization"
.Vb 1
\&  $algorithm\->add_header("Subject: this is the subject\e015\e012");
.Ve
.PP
The header must start with the header field name and continue through any
folded lines (including the embedded <\s-1CRLF\s0> sequences). It terminates with
the <\s-1CRLF\s0> at the end of the header field.
.SS "\fIfinish_body()\fP \- signals the end of the message body"
.IX Subsection "finish_body() - signals the end of the message body"
.Vb 1
\&  $algorithm\->finish_body
.Ve
.PP
Call this method when all lines from the body have been submitted.
After calling this method, use \fIsign()\fR or \fIverify()\fR to get the results
from the algorithm.
.SS "\fIfinish_header()\fP \- signals the end of the header field block"
.IX Subsection "finish_header() - signals the end of the header field block"
.Vb 1
\&  $algorithm\->finish_header;
.Ve
.PP
Call this method when all the headers have been submitted.
.SS "\fIsign()\fP \- generates a signature using a private key"
.IX Subsection "sign() - generates a signature using a private key"
.Vb 1
\&  $base64 = $algorithm\->sign($private_key);
.Ve
.SS "\fIsignature()\fP \- get/set the signature worked on by this algorithm"
.IX Subsection "signature() - get/set the signature worked on by this algorithm"
.Vb 2
\&  my $old_signature = $algorithm\->signature;
\&  $algorithm\->signature($new_signature);
.Ve
.SS "\fIverify()\fP \- verifies a signature"
.IX Subsection "verify() - verifies a signature"
.Vb 1
\&  $result = $algorithm\->verify();
.Ve
.PP
Must be called after \fIfinish_body()\fR.
.PP
The result is a true/false value: true indicates the signature data
is valid, false indicates it is invalid.
.PP
For an invalid signature, details may be obtained from
\&\f(CW$algorithm\fR\->{verification_details} or $@.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Mail::DKIM
.SH "AUTHOR"
.IX Header "AUTHOR"
Jason Long, <jlong@messiah.edu>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright (C) 2005\-2007 by Messiah College
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself, either Perl version 5.8.6 or,
at your option, any later version of Perl 5 you may have available.
