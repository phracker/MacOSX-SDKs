.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Parse::Eyapp::MatchingTrees 3"
.TH Parse::Eyapp::MatchingTrees 3 "2012-03-23" "perl v5.18.4" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Parse::Eyapp::treematchingtut \- Tree Matching and Tree substitution: an introduction
.SH "TREE MATCHING AND TREE SUBSTITUTION"
.IX Header "TREE MATCHING AND TREE SUBSTITUTION"
Most of the examples in this section can be found in the directory
\&\f(CW\*(C`examples/MatchingTrees\*(C'\fR that comes with the distribution of Parse::Eyapp.
.SS "Matching Trees"
.IX Subsection "Matching Trees"
Both the transformation objects in \f(CW\*(C`Parse::Eyapp::YATW\*(C'\fR
and the nodes in \f(CW\*(C`Parse::Eyapp::Node\*(C'\fR have a method 
named \f(CW\*(C`m\*(C'\fR for matching. 
For a \f(CW\*(C`Parse::Eyapp::YATW\*(C'\fR object, the method \-when called
in a list context\- returns a list of 
\&\f(CW\*(C`Parse::Eyapp::Node::Match\*(C'\fR nodes.
.PP
.Vb 1
\&                    @R = $t\->m($yatw1, $yatw2, $yatw3, ...)
.Ve
.PP
A \f(CW\*(C`Parse::Eyapp::Node::Match\*(C'\fR 
object describes 
the nodes of the actual tree that have matched.
The nodes in the returned list are organized in a hierarchy.
They appear in the list 
sorted according to a depth-first visit of the actual tree \f(CW$t\fR.
In a scalar context \f(CW\*(C`m\*(C'\fR returns the first element of
the list.
.PP
Let us denote by \f(CW$t\fR the actual tree being searched
and \f(CW$r\fR one of the \f(CW\*(C`Parse::Eyapp::Node::Match\*(C'\fR
nodes in the resulting forest \f(CW@R\fR.
Then we have the following methods:
.IP "\(bu" 4
The method \f(CW\*(C`$r\->node\*(C'\fR return the node \f(CW$t\fR of the actual 
tree that matched
.IP "\(bu" 4
The method \f(CW\*(C`$r\->father\*(C'\fR returns the father of \f(CW$r\fR
in the matching forest.
The father of \f(CW$r\fR is defined by this property:
\&\f(CW\*(C`$r\->father\->node\*(C'\fR is the nearest ancestor of
\&\f(CW\*(C`$r\->node\*(C'\fR that matched with the treeregexp pattern.
That is, there is no ancestor that matched between
\&\f(CW\*(C`$r\->node\*(C'\fR and \f(CW\*(C`$r\->father\->node\*(C'\fR.
Otherwise \f(CW\*(C`$r\->father\*(C'\fR is \f(CW\*(C`undef\*(C'\fR
.IP "\(bu" 4
The method \f(CW\*(C`$r\->coord\*(C'\fR returns the coordinates of \f(CW\*(C`$r\->node\*(C'\fR 
relative to \f(CW$t\fR.
For example, the coordinate \f(CW".1.3.2"\fR 
denotes the node \f(CW\*(C`$t\->child(1)\->child(3)\->child(2)\*(C'\fR, where \f(CW$t\fR
is the root of the search.
.IP "\(bu" 4
The method \f(CW\*(C`$r\->depth\*(C'\fR returns the depth of \f(CW\*(C`$r\->node\*(C'\fR 
in \f(CW$t\fR.
.IP "\(bu" 4
When \f(CW\*(C`m\*(C'\fR was called as a \f(CW\*(C`Parse::Eyapp::Node\*(C'\fR method, i. e. 
with potentially more than one \f(CW\*(C`YATW\*(C'\fR treeregexp, the method \f(CW\*(C`$r\->names\*(C'\fR
returns the array of names of the transformations that matched with
\&\f(CW\*(C`$r\->node\*(C'\fR.
.PP
\fIUse of \f(CI\*(C`m\*(C'\fI as a Parse::Eyapp::Node Method\fR
.IX Subsection "Use of m as a Parse::Eyapp::Node Method"
.PP
The example in \f(CW\*(C`examples/MatchingTrees/m2.pl\*(C'\fR shows the use of \f(CW\*(C`m\*(C'\fR as
a \f(CW\*(C`Parse::Eyapp::Node\*(C'\fR method.
.PP
.Vb 10
\&  examples/MatchingTrees$ cat \-n m2.pl
\&     1  #!/usr/bin/perl \-w
\&     2  use strict;
\&     3  use Rule6;
\&     4  use Parse::Eyapp::Treeregexp;
\&     5
\&     6  Parse::Eyapp::Treeregexp\->new( STRING => q{
\&     7    fold: /TIMES|PLUS|DIV|MINUS/(NUM, NUM)
\&     8    zxw: TIMES(NUM($x), .) and { $x\->{attr} == 0 }
\&     9    wxz: TIMES(., NUM($x)) and { $x\->{attr} == 0 }
\&    10  })\->generate();
\&    11
\&    12  # Syntax analysis
\&    13  my $parser = new Rule6();
\&    14  my $input = "0*0*0";
\&    15  my $t = $parser\->Run(\e$input);
\&    16  print "Tree:",$t\->str,"\en";
\&    17
\&    18  # Search
\&    19  my $m = $t\->m(our ($fold, $zxw, $wxz));
\&    20  print "Match Node:\en",$m\->str,"\en";
.Ve
.PP
When executed with input \f(CW\*(C`0*0*0\*(C'\fR the program generates this output:
.PP
.Vb 4
\&  examples/MatchingTrees$ m2.pl
\&  Tree:TIMES(TIMES(NUM(TERMINAL),NUM(TERMINAL)),NUM(TERMINAL))
\&  Match Node:
\&  Match[[TIMES:0:wxz]](Match[[TIMES:1:fold,zxw,wxz]])
.Ve
.PP
The representation of \f(CW\*(C`Match\*(C'\fR nodes by \f(CW\*(C`str\*(C'\fR deserves a comment.
\&\f(CW\*(C`Match\*(C'\fR nodes have their own \f(CW\*(C`info\*(C'\fR method. It returns a string
containing the concatenation of the class of \f(CW\*(C`$r\->node\*(C'\fR 
(i.e. the actual node that matched), the depth
(\f(CW\*(C`$r\->depth\*(C'\fR) and the names of the transformations
that matched (as provided by the method \f(CW\*(C`$r\->names\*(C'\fR)
.PP
\fIUse of \f(CI\*(C`m\*(C'\fI as a Parse::Eyapp::YATW Method\fR
.IX Subsection "Use of m as a Parse::Eyapp::YATW Method"
.PP
A second example can be found 
inside the file \f(CW\*(C`examples/typechecking/Simple\-Types\-XXX.tar.gz\*(C'\fR.
It illustrates a use of \f(CW\*(C`m\*(C'\fR as 
a \f(CW\*(C`Parse::Eyapp:YATW\*(C'\fR method.
It solves a problem of scope analysis in a C compiler:
matching each \f(CW\*(C`RETURN\*(C'\fR statement with the function
that surrounds it. The parsing was already done, the 
\&\s-1AST\s0 was built and left in \f(CW$t\fR. The treeregexp used 
(see \f(CW\*(C`lib/Simple/Trans.trg\*(C'\fR) is:
.PP
.Vb 1
\&  retscope: /FUNCTION|RETURN/
.Ve
.PP
and the code that solves the problem (see
subroutine \f(CW\*(C`compile\*(C'\fR in file \f(CW\*(C`lib/Simple/Types.eyp\*(C'\fR
is:
.PP
.Vb 10
\& # Associate each "return exp" with its "function"
\& my @returns = $retscope\->m($t); 
\& for (@returns) {
\&   my $node = $_\->node;
\&   if (ref($node) eq \*(AqRETURN\*(Aq) {
\&     my $function = $_\->father\->node; 
\&     $node\->{function}  = $function;  
\&     $node\->{t} = $function\->{t};
\&   }
\& }
.Ve
.PP
The first line gets a list of \f(CW\*(C`Parse::Eyapp::Node::Match\*(C'\fR nodes 
describing  the actual nodes that matched \f(CW\*(C`/FUNCTION|RETURN/\*(C'\fR. 
If the node described by \f(CW$_\fR is a \f(CW\*(AqRETURN\*(Aq\fR node,
the expresion \f(CW\*(C` $_\->father\->node\*(C'\fR must necessarily point
to the function node that encloses it.
.ie n .SS "The ""SEVERITY"" option of ""Parse::Eyapp::Treeregexp::new"""
.el .SS "The \f(CWSEVERITY\fP option of \f(CWParse::Eyapp::Treeregexp::new\fP"
.IX Subsection "The SEVERITY option of Parse::Eyapp::Treeregexp::new"
The \f(CW\*(C`SEVERITY\*(C'\fR option of \f(CW\*(C`Parse::Eyapp::Treeregexp::new\*(C'\fR controls the
way matching succeeds regarding the number of children.
To illustrate its use let us consider the following example.
The grammar used \f(CW\*(C`Rule6.yp\*(C'\fR is similar
to the example in the section \*(L"\s-1SYNOPSIS\*(R"\s0 in Parse::Eyapp::Node.
.PP
.Vb 10
\&  examples/MatchingTrees$ cat \-n numchildren.pl
\&     1  #!/usr/bin/perl \-w
\&     2  use strict;
\&     3  use Rule6;
\&     4  use Parse::Eyapp::Treeregexp;
\&     5
\&     6  sub TERMINAL::info { $_[0]{attr} }
\&     7
\&     8  my $severity = shift || 0;
\&     9  my $input = shift || \*(Aq0*2\*(Aq;
\&    10
\&    11  my $parser = new Rule6();
\&    12  my $t = $parser\->Run(\e$input);
\&    13
\&    14  my $transform = Parse::Eyapp::Treeregexp\->new(
\&    15    STRING => q{
\&    16      zero_times_whatever: TIMES(NUM($x)) and { $x\->{attr} == 0 } => { $_[0] = $NUM }
\&    17    },
\&    18    SEVERITY => $severity,
\&    19    FIRSTLINE => 14,
\&    20  )\->generate;
\&    21
\&    22  $t\->s(our @all);
\&    23
\&    24  print $t\->str,"\en";
.Ve
.PP
The program gets the severity level from the command line (line 9).
The specification of the term \f(CW\*(C`TIMES(NUM($x))\*(C'\fR inside the
transformation \f(CW\*(C`zero_times_whatever\*(C'\fR does not
clearly state that \f(CW\*(C`TIMES\*(C'\fR must have two children.
There are several interpretations of the treregexp depending
on the level fixed for \f(CW\*(C`SEVERITY\*(C'\fR:
.IP "\(bu" 4
0: \f(CW\*(C`TIMES\*(C'\fR must have at least one child. Don't care if it has more.
.IP "\(bu" 4
1: \f(CW\*(C`TIMES\*(C'\fR must have exactly one child.
.IP "\(bu" 4
2: \f(CW\*(C`TIMES\*(C'\fR must have exactly one child. When visit a 
\&\f(CW\*(C`TIMES\*(C'\fR node with a different number of children issue a warning.
.IP "\(bu" 4
3: \f(CW\*(C`TIMES\*(C'\fR must have exactly one child.  When visit a
\&\f(CW\*(C`TIMES\*(C'\fR node with a different number of children issue an
error.
.PP
Observe the change in behavior according to the level of \f(CW\*(C`SEVERITY\*(C'\fR:
.PP
.Vb 12
\&  pl@nereida:~/LEyapp/examples/MatchingTrees$ numchildren.pl 0 \*(Aq0*2\*(Aq
\&  NUM(TERMINAL[0])
\&  pl@nereida:~/LEyapp/examples/MatchingTrees$ numchildren.pl 1 \*(Aq0*2\*(Aq
\&  TIMES(NUM(TERMINAL[0]),NUM(TERMINAL[2]))
\&  pl@nereida:~/LEyapp/examples/MatchingTrees$ numchildren.pl 2 \*(Aq0*2\*(Aq
\&  Warning! found node TIMES with 2 children.
\&  Expected 1 children (see line 15 of ./numchildren.pl)"
\&  TIMES(NUM(TERMINAL[0]),NUM(TERMINAL[2]))
\&  pl@nereida:~/LEyapp/examples/MatchingTrees$ numchildren.pl 3 \*(Aq0*2\*(Aq
\&  Error! found node TIMES with 2 children.
\&  Expected 1 children (see line 15 of ./numchildren.pl)"
\&   at (eval 3) line 29
.Ve
.ie n .SS "Tree Substitution: The ""s"" methods"
.el .SS "Tree Substitution: The \f(CWs\fP methods"
.IX Subsection "Tree Substitution: The s methods"
Both \f(CW\*(C`Parse::Eyapp:Node\*(C'\fR and \f(CW\*(C`Parse::Eyapp::YATW\*(C'\fR objects (i.e.
nodes and tree transformations) are provided with a \f(CW\*(C`s\*(C'\fR method.
.PP
In the case of a \f(CW\*(C`Parse::Eyapp::YATW\*(C'\fR object the method \f(CW\*(C`s\*(C'\fR
applies the tree transformation using a single bottom-up traversing:
the transformation is recursively applied to the children and 
then to the current node.
.PP
For \f(CW\*(C`Parse::Eyapp:Node\*(C'\fR nodes the set of transformations is applied
to each node until no transformation matches any more.
The example in the section \*(L"\s-1SYNOPSIS\*(R"\s0 in Parse::Eyapp::Node illustrates the use:
.PP
.Vb 10
\&  1  # Let us transform the tree. Define the tree\-regular expressions ..
\&  2  my $p = Parse::Eyapp::Treeregexp\->new( STRING => q{
\&  3    { #  Example of support code
\&  4      my %Op = (PLUS=>\*(Aq+\*(Aq, MINUS => \*(Aq\-\*(Aq, TIMES=>\*(Aq*\*(Aq, DIV => \*(Aq/\*(Aq);
\&  5    }
\&  6    constantfold: /TIMES|PLUS|DIV|MINUS/:bin(NUM($x), NUM($y))
\&  7      => {
\&  8        my $op = $Op{ref($_[0])};
\&  9        $x\->{attr} = eval  "$x\->{attr} $op $y\->{attr}";
\& 10        $_[0] = $NUM[0];
\& 11      }
\& 12    uminus: UMINUS(NUM($x)) => { $x\->{attr} = \-$x\->{attr}; $_[0] = $NUM }
\& 13    zero_times_whatever: TIMES(NUM($x), .) and { $x\->{attr} == 0 } => { $_[0] = $NUM }
\& 14    whatever_times_zero: TIMES(., NUM($x)) and { $x\->{attr} == 0 } => { $_[0] = $NUM }
\& 15    },
\& 16    OUTPUTFILE=> \*(Aqmain.pm\*(Aq
\& 17  );
\& 18  $p\->generate(); # Create the tranformations
\& 19 
\& 20  $t\->s($uminus); # Transform UMINUS nodes
\& 21  $t\->s(@all);    # constant folding and mult. by zero
.Ve
.PP
The call at line 20 can be substituted by \f(CW\*(C`$uminus\->s($t)\*(C'\fR
without changes.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.IP "\(bu" 4
The project home is at <http://code.google.com/p/parse\-eyapp/>.
Use a subversion client to anonymously check out the latest project source code:
.Sp
.Vb 1
\&   svn checkout http://parse\-eyapp.googlecode.com/svn/trunk/ parse\-eyapp\-read\-only
.Ve
.IP "\(bu" 4
The tutorial \fIParsing Strings and Trees with\fR \f(CW\*(C`Parse::Eyapp\*(C'\fR
(An Introduction to Compiler Construction in seven pages) in
<http://nereida.deioc.ull.es/~pl/eyapsimple/>
.IP "\(bu" 4
Parse::Eyapp, 
Parse::Eyapp::eyapplanguageref, 
Parse::Eyapp::debuggingtut,
Parse::Eyapp::defaultactionsintro,
Parse::Eyapp::translationschemestut,
Parse::Eyapp::Driver,
Parse::Eyapp::Node,
Parse::Eyapp::YATW,
Parse::Eyapp::Treeregexp,
Parse::Eyapp::Scope,
Parse::Eyapp::Base,
Parse::Eyapp::datagenerationtut
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/languageintro.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/debuggingtut.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/eyapplanguageref.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/Treeregexp.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/Node.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/YATW.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/Eyapp.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/Base.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/translationschemestut.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/treematchingtut.pdf>
.IP "\(bu" 4
perldoc eyapp,
.IP "\(bu" 4
perldoc treereg,
.IP "\(bu" 4
perldoc vgg,
.IP "\(bu" 4
The Syntax Highlight file for vim at <http://www.vim.org/scripts/script.php?script_id=2453>
and <http://nereida.deioc.ull.es/~vim/>
.IP "\(bu" 4
\&\fIAnalisis Lexico y Sintactico\fR, (Notes for a course in compiler 
construction) by  Casiano Rodriguez-Leon. 
Available at  <http://nereida.deioc.ull.es/~pl/perlexamples/>
Is the more complete and reliable source for Parse::Eyapp. However is in Spanish.
.IP "\(bu" 4
Parse::Yapp,
.IP "\(bu" 4
Man pages of \fIyacc\fR\|(1) and
\&\fIbison\fR\|(1),
<http://www.delorie.com/gnu/docs/bison/bison.html>
.IP "\(bu" 4
Language::AttributeGrammar
.IP "\(bu" 4
Parse::RecDescent.
.IP "\(bu" 4
HOP::Parser
.IP "\(bu" 4
HOP::Lexer
.IP "\(bu" 4
ocamlyacc tutorial at 
<http://plus.kaist.ac.kr/~shoh/ocaml/ocamllex\-ocamlyacc/ocamlyacc\-tutorial/ocamlyacc\-tutorial.html>
.SH "REFERENCES"
.IX Header "REFERENCES"
.IP "\(bu" 4
The classic Dragon's book \fICompilers: Principles, Techniques, and Tools\fR 
by Alfred V. Aho, Ravi Sethi and
Jeffrey D. Ullman (Addison-Wesley 1986)
.IP "\(bu" 4
\&\fI\s-1CS2121:\s0 The Implementation and Power of Programming Languages\fR
(See <http://www.cs.man.ac.uk/~pjj>, <http://www.cs.man.ac.uk/~pjj/complang/g2lr.html> 
and <http://www.cs.man.ac.uk/~pjj/cs2121/ho/ho.html>) by 
Pete Jinks
.SH "CONTRIBUTORS"
.IX Header "CONTRIBUTORS"
.IP "\(bu" 2
Hal Finkel <http://www.halssoftware.com/>
.IP "\(bu" 2
G. Williams <http://kasei.us/>
.IP "\(bu" 2
Thomas L. Shinnick <http://search.cpan.org/~tshinnic/>
.IP "\(bu" 2
Frank Leray
.SH "AUTHOR"
.IX Header "AUTHOR"
Casiano Rodriguez-Leon (casiano@ull.es)
.SH "ACKNOWLEDGMENTS"
.IX Header "ACKNOWLEDGMENTS"
This work has been supported by \s-1CEE \s0(\s-1FEDER\s0) and the Spanish Ministry of
\&\fIEducacion y Ciencia\fR through \fIPlan Nacional I+D+I\fR number \s-1TIN2005\-08818\-C04\-04
\&\s0(\s-1ULL::OPLINK\s0 project <http://www.oplink.ull.es/>). 
Support from Gobierno de Canarias was through \s-1GC02210601
\&\s0(\fIGrupos Consolidados\fR).
The University of La Laguna has also supported my work in many ways
and for many years.
.PP
A large percentage of  code is verbatim taken from Parse::Yapp 1.05.
The author of Parse::Yapp is Francois Desarmenien.
.PP
I wish to thank Francois Desarmenien for his Parse::Yapp module, 
to my students at La Laguna and to the Perl Community. Thanks to 
the people who have contributed to improve the module (see \*(L"\s-1CONTRIBUTORS\*(R"\s0 in Parse::Eyapp).
Thanks to Larry Wall for giving us Perl.
Special thanks to Juana.
.SH "LICENCE AND COPYRIGHT"
.IX Header "LICENCE AND COPYRIGHT"
Copyright (c) 2006\-2008 Casiano Rodriguez-Leon (casiano@ull.es). All rights reserved.
.PP
Parse::Yapp copyright is of Francois Desarmenien, all rights reserved. 1998\-2001
.PP
These modules are free software; you can redistribute it and/or
modify it under the same terms as Perl itself. See perlartistic.
.PP
This program is distributed in the hope that it will be useful,
but \s-1WITHOUT ANY WARRANTY\s0; without even the implied warranty of
\&\s-1MERCHANTABILITY\s0 or \s-1FITNESS FOR A PARTICULAR PURPOSE. \s0
