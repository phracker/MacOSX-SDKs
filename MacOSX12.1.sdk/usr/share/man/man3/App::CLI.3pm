.\" Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "App::CLI 3"
.TH App::CLI 3 "2018-05-14" "perl v5.30.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
App::CLI \- Dispatcher module for command line interface programs
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 4
\&    package MyApp;
\&    use base \*(AqApp::CLI\*(Aq;        # the DISPATCHER of your App
\&                                # it\*(Aqs not necessary to put the dispatcher
\&                                # on the top level of your App
\&
\&    package main;
\&
\&    MyApp\->dispatch;            # call the dispatcher where you want
\&
\&
\&    package MyApp::List;
\&    use base qw(App::CLI::Command); # any (SUB)COMMAND of your App
\&
\&    use constant options => (
\&        "h|help"   => "help",
\&        "verbose"  => "verbose",
\&        \*(Aqn|name=s\*(Aq  => \*(Aqname\*(Aq,
\&    );
\&
\&    use constant subcommands => qw(User Nickname type); # if you want subcommands
\&                                                        # automatically dispatch to subcommands
\&                                                        # when invoke $ myapp list [user|nickname|\-\-type]
\&                                                        # note \*(Aqtype\*(Aq is not capitalized
\&                                                        # it is a deprecated subcommand
\&
\&    sub run {
\&        my ($self, @args) = @_;
\&
\&        print "verbose" if $self\->{verbose};
\&        my $name = $self\->{name}; # get arg following long option \-\-name
\&
\&        if ($self\->{help}) {
\&            # if $ myapp list \-\-help or $ myapp list \-h
\&            # only output PODs
\&        } else {
\&            # do something when invoking $ myapp list
\&            # without subcommand and \-\-help
\&        }
\&    }
\&
\&
\&    package MyApp::List::User;
\&    use base qw(App::CLI::Command);
\&    use constant options => (
\&        "h|help"  =>  "help",
\&    );
\&
\&    sub run {
\&        my ($self,@args) = @_;
\&        # code for listing user
\&    }
\&
\&
\&    pakcage MyApp::List::Nickname;
\&    use base qw(App::CLI::Command);
\&    use constant options => (
\&        "sort=s"  =>  "sort",
\&    );
\&
\&    sub run {
\&        my ($self,@args) = @_;
\&        # code for listing nickname
\&    }
\&
\&
\&    package MyApp::List::type;   # old genre of subcommand could not cascade infinitely
\&    use base qw(MyApp::List);    # should inherit its parent\*(Aqs command
\&
\&    sub run {
\&        my ($self, @args);
\&        # run to here when invoking $ myapp list \-\-type
\&    }
\&
\&
\&    package MyApp::Help;
\&    use base \*(AqApp::CLI::Command::Help\*(Aq;
\&
\&    use constant options => (
\&        \*(Aqverbose\*(Aq => \*(Aqverbose\*(Aq,
\&    );
\&
\&    sub run {
\&        my ($self, @arg) = @_;
\&        # do something
\&        $self\->SUPER(@_); # App::CLI::Command::Help would output POD of each command
\&    }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\f(CW\*(C`App::CLI\*(C'\fR dispatches \s-1CLI\s0 (command line interface) based commands
into command classes.  It also supports subcommand and per-command
options.
.SS "Methods"
.IX Subsection "Methods"
\fIget_opt([@config], \f(CI%opt_map\fI)\fR
.IX Subsection "get_opt([@config], %opt_map)"
.PP
Give options map, processed by Getopt::Long::Parser.
.PP
\fIdispatch(@args)\fR
.IX Subsection "dispatch(@args)"
.PP
Interface of dispatcher
.PP
\fIcmd_map($cmd)\fR
.IX Subsection "cmd_map($cmd)"
.PP
Find the name of the package implementing the requested command.
.PP
The command is first searched for in \f(CW\*(C`alias\*(C'\fR. If the alias exists and points
to a package name starting with the \f(CW\*(C`+\*(C'\fR sign, then that package name (minus
the \f(CW\*(C`+\*(C'\fR sign) is returned. This makes it possible to map commands to arbitrary
packages.
.PP
Otherwise, the package is searched for in the result of calling \f(CW\*(C`commands\*(C'\fR,
and a package name is constructed by upper-casing the first character of the
command name, and appending it to the package name of the app itself.
.PP
If both of these fail, and the command does not map to any package name,
\&\f(CW\*(C`undef\*(C'\fR is returned instead.
.PP
\fIget_cmd($cmd, \f(CI@arg\fI)\fR
.IX Subsection "get_cmd($cmd, @arg)"
.PP
Return subcommand of first level via \f(CW$ARGV[0]\fR.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.IP "\(bu" 4
App::CLI::Command
.IP "\(bu" 4
Getopt::Long
.SH "AUTHORS"
.IX Header "AUTHORS"
.IP "\(bu" 4
Chia-liang Kao <clkao@clkao.org>
.IP "\(bu" 4
Alex Vandiver  <alexmv@bestpractical.com>
.IP "\(bu" 4
Yo-An Lin      <cornelius.howl@gmail.com>
.IP "\(bu" 4
Shelling       <navyblueshellingford@gmail.com>
.IP "\(bu" 4
Paul Cochrane  <paul@liekut.de> (current maintainer)
.SH "CONTRIBUTORS"
.IX Header "CONTRIBUTORS"
The following people have contributed patches to the project:
.IP "\(bu" 4
José Joaquín Atria <jjatria@gmail.com>
.IP "\(bu" 4
sunnavy            <sunnavy@gmail.com>
.IP "\(bu" 4
Ildar Shaimordanov <ildar.shaimordanov@gmail.com>
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright 2005\-2010 by Chia-liang Kao <clkao@clkao.org>.
Copyright 2010 by Yo-An Lin <cornelius.howl@gmail.com>
and Shelling <navyblueshellingford@gmail.com>.
Copyright 2017\-2018 by Paul Cochrane <paul@liekut.de>
.PP
This program is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.
.PP
See <http://www.perl.com/perl/misc/Artistic.html>
