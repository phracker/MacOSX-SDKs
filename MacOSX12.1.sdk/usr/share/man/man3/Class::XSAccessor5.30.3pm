.\" Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Class::XSAccessor 3"
.TH Class::XSAccessor 3 "2013-11-22" "perl v5.30.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Class::XSAccessor \- Generate fast XS accessors without runtime compilation
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 10
\&  package MyClass;
\&  use Class::XSAccessor
\&    replace     => 1,   # Replace existing methods (if any)
\&    constructor => \*(Aqnew\*(Aq,
\&    getters     => {
\&      get_foo => \*(Aqfoo\*(Aq, # \*(Aqfoo\*(Aq is the hash key to access
\&      get_bar => \*(Aqbar\*(Aq,
\&    },
\&    setters => {
\&      set_foo => \*(Aqfoo\*(Aq,
\&      set_bar => \*(Aqbar\*(Aq,
\&    },
\&    accessors => {
\&      foo => \*(Aqfoo\*(Aq,
\&      bar => \*(Aqbar\*(Aq,
\&    },
\&    # "predicates" is an alias for "defined_predicates"
\&    defined_predicates => {
\&      defined_foo => \*(Aqfoo\*(Aq,
\&      defined_bar => \*(Aqbar\*(Aq,
\&    },
\&    exists_predicates => {
\&      has_foo => \*(Aqfoo\*(Aq,
\&      has_bar => \*(Aqbar\*(Aq,
\&    },
\&    lvalue_accessors => { # see below
\&      baz => \*(Aqbaz\*(Aq, # ...
\&    },
\&    true  => [ \*(Aqis_token\*(Aq, \*(Aqis_whitespace\*(Aq ],
\&    false => [ \*(Aqsignificant\*(Aq ];
\&  
\&  # The imported methods are implemented in fast XS.
\&  
\&  # normal class code here.
.Ve
.PP
As of version 1.05, some alternative syntax forms are available:
.PP
.Vb 1
\&  package MyClass;
\&  
\&  # Options can be passed as a HASH reference, if preferred,
\&  # which can also help Perl::Tidy to format the statement correctly.
\&  use Class::XSAccessor {
\&     # If the name => key values are always identical,
\&     # the following shorthand can be used.
\&     accessors => [ \*(Aqfoo\*(Aq, \*(Aqbar\*(Aq ],
\&  };
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Class::XSAccessor implements fast read, write and read/write accessors in \s-1XS.\s0
Additionally, it can provide predicates such as \f(CW\*(C`has_foo()\*(C'\fR for testing
whether the attribute \f(CW\*(C`foo\*(C'\fR exists in the object (which is different from
\&\*(L"is defined within the object\*(R").
It only works with objects that are implemented as ordinary hashes.
Class::XSAccessor::Array implements the same interface for objects
that use arrays for their internal representation.
.PP
Since version 0.10, the module can also generate simple constructors
(implemented in \s-1XS\s0). Simply supply the
\&\f(CW\*(C`constructor => \*(Aqconstructor_name\*(Aq\*(C'\fR option or the
\&\f(CW\*(C`constructors => [\*(Aqnew\*(Aq, \*(Aqcreate\*(Aq, \*(Aqspawn\*(Aq]\*(C'\fR option.
These constructors do the equivalent of the following Perl code:
.PP
.Vb 4
\&  sub new {
\&    my $class = shift;
\&    return bless { @_ }, ref($class)||$class;
\&  }
.Ve
.PP
That means they can be called on objects and classes but will not
clone objects entirely. Parameters to \f(CW\*(C`new()\*(C'\fR are added to the
object.
.PP
The \s-1XS\s0 accessor methods are between 3 and 4 times faster than typical
pure-Perl accessors in some simple benchmarking.
The lower factor applies to the potentially slightly obscure
\&\f(CW\*(C`sub set_foo_pp {$_[0]\->{foo} = $_[1]}\*(C'\fR, so if you usually
write clear code, a factor of 3.5 speed-up is a good estimate.
If in doubt, do your own benchmarking!
.PP
The method names may be fully qualified. The example in the synopsis could
have been written as \f(CW\*(C`MyClass::get_foo\*(C'\fR instead
of \f(CW\*(C`get_foo\*(C'\fR. This way, methods can be installed in classes other
than the current class. See also: the \f(CW\*(C`class\*(C'\fR option below.
.PP
By default, the setters return the new value that was set,
and the accessors (mutators) do the same. This behaviour can be changed
with the \f(CW\*(C`chained\*(C'\fR option \- see below. The predicates return a boolean.
.PP
Since version 1.01, \f(CW\*(C`Class::XSAccessor\*(C'\fR can generate extremely simple methods which
just return true or false (and always do so). If that seems like a
really superfluous thing to you, then consider a large class hierarchy
with interfaces such as \s-1PPI\s0. These methods are provided by the \f(CW\*(C`true\*(C'\fR
and \f(CW\*(C`false\*(C'\fR options \- see the synopsis.
.PP
\&\f(CW\*(C`defined_predicates\*(C'\fR check whether a given object attribute is defined.
\&\f(CW\*(C`predicates\*(C'\fR is an alias for \f(CW\*(C`defined_predicates\*(C'\fR for compatibility with
older versions of \f(CW\*(C`Class::XSAccessor\*(C'\fR. \f(CW\*(C`exists_predicates\*(C'\fR checks
whether the given attribute exists in the object using \f(CW\*(C`exists\*(C'\fR.
.SH "OPTIONS"
.IX Header "OPTIONS"
In addition to specifying the types and names of accessors, additional options
can be supplied which modify behaviour. The options are specified as key/value pairs
in the same manner as the accessor declaration. For example:
.PP
.Vb 5
\&  use Class::XSAccessor
\&    getters => {
\&      get_foo => \*(Aqfoo\*(Aq,
\&    },
\&    replace => 1;
.Ve
.PP
The list of available options is:
.SS "replace"
.IX Subsection "replace"
Set this to a true value to prevent \f(CW\*(C`Class::XSAccessor\*(C'\fR from
complaining about replacing existing subroutines.
.SS "chained"
.IX Subsection "chained"
Set this to a true value to change the return value of setters
and mutators (when called with an argument).
If \f(CW\*(C`chained\*(C'\fR is enabled, the setters and accessors/mutators will
return the object. Mutators called without an argument still
return the value of the associated attribute.
.PP
As with the other options, \f(CW\*(C`chained\*(C'\fR affects all methods generated
in the same \f(CW\*(C`use Class::XSAccessor ...\*(C'\fR statement.
.SS "class"
.IX Subsection "class"
By default, the accessors are generated in the calling class. The
the \f(CW\*(C`class\*(C'\fR option allows the target class to be specified.
.SH "LVALUES"
.IX Header "LVALUES"
Support for lvalue accessors via the keyword \f(CW\*(C`lvalue_accessors\*(C'\fR
was added in version 1.08. At this point, \fB\s-1THEY ARE CONSIDERED HIGHLY
EXPERIMENTAL\s0\fR. Furthermore, their performance hasn't been benchmarked
yet.
.PP
The following example demonstrates an lvalue accessor:
.PP
.Vb 4
\&  package Address;
\&  use Class::XSAccessor
\&    constructor => \*(Aqnew\*(Aq,
\&    lvalue_accessors => { zip_code => \*(Aqzip\*(Aq };
\&  
\&  package main;
\&  my $address = Address\->new(zip => 2);
\&  print $address\->zip_code, "\en"; # prints 2
\&  $address\->zip_code = 76135; # <\-\-\- This is it!
\&  print $address\->zip_code, "\en"; # prints 76135
.Ve
.SH "CAVEATS"
.IX Header "CAVEATS"
Probably won't work for objects based on \fItied\fR hashes. But that's a strange thing to do anyway.
.PP
Scary code exploiting strange \s-1XS\s0 features.
.PP
If you think writing an accessor in \s-1XS\s0 should be a laughably simple exercise, then
please contemplate how you could instantiate a new \s-1XS\s0 accessor for a new hash key
that's only known at run-time. Note that compiling C code at run-time a la Inline::C
is a no go.
.PP
Threading. With version 1.00, a memory leak has been \fBfixed\fR. Previously, a small amount of
memory would leak if \f(CW\*(C`Class::XSAccessor\*(C'\fR\-based classes were loaded in a subthread without having
been loaded in the \*(L"main\*(R" thread. If the subthread then terminated, a hash key and an int per
associated method used to be lost. Note that this mattered only if classes were \fBonly\fR loaded
in a sort of throw-away thread.
.PP
In the new implementation, as of 1.00, the memory will still not be released, in the same situation,
but it will be recycled when the same class, or a similar class, is loaded again in \fBany\fR thread.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.IP "\(bu" 4
Class::XSAccessor::Array
.IP "\(bu" 4
AutoXS
.SH "AUTHOR"
.IX Header "AUTHOR"
Steffen Mueller <smueller@cpan.org>
.PP
chocolateboy <chocolate@cpan.org>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright (C) 2008, 2009, 2010, 2011, 2012, 2013 by Steffen Mueller
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself, either Perl version 5.8 or,
at your option, any later version of Perl 5 you may have available.
