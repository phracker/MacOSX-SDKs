.\" Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Class::MOP::Class 3"
.TH Class::MOP::Class 3 "2019-11-22" "perl v5.30.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Class::MOP::Class \- Class Meta Object
.SH "VERSION"
.IX Header "VERSION"
version 2.2012
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&  # assuming that class Foo
\&  # has been defined, you can
\&
\&  # use this for introspection ...
\&
\&  # add a method to Foo ...
\&  Foo\->meta\->add_method( \*(Aqbar\*(Aq => sub {...} )
\&
\&  # get a list of all the classes searched
\&  # the method dispatcher in the correct order
\&  Foo\->meta\->class_precedence_list()
\&
\&  # remove a method from Foo
\&  Foo\->meta\->remove_method(\*(Aqbar\*(Aq);
\&
\&  # or use this to actually create classes ...
\&
\&  Class::MOP::Class\->create(
\&      \*(AqBar\*(Aq => (
\&          version      => \*(Aq0.01\*(Aq,
\&          superclasses => [\*(AqFoo\*(Aq],
\&          attributes   => [
\&              Class::MOP::Attribute\->new(\*(Aq$bar\*(Aq),
\&              Class::MOP::Attribute\->new(\*(Aq$baz\*(Aq),
\&          ],
\&          methods => {
\&              calculate_bar => sub {...},
\&              construct_baz => sub {...}
\&          }
\&      )
\&  );
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The Class Protocol is the largest and most complex part of the
Class::MOP meta-object protocol. It controls the introspection and
manipulation of Perl 5 classes, and it can create them as well. The
best way to understand what this module can do is to read the
documentation for each of its methods.
.SH "INHERITANCE"
.IX Header "INHERITANCE"
\&\f(CW\*(C`Class::MOP::Class\*(C'\fR is a subclass of Class::MOP::Module.
.SH "METHODS"
.IX Header "METHODS"
.SS "Class construction"
.IX Subsection "Class construction"
These methods all create new \f(CW\*(C`Class::MOP::Class\*(C'\fR objects. These
objects can represent existing classes or they can be used to create
new classes from scratch.
.PP
The metaclass object for a given class is a singleton. If you attempt
to create a metaclass for the same class twice, you will just get the
existing object.
.IP "\fBClass::MOP::Class\->create($package_name, \f(CB%options\fB)\fR" 4
.IX Item "Class::MOP::Class->create($package_name, %options)"
This method creates a new \f(CW\*(C`Class::MOP::Class\*(C'\fR object with the given
package name. It accepts a number of options:
.RS 4
.IP "\(bu" 8
version
.Sp
An optional version number for the newly created package.
.IP "\(bu" 8
authority
.Sp
An optional authority for the newly created package.
See \*(L"authority\*(R" in Class::MOP::Module for more details.
.IP "\(bu" 8
superclasses
.Sp
An optional array reference of superclass names.
.IP "\(bu" 8
methods
.Sp
An optional hash reference of methods for the class. The keys of the
hash reference are method names and values are subroutine references.
.IP "\(bu" 8
attributes
.Sp
An optional array reference of Class::MOP::Attribute objects.
.IP "\(bu" 8
meta_name
.Sp
Specifies the name to install the \f(CW\*(C`meta\*(C'\fR method for this class under.
If it is not passed, \f(CW\*(C`meta\*(C'\fR is assumed, and if \f(CW\*(C`undef\*(C'\fR is explicitly
given, no meta method will be installed.
.IP "\(bu" 8
weaken
.Sp
If true, the metaclass that is stored in the global cache will be a
weak reference.
.Sp
Classes created in this way are destroyed once the metaclass they are
attached to goes out of scope, and will be removed from Perl's internal
symbol table.
.Sp
All instances of a class with a weakened metaclass keep a special
reference to the metaclass object, which prevents the metaclass from
going out of scope while any instances exist.
.Sp
This only works if the instance is based on a hash reference, however.
.RE
.RS 4
.RE
.IP "\fBClass::MOP::Class\->create_anon_class(%options)\fR" 4
.IX Item "Class::MOP::Class->create_anon_class(%options)"
This method works just like \f(CW\*(C`Class::MOP::Class\->create\*(C'\fR but it
creates an \*(L"anonymous\*(R" class. In fact, the class does have a name, but
that name is a unique name generated internally by this module.
.Sp
It accepts the same \f(CW\*(C`superclasses\*(C'\fR, \f(CW\*(C`methods\*(C'\fR, and \f(CW\*(C`attributes\*(C'\fR
parameters that \f(CW\*(C`create\*(C'\fR accepts.
.Sp
It also accepts a \f(CW\*(C`cache\*(C'\fR option. If this is \f(CW\*(C`true\*(C'\fR, then the anonymous class
will be cached based on its superclasses and roles. If an existing anonymous
class in the cache has the same superclasses and roles, it will be reused.
.Sp
Anonymous classes default to \f(CW\*(C`weaken => 1\*(C'\fR if cache is \f(CW\*(C`false\*(C'\fR, although
this can be overridden.
.IP "\fBClass::MOP::Class\->initialize($package_name, \f(CB%options\fB)\fR" 4
.IX Item "Class::MOP::Class->initialize($package_name, %options)"
This method will initialize a \f(CW\*(C`Class::MOP::Class\*(C'\fR object for the
named package. Unlike \f(CW\*(C`create\*(C'\fR, this method \fIwill not\fR create a new
class.
.Sp
The purpose of this method is to retrieve a \f(CW\*(C`Class::MOP::Class\*(C'\fR
object for introspecting an existing class.
.Sp
If an existing \f(CW\*(C`Class::MOP::Class\*(C'\fR object exists for the named
package, it will be returned, and any options provided will be
ignored!
.Sp
If the object does not yet exist, it will be created.
.Sp
The valid options that can be passed to this method are
\&\f(CW\*(C`attribute_metaclass\*(C'\fR, \f(CW\*(C`method_metaclass\*(C'\fR,
\&\f(CW\*(C`wrapped_method_metaclass\*(C'\fR, and \f(CW\*(C`instance_metaclass\*(C'\fR. These are all
optional, and default to the appropriate class in the \f(CW\*(C`Class::MOP\*(C'\fR
distribution.
.SS "Object instance construction and cloning"
.IX Subsection "Object instance construction and cloning"
These methods are all related to creating and/or cloning object
instances.
.IP "\fB\f(CB$metaclass\fB\->clone_object($instance, \f(CB%params\fB)\fR" 4
.IX Item "$metaclass->clone_object($instance, %params)"
This method clones an existing object instance. Any parameters you
provide are will override existing attribute values in the object.
.Sp
This is a convenience method for cloning an object instance, then
blessing it into the appropriate package.
.Sp
You could implement a clone method in your class, using this method:
.Sp
.Vb 4
\&  sub clone {
\&      my ($self, %params) = @_;
\&      $self\->meta\->clone_object($self, %params);
\&  }
.Ve
.IP "\fB\f(CB$metaclass\fB\->rebless_instance($instance, \f(CB%params\fB)\fR" 4
.IX Item "$metaclass->rebless_instance($instance, %params)"
This method changes the class of \f(CW$instance\fR to the metaclass's class.
.Sp
You can only rebless an instance into a subclass of its current
class. If you pass any additional parameters, these will be treated
like constructor parameters and used to initialize the object's
attributes. Any existing attributes that are already set will be
overwritten.
.Sp
Before reblessing the instance, this method will call
\&\f(CW\*(C`rebless_instance_away\*(C'\fR on the instance's current metaclass. This method
will be passed the instance, the new metaclass, and any parameters
specified to \f(CW\*(C`rebless_instance\*(C'\fR. By default, \f(CW\*(C`rebless_instance_away\*(C'\fR
does nothing; it is merely a hook.
.IP "\fB\f(CB$metaclass\fB\->rebless_instance_back($instance)\fR" 4
.IX Item "$metaclass->rebless_instance_back($instance)"
Does the same thing as \f(CW\*(C`rebless_instance\*(C'\fR, except that you can only
rebless an instance into one of its superclasses. Any attributes that
do not exist in the superclass will be deinitialized.
.Sp
This is a much more dangerous operation than \f(CW\*(C`rebless_instance\*(C'\fR,
especially when multiple inheritance is involved, so use this carefully!
.IP "\fB\f(CB$metaclass\fB\->new_object(%params)\fR" 4
.IX Item "$metaclass->new_object(%params)"
This method is used to create a new object of the metaclass's
class. Any parameters you provide are used to initialize the
instance's attributes. A special \f(CW\*(C`_\|_INSTANCE_\|_\*(C'\fR key can be passed to
provide an already generated instance, rather than having Class::MOP
generate it for you. This is mostly useful for using Class::MOP with
foreign classes which generate instances using their own constructors.
.IP "\fB\f(CB$metaclass\fB\->instance_metaclass\fR" 4
.IX Item "$metaclass->instance_metaclass"
Returns the class name of the instance metaclass. See
Class::MOP::Instance for more information on the instance
metaclass.
.IP "\fB\f(CB$metaclass\fB\->get_meta_instance\fR" 4
.IX Item "$metaclass->get_meta_instance"
Returns an instance of the \f(CW\*(C`instance_metaclass\*(C'\fR to be used in the
construction of a new instance of the class.
.SS "Informational predicates"
.IX Subsection "Informational predicates"
These are a few predicate methods for asking information about the
class itself.
.IP "\fB\f(CB$metaclass\fB\->is_anon_class\fR" 4
.IX Item "$metaclass->is_anon_class"
This returns true if the class was created by calling \f(CW\*(C`Class::MOP::Class\->create_anon_class\*(C'\fR.
.IP "\fB\f(CB$metaclass\fB\->is_mutable\fR" 4
.IX Item "$metaclass->is_mutable"
This returns true if the class is still mutable.
.IP "\fB\f(CB$metaclass\fB\->is_immutable\fR" 4
.IX Item "$metaclass->is_immutable"
This returns true if the class has been made immutable.
.IP "\fB\f(CB$metaclass\fB\->is_pristine\fR" 4
.IX Item "$metaclass->is_pristine"
A class is \fInot\fR pristine if it has non-inherited attributes or if it
has any generated methods.
.SS "Inheritance Relationships"
.IX Subsection "Inheritance Relationships"
.IP "\fB\f(CB$metaclass\fB\->superclasses(@superclasses)\fR" 4
.IX Item "$metaclass->superclasses(@superclasses)"
This is a read-write accessor which represents the superclass
relationships of the metaclass's class.
.Sp
This is basically sugar around getting and setting \f(CW@ISA\fR.
.IP "\fB\f(CB$metaclass\fB\->class_precedence_list\fR" 4
.IX Item "$metaclass->class_precedence_list"
This returns a list of all of the class's ancestor classes. The
classes are returned in method dispatch order.
.IP "\fB\f(CB$metaclass\fB\->linearized_isa\fR" 4
.IX Item "$metaclass->linearized_isa"
This returns a list based on \f(CW\*(C`class_precedence_list\*(C'\fR but with all
duplicates removed.
.IP "\fB\f(CB$metaclass\fB\->subclasses\fR" 4
.IX Item "$metaclass->subclasses"
This returns a list of all subclasses for this class, even indirect
subclasses.
.IP "\fB\f(CB$metaclass\fB\->direct_subclasses\fR" 4
.IX Item "$metaclass->direct_subclasses"
This returns a list of immediate subclasses for this class, which does not
include indirect subclasses.
.SS "Method introspection and creation"
.IX Subsection "Method introspection and creation"
These methods allow you to introspect a class's methods, as well as
add, remove, or change methods.
.PP
Determining what is truly a method in a Perl 5 class requires some
heuristics (aka guessing).
.PP
Methods defined outside the package with a fully qualified name (\f(CW\*(C`sub
Package::name { ... }\*(C'\fR) will be included. Similarly, methods named
with a fully qualified name using Sub::Name are also included.
.PP
However, we attempt to ignore imported functions.
.PP
Ultimately, we are using heuristics to determine what truly is a
method in a class, and these heuristics may get the wrong answer in
some edge cases. However, for most \*(L"normal\*(R" cases the heuristics work
correctly.
.IP "\fB\f(CB$metaclass\fB\->get_method($method_name)\fR" 4
.IX Item "$metaclass->get_method($method_name)"
This will return a Class::MOP::Method for the specified
\&\f(CW$method_name\fR. If the class does not have the specified method, it
returns \f(CW\*(C`undef\*(C'\fR
.IP "\fB\f(CB$metaclass\fB\->has_method($method_name)\fR" 4
.IX Item "$metaclass->has_method($method_name)"
Returns a boolean indicating whether or not the class defines the
named method. It does not include methods inherited from parent
classes.
.IP "\fB\f(CB$metaclass\fB\->get_method_list\fR" 4
.IX Item "$metaclass->get_method_list"
This will return a list of method \fInames\fR for all methods defined in
this class.
.IP "\fB\f(CB$metaclass\fB\->add_method($method_name, \f(CB$method\fB)\fR" 4
.IX Item "$metaclass->add_method($method_name, $method)"
This method takes a method name and a subroutine reference, and adds
the method to the class.
.Sp
The subroutine reference can be a Class::MOP::Method, and you are
strongly encouraged to pass a meta method object instead of a code
reference. If you do so, that object gets stored as part of the
class's method map directly. If not, the meta information will have to
be recreated later, and may be incorrect.
.Sp
If you provide a method object, this method will clone that object if
the object's package name does not match the class name. This lets us
track the original source of any methods added from other classes
(notably Moose roles).
.IP "\fB\f(CB$metaclass\fB\->remove_method($method_name)\fR" 4
.IX Item "$metaclass->remove_method($method_name)"
Remove the named method from the class. This method returns the
Class::MOP::Method object for the method.
.IP "\fB\f(CB$metaclass\fB\->method_metaclass\fR" 4
.IX Item "$metaclass->method_metaclass"
Returns the class name of the method metaclass, see
Class::MOP::Method for more information on the method metaclass.
.IP "\fB\f(CB$metaclass\fB\->wrapped_method_metaclass\fR" 4
.IX Item "$metaclass->wrapped_method_metaclass"
Returns the class name of the wrapped method metaclass, see
Class::MOP::Method::Wrapped for more information on the wrapped
method metaclass.
.IP "\fB\f(CB$metaclass\fB\->get_all_methods\fR" 4
.IX Item "$metaclass->get_all_methods"
This will traverse the inheritance hierarchy and return a list of all
the Class::MOP::Method objects for this class and its parents.
.IP "\fB\f(CB$metaclass\fB\->find_method_by_name($method_name)\fR" 4
.IX Item "$metaclass->find_method_by_name($method_name)"
This will return a Class::MOP::Method for the specified
\&\f(CW$method_name\fR. If the class does not have the specified method, it
returns \f(CW\*(C`undef\*(C'\fR
.Sp
Unlike \f(CW\*(C`get_method\*(C'\fR, this method \fIwill\fR look for the named method in
superclasses.
.IP "\fB\f(CB$metaclass\fB\->get_all_method_names\fR" 4
.IX Item "$metaclass->get_all_method_names"
This will return a list of method \fInames\fR for all of this class's
methods, including inherited methods.
.IP "\fB\f(CB$metaclass\fB\->find_all_methods_by_name($method_name)\fR" 4
.IX Item "$metaclass->find_all_methods_by_name($method_name)"
This method looks for the named method in the class and all of its
parents. It returns every matching method it finds in the inheritance
tree, so it returns a list of methods.
.Sp
Each method is returned as a hash reference with three keys. The keys
are \f(CW\*(C`name\*(C'\fR, \f(CW\*(C`class\*(C'\fR, and \f(CW\*(C`code\*(C'\fR. The \f(CW\*(C`code\*(C'\fR key has a
Class::MOP::Method object as its value.
.Sp
The list of methods is distinct.
.IP "\fB\f(CB$metaclass\fB\->find_next_method_by_name($method_name)\fR" 4
.IX Item "$metaclass->find_next_method_by_name($method_name)"
This method returns the first method in any superclass matching the
given name. It is effectively the method that \f(CW\*(C`SUPER::$method_name\*(C'\fR
would dispatch to.
.SS "Attribute introspection and creation"
.IX Subsection "Attribute introspection and creation"
Because Perl 5 does not have a core concept of attributes in classes,
we can only return information about attributes which have been added
via this class's methods. We cannot discover information about
attributes which are defined in terms of \*(L"regular\*(R" Perl 5 methods.
.IP "\fB\f(CB$metaclass\fB\->get_attribute($attribute_name)\fR" 4
.IX Item "$metaclass->get_attribute($attribute_name)"
This will return a Class::MOP::Attribute for the specified
\&\f(CW$attribute_name\fR. If the class does not have the specified
attribute, it returns \f(CW\*(C`undef\*(C'\fR.
.Sp
\&\s-1NOTE\s0 that get_attribute does not search superclasses, for that you
need to use \f(CW\*(C`find_attribute_by_name\*(C'\fR.
.IP "\fB\f(CB$metaclass\fB\->has_attribute($attribute_name)\fR" 4
.IX Item "$metaclass->has_attribute($attribute_name)"
Returns a boolean indicating whether or not the class defines the
named attribute. It does not include attributes inherited from parent
classes.
.IP "\fB\f(CB$metaclass\fB\->get_attribute_list\fR" 4
.IX Item "$metaclass->get_attribute_list"
This will return a list of attributes \fInames\fR for all attributes
defined in this class.  Note that this operates on the current class
only, it does not traverse the inheritance hierarchy.
.IP "\fB\f(CB$metaclass\fB\->get_all_attributes\fR" 4
.IX Item "$metaclass->get_all_attributes"
This will traverse the inheritance hierarchy and return a list of all
the Class::MOP::Attribute objects for this class and its parents.
.IP "\fB\f(CB$metaclass\fB\->find_attribute_by_name($attribute_name)\fR" 4
.IX Item "$metaclass->find_attribute_by_name($attribute_name)"
This will return a Class::MOP::Attribute for the specified
\&\f(CW$attribute_name\fR. If the class does not have the specified
attribute, it returns \f(CW\*(C`undef\*(C'\fR.
.Sp
Unlike \f(CW\*(C`get_attribute\*(C'\fR, this attribute \fIwill\fR look for the named
attribute in superclasses.
.IP "\fB\f(CB$metaclass\fB\->add_attribute(...)\fR" 4
.IX Item "$metaclass->add_attribute(...)"
This method accepts either an existing Class::MOP::Attribute
object or parameters suitable for passing to that class's \f(CW\*(C`new\*(C'\fR
method.
.Sp
The attribute provided will be added to the class.
.Sp
Any accessor methods defined by the attribute will be added to the
class when the attribute is added.
.Sp
If an attribute of the same name already exists, the old attribute
will be removed first.
.IP "\fB\f(CB$metaclass\fB\->remove_attribute($attribute_name)\fR" 4
.IX Item "$metaclass->remove_attribute($attribute_name)"
This will remove the named attribute from the class, and
Class::MOP::Attribute object.
.Sp
Removing an attribute also removes any accessor methods defined by the
attribute.
.Sp
However, note that removing an attribute will only affect \fIfuture\fR
object instances created for this class, not existing instances.
.IP "\fB\f(CB$metaclass\fB\->attribute_metaclass\fR" 4
.IX Item "$metaclass->attribute_metaclass"
Returns the class name of the attribute metaclass for this class. By
default, this is Class::MOP::Attribute.
.SS "Overload introspection and creation"
.IX Subsection "Overload introspection and creation"
These methods provide an \s-1API\s0 to the core overload functionality.
.IP "\fB\f(CB$metaclass\fB\->is_overloaded\fR" 4
.IX Item "$metaclass->is_overloaded"
Returns true if overloading is enabled for this class. Corresponds to
\&\*(L"is_overloaded\*(R" in Devel::OverloadInfo.
.IP "\fB\f(CB$metaclass\fB\->get_overloaded_operator($op)\fR" 4
.IX Item "$metaclass->get_overloaded_operator($op)"
Returns the Class::MOP::Overload object corresponding to the operator named
\&\f(CW$op\fR, if one exists for this class.
.IP "\fB\f(CB$metaclass\fB\->has_overloaded_operator($op)\fR" 4
.IX Item "$metaclass->has_overloaded_operator($op)"
Returns whether or not the operator \f(CW$op\fR is overloaded for this class.
.IP "\fB\f(CB$metaclass\fB\->get_overload_list\fR" 4
.IX Item "$metaclass->get_overload_list"
Returns a list of operator names which have been overloaded (see
\&\*(L"Overloadable Operations\*(R" in overload for the list of valid operator names).
.IP "\fB\f(CB$metaclass\fB\->get_all_overloaded_operators\fR" 4
.IX Item "$metaclass->get_all_overloaded_operators"
Returns a list of Class::MOP::Overload objects corresponding to the
operators that have been overloaded.
.IP "\fB\f(CB$metaclass\fB\->add_overloaded_operator($op, \f(CB$impl\fB)\fR" 4
.IX Item "$metaclass->add_overloaded_operator($op, $impl)"
Overloads the operator \f(CW$op\fR for this class. The \f(CW$impl\fR can be a coderef, a
method name, or a Class::MOP::Overload object. Corresponds to
\&\f(CW\*(C`use overload $op => $impl;\*(C'\fR
.IP "\fB\f(CB$metaclass\fB\->remove_overloaded_operator($op)\fR" 4
.IX Item "$metaclass->remove_overloaded_operator($op)"
Remove overloading for operator \f(CW$op\fR. Corresponds to \f(CW\*(C`no overload $op;\*(C'\fR
.IP "\fB\f(CB$metaclass\fB\->get_overload_fallback_value\fR" 4
.IX Item "$metaclass->get_overload_fallback_value"
Returns the overload \f(CW\*(C`fallback\*(C'\fR setting for the package.
.IP "\fB\f(CB$metaclass\fB\->set_overload_fallback_value($fallback)\fR" 4
.IX Item "$metaclass->set_overload_fallback_value($fallback)"
Sets the overload \f(CW\*(C`fallback\*(C'\fR setting for the package.
.SS "Class Immutability"
.IX Subsection "Class Immutability"
Making a class immutable \*(L"freezes\*(R" the class definition. You can no
longer call methods which alter the class, such as adding or removing
methods or attributes.
.PP
Making a class immutable lets us optimize the class by inlining some
methods, and also allows us to optimize some methods on the metaclass
object itself.
.PP
After immutabilization, the metaclass object will cache most informational
methods that returns information about methods or attributes. Methods which
would alter the class, such as \f(CW\*(C`add_attribute\*(C'\fR and \f(CW\*(C`add_method\*(C'\fR, will
throw an error on an immutable metaclass object.
.PP
The immutabilization system in Moose takes much greater advantage
of the inlining features than Class::MOP itself does.
.IP "\fB\f(CB$metaclass\fB\->make_immutable(%options)\fR" 4
.IX Item "$metaclass->make_immutable(%options)"
This method will create an immutable transformer and use it to make
the class and its metaclass object immutable, and returns true
(you should not rely on the details of this value apart from its truth).
.Sp
This method accepts the following options:
.RS 4
.IP "\(bu" 8
inline_accessors
.IP "\(bu" 8
inline_constructor
.IP "\(bu" 8
inline_destructor
.Sp
These are all booleans indicating whether the specified method(s)
should be inlined.
.Sp
By default, accessors and the constructor are inlined, but not the
destructor.
.IP "\(bu" 8
immutable_trait
.Sp
The name of a class which will be used as a parent class for the
metaclass object being made immutable. This \*(L"trait\*(R" implements the
post-immutability functionality of the metaclass (but not the
transformation itself).
.Sp
This defaults to Class::MOP::Class::Immutable::Trait.
.IP "\(bu" 8
constructor_name
.Sp
This is the constructor method name. This defaults to \*(L"new\*(R".
.IP "\(bu" 8
constructor_class
.Sp
The name of the method metaclass for constructors. It will be used to
generate the inlined constructor. This defaults to
\&\*(L"Class::MOP::Method::Constructor\*(R".
.IP "\(bu" 8
replace_constructor
.Sp
This is a boolean indicating whether an existing constructor should be
replaced when inlining a constructor. This defaults to false.
.IP "\(bu" 8
destructor_class
.Sp
The name of the method metaclass for destructors. It will be used to
generate the inlined destructor. This defaults to
\&\*(L"Class::MOP::Method::Denstructor\*(R".
.IP "\(bu" 8
replace_destructor
.Sp
This is a boolean indicating whether an existing destructor should be
replaced when inlining a destructor. This defaults to false.
.RE
.RS 4
.RE
.IP "\fB\f(CB$metaclass\fB\->immutable_options\fR" 4
.IX Item "$metaclass->immutable_options"
Returns a hash of the options used when making the class immutable, including
both defaults and anything supplied by the user in the call to \f(CW\*(C`$metaclass\->make_immutable\*(C'\fR. This is useful if you need to temporarily make
a class mutable and then restore immutability as it was before.
.IP "\fB\f(CB$metaclass\fB\->make_mutable\fR" 4
.IX Item "$metaclass->make_mutable"
Calling this method reverse the immutabilization transformation.
.SS "Method Modifiers"
.IX Subsection "Method Modifiers"
Method modifiers are hooks which allow a method to be wrapped with
\&\fIbefore\fR, \fIafter\fR and \fIaround\fR method modifiers. Every time a
method is called, its modifiers are also called.
.PP
A class can modify its own methods, as well as methods defined in
parent classes.
.PP
\fIHow method modifiers work?\fR
.IX Subsection "How method modifiers work?"
.PP
Method modifiers work by wrapping the original method and then
replacing it in the class's symbol table. The wrappers will handle
calling all the modifiers in the appropriate order and preserving the
calling context for the original method.
.PP
The return values of \f(CW\*(C`before\*(C'\fR and \f(CW\*(C`after\*(C'\fR modifiers are
ignored. This is because their purpose is \fBnot\fR to filter the input
and output of the primary method (this is done with an \fIaround\fR
modifier).
.PP
This may seem like an odd restriction to some, but doing this allows
for simple code to be added at the beginning or end of a method call
without altering the function of the wrapped method or placing any
extra responsibility on the code of the modifier.
.PP
Of course if you have more complex needs, you can use the \f(CW\*(C`around\*(C'\fR
modifier which allows you to change both the parameters passed to the
wrapped method, as well as its return value.
.PP
Before and around modifiers are called in last-defined-first-called
order, while after modifiers are called in first-defined-first-called
order. So the call tree might looks something like this:
.PP
.Vb 9
\&  before 2
\&   before 1
\&    around 2
\&     around 1
\&      primary
\&     around 1
\&    around 2
\&   after 1
\&  after 2
.Ve
.PP
\fIWhat is the performance impact?\fR
.IX Subsection "What is the performance impact?"
.PP
Of course there is a performance cost associated with method
modifiers, but we have made every effort to make that cost directly
proportional to the number of modifier features you use.
.PP
The wrapping method does its best to \fBonly\fR do as much work as it
absolutely needs to. In order to do this we have moved some of the
performance costs to set-up time, where they are easier to amortize.
.PP
All this said, our benchmarks have indicated the following:
.PP
.Vb 5
\&  simple wrapper with no modifiers             100% slower
\&  simple wrapper with simple before modifier   400% slower
\&  simple wrapper with simple after modifier    450% slower
\&  simple wrapper with simple around modifier   500\-550% slower
\&  simple wrapper with all 3 modifiers          1100% slower
.Ve
.PP
These numbers may seem daunting, but you must remember, every feature
comes with some cost. To put things in perspective, just doing a
simple \f(CW\*(C`AUTOLOAD\*(C'\fR which does nothing but extract the name of the
method called and return it costs about 400% over a normal method
call.
.IP "\fB\f(CB$metaclass\fB\->add_before_method_modifier($method_name, \f(CB$code\fB)\fR" 4
.IX Item "$metaclass->add_before_method_modifier($method_name, $code)"
This wraps the specified method with the supplied subroutine
reference. The modifier will be called as a method itself, and will
receive the same arguments as are passed to the method.
.Sp
When the modifier exits, the wrapped method will be called.
.Sp
The return value of the modifier will be ignored.
.IP "\fB\f(CB$metaclass\fB\->add_after_method_modifier($method_name, \f(CB$code\fB)\fR" 4
.IX Item "$metaclass->add_after_method_modifier($method_name, $code)"
This wraps the specified method with the supplied subroutine
reference. The modifier will be called as a method itself, and will
receive the same arguments as are passed to the method.
.Sp
When the wrapped methods exits, the modifier will be called.
.Sp
The return value of the modifier will be ignored.
.IP "\fB\f(CB$metaclass\fB\->add_around_method_modifier($method_name, \f(CB$code\fB)\fR" 4
.IX Item "$metaclass->add_around_method_modifier($method_name, $code)"
This wraps the specified method with the supplied subroutine
reference.
.Sp
The first argument passed to the modifier will be a subroutine
reference to the wrapped method. The second argument is the object,
and after that come any arguments passed when the method is called.
.Sp
The around modifier can choose to call the original method, as well as
what arguments to pass if it does so.
.Sp
The return value of the modifier is what will be seen by the caller.
.SS "Introspection"
.IX Subsection "Introspection"
.IP "\fBClass::MOP::Class\->meta\fR" 4
.IX Item "Class::MOP::Class->meta"
This will return a Class::MOP::Class instance for this class.
.Sp
It should also be noted that Class::MOP will actually bootstrap
this module by installing a number of attribute meta-objects into its
metaclass.
.SH "AUTHORS"
.IX Header "AUTHORS"
.IP "\(bu" 4
Stevan Little <stevan.little@iinteractive.com>
.IP "\(bu" 4
Dave Rolsky <autarch@urth.org>
.IP "\(bu" 4
Jesse Luehrs <doy@tozt.net>
.IP "\(bu" 4
Shawn M Moore <code@sartak.org>
.IP "\(bu" 4
יובל קוג'מן (Yuval Kogman) <nothingmuch@woobling.org>
.IP "\(bu" 4
Karen Etheridge <ether@cpan.org>
.IP "\(bu" 4
Florian Ragwitz <rafl@debian.org>
.IP "\(bu" 4
Hans Dieter Pearcey <hdp@weftsoar.net>
.IP "\(bu" 4
Chris Prather <chris@prather.org>
.IP "\(bu" 4
Matt S Trout <mst@shadowcat.co.uk>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is copyright (c) 2006 by Infinity Interactive, Inc.
.PP
This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.
