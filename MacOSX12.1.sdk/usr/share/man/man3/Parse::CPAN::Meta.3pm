.\" Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Parse::CPAN::Meta 3pm"
.TH Parse::CPAN::Meta 3pm "2019-10-21" "perl v5.30.3" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Parse::CPAN::Meta \- Parse META.yml and META.json CPAN metadata files
.SH "VERSION"
.IX Header "VERSION"
version 2.150010
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&    #############################################
\&    # In your file
\&
\&    \-\-\-
\&    name: My\-Distribution
\&    version: 1.23
\&    resources:
\&      homepage: "http://example.com/dist/My\-Distribution"
\&
\&
\&    #############################################
\&    # In your program
\&
\&    use Parse::CPAN::Meta;
\&
\&    my $distmeta = Parse::CPAN::Meta\->load_file(\*(AqMETA.yml\*(Aq);
\&
\&    # Reading properties
\&    my $name     = $distmeta\->{name};
\&    my $version  = $distmeta\->{version};
\&    my $homepage = $distmeta\->{resources}{homepage};
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\fBParse::CPAN::Meta\fR is a parser for \fI\s-1META\s0.json\fR and \fI\s-1META\s0.yml\fR files, using
\&\s-1JSON::PP\s0 and/or CPAN::Meta::YAML.
.PP
\&\fBParse::CPAN::Meta\fR provides three methods: \f(CW\*(C`load_file\*(C'\fR, \f(CW\*(C`load_json_string\*(C'\fR,
and \f(CW\*(C`load_yaml_string\*(C'\fR.  These will read and deserialize \s-1CPAN\s0 metafiles, and
are described below in detail.
.PP
\&\fBParse::CPAN::Meta\fR provides a legacy \s-1API\s0 of only two functions,
based on the \s-1YAML\s0 functions of the same name. Wherever possible,
identical calling semantics are used.  These may only be used with \s-1YAML\s0 sources.
.PP
All error reporting is done with exceptions (die'ing).
.PP
Note that \s-1META\s0 files are expected to be in \s-1UTF\-8\s0 encoding, only.  When
converted string data, it must first be decoded from \s-1UTF\-8.\s0
.SH "METHODS"
.IX Header "METHODS"
.SS "load_file"
.IX Subsection "load_file"
.Vb 1
\&  my $metadata_structure = Parse::CPAN::Meta\->load_file(\*(AqMETA.json\*(Aq);
\&
\&  my $metadata_structure = Parse::CPAN::Meta\->load_file(\*(AqMETA.yml\*(Aq);
.Ve
.PP
This method will read the named file and deserialize it to a data structure,
determining whether it should be \s-1JSON\s0 or \s-1YAML\s0 based on the filename.
The file will be read using the \*(L":utf8\*(R" \s-1IO\s0 layer.
.SS "load_yaml_string"
.IX Subsection "load_yaml_string"
.Vb 1
\&  my $metadata_structure = Parse::CPAN::Meta\->load_yaml_string($yaml_string);
.Ve
.PP
This method deserializes the given string of \s-1YAML\s0 and returns the first
document in it.  (\s-1CPAN\s0 metadata files should always have only one document.)
If the source was \s-1UTF\-8\s0 encoded, the string must be decoded before calling
\&\f(CW\*(C`load_yaml_string\*(C'\fR.
.SS "load_json_string"
.IX Subsection "load_json_string"
.Vb 1
\&  my $metadata_structure = Parse::CPAN::Meta\->load_json_string($json_string);
.Ve
.PP
This method deserializes the given string of \s-1JSON\s0 and the result.
If the source was \s-1UTF\-8\s0 encoded, the string must be decoded before calling
\&\f(CW\*(C`load_json_string\*(C'\fR.
.SS "load_string"
.IX Subsection "load_string"
.Vb 1
\&  my $metadata_structure = Parse::CPAN::Meta\->load_string($some_string);
.Ve
.PP
If you don't know whether a string contains \s-1YAML\s0 or \s-1JSON\s0 data, this method
will use some heuristics and guess.  If it can't tell, it assumes \s-1YAML.\s0
.SS "yaml_backend"
.IX Subsection "yaml_backend"
.Vb 1
\&  my $backend = Parse::CPAN::Meta\->yaml_backend;
.Ve
.PP
Returns the module name of the \s-1YAML\s0 serializer. See \*(L"\s-1ENVIRONMENT\*(R"\s0
for details.
.SS "json_backend"
.IX Subsection "json_backend"
.Vb 1
\&  my $backend = Parse::CPAN::Meta\->json_backend;
.Ve
.PP
Returns the module name of the \s-1JSON\s0 serializer.  If \f(CW\*(C`CPAN_META_JSON_BACKEND\*(C'\fR
is set, this will be whatever that's set to.  If not, this will either
be \s-1JSON::PP\s0 or \s-1JSON\s0.  If \f(CW\*(C`PERL_JSON_BACKEND\*(C'\fR is set,
this will return \s-1JSON\s0 as further delegation is handled by
the \s-1JSON\s0 module.  See \*(L"\s-1ENVIRONMENT\*(R"\s0 for details.
.SS "json_decoder"
.IX Subsection "json_decoder"
.Vb 1
\&  my $decoder = Parse::CPAN::Meta\->json_decoder;
.Ve
.PP
Returns the module name of the \s-1JSON\s0 decoder.  Unlike \*(L"json_backend\*(R", this
is not necessarily a full \s-1JSON\s0\-style module, but only something that will
provide a \f(CW\*(C`decode_json\*(C'\fR subroutine.  If \f(CW\*(C`CPAN_META_JSON_DECODER\*(C'\fR is set,
this will be whatever that's set to.  If not, this will be whatever has
been selected as \*(L"json_backend\*(R".  See \*(L"\s-1ENVIRONMENT\*(R"\s0 for more notes.
.SH "FUNCTIONS"
.IX Header "FUNCTIONS"
For maintenance clarity, no functions are exported by default.  These functions
are available for backwards compatibility only and are best avoided in favor of
\&\f(CW\*(C`load_file\*(C'\fR.
.SS "Load"
.IX Subsection "Load"
.Vb 1
\&  my @yaml = Parse::CPAN::Meta::Load( $string );
.Ve
.PP
Parses a string containing a valid \s-1YAML\s0 stream into a list of Perl data
structures.
.SS "LoadFile"
.IX Subsection "LoadFile"
.Vb 1
\&  my @yaml = Parse::CPAN::Meta::LoadFile( \*(AqMETA.yml\*(Aq );
.Ve
.PP
Reads the \s-1YAML\s0 stream from a file instead of a string.
.SH "ENVIRONMENT"
.IX Header "ENVIRONMENT"
.SS "\s-1CPAN_META_JSON_DECODER\s0"
.IX Subsection "CPAN_META_JSON_DECODER"
By default, \s-1JSON::PP\s0 will be used for deserializing \s-1JSON\s0 data.  If the
\&\f(CW\*(C`CPAN_META_JSON_DECODER\*(C'\fR environment variable exists, this is expected to
be the name of a loadable module that provides a \f(CW\*(C`decode_json\*(C'\fR subroutine,
which will then be used for deserialization.  Relying only on the existence
of said subroutine allows for maximum compatibility, since this \s-1API\s0 is
provided by all of \s-1JSON::PP\s0, \s-1JSON::XS\s0, Cpanel::JSON::XS,
JSON::MaybeXS, JSON::Tiny, and Mojo::JSON.
.SS "\s-1CPAN_META_JSON_BACKEND\s0"
.IX Subsection "CPAN_META_JSON_BACKEND"
By default, \s-1JSON::PP\s0 will be used for deserializing \s-1JSON\s0 data.  If the
\&\f(CW\*(C`CPAN_META_JSON_BACKEND\*(C'\fR environment variable exists, this is expected to
be the name of a loadable module that provides the \s-1JSON\s0 \s-1API,\s0 since
downstream code expects to be able to call \f(CW\*(C`new\*(C'\fR on this class.  As such,
while \s-1JSON::PP\s0, \s-1JSON::XS\s0, Cpanel::JSON::XS and JSON::MaybeXS will
work for this, to use Mojo::JSON or JSON::Tiny for decoding requires
setting \*(L"\s-1CPAN_META_JSON_DECODER\*(R"\s0.
.SS "\s-1PERL_JSON_BACKEND\s0"
.IX Subsection "PERL_JSON_BACKEND"
If the \f(CW\*(C`CPAN_META_JSON_BACKEND\*(C'\fR environment variable does not exist, and if
\&\f(CW\*(C`PERL_JSON_BACKEND\*(C'\fR environment variable exists, is true and is not
\&\*(L"\s-1JSON::PP\*(R",\s0 then the \s-1JSON\s0 module (version 2.5 or greater) will be loaded and
used to interpret \f(CW\*(C`PERL_JSON_BACKEND\*(C'\fR.  If \s-1JSON\s0 is not installed or is too
old, an exception will be thrown.  Note that at the time of writing, the only
useful values are 1, which will tell \s-1JSON\s0 to guess, or \s-1JSON::XS\s0 \- if
you want to use a newer \s-1JSON\s0 module, see \*(L"\s-1CPAN_META_JSON_BACKEND\*(R"\s0.
.SS "\s-1PERL_YAML_BACKEND\s0"
.IX Subsection "PERL_YAML_BACKEND"
By default, CPAN::Meta::YAML will be used for deserializing \s-1YAML\s0 data. If
the \f(CW\*(C`PERL_YAML_BACKEND\*(C'\fR environment variable is defined, then it is interpreted
as a module to use for deserialization.  The given module must be installed,
must load correctly and must implement the \f(CW\*(C`Load()\*(C'\fR function or an exception
will be thrown.
.SH "AUTHORS"
.IX Header "AUTHORS"
.IP "\(bu" 4
David Golden <dagolden@cpan.org>
.IP "\(bu" 4
Ricardo Signes <rjbs@cpan.org>
.IP "\(bu" 4
Adam Kennedy <adamk@cpan.org>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is copyright (c) 2010 by David Golden, Ricardo Signes, Adam Kennedy and Contributors.
.PP
This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.
