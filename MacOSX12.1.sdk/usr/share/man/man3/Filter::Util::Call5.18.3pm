.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Filter::Util::Call 3pm"
.TH Filter::Util::Call 3pm "2014-09-30" "perl v5.18.4" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Filter::Util::Call \- Perl Source Filter Utility Module
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use Filter::Util::Call ;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module provides you with the framework to write \fISource Filters\fR
in Perl.
.PP
An alternate interface to Filter::Util::Call is now available. See
Filter::Simple for more details.
.PP
A \fIPerl Source Filter\fR is implemented as a Perl module. The structure
of the module can take one of two broadly similar formats. To
distinguish between them, the first will be referred to as \fImethod
filter\fR and the second as \fIclosure filter\fR.
.PP
Here is a skeleton for the \fImethod filter\fR:
.PP
.Vb 1
\&    package MyFilter ;
\&
\&    use Filter::Util::Call ;
\&
\&    sub import
\&    {
\&        my($type, @arguments) = @_ ;
\&        filter_add([]) ;
\&    }
\&
\&    sub filter
\&    {
\&        my($self) = @_ ;
\&        my($status) ;
\&
\&        $status = filter_read() ;
\&        $status ;
\&    }
\&
\&    1 ;
.Ve
.PP
and this is the equivalent skeleton for the \fIclosure filter\fR:
.PP
.Vb 1
\&    package MyFilter ;
\&
\&    use Filter::Util::Call ;
\&
\&    sub import
\&    {
\&        my($type, @arguments) = @_ ;
\&
\&        filter_add(
\&            sub 
\&            {
\&                my($status) ;
\&                $status = filter_read() ;
\&                $status ;
\&            } )
\&    }
\&
\&    1 ;
.Ve
.PP
To make use of either of the two filter modules above, place the line
below in a Perl source file.
.PP
.Vb 1
\&    use MyFilter;
.Ve
.PP
In fact, the skeleton modules shown above are fully functional \fISource
Filters\fR, albeit fairly useless ones. All they does is filter the
source stream without modifying it at all.
.PP
As you can see both modules have a broadly similar structure. They both
make use of the \f(CW\*(C`Filter::Util::Call\*(C'\fR module and both have an \f(CW\*(C`import\*(C'\fR
method. The difference between them is that the \fImethod filter\fR
requires a \fIfilter\fR method, whereas the \fIclosure filter\fR gets the
equivalent of a \fIfilter\fR method with the anonymous sub passed to
\&\fIfilter_add\fR.
.PP
To make proper use of the \fIclosure filter\fR shown above you need to
have a good understanding of the concept of a \fIclosure\fR. See
perlref for more details on the mechanics of \fIclosures\fR.
.SS "\fBuse Filter::Util::Call\fP"
.IX Subsection "use Filter::Util::Call"
The following functions are exported by \f(CW\*(C`Filter::Util::Call\*(C'\fR:
.PP
.Vb 4
\&    filter_add()
\&    filter_read()
\&    filter_read_exact()
\&    filter_del()
.Ve
.SS "\fB\fP\f(BIimport()\fP\fB\fP"
.IX Subsection "import()"
The \f(CW\*(C`import\*(C'\fR method is used to create an instance of the filter. It is
called indirectly by Perl when it encounters the \f(CW\*(C`use MyFilter\*(C'\fR line
in a source file (See \*(L"import\*(R" in perlfunc for more details on
\&\f(CW\*(C`import\*(C'\fR).
.PP
It will always have at least one parameter automatically passed by Perl
\&\- this corresponds to the name of the package. In the example above it
will be \f(CW"MyFilter"\fR.
.PP
Apart from the first parameter, import can accept an optional list of
parameters. These can be used to pass parameters to the filter. For
example:
.PP
.Vb 1
\&    use MyFilter qw(a b c) ;
.Ve
.PP
will result in the \f(CW@_\fR array having the following values:
.PP
.Vb 4
\&    @_ [0] => "MyFilter"
\&    @_ [1] => "a"
\&    @_ [2] => "b"
\&    @_ [3] => "c"
.Ve
.PP
Before terminating, the \f(CW\*(C`import\*(C'\fR function must explicitly install the
filter by calling \f(CW\*(C`filter_add\*(C'\fR.
.PP
\&\fB\f(BIfilter_add()\fB\fR
.PP
The function, \f(CW\*(C`filter_add\*(C'\fR, actually installs the filter. It takes one
parameter which should be a reference. The kind of reference used will
dictate which of the two filter types will be used.
.PP
If a \s-1CODE\s0 reference is used then a \fIclosure filter\fR will be assumed.
.PP
If a \s-1CODE\s0 reference is not used, a \fImethod filter\fR will be assumed.
In a \fImethod filter\fR, the reference can be used to store context
information. The reference will be \fIblessed\fR into the package by
\&\f(CW\*(C`filter_add\*(C'\fR.
.PP
See the filters at the end of this documents for examples of using
context information using both \fImethod filters\fR and \fIclosure
filters\fR.
.SS "\fB\fP\f(BIfilter()\fP\fB and anonymous sub\fP"
.IX Subsection "filter() and anonymous sub"
Both the \f(CW\*(C`filter\*(C'\fR method used with a \fImethod filter\fR and the
anonymous sub used with a \fIclosure filter\fR is where the main
processing for the filter is done.
.PP
The big difference between the two types of filter is that the \fImethod
filter\fR uses the object passed to the method to store any context data,
whereas the \fIclosure filter\fR uses the lexical variables that are
maintained by the closure.
.PP
Note that the single parameter passed to the \fImethod filter\fR,
\&\f(CW$self\fR, is the same reference that was passed to \f(CW\*(C`filter_add\*(C'\fR
blessed into the filter's package. See the example filters later on for
details of using \f(CW$self\fR.
.PP
Here is a list of the common features of the anonymous sub and the
\&\f(CW\*(C`filter()\*(C'\fR method.
.ie n .IP "\fB\fB$_\fB\fR" 5
.el .IP "\fB\f(CB$_\fB\fR" 5
.IX Item "$_"
Although \f(CW$_\fR doesn't actually appear explicitly in the sample filters
above, it is implicitly used in a number of places.
.Sp
Firstly, when either \f(CW\*(C`filter\*(C'\fR or the anonymous sub are called, a local
copy of \f(CW$_\fR will automatically be created. It will always contain the
empty string at this point.
.Sp
Next, both \f(CW\*(C`filter_read\*(C'\fR and \f(CW\*(C`filter_read_exact\*(C'\fR will append any
source data that is read to the end of \f(CW$_\fR.
.Sp
Finally, when \f(CW\*(C`filter\*(C'\fR or the anonymous sub are finished processing,
they are expected to return the filtered source using \f(CW$_\fR.
.Sp
This implicit use of \f(CW$_\fR greatly simplifies the filter.
.ie n .IP "\fB\fB$status\fB\fR" 5
.el .IP "\fB\f(CB$status\fB\fR" 5
.IX Item "$status"
The status value that is returned by the user's \f(CW\*(C`filter\*(C'\fR method or
anonymous sub and the \f(CW\*(C`filter_read\*(C'\fR and \f(CW\*(C`read_exact\*(C'\fR functions take
the same set of values, namely:
.Sp
.Vb 3
\&    < 0  Error
\&    = 0  EOF
\&    > 0  OK
.Ve
.IP "\fBfilter_read\fR and \fBfilter_read_exact\fR" 5
.IX Item "filter_read and filter_read_exact"
These functions are used by the filter to obtain either a line or block
from the next filter in the chain or the actual source file if there
aren't any other filters.
.Sp
The function \f(CW\*(C`filter_read\*(C'\fR takes two forms:
.Sp
.Vb 2
\&    $status = filter_read() ;
\&    $status = filter_read($size) ;
.Ve
.Sp
The first form is used to request a \fIline\fR, the second requests a
\&\fIblock\fR.
.Sp
In line mode, \f(CW\*(C`filter_read\*(C'\fR will append the next source line to the
end of the \f(CW$_\fR scalar.
.Sp
In block mode, \f(CW\*(C`filter_read\*(C'\fR will append a block of data which is <=
\&\f(CW$size\fR to the end of the \f(CW$_\fR scalar. It is important to emphasise
the that \f(CW\*(C`filter_read\*(C'\fR will not necessarily read a block which is
\&\fIprecisely\fR \f(CW$size\fR bytes.
.Sp
If you need to be able to read a block which has an exact size, you can
use the function \f(CW\*(C`filter_read_exact\*(C'\fR. It works identically to
\&\f(CW\*(C`filter_read\*(C'\fR in block mode, except it will try to read a block which
is exactly \f(CW$size\fR bytes in length. The only circumstances when it
will not return a block which is \f(CW$size\fR bytes long is on \s-1EOF\s0 or
error.
.Sp
It is \fIvery\fR important to check the value of \f(CW$status\fR after \fIevery\fR
call to \f(CW\*(C`filter_read\*(C'\fR or \f(CW\*(C`filter_read_exact\*(C'\fR.
.IP "\fBfilter_del\fR" 5
.IX Item "filter_del"
The function, \f(CW\*(C`filter_del\*(C'\fR, is used to disable the current filter. It
does not affect the running of the filter. All it does is tell Perl not
to call filter any more.
.Sp
See \*(L"Example 4: Using filter_del\*(R" for details.
.SH "EXAMPLES"
.IX Header "EXAMPLES"
Here are a few examples which illustrate the key concepts \- as such
most of them are of little practical use.
.PP
The \f(CW\*(C`examples\*(C'\fR sub-directory has copies of all these filters
implemented both as \fImethod filters\fR and as \fIclosure filters\fR.
.SS "Example 1: A simple filter."
.IX Subsection "Example 1: A simple filter."
Below is a \fImethod filter\fR which is hard-wired to replace all
occurrences of the string \f(CW"Joe"\fR to \f(CW"Jim"\fR. Not particularly
Useful, but it is the first example and I wanted to keep it simple.
.PP
.Vb 1
\&    package Joe2Jim ;
\&
\&    use Filter::Util::Call ;
\&
\&    sub import
\&    {
\&        my($type) = @_ ;
\&
\&        filter_add(bless []) ;
\&    }
\&
\&    sub filter
\&    {
\&        my($self) = @_ ;
\&        my($status) ;
\&
\&        s/Joe/Jim/g
\&            if ($status = filter_read()) > 0 ;
\&        $status ;
\&    }
\&
\&    1 ;
.Ve
.PP
Here is an example of using the filter:
.PP
.Vb 2
\&    use Joe2Jim ;
\&    print "Where is Joe?\en" ;
.Ve
.PP
And this is what the script above will print:
.PP
.Vb 1
\&    Where is Jim?
.Ve
.SS "Example 2: Using the context"
.IX Subsection "Example 2: Using the context"
The previous example was not particularly useful. To make it more
general purpose we will make use of the context data and allow any
arbitrary \fIfrom\fR and \fIto\fR strings to be used. This time we will use a
\&\fIclosure filter\fR. To reflect its enhanced role, the filter is called
\&\f(CW\*(C`Subst\*(C'\fR.
.PP
.Vb 1
\&    package Subst ;
\&
\&    use Filter::Util::Call ;
\&    use Carp ;
\&
\&    sub import
\&    {
\&        croak("usage: use Subst qw(from to)")
\&            unless @_ == 3 ;
\&        my ($self, $from, $to) = @_ ;
\&        filter_add(
\&            sub 
\&            {
\&                my ($status) ;
\&                s/$from/$to/
\&                    if ($status = filter_read()) > 0 ;
\&                $status ;
\&            })
\&    }
\&    1 ;
.Ve
.PP
and is used like this:
.PP
.Vb 2
\&    use Subst qw(Joe Jim) ;
\&    print "Where is Joe?\en" ;
.Ve
.SS "Example 3: Using the context within the filter"
.IX Subsection "Example 3: Using the context within the filter"
Here is a filter which a variation of the \f(CW\*(C`Joe2Jim\*(C'\fR filter. As well as
substituting all occurrences of \f(CW"Joe"\fR to \f(CW"Jim"\fR it keeps a count
of the number of substitutions made in the context object.
.PP
Once \s-1EOF\s0 is detected (\f(CW$status\fR is zero) the filter will insert an
extra line into the source stream. When this extra line is executed it
will print a count of the number of substitutions actually made.
Note that \f(CW$status\fR is set to \f(CW1\fR in this case.
.PP
.Vb 1
\&    package Count ;
\&
\&    use Filter::Util::Call ;
\&
\&    sub filter
\&    {
\&        my ($self) = @_ ;
\&        my ($status) ;
\&
\&        if (($status = filter_read()) > 0 ) {
\&            s/Joe/Jim/g ;
\&            ++ $$self ;
\&        }
\&        elsif ($$self >= 0) { # EOF
\&            $_ = "print q[Made ${$self} substitutions\en]" ;
\&            $status = 1 ;
\&            $$self = \-1 ;
\&        }
\&
\&        $status ;
\&    }
\&
\&    sub import
\&    {
\&        my ($self) = @_ ;
\&        my ($count) = 0 ;
\&        filter_add(\e$count) ;
\&    }
\&
\&    1 ;
.Ve
.PP
Here is a script which uses it:
.PP
.Vb 3
\&    use Count ;
\&    print "Hello Joe\en" ;
\&    print "Where is Joe\en" ;
.Ve
.PP
Outputs:
.PP
.Vb 3
\&    Hello Jim
\&    Where is Jim
\&    Made 2 substitutions
.Ve
.SS "Example 4: Using filter_del"
.IX Subsection "Example 4: Using filter_del"
Another variation on a theme. This time we will modify the \f(CW\*(C`Subst\*(C'\fR
filter to allow a starting and stopping pattern to be specified as well
as the \fIfrom\fR and \fIto\fR patterns. If you know the \fIvi\fR editor, it is
the equivalent of this command:
.PP
.Vb 1
\&    :/start/,/stop/s/from/to/
.Ve
.PP
When used as a filter we want to invoke it like this:
.PP
.Vb 1
\&    use NewSubst qw(start stop from to) ;
.Ve
.PP
Here is the module.
.PP
.Vb 1
\&    package NewSubst ;
\&
\&    use Filter::Util::Call ;
\&    use Carp ;
\&
\&    sub import
\&    {
\&        my ($self, $start, $stop, $from, $to) = @_ ;
\&        my ($found) = 0 ;
\&        croak("usage: use Subst qw(start stop from to)")
\&            unless @_ == 5 ;
\&
\&        filter_add( 
\&            sub 
\&            {
\&                my ($status) ;
\&
\&                if (($status = filter_read()) > 0) {
\&
\&                    $found = 1
\&                        if $found == 0 and /$start/ ;
\&
\&                    if ($found) {
\&                        s/$from/$to/ ;
\&                        filter_del() if /$stop/ ;
\&                    }
\&
\&                }
\&                $status ;
\&            } )
\&
\&    }
\&
\&    1 ;
.Ve
.SH "Filter::Simple"
.IX Header "Filter::Simple"
If you intend using the Filter::Call functionality, I would strongly
recommend that you check out Damian Conway's excellent Filter::Simple
module. Damian's module provides a much cleaner interface than
Filter::Util::Call. Although it doesn't allow the fine control that
Filter::Util::Call does, it should be adequate for the majority of
applications. It's available at
.PP
.Vb 1
\&   http://search.cpan.org/dist/Filter\-Simple/
.Ve
.SH "AUTHOR"
.IX Header "AUTHOR"
Paul Marquess
.SH "DATE"
.IX Header "DATE"
26th January 1996
