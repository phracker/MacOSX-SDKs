.\" Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Net::HTTP 3"
.TH Net::HTTP 3 "2019-05-16" "perl v5.30.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Net::HTTP \- Low\-level HTTP connection (client)
.SH "VERSION"
.IX Header "VERSION"
version 6.19
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 4
\& use Net::HTTP;
\& my $s = Net::HTTP\->new(Host => "www.perl.com") || die $@;
\& $s\->write_request(GET => "/", \*(AqUser\-Agent\*(Aq => "Mozilla/5.0");
\& my($code, $mess, %h) = $s\->read_response_headers;
\&
\& while (1) {
\&    my $buf;
\&    my $n = $s\->read_entity_body($buf, 1024);
\&    die "read failed: $!" unless defined $n;
\&    last unless $n;
\&    print $buf;
\& }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The \f(CW\*(C`Net::HTTP\*(C'\fR class is a low-level \s-1HTTP\s0 client.  An instance of the
\&\f(CW\*(C`Net::HTTP\*(C'\fR class represents a connection to an \s-1HTTP\s0 server.  The
\&\s-1HTTP\s0 protocol is described in \s-1RFC 2616.\s0  The \f(CW\*(C`Net::HTTP\*(C'\fR class
supports \f(CW\*(C`HTTP/1.0\*(C'\fR and \f(CW\*(C`HTTP/1.1\*(C'\fR.
.PP
\&\f(CW\*(C`Net::HTTP\*(C'\fR is a sub-class of one of \f(CW\*(C`IO::Socket::IP\*(C'\fR (IPv6+IPv4),
\&\f(CW\*(C`IO::Socket::INET6\*(C'\fR (IPv6+IPv4), or \f(CW\*(C`IO::Socket::INET\*(C'\fR (IPv4 only).  
You can mix the methods described below with reading and writing from the
socket directly.  This is not necessary a good idea, unless you know what
you are doing.
.PP
The following methods are provided (in addition to those of
\&\f(CW\*(C`IO::Socket::INET\*(C'\fR):
.ie n .IP "$s = Net::HTTP\->new( %options )" 4
.el .IP "\f(CW$s\fR = Net::HTTP\->new( \f(CW%options\fR )" 4
.IX Item "$s = Net::HTTP->new( %options )"
The \f(CW\*(C`Net::HTTP\*(C'\fR constructor method takes the same options as
\&\f(CW\*(C`IO::Socket::INET\*(C'\fR's as well as these:
.Sp
.Vb 7
\&  Host:            Initial host attribute value
\&  KeepAlive:       Initial keep_alive attribute value
\&  SendTE:          Initial send_te attribute_value
\&  HTTPVersion:     Initial http_version attribute value
\&  PeerHTTPVersion: Initial peer_http_version attribute value
\&  MaxLineLength:   Initial max_line_length attribute value
\&  MaxHeaderLines:  Initial max_header_lines attribute value
.Ve
.Sp
The \f(CW\*(C`Host\*(C'\fR option is also the default for \f(CW\*(C`IO::Socket::INET\*(C'\fR's
\&\f(CW\*(C`PeerAddr\*(C'\fR.  The \f(CW\*(C`PeerPort\*(C'\fR defaults to 80 if not provided.
The \f(CW\*(C`PeerPort\*(C'\fR specification can also be embedded in the \f(CW\*(C`PeerAddr\*(C'\fR
by preceding it with a \*(L":\*(R", and closing the IPv6 address on brackets \*(L"[]\*(R" if
necessary: \*(L"192.0.2.1:80\*(R",\*(L"[2001:db8::1]:80\*(R",\*(L"any.example.com:80\*(R".
.Sp
The \f(CW\*(C`Listen\*(C'\fR option provided by \f(CW\*(C`IO::Socket::INET\*(C'\fR's constructor
method is not allowed.
.Sp
If unable to connect to the given \s-1HTTP\s0 server then the constructor
returns \f(CW\*(C`undef\*(C'\fR and $@ contains the reason.  After a successful
connect, a \f(CW\*(C`Net:HTTP\*(C'\fR object is returned.
.ie n .IP "$s\->host" 4
.el .IP "\f(CW$s\fR\->host" 4
.IX Item "$s->host"
Get/set the default value of the \f(CW\*(C`Host\*(C'\fR header to send.  The \f(CW$host\fR
must not be set to an empty string (or \f(CW\*(C`undef\*(C'\fR) for \s-1HTTP/1.1.\s0
.ie n .IP "$s\->keep_alive" 4
.el .IP "\f(CW$s\fR\->keep_alive" 4
.IX Item "$s->keep_alive"
Get/set the \fIkeep-alive\fR value.  If this value is \s-1TRUE\s0 then the
request will be sent with headers indicating that the server should try
to keep the connection open so that multiple requests can be sent.
.Sp
The actual headers set will depend on the value of the \f(CW\*(C`http_version\*(C'\fR
and \f(CW\*(C`peer_http_version\*(C'\fR attributes.
.ie n .IP "$s\->send_te" 4
.el .IP "\f(CW$s\fR\->send_te" 4
.IX Item "$s->send_te"
Get/set the a value indicating if the request will be sent with a \*(L"\s-1TE\*(R"\s0
header to indicate the transfer encodings that the server can choose to
use.  The list of encodings announced as accepted by this client depends
on availability of the following modules: \f(CW\*(C`Compress::Raw::Zlib\*(C'\fR for
\&\fIdeflate\fR, and \f(CW\*(C`IO::Compress::Gunzip\*(C'\fR for \fIgzip\fR.
.ie n .IP "$s\->http_version" 4
.el .IP "\f(CW$s\fR\->http_version" 4
.IX Item "$s->http_version"
Get/set the \s-1HTTP\s0 version number that this client should announce.
This value can only be set to \*(L"1.0\*(R" or \*(L"1.1\*(R".  The default is \*(L"1.1\*(R".
.ie n .IP "$s\->peer_http_version" 4
.el .IP "\f(CW$s\fR\->peer_http_version" 4
.IX Item "$s->peer_http_version"
Get/set the protocol version number of our peer.  This value will
initially be \*(L"1.0\*(R", but will be updated by a successful
\&\fBread_response_headers()\fR method call.
.ie n .IP "$s\->max_line_length" 4
.el .IP "\f(CW$s\fR\->max_line_length" 4
.IX Item "$s->max_line_length"
Get/set a limit on the length of response line and response header
lines.  The default is 8192.  A value of 0 means no limit.
.ie n .IP "$s\->max_header_length" 4
.el .IP "\f(CW$s\fR\->max_header_length" 4
.IX Item "$s->max_header_length"
Get/set a limit on the number of header lines that a response can
have.  The default is 128.  A value of 0 means no limit.
.ie n .IP "$s\->format_request($method, $uri, %headers, [$content])" 4
.el .IP "\f(CW$s\fR\->format_request($method, \f(CW$uri\fR, \f(CW%headers\fR, [$content])" 4
.IX Item "$s->format_request($method, $uri, %headers, [$content])"
Format a request message and return it as a string.  If the headers do
not include a \f(CW\*(C`Host\*(C'\fR header, then a header is inserted with the value
of the \f(CW\*(C`host\*(C'\fR attribute.  Headers like \f(CW\*(C`Connection\*(C'\fR and
\&\f(CW\*(C`Keep\-Alive\*(C'\fR might also be added depending on the status of the
\&\f(CW\*(C`keep_alive\*(C'\fR attribute.
.Sp
If \f(CW$content\fR is given (and it is non-empty), then a \f(CW\*(C`Content\-Length\*(C'\fR
header is automatically added unless it was already present.
.ie n .IP "$s\->write_request($method, $uri, %headers, [$content])" 4
.el .IP "\f(CW$s\fR\->write_request($method, \f(CW$uri\fR, \f(CW%headers\fR, [$content])" 4
.IX Item "$s->write_request($method, $uri, %headers, [$content])"
Format and send a request message.  Arguments are the same as for
\&\fBformat_request()\fR.  Returns true if successful.
.ie n .IP "$s\->format_chunk( $data )" 4
.el .IP "\f(CW$s\fR\->format_chunk( \f(CW$data\fR )" 4
.IX Item "$s->format_chunk( $data )"
Returns the string to be written for the given chunk of data.
.ie n .IP "$s\->write_chunk($data)" 4
.el .IP "\f(CW$s\fR\->write_chunk($data)" 4
.IX Item "$s->write_chunk($data)"
Will write a new chunk of request entity body data.  This method
should only be used if the \f(CW\*(C`Transfer\-Encoding\*(C'\fR header with a value of
\&\f(CW\*(C`chunked\*(C'\fR was sent in the request.  Note, writing zero-length data is
a no-op.  Use the \fBwrite_chunk_eof()\fR method to signal end of entity
body data.
.Sp
Returns true if successful.
.ie n .IP "$s\->format_chunk_eof( %trailers )" 4
.el .IP "\f(CW$s\fR\->format_chunk_eof( \f(CW%trailers\fR )" 4
.IX Item "$s->format_chunk_eof( %trailers )"
Returns the string to be written for signaling \s-1EOF\s0 when a
\&\f(CW\*(C`Transfer\-Encoding\*(C'\fR of \f(CW\*(C`chunked\*(C'\fR is used.
.ie n .IP "$s\->write_chunk_eof( %trailers )" 4
.el .IP "\f(CW$s\fR\->write_chunk_eof( \f(CW%trailers\fR )" 4
.IX Item "$s->write_chunk_eof( %trailers )"
Will write eof marker for chunked data and optional trailers.  Note
that trailers should not really be used unless is was signaled
with a \f(CW\*(C`Trailer\*(C'\fR header.
.Sp
Returns true if successful.
.ie n .IP "($code, $mess, %headers) = $s\->read_response_headers( %opts )" 4
.el .IP "($code, \f(CW$mess\fR, \f(CW%headers\fR) = \f(CW$s\fR\->read_response_headers( \f(CW%opts\fR )" 4
.IX Item "($code, $mess, %headers) = $s->read_response_headers( %opts )"
Read response headers from server and return it.  The \f(CW$code\fR is the 3
digit \s-1HTTP\s0 status code (see HTTP::Status) and \f(CW$mess\fR is the textual
message that came with it.  Headers are then returned as key/value
pairs.  Since key letter casing is not normalized and the same key can
even occur multiple times, assigning these values directly to a hash
is not wise.  Only the \f(CW$code\fR is returned if this method is called in
scalar context.
.Sp
As a side effect this method updates the 'peer_http_version'
attribute.
.Sp
Options might be passed in as key/value pairs.  There are currently
only two options supported; \f(CW\*(C`laxed\*(C'\fR and \f(CW\*(C`junk_out\*(C'\fR.
.Sp
The \f(CW\*(C`laxed\*(C'\fR option will make \fBread_response_headers()\fR more forgiving
towards servers that have not learned how to speak \s-1HTTP\s0 properly.  The
\&\f(CW\*(C`laxed\*(C'\fR option is a boolean flag, and is enabled by passing in a \s-1TRUE\s0
value.  The \f(CW\*(C`junk_out\*(C'\fR option can be used to capture bad header lines
when \f(CW\*(C`laxed\*(C'\fR is enabled.  The value should be an array reference.
Bad header lines will be pushed onto the array.
.Sp
The \f(CW\*(C`laxed\*(C'\fR option must be specified in order to communicate with
pre\-HTTP/1.0 servers that don't describe the response outcome or the
data they send back with a header block.  For these servers
peer_http_version is set to \*(L"0.9\*(R" and this method returns (200,
\&\*(L"Assumed \s-1OK\*(R"\s0).
.Sp
The method will raise an exception (die) if the server does not speak
proper \s-1HTTP\s0 or if the \f(CW\*(C`max_line_length\*(C'\fR or \f(CW\*(C`max_header_length\*(C'\fR
limits are reached.  If the \f(CW\*(C`laxed\*(C'\fR option is turned on and
\&\f(CW\*(C`max_line_length\*(C'\fR and \f(CW\*(C`max_header_length\*(C'\fR checks are turned off,
then no exception will be raised and this method will always
return a response code.
.ie n .IP "$n = $s\->read_entity_body($buf, $size);" 4
.el .IP "\f(CW$n\fR = \f(CW$s\fR\->read_entity_body($buf, \f(CW$size\fR);" 4
.IX Item "$n = $s->read_entity_body($buf, $size);"
Reads chunks of the entity body content.  Basically the same interface
as for \fBread()\fR and \fBsysread()\fR, but the buffer offset argument is not
supported yet.  This method should only be called after a successful
\&\fBread_response_headers()\fR call.
.Sp
The return value will be \f(CW\*(C`undef\*(C'\fR on read errors, 0 on \s-1EOF,\s0 \-1 if no data
could be returned this time, otherwise the number of bytes assigned
to \f(CW$buf\fR.  The \f(CW$buf\fR is set to "" when the return value is \-1.
.Sp
You normally want to retry this call if this function returns either
\&\-1 or \f(CW\*(C`undef\*(C'\fR with \f(CW$!\fR as \s-1EINTR\s0 or \s-1EAGAIN\s0 (see Errno).  \s-1EINTR\s0
can happen if the application catches signals and \s-1EAGAIN\s0 can happen if
you made the socket non-blocking.
.Sp
This method will raise exceptions (die) if the server does not speak
proper \s-1HTTP.\s0  This can only happen when reading chunked data.
.ie n .IP "%headers = $s\->get_trailers" 4
.el .IP "\f(CW%headers\fR = \f(CW$s\fR\->get_trailers" 4
.IX Item "%headers = $s->get_trailers"
After \fBread_entity_body()\fR has returned 0 to indicate end of the entity
body, you might call this method to pick up any trailers.
.ie n .IP "$s\->_rbuf" 4
.el .IP "\f(CW$s\fR\->_rbuf" 4
.IX Item "$s->_rbuf"
Get/set the read buffer content.  The \fBread_response_headers()\fR and
\&\fBread_entity_body()\fR methods use an internal buffer which they will look
for data before they actually sysread more from the socket itself.  If
they read too much, the remaining data will be left in this buffer.
.ie n .IP "$s\->_rbuf_length" 4
.el .IP "\f(CW$s\fR\->_rbuf_length" 4
.IX Item "$s->_rbuf_length"
Returns the number of bytes in the read buffer.  This should always be
the same as:
.Sp
.Vb 1
\&    length($s\->_rbuf)
.Ve
.Sp
but might be more efficient.
.SH "SUBCLASSING"
.IX Header "SUBCLASSING"
The \fBread_response_headers()\fR and \fBread_entity_body()\fR will invoke the
\&\fBsysread()\fR method when they need more data.  Subclasses might want to
override this method to control how reading takes place.
.PP
The object itself is a glob.  Subclasses should avoid using hash key
names prefixed with \f(CW\*(C`http_\*(C'\fR and \f(CW\*(C`io_\*(C'\fR.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\s-1LWP\s0, IO::Socket::INET, Net::HTTP::NB
.SH "AUTHOR"
.IX Header "AUTHOR"
Gisle Aas <gisle@activestate.com>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is copyright (c) 2001\-2017 by Gisle Aas.
.PP
This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.
