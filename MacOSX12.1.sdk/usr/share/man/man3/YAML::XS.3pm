.\" Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "YAML::XS 3"
.TH YAML::XS 3 "2020-05-02" "perl v5.30.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
YAML::XS \- Perl YAML Serialization using XS and libyaml
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use YAML::XS;
\&
\&    my $yaml = Dump [ 1..4 ];
\&    my $array = Load $yaml;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Kirill Simonov's \f(CW\*(C`libyaml\*(C'\fR is arguably the best \s-1YAML\s0 implementation. The C
library is written precisely to the \s-1YAML 1.1\s0 specification. It was originally
bound to Python and was later bound to Ruby.
.PP
This module is a Perl \s-1XS\s0 binding to libyaml which offers Perl the best \s-1YAML\s0
support to date.
.PP
This module exports the functions \f(CW\*(C`Dump\*(C'\fR, \f(CW\*(C`Load\*(C'\fR, \f(CW\*(C`DumpFile\*(C'\fR and
\&\f(CW\*(C`LoadFile\*(C'\fR. These functions are intended to work exactly like \f(CW\*(C`YAML.pm\*(C'\fR's
corresponding functions. Only \f(CW\*(C`Load\*(C'\fR and \f(CW\*(C`Dump\*(C'\fR are exported by default.
.SH "CONFIGURATION"
.IX Header "CONFIGURATION"
.ie n .IP "$YAML::XS::LoadBlessed (since v0.69)" 4
.el .IP "\f(CW$YAML::XS::LoadBlessed\fR (since v0.69)" 4
.IX Item "$YAML::XS::LoadBlessed (since v0.69)"
Default: false.
.Sp
The default was changed in version 0.81.
.Sp
When set to false, it will not bless data into objects, which can be a
security problem, when loading \s-1YAML\s0 from an untrusted source. It will silently
ignore the tag and just load the data unblessed.
.Sp
In PyYAML, this is called SafeLoad.
.Sp
If set to true, it will load the following \s-1YAML\s0 as objects:
.Sp
.Vb 4
\&    \-\-\-
\&    local: !Foo::Bar [a]
\&    perl: !!perl/hash:Foo::Bar { a: 1 }
\&    regex: !!perl/regexp:Foo::Bar pattern
.Ve
.Sp
You can create any kind of object with \s-1YAML.\s0 The creation itself is not the
critical part. If the class has a \f(CW\*(C`DESTROY\*(C'\fR method, it will be called once
the object is deleted. An example with File::Temp removing files can be found
at <https://bugs.debian.org/cgi\-bin/bugreport.cgi?bug=862373>
.ie n .IP "$YAML::XS::UseCode" 4
.el .IP "\f(CW$YAML::XS::UseCode\fR" 4
.IX Item "$YAML::XS::UseCode"
.PD 0
.ie n .IP "$YAML::XS::DumpCode" 4
.el .IP "\f(CW$YAML::XS::DumpCode\fR" 4
.IX Item "$YAML::XS::DumpCode"
.ie n .IP "$YAML::XS::LoadCode" 4
.el .IP "\f(CW$YAML::XS::LoadCode\fR" 4
.IX Item "$YAML::XS::LoadCode"
.PD
If enabled supports deparsing and evaling of code blocks.
.Sp
Note that support for loading code was added in version 0.75, although
\&\f(CW$LoadCode\fR was documented already in earlier versions.
.ie n .IP "$YAML::XS::QuoteNumericStrings" 4
.el .IP "\f(CW$YAML::XS::QuoteNumericStrings\fR" 4
.IX Item "$YAML::XS::QuoteNumericStrings"
When true (the default) strings that look like numbers but have not been
numified will be quoted when dumping.
.Sp
This ensures leading that things like leading zeros and other formatting are
preserved.
.ie n .IP "$YAML::XS::Boolean (since v0.67)" 4
.el .IP "\f(CW$YAML::XS::Boolean\fR (since v0.67)" 4
.IX Item "$YAML::XS::Boolean (since v0.67)"
Default is undef.
.Sp
When set to \f(CW"JSON::PP"\fR or \f(CW"boolean"\fR, the plain (unquoted) strings
\&\f(CW\*(C`true\*(C'\fR and \f(CW\*(C`false\*(C'\fR will be loaded as \f(CW\*(C`JSON::PP::Boolean\*(C'\fR or \f(CW\*(C`boolean.pm\*(C'\fR
objects. Those objects will be dumped again as plain \*(L"true\*(R" or \*(L"false\*(R".
.Sp
It will try to load \s-1JSON::PP\s0 or boolean and die if it can't be loaded.
.Sp
With that it's possible to add new \*(L"real\*(R" booleans to a data structure:
.Sp
.Vb 6
\&      local $YAML::XS::Boolean = "JSON::PP"; # or "boolean"
\&      my $data = Load("booltrue: true");
\&      $data\->{boolfalse} = JSON::PP::false;
\&      my $yaml = Dump($data);
\&      # boolfalse: false
\&      # booltrue: true
.Ve
.Sp
It also lets booleans survive when loading \s-1YAML\s0 via \s-1YAML::XS\s0 and encode it
in \s-1JSON\s0 via one of the various \s-1JSON\s0 encoders, which mostly support
\&\s-1JSON::PP\s0 booleans.
.Sp
Please note that JSON::PP::Boolean and boolean.pm behave a bit differently.
Ideally you should only use them in boolean context.
.Sp
If not set, booleans are loaded as special perl variables \f(CW\*(C`PL_sv_yes\*(C'\fR and
\&\f(CW\*(C`PL_sv_no\*(C'\fR, which have the disadvantage that they are readonly, and you can't
add those to an existing data structure with pure perl.
.Sp
If you simply need to load \*(L"perl booleans\*(R" that are true or false in boolean
context, you will be fine with the default setting.
.ie n .IP "$YAML::XS::Indent (since v0.76)" 4
.el .IP "\f(CW$YAML::XS::Indent\fR (since v0.76)" 4
.IX Item "$YAML::XS::Indent (since v0.76)"
Default is 2.
.Sp
Sets the number of spaces for indentation for \f(CW\*(C`Dump\*(C'\fR.
.SH "USING YAML::XS WITH UNICODE"
.IX Header "USING YAML::XS WITH UNICODE"
Handling unicode properly in Perl can be a pain. \s-1YAML::XS\s0 only deals with
streams of utf8 octets. Just remember this:
.PP
.Vb 2
\&    $perl = Load($utf8_octets);
\&    $utf8_octets = Dump($perl);
.Ve
.PP
There are many, many places where things can go wrong with unicode. If you are
having problems, use Devel::Peek on all the possible data points.
.SH "LIBYAML"
.IX Header "LIBYAML"
You can find out (since v.079) which libyaml version this module was
built with:
.PP
.Vb 1
\&      my $libyaml_version = YAML::XS::LibYAML::libyaml_version();
.Ve
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.IP "\(bu" 4
\&\s-1YAML\s0.pm
.IP "\(bu" 4
YAML::Syck
.IP "\(bu" 4
YAML::Tiny
.IP "\(bu" 4
\&\s-1YAML::PP\s0
.IP "\(bu" 4
YAML::PP::LibYAML
.SH "AUTHOR"
.IX Header "AUTHOR"
Ingy döt Net <ingy@cpan.org>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright 2007\-2020. Ingy döt Net.
.PP
This program is free software; you can redistribute it and/or modify it under
the same terms as Perl itself.
.PP
See <http://www.perl.com/perl/misc/Artistic.html>
