.\" Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Class::MOP::Package 3"
.TH Class::MOP::Package 3 "2019-11-22" "perl v5.30.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Class::MOP::Package \- Package Meta Object
.SH "VERSION"
.IX Header "VERSION"
version 2.2012
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The Package Protocol provides an abstraction of a Perl 5 package. A
package is basically namespace, and this module provides methods for
looking at and changing that namespace's symbol table.
.SH "METHODS"
.IX Header "METHODS"
.ie n .SS "Class::MOP::Package\->initialize($package_name, %options)"
.el .SS "Class::MOP::Package\->initialize($package_name, \f(CW%options\fP)"
.IX Subsection "Class::MOP::Package->initialize($package_name, %options)"
This method creates a new \f(CW\*(C`Class::MOP::Package\*(C'\fR instance which
represents specified package. If an existing metaclass object exists
for the package, that will be returned instead. No options are valid at the
package level.
.ie n .SS "Class::MOP::Package\->reinitialize($package, %options)"
.el .SS "Class::MOP::Package\->reinitialize($package, \f(CW%options\fP)"
.IX Subsection "Class::MOP::Package->reinitialize($package, %options)"
This method forcibly removes any existing metaclass for the package
before calling \f(CW\*(C`initialize\*(C'\fR. In contrast to \f(CW\*(C`initialize\*(C'\fR, you may
also pass an existing \f(CW\*(C`Class::MOP::Package\*(C'\fR instance instead of just
a package name as \f(CW$package\fR.
.PP
Do not call this unless you know what you are doing.
.ie n .SS "Class::MOP::Package\->create($package, %options)"
.el .SS "Class::MOP::Package\->create($package, \f(CW%options\fP)"
.IX Subsection "Class::MOP::Package->create($package, %options)"
Creates a new \f(CW\*(C`Class::MOP::Package\*(C'\fR instance which represents the specified
package, and also does some initialization of that package. Currently, this
just does the same thing as \f(CW\*(C`initialize\*(C'\fR, but is overridden in subclasses,
such as \f(CW\*(C`Class::MOP::Class\*(C'\fR.
.SS "Class::MOP::Package\->create_anon(%options)"
.IX Subsection "Class::MOP::Package->create_anon(%options)"
Creates a new anonymous package. Valid keys for \f(CW%options\fR are:
.ie n .IP """cache""" 4
.el .IP "\f(CWcache\fR" 4
.IX Item "cache"
If this will be \f(CW\*(C`true\*(C'\fR (the default is \f(CW\*(C`false\*(C'\fR), the instance will be cached
in \f(CW\*(C`Class::MOP\*(C'\fR's metaclass cache.
.ie n .IP """weaken""" 4
.el .IP "\f(CWweaken\fR" 4
.IX Item "weaken"
If this is \f(CW\*(C`true\*(C'\fR (the default \f(CW\*(C`true\*(C'\fR when cache is \f(CW\*(C`false\*(C'\fR), the instance
stored in \f(CW\*(C`Class::MOP\*(C'\fR's metaclass cache will be weakened, so that the
anonymous package will be garbage collected when the returned instance goes out
of scope.
.ie n .SS "$metapackage\->is_anon"
.el .SS "\f(CW$metapackage\fP\->is_anon"
.IX Subsection "$metapackage->is_anon"
Returns true if the package is an anonymous package.
.ie n .SS "$metapackage\->name"
.el .SS "\f(CW$metapackage\fP\->name"
.IX Subsection "$metapackage->name"
This is returns the package's name, as passed to the constructor.
.ie n .SS "$metapackage\->namespace"
.el .SS "\f(CW$metapackage\fP\->namespace"
.IX Subsection "$metapackage->namespace"
This returns a hash reference to the package's symbol table. The keys
are symbol names and the values are typeglob references.
.ie n .SS "$metapackage\->add_package_symbol($variable_name, $initial_value)"
.el .SS "\f(CW$metapackage\fP\->add_package_symbol($variable_name, \f(CW$initial_value\fP)"
.IX Subsection "$metapackage->add_package_symbol($variable_name, $initial_value)"
This method accepts a variable name and an optional initial value. The
\&\f(CW$variable_name\fR must contain a leading sigil.
.PP
This method creates the variable in the package's symbol table, and
sets it to the initial value if one was provided.
.ie n .SS "$metapackage\->get_package_symbol($variable_name)"
.el .SS "\f(CW$metapackage\fP\->get_package_symbol($variable_name)"
.IX Subsection "$metapackage->get_package_symbol($variable_name)"
Given a variable name, this method returns the variable as a reference
or undef if it does not exist. The \f(CW$variable_name\fR must contain a
leading sigil.
.ie n .SS "$metapackage\->get_or_add_package_symbol($variable_name)"
.el .SS "\f(CW$metapackage\fP\->get_or_add_package_symbol($variable_name)"
.IX Subsection "$metapackage->get_or_add_package_symbol($variable_name)"
Given a variable name, this method returns the variable as a reference.
If it does not exist, a default value will be generated if possible. The
\&\f(CW$variable_name\fR must contain a leading sigil.
.ie n .SS "$metapackage\->has_package_symbol($variable_name)"
.el .SS "\f(CW$metapackage\fP\->has_package_symbol($variable_name)"
.IX Subsection "$metapackage->has_package_symbol($variable_name)"
Returns true if there is a package variable defined for
\&\f(CW$variable_name\fR. The \f(CW$variable_name\fR must contain a leading sigil.
.ie n .SS "$metapackage\->remove_package_symbol($variable_name)"
.el .SS "\f(CW$metapackage\fP\->remove_package_symbol($variable_name)"
.IX Subsection "$metapackage->remove_package_symbol($variable_name)"
This will remove the package variable specified \f(CW$variable_name\fR. The
\&\f(CW$variable_name\fR must contain a leading sigil.
.ie n .SS "$metapackage\->remove_package_glob($glob_name)"
.el .SS "\f(CW$metapackage\fP\->remove_package_glob($glob_name)"
.IX Subsection "$metapackage->remove_package_glob($glob_name)"
Given the name of a glob, this will remove that glob from the
package's symbol table. Glob names do not include a sigil. Removing
the glob removes all variables and subroutines with the specified
name.
.ie n .SS "$metapackage\->list_all_package_symbols($type_filter)"
.el .SS "\f(CW$metapackage\fP\->list_all_package_symbols($type_filter)"
.IX Subsection "$metapackage->list_all_package_symbols($type_filter)"
This will list all the glob names associated with the current
package. These names do not have leading sigils.
.PP
You can provide an optional type filter, which should be one of
\&'\s-1SCALAR\s0', '\s-1ARRAY\s0', '\s-1HASH\s0', or '\s-1CODE\s0'.
.ie n .SS "$metapackage\->get_all_package_symbols($type_filter)"
.el .SS "\f(CW$metapackage\fP\->get_all_package_symbols($type_filter)"
.IX Subsection "$metapackage->get_all_package_symbols($type_filter)"
This works much like \f(CW\*(C`list_all_package_symbols\*(C'\fR, but it returns a
hash reference. The keys are glob names and the values are references
to the value for that name.
.SS "Class::MOP::Package\->meta"
.IX Subsection "Class::MOP::Package->meta"
This will return a Class::MOP::Class instance for this class.
.SH "AUTHORS"
.IX Header "AUTHORS"
.IP "\(bu" 4
Stevan Little <stevan.little@iinteractive.com>
.IP "\(bu" 4
Dave Rolsky <autarch@urth.org>
.IP "\(bu" 4
Jesse Luehrs <doy@tozt.net>
.IP "\(bu" 4
Shawn M Moore <code@sartak.org>
.IP "\(bu" 4
יובל קוג'מן (Yuval Kogman) <nothingmuch@woobling.org>
.IP "\(bu" 4
Karen Etheridge <ether@cpan.org>
.IP "\(bu" 4
Florian Ragwitz <rafl@debian.org>
.IP "\(bu" 4
Hans Dieter Pearcey <hdp@weftsoar.net>
.IP "\(bu" 4
Chris Prather <chris@prather.org>
.IP "\(bu" 4
Matt S Trout <mst@shadowcat.co.uk>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is copyright (c) 2006 by Infinity Interactive, Inc.
.PP
This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.
