.\" Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Pegex::Tutorial::Calculator 3"
.TH Pegex::Tutorial::Calculator 3 "2020-02-13" "perl v5.30.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "Pegex Tutorial Calculator"
.IX Header "Pegex Tutorial Calculator"
A Pegex Calculator
.PP
When you look around the web for stuff about parsing, you inevitably find a
bunch of examples about how to write a precedence parser for mathematical
expressions.
.IP "\(bu" 4
<http://en.wikipedia.org/wiki/Operator\-precedence_parser>
.IP "\(bu" 4
<http://eli.thegreenplace.net/2010/01/02/top\-down\-operator\-precedence\-parsing/>
.IP "\(bu" 4
<http://www.hokstad.com/operator\-precedence\-parser.html>
.IP "\(bu" 4
<http://www.perlmonks.org/?node_id=554516>
.PP
This tutorial is the Pegex version of that. Pegex actually comes with an
examples directory that contains two arithmetic expression parser/evaluator
calculator programs:
.IP "\(bu" 4
<https://github.com/ingydotnet/pegex\-pm/blob/master/eg/calculator/calculator1.pl>
.IP "\(bu" 4
<https://github.com/ingydotnet/pegex\-pm/blob/master/eg/calculator/calculator2.pl>
.PP
They both do the same thing but using different parsing approaches. We'll
cover both of them in detail. I hope you'll find that Pegex handles operator
precedence parsing elegantly.
.SH "The Problem"
.IX Header "The Problem"
Precedence parsers are interesting because you need to deal with operators
that have the same precedence, different precedences and both left and right
associativity.
.PP
Consider the equation:
.PP
.Vb 1
\&    1 \- 2 ^ 3 ^ 4 + 5 * 6 / 7
.Ve
.PP
Normal precedence and associativity rules make this the same as:
.PP
.Vb 1
\&    (1 \- (2 ^ (3 ^ 4)) + ((5 * 6) / 7))
.Ve
.PP
Our calculator should produce the same result for both. Note that this means
we will be parsing numbers, 5 operators, parentheses, and separating
whitespace.
.PP
Here's an example of the calculator program running:
.PP
.Vb 6
\&    > perl eg/calculator1.pl
\&    Enter an equation: 1+2*3
\&    1+2*3 = 7
\&    Enter an equation: (1 + 2) * 3
\&    (1 + 2) * 3 = 9
\&    Enter an equation:
.Ve
.SH "The Solutions"
.IX Header "The Solutions"
Most of the solutions that you'll read about on the web, involve (or assume) a
lexing/tokenizing step before parsing. Pegex always parses an input stream
directly, pulling out \*(L"tokens\*(R" that it needs using regex captures. So the
parse happens as one operation, which has many advantages.
.PP
But how do we get the operator precedence rules into this? Well, we have 2
different ways:
.SS "calculator1.pl \- Operator Precedence Climbing"
.IX Subsection "calculator1.pl - Operator Precedence Climbing"
Note: The code in this example is copy/pasted from \*(L"calculator/\*(R" in example
      files. The code in those running files is slightly different but
      rewritten to make more sense in this doc.
.PP
Our first example calculator uses what is known as the Operator Precedence
Climbing method. See:
<http://en.wikipedia.org/wiki/Operator\-precedence_parser#Precedence_climbing_method>.
.PP
This is basically a clever technique of specifying our grammar rules such that
they imply precedence. Here's the pegex grammar from the code:
.PP
.Vb 6
\&    expr: add\-sub
\&    add\-sub: mul\-div+ % /\- ( [ \*(Aq+\-\*(Aq ])/
\&    mul\-div: power+ % /\- ([ \*(Aq*/\*(Aq ])/
\&    power: token+ % /\- \*(Aq^\*(Aq /
\&    token: /\- \*(Aq(\*(Aq \-/ expr /\- \*(Aq)\*(Aq/ | number
\&    number: /\- ( \*(Aq\-\*(Aq? DIGIT+ )/
.Ve
.PP
It's a little bit wonky but it works. It says that any expression is an
add/subtract and that an add/subtract is really a multiply/divide etc. Finally
after the last operator comes the number token and the parens.
.PP
It feels a bit backwards. One of the biggest drawbacks of \s-1PCM\s0 is that it
becomes less and less efficient with more and more operators. It needs to go
through the whole tree, just to find each number.
.PP
But it works and the code is minimal. The receiver class gets the numbers in
the correct order, immediately evaluates the answer and returns the answer for
each level. Whatever the return value of the final operation is, becomes the
result of the parse. Here's the receiver class:
.PP
.Vb 3
\&    {
\&        package Calculator;
\&        use base \*(AqPegex::Tree\*(Aq;
\&
\&        sub gotrule {
\&            my ($self, $list) = @_;
\&            return $list unless ref $list;
\&
\&            # Right associative:
\&            if ($self\->rule eq \*(Aqpower\*(Aq) {
\&                while (@$list > 1) {
\&                    my ($a, $b) = splice(@$list, \-2, 2);
\&                    push @$list, $a ** $b;
\&                }
\&            }
\&            # Left associative:
\&            else {
\&                while (@$list > 1) {
\&                    my ($a, $op, $b) = splice(@$list, 0, 3);
\&                    unshift @$list,
\&                        ($op eq \*(Aq+\*(Aq) ? ($a + $b) :
\&                        ($op eq \*(Aq\-\*(Aq) ? ($a \- $b) :
\&                        ($op eq \*(Aq*\*(Aq) ? ($a * $b) :
\&                        ($op eq \*(Aq/\*(Aq) ? ($a / $b) :
\&                        die;
\&                }
\&            }
\&            return @$list;
\&        }
\&    }
.Ve
.PP
As you can see, it has an action method for each level or precedence. It loops
over the expression, evaluating it. Whether it loops from left to right or
right to left depends on the associativity that we want to use.
.PP
Our runner code looks like this:
.PP
.Vb 7
\&    while (1) {
\&        print "\enEnter an equation: ";
\&        my $expr = <> || \*(Aq\*(Aq;
\&        chomp $expr;
\&        last unless length $expr;
\&        calc($expr);
\&    }
\&
\&    sub calc {
\&        my ($expr) = @_;
\&        my $result = pegex($grammar, \*(AqCalculator\*(Aq)\->parse($expr);
\&        if ($@) {
\&            warn $@;
\&            return;
\&        }
\&        print "$expr = $result\en";
\&    }
.Ve
.PP
And that's the whole thing. We have a working calculator as specced!
.PP
However the real point of this is to explore good parsing techniques, and the
\&\s-1PCM\s0 leaves us wanting to try something more efficient. Let's try another
approach...
.SS "calculator2.pl \- Shunting Yard Algorithm"
.IX Subsection "calculator2.pl - Shunting Yard Algorithm"
An age old way of parsing expressions is to somehow get the numbers and
operators into an \s-1RPN\s0 (Reverse Polish Notation) stack, which is each operand
follow by its operator. Once in that form, precedence and associativity are
accounted for.
.PP
For example:
.PP
.Vb 1
\&    1 / 2 \- ( \-3 * 4 )
.Ve
.PP
becomes:
.PP
.Vb 1
\&    1, 2, /, \-3, 4, *, \-
.Ve
.PP
To evaluate an \s-1RPN\s0 you pop off an operator and then attempt to pop off and
operand. If the operand is another operator you recurse. When you have 2
operands you do the operation and put the result back on the stack. When there
is only 1 element on the stack, you are done. That's your result.
.PP
Let's look at our new grammar in \f(CW\*(C`calculator2.pl\*(C'\fR:
.PP
.Vb 4
\&    expr: operand (operator operand)*
\&    operator: /\- ([\*(Aq+\-*/^\*(Aq])/
\&    operand: num | /\- \*(Aq(\*(Aq/ expr /\- \*(Aq)\*(Aq/
\&    num: /\- (\*(Aq\-\*(Aq? DIGIT+)/
.Ve
.PP
This is much easier to understand. We are just parsing out the tokens. In a
(very real) sense, we are using Pegex as a lexer.
.PP
Now let's look at the receiver class:
.PP
.Vb 3
\&    {
\&        package Calculator;
\&        use base \*(AqPegex::Tree\*(Aq, \*(AqPrecedence\*(Aq;
\&
\&        my $operator_precedence_table = {
\&            \*(Aq+\*(Aq => {p => 1, a => \*(Aql\*(Aq},
\&            \*(Aq\-\*(Aq => {p => 1, a => \*(Aql\*(Aq},
\&            \*(Aq*\*(Aq => {p => 2, a => \*(Aql\*(Aq},
\&            \*(Aq/\*(Aq => {p => 2, a => \*(Aql\*(Aq},
\&            \*(Aq^\*(Aq => {p => 3, a => \*(Aqr\*(Aq},
\&        };
\&
\&        sub got_expr {
\&            my ($self, $expr) = @_;
\&            $self\->precedence_rpn($expr, $operator_precedence_table);
\&        }
\&    }
.Ve
.PP
This is also much simpler. There's only one method. What's going on? Well the
secret is that I put the code to turn the tokens into \s-1RPN\s0 in a separate base
class called \*(L"lib/Precedence.pm\*(R" in example.
.PP
This is an implementation of Edsger Dijkstra's famous Shunting-yard Algorithm
from 1961! It's only 20 lines of Perl. I won't include it inline here, but
have a look at it for yourself.
<https://github.com/ingydotnet/pegex\-pm/blob/master/eg/calculator/lib/Precedence.pm>
.PP
The Shunting-yard algorithm simply takes a list of expression tokens and
transforms them into an \s-1RPN\s0 stack. It uses information from a
precedence/associativity table like the one above.
.PP
Unlike calculator1.pl where we evaluated as we parsed, calculator2.pl
creates an \s-1RPN\s0 which is akin to an \s-1AST.\s0 In other words, it's more like
something an actually language compiler would do.
.PP
But we are writing a calculator and we still need to evaluate this puppy. I
changed the runner code to look like this:
.PP
.Vb 7
\&    sub calc {
\&        my $expr = shift;
\&        my $calculator = pegex($grammar, \*(AqCalculator\*(Aq);
\&        my $rpn = eval { $calculator\->parse($expr) };
\&        my $result = RPN::evaluate($rpn);
\&        print $@ || "$expr = $result\en";
\&    }
.Ve
.PP
So overall, this second solution was a bit more code, but also feels more
solid on several levels.
.SH "Conclusion"
.IX Header "Conclusion"
Pegex strives to be the nicest and most reusable way to write new parsers.
Operator precedence parsers are a necessary part of parsing mathematical
expressions and computer languages. This tutorial showed you 2 ways to do it.
As the demands for Pegex grow, we may see even more ways to do it.
