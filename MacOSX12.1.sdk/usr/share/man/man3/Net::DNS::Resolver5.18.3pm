.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Net::DNS::Resolver 3"
.TH Net::DNS::Resolver 3 "2014-01-16" "perl v5.18.4" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Net::DNS::Resolver \- DNS resolver class
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use Net::DNS;
\&
\&  my $res = Net::DNS::Resolver\->new;
\&
\&  # Perform a lookup, using the searchlist if appropriate.
\&  my $answer = $res\->search(\*(Aqexample.com\*(Aq);
\&
\&  # Perform a lookup, without the searchlist
\&  my $answer = $res\->query(\*(Aqexample.com\*(Aq, \*(AqMX\*(Aq);
\&
\&  # Perform a lookup, without pre or post\-processing
\&  my $answer = $res\->send(\*(Aqexample.com\*(Aq, \*(AqMX\*(Aq, \*(AqCH\*(Aq);
\&
\&  # Send a prebuilt packet
\&  my $packet = Net::DNS::Packet\->new(...);
\&  my $answer = $res\->send($packet);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Instances of the \f(CW\*(C`Net::DNS::Resolver\*(C'\fR class represent resolver objects.
A program can have multiple resolver objects, each maintaining its
own state information such as the nameservers to be queried, whether
recursion is desired, etc.
.SH "METHODS"
.IX Header "METHODS"
.SS "new"
.IX Subsection "new"
.Vb 2
\&  # Use the system defaults
\&  my $res = Net::DNS::Resolver\->new;
\&
\&  # Use my own configuration file
\&  my $res = Net::DNS::Resolver\->new(config_file => \*(Aq/my/dns.conf\*(Aq);
\&
\&  # Set options in the constructor
\&  my $res = Net::DNS::Resolver\->new(
\&        nameservers => [qw(10.1.1.128 10.1.2.128)],
\&        recurse     => 0,
\&        debug       => 1,
\&  );
.Ve
.PP
Returns a resolver object.  If given no arguments, \f(CW\*(C`new()\*(C'\fR returns an
object configured to your system's defaults.  On \s-1UNIX\s0 systems the
defaults are read from the following files, in the order indicated:
.PP
.Vb 3
\&    /etc/resolv.conf
\&    $HOME/.resolv.conf
\&    ./.resolv.conf
.Ve
.PP
The following keywords are recognized in resolver configuration files:
.IP "domain" 4
.IX Item "domain"
The default domain.
.IP "search" 4
.IX Item "search"
A space-separated list of domains to put in the search list.
.IP "nameserver" 4
.IX Item "nameserver"
A space-separated list of nameservers to query.
.PP
Files except for \fI/etc/resolv.conf\fR must be owned by the effective
userid running the program or they won't be read.  In addition, several
environment variables can also contain configuration information; see
\&\*(L"\s-1ENVIRONMENT\*(R"\s0.
.PP
On Windows systems, an attempt is made to determine the system defaults
using the registry.  This is still a work in progress; systems with many
dynamically configured network interfaces may confuse Net::DNS.
.PP
You can include a configuration file of your own when creating a
resolver object:
.PP
.Vb 2
\& # Use my own configuration file
\& my $res = Net::DNS::Resolver\->new(config_file => \*(Aq/my/dns.conf\*(Aq);
.Ve
.PP
This is supported on both \s-1UNIX\s0 and Windows.  Values pulled from a custom
configuration file override the the system's defaults, but can still be
overridden by the other arguments to \fInew()\fR.
.PP
Explicit arguments to new override both the system's defaults and the
values of the custom configuration file, if any.  The following
arguments to \fInew()\fR are supported:
.IP "nameservers" 4
.IX Item "nameservers"
An array reference of nameservers to query.
.IP "searchlist" 4
.IX Item "searchlist"
An array reference of domains.
.IP "recurse" 4
.IX Item "recurse"
.PD 0
.IP "debug" 4
.IX Item "debug"
.IP "domain" 4
.IX Item "domain"
.IP "port" 4
.IX Item "port"
.IP "srcaddr" 4
.IX Item "srcaddr"
.IP "srcport" 4
.IX Item "srcport"
.IP "tcp_timeout" 4
.IX Item "tcp_timeout"
.IP "udp_timeout" 4
.IX Item "udp_timeout"
.IP "retrans" 4
.IX Item "retrans"
.IP "retry" 4
.IX Item "retry"
.IP "usevc" 4
.IX Item "usevc"
.IP "stayopen" 4
.IX Item "stayopen"
.IP "igntc" 4
.IX Item "igntc"
.IP "defnames" 4
.IX Item "defnames"
.IP "dnsrch" 4
.IX Item "dnsrch"
.IP "persistent_tcp" 4
.IX Item "persistent_tcp"
.IP "persistent_udp" 4
.IX Item "persistent_udp"
.IP "dnssec" 4
.IX Item "dnssec"
.PD
.PP
For more information on any of these options, please consult the method
of the same name.
.SS "search"
.IX Subsection "search"
.Vb 5
\&    $packet = $res\->search(\*(Aqmailhost\*(Aq);
\&    $packet = $res\->search(\*(Aqmailhost.example.com\*(Aq);
\&    $packet = $res\->search(\*(Aq192.168.1.1\*(Aq);
\&    $packet = $res\->search(\*(Aqexample.com\*(Aq, \*(AqMX\*(Aq);
\&    $packet = $res\->search(\*(Aquser.passwd.example.com\*(Aq, \*(AqTXT\*(Aq, \*(AqHS\*(Aq);
.Ve
.PP
Performs a \s-1DNS\s0 query for the given name, applying the searchlist
if appropriate.  The search algorithm is as follows:
.IP "1." 4
If the name contains at least one dot, try it as is.
.IP "2." 4
If the name doesn't end in a dot then append each item in
the search list to the name.  This is only done if \fBdnsrch\fR
is true.
.IP "3." 4
If the name doesn't contain any dots, try it as is.
.PP
The record type and class can be omitted; they default to A and
\&\s-1IN. \s0 If the name looks like an \s-1IP\s0 address (4 dot-separated numbers),
then an appropriate \s-1PTR\s0 query will be performed.
.PP
Returns a \*(L"Net::DNS::Packet\*(R" object, or \*(L"undef\*(R" if no answers were
found.  If you need to examine the response packet whether it contains
any answers or not, use the \fIsend()\fR method instead.
.SS "query"
.IX Subsection "query"
.Vb 5
\&    $packet = $res\->query(\*(Aqmailhost\*(Aq);
\&    $packet = $res\->query(\*(Aqmailhost.example.com\*(Aq);
\&    $packet = $res\->query(\*(Aq192.168.1.1\*(Aq);
\&    $packet = $res\->query(\*(Aqexample.com\*(Aq, \*(AqMX\*(Aq);
\&    $packet = $res\->query(\*(Aquser.passwd.example.com\*(Aq, \*(AqTXT\*(Aq, \*(AqHS\*(Aq);
.Ve
.PP
Performs a \s-1DNS\s0 query for the given name; the search list is not
applied.  If the name doesn't contain any dots and \fBdefnames\fR
is true then the default domain will be appended.
.PP
The record type and class can be omitted; they default to A and
\&\s-1IN. \s0 If the name looks like an \s-1IP\s0 address (IPv4 or IPv6),
then an appropriate \s-1PTR\s0 query will be performed.
.PP
Returns a \*(L"Net::DNS::Packet\*(R" object, or \*(L"undef\*(R" if no answers were
found.  If you need to examine the response packet whether it contains
any answers or not, use the \fIsend()\fR method instead.
.SS "send"
.IX Subsection "send"
.Vb 4
\&    $packet = $res\->send($packet_object);
\&    $packet = $res\->send(\*(Aqmailhost.example.com\*(Aq);
\&    $packet = $res\->send(\*(Aqexample.com\*(Aq, \*(AqMX\*(Aq);
\&    $packet = $res\->send(\*(Aquser.passwd.example.com\*(Aq, \*(AqTXT\*(Aq, \*(AqHS\*(Aq);
.Ve
.PP
Performs a \s-1DNS\s0 query for the given name.  Neither the searchlist
nor the default domain will be appended.
.PP
The argument list can be either a \f(CW\*(C`Net::DNS::Packet\*(C'\fR object or a list
of strings.  The record type and class can be omitted; they default to
A and \s-1IN. \s0 If the name looks like an \s-1IP\s0 address (Ipv4 or IPv6),
then an appropriate \s-1PTR\s0 query will be performed.
.PP
Returns a \f(CW\*(C`Net::DNS::Packet\*(C'\fR object whether there were any answers or not.
Use \f(CW\*(C`$packet\->header\->ancount\*(C'\fR or \f(CW\*(C`$packet\->answer\*(C'\fR to find out
if there were any records in the answer section.  Returns \f(CW\*(C`undef\*(C'\fR if there
was an error.
.SS "axfr"
.IX Subsection "axfr"
.Vb 3
\&    @zone = $res\->axfr;
\&    @zone = $res\->axfr(\*(Aqexample.com\*(Aq);
\&    @zone = $res\->axfr(\*(Aqpasswd.example.com\*(Aq, \*(AqHS\*(Aq);
.Ve
.PP
Performs a zone transfer from the first nameserver listed in \f(CW\*(C`nameservers\*(C'\fR.
If the zone is omitted, it defaults to the first zone listed in the resolver's
search list.  If the class is omitted, it defaults to \s-1IN.\s0
.PP
Returns a list of \f(CW\*(C`Net::DNS::RR\*(C'\fR objects, or \f(CW\*(C`undef\*(C'\fR if the zone
transfer failed.
.PP
The redundant \s-1SOA\s0 record that terminates the zone transfer is not
returned to the caller.
.PP
See also \*(L"axfr_start\*(R" and \*(L"axfr_next\*(R".
.PP
Here's an example that uses a timeout:
.PP
.Vb 2
\&    $res\->tcp_timeout(10);
\&    my @zone = $res\->axfr(\*(Aqexample.com\*(Aq);
\&
\&    if (@zone) {
\&        foreach my $rr (@zone) {
\&            $rr\->print;
\&        }
\&    } else {
\&        print \*(AqZone transfer failed: \*(Aq, $res\->errorstring, "\en";
\&    }
.Ve
.SS "axfr_start"
.IX Subsection "axfr_start"
.Vb 3
\&    $res\->axfr_start;
\&    $res\->axfr_start(\*(Aqexample.com\*(Aq);
\&    $res\->axfr_start(\*(Aqexample.com\*(Aq, \*(AqHS\*(Aq);
.Ve
.PP
Starts a zone transfer from the first nameserver listed in \f(CW\*(C`nameservers\*(C'\fR.
If the zone is omitted, it defaults to the first zone listed in the resolver's
search list.  If the class is omitted, it defaults to \s-1IN.\s0
.PP
\&\fB\s-1IMPORTANT\s0\fR:
.PP
This method currently returns the \f(CW\*(C`IO::Socket::INET\*(C'\fR object that will
be used for reading, or \f(CW\*(C`undef\*(C'\fR on error.  \s-1DO NOT DEPEND ON \s0\f(CW\*(C`axfr_start()\*(C'\fR
returning a socket object.  \s-1THIS MIGHT CHANGE\s0 in future releases.
.PP
Use \f(CW\*(C`axfr_next\*(C'\fR to read the zone records one at a time.
.SS "axfr_next"
.IX Subsection "axfr_next"
.Vb 1
\&    $res\->axfr_start(\*(Aqexample.com\*(Aq);
\&
\&    while (my $rr = $res\->axfr_next) {
\&            $rr\->print;
\&    }
.Ve
.PP
Reads records from a zone transfer one at a time.
.PP
Returns \f(CW\*(C`undef\*(C'\fR at the end of the zone transfer.  The redundant
\&\s-1SOA\s0 record that terminates the zone transfer is not returned.
.PP
See also \*(L"axfr\*(R".
.SS "nameservers"
.IX Subsection "nameservers"
.Vb 2
\&    @nameservers = $res\->nameservers;
\&    $res\->nameservers(\*(Aq192.168.1.1\*(Aq, \*(Aq192.168.2.2\*(Aq, \*(Aq192.168.3.3\*(Aq);
.Ve
.PP
Gets or sets the nameservers to be queried.
.PP
Also see the IPv6 transport notes below
.SS "empty_nameservers"
.IX Subsection "empty_nameservers"
.Vb 1
\&    $res\->empty_nameservers();
.Ve
.PP
Empties the list of nameservers.
.SS "print"
.IX Subsection "print"
.Vb 1
\&    $res\->print;
.Ve
.PP
Prints the resolver state on the standard output.
.SS "string"
.IX Subsection "string"
.Vb 1
\&    print $res\->string;
.Ve
.PP
Returns a string representation of the resolver state.
.SS "searchlist"
.IX Subsection "searchlist"
.Vb 2
\&    @searchlist = $res\->searchlist;
\&    $res\->searchlist(\*(Aqexample.com\*(Aq, \*(Aqa.example.com\*(Aq, \*(Aqb.example.com\*(Aq);
.Ve
.PP
Gets or sets the resolver search list.
.SS "empty_searchlist"
.IX Subsection "empty_searchlist"
.Vb 1
\&    $res\->empty_searchlist();
.Ve
.PP
Empties the searchlist.
.SS "port"
.IX Subsection "port"
.Vb 2
\&    print \*(Aqsending queries to port \*(Aq, $res\->port, "\en";
\&    $res\->port(9732);
.Ve
.PP
Gets or sets the port to which we send queries.  This can be useful
for testing a nameserver running on a non-standard port.  The
default is port 53.
.SS "srcport"
.IX Subsection "srcport"
.Vb 2
\&    print \*(Aqsending queries from port \*(Aq, $res\->srcport, "\en";
\&    $res\->srcport(5353);
.Ve
.PP
Gets or sets the port from which we send queries.  The default is 0,
meaning any port.
.SS "srcaddr"
.IX Subsection "srcaddr"
.Vb 2
\&    print \*(Aqsending queries from address \*(Aq, $res\->srcaddr, "\en";
\&    $res\->srcaddr(\*(Aq192.168.1.1\*(Aq);
.Ve
.PP
Gets or sets the source address from which we send queries.  Convenient
for forcing queries out a specific interfaces on a multi-homed host.
The default is 0.0.0.0, meaning any local address.
.SS "bgsend"
.IX Subsection "bgsend"
.Vb 1
\&    $socket = $res\->bgsend($packet_object) || die " $res\->errorstring";
\&
\&    $socket = $res\->bgsend(\*(Aqmailhost.example.com\*(Aq);
\&    $socket = $res\->bgsend(\*(Aqexample.com\*(Aq, \*(AqMX\*(Aq);
\&    $socket = $res\->bgsend(\*(Aquser.passwd.example.com\*(Aq, \*(AqTXT\*(Aq, \*(AqHS\*(Aq);
.Ve
.PP
Performs a background \s-1DNS\s0 query for the given name, i.e., sends a
query packet to the first nameserver listed in \f(CW\*(C`$res\->nameservers\*(C'\fR
and returns immediately without waiting for a response.  The program
can then perform other tasks while waiting for a response from the
nameserver.
.PP
The argument list can be either a \f(CW\*(C`Net::DNS::Packet\*(C'\fR object or a list
of strings.  The record type and class can be omitted; they default to
A and \s-1IN. \s0 If the name looks like an \s-1IP\s0 address (4 dot-separated numbers),
then an appropriate \s-1PTR\s0 query will be performed.
.PP
Returns an \f(CW\*(C`IO::Socket::INET\*(C'\fR object or \f(CW\*(C`undef\*(C'\fR on error in which
case the reason for failure can be found through a call to the
errorstring method.
.PP
The program must determine when the socket is ready for reading and
call \f(CW\*(C`$res\->bgread\*(C'\fR to get the response packet.  You can use \f(CW\*(C`$res\->bgisready\*(C'\fR or \f(CW\*(C`IO::Select\*(C'\fR to find out if the socket is ready
before reading it.
.PP
bgsend does not support persistent sockets.
.PP
\&\fB\s-1BEWARE\s0\fR:
bgsend does not support the usevc option (\s-1TCP\s0) and operates on \s-1UDP\s0 only;
Answers may not fit in an \s-1UDP\s0 packet and might be truncated. Truncated 
packets will \fBnot\fR be retried over \s-1TCP\s0 automatically and should be handled
by the caller.
.SS "bgread"
.IX Subsection "bgread"
.Vb 5
\&    $packet = $res\->bgread($socket);
\&    if ($packet\->header\->tc) { 
\&        # Retry over TCP (blocking).
\&    }
\&    undef $socket;
.Ve
.PP
Reads the answer from a background query (see \*(L"bgsend\*(R").  The argument
is an \f(CW\*(C`IO::Socket\*(C'\fR object returned by \f(CW\*(C`bgsend\*(C'\fR.
.PP
Returns a \f(CW\*(C`Net::DNS::Packet\*(C'\fR object or \f(CW\*(C`undef\*(C'\fR on error.
.PP
The programmer should close or destroy the socket object after reading it.
.SS "bgisready"
.IX Subsection "bgisready"
.Vb 9
\&    $socket = $res\->bgsend(\*(Aqfoo.example.com\*(Aq);
\&    until ($res\->bgisready($socket)) {
\&        # do some other processing
\&    }
\&    $packet = $res\->bgread($socket);
\&    if ($packet\->header\->tc) { 
\&        # Retry over TCP (blocking).
\&    }
\&    $socket = undef;
.Ve
.PP
Determines whether a socket is ready for reading.  The argument is
an \f(CW\*(C`IO::Socket\*(C'\fR object returned by \f(CW\*(C`$res\->bgsend\*(C'\fR.
.PP
Returns true if the socket is ready, false if not.
.SS "tsig"
.IX Subsection "tsig"
.Vb 1
\&    my $tsig = $res\->tsig;
\&
\&    $res\->tsig(Net::DNS::RR\->new("$key_name TSIG $key"));
\&
\&    $tsig = Net::DNS::RR\->new("$key_name TSIG $key");
\&    $tsig\->fudge(60);
\&    $res\->tsig($tsig);
\&
\&    $res\->tsig($key_name, $key);
\&
\&    $res\->tsig(0);
.Ve
.PP
Get or set the \s-1TSIG\s0 record used to automatically sign outgoing
queries and updates.  Call with an argument of 0 or '' to turn off
automatic signing.
.PP
The default resolver behavior is not to sign any packets.  You must
call this method to set the key if you'd like the resolver to sign
packets automatically.
.PP
You can also sign packets manually \*(-- see the \f(CW\*(C`Net::DNS::Packet\*(C'\fR
and \f(CW\*(C`Net::DNS::Update\*(C'\fR manual pages for examples.  \s-1TSIG\s0 records
in manually-signed packets take precedence over those that the
resolver would add automatically.
.SS "retrans"
.IX Subsection "retrans"
.Vb 2
\&    print \*(Aqretrans interval: \*(Aq, $res\->retrans, "\en";
\&    $res\->retrans(3);
.Ve
.PP
Get or set the retransmission interval.  The default is 5.
.SS "retry"
.IX Subsection "retry"
.Vb 2
\&    print \*(Aqnumber of tries: \*(Aq, $res\->retry, "\en";
\&    $res\->retry(2);
.Ve
.PP
Get or set the number of times to try the query.  The default is 4.
.SS "recurse"
.IX Subsection "recurse"
.Vb 2
\&    print \*(Aqrecursion flag: \*(Aq, $res\->recurse, "\en";
\&    $res\->recurse(0);
.Ve
.PP
Get or set the recursion flag.  If this is true, nameservers will
be requested to perform a recursive query.  The default is true.
.SS "defnames"
.IX Subsection "defnames"
.Vb 2
\&    print \*(Aqdefnames flag: \*(Aq, $res\->defnames, "\en";
\&    $res\->defnames(0);
.Ve
.PP
Get or set the defnames flag.  If this is true, calls to \fBquery\fR will
append the default domain to names that contain no dots.  The default
is true.
.SS "dnsrch"
.IX Subsection "dnsrch"
.Vb 2
\&    print \*(Aqdnsrch flag: \*(Aq, $res\->dnsrch, "\en";
\&    $res\->dnsrch(0);
.Ve
.PP
Get or set the dnsrch flag.  If this is true, calls to \fBsearch\fR will
apply the search list.  The default is true.
.SS "debug"
.IX Subsection "debug"
.Vb 2
\&    print \*(Aqdebug flag: \*(Aq, $res\->debug, "\en";
\&    $res\->debug(1);
.Ve
.PP
Get or set the debug flag.  If set, calls to \fBsearch\fR, \fBquery\fR,
and \fBsend\fR will print debugging information on the standard output.
The default is false.
.SS "usevc"
.IX Subsection "usevc"
.Vb 2
\&    print \*(Aqusevc flag: \*(Aq, $res\->usevc, "\en";
\&    $res\->usevc(1);
.Ve
.PP
Get or set the usevc flag.  If true, then queries will be performed
using virtual circuits (\s-1TCP\s0) instead of datagrams (\s-1UDP\s0).  The default
is false.
.SS "tcp_timeout"
.IX Subsection "tcp_timeout"
.Vb 2
\&    print \*(AqTCP timeout: \*(Aq, $res\->tcp_timeout, "\en";
\&    $res\->tcp_timeout(10);
.Ve
.PP
Get or set the \s-1TCP\s0 timeout in seconds.  A timeout of \f(CW\*(C`undef\*(C'\fR means
indefinite.  The default is 120 seconds (2 minutes).
.SS "udp_timeout"
.IX Subsection "udp_timeout"
.Vb 2
\&    print \*(AqUDP timeout: \*(Aq, $res\->udp_timeout, "\en";
\&    $res\->udp_timeout(10);
.Ve
.PP
Get or set the \s-1UDP\s0 timeout in seconds.  A timeout of \f(CW\*(C`undef\*(C'\fR means
the retry and retrans settings will be just utilized to perform the
retries until they are exhausted.  The default is \f(CW\*(C`undef\*(C'\fR.
.SS "persistent_tcp"
.IX Subsection "persistent_tcp"
.Vb 2
\&    print \*(AqPersistent TCP flag: \*(Aq, $res\->persistent_tcp, "\en";
\&    $res\->persistent_tcp(1);
.Ve
.PP
Get or set the persistent \s-1TCP\s0 setting.  If set to true, Net::DNS
will keep a \s-1TCP\s0 socket open for each host:port to which it connects.
This is useful if you're using \s-1TCP\s0 and need to make a lot of queries
or updates to the same nameserver.
.PP
This option defaults to false unless you're running under a
SOCKSified Perl, in which case it defaults to true.
.SS "persistent_udp"
.IX Subsection "persistent_udp"
.Vb 2
\&    print \*(AqPersistent UDP flag: \*(Aq, $res\->persistent_udp, "\en";
\&    $res\->persistent_udp(1);
.Ve
.PP
Get or set the persistent \s-1UDP\s0 setting.  If set to true, Net::DNS
will keep a single \s-1UDP\s0 socket open for all queries.
This is useful if you're using \s-1UDP\s0 and need to make a lot of queries
or updates.
.SS "igntc"
.IX Subsection "igntc"
.Vb 2
\&    print \*(Aqigntc flag: \*(Aq, $res\->igntc, "\en";
\&    $res\->igntc(1);
.Ve
.PP
Get or set the igntc flag.  If true, truncated packets will be
ignored.  If false, truncated packets will cause the query to
be retried using \s-1TCP. \s0 The default is false.
.SS "errorstring"
.IX Subsection "errorstring"
.Vb 1
\&    print \*(Aqquery status: \*(Aq, $res\->errorstring, "\en";
.Ve
.PP
Returns a string containing the status of the most recent query.
.SS "answerfrom"
.IX Subsection "answerfrom"
.Vb 1
\&    print \*(Aqlast answer was from: \*(Aq, $res\->answerfrom, "\en";
.Ve
.PP
Returns the \s-1IP\s0 address from which we received the last answer in
response to a query.
.SS "answersize"
.IX Subsection "answersize"
.Vb 1
\&    print \*(Aqsize of last answer: \*(Aq, $res\->answersize, "\en";
.Ve
.PP
Returns the size in bytes of the last answer we received in
response to a query.
.SS "dnssec"
.IX Subsection "dnssec"
.Vb 2
\&    print "dnssec flag: ", $res\->dnssec, "\en";
\&    $res\->dnssec(0);
.Ve
.PP
Enabled \s-1DNSSEC\s0 this will set the checking disabled flag in the query header
and add \s-1EDNS0\s0 data as in \s-1RFC2671\s0 and \s-1RFC3225\s0
.PP
When set to true the answer and additional section of queries from
secured zones will contain \s-1DNSKEY, NSEC\s0 and \s-1RRSIG\s0 records.
.PP
Setting calling the dnssec method with a non-zero value will set the
\&\s-1UDP\s0 packet size to the default value of 2048. If that is too small or
too big for your environment you should call the \fIudppacketsize()\fR
method immediately after.
.PP
.Vb 2
\&   $res\->dnssec(1);    # turns on DNSSEC and sets udp packetsize to 2048
\&   $res\->udppacketsize(1028);   # lowers the UDP pakcet size
.Ve
.PP
The method will Croak::croak with the message \*(L"You called the
\&\fINet::DNS::Resolver::dnssec()\fR method but do not have Net::DNS::SEC
installed at ...\*(R" if you call it without Net::DNS::SEC being in your
\&\f(CW@INC\fR path.
.SS "cdflag"
.IX Subsection "cdflag"
.Vb 3
\&    print "checking disabled flag: ", $res\->dnssec, "\en";
\&    $res\->dnssec(1);
\&    $res\->cdflag(1);
.Ve
.PP
Sets or gets the \s-1CD\s0 bit for a dnssec query.  This bit is always zero
for non dnssec queries. When the dnssec is enabled the flag defaults to
0 can be set to 1.
.SS "adflag"
.IX Subsection "adflag"
.Vb 3
\&    print "checking disabled flag: ", $res\->dnssec, "\en";
\&    $res\->dnssec(1);
\&    $res\->adflag(1);
.Ve
.PP
Sets or gets the \s-1AD\s0 bit for a dnssec query.  This bit is always zero
for non dnssec queries. When the dnssec is enabled the flag defaults
to 1.
.SS "udppacketsize"
.IX Subsection "udppacketsize"
.Vb 2
\&    print "udppacketsize: ", $res\->udppacketsize, "\en";
\&    $res\->udppacketsize(2048);
.Ve
.PP
udppacketsize will set or get the packet size. If set to a value greater than
\&\fINet::DNS::PACKETSZ()\fR an \s-1EDNS\s0 extension will be added indicating support for \s-1MTU\s0 path
recovery.
.PP
Default udppacketsize is \fINet::DNS::PACKETSZ()\fR (512)
.SH "CUSTOMIZING"
.IX Header "CUSTOMIZING"
Net::DNS::Resolver is actually an empty subclass.  At compile time a
super class is chosen based on the current platform.  A side benefit of
this allows for easy modification of the methods in Net::DNS::Resolver.
You simply add a method to the namespace!
.PP
For example, if we wanted to cache lookups:
.PP
.Vb 1
\& package Net::DNS::Resolver;
\&
\& my %cache;
\&
\& sub search {
\&        my ($self, @args) = @_;
\&
\&        return $cache{@args} ||= $self\->SUPER::search(@args);
\& }
.Ve
.SH "IPv6 transport"
.IX Header "IPv6 transport"
The Net::DNS::Resolver library will use IPv6 transport if the
appropriate libraries (Socket6 and IO::Socket::INET6) are available
and the address the server tries to connect to is an IPv6 address.
.PP
The \fIprint()\fR will method will report if IPv6 transport is available.
.PP
You can use the \fIforce_v4()\fR method with a non-zero argument
to force IPv4 transport.
.PP
The \fInameserver()\fR method has IPv6 dependend behavior. If IPv6 is not
available or IPv4 transport has been forced the \fInameserver()\fR method
will only return IPv4 addresses.
.PP
For example
.PP
.Vb 3
\&    $res\->nameservers(\*(Aq192.168.1.1\*(Aq, \*(Aq192.168.2.2\*(Aq, \*(Aq2001:610:240:0:53:0:0:3\*(Aq);
\&    $res\->force_v4(1);
\&    print join (" ",$res\->nameserver());
.Ve
.PP
Will print: 192.168.1.1 192.168.2.2
.SH "ENVIRONMENT"
.IX Header "ENVIRONMENT"
The following environment variables can also be used to configure
the resolver:
.SS "\s-1RES_NAMESERVERS\s0"
.IX Subsection "RES_NAMESERVERS"
.Vb 3
\&    # Bourne Shell
\&    RES_NAMESERVERS="192.168.1.1 192.168.2.2 192.168.3.3"
\&    export RES_NAMESERVERS
\&
\&    # C Shell
\&    setenv RES_NAMESERVERS "192.168.1.1 192.168.2.2 192.168.3.3"
.Ve
.PP
A space-separated list of nameservers to query.
.SS "\s-1RES_SEARCHLIST\s0"
.IX Subsection "RES_SEARCHLIST"
.Vb 3
\&    # Bourne Shell
\&    RES_SEARCHLIST="example.com sub1.example.com sub2.example.com"
\&    export RES_SEARCHLIST
\&
\&    # C Shell
\&    setenv RES_SEARCHLIST "example.com sub1.example.com sub2.example.com"
.Ve
.PP
A space-separated list of domains to put in the search list.
.SS "\s-1LOCALDOMAIN\s0"
.IX Subsection "LOCALDOMAIN"
.Vb 3
\&    # Bourne Shell
\&    LOCALDOMAIN=example.com
\&    export LOCALDOMAIN
\&
\&    # C Shell
\&    setenv LOCALDOMAIN example.com
.Ve
.PP
The default domain.
.SS "\s-1RES_OPTIONS\s0"
.IX Subsection "RES_OPTIONS"
.Vb 3
\&    # Bourne Shell
\&    RES_OPTIONS="retrans:3 retry:2 debug"
\&    export RES_OPTIONS
\&
\&    # C Shell
\&    setenv RES_OPTIONS "retrans:3 retry:2 debug"
.Ve
.PP
A space-separated list of resolver options to set.  Options that
take values are specified as \fIoption\fR:\fIvalue\fR.
.SH "BUGS"
.IX Header "BUGS"
Error reporting and handling needs to be improved.
.PP
The current implementation supports \s-1TSIG\s0 only on outgoing packets.
No validation of server replies is performed.
.PP
bgsend does not honor the usevc flag and only uses \s-1UDP\s0 for transport.
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (c) 1997\-2002 Michael Fuhr.
.PP
Portions Copyright (c) 2002\-2004 Chris Reinhardt.
Portions Copyright (c) 2005 Olaf M. Kolkman, NLnet Labs.
.PP
All rights reserved.  This program is free software; you may redistribute
it and/or modify it under the same terms as Perl itself.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
perl, Net::DNS, Net::DNS::Packet, Net::DNS::Update,
Net::DNS::Header, Net::DNS::Question, Net::DNS::RR,
\&\fIresolver\fR\|(5), \s-1RFC 1035, RFC 1034\s0 Section 4.3.5
