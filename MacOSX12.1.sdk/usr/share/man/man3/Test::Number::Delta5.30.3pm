.\" Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Test::Number::Delta 3"
.TH Test::Number::Delta 3 "2014-11-25" "perl v5.30.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Test::Number::Delta \- Compare the difference between numbers against a given tolerance
.SH "VERSION"
.IX Header "VERSION"
version 1.06
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&  # Import test functions
\&  use Test::Number::Delta;
\&
\&  # Equality test with default tolerance
\&  delta_ok( 1e\-5, 2e\-5, \*(Aqvalues within 1e\-6\*(Aq);
\&
\&  # Inequality test with default tolerance
\&  delta_not_ok( 1e\-5, 2e\-5, \*(Aqvalues not within 1e\-6\*(Aq);
\&
\&  # Provide specific tolerance
\&  delta_within( 1e\-3, 2e\-3, 1e\-4, \*(Aqvalues within 1e\-4\*(Aq);
\&  delta_not_within( 1e\-3, 2e\-3, 1e\-4, \*(Aqvalues not within 1e\-4\*(Aq);
\&
\&  # Compare arrays or matrices
\&  @a = ( 3.14, 1.41 );
\&  @b = ( 3.15, 1.41 );
\&  delta_ok( \e@a, \e@b, \*(Aqcompare @a and @b\*(Aq );
\&
\&  # Set a different default tolerance
\&  use Test::Number::Delta within => 1e\-5;
\&  delta_ok( 1.1e\-5, 2e\-5, \*(Aqvalues within 1e\-5\*(Aq); # ok
\&
\&  # Set a relative tolerance
\&  use Test::Number::Delta relative => 1e\-3;
\&  delta_ok( 1.01, 1.0099, \*(Aqvalues within 1.01e\-3\*(Aq);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
At some point or another, most programmers find they need to compare
floating-point numbers for equality.  The typical idiom is to test
if the absolute value of the difference of the numbers is within a desired
tolerance, usually called epsilon.  This module provides such a function for use
with Test::More.  Usage is similar to other test functions described in
Test::More.  Semantically, the \f(CW\*(C`delta_within\*(C'\fR function replaces this kind
of construct:
.PP
.Vb 2
\& ok ( abs($p \- $q) < $epsilon, \*(Aq$p is equal to $q\*(Aq ) or
\&     diag "$p is not equal to $q to within $epsilon";
.Ve
.PP
While there's nothing wrong with that construct, it's painful to type it
repeatedly in a test script.  This module does the same thing with a single
function call.  The \f(CW\*(C`delta_ok\*(C'\fR function is similar, but either uses a global
default value for epsilon or else calculates a 'relative' epsilon on
the fly so that epsilon is scaled automatically to the size of the arguments to
\&\f(CW\*(C`delta_ok\*(C'\fR.  Both functions are exported automatically.
.PP
Because checking floating-point equality is not always reliable, it is not
possible to check the 'equal to' boundary of 'less than or equal to
epsilon'.  Therefore, Test::Number::Delta only compares if the absolute value
of the difference is \fBless than\fR epsilon (for equality tests) or
\&\fBgreater than\fR epsilon (for inequality tests).
.SH "USAGE"
.IX Header "USAGE"
.SS "use Test::Number::Delta;"
.IX Subsection "use Test::Number::Delta;"
With no arguments, epsilon defaults to 1e\-6. (An arbitrary choice on the
author's part.)
.SS "use Test::Number::Delta within => 1e\-9;"
.IX Subsection "use Test::Number::Delta within => 1e-9;"
To specify a different default value for epsilon, provide a \f(CW\*(C`within\*(C'\fR parameter
when importing the module.  The value must be non-zero.
.SS "use Test::Number::Delta relative => 1e\-3;"
.IX Subsection "use Test::Number::Delta relative => 1e-3;"
As an alternative to using a fixed value for epsilon, provide a \f(CW\*(C`relative\*(C'\fR
parameter when importing the module.  This signals that \f(CW\*(C`delta_ok\*(C'\fR should
test equality with an epsilon that is scaled to the size of the arguments.
Epsilon is calculated as the relative value times the absolute value
of the argument with the greatest magnitude.  Mathematically, for arguments
\&'x' and 'y':
.PP
.Vb 1
\& epsilon = relative * max( abs(x), abs(y) )
.Ve
.PP
For example, a relative value of \*(L"0.01\*(R" would mean that the arguments are equal
if they differ by less than 1% of the larger of the two values.  A relative
value of 1e\-6 means that the arguments must differ by less than 1 millionth
of the larger value.  The relative value must be non-zero.
.SS "Combining with a test plan"
.IX Subsection "Combining with a test plan"
.Vb 1
\& use Test::Number::Delta \*(Aqno_plan\*(Aq;
\&
\& # or
\&
\& use Test::Number::Delta within => 1e\-9, tests => 1;
.Ve
.PP
If a test plan has not already been specified, the optional
parameter for Test::Number::Delta may be followed with a test plan (see
Test::More for details).  If a parameter for Test::Number::Delta is
given, it must come first.
.SH "FUNCTIONS"
.IX Header "FUNCTIONS"
.SS "delta_within"
.IX Subsection "delta_within"
.Vb 2
\& delta_within(  $p,  $q, $epsilon, \*(Aq$p and $q are equal within $epsilon\*(Aq );
\& delta_within( \e@p, \e@q, $epsilon, \*(Aq@p and @q are equal within $epsilon\*(Aq );
.Ve
.PP
This function tests for equality within a given value of epsilon. The test is
true if the absolute value of the difference between \f(CW$p\fR and \f(CW$q\fR is \fBless than\fR
epsilon.  If the test is true, it prints an \*(L"\s-1OK\*(R"\s0 statement for use in testing.
If the test is not true, this function prints a failure report and diagnostic.
Epsilon must be non-zero.
.PP
The values to compare may be scalars or references to arrays.  If the values
are references to arrays, the comparison is done pairwise for each index value
of the array.  The pairwise comparison is recursive, so matrices may
be compared as well.
.PP
For example, this code sample compares two matrices:
.PP
.Vb 2
\&    my @a = (   [ 3.14, 6.28 ],
\&                [ 1.41, 2.84 ]   );
\&
\&    my @b = (   [ 3.14, 6.28 ],
\&                [ 1.42, 2.84 ]   );
\&
\&    delta_within( \e@a, \e@b, 1e\-6, \*(Aqcompare @a and @b\*(Aq );
.Ve
.PP
The sample prints the following:
.PP
.Vb 2
\&    not ok 1 \- compare @a and @b
\&    # At [1][0]: 1.4100000 and 1.4200000 are not equal to within 0.000001
.Ve
.SS "delta_ok"
.IX Subsection "delta_ok"
.Vb 2
\& delta_ok(  $p,  $q, \*(Aq$p and $q are close enough to equal\*(Aq );
\& delta_ok( \e@p, \e@q, \*(Aq@p and @q are close enough to equal\*(Aq );
.Ve
.PP
This function tests for equality within a default epsilon value.  See \*(L"\s-1USAGE\*(R"\s0
for details on changing the default.  Otherwise, this function works the same
as \f(CW\*(C`delta_within\*(C'\fR.
.SS "delta_not_within"
.IX Subsection "delta_not_within"
.Vb 2
\& delta_not_within(  $p,  $q, \*(Aq$p and $q are different\*(Aq );
\& delta_not_within( \e@p, \e@q, $epsilon, \*(Aq@p and @q are different\*(Aq );
.Ve
.PP
This test compares inequality in excess of a given value of epsilon. The test
is true if the absolute value of the difference between \f(CW$p\fR and \f(CW$q\fR is \fBgreater
than\fR epsilon.  For array or matrix comparisons, the test is true if \fIany\fR
pair of values differs by more than epsilon.  Otherwise, this function works
the same as \f(CW\*(C`delta_within\*(C'\fR.
.SS "delta_not_ok"
.IX Subsection "delta_not_ok"
.Vb 2
\& delta_not_ok(  $p,  $q, \*(Aq$p and $q are different\*(Aq );
\& delta_not_ok( \e@p, \e@q, \*(Aq@p and @q are different\*(Aq );
.Ve
.PP
This function tests for inequality in excess of a default epsilon value.  See
\&\*(L"\s-1USAGE\*(R"\s0 for details on changing the default.  Otherwise, this function works
the same as \f(CW\*(C`delta_not_within\*(C'\fR.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.IP "\(bu" 4
Number::Tolerant
.IP "\(bu" 4
Test::Deep::NumberTolerant
.SH "SUPPORT"
.IX Header "SUPPORT"
.SS "Bugs / Feature Requests"
.IX Subsection "Bugs / Feature Requests"
Please report any bugs or feature requests through the issue tracker
at <https://github.com/dagolden/Test\-Number\-Delta/issues>.
You will be notified automatically of any progress on your issue.
.SS "Source Code"
.IX Subsection "Source Code"
This is open source software.  The code repository is available for
public review and contribution under the terms of the license.
.PP
<https://github.com/dagolden/Test\-Number\-Delta>
.PP
.Vb 1
\&  git clone https://github.com/dagolden/Test\-Number\-Delta.git
.Ve
.SH "AUTHOR"
.IX Header "AUTHOR"
David Golden <dagolden@cpan.org>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is Copyright (c) 2014 by David Golden.
.PP
This is free software, licensed under:
.PP
.Vb 1
\&  The Apache License, Version 2.0, January 2004
.Ve
