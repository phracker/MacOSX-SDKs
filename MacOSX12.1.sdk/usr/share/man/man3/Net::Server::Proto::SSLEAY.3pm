.\" Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Net::Server::Proto::SSLEAY 3"
.TH Net::Server::Proto::SSLEAY 3 "2017-08-10" "perl v5.30.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Net::Server::Proto::SSLEAY \- Custom Net::Server SSL protocol handler based on Net::SSLeay.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
See Net::Server::Proto.
.PP
.Vb 6
\&    use base qw(Net::Server::HTTP);
\&    main\->run(
\&        proto => \*(Aqssleay\*(Aq,
\&        SSL_key_file  => "/path/to/my/file.key",
\&        SSL_cert_file => "/path/to/my/file.crt",
\&    );
\&
\&
\&    # OR
\&
\&    sub SSL_key_file  { "/path/to/my/file.key" }
\&    sub SSL_cert_file { "/path/to/my/file.crt" }
\&    main\->run(proto => \*(Aqssleay\*(Aq);
\&
\&
\&    # OR
\&
\&    main\->run(
\&        port => [443, 8443, "80/tcp"],  # bind to two ssleay ports and one tcp
\&        proto => "ssleay",    # use ssleay as the default
\&        ipv  => "*",          # bind both IPv4 and IPv6 interfaces
\&        SSL_key_file  => "/path/to/my/file.key",
\&        SSL_cert_file => "/path/to/my/file.crt",
\&    );
\&
\&
\&    # OR
\&
\&    main\->run(port => [{
\&        port  => "443",
\&        proto => "ssleay",
\&        # ipv => 4, # default \- only do IPv4
\&        SSL_key_file  => "/path/to/my/file.key",
\&        SSL_cert_file => "/path/to/my/file.crt",
\&    }, {
\&        port  => "8443",
\&        proto => "ssleay",
\&        ipv   => "*", # IPv4 and IPv6
\&        SSL_key_file  => "/path/to/my/file2.key", # separate key
\&        SSL_cert_file => "/path/to/my/file2.crt", # separate cert
\&    }]);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module has reliably been used in situations receiving millions of
hits on a single box per day.  If anybody has any successes or ideas
for improvment under \s-1SSLEAY,\s0 please email <paul@seamons.com>.
.PP
Protocol module for Net::Server.  This module implements a secure
socket layer over tcp (also known as \s-1SSL\s0).  See Net::Server::Proto.
.PP
If you need more customization of the \s-1SSL\s0 layer, you may want to
investigate using \s-1SSL\s0 rather than \s-1SSLEAY\s0 as it uses the venerable(ish)
IO::Socket::SSL.
.SH "PARAMETERS"
.IX Header "PARAMETERS"
Currently there is support for the following:
.ie n .IP """SSL_cert_file""" 4
.el .IP "\f(CWSSL_cert_file\fR" 4
.IX Item "SSL_cert_file"
Full path to the certificate file to be used for this server.  Should
be in \s-1PEM\s0 format.
.ie n .IP """SSL_key_file""" 4
.el .IP "\f(CWSSL_key_file\fR" 4
.IX Item "SSL_key_file"
Full path to the key file to be used for this server.  Should be in
\&\s-1PEM\s0 format.
.ie n .IP """SSL_max_getline_length""" 4
.el .IP "\f(CWSSL_max_getline_length\fR" 4
.IX Item "SSL_max_getline_length"
Used during getline to only read until this many bytes are found.
Default is undef which means unlimited.
.ie n .IP """SSL_error_callback""" 4
.el .IP "\f(CWSSL_error_callback\fR" 4
.IX Item "SSL_error_callback"
Should be a code ref that will be called whenever error conditions are
encountered.  It passes a source message and an arrayref of the
errors.
.SH "METHODS"
.IX Header "METHODS"
This module implements most of the common file handle operations.
There are some additions though:
.ie n .IP """read_until""" 4
.el .IP "\f(CWread_until\fR" 4
.IX Item "read_until"
Takes bytes and match qr.  If bytes is defined \- it will read until
that many bytes are found.  If match qr is defined, it will read until
the buffer matches that qr.  If both are undefined, it will read until
there is nothing left to read.
.ie n .IP """error""" 4
.el .IP "\f(CWerror\fR" 4
.IX Item "error"
If an error occurred while writing, this method will return that error.
.SH "BUGS"
.IX Header "BUGS"
There are probably many.
.SH "LICENCE"
.IX Header "LICENCE"
Distributed under the same terms as Net::Server
.SH "THANKS"
.IX Header "THANKS"
Thanks to Bilbo at
http://devpit.org/wiki/OpenSSL_with_nonblocking_sockets_%28in_Perl%29
for documenting a more reliable way of accepting and reading \s-1SSL\s0
connections.
