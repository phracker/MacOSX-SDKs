.\" Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "install::TempContent::Objects::mod_perl-2.0.9::docs::api::APR::Bucket 3"
.TH install::TempContent::Objects::mod_perl-2.0.9::docs::api::APR::Bucket 3 "2015-06-18" "perl v5.30.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
APR::Bucket \- Perl API for manipulating APR Buckets
.SH "Synopsis"
.IX Header "Synopsis"
.Vb 2
\&  use APR::Bucket ();
\&  my $ba = $c\->bucket_alloc;
\&  
\&  $b1 = APR::Bucket\->new($ba, "aaa");
\&  $b2 = APR::Bucket::eos_create($ba);
\&  $b3 = APR::Bucket::flush_create($ba);
\&  
\&  $b2\->is_eos;
\&  $b3\->is_flush;
\&  
\&  $len = $b1\->length;
\&  $len = $b1\->read($data);
\&  $type = $b1\->type;
\&  
\&  $b1\->insert_after($b2);
\&  $b1\->insert_before($b3);
\&  $b1\->remove;
\&  $b1\->destroy;
\&  
\&  $b2\->delete; # remove+destroy
\&  
\&  $b4 = APR::Bucket\->new($ba, "to be setaside");
\&  $b4\->setaside($pool);
.Ve
.SH "Description"
.IX Header "Description"
\&\f(CW\*(C`APR::Bucket\*(C'\fR allows you to create, manipulate and delete \s-1APR\s0
buckets.
.PP
You will probably find the various insert methods confusing, the tip
is to read the function right to left. The following code sample helps
to visualize the operations:
.PP
.Vb 12
\&  my $bb = APR::Brigade\->new($r\->pool, $ba);
\&  my $d1 = APR::Bucket\->new($ba, "d1");
\&  my $d2 = APR::Bucket\->new($ba, "d2");
\&  my $f1 = APR::Bucket::flush_create($ba);
\&  my $f2 = APR::Bucket::flush_create($ba);
\&  my $e1 = APR::Bucket::eos_create($ba);
\&                           # head\->tail
\&  $bb\->insert_head(  $d1); # head\->d1\->tail
\&  $d1\->insert_after( $d2); # head\->d1\->d2\->tail
\&  $d2\->insert_before($f1); # head\->d1\->f1\->d2\->tail
\&  $d2\->insert_after( $f2); # head\->d1\->f1\->d2\->f2\->tail
\&  $bb\->insert_tail(  $e1); # head\->d1\->f1\->d2\->f2\->e1\->tail
.Ve
.SH "API"
.IX Header "API"
\&\f(CW\*(C`APR::Bucket\*(C'\fR provides the following functions and/or methods:
.ie n .SS """delete"""
.el .SS "\f(CWdelete\fP"
.IX Subsection "delete"
Tell the bucket to remove itself from the bucket brigade it belongs
to, and destroy itself.
.PP
.Vb 1
\&  $bucket\->delete();
.Ve
.ie n .IP "obj: $bucket ( ""APR::Bucket object"" )" 4
.el .IP "obj: \f(CW$bucket\fR ( \f(CWAPR::Bucket object\fR )" 4
.IX Item "obj: $bucket ( APR::Bucket object )"
.PD 0
.IP "ret: no return value" 4
.IX Item "ret: no return value"
.IP "since: 2.0.00" 4
.IX Item "since: 2.0.00"
.PD
.PP
If the bucket is not attached to any bucket brigade then this
operation just destroys the bucket.
.PP
\&\f(CW\*(C`delete\*(C'\fR is a convenience wrapper, internally doing:
.PP
.Vb 2
\&  $b\->remove;
\&  $b\->destroy;
.Ve
.PP
Examples:
.PP
Assuming that \f(CW$bb\fR already exists and filled with buckets, replace
the existing data buckets with new buckets with upcased data;
.PP
.Vb 8
\&  for (my $b = $bb\->first; $b; $b = $bb\->next($b)) {
\&     if ($b\->read(my $data)) {
\&          my $nb = APR::Bucket\->new($bb\->bucket_alloc, uc $data);
\&          $b\->insert_before($nb);
\&          $b\->delete;
\&          $b = $nb;
\&      }
\&  }
.Ve
.ie n .SS """destroy"""
.el .SS "\f(CWdestroy\fP"
.IX Subsection "destroy"
Free the resources used by a bucket. If multiple buckets refer to the
same resource it is freed when the last one goes away.
.PP
.Vb 1
\&  $bucket\->destroy();
.Ve
.ie n .IP "obj: $bucket ( ""APR::Bucket object"" )" 4
.el .IP "obj: \f(CW$bucket\fR ( \f(CWAPR::Bucket object\fR )" 4
.IX Item "obj: $bucket ( APR::Bucket object )"
.PD 0
.IP "ret: no return value" 4
.IX Item "ret: no return value"
.IP "since: 2.0.00" 4
.IX Item "since: 2.0.00"
.PD
.PP
A bucket needs to be destroyed if it was removed from a
bucket brigade, to avoid memory leak.
.PP
If a bucket is linked to a bucket brigade, it needs to be
removed from it, before it can be destroyed.
.PP
Usually instead of calling:
.PP
.Vb 2
\&  $b\->remove;
\&  $b\->destroy;
.Ve
.PP
it's better to call \f(CW\*(C`delete\*(C'\fR which does exactly that.
.ie n .SS """eos_create"""
.el .SS "\f(CWeos_create\fP"
.IX Subsection "eos_create"
Create an \fIEndOfStream\fR bucket.
.PP
.Vb 1
\&  $b = APR::Bucket::eos_create($ba);
.Ve
.ie n .IP "arg1: $ba ( ""APR::BucketAlloc object"" )" 4
.el .IP "arg1: \f(CW$ba\fR ( \f(CWAPR::BucketAlloc object\fR )" 4
.IX Item "arg1: $ba ( APR::BucketAlloc object )"
The freelist from which this bucket should be allocated
.ie n .IP "ret: $b ( ""APR::Bucket object"" )" 4
.el .IP "ret: \f(CW$b\fR ( \f(CWAPR::Bucket object\fR )" 4
.IX Item "ret: $b ( APR::Bucket object )"
The new bucket
.IP "since: 2.0.00" 4
.IX Item "since: 2.0.00"
.PP
This bucket type indicates that there is no more data coming from down
the filter stack.  All filters should flush any buffered data at this
point.
.PP
Example:
.PP
.Vb 4
\&  use APR::Bucket ();
\&  use Apache2::Connection ();
\&  my $ba = $c\->bucket_alloc;
\&  my $eos_b = APR::Bucket::eos_create($ba);
.Ve
.ie n .SS """flush_create"""
.el .SS "\f(CWflush_create\fP"
.IX Subsection "flush_create"
Create a flush bucket.
.PP
.Vb 1
\&  $b = APR::Bucket::flush_create($ba);
.Ve
.ie n .IP "arg1: $ba ( ""APR::BucketAlloc object"" )" 4
.el .IP "arg1: \f(CW$ba\fR ( \f(CWAPR::BucketAlloc object\fR )" 4
.IX Item "arg1: $ba ( APR::BucketAlloc object )"
The freelist from which this bucket should be allocated
.ie n .IP "ret: $b ( ""APR::Bucket object"" )" 4
.el .IP "ret: \f(CW$b\fR ( \f(CWAPR::Bucket object\fR )" 4
.IX Item "ret: $b ( APR::Bucket object )"
The new bucket
.IP "since: 2.0.00" 4
.IX Item "since: 2.0.00"
.PP
This bucket type indicates that filters should flush their data.
There is no guarantee that they will flush it, but this is the best we
can do.
.ie n .SS """insert_after"""
.el .SS "\f(CWinsert_after\fP"
.IX Subsection "insert_after"
Insert a list of buckets after a specified bucket
.PP
.Vb 1
\&  $after_bucket\->insert_after($add_bucket);
.Ve
.ie n .IP "obj: $after_bucket ( ""APR::Bucket object"" )" 4
.el .IP "obj: \f(CW$after_bucket\fR ( \f(CWAPR::Bucket object\fR )" 4
.IX Item "obj: $after_bucket ( APR::Bucket object )"
The bucket to insert after
.ie n .IP "arg1: $add_bucket ( ""APR::Bucket object"" )" 4
.el .IP "arg1: \f(CW$add_bucket\fR ( \f(CWAPR::Bucket object\fR )" 4
.IX Item "arg1: $add_bucket ( APR::Bucket object )"
The buckets to insert. It says buckets, since \f(CW$add_bucket\fR may have
more buckets attached after itself.
.IP "ret: no return value" 4
.IX Item "ret: no return value"
.PD 0
.IP "since: 2.0.00" 4
.IX Item "since: 2.0.00"
.PD
.ie n .SS """insert_before"""
.el .SS "\f(CWinsert_before\fP"
.IX Subsection "insert_before"
Insert a list of buckets before a specified bucket
.PP
.Vb 1
\&  $before_bucket\->insert_before($add_bucket);
.Ve
.ie n .IP "obj: $before_bucket ( ""APR::Bucket object"" )" 4
.el .IP "obj: \f(CW$before_bucket\fR ( \f(CWAPR::Bucket object\fR )" 4
.IX Item "obj: $before_bucket ( APR::Bucket object )"
The bucket to insert before
.ie n .IP "arg1: $add_bucket ( ""APR::Bucket object"" )" 4
.el .IP "arg1: \f(CW$add_bucket\fR ( \f(CWAPR::Bucket object\fR )" 4
.IX Item "arg1: $add_bucket ( APR::Bucket object )"
The buckets to insert. It says buckets, since \f(CW$add_bucket\fR may have
more buckets attached after itself.
.IP "ret: no return value" 4
.IX Item "ret: no return value"
.PD 0
.IP "since: 2.0.00" 4
.IX Item "since: 2.0.00"
.PD
.ie n .SS """is_eos"""
.el .SS "\f(CWis_eos\fP"
.IX Subsection "is_eos"
Determine if a bucket is an \s-1EOS\s0 bucket
.PP
.Vb 1
\&  $ret = $bucket\->is_eos();
.Ve
.ie n .IP "obj: $bucket ( ""APR::Bucket object"" )" 4
.el .IP "obj: \f(CW$bucket\fR ( \f(CWAPR::Bucket object\fR )" 4
.IX Item "obj: $bucket ( APR::Bucket object )"
.PD 0
.ie n .IP "ret: $ret ( boolean )" 4
.el .IP "ret: \f(CW$ret\fR ( boolean )" 4
.IX Item "ret: $ret ( boolean )"
.IP "since: 2.0.00" 4
.IX Item "since: 2.0.00"
.PD
.ie n .SS """is_flush"""
.el .SS "\f(CWis_flush\fP"
.IX Subsection "is_flush"
Determine if a bucket is a \s-1FLUSH\s0 bucket
.PP
.Vb 1
\&  $ret = $bucket\->is_flush();
.Ve
.ie n .IP "obj: $bucket ( ""APR::Bucket object"" )" 4
.el .IP "obj: \f(CW$bucket\fR ( \f(CWAPR::Bucket object\fR )" 4
.IX Item "obj: $bucket ( APR::Bucket object )"
.PD 0
.ie n .IP "ret: $ret ( boolean )" 4
.el .IP "ret: \f(CW$ret\fR ( boolean )" 4
.IX Item "ret: $ret ( boolean )"
.IP "since: 2.0.00" 4
.IX Item "since: 2.0.00"
.PD
.ie n .SS """length"""
.el .SS "\f(CWlength\fP"
.IX Subsection "length"
Get the length of the data in the bucket.
.PP
.Vb 1
\&  $len = $b\->length;
.Ve
.ie n .IP "obj: $b ( ""APR::Bucket object"" )" 4
.el .IP "obj: \f(CW$b\fR ( \f(CWAPR::Bucket object\fR )" 4
.IX Item "obj: $b ( APR::Bucket object )"
.PD 0
.ie n .IP "ret: $len ( integer )" 4
.el .IP "ret: \f(CW$len\fR ( integer )" 4
.IX Item "ret: $len ( integer )"
.PD
If the length is unknown, \f(CW$len\fR value will be \-1.
.IP "since: 2.0.00" 4
.IX Item "since: 2.0.00"
.ie n .SS """new"""
.el .SS "\f(CWnew\fP"
.IX Subsection "new"
Create a new bucket and initialize it with data:
.PP
.Vb 4
\&  $nb = APR::Bucket\->new($ba, $data);
\&  $nb =          $b\->new($ba, $data);
\&  $nb = APR::Bucket\->new($ba, $data, $offset);
\&  $nb = APR::Bucket\->new($ba, $data, $offset, $len);
.Ve
.ie n .IP "obj: $b ( ""APR::Bucket object or class"" )" 4
.el .IP "obj: \f(CW$b\fR ( \f(CWAPR::Bucket object or class\fR )" 4
.IX Item "obj: $b ( APR::Bucket object or class )"
.PD 0
.ie n .IP "arg1: $ba ( ""APR::BucketAlloc object"" )" 4
.el .IP "arg1: \f(CW$ba\fR ( \f(CWAPR::BucketAlloc object\fR )" 4
.IX Item "arg1: $ba ( APR::BucketAlloc object )"
.ie n .IP "arg2: $data ( string )" 4
.el .IP "arg2: \f(CW$data\fR ( string )" 4
.IX Item "arg2: $data ( string )"
.PD
The data to initialize with.
.Sp
\&\fBImportant:\fR in order to avoid unnecessary data copying the variable
is stored in the bucket object. That means that if you modify \f(CW$data\fR
after passing it to \f(CW\*(C`new()\*(C'\fR you will modify the data in the bucket as
well. To avoid that pass to \f(CW\*(C`new()\*(C'\fR a copy which you won't modify.
.ie n .IP "opt arg3: $offset ( number )" 4
.el .IP "opt arg3: \f(CW$offset\fR ( number )" 4
.IX Item "opt arg3: $offset ( number )"
Optional offset inside \f(CW$data\fR. Default: 0.
.ie n .IP "opt arg4: $len ( number )" 4
.el .IP "opt arg4: \f(CW$len\fR ( number )" 4
.IX Item "opt arg4: $len ( number )"
Optional partial length to read.
.Sp
If \f(CW$offset\fR is specified, then:
.Sp
.Vb 1
\&  length $buffer \- $offset;
.Ve
.Sp
will be used. Otherwise the default is to use:
.Sp
.Vb 1
\&  length $buffer;
.Ve
.ie n .IP "ret: $nb ( ""APR::Bucket object"" )" 4
.el .IP "ret: \f(CW$nb\fR ( \f(CWAPR::Bucket object\fR )" 4
.IX Item "ret: $nb ( APR::Bucket object )"
a newly created bucket object
.IP "since: 2.0.00" 4
.IX Item "since: 2.0.00"
.PP
Examples:
.IP "\(bu" 4
Create a new bucket using a whole string:
.Sp
.Vb 3
\&  use APR::Bucket ();
\&  my $data = "my data";
\&  my $b = APR::Bucket\->new($ba, $data);
.Ve
.Sp
now the bucket contains the string \fI'my data'\fR.
.IP "\(bu" 4
Create a new bucket using a sub-string:
.Sp
.Vb 4
\&  use APR::Bucket ();
\&  my $data   = "my data";
\&  my $offset = 3;
\&  my $b = APR::Bucket\->new($ba, $data, $offset);
.Ve
.Sp
now the bucket contains the string \fI'data'\fR.
.IP "\(bu" 4
Create a new bucket not using the whole length and starting from an
offset:
.Sp
.Vb 5
\&  use APR::Bucket ();
\&  my $data   = "my data";
\&  my $offset = 3;
\&  my $len    = 3;
\&  my $b = APR::Bucket\->new($ba, $data, $offset, $len);
.Ve
.Sp
now the bucket contains the string \fI'dat'\fR.
.ie n .SS """read"""
.el .SS "\f(CWread\fP"
.IX Subsection "read"
Read the data from the bucket.
.PP
.Vb 2
\&  $len = $b\->read($buffer);
\&  $len = $b\->read($buffer, $block);
.Ve
.ie n .IP "obj: $b ( ""APR::Bucket object"" )" 4
.el .IP "obj: \f(CW$b\fR ( \f(CWAPR::Bucket object\fR )" 4
.IX Item "obj: $b ( APR::Bucket object )"
The bucket to read from
.ie n .IP "arg1: $buffer ( \s-1SCALAR\s0 )" 4
.el .IP "arg1: \f(CW$buffer\fR ( \s-1SCALAR\s0 )" 4
.IX Item "arg1: $buffer ( SCALAR )"
The buffer to fill. All previous data will be lost.
.ie n .IP "opt arg2: $block ( ""APR::Const :read_type constant"" )" 4
.el .IP "opt arg2: \f(CW$block\fR ( \f(CWAPR::Const :read_type constant\fR )" 4
.IX Item "opt arg2: $block ( APR::Const :read_type constant )"
optional reading mode constant.
.Sp
By default the read is blocking, via \f(CW\*(C`APR::Const::BLOCK_READ
constant\*(C'\fR.
.ie n .IP "ret: $len ( number )" 4
.el .IP "ret: \f(CW$len\fR ( number )" 4
.IX Item "ret: $len ( number )"
How many bytes were actually read
.Sp
\&\f(CW$buffer\fR gets populated with the string that is read. It will
contain an empty string if there was nothing to read.
.IP "since: 2.0.00" 4
.IX Item "since: 2.0.00"
.PD 0
.ie n .IP "excpt: ""APR::Error""" 4
.el .IP "excpt: \f(CWAPR::Error\fR" 4
.IX Item "excpt: APR::Error"
.PD
.PP
It's important to know that certain bucket types (e.g. file bucket),
may perform a split and insert extra buckets following the current
one. Therefore never call \f(CW\*(C`$b\->remove\*(C'\fR, before
calling \f(CW\*(C`$b\->read\*(C'\fR, or you may lose data.
.PP
Examples:
.PP
Blocking read:
.PP
.Vb 1
\&  my $len = $b\->read(my $buffer);
.Ve
.PP
Non-blocking read:
.PP
.Vb 2
\&  use APR::Const \-compile \*(AqNONBLOCK_READ\*(Aq;
\&  my $len = $b\->read(my $buffer, APR::Const::NONBLOCK_READ);
.Ve
.ie n .SS """remove"""
.el .SS "\f(CWremove\fP"
.IX Subsection "remove"
Tell the bucket to remove itself from the bucket brigade it belongs
to.
.PP
.Vb 1
\&  $bucket\->remove();
.Ve
.ie n .IP "obj: $bucket ( ""APR::Bucket object"" )" 4
.el .IP "obj: \f(CW$bucket\fR ( \f(CWAPR::Bucket object\fR )" 4
.IX Item "obj: $bucket ( APR::Bucket object )"
.PD 0
.IP "ret: no return value" 4
.IX Item "ret: no return value"
.IP "since: 2.0.00" 4
.IX Item "since: 2.0.00"
.PD
.PP
If the bucket is not attached to any bucket brigade then this
operation doesn't do anything.
.PP
When the bucket is removed, it's not not destroyed. Usually this is
done in order to move the bucket to another bucket brigade. Or to copy
the data way before destroying the bucket.  If the bucket wasn't moved
to another bucket brigade it must be destroyed.
.PP
Examples:
.PP
Assuming that \f(CW$bb1\fR already exists and filled with buckets, move
every odd bucket number to \f(CW$bb2\fR and every even to \f(CW$bb3\fR:
.PP
.Vb 10
\&  my $bb2 = APR::Brigade\->new($c\->pool, $c\->bucket_alloc);
\&  my $bb3 = APR::Brigade\->new($c\->pool, $c\->bucket_alloc);
\&  my $count = 0;
\&  while (my $bucket = $bb\->first) {
\&      $count++;
\&      $bucket\->remove;
\&      $count % 2
\&          ? $bb2\->insert_tail($bucket)
\&          : $bb3\->insert_tail($bucket);
\&  }
.Ve
.ie n .SS """setaside"""
.el .SS "\f(CWsetaside\fP"
.IX Subsection "setaside"
Ensure the bucket's data lasts at least as long as the given pool:
.PP
.Vb 1
\&  my $status = $b\->setaside($pool);
.Ve
.ie n .IP "obj: $b ( ""APR::Bucket object"" )" 4
.el .IP "obj: \f(CW$b\fR ( \f(CWAPR::Bucket object\fR )" 4
.IX Item "obj: $b ( APR::Bucket object )"
.PD 0
.ie n .IP "arg1: $pool ( ""APR::Pool object"" )" 4
.el .IP "arg1: \f(CW$pool\fR ( \f(CWAPR::Pool object\fR )" 4
.IX Item "arg1: $pool ( APR::Pool object )"
.ie n .IP "ret: ( ""APR::Const status constant"" )" 4
.el .IP "ret: ( \f(CWAPR::Const status constant\fR )" 4
.IX Item "ret: ( APR::Const status constant )"
.PD
On success,
\&\f(CW\*(C`APR::Const::SUCCESS\*(C'\fR is
returned. Otherwise a failure code is returned.
.ie n .IP "excpt: ""APR::Error""" 4
.el .IP "excpt: \f(CWAPR::Error\fR" 4
.IX Item "excpt: APR::Error"
when your code deals only with mod_perl buckets, you don't have to ask
for the return value. If this method is called in the \f(CW\*(C`VOID\*(C'\fR context,
i.e.:
.Sp
.Vb 1
\&  $b\->setaside($pool);
.Ve
.Sp
mod_perl will do the error checking on your behalf, and if the return
code is not
\&\f(CW\*(C`APR::Const::SUCCESS\*(C'\fR, an
\&\f(CW\*(C`APR::Error exception\*(C'\fR will be thrown.
.Sp
However if your code doesn't know which bucket types it may need to
setaside, you may want to check the return code and deal with any
errors. For example one of the possible error codes is
\&\f(CW\*(C`APR::Const::ENOTIMPL\*(C'\fR. As of
this writing the pipe and socket buckets can't \f(CW\*(C`setaside()\*(C'\fR, in which
case you may want to look at the \f(CW\*(C`ap_save_brigade()\*(C'\fR implementation.
.IP "since: 2.0.00" 4
.IX Item "since: 2.0.00"
.PP
Usually setaside is called by certain output filters, in order to
buffer socket writes of smaller buckets into a single write. This
method works on all bucket types (not only the mod_perl bucket type),
but as explained in the exceptions section, not all bucket types
implement this method.
.PP
When a mod_perl bucket is setaside, its data is detached from the
original perl scalar and copied into a pool bucket. That allows
downstream filters to deal with the data originally owned by a Perl
interpreter, making it possible for that interpreter to go away and do
other things, or be destroyed.
.ie n .SS """type"""
.el .SS "\f(CWtype\fP"
.IX Subsection "type"
Get the type of the data in the bucket.
.PP
.Vb 1
\&  $type = $b\->type;
.Ve
.ie n .IP "obj: $b ( ""APR::Bucket object"" )" 4
.el .IP "obj: \f(CW$b\fR ( \f(CWAPR::Bucket object\fR )" 4
.IX Item "obj: $b ( APR::Bucket object )"
.PD 0
.ie n .IP "ret: $type ( ""APR::BucketType object"" )" 4
.el .IP "ret: \f(CW$type\fR ( \f(CWAPR::BucketType object\fR )" 4
.IX Item "ret: $type ( APR::BucketType object )"
.IP "since: 2.0.00" 4
.IX Item "since: 2.0.00"
.PD
.PP
You need to invoke
\&\f(CW\*(C`APR::BucketType\*(C'\fR methods to
access the data.
.PP
Example:
.PP
Create a flush bucket and read its type's name:
.PP
.Vb 5
\&  use APR::Bucket ();
\&  use APR::BucketType ();
\&  my $b = APR::Bucket::flush_create($ba);
\&  my $type = $b\->type;
\&  my $type_name =  $type\->name; # FLUSH
.Ve
.PP
The type name will be \fI'\s-1FLUSH\s0'\fR in this example.
.SH "Unsupported API"
.IX Header "Unsupported API"
\&\f(CW\*(C`APR::Socket\*(C'\fR also provides auto-generated Perl interface for a few
other methods which aren't tested at the moment and therefore their
\&\s-1API\s0 is a subject to change. These methods will be finalized later as a
need arises. If you want to rely on any of the following methods
please contact the the mod_perl development mailing
list so we can help each other take the steps necessary
to shift the method to an officially supported \s-1API.\s0
.ie n .SS """data"""
.el .SS "\f(CWdata\fP"
.IX Subsection "data"
.Vb 1
\&  $data = $b\->data;
.Ve
.PP
Gives a C pointer to the address of the data in the bucket. I can't
see what use can be done of it in Perl.
.ie n .IP "obj: $b ( ""APR::Bucket object"" )" 4
.el .IP "obj: \f(CW$b\fR ( \f(CWAPR::Bucket object\fR )" 4
.IX Item "obj: $b ( APR::Bucket object )"
.PD 0
.ie n .IP "ret: $data ( C pointer )" 4
.el .IP "ret: \f(CW$data\fR ( C pointer )" 4
.IX Item "ret: $data ( C pointer )"
.IP "since: subject to change" 4
.IX Item "since: subject to change"
.PD
.ie n .SS """start"""
.el .SS "\f(CWstart\fP"
.IX Subsection "start"
.Vb 1
\&  $start = $b\->start;
.Ve
.PP
It gives the offset to when a new bucket is created with a non-zero
offset value:
.PP
.Vb 1
\&  my $b = APR::Bucket\->new($ba, $data, $offset, $len);
.Ve
.PP
So if the offset was 3. \f(CW$start\fR will be 3 too.
.PP
I fail to see what it can be useful for to the end user (it's mainly
used internally).
.ie n .IP "obj: $b ( ""APR::Bucket object"" )" 4
.el .IP "obj: \f(CW$b\fR ( \f(CWAPR::Bucket object\fR )" 4
.IX Item "obj: $b ( APR::Bucket object )"
.PD 0
.ie n .IP "ret: $start ( offset number )" 4
.el .IP "ret: \f(CW$start\fR ( offset number )" 4
.IX Item "ret: $start ( offset number )"
.IP "since: subject to change" 4
.IX Item "since: subject to change"
.PD
.SH "See Also"
.IX Header "See Also"
mod_perl 2.0 documentation.
.SH "Copyright"
.IX Header "Copyright"
mod_perl 2.0 and its core modules are copyrighted under
The Apache Software License, Version 2.0.
.SH "Authors"
.IX Header "Authors"
The mod_perl development team and numerous
contributors.
