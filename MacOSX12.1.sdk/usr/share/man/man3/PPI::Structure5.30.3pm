.\" Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "PPI::Structure 3"
.TH PPI::Structure 3 "2019-07-09" "perl v5.30.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
PPI::Structure \- The base class for Perl braced structures
.SH "INHERITANCE"
.IX Header "INHERITANCE"
.Vb 3
\&  PPI::Structure
\&  isa PPI::Node
\&      isa PPI::Element
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
PPI::Structure is the root class for all Perl bracing structures. This
covers all forms of \f(CW\*(C` [ ... ] \*(C'\fR, \f(CW\*(C` { ... } \*(C'\fR, and \f(CW\*(C` ( ... ) \*(C'\fR brace
types, and includes cases where only one half of the pair exist.
.PP
The class PPI::Structure itself is full abstract and no objects of that
type should actually exist in the tree.
.SS "Elements vs Children"
.IX Subsection "Elements vs Children"
A \fBPPI::Structure\fR has an unusual existence. Unlike a PPI::Document
or PPI::Statement, which both simply contain other elements, a
structure \fBboth\fR contains and consists of content.
.PP
That is, the brace tokens are \fBnot\fR considered to be \*(L"children\*(R" of the
structure, but are part of it.
.PP
In practice, this will mean that while the \->elements and \->tokens
methods (and related) \fBwill\fR return a list with the brace tokens at either
end, the \->children method explicitly will \fBnot\fR return the brace.
.SH "STRUCTURE CLASSES"
.IX Header "STRUCTURE CLASSES"
Excluding the transient PPI::Structure::Unknown that exists briefly
inside the parser, there are eight types of structure.
.SS "PPI::Structure::List"
.IX Subsection "PPI::Structure::List"
This covers all round braces used for function arguments, in \f(CW\*(C`foreach\*(C'\fR
loops, literal lists, and braces used for precedence-ordering purposes.
.SS "PPI::Structure::For"
.IX Subsection "PPI::Structure::For"
Although \fBnot\fR used for the \f(CW\*(C`foreach\*(C'\fR loop list, this \fBis\fR used for
the special case of the round-brace three-part semicolon-separated \f(CW\*(C`for\*(C'\fR
loop expression (the traditional C style for loop).
.SS "PPI::Structure::Given"
.IX Subsection "PPI::Structure::Given"
This is for the expression being matched in switch statements.
.SS "PPI::Structure::When"
.IX Subsection "PPI::Structure::When"
This is for the matching expression in \*(L"when\*(R" statements.
.SS "PPI::Structure::Condition"
.IX Subsection "PPI::Structure::Condition"
This round-brace structure covers boolean conditional braces, such as
for \f(CW\*(C`if\*(C'\fR and \f(CW\*(C`while\*(C'\fR blocks.
.SS "PPI::Structure::Block"
.IX Subsection "PPI::Structure::Block"
This curly-brace and common structure is used for all form of code
blocks. This includes those for \f(CW\*(C`if\*(C'\fR, \f(CW\*(C`do\*(C'\fR and similar, as well
as \f(CW\*(C`grep\*(C'\fR, \f(CW\*(C`map\*(C'\fR, \f(CW\*(C`sort\*(C'\fR, \f(CW\*(C`sub\*(C'\fR and (labelled or anonymous) 
scoping blocks.
.SS "PPI::Structure::Constructor"
.IX Subsection "PPI::Structure::Constructor"
This class covers brace structures used for the construction of
anonymous \f(CW\*(C`ARRAY\*(C'\fR and \f(CW\*(C`HASH\*(C'\fR references.
.SS "PPI::Structure::Subscript"
.IX Subsection "PPI::Structure::Subscript"
This class covers square-braces and curly-braces used after a
\&\-> pointer to access the subscript of an \f(CW\*(C`ARRAY\*(C'\fR or \f(CW\*(C`HASH\*(C'\fR.
.SH "METHODS"
.IX Header "METHODS"
\&\f(CW\*(C`PPI::Structure\*(C'\fR itself has very few methods. Most of the time, you will be
working with the more generic PPI::Element or PPI::Node methods, or one
of the methods that are subclass-specific.
.SS "start"
.IX Subsection "start"
For lack of better terminology (like \*(L"open\*(R" and \*(L"close\*(R") that has not
already in use for some other more important purpose, the two individual
braces for the structure are known within \s-1PPI\s0 as the \*(L"start\*(R" and \*(L"finish\*(R"
braces (at least for method purposes).
.PP
The \f(CW\*(C`start\*(C'\fR method returns the start brace for the structure (i.e. the
opening brace).
.PP
Returns the brace as a PPI::Token::Structure or \f(CW\*(C`undef\*(C'\fR if the
structure does not have a starting brace.
.PP
Under normal parsing circumstances this should never occur, but may happen
due to manipulation of the \s-1PDOM\s0 tree.
.SS "finish"
.IX Subsection "finish"
The \f(CW\*(C`finish\*(C'\fR method returns the finish brace for the structure (i.e. the
closing brace).
.PP
Returns the brace as a PPI::Token::Structure or \f(CW\*(C`undef\*(C'\fR if the
structure does not have a finishing brace. This can be quite common if
the document is not complete (for example, from an editor where the user
may be halfway through typeing a subroutine).
.SS "braces"
.IX Subsection "braces"
The \f(CW\*(C`braces\*(C'\fR method is a utility method which returns the brace type,
regardless of whether both or just one of the braces is defined.
.PP
Returns one of the three strings \f(CW\*(Aq[]\*(Aq\fR, \f(CW\*(Aq{}\*(Aq\fR, or \f(CW\*(Aq()\*(Aq\fR, or \f(CW\*(C`undef\*(C'\fR
on error (primarily not having a start brace, as mentioned above).
.SH "complete"
.IX Header "complete"
The \f(CW\*(C`complete\*(C'\fR method is a convenience method that returns true if
the both braces are defined for the structure, or false if only one
brace is defined.
.PP
Unlike the top level \f(CW\*(C`complete\*(C'\fR method which checks for completeness
in depth, the structure complete method \s-1ONLY\s0 confirms completeness
for the braces, and does not recurse downwards.
.SH "SUPPORT"
.IX Header "SUPPORT"
See the support section in the main module.
.SH "AUTHOR"
.IX Header "AUTHOR"
Adam Kennedy <adamk@cpan.org>
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright 2001 \- 2011 Adam Kennedy.
.PP
This program is free software; you can redistribute
it and/or modify it under the same terms as Perl itself.
.PP
The full text of the license can be found in the
\&\s-1LICENSE\s0 file included with this module.
