.\" Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Test2::API::InterceptResult::Event 3"
.TH Test2::API::InterceptResult::Event 3 "2020-10-22" "perl v5.30.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Test2::API::InterceptResult::Event \- Representation of an event for use in
testing other test tools.
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\f(CW\*(C`intercept { ... }\*(C'\fR from Test2::API returns an instance of
Test2::API::InterceptResult which is a blessed arrayref of
Test2::API::InterceptResult::Event objects.
.PP
This \s-1POD\s0 documents the methods of these events, which are mainly provided for
you to use when testing your test tools.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&    use Test2::V0;
\&    use Test2::API qw/intercept/;
\&
\&    my $events = intercept {
\&        ok(1, "A passing assertion");
\&        plan(1);
\&    };
\&
\&    # This will convert all events into instances of
\&    # Test2::API::InterceptResult::Event. Until we do this they are the
\&    # original Test::Event::* instances
\&    $events\->upgrade(in_place => 1);
\&
\&    # Now we can get individual events in this form
\&    my $assert = $events\->[0];
\&    my $plan   = $events\->[1];
\&
\&    # Or we can operate on all events at once:
\&    my $flattened = $events\->flatten;
\&    is(
\&        $flattened,
\&        [
\&          {
\&            causes_failure => 0,
\&
\&            name => \*(AqA passing assertion\*(Aq,
\&            pass => 1,
\&
\&            trace_file => \*(Aqxxx.t\*(Aq,
\&            trace_line => 5,
\&          },
\&          {
\&            causes_failure => 0,
\&
\&            plan => 1,
\&
\&            trace_file => \*(Aqxxx.t\*(Aq,
\&            trace_line => 6,
\&          },
\&        ],
\&        "Flattened both events and returned an arrayref of the results
\&    );
.Ve
.SH "METHODS"
.IX Header "METHODS"
.SS "!!! \s-1IMPORTANT NOTES ON DESIGN\s0 !!!"
.IX Subsection "!!! IMPORTANT NOTES ON DESIGN !!!"
Please pay attention to what these return, many return a scalar when
applicable or an empty list when not (as opposed to undef). Many also always
return a list of 0 or more items. Some always return a scalar. Note that none
of the methods care about context, their behavior is consistent regardless of
scalar, list, or void context.
.PP
This was done because this class was specifically designed to be used in a list
and generate more lists in bulk operations. Sometimes in a map you want nothing
to show up for the event, and you do not want an undef in its place. In general
single event instances are not going to be used alone, though that is allowed.
.PP
As a general rule any method prefixed with \f(CW\*(C`the_\*(C'\fR implies the event should
have exactly 1 of the specified item, and and exception will be thrown if there
are 0, or more than 1 of the item.
.SS "\s-1ATTRIBUTES\s0"
.IX Subsection "ATTRIBUTES"
.ie n .IP "$hashref = $event\->facet_data" 4
.el .IP "\f(CW$hashref\fR = \f(CW$event\fR\->facet_data" 4
.IX Item "$hashref = $event->facet_data"
This will return the facet data hashref, which is all Test2 cares about for any
given event.
.ie n .IP "$class = $event\->result_class" 4
.el .IP "\f(CW$class\fR = \f(CW$event\fR\->result_class" 4
.IX Item "$class = $event->result_class"
This is normally Test2::API::InterceptResult. This is set at construction so
that subtest results can be turned into instances of it on demand.
.SS "\s-1DUPLICATION\s0"
.IX Subsection "DUPLICATION"
.ie n .IP "$copy = $event\->clone" 4
.el .IP "\f(CW$copy\fR = \f(CW$event\fR\->clone" 4
.IX Item "$copy = $event->clone"
Create a deep copy of the event. Modifying either event will not effect the
other.
.SS "\s-1CONDENSED\s0 MULTI-FACET \s-1DATA\s0"
.IX Subsection "CONDENSED MULTI-FACET DATA"
.ie n .IP "$bool = $event\->causes_failure" 4
.el .IP "\f(CW$bool\fR = \f(CW$event\fR\->causes_failure" 4
.IX Item "$bool = $event->causes_failure"
.PD 0
.ie n .IP "$bool = $event\->causes_fail" 4
.el .IP "\f(CW$bool\fR = \f(CW$event\fR\->causes_fail" 4
.IX Item "$bool = $event->causes_fail"
.PD
These are both aliases of the same functionality.
.Sp
This will always return either a true value, or a false value. This never
returns a list.
.Sp
This method may be relatively slow (still super fast) because it determines
pass or fail by creating an instance of Test2::Hub and asking it to process
the event, and then asks the hub for its pass/fail state. This is slower than
bulding in logic to do the check, but it is more reliable as it will always
tell you what the hub thinks, so the logic will never be out of date relative
to the Test2 logic that actually cares.
.ie n .IP "\s-1STRING_OR_EMPTY_LIST\s0 = $event\->brief" 4
.el .IP "\s-1STRING_OR_EMPTY_LIST\s0 = \f(CW$event\fR\->brief" 4
.IX Item "STRING_OR_EMPTY_LIST = $event->brief"
Not all events have a brief, some events are not rendered by the formatter,
others have no \*(L"brief\*(R" data worth seeing. When this is the case an empty list
is returned. This is done intentionally so it can be used in a map operation
without having \f(CW\*(C`undef\*(C'\fR being included in the result.
.Sp
When a brief can be generated it is always a single 1\-line string, and is
returned as-is, not in a list.
.Sp
Possible briefs:
.Sp
.Vb 3
\&    # From control facets
\&    "BAILED OUT"
\&    "BAILED OUT: $why"
\&
\&    # From error facets
\&    "ERROR"
\&    "ERROR: $message"
\&    "ERROR: $partial_message [...]"
\&    "ERRORS: $first_error_message [...]"
\&
\&    # From assert facets
\&    "PASS"
\&    "FAIL"
\&    "PASS with amnesty"
\&    "FAIL with amnesty"
\&
\&    # From plan facets
\&    "PLAN $count"
\&    "NO PLAN"
\&    "SKIP ALL"
\&    "SKIP ALL: $why"
.Ve
.Sp
Note that only the first applicable brief is returned. This is essnetially a
poor-mans \s-1TAP\s0 that only includes facets that could (but not necessarily do)
cause a failure.
.ie n .IP "$hashref = $event\->flatten" 4
.el .IP "\f(CW$hashref\fR = \f(CW$event\fR\->flatten" 4
.IX Item "$hashref = $event->flatten"
.PD 0
.ie n .IP "$hashref = $event\->flatten(include_subevents => 1)" 4
.el .IP "\f(CW$hashref\fR = \f(CW$event\fR\->flatten(include_subevents => 1)" 4
.IX Item "$hashref = $event->flatten(include_subevents => 1)"
.PD
This \s-1ALWAYS\s0 returns a hashref. This puts all the most useful data for the most
interesting facets into a single hashref for easy validation.
.Sp
If there are no meaningful facets this will return an empty hashref.
.Sp
If given the 'include_subevents' parameter it will also include subtest data:
.Sp
Here is a list of \s-1EVERY\s0 possible field. If a field is not applicable it will
not be present.
.RS 4
.IP "always present" 4
.IX Item "always present"
.Vb 1
\&        causes_failure => 1,    # Always present
.Ve
.IP "Present if the event has a trace facet" 4
.IX Item "Present if the event has a trace facet"
.Vb 3
\&        trace_line    => 42,
\&        trace_file    => \*(AqFoo/Bar.pm\*(Aq,
\&        trace_details => \*(AqExtra trace details\*(Aq,    # usually not present
.Ve
.IP "If an assertion is present" 4
.IX Item "If an assertion is present"
.Vb 2
\&        pass => 0,
\&        name => "1 + 1 = 2, so math works",
.Ve
.IP "If a plan is present:" 4
.IX Item "If a plan is present:"
.Vb 1
\&        plan => $count_or_SKIP_ALL_or_NO_PLAN,
.Ve
.IP "If amnesty facets are present" 4
.IX Item "If amnesty facets are present"
You get an array for each type that is present.
.Sp
.Vb 4
\&        todo => [    # Yes you could be under multiple todos, this will list them all.
\&            "I will fix this later",
\&            "I promise to fix these",
\&        ],
\&
\&        skip => ["This will format the main drive, do not run"],
\&
\&        ... => ["Other amnesty"]
.Ve
.IP "If Info (note/diag) facets are present" 4
.IX Item "If Info (note/diag) facets are present"
You get an arrayref for any that are present, the key is not defined if they are not present.
.Sp
.Vb 4
\&        diag => [
\&            "Test failed at Foo/Bar.pm line 42",
\&            "You forgot to tie your boots",
\&        ],
\&
\&        note => ["Your boots are red"],
\&
\&        ...  => ["Other info"],
.Ve
.IP "If error facets are present" 4
.IX Item "If error facets are present"
Always an arrayref
.Sp
.Vb 4
\&        error => [
\&            "non fatal error (does not cause test failure, just an FYI",
\&            "FATAL: This is a fatal error (causes failure)",
\&        ],
\&
\&        # Errors can have alternative tags, but in practice are always \*(Aqerror\*(Aq,
\&        # listing this for completeness.
\&        ... => [ ... ]
.Ve
.IP "Present if the event is a subtest" 4
.IX Item "Present if the event is a subtest"
.Vb 5
\&        subtest => {
\&            count      => 2,    # Number of assertions made
\&            failed     => 1,    # Number of test failures seen
\&            is_passing => 0,    # Boolean, true if the test would be passing
\&                                # after the events are processed.
\&
\&            plan         => 2,  # Plan, either a number, undef, \*(AqSKIP\*(Aq, or \*(AqNO PLAN\*(Aq
\&            follows_plan => 1,  # True if there is a plan and it was followed.
\&                                # False if the plan and assertions did not
\&                                # match, undef if no plan was present in the
\&                                # event list.
\&
\&            bailed_out => "foo",    # if there was a bail\-out in the
\&                                    # events in this will be a string explaining
\&                                    # why there was a bailout, if no reason was
\&                                    # given this will simply be set to true (1).
\&
\&            skip_reason => "foo",   # If there was a skip_all this will give the
\&                                    # reason.
\&        },
.Ve
.Sp
if \f(CW\*(C`(include_subtest => 1)\*(C'\fR was provided as a parameter then the following
will be included. This is the result of turning all subtest child events into
an Test2::API::InterceptResult instance and calling the \f(CW\*(C`flatten\*(C'\fR method on
it.
.Sp
.Vb 1
\&        subevents => Test2::API::InterceptResult\->new(@child_events)\->flatten(...),
.Ve
.IP "If a bail-out is being requested" 4
.IX Item "If a bail-out is being requested"
If no reason was given this will be set to 1.
.Sp
.Vb 1
\&        bailed_out => "reason",
.Ve
.RE
.RS 4
.RE
.ie n .IP "$hashref = $event\->\fBsummary()\fR" 4
.el .IP "\f(CW$hashref\fR = \f(CW$event\fR\->\fBsummary()\fR" 4
.IX Item "$hashref = $event->summary()"
This returns a limited summary. See \f(CW\*(C`flatten()\*(C'\fR, which is usually a better
option.
.Sp
.Vb 2
\&    {
\&        brief => $event\->brief || \*(Aq\*(Aq,
\&
\&        causes_failure => $event\->causes_failure,
\&
\&        trace_line    => $event\->trace_line,
\&        trace_file    => $event\->trace_file,
\&        trace_tool    => $event\->trace_subname,
\&        trace_details => $event\->trace_details,
\&
\&        facets => [ sort keys(%{$event\->{+FACET_DATA}}) ],
\&    }
.Ve
.SS "\s-1DIRECT ARBITRARY FACET ACCESS\s0"
.IX Subsection "DIRECT ARBITRARY FACET ACCESS"
.ie n .IP "@list_of_facets = $event\->facet($name)" 4
.el .IP "\f(CW@list_of_facets\fR = \f(CW$event\fR\->facet($name)" 4
.IX Item "@list_of_facets = $event->facet($name)"
This always returns a list of 0 or more items. This fetches the facet instances
from the event. For facets like 'assert' this will always return 0 or 1
item. For events like 'info' (diags, notes) this will return 0 or more
instances, once for each instance of the facet.
.Sp
These will be blessed into the proper Test2::EventFacet subclass. If no
subclass can be found it will be blessed as an
Test2::API::InterceptResult::Facet generic facet class.
.ie n .IP "$undef_or_facet = $event\->the_facet($name)" 4
.el .IP "\f(CW$undef_or_facet\fR = \f(CW$event\fR\->the_facet($name)" 4
.IX Item "$undef_or_facet = $event->the_facet($name)"
If you know you will have exactly 1 instance of a facet you can call this.
.Sp
If you are correct and there is exactly one instance of the facet it will
always return the hashref.
.Sp
If there are 0 instances of the facet this will reutrn undef, not an empty
list.
.Sp
If there are more than 1 instance this will throw an exception because your
assumption was incorrect.
.SS "\s-1TRACE FACET\s0"
.IX Subsection "TRACE FACET"
.ie n .IP "@list_of_facets = $event\->trace" 4
.el .IP "\f(CW@list_of_facets\fR = \f(CW$event\fR\->trace" 4
.IX Item "@list_of_facets = $event->trace"
\&\s-1TODO\s0
.ie n .IP "$undef_or_hashref = $event\->the_trace" 4
.el .IP "\f(CW$undef_or_hashref\fR = \f(CW$event\fR\->the_trace" 4
.IX Item "$undef_or_hashref = $event->the_trace"
This returns the trace hashref, or undef if it is not present.
.ie n .IP "$undef_or_arrayref = $event\->frame" 4
.el .IP "\f(CW$undef_or_arrayref\fR = \f(CW$event\fR\->frame" 4
.IX Item "$undef_or_arrayref = $event->frame"
If a trace is present, and has a caller frame, this will be an arrayref:
.Sp
.Vb 1
\&    [$package, $file, $line, $subname]
.Ve
.Sp
If the trace is not present, or has no caller frame this will return undef.
.ie n .IP "$undef_or_string = $event\->trace_details" 4
.el .IP "\f(CW$undef_or_string\fR = \f(CW$event\fR\->trace_details" 4
.IX Item "$undef_or_string = $event->trace_details"
This is usually undef, but occasionally has a string that overrides the
file/line number debugging a trace usually provides on test failure.
.ie n .IP "$undef_or_string = $event\->trace_package" 4
.el .IP "\f(CW$undef_or_string\fR = \f(CW$event\fR\->trace_package" 4
.IX Item "$undef_or_string = $event->trace_package"
Same as \f(CW\*(C`(caller())[0]\*(C'\fR, the first element of the trace frame.
.Sp
Will be undef if not present.
.ie n .IP "$undef_or_string = $event\->trace_file" 4
.el .IP "\f(CW$undef_or_string\fR = \f(CW$event\fR\->trace_file" 4
.IX Item "$undef_or_string = $event->trace_file"
Same as \f(CW\*(C`(caller())[1]\*(C'\fR, the second element of the trace frame.
.Sp
Will be undef if not present.
.ie n .IP "$undef_or_integer = $event\->trace_line" 4
.el .IP "\f(CW$undef_or_integer\fR = \f(CW$event\fR\->trace_line" 4
.IX Item "$undef_or_integer = $event->trace_line"
Same as \f(CW\*(C`(caller())[2]\*(C'\fR, the third element of the trace frame.
.Sp
Will be undef if not present.
.ie n .IP "$undef_or_string = $event\->trace_subname" 4
.el .IP "\f(CW$undef_or_string\fR = \f(CW$event\fR\->trace_subname" 4
.IX Item "$undef_or_string = $event->trace_subname"
.PD 0
.ie n .IP "$undef_or_string = $event\->trace_tool" 4
.el .IP "\f(CW$undef_or_string\fR = \f(CW$event\fR\->trace_tool" 4
.IX Item "$undef_or_string = $event->trace_tool"
.PD
Aliases for the same thing
.Sp
Same as \f(CW\*(C`(caller($level))[4]\*(C'\fR, the fourth element of the trace frame.
.Sp
Will be undef if not present.
.ie n .IP "$undef_or_string = $event\->trace_signature" 4
.el .IP "\f(CW$undef_or_string\fR = \f(CW$event\fR\->trace_signature" 4
.IX Item "$undef_or_string = $event->trace_signature"
A string that is a unique signature for the trace. If a single context
generates multiple events they will all have the same signature. This can be
used to tie assertions and diagnostics sent as seperate events together after
the fact.
.SS "\s-1ASSERT FACET\s0"
.IX Subsection "ASSERT FACET"
.ie n .IP "$bool = $event\->has_assert" 4
.el .IP "\f(CW$bool\fR = \f(CW$event\fR\->has_assert" 4
.IX Item "$bool = $event->has_assert"
Returns true if the event has an assert facet, false if it does not.
.ie n .IP "$undef_or_hashref = $event\->the_assert" 4
.el .IP "\f(CW$undef_or_hashref\fR = \f(CW$event\fR\->the_assert" 4
.IX Item "$undef_or_hashref = $event->the_assert"
Returns the assert facet if present, undef if it is not.
.ie n .IP "@list_of_facets = $event\->assert" 4
.el .IP "\f(CW@list_of_facets\fR = \f(CW$event\fR\->assert" 4
.IX Item "@list_of_facets = $event->assert"
\&\s-1TODO\s0
.ie n .IP "\s-1EMPTY_LIST_OR_STRING\s0 = $event\->assert_brief" 4
.el .IP "\s-1EMPTY_LIST_OR_STRING\s0 = \f(CW$event\fR\->assert_brief" 4
.IX Item "EMPTY_LIST_OR_STRING = $event->assert_brief"
Returns a string giving a brief of the assertion if an assertion is present.
Returns an empty list if no assertion is present.
.SS "\s-1SUBTESTS\s0 (\s-1PARENT FACET\s0)"
.IX Subsection "SUBTESTS (PARENT FACET)"
.ie n .IP "$bool = $event\->has_subtest" 4
.el .IP "\f(CW$bool\fR = \f(CW$event\fR\->has_subtest" 4
.IX Item "$bool = $event->has_subtest"
True if a subetest is present in this event.
.ie n .IP "$undef_or_hashref = $event\->the_subtest" 4
.el .IP "\f(CW$undef_or_hashref\fR = \f(CW$event\fR\->the_subtest" 4
.IX Item "$undef_or_hashref = $event->the_subtest"
Get the one subtest if present, otherwise undef.
.ie n .IP "@list_of_facets = $event\->subtest" 4
.el .IP "\f(CW@list_of_facets\fR = \f(CW$event\fR\->subtest" 4
.IX Item "@list_of_facets = $event->subtest"
\&\s-1TODO\s0
.ie n .IP "\s-1EMPTY_LIST_OR_OBJECT\s0 = $event\->subtest_result" 4
.el .IP "\s-1EMPTY_LIST_OR_OBJECT\s0 = \f(CW$event\fR\->subtest_result" 4
.IX Item "EMPTY_LIST_OR_OBJECT = $event->subtest_result"
Returns an empty list if there is no subtest.
.Sp
Get an instance of Test2::API::InterceptResult representing the subtest.
.SS "\s-1CONTROL FACET\s0 (\s-1BAILOUT, ENCODING\s0)"
.IX Subsection "CONTROL FACET (BAILOUT, ENCODING)"
.ie n .IP "$bool = $event\->has_bailout" 4
.el .IP "\f(CW$bool\fR = \f(CW$event\fR\->has_bailout" 4
.IX Item "$bool = $event->has_bailout"
True if there was a bailout
.ie n .IP "$undef_hashref = $event\->the_bailout" 4
.el .IP "\f(CW$undef_hashref\fR = \f(CW$event\fR\->the_bailout" 4
.IX Item "$undef_hashref = $event->the_bailout"
Return the control facet if it requested a bailout.
.ie n .IP "\s-1EMPTY_LIST_OR_HASHREF\s0 = $event\->bailout" 4
.el .IP "\s-1EMPTY_LIST_OR_HASHREF\s0 = \f(CW$event\fR\->bailout" 4
.IX Item "EMPTY_LIST_OR_HASHREF = $event->bailout"
Get a list of 0 or 1 hashrefs. The hashref will be the control facet if a
bail-out was requested.
.ie n .IP "\s-1EMPTY_LIST_OR_STRING\s0 = $event\->bailout_brief" 4
.el .IP "\s-1EMPTY_LIST_OR_STRING\s0 = \f(CW$event\fR\->bailout_brief" 4
.IX Item "EMPTY_LIST_OR_STRING = $event->bailout_brief"
Get the brief of the balout if present.
.ie n .IP "\s-1EMPTY_LIST_OR_STRING\s0 = $event\->bailout_reason" 4
.el .IP "\s-1EMPTY_LIST_OR_STRING\s0 = \f(CW$event\fR\->bailout_reason" 4
.IX Item "EMPTY_LIST_OR_STRING = $event->bailout_reason"
Get the reason for the bailout, an empty string if no reason was provided, or
an empty list if there was no bailout.
.SS "\s-1PLAN FACET\s0"
.IX Subsection "PLAN FACET"
\&\s-1TODO\s0
.ie n .IP "$bool = $event\->has_plan" 4
.el .IP "\f(CW$bool\fR = \f(CW$event\fR\->has_plan" 4
.IX Item "$bool = $event->has_plan"
.PD 0
.ie n .IP "$undef_or_hashref = $event\->the_plan" 4
.el .IP "\f(CW$undef_or_hashref\fR = \f(CW$event\fR\->the_plan" 4
.IX Item "$undef_or_hashref = $event->the_plan"
.ie n .IP "@list_if_hashrefs = $event\->plan" 4
.el .IP "\f(CW@list_if_hashrefs\fR = \f(CW$event\fR\->plan" 4
.IX Item "@list_if_hashrefs = $event->plan"
.ie n .IP "\s-1EMPTY_LIST_OR_STRING\s0 $event\->plan_brief" 4
.el .IP "\s-1EMPTY_LIST_OR_STRING\s0 \f(CW$event\fR\->plan_brief" 4
.IX Item "EMPTY_LIST_OR_STRING $event->plan_brief"
.PD
.SS "\s-1AMNESTY FACET\s0 (\s-1TODO AND SKIP\s0)"
.IX Subsection "AMNESTY FACET (TODO AND SKIP)"
\&\s-1TODO\s0
.ie n .IP "$event\->has_amnesty" 4
.el .IP "\f(CW$event\fR\->has_amnesty" 4
.IX Item "$event->has_amnesty"
.PD 0
.ie n .IP "$event\->the_amnesty" 4
.el .IP "\f(CW$event\fR\->the_amnesty" 4
.IX Item "$event->the_amnesty"
.ie n .IP "$event\->amnesty" 4
.el .IP "\f(CW$event\fR\->amnesty" 4
.IX Item "$event->amnesty"
.ie n .IP "$event\->amnesty_reasons" 4
.el .IP "\f(CW$event\fR\->amnesty_reasons" 4
.IX Item "$event->amnesty_reasons"
.ie n .IP "$event\->has_todos" 4
.el .IP "\f(CW$event\fR\->has_todos" 4
.IX Item "$event->has_todos"
.ie n .IP "$event\->todos" 4
.el .IP "\f(CW$event\fR\->todos" 4
.IX Item "$event->todos"
.ie n .IP "$event\->todo_reasons" 4
.el .IP "\f(CW$event\fR\->todo_reasons" 4
.IX Item "$event->todo_reasons"
.ie n .IP "$event\->has_skips" 4
.el .IP "\f(CW$event\fR\->has_skips" 4
.IX Item "$event->has_skips"
.ie n .IP "$event\->skips" 4
.el .IP "\f(CW$event\fR\->skips" 4
.IX Item "$event->skips"
.ie n .IP "$event\->skip_reasons" 4
.el .IP "\f(CW$event\fR\->skip_reasons" 4
.IX Item "$event->skip_reasons"
.ie n .IP "$event\->has_other_amnesty" 4
.el .IP "\f(CW$event\fR\->has_other_amnesty" 4
.IX Item "$event->has_other_amnesty"
.ie n .IP "$event\->other_amnesty" 4
.el .IP "\f(CW$event\fR\->other_amnesty" 4
.IX Item "$event->other_amnesty"
.ie n .IP "$event\->other_amnesty_reasons" 4
.el .IP "\f(CW$event\fR\->other_amnesty_reasons" 4
.IX Item "$event->other_amnesty_reasons"
.PD
.SS "\s-1ERROR FACET\s0 (\s-1CAPTURED EXCEPTIONS\s0)"
.IX Subsection "ERROR FACET (CAPTURED EXCEPTIONS)"
\&\s-1TODO\s0
.ie n .IP "$event\->has_errors" 4
.el .IP "\f(CW$event\fR\->has_errors" 4
.IX Item "$event->has_errors"
.PD 0
.ie n .IP "$event\->the_errors" 4
.el .IP "\f(CW$event\fR\->the_errors" 4
.IX Item "$event->the_errors"
.ie n .IP "$event\->errors" 4
.el .IP "\f(CW$event\fR\->errors" 4
.IX Item "$event->errors"
.ie n .IP "$event\->error_messages" 4
.el .IP "\f(CW$event\fR\->error_messages" 4
.IX Item "$event->error_messages"
.ie n .IP "$event\->error_brief" 4
.el .IP "\f(CW$event\fR\->error_brief" 4
.IX Item "$event->error_brief"
.PD
.SS "\s-1INFO FACET\s0 (\s-1DIAG, NOTE\s0)"
.IX Subsection "INFO FACET (DIAG, NOTE)"
\&\s-1TODO\s0
.ie n .IP "$event\->has_info" 4
.el .IP "\f(CW$event\fR\->has_info" 4
.IX Item "$event->has_info"
.PD 0
.ie n .IP "$event\->the_info" 4
.el .IP "\f(CW$event\fR\->the_info" 4
.IX Item "$event->the_info"
.ie n .IP "$event\->info" 4
.el .IP "\f(CW$event\fR\->info" 4
.IX Item "$event->info"
.ie n .IP "$event\->info_messages" 4
.el .IP "\f(CW$event\fR\->info_messages" 4
.IX Item "$event->info_messages"
.ie n .IP "$event\->has_diags" 4
.el .IP "\f(CW$event\fR\->has_diags" 4
.IX Item "$event->has_diags"
.ie n .IP "$event\->diags" 4
.el .IP "\f(CW$event\fR\->diags" 4
.IX Item "$event->diags"
.ie n .IP "$event\->diag_messages" 4
.el .IP "\f(CW$event\fR\->diag_messages" 4
.IX Item "$event->diag_messages"
.ie n .IP "$event\->has_notes" 4
.el .IP "\f(CW$event\fR\->has_notes" 4
.IX Item "$event->has_notes"
.ie n .IP "$event\->notes" 4
.el .IP "\f(CW$event\fR\->notes" 4
.IX Item "$event->notes"
.ie n .IP "$event\->note_messages" 4
.el .IP "\f(CW$event\fR\->note_messages" 4
.IX Item "$event->note_messages"
.ie n .IP "$event\->has_other_info" 4
.el .IP "\f(CW$event\fR\->has_other_info" 4
.IX Item "$event->has_other_info"
.ie n .IP "$event\->other_info" 4
.el .IP "\f(CW$event\fR\->other_info" 4
.IX Item "$event->other_info"
.ie n .IP "$event\->other_info_messages" 4
.el .IP "\f(CW$event\fR\->other_info_messages" 4
.IX Item "$event->other_info_messages"
.PD
.SH "SOURCE"
.IX Header "SOURCE"
The source code repository for Test2 can be found at
\&\fIhttp://github.com/Test\-More/test\-more/\fR.
.SH "MAINTAINERS"
.IX Header "MAINTAINERS"
.IP "Chad Granum <exodist@cpan.org>" 4
.IX Item "Chad Granum <exodist@cpan.org>"
.SH "AUTHORS"
.IX Header "AUTHORS"
.PD 0
.IP "Chad Granum <exodist@cpan.org>" 4
.IX Item "Chad Granum <exodist@cpan.org>"
.PD
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright 2020 Chad Granum <exodist@cpan.org>.
.PP
This program is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.
.PP
See \fIhttp://dev.perl.org/licenses/\fR
