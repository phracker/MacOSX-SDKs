.\" Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "IO::Socket::SSL 3"
.TH IO::Socket::SSL 3 "2020-02-19" "perl v5.30.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
IO::Socket::SSL \- SSL sockets with IO::Socket interface
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&    use strict;
\&    use IO::Socket::SSL;
\&
\&    # simple client
\&    my $cl = IO::Socket::SSL\->new(\*(Aqwww.google.com:443\*(Aq);
\&    print $cl "GET / HTTP/1.0\er\en\er\en";
\&    print <$cl>;
\&
\&    # simple server
\&    my $srv = IO::Socket::SSL\->new(
\&        LocalAddr => \*(Aq0.0.0.0:1234\*(Aq,
\&        Listen => 10,
\&        SSL_cert_file => \*(Aqserver\-cert.pem\*(Aq,
\&        SSL_key_file => \*(Aqserver\-key.pem\*(Aq,
\&    );
\&    $srv\->accept;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
IO::Socket::SSL makes using \s-1SSL/TLS\s0 much easier by wrapping the necessary
functionality into the familiar IO::Socket interface and providing secure
defaults whenever possible.
This way, existing applications can be made SSL-aware without much effort, at
least if you do blocking I/O and don't use select or poll.
.PP
But, under the hood, \s-1SSL\s0 is a complex beast.
So there are lots of methods to make it do what you need if the default
behavior is not adequate.
Because it is easy to inadvertently introduce critical security bugs or just
hard to debug problems, I would recommend studying the following
documentation carefully.
.PP
The documentation consists of the following parts:
.IP "\(bu" 4
\&\*(L"Essential Information About \s-1SSL/TLS\*(R"\s0
.IP "\(bu" 4
\&\*(L"Basic \s-1SSL\s0 Client\*(R"
.IP "\(bu" 4
\&\*(L"Basic \s-1SSL\s0 Server\*(R"
.IP "\(bu" 4
\&\*(L"Common Usage Errors\*(R"
.IP "\(bu" 4
\&\*(L"Common Problems with \s-1SSL\*(R"\s0
.IP "\(bu" 4
\&\*(L"Using Non-Blocking Sockets\*(R"
.IP "\(bu" 4
\&\*(L"Advanced Usage\*(R"
.IP "\(bu" 4
\&\*(L"Integration Into Own Modules\*(R"
.IP "\(bu" 4
\&\*(L"Description Of Methods\*(R"
.PP
Additional documentation can be found in
.IP "\(bu" 4
IO::Socket::SSL::Intercept \- Doing Man-In-The-Middle with \s-1SSL\s0
.IP "\(bu" 4
IO::Socket::SSL::Utils \- Useful functions for certificates etc
.SH "Essential Information About SSL/TLS"
.IX Header "Essential Information About SSL/TLS"
\&\s-1SSL\s0 (Secure Socket Layer) or its successor \s-1TLS\s0 (Transport Layer Security) are
protocols to facilitate end-to-end security. These protocols are used when
accessing web sites (https), delivering or retrieving email, and in lots of other
use cases.
In the following documentation we will refer to both \s-1SSL\s0 and \s-1TLS\s0 as simply '\s-1SSL\s0'.
.PP
\&\s-1SSL\s0 enables end-to-end security by providing two essential functions:
.IP "Encryption" 4
.IX Item "Encryption"
This part encrypts the data for transit between the communicating parties, so
that nobody in between can read them. It also provides tamper resistance so that
nobody in between can manipulate the data.
.IP "Identification" 4
.IX Item "Identification"
This part makes sure that you talk to the right peer.
If the identification is done incorrectly it is easy to mount man-in-the-middle
attacks, e.g. if Alice wants to talk to Bob it would be possible for Mallory to
put itself in the middle, so that Alice talks to Mallory and Mallory to Bob.
All the data would still be encrypted, but not end-to-end between Alice and Bob,
but only between Alice and Mallory and then between Mallory and Bob.
Thus Mallory would be able to read and modify all traffic between Alice and Bob.
.PP
Identification is the part which is the hardest to understand and the easiest
to get wrong.
.PP
With \s-1SSL,\s0 the Identification is usually done with \fBcertificates\fR inside a \fB\s-1PKI\s0\fR
(Public Key Infrastructure).
These Certificates are comparable to an identity card, which contains
information about the owner of the card. The card then is somehow \fBsigned\fR by
the \fBissuer\fR of the card, the \fB\s-1CA\s0\fR (Certificate Agency).
.PP
To verify the identity of the peer the following must be done inside \s-1SSL:\s0
.IP "\(bu" 4
Get the certificate from the peer.
If the peer does not present a certificate we cannot verify it.
.IP "\(bu" 4
Check if we trust the certificate, e.g. make sure it's not a forgery.
.Sp
We believe that a certificate is not a fake if we either know the certificate
already or if we \fBtrust\fR the issuer (the \s-1CA\s0) and can verify the issuers
signature on the certificate.
In reality there is often a hierarchy of certificate agencies and we only
directly trust the root of this hierarchy.
In this case the peer not only sends his own certificate, but also all
\&\fBintermediate certificates\fR.
Verification will be done by building a \fBtrust path\fR from the trusted root up
to the peers certificate and checking in each step if the we can verify the
issuer's signature.
.Sp
This step often causes problems because the client does not know the necessary
trusted root certificates. These are usually stored in a system dependent
\&\s-1CA\s0 store, but often the browsers have their own \s-1CA\s0 store.
.IP "\(bu" 4
Check if the certificate is still valid.
Each certificate has a lifetime and should not be used after that time because
it might be compromised or the underlying cryptography got broken in the mean
time.
.IP "\(bu" 4
Check if the subject of the certificate matches the peer.
This is like comparing the picture on the identity card against the person
representing the identity card.
.Sp
When connecting to a server this is usually done by comparing the hostname used
for connecting against the names represented in the certificate.
A certificate might contain multiple names or wildcards, so that it can be used
for multiple hosts (e.g.  *.example.com and *.example.org).
.Sp
Although nobody sane would accept an identity card where the picture does not
match the person we see, it is a common implementation error with \s-1SSL\s0 to omit
this check or get it wrong.
.IP "\(bu" 4
Check if the certificate was revoked by the issuer.
This might be the case if the certificate was compromised somehow and now
somebody else might use it to claim the wrong identity.
Such revocations happened a lot after the heartbleed attack.
.Sp
For \s-1SSL\s0 there are two ways to verify a revocation, \s-1CRL\s0 and \s-1OCSP.\s0
With CRLs (Certificate Revocation List) the \s-1CA\s0 provides a list of serial numbers
for revoked certificates. The client somehow has to download the list
(which can be huge) and keep it up to date.
With \s-1OCSP\s0 (Online Certificate Status Protocol) the client can check a single
certificate directly by asking the issuer.
.Sp
Revocation is the hardest part of the verification and none of today's browsers
get it fully correct. But, they are still better than most other implementations
which don't implement revocation checks or leave the hard parts to the
developer.
.PP
When accessing a web site with \s-1SSL\s0 or delivering mail in a secure way the
identity is usually only checked one way, e.g. the client wants to make sure it
talks to the right server, but the server usually does not care which client it
talks to.
But, sometimes the server wants to identify the client too and will request a
certificate from the client which the server must verify in a similar way.
.SH "Basic SSL Client"
.IX Header "Basic SSL Client"
A basic \s-1SSL\s0 client is simple:
.PP
.Vb 2
\&    my $client = IO::Socket::SSL\->new(\*(Aqwww.example.com:443\*(Aq)
\&        or die "error=$!, ssl_error=$SSL_ERROR";
.Ve
.PP
This will take the OpenSSL default \s-1CA\s0 store as the store for the trusted \s-1CA.\s0
This usually works on \s-1UNIX\s0 systems.
If there are no certificates in the store it will try use Mozilla::CA which
provides the default CAs of Firefox.
.PP
In the default settings, IO::Socket::SSL will use a safer cipher set and \s-1SSL\s0
version, do a proper hostname check against the certificate, and use \s-1SNI\s0 (server
name indication) to send the hostname inside the \s-1SSL\s0 handshake. This is
necessary to work with servers which have different certificates behind the
same \s-1IP\s0 address.
It will also check the revocation of the certificate with \s-1OCSP,\s0 but currently
only if the server provides \s-1OCSP\s0 stapling (for deeper checks see
\&\f(CW\*(C`ocsp_resolver\*(C'\fR method).
.PP
Lots of options can be used to change ciphers, \s-1SSL\s0 version, location of \s-1CA\s0 and
much more. See documentation of methods for details.
.PP
With protocols like \s-1SMTP\s0 it is necessary to upgrade an existing socket to \s-1SSL.\s0
This can be done like this:
.PP
.Vb 9
\&    my $client = IO::Socket::INET\->new(\*(Aqmx.example.com:25\*(Aq) or die $!;
\&    # .. read greeting from server
\&    # .. send EHLO and read response
\&    # .. send STARTTLS command and read response
\&    # .. if response was successful we can upgrade the socket to SSL now:
\&    IO::Socket::SSL\->start_SSL($client,
\&        # explicitly set hostname we should use for SNI
\&        SSL_hostname => \*(Aqmx.example.com\*(Aq
\&    ) or die $SSL_ERROR;
.Ve
.PP
A more complete example for a simple \s-1HTTP\s0 client:
.PP
.Vb 4
\&    my $client = IO::Socket::SSL\->new(
\&        # where to connect
\&        PeerHost => "www.example.com",
\&        PeerPort => "https",
\&
\&        # certificate verification \- VERIFY_PEER is default
\&        SSL_verify_mode => SSL_VERIFY_PEER,
\&
\&        # location of CA store
\&        # need only be given if default store should not be used
\&        SSL_ca_path => \*(Aq/etc/ssl/certs\*(Aq, # typical CA path on Linux
\&        SSL_ca_file => \*(Aq/etc/ssl/cert.pem\*(Aq, # typical CA file on BSD
\&
\&        # or just use default path on system:
\&        IO::Socket::SSL::default_ca(), # either explicitly
\&        # or implicitly by not giving SSL_ca_*
\&
\&        # easy hostname verification
\&        # It will use PeerHost as default name a verification
\&        # scheme as default, which is safe enough for most purposes.
\&        SSL_verifycn_name => \*(Aqfoo.bar\*(Aq,
\&        SSL_verifycn_scheme => \*(Aqhttp\*(Aq,
\&
\&        # SNI support \- defaults to PeerHost
\&        SSL_hostname => \*(Aqfoo.bar\*(Aq,
\&
\&    ) or die "failed connect or ssl handshake: $!,$SSL_ERROR";
\&
\&    # send and receive over SSL connection
\&    print $client "GET / HTTP/1.0\er\en\er\en";
\&    print <$client>;
.Ve
.PP
And to do revocation checks with \s-1OCSP\s0 (only available with OpenSSL 1.0.0 or
higher and Net::SSLeay 1.59 or higher):
.PP
.Vb 2
\&    # default will try OCSP stapling and check only leaf certificate
\&    my $client = IO::Socket::SSL\->new($dst);
\&
\&    # better yet: require checking of full chain
\&    my $client = IO::Socket::SSL\->new(
\&        PeerAddr => $dst,
\&        SSL_ocsp_mode => SSL_OCSP_FULL_CHAIN,
\&    );
\&
\&    # even better: make OCSP errors fatal
\&    # (this will probably fail with lots of sites because of bad OCSP setups)
\&    # also use common OCSP response cache
\&    my $ocsp_cache = IO::Socket::SSL::OCSP_Cache\->new;
\&    my $client = IO::Socket::SSL\->new(
\&        PeerAddr => $dst,
\&        SSL_ocsp_mode => SSL_OCSP_FULL_CHAIN|SSL_OCSP_FAIL_HARD,
\&        SSL_ocsp_cache => $ocsp_cache,
\&    );
\&
\&    # disable OCSP stapling in case server has problems with it
\&    my $client = IO::Socket::SSL\->new(
\&        PeerAddr => $dst,
\&        SSL_ocsp_mode => SSL_OCSP_NO_STAPLE,
\&    );
\&
\&    # check any certificates which are not yet checked by OCSP stapling or
\&    # where we have already cached results. For your own resolving combine
\&    # $ocsp\->requests with $ocsp\->add_response(uri,response).
\&    my $ocsp = $client\->ocsp_resolver();
\&    my $errors = $ocsp\->resolve_blocking();
\&    if ($errors) {
\&        warn "OCSP verification failed: $errors";
\&        close($client);
\&    }
.Ve
.SH "Basic SSL Server"
.IX Header "Basic SSL Server"
A basic \s-1SSL\s0 server looks similar to other IO::Socket servers, only that it
also contains settings for certificate and key:
.PP
.Vb 6
\&    # simple server
\&    my $server = IO::Socket::SSL\->new(
\&        # where to listen
\&        LocalAddr => \*(Aq127.0.0.1\*(Aq,
\&        LocalPort => 8080,
\&        Listen => 10,
\&
\&        # which certificate to offer
\&        # with SNI support there can be different certificates per hostname
\&        SSL_cert_file => \*(Aqcert.pem\*(Aq,
\&        SSL_key_file => \*(Aqkey.pem\*(Aq,
\&    ) or die "failed to listen: $!";
\&
\&    # accept client
\&    my $client = $server\->accept or die
\&        "failed to accept or ssl handshake: $!,$SSL_ERROR";
.Ve
.PP
This will automatically use a secure set of ciphers and \s-1SSL\s0 version and also
supports Forward Secrecy with (Elliptic-Curve) Diffie-Hellmann Key Exchange.
.PP
If you are doing a forking or threading server, we recommend that you do the \s-1SSL\s0
handshake inside the new process/thread so that the master is free for new
connections.
We recommend this because a client with improper or slow \s-1SSL\s0 handshake could
make the server block in the handshake which would be bad to do on the
listening socket:
.PP
.Vb 7
\&    # inet server
\&    my $server = IO::Socket::INET\->new(
\&        # where to listen
\&        LocalAddr => \*(Aq127.0.0.1\*(Aq,
\&        LocalPort => 8080,
\&        Listen => 10,
\&    );
\&
\&    # accept client
\&    my $client = $server\->accept or die;
\&
\&    # SSL upgrade client (in new process/thread)
\&    IO::Socket::SSL\->start_SSL($client,
\&        SSL_server => 1,
\&        SSL_cert_file => \*(Aqcert.pem\*(Aq,
\&        SSL_key_file => \*(Aqkey.pem\*(Aq,
\&    ) or die "failed to ssl handshake: $SSL_ERROR";
.Ve
.PP
Like with normal sockets, neither forking nor threading servers scale well.
It is recommended to use non-blocking sockets instead, see
\&\*(L"Using Non-Blocking Sockets\*(R"
.SH "Common Usage Errors"
.IX Header "Common Usage Errors"
This is a list of typical errors seen with the use of IO::Socket::SSL:
.IP "\(bu" 4
Disabling verification with \f(CW\*(C`SSL_verify_mode\*(C'\fR.
.Sp
As described in \*(L"Essential Information About \s-1SSL/TLS\*(R"\s0, a proper
identification of the peer is essential and failing to verify makes
Man-In-The-Middle attacks possible.
.Sp
Nevertheless, lots of scripts and even public modules or applications disable
verification, because it is probably the easiest way to make the thing work
and usually nobody notices any security problems anyway.
.Sp
If the verification does not succeed with the default settings, one can do the
following:
.RS 4
.IP "\(bu" 8
Make sure the needed CAs are in the store, maybe use \f(CW\*(C`SSL_ca_file\*(C'\fR or
\&\f(CW\*(C`SSL_ca_path\*(C'\fR to specify a different \s-1CA\s0 store.
.IP "\(bu" 8
If the validation fails because the certificate is self-signed and that's what
you expect, you can use the \f(CW\*(C`SSL_fingerprint\*(C'\fR option to accept specific
leaf certificates by their certificate or pubkey fingerprint.
.IP "\(bu" 8
If the validation failed because the hostname does not match and you cannot
access the host with the name given in the certificate, you can use
\&\f(CW\*(C`SSL_verifycn_name\*(C'\fR to specify the hostname you expect in the certificate.
.RE
.RS 4
.Sp
A common error pattern is also to disable verification if they found no \s-1CA\s0
store (different modules look at different \*(L"default\*(R" places).
Because IO::Socket::SSL is now able to provide a usable \s-1CA\s0 store on most
platforms (\s-1UNIX,\s0 Mac \s-1OSX\s0 and Windows) it is better to use the defaults provided
by IO::Socket::SSL.
If necessary these can be checked with the \f(CW\*(C`default_ca\*(C'\fR method.
.RE
.IP "\(bu" 4
Polling of \s-1SSL\s0 sockets (e.g. select, poll and other event loops).
.Sp
If you sysread one byte on a normal socket it will result in a syscall to read
one byte. Thus, if more than one byte is available on the socket it will be kept
in the network stack of your \s-1OS\s0 and the next select or poll call will return the
socket as readable.
But, with \s-1SSL\s0 you don't deliver single bytes. Multiple data bytes are packaged
and encrypted together in an \s-1SSL\s0 frame. Decryption can only be done on the whole
frame, so a sysread for one byte actually reads the complete \s-1SSL\s0 frame from the
socket, decrypts it and returns the first decrypted byte. Further sysreads will
return more bytes from the same frame until all bytes are returned and the
next \s-1SSL\s0 frame will be read from the socket.
.Sp
Thus, in order to decide if you can read more data (e.g. if sysread will block)
you must check if there are still data in the current \s-1SSL\s0 frame by calling
\&\f(CW\*(C`pending\*(C'\fR and if there are no data pending you might check the underlying
socket with select or poll.
Another way might be if you try to sysread at least 16kByte all the time.
16kByte is the maximum size of an \s-1SSL\s0 frame and because sysread returns data
from only a single \s-1SSL\s0 frame you can guarantee that there are no pending
data.
.Sp
Additionally, contrary to plain sockets the  data delivered on the socket are
not necessarily application payload.
It might be a \s-1TLS\s0 handshake, it might just be the beginning of a \s-1TLS\s0 record or
it might be \s-1TLS\s0 session tickets which are send after the \s-1TLS\s0 handshake in \s-1TLS
1.3.\s0
In such situations select will return that data are available for read since it
only looks at the plain socket.
A sysread on the IO::Socket::SSL socket will not return any data though since it
is an abstraction which only returns application data.
This causes the sysread to hang in case the socket was blocking or to return
an error with \s-1EAGAIN\s0 on non-blocking sockets.
Applications using select or similar should therefore set the socket to
non-blocking and also expect that the sysread might temporarily fail with
\&\s-1EAGAIN.\s0
.Sp
See also \*(L"Using Non-Blocking Sockets\*(R".
.IP "\(bu" 4
Expecting exactly the same behavior as plain sockets.
.Sp
IO::Socket::SSL tries to emulate the usual socket behavior as good as possible,
but full emulation can not be done. Specifically a read on the \s-1SSL\s0 socket might
also result in a write on the \s-1TCP\s0 socket or a write on the \s-1SSL\s0 socket might
result in a read on the \s-1TCP\s0 socket. Also \f(CW\*(C`accept\*(C'\fR and \fBclose\fR on the \s-1SSL\s0
socket will result in writing and reading data to the \s-1TCP\s0 socket too.
.Sp
Especially the hidden writes might result in a connection reset if the
underlying \s-1TCP\s0 socket is already closed by the peer. Unless signal \s-1PIPE\s0 is
explicitly handled by the application this will usually result in the
application crashing. It is thus recommended to explicitly \s-1IGNORE\s0 signal \s-1PIPE\s0 so
that the errors get propagated as \s-1EPIPE\s0 instead of causing a crash of the
application.
.IP "\(bu" 4
Set 'SSL_version' or 'SSL_cipher_list' to a \*(L"better\*(R" value.
.Sp
IO::Socket::SSL tries to set these values to reasonable, secure values which
are compatible with the rest of the world.
But, there are some scripts or modules out there which tried to be smart and
get more secure or compatible settings.
Unfortunately, they did this years ago and never updated these values, so they
are still forced to do only 'TLSv1' (instead of also using TLSv12 or TLSv11).
Or they set '\s-1HIGH\s0' as the cipher list and thought they were secure, but did not
notice that '\s-1HIGH\s0' includes anonymous ciphers, e.g. without identification of
the peer.
.Sp
So it is recommended to leave the settings at the secure defaults which
IO::Socket::SSL sets and which get updated from time to time to
better fit the real world.
.IP "\(bu" 4
Make \s-1SSL\s0 settings inaccessible by the user, together with bad builtin settings.
.Sp
Some modules use IO::Socket::SSL, but don't make the \s-1SSL\s0 settings available
to the user. This is often combined with bad builtin settings or defaults (like
switching verification off).
.Sp
Thus the user needs to hack around these restrictions by using
\&\f(CW\*(C`set_args_filter_hack\*(C'\fR or similar.
.IP "\(bu" 4
Use of constants as strings.
.Sp
Constants like \f(CW\*(C`SSL_VERIFY_PEER\*(C'\fR or \f(CW\*(C`SSL_WANT_READ\*(C'\fR should be used as
constants and not be put inside quotes, because they represent numerical values.
.IP "\(bu" 4
Forking and handling the socket in parent and child.
.Sp
A \fBfork\fR of the process will duplicate the internal user space \s-1SSL\s0 state of the
socket. If both master and child interact with the socket by using their own \s-1SSL\s0
state strange error messages will happen. Such interaction includes explicit or
implicit \fBclose\fR of the \s-1SSL\s0 socket. To avoid this the socket should be explicitly
closed with \fBSSL_no_shutdown\fR.
.IP "\(bu" 4
Forking and executing a new process.
.Sp
Since the \s-1SSL\s0 state is stored in user space it will be duplicated by a \fBfork\fR but
it will be lost when doing \fBexec\fR. This means it is not possible to simply
redirect stdin and stdout for the new process to the \s-1SSL\s0 socket by duplicating
the relevant file handles. Instead explicitly exchanging plain data between
child-process and \s-1SSL\s0 socket are needed.
.SH "Common Problems with SSL"
.IX Header "Common Problems with SSL"
\&\s-1SSL\s0 is a complex protocol with multiple implementations and each of these has
their own quirks. While most of these implementations work together, it often
gets problematic with older versions, minimal versions in load balancers, or plain
wrong setups.
.PP
Unfortunately these problems are hard to debug.
Helpful for debugging are a knowledge of \s-1SSL\s0 internals, wireshark and the use of
the debug settings of IO::Socket::SSL and Net::SSLeay, which can both be
set with \f(CW$IO::Socket::SSL::DEBUG\fR.
The following debugs levels are defined, but used not in any consistent way:
.IP "\(bu" 4
0 \- No debugging (default).
.IP "\(bu" 4
1 \- Print out errors from IO::Socket::SSL and ciphers from Net::SSLeay.
.IP "\(bu" 4
2 \- Print also information about call flow from IO::Socket::SSL and progress
information from Net::SSLeay.
.IP "\(bu" 4
3 \- Print also some data dumps from IO::Socket::SSL and from Net::SSLeay.
.PP
Also, \f(CW\*(C`analyze\-ssl.pl\*(C'\fR from the ssl-tools repository at
<https://github.com/noxxi/p5\-ssl\-tools>  might be a helpful tool when debugging
\&\s-1SSL\s0 problems, as do the \f(CW\*(C`openssl\*(C'\fR command line tool and a check with a
different \s-1SSL\s0 implementation (e.g. a web browser).
.PP
The following problems are not uncommon:
.IP "\(bu" 4
Bad server setup: missing intermediate certificates.
.Sp
It is a regular problem that administrators fail to include all necessary
certificates into their server setup, e.g. everything needed to build the trust
chain from the trusted root.
If they check the setup with the browser everything looks ok, because browsers
work around these problems by caching any intermediate certificates and apply
them to new connections if certificates are missing.
.Sp
But, fresh browser profiles which have never seen these intermediates cannot
fill in the missing certificates and fail to verify; the same is true with
IO::Socket::SSL.
.IP "\(bu" 4
Old versions of servers or load balancers which do not understand specific \s-1TLS\s0
versions or croak on specific data.
.Sp
From time to time one encounters an \s-1SSL\s0 peer, which just closes the connection
inside the \s-1SSL\s0 handshake. This can usually be worked around by downgrading the
\&\s-1SSL\s0 version, e.g. by setting \f(CW\*(C`SSL_version\*(C'\fR. Modern Browsers usually deal with
such servers by automatically downgrading the \s-1SSL\s0 version and repeat the
connection attempt until they succeed.
.Sp
Worse servers do not close the underlying \s-1TCP\s0 connection but instead just
drop the relevant packet. This is harder to detect because it looks like a
stalled connection. But downgrading the \s-1SSL\s0 version often works here too.
.Sp
A cause of such problems are often load balancers or security devices, which
have hardware acceleration and only a minimal (and less robust) \s-1SSL\s0 stack. They
can often be detected because they support much fewer ciphers than other
implementations.
.IP "\(bu" 4
Bad or old OpenSSL versions.
.Sp
IO::Socket::SSL uses OpenSSL with the help of the Net::SSLeay library. It
is recommend to have a recent version of this library, because it has more
features and usually fewer known bugs.
.IP "\(bu" 4
Validation of client certificates fail.
.Sp
Make sure that the purpose of the certificate allows use as ssl client (check
with \f(CW\*(C`openssl x509 \-purpose\*(C'\fR, that the necessary root certificate is in the
path specified by \f(CW\*(C`SSL_ca*\*(C'\fR (or the default path) and that any intermediate
certificates needed to build the trust chain are sent by the client.
.IP "\(bu" 4
Validation of self-signed certificate fails even if it is given with
\&\f(CW\*(C`SSL_ca*\*(C'\fR argument.
.Sp
The \f(CW\*(C`SSL_ca*\*(C'\fR arguments do not give a general trust store for arbitrary
certificates but only specify a store for \s-1CA\s0 certificates which then can be used
to verify other certificates.  This especially means that certificates which are
not a \s-1CA\s0 get simply ignored, notably self-signed certificates which do not also
have the CA-flag set.
.Sp
This behavior of OpenSSL differs from the more general trust-store concept which
can be found in browsers and where it is possible to simply added arbitrary
certificates (\s-1CA\s0 or not) as trusted.
.SH "Using Non-Blocking Sockets"
.IX Header "Using Non-Blocking Sockets"
If you have a non-blocking socket, the expected behavior on read, write, accept
or connect is to set \f(CW$!\fR to \s-1EWOULDBLOCK\s0 if the operation cannot be completed
immediately. Note that \s-1EWOULDBLOCK\s0 is the same as \s-1EAGAIN\s0 on \s-1UNIX\s0 systems, but
is different on Windows.
.PP
With \s-1SSL,\s0 handshakes might occur at any time, even within an established
connection. In these cases it is necessary to finish the handshake before
you can read or write data. This might result in situations where you want to
read but must first finish the write of a handshake or where you want to write
but must first finish a read.
In these cases \f(CW$!\fR is set to \s-1EAGAIN\s0 like expected, and additionally
\&\f(CW$SSL_ERROR\fR is set to either \s-1SSL_WANT_READ\s0 or \s-1SSL_WANT_WRITE.\s0
Thus if you get \s-1EWOULDBLOCK\s0 on a \s-1SSL\s0 socket you must check \f(CW$SSL_ERROR\fR for
SSL_WANT_* and adapt your event mask accordingly.
.PP
Using readline on non-blocking sockets does not make much sense and I would
advise against using it.
And, while the behavior is not documented for other IO::Socket classes, it
will try to emulate the behavior seen there, e.g. to return the received data
instead of blocking, even if the line is not complete. If an unrecoverable error
occurs it will return nothing, even if it already received some data.
.PP
Also, I would advise against using \f(CW\*(C`accept\*(C'\fR with a non-blocking \s-1SSL\s0 object
because it might block and this is not what most would expect. The reason for
this is that \f(CW\*(C`accept\*(C'\fR on a non-blocking \s-1TCP\s0 socket (e.g. IO::Socket::IP,
IO::Socket::INET..) results in a new \s-1TCP\s0 socket which does not inherit the
non-blocking behavior of the master socket. And thus, the initial \s-1SSL\s0 handshake
on the new socket inside \f(CW\*(C`IO::Socket::SSL::accept\*(C'\fR will be done in a blocking
way. To work around this you are safer by doing a \s-1TCP\s0 accept and later upgrade the
\&\s-1TCP\s0 socket in a non-blocking way with \f(CW\*(C`start_SSL\*(C'\fR and \f(CW\*(C`accept_SSL\*(C'\fR.
.PP
.Vb 8
\&    my $cl = IO::Socket::SSL\->new($dst);
\&    $cl\->blocking(0);
\&    my $sel = IO::Select\->new($cl);
\&    while (1) {
\&        # with SSL a call for reading n bytes does not result in reading of n
\&        # bytes from the socket, but instead it must read at least one full SSL
\&        # frame. If the socket has no new bytes, but there are unprocessed data
\&        # from the SSL frame can_read will block!
\&
\&        # wait for data on socket
\&        $sel\->can_read();
\&
\&        # new data on socket or eof
\&        READ:
\&        # this does not read only 1 byte from socket, but reads the complete SSL
\&        # frame and then just returns one byte. On subsequent calls it than
\&        # returns more byte of the same SSL frame until it needs to read the
\&        # next frame.
\&        my $n = sysread( $cl,my $buf,1);
\&        if ( ! defined $n ) {
\&            die $! if not $!{EWOULDBLOCK};
\&            next if $SSL_ERROR == SSL_WANT_READ;
\&            if ( $SSL_ERROR == SSL_WANT_WRITE ) {
\&                # need to write data on renegotiation
\&                $sel\->can_write;
\&                next;
\&            }
\&            die "something went wrong: $SSL_ERROR";
\&        } elsif ( ! $n ) {
\&            last; # eof
\&        } else {
\&            # read next bytes
\&            # we might have still data within the current SSL frame
\&            # thus first process these data instead of waiting on the underlying
\&            # socket object
\&            goto READ if $cl\->pending;    # goto sysread
\&            next;                         # goto $sel\->can_read
\&        }
\&    }
.Ve
.PP
Additionally there are differences to plain sockets when using select, poll,
kqueue or similar technologies to get notified if data are available.
Relying only on these calls is not sufficient in all cases since unread data
might be internally buffered in the \s-1SSL\s0 stack. To detect such buffering
\&\fB\fBpending()\fB\fR need to be used. Alternatively the buffering can be avoided by using
\&\fBsysread\fR with the maximum size of an \s-1SSL\s0 frame. See \*(L"Common Usage Errors\*(R"
for details.
.SH "Advanced Usage"
.IX Header "Advanced Usage"
.SS "\s-1SNI\s0 Support"
.IX Subsection "SNI Support"
Newer extensions to \s-1SSL\s0 can distinguish between multiple hostnames on the same
\&\s-1IP\s0 address using Server Name Indication (\s-1SNI\s0).
.PP
Support for \s-1SNI\s0 on the client side was added somewhere in the OpenSSL 0.9.8
series, but with 1.0 a bug was fixed when the server could not decide about
its hostname. Therefore client side \s-1SNI\s0 is only supported with OpenSSL 1.0 or
higher in IO::Socket::SSL.
With a supported version, \s-1SNI\s0 is used automatically on the client side, if it
can determine the hostname from \f(CW\*(C`PeerAddr\*(C'\fR or \f(CW\*(C`PeerHost\*(C'\fR (which are synonyms
in the underlying IO::Socket:: classes and thus should never be set both or at
least not to different values).
On unsupported OpenSSL versions it will silently not use \s-1SNI.\s0
The hostname can also be given explicitly given with \f(CW\*(C`SSL_hostname\*(C'\fR, but in
this case it will throw in error, if \s-1SNI\s0 is not supported.
To check for support you might call \f(CW\*(C`IO::Socket::SSL\->can_client_sni()\*(C'\fR.
.PP
On the server side, earlier versions of OpenSSL are supported, but only together
with Net::SSLeay version >= 1.50.
To check for support you might call \f(CW\*(C`IO::Socket::SSL\->can_server_sni()\*(C'\fR.
If server side \s-1SNI\s0 is supported, you might specify different certificates per
host with \f(CW\*(C`SSL_cert*\*(C'\fR and \f(CW\*(C`SSL_key*\*(C'\fR, and check the requested name using
\&\f(CW\*(C`get_servername\*(C'\fR.
.SS "Talk Plain and \s-1SSL\s0 With The Same Socket"
.IX Subsection "Talk Plain and SSL With The Same Socket"
It is often required to first exchange some plain data and then upgrade the
socket to \s-1SSL\s0 after some kind of \s-1STARTTLS\s0 command. Protocols like \s-1FTPS\s0 even
need a way to downgrade the socket again back to plain.
.PP
The common way to do this would be to create a normal socket and use \f(CW\*(C`start_SSL\*(C'\fR
to upgrade and stop_SSL to downgrade:
.PP
.Vb 7
\&    my $sock = IO::Socket::INET\->new(...) or die $!;
\&    ... exchange plain data on $sock until starttls command ...
\&    IO::Socket::SSL\->start_SSL($sock,%sslargs) or die $SSL_ERROR;
\&    ... now $sock is an IO::Socket::SSL object ...
\&    ... exchange data with SSL on $sock until stoptls command ...
\&    $sock\->stop_SSL or die $SSL_ERROR;
\&    ... now $sock is again an IO::Socket::INET object ...
.Ve
.PP
But, lots of modules just derive directly from IO::Socket::INET.
While this base class can be replaced with IO::Socket::SSL, these modules cannot
easily support different base classes for \s-1SSL\s0 and plain data and switch between
these classes on a starttls command.
.PP
To help in this case, IO::Socket::SSL can be reduced to a plain socket on
startup, and connect_SSL/accept_SSL/start_SSL can be used to enable \s-1SSL\s0 and
\&\f(CW\*(C`stop_SSL\*(C'\fR to talk plain again:
.PP
.Vb 12
\&    my $sock = IO::Socket::SSL\->new(
\&        PeerAddr => ...
\&        SSL_startHandshake => 0,
\&        %sslargs
\&    ) or die $!;
\&    ... exchange plain data on $sock until starttls command ...
\&    $sock\->connect_SSL or die $SSL_ERROR;
\&    ... now $sock is an IO::Socket::SSL object ...
\&    ... exchange data with SSL on $sock until stoptls command ...
\&    $sock\->stop_SSL or die $SSL_ERROR;
\&    ... $sock is still an IO::Socket::SSL object ...
\&    ... but data exchanged again in plain ...
.Ve
.SH "Integration Into Own Modules"
.IX Header "Integration Into Own Modules"
IO::Socket::SSL behaves similarly to other IO::Socket modules and thus could
be integrated in the same way, but you have to take special care when using
non-blocking I/O (like for handling timeouts) or using select or poll.
Please study the documentation on how to deal with these differences.
.PP
Also, it is recommended to not set or touch most of the \f(CW\*(C`SSL_*\*(C'\fR options, so
that they keep their secure defaults. It is also recommended to let the user
override these \s-1SSL\s0 specific settings without the need of global settings or hacks
like \f(CW\*(C`set_args_filter_hack\*(C'\fR.
.PP
The notable exception is \f(CW\*(C`SSL_verifycn_scheme\*(C'\fR.
This should be set to the hostname verification scheme required by the module or
protocol.
.SH "Description Of Methods"
.IX Header "Description Of Methods"
IO::Socket::SSL inherits from another IO::Socket module.
The choice of the super class depends on the installed modules:
.IP "\(bu" 4
If IO::Socket::IP with at least version 0.20 is installed it will use this
module as super class, transparently providing IPv6 and IPv4 support.
.IP "\(bu" 4
If IO::Socket::INET6 is installed it will use this module as super class,
transparently providing IPv6 and IPv4 support.
.IP "\(bu" 4
Otherwise it will fall back to IO::Socket::INET, which is a perl core module.
With IO::Socket::INET you only get IPv4 support.
.PP
Please be aware that with the IPv6 capable super classes, it will look first
for the IPv6 address of a given hostname. If the resolver provides an IPv6
address, but the host cannot be reached by IPv6, there will be no automatic
fallback to IPv4.
To avoid these problems you can enforce IPv4 for a specific socket by
using the \f(CW\*(C`Domain\*(C'\fR or \f(CW\*(C`Family\*(C'\fR option with the value \s-1AF_INET\s0 as described in
IO::Socket::IP. Alternatively you can enforce IPv4 globally by loading
IO::Socket::SSL with the option 'inet4', in which case it will use the IPv4
only class IO::Socket::INET as the super class.
.PP
IO::Socket::SSL will provide all of the methods of its super class, but
sometimes it will override them to match the behavior expected from \s-1SSL\s0 or to
provide additional arguments.
.PP
The new or changed methods are described below, but please also read the
section about \s-1SSL\s0 specific error handling.
.IP "Error Handling" 4
.IX Item "Error Handling"
If an \s-1SSL\s0 specific error occurs, the global variable \f(CW$SSL_ERROR\fR will be set.
If the error occurred on an existing \s-1SSL\s0 socket, the method \f(CW\*(C`errstr\*(C'\fR will
give access to the latest socket specific error.
Both \f(CW$SSL_ERROR\fR and the \f(CW\*(C`errstr\*(C'\fR method give a dualvar similar to \f(CW$!\fR, e.g.
providing an error number in numeric context or an error description in string
context.
.IP "\fBnew(...)\fR" 4
.IX Item "new(...)"
Creates a new IO::Socket::SSL object.  You may use all the friendly options
that came bundled with the super class (e.g. IO::Socket::IP,
IO::Socket::INET, ...) plus (optionally) the ones described below.
If you don't specify any \s-1SSL\s0 related options it will do its best in using
secure defaults, e.g. choosing good ciphers, enabling proper verification, etc.
.RS 4
.IP "SSL_server" 2
.IX Item "SSL_server"
Set this option to a true value if the socket should be used as a server.
If this is not explicitly set it is assumed if the \f(CW\*(C`Listen\*(C'\fR parameter is given
when creating the socket.
.IP "SSL_hostname" 2
.IX Item "SSL_hostname"
This can be given to specify the hostname used for \s-1SNI,\s0 which is needed if you
have multiple \s-1SSL\s0 hostnames on the same \s-1IP\s0 address. If not given it will try to
determine the hostname from \f(CW\*(C`PeerAddr\*(C'\fR, which will fail if only an \s-1IP\s0 was given or if
this argument is used within \f(CW\*(C`start_SSL\*(C'\fR.
.Sp
If you want to disable \s-1SNI,\s0 set this argument to ''.
.Sp
Currently only supported for the client side and will be ignored for the server
side.
.Sp
See section \*(L"\s-1SNI\s0 Support\*(R" for details of \s-1SNI\s0 the support.
.IP "SSL_startHandshake" 2
.IX Item "SSL_startHandshake"
If this option is set to false (defaults to true) it will not start the \s-1SSL\s0
handshake yet. This has to be done later with \f(CW\*(C`accept_SSL\*(C'\fR or \f(CW\*(C`connect_SSL\*(C'\fR.
Before the handshake is started read/write/etc. can be used to exchange plain
data.
.IP "SSL_keepSocketOnError" 2
.IX Item "SSL_keepSocketOnError"
If this option is set to true (defaults to false) it will not close the
underlying \s-1TCP\s0 socket on errors. In most cases there is no real use for this
behavior since both sides of the \s-1TCP\s0 connection will probably have a
different idea of the current state of the connection.
.IP "SSL_ca | SSL_ca_file | SSL_ca_path" 2
.IX Item "SSL_ca | SSL_ca_file | SSL_ca_path"
Usually you want to verify that the peer certificate has been signed by a
trusted certificate authority. In this case you should use this option to
specify the file (\f(CW\*(C`SSL_ca_file\*(C'\fR) or directory (\f(CW\*(C`SSL_ca_path\*(C'\fR) containing the
certificate(s) of the trusted certificate authorities.
.Sp
\&\f(CW\*(C`SSL_ca_path\*(C'\fR can also be an array or a string containing multiple path, where
the path are separated by the platform specific separator. This separator is
\&\f(CW\*(C`;\*(C'\fR on \s-1DOS,\s0 Windows, Netware, \f(CW\*(C`,\*(C'\fR on \s-1VMS\s0 and \f(CW\*(C`:\*(C'\fR for all the other systems.
If multiple path are given at least one of these must be accessible.
.Sp
You can also give a list of X509* certificate handles (like you get from
Net::SSLeay or IO::Socket::SSL::Utils::PEM_xxx2cert) with \f(CW\*(C`SSL_ca\*(C'\fR. These
will be added to the \s-1CA\s0 store before path and file and thus take precedence.
If neither SSL_ca, nor SSL_ca_file or SSL_ca_path are set it will use
\&\f(CW\*(C`default_ca()\*(C'\fR to determine the user-set or system defaults.
If you really don't want to set a \s-1CA\s0 set SSL_ca_file or SSL_ca_path to
\&\f(CW\*(C`\eundef\*(C'\fR or SSL_ca to an empty list. (unfortunately \f(CW\*(Aq\*(Aq\fR is used by some
modules using IO::Socket::SSL when \s-1CA\s0 is not explicitly given).
.IP "SSL_client_ca | SSL_client_ca_file" 2
.IX Item "SSL_client_ca | SSL_client_ca_file"
If verify_mode is \s-1VERIFY_PEER\s0 on the server side these options can be used to
set the list of acceptable CAs for the client. This way the client can select
they required certificate from a list of certificates.
The value for these options is similar to \f(CW\*(C`SSL_ca\*(C'\fR and \f(CW\*(C`SSL_ca_file\*(C'\fR.
.IP "SSL_fingerprint" 2
.IX Item "SSL_fingerprint"
Sometimes you have a self-signed certificate or a certificate issued by an
unknown \s-1CA\s0 and you really want to accept it, but don't want to disable
verification at all. In this case you can specify the fingerprint of the
certificate as \f(CW\*(Aqalgo$hex_fingerprint\*(Aq\fR. \f(CW\*(C`algo\*(C'\fR is a fingerprint algorithm
supported by OpenSSL, e.g. 'sha1','sha256'... and \f(CW\*(C`hex_fingerprint\*(C'\fR is the
hexadecimal representation of the binary fingerprint. Any colons inside the
hex string will be ignored.
.Sp
If you want to use the fingerprint of the pubkey inside the certificate instead
of the certificate use the syntax \f(CW\*(Aqalgo$pub$hex_fingerprint\*(Aq\fR instead.
To get the fingerprint of an established connection you can use
\&\f(CW\*(C`get_fingerprint\*(C'\fR.
.Sp
It is also possible to skip \f(CW\*(C`algo$\*(C'\fR, i.e. only specify the fingerprint. In
this case the likely algorithms will be automatically detected based on the
length of the digest string.
.Sp
You can specify a list of fingerprints in case you have several acceptable
certificates.
If a fingerprint matches the topmost (i.e. leaf) certificate no additional
validations can make the verification fail.
.IP "SSL_cert_file | SSL_cert | SSL_key_file | SSL_key" 2
.IX Item "SSL_cert_file | SSL_cert | SSL_key_file | SSL_key"
If you create a server you usually need to specify a server certificate which
should be verified by the client. Same is true for client certificates, which
should be verified by the server.
The certificate can be given as a file with SSL_cert_file or as an internal
representation of an X509* object (like you get from Net::SSLeay or
IO::Socket::SSL::Utils::PEM_xxx2cert) with SSL_cert.
If given as a file it will automatically detect the format.
Supported file formats are \s-1PEM, DER\s0 and PKCS#12, where \s-1PEM\s0 and PKCS#12 can
contain the certificate and the chain to use, while \s-1DER\s0 can only contain a single
certificate.
.Sp
If given as a list of X509* please note, that the all the chain certificates
(e.g. all except the first) will be \*(L"consumed\*(R" by openssl and will be freed
if the \s-1SSL\s0 context gets destroyed \- so you should never free them yourself. But
the servers certificate (e.g. the first) will not be consumed by openssl and
thus must be freed by the application.
.Sp
For each certificate a key is need, which can either be given as a file with
SSL_key_file or as an internal representation of an EVP_PKEY* object with
SSL_key (like you get from Net::SSLeay or
IO::Socket::SSL::Utils::PEM_xxx2key).
If a key was already given within the PKCS#12 file specified by SSL_cert_file
it will ignore any SSL_key or SSL_key_file.
If no SSL_key or SSL_key_file was given it will try to use the \s-1PEM\s0 file given
with SSL_cert_file again, maybe it contains the key too.
.Sp
If your \s-1SSL\s0 server should be able to use different certificates on the same \s-1IP\s0
address, depending on the name given by \s-1SNI,\s0 you can use a hash reference
instead of a file with \f(CW\*(C`<hostname =\*(C'\fR cert_file>>.
.Sp
If your \s-1SSL\s0 server should be able to use both \s-1RSA\s0 and \s-1ECDSA\s0 certificates for the
same domain/IP a similar hash reference like with \s-1SNI\s0 is given. The
domain names used to specify the additional certificates should be
\&\f(CW\*(C`hostname%whatever\*(C'\fR, i.e.  \f(CW\*(C`hostname%ecc\*(C'\fR or similar. This needs at least
OpenSSL 1.0.2. To let the server pick the certificate based on the clients
cipher preference \f(CW\*(C`SSL_honor_cipher_order\*(C'\fR should be set to false.
.Sp
In case certs and keys are needed but not given it might fall back to builtin
defaults, see \*(L"Defaults for Cert, Key and \s-1CA\*(R".\s0
.Sp
Examples:
.Sp
.Vb 2
\& SSL_cert_file => \*(Aqmycert.pem\*(Aq,
\& SSL_key_file => \*(Aqmykey.pem\*(Aq,
\&
\& SSL_cert_file => {
\&    "foo.example.org" => \*(Aqfoo\-cert.pem\*(Aq,
\&    "foo.example.org%ecc" => \*(Aqfoo\-ecc\-cert.pem\*(Aq,
\&    "bar.example.org" => \*(Aqbar\-cert.pem\*(Aq,
\&    # used when nothing matches or client does not support SNI
\&    \*(Aq\*(Aq => \*(Aqdefault\-cert.pem\*(Aq,
\&    \*(Aq%ecc\*(Aq => \*(Aqdefault\-ecc\-cert.pem\*(Aq,
\& },
\& SSL_key_file => {
\&    "foo.example.org" => \*(Aqfoo\-key.pem\*(Aq,
\&    "foo.example.org%ecc" => \*(Aqfoo\-ecc\-key.pem\*(Aq,
\&    "bar.example.org" => \*(Aqbar\-key.pem\*(Aq,
\&    # used when nothing matches or client does not support SNI
\&    \*(Aq\*(Aq => \*(Aqdefault\-key.pem\*(Aq,
\&    \*(Aq%ecc\*(Aq => \*(Aqdefault\-ecc\-key.pem\*(Aq,
\& }
.Ve
.IP "SSL_passwd_cb" 2
.IX Item "SSL_passwd_cb"
If your private key is encrypted, you might not want the default password prompt
from Net::SSLeay.  This option takes a reference to a subroutine that should
return the password required to decrypt your private key.
.IP "SSL_use_cert" 2
.IX Item "SSL_use_cert"
If this is true, it forces IO::Socket::SSL to use a certificate and key, even if
you are setting up an \s-1SSL\s0 client.  If this is set to 0 (the default), then you
will only need a certificate and key if you are setting up a server.
.Sp
SSL_use_cert will implicitly be set if SSL_server is set.
For convenience it is also set if it was not given but a cert was given for use
(SSL_cert_file or similar).
.IP "SSL_version" 2
.IX Item "SSL_version"
Sets the version of the \s-1SSL\s0 protocol used to transmit data.
\&'SSLv23' uses a handshake compatible with \s-1SSL2.0, SSL3.0\s0 and \s-1TLS1\s0.x, while
\&'SSLv2', 'SSLv3', 'TLSv1', 'TLSv1_1', 'TLSv1_2', or 'TLSv1_3' restrict
handshake and protocol to the specified version.
All values are case-insensitive.  Instead of 'TLSv1_1', 'TLSv1_2', and
\&'TLSv1_3' one can also use 'TLSv11', 'TLSv12', and 'TLSv13'.  Support for
\&'TLSv1_1', 'TLSv1_2', and 'TLSv1_3' requires recent versions of Net::SSLeay
and openssl.
.Sp
Independent from the handshake format you can limit to set of accepted \s-1SSL\s0
versions by adding !version separated by ':'.
.Sp
The default SSL_version is 'SSLv23:!SSLv3:!SSLv2' which means, that the
handshake format is compatible to \s-1SSL2.0\s0 and higher, but that the successful
handshake is limited to \s-1TLS1.0\s0 and higher, that is no \s-1SSL2.0\s0 or \s-1SSL3.0\s0 because
both of these versions have serious security issues and should not be used
anymore.
You can also use !TLSv1_1 and !TLSv1_2 to disable \s-1TLS\s0 versions 1.1 and 1.2 while
still allowing \s-1TLS\s0 version 1.0.
.Sp
Setting the version instead to 'TLSv1' might break interaction with older
clients, which need and \s-1SSL2.0\s0 compatible handshake. On the other
side some clients just close the connection when they receive a \s-1TLS\s0 version 1.1
request. In this case setting the version to
\&'SSLv23:!SSLv2:!SSLv3:!TLSv1_1:!TLSv1_2' might help.
.IP "SSL_cipher_list" 2
.IX Item "SSL_cipher_list"
If this option is set the cipher list for the connection will be set to the
given value, e.g. something like '\s-1ALL:\s0!LOW:!EXP:!aNULL'. Look into the OpenSSL
documentation (<https://www.openssl.org/docs/manmaster/man1/openssl\-ciphers.html#CIPHER\-STRINGS>)
for more details.
.Sp
Unless you fail to contact your peer because of no shared ciphers it is
recommended to leave this option at the default setting. The default setting
prefers ciphers with forward secrecy, disables anonymous authentication and
disables known insecure ciphers like \s-1MD5, DES\s0 etc. This gives a grade A result
at the tests of \s-1SSL\s0 Labs.
To use the less secure OpenSSL builtin default (whatever this is) set
SSL_cipher_list to ''.
.Sp
In case different cipher lists are needed for different \s-1SNI\s0 hosts a hash can be
given with the host as key and the cipher suite as value, similar to
\&\fBSSL_cert*\fR.
.IP "SSL_honor_cipher_order" 2
.IX Item "SSL_honor_cipher_order"
If this option is true the cipher order the server specified is used instead
of the order proposed by the client. This option defaults to true to make use of
our secure cipher list setting.
.IP "SSL_dh_file" 2
.IX Item "SSL_dh_file"
To create a server which provides forward secrecy you need to either give the \s-1DH\s0
parameters or (better, because faster) the \s-1ECDH\s0 curve. This setting cares
about \s-1DH\s0 parameters.
.Sp
To support non-elliptic Diffie-Hellman key exchange a suitable file needs to
be given here or the SSL_dh should be used with an appropriate value.
See dhparam command in openssl for more information.
.Sp
If neither \f(CW\*(C`SSL_dh_file\*(C'\fR nor \f(CW\*(C`SSL_dh\*(C'\fR are set a builtin \s-1DH\s0 parameter with a
length of 2048 bit is used to offer \s-1DH\s0 key exchange by default. If you don't
want this (e.g. disable \s-1DH\s0 key exchange) explicitly set this or the \f(CW\*(C`SSL_dh\*(C'\fR
parameter to undef.
.IP "SSL_dh" 2
.IX Item "SSL_dh"
Like SSL_dh_file, but instead of giving a file you use a preloaded or generated
DH*.
.IP "SSL_ecdh_curve" 2
.IX Item "SSL_ecdh_curve"
To create a server which provides forward secrecy you need to either give the \s-1DH\s0
parameters or (better, because faster) the \s-1ECDH\s0 curve. This setting cares
about the \s-1ECDH\s0 curve(s).
.Sp
To support Elliptic Curve Diffie-Hellmann key exchange the \s-1OID\s0 or \s-1NID\s0 of at
least one suitable curve needs to be provided here.
.Sp
With OpenSSL 1.1.0+ this parameter defaults to \f(CW\*(C`auto\*(C'\fR, which means that it
lets OpenSSL pick the best settings. If support for CTX_set_ecdh_auto is
implemented in Net::SSLeay (needs at least version 1.86) it will use this to
implement the same default.  Otherwise it will default to \f(CW\*(C`prime256v1\*(C'\fR
(builtin of OpenSSL) in order to offer \s-1ECDH\s0 key exchange by default.
.Sp
If setting groups or curves is supported by Net::SSLeay (needs at least
version 1.86) then multiple curves can be given here in the order of the
preference, i.e.  \f(CW\*(C`P\-521:P\-384:P\-256\*(C'\fR. When used at the client side this
will include the supported curves as extension in the \s-1TLS\s0 handshake.
.Sp
If you don't want to have \s-1ECDH\s0 key exchange this could be set to undef or
set \f(CW\*(C`SSL_ciphers\*(C'\fR to exclude all of these ciphers.
.Sp
You can check if \s-1ECDH\s0 support is available by calling
\&\f(CW\*(C`IO::Socket::SSL\->can_ecdh\*(C'\fR.
.IP "SSL_verify_mode" 2
.IX Item "SSL_verify_mode"
This option sets the verification mode for the peer certificate.
You may combine \s-1SSL_VERIFY_PEER\s0 (verify_peer), \s-1SSL_VERIFY_FAIL_IF_NO_PEER_CERT\s0
(fail verification if no peer certificate exists; ignored for clients),
\&\s-1SSL_VERIFY_CLIENT_ONCE\s0 (verify client once; ignored for clients).
See OpenSSL man page for SSL_CTX_set_verify for more information.
.Sp
The default is \s-1SSL_VERIFY_NONE\s0 for server  (e.g. no check for client
certificate) and \s-1SSL_VERIFY_PEER\s0 for client (check server certificate).
.IP "SSL_verify_callback" 2
.IX Item "SSL_verify_callback"
If you want to verify certificates yourself, you can pass a sub reference along
with this parameter to do so.  When the callback is called, it will be passed:
.RS 2
.IP "1. a true/false value that indicates what OpenSSL thinks of the certificate," 4
.IX Item "1. a true/false value that indicates what OpenSSL thinks of the certificate,"
.PD 0
.IP "2. a C\-style memory address of the certificate store," 4
.IX Item "2. a C-style memory address of the certificate store,"
.IP "3. a string containing the certificate's issuer attributes and owner attributes, and" 4
.IX Item "3. a string containing the certificate's issuer attributes and owner attributes, and"
.IP "4. a string containing any errors encountered (0 if no errors)." 4
.IX Item "4. a string containing any errors encountered (0 if no errors)."
.IP "5. a C\-style memory address of the peer's own certificate (convertible to \s-1PEM\s0 form with \fBNet::SSLeay::PEM_get_string_X509()\fR)." 4
.IX Item "5. a C-style memory address of the peer's own certificate (convertible to PEM form with Net::SSLeay::PEM_get_string_X509())."
.IP "6. The depth of the certificate in the chain. Depth 0 is the leaf certificate." 4
.IX Item "6. The depth of the certificate in the chain. Depth 0 is the leaf certificate."
.RE
.RS 2
.PD
.Sp
The function should return 1 or 0, depending on whether it thinks the
certificate is valid or invalid.  The default is to let OpenSSL do all of the
busy work.
.Sp
The callback will be called for each element in the certificate chain.
.Sp
See the OpenSSL documentation for SSL_CTX_set_verify for more information.
.RE
.IP "SSL_verifycn_scheme" 2
.IX Item "SSL_verifycn_scheme"
The scheme is used to correctly verify the identity inside the certificate
by using the hostname of the peer.
See the information about the verification schemes in \fBverify_hostname\fR.
.Sp
If you don't specify a scheme it will use 'default', but only complain loudly if
the name verification fails instead of letting the whole certificate
verification fail. \s-1THIS WILL CHANGE,\s0 e.g. it will let the certificate
verification fail in the future if the hostname does not match the certificate
!!!!  To override the name used in verification use \fBSSL_verifycn_name\fR.
.Sp
The scheme 'default' is a superset of the usual schemes, which will accept the
hostname in common name and subjectAltName and allow wildcards everywhere.
While using this scheme is way more secure than no name verification at all you
better should use the scheme specific to your application protocol, e.g. 'http',
\&'ftp'...
.Sp
If you are really sure, that you don't want to verify the identity using the
hostname  you can use 'none' as a scheme. In this case you'd better have
alternative forms of verification, like a certificate fingerprint or do a manual
verification later by calling \fBverify_hostname\fR yourself.
.IP "SSL_verifycn_publicsuffix" 2
.IX Item "SSL_verifycn_publicsuffix"
This option is used to specify the behavior when checking wildcards certificates
for public suffixes, e.g. no wildcard certificates for *.com or *.co.uk should
be accepted, while *.example.com or *.example.co.uk is ok.
.Sp
If not specified it will simply use the builtin default of
IO::Socket::SSL::PublicSuffix, you can create another object with
from_string or from_file of this module.
.Sp
To disable verification of public suffix set this option to \f(CW\*(Aq\*(Aq\fR.
.IP "SSL_verifycn_name" 2
.IX Item "SSL_verifycn_name"
Set the name which is used in verification of hostname. If SSL_verifycn_scheme
is set and no SSL_verifycn_name is given it will try to use SSL_hostname or
PeerHost and PeerAddr settings and fail if no name can be determined.
If SSL_verifycn_scheme is not set it will use a default scheme and warn if it
cannot determine a hostname, but it will not fail.
.Sp
Using PeerHost or PeerAddr works only if you create the connection directly
with \f(CW\*(C`IO::Socket::SSL\->new\*(C'\fR, if an IO::Socket::INET object is upgraded
with \fBstart_SSL\fR the name has to be given in \fBSSL_verifycn_name\fR or
\&\fBSSL_hostname\fR.
.IP "SSL_check_crl" 2
.IX Item "SSL_check_crl"
If you want to verify that the peer certificate has not been revoked
by the signing authority, set this value to true. OpenSSL will search
for the \s-1CRL\s0 in your SSL_ca_path, or use the file specified by
SSL_crl_file.  See the Net::SSLeay documentation for more details.
Note that this functionality appears to be broken with OpenSSL <
v0.9.7b, so its use with lower versions will result in an error.
.IP "SSL_crl_file" 2
.IX Item "SSL_crl_file"
If you want to specify the \s-1CRL\s0 file to be used, set this value to the
pathname to be used.  This must be used in addition to setting
SSL_check_crl.
.IP "SSL_ocsp_mode" 2
.IX Item "SSL_ocsp_mode"
Defines how certificate revocation is done using \s-1OCSP\s0 (Online Status Revocation
Protocol). The default is to send a request for \s-1OCSP\s0 stapling to the server and
if the server sends an \s-1OCSP\s0 response back the result will be used.
.Sp
Any other \s-1OCSP\s0 checking needs to be done manually with \f(CW\*(C`ocsp_resolver\*(C'\fR.
.Sp
The following flags can be combined with \f(CW\*(C`|\*(C'\fR:
.RS 2
.IP "\s-1SSL_OCSP_NO_STAPLE\s0" 8
.IX Item "SSL_OCSP_NO_STAPLE"
Don't ask for \s-1OCSP\s0 stapling.
This is the default if SSL_verify_mode is \s-1VERIFY_NONE.\s0
.IP "\s-1SSL_OCSP_TRY_STAPLE\s0" 8
.IX Item "SSL_OCSP_TRY_STAPLE"
Try \s-1OCSP\s0 stapling, but don't complain if it gets no stapled response back.
This is the default if SSL_verify_mode is \s-1VERIFY_PEER\s0 (the default).
.IP "\s-1SSL_OCSP_MUST_STAPLE\s0" 8
.IX Item "SSL_OCSP_MUST_STAPLE"
Consider it a hard error, if the server does not send a stapled \s-1OCSP\s0 response
back. Most servers currently send no stapled \s-1OCSP\s0 response back.
.IP "\s-1SSL_OCSP_FAIL_HARD\s0" 8
.IX Item "SSL_OCSP_FAIL_HARD"
Fail hard on response errors, default is to fail soft like the browsers do.
Soft errors mean, that the \s-1OCSP\s0 response is not usable, e.g. no response,
error response, no valid signature etc.
Certificate revocations inside a verified response are considered hard errors
in any case.
.Sp
Soft errors inside a stapled response are never considered hard, e.g. it is
expected that in this case an \s-1OCSP\s0 request will be send to the responsible
\&\s-1OCSP\s0 responder.
.IP "\s-1SSL_OCSP_FULL_CHAIN\s0" 8
.IX Item "SSL_OCSP_FULL_CHAIN"
This will set up the \f(CW\*(C`ocsp_resolver\*(C'\fR so that all certificates from the peer
chain will be checked, otherwise only the leaf certificate will be checked
against revocation.
.RE
.RS 2
.RE
.IP "SSL_ocsp_staple_callback" 2
.IX Item "SSL_ocsp_staple_callback"
If this callback is defined, it will be called with the \s-1SSL\s0 object and the \s-1OCSP\s0
response handle obtained from the peer, e.g. \f(CW\*(C`<$cb\-\*(C'\fR($ssl,$resp)>>.
If the peer did not provide a stapled \s-1OCSP\s0 response the function will be called
with \f(CW\*(C`$resp=undef\*(C'\fR.
Because the \s-1OCSP\s0 response handle is no longer valid after leaving this function
it should not by copied or freed. If access to the response is necessary after
leaving this function it can be serialized with
\&\f(CW\*(C`Net::SSLeay::i2d_OCSP_RESPONSE\*(C'\fR.
.Sp
If no such callback is provided, it will use the default one, which verifies the
response and uses it to check if the certificate(s) of the connection got
revoked.
.IP "SSL_ocsp_cache" 2
.IX Item "SSL_ocsp_cache"
With this option a cache can be given for caching \s-1OCSP\s0 responses, which could
be shared between different \s-1SSL\s0 contexts. If not given a cache specific to the
\&\s-1SSL\s0 context only will be used.
.Sp
You can either create a new cache with
\&\f(CW\*(C`IO::Socket::SSL::OCSP_Cache\->new([size])\*(C'\fR or implement your own cache,
which needs to have methods \f(CW\*(C`put($key,\e%entry)\*(C'\fR and \f(CW\*(C`get($key)\*(C'\fR (returning
\&\f(CW\*(C`\e%entry\*(C'\fR) where entry is the hash representation of the \s-1OCSP\s0 response with
fields like \f(CW\*(C`nextUpdate\*(C'\fR. The default implementation of the cache will consider
responses valid as long as \f(CW\*(C`nextUpdate\*(C'\fR is less then the current time.
.IP "SSL_reuse_ctx" 2
.IX Item "SSL_reuse_ctx"
If you have already set the above options for a previous instance of
IO::Socket::SSL, then you can reuse the \s-1SSL\s0 context of that instance by passing
it as the value for the SSL_reuse_ctx parameter.  You may also create a
new instance of the IO::Socket::SSL::SSL_Context class, using any context
options that you desire without specifying connection options, and pass that
here instead.
.Sp
If you use this option, all other context-related options that you pass
in the same call to \fBnew()\fR will be ignored unless the context supplied was
invalid.  Note that, contrary to versions of IO::Socket::SSL below v0.90, a
global \s-1SSL\s0 context will not be implicitly used unless you use the
\&\fBset_default_context()\fR function.
.IP "SSL_create_ctx_callback" 2
.IX Item "SSL_create_ctx_callback"
With this callback you can make individual settings to the context after it
got created and the default setup was done.
The callback will be called with the \s-1CTX\s0 object from Net::SSLeay as the single
argument.
.Sp
Example for limiting the server session cache size:
.Sp
.Vb 4
\&  SSL_create_ctx_callback => sub {
\&      my $ctx = shift;
\&      Net::SSLeay::CTX_sess_set_cache_size($ctx,128);
\&  }
.Ve
.IP "SSL_session_cache_size" 2
.IX Item "SSL_session_cache_size"
If you make repeated connections to the same host/port and the \s-1SSL\s0 renegotiation
time is an issue, you can turn on client-side session caching with this option
by specifying a positive cache size.  For successive connections, pass the
SSL_reuse_ctx option to the \fBnew()\fR calls (or use \fBset_default_context()\fR) to make
use of the cached sessions.  The session cache size refers to the number of
unique host/port pairs that can be stored at one time; the oldest sessions in
the cache will be removed if new ones are added.
.Sp
This option does not effect the session cache a server has for it's clients,
e.g. it does not affect \s-1SSL\s0 objects with SSL_server set.
.Sp
Note that session caching with \s-1TLS 1.3\s0 needs at least Net::SSLeay 1.86.
.IP "SSL_session_cache" 2
.IX Item "SSL_session_cache"
Specifies session cache object which should be used instead of creating a new.
Overrules SSL_session_cache_size.
This option is useful if you want to reuse the cache, but not the rest of
the context.
.Sp
A session cache object can be created using
\&\f(CW\*(C`IO::Socket::SSL::Session_Cache\->new( cachesize )\*(C'\fR.
.Sp
Use \fBset_default_session_cache()\fR to set a global cache object.
.IP "SSL_session_key" 2
.IX Item "SSL_session_key"
Specifies a key to use for lookups and inserts into client-side session cache.
Per default ip:port of destination will be used, but sometimes you want to
share the same session over multiple ports on the same server (like with \s-1FTPS\s0).
.IP "SSL_session_id_context" 2
.IX Item "SSL_session_id_context"
This gives an id for the servers session cache. It's necessary if you want
clients to connect with a client certificate. If not given but SSL_verify_mode
specifies the need for client certificate a context unique id will be picked.
.IP "SSL_error_trap" 2
.IX Item "SSL_error_trap"
When using the \fBaccept()\fR or \fBconnect()\fR methods, it may be the case that the
actual socket connection works but the \s-1SSL\s0 negotiation fails, as in the case of
an \s-1HTTP\s0 client connecting to an \s-1HTTPS\s0 server.  Passing a subroutine ref attached
to this parameter allows you to gain control of the orphaned socket instead of
having it be closed forcibly.
The subroutine, if called, will be passed two parameters:
a reference to the socket on which the \s-1SSL\s0 negotiation failed and the full
text of the error message.
.IP "SSL_npn_protocols" 2
.IX Item "SSL_npn_protocols"
If used on the server side it specifies list of protocols advertised by \s-1SSL\s0
server as an array ref, e.g. ['spdy/2','http1.1'].
On the client side it specifies the protocols offered by the client for \s-1NPN\s0
as an array ref.
See also method \f(CW\*(C`next_proto_negotiated\*(C'\fR.
.Sp
Next Protocol Negotiation (\s-1NPN\s0) is available with Net::SSLeay 1.46+ and
openssl\-1.0.1+. \s-1NPN\s0 is unavailable in TLSv1.3 protocol.
To check support you might call \f(CW\*(C`IO::Socket::SSL\->can_npn()\*(C'\fR.
If you use this option with an unsupported Net::SSLeay/OpenSSL it will
throw an error.
.IP "SSL_alpn_protocols" 2
.IX Item "SSL_alpn_protocols"
If used on the server side it specifies list of protocols supported by the \s-1SSL\s0
server as an array ref, e.g. ['http/2.0', 'spdy/3.1','http/1.1'].
On the client side it specifies the protocols advertised by the client for \s-1ALPN\s0
as an array ref.
See also method \f(CW\*(C`alpn_selected\*(C'\fR.
.Sp
Application-Layer Protocol Negotiation (\s-1ALPN\s0) is available with Net::SSLeay
1.56+ and openssl\-1.0.2+. More details about the extension are in \s-1RFC7301.\s0 To
check support you might call \f(CW\*(C`IO::Socket::SSL\->can_alpn()\*(C'\fR. If you use
this option with an unsupported Net::SSLeay/OpenSSL it will throw an error.
.Sp
Note that some client implementations may encounter problems if both \s-1NPN\s0 and
\&\s-1ALPN\s0 are specified. Since \s-1ALPN\s0 is intended as a replacement for \s-1NPN,\s0 try
providing \s-1ALPN\s0 protocols then fall back to \s-1NPN\s0 if that fails.
.ie n .IP "SSL_ticket_keycb => [$sub,$data] | $sub" 2
.el .IP "SSL_ticket_keycb => [$sub,$data] | \f(CW$sub\fR" 2
.IX Item "SSL_ticket_keycb => [$sub,$data] | $sub"
This is a callback used for stateless session reuse (Session Tickets, \s-1RFC 5077\s0).
.Sp
This callback will be called as \f(CW\*(C`$sub\->($data,[$key_name])\*(C'\fR where \f(CW$data\fR
is the argument given to SSL_ticket_keycb (or undef) and \f(CW$key_name\fR depends
on the mode:
.RS 2
.IP "encrypt ticket" 8
.IX Item "encrypt ticket"
If a ticket needs to be encrypted the callback will be called without
\&\f(CW$key_name\fR. In this case it should return \f(CW\*(C`($current_key,$current_key_name\*(C'\fR)
where \f(CW$current_key\fR is the current key (32 byte random data) and
\&\f(CW$current_key_name\fR the name associated with this key (exactly 16 byte). This
\&\f(CW$current_key_name\fR will be incorporated into the ticket.
.IP "decrypt ticket" 8
.IX Item "decrypt ticket"
If a ticket needs to be decrypted the callback will be called with \f(CW$key_name\fR
as found in the ticket. It should return \f(CW\*(C`($key,$current_key_name\*(C'\fR) where
\&\f(CW$key\fR is the key associated with the given \f(CW$key_name\fR and
\&\f(CW$current_key_name\fR the name associated with the currently active key.
If \f(CW$current_key_name\fR is different from the given \f(CW$key_name\fR the callback
will be called again to re-encrypt the ticket with the currently active key.
.Sp
If no key can be found which matches the given \f(CW$key_name\fR then this function
should return nothing (empty list).
.Sp
This mechanism should be used to limit the life time for each key encrypting the
ticket. Compromise of a ticket encryption key might lead to decryption of \s-1SSL\s0
sessions which used session tickets protected by this key.
.RE
.RS 2
.Sp
Example:
.Sp
.Vb 4
\&    Net::SSLeay::RAND_bytes(my $oldkey,32);
\&    Net::SSLeay::RAND_bytes(my $newkey,32);
\&    my $oldkey_name = pack("a16",\*(Aqoldsecret\*(Aq);
\&    my $newkey_name = pack("a16",\*(Aqnewsecret\*(Aq);
\&
\&    my @keys = (
\&       [ $newkey_name, $newkey ], # current active key
\&       [ $oldkey_name, $oldkey ], # already expired
\&    );
\&
\&    my $keycb = [ sub {
\&       my ($mykeys,$name) = @_;
\&
\&       # return (current_key, current_key_name) if no name given
\&       return ($mykeys\->[0][1],$mykeys\->[0][0]) if ! $name;
\&
\&       # return (matching_key, current_key_name) if we find a key matching
\&       # the given name
\&       for(my $i = 0; $i<@$mykeys; $i++) {
\&           next if $name ne $mykeys\->[$i][0];
\&           return ($mykeys\->[$i][1],$mykeys\->[0][0]);
\&       }
\&
\&       # no matching key found
\&       return;
\&    },\e@keys ];
\&
\&    my $srv = IO::Socket::SSL\->new(..., SSL_ticket_keycb => $keycb);
.Ve
.RE
.IP "SSL_mode_release_buffers 1|0" 2
.IX Item "SSL_mode_release_buffers 1|0"
This enables or disables the \s-1SSL_MODE_RELEASE_BUFFERS\s0 option on the \s-1SSL\s0 object.
With this option the read buffer will be released after each SSL_read but will
need to be reallocated for each new SSL_read. If memory usage is a concern this
might save lots of memory in the mean time though, about 34k per idle \s-1SSL\s0
connection according to the documentation in \fBSSL_CTX_set_mode\fR\|(3ssl).
.RE
.RS 4
.RE
.IP "\fBaccept\fR" 4
.IX Item "accept"
This behaves similar to the accept function of the underlying socket class, but
additionally does the initial \s-1SSL\s0 handshake. But because the underlying socket
class does return a blocking file handle even when accept is called on a
non-blocking socket, the \s-1SSL\s0 handshake on the new file object will be done in a
blocking way. Please see the section about non-blocking I/O for details.
If you don't like this behavior you should do accept on the \s-1TCP\s0 socket and then
upgrade it with \f(CW\*(C`start_SSL\*(C'\fR later.
.IP "\fBconnect(...)\fR" 4
.IX Item "connect(...)"
This behaves similar to the connect function but also does an \s-1SSL\s0 handshake.
Because you cannot give \s-1SSL\s0 specific arguments to this function, you should
better either use \f(CW\*(C`new\*(C'\fR to create a connect \s-1SSL\s0 socket or \f(CW\*(C`start_SSL\*(C'\fR to
upgrade an established \s-1TCP\s0 socket to \s-1SSL.\s0
.IP "\fBclose(...)\fR" 4
.IX Item "close(...)"
Contrary to a close for a simple \s-1INET\s0 socket a close in \s-1SSL\s0 also mandates a
proper shutdown of the \s-1SSL\s0 part. This is done by sending a close notify message
by both peers.
.Sp
A naive implementation would thus wait until it receives the
close notify message from the peer \- which conflicts with the commonly expected
semantic that a close will not block. The default behavior is thus to only send
a close notify but not  wait for the close notify of the peer. If this is
required \f(CW\*(C`SSL_fast_shutdown\*(C'\fR need to be explicitly set to false.
.Sp
There are also cases where a \s-1SSL\s0 shutdown should not be done at all. This is
true for example when forking to let a child deal with the socket and closing
the socket in the parent process. A naive explicit \f(CW\*(C`close\*(C'\fR or an implicit close
when destroying the socket in the parent would send a close notify to the peer
which would make the \s-1SSL\s0 socket in the client process unusable. In this case an
explicit \f(CW\*(C`close\*(C'\fR with \f(CW\*(C`SSL_no_shutdown\*(C'\fR set to true should be done in the
parent process.
.Sp
For more details and other arguments see \f(CW\*(C`stop_SSL\*(C'\fR which gets called from
\&\f(CW\*(C`close\*(C'\fR to shutdown the \s-1SSL\s0 state of the socket.
.IP "\fBsysread( \s-1BUF, LEN,\s0 [ \s-1OFFSET\s0 ] )\fR" 4
.IX Item "sysread( BUF, LEN, [ OFFSET ] )"
This function behaves from the outside the same as \fBsysread\fR in other
IO::Socket objects, e.g. it returns at most \s-1LEN\s0 bytes of data.
But in reality it reads not only \s-1LEN\s0 bytes from the underlying socket, but at
a single \s-1SSL\s0 frame. It then returns up to \s-1LEN\s0 bytes it decrypted from this \s-1SSL\s0
frame. If the frame contained more data than requested it will return only \s-1LEN\s0
data, buffer the rest and return it on further read calls.
This means, that it might be possible to read data, even if the underlying
socket is not readable, so using poll or select might not be sufficient.
.Sp
sysread will only return data from a single \s-1SSL\s0 frame, e.g. either the pending
data from the already buffered frame or it will read a frame from the underlying
socket and return the decrypted data. It will not return data spanning several
\&\s-1SSL\s0 frames in a single call.
.Sp
Also, calls to sysread might fail, because it must first finish an \s-1SSL\s0
handshake.
.Sp
To understand these behaviors is essential, if you write applications which use
event loops and/or non-blocking sockets. Please read the specific sections in
this documentation.
.IP "\fBsyswrite( \s-1BUF,\s0 [ \s-1LEN,\s0 [ \s-1OFFSET\s0 ]] )\fR" 4
.IX Item "syswrite( BUF, [ LEN, [ OFFSET ]] )"
This functions behaves from the outside the same as \fBsyswrite\fR in other
IO::Socket objects, e.g. it will write at most \s-1LEN\s0 bytes to the socket, but
there is no guarantee, that all \s-1LEN\s0 bytes are written. It will return the number
of bytes written.
Because it basically just calls SSL_write from OpenSSL syswrite will write at
most a single \s-1SSL\s0 frame. This means, that no more than 16.384 bytes, which is
the maximum size of an \s-1SSL\s0 frame, will be written at once.
.Sp
For non-blocking sockets \s-1SSL\s0 specific behavior applies.
Pease read the specific section in this documentation.
.IP "\fBpeek( \s-1BUF, LEN,\s0 [ \s-1OFFSET\s0 ])\fR" 4
.IX Item "peek( BUF, LEN, [ OFFSET ])"
This function has exactly the same syntax as \fBsysread\fR, and performs nearly the
same task but will not advance the read position so that successive calls to
\&\fBpeek()\fR with the same arguments will return the same results.  This function
requires OpenSSL 0.9.6a or later to work.
.IP "\fB\fBpending()\fB\fR" 4
.IX Item "pending()"
This function gives you the number of bytes available without reading from the
underlying socket object. This function is essential if you work with event
loops, please see the section about polling \s-1SSL\s0 sockets.
.IP "\fBget_fingerprint([algo,certificate,pubkey])\fR" 4
.IX Item "get_fingerprint([algo,certificate,pubkey])"
This methods returns the fingerprint of the given certificate in the form
\&\f(CW\*(C`algo$digest_hex\*(C'\fR, where \f(CW\*(C`algo\*(C'\fR is the used algorithm, default 'sha256'.
If no certificate is given the peer certificate of the connection is used.
If \f(CW\*(C`pubkey\*(C'\fR is true it will not return the fingerprint of the certificate but
instead the fingerprint of the pubkey inside the certificate as
\&\f(CW\*(C`algo$pub$digest_hex\*(C'\fR.
.IP "\fBget_fingerprint_bin([algo,certificate,pubkey])\fR" 4
.IX Item "get_fingerprint_bin([algo,certificate,pubkey])"
This methods returns the binary fingerprint of the given certificate by using
the algorithm \f(CW\*(C`algo\*(C'\fR, default 'sha256'.
If no certificate is given the peer certificate of the connection is used.
If \f(CW\*(C`pubkey\*(C'\fR is true it will not return the fingerprint of the certificate but
instead the fingerprint of the pubkey inside the certificate.
.IP "\fB\fBget_cipher()\fB\fR" 4
.IX Item "get_cipher()"
Returns the string form of the cipher that the IO::Socket::SSL object is using.
.IP "\fB\fBget_sslversion()\fB\fR" 4
.IX Item "get_sslversion()"
Returns the string representation of the \s-1SSL\s0 version of an established
connection.
.IP "\fB\fBget_sslversion_int()\fB\fR" 4
.IX Item "get_sslversion_int()"
Returns the integer representation of the \s-1SSL\s0 version of an established
connection.
.IP "\fB\fBget_session_reused()\fB\fR" 4
.IX Item "get_session_reused()"
This returns true if the session got reused and false otherwise. Note that with
a reused session no certificates are send within the handshake and no ciphers
are offered and thus functions which rely on this might not work.
.IP "\fB\fBdump_peer_certificate()\fB\fR" 4
.IX Item "dump_peer_certificate()"
Returns a parsable string with select fields from the peer \s-1SSL\s0 certificate.
This method directly returns the result of the \fBdump_peer_certificate()\fR method of
Net::SSLeay.
.IP "\fBpeer_certificate($field;[$refresh])\fR" 4
.IX Item "peer_certificate($field;[$refresh])"
If a peer certificate exists, this function can retrieve values from it.
If no field is given the internal representation of certificate from Net::SSLeay
is returned.
If refresh is true it will not used a cached version, but check again in case
the certificate of the connection has changed due to renegotiation.
.Sp
The following fields can be queried:
.RS 4
.IP "authority (alias issuer)" 8
.IX Item "authority (alias issuer)"
The certificate authority which signed the certificate.
.IP "owner (alias subject)" 8
.IX Item "owner (alias subject)"
The owner of the certificate.
.IP "commonName (alias cn) \- only for Net::SSLeay version >=1.30" 8
.IX Item "commonName (alias cn) - only for Net::SSLeay version >=1.30"
The common name, usually the server name for \s-1SSL\s0 certificates.
.IP "subjectAltNames \- only for Net::SSLeay version >=1.33" 8
.IX Item "subjectAltNames - only for Net::SSLeay version >=1.33"
Alternative names for the subject, usually different names for the same
server, like example.org, example.com, *.example.com.
.Sp
It returns a list of (typ,value) with typ \s-1GEN_DNS, GEN_IPADD\s0 etc (these
constants are exported from IO::Socket::SSL).
See Net::SSLeay::X509_get_subjectAltNames.
.RE
.RS 4
.RE
.IP "\fBsock_certificate($field)\fR" 4
.IX Item "sock_certificate($field)"
This is similar to \f(CW\*(C`peer_certificate\*(C'\fR but will return the sites own
certificate. The same arguments for \fB\f(CB$field\fB\fR can be used.
If no \fB\f(CB$field\fB\fR is given the certificate handle from the underlying OpenSSL will
be returned. This handle will only be valid as long as the \s-1SSL\s0 connection exists
and if used afterwards it might result in strange crashes of the application.
.IP "\fBpeer_certificates\fR" 4
.IX Item "peer_certificates"
This returns all the certificates send by the peer, e.g. first the peers own
certificate and then the rest of the chain. You might use \fBCERT_asHash\fR from
IO::Socket::SSL::Utils to inspect each of the certificates.
.Sp
This function depends on a version of Net::SSLeay >= 1.58 .
.IP "\fBget_servername\fR" 4
.IX Item "get_servername"
This gives the name requested by the client if Server Name Indication
(\s-1SNI\s0) was used.
.IP "\fBverify_hostname($hostname,$scheme,$publicsuffix)\fR" 4
.IX Item "verify_hostname($hostname,$scheme,$publicsuffix)"
This verifies the given hostname against the peer certificate using the
given scheme. Hostname is usually what you specify within the PeerAddr.
See the \f(CW\*(C`SSL_verifycn_publicsuffix\*(C'\fR parameter for an explanation of suffix
checking and for the possible values.
.Sp
Verification of hostname against a certificate is different between various
applications and RFCs. Some scheme allow wildcards for hostnames, some only
in subjectAltNames, and even their different wildcard schemes are possible.
\&\s-1RFC 6125\s0 provides a good overview.
.Sp
To ease the verification the following schemes are predefined (both protocol
name and rfcXXXX name can be used):
.RS 4
.IP "rfc2818, xmpp (rfc3920), ftp (rfc4217)" 8
.IX Item "rfc2818, xmpp (rfc3920), ftp (rfc4217)"
Extended wildcards in subjectAltNames and common name are possible, e.g.
*.example.org or even www*.example.org. The common
name will be only checked if no \s-1DNS\s0 names are given in subjectAltNames.
.IP "http (alias www)" 8
.IX Item "http (alias www)"
While name checking is defined in rfc2818 the current browsers usually accept
also an \s-1IP\s0 address (w/o wildcards) within the common name as long as no
subjectAltNames are defined. Thus this is rfc2818 extended with this feature.
.IP "smtp (rfc2595), imap, pop3, acap (rfc4642), netconf (rfc5538), syslog (rfc5425), snmp (rfc5953)" 8
.IX Item "smtp (rfc2595), imap, pop3, acap (rfc4642), netconf (rfc5538), syslog (rfc5425), snmp (rfc5953)"
Simple wildcards in subjectAltNames are possible, e.g. *.example.org matches
www.example.org but not lala.www.example.org. If nothing from subjectAltNames
match it checks against the common name, where wildcards are also allowed to
match the full leftmost label.
.IP "ldap (rfc4513)" 8
.IX Item "ldap (rfc4513)"
Simple wildcards are allowed in subjectAltNames, but not in common name.
Common name will be checked even if subjectAltNames exist.
.IP "sip (rfc5922)" 8
.IX Item "sip (rfc5922)"
No wildcards are allowed and common name is checked even if subjectAltNames
exist.
.IP "gist (rfc5971)" 8
.IX Item "gist (rfc5971)"
Simple wildcards are allowed in subjectAltNames and common name, but common name
will only be checked if their are no \s-1DNS\s0 names in subjectAltNames.
.IP "default" 8
.IX Item "default"
This is a superset of all the rules and is automatically used if no scheme is
given but a hostname (instead of \s-1IP\s0) is known.
Extended wildcards are allowed in subjectAltNames and common name and common
name is checked always.
.IP "none" 8
.IX Item "none"
No verification will be done.
Actually is does not make any sense to call verify_hostname in this case.
.RE
.RS 4
.Sp
The scheme can be given either by specifying the name for one of the above
predefined schemes, or by using a hash which can have the following keys and
values:
.IP "check_cn:  0|'always'|'when_only'" 8
.IX Item "check_cn: 0|'always'|'when_only'"
Determines if the common name gets checked. If 'always' it will always be
checked (like in ldap), if 'when_only' it will only be checked if no names are
given in subjectAltNames (like in http), for any other values the common name
will not be checked.
.IP "wildcards_in_alt: 0|'full_label'|'anywhere'" 8
.IX Item "wildcards_in_alt: 0|'full_label'|'anywhere'"
Determines if and where wildcards in subjectAltNames are possible. If
\&'full_label' only cases like *.example.org will be possible (like in ldap), for
\&'anywhere' www*.example.org is possible too (like http), dangerous things like
but www.*.org or even '*' will not be allowed.
For compatibility with older versions 'leftmost' can be given instead of
\&'full_label'.
.IP "wildcards_in_cn: 0|'full_label'|'anywhere'" 8
.IX Item "wildcards_in_cn: 0|'full_label'|'anywhere'"
Similar to wildcards_in_alt, but checks the common name. There is no predefined
scheme which allows wildcards in common names.
.IP "ip_in_cn: 0|1|4|6" 8
.IX Item "ip_in_cn: 0|1|4|6"
Determines if an \s-1IP\s0 address is allowed in the common name (no wildcards are
allowed). If set to 4 or 6 it only allows IPv4 or IPv6 addresses, any other
true value allows both.
.IP "callback: \e&coderef" 8
.IX Item "callback: &coderef"
If you give a subroutine for verification it will be called with the arguments
($hostname,$commonName,@subjectAltNames), where hostname is the name given for
verification, commonName is the result from peer_certificate('cn') and
subjectAltNames is the result from peer_certificate('subjectAltNames').
.Sp
All other arguments for the verification scheme will be ignored in this case.
.RE
.RS 4
.RE
.IP "\fB\fBnext_proto_negotiated()\fB\fR" 4
.IX Item "next_proto_negotiated()"
This method returns the name of negotiated protocol \- e.g. 'http/1.1'. It works
for both client and server side of \s-1SSL\s0 connection.
.Sp
\&\s-1NPN\s0 support is available with Net::SSLeay 1.46+ and openssl\-1.0.1+.
To check support you might call \f(CW\*(C`IO::Socket::SSL\->can_npn()\*(C'\fR.
.IP "\fB\fBalpn_selected()\fB\fR" 4
.IX Item "alpn_selected()"
Returns the protocol negotiated via \s-1ALPN\s0 as a string, e.g. 'http/1.1',
\&'http/2.0' or 'spdy/3.1'.
.Sp
\&\s-1ALPN\s0 support is available with Net::SSLeay 1.56+ and openssl\-1.0.2+.
To check support, use \f(CW\*(C`IO::Socket::SSL\->can_alpn()\*(C'\fR.
.IP "\fB\fBerrstr()\fB\fR" 4
.IX Item "errstr()"
Returns the last error (in string form) that occurred.	If you do not have a
real object to perform this method on, call \fBIO::Socket::SSL::errstr()\fR instead.
.Sp
For read and write errors on non-blocking sockets, this method may include the
string \f(CW\*(C`SSL wants a read first!\*(C'\fR or \f(CW\*(C`SSL wants a write first!\*(C'\fR meaning that
the other side is expecting to read from or write to the socket and wants to be
satisfied before you get to do anything. But with version 0.98 you are better
comparing the global exported variable \f(CW$SSL_ERROR\fR against the exported symbols
\&\s-1SSL_WANT_READ\s0 and \s-1SSL_WANT_WRITE.\s0
.IP "\fB\fBopened()\fB\fR" 4
.IX Item "opened()"
This returns false if the socket could not be opened, 1 if the socket could be
opened and the \s-1SSL\s0 handshake was successful done and \-1 if the underlying
IO::Handle is open, but the \s-1SSL\s0 handshake failed.
.IP "\fBIO::Socket::SSL\->start_SSL($socket, ... )\fR" 4
.IX Item "IO::Socket::SSL->start_SSL($socket, ... )"
This will convert a glob reference or a socket that you provide to an
IO::Socket::SSL object.	 You may also pass parameters to specify context or
connection options as with a call to \fBnew()\fR.  If you are using this function on
an \fBaccept()\fRed socket, you must set the parameter \*(L"SSL_server\*(R" to 1, i.e.
IO::Socket::SSL\->start_SSL($socket, SSL_server => 1).  If you have a class that
inherits from IO::Socket::SSL and you want the \f(CW$socket\fR to be blessed into your
own class instead, use MyClass\->start_SSL($socket) to achieve the desired
effect.
.Sp
Note that if \fBstart_SSL()\fR fails in \s-1SSL\s0 negotiation, \f(CW$socket\fR will remain blessed
in its original class.	 For non-blocking sockets you better just upgrade the
socket to IO::Socket::SSL and call accept_SSL or connect_SSL and the upgraded
object. To just upgrade the socket set \fBSSL_startHandshake\fR explicitly to 0. If
you call start_SSL w/o this parameter it will revert to blocking behavior for
accept_SSL and connect_SSL.
.Sp
If given the parameter \*(L"Timeout\*(R" it will stop if after the timeout no \s-1SSL\s0
connection was established. This parameter is only used for blocking sockets, if
it is not given the default Timeout from the underlying IO::Socket will be
used.
.IP "\fBstop_SSL(...)\fR" 4
.IX Item "stop_SSL(...)"
This is the opposite of \fBstart_SSL()\fR, \fBconnect_SSL()\fR and \fBaccept_SSL()\fR, e.g. it
will shutdown the \s-1SSL\s0 connection and return to the class before \fBstart_SSL()\fR. It
gets the same arguments as \fBclose()\fR, in fact \fBclose()\fR calls \fBstop_SSL()\fR (but
without downgrading the class).
.Sp
Will return true if it succeeded and undef if failed. This might be the case for
non-blocking sockets. In this case $! is set to \s-1EWOULDBLOCK\s0 and the ssl error to
\&\s-1SSL_WANT_READ\s0 or \s-1SSL_WANT_WRITE.\s0 In this case the call should be retried again
with the same arguments once the socket is ready.
.Sp
For calling from \f(CW\*(C`stop_SSL\*(C'\fR \f(CW\*(C`SSL_fast_shutdown\*(C'\fR default to false, e.g. it
waits for the close_notify of the peer. This is necessary in case you want to
downgrade the socket and continue to use it as a plain socket.
.Sp
After stop_SSL the socket can again be used to exchange plain data.
.IP "\fBconnect_SSL\fR, \fBaccept_SSL\fR" 4
.IX Item "connect_SSL, accept_SSL"
These functions should be used to do the relevant handshake, if the socket got
created with \f(CW\*(C`new\*(C'\fR or upgraded with \f(CW\*(C`start_SSL\*(C'\fR and \f(CW\*(C`SSL_startHandshake\*(C'\fR was
set to false.
They will return undef until the handshake succeeded or an error got thrown.
As long as the function returns undef and $! is set to \s-1EWOULDBLOCK\s0 one could
retry the call after the socket got readable (\s-1SSL_WANT_READ\s0) or writeable
(\s-1SSL_WANT_WRITE\s0).
.IP "\fBocsp_resolver\fR" 4
.IX Item "ocsp_resolver"
This will create an \s-1OCSP\s0 resolver object, which can be used to create \s-1OCSP\s0
requests for the certificates of the \s-1SSL\s0 connection. Which certificates are
verified depends on the setting of \f(CW\*(C`SSL_ocsp_mode\*(C'\fR: by default only the leaf
certificate will be checked, but with \s-1SSL_OCSP_FULL_CHAIN\s0 all chain
certificates will be checked.
.Sp
Because to create an \s-1OCSP\s0 request the certificate and its issuer certificate
need to be known it is not possible to check certificates when the trust chain
is incomplete or if the certificate is self-signed.
.Sp
The \s-1OCSP\s0 resolver gets created by calling \f(CW\*(C`$ssl\->ocsp_resolver\*(C'\fR and
provides the following methods:
.RS 4
.IP "hard_error" 8
.IX Item "hard_error"
This returns the hard error when checking the \s-1OCSP\s0 response.
Hard errors are certificate revocations. With the \f(CW\*(C`SSL_ocsp_mode\*(C'\fR of
\&\s-1SSL_OCSP_FAIL_HARD\s0 any soft error (e.g. failures to get signed information
about the certificates) will be considered a hard error too.
.Sp
The \s-1OCSP\s0 resolving will stop on the first hard error.
.Sp
The method will return undef as long as no hard errors occurred and still
requests to be resolved. If all requests got resolved and no hard errors
occurred the method will return \f(CW\*(Aq\*(Aq\fR.
.IP "soft_error" 8
.IX Item "soft_error"
This returns the soft error(s) which occurred when asking the \s-1OCSP\s0 responders.
.IP "requests" 8
.IX Item "requests"
This will return a hash consisting of \f(CW\*(C`(url,request)\*(C'\fR\-tuples, e.g. which
contain the \s-1OCSP\s0 request string and the \s-1URL\s0 where it should be sent too. The
usual way to send such a request is as \s-1HTTP POST\s0 request with a content-type
of \f(CW\*(C`application/ocsp\-request\*(C'\fR or as a \s-1GET\s0 request with the base64 and
url-encoded request is added to the path of the \s-1URL.\s0
.Sp
After you've handled all these requests and added the response with
\&\f(CW\*(C`add_response\*(C'\fR you should better call this method again to make sure, that no
more requests are outstanding. IO::Socket::SSL will combine multiple \s-1OCSP\s0
requests for the same server inside a single request, but some server don't
give a response to all these requests, so that one has to ask again with the
remaining requests.
.IP "add_response($uri,$response)" 8
.IX Item "add_response($uri,$response)"
This method takes the \s-1HTTP\s0 body of the response which got received when sending
the \s-1OCSP\s0 request to \f(CW$uri\fR. If no response was received or an error occurred
one should either retry or consider \f(CW$response\fR as empty which will trigger a
soft error.
.Sp
The method returns the current value of \f(CW\*(C`hard_error\*(C'\fR, e.g. a defined value
when no more requests need to be done.
.IP "resolve_blocking(%args)" 8
.IX Item "resolve_blocking(%args)"
This combines \f(CW\*(C`requests\*(C'\fR and \f(CW\*(C`add_response\*(C'\fR which HTTP::Tiny to do all
necessary requests in a blocking way. \f(CW%args\fR will be given to HTTP::Tiny
so that you can put proxy settings etc here. HTTP::Tiny will be called with
\&\f(CW\*(C`verify_SSL\*(C'\fR of false, because the \s-1OCSP\s0 responses have their own signatures so
no extra \s-1SSL\s0 verification is needed.
.Sp
If you don't want to use blocking requests you need to roll your own user agent
with \f(CW\*(C`requests\*(C'\fR and \f(CW\*(C`add_response\*(C'\fR.
.RE
.RS 4
.RE
.IP "\fBIO::Socket::SSL\->new_from_fd($fd, [mode], \f(CB%sslargs\fB)\fR" 4
.IX Item "IO::Socket::SSL->new_from_fd($fd, [mode], %sslargs)"
This will convert a socket identified via a file descriptor into an \s-1SSL\s0 socket.
Note that the argument list does not include a \*(L"\s-1MODE\*(R"\s0 argument; if you supply
one, it will be thoughtfully ignored (for compatibility with IO::Socket::INET).
Instead, a mode of '+<' is assumed, and the file descriptor passed must be able
to handle such I/O because the initial \s-1SSL\s0 handshake requires bidirectional
communication.
.Sp
Internally the given \f(CW$fd\fR will be upgraded to a socket object using the
\&\f(CW\*(C`new_from_fd\*(C'\fR method of the super class (IO::Socket::INET or similar) and
then \f(CW\*(C`start_SSL\*(C'\fR will be called using the given \f(CW%sslargs\fR.
If \f(CW$fd\fR is already an IO::Socket object you should better call \f(CW\*(C`start_SSL\*(C'\fR
directly.
.IP "\fBIO::Socket::SSL::default_ca([ path|dir| SSL_ca_file =\fR ..., SSL_ca_path => ... ])>" 4
.IX Item "IO::Socket::SSL::default_ca([ path|dir| SSL_ca_file = ..., SSL_ca_path => ... ])>"
Determines or sets the default \s-1CA\s0 path.
If existing path or dir or a hash is given it will set the default \s-1CA\s0 path to
this value and never try to detect it automatically.
If \f(CW\*(C`undef\*(C'\fR is given it will forget any stored defaults and continue with
detection of system defaults.
If no arguments are given it will start detection of system defaults, unless it
has already stored user-set or previously detected values.
.Sp
The detection of system defaults works similar to OpenSSL, e.g. it will check
the directory specified in environment variable \s-1SSL_CERT_DIR\s0 or the path
OPENSSLDIR/certs (\s-1SSLCERTS:\s0 on \s-1VMS\s0) and the file specified in environment
variable \s-1SSL_CERT_FILE\s0 or the path OPENSSLDIR/cert.pem (SSLCERTS:cert.pem on
\&\s-1VMS\s0). Contrary to OpenSSL it will check if the SSL_ca_path contains \s-1PEM\s0 files
with the hash as file name and if the SSL_ca_file looks like \s-1PEM.\s0
If no usable system default can be found it will try to load and use
Mozilla::CA and if not available give up detection.
The result of the detection will be saved to speed up future calls.
.Sp
The function returns the saved default \s-1CA\s0 as hash with SSL_ca_file and
SSL_ca_path.
.IP "\fBIO::Socket::SSL::set_default_context(...)\fR" 4
.IX Item "IO::Socket::SSL::set_default_context(...)"
You may use this to make IO::Socket::SSL automatically re-use a given context
(unless specifically overridden in a call to \fBnew()\fR).
It accepts one argument, which should be either an IO::Socket::SSL object or an
IO::Socket::SSL::SSL_Context object.
See the SSL_reuse_ctx option of \fBnew()\fR for more details.
Note that this sets the default context globally, so use with caution (esp. in
mod_perl scripts).
.IP "\fBIO::Socket::SSL::set_default_session_cache(...)\fR" 4
.IX Item "IO::Socket::SSL::set_default_session_cache(...)"
You may use this to make IO::Socket::SSL automatically re-use a given session
cache (unless specifically overridden in a call to \fBnew()\fR).
It accepts one argument, which should be an IO::Socket::SSL::Session_Cache
object or similar (e.g. something which implements get_session, add_session and
del_session like IO::Socket::SSL::Session_Cache does).
See the SSL_session_cache option of \fBnew()\fR for more details.
Note that this sets the default cache globally, so use with caution.
.IP "\fBIO::Socket::SSL::set_defaults(%args)\fR" 4
.IX Item "IO::Socket::SSL::set_defaults(%args)"
With this function one can set defaults for all SSL_* parameter used for
creation of the context, like the SSL_verify* parameter. Any SSL_* parameter can
be given or the following short versions:
.RS 4
.IP "mode \- SSL_verify_mode" 8
.IX Item "mode - SSL_verify_mode"
.PD 0
.IP "callback \- SSL_verify_callback" 8
.IX Item "callback - SSL_verify_callback"
.IP "scheme \- SSL_verifycn_scheme" 8
.IX Item "scheme - SSL_verifycn_scheme"
.IP "name \- SSL_verifycn_name" 8
.IX Item "name - SSL_verifycn_name"
.RE
.RS 4
.RE
.IP "\fBIO::Socket::SSL::set_client_defaults(%args)\fR" 4
.IX Item "IO::Socket::SSL::set_client_defaults(%args)"
.PD
Similar to \f(CW\*(C`set_defaults\*(C'\fR, but only sets the defaults for client mode.
.IP "\fBIO::Socket::SSL::set_server_defaults(%args)\fR" 4
.IX Item "IO::Socket::SSL::set_server_defaults(%args)"
Similar to \f(CW\*(C`set_defaults\*(C'\fR, but only sets the defaults for server mode.
.IP "\fBIO::Socket::SSL::set_args_filter_hack(\e&code|'use_defaults')\fR" 4
.IX Item "IO::Socket::SSL::set_args_filter_hack(&code|'use_defaults')"
Sometimes one has to use code which uses unwanted or invalid arguments for \s-1SSL,\s0
typically disabling \s-1SSL\s0 verification or setting wrong ciphers or \s-1SSL\s0 versions.
With this hack it is possible to override these settings and restore sanity.
Example:
.Sp
.Vb 10
\&    IO::Socket::SSL::set_args_filter_hack( sub {
\&        my ($is_server,$args) = @_;
\&        if ( ! $is_server ) {
\&            # client settings \- enable verification with default CA
\&            # and fallback hostname verification etc
\&            delete @{$args}{qw(
\&                SSL_verify_mode
\&                SSL_ca_file
\&                SSL_ca_path
\&                SSL_verifycn_scheme
\&                SSL_version
\&            )};
\&            # and add some fingerprints for known certs which are signed by
\&            # unknown CAs or are self\-signed
\&            $args\->{SSL_fingerprint} = ...
\&        }
\&    });
.Ve
.Sp
With the short setting \f(CW\*(C`set_args_filter_hack(\*(Aquse_defaults\*(Aq)\*(C'\fR it will prefer
the default settings in all cases. These default settings can be modified with
\&\f(CW\*(C`set_defaults\*(C'\fR, \f(CW\*(C`set_client_defaults\*(C'\fR and \f(CW\*(C`set_server_defaults\*(C'\fR.
.PP
The following methods are unsupported (not to mention futile!) and
IO::Socket::SSL will emit a large \s-1\fBCROAK\s0()\fR if you are silly enough to use them:
.IP "truncate" 4
.IX Item "truncate"
.PD 0
.IP "stat" 4
.IX Item "stat"
.IP "ungetc" 4
.IX Item "ungetc"
.IP "setbuf" 4
.IX Item "setbuf"
.IP "setvbuf" 4
.IX Item "setvbuf"
.IP "fdopen" 4
.IX Item "fdopen"
.IP "send/recv" 4
.IX Item "send/recv"
.PD
Note that \fBsend()\fR and \fBrecv()\fR cannot be reliably trapped by a tied filehandle
(such as that used by IO::Socket::SSL) and so may send unencrypted data over the
socket.	 Object-oriented calls to these functions will fail, telling you to use
the print/printf/syswrite and read/sysread families instead.
.SH "DEPRECATIONS"
.IX Header "DEPRECATIONS"
The following functions are deprecated and are only retained for compatibility:
.IP "\fBcontext_init()\fR" 2
.IX Item "context_init()"
use the SSL_reuse_ctx option if you want to re-use a context
.IP "\fBsocketToSSL()\fR and \fBsocket_to_SSL()\fR" 2
.IX Item "socketToSSL() and socket_to_SSL()"
use IO::Socket::SSL\->\fBstart_SSL()\fR instead
.IP "\fBkill_socket()\fR" 2
.IX Item "kill_socket()"
use \fBclose()\fR instead
.IP "\fBget_peer_certificate()\fR" 2
.IX Item "get_peer_certificate()"
use the \fBpeer_certificate()\fR function instead.
Used to return X509_Certificate with methods subject_name and issuer_name.
Now simply returns \f(CW$self\fR which has these methods (although deprecated).
.IP "\fBissuer_name()\fR" 2
.IX Item "issuer_name()"
use peer_certificate( 'issuer' ) instead
.IP "\fBsubject_name()\fR" 2
.IX Item "subject_name()"
use peer_certificate( 'subject' ) instead
.SH "EXAMPLES"
.IX Header "EXAMPLES"
See the 'example' directory, the tests in 't' and also the tools in 'util'.
.SH "BUGS"
.IX Header "BUGS"
If you use IO::Socket::SSL together with threads you should load it (e.g. use or
require) inside the main thread before creating any other threads which use it.
This way it is much faster because it will be initialized only once. Also there
are reports that it might crash the other way.
.PP
Creating an IO::Socket::SSL object in one thread and closing it in another
thread will not work.
.PP
IO::Socket::SSL does not work together with Storable::fd_retrieve/fd_store.
See \s-1BUGS\s0 file for more information and how to work around the problem.
.PP
Non-blocking and timeouts (which are based on non-blocking) are not
supported on Win32, because the underlying IO::Socket::INET does not support
non-blocking on this platform.
.PP
If you have a server and it looks like you have a memory leak you might
check the size of your session cache. Default for Net::SSLeay seems to be
20480, see the example for SSL_create_ctx_callback for how to limit it.
.PP
\&\s-1TLS 1.3\s0 support regarding session reuse is incomplete.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
IO::Socket::INET, IO::Socket::INET6, IO::Socket::IP, Net::SSLeay.
.SH "THANKS"
.IX Header "THANKS"
Many thanks to all who added patches or reported bugs or helped IO::Socket::SSL
another way. Please keep reporting bugs and help with patches, even if they just
fix the documentation.
.PP
Special thanks to the team of Net::SSLeay for the good cooperation.
.SH "AUTHORS"
.IX Header "AUTHORS"
Steffen Ullrich, <sullr at cpan.org> is the current maintainer.
.PP
Peter Behroozi, <behrooz at fas.harvard.edu> (Note the lack of an \*(L"i\*(R" at the end of \*(L"behrooz\*(R")
.PP
Marko Asplund, <marko.asplund at kronodoc.fi>, was the original author of IO::Socket::SSL.
.PP
Patches incorporated from various people, see file Changes.
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
The original versions of this module are Copyright (C) 1999\-2002 Marko Asplund.
.PP
The rewrite of this module is Copyright (C) 2002\-2005 Peter Behroozi.
.PP
Versions 0.98 and newer are Copyright (C) 2006\-2014 Steffen Ullrich.
.PP
This module is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.
