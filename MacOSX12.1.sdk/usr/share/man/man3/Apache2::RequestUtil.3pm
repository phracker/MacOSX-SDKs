.\" Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "install::TempContent::Objects::mod_perl-2.0.9::docs::api::Apache2::RequestUtil 3"
.TH install::TempContent::Objects::mod_perl-2.0.9::docs::api::Apache2::RequestUtil 3 "2015-06-18" "perl v5.30.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Apache2::RequestUtil \- Perl API for Apache request record utils
.SH "Synopsis"
.IX Header "Synopsis"
.Vb 1
\&  use Apache2::RequestUtil ();
\&  
\&  # add httpd config dynamically
\&  $r\->add_config([\*(Aqrequire valid\-user\*(Aq]);
\&  
\&  # dump the request object as a string
\&  print $r\->as_string();
\&  
\&  # default content_type
\&  $content_type = $r\->default_type();
\&  
\&  # get PerlSetVar/PerlAddVar values
\&  @values = $r\->dir_config\->get($key);
\&  
\&  # get server docroot
\&  $docroot = $r\->document_root();
\&  
\&  # set server docroot
\&  $r\->document_root($new_root);
\&  
\&  # what are the registered perl handlers for a given phase
\&  my @handlers = @{ $r\->get_handlers(\*(AqPerlResponseHandler\*(Aq) || [] };
\&  
\&  # push a new handler for a given phase
\&  $r\->push_handlers(PerlCleanupHandler => \e&handler);
\&  
\&  # set handlers for a given phase (resetting previous values)
\&  $r\->set_handlers(PerlCleanupHandler => []);
\&  
\&  # what\*(Aqs the request body limit
\&  $limit = $r\->get_limit_req_body();
\&  
\&  # server and port names
\&  $server = $r\->get_server_name();
\&  $port   = $r\->get_server_port();
\&  
\&  # what string Apache is going to send for a given status code
\&  $status_line = Apache2::RequestUtil::get_status_line(404);
\&  
\&  # are we in the main request?
\&  $is_initial = $r\->is_initial_req();
\&  
\&  # directory level PerlOptions flags lookup
\&  $r\->subprocess_env unless $r\->is_perl_option_enabled(\*(AqSetupEnv\*(Aq);
\&  
\&  # current <Location> value
\&  $location = $r\->location();
\&  
\&  # merge a <Location> container in a request object
\&  $r\->location_merge($location);
\&  
\&  # create a new Apache2::RequestRec object
\&  $r = Apache2::RequestRec\->new($c);
\&  
\&  # tell the client not to cache the response
\&  $r\->no_cache($boolean);
\&  
\&  # share perl objects by reference like $r\->notes
\&  $r\->pnotes($key => [$obj1, $obj2]);
\&  
\&  # get HTML signature
\&  $sig = $r\->psignature($prefix);
\&  
\&  # get the global request object (requires PerlOptions +GlobalRequest)
\&  $r = Apache2::RequestUtil\->request;
\&  
\&  # insert auth credentials into the request as if the client did that
\&  $r\->set_basic_credentials($username, $password);
\&  
\&  # slurp the contents of $r\->filename
\&  my $content = ${ $r\->slurp_filename() };
\&  
\&  # terminate the current child after this request
\&  $r\->child_terminate();
.Ve
.SH "Description"
.IX Header "Description"
\&\f(CW\*(C`Apache2::RequestUtil\*(C'\fR provides the Apache request
object utilities \s-1API.\s0
.SH "API"
.IX Header "API"
.ie n .SS """add_config"""
.el .SS "\f(CWadd_config\fP"
.IX Subsection "add_config"
Dynamically add Apache configuration at request processing runtime:
.PP
.Vb 4
\&  $r\->add_config($lines);
\&  $r\->add_config($lines, $override);
\&  $r\->add_config($lines, $override, $path);
\&  $r\->add_config($lines, $override, $path, $override_opts);
.Ve
.PP
Configuration directives are processed as if given in a \f(CW\*(C`<Location>\*(C'\fR
block.
.ie n .IP "obj: $r ( ""Apache2::RequestRec object"" )" 4
.el .IP "obj: \f(CW$r\fR ( \f(CWApache2::RequestRec object\fR )" 4
.IX Item "obj: $r ( Apache2::RequestRec object )"
.PD 0
.ie n .IP "arg1: $lines (\s-1ARRAY\s0 ref)" 4
.el .IP "arg1: \f(CW$lines\fR (\s-1ARRAY\s0 ref)" 4
.IX Item "arg1: $lines (ARRAY ref)"
.PD
An \s-1ARRAY\s0 reference containing configuration lines per element, without
the new line terminators.
.ie n .IP "opt arg2: $override ( ""Apache2::Const override constant"" )" 4
.el .IP "opt arg2: \f(CW$override\fR ( \f(CWApache2::Const override constant\fR )" 4
.IX Item "opt arg2: $override ( Apache2::Const override constant )"
Which allow-override bits are set
.Sp
Default value is:
\&\f(CW\*(C`Apache2::Const::OR_AUTHCFG\*(C'\fR
.ie n .IP "opt arg3: $path ( string )" 4
.el .IP "opt arg3: \f(CW$path\fR ( string )" 4
.IX Item "opt arg3: $path ( string )"
Set the \f(CW\*(C`Apache2::CmdParms object\*(C'\fR \f(CW\*(C`path\*(C'\fR component.
This is the path of the \f(CW\*(C`<Location>\*(C'\fR block. Some directives need this,
for example \f(CW\*(C`ProxyPassReverse\*(C'\fR.
.Sp
If an empty string is passed a \f(CW\*(C`NULL\*(C'\fR pointer is passed further at C\-level.
This is necessary to make something like this work:
.Sp
.Vb 5
\&  $r\->add_config( [
\&                   \*(Aq<Directory />\*(Aq,
\&                   \*(AqAllowOverride Options AuthConfig\*(Aq,
\&                   \*(Aq</Directory>\*(Aq,
\&                  ], ~0, \*(Aq\*(Aq );
.Ve
.Sp
Note: \f(CW\*(C`AllowOverride\*(C'\fR is valid only in directory context.
.Sp
\&\fBCaution:\fR Some directives need a non-empty path otherwise they cause
segfaults. Thus, use the empty path with caution.
.Sp
Default value is: \f(CW\*(C`/\*(C'\fR
.ie n .IP "opt arg4: $override_opts ( ""Apache2::Const options constant"" )" 4
.el .IP "opt arg4: \f(CW$override_opts\fR ( \f(CWApache2::Const options constant\fR )" 4
.IX Item "opt arg4: $override_opts ( Apache2::Const options constant )"
Apache limits the applicable directives in certain situations with
\&\f(CW\*(C`AllowOverride\*(C'\fR. With Apache 2.2 comes the possibility to enable or
disable single options, for example
.Sp
.Vb 1
\&  AllowOverride AuthConfig Options=ExecCGI,Indexes
.Ve
.Sp
Internally, this directive is parsed into 2 bit fields that are represented
by the \f(CW$override\fR and \f(CW$override_opts\fR parameters to \f(CW\*(C`add_config\*(C'\fR.
The above example is parsed into an \f(CW$override\fR with 2 bits set, one for
\&\f(CW\*(C`AuthConfig\*(C'\fR the other for \f(CW\*(C`Options\*(C'\fR and an \f(CW$override_opts\fR with
2 bits set for ExecCGI and Indexes.
.Sp
When applying other directives, for example \f(CW\*(C`AuthType\*(C'\fR or \f(CW\*(C`Options\*(C'\fR the
appropriate bits in \f(CW$override\fR must be set. For the \f(CW\*(C`Options\*(C'\fR directive
additionally \f(CW$override_opts\fR bits must be set.
.Sp
The \f(CW$override\fR and \f(CW$override_opts\fR parameters to \f(CW\*(C`add_config\*(C'\fR are
valid while applying \f(CW$lines\fR.
.Sp
\&\f(CW$override_opts\fR is new in Apache 2.2. The mod_perl implementation for
Apache 2.0 lets you pass the parameter but ignores it.
.Sp
Default for \f(CW$override_opts\fR is:
\&\f(CW\*(C`Apache2::Const::OPT_UNSET\*(C'\fR |
\&\f(CW\*(C`Apache2::Const::OPT_ALL\*(C'\fR |
\&\f(CW\*(C`Apache2::Const::OPT_INCNOEXEC\*(C'\fR |
\&\f(CW\*(C`Apache2::Const::OPT_SYM_OWNER\*(C'\fR |
\&\f(CW\*(C`Apache2::Const::OPT_MULTI\*(C'\fR
.Sp
That means, all options are allowed.
.IP "ret: no return value" 4
.IX Item "ret: no return value"
.PD 0
.ie n .IP "since: 2.0.00, $path and $override_opts since 2.0.3" 4
.el .IP "since: 2.0.00, \f(CW$path\fR and \f(CW$override_opts\fR since 2.0.3" 4
.IX Item "since: 2.0.00, $path and $override_opts since 2.0.3"
.PD
.PP
See also:
\&\f(CW\*(C`$s\->add_config\*(C'\fR
.PP
For example:
.PP
.Vb 2
\&  use Apache2::RequestUtil ();
\&  use Apache2::Access ();
\&
\&  $r\->add_config([\*(Aqrequire valid\-user\*(Aq]);
\&
\&  # this regards the current AllowOverride setting
\&  $r\->add_config([\*(AqAuthName secret\*(Aq,
\&                  \*(AqAuthType Basic\*(Aq,
\&                  \*(AqOptions ExecCGI\*(Aq],
\&                 $r\->allow_override, $path, $r\->allow_override_opts);
.Ve
.ie n .SS """as_string"""
.el .SS "\f(CWas_string\fP"
.IX Subsection "as_string"
Dump the request object as a string
.PP
.Vb 1
\&  $dump = $r\->as_string();
.Ve
.ie n .IP "obj: $r ( ""Apache2::RequestRec object"" )" 4
.el .IP "obj: \f(CW$r\fR ( \f(CWApache2::RequestRec object\fR )" 4
.IX Item "obj: $r ( Apache2::RequestRec object )"
.PD 0
.ie n .IP "ret: $dump ( string )" 4
.el .IP "ret: \f(CW$dump\fR ( string )" 4
.IX Item "ret: $dump ( string )"
.IP "since: 2.0.00" 4
.IX Item "since: 2.0.00"
.PD
.PP
Dumps various request and response headers (mainly useful for
debugging)
.ie n .SS """child_terminate"""
.el .SS "\f(CWchild_terminate\fP"
.IX Subsection "child_terminate"
Terminate the current worker process as soon as the current request is
over
.PP
.Vb 1
\&  $r\->child_terminate();
.Ve
.ie n .IP "obj: $r ( ""Apache2::RequestRec object"" )" 4
.el .IP "obj: \f(CW$r\fR ( \f(CWApache2::RequestRec object\fR )" 4
.IX Item "obj: $r ( Apache2::RequestRec object )"
.PD 0
.IP "ret: no return value" 4
.IX Item "ret: no return value"
.IP "since: 2.0.00" 4
.IX Item "since: 2.0.00"
.PD
.PP
This method is not supported in threaded MPMs
.ie n .SS """default_type"""
.el .SS "\f(CWdefault_type\fP"
.IX Subsection "default_type"
Retrieve the value of the DefaultType directive for the current
request. If not set \f(CW\*(C`text/plain\*(C'\fR is returned.
.PP
.Vb 1
\&  $content_type = $r\->default_type();
.Ve
.ie n .IP "obj: $r ( ""Apache2::RequestRec object"" )" 4
.el .IP "obj: \f(CW$r\fR ( \f(CWApache2::RequestRec object\fR )" 4
.IX Item "obj: $r ( Apache2::RequestRec object )"
The current request
.ie n .IP "ret: $content_type ( string )" 4
.el .IP "ret: \f(CW$content_type\fR ( string )" 4
.IX Item "ret: $content_type ( string )"
The default type
.IP "since: 2.0.00" 4
.IX Item "since: 2.0.00"
.PD 0
.ie n .IP "removed from the ""httpd"" \s-1API\s0 in version 2.3.2" 4
.el .IP "removed from the \f(CWhttpd\fR \s-1API\s0 in version 2.3.2" 4
.IX Item "removed from the httpd API in version 2.3.2"
.PD
.ie n .SS """dir_config"""
.el .SS "\f(CWdir_config\fP"
.IX Subsection "dir_config"
\&\f(CW\*(C`$r\->dir_config()\*(C'\fR provides an interface for the per-directory
variable specified by the \f(CW\*(C`PerlSetVar\*(C'\fR and \f(CW\*(C`PerlAddVar\*(C'\fR directives,
and also can be manipulated via the
\&\f(CW\*(C`APR::Table\*(C'\fR methods.
.PP
.Vb 4
\&  $table  = $r\->dir_config();
\&  $value  = $r\->dir_config($key);
\&  @values = $r\->dir_config\->get($key);
\&  $r\->dir_config($key, $val);
.Ve
.ie n .IP "obj: $r ( ""Apache2::RequestRec object"" )" 4
.el .IP "obj: \f(CW$r\fR ( \f(CWApache2::RequestRec object\fR )" 4
.IX Item "obj: $r ( Apache2::RequestRec object )"
.PD 0
.ie n .IP "opt arg2: $key ( string )" 4
.el .IP "opt arg2: \f(CW$key\fR ( string )" 4
.IX Item "opt arg2: $key ( string )"
.PD
Key string
.ie n .IP "opt arg3: $val ( string )" 4
.el .IP "opt arg3: \f(CW$val\fR ( string )" 4
.IX Item "opt arg3: $val ( string )"
Value string
.IP "ret: ..." 4
.IX Item "ret: ..."
Depends on the passed arguments, see further discussion
.IP "since: 2.0.00" 4
.IX Item "since: 2.0.00"
.PP
The keys are case-insensitive.
.PP
.Vb 1
\&  $apr_table = $r\->dir_config();
.Ve
.PP
\&\fBdir_config()\fR called in a scalar context without the \f(CW$key\fR argument
returns a \fI\s-1HASH\s0\fR reference blessed into the
\&\f(CW\*(C`APR::Table\*(C'\fR class. This object can be
manipulated via the \f(CW\*(C`APR::Table\*(C'\fR
methods. For available methods see
the \f(CW\*(C`APR::Table\*(C'\fR manpage.
.PP
.Vb 1
\&  $value = $r\->dir_config($key);
.Ve
.PP
If the \f(CW$key\fR argument is passed in the scalar context only a single
value will be returned. Since the table preserves the insertion order,
if there is more than one value for the same key, the oldest value
assosiated with the desired key is returned. Calling in the scalar
context is also much faster, as it'll stop searching the table as soon
as the first match happens.
.PP
.Vb 1
\&  @values = $r\->dir_config\->get($key);
.Ve
.PP
To receive a list of values you must use \f(CW\*(C`get()\*(C'\fR method from the
\&\f(CW\*(C`APR::Table\*(C'\fR class.
.PP
.Vb 1
\&  $r\->dir_config($key => $val);
.Ve
.PP
If the \f(CW$key\fR and the \f(CW$val\fR arguments are used, the \fBset()\fR operation
will happen: all existing values associated with the key \f(CW$key\fR (and
the key itself) will be deleted and \f(CW$value\fR will be placed instead.
.PP
.Vb 1
\&  $r\->dir_config($key => undef);
.Ve
.PP
If \f(CW$val\fR is \fIundef\fR the \fBunset()\fR operation will happen: all existing
values associated with the key \f(CW$key\fR (and the key itself) will be
deleted.
.ie n .SS """document_root"""
.el .SS "\f(CWdocument_root\fP"
.IX Subsection "document_root"
Retrieve the document root for this server
.PP
.Vb 2
\&  $docroot = $r\->document_root();
\&  $docroot = $r\->document_root($new_root);
.Ve
.ie n .IP "obj: $r ( ""Apache2::RequestRec object"" )" 4
.el .IP "obj: \f(CW$r\fR ( \f(CWApache2::RequestRec object\fR )" 4
.IX Item "obj: $r ( Apache2::RequestRec object )"
The current request
.ie n .IP "opt arg1: $new_root" 4
.el .IP "opt arg1: \f(CW$new_root\fR" 4
.IX Item "opt arg1: $new_root"
Sets the document root to a new value \fBonly for the duration of the
current request\fR.
.Sp
Note the limited functionality under threaded
MPMs.
.ie n .IP "ret: $docroot ( string )" 4
.el .IP "ret: \f(CW$docroot\fR ( string )" 4
.IX Item "ret: $docroot ( string )"
The document root
.IP "since: 2.0.00" 4
.IX Item "since: 2.0.00"
.ie n .SS """get_handlers"""
.el .SS "\f(CWget_handlers\fP"
.IX Subsection "get_handlers"
Returns a reference to a list of handlers enabled for a given phase.
.PP
.Vb 1
\&  $handlers_list = $r\->get_handlers($hook_name);
.Ve
.ie n .IP "obj: $r ( ""Apache2::RequestRec object"" )" 4
.el .IP "obj: \f(CW$r\fR ( \f(CWApache2::RequestRec object\fR )" 4
.IX Item "obj: $r ( Apache2::RequestRec object )"
.PD 0
.ie n .IP "arg1: $hook_name ( string )" 4
.el .IP "arg1: \f(CW$hook_name\fR ( string )" 4
.IX Item "arg1: $hook_name ( string )"
.PD
a string representing the phase to handle (e.g. \f(CW\*(C`PerlLogHandler\*(C'\fR)
.ie n .IP "ret: $handlers_list (ref to an \s-1ARRAY\s0 of \s-1CODE\s0 refs)" 4
.el .IP "ret: \f(CW$handlers_list\fR (ref to an \s-1ARRAY\s0 of \s-1CODE\s0 refs)" 4
.IX Item "ret: $handlers_list (ref to an ARRAY of CODE refs)"
a list of handler subroutines \s-1CODE\s0 references
.IP "since: 2.0.00" 4
.IX Item "since: 2.0.00"
.PP
See also:
\&\f(CW\*(C`$s\->add_config\*(C'\fR
.PP
For example:
.PP
A list of handlers configured to run at the response phase:
.PP
.Vb 1
\&  my @handlers = @{ $r\->get_handlers(\*(AqPerlResponseHandler\*(Aq) || [] };
.Ve
.ie n .SS """get_limit_req_body"""
.el .SS "\f(CWget_limit_req_body\fP"
.IX Subsection "get_limit_req_body"
Return the limit on bytes in request msg body
.PP
.Vb 1
\&  $limit = $r\->get_limit_req_body();
.Ve
.ie n .IP "obj: $r ( ""Apache2::RequestRec object"" )" 4
.el .IP "obj: \f(CW$r\fR ( \f(CWApache2::RequestRec object\fR )" 4
.IX Item "obj: $r ( Apache2::RequestRec object )"
The current request
.ie n .IP "ret: $limit (integer)" 4
.el .IP "ret: \f(CW$limit\fR (integer)" 4
.IX Item "ret: $limit (integer)"
the maximum number of bytes in the request msg body
.IP "since: 2.0.00" 4
.IX Item "since: 2.0.00"
.ie n .SS """get_server_name"""
.el .SS "\f(CWget_server_name\fP"
.IX Subsection "get_server_name"
Get the current request's server name
.PP
.Vb 1
\&  $server = $r\->get_server_name();
.Ve
.ie n .IP "obj: $r ( ""Apache2::RequestRec object"" )" 4
.el .IP "obj: \f(CW$r\fR ( \f(CWApache2::RequestRec object\fR )" 4
.IX Item "obj: $r ( Apache2::RequestRec object )"
The current request
.ie n .IP "ret: $server ( string )" 4
.el .IP "ret: \f(CW$server\fR ( string )" 4
.IX Item "ret: $server ( string )"
the server name
.IP "since: 2.0.00" 4
.IX Item "since: 2.0.00"
.PP
For example, consruct a hostport string:
.PP
.Vb 2
\&  use Apache2::RequestUtil ();
\&  my $hostport = join \*(Aq:\*(Aq, $r\->get_server_name, $r\->get_server_port;
.Ve
.ie n .SS """get_server_port"""
.el .SS "\f(CWget_server_port\fP"
.IX Subsection "get_server_port"
Get the current server port
.PP
.Vb 1
\&  $port = $r\->get_server_port();
.Ve
.ie n .IP "obj: $r ( ""Apache2::RequestRec object"" )" 4
.el .IP "obj: \f(CW$r\fR ( \f(CWApache2::RequestRec object\fR )" 4
.IX Item "obj: $r ( Apache2::RequestRec object )"
The current request
.ie n .IP "ret: $port ( integer )" 4
.el .IP "ret: \f(CW$port\fR ( integer )" 4
.IX Item "ret: $port ( integer )"
The server's port number
.IP "since: 2.0.00" 4
.IX Item "since: 2.0.00"
.PP
For example, consruct a hostport string:
.PP
.Vb 2
\&  use Apache2::RequestUtil ();
\&  my $hostport = join \*(Aq:\*(Aq, $r\->get_server_name, $r\->get_server_port;
.Ve
.ie n .SS """get_status_line"""
.el .SS "\f(CWget_status_line\fP"
.IX Subsection "get_status_line"
Return the \f(CW\*(C`Status\-Line\*(C'\fR for a given status code (excluding the
HTTP-Version field).
.PP
.Vb 1
\&  $status_line = Apache2::RequestUtil::get_status_line($status);
.Ve
.ie n .IP "arg1: $status (integer)" 4
.el .IP "arg1: \f(CW$status\fR (integer)" 4
.IX Item "arg1: $status (integer)"
The \s-1HTTP\s0 status code
.ie n .IP "ret: $status_line ( string )" 4
.el .IP "ret: \f(CW$status_line\fR ( string )" 4
.IX Item "ret: $status_line ( string )"
The Status-Line
.Sp
If an invalid or unknown status code is passed, \f(CW"500 Internal Server
Error"\fR will be returned.
.IP "since: 2.0.00" 4
.IX Item "since: 2.0.00"
.PP
For example:
.PP
.Vb 2
\&  use Apache2::RequestUtil ();
\&  print Apache2::RequestUtil::get_status_line(400);
.Ve
.PP
will print:
.PP
.Vb 1
\&  400 Bad Request
.Ve
.ie n .SS """is_initial_req"""
.el .SS "\f(CWis_initial_req\fP"
.IX Subsection "is_initial_req"
Determine whether the current request is the main request or a
sub-request
.PP
.Vb 1
\&  $is_initial = $r\->is_initial_req();
.Ve
.ie n .IP "obj: $r ( ""Apache2::RequestRec object"" )" 4
.el .IP "obj: \f(CW$r\fR ( \f(CWApache2::RequestRec object\fR )" 4
.IX Item "obj: $r ( Apache2::RequestRec object )"
A request or a sub-request object
.ie n .IP "ret: $is_initial ( boolean )" 4
.el .IP "ret: \f(CW$is_initial\fR ( boolean )" 4
.IX Item "ret: $is_initial ( boolean )"
If true \*(-- it's the main request, otherwise it's a sub-request
.IP "since: 2.0.00" 4
.IX Item "since: 2.0.00"
.ie n .SS """is_perl_option_enabled"""
.el .SS "\f(CWis_perl_option_enabled\fP"
.IX Subsection "is_perl_option_enabled"
check whether a directory level \f(CW\*(C`PerlOptions\*(C'\fR flag is enabled or not.
.PP
.Vb 1
\&  $result = $r\->is_perl_option_enabled($flag);
.Ve
.ie n .IP "obj: $r ( ""Apache2::RequestRec object"" )" 4
.el .IP "obj: \f(CW$r\fR ( \f(CWApache2::RequestRec object\fR )" 4
.IX Item "obj: $r ( Apache2::RequestRec object )"
.PD 0
.ie n .IP "arg1: $flag ( string )" 4
.el .IP "arg1: \f(CW$flag\fR ( string )" 4
.IX Item "arg1: $flag ( string )"
.ie n .IP "ret: $result ( boolean )" 4
.el .IP "ret: \f(CW$result\fR ( boolean )" 4
.IX Item "ret: $result ( boolean )"
.IP "since: 2.0.00" 4
.IX Item "since: 2.0.00"
.PD
.PP
For example to check whether the \f(CW\*(C`SetupEnv\*(C'\fR option is enabled for the
current request (which can be disabled with \f(CW\*(C`PerlOptions \-SetupEnv\*(C'\fR)
and populate the environment variables table if disabled:
.PP
.Vb 1
\&  $r\->subprocess_env unless $r\->is_perl_option_enabled(\*(AqSetupEnv\*(Aq);
.Ve
.PP
See also:
PerlOptions and
the equivalent function for server level PerlOptions
flags.
.ie n .SS """location"""
.el .SS "\f(CWlocation\fP"
.IX Subsection "location"
Get the path of the <Location> section from which the current
\&\f(CW\*(C`Perl*Handler\*(C'\fR is being called.
.PP
.Vb 1
\&  $location = $r\->location();
.Ve
.ie n .IP "obj: $r ( ""Apache2::RequestRec object"" )" 4
.el .IP "obj: \f(CW$r\fR ( \f(CWApache2::RequestRec object\fR )" 4
.IX Item "obj: $r ( Apache2::RequestRec object )"
.PD 0
.ie n .IP "ret: $location ( string )" 4
.el .IP "ret: \f(CW$location\fR ( string )" 4
.IX Item "ret: $location ( string )"
.IP "since: 2.0.00" 4
.IX Item "since: 2.0.00"
.PD
.ie n .SS """location_merge"""
.el .SS "\f(CWlocation_merge\fP"
.IX Subsection "location_merge"
Merge a given \f(CW\*(C`<Location>\*(C'\fR container into the current request
object:
.PP
.Vb 1
\&  $ret = $r\->location_merge($location);
.Ve
.ie n .IP "obj: $r ( ""Apache2::RequestRec object"" )" 4
.el .IP "obj: \f(CW$r\fR ( \f(CWApache2::RequestRec object\fR )" 4
.IX Item "obj: $r ( Apache2::RequestRec object )"
.PD 0
.ie n .IP "arg1: $location ( string )" 4
.el .IP "arg1: \f(CW$location\fR ( string )" 4
.IX Item "arg1: $location ( string )"
.PD
The argument in a \f(CW\*(C`<Location>\*(C'\fR section. For example to merge
a container:
.Sp
.Vb 3
\&  <Location /foo>
\&      ...
\&  </Location>
.Ve
.Sp
that argument will be \fI/foo\fR
.ie n .IP "ret: $ret ( boolean )" 4
.el .IP "ret: \f(CW$ret\fR ( boolean )" 4
.IX Item "ret: $ret ( boolean )"
a true value if the merge was successful (i.e. the request
\&\f(CW$location\fR match was found), otherwise false.
.IP "since: 2.0.00" 4
.IX Item "since: 2.0.00"
.PP
Useful for insertion of a configuration section into a custom
\&\f(CW\*(C`Apache2::RequestRec\*(C'\fR object, created via the
\&\f(CW\*(C`Apache2::RequestRec\->new()\*(C'\fR method. See for example the Command
Server protocol
example.
.ie n .SS """new"""
.el .SS "\f(CWnew\fP"
.IX Subsection "new"
Create a new \f(CW\*(C`Apache2::RequestRec\*(C'\fR object.
.PP
.Vb 2
\&  $r = Apache2::RequestRec\->new($c);
\&  $r = Apache2::RequestRec\->new($c, $pool);
.Ve
.ie n .IP "obj: ""Apache2::RequestRec"" ( ""Apache2::RequestRec class name"" )" 4
.el .IP "obj: \f(CWApache2::RequestRec\fR ( \f(CWApache2::RequestRec class name\fR )" 4
.IX Item "obj: Apache2::RequestRec ( Apache2::RequestRec class name )"
.PD 0
.ie n .IP "arg1: $c (""Apache2::Connection object"")" 4
.el .IP "arg1: \f(CW$c\fR (\f(CWApache2::Connection object\fR)" 4
.IX Item "arg1: $c (Apache2::Connection object)"
.ie n .IP "opt arg2: $pool" 4
.el .IP "opt arg2: \f(CW$pool\fR" 4
.IX Item "opt arg2: $pool"
.PD
If no \f(CW$pool\fR argument is passed, \f(CW\*(C`$c\->pool\*(C'\fR is used. That means
that the created \f(CW\*(C`Apache2::RequestRec\*(C'\fR object will be valid as long as
the connection object is valid.
.ie n .IP "ret: $r ( ""Apache2::RequestRec object"" )" 4
.el .IP "ret: \f(CW$r\fR ( \f(CWApache2::RequestRec object\fR )" 4
.IX Item "ret: $r ( Apache2::RequestRec object )"
.PD 0
.IP "since: 2.0.00" 4
.IX Item "since: 2.0.00"
.PD
.PP
It's possible to reuse the \s-1HTTP\s0 framework features outside the
familiar \s-1HTTP\s0 request cycle. It's possible to write your own full or
partial \s-1HTTP\s0 implementation without needing a running Apache
server. You will need the \f(CW\*(C`Apache2::RequestRec\*(C'\fR object in order to be
able to reuse the rich functionality supplied via this object.
.PP
See for example the Command Server protocol
example which
reuses \s-1HTTP AAA\s0 model under non-HTTP protocol.
.ie n .SS """no_cache"""
.el .SS "\f(CWno_cache\fP"
.IX Subsection "no_cache"
Add/remove cache control headers:
.PP
.Vb 1
\&  $prev_no_cache = $r\->no_cache($boolean);
.Ve
.ie n .IP "obj: $r ( ""Apache2::RequestRec object"" )" 4
.el .IP "obj: \f(CW$r\fR ( \f(CWApache2::RequestRec object\fR )" 4
.IX Item "obj: $r ( Apache2::RequestRec object )"
.PD 0
.ie n .IP "arg1: $boolean ( boolean )" 4
.el .IP "arg1: \f(CW$boolean\fR ( boolean )" 4
.IX Item "arg1: $boolean ( boolean )"
.PD
A true value sets the \f(CW\*(C`no_cache\*(C'\fR request record member to a true
value and inserts:
.Sp
.Vb 2
\&  Pragma: no\-cache
\&  Cache\-control: no\-cache
.Ve
.Sp
into the response headers, indicating that the data being returned is
volatile and the client should not cache it.
.Sp
A false value unsets the \f(CW\*(C`no_cache\*(C'\fR request record member and the
mentioned headers if they were previously set.
.ie n .IP "ret: $prev_no_cache ( boolean )" 4
.el .IP "ret: \f(CW$prev_no_cache\fR ( boolean )" 4
.IX Item "ret: $prev_no_cache ( boolean )"
Should you care, the \f(CW\*(C`no_cache\*(C'\fR request record member value prior to
the change is returned.
.IP "since: 2.0.00" 4
.IX Item "since: 2.0.00"
.PP
This method should be invoked before any response data has been sent
out.
.ie n .SS """pnotes"""
.el .SS "\f(CWpnotes\fP"
.IX Subsection "pnotes"
Share Perl variables between Perl \s-1HTTP\s0 handlers
.PP
.Vb 4
\&  # to share variables by value and not reference, $val should be a lexical.
\&  $old_val  = $r\->pnotes($key => $val);
\&  $val      = $r\->pnotes($key);
\&  $hash_ref = $r\->pnotes();
.Ve
.PP
\&\fBNote:\fR sharing variables really means it. The variable is not copied.
Only its reference count is incremented. If it is changed after being
put in pnotes that change also affects the stored value. The following
example illustrates the effect:
.PP
.Vb 4
\&  my $v=1;                     my $v=1;
\&  $r\->pnotes( \*(Aqv\*(Aq=>$v );       $r\->pnotes\->{v}=$v;
\&  $v++;                        $v++;
\&  my $x=$r\->pnotes(\*(Aqv\*(Aq);       my $x=$r\->pnotes\->{v};
.Ve
.PP
In both cases \f(CW$x\fR is \f(CW2\fR not \f(CW1\fR. See also \f(CW\*(C`Apache2::SafePnotes\*(C'\fR on
\&\s-1CPAN.\s0
.PP
There has been a lot of discussion advocating for pnotes sharing variables
by value and not reference.  Sharing by reference can create 'spooky action
at a distance' effects when the sharing is assumed to share a copy of the
value.  Tim Bunce offers the following summary and suggestion for sharing
by value.
.PP
What's wrong with this code:
.PP
.Vb 5
\&  sub foo {
\&      my ($r, $status, $why) = @_;
\&      $r\->pnotes(\*(Aqfoo\*(Aq, ($why) ? "$status:$why" : $status);
\&      return;
\&  }
.Ve
.PP
Nothing, except it doesn't work as expected due to this pnotes bug: If the 
same code is called in a sub-request then the pnote of \f(CW$r\fR\->prev is magically 
updated at a distance to the same value!
.PP
Try explain why that is to anyone not deeply familar with perl internals!
.PP
The fix is to avoid pnotes taking a ref to the invisible op_targ embededed in 
the code by passing a simple lexical variable as the actual argument. That can be done in-line like this:
.PP
.Vb 5
\&  sub mark_as_internally_redirected {
\&      my ($r, $status, $why) = @_;
\&      $r\->pnotes(\*(Aqfoo\*(Aq, my $tmp = (($why) ? "$status:$why" : $status));
\&      return;
\&  }
.Ve
.ie n .IP "obj: $r ( ""Apache2::RequestRec object"" )" 4
.el .IP "obj: \f(CW$r\fR ( \f(CWApache2::RequestRec object\fR )" 4
.IX Item "obj: $r ( Apache2::RequestRec object )"
.PD 0
.ie n .IP "opt arg1: $key ( string )" 4
.el .IP "opt arg1: \f(CW$key\fR ( string )" 4
.IX Item "opt arg1: $key ( string )"
.PD
A key value
.ie n .IP "opt arg2: $val ( \s-1SCALAR\s0 )" 4
.el .IP "opt arg2: \f(CW$val\fR ( \s-1SCALAR\s0 )" 4
.IX Item "opt arg2: $val ( SCALAR )"
Any scalar value (e.g. a reference to an array)
.IP "ret: (3 different possible values)" 4
.IX Item "ret: (3 different possible values)"
if both, \f(CW$key\fR and \f(CW$val\fR are passed the previous value for \f(CW$key\fR
is returned if such existed, otherwise \f(CW\*(C`undef\*(C'\fR is returned.
.Sp
if only \f(CW$key\fR is passed, the current value for the given key is
returned.
.Sp
if no arguments are passed, a hash reference is returned, which can
then be directly accessed without going through the \f(CW\*(C`pnotes()\*(C'\fR
interface.
.IP "since: 2.0.00" 4
.IX Item "since: 2.0.00"
.PP
This method provides functionality similar to
(\f(CW\*(C`Apache2::RequestRec::notes\*(C'\fR),
but values can be any Perl variables. That also means that it can be
used only between Perl modules.
.PP
The values get reset automatically at the end of each \s-1HTTP\s0 request.
.PP
Examples:
.PP
Set a key/value pair:
.PP
.Vb 1
\&  $r\->pnotes(foo => [1..5]);
.Ve
.PP
Get the value:
.PP
.Vb 1
\&  $val = $r\->pnotes("foo");
.Ve
.PP
\&\f(CW$val\fR now contains an array ref containing 5 elements (\f(CW1..5\fR).
.PP
Now change the existing value:
.PP
.Vb 2
\&  $old_val = $r\->pnotes(foo => [\*(Aqa\*(Aq..\*(Aqc\*(Aq]);
\&  $val = $r\->pnotes("foo");
.Ve
.PP
\&\f(CW$old_val\fR now contains an array ref with 5 elements (\f(CW1..5\fR) and
\&\f(CW$val\fR contains an array ref with 3 elements \f(CW\*(Aqa\*(Aq\fR, \f(CW\*(Aqb\*(Aq\fR, \f(CW\*(Aqc\*(Aq\fR.
.PP
Alternatively you can access the hash reference with all pnotes
values:
.PP
.Vb 1
\&  $pnotes = $r\->pnotes;
.Ve
.PP
Now we can read what's in there for the key \fIfoo\fR:
.PP
.Vb 1
\&  $val = $pnotes\->{foo};
.Ve
.PP
and as before \f(CW$val\fR still gives us an array ref with 3 elements
\&\f(CW\*(Aqa\*(Aq\fR, \f(CW\*(Aqb\*(Aq\fR, \f(CW\*(Aqc\*(Aq\fR.
.PP
Now we can add elements to it:
.PP
.Vb 1
\&  push @{ $pnotes{foo} }, \*(Aqd\*(Aq..\*(Aqf\*(Aq;
.Ve
.PP
and we can try to retrieve them using the hash and non-hash \s-1API:\s0
.PP
.Vb 2
\&  $val1 = $pnotes{foo};
\&  $val2 = $r\->pnotes("foo");
.Ve
.PP
Both \f(CW$val1\fR and \f(CW$val2\fR contain an array ref with 6 elements
(letters 'a' to 'f').
.PP
Finally to reset an entry you could just assign \f(CW\*(C`undef\*(C'\fR as a value:
.PP
.Vb 1
\&  $r\->pnotes(foo => undef);
.Ve
.PP
but the entry for the key \fIfoo\fR still remains with the value
\&\f(CW\*(C`undef\*(C'\fR. If you really want to completely remove it, use the hash
interface:
.PP
.Vb 1
\&  delete $r\->pnotes\->{foo};
.Ve
.ie n .SS """psignature"""
.el .SS "\f(CWpsignature\fP"
.IX Subsection "psignature"
Get \s-1HTML\s0 describing the address and (optionally) admin of the server.
.PP
.Vb 1
\&  $sig = $r\->psignature($prefix);
.Ve
.ie n .IP "obj: $r ( ""Apache2::RequestRec"" )" 4
.el .IP "obj: \f(CW$r\fR ( \f(CWApache2::RequestRec\fR )" 4
.IX Item "obj: $r ( Apache2::RequestRec )"
.PD 0
.ie n .IP "arg1: $prefix ( string )" 4
.el .IP "arg1: \f(CW$prefix\fR ( string )" 4
.IX Item "arg1: $prefix ( string )"
.PD
Text which is prepended to the return value
.ie n .IP "ret: $sig ( string )" 4
.el .IP "ret: \f(CW$sig\fR ( string )" 4
.IX Item "ret: $sig ( string )"
\&\s-1HTML\s0 text describing the server. Note that depending on the value of
the \f(CW\*(C`ServerSignature\*(C'\fR directive, the function may return the address,
including the admin information or nothing at all.
.IP "since: 2.0.00" 4
.IX Item "since: 2.0.00"
.ie n .SS """request"""
.el .SS "\f(CWrequest\fP"
.IX Subsection "request"
Get/set the ( \f(CW\*(C`Apache2::RequestRec
object\*(C'\fR ) object for the current
request.
.PP
.Vb 2
\&  $r = Apache2::RequestUtil\->request;
\&       Apache2::RequestUtil\->request($new_r);
.Ve
.ie n .IP "obj: ""Apache2"" (class name)" 4
.el .IP "obj: \f(CWApache2\fR (class name)" 4
.IX Item "obj: Apache2 (class name)"
The Apache class name
.ie n .IP "opt arg1: $new_r ( ""Apache2::RequestRec object"" )" 4
.el .IP "opt arg1: \f(CW$new_r\fR ( \f(CWApache2::RequestRec object\fR )" 4
.IX Item "opt arg1: $new_r ( Apache2::RequestRec object )"
.PD 0
.ie n .IP "ret: $r ( ""Apache2::RequestRec object"" )" 4
.el .IP "ret: \f(CW$r\fR ( \f(CWApache2::RequestRec object\fR )" 4
.IX Item "ret: $r ( Apache2::RequestRec object )"
.IP "since: 2.0.00" 4
.IX Item "since: 2.0.00"
.PD
.PP
The get-able part of this method is only available if \f(CW\*(C`PerlOptions
+GlobalRequest\*(C'\fR is
in effect or if \f(CW\*(C`Apache2\->request($new_r)\*(C'\fR was called earlier. So
instead of setting \f(CW\*(C`PerlOptions
+GlobalRequest\*(C'\fR, one
can set the global request from within the handler.
.ie n .SS """push_handlers"""
.el .SS "\f(CWpush_handlers\fP"
.IX Subsection "push_handlers"
Add one or more handlers to a list of handlers to be called for a
given phase.
.PP
.Vb 2
\&  $ok = $r\->push_handlers($hook_name => \e&handler);
\&  $ok = $r\->push_handlers($hook_name => [\*(AqFoo::Bar::handler\*(Aq, \e&handler2]);
.Ve
.ie n .IP "obj: $r ( ""Apache2::RequestRec object"" )" 4
.el .IP "obj: \f(CW$r\fR ( \f(CWApache2::RequestRec object\fR )" 4
.IX Item "obj: $r ( Apache2::RequestRec object )"
.PD 0
.ie n .IP "arg1: $hook_name ( string )" 4
.el .IP "arg1: \f(CW$hook_name\fR ( string )" 4
.IX Item "arg1: $hook_name ( string )"
.PD
the phase to add the handlers to
.ie n .IP "arg2: $handlers ( \s-1CODE\s0 ref or \s-1SUB\s0 name or an \s-1ARRAY\s0 ref )" 4
.el .IP "arg2: \f(CW$handlers\fR ( \s-1CODE\s0 ref or \s-1SUB\s0 name or an \s-1ARRAY\s0 ref )" 4
.IX Item "arg2: $handlers ( CODE ref or SUB name or an ARRAY ref )"
a single handler \s-1CODE\s0 reference or just a name of the subroutine
(fully qualified unless defined in the current package).
.Sp
if more than one passed, use a reference to an array of \s-1CODE\s0 refs
and/or subroutine names.
.ie n .IP "ret: $ok ( boolean )" 4
.el .IP "ret: \f(CW$ok\fR ( boolean )" 4
.IX Item "ret: $ok ( boolean )"
returns a true value on success, otherwise a false value
.IP "since: 2.0.00" 4
.IX Item "since: 2.0.00"
See also:
\&\f(CW\*(C`$s\->add_config\*(C'\fR
.Sp
Note that to push input/output filters you have to use
\&\f(CW\*(C`Apache2::Filter\*(C'\fR methods:
\&\f(CW\*(C`add_input_filter\*(C'\fR
and
\&\f(CW\*(C`add_output_filter\*(C'\fR.
.PP
Examples:
.PP
A single handler:
.PP
.Vb 1
\&  $r\->push_handlers(PerlResponseHandler => \e&handler);
.Ve
.PP
Multiple handlers:
.PP
.Vb 1
\&  $r\->push_handlers(PerlFixupHandler => [\*(AqFoo::Bar::handler\*(Aq, \e&handler2]);
.Ve
.PP
Anonymous functions:
.PP
.Vb 1
\&  $r\->push_handlers(PerlLogHandler => sub { return Apache2::Const::OK });
.Ve
.ie n .SS """set_basic_credentials"""
.el .SS "\f(CWset_basic_credentials\fP"
.IX Subsection "set_basic_credentials"
Populate the incoming request headers table (\f(CW\*(C`headers_in\*(C'\fR) with
authentication headers for Basic Authorization as if the client has
submitted those in first place:
.PP
.Vb 1
\&  $r\->set_basic_credentials($username, $password);
.Ve
.ie n .IP "obj: $r ( ""Apache2::RequestRec object"" )" 4
.el .IP "obj: \f(CW$r\fR ( \f(CWApache2::RequestRec object\fR )" 4
.IX Item "obj: $r ( Apache2::RequestRec object )"
.PD 0
.ie n .IP "arg1: $username ( string )" 4
.el .IP "arg1: \f(CW$username\fR ( string )" 4
.IX Item "arg1: $username ( string )"
.ie n .IP "arg2: $password ( string )" 4
.el .IP "arg2: \f(CW$password\fR ( string )" 4
.IX Item "arg2: $password ( string )"
.IP "ret: no return value" 4
.IX Item "ret: no return value"
.IP "since: 2.0.00" 4
.IX Item "since: 2.0.00"
.PD
.PP
See for example the Command Server protocol
example which
reuses \s-1HTTP AAA\s0 model under non-HTTP protocol.
.ie n .SS """set_handlers"""
.el .SS "\f(CWset_handlers\fP"
.IX Subsection "set_handlers"
Set a list of handlers to be called for a given phase. Any previously
set handlers are forgotten.
.PP
.Vb 4
\&  $ok = $r\->set_handlers($hook_name => \e&handler);
\&  $ok = $r\->set_handlers($hook_name => [\*(AqFoo::Bar::handler\*(Aq, \e&handler2]);
\&  $ok = $r\->set_handlers($hook_name => []);
\&  $ok = $r\->set_handlers($hook_name => undef);
.Ve
.ie n .IP "obj: $r ( ""Apache2::RequestRec object"" )" 4
.el .IP "obj: \f(CW$r\fR ( \f(CWApache2::RequestRec object\fR )" 4
.IX Item "obj: $r ( Apache2::RequestRec object )"
.PD 0
.ie n .IP "arg1: $hook_name ( string )" 4
.el .IP "arg1: \f(CW$hook_name\fR ( string )" 4
.IX Item "arg1: $hook_name ( string )"
.PD
the phase to set the handlers in
.ie n .IP "arg2: $handlers (\s-1CODE\s0 ref or \s-1SUB\s0 name or an \s-1ARRAY\s0 ref)" 4
.el .IP "arg2: \f(CW$handlers\fR (\s-1CODE\s0 ref or \s-1SUB\s0 name or an \s-1ARRAY\s0 ref)" 4
.IX Item "arg2: $handlers (CODE ref or SUB name or an ARRAY ref)"
a reference to a single handler \s-1CODE\s0 reference or just a name of the
subroutine (fully qualified unless defined in the current package).
.Sp
if more than one passed, use a reference to an array of \s-1CODE\s0 refs
and/or subroutine names.
.Sp
if the argument is \f(CW\*(C`undef\*(C'\fR or \f(CW\*(C`[]\*(C'\fR the list of handlers is reset to
zero.
.ie n .IP "ret: $ok ( boolean )" 4
.el .IP "ret: \f(CW$ok\fR ( boolean )" 4
.IX Item "ret: $ok ( boolean )"
returns a true value on success, otherwise a false value
.IP "since: 2.0.00" 4
.IX Item "since: 2.0.00"
.PP
See also:
\&\f(CW\*(C`$s\->add_config\*(C'\fR
.PP
Examples:
.PP
A single handler:
.PP
.Vb 1
\&  $r\->set_handlers(PerlResponseHandler => \e&handler);
.Ve
.PP
Multiple handlers:
.PP
.Vb 1
\&  $r\->set_handlers(PerlFixupHandler => [\*(AqFoo::Bar::handler\*(Aq, \e&handler2]);
.Ve
.PP
Anonymous functions:
.PP
.Vb 1
\&  $r\->set_handlers(PerlLogHandler => sub { return Apache2::Const::OK });
.Ve
.PP
Reset any previously set handlers:
.PP
.Vb 1
\&  $r\->set_handlers(PerlCleanupHandler => []);
.Ve
.PP
or
.PP
.Vb 1
\&  $r\->set_handlers(PerlCleanupHandler => undef);
.Ve
.ie n .SS """slurp_filename"""
.el .SS "\f(CWslurp_filename\fP"
.IX Subsection "slurp_filename"
Slurp the contents of \f(CW\*(C`$r\->filename\*(C'\fR:
.PP
.Vb 1
\&  $content_ref = $r\->slurp_filename($tainted);
.Ve
.ie n .IP "obj: $r ( ""Apache2::RequestRec object"" )" 4
.el .IP "obj: \f(CW$r\fR ( \f(CWApache2::RequestRec object\fR )" 4
.IX Item "obj: $r ( Apache2::RequestRec object )"
.PD 0
.ie n .IP "arg1: $tainted (number)" 4
.el .IP "arg1: \f(CW$tainted\fR (number)" 4
.IX Item "arg1: $tainted (number)"
.PD
If the server is run under the tainting mode (\f(CW\*(C`\-T\*(C'\fR) which we hope you
do, by default the returned data is tainted. If an optional
\&\f(CW$tainted\fR flag is set to zero, the data will be marked as
non-tainted.
.Sp
Do \fBnot\fR set this flag to zero unless you know what you are doing,
you may create a security hole in your program if you do. For more
information see the \fIperlsec\fR manpage.
.Sp
If you wonder why this option is available, it is used internally by
the \f(CW\*(C`ModPerl::Registry\*(C'\fR handler
and friends, because the \s-1CGI\s0 scripts that it reads are considered safe
(you could just as well \f(CW\*(C`require()\*(C'\fR them).
.ie n .IP "ret: $content_ref ( \s-1SCALAR\s0 ref )" 4
.el .IP "ret: \f(CW$content_ref\fR ( \s-1SCALAR\s0 ref )" 4
.IX Item "ret: $content_ref ( SCALAR ref )"
A reference to a string with the contents
.ie n .IP "excpt: ""APR::Error""" 4
.el .IP "excpt: \f(CWAPR::Error\fR" 4
.IX Item "excpt: APR::Error"
Possible error codes could be:
\&\f(CW\*(C`APR::Const::EACCES\*(C'\fR
(permission problems),
\&\f(CW\*(C`APR::Const::ENOENT\*(C'\fR
(file not found), and others. For checking such error codes, see the
documentation for, for example,
\&\f(CW\*(C`APR::Status::is_EACCES\*(C'\fR
and
\&\f(CW\*(C`APR::Status::is_ENOENT\*(C'\fR.
.IP "since: 2.0.00" 4
.IX Item "since: 2.0.00"
.PP
Note that if you assign to \f(CW\*(C`$r\->filename\*(C'\fR you need to update
its stat record.
.SH "See Also"
.IX Header "See Also"
mod_perl 2.0 documentation.
.SH "Copyright"
.IX Header "Copyright"
mod_perl 2.0 and its core modules are copyrighted under
The Apache Software License, Version 2.0.
.SH "Authors"
.IX Header "Authors"
The mod_perl development team and numerous
contributors.
