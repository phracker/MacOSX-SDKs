.\" Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "XML::SAX 3"
.TH XML::SAX 3 "2019-06-14" "perl v5.30.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
XML::SAX \- Simple API for XML
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use XML::SAX;
\&  
\&  # get a list of known parsers
\&  my $parsers = XML::SAX\->parsers();
\&  
\&  # add/update a parser
\&  XML::SAX\->add_parser(q(XML::SAX::PurePerl));
\&
\&  # remove parser
\&  XML::SAX\->remove_parser(q(XML::SAX::Foodelberry));
\&
\&  # save parsers
\&  XML::SAX\->save_parsers();
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\s-1XML::SAX\s0 is a \s-1SAX\s0 parser access \s-1API\s0 for Perl. It includes classes
and APIs required for implementing \s-1SAX\s0 drivers, along with a factory
class for returning any \s-1SAX\s0 parser installed on the user's system.
.SH "USING A SAX2 PARSER"
.IX Header "USING A SAX2 PARSER"
The factory class is XML::SAX::ParserFactory. Please see the
documentation of that module for how to instantiate a \s-1SAX\s0 parser:
XML::SAX::ParserFactory. However if you don't want to load up
another manual page, here's a short synopsis:
.PP
.Vb 6
\&  use XML::SAX::ParserFactory;
\&  use XML::SAX::XYZHandler;
\&  my $handler = XML::SAX::XYZHandler\->new();
\&  my $p = XML::SAX::ParserFactory\->parser(Handler => $handler);
\&  $p\->parse_uri("foo.xml");
\&  # or $p\->parse_string("<foo/>") or $p\->parse_file($fh);
.Ve
.PP
This will automatically load a \s-1SAX2\s0 parser (defaulting to
XML::SAX::PurePerl if no others are found) and return it to you.
.PP
In order to learn how to use \s-1SAX\s0 to parse \s-1XML,\s0 you will need to read
XML::SAX::Intro and for reference, XML::SAX::Specification.
.SH "WRITING A SAX2 PARSER"
.IX Header "WRITING A SAX2 PARSER"
The first thing to remember in writing a \s-1SAX2\s0 parser is to subclass
XML::SAX::Base. This will make your life infinitely easier, by providing
a number of methods automagically for you. See XML::SAX::Base for more
details.
.PP
When writing a \s-1SAX2\s0 parser that is compatible with \s-1XML::SAX,\s0 you need
to inform \s-1XML::SAX\s0 of the presence of that driver when you install it.
In order to do that, \s-1XML::SAX\s0 contains methods for saving the fact that
the parser exists on your system to a \*(L"\s-1INI\*(R"\s0 file, which is then loaded
to determine which parsers are installed.
.PP
The best way to do this is to follow these rules:
.IP "\(bu" 4
Add \s-1XML::SAX\s0 as a prerequisite in Makefile.PL:
.Sp
.Vb 5
\&  WriteMakefile(
\&      ...
\&      PREREQ_PM => { \*(AqXML::SAX\*(Aq => 0 },
\&      ...
\&  );
.Ve
.Sp
Alternatively you may wish to check for it in other ways that will
cause more than just a warning.
.IP "\(bu" 4
Add the following code snippet to your Makefile.PL:
.Sp
.Vb 8
\&  sub MY::install {
\&    package MY;
\&    my $script = shift\->SUPER::install(@_);
\&    if (ExtUtils::MakeMaker::prompt(
\&      "Do you want to modify ParserDetails.ini?", \*(AqY\*(Aq)
\&      =~ /^y/i) {
\&      $script =~ s/install :: (.*)$/install :: $1 install_sax_driver/m;
\&      $script .= <<"INSTALL";
\&  
\&  install_sax_driver :
\&  \et\e@\e$(PERL) \-MXML::SAX \-e "XML::SAX\->add_parser(q(\e$(NAME)))\->save_parsers()"
\&  
\&  INSTALL
\&    }
\&    return $script;
\&  }
.Ve
.Sp
Note that you should check the output of this \- \e$(\s-1NAME\s0) will use the name of
your distribution, which may not be exactly what you want. For example XML::LibXML
has a driver called XML::LibXML::SAX::Generator, which is used in place of
\&\e$(\s-1NAME\s0) in the above.
.IP "\(bu" 4
Add an \s-1XML::SAX\s0 test:
.Sp
A test file should be added to your t/ directory containing something like the
following:
.Sp
.Vb 10
\&  use Test;
\&  BEGIN { plan tests => 3 }
\&  use XML::SAX;
\&  use XML::SAX::PurePerl::DebugHandler;
\&  XML::SAX\->add_parser(q(XML::SAX::MyDriver));
\&  local $XML::SAX::ParserPackage = \*(AqXML::SAX::MyDriver\*(Aq;
\&  eval {
\&    my $handler = XML::SAX::PurePerl::DebugHandler\->new();
\&    ok($handler);
\&    my $parser = XML::SAX::ParserFactory\->parser(Handler => $handler);
\&    ok($parser);
\&    ok($parser\->isa(\*(AqXML::SAX::MyDriver\*(Aq);
\&    $parser\->parse_string("<tag/>");
\&    ok($handler\->{seen}{start_element});
\&  };
.Ve
.SH "EXPORTS"
.IX Header "EXPORTS"
By default, \s-1XML::SAX\s0 exports nothing into the caller's namespace. However you
can request the symbols \f(CW\*(C`Namespaces\*(C'\fR and \f(CW\*(C`Validation\*(C'\fR which are the
URIs for those features, allowing an easier way to request those features
via ParserFactory:
.PP
.Vb 5
\&  use XML::SAX qw(Namespaces Validation);
\&  my $factory = XML::SAX::ParserFactory\->new();
\&  $factory\->require_feature(Namespaces);
\&  $factory\->require_feature(Validation);
\&  my $parser = $factory\->parser();
.Ve
.SH "AUTHOR"
.IX Header "AUTHOR"
Current maintainer: Grant McLean, grantm@cpan.org
.PP
Originally written by:
.PP
Matt Sergeant, matt@sergeant.org
.PP
Kip Hampton, khampton@totalcinema.com
.PP
Robin Berjon, robin@knowscape.com
.SH "LICENSE"
.IX Header "LICENSE"
This is free software, you may use it and distribute it under
the same terms as Perl itself.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
XML::SAX::Base for writing \s-1SAX\s0 Filters and Parsers
.PP
XML::SAX::PurePerl for an \s-1XML\s0 parser written in 100%
pure perl.
.PP
XML::SAX::Exception for details on exception handling
