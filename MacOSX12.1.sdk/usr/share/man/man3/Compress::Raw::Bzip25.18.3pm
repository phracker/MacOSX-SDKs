.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Compress::Raw::Bzip2 3pm"
.TH Compress::Raw::Bzip2 3pm "2014-09-30" "perl v5.18.4" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Compress::Raw::Bzip2 \- Low\-Level Interface to bzip2 compression library
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use Compress::Raw::Bzip2 ;
\&
\&    my ($bz, $status) = new Compress::Raw::Bzip2 [OPTS]
\&        or die "Cannot create bzip2 object: $bzerno\en";
\&    
\&    $status = $bz\->bzdeflate($input, $output);
\&    $status = $bz\->bzflush($output);
\&    $status = $bz\->bzclose($output);
\&
\&    my ($bz, $status) = new Compress::Raw::Bunzip2 [OPTS]
\&        or die "Cannot create bunzip2 object: $bzerno\en";
\&    
\&    $status = $bz\->bzinflate($input, $output);
\&
\&    my $version = Compress::Raw::Bzip2::bzlibversion();
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\f(CW\*(C`Compress::Raw::Bzip2\*(C'\fR provides an interface to the in-memory
compression/uncompression functions from the bzip2 compression library.
.PP
Although the primary purpose for the existence of \f(CW\*(C`Compress::Raw::Bzip2\*(C'\fR
is for use by the  \f(CW\*(C`IO::Compress::Bzip2\*(C'\fR and \f(CW\*(C`IO::Compress::Bunzip2\*(C'\fR
modules, it can be used on its own for simple compression/uncompression
tasks.
.SH "Compression"
.IX Header "Compression"
.ie n .SS "($z, $status) = new Compress::Raw::Bzip2 $appendOutput, $blockSize100k, $workfactor;"
.el .SS "($z, \f(CW$status\fP) = new Compress::Raw::Bzip2 \f(CW$appendOutput\fP, \f(CW$blockSize100k\fP, \f(CW$workfactor\fP;"
.IX Subsection "($z, $status) = new Compress::Raw::Bzip2 $appendOutput, $blockSize100k, $workfactor;"
Creates a new compression object.
.PP
If successful, it will return the initialised compression object, \f(CW$z\fR
and a \f(CW$status\fR of \f(CW\*(C`BZ_OK\*(C'\fR in a list context. In scalar context it
returns the deflation object, \f(CW$z\fR, only.
.PP
If not successful, the returned compression object, \f(CW$z\fR, will be
\&\fIundef\fR and \f(CW$status\fR will hold the a \fIbzip2\fR error code.
.PP
Below is a list of the valid options:
.ie n .IP "\fB\fB$appendOutput\fB\fR" 5
.el .IP "\fB\f(CB$appendOutput\fB\fR" 5
.IX Item "$appendOutput"
Controls whether the compressed data is appended to the output buffer in
the \f(CW\*(C`bzdeflate\*(C'\fR, \f(CW\*(C`bzflush\*(C'\fR and \f(CW\*(C`bzclose\*(C'\fR methods.
.Sp
Defaults to 1.
.ie n .IP "\fB\fB$blockSize100k\fB\fR" 5
.el .IP "\fB\f(CB$blockSize100k\fB\fR" 5
.IX Item "$blockSize100k"
To quote the bzip2 documentation
.Sp
.Vb 4
\&    blockSize100k specifies the block size to be used for compression. It
\&    should be a value between 1 and 9 inclusive, and the actual block size
\&    used is 100000 x this figure. 9 gives the best compression but takes
\&    most memory.
.Ve
.Sp
Defaults to 1.
.ie n .IP "\fB\fB$workfactor\fB\fR" 5
.el .IP "\fB\f(CB$workfactor\fB\fR" 5
.IX Item "$workfactor"
To quote the bzip2 documentation
.Sp
.Vb 7
\&    This parameter controls how the compression phase behaves when
\&    presented with worst case, highly repetitive, input data. If
\&    compression runs into difficulties caused by repetitive data, the
\&    library switches from the standard sorting algorithm to a fallback
\&    algorithm. The fallback is slower than the standard algorithm by
\&    perhaps a factor of three, but always behaves reasonably, no matter how
\&    bad the input.
\&
\&    Lower values of workFactor reduce the amount of effort the standard
\&    algorithm will expend before resorting to the fallback. You should set
\&    this parameter carefully; too low, and many inputs will be handled by
\&    the fallback algorithm and so compress rather slowly, too high, and
\&    your average\-to\-worst case compression times can become very large. The
\&    default value of 30 gives reasonable behaviour over a wide range of
\&    circumstances.
\&
\&    Allowable values range from 0 to 250 inclusive. 0 is a special case,
\&    equivalent to using the default value of 30.
.Ve
.Sp
Defaults to 0.
.ie n .SS "$status = $bz\->bzdeflate($input, $output);"
.el .SS "\f(CW$status\fP = \f(CW$bz\fP\->bzdeflate($input, \f(CW$output\fP);"
.IX Subsection "$status = $bz->bzdeflate($input, $output);"
Reads the contents of \f(CW$input\fR, compresses it and writes the compressed
data to \f(CW$output\fR.
.PP
Returns \f(CW\*(C`BZ_RUN_OK\*(C'\fR on success and a \f(CW\*(C`bzip2\*(C'\fR error code on failure.
.PP
If \f(CW\*(C`appendOutput\*(C'\fR is enabled in the constructor for the bzip2 object, the
compressed data will be appended to \f(CW$output\fR. If not enabled, \f(CW$output\fR
will be truncated before the compressed data is written to it.
.ie n .SS "$status = $bz\->bzflush($output);"
.el .SS "\f(CW$status\fP = \f(CW$bz\fP\->bzflush($output);"
.IX Subsection "$status = $bz->bzflush($output);"
Flushes any pending compressed data to \f(CW$output\fR.
.PP
Returns \f(CW\*(C`BZ_RUN_OK\*(C'\fR on success and a \f(CW\*(C`bzip2\*(C'\fR error code on failure.
.ie n .SS "$status = $bz\->bzclose($output);"
.el .SS "\f(CW$status\fP = \f(CW$bz\fP\->bzclose($output);"
.IX Subsection "$status = $bz->bzclose($output);"
Terminates the compressed data stream and flushes any pending compressed
data to \f(CW$output\fR.
.PP
Returns \f(CW\*(C`BZ_STREAM_END\*(C'\fR on success and a \f(CW\*(C`bzip2\*(C'\fR error code on failure.
.SS "Example"
.IX Subsection "Example"
.SH "Uncompression"
.IX Header "Uncompression"
.ie n .SS "($z, $status) = new Compress::Raw::Bunzip2 $appendOutput, $consumeInput, $small, $verbosity, $limitOutput;"
.el .SS "($z, \f(CW$status\fP) = new Compress::Raw::Bunzip2 \f(CW$appendOutput\fP, \f(CW$consumeInput\fP, \f(CW$small\fP, \f(CW$verbosity\fP, \f(CW$limitOutput\fP;"
.IX Subsection "($z, $status) = new Compress::Raw::Bunzip2 $appendOutput, $consumeInput, $small, $verbosity, $limitOutput;"
If successful, it will return the initialised uncompression object, \f(CW$z\fR
and a \f(CW$status\fR of \f(CW\*(C`BZ_OK\*(C'\fR in a list context. In scalar context it
returns the deflation object, \f(CW$z\fR, only.
.PP
If not successful, the returned uncompression object, \f(CW$z\fR, will be
\&\fIundef\fR and \f(CW$status\fR will hold the a \fIbzip2\fR error code.
.PP
Below is a list of the valid options:
.ie n .IP "\fB\fB$appendOutput\fB\fR" 5
.el .IP "\fB\f(CB$appendOutput\fB\fR" 5
.IX Item "$appendOutput"
Controls whether the compressed data is appended to the output buffer in the
\&\f(CW\*(C`bzinflate\*(C'\fR, \f(CW\*(C`bzflush\*(C'\fR and \f(CW\*(C`bzclose\*(C'\fR methods.
.Sp
Defaults to 1.
.ie n .IP "\fB\fB$consumeInput\fB\fR" 5
.el .IP "\fB\f(CB$consumeInput\fB\fR" 5
.IX Item "$consumeInput"
.PD 0
.ie n .IP "\fB\fB$small\fB\fR" 5
.el .IP "\fB\f(CB$small\fB\fR" 5
.IX Item "$small"
.PD
To quote the bzip2 documentation
.Sp
.Vb 4
\&    If small is nonzero, the library will use an alternative decompression
\&    algorithm which uses less memory but at the cost of decompressing more
\&    slowly (roughly speaking, half the speed, but the maximum memory
\&    requirement drops to around 2300k).
.Ve
.Sp
Defaults to 0.
.ie n .IP "\fB\fB$limitOutput\fB\fR" 5
.el .IP "\fB\f(CB$limitOutput\fB\fR" 5
.IX Item "$limitOutput"
The \f(CW\*(C`LimitOutput\*(C'\fR option changes the behavior of the \f(CW\*(C`$i\->bzinflate\*(C'\fR
method so that the amount of memory used by the output buffer can be
limited.
.Sp
When \f(CW\*(C`LimitOutput\*(C'\fR is used the size of the output buffer used will either
be the 16k or the amount of memory already allocated to \f(CW$output\fR,
whichever is larger. Predicting the output size available is tricky, so
don't rely on getting an exact output buffer size.
.Sp
When \f(CW\*(C`LimitOutout\*(C'\fR is not specified \f(CW\*(C`$i\->bzinflate\*(C'\fR will use as much
memory as it takes to write all the uncompressed data it creates by
uncompressing the input buffer.
.Sp
If \f(CW\*(C`LimitOutput\*(C'\fR is enabled, the \f(CW\*(C`ConsumeInput\*(C'\fR option will also be
enabled.
.Sp
This option defaults to false.
.ie n .IP "\fB\fB$verbosity\fB\fR" 5
.el .IP "\fB\f(CB$verbosity\fB\fR" 5
.IX Item "$verbosity"
This parameter is ignored.
.Sp
Defaults to 0.
.ie n .SS "$status = $z\->bzinflate($input, $output);"
.el .SS "\f(CW$status\fP = \f(CW$z\fP\->bzinflate($input, \f(CW$output\fP);"
.IX Subsection "$status = $z->bzinflate($input, $output);"
Uncompresses \f(CW$input\fR and writes the uncompressed data to \f(CW$output\fR.
.PP
Returns \f(CW\*(C`BZ_OK\*(C'\fR if the uncompression was successful, but the end of the
compressed data stream has not been reached. Returns \f(CW\*(C`BZ_STREAM_END\*(C'\fR on
successful uncompression and the end of the compression stream has been
reached.
.PP
If \f(CW\*(C`consumeInput\*(C'\fR is enabled in the constructor for the bunzip2 object,
\&\f(CW$input\fR will have all compressed data removed from it after
uncompression. On \f(CW\*(C`BZ_OK\*(C'\fR return this will mean that \f(CW$input\fR will be an
empty string; when \f(CW\*(C`BZ_STREAM_END\*(C'\fR \f(CW$input\fR will either be an empty
string or will contain whatever data immediately followed the compressed
data stream.
.PP
If \f(CW\*(C`appendOutput\*(C'\fR is enabled in the constructor for the bunzip2 object,
the uncompressed data will be appended to \f(CW$output\fR. If not enabled,
\&\f(CW$output\fR will be truncated before the uncompressed data is written to it.
.SH "Misc"
.IX Header "Misc"
.ie n .SS "my $version = \fICompress::Raw::Bzip2::bzlibversion()\fP;"
.el .SS "my \f(CW$version\fP = \fICompress::Raw::Bzip2::bzlibversion()\fP;"
.IX Subsection "my $version = Compress::Raw::Bzip2::bzlibversion();"
Returns the version of the underlying bzip2 library.
.SH "Constants"
.IX Header "Constants"
The following bzip2 constants are exported by this module
.PP
.Vb 3
\&                BZ_RUN
\&                BZ_FLUSH
\&                BZ_FINISH
\&
\&                BZ_OK
\&                BZ_RUN_OK
\&                BZ_FLUSH_OK
\&                BZ_FINISH_OK
\&                BZ_STREAM_END
\&                BZ_SEQUENCE_ERROR
\&                BZ_PARAM_ERROR
\&                BZ_MEM_ERROR
\&                BZ_DATA_ERROR
\&                BZ_DATA_ERROR_MAGIC
\&                BZ_IO_ERROR
\&                BZ_UNEXPECTED_EOF
\&                BZ_OUTBUFF_FULL
\&                BZ_CONFIG_ERROR
.Ve
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Compress::Zlib, IO::Compress::Gzip, IO::Uncompress::Gunzip, IO::Compress::Deflate, IO::Uncompress::Inflate, IO::Compress::RawDeflate, IO::Uncompress::RawInflate, IO::Compress::Bzip2, IO::Uncompress::Bunzip2, IO::Compress::Lzma, IO::Uncompress::UnLzma, IO::Compress::Xz, IO::Uncompress::UnXz, IO::Compress::Lzop, IO::Uncompress::UnLzop, IO::Compress::Lzf, IO::Uncompress::UnLzf, IO::Uncompress::AnyInflate, IO::Uncompress::AnyUncompress
.PP
IO::Compress::FAQ
.PP
File::GlobMapper, Archive::Zip,
Archive::Tar,
IO::Zlib
.PP
The primary site for the bzip2 program is \fIhttp://www.bzip.org\fR.
.PP
See the module Compress::Bzip2
.SH "AUTHOR"
.IX Header "AUTHOR"
This module was written by Paul Marquess, \fIpmqs@cpan.org\fR.
.SH "MODIFICATION HISTORY"
.IX Header "MODIFICATION HISTORY"
See the Changes file.
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright (c) 2005\-2013 Paul Marquess. All rights reserved.
.PP
This program is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.
