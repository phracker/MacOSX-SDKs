.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "MIME::Field::ContType 3"
.TH MIME::Field::ContType 3 "2013-11-14" "perl v5.18.4" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
MIME::Field::ContType \- a "Content\-type" field
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
A subclass of Mail::Field.
.PP
\&\fIDon't use this class directly... its name may change in the future!\fR
Instead, ask Mail::Field for new instances based on the field name!
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&    use Mail::Field;
\&    use MIME::Head;
\&
\&    # Create an instance from some text:
\&    $field = Mail::Field\->new(\*(AqContent\-type\*(Aq,
\&                              \*(Aqtext/HTML; charset="US\-ASCII"\*(Aq);
\&
\&    # Get the MIME type, like \*(Aqtext/plain\*(Aq or \*(Aqx\-foobar\*(Aq.
\&    # Returns \*(Aqtext/plain\*(Aq as default, as per RFC 2045:
\&    my ($type, $subtype) = split(\*(Aq/\*(Aq, $field\->type);
\&
\&    # Get generic information:
\&    print $field\->name;
\&
\&    # Get information related to "message" type:
\&    if ($type eq \*(Aqmessage\*(Aq) {
\&        print $field\->id;
\&        print $field\->number;
\&        print $field\->total;
\&    }
\&
\&    # Get information related to "multipart" type:
\&    if ($type eq \*(Aqmultipart\*(Aq) {
\&        print $field\->boundary;            # the basic value, fixed up
\&        print $field\->multipart_boundary;  # empty if not a multipart message!
\&    }
\&
\&    # Get information related to "text" type:
\&    if ($type eq \*(Aqtext\*(Aq) {
\&        print $field\->charset;      # returns \*(Aqus\-ascii\*(Aq as default
\&    }
.Ve
.SH "PUBLIC INTERFACE"
.IX Header "PUBLIC INTERFACE"
.IP "boundary" 4
.IX Item "boundary"
Return the boundary field.  The boundary is returned exactly
as given in the \f(CW\*(C`Content\-type:\*(C'\fR field; that is, the leading
double-hyphen (\f(CW\*(C`\-\-\*(C'\fR) is \fInot\fR prepended.
.Sp
(Well, \fIalmost\fR exactly... from \s-1RFC 2046:\s0
.Sp
.Vb 2
\&   (If a boundary appears to end with white space, the white space
\&   must be presumed to have been added by a gateway, and must be deleted.)
.Ve
.Sp
so we oblige and remove any trailing spaces.)
.Sp
Returns the empty string if there is no boundary, or if the boundary is
illegal (e.g., if it is empty after all trailing whitespace has been
removed).
.IP "multipart_boundary" 4
.IX Item "multipart_boundary"
Like \f(CW\*(C`boundary()\*(C'\fR, except that this will also return the empty
string if the message is not a multipart message.  In other words,
there's an automatic sanity check.
.IP "type" 4
.IX Item "type"
Try real hard to determine the content type (e.g., \f(CW"text/plain"\fR,
\&\f(CW"image/gif"\fR, \f(CW"x\-weird\-type"\fR, which is returned
in all-lowercase.
.Sp
A happy thing: the following code will work just as you would want,
even if there's no subtype (as in \f(CW"x\-weird\-type"\fR)... in such a case,
the \f(CW$subtype\fR would simply be the empty string:
.Sp
.Vb 1
\&    ($type, $subtype) = split(\*(Aq/\*(Aq, $head\->mime_type);
.Ve
.Sp
If the content-type information is missing, it defaults to \f(CW"text/plain"\fR,
as per \s-1RFC 2045:\s0
.Sp
.Vb 4
\&    Default RFC 2822 messages are typed by this protocol as plain text in
\&    the US\-ASCII character set, which can be explicitly specified as
\&    "Content\-type: text/plain; charset=us\-ascii".  If no Content\-Type is
\&    specified, this default is assumed.
.Ve
.Sp
\&\fBNote:\fR under the \*(L"be liberal in what we accept\*(R" principle, this routine
no longer syntax-checks the content type.  If it ain't empty,
just downcase and return it.
.SH "NOTES"
.IX Header "NOTES"
Since nearly all (if not all) parameters must have non-empty values
to be considered valid, we just return the empty string to signify
missing fields.  If you need to get the \fIreal\fR underlying value,
use the inherited \f(CW\*(C`param()\*(C'\fR method (which returns undef if the
parameter is missing).
.SH "SEE ALSO"
.IX Header "SEE ALSO"
MIME::Field::ParamVal, Mail::Field
.SH "AUTHOR"
.IX Header "AUTHOR"
Eryq (\fIeryq@zeegee.com\fR), ZeeGee Software Inc (\fIhttp://www.zeegee.com\fR).
David F. Skoll (dfs@roaringpenguin.com) http://www.roaringpenguin.com
