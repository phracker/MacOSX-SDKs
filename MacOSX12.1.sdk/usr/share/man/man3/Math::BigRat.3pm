.\" Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Math::BigRat 3pm"
.TH Math::BigRat 3pm "2019-10-21" "perl v5.30.3" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Math::BigRat \- Arbitrary big rational numbers
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use Math::BigRat;
\&
\&    my $x = Math::BigRat\->new(\*(Aq3/7\*(Aq); $x += \*(Aq5/9\*(Aq;
\&
\&    print $x\->bstr(), "\en";
\&    print $x ** 2, "\en";
\&
\&    my $y = Math::BigRat\->new(\*(Aqinf\*(Aq);
\&    print "$y ", ($y\->is_inf ? \*(Aqis\*(Aq : \*(Aqis not\*(Aq), " infinity\en";
\&
\&    my $z = Math::BigRat\->new(144); $z\->bsqrt();
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Math::BigRat complements Math::BigInt and Math::BigFloat by providing support
for arbitrary big rational numbers.
.SS "\s-1MATH LIBRARY\s0"
.IX Subsection "MATH LIBRARY"
You can change the underlying module that does the low-level
math operations by using:
.PP
.Vb 1
\&    use Math::BigRat try => \*(AqGMP\*(Aq;
.Ve
.PP
Note: This needs Math::BigInt::GMP installed.
.PP
The following would first try to find Math::BigInt::Foo, then
Math::BigInt::Bar, and when this also fails, revert to Math::BigInt::Calc:
.PP
.Vb 1
\&    use Math::BigRat try => \*(AqFoo,Math::BigInt::Bar\*(Aq;
.Ve
.PP
If you want to get warned when the fallback occurs, replace \*(L"try\*(R" with \*(L"lib\*(R":
.PP
.Vb 1
\&    use Math::BigRat lib => \*(AqFoo,Math::BigInt::Bar\*(Aq;
.Ve
.PP
If you want the code to die instead, replace \*(L"try\*(R" with \*(L"only\*(R":
.PP
.Vb 1
\&    use Math::BigRat only => \*(AqFoo,Math::BigInt::Bar\*(Aq;
.Ve
.SH "METHODS"
.IX Header "METHODS"
Any methods not listed here are derived from Math::BigFloat (or
Math::BigInt), so make sure you check these two modules for further
information.
.IP "\fBnew()\fR" 4
.IX Item "new()"
.Vb 1
\&    $x = Math::BigRat\->new(\*(Aq1/3\*(Aq);
.Ve
.Sp
Create a new Math::BigRat object. Input can come in various forms:
.Sp
.Vb 9
\&    $x = Math::BigRat\->new(123);                            # scalars
\&    $x = Math::BigRat\->new(\*(Aqinf\*(Aq);                          # infinity
\&    $x = Math::BigRat\->new(\*(Aq123.3\*(Aq);                        # float
\&    $x = Math::BigRat\->new(\*(Aq1/3\*(Aq);                          # simple string
\&    $x = Math::BigRat\->new(\*(Aq1 / 3\*(Aq);                        # spaced
\&    $x = Math::BigRat\->new(\*(Aq1 / 0.1\*(Aq);                      # w/ floats
\&    $x = Math::BigRat\->new(Math::BigInt\->new(3));           # BigInt
\&    $x = Math::BigRat\->new(Math::BigFloat\->new(\*(Aq3.1\*(Aq));     # BigFloat
\&    $x = Math::BigRat\->new(Math::BigInt::Lite\->new(\*(Aq2\*(Aq));   # BigLite
\&
\&    # You can also give D and N as different objects:
\&    $x = Math::BigRat\->new(
\&            Math::BigInt\->new(\-123),
\&            Math::BigInt\->new(7),
\&         );                      # => \-123/7
.Ve
.IP "\fBnumerator()\fR" 4
.IX Item "numerator()"
.Vb 1
\&    $n = $x\->numerator();
.Ve
.Sp
Returns a copy of the numerator (the part above the line) as signed BigInt.
.IP "\fBdenominator()\fR" 4
.IX Item "denominator()"
.Vb 1
\&    $d = $x\->denominator();
.Ve
.Sp
Returns a copy of the denominator (the part under the line) as positive BigInt.
.IP "\fBparts()\fR" 4
.IX Item "parts()"
.Vb 1
\&    ($n, $d) = $x\->parts();
.Ve
.Sp
Return a list consisting of (signed) numerator and (unsigned) denominator as
BigInts.
.IP "\fBnumify()\fR" 4
.IX Item "numify()"
.Vb 1
\&    my $y = $x\->numify();
.Ve
.Sp
Returns the object as a scalar. This will lose some data if the object
cannot be represented by a normal Perl scalar (integer or float), so
use \*(L"\fBas_int()\fR\*(R" or \*(L"\fBas_float()\fR\*(R" instead.
.Sp
This routine is automatically used whenever a scalar is required:
.Sp
.Vb 3
\&    my $x = Math::BigRat\->new(\*(Aq3/1\*(Aq);
\&    @array = (0, 1, 2, 3);
\&    $y = $array[$x];                # set $y to 3
.Ve
.IP "\fBas_int()\fR" 4
.IX Item "as_int()"
.PD 0
.IP "\fBas_number()\fR" 4
.IX Item "as_number()"
.PD
.Vb 2
\&    $x = Math::BigRat\->new(\*(Aq13/7\*(Aq);
\&    print $x\->as_int(), "\en";               # \*(Aq1\*(Aq
.Ve
.Sp
Returns a copy of the object as BigInt, truncated to an integer.
.Sp
\&\f(CW\*(C`as_number()\*(C'\fR is an alias for \f(CW\*(C`as_int()\*(C'\fR.
.IP "\fBas_float()\fR" 4
.IX Item "as_float()"
.Vb 2
\&    $x = Math::BigRat\->new(\*(Aq13/7\*(Aq);
\&    print $x\->as_float(), "\en";             # \*(Aq1\*(Aq
\&
\&    $x = Math::BigRat\->new(\*(Aq2/3\*(Aq);
\&    print $x\->as_float(5), "\en";            # \*(Aq0.66667\*(Aq
.Ve
.Sp
Returns a copy of the object as BigFloat, preserving the
accuracy as wanted, or the default of 40 digits.
.Sp
This method was added in v0.22 of Math::BigRat (April 2008).
.IP "\fBas_hex()\fR" 4
.IX Item "as_hex()"
.Vb 2
\&    $x = Math::BigRat\->new(\*(Aq13\*(Aq);
\&    print $x\->as_hex(), "\en";               # \*(Aq0xd\*(Aq
.Ve
.Sp
Returns the BigRat as hexadecimal string. Works only for integers.
.IP "\fBas_bin()\fR" 4
.IX Item "as_bin()"
.Vb 2
\&    $x = Math::BigRat\->new(\*(Aq13\*(Aq);
\&    print $x\->as_bin(), "\en";               # \*(Aq0x1101\*(Aq
.Ve
.Sp
Returns the BigRat as binary string. Works only for integers.
.IP "\fBas_oct()\fR" 4
.IX Item "as_oct()"
.Vb 2
\&    $x = Math::BigRat\->new(\*(Aq13\*(Aq);
\&    print $x\->as_oct(), "\en";               # \*(Aq015\*(Aq
.Ve
.Sp
Returns the BigRat as octal string. Works only for integers.
.IP "\fBfrom_hex()\fR" 4
.IX Item "from_hex()"
.Vb 1
\&    my $h = Math::BigRat\->from_hex(\*(Aq0x10\*(Aq);
.Ve
.Sp
Create a BigRat from a hexadecimal number in string form.
.IP "\fBfrom_oct()\fR" 4
.IX Item "from_oct()"
.Vb 1
\&    my $o = Math::BigRat\->from_oct(\*(Aq020\*(Aq);
.Ve
.Sp
Create a BigRat from an octal number in string form.
.IP "\fBfrom_bin()\fR" 4
.IX Item "from_bin()"
.Vb 1
\&    my $b = Math::BigRat\->from_bin(\*(Aq0b10000000\*(Aq);
.Ve
.Sp
Create a BigRat from an binary number in string form.
.IP "\fBbnan()\fR" 4
.IX Item "bnan()"
.Vb 1
\&    $x = Math::BigRat\->bnan();
.Ve
.Sp
Creates a new BigRat object representing NaN (Not A Number).
If used on an object, it will set it to NaN:
.Sp
.Vb 1
\&    $x\->bnan();
.Ve
.IP "\fBbzero()\fR" 4
.IX Item "bzero()"
.Vb 1
\&    $x = Math::BigRat\->bzero();
.Ve
.Sp
Creates a new BigRat object representing zero.
If used on an object, it will set it to zero:
.Sp
.Vb 1
\&    $x\->bzero();
.Ve
.IP "\fBbinf()\fR" 4
.IX Item "binf()"
.Vb 1
\&    $x = Math::BigRat\->binf($sign);
.Ve
.Sp
Creates a new BigRat object representing infinity. The optional argument is
either '\-' or '+', indicating whether you want infinity or minus infinity.
If used on an object, it will set it to infinity:
.Sp
.Vb 2
\&    $x\->binf();
\&    $x\->binf(\*(Aq\-\*(Aq);
.Ve
.IP "\fBbone()\fR" 4
.IX Item "bone()"
.Vb 1
\&    $x = Math::BigRat\->bone($sign);
.Ve
.Sp
Creates a new BigRat object representing one. The optional argument is
either '\-' or '+', indicating whether you want one or minus one.
If used on an object, it will set it to one:
.Sp
.Vb 2
\&    $x\->bone();                 # +1
\&    $x\->bone(\*(Aq\-\*(Aq);              # \-1
.Ve
.IP "\fBlength()\fR" 4
.IX Item "length()"
.Vb 1
\&    $len = $x\->length();
.Ve
.Sp
Return the length of \f(CW$x\fR in digits for integer values.
.IP "\fBdigit()\fR" 4
.IX Item "digit()"
.Vb 2
\&    print Math::BigRat\->new(\*(Aq123/1\*(Aq)\->digit(1);     # 1
\&    print Math::BigRat\->new(\*(Aq123/1\*(Aq)\->digit(\-1);    # 3
.Ve
.Sp
Return the N'ths digit from X when X is an integer value.
.IP "\fBbnorm()\fR" 4
.IX Item "bnorm()"
.Vb 1
\&    $x\->bnorm();
.Ve
.Sp
Reduce the number to the shortest form. This routine is called
automatically whenever it is needed.
.IP "\fBbfac()\fR" 4
.IX Item "bfac()"
.Vb 1
\&    $x\->bfac();
.Ve
.Sp
Calculates the factorial of \f(CW$x\fR. For instance:
.Sp
.Vb 2
\&    print Math::BigRat\->new(\*(Aq3/1\*(Aq)\->bfac(), "\en";   # 1*2*3
\&    print Math::BigRat\->new(\*(Aq5/1\*(Aq)\->bfac(), "\en";   # 1*2*3*4*5
.Ve
.Sp
Works currently only for integers.
.IP "\fBbround()\fR/\fBround()\fR/\fBbfround()\fR" 4
.IX Item "bround()/round()/bfround()"
Are not yet implemented.
.IP "\fBbmod()\fR" 4
.IX Item "bmod()"
.Vb 1
\&    $x\->bmod($y);
.Ve
.Sp
Returns \f(CW$x\fR modulo \f(CW$y\fR. When \f(CW$x\fR is finite, and \f(CW$y\fR is finite and non-zero, the
result is identical to the remainder after floored division (F\-division). If,
in addition, both \f(CW$x\fR and \f(CW$y\fR are integers, the result is identical to the result
from Perl's % operator.
.IP "\fBbmodinv()\fR" 4
.IX Item "bmodinv()"
.Vb 1
\&    $x\->bmodinv($mod);          # modular multiplicative inverse
.Ve
.Sp
Returns the multiplicative inverse of \f(CW$x\fR modulo \f(CW$mod\fR. If
.Sp
.Vb 1
\&    $y = $x \-> copy() \-> bmodinv($mod)
.Ve
.Sp
then \f(CW$y\fR is the number closest to zero, and with the same sign as \f(CW$mod\fR,
satisfying
.Sp
.Vb 1
\&    ($x * $y) % $mod = 1 % $mod
.Ve
.Sp
If \f(CW$x\fR and \f(CW$y\fR are non-zero, they must be relative primes, i.e.,
\&\f(CW\*(C`bgcd($y, $mod)==1\*(C'\fR. '\f(CW\*(C`NaN\*(C'\fR' is returned when no modular multiplicative
inverse exists.
.IP "\fBbmodpow()\fR" 4
.IX Item "bmodpow()"
.Vb 2
\&    $num\->bmodpow($exp,$mod);           # modular exponentiation
\&                                        # ($num**$exp % $mod)
.Ve
.Sp
Returns the value of \f(CW$num\fR taken to the power \f(CW$exp\fR in the modulus
\&\f(CW$mod\fR using binary exponentiation.  \f(CW\*(C`bmodpow\*(C'\fR is far superior to
writing
.Sp
.Vb 1
\&    $num ** $exp % $mod
.Ve
.Sp
because it is much faster \- it reduces internal variables into
the modulus whenever possible, so it operates on smaller numbers.
.Sp
\&\f(CW\*(C`bmodpow\*(C'\fR also supports negative exponents.
.Sp
.Vb 1
\&    bmodpow($num, \-1, $mod)
.Ve
.Sp
is exactly equivalent to
.Sp
.Vb 1
\&    bmodinv($num, $mod)
.Ve
.IP "\fBbneg()\fR" 4
.IX Item "bneg()"
.Vb 1
\&    $x\->bneg();
.Ve
.Sp
Used to negate the object in-place.
.IP "\fBis_one()\fR" 4
.IX Item "is_one()"
.Vb 1
\&    print "$x is 1\en" if $x\->is_one();
.Ve
.Sp
Return true if \f(CW$x\fR is exactly one, otherwise false.
.IP "\fBis_zero()\fR" 4
.IX Item "is_zero()"
.Vb 1
\&    print "$x is 0\en" if $x\->is_zero();
.Ve
.Sp
Return true if \f(CW$x\fR is exactly zero, otherwise false.
.IP "\fBis_pos()\fR/\fBis_positive()\fR" 4
.IX Item "is_pos()/is_positive()"
.Vb 1
\&    print "$x is >= 0\en" if $x\->is_positive();
.Ve
.Sp
Return true if \f(CW$x\fR is positive (greater than or equal to zero), otherwise
false. Please note that '+inf' is also positive, while 'NaN' and '\-inf' aren't.
.Sp
\&\f(CW\*(C`is_positive()\*(C'\fR is an alias for \f(CW\*(C`is_pos()\*(C'\fR.
.IP "\fBis_neg()\fR/\fBis_negative()\fR" 4
.IX Item "is_neg()/is_negative()"
.Vb 1
\&    print "$x is < 0\en" if $x\->is_negative();
.Ve
.Sp
Return true if \f(CW$x\fR is negative (smaller than zero), otherwise false. Please
note that '\-inf' is also negative, while 'NaN' and '+inf' aren't.
.Sp
\&\f(CW\*(C`is_negative()\*(C'\fR is an alias for \f(CW\*(C`is_neg()\*(C'\fR.
.IP "\fBis_int()\fR" 4
.IX Item "is_int()"
.Vb 1
\&    print "$x is an integer\en" if $x\->is_int();
.Ve
.Sp
Return true if \f(CW$x\fR has a denominator of 1 (e.g. no fraction parts), otherwise
false. Please note that '\-inf', 'inf' and 'NaN' aren't integer.
.IP "\fBis_odd()\fR" 4
.IX Item "is_odd()"
.Vb 1
\&    print "$x is odd\en" if $x\->is_odd();
.Ve
.Sp
Return true if \f(CW$x\fR is odd, otherwise false.
.IP "\fBis_even()\fR" 4
.IX Item "is_even()"
.Vb 1
\&    print "$x is even\en" if $x\->is_even();
.Ve
.Sp
Return true if \f(CW$x\fR is even, otherwise false.
.IP "\fBbceil()\fR" 4
.IX Item "bceil()"
.Vb 1
\&    $x\->bceil();
.Ve
.Sp
Set \f(CW$x\fR to the next bigger integer value (e.g. truncate the number to integer
and then increment it by one).
.IP "\fBbfloor()\fR" 4
.IX Item "bfloor()"
.Vb 1
\&    $x\->bfloor();
.Ve
.Sp
Truncate \f(CW$x\fR to an integer value.
.IP "\fBbint()\fR" 4
.IX Item "bint()"
.Vb 1
\&    $x\->bint();
.Ve
.Sp
Round \f(CW$x\fR towards zero.
.IP "\fBbsqrt()\fR" 4
.IX Item "bsqrt()"
.Vb 1
\&    $x\->bsqrt();
.Ve
.Sp
Calculate the square root of \f(CW$x\fR.
.IP "\fBbroot()\fR" 4
.IX Item "broot()"
.Vb 1
\&    $x\->broot($n);
.Ve
.Sp
Calculate the N'th root of \f(CW$x\fR.
.IP "\fBbadd()\fR" 4
.IX Item "badd()"
.Vb 1
\&    $x\->badd($y);
.Ve
.Sp
Adds \f(CW$y\fR to \f(CW$x\fR and returns the result.
.IP "\fBbmul()\fR" 4
.IX Item "bmul()"
.Vb 1
\&    $x\->bmul($y);
.Ve
.Sp
Multiplies \f(CW$y\fR to \f(CW$x\fR and returns the result.
.IP "\fBbsub()\fR" 4
.IX Item "bsub()"
.Vb 1
\&    $x\->bsub($y);
.Ve
.Sp
Subtracts \f(CW$y\fR from \f(CW$x\fR and returns the result.
.IP "\fBbdiv()\fR" 4
.IX Item "bdiv()"
.Vb 2
\&    $q = $x\->bdiv($y);
\&    ($q, $r) = $x\->bdiv($y);
.Ve
.Sp
In scalar context, divides \f(CW$x\fR by \f(CW$y\fR and returns the result. In list context,
does floored division (F\-division), returning an integer \f(CW$q\fR and a remainder \f(CW$r\fR
so that \f(CW$x\fR = \f(CW$q\fR * \f(CW$y\fR + \f(CW$r\fR. The remainer (modulo) is equal to what is returned
by \f(CW\*(C`$x\-\*(C'\fRbmod($y)>.
.IP "\fBbdec()\fR" 4
.IX Item "bdec()"
.Vb 1
\&    $x\->bdec();
.Ve
.Sp
Decrements \f(CW$x\fR by 1 and returns the result.
.IP "\fBbinc()\fR" 4
.IX Item "binc()"
.Vb 1
\&    $x\->binc();
.Ve
.Sp
Increments \f(CW$x\fR by 1 and returns the result.
.IP "\fBcopy()\fR" 4
.IX Item "copy()"
.Vb 1
\&    my $z = $x\->copy();
.Ve
.Sp
Makes a deep copy of the object.
.Sp
Please see the documentation in Math::BigInt for further details.
.IP "\fBbstr()\fR/\fBbsstr()\fR" 4
.IX Item "bstr()/bsstr()"
.Vb 3
\&    my $x = Math::BigRat\->new(\*(Aq8/4\*(Aq);
\&    print $x\->bstr(), "\en";             # prints 1/2
\&    print $x\->bsstr(), "\en";            # prints 1/2
.Ve
.Sp
Return a string representing this object.
.IP "\fBbcmp()\fR" 4
.IX Item "bcmp()"
.Vb 1
\&    $x\->bcmp($y);
.Ve
.Sp
Compares \f(CW$x\fR with \f(CW$y\fR and takes the sign into account.
Returns \-1, 0, 1 or undef.
.IP "\fBbacmp()\fR" 4
.IX Item "bacmp()"
.Vb 1
\&    $x\->bacmp($y);
.Ve
.Sp
Compares \f(CW$x\fR with \f(CW$y\fR while ignoring their sign. Returns \-1, 0, 1 or undef.
.IP "\fBbeq()\fR" 4
.IX Item "beq()"
.Vb 1
\&    $x \-> beq($y);
.Ve
.Sp
Returns true if and only if \f(CW$x\fR is equal to \f(CW$y\fR, and false otherwise.
.IP "\fBbne()\fR" 4
.IX Item "bne()"
.Vb 1
\&    $x \-> bne($y);
.Ve
.Sp
Returns true if and only if \f(CW$x\fR is not equal to \f(CW$y\fR, and false otherwise.
.IP "\fBblt()\fR" 4
.IX Item "blt()"
.Vb 1
\&    $x \-> blt($y);
.Ve
.Sp
Returns true if and only if \f(CW$x\fR is equal to \f(CW$y\fR, and false otherwise.
.IP "\fBble()\fR" 4
.IX Item "ble()"
.Vb 1
\&    $x \-> ble($y);
.Ve
.Sp
Returns true if and only if \f(CW$x\fR is less than or equal to \f(CW$y\fR, and false
otherwise.
.IP "\fBbgt()\fR" 4
.IX Item "bgt()"
.Vb 1
\&    $x \-> bgt($y);
.Ve
.Sp
Returns true if and only if \f(CW$x\fR is greater than \f(CW$y\fR, and false otherwise.
.IP "\fBbge()\fR" 4
.IX Item "bge()"
.Vb 1
\&    $x \-> bge($y);
.Ve
.Sp
Returns true if and only if \f(CW$x\fR is greater than or equal to \f(CW$y\fR, and false
otherwise.
.IP "\fBblsft()\fR/\fBbrsft()\fR" 4
.IX Item "blsft()/brsft()"
Used to shift numbers left/right.
.Sp
Please see the documentation in Math::BigInt for further details.
.IP "\fBband()\fR" 4
.IX Item "band()"
.Vb 1
\&    $x\->band($y);               # bitwise and
.Ve
.IP "\fBbior()\fR" 4
.IX Item "bior()"
.Vb 1
\&    $x\->bior($y);               # bitwise inclusive or
.Ve
.IP "\fBbxor()\fR" 4
.IX Item "bxor()"
.Vb 1
\&    $x\->bxor($y);               # bitwise exclusive or
.Ve
.IP "\fBbnot()\fR" 4
.IX Item "bnot()"
.Vb 1
\&    $x\->bnot();                 # bitwise not (two\*(Aqs complement)
.Ve
.IP "\fBbpow()\fR" 4
.IX Item "bpow()"
.Vb 1
\&    $x\->bpow($y);
.Ve
.Sp
Compute \f(CW$x\fR ** \f(CW$y\fR.
.Sp
Please see the documentation in Math::BigInt for further details.
.IP "\fBblog()\fR" 4
.IX Item "blog()"
.Vb 1
\&    $x\->blog($base, $accuracy);         # logarithm of x to the base $base
.Ve
.Sp
If \f(CW$base\fR is not defined, Euler's number (e) is used:
.Sp
.Vb 1
\&    print $x\->blog(undef, 100);         # log(x) to 100 digits
.Ve
.IP "\fBbexp()\fR" 4
.IX Item "bexp()"
.Vb 1
\&    $x\->bexp($accuracy);        # calculate e ** X
.Ve
.Sp
Calculates two integers A and B so that A/B is equal to \f(CW\*(C`e ** $x\*(C'\fR, where \f(CW\*(C`e\*(C'\fR is
Euler's number.
.Sp
This method was added in v0.20 of Math::BigRat (May 2007).
.Sp
See also \f(CW\*(C`blog()\*(C'\fR.
.IP "\fBbnok()\fR" 4
.IX Item "bnok()"
.Vb 1
\&    $x\->bnok($y);               # x over y (binomial coefficient n over k)
.Ve
.Sp
Calculates the binomial coefficient n over k, also called the \*(L"choose\*(R"
function. The result is equivalent to:
.Sp
.Vb 3
\&    ( n )      n!
\&    | \- |  = \-\-\-\-\-\-\-
\&    ( k )    k!(n\-k)!
.Ve
.Sp
This method was added in v0.20 of Math::BigRat (May 2007).
.IP "\fBconfig()\fR" 4
.IX Item "config()"
.Vb 2
\&    Math::BigRat\->config("trap_nan" => 1);      # set
\&    $accu = Math::BigRat\->config("accuracy");   # get
.Ve
.Sp
Set or get configuration parameter values. Read-only parameters are marked as
\&\s-1RO.\s0 Read-write parameters are marked as \s-1RW.\s0 The following parameters are
supported.
.Sp
.Vb 10
\&    Parameter       RO/RW   Description
\&                            Example
\&    ============================================================
\&    lib             RO      Name of the math backend library
\&                            Math::BigInt::Calc
\&    lib_version     RO      Version of the math backend library
\&                            0.30
\&    class           RO      The class of config you just called
\&                            Math::BigRat
\&    version         RO      version number of the class you used
\&                            0.10
\&    upgrade         RW      To which class numbers are upgraded
\&                            undef
\&    downgrade       RW      To which class numbers are downgraded
\&                            undef
\&    precision       RW      Global precision
\&                            undef
\&    accuracy        RW      Global accuracy
\&                            undef
\&    round_mode      RW      Global round mode
\&                            even
\&    div_scale       RW      Fallback accuracy for div, sqrt etc.
\&                            40
\&    trap_nan        RW      Trap NaNs
\&                            undef
\&    trap_inf        RW      Trap +inf/\-inf
\&                            undef
.Ve
.SH "BUGS"
.IX Header "BUGS"
Please report any bugs or feature requests to
\&\f(CW\*(C`bug\-math\-bigrat at rt.cpan.org\*(C'\fR, or through the web interface at
<https://rt.cpan.org/Ticket/Create.html?Queue=Math\-BigRat>
(requires login).
We will be notified, and then you'll automatically be notified of progress on
your bug as I make changes.
.SH "SUPPORT"
.IX Header "SUPPORT"
You can find documentation for this module with the perldoc command.
.PP
.Vb 1
\&    perldoc Math::BigRat
.Ve
.PP
You can also look for information at:
.IP "\(bu" 4
\&\s-1RT: CPAN\s0's request tracker
.Sp
<https://rt.cpan.org/Public/Dist/Display.html?Name=Math\-BigRat>
.IP "\(bu" 4
AnnoCPAN: Annotated \s-1CPAN\s0 documentation
.Sp
<http://annocpan.org/dist/Math\-BigRat>
.IP "\(bu" 4
\&\s-1CPAN\s0 Ratings
.Sp
<http://cpanratings.perl.org/dist/Math\-BigRat>
.IP "\(bu" 4
Search \s-1CPAN\s0
.Sp
<http://search.cpan.org/dist/Math\-BigRat/>
.IP "\(bu" 4
\&\s-1CPAN\s0 Testers Matrix
.Sp
<http://matrix.cpantesters.org/?dist=Math\-BigRat>
.IP "\(bu" 4
The Bignum mailing list
.RS 4
.IP "\(bu" 4
Post to mailing list
.Sp
\&\f(CW\*(C`bignum at lists.scsys.co.uk\*(C'\fR
.IP "\(bu" 4
View mailing list
.Sp
<http://lists.scsys.co.uk/pipermail/bignum/>
.IP "\(bu" 4
Subscribe/Unsubscribe
.Sp
<http://lists.scsys.co.uk/cgi\-bin/mailman/listinfo/bignum>
.RE
.RS 4
.RE
.SH "LICENSE"
.IX Header "LICENSE"
This program is free software; you may redistribute it and/or modify it under
the same terms as Perl itself.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
bigrat, Math::BigFloat and Math::BigInt as well as the backends
Math::BigInt::FastCalc, Math::BigInt::GMP, and Math::BigInt::Pari.
.SH "AUTHORS"
.IX Header "AUTHORS"
.IP "\(bu" 4
Tels <http://bloodgate.com/> 2001\-2009.
.IP "\(bu" 4
Maintained by Peter John Acklam <pjacklam@online.no> 2011\-
