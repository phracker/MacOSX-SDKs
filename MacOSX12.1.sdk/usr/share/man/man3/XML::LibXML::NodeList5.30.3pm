.\" Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "XML::LibXML::NodeList 3"
.TH XML::LibXML::NodeList 3 "2014-02-01" "perl v5.30.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
XML::LibXML::NodeList \- a list of XML document nodes
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
An XML::LibXML::NodeList object contains an ordered list of nodes, as
detailed by the W3C \s-1DOM\s0 documentation of Node Lists.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 5
\&  my $results = $dom\->findnodes(\*(Aq//somepath\*(Aq);
\&  foreach my $context ($results\->get_nodelist) {
\&    my $newresults = $context\->findnodes(\*(Aq./other/element\*(Aq);
\&    ...
\&  }
.Ve
.SH "API"
.IX Header "API"
.SS "new(@nodes)"
.IX Subsection "new(@nodes)"
You will almost never have to create a new NodeList object, as it is all
done for you by XPath.
.SS "\fBget_nodelist()\fP"
.IX Subsection "get_nodelist()"
Returns a list of nodes, the contents of the node list, as a perl list.
.SS "\fBstring_value()\fP"
.IX Subsection "string_value()"
Returns the string-value of the first node in the list.
See the XPath specification for what \*(L"string-value\*(R" means.
.SS "\fBto_literal()\fP"
.IX Subsection "to_literal()"
Returns the concatenation of all the string-values of all
the nodes in the list.
.SS "to_literal_delimited($separator)"
.IX Subsection "to_literal_delimited($separator)"
Returns the concatenation of all the string-values of all
the nodes in the list, delimited by the specified separator.
.SS "\fBto_literal_list()\fP"
.IX Subsection "to_literal_list()"
Returns all the string-values of all the nodes in the list as
a perl list.
.SS "get_node($pos)"
.IX Subsection "get_node($pos)"
Returns the node at \f(CW$pos\fR. The node position in XPath is based at 1, not 0.
.SS "\fBsize()\fP"
.IX Subsection "size()"
Returns the number of nodes in the NodeList.
.SS "\fBpop()\fP"
.IX Subsection "pop()"
Equivalent to perl's pop function.
.SS "push(@nodes)"
.IX Subsection "push(@nodes)"
Equivalent to perl's push function.
.SS "append($nodelist)"
.IX Subsection "append($nodelist)"
Given a nodelist, appends the list of nodes in \f(CW$nodelist\fR to the end of the
current list.
.SS "\fBshift()\fP"
.IX Subsection "shift()"
Equivalent to perl's shift function.
.SS "unshift(@nodes)"
.IX Subsection "unshift(@nodes)"
Equivalent to perl's unshift function.
.SS "prepend($nodelist)"
.IX Subsection "prepend($nodelist)"
Given a nodelist, prepends the list of nodes in \f(CW$nodelist\fR to the front of
the current list.
.SS "map($coderef)"
.IX Subsection "map($coderef)"
Equivalent to perl's map function.
.SS "grep($coderef)"
.IX Subsection "grep($coderef)"
Equivalent to perl's grep function.
.SS "sort($coderef)"
.IX Subsection "sort($coderef)"
Equivalent to perl's sort function.
.PP
Caveat: Perl's magic \f(CW$a\fR and \f(CW$b\fR variables are not available in
\&\f(CW$coderef\fR. Instead the two terms are passed to the coderef as arguments.
.SS "\fBreverse()\fP"
.IX Subsection "reverse()"
Equivalent to perl's reverse function.
.SS "foreach($coderef)"
.IX Subsection "foreach($coderef)"
Inspired by perl's foreach loop. Executes the coderef on each item in
the list. Similar to \f(CW\*(C`map\*(C'\fR, but instead of returning the list of values
returned by \f(CW$coderef\fR, returns the original NodeList.
.ie n .SS "reduce($coderef, $init)"
.el .SS "reduce($coderef, \f(CW$init\fP)"
.IX Subsection "reduce($coderef, $init)"
Equivalent to List::Util's reduce function. \f(CW$init\fR is optional and
provides an initial value for the reduction.
.PP
Caveat: Perl's magic \f(CW$a\fR and \f(CW$b\fR variables are not available in
\&\f(CW$coderef\fR. Instead the two terms are passed to the coderef as arguments.
