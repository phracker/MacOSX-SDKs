.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Parse::Eyapp::Treeregexp 3"
.TH Parse::Eyapp::Treeregexp 3 "2012-03-23" "perl v5.18.4" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Parse::Eyapp::Treeregexp \- Tree transformations
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 3
\&  use strict;
\&  use Parse::Eyapp;
\&  use Parse::Eyapp::Treeregexp;
\&
\&  my $grammar = q{
\&    %right  \*(Aq=\*(Aq
\&    %left   \*(Aq\-\*(Aq \*(Aq+\*(Aq
\&    %left   \*(Aq*\*(Aq \*(Aq/\*(Aq
\&    %left   NEG
\&    %tree
\&    %{
\&    use Tail2;  # See file examples/Tail2.pm in the distribution
\&    %}
\&
\&    %%
\&    block:  exp <%name BLOCK + \*(Aq;\*(Aq> { $_[1] }
\&    ;
\&
\&    exp:      %name NUM
\&                NUM
\&            | %name WHILE
\&                \*(Aqwhile\*(Aq   exp  \*(Aq{\*(Aq block \*(Aq}\*(Aq
\&            | %name VAR
\&                VAR
\&            | %name ASSIGN
\&                VAR \*(Aq=\*(Aq exp
\&            | %name PLUS
\&                exp \*(Aq+\*(Aq exp
\&            | %name MINUS
\&                exp \*(Aq\-\*(Aq exp
\&            | %name TIMES
\&                exp \*(Aq*\*(Aq exp
\&            | %name DIV
\&                exp \*(Aq/\*(Aq exp
\&            | %name UMINUS
\&                \*(Aq\-\*(Aq exp %prec NEG
\&            |   \*(Aq(\*(Aq exp \*(Aq)\*(Aq  { $_[2] } /* Let us simplify a bit the tree */
\&    ;
\&
\&    %%
\&  }; # end grammar
\&
\&  sub TERMINAL::info { $_[0]{attr} }
\&  $Parse::Eyapp::Node::INDENT = 2;
\&
\&  our (@all,$moveinvariant, $condition, $assign, $before, $after);
\&
\&  Parse::Eyapp\->new_grammar(
\&    input=>$grammar,
\&    classname=>\*(AqRule6\*(Aq,
\&    firstline=>7,
\&  );
\&  my $parser = Rule6\->new();
\&  my $program = "a =1000; c = 1; while (a) { c = c*a; b = 5; a = a\-1 }\en";
\&  my $t = $parser\->Run(\e$program);
\&  my @output = split /\en/, $t\->str;
\&
\&  my $p = Parse::Eyapp::Treeregexp\->new( STRING => q{
\&    moveinvariant: BLOCK(
\&                     @prests,
\&                     WHILE(VAR($b), BLOCK(@a, ASSIGN($x, NUM($e)), @c)),
\&                     @possts
\&                   )
\&      => {
\&           my $assign = $ASSIGN;
\&           $BLOCK[1]\->delete($ASSIGN);
\&           $BLOCK[0]\->insert_before($WHILE, $assign);
\&         }
\&    },
\&  );
\&  $p\->generate();
\&  $moveinvariant\->s($t);
\&  my @output2 = split /\en/, $t\->str;
\&
\&  my ($node1, $node2);
\&  format STDOUT_TOP =
\&                          PROGRAM
\&  \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&  @||||||||||||||||||||||||||||||||||||||||||||||||||||||
\&  $program
\&  \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&  Before                     |    After
\&  \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-|\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&  .
\&
\&  format STDOUT =
\&  @<<<<<<<<<<<<<<<<<<<<<<<<<<@|@<<<<<<<<<<<<<<<<<<<<<<<<<
\&  $node1,                    \*(Aq|\*(Aq,$node2
\&  .
\&
\&  for (1..$#output) {
\&    $node1 = $output[$_];
\&    $node2 = $output2[$_];
\&    write;
\&  }
.Ve
.SH "Introduction"
.IX Header "Introduction"
The example in the \s-1SYNOPSIS\s0 
section uses \f(CW\*(C`Parse::Eyapp\*(C'\fR to build an abstract
syntax tree for the program
.PP
.Vb 1
\&  my $program = "a =1000; c = 1; while (a) { c = c*a; b = 5; a = a\-1 }\en";
.Ve
.PP
The tree is transformed 
using the transformation \f(CW\*(C`moveinvariant\*(C'\fR:
.PP
.Vb 10
\&  my $p = Parse::Eyapp::Treeregexp\->new( STRING => q{
\&    moveinvariant: BLOCK(
\&                     @prests,
\&                     WHILE(VAR($b), BLOCK(@a, ASSIGN($x, NUM($e)), @c)),
\&                     @possts
\&                   )
\&      => {
\&           my $assign = $ASSIGN;
\&           $BLOCK[1]\->delete($ASSIGN);
\&           $BLOCK[0]\->insert_before($WHILE, $assign);
\&         }
\&    },
\&  );
.Ve
.PP
The output shows the original tree versus the transformed
tree:
.PP
.Vb 3
\&  pl@nereida:~/LEyapp/examples$ moveinvariantoutofloopcomplexformula.pl
\&                          PROGRAM
\&  \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&
\&  \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&  Before                     |    After
\&  \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-|\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&  BLOCK(                     | BLOCK(
\&    ASSIGN(                  |   ASSIGN(
\&      TERMINAL[a],           |     TERMINAL[a],
\&      NUM(                   |     NUM(
\&        TERMINAL[1000]       |       TERMINAL[1000]
\&      )                      |     )
\&    ) # ASSIGN,              |   ) # ASSIGN,
\&    ASSIGN(                  |   ASSIGN(
\&      TERMINAL[c],           |     TERMINAL[c],
\&      NUM(                   |     NUM(
\&        TERMINAL[1]          |       TERMINAL[1]
\&      )                      |     )
\&    ) # ASSIGN,              |   ) # ASSIGN,
\&    WHILE(                   |   ASSIGN(
\&      VAR(                   |     TERMINAL[b],
\&        TERMINAL[a]          |     NUM(
\&      ),                     |       TERMINAL[5]
\&      BLOCK(                 |     )
\&        ASSIGN(              |   ) # ASSIGN,
\&          TERMINAL[c],       |   WHILE(
\&          TIMES(             |     VAR(
\&            VAR(             |       TERMINAL[a]
\&              TERMINAL[c]    |     ),
\&            ),               |     BLOCK(
\&            VAR(             |       ASSIGN(
\&              TERMINAL[a]    |         TERMINAL[c],
\&            )                |         TIMES(
\&          ) # TIMES          |           VAR(
\&        ) # ASSIGN,          |             TERMINAL[c]
\&        ASSIGN(              |           ),
\&          TERMINAL[b],       |           VAR(
\&          NUM(               |             TERMINAL[a]
\&            TERMINAL[5]      |           )
\&          )                  |         ) # TIMES
\&        ) # ASSIGN,          |       ) # ASSIGN,
\&        ASSIGN(              |       ASSIGN(
\&          TERMINAL[a],       |         TERMINAL[a],
\&          MINUS(             |         MINUS(
\&            VAR(             |           VAR(
\&              TERMINAL[a]    |             TERMINAL[a]
\&            ),               |           ),
\&            NUM(             |           NUM(
\&              TERMINAL[1]    |             TERMINAL[1]
\&            )                |           )
\&          ) # MINUS          |         ) # MINUS
\&        ) # ASSIGN           |       ) # ASSIGN
\&      ) # BLOCK              |     ) # BLOCK
\&    ) # WHILE                |   ) # WHILE
\&  ) # BLOCK                  | ) # BLOCK
.Ve
.SH "The Treeregexp Language"
.IX Header "The Treeregexp Language"
A Treeregexp program is made of the repetition of three kind of 
primitives: The treeregexp transformations, supporting Perl code 
and Transformation Families.
.PP
.Vb 1
\&  treeregexplist:  treeregexp* 
\&
\&  treeregexp: 
\&      IDENT \*(Aq:\*(Aq treereg (\*(Aq=>\*(Aq CODE)?  # Treeregexp 
\&    | CODE                            # Auxiliar code
\&    | IDENT \*(Aq=\*(Aq IDENT + \*(Aq;\*(Aq           # Transformation families
.Ve
.PP
Treeregexp themselves follow the rule:
.PP
.Vb 1
\&                  IDENT \*(Aq:\*(Aq treereg (\*(Aq=>\*(Aq CODE)?
.Ve
.PP
Several instances of this rule can be seen in the example in
the \*(L"\s-1SYNOPSIS\*(R"\s0 section.
The identifier \f(CW\*(C`IDENT\*(C'\fR gives the name to the rule.
At the time of this writing (2006) there are the following kinds
of treeregexes:
.PP
.Vb 10
\&  treereg: 
\&        /* tree patterns with children */
\&      IDENT \*(Aq(\*(Aq childlist \*(Aq)\*(Aq (\*(Aqand\*(Aq CODE)? 
\&    | REGEXP (\*(Aq:\*(Aq IDENT)? \*(Aq(\*(Aq childlist \*(Aq)\*(Aq (\*(Aqand\*(Aq CODE)? 
\&    | SCALAR \*(Aq(\*(Aq childlist \*(Aq)\*(Aq (\*(Aqand\*(Aq CODE)?  
\&    | \*(Aq.\*(Aq \*(Aq(\*(Aq childlist \*(Aq)\*(Aq (\*(Aqand\*(Aq CODE)? 
\&          /* leaf tree patterns */
\&    | IDENT (\*(Aqand\*(Aq CODE)? 
\&    | REGEXP (\*(Aq:\*(Aq IDENT)? (\*(Aqand\*(Aq CODE)? 
\&    | \*(Aq.\*(Aq (\*(Aqand\*(Aq CODE)? 
\&    | SCALAR (\*(Aqand\*(Aq CODE)? 
\&    | ARRAY 
\&    | \*(Aq*\*(Aq
.Ve
.SS "Treeregexp rules"
.IX Subsection "Treeregexp rules"
When seen a rule like
.PP
.Vb 1
\&    zero_times: TIMES(NUM($x), ., .) and { $x\->{attr} == 0 } => { $_[0] = $NUM }
.Ve
.PP
The Treeregexp translator creates a \f(CW\*(C`Parse::Eyapp:YATW\*(C'\fR object
that can be later referenced in the user code by the package variable
\&\f(CW$zero_times\fR.
.PP
\fIThe treeregexp\fR
.IX Subsection "The treeregexp"
.PP
The first part of the rule \f(CW\*(C`TIMES(NUM($x), ., .)\*(C'\fR
indicates that for a matching to succeed the node being
visited must be of \f(CW\*(C`type\*(C'\fR \f(CW\*(C`TIMES\*(C'\fR, have a left child
of  \f(CW\*(C`type\*(C'\fR \f(CW\*(C`NUM\*(C'\fR and two more children.
.PP
If the first part succeeded then the following part 
takes the control to see if the \fIsemantic conditions\fR
are satisfied.
.PP
\fISemantic condition\fR
.IX Subsection "Semantic condition"
.PP
The second part is optional and must be prefixed by the reserved word \f(CW\*(C`and\*(C'\fR
followed by a Perl code manifesting the semantic conditions that must be hold
by the node to succeed. Thus, in the example:
.PP
.Vb 1
\&  zero_times: TIMES(NUM($x), ., .) and { $x\->{attr} == 0 } => { $_[0] = $NUM }
.Ve
.PP
the semantic condition \f(CW\*(C`$x\->{attr} == 0\*(C'\fR states that the
value of the number stored in the \f(CW\*(C`TERMINAL\*(C'\fR node referenced
by \f(CW$x\fR must be zero.
.PP
\fIReferencing the matching nodes\fR
.IX Subsection "Referencing the matching nodes"
.PP
The node  being visited can be referenced/modified
inside the semantic actions using \f(CW$_[0]\fR.
.PP
The Treeregexp
translator automatically creates a set of lexical variables
for us. The scope of these variables is limited to the
semantic condition and the transformation code.
.PP
Thus, in the example
.PP
.Vb 1
\&  zero_times: TIMES(NUM($x), ., .) and { $x\->{attr} == 0 } => { $_[0] = $NUM }
.Ve
.PP
the node being visited \f(CW$_[0]\fR
can be also referenced using the lexical variable
\&\f(CW$TIMES\fR which is created by he Treeregexp compiler.
In the same way a reference to the left child \f(CW\*(C`NUM\*(C'\fR will be stored
in the lexical variable \f(CW$NUM\fR and a
reference to the child of \f(CW$NUM\fR will be stored in \f(CW$x\fR.
The semantic condition states that the attribute
of the node associated with \f(CW$x\fR must be zero.
.PP
When the same type of node appears several times inside 
the treeregexp part the associated lexical variable is 
declared by the Treeregexp compiler as an array.
This is the case in the \f(CW\*(C`constantfold\*(C'\fR transformation
in the \*(L"\s-1SYNOPSIS\*(R"\s0 example, where there are two nodes of type \f(CW\*(C`NUM\*(C'\fR:
.PP
.Vb 5
\&  constantfold: /TIMES|PLUS|DIV|MINUS/(NUM($x), ., NUM($y))
\&     => {
\&    $x\->{attr} = eval  "$x\->{attr} $W\->{attr} $y\->{attr}";
\&    $_[0] = $NUM[0];
\&  }
.Ve
.PP
Thus variable  \f(CW$NUM[0]\fR references the node that matches the 
first \f(CW\*(C`NUM\*(C'\fR term in the formula and \f(CW$NUM[1]\fR the one
that matches the second.
.PP
\fITransformation code\fR
.IX Subsection "Transformation code"
.PP
The third part of the rule is also optional and comes prefixed by
the big arrow \f(CW\*(C`=>\*(C'\fR. The Perl code in this section usually 
transforms the matching tree.
To achieve the modification of the tree, the Treeregexp programmer
\&\fBmust use \f(CB$_[0]\fB\fR and not the lexical variables provided by the translator.
Remember that in Perl \f(CW$_[0]\fR is an alias of the actual parameter.
The \f(CW\*(C`constantfold\*(C'\fR example above \fBwill not work\fR if we rewrite the code \f(CW$_[0] = $NUM[0]\fR as
.PP
.Vb 1
\&                            { $TIMES = $NUM }
.Ve
.SS "Regexp Treeregexes"
.IX Subsection "Regexp Treeregexes"
The previous \f(CW\*(C`constantfold\*(C'\fR example used a classic Perl linear regexp
to explicit that the root node of the matching subtree must match the Perl regexp.
The general syntax for \f(CW\*(C`REGEXP\*(C'\fR treeregexes patterns is:
.PP
.Vb 1
\&      treereg: REGEXP (\*(Aq:\*(Aq IDENT)? \*(Aq(\*(Aq childlist \*(Aq)\*(Aq (\*(Aqand\*(Aq CODE)?
.Ve
.PP
The \f(CW\*(C`REGEXP\*(C'\fR must be specified between slashes (other delimiters
as \f(CW\*(C`{}\*(C'\fR are not accepted).
It is legal to specify options after the second slash (like \f(CW\*(C`e\*(C'\fR, \f(CW\*(C`i\*(C'\fR, etc.).
.PP
The operation of string oriented regexps is slightly modified
when they are used inside a treeregexp:
\&\fBby default the option\fR 
\&\f(CW\*(C`x\*(C'\fR 
\&\fBwill be assumed\fR.
The treeregexp compiler will automatically insert it.
Use the new option \f(CW\*(C`X\*(C'\fR (upper case X) if you want to suppress such behavior.
\&\fBThere is no need also to insert\fR \f(CW\*(C`\eb\*(C'\fR 
\&\fBword anchors\fR to delimit identifiers:
all the identifiers in a regexp treeregexp are automatically
surrounded by \f(CW\*(C`\eb\*(C'\fR. Use the option \f(CW\*(C`B\*(C'\fR (upper case B)
to suppress this behavior.
.PP
The optional identifier after the \f(CW\*(C`REGEXP\*(C'\fR indicates the name of the lexical variable
that will be held a reference to the node whose type matches \f(CW\*(C`REGEXP\*(C'\fR.
Variable \f(CW$W\fR (or \f(CW@W\fR if there are more than one \s-1REGEXP\s0 and or dot treeregexes)
will be used instead if no identifier is specified.
.SS "Scalar Treeregexes"
.IX Subsection "Scalar Treeregexes"
A scalar treeregxp is defined writing a Perl scalar inside the treeregexp, like \f(CW$x\fR
in \f(CW\*(C`NUM($x)\*(C'\fR. A scalar treeregxp immediately matches any node that exists
and stores a reference to such node inside the Perl lexical scalar variable.
The scope of the variable is limited to the semantic parts of the Treeregexp.
Is illegal to use \f(CW$W\fR or \f(CW\*(C`$W_#num\*(C'\fR as variable names for scalar treeregexes.
.SS "Dot Treeregexes"
.IX Subsection "Dot Treeregexes"
A dot matches any node. It can be seen as an abbreviation for
scalar treeregexes. The reference to the matching node
is stored in the lexical variable \f(CW$W\fR. 
The variable \f(CW@W\fR will be used instead
if there are more than one \s-1REGEXP\s0 and or dot treeregexes
.SS "Array Treeregexp Expressions"
.IX Subsection "Array Treeregexp Expressions"
The Treeregexp language permits expressions like:
.PP
.Vb 1
\&                   A(@a,B($x),@c)
.Ve
.PP
After the matching variable \f(CW@A\fR contains the shortest prefix
of \f(CW\*(C`$A\->children\*(C'\fR that does not match \f(CW\*(C`B($x)\*(C'\fR.
The variable \f(CW@c\fR contains the remaining suffix of
 \f(CW\*(C`$A\->children\*(C'\fR.
.PP
The following example uses 
array treereg expressions to move the assignment \f(CW\*(C`b = 5\*(C'\fR
out of the \f(CW\*(C`while\*(C'\fR loop:
.PP
.Vb 10
\&  ..  ......................................................................
\&  93  my $program = "a =1000; c = 1; while (a) { c = c*a; b = 5; a = a\-1 }\en";
\&  94  $parser\->YYData\->{INPUT} = $program;
\&  95  my $t = $parser\->Run;
\&  96  my @output = split /\en/, $t\->str;
\&  97
\&  98  my $p = Parse::Eyapp::Treeregexp\->new( STRING => q{
\&  99    moveinvariant: BLOCK(
\& 100                     @prests,
\& 101                     WHILE(VAR($b), BLOCK(@a, ASSIGN($x, NUM($e)), @c)),
\& 102                     @possts
\& 103                   )
\& 104      => {
\& 105           my $assign = $ASSIGN;
\& 106           $BLOCK[1]\->delete($ASSIGN);
\& 107           $BLOCK[0]\->insert_before($WHILE, $assign);
\& 108         }
\& 109    },
\& 110    FIRSTLINE => 99,
\& 111  );
\& 112  $p\->generate();
.Ve
.SS "Star Treeregexp"
.IX Subsection "Star Treeregexp"
Deprecated. Don't use it. Is still there but not to endure.
.SS "Transformation Families"
.IX Subsection "Transformation Families"
Transformations created by \f(CW\*(C`Parse::Eyapp::Treeregexp\*(C'\fR can be grouped in 
families. That is the function of the rule:
.PP
.Vb 1
\&                    treeregexp: IDENT \*(Aq=\*(Aq IDENT + \*(Aq;\*(Aq
.Ve
.PP
The next example (file \f(CW\*(C`examples/TSwithtreetransformations3.eyp\*(C'\fR)
defines the family
.PP
.Vb 1
\&     algebraic_transformations = constantfold zero_times times_zero comasocfold;
.Ve
.PP
Follows the code:
.PP
.Vb 1
\&     my $transform = Parse::Eyapp::Treeregexp\->new( STRING => q{
\&
\&      uminus: UMINUS(., NUM($x), .) => { $x\->{attr} = \-$x\->{attr}; $_[0] = $NUM }
\&      constantfold: /TIMES|PLUS|DIV|MINUS/:bin(NUM($z), ., NUM($y))
\&         => {
\&        $z\->{attr} = eval  "$z\->{attr} $W\->{attr} $y\->{attr}";
\&        $_[0] = $NUM[0];
\&      }
\&      commutative_add: PLUS($x, ., $y, .)
\&        => { my $t = $x; $_[0]\->child(0, $y); $_[0]\->child(2, $t)}
\&      comasocfold: TIMES(DIV(NUM($x), ., $b), ., NUM($y))
\&         => {
\&        $x\->{attr} = $x\->{attr} * $y\->{attr};
\&        $_[0] = $DIV;
\&      }
\&      zero_times: TIMES(NUM($x), ., .) and { $x\->{attr} == 0 } => { $_[0] = $NUM }
\&      times_zero: TIMES(., ., NUM($x)) and { $x\->{attr} == 0 } => { $_[0] = $NUM }
\&      algebraic_transformations = constantfold zero_times times_zero comasocfold;
\&    },
\&    );
\&
\&    $transform\->generate();
\&    our ($uminus);
\&    $uminus\->s($tree);
.Ve
.PP
The transformations belonging to a family are usually applied 
together:
.PP
.Vb 1
\&                $tree\->s(@algebraic_transformations);
.Ve
.SS "Code Support"
.IX Subsection "Code Support"
In between Treeregexp rules and family assignments the programmer can insert 
Perl code between curly brackets. That code usually gives support to
the semantic conditions and transformations inside the rules.
See for example test 14 in the \f(CW\*(C`t/\*(C'\fR directory of the Parse::Eyapp distribution.
.PP
.Vb 7
\&  {
\&    sub not_semantic {
\&      my $self = shift;
\&      return  1 if $self\->{token} eq $self\->{attr};
\&      return 0;
\&    }
\&  }
\&
\&  delete_tokens : TERMINAL and { not_semantic($TERMINAL) } 
\&                           => { $delete_tokens\->delete() }
.Ve
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.IP "\(bu" 4
The project home is at <http://code.google.com/p/parse\-eyapp/>.
Use a subversion client to anonymously check out the latest project source code:
.Sp
.Vb 1
\&   svn checkout http://parse\-eyapp.googlecode.com/svn/trunk/ parse\-eyapp\-read\-only
.Ve
.IP "\(bu" 4
The tutorial \fIParsing Strings and Trees with\fR \f(CW\*(C`Parse::Eyapp\*(C'\fR
(An Introduction to Compiler Construction in seven pages) in
<http://nereida.deioc.ull.es/~pl/eyapsimple/>
.IP "\(bu" 4
Parse::Eyapp, 
Parse::Eyapp::eyapplanguageref, 
Parse::Eyapp::debuggingtut,
Parse::Eyapp::defaultactionsintro,
Parse::Eyapp::translationschemestut,
Parse::Eyapp::Driver,
Parse::Eyapp::Node,
Parse::Eyapp::YATW,
Parse::Eyapp::Treeregexp,
Parse::Eyapp::Scope,
Parse::Eyapp::Base,
Parse::Eyapp::datagenerationtut
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/languageintro.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/debuggingtut.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/eyapplanguageref.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/Treeregexp.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/Node.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/YATW.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/Eyapp.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/Base.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/translationschemestut.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/treematchingtut.pdf>
.IP "\(bu" 4
perldoc eyapp,
.IP "\(bu" 4
perldoc treereg,
.IP "\(bu" 4
perldoc vgg,
.IP "\(bu" 4
The Syntax Highlight file for vim at <http://www.vim.org/scripts/script.php?script_id=2453>
and <http://nereida.deioc.ull.es/~vim/>
.IP "\(bu" 4
\&\fIAnalisis Lexico y Sintactico\fR, (Notes for a course in compiler 
construction) by  Casiano Rodriguez-Leon. 
Available at  <http://nereida.deioc.ull.es/~pl/perlexamples/>
Is the more complete and reliable source for Parse::Eyapp. However is in Spanish.
.IP "\(bu" 4
Parse::Yapp,
.IP "\(bu" 4
Man pages of \fIyacc\fR\|(1) and
\&\fIbison\fR\|(1),
<http://www.delorie.com/gnu/docs/bison/bison.html>
.IP "\(bu" 4
Language::AttributeGrammar
.IP "\(bu" 4
Parse::RecDescent.
.IP "\(bu" 4
HOP::Parser
.IP "\(bu" 4
HOP::Lexer
.IP "\(bu" 4
ocamlyacc tutorial at 
<http://plus.kaist.ac.kr/~shoh/ocaml/ocamllex\-ocamlyacc/ocamlyacc\-tutorial/ocamlyacc\-tutorial.html>
.SH "REFERENCES"
.IX Header "REFERENCES"
.IP "\(bu" 4
The classic Dragon's book \fICompilers: Principles, Techniques, and Tools\fR 
by Alfred V. Aho, Ravi Sethi and
Jeffrey D. Ullman (Addison-Wesley 1986)
.IP "\(bu" 4
\&\fI\s-1CS2121:\s0 The Implementation and Power of Programming Languages\fR
(See <http://www.cs.man.ac.uk/~pjj>, <http://www.cs.man.ac.uk/~pjj/complang/g2lr.html> 
and <http://www.cs.man.ac.uk/~pjj/cs2121/ho/ho.html>) by 
Pete Jinks
.SH "CONTRIBUTORS"
.IX Header "CONTRIBUTORS"
.IP "\(bu" 2
Hal Finkel <http://www.halssoftware.com/>
.IP "\(bu" 2
G. Williams <http://kasei.us/>
.IP "\(bu" 2
Thomas L. Shinnick <http://search.cpan.org/~tshinnic/>
.IP "\(bu" 2
Frank Leray
.SH "AUTHOR"
.IX Header "AUTHOR"
Casiano Rodriguez-Leon (casiano@ull.es)
.SH "ACKNOWLEDGMENTS"
.IX Header "ACKNOWLEDGMENTS"
This work has been supported by \s-1CEE \s0(\s-1FEDER\s0) and the Spanish Ministry of
\&\fIEducacion y Ciencia\fR through \fIPlan Nacional I+D+I\fR number \s-1TIN2005\-08818\-C04\-04
\&\s0(\s-1ULL::OPLINK\s0 project <http://www.oplink.ull.es/>). 
Support from Gobierno de Canarias was through \s-1GC02210601
\&\s0(\fIGrupos Consolidados\fR).
The University of La Laguna has also supported my work in many ways
and for many years.
.PP
A large percentage of  code is verbatim taken from Parse::Yapp 1.05.
The author of Parse::Yapp is Francois Desarmenien.
.PP
I wish to thank Francois Desarmenien for his Parse::Yapp module, 
to my students at La Laguna and to the Perl Community. Thanks to 
the people who have contributed to improve the module (see \*(L"\s-1CONTRIBUTORS\*(R"\s0 in Parse::Eyapp).
Thanks to Larry Wall for giving us Perl.
Special thanks to Juana.
.SH "LICENCE AND COPYRIGHT"
.IX Header "LICENCE AND COPYRIGHT"
Copyright (c) 2006\-2008 Casiano Rodriguez-Leon (casiano@ull.es). All rights reserved.
.PP
Parse::Yapp copyright is of Francois Desarmenien, all rights reserved. 1998\-2001
.PP
These modules are free software; you can redistribute it and/or
modify it under the same terms as Perl itself. See perlartistic.
.PP
This program is distributed in the hope that it will be useful,
but \s-1WITHOUT ANY WARRANTY\s0; without even the implied warranty of
\&\s-1MERCHANTABILITY\s0 or \s-1FITNESS FOR A PARTICULAR PURPOSE. \s0
