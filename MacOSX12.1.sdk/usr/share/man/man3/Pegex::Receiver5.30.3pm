.\" Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Pegex::Receiver 3"
.TH Pegex::Receiver 3 "2020-02-13" "perl v5.30.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Pegex::Receiver \- Base Class for All Pegex Receivers
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&    package MyReceiver;
\&    use base \*(AqPegex::Receiver\*(Aq;
\&
\&    # Handle data for a specific rule
\&    sub got_somerulename {
\&        my ($self, $got) = @_;
\&        # ... process ...
\&        return $result;
\&    }
\&
\&    # Handle data for any other rule
\&    sub gotrule {
\&        my ($self, $got) = @_;
\&        return $result;
\&    }
\&
\&    # Pre\-process
\&    sub initial { ... }
\&
\&    # Post\-process
\&    sub final {
\&        ...;
\&        return $final_result;
\&    }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
In Pegex, a \fBreceiver\fR is the class object that a \fBparser\fR passes captured
data to when a \fBrule\fR in a \fBgrammar\fR matches a part of an \fBinput\fR stream. A
receiver provides \fBaction methods\fR to turn parsed data into what the parser
is intended to do.
.PP
This is the base class of all Pegex receiver classes.
.PP
It doesn't do much of anything, which is the correct thing to do. If you use
this class as your receiver if won't do any extra work. See Pegex::Tree for
a receiver base class that will help organize your matches by default.
.SS "How A Receiver Works"
.IX Subsection "How A Receiver Works"
A Pegex grammar is made up of \fBnamed-rules\fR, \fBregexes\fR, and \fBgroups\fR. When
a \fBregex\fR matches, the parser makes array of its capture strings. When a
\&\fBgroup\fR matches, the parser makes an array of all the submatch arrays. In
this way a \fBparse tree\fR forms.
.PP
When a \fBnamed-rule\fR matches, an action method is called in the receiver
class. The method is passed the current \fBparse tree\fR and returns what parser
will consider the new parse tree.
.PP
This makes for a very elegant and understandable \s-1API.\s0
.SH "API"
.IX Header "API"
This section documents the methods that you can include in receiver subclass.
.ie n .IP """got_$rulename($got)""" 4
.el .IP "\f(CWgot_$rulename($got)\fR" 4
.IX Item "got_$rulename($got)"
An action method for a specific, named rule.
.Sp
.Vb 5
\&    sub got_rule42 {
\&        my ($self, $got) = @_;
\&        ...
\&        return $result;
\&    }
.Ve
.Sp
The \f(CW$got\fR value that is passed in is the current value of the parse tree.
What gets returned is whatever you want to new value to be.
.ie n .IP """gotrule($got)""" 4
.el .IP "\f(CWgotrule($got)\fR" 4
.IX Item "gotrule($got)"
The action method for a named rule that does not have a specific action
method.
.ie n .IP """initial()""" 4
.el .IP "\f(CWinitial()\fR" 4
.IX Item "initial()"
Called at the beginning of a parse operation, before the parsing begins.
.ie n .IP """final($got)""" 4
.el .IP "\f(CWfinal($got)\fR" 4
.IX Item "final($got)"
Called at the end of a parse operation. Whatever this action returns, will be
the result of the parse.
.SS "Methods"
.IX Subsection "Methods"
.ie n .IP """parser""" 4
.el .IP "\f(CWparser\fR" 4
.IX Item "parser"
An attribute containing the parser object that is currently running. This can
be very useful to introspect what is happening, and possibly modify the
grammar on the fly. (Experts only!)
.ie n .IP """flatten($array)""" 4
.el .IP "\f(CWflatten($array)\fR" 4
.IX Item "flatten($array)"
A utility method that can turn an array of arrays into a single array.
For example:
.Sp
.Vb 2
\&    $self\->flatten([1, [2, [3, 4], 5], 6]);
\&    # produces [1, 2, 3, 4, 5, 6]
.Ve
.Sp
Hashes are left unchanged. The array is modified in place, but is also the
return value.
.SH "AUTHOR"
.IX Header "AUTHOR"
Ingy döt Net <ingy@cpan.org>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright 2010\-2020. Ingy döt Net.
.PP
This program is free software; you can redistribute it and/or modify it under
the same terms as Perl itself.
.PP
See <http://www.perl.com/perl/misc/Artistic.html>
