.\" Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "URI::file 3"
.TH URI::file 3 "2019-01-09" "perl v5.30.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
URI::file \- URI that maps to local file names
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& use URI::file;
\& 
\& $u1 = URI\->new("file:/foo/bar");
\& $u2 = URI\->new("foo/bar", "file");
\& 
\& $u3 = URI::file\->new($path);
\& $u4 = URI::file\->new("c:\e\ewindows\e\e", "win32");
\& 
\& $u1\->file;
\& $u1\->file("mac");
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The \f(CW\*(C`URI::file\*(C'\fR class supports \f(CW\*(C`URI\*(C'\fR objects belonging to the \fIfile\fR
\&\s-1URI\s0 scheme.  This scheme allows us to map the conventional file names
found on various computer systems to the \s-1URI\s0 name space.  An old
specification of the \fIfile\fR \s-1URI\s0 scheme is found in \s-1RFC 1738.\s0  Some
older background information is also in \s-1RFC 1630.\s0 There are no newer
specifications as far as I know.
.PP
If you simply want to construct \fIfile\fR \s-1URI\s0 objects from \s-1URI\s0 strings,
use the normal \f(CW\*(C`URI\*(C'\fR constructor.  If you want to construct \fIfile\fR
\&\s-1URI\s0 objects from the actual file names used by various systems, then
use one of the following \f(CW\*(C`URI::file\*(C'\fR constructors:
.ie n .IP "$u = URI::file\->new( $filename, [$os] )" 4
.el .IP "\f(CW$u\fR = URI::file\->new( \f(CW$filename\fR, [$os] )" 4
.IX Item "$u = URI::file->new( $filename, [$os] )"
Maps a file name to the \fIfile:\fR \s-1URI\s0 name space, creates a \s-1URI\s0 object
and returns it.  The \f(CW$filename\fR is interpreted as belonging to the
indicated operating system ($os), which defaults to the value of the
$^O variable.  The \f(CW$filename\fR can be either absolute or relative, and
the corresponding type of \s-1URI\s0 object for \f(CW$os\fR is returned.
.ie n .IP "$u = URI::file\->new_abs( $filename, [$os] )" 4
.el .IP "\f(CW$u\fR = URI::file\->new_abs( \f(CW$filename\fR, [$os] )" 4
.IX Item "$u = URI::file->new_abs( $filename, [$os] )"
Same as URI::file\->new, but makes sure that the \s-1URI\s0 returned
represents an absolute file name.  If the \f(CW$filename\fR argument is
relative, then the name is resolved relative to the current directory,
i.e. this constructor is really the same as:
.Sp
.Vb 1
\&  URI::file\->new($filename)\->abs(URI::file\->cwd);
.Ve
.ie n .IP "$u = URI::file\->cwd" 4
.el .IP "\f(CW$u\fR = URI::file\->cwd" 4
.IX Item "$u = URI::file->cwd"
Returns a \fIfile\fR \s-1URI\s0 that represents the current working directory.
See Cwd.
.PP
The following methods are supported for \fIfile\fR \s-1URI\s0 (in addition to
the common and generic methods described in \s-1URI\s0):
.ie n .IP "$u\->file( [$os] )" 4
.el .IP "\f(CW$u\fR\->file( [$os] )" 4
.IX Item "$u->file( [$os] )"
Returns a file name.  It maps from the \s-1URI\s0 name space
to the file name space of the indicated operating system.
.Sp
It might return \f(CW\*(C`undef\*(C'\fR if the name can not be represented in the
indicated file system.
.ie n .IP "$u\->dir( [$os] )" 4
.el .IP "\f(CW$u\fR\->dir( [$os] )" 4
.IX Item "$u->dir( [$os] )"
Some systems use a different form for names of directories than for plain
files.  Use this method if you know you want to use the name for
a directory.
.PP
The \f(CW\*(C`URI::file\*(C'\fR module can be used to map generic file names to names
suitable for the current system.  As such, it can work as a nice
replacement for the \f(CW\*(C`File::Spec\*(C'\fR module.  For instance, the following
code translates the UNIX-style file name \fIFoo/Bar.pm\fR to a name
suitable for the local system:
.PP
.Vb 4
\&  $file = URI::file\->new("Foo/Bar.pm", "unix")\->file;
\&  die "Can\*(Aqt map filename Foo/Bar.pm for $^O" unless defined $file;
\&  open(FILE, $file) || die "Can\*(Aqt open \*(Aq$file\*(Aq: $!";
\&  # do something with FILE
.Ve
.SH "MAPPING NOTES"
.IX Header "MAPPING NOTES"
Most computer systems today have hierarchically organized file systems.
Mapping the names used in these systems to the generic \s-1URI\s0 syntax
allows us to work with relative file URIs that behave as they should
when resolved using the generic algorithm for URIs (specified in \s-1RFC
2396\s0).  Mapping a file name to the generic \s-1URI\s0 syntax involves mapping
the path separator character to \*(L"/\*(R" and encoding any reserved
characters that appear in the path segments of the file name.  If
path segments consisting of the strings \*(L".\*(R" or \*(L"..\*(R" have a
different meaning than what is specified for generic URIs, then these
must be encoded as well.
.PP
If the file system has device, volume or drive specifications as
the root of the name space, then it makes sense to map them to the
authority field of the generic \s-1URI\s0 syntax.  This makes sure that
relative URIs can not be resolved \*(L"above\*(R" them, i.e. generally how
relative file names work in those systems.
.PP
Another common use of the authority field is to encode the host on which
this file name is valid.  The host name \*(L"localhost\*(R" is special and
generally has the same meaning as a missing or empty authority
field.  This use is in conflict with using it as a device
specification, but can often be resolved for device specifications
having characters not legal in plain host names.
.PP
File name to \s-1URI\s0 mapping in normally not one-to-one.  There are
usually many URIs that map to any given file name.  For instance, an
authority of \*(L"localhost\*(R" maps the same as a \s-1URI\s0 with a missing or empty
authority.
.PP
Example 1: The Mac classic (Mac \s-1OS 9\s0 and earlier) used \*(L":\*(R" as path separator,
but not in the same way as a generic \s-1URI.\s0 \*(L":foo\*(R" was a relative name.  \*(L"foo:bar\*(R"
was an absolute name.  Also, path segments could contain the \*(L"/\*(R" character as well
as the literal \*(L".\*(R" or \*(L"..\*(R".  So the mapping looks like this:
.PP
.Vb 12
\&  Mac classic           URI
\&  \-\-\-\-\-\-\-\-\-\-            \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&  :foo:bar     <==>     foo/bar
\&  :            <==>     ./
\&  ::foo:bar    <==>     ../foo/bar
\&  :::          <==>     ../../
\&  foo:bar      <==>     file:/foo/bar
\&  foo:bar:     <==>     file:/foo/bar/
\&  ..           <==>     %2E%2E
\&  <undef>      <==      /
\&  foo/         <==      file:/foo%2F
\&  ./foo.txt    <==      file:/.%2Ffoo.txt
.Ve
.PP
Note that if you want a relative \s-1URL,\s0 you *must* begin the path with a :.  Any
path that begins with [^:] is treated as absolute.
.PP
Example 2: The \s-1UNIX\s0 file system is easy to map, as it uses the same path
separator as URIs, has a single root, and segments of \*(L".\*(R" and \*(L"..\*(R"
have the same meaning.  URIs that have the character \*(L"\e0\*(R" or \*(L"/\*(R" as
part of any path segment can not be turned into valid \s-1UNIX\s0 file names.
.PP
.Vb 8
\&  UNIX                  URI
\&  \-\-\-\-\-\-\-\-\-\-            \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&  foo/bar      <==>     foo/bar
\&  /foo/bar     <==>     file:/foo/bar
\&  /foo/bar     <==      file://localhost/foo/bar
\&  file:         ==>     ./file:
\&  <undef>      <==      file:/fo%00/bar
\&  /            <==>     file:/
.Ve
.SH "CONFIGURATION VARIABLES"
.IX Header "CONFIGURATION VARIABLES"
The following configuration variables influence how the class and its
methods behave:
.ie n .IP "%URI::file::OS_CLASS" 4
.el .IP "\f(CW%URI::file::OS_CLASS\fR" 4
.IX Item "%URI::file::OS_CLASS"
This hash maps \s-1OS\s0 identifiers to implementation classes.  You might
want to add or modify this if you want to plug in your own file
handler class.  Normally the keys should match the $^O values in use.
.Sp
If there is no mapping then the \*(L"Unix\*(R" implementation is used.
.ie n .IP "$URI::file::DEFAULT_AUTHORITY" 4
.el .IP "\f(CW$URI::file::DEFAULT_AUTHORITY\fR" 4
.IX Item "$URI::file::DEFAULT_AUTHORITY"
This determine what \*(L"authority\*(R" string to include in absolute file
URIs.  It defaults to "\*(L".  If you prefer verbose URIs you might set it
to be \*(R"localhost".
.Sp
Setting this value to \f(CW\*(C`undef\*(C'\fR force behaviour compatible to \s-1URI\s0 v1.31
and earlier.  In this mode host names in \s-1UNC\s0 paths and drive letters
are mapped to the authority component on Windows, while we produce
authority-less URIs on Unix.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\s-1URI\s0, File::Spec, perlport
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright 1995\-1998,2004 Gisle Aas.
.PP
This library is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.
