.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Encode::Alias 3pm"
.TH Encode::Alias 3pm "2014-09-30" "perl v5.18.4" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Encode::Alias \- alias definitions to encodings
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 5
\&  use Encode;
\&  use Encode::Alias;
\&  define_alias( "newName" => ENCODING);
\&  define_alias( qr/.../ => ENCODING);
\&  define_alias( sub { return ENCODING if ...; } );
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Allows newName to be used as an alias for \s-1ENCODING. ENCODING\s0 may be
either the name of an encoding or an encoding object (as described 
in Encode).
.PP
Currently the first argument to \fIdefine_alias()\fR can be specified in the
following ways:
.IP "As a simple string." 4
.IX Item "As a simple string."
.PD 0
.IP "As a qr// compiled regular expression, e.g.:" 4
.IX Item "As a qr// compiled regular expression, e.g.:"
.PD
.Vb 1
\&  define_alias( qr/^iso8859\-(\ed+)$/i => \*(Aq"iso\-8859\-$1"\*(Aq );
.Ve
.Sp
In this case, if \fI\s-1ENCODING\s0\fR is not a reference, it is \f(CW\*(C`eval\*(C'\fR\-ed
in order to allow \f(CW$1\fR etc. to be substituted.  The example is one
way to alias names as used in X11 fonts to the \s-1MIME\s0 names for the
iso\-8859\-* family.  Note the double quotes inside the single quotes.
.Sp
(or, you don't have to do this yourself because this example is predefined)
.Sp
If you are using a regex here, you have to use the quotes as shown or
it won't work.  Also note that regex handling is tricky even for the
experienced.  Use this feature with caution.
.IP "As a code reference, e.g.:" 4
.IX Item "As a code reference, e.g.:"
.Vb 1
\&  define_alias( sub {shift =~ /^iso8859\-(\ed+)$/i ? "iso\-8859\-$1" : undef } );
.Ve
.Sp
The same effect as the example above in a different way.  The coderef
takes the alias name as an argument and returns a canonical name on
success or undef if not.  Note the second argument is ignored if provided.
Use this with even more caution than the regex version.
.PP
\fIChanges in code reference aliasing\fR
.IX Subsection "Changes in code reference aliasing"
.PP
As of Encode 1.87, the older form
.PP
.Vb 1
\&  define_alias( sub { return  /^iso8859\-(\ed+)$/i ? "iso\-8859\-$1" : undef } );
.Ve
.PP
no longer works.
.PP
Encode up to 1.86 internally used \*(L"local \f(CW$_\fR\*(R" to implement ths older
form.  But consider the code below;
.PP
.Vb 6
\&  use Encode;
\&  $_ = "eeeee" ;
\&  while (/(e)/g) {
\&    my $utf = decode(\*(Aqaliased\-encoding\-name\*(Aq, $1);
\&    print "position:",pos,"\en";
\&  }
.Ve
.PP
Prior to Encode 1.86 this fails because of \*(L"local \f(CW$_\fR\*(R".
.SS "Alias overloading"
.IX Subsection "Alias overloading"
You can override predefined aliases by simply applying \fIdefine_alias()\fR.
The new alias is always evaluated first, and when necessary,
\&\fIdefine_alias()\fR flushes the internal cache to make the new definition
available.
.PP
.Vb 2
\&  # redirect SHIFT_JIS to MS/IBM Code Page 932, which is a
\&  # superset of SHIFT_JIS
\&
\&  define_alias( qr/shift.*jis$/i  => \*(Aq"cp932"\*(Aq );
\&  define_alias( qr/sjis$/i        => \*(Aq"cp932"\*(Aq );
.Ve
.PP
If you want to zap all predefined aliases, you can use
.PP
.Vb 1
\&  Encode::Alias\->undef_aliases;
.Ve
.PP
to do so.  And
.PP
.Vb 1
\&  Encode::Alias\->init_aliases;
.Ve
.PP
gets the factory settings back.
.PP
Note that \fIdefine_alias()\fR will not be able to override the canonical name
of encodings. Encodings are first looked up by canonical name before
potential aliases are tried.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Encode, Encode::Supported
