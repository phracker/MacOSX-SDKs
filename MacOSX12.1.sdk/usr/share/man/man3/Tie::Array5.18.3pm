.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Tie::Array 3pm"
.TH Tie::Array 3pm "2014-09-30" "perl v5.18.4" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Tie::Array \- base class for tied arrays
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 3
\&    package Tie::NewArray;
\&    use Tie::Array;
\&    @ISA = (\*(AqTie::Array\*(Aq);
\&
\&    # mandatory methods
\&    sub TIEARRAY { ... }
\&    sub FETCH { ... }
\&    sub FETCHSIZE { ... }
\&
\&    sub STORE { ... }        # mandatory if elements writeable
\&    sub STORESIZE { ... }    # mandatory if elements can be added/deleted
\&    sub EXISTS { ... }       # mandatory if exists() expected to work
\&    sub DELETE { ... }       # mandatory if delete() expected to work
\&
\&    # optional methods \- for efficiency
\&    sub CLEAR { ... }
\&    sub PUSH { ... }
\&    sub POP { ... }
\&    sub SHIFT { ... }
\&    sub UNSHIFT { ... }
\&    sub SPLICE { ... }
\&    sub EXTEND { ... }
\&    sub DESTROY { ... }
\&
\&    package Tie::NewStdArray;
\&    use Tie::Array;
\&
\&    @ISA = (\*(AqTie::StdArray\*(Aq);
\&
\&    # all methods provided by default
\&
\&    package main;
\&
\&    $object = tie @somearray,\*(AqTie::NewArray\*(Aq;
\&    $object = tie @somearray,\*(AqTie::StdArray\*(Aq;
\&    $object = tie @somearray,\*(AqTie::NewStdArray\*(Aq;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module provides methods for array-tying classes. See
perltie for a list of the functions required in order to tie an array
to a package. The basic \fBTie::Array\fR package provides stub \f(CW\*(C`DESTROY\*(C'\fR,
and \f(CW\*(C`EXTEND\*(C'\fR methods that do nothing, stub \f(CW\*(C`DELETE\*(C'\fR and \f(CW\*(C`EXISTS\*(C'\fR
methods that \fIcroak()\fR if the \fIdelete()\fR or \fIexists()\fR builtins are ever called
on the tied array, and implementations of \f(CW\*(C`PUSH\*(C'\fR, \f(CW\*(C`POP\*(C'\fR, \f(CW\*(C`SHIFT\*(C'\fR,
\&\f(CW\*(C`UNSHIFT\*(C'\fR, \f(CW\*(C`SPLICE\*(C'\fR and \f(CW\*(C`CLEAR\*(C'\fR in terms of basic \f(CW\*(C`FETCH\*(C'\fR, \f(CW\*(C`STORE\*(C'\fR,
\&\f(CW\*(C`FETCHSIZE\*(C'\fR, \f(CW\*(C`STORESIZE\*(C'\fR.
.PP
The \fBTie::StdArray\fR package provides efficient methods required for tied arrays
which are implemented as blessed references to an \*(L"inner\*(R" perl array.
It inherits from \fBTie::Array\fR, and should cause tied arrays to behave exactly
like standard arrays, allowing for selective overloading of methods.
.PP
For developers wishing to write their own tied arrays, the required methods
are briefly defined below. See the perltie section for more detailed
descriptive, as well as example code:
.IP "\s-1TIEARRAY\s0 classname, \s-1LIST\s0" 4
.IX Item "TIEARRAY classname, LIST"
The class method is invoked by the command \f(CW\*(C`tie @array, classname\*(C'\fR. Associates
an array instance with the specified class. \f(CW\*(C`LIST\*(C'\fR would represent
additional arguments (along the lines of AnyDBM_File and compatriots) needed
to complete the association. The method should return an object of a class which
provides the methods below.
.IP "\s-1STORE\s0 this, index, value" 4
.IX Item "STORE this, index, value"
Store datum \fIvalue\fR into \fIindex\fR for the tied array associated with
object \fIthis\fR. If this makes the array larger then
class's mapping of \f(CW\*(C`undef\*(C'\fR should be returned for new positions.
.IP "\s-1FETCH\s0 this, index" 4
.IX Item "FETCH this, index"
Retrieve the datum in \fIindex\fR for the tied array associated with
object \fIthis\fR.
.IP "\s-1FETCHSIZE\s0 this" 4
.IX Item "FETCHSIZE this"
Returns the total number of items in the tied array associated with
object \fIthis\fR. (Equivalent to \f(CW\*(C`scalar(@array)\*(C'\fR).
.IP "\s-1STORESIZE\s0 this, count" 4
.IX Item "STORESIZE this, count"
Sets the total number of items in the tied array associated with
object \fIthis\fR to be \fIcount\fR. If this makes the array larger then
class's mapping of \f(CW\*(C`undef\*(C'\fR should be returned for new positions.
If the array becomes smaller then entries beyond count should be
deleted.
.IP "\s-1EXTEND\s0 this, count" 4
.IX Item "EXTEND this, count"
Informative call that array is likely to grow to have \fIcount\fR entries.
Can be used to optimize allocation. This method need do nothing.
.IP "\s-1EXISTS\s0 this, key" 4
.IX Item "EXISTS this, key"
Verify that the element at index \fIkey\fR exists in the tied array \fIthis\fR.
.Sp
The \fBTie::Array\fR implementation is a stub that simply croaks.
.IP "\s-1DELETE\s0 this, key" 4
.IX Item "DELETE this, key"
Delete the element at index \fIkey\fR from the tied array \fIthis\fR.
.Sp
The \fBTie::Array\fR implementation is a stub that simply croaks.
.IP "\s-1CLEAR\s0 this" 4
.IX Item "CLEAR this"
Clear (remove, delete, ...) all values from the tied array associated with
object \fIthis\fR.
.IP "\s-1DESTROY\s0 this" 4
.IX Item "DESTROY this"
Normal object destructor method.
.IP "\s-1PUSH\s0 this, \s-1LIST\s0" 4
.IX Item "PUSH this, LIST"
Append elements of \s-1LIST\s0 to the array.
.IP "\s-1POP\s0 this" 4
.IX Item "POP this"
Remove last element of the array and return it.
.IP "\s-1SHIFT\s0 this" 4
.IX Item "SHIFT this"
Remove the first element of the array (shifting other elements down)
and return it.
.IP "\s-1UNSHIFT\s0 this, \s-1LIST\s0" 4
.IX Item "UNSHIFT this, LIST"
Insert \s-1LIST\s0 elements at the beginning of the array, moving existing elements
up to make room.
.IP "\s-1SPLICE\s0 this, offset, length, \s-1LIST\s0" 4
.IX Item "SPLICE this, offset, length, LIST"
Perform the equivalent of \f(CW\*(C`splice\*(C'\fR on the array.
.Sp
\&\fIoffset\fR is optional and defaults to zero, negative values count back
from the end of the array.
.Sp
\&\fIlength\fR is optional and defaults to rest of the array.
.Sp
\&\fI\s-1LIST\s0\fR may be empty.
.Sp
Returns a list of the original \fIlength\fR elements at \fIoffset\fR.
.SH "CAVEATS"
.IX Header "CAVEATS"
There is no support at present for tied \f(CW@ISA\fR. There is a potential conflict
between magic entries needed to notice setting of \f(CW@ISA\fR, and those needed to
implement 'tie'.
.SH "AUTHOR"
.IX Header "AUTHOR"
Nick Ing-Simmons <nik@tiuk.ti.com>
