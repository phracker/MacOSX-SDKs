.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PPI::Transform 3"
.TH PPI::Transform 3 "2011-02-25" "perl v5.18.4" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
PPI::Transform \- Abstract base class for document transformation classes
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\f(CW\*(C`PPI::Transform\*(C'\fR provides an \s-1API\s0 for the creation of classes and objects
that modify or transform \s-1PPI\s0 documents.
.SH "METHODS"
.IX Header "METHODS"
.SS "new"
.IX Subsection "new"
.Vb 4
\&  my $transform = PPI::Transform\->new(
\&      param1 => \*(Aqvalue1\*(Aq,
\&      param2 => \*(Aqvalue2\*(Aq,
\&  );
.Ve
.PP
The \f(CW\*(C`new\*(C'\fR constructor creates a new object for your \f(CW\*(C`PPI::Transform\*(C'\fR
subclass. A default constructor is provided for you which takes no params
and creates a basic, empty, object.
.PP
If you wish to have your transform constructor take params, these \fBmust\fR
be in the form of a list of key/value pairs.
.PP
Returns a new \f(CW\*(C`PPI::Transform\*(C'\fR\-compatible object, or returns
\&\f(CW\*(C`undef\*(C'\fR on error.
.SS "document"
.IX Subsection "document"
The \f(CW\*(C`document\*(C'\fR method should be implemented by each subclass, and
takes a single argument of a PPI::Document object, modifying it
\&\fBin place\fR as appropriate for the particular transform class.
.PP
That's right, this method \fBwill not clone\fR and \fBshould not clone\fR
the document object. If you do not want the original to be modified,
you need to clone it yourself before passing it in.
.PP
Returns the numbers of changes made to the document. If the transform
is unable to track the quantity (including the situation where it cannot
tell \fB\s-1IF\s0\fR it made a change) it should return 1. Returns zero if no
changes were made to the document, or \f(CW\*(C`undef\*(C'\fR if an error occurs.
.PP
By default this error is likely to only mean that you passed in something
that wasn't a PPI::Document, but may include additional errors
depending on the subclass.
.SS "apply"
.IX Subsection "apply"
The \f(CW\*(C`apply\*(C'\fR method is used to apply the transform to something. The
argument must be a PPI::Document, or something which can be turned
into a one and then be written back to again.
.PP
Currently, this list is limited to a \f(CW\*(C`SCALAR\*(C'\fR reference, although a
handler registration process is available for you to add support for
additional types of object should you wish (see the source for this module).
.PP
Returns true if the transform was applied, false if there is an error in the
transform process, or may die if there is a critical error in the apply
handler.
.SS "file"
.IX Subsection "file"
.Vb 2
\&  # Read from one file and write to another
\&  $transform\->file( \*(AqInput.pm\*(Aq => \*(AqOutput.pm\*(Aq );
\&  
\&  # Change a file in place
\&  $transform\->file( \*(AqChange.pm\*(Aq );
.Ve
.PP
The \f(CW\*(C`file\*(C'\fR method modifies a Perl document by filename. If passed a single
parameter, it modifies the file in-place. If provided a second parameter,
it will attempt to save the modified file to the alternative filename.
.PP
Returns true on success, or \f(CW\*(C`undef\*(C'\fR on error.
.SH "SUPPORT"
.IX Header "SUPPORT"
See the support section in the main module.
.SH "AUTHOR"
.IX Header "AUTHOR"
Adam Kennedy <adamk@cpan.org>
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright 2001 \- 2011 Adam Kennedy.
.PP
This program is free software; you can redistribute
it and/or modify it under the same terms as Perl itself.
.PP
The full text of the license can be found in the
\&\s-1LICENSE\s0 file included with this module.
