.\" Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "install::TempContent::Objects::mod_perl-2.0.9::docs::api::ModPerl::RegistryCooker 3"
.TH install::TempContent::Objects::mod_perl-2.0.9::docs::api::ModPerl::RegistryCooker 3 "2015-06-18" "perl v5.30.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
ModPerl::RegistryCooker \- Cook mod_perl 2.0 Registry Modules
.SH "Synopsis"
.IX Header "Synopsis"
.Vb 2
\&  # shouldn\*(Aqt be used as\-is but sub\-classed first
\&  # see ModPerl::Registry for an example
.Ve
.SH "Description"
.IX Header "Description"
\&\f(CW\*(C`ModPerl::RegistryCooker\*(C'\fR is used to create flexible and overridable
registry modules which emulate mod_cgi for Perl scripts. The concepts
are discussed in the manpage of the following modules:
\&\f(CW\*(C`ModPerl::Registry\*(C'\fR, \f(CW\*(C`ModPerl::Registry\*(C'\fR and
\&\f(CW\*(C`ModPerl::RegistryBB\*(C'\fR.
.PP
\&\f(CW\*(C`ModPerl::RegistryCooker\*(C'\fR has two purposes:
.IP "\(bu" 4
Provide ingredients that can be used by registry sub-classes
.IP "\(bu" 4
Provide a default behavior, which can be overriden in sub-classed
.Sp
\&\s-1META:\s0 in the future this functionality may move into a separate class.
.PP
Here are the current overridable methods:
.PP
\&\s-1META:\s0 these are all documented in RegistryCooker.pm, though not using
pod. please help to port these to pod and move the descriptions here.
.IP "\(bu" 4
\&\fBnew()\fR
.Sp
create the class's object, bless it and return it
.Sp
.Vb 1
\&  my $obj = $class\->new($r);
.Ve
.Sp
\&\f(CW$class\fR \*(-- the registry class, usually \f(CW\*(C`_\|_PACKAGE_\|_\*(C'\fR can be used.
.Sp
\&\f(CW$r\fR \*(-- \f(CW\*(C`Apache2::Request\*(C'\fR object.
.Sp
default: \fBnew()\fR
.IP "\(bu" 4
\&\fBinit()\fR
.Sp
initializes the data object's fields: \f(CW\*(C`REQ\*(C'\fR, \f(CW\*(C`FILENAME\*(C'\fR,
\&\f(CW\*(C`URI\*(C'\fR. Called from the \fBnew()\fR.
.Sp
default: \fBinit()\fR
.IP "\(bu" 4
\&\fBdefault_handler()\fR
.Sp
default:  \fBdefault_handler()\fR
.IP "\(bu" 4
\&\fBrun()\fR
.Sp
default: \fBrun()\fR
.IP "\(bu" 4
\&\fBcan_compile()\fR
.Sp
default: \fBcan_compile()\fR
.IP "\(bu" 4
\&\fBmake_namespace()\fR
.Sp
default: \fBmake_namespace()\fR
.IP "\(bu" 4
\&\fBnamespace_root()\fR
.Sp
default: \fBnamespace_root()\fR
.IP "\(bu" 4
\&\fBnamespace_from()\fR
.Sp
If \f(CW\*(C`namespace_from_uri\*(C'\fR is used and the script is called from the
virtual host, by default the virtual host name is prepended to the uri
when package name for the compiled script is created. Sometimes this
behavior is undesirable, e.g., when the same (physical) script is
accessed using the same path_info but different virtual hosts. In that
case you can make the script compiled only once for all vhosts, by
specifying:
.Sp
.Vb 1
\&  $ModPerl::RegistryCooker::NameWithVirtualHost = 0;
.Ve
.Sp
The drawback is that it affects the global environment and all other
scripts will be compiled ignoring virtual hosts.
.Sp
default: \fBnamespace_from()\fR
.IP "\(bu" 4
\&\fBis_cached()\fR
.Sp
default: \fBis_cached()\fR
.IP "\(bu" 4
\&\fBshould_compile()\fR
.Sp
default: \fBshould_compile()\fR
.IP "\(bu" 4
\&\fBflush_namespace()\fR
.Sp
default: \fBflush_namespace()\fR
.IP "\(bu" 4
\&\fBcache_table()\fR
.Sp
default: \fBcache_table()\fR
.IP "\(bu" 4
\&\fBcache_it()\fR
.Sp
default: \fBcache_it()\fR
.IP "\(bu" 4
\&\fBread_script()\fR
.Sp
default: \fBread_script()\fR
.IP "\(bu" 4
\&\fBshebang_to_perl()\fR
.Sp
default: \fBshebang_to_perl()\fR
.IP "\(bu" 4
\&\fBget_script_name()\fR
.Sp
default: \fBget_script_name()\fR
.IP "\(bu" 4
\&\fBchdir_file()\fR
.Sp
default: \fBchdir_file()\fR
.IP "\(bu" 4
\&\fBget_mark_line()\fR
.Sp
default: \fBget_mark_line()\fR
.IP "\(bu" 4
\&\fBcompile()\fR
.Sp
default: \fBcompile()\fR
.IP "\(bu" 4
\&\fBerror_check()\fR
.Sp
default: \fBerror_check()\fR
.IP "\(bu" 4
\&\fBstrip_end_data_segment()\fR
.Sp
default: \fBstrip_end_data_segment()\fR
.IP "\(bu" 4
\&\fBconvert_script_to_compiled_handler()\fR
.Sp
default: \fBconvert_script_to_compiled_handler()\fR
.SS "Special Predefined Functions"
.IX Subsection "Special Predefined Functions"
The following functions are implemented as constants.
.IP "\(bu" 4
\&\s-1\fBNOP\s0()\fR
.Sp
Use when the function shouldn't do anything.
.IP "\(bu" 4
\&\s-1\fBTRUE\s0()\fR
.Sp
Use when a function should always return a true value.
.IP "\(bu" 4
\&\s-1\fBFALSE\s0()\fR
.Sp
Use when a function should always return a false value.
.SH "Sub-classing Techniques"
.IX Header "Sub-classing Techniques"
To override the default \f(CW\*(C`ModPerl::RegistryCooker\*(C'\fR methods, first,
sub-class \f(CW\*(C`ModPerl::RegistryCooker\*(C'\fR or one of its existing
sub-classes, using \f(CW\*(C`use base\*(C'\fR. Second, override the methods.
.PP
Those methods that weren't overridden will be resolved at run time
when used for the first time and cached for the future requests. One
way to to shortcut this first run resolution is to use the symbol
aliasing feature. For example to alias \f(CW\*(C`ModPerl::MyRegistry::flush_namespace\*(C'\fR
as \f(CW\*(C`ModPerl::RegistryCooker::flush_namespace\*(C'\fR, you can do:
.PP
.Vb 5
\&  package ModPerl::MyRegistry;
\&  use base qw(ModPerl::RegistryCooker);
\&  *ModPerl::MyRegistry::flush_namespace =
\&      \e&ModPerl::RegistryCooker::flush_namespace;
\&  1;
.Ve
.PP
In fact, it's a good idea to explicitly alias all the methods so you
know exactly what functions are used, rather then relying on the
defaults. For that purpose \f(CW\*(C`ModPerl::RegistryCooker\*(C'\fR class method
\&\fBinstall_aliases()\fR can be used. Simply prepare a hash with method names
in the current package as keys and corresponding fully qualified
methods to be aliased for as values and pass it to
\&\fBinstall_aliases()\fR. Continuing our example we could do:
.PP
.Vb 7
\&  package ModPerl::MyRegistry;
\&  use base qw(ModPerl::RegistryCooker);
\&  my %aliases = (
\&      flush_namespace => \*(AqModPerl::RegistryCooker::flush_namespace\*(Aq,
\&  );
\&  _\|_PACKAGE_\|_\->install_aliases(\e%aliases);
\&  1;
.Ve
.PP
The values use fully qualified packages so you can mix methods from
different classes.
.SH "Examples"
.IX Header "Examples"
The best examples are existing core registry modules:
\&\f(CW\*(C`ModPerl::Registry\*(C'\fR, \f(CW\*(C`ModPerl::Registry\*(C'\fR and
\&\f(CW\*(C`ModPerl::RegistryBB\*(C'\fR. Look at the source code and their manpages
to see how they subclass \f(CW\*(C`ModPerl::RegistryCooker\*(C'\fR.
.PP
For example by default \f(CW\*(C`ModPerl::Registry\*(C'\fR uses the script's path
when creating a package's namespace. If for example you want to use a
uri instead you can override it with:
.PP
.Vb 3
\&  *ModPerl::MyRegistry::namespace_from =
\&      \e&ModPerl::RegistryCooker::namespace_from_uri;
\&  1;
.Ve
.PP
Since the \f(CW\*(C`namespace_from_uri\*(C'\fR component already exists in
\&\f(CW\*(C`ModPerl::RegistryCooker\*(C'\fR. If you want to write your own method,
e.g., that creates a namespace based on the inode, you can do:
.PP
.Vb 4
\&  sub namespace_from_inode {
\&      my $self = shift;
\&      return (stat $self\->[FILENAME])[1];
\&  }
.Ve
.PP
\&\s-1META:\s0 when \f(CW$r\fR\->finfo will be ported it'll be more effecient. 
(stat \f(CW$r\fR\->finfo)[1]
.SH "Authors"
.IX Header "Authors"
Doug MacEachern
.PP
Stas Bekman
.SH "See Also"
.IX Header "See Also"
\&\f(CW\*(C`ModPerl::Registry\*(C'\fR,
\&\f(CW\*(C`ModPerl::RegistryBB\*(C'\fR and
\&\f(CW\*(C`ModPerl::PerlRun\*(C'\fR.
