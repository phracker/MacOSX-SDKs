.\" Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "POSIX 3pm"
.TH POSIX 3pm "2019-10-21" "perl v5.30.3" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
POSIX \- Perl interface to IEEE Std 1003.1
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 3
\&    use POSIX ();
\&    use POSIX qw(setsid);
\&    use POSIX qw(:errno_h :fcntl_h);
\&
\&    printf "EINTR is %d\en", EINTR;
\&
\&    $sess_id = POSIX::setsid();
\&
\&    $fd = POSIX::open($path, O_CREAT|O_EXCL|O_WRONLY, 0644);
\&        # note: that\*(Aqs a filedescriptor, *NOT* a filehandle
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The \s-1POSIX\s0 module permits you to access all (or nearly all) the standard
\&\s-1POSIX 1003.1\s0 identifiers.  Many of these identifiers have been given Perl-ish
interfaces.
.PP
This document gives a condensed list of the features available in the \s-1POSIX\s0
module.  Consult your operating system's manpages for general information on
most features.  Consult perlfunc for functions which are noted as being
identical or almost identical to Perl's builtin functions.
.PP
The first section describes \s-1POSIX\s0 functions from the 1003.1 specification.
The second section describes some classes for signal objects, \s-1TTY\s0 objects,
and other miscellaneous objects.  The remaining sections list various
constants and macros in an organization which roughly follows \s-1IEEE\s0 Std
1003.1b\-1993.
.SH "CAVEATS"
.IX Header "CAVEATS"
\&\fIEverything is exported by default\fR (with a handful of exceptions).
This is an unfortunate backwards compatibility feature and its use is
\&\fBstrongly discouraged\fR.
You should either prevent the exporting (by saying \f(CW\*(C`use\ POSIX\ ();\*(C'\fR,
as usual) and then use fully qualified names (e.g. \f(CW\*(C`POSIX::SEEK_END\*(C'\fR),
or give an explicit import list.
If you do neither and opt for the default (as in \f(CW\*(C`use\ POSIX;\*(C'\fR), you
will import \fIhundreds and hundreds\fR of symbols into your namespace.
.PP
A few functions are not implemented because they are C specific.  If you
attempt to call these, they will print a message telling you that they
aren't implemented, and suggest using the Perl equivalent, should one
exist.  For example, trying to access the \f(CW\*(C`setjmp()\*(C'\fR call will elicit the
message "\f(CW\*(C`setjmp() is C\-specific: use eval {} instead\*(C'\fR".
.PP
Furthermore, some evil vendors will claim 1003.1 compliance, but in fact
are not so: they will not pass the \s-1PCTS\s0 (\s-1POSIX\s0 Compliance Test Suites).
For example, one vendor may not define \f(CW\*(C`EDEADLK\*(C'\fR, or the semantics of the
errno values set by \f(CWopen(2)\fR might not be quite right.  Perl does not
attempt to verify \s-1POSIX\s0 compliance.  That means you can currently
successfully say \*(L"use \s-1POSIX\*(R",\s0  and then later in your program you find
that your vendor has been lax and there's no usable \f(CW\*(C`ICANON\*(C'\fR macro after
all.  This could be construed to be a bug.
.SH "FUNCTIONS"
.IX Header "FUNCTIONS"
.ie n .IP """_exit""" 8
.el .IP "\f(CW_exit\fR" 8
.IX Item "_exit"
This is identical to the C function \f(CW\*(C`_exit()\*(C'\fR.  It exits the program
immediately which means among other things buffered I/O is \fBnot\fR flushed.
.Sp
Note that when using threads and in Linux this is \fBnot\fR a good way to
exit a thread because in Linux processes and threads are kind of the
same thing (Note: while this is the situation in early 2003 there are
projects under way to have threads with more POSIXly semantics in Linux).
If you want not to return from a thread, detach the thread.
.ie n .IP """abort""" 8
.el .IP "\f(CWabort\fR" 8
.IX Item "abort"
This is identical to the C function \f(CW\*(C`abort()\*(C'\fR.  It terminates the
process with a \f(CW\*(C`SIGABRT\*(C'\fR signal unless caught by a signal handler or
if the handler does not return normally (it e.g.  does a \f(CW\*(C`longjmp\*(C'\fR).
.ie n .IP """abs""" 8
.el .IP "\f(CWabs\fR" 8
.IX Item "abs"
This is identical to Perl's builtin \f(CW\*(C`abs()\*(C'\fR function, returning the absolute
value of its numerical argument (except that \f(CW\*(C`POSIX::abs()\*(C'\fR must be provided
an explicit value (rather than relying on an implicit \f(CW$_\fR):
.Sp
.Vb 1
\&    $absolute_value = POSIX::abs(42);   # good
\&
\&    $absolute_value = POSIX::abs();     # throws exception
.Ve
.ie n .IP """access""" 8
.el .IP "\f(CWaccess\fR" 8
.IX Item "access"
Determines the accessibility of a file.
.Sp
.Vb 3
\&        if( POSIX::access( "/", &POSIX::R_OK ) ){
\&                print "have read permission\en";
\&        }
.Ve
.Sp
Returns \f(CW\*(C`undef\*(C'\fR on failure.  Note: do not use \f(CW\*(C`access()\*(C'\fR for
security purposes.  Between the \f(CW\*(C`access()\*(C'\fR call and the operation
you are preparing for the permissions might change: a classic
\&\fIrace condition\fR.
.ie n .IP """acos""" 8
.el .IP "\f(CWacos\fR" 8
.IX Item "acos"
This is identical to the C function \f(CW\*(C`acos()\*(C'\fR, returning
the arcus cosine of its numerical argument.  See also Math::Trig.
.ie n .IP """acosh""" 8
.el .IP "\f(CWacosh\fR" 8
.IX Item "acosh"
This is identical to the C function \f(CW\*(C`acosh()\*(C'\fR, returning the
hyperbolic arcus cosine of its numerical argument [C99].  See also
Math::Trig.
.ie n .IP """alarm""" 8
.el .IP "\f(CWalarm\fR" 8
.IX Item "alarm"
This is identical to Perl's builtin \f(CW\*(C`alarm()\*(C'\fR function, either for arming or
disarming the \f(CW\*(C`SIGARLM\*(C'\fR timer, except that \f(CW\*(C`POSIX::alarm()\*(C'\fR must be provided
an explicit value (rather than relying on an implicit \f(CW$_\fR):
.Sp
.Vb 1
\&    POSIX::alarm(3)     # good
\&
\&    POSIX::alarm()      # throws exception
.Ve
.ie n .IP """asctime""" 8
.el .IP "\f(CWasctime\fR" 8
.IX Item "asctime"
This is identical to the C function \f(CW\*(C`asctime()\*(C'\fR.  It returns
a string of the form
.Sp
.Vb 1
\&        "Fri Jun  2 18:22:13 2000\en\e0"
.Ve
.Sp
and it is called thusly
.Sp
.Vb 2
\&        $asctime = asctime($sec, $min, $hour, $mday, $mon,
\&                           $year, $wday, $yday, $isdst);
.Ve
.Sp
The \f(CW$mon\fR is zero-based: January equals \f(CW0\fR.  The \f(CW$year\fR is
1900\-based: 2001 equals \f(CW101\fR.  \f(CW$wday\fR and \f(CW$yday\fR default to zero
(and are usually ignored anyway), and \f(CW$isdst\fR defaults to \-1.
.ie n .IP """asin""" 8
.el .IP "\f(CWasin\fR" 8
.IX Item "asin"
This is identical to the C function \f(CW\*(C`asin()\*(C'\fR, returning
the arcus sine of its numerical argument.  See also Math::Trig.
.ie n .IP """asinh""" 8
.el .IP "\f(CWasinh\fR" 8
.IX Item "asinh"
This is identical to the C function \f(CW\*(C`asinh()\*(C'\fR, returning the
hyperbolic arcus sine of its numerical argument [C99].  See also
Math::Trig.
.ie n .IP """assert""" 8
.el .IP "\f(CWassert\fR" 8
.IX Item "assert"
Unimplemented, but you can use \*(L"die\*(R" in perlfunc and the Carp module
to achieve similar things.
.ie n .IP """atan""" 8
.el .IP "\f(CWatan\fR" 8
.IX Item "atan"
This is identical to the C function \f(CW\*(C`atan()\*(C'\fR, returning the
arcus tangent of its numerical argument.  See also Math::Trig.
.ie n .IP """atanh""" 8
.el .IP "\f(CWatanh\fR" 8
.IX Item "atanh"
This is identical to the C function \f(CW\*(C`atanh()\*(C'\fR, returning the
hyperbolic arcus tangent of its numerical argument [C99].  See also
Math::Trig.
.ie n .IP """atan2""" 8
.el .IP "\f(CWatan2\fR" 8
.IX Item "atan2"
This is identical to Perl's builtin \f(CW\*(C`atan2()\*(C'\fR function, returning
the arcus tangent defined by its two numerical arguments, the \fIy\fR
coordinate and the \fIx\fR coordinate.  See also Math::Trig.
.ie n .IP """atexit""" 8
.el .IP "\f(CWatexit\fR" 8
.IX Item "atexit"
Not implemented.  \f(CW\*(C`atexit()\*(C'\fR is C\-specific: use \f(CW\*(C`END {}\*(C'\fR instead, see perlmod.
.ie n .IP """atof""" 8
.el .IP "\f(CWatof\fR" 8
.IX Item "atof"
Not implemented.  \f(CW\*(C`atof()\*(C'\fR is C\-specific.  Perl converts strings to numbers transparently.
If you need to force a scalar to a number, add a zero to it.
.ie n .IP """atoi""" 8
.el .IP "\f(CWatoi\fR" 8
.IX Item "atoi"
Not implemented.  \f(CW\*(C`atoi()\*(C'\fR is C\-specific.  Perl converts strings to numbers transparently.
If you need to force a scalar to a number, add a zero to it.
If you need to have just the integer part, see \*(L"int\*(R" in perlfunc.
.ie n .IP """atol""" 8
.el .IP "\f(CWatol\fR" 8
.IX Item "atol"
Not implemented.  \f(CW\*(C`atol()\*(C'\fR is C\-specific.  Perl converts strings to numbers transparently.
If you need to force a scalar to a number, add a zero to it.
If you need to have just the integer part, see \*(L"int\*(R" in perlfunc.
.ie n .IP """bsearch""" 8
.el .IP "\f(CWbsearch\fR" 8
.IX Item "bsearch"
\&\f(CW\*(C`bsearch()\*(C'\fR not supplied.  For doing binary search on wordlists,
see Search::Dict.
.ie n .IP """calloc""" 8
.el .IP "\f(CWcalloc\fR" 8
.IX Item "calloc"
Not implemented.  \f(CW\*(C`calloc()\*(C'\fR is C\-specific.  Perl does memory management transparently.
.ie n .IP """cbrt""" 8
.el .IP "\f(CWcbrt\fR" 8
.IX Item "cbrt"
The cube root [C99].
.ie n .IP """ceil""" 8
.el .IP "\f(CWceil\fR" 8
.IX Item "ceil"
This is identical to the C function \f(CW\*(C`ceil()\*(C'\fR, returning the smallest
integer value greater than or equal to the given numerical argument.
.ie n .IP """chdir""" 8
.el .IP "\f(CWchdir\fR" 8
.IX Item "chdir"
This is identical to Perl's builtin \f(CW\*(C`chdir()\*(C'\fR function, allowing one to
change the working (default) directory \*(-- see \*(L"chdir\*(R" in perlfunc \*(-- with the
exception that \f(CW\*(C`POSIX::chdir()\*(C'\fR must be provided an explicit value (rather
than relying on an implicit \f(CW$_\fR):
.Sp
.Vb 1
\&    $rv = POSIX::chdir(\*(Aqpath/to/dir\*(Aq);      # good
\&
\&    $rv = POSIX::chdir();                   # throws exception
.Ve
.ie n .IP """chmod""" 8
.el .IP "\f(CWchmod\fR" 8
.IX Item "chmod"
This is identical to Perl's builtin \f(CW\*(C`chmod()\*(C'\fR function, allowing
one to change file and directory permissions \*(-- see \*(L"chmod\*(R" in perlfunc \*(-- with
the exception that \f(CW\*(C`POSIX::chmod()\*(C'\fR can only change one file at a time
(rather than a list of files):
.Sp
.Vb 1
\&    $c = chmod 0664, $file1, $file2;          # good
\&
\&    $c = POSIX::chmod 0664, $file1;           # throws exception
\&
\&    $c = POSIX::chmod 0664, $file1, $file2;   # throws exception
.Ve
.Sp
As with the built-in \f(CW\*(C`chmod()\*(C'\fR, \f(CW$file\fR may be a filename or a file
handle.
.ie n .IP """chown""" 8
.el .IP "\f(CWchown\fR" 8
.IX Item "chown"
This is identical to Perl's builtin \f(CW\*(C`chown()\*(C'\fR function, allowing one
to change file and directory owners and groups, see \*(L"chown\*(R" in perlfunc.
.ie n .IP """clearerr""" 8
.el .IP "\f(CWclearerr\fR" 8
.IX Item "clearerr"
Not implemented.  Use the method \f(CW\*(C`IO::Handle::clearerr()\*(C'\fR instead, to reset the error
state (if any) and \s-1EOF\s0 state (if any) of the given stream.
.ie n .IP """clock""" 8
.el .IP "\f(CWclock\fR" 8
.IX Item "clock"
This is identical to the C function \f(CW\*(C`clock()\*(C'\fR, returning the
amount of spent processor time in microseconds.
.ie n .IP """close""" 8
.el .IP "\f(CWclose\fR" 8
.IX Item "close"
Close the file.  This uses file descriptors such as those obtained by calling
\&\f(CW\*(C`POSIX::open\*(C'\fR.
.Sp
.Vb 2
\&        $fd = POSIX::open( "foo", &POSIX::O_RDONLY );
\&        POSIX::close( $fd );
.Ve
.Sp
Returns \f(CW\*(C`undef\*(C'\fR on failure.
.Sp
See also \*(L"close\*(R" in perlfunc.
.ie n .IP """closedir""" 8
.el .IP "\f(CWclosedir\fR" 8
.IX Item "closedir"
This is identical to Perl's builtin \f(CW\*(C`closedir()\*(C'\fR function for closing
a directory handle, see \*(L"closedir\*(R" in perlfunc.
.ie n .IP """cos""" 8
.el .IP "\f(CWcos\fR" 8
.IX Item "cos"
This is identical to Perl's builtin \f(CW\*(C`cos()\*(C'\fR function, for returning
the cosine of its numerical argument, see \*(L"cos\*(R" in perlfunc.
See also Math::Trig.
.ie n .IP """cosh""" 8
.el .IP "\f(CWcosh\fR" 8
.IX Item "cosh"
This is identical to the C function \f(CW\*(C`cosh()\*(C'\fR, for returning
the hyperbolic cosine of its numeric argument.  See also Math::Trig.
.ie n .IP """copysign""" 8
.el .IP "\f(CWcopysign\fR" 8
.IX Item "copysign"
Returns \f(CW\*(C`x\*(C'\fR but with the sign of \f(CW\*(C`y\*(C'\fR [C99].
.Sp
.Vb 1
\& $x_with_sign_of_y = POSIX::copysign($x, $y);
.Ve
.Sp
See also \*(L"signbit\*(R".
.ie n .IP """creat""" 8
.el .IP "\f(CWcreat\fR" 8
.IX Item "creat"
Create a new file.  This returns a file descriptor like the ones returned by
\&\f(CW\*(C`POSIX::open\*(C'\fR.  Use \f(CW\*(C`POSIX::close\*(C'\fR to close the file.
.Sp
.Vb 2
\&        $fd = POSIX::creat( "foo", 0611 );
\&        POSIX::close( $fd );
.Ve
.Sp
See also \*(L"sysopen\*(R" in perlfunc and its \f(CW\*(C`O_CREAT\*(C'\fR flag.
.ie n .IP """ctermid""" 8
.el .IP "\f(CWctermid\fR" 8
.IX Item "ctermid"
Generates the path name for the controlling terminal.
.Sp
.Vb 1
\&        $path = POSIX::ctermid();
.Ve
.ie n .IP """ctime""" 8
.el .IP "\f(CWctime\fR" 8
.IX Item "ctime"
This is identical to the C function \f(CW\*(C`ctime()\*(C'\fR and equivalent
to \f(CW\*(C`asctime(localtime(...))\*(C'\fR, see \*(L"asctime\*(R" and \*(L"localtime\*(R".
.ie n .IP """cuserid"" [\s-1POSIX.1\-1988\s0]" 8
.el .IP "\f(CWcuserid\fR [\s-1POSIX.1\-1988\s0]" 8
.IX Item "cuserid [POSIX.1-1988]"
Get the login name of the owner of the current process.
.Sp
.Vb 1
\&        $name = POSIX::cuserid();
.Ve
.Sp
Note: this function has not been specified by \s-1POSIX\s0 since 1990 and is included
only for backwards compatibility. New code should use \f(CW\*(C`getlogin()\*(C'\fR instead.
.ie n .IP """difftime""" 8
.el .IP "\f(CWdifftime\fR" 8
.IX Item "difftime"
This is identical to the C function \f(CW\*(C`difftime()\*(C'\fR, for returning
the time difference (in seconds) between two times (as returned
by \f(CW\*(C`time()\*(C'\fR), see \*(L"time\*(R".
.ie n .IP """div""" 8
.el .IP "\f(CWdiv\fR" 8
.IX Item "div"
Not implemented.  \f(CW\*(C`div()\*(C'\fR is C\-specific, use \*(L"int\*(R" in perlfunc on the usual \f(CW\*(C`/\*(C'\fR division and
the modulus \f(CW\*(C`%\*(C'\fR.
.ie n .IP """dup""" 8
.el .IP "\f(CWdup\fR" 8
.IX Item "dup"
This is similar to the C function \f(CW\*(C`dup()\*(C'\fR, for duplicating a file
descriptor.
.Sp
This uses file descriptors such as those obtained by calling
\&\f(CW\*(C`POSIX::open\*(C'\fR.
.Sp
Returns \f(CW\*(C`undef\*(C'\fR on failure.
.ie n .IP """dup2""" 8
.el .IP "\f(CWdup2\fR" 8
.IX Item "dup2"
This is similar to the C function \f(CW\*(C`dup2()\*(C'\fR, for duplicating a file
descriptor to an another known file descriptor.
.Sp
This uses file descriptors such as those obtained by calling
\&\f(CW\*(C`POSIX::open\*(C'\fR.
.Sp
Returns \f(CW\*(C`undef\*(C'\fR on failure.
.ie n .IP """erf""" 8
.el .IP "\f(CWerf\fR" 8
.IX Item "erf"
The error function [C99].
.ie n .IP """erfc""" 8
.el .IP "\f(CWerfc\fR" 8
.IX Item "erfc"
The complementary error function [C99].
.ie n .IP """errno""" 8
.el .IP "\f(CWerrno\fR" 8
.IX Item "errno"
Returns the value of errno.
.Sp
.Vb 1
\&        $errno = POSIX::errno();
.Ve
.Sp
This identical to the numerical values of the \f(CW$!\fR, see \*(L"$ERRNO\*(R" in perlvar.
.ie n .IP """execl""" 8
.el .IP "\f(CWexecl\fR" 8
.IX Item "execl"
Not implemented.  \f(CW\*(C`execl()\*(C'\fR is C\-specific, see \*(L"exec\*(R" in perlfunc.
.ie n .IP """execle""" 8
.el .IP "\f(CWexecle\fR" 8
.IX Item "execle"
Not implemented.  \f(CW\*(C`execle()\*(C'\fR is C\-specific, see \*(L"exec\*(R" in perlfunc.
.ie n .IP """execlp""" 8
.el .IP "\f(CWexeclp\fR" 8
.IX Item "execlp"
Not implemented.  \f(CW\*(C`execlp()\*(C'\fR is C\-specific, see \*(L"exec\*(R" in perlfunc.
.ie n .IP """execv""" 8
.el .IP "\f(CWexecv\fR" 8
.IX Item "execv"
Not implemented.  \f(CW\*(C`execv()\*(C'\fR is C\-specific, see \*(L"exec\*(R" in perlfunc.
.ie n .IP """execve""" 8
.el .IP "\f(CWexecve\fR" 8
.IX Item "execve"
Not implemented.  \f(CW\*(C`execve()\*(C'\fR is C\-specific, see \*(L"exec\*(R" in perlfunc.
.ie n .IP """execvp""" 8
.el .IP "\f(CWexecvp\fR" 8
.IX Item "execvp"
Not implemented.  \f(CW\*(C`execvp()\*(C'\fR is C\-specific, see \*(L"exec\*(R" in perlfunc.
.ie n .IP """exit""" 8
.el .IP "\f(CWexit\fR" 8
.IX Item "exit"
This is identical to Perl's builtin \f(CW\*(C`exit()\*(C'\fR function for exiting the
program, see \*(L"exit\*(R" in perlfunc.
.ie n .IP """exp""" 8
.el .IP "\f(CWexp\fR" 8
.IX Item "exp"
This is identical to Perl's builtin \f(CW\*(C`exp()\*(C'\fR function for
returning the exponent (\fIe\fR\-based) of the numerical argument,
see \*(L"exp\*(R" in perlfunc.
.ie n .IP """expm1""" 8
.el .IP "\f(CWexpm1\fR" 8
.IX Item "expm1"
Equivalent to \f(CW\*(C`exp(x) \- 1\*(C'\fR, but more precise for small argument values [C99].
.Sp
See also \*(L"log1p\*(R".
.ie n .IP """fabs""" 8
.el .IP "\f(CWfabs\fR" 8
.IX Item "fabs"
This is identical to Perl's builtin \f(CW\*(C`abs()\*(C'\fR function for returning
the absolute value of the numerical argument, see \*(L"abs\*(R" in perlfunc.
.ie n .IP """fclose""" 8
.el .IP "\f(CWfclose\fR" 8
.IX Item "fclose"
Not implemented.  Use method \f(CW\*(C`IO::Handle::close()\*(C'\fR instead, or see \*(L"close\*(R" in perlfunc.
.ie n .IP """fcntl""" 8
.el .IP "\f(CWfcntl\fR" 8
.IX Item "fcntl"
This is identical to Perl's builtin \f(CW\*(C`fcntl()\*(C'\fR function,
see \*(L"fcntl\*(R" in perlfunc.
.ie n .IP """fdopen""" 8
.el .IP "\f(CWfdopen\fR" 8
.IX Item "fdopen"
Not implemented.  Use method \f(CW\*(C`IO::Handle::new_from_fd()\*(C'\fR instead, or see \*(L"open\*(R" in perlfunc.
.ie n .IP """feof""" 8
.el .IP "\f(CWfeof\fR" 8
.IX Item "feof"
Not implemented.  Use method \f(CW\*(C`IO::Handle::eof()\*(C'\fR instead, or see \*(L"eof\*(R" in perlfunc.
.ie n .IP """ferror""" 8
.el .IP "\f(CWferror\fR" 8
.IX Item "ferror"
Not implemented.  Use method \f(CW\*(C`IO::Handle::error()\*(C'\fR instead.
.ie n .IP """fflush""" 8
.el .IP "\f(CWfflush\fR" 8
.IX Item "fflush"
Not implemented.  Use method \f(CW\*(C`IO::Handle::flush()\*(C'\fR instead.
See also \f(CW\*(C`"$OUTPUT_AUTOFLUSH" in perlvar\*(C'\fR.
.ie n .IP """fgetc""" 8
.el .IP "\f(CWfgetc\fR" 8
.IX Item "fgetc"
Not implemented.  Use method \f(CW\*(C`IO::Handle::getc()\*(C'\fR instead, or see \*(L"read\*(R" in perlfunc.
.ie n .IP """fgetpos""" 8
.el .IP "\f(CWfgetpos\fR" 8
.IX Item "fgetpos"
Not implemented.  Use method \f(CW\*(C`IO::Seekable::getpos()\*(C'\fR instead, or see \*(L"seek\*(R" in perlfunc.
.ie n .IP """fgets""" 8
.el .IP "\f(CWfgets\fR" 8
.IX Item "fgets"
Not implemented.  Use method \f(CW\*(C`IO::Handle::gets()\*(C'\fR instead.  Similar to <>, also known
as \*(L"readline\*(R" in perlfunc.
.ie n .IP """fileno""" 8
.el .IP "\f(CWfileno\fR" 8
.IX Item "fileno"
Not implemented.  Use method \f(CW\*(C`IO::Handle::fileno()\*(C'\fR instead, or see \*(L"fileno\*(R" in perlfunc.
.ie n .IP """floor""" 8
.el .IP "\f(CWfloor\fR" 8
.IX Item "floor"
This is identical to the C function \f(CW\*(C`floor()\*(C'\fR, returning the largest
integer value less than or equal to the numerical argument.
.ie n .IP """fdim""" 8
.el .IP "\f(CWfdim\fR" 8
.IX Item "fdim"
\&\*(L"Positive difference\*(R", \f(CW\*(C`x\ \-\ y\*(C'\fR if \f(CW\*(C`x\ >\ y\*(C'\fR, zero otherwise [C99].
.ie n .IP """fegetround""" 8
.el .IP "\f(CWfegetround\fR" 8
.IX Item "fegetround"
Returns the current floating point rounding mode, one of
.Sp
.Vb 1
\&  FE_TONEAREST FE_TOWARDZERO FE_UPWARD FE_UPWARD
.Ve
.Sp
\&\f(CW\*(C`FE_TONEAREST\*(C'\fR is like \*(L"round\*(R", \f(CW\*(C`FE_TOWARDZERO\*(C'\fR is like \*(L"trunc\*(R" [C99].
.ie n .IP """fesetround""" 8
.el .IP "\f(CWfesetround\fR" 8
.IX Item "fesetround"
Sets the floating point rounding mode, see \*(L"fegetround\*(R" [C99].
.ie n .IP """fma""" 8
.el .IP "\f(CWfma\fR" 8
.IX Item "fma"
\&\*(L"Fused multiply-add\*(R", \f(CW\*(C`x\ *\ y\ +\ z\*(C'\fR, possibly faster (and less lossy)
than the explicit two operations [C99].
.Sp
.Vb 1
\& my $fused = POSIX::fma($x, $y, $z);
.Ve
.ie n .IP """fmax""" 8
.el .IP "\f(CWfmax\fR" 8
.IX Item "fmax"
Maximum of \f(CW\*(C`x\*(C'\fR and \f(CW\*(C`y\*(C'\fR, except when either is \f(CW\*(C`NaN\*(C'\fR, returns the other [C99].
.Sp
.Vb 1
\& my $min = POSIX::fmax($x, $y);
.Ve
.ie n .IP """fmin""" 8
.el .IP "\f(CWfmin\fR" 8
.IX Item "fmin"
Minimum of \f(CW\*(C`x\*(C'\fR and \f(CW\*(C`y\*(C'\fR, except when either is \f(CW\*(C`NaN\*(C'\fR, returns the other [C99].
.Sp
.Vb 1
\& my $min = POSIX::fmin($x, $y);
.Ve
.ie n .IP """fmod""" 8
.el .IP "\f(CWfmod\fR" 8
.IX Item "fmod"
This is identical to the C function \f(CW\*(C`fmod()\*(C'\fR.
.Sp
.Vb 1
\&        $r = fmod($x, $y);
.Ve
.Sp
It returns the remainder \f(CW\*(C`$r\ =\ $x\ \-\ $n*$y\*(C'\fR, where \f(CW\*(C`$n\ =\ trunc($x/$y)\*(C'\fR.
The \f(CW$r\fR has the same sign as \f(CW$x\fR and magnitude (absolute value)
less than the magnitude of \f(CW$y\fR.
.ie n .IP """fopen""" 8
.el .IP "\f(CWfopen\fR" 8
.IX Item "fopen"
Not implemented.  Use method \f(CW\*(C`IO::File::open()\*(C'\fR instead, or see \*(L"open\*(R" in perlfunc.
.ie n .IP """fork""" 8
.el .IP "\f(CWfork\fR" 8
.IX Item "fork"
This is identical to Perl's builtin \f(CW\*(C`fork()\*(C'\fR function
for duplicating the current process, see \*(L"fork\*(R" in perlfunc
and perlfork if you are in Windows.
.ie n .IP """fpathconf""" 8
.el .IP "\f(CWfpathconf\fR" 8
.IX Item "fpathconf"
Retrieves the value of a configurable limit on a file or directory.  This
uses file descriptors such as those obtained by calling \f(CW\*(C`POSIX::open\*(C'\fR.
.Sp
The following will determine the maximum length of the longest allowable
pathname on the filesystem which holds \fI/var/foo\fR.
.Sp
.Vb 2
\&        $fd = POSIX::open( "/var/foo", &POSIX::O_RDONLY );
\&        $path_max = POSIX::fpathconf($fd, &POSIX::_PC_PATH_MAX);
.Ve
.Sp
Returns \f(CW\*(C`undef\*(C'\fR on failure.
.ie n .IP """fpclassify""" 8
.el .IP "\f(CWfpclassify\fR" 8
.IX Item "fpclassify"
Returns one of
.Sp
.Vb 1
\&  FP_NORMAL FP_ZERO FP_SUBNORMAL FP_INFINITE FP_NAN
.Ve
.Sp
telling the class of the argument [C99].  \f(CW\*(C`FP_INFINITE\*(C'\fR is positive
or negative infinity, \f(CW\*(C`FP_NAN\*(C'\fR is not-a-number.  \f(CW\*(C`FP_SUBNORMAL\*(C'\fR
means subnormal numbers (also known as denormals), very small numbers
with low precision. \f(CW\*(C`FP_ZERO\*(C'\fR is zero.  \f(CW\*(C`FP_NORMAL\*(C'\fR is all the rest.
.ie n .IP """fprintf""" 8
.el .IP "\f(CWfprintf\fR" 8
.IX Item "fprintf"
Not implemented.  \f(CW\*(C`fprintf()\*(C'\fR is C\-specific, see \*(L"printf\*(R" in perlfunc instead.
.ie n .IP """fputc""" 8
.el .IP "\f(CWfputc\fR" 8
.IX Item "fputc"
Not implemented.  \f(CW\*(C`fputc()\*(C'\fR is C\-specific, see \*(L"print\*(R" in perlfunc instead.
.ie n .IP """fputs""" 8
.el .IP "\f(CWfputs\fR" 8
.IX Item "fputs"
Not implemented.  \f(CW\*(C`fputs()\*(C'\fR is C\-specific, see \*(L"print\*(R" in perlfunc instead.
.ie n .IP """fread""" 8
.el .IP "\f(CWfread\fR" 8
.IX Item "fread"
Not implemented.  \f(CW\*(C`fread()\*(C'\fR is C\-specific, see \*(L"read\*(R" in perlfunc instead.
.ie n .IP """free""" 8
.el .IP "\f(CWfree\fR" 8
.IX Item "free"
Not implemented.  \f(CW\*(C`free()\*(C'\fR is C\-specific.  Perl does memory management transparently.
.ie n .IP """freopen""" 8
.el .IP "\f(CWfreopen\fR" 8
.IX Item "freopen"
Not implemented.  \f(CW\*(C`freopen()\*(C'\fR is C\-specific, see \*(L"open\*(R" in perlfunc instead.
.ie n .IP """frexp""" 8
.el .IP "\f(CWfrexp\fR" 8
.IX Item "frexp"
Return the mantissa and exponent of a floating-point number.
.Sp
.Vb 1
\&        ($mantissa, $exponent) = POSIX::frexp( 1.234e56 );
.Ve
.ie n .IP """fscanf""" 8
.el .IP "\f(CWfscanf\fR" 8
.IX Item "fscanf"
Not implemented.  \f(CW\*(C`fscanf()\*(C'\fR is C\-specific, use <> and regular expressions instead.
.ie n .IP """fseek""" 8
.el .IP "\f(CWfseek\fR" 8
.IX Item "fseek"
Not implemented.  Use method \f(CW\*(C`IO::Seekable::seek()\*(C'\fR instead, or see \*(L"seek\*(R" in perlfunc.
.ie n .IP """fsetpos""" 8
.el .IP "\f(CWfsetpos\fR" 8
.IX Item "fsetpos"
Not implemented.  Use method \f(CW\*(C`IO::Seekable::setpos()\*(C'\fR instead, or seek \*(L"seek\*(R" in perlfunc.
.ie n .IP """fstat""" 8
.el .IP "\f(CWfstat\fR" 8
.IX Item "fstat"
Get file status.  This uses file descriptors such as those obtained by
calling \f(CW\*(C`POSIX::open\*(C'\fR.  The data returned is identical to the data from
Perl's builtin \f(CW\*(C`stat\*(C'\fR function.
.Sp
.Vb 2
\&        $fd = POSIX::open( "foo", &POSIX::O_RDONLY );
\&        @stats = POSIX::fstat( $fd );
.Ve
.ie n .IP """fsync""" 8
.el .IP "\f(CWfsync\fR" 8
.IX Item "fsync"
Not implemented.  Use method \f(CW\*(C`IO::Handle::sync()\*(C'\fR instead.
.ie n .IP """ftell""" 8
.el .IP "\f(CWftell\fR" 8
.IX Item "ftell"
Not implemented.  Use method \f(CW\*(C`IO::Seekable::tell()\*(C'\fR instead, or see \*(L"tell\*(R" in perlfunc.
.ie n .IP """fwrite""" 8
.el .IP "\f(CWfwrite\fR" 8
.IX Item "fwrite"
Not implemented.  \f(CW\*(C`fwrite()\*(C'\fR is C\-specific, see \*(L"print\*(R" in perlfunc instead.
.ie n .IP """getc""" 8
.el .IP "\f(CWgetc\fR" 8
.IX Item "getc"
This is identical to Perl's builtin \f(CW\*(C`getc()\*(C'\fR function,
see \*(L"getc\*(R" in perlfunc.
.ie n .IP """getchar""" 8
.el .IP "\f(CWgetchar\fR" 8
.IX Item "getchar"
Returns one character from \s-1STDIN.\s0  Identical to Perl's \f(CW\*(C`getc()\*(C'\fR,
see \*(L"getc\*(R" in perlfunc.
.ie n .IP """getcwd""" 8
.el .IP "\f(CWgetcwd\fR" 8
.IX Item "getcwd"
Returns the name of the current working directory.
See also Cwd.
.ie n .IP """getegid""" 8
.el .IP "\f(CWgetegid\fR" 8
.IX Item "getegid"
Returns the effective group identifier.  Similar to Perl' s builtin
variable \f(CW$(\fR, see \*(L"$EGID\*(R" in perlvar.
.ie n .IP """getenv""" 8
.el .IP "\f(CWgetenv\fR" 8
.IX Item "getenv"
Returns the value of the specified environment variable.
The same information is available through the \f(CW%ENV\fR array.
.ie n .IP """geteuid""" 8
.el .IP "\f(CWgeteuid\fR" 8
.IX Item "geteuid"
Returns the effective user identifier.  Identical to Perl's builtin \f(CW$>\fR
variable, see \*(L"$EUID\*(R" in perlvar.
.ie n .IP """getgid""" 8
.el .IP "\f(CWgetgid\fR" 8
.IX Item "getgid"
Returns the user's real group identifier.  Similar to Perl's builtin
variable \f(CW$)\fR, see \*(L"$GID\*(R" in perlvar.
.ie n .IP """getgrgid""" 8
.el .IP "\f(CWgetgrgid\fR" 8
.IX Item "getgrgid"
This is identical to Perl's builtin \f(CW\*(C`getgrgid()\*(C'\fR function for
returning group entries by group identifiers, see
\&\*(L"getgrgid\*(R" in perlfunc.
.ie n .IP """getgrnam""" 8
.el .IP "\f(CWgetgrnam\fR" 8
.IX Item "getgrnam"
This is identical to Perl's builtin \f(CW\*(C`getgrnam()\*(C'\fR function for
returning group entries by group names, see \*(L"getgrnam\*(R" in perlfunc.
.ie n .IP """getgroups""" 8
.el .IP "\f(CWgetgroups\fR" 8
.IX Item "getgroups"
Returns the ids of the user's supplementary groups.  Similar to Perl's
builtin variable \f(CW$)\fR, see \*(L"$GID\*(R" in perlvar.
.ie n .IP """getlogin""" 8
.el .IP "\f(CWgetlogin\fR" 8
.IX Item "getlogin"
This is identical to Perl's builtin \f(CW\*(C`getlogin()\*(C'\fR function for
returning the user name associated with the current session, see
\&\*(L"getlogin\*(R" in perlfunc.
.ie n .IP """getpayload""" 8
.el .IP "\f(CWgetpayload\fR" 8
.IX Item "getpayload"
.Vb 2
\&        use POSIX \*(Aq:nan_payload\*(Aq;
\&        getpayload($var)
.Ve
.Sp
Returns the \f(CW\*(C`NaN\*(C'\fR payload.
.Sp
Note the \s-1API\s0 instability warning in \*(L"setpayload\*(R".
.Sp
See \*(L"nan\*(R" for more discussion about \f(CW\*(C`NaN\*(C'\fR.
.ie n .IP """getpgrp""" 8
.el .IP "\f(CWgetpgrp\fR" 8
.IX Item "getpgrp"
This is identical to Perl's builtin \f(CW\*(C`getpgrp()\*(C'\fR function for
returning the process group identifier of the current process, see
\&\*(L"getpgrp\*(R" in perlfunc.
.ie n .IP """getpid""" 8
.el .IP "\f(CWgetpid\fR" 8
.IX Item "getpid"
Returns the process identifier.  Identical to Perl's builtin
variable \f(CW$$\fR, see \*(L"$PID\*(R" in perlvar.
.ie n .IP """getppid""" 8
.el .IP "\f(CWgetppid\fR" 8
.IX Item "getppid"
This is identical to Perl's builtin \f(CW\*(C`getppid()\*(C'\fR function for
returning the process identifier of the parent process of the current
process , see \*(L"getppid\*(R" in perlfunc.
.ie n .IP """getpwnam""" 8
.el .IP "\f(CWgetpwnam\fR" 8
.IX Item "getpwnam"
This is identical to Perl's builtin \f(CW\*(C`getpwnam()\*(C'\fR function for
returning user entries by user names, see \*(L"getpwnam\*(R" in perlfunc.
.ie n .IP """getpwuid""" 8
.el .IP "\f(CWgetpwuid\fR" 8
.IX Item "getpwuid"
This is identical to Perl's builtin \f(CW\*(C`getpwuid()\*(C'\fR function for
returning user entries by user identifiers, see \*(L"getpwuid\*(R" in perlfunc.
.ie n .IP """gets""" 8
.el .IP "\f(CWgets\fR" 8
.IX Item "gets"
Returns one line from \f(CW\*(C`STDIN\*(C'\fR, similar to <>, also known
as the \f(CW\*(C`readline()\*(C'\fR function, see \*(L"readline\*(R" in perlfunc.
.Sp
\&\fB\s-1NOTE\s0\fR: if you have C programs that still use \f(CW\*(C`gets()\*(C'\fR, be very
afraid.  The \f(CW\*(C`gets()\*(C'\fR function is a source of endless grief because
it has no buffer overrun checks.  It should \fBnever\fR be used.  The
\&\f(CW\*(C`fgets()\*(C'\fR function should be preferred instead.
.ie n .IP """getuid""" 8
.el .IP "\f(CWgetuid\fR" 8
.IX Item "getuid"
Returns the user's identifier.  Identical to Perl's builtin \f(CW$<\fR variable,
see \*(L"$UID\*(R" in perlvar.
.ie n .IP """gmtime""" 8
.el .IP "\f(CWgmtime\fR" 8
.IX Item "gmtime"
This is identical to Perl's builtin \f(CW\*(C`gmtime()\*(C'\fR function for
converting seconds since the epoch to a date in Greenwich Mean Time,
see \*(L"gmtime\*(R" in perlfunc.
.ie n .IP """hypot""" 8
.el .IP "\f(CWhypot\fR" 8
.IX Item "hypot"
Equivalent to \f(CW\*(C`sqrt(x\ *\ x\ +\ y\ *\ y)\*(C'\fR except more stable on very large
or very small arguments [C99].
.ie n .IP """ilogb""" 8
.el .IP "\f(CWilogb\fR" 8
.IX Item "ilogb"
Integer binary logarithm [C99]
.Sp
For example \f(CW\*(C`ilogb(20)\*(C'\fR is 4, as an integer.
.Sp
See also \*(L"logb\*(R".
.ie n .IP """Inf""" 8
.el .IP "\f(CWInf\fR" 8
.IX Item "Inf"
The infinity as a constant:
.Sp
.Vb 3
\&   use POSIX qw(Inf);
\&   my $pos_inf = +Inf;  # Or just Inf.
\&   my $neg_inf = \-Inf;
.Ve
.Sp
See also \*(L"isinf\*(R", and \*(L"fpclassify\*(R".
.ie n .IP """isalnum""" 8
.el .IP "\f(CWisalnum\fR" 8
.IX Item "isalnum"
This function has been removed as of v5.24.  It was very similar to
matching against \f(CW\*(C`qr/\ ^\ [[:alnum:]]+\ $\ /x\*(C'\fR, which you should convert
to use instead.  See \*(L"\s-1POSIX\s0 Character Classes\*(R" in perlrecharclass.
.ie n .IP """isalpha""" 8
.el .IP "\f(CWisalpha\fR" 8
.IX Item "isalpha"
This function has been removed as of v5.24.  It was very similar to
matching against \f(CW\*(C`qr/\ ^\ [[:alpha:]]+\ $\ /x\*(C'\fR, which you should convert
to use instead.  See \*(L"\s-1POSIX\s0 Character Classes\*(R" in perlrecharclass.
.ie n .IP """isatty""" 8
.el .IP "\f(CWisatty\fR" 8
.IX Item "isatty"
Returns a boolean indicating whether the specified filehandle is connected
to a tty.  Similar to the \f(CW\*(C`\-t\*(C'\fR operator, see \*(L"\-X\*(R" in perlfunc.
.ie n .IP """iscntrl""" 8
.el .IP "\f(CWiscntrl\fR" 8
.IX Item "iscntrl"
This function has been removed as of v5.24.  It was very similar to
matching against \f(CW\*(C`qr/\ ^\ [[:cntrl:]]+\ $\ /x\*(C'\fR, which you should convert
to use instead.  See \*(L"\s-1POSIX\s0 Character Classes\*(R" in perlrecharclass.
.ie n .IP """isdigit""" 8
.el .IP "\f(CWisdigit\fR" 8
.IX Item "isdigit"
This function has been removed as of v5.24.  It was very similar to
matching against \f(CW\*(C`qr/\ ^\ [[:digit:]]+\ $\ /x\*(C'\fR, which you should convert
to use instead.  See \*(L"\s-1POSIX\s0 Character Classes\*(R" in perlrecharclass.
.ie n .IP """isfinite""" 8
.el .IP "\f(CWisfinite\fR" 8
.IX Item "isfinite"
Returns true if the argument is a finite number (that is, not an
infinity, or the not-a-number) [C99].
.Sp
See also \*(L"isinf\*(R", \*(L"isnan\*(R", and \*(L"fpclassify\*(R".
.ie n .IP """isgraph""" 8
.el .IP "\f(CWisgraph\fR" 8
.IX Item "isgraph"
This function has been removed as of v5.24.  It was very similar to
matching against \f(CW\*(C`qr/\ ^\ [[:graph:]]+\ $\ /x\*(C'\fR, which you should convert
to use instead.  See \*(L"\s-1POSIX\s0 Character Classes\*(R" in perlrecharclass.
.ie n .IP """isgreater""" 8
.el .IP "\f(CWisgreater\fR" 8
.IX Item "isgreater"
(Also \f(CW\*(C`isgreaterequal\*(C'\fR, \f(CW\*(C`isless\*(C'\fR, \f(CW\*(C`islessequal\*(C'\fR, \f(CW\*(C`islessgreater\*(C'\fR,
\&\f(CW\*(C`isunordered\*(C'\fR)
.Sp
Floating point comparisons which handle the \f(CW\*(C`NaN\*(C'\fR [C99].
.ie n .IP """isinf""" 8
.el .IP "\f(CWisinf\fR" 8
.IX Item "isinf"
Returns true if the argument is an infinity (positive or negative) [C99].
.Sp
See also \*(L"Inf\*(R", \*(L"isnan\*(R", \*(L"isfinite\*(R", and \*(L"fpclassify\*(R".
.ie n .IP """islower""" 8
.el .IP "\f(CWislower\fR" 8
.IX Item "islower"
This function has been removed as of v5.24.  It was very similar to
matching against \f(CW\*(C`qr/\ ^\ [[:lower:]]+\ $\ /x\*(C'\fR, which you should convert
to use instead.  See \*(L"\s-1POSIX\s0 Character Classes\*(R" in perlrecharclass.
.ie n .IP """isnan""" 8
.el .IP "\f(CWisnan\fR" 8
.IX Item "isnan"
Returns true if the argument is \f(CW\*(C`NaN\*(C'\fR (not-a-number) [C99].
.Sp
Note that you cannot test for "\f(CW\*(C`NaN\*(C'\fR\-ness" with
.Sp
.Vb 1
\&   $x == $x
.Ve
.Sp
since the \f(CW\*(C`NaN\*(C'\fR is not equivalent to anything, \fBincluding itself\fR.
.Sp
See also \*(L"nan\*(R", \*(L"NaN\*(R", \*(L"isinf\*(R", and \*(L"fpclassify\*(R".
.ie n .IP """isnormal""" 8
.el .IP "\f(CWisnormal\fR" 8
.IX Item "isnormal"
Returns true if the argument is normal (that is, not a subnormal/denormal,
and not an infinity, or a not-a-number) [C99].
.Sp
See also \*(L"isfinite\*(R", and \*(L"fpclassify\*(R".
.ie n .IP """isprint""" 8
.el .IP "\f(CWisprint\fR" 8
.IX Item "isprint"
This function has been removed as of v5.24.  It was very similar to
matching against \f(CW\*(C`qr/\ ^\ [[:print:]]+\ $\ /x\*(C'\fR, which you should convert
to use instead.  See \*(L"\s-1POSIX\s0 Character Classes\*(R" in perlrecharclass.
.ie n .IP """ispunct""" 8
.el .IP "\f(CWispunct\fR" 8
.IX Item "ispunct"
This function has been removed as of v5.24.  It was very similar to
matching against \f(CW\*(C`qr/\ ^\ [[:punct:]]+\ $\ /x\*(C'\fR, which you should convert
to use instead.  See \*(L"\s-1POSIX\s0 Character Classes\*(R" in perlrecharclass.
.ie n .IP """issignaling""" 8
.el .IP "\f(CWissignaling\fR" 8
.IX Item "issignaling"
.Vb 2
\&        use POSIX \*(Aq:nan_payload\*(Aq;
\&        issignaling($var, $payload)
.Ve
.Sp
Return true if the argument is a \fIsignaling\fR NaN.
.Sp
Note the \s-1API\s0 instability warning in \*(L"setpayload\*(R".
.Sp
See \*(L"nan\*(R" for more discussion about \f(CW\*(C`NaN\*(C'\fR.
.ie n .IP """isspace""" 8
.el .IP "\f(CWisspace\fR" 8
.IX Item "isspace"
This function has been removed as of v5.24.  It was very similar to
matching against \f(CW\*(C`qr/\ ^\ [[:space:]]+\ $\ /x\*(C'\fR, which you should convert
to use instead.  See \*(L"\s-1POSIX\s0 Character Classes\*(R" in perlrecharclass.
.ie n .IP """isupper""" 8
.el .IP "\f(CWisupper\fR" 8
.IX Item "isupper"
This function has been removed as of v5.24.  It was very similar to
matching against \f(CW\*(C`qr/\ ^\ [[:upper:]]+\ $\ /x\*(C'\fR, which you should convert
to use instead.  See \*(L"\s-1POSIX\s0 Character Classes\*(R" in perlrecharclass.
.ie n .IP """isxdigit""" 8
.el .IP "\f(CWisxdigit\fR" 8
.IX Item "isxdigit"
This function has been removed as of v5.24.  It was very similar to
matching against \f(CW\*(C`qr/\ ^\ [[:xdigit:]]+\ $\ /x\*(C'\fR, which you should
convert to use instead.  See \*(L"\s-1POSIX\s0 Character Classes\*(R" in perlrecharclass.
.ie n .IP """j0""" 8
.el .IP "\f(CWj0\fR" 8
.IX Item "j0"
.PD 0
.ie n .IP """j1""" 8
.el .IP "\f(CWj1\fR" 8
.IX Item "j1"
.ie n .IP """jn""" 8
.el .IP "\f(CWjn\fR" 8
.IX Item "jn"
.ie n .IP """y0""" 8
.el .IP "\f(CWy0\fR" 8
.IX Item "y0"
.ie n .IP """y1""" 8
.el .IP "\f(CWy1\fR" 8
.IX Item "y1"
.ie n .IP """yn""" 8
.el .IP "\f(CWyn\fR" 8
.IX Item "yn"
.PD
The Bessel function of the first kind of the order zero.
.ie n .IP """kill""" 8
.el .IP "\f(CWkill\fR" 8
.IX Item "kill"
This is identical to Perl's builtin \f(CW\*(C`kill()\*(C'\fR function for sending
signals to processes (often to terminate them), see \*(L"kill\*(R" in perlfunc.
.ie n .IP """labs""" 8
.el .IP "\f(CWlabs\fR" 8
.IX Item "labs"
Not implemented.  (For returning absolute values of long integers.)
\&\f(CW\*(C`labs()\*(C'\fR is C\-specific, see \*(L"abs\*(R" in perlfunc instead.
.ie n .IP """lchown""" 8
.el .IP "\f(CWlchown\fR" 8
.IX Item "lchown"
This is identical to the C function, except the order of arguments is
consistent with Perl's builtin \f(CW\*(C`chown()\*(C'\fR with the added restriction
of only one path, not a list of paths.  Does the same thing as the
\&\f(CW\*(C`chown()\*(C'\fR function but changes the owner of a symbolic link instead
of the file the symbolic link points to.
.Sp
.Vb 1
\& POSIX::lchown($uid, $gid, $file_path);
.Ve
.ie n .IP """ldexp""" 8
.el .IP "\f(CWldexp\fR" 8
.IX Item "ldexp"
This is identical to the C function \f(CW\*(C`ldexp()\*(C'\fR
for multiplying floating point numbers with powers of two.
.Sp
.Vb 1
\&        $x_quadrupled = POSIX::ldexp($x, 2);
.Ve
.ie n .IP """ldiv""" 8
.el .IP "\f(CWldiv\fR" 8
.IX Item "ldiv"
Not implemented.  (For computing dividends of long integers.)
\&\f(CW\*(C`ldiv()\*(C'\fR is C\-specific, use \f(CW\*(C`/\*(C'\fR and \f(CW\*(C`int()\*(C'\fR instead.
.ie n .IP """lgamma""" 8
.el .IP "\f(CWlgamma\fR" 8
.IX Item "lgamma"
The logarithm of the Gamma function [C99].
.Sp
See also \*(L"tgamma\*(R".
.ie n .IP """log1p""" 8
.el .IP "\f(CWlog1p\fR" 8
.IX Item "log1p"
Equivalent to \f(CW\*(C`log(1\ +\ x)\*(C'\fR, but more stable results for small argument
values [C99].
.ie n .IP """log2""" 8
.el .IP "\f(CWlog2\fR" 8
.IX Item "log2"
Logarithm base two [C99].
.Sp
See also \*(L"expm1\*(R".
.ie n .IP """logb""" 8
.el .IP "\f(CWlogb\fR" 8
.IX Item "logb"
Integer binary logarithm [C99].
.Sp
For example \f(CW\*(C`logb(20)\*(C'\fR is 4, as a floating point number.
.Sp
See also \*(L"ilogb\*(R".
.ie n .IP """link""" 8
.el .IP "\f(CWlink\fR" 8
.IX Item "link"
This is identical to Perl's builtin \f(CW\*(C`link()\*(C'\fR function
for creating hard links into files, see \*(L"link\*(R" in perlfunc.
.ie n .IP """localeconv""" 8
.el .IP "\f(CWlocaleconv\fR" 8
.IX Item "localeconv"
Get numeric formatting information.  Returns a reference to a hash
containing the current underlying locale's formatting values.  Users of this function
should also read perllocale, which provides a comprehensive
discussion of Perl locale handling, including
a section devoted to this function.
Prior to Perl 5.28, or when operating in a non thread-safe environment,
it should not be used in a threaded application unless it's certain that
the underlying locale is C or \s-1POSIX.\s0  This is because it otherwise
changes the locale, which globally affects all threads simultaneously.
Windows platforms starting with Visual Studio 2005 are mostly
thread-safe, but use of this function in those prior to Visual Studio
2015 can interefere with a thread that has called
\&\*(L"switch_to_global_locale\*(R" in perlapi.
.Sp
Here is how to query the database for the \fBde\fR (Deutsch or German) locale.
.Sp
.Vb 10
\&        my $loc = POSIX::setlocale( &POSIX::LC_ALL, "de" );
\&        print "Locale: \e"$loc\e"\en";
\&        my $lconv = POSIX::localeconv();
\&        foreach my $property (qw(
\&                decimal_point
\&                thousands_sep
\&                grouping
\&                int_curr_symbol
\&                currency_symbol
\&                mon_decimal_point
\&                mon_thousands_sep
\&                mon_grouping
\&                positive_sign
\&                negative_sign
\&                int_frac_digits
\&                frac_digits
\&                p_cs_precedes
\&                p_sep_by_space
\&                n_cs_precedes
\&                n_sep_by_space
\&                p_sign_posn
\&                n_sign_posn
\&                int_p_cs_precedes
\&                int_p_sep_by_space
\&                int_n_cs_precedes
\&                int_n_sep_by_space
\&                int_p_sign_posn
\&                int_n_sign_posn
\&        ))
\&        {
\&                printf qq(%s: "%s",\en),
\&                        $property, $lconv\->{$property};
\&        }
.Ve
.Sp
The members whose names begin with \f(CW\*(C`int_p_\*(C'\fR and \f(CW\*(C`int_n_\*(C'\fR were added by
\&\s-1POSIX.1\-2008\s0 and are only available on systems that support them.
.ie n .IP """localtime""" 8
.el .IP "\f(CWlocaltime\fR" 8
.IX Item "localtime"
This is identical to Perl's builtin \f(CW\*(C`localtime()\*(C'\fR function for
converting seconds since the epoch to a date see \*(L"localtime\*(R" in perlfunc except
that \f(CW\*(C`POSIX::localtime()\*(C'\fR must be provided an explicit value (rather than
relying on an implicit \f(CW$_\fR):
.Sp
.Vb 1
\&    @localtime = POSIX::localtime(time);    # good
\&
\&    @localtime = localtime();               # good
\&
\&    @localtime = POSIX::localtime();        # throws exception
.Ve
.ie n .IP """log""" 8
.el .IP "\f(CWlog\fR" 8
.IX Item "log"
This is identical to Perl's builtin \f(CW\*(C`log()\*(C'\fR function,
returning the natural (\fIe\fR\-based) logarithm of the numerical argument,
see \*(L"log\*(R" in perlfunc.
.ie n .IP """log10""" 8
.el .IP "\f(CWlog10\fR" 8
.IX Item "log10"
This is identical to the C function \f(CW\*(C`log10()\*(C'\fR,
returning the 10\-base logarithm of the numerical argument.
You can also use
.Sp
.Vb 1
\&    sub log10 { log($_[0]) / log(10) }
.Ve
.Sp
or
.Sp
.Vb 1
\&    sub log10 { log($_[0]) / 2.30258509299405 }
.Ve
.Sp
or
.Sp
.Vb 1
\&    sub log10 { log($_[0]) * 0.434294481903252 }
.Ve
.ie n .IP """longjmp""" 8
.el .IP "\f(CWlongjmp\fR" 8
.IX Item "longjmp"
Not implemented.  \f(CW\*(C`longjmp()\*(C'\fR is C\-specific: use \*(L"die\*(R" in perlfunc instead.
.ie n .IP """lseek""" 8
.el .IP "\f(CWlseek\fR" 8
.IX Item "lseek"
Move the file's read/write position.  This uses file descriptors such as
those obtained by calling \f(CW\*(C`POSIX::open\*(C'\fR.
.Sp
.Vb 2
\&        $fd = POSIX::open( "foo", &POSIX::O_RDONLY );
\&        $off_t = POSIX::lseek( $fd, 0, &POSIX::SEEK_SET );
.Ve
.Sp
Returns \f(CW\*(C`undef\*(C'\fR on failure.
.ie n .IP """lrint""" 8
.el .IP "\f(CWlrint\fR" 8
.IX Item "lrint"
Depending on the current floating point rounding mode, rounds the
argument either toward nearest (like \*(L"round\*(R"), toward zero (like
\&\*(L"trunc\*(R"), downward (toward negative infinity), or upward (toward
positive infinity) [C99].
.Sp
For the rounding mode, see \*(L"fegetround\*(R".
.ie n .IP """lround""" 8
.el .IP "\f(CWlround\fR" 8
.IX Item "lround"
Like \*(L"round\*(R", but as integer, as opposed to floating point [C99].
.Sp
See also \*(L"ceil\*(R", \*(L"floor\*(R", \*(L"trunc\*(R".
.Sp
Owing to an oversight, this is not currently exported by default, or as part of
the \f(CW\*(C`:math_h_c99\*(C'\fR export tag; importing it must therefore be done by explicit
name.
.ie n .IP """malloc""" 8
.el .IP "\f(CWmalloc\fR" 8
.IX Item "malloc"
Not implemented.  \f(CW\*(C`malloc()\*(C'\fR is C\-specific.  Perl does memory management transparently.
.ie n .IP """mblen""" 8
.el .IP "\f(CWmblen\fR" 8
.IX Item "mblen"
This is identical to the C function \f(CW\*(C`mblen()\*(C'\fR.
.Sp
Core Perl does not have any support for the wide and multibyte
characters of the C standards, except under \s-1UTF\-8\s0 locales, so this might
be a rather useless function.
.Sp
However, Perl supports Unicode, see perluniintro.
.ie n .IP """mbstowcs""" 8
.el .IP "\f(CWmbstowcs\fR" 8
.IX Item "mbstowcs"
This is identical to the C function \f(CW\*(C`mbstowcs()\*(C'\fR.
.Sp
See \*(L"mblen\*(R".
.ie n .IP """mbtowc""" 8
.el .IP "\f(CWmbtowc\fR" 8
.IX Item "mbtowc"
This is identical to the C function \f(CW\*(C`mbtowc()\*(C'\fR.
.Sp
See \*(L"mblen\*(R".
.ie n .IP """memchr""" 8
.el .IP "\f(CWmemchr\fR" 8
.IX Item "memchr"
Not implemented.  \f(CW\*(C`memchr()\*(C'\fR is C\-specific, see \*(L"index\*(R" in perlfunc instead.
.ie n .IP """memcmp""" 8
.el .IP "\f(CWmemcmp\fR" 8
.IX Item "memcmp"
Not implemented.  \f(CW\*(C`memcmp()\*(C'\fR is C\-specific, use \f(CW\*(C`eq\*(C'\fR instead, see perlop.
.ie n .IP """memcpy""" 8
.el .IP "\f(CWmemcpy\fR" 8
.IX Item "memcpy"
Not implemented.  \f(CW\*(C`memcpy()\*(C'\fR is C\-specific, use \f(CW\*(C`=\*(C'\fR, see perlop, or see \*(L"substr\*(R" in perlfunc.
.ie n .IP """memmove""" 8
.el .IP "\f(CWmemmove\fR" 8
.IX Item "memmove"
Not implemented.  \f(CW\*(C`memmove()\*(C'\fR is C\-specific, use \f(CW\*(C`=\*(C'\fR, see perlop, or see \*(L"substr\*(R" in perlfunc.
.ie n .IP """memset""" 8
.el .IP "\f(CWmemset\fR" 8
.IX Item "memset"
Not implemented.  \f(CW\*(C`memset()\*(C'\fR is C\-specific, use \f(CW\*(C`x\*(C'\fR instead, see perlop.
.ie n .IP """mkdir""" 8
.el .IP "\f(CWmkdir\fR" 8
.IX Item "mkdir"
This is identical to Perl's builtin \f(CW\*(C`mkdir()\*(C'\fR function
for creating directories, see \*(L"mkdir\*(R" in perlfunc.
.ie n .IP """mkfifo""" 8
.el .IP "\f(CWmkfifo\fR" 8
.IX Item "mkfifo"
This is similar to the C function \f(CW\*(C`mkfifo()\*(C'\fR for creating
\&\s-1FIFO\s0 special files.
.Sp
.Vb 1
\&        if (mkfifo($path, $mode)) { ....
.Ve
.Sp
Returns \f(CW\*(C`undef\*(C'\fR on failure.  The \f(CW$mode\fR is similar to the
mode of \f(CW\*(C`mkdir()\*(C'\fR, see \*(L"mkdir\*(R" in perlfunc, though for \f(CW\*(C`mkfifo\*(C'\fR
you \fBmust\fR specify the \f(CW$mode\fR.
.ie n .IP """mktime""" 8
.el .IP "\f(CWmktime\fR" 8
.IX Item "mktime"
Convert date/time info to a calendar time.
.Sp
Synopsis:
.Sp
.Vb 2
\&        mktime(sec, min, hour, mday, mon, year, wday = 0,
\&               yday = 0, isdst = \-1)
.Ve
.Sp
The month (\f(CW\*(C`mon\*(C'\fR), weekday (\f(CW\*(C`wday\*(C'\fR), and yearday (\f(CW\*(C`yday\*(C'\fR) begin at zero,
\&\fIi.e.\fR, January is 0, not 1; Sunday is 0, not 1; January 1st is 0, not 1.  The
year (\f(CW\*(C`year\*(C'\fR) is given in years since 1900; \fIi.e.\fR, the year 1995 is 95; the
year 2001 is 101.  Consult your system's \f(CW\*(C`mktime()\*(C'\fR manpage for details
about these and the other arguments.
.Sp
Calendar time for December 12, 1995, at 10:30 am.
.Sp
.Vb 2
\&        $time_t = POSIX::mktime( 0, 30, 10, 12, 11, 95 );
\&        print "Date = ", POSIX::ctime($time_t);
.Ve
.Sp
Returns \f(CW\*(C`undef\*(C'\fR on failure.
.ie n .IP """modf""" 8
.el .IP "\f(CWmodf\fR" 8
.IX Item "modf"
Return the integral and fractional parts of a floating-point number.
.Sp
.Vb 1
\&        ($fractional, $integral) = POSIX::modf( 3.14 );
.Ve
.Sp
See also \*(L"round\*(R".
.ie n .IP """NaN""" 8
.el .IP "\f(CWNaN\fR" 8
.IX Item "NaN"
The not-a-number as a constant:
.Sp
.Vb 2
\&   use POSIX qw(NaN);
\&   my $nan = NaN;
.Ve
.Sp
See also \*(L"nan\*(R", \f(CW\*(C`/isnan\*(C'\fR, and \*(L"fpclassify\*(R".
.ie n .IP """nan""" 8
.el .IP "\f(CWnan\fR" 8
.IX Item "nan"
.Vb 1
\&   my $nan = nan();
.Ve
.Sp
Returns \f(CW\*(C`NaN\*(C'\fR, not-a-number [C99].
.Sp
The returned NaN is always a \fIquiet\fR NaN, as opposed to \fIsignaling\fR.
.Sp
With an argument, can be used to generate a NaN with \fIpayload\fR.
The argument is first interpreted as a floating point number,
but then any fractional parts are truncated (towards zero),
and the value is interpreted as an unsigned integer.
The bits of this integer are stored in the unused bits of the NaN.
.Sp
The result has a dual nature: it is a NaN, but it also carries
the integer inside it.  The integer can be retrieved with \*(L"getpayload\*(R".
Note, though, that the payload is not propagated, not even on copies,
and definitely not in arithmetic operations.
.Sp
How many bits fit in the NaN depends on what kind of floating points
are being used, but on the most common platforms (64\-bit \s-1IEEE 754,\s0
or the x86 80\-bit long doubles) there are 51 and 61 bits available,
respectively.  (There would be 52 and 62, but the quiet/signaling
bit of NaNs takes away one.)  However, because of the floating\-point\-to\-
integer-and-back conversions, please test carefully whether you get back
what you put in.  If your integers are only 32 bits wide, you probably
should not rely on more than 32 bits of payload.
.Sp
Whether a \*(L"signaling\*(R" NaN is in any way different from a \*(L"quiet\*(R" NaN,
depends on the platform.  Also note that the payload of the default
NaN (no argument to \fBnan()\fR) is not necessarily zero, use \f(CW\*(C`setpayload\*(C'\fR
to explicitly set the payload.  On some platforms like the 32\-bit x86,
(unless using the 80\-bit long doubles) the signaling bit is not supported
at all.
.Sp
See also \*(L"isnan\*(R", \*(L"NaN\*(R", \*(L"setpayload\*(R" and \*(L"issignaling\*(R".
.ie n .IP """nearbyint""" 8
.el .IP "\f(CWnearbyint\fR" 8
.IX Item "nearbyint"
Returns the nearest integer to the argument, according to the current
rounding mode (see \*(L"fegetround\*(R") [C99].
.ie n .IP """nextafter""" 8
.el .IP "\f(CWnextafter\fR" 8
.IX Item "nextafter"
Returns the next representable floating point number after \f(CW\*(C`x\*(C'\fR in the
direction of \f(CW\*(C`y\*(C'\fR [C99].
.Sp
.Vb 1
\& my $nextafter = POSIX::nextafter($x, $y);
.Ve
.Sp
Like \*(L"nexttoward\*(R", but potentially less accurate.
.ie n .IP """nexttoward""" 8
.el .IP "\f(CWnexttoward\fR" 8
.IX Item "nexttoward"
Returns the next representable floating point number after \f(CW\*(C`x\*(C'\fR in the
direction of \f(CW\*(C`y\*(C'\fR [C99].
.Sp
.Vb 1
\& my $nexttoward = POSIX::nexttoward($x, $y);
.Ve
.Sp
Like \*(L"nextafter\*(R", but potentially more accurate.
.ie n .IP """nice""" 8
.el .IP "\f(CWnice\fR" 8
.IX Item "nice"
This is similar to the C function \f(CW\*(C`nice()\*(C'\fR, for changing
the scheduling preference of the current process.  Positive
arguments mean a more polite process, negative values a more
needy process.  Normal (non-root) user processes can only change towards
being more polite.
.Sp
Returns \f(CW\*(C`undef\*(C'\fR on failure.
.ie n .IP """offsetof""" 8
.el .IP "\f(CWoffsetof\fR" 8
.IX Item "offsetof"
Not implemented.  \f(CW\*(C`offsetof()\*(C'\fR is C\-specific, you probably want to see \*(L"pack\*(R" in perlfunc instead.
.ie n .IP """open""" 8
.el .IP "\f(CWopen\fR" 8
.IX Item "open"
Open a file for reading for writing.  This returns file descriptors, not
Perl filehandles.  Use \f(CW\*(C`POSIX::close\*(C'\fR to close the file.
.Sp
Open a file read-only with mode 0666.
.Sp
.Vb 1
\&        $fd = POSIX::open( "foo" );
.Ve
.Sp
Open a file for read and write.
.Sp
.Vb 1
\&        $fd = POSIX::open( "foo", &POSIX::O_RDWR );
.Ve
.Sp
Open a file for write, with truncation.
.Sp
.Vb 3
\&        $fd = POSIX::open(
\&                "foo", &POSIX::O_WRONLY | &POSIX::O_TRUNC
\&        );
.Ve
.Sp
Create a new file with mode 0640.  Set up the file for writing.
.Sp
.Vb 3
\&        $fd = POSIX::open(
\&                "foo", &POSIX::O_CREAT | &POSIX::O_WRONLY, 0640
\&        );
.Ve
.Sp
Returns \f(CW\*(C`undef\*(C'\fR on failure.
.Sp
See also \*(L"sysopen\*(R" in perlfunc.
.ie n .IP """opendir""" 8
.el .IP "\f(CWopendir\fR" 8
.IX Item "opendir"
Open a directory for reading.
.Sp
.Vb 3
\&        $dir = POSIX::opendir( "/var" );
\&        @files = POSIX::readdir( $dir );
\&        POSIX::closedir( $dir );
.Ve
.Sp
Returns \f(CW\*(C`undef\*(C'\fR on failure.
.ie n .IP """pathconf""" 8
.el .IP "\f(CWpathconf\fR" 8
.IX Item "pathconf"
Retrieves the value of a configurable limit on a file or directory.
.Sp
The following will determine the maximum length of the longest allowable
pathname on the filesystem which holds \f(CW\*(C`/var\*(C'\fR.
.Sp
.Vb 2
\&        $path_max = POSIX::pathconf( "/var",
\&                                      &POSIX::_PC_PATH_MAX );
.Ve
.Sp
Returns \f(CW\*(C`undef\*(C'\fR on failure.
.ie n .IP """pause""" 8
.el .IP "\f(CWpause\fR" 8
.IX Item "pause"
This is similar to the C function \f(CW\*(C`pause()\*(C'\fR, which suspends
the execution of the current process until a signal is received.
.Sp
Returns \f(CW\*(C`undef\*(C'\fR on failure.
.ie n .IP """perror""" 8
.el .IP "\f(CWperror\fR" 8
.IX Item "perror"
This is identical to the C function \f(CW\*(C`perror()\*(C'\fR, which outputs to the
standard error stream the specified message followed by \f(CW": "\fR and the
current error string.  Use the \f(CW\*(C`warn()\*(C'\fR function and the \f(CW$!\fR
variable instead, see \*(L"warn\*(R" in perlfunc and \*(L"$ERRNO\*(R" in perlvar.
.ie n .IP """pipe""" 8
.el .IP "\f(CWpipe\fR" 8
.IX Item "pipe"
Create an interprocess channel.  This returns file descriptors like those
returned by \f(CW\*(C`POSIX::open\*(C'\fR.
.Sp
.Vb 3
\&        my ($read, $write) = POSIX::pipe();
\&        POSIX::write( $write, "hello", 5 );
\&        POSIX::read( $read, $buf, 5 );
.Ve
.Sp
See also \*(L"pipe\*(R" in perlfunc.
.ie n .IP """pow""" 8
.el .IP "\f(CWpow\fR" 8
.IX Item "pow"
Computes \f(CW$x\fR raised to the power \f(CW$exponent\fR.
.Sp
.Vb 1
\&        $ret = POSIX::pow( $x, $exponent );
.Ve
.Sp
You can also use the \f(CW\*(C`**\*(C'\fR operator, see perlop.
.ie n .IP """printf""" 8
.el .IP "\f(CWprintf\fR" 8
.IX Item "printf"
Formats and prints the specified arguments to \f(CW\*(C`STDOUT\*(C'\fR.
See also \*(L"printf\*(R" in perlfunc.
.ie n .IP """putc""" 8
.el .IP "\f(CWputc\fR" 8
.IX Item "putc"
Not implemented.  \f(CW\*(C`putc()\*(C'\fR is C\-specific, see \*(L"print\*(R" in perlfunc instead.
.ie n .IP """putchar""" 8
.el .IP "\f(CWputchar\fR" 8
.IX Item "putchar"
Not implemented.  \f(CW\*(C`putchar()\*(C'\fR is C\-specific, see \*(L"print\*(R" in perlfunc instead.
.ie n .IP """puts""" 8
.el .IP "\f(CWputs\fR" 8
.IX Item "puts"
Not implemented.  \f(CW\*(C`puts()\*(C'\fR is C\-specific, see \*(L"print\*(R" in perlfunc instead.
.ie n .IP """qsort""" 8
.el .IP "\f(CWqsort\fR" 8
.IX Item "qsort"
Not implemented.  \f(CW\*(C`qsort()\*(C'\fR is C\-specific, see \*(L"sort\*(R" in perlfunc instead.
.ie n .IP """raise""" 8
.el .IP "\f(CWraise\fR" 8
.IX Item "raise"
Sends the specified signal to the current process.
See also \*(L"kill\*(R" in perlfunc and the \f(CW$$\fR in \*(L"$PID\*(R" in perlvar.
.ie n .IP """rand""" 8
.el .IP "\f(CWrand\fR" 8
.IX Item "rand"
Not implemented.  \f(CW\*(C`rand()\*(C'\fR is non-portable, see \*(L"rand\*(R" in perlfunc instead.
.ie n .IP """read""" 8
.el .IP "\f(CWread\fR" 8
.IX Item "read"
Read from a file.  This uses file descriptors such as those obtained by
calling \f(CW\*(C`POSIX::open\*(C'\fR.  If the buffer \f(CW$buf\fR is not large enough for the
read then Perl will extend it to make room for the request.
.Sp
.Vb 2
\&        $fd = POSIX::open( "foo", &POSIX::O_RDONLY );
\&        $bytes = POSIX::read( $fd, $buf, 3 );
.Ve
.Sp
Returns \f(CW\*(C`undef\*(C'\fR on failure.
.Sp
See also \*(L"sysread\*(R" in perlfunc.
.ie n .IP """readdir""" 8
.el .IP "\f(CWreaddir\fR" 8
.IX Item "readdir"
This is identical to Perl's builtin \f(CW\*(C`readdir()\*(C'\fR function
for reading directory entries, see \*(L"readdir\*(R" in perlfunc.
.ie n .IP """realloc""" 8
.el .IP "\f(CWrealloc\fR" 8
.IX Item "realloc"
Not implemented.  \f(CW\*(C`realloc()\*(C'\fR is C\-specific.  Perl does memory management transparently.
.ie n .IP """remainder""" 8
.el .IP "\f(CWremainder\fR" 8
.IX Item "remainder"
Given \f(CW\*(C`x\*(C'\fR and \f(CW\*(C`y\*(C'\fR, returns the value \f(CW\*(C`x\ \-\ n*y\*(C'\fR, where \f(CW\*(C`n\*(C'\fR is the integer
closest to \f(CW\*(C`x\*(C'\fR/\f(CW\*(C`y\*(C'\fR. [C99]
.Sp
.Vb 1
\& my $remainder = POSIX::remainder($x, $y)
.Ve
.Sp
See also \*(L"remquo\*(R".
.ie n .IP """remove""" 8
.el .IP "\f(CWremove\fR" 8
.IX Item "remove"
Deletes a name from the filesystem.  Calls \*(L"unlink\*(R" in perlfunc for
files and \*(L"rmdir\*(R" in perlfunc for directories.
.ie n .IP """remquo""" 8
.el .IP "\f(CWremquo\fR" 8
.IX Item "remquo"
Like \*(L"remainder\*(R" but also returns the low-order bits of the quotient (n)
[C99]
.Sp
(This is quite esoteric interface, mainly used to implement numerical
algorithms.)
.ie n .IP """rename""" 8
.el .IP "\f(CWrename\fR" 8
.IX Item "rename"
This is identical to Perl's builtin \f(CW\*(C`rename()\*(C'\fR function
for renaming files, see \*(L"rename\*(R" in perlfunc.
.ie n .IP """rewind""" 8
.el .IP "\f(CWrewind\fR" 8
.IX Item "rewind"
Seeks to the beginning of the file.
.ie n .IP """rewinddir""" 8
.el .IP "\f(CWrewinddir\fR" 8
.IX Item "rewinddir"
This is identical to Perl's builtin \f(CW\*(C`rewinddir()\*(C'\fR function for
rewinding directory entry streams, see \*(L"rewinddir\*(R" in perlfunc.
.ie n .IP """rint""" 8
.el .IP "\f(CWrint\fR" 8
.IX Item "rint"
Identical to \*(L"lrint\*(R".
.ie n .IP """rmdir""" 8
.el .IP "\f(CWrmdir\fR" 8
.IX Item "rmdir"
This is identical to Perl's builtin \f(CW\*(C`rmdir()\*(C'\fR function
for removing (empty) directories, see \*(L"rmdir\*(R" in perlfunc.
.ie n .IP """round""" 8
.el .IP "\f(CWround\fR" 8
.IX Item "round"
Returns the integer (but still as floating point) nearest to the
argument [C99].
.Sp
See also \*(L"ceil\*(R", \*(L"floor\*(R", \*(L"lround\*(R", \*(L"modf\*(R", and \*(L"trunc\*(R".
.ie n .IP """scalbn""" 8
.el .IP "\f(CWscalbn\fR" 8
.IX Item "scalbn"
Returns \f(CW\*(C`x\ *\ 2**y\*(C'\fR [C99].
.Sp
See also \*(L"frexp\*(R" and \*(L"ldexp\*(R".
.ie n .IP """scanf""" 8
.el .IP "\f(CWscanf\fR" 8
.IX Item "scanf"
Not implemented.  \f(CW\*(C`scanf()\*(C'\fR is C\-specific, use <> and regular expressions instead,
see perlre.
.ie n .IP """setgid""" 8
.el .IP "\f(CWsetgid\fR" 8
.IX Item "setgid"
Sets the real group identifier and the effective group identifier for
this process.  Similar to assigning a value to the Perl's builtin
\&\f(CW$)\fR variable, see \*(L"$EGID\*(R" in perlvar, except that the latter
will change only the real user identifier, and that the \fBsetgid()\fR
uses only a single numeric argument, as opposed to a space-separated
list of numbers.
.ie n .IP """setjmp""" 8
.el .IP "\f(CWsetjmp\fR" 8
.IX Item "setjmp"
Not implemented.  \f(CW\*(C`setjmp()\*(C'\fR is C\-specific: use \f(CW\*(C`eval {}\*(C'\fR instead,
see \*(L"eval\*(R" in perlfunc.
.ie n .IP """setlocale""" 8
.el .IP "\f(CWsetlocale\fR" 8
.IX Item "setlocale"
\&\s-1WARNING\s0!  Do \s-1NOT\s0 use this function in a thread.  The locale
will change in all other threads at the same time, and should your
thread get paused by the operating system, and another started, that
thread will not have the locale it is expecting.  On some platforms,
there can be a race leading to segfaults if two threads call this
function nearly simultaneously.
.Sp
Modifies and queries the program's underlying locale.  Users of this
function should read perllocale, whch provides a comprehensive
discussion of Perl locale handling, knowledge of which is necessary to
properly use this function.  It contains
a section devoted to this function.
The discussion here is merely a summary reference for \f(CW\*(C`setlocale()\*(C'\fR.
Note that Perl itself is almost entirely unaffected by the locale
except within the scope of \f(CW"use\ locale"\fR.  (Exceptions are listed
in \*(L"Not within the scope of \*(R"use locale"" in perllocale.)
.Sp
The following examples assume
.Sp
.Vb 1
\&        use POSIX qw(setlocale LC_ALL LC_CTYPE);
.Ve
.Sp
has been issued.
.Sp
The following will set the traditional \s-1UNIX\s0 system locale behavior
(the second argument \f(CW"C"\fR).
.Sp
.Vb 1
\&        $loc = setlocale( LC_ALL, "C" );
.Ve
.Sp
The following will query the current \f(CW\*(C`LC_CTYPE\*(C'\fR category.  (No second
argument means 'query'.)
.Sp
.Vb 1
\&        $loc = setlocale( LC_CTYPE );
.Ve
.Sp
The following will set the \f(CW\*(C`LC_CTYPE\*(C'\fR behaviour according to the locale
environment variables (the second argument \f(CW""\fR).
Please see your system's \f(CWsetlocale(3)\fR documentation for the locale
environment variables' meaning or consult perllocale.
.Sp
.Vb 1
\&        $loc = setlocale( LC_CTYPE, "" );
.Ve
.Sp
The following will set the \f(CW\*(C`LC_COLLATE\*(C'\fR behaviour to Argentinian
Spanish. \fB\s-1NOTE\s0\fR: The naming and availability of locales depends on
your operating system. Please consult perllocale for how to find
out which locales are available in your system.
.Sp
.Vb 1
\&        $loc = setlocale( LC_COLLATE, "es_AR.ISO8859\-1" );
.Ve
.ie n .IP """setpayload""" 8
.el .IP "\f(CWsetpayload\fR" 8
.IX Item "setpayload"
.Vb 2
\&        use POSIX \*(Aq:nan_payload\*(Aq;
\&        setpayload($var, $payload);
.Ve
.Sp
Sets the \f(CW\*(C`NaN\*(C'\fR payload of var.
.Sp
\&\s-1NOTE:\s0 the NaN payload APIs are based on the latest (as of June 2015)
proposed \s-1ISO C\s0 interfaces, but they are not yet a standard.  Things
may change.
.Sp
See \*(L"nan\*(R" for more discussion about \f(CW\*(C`NaN\*(C'\fR.
.Sp
See also \*(L"setpayloadsig\*(R", \*(L"isnan\*(R", \*(L"getpayload\*(R", and \*(L"issignaling\*(R".
.ie n .IP """setpayloadsig""" 8
.el .IP "\f(CWsetpayloadsig\fR" 8
.IX Item "setpayloadsig"
.Vb 2
\&        use POSIX \*(Aq:nan_payload\*(Aq;
\&        setpayloadsig($var, $payload);
.Ve
.Sp
Like \*(L"setpayload\*(R" but also makes the NaN \fIsignaling\fR.
.Sp
Depending on the platform the NaN may or may not behave differently.
.Sp
Note the \s-1API\s0 instability warning in \*(L"setpayload\*(R".
.Sp
Note that because how the floating point formats work out, on the most
common platforms signaling payload of zero is best avoided,
since it might end up being identical to \f(CW\*(C`+Inf\*(C'\fR.
.Sp
See also \*(L"nan\*(R", \*(L"isnan\*(R", \*(L"getpayload\*(R", and \*(L"issignaling\*(R".
.ie n .IP """setpgid""" 8
.el .IP "\f(CWsetpgid\fR" 8
.IX Item "setpgid"
This is similar to the C function \f(CW\*(C`setpgid()\*(C'\fR for
setting the process group identifier of the current process.
.Sp
Returns \f(CW\*(C`undef\*(C'\fR on failure.
.ie n .IP """setsid""" 8
.el .IP "\f(CWsetsid\fR" 8
.IX Item "setsid"
This is identical to the C function \f(CW\*(C`setsid()\*(C'\fR for
setting the session identifier of the current process.
.ie n .IP """setuid""" 8
.el .IP "\f(CWsetuid\fR" 8
.IX Item "setuid"
Sets the real user identifier and the effective user identifier for
this process.  Similar to assigning a value to the Perl's builtin
\&\f(CW$<\fR variable, see \*(L"$UID\*(R" in perlvar, except that the latter
will change only the real user identifier.
.ie n .IP """sigaction""" 8
.el .IP "\f(CWsigaction\fR" 8
.IX Item "sigaction"
Detailed signal management.  This uses \f(CW\*(C`POSIX::SigAction\*(C'\fR objects for
the \f(CW\*(C`action\*(C'\fR and \f(CW\*(C`oldaction\*(C'\fR arguments (the oldaction can also be
just a hash reference).  Consult your system's \f(CW\*(C`sigaction\*(C'\fR manpage
for details, see also \f(CW\*(C`POSIX::SigRt\*(C'\fR.
.Sp
Synopsis:
.Sp
.Vb 1
\&        sigaction(signal, action, oldaction = 0)
.Ve
.Sp
Returns \f(CW\*(C`undef\*(C'\fR on failure.  The \f(CW\*(C`signal\*(C'\fR must be a number (like
\&\f(CW\*(C`SIGHUP\*(C'\fR), not a string (like \f(CW"SIGHUP"\fR), though Perl does try hard
to understand you.
.Sp
If you use the \f(CW\*(C`SA_SIGINFO\*(C'\fR flag, the signal handler will in addition to
the first argument, the signal name, also receive a second argument, a
hash reference, inside which are the following keys with the following
semantics, as defined by POSIX/SUSv3:
.Sp
.Vb 5
\&    signo       the signal number
\&    errno       the error number
\&    code        if this is zero or less, the signal was sent by
\&                a user process and the uid and pid make sense,
\&                otherwise the signal was sent by the kernel
.Ve
.Sp
The constants for specific \f(CW\*(C`code\*(C'\fR values can be imported individually
or using the \f(CW\*(C`:signal_h_si_code\*(C'\fR tag.
.Sp
The following are also defined by POSIX/SUSv3, but unfortunately
not very widely implemented:
.Sp
.Vb 6
\&    pid         the process id generating the signal
\&    uid         the uid of the process id generating the signal
\&    status      exit value or signal for SIGCHLD
\&    band        band event for SIGPOLL
\&    addr        address of faulting instruction or memory
\&                reference for SIGILL, SIGFPE, SIGSEGV or SIGBUS
.Ve
.Sp
A third argument is also passed to the handler, which contains a copy
of the raw binary contents of the \f(CW\*(C`siginfo\*(C'\fR structure: if a system has
some non-POSIX fields, this third argument is where to \f(CW\*(C`unpack()\*(C'\fR them
from.
.Sp
Note that not all \f(CW\*(C`siginfo\*(C'\fR values make sense simultaneously (some are
valid only for certain signals, for example), and not all values make
sense from Perl perspective, you should to consult your system's
\&\f(CW\*(C`sigaction\*(C'\fR and possibly also \f(CW\*(C`siginfo\*(C'\fR documentation.
.ie n .IP """siglongjmp""" 8
.el .IP "\f(CWsiglongjmp\fR" 8
.IX Item "siglongjmp"
Not implemented.  \f(CW\*(C`siglongjmp()\*(C'\fR is C\-specific: use \*(L"die\*(R" in perlfunc instead.
.ie n .IP """signbit""" 8
.el .IP "\f(CWsignbit\fR" 8
.IX Item "signbit"
Returns zero for positive arguments, non-zero for negative arguments [C99].
.ie n .IP """sigpending""" 8
.el .IP "\f(CWsigpending\fR" 8
.IX Item "sigpending"
Examine signals that are blocked and pending.  This uses \f(CW\*(C`POSIX::SigSet\*(C'\fR
objects for the \f(CW\*(C`sigset\*(C'\fR argument.  Consult your system's \f(CW\*(C`sigpending\*(C'\fR
manpage for details.
.Sp
Synopsis:
.Sp
.Vb 1
\&        sigpending(sigset)
.Ve
.Sp
Returns \f(CW\*(C`undef\*(C'\fR on failure.
.ie n .IP """sigprocmask""" 8
.el .IP "\f(CWsigprocmask\fR" 8
.IX Item "sigprocmask"
Change and/or examine calling process's signal mask.  This uses
\&\f(CW\*(C`POSIX::SigSet\*(C'\fR objects for the \f(CW\*(C`sigset\*(C'\fR and \f(CW\*(C`oldsigset\*(C'\fR arguments.
Consult your system's \f(CW\*(C`sigprocmask\*(C'\fR manpage for details.
.Sp
Synopsis:
.Sp
.Vb 1
\&        sigprocmask(how, sigset, oldsigset = 0)
.Ve
.Sp
Returns \f(CW\*(C`undef\*(C'\fR on failure.
.Sp
Note that you can't reliably block or unblock a signal from its own signal
handler if you're using safe signals. Other signals can be blocked or unblocked
reliably.
.ie n .IP """sigsetjmp""" 8
.el .IP "\f(CWsigsetjmp\fR" 8
.IX Item "sigsetjmp"
Not implemented.  \f(CW\*(C`sigsetjmp()\*(C'\fR is C\-specific: use \f(CW\*(C`eval {}\*(C'\fR instead,
see \*(L"eval\*(R" in perlfunc.
.ie n .IP """sigsuspend""" 8
.el .IP "\f(CWsigsuspend\fR" 8
.IX Item "sigsuspend"
Install a signal mask and suspend process until signal arrives.  This uses
\&\f(CW\*(C`POSIX::SigSet\*(C'\fR objects for the \f(CW\*(C`signal_mask\*(C'\fR argument.  Consult your
system's \f(CW\*(C`sigsuspend\*(C'\fR manpage for details.
.Sp
Synopsis:
.Sp
.Vb 1
\&        sigsuspend(signal_mask)
.Ve
.Sp
Returns \f(CW\*(C`undef\*(C'\fR on failure.
.ie n .IP """sin""" 8
.el .IP "\f(CWsin\fR" 8
.IX Item "sin"
This is identical to Perl's builtin \f(CW\*(C`sin()\*(C'\fR function
for returning the sine of the numerical argument,
see \*(L"sin\*(R" in perlfunc.  See also Math::Trig.
.ie n .IP """sinh""" 8
.el .IP "\f(CWsinh\fR" 8
.IX Item "sinh"
This is identical to the C function \f(CW\*(C`sinh()\*(C'\fR
for returning the hyperbolic sine of the numerical argument.
See also Math::Trig.
.ie n .IP """sleep""" 8
.el .IP "\f(CWsleep\fR" 8
.IX Item "sleep"
This is functionally identical to Perl's builtin \f(CW\*(C`sleep()\*(C'\fR function
for suspending the execution of the current for process for certain
number of seconds, see \*(L"sleep\*(R" in perlfunc.  There is one significant
difference, however: \f(CW\*(C`POSIX::sleep()\*(C'\fR returns the number of
\&\fBunslept\fR seconds, while the \f(CW\*(C`CORE::sleep()\*(C'\fR returns the
number of slept seconds.
.ie n .IP """sprintf""" 8
.el .IP "\f(CWsprintf\fR" 8
.IX Item "sprintf"
This is similar to Perl's builtin \f(CW\*(C`sprintf()\*(C'\fR function
for returning a string that has the arguments formatted as requested,
see \*(L"sprintf\*(R" in perlfunc.
.ie n .IP """sqrt""" 8
.el .IP "\f(CWsqrt\fR" 8
.IX Item "sqrt"
This is identical to Perl's builtin \f(CW\*(C`sqrt()\*(C'\fR function.
for returning the square root of the numerical argument,
see \*(L"sqrt\*(R" in perlfunc.
.ie n .IP """srand""" 8
.el .IP "\f(CWsrand\fR" 8
.IX Item "srand"
Give a seed the pseudorandom number generator, see \*(L"srand\*(R" in perlfunc.
.ie n .IP """sscanf""" 8
.el .IP "\f(CWsscanf\fR" 8
.IX Item "sscanf"
Not implemented.  \f(CW\*(C`sscanf()\*(C'\fR is C\-specific, use regular expressions instead,
see perlre.
.ie n .IP """stat""" 8
.el .IP "\f(CWstat\fR" 8
.IX Item "stat"
This is identical to Perl's builtin \f(CW\*(C`stat()\*(C'\fR function
for returning information about files and directories.
.ie n .IP """strcat""" 8
.el .IP "\f(CWstrcat\fR" 8
.IX Item "strcat"
Not implemented.  \f(CW\*(C`strcat()\*(C'\fR is C\-specific, use \f(CW\*(C`.=\*(C'\fR instead, see perlop.
.ie n .IP """strchr""" 8
.el .IP "\f(CWstrchr\fR" 8
.IX Item "strchr"
Not implemented.  \f(CW\*(C`strchr()\*(C'\fR is C\-specific, see \*(L"index\*(R" in perlfunc instead.
.ie n .IP """strcmp""" 8
.el .IP "\f(CWstrcmp\fR" 8
.IX Item "strcmp"
Not implemented.  \f(CW\*(C`strcmp()\*(C'\fR is C\-specific, use \f(CW\*(C`eq\*(C'\fR or \f(CW\*(C`cmp\*(C'\fR instead, see perlop.
.ie n .IP """strcoll""" 8
.el .IP "\f(CWstrcoll\fR" 8
.IX Item "strcoll"
This is identical to the C function \f(CW\*(C`strcoll()\*(C'\fR
for collating (comparing) strings transformed using
the \f(CW\*(C`strxfrm()\*(C'\fR function.  Not really needed since
Perl can do this transparently, see perllocale.
.Sp
Beware that in a \s-1UTF\-8\s0 locale, anything you pass to this function must
be in \s-1UTF\-8\s0; and when not in a \s-1UTF\-8\s0 locale, anything passed must not be
\&\s-1UTF\-8\s0 encoded.
.ie n .IP """strcpy""" 8
.el .IP "\f(CWstrcpy\fR" 8
.IX Item "strcpy"
Not implemented.  \f(CW\*(C`strcpy()\*(C'\fR is C\-specific, use \f(CW\*(C`=\*(C'\fR instead, see perlop.
.ie n .IP """strcspn""" 8
.el .IP "\f(CWstrcspn\fR" 8
.IX Item "strcspn"
Not implemented.  \f(CW\*(C`strcspn()\*(C'\fR is C\-specific, use regular expressions instead,
see perlre.
.ie n .IP """strerror""" 8
.el .IP "\f(CWstrerror\fR" 8
.IX Item "strerror"
Returns the error string for the specified errno.
Identical to the string form of \f(CW$!\fR, see \*(L"$ERRNO\*(R" in perlvar.
.ie n .IP """strftime""" 8
.el .IP "\f(CWstrftime\fR" 8
.IX Item "strftime"
Convert date and time information to string.  Returns the string.
.Sp
Synopsis:
.Sp
.Vb 2
\&        strftime(fmt, sec, min, hour, mday, mon, year,
\&                 wday = \-1, yday = \-1, isdst = \-1)
.Ve
.Sp
The month (\f(CW\*(C`mon\*(C'\fR), weekday (\f(CW\*(C`wday\*(C'\fR), and yearday (\f(CW\*(C`yday\*(C'\fR) begin at zero,
\&\fIi.e.\fR, January is 0, not 1; Sunday is 0, not 1; January 1st is 0, not 1.  The
year (\f(CW\*(C`year\*(C'\fR) is given in years since 1900, \fIi.e.\fR, the year 1995 is 95; the
year 2001 is 101.  Consult your system's \f(CW\*(C`strftime()\*(C'\fR manpage for details
about these and the other arguments.
.Sp
If you want your code to be portable, your format (\f(CW\*(C`fmt\*(C'\fR) argument
should use only the conversion specifiers defined by the \s-1ANSI C\s0
standard (C89, to play safe).  These are \f(CW\*(C`aAbBcdHIjmMpSUwWxXyYZ%\*(C'\fR.
But even then, the \fBresults\fR of some of the conversion specifiers are
non-portable.  For example, the specifiers \f(CW\*(C`aAbBcpZ\*(C'\fR change according
to the locale settings of the user, and both how to set locales (the
locale names) and what output to expect are non-standard.
The specifier \f(CW\*(C`c\*(C'\fR changes according to the timezone settings of the
user and the timezone computation rules of the operating system.
The \f(CW\*(C`Z\*(C'\fR specifier is notoriously unportable since the names of
timezones are non-standard. Sticking to the numeric specifiers is the
safest route.
.Sp
The given arguments are made consistent as though by calling
\&\f(CW\*(C`mktime()\*(C'\fR before calling your system's \f(CW\*(C`strftime()\*(C'\fR function,
except that the \f(CW\*(C`isdst\*(C'\fR value is not affected.
.Sp
The string for Tuesday, December 12, 1995.
.Sp
.Vb 3
\&        $str = POSIX::strftime( "%A, %B %d, %Y",
\&                                 0, 0, 0, 12, 11, 95, 2 );
\&        print "$str\en";
.Ve
.ie n .IP """strlen""" 8
.el .IP "\f(CWstrlen\fR" 8
.IX Item "strlen"
Not implemented.  \f(CW\*(C`strlen()\*(C'\fR is C\-specific, use \f(CW\*(C`length()\*(C'\fR instead, see \*(L"length\*(R" in perlfunc.
.ie n .IP """strncat""" 8
.el .IP "\f(CWstrncat\fR" 8
.IX Item "strncat"
Not implemented.  \f(CW\*(C`strncat()\*(C'\fR is C\-specific, use \f(CW\*(C`.=\*(C'\fR instead, see perlop.
.ie n .IP """strncmp""" 8
.el .IP "\f(CWstrncmp\fR" 8
.IX Item "strncmp"
Not implemented.  \f(CW\*(C`strncmp()\*(C'\fR is C\-specific, use \f(CW\*(C`eq\*(C'\fR instead, see perlop.
.ie n .IP """strncpy""" 8
.el .IP "\f(CWstrncpy\fR" 8
.IX Item "strncpy"
Not implemented.  \f(CW\*(C`strncpy()\*(C'\fR is C\-specific, use \f(CW\*(C`=\*(C'\fR instead, see perlop.
.ie n .IP """strpbrk""" 8
.el .IP "\f(CWstrpbrk\fR" 8
.IX Item "strpbrk"
Not implemented.  \f(CW\*(C`strpbrk()\*(C'\fR is C\-specific, use regular expressions instead,
see perlre.
.ie n .IP """strrchr""" 8
.el .IP "\f(CWstrrchr\fR" 8
.IX Item "strrchr"
Not implemented.  \f(CW\*(C`strrchr()\*(C'\fR is C\-specific, see \*(L"rindex\*(R" in perlfunc instead.
.ie n .IP """strspn""" 8
.el .IP "\f(CWstrspn\fR" 8
.IX Item "strspn"
Not implemented.  \f(CW\*(C`strspn()\*(C'\fR is C\-specific, use regular expressions instead,
see perlre.
.ie n .IP """strstr""" 8
.el .IP "\f(CWstrstr\fR" 8
.IX Item "strstr"
This is identical to Perl's builtin \f(CW\*(C`index()\*(C'\fR function,
see \*(L"index\*(R" in perlfunc.
.ie n .IP """strtod""" 8
.el .IP "\f(CWstrtod\fR" 8
.IX Item "strtod"
String to double translation. Returns the parsed number and the number
of characters in the unparsed portion of the string.  Truly
POSIX-compliant systems set \f(CW$!\fR (\f(CW$ERRNO\fR) to indicate a translation
error, so clear \f(CW$!\fR before calling \f(CW\*(C`strtod\*(C'\fR.  However, non-POSIX systems
may not check for overflow, and therefore will never set \f(CW$!\fR.
.Sp
\&\f(CW\*(C`strtod\*(C'\fR respects any \s-1POSIX\s0 \f(CW\*(C`setlocale()\*(C'\fR \f(CW\*(C`LC_TIME\*(C'\fR settings,
regardless of whether or not it is called from Perl code that is within
the scope of \f(CW\*(C`use\ locale\*(C'\fR.  This means it should not be used in a
threaded application unless it's certain that the underlying locale is C
or \s-1POSIX.\s0  This is because it otherwise changes the locale, which
globally affects all threads simultaneously.
.Sp
To parse a string \f(CW$str\fR as a floating point number use
.Sp
.Vb 2
\&    $! = 0;
\&    ($num, $n_unparsed) = POSIX::strtod($str);
.Ve
.Sp
The second returned item and \f(CW$!\fR can be used to check for valid input:
.Sp
.Vb 3
\&    if (($str eq \*(Aq\*(Aq) || ($n_unparsed != 0) || $!) {
\&        die "Non\-numeric input $str" . ($! ? ": $!\en" : "\en");
\&    }
.Ve
.Sp
When called in a scalar context \f(CW\*(C`strtod\*(C'\fR returns the parsed number.
.ie n .IP """strtok""" 8
.el .IP "\f(CWstrtok\fR" 8
.IX Item "strtok"
Not implemented.  \f(CW\*(C`strtok()\*(C'\fR is C\-specific, use regular expressions instead, see
perlre, or \*(L"split\*(R" in perlfunc.
.ie n .IP """strtol""" 8
.el .IP "\f(CWstrtol\fR" 8
.IX Item "strtol"
String to (long) integer translation.  Returns the parsed number and
the number of characters in the unparsed portion of the string.  Truly
POSIX-compliant systems set \f(CW$!\fR (\f(CW$ERRNO\fR) to indicate a translation
error, so clear \f(CW$!\fR before calling \f(CW\*(C`strtol\*(C'\fR.  However, non-POSIX systems
may not check for overflow, and therefore will never set \f(CW$!\fR.
.Sp
\&\f(CW\*(C`strtol\*(C'\fR should respect any \s-1POSIX\s0 \fI\f(BIsetlocale()\fI\fR settings.
.Sp
To parse a string \f(CW$str\fR as a number in some base \f(CW$base\fR use
.Sp
.Vb 2
\&    $! = 0;
\&    ($num, $n_unparsed) = POSIX::strtol($str, $base);
.Ve
.Sp
The base should be zero or between 2 and 36, inclusive.  When the base
is zero or omitted \f(CW\*(C`strtol\*(C'\fR will use the string itself to determine the
base: a leading \*(L"0x\*(R" or \*(L"0X\*(R" means hexadecimal; a leading \*(L"0\*(R" means
octal; any other leading characters mean decimal.  Thus, \*(L"1234\*(R" is
parsed as a decimal number, \*(L"01234\*(R" as an octal number, and \*(L"0x1234\*(R"
as a hexadecimal number.
.Sp
The second returned item and \f(CW$!\fR can be used to check for valid input:
.Sp
.Vb 3
\&    if (($str eq \*(Aq\*(Aq) || ($n_unparsed != 0) || !$!) {
\&        die "Non\-numeric input $str" . $! ? ": $!\en" : "\en";
\&    }
.Ve
.Sp
When called in a scalar context \f(CW\*(C`strtol\*(C'\fR returns the parsed number.
.ie n .IP """strtold""" 8
.el .IP "\f(CWstrtold\fR" 8
.IX Item "strtold"
Like \*(L"strtod\*(R" but for long doubles.  Defined only if the
system supports long doubles.
.ie n .IP """strtoul""" 8
.el .IP "\f(CWstrtoul\fR" 8
.IX Item "strtoul"
String to unsigned (long) integer translation.  \f(CW\*(C`strtoul()\*(C'\fR is identical
to \f(CW\*(C`strtol()\*(C'\fR except that \f(CW\*(C`strtoul()\*(C'\fR only parses unsigned integers.  See
\&\*(L"strtol\*(R" for details.
.Sp
Note: Some vendors supply \f(CW\*(C`strtod()\*(C'\fR and \f(CW\*(C`strtol()\*(C'\fR but not \f(CW\*(C`strtoul()\*(C'\fR.
Other vendors that do supply \f(CW\*(C`strtoul()\*(C'\fR parse \*(L"\-1\*(R" as a valid value.
.ie n .IP """strxfrm""" 8
.el .IP "\f(CWstrxfrm\fR" 8
.IX Item "strxfrm"
String transformation.  Returns the transformed string.
.Sp
.Vb 1
\&        $dst = POSIX::strxfrm( $src );
.Ve
.Sp
Used in conjunction with the \f(CW\*(C`strcoll()\*(C'\fR function, see \*(L"strcoll\*(R".
.Sp
Not really needed since Perl can do this transparently, see
perllocale.
.Sp
Beware that in a \s-1UTF\-8\s0 locale, anything you pass to this function must
be in \s-1UTF\-8\s0; and when not in a \s-1UTF\-8\s0 locale, anything passed must not be
\&\s-1UTF\-8\s0 encoded.
.ie n .IP """sysconf""" 8
.el .IP "\f(CWsysconf\fR" 8
.IX Item "sysconf"
Retrieves values of system configurable variables.
.Sp
The following will get the machine's clock speed.
.Sp
.Vb 1
\&        $clock_ticks = POSIX::sysconf( &POSIX::_SC_CLK_TCK );
.Ve
.Sp
Returns \f(CW\*(C`undef\*(C'\fR on failure.
.ie n .IP """system""" 8
.el .IP "\f(CWsystem\fR" 8
.IX Item "system"
This is identical to Perl's builtin \f(CW\*(C`system()\*(C'\fR function, see
\&\*(L"system\*(R" in perlfunc.
.ie n .IP """tan""" 8
.el .IP "\f(CWtan\fR" 8
.IX Item "tan"
This is identical to the C function \f(CW\*(C`tan()\*(C'\fR, returning the
tangent of the numerical argument.  See also Math::Trig.
.ie n .IP """tanh""" 8
.el .IP "\f(CWtanh\fR" 8
.IX Item "tanh"
This is identical to the C function \f(CW\*(C`tanh()\*(C'\fR, returning the
hyperbolic tangent of the numerical argument.   See also Math::Trig.
.ie n .IP """tcdrain""" 8
.el .IP "\f(CWtcdrain\fR" 8
.IX Item "tcdrain"
This is similar to the C function \f(CW\*(C`tcdrain()\*(C'\fR for draining
the output queue of its argument stream.
.Sp
Returns \f(CW\*(C`undef\*(C'\fR on failure.
.ie n .IP """tcflow""" 8
.el .IP "\f(CWtcflow\fR" 8
.IX Item "tcflow"
This is similar to the C function \f(CW\*(C`tcflow()\*(C'\fR for controlling
the flow of its argument stream.
.Sp
Returns \f(CW\*(C`undef\*(C'\fR on failure.
.ie n .IP """tcflush""" 8
.el .IP "\f(CWtcflush\fR" 8
.IX Item "tcflush"
This is similar to the C function \f(CW\*(C`tcflush()\*(C'\fR for flushing
the I/O buffers of its argument stream.
.Sp
Returns \f(CW\*(C`undef\*(C'\fR on failure.
.ie n .IP """tcgetpgrp""" 8
.el .IP "\f(CWtcgetpgrp\fR" 8
.IX Item "tcgetpgrp"
This is identical to the C function \f(CW\*(C`tcgetpgrp()\*(C'\fR for returning the
process group identifier of the foreground process group of the controlling
terminal.
.ie n .IP """tcsendbreak""" 8
.el .IP "\f(CWtcsendbreak\fR" 8
.IX Item "tcsendbreak"
This is similar to the C function \f(CW\*(C`tcsendbreak()\*(C'\fR for sending
a break on its argument stream.
.Sp
Returns \f(CW\*(C`undef\*(C'\fR on failure.
.ie n .IP """tcsetpgrp""" 8
.el .IP "\f(CWtcsetpgrp\fR" 8
.IX Item "tcsetpgrp"
This is similar to the C function \f(CW\*(C`tcsetpgrp()\*(C'\fR for setting the
process group identifier of the foreground process group of the controlling
terminal.
.Sp
Returns \f(CW\*(C`undef\*(C'\fR on failure.
.ie n .IP """tgamma""" 8
.el .IP "\f(CWtgamma\fR" 8
.IX Item "tgamma"
The Gamma function [C99].
.Sp
See also \*(L"lgamma\*(R".
.ie n .IP """time""" 8
.el .IP "\f(CWtime\fR" 8
.IX Item "time"
This is identical to Perl's builtin \f(CW\*(C`time()\*(C'\fR function
for returning the number of seconds since the epoch
(whatever it is for the system), see \*(L"time\*(R" in perlfunc.
.ie n .IP """times""" 8
.el .IP "\f(CWtimes\fR" 8
.IX Item "times"
The \f(CW\*(C`times()\*(C'\fR function returns elapsed realtime since some point in the past
(such as system startup), user and system times for this process, and user
and system times used by child processes.  All times are returned in clock
ticks.
.Sp
.Vb 2
\&    ($realtime, $user, $system, $cuser, $csystem)
\&        = POSIX::times();
.Ve
.Sp
Note: Perl's builtin \f(CW\*(C`times()\*(C'\fR function returns four values, measured in
seconds.
.ie n .IP """tmpfile""" 8
.el .IP "\f(CWtmpfile\fR" 8
.IX Item "tmpfile"
Not implemented.  Use method \f(CW\*(C`IO::File::new_tmpfile()\*(C'\fR instead, or see File::Temp.
.ie n .IP """tmpnam""" 8
.el .IP "\f(CWtmpnam\fR" 8
.IX Item "tmpnam"
For security reasons, which are probably detailed in your system's
documentation for the C library \f(CW\*(C`tmpnam()\*(C'\fR function, this interface
is no longer available; instead use File::Temp.
.ie n .IP """tolower""" 8
.el .IP "\f(CWtolower\fR" 8
.IX Item "tolower"
This is identical to the C function, except that it can apply to a single
character or to a whole string, and currently operates as if the locale
always is \*(L"C\*(R".  Consider using the \f(CW\*(C`lc()\*(C'\fR function, see \*(L"lc\*(R" in perlfunc,
see \*(L"lc\*(R" in perlfunc, or the equivalent \f(CW\*(C`\eL\*(C'\fR operator inside doublequotish
strings.
.ie n .IP """toupper""" 8
.el .IP "\f(CWtoupper\fR" 8
.IX Item "toupper"
This is similar to the C function, except that it can apply to a single
character or to a whole string, and currently operates as if the locale
always is \*(L"C\*(R".  Consider using the \f(CW\*(C`uc()\*(C'\fR function, see \*(L"uc\*(R" in perlfunc,
or the equivalent \f(CW\*(C`\eU\*(C'\fR operator inside doublequotish strings.
.ie n .IP """trunc""" 8
.el .IP "\f(CWtrunc\fR" 8
.IX Item "trunc"
Returns the integer toward zero from the argument [C99].
.Sp
See also \*(L"ceil\*(R", \*(L"floor\*(R", and \*(L"round\*(R".
.ie n .IP """ttyname""" 8
.el .IP "\f(CWttyname\fR" 8
.IX Item "ttyname"
This is identical to the C function \f(CW\*(C`ttyname()\*(C'\fR for returning the
name of the current terminal.
.ie n .IP """tzname""" 8
.el .IP "\f(CWtzname\fR" 8
.IX Item "tzname"
Retrieves the time conversion information from the \f(CW\*(C`tzname\*(C'\fR variable.
.Sp
.Vb 2
\&        POSIX::tzset();
\&        ($std, $dst) = POSIX::tzname();
.Ve
.ie n .IP """tzset""" 8
.el .IP "\f(CWtzset\fR" 8
.IX Item "tzset"
This is identical to the C function \f(CW\*(C`tzset()\*(C'\fR for setting
the current timezone based on the environment variable \f(CW\*(C`TZ\*(C'\fR,
to be used by \f(CW\*(C`ctime()\*(C'\fR, \f(CW\*(C`localtime()\*(C'\fR, \f(CW\*(C`mktime()\*(C'\fR, and \f(CW\*(C`strftime()\*(C'\fR
functions.
.ie n .IP """umask""" 8
.el .IP "\f(CWumask\fR" 8
.IX Item "umask"
This is identical to Perl's builtin \f(CW\*(C`umask()\*(C'\fR function
for setting (and querying) the file creation permission mask,
see \*(L"umask\*(R" in perlfunc.
.ie n .IP """uname""" 8
.el .IP "\f(CWuname\fR" 8
.IX Item "uname"
Get name of current operating system.
.Sp
.Vb 2
\&        ($sysname, $nodename, $release, $version, $machine)
\&                = POSIX::uname();
.Ve
.Sp
Note that the actual meanings of the various fields are not
that well standardized, do not expect any great portability.
The \f(CW$sysname\fR might be the name of the operating system,
the \f(CW$nodename\fR might be the name of the host, the \f(CW$release\fR
might be the (major) release number of the operating system,
the \f(CW$version\fR might be the (minor) release number of the
operating system, and the \f(CW$machine\fR might be a hardware identifier.
Maybe.
.ie n .IP """ungetc""" 8
.el .IP "\f(CWungetc\fR" 8
.IX Item "ungetc"
Not implemented.  Use method \f(CW\*(C`IO::Handle::ungetc()\*(C'\fR instead.
.ie n .IP """unlink""" 8
.el .IP "\f(CWunlink\fR" 8
.IX Item "unlink"
This is identical to Perl's builtin \f(CW\*(C`unlink()\*(C'\fR function
for removing files, see \*(L"unlink\*(R" in perlfunc.
.ie n .IP """utime""" 8
.el .IP "\f(CWutime\fR" 8
.IX Item "utime"
This is identical to Perl's builtin \f(CW\*(C`utime()\*(C'\fR function
for changing the time stamps of files and directories,
see \*(L"utime\*(R" in perlfunc.
.ie n .IP """vfprintf""" 8
.el .IP "\f(CWvfprintf\fR" 8
.IX Item "vfprintf"
Not implemented.  \f(CW\*(C`vfprintf()\*(C'\fR is C\-specific, see \*(L"printf\*(R" in perlfunc instead.
.ie n .IP """vprintf""" 8
.el .IP "\f(CWvprintf\fR" 8
.IX Item "vprintf"
Not implemented.  \f(CW\*(C`vprintf()\*(C'\fR is C\-specific, see \*(L"printf\*(R" in perlfunc instead.
.ie n .IP """vsprintf""" 8
.el .IP "\f(CWvsprintf\fR" 8
.IX Item "vsprintf"
Not implemented.  \f(CW\*(C`vsprintf()\*(C'\fR is C\-specific, see \*(L"sprintf\*(R" in perlfunc instead.
.ie n .IP """wait""" 8
.el .IP "\f(CWwait\fR" 8
.IX Item "wait"
This is identical to Perl's builtin \f(CW\*(C`wait()\*(C'\fR function,
see \*(L"wait\*(R" in perlfunc.
.ie n .IP """waitpid""" 8
.el .IP "\f(CWwaitpid\fR" 8
.IX Item "waitpid"
Wait for a child process to change state.  This is identical to Perl's
builtin \f(CW\*(C`waitpid()\*(C'\fR function, see \*(L"waitpid\*(R" in perlfunc.
.Sp
.Vb 2
\&        $pid = POSIX::waitpid( \-1, POSIX::WNOHANG );
\&        print "status = ", ($? / 256), "\en";
.Ve
.ie n .IP """wcstombs""" 8
.el .IP "\f(CWwcstombs\fR" 8
.IX Item "wcstombs"
This is identical to the C function \f(CW\*(C`wcstombs()\*(C'\fR.
.Sp
See \*(L"mblen\*(R".
.ie n .IP """wctomb""" 8
.el .IP "\f(CWwctomb\fR" 8
.IX Item "wctomb"
This is identical to the C function \f(CW\*(C`wctomb()\*(C'\fR.
.Sp
See \*(L"mblen\*(R".
.ie n .IP """write""" 8
.el .IP "\f(CWwrite\fR" 8
.IX Item "write"
Write to a file.  This uses file descriptors such as those obtained by
calling \f(CW\*(C`POSIX::open\*(C'\fR.
.Sp
.Vb 3
\&        $fd = POSIX::open( "foo", &POSIX::O_WRONLY );
\&        $buf = "hello";
\&        $bytes = POSIX::write( $fd, $buf, 5 );
.Ve
.Sp
Returns \f(CW\*(C`undef\*(C'\fR on failure.
.Sp
See also \*(L"syswrite\*(R" in perlfunc.
.SH "CLASSES"
.IX Header "CLASSES"
.ie n .SS """POSIX::SigAction"""
.el .SS "\f(CWPOSIX::SigAction\fP"
.IX Subsection "POSIX::SigAction"
.ie n .IP """new""" 8
.el .IP "\f(CWnew\fR" 8
.IX Item "new"
Creates a new \f(CW\*(C`POSIX::SigAction\*(C'\fR object which corresponds to the C
\&\f(CW\*(C`struct sigaction\*(C'\fR.  This object will be destroyed automatically when
it is no longer needed.  The first parameter is the handler, a sub
reference.  The second parameter is a \f(CW\*(C`POSIX::SigSet\*(C'\fR object, it
defaults to the empty set.  The third parameter contains the
\&\f(CW\*(C`sa_flags\*(C'\fR, it defaults to 0.
.Sp
.Vb 4
\&        $sigset = POSIX::SigSet\->new(SIGINT, SIGQUIT);
\&        $sigaction = POSIX::SigAction\->new(
\&                        \e&handler, $sigset, &POSIX::SA_NOCLDSTOP
\&                     );
.Ve
.Sp
This \f(CW\*(C`POSIX::SigAction\*(C'\fR object is intended for use with the \f(CW\*(C`POSIX::sigaction()\*(C'\fR
function.
.ie n .IP """handler""" 8
.el .IP "\f(CWhandler\fR" 8
.IX Item "handler"
.PD 0
.ie n .IP """mask""" 8
.el .IP "\f(CWmask\fR" 8
.IX Item "mask"
.ie n .IP """flags""" 8
.el .IP "\f(CWflags\fR" 8
.IX Item "flags"
.PD
accessor functions to get/set the values of a SigAction object.
.Sp
.Vb 2
\&        $sigset = $sigaction\->mask;
\&        $sigaction\->flags(&POSIX::SA_RESTART);
.Ve
.ie n .IP """safe""" 8
.el .IP "\f(CWsafe\fR" 8
.IX Item "safe"
accessor function for the \*(L"safe signals\*(R" flag of a SigAction object; see
perlipc for general information on safe (a.k.a. \*(L"deferred\*(R") signals.  If
you wish to handle a signal safely, use this accessor to set the \*(L"safe\*(R" flag
in the \f(CW\*(C`POSIX::SigAction\*(C'\fR object:
.Sp
.Vb 1
\&        $sigaction\->safe(1);
.Ve
.Sp
You may also examine the \*(L"safe\*(R" flag on the output action object which is
filled in when given as the third parameter to \f(CW\*(C`POSIX::sigaction()\*(C'\fR:
.Sp
.Vb 4
\&        sigaction(SIGINT, $new_action, $old_action);
\&        if ($old_action\->safe) {
\&            # previous SIGINT handler used safe signals
\&        }
.Ve
.ie n .SS """POSIX::SigRt"""
.el .SS "\f(CWPOSIX::SigRt\fP"
.IX Subsection "POSIX::SigRt"
.ie n .IP "%SIGRT" 8
.el .IP "\f(CW%SIGRT\fR" 8
.IX Item "%SIGRT"
A hash of the \s-1POSIX\s0 realtime signal handlers.  It is an extension of
the standard \f(CW%SIG\fR, the \f(CW$POSIX::SIGRT{SIGRTMIN}\fR is roughly equivalent
to \f(CW$SIG{SIGRTMIN}\fR, but the right \s-1POSIX\s0 moves (see below) are made with
the \f(CW\*(C`POSIX::SigSet\*(C'\fR and \f(CW\*(C`POSIX::sigaction\*(C'\fR instead of accessing the \f(CW%SIG\fR.
.Sp
You can set the \f(CW%POSIX::SIGRT\fR elements to set the \s-1POSIX\s0 realtime
signal handlers, use \f(CW\*(C`delete\*(C'\fR and \f(CW\*(C`exists\*(C'\fR on the elements, and use
\&\f(CW\*(C`scalar\*(C'\fR on the \f(CW%POSIX::SIGRT\fR to find out how many \s-1POSIX\s0 realtime
signals there are available \f(CW\*(C`(SIGRTMAX\ \-\ SIGRTMIN\ +\ 1\*(C'\fR, the \f(CW\*(C`SIGRTMAX\*(C'\fR is
a valid \s-1POSIX\s0 realtime signal).
.Sp
Setting the \f(CW%SIGRT\fR elements is equivalent to calling this:
.Sp
.Vb 6
\&  sub new {
\&    my ($rtsig, $handler, $flags) = @_;
\&    my $sigset = POSIX::SigSet($rtsig);
\&    my $sigact = POSIX::SigAction\->new($handler,$sigset,$flags);
\&    sigaction($rtsig, $sigact);
\&  }
.Ve
.Sp
The flags default to zero, if you want something different you can
either use \f(CW\*(C`local\*(C'\fR on \f(CW$POSIX::SigRt::SIGACTION_FLAGS\fR, or you can
derive from POSIX::SigRt and define your own \f(CW\*(C`new()\*(C'\fR (the tied hash
\&\s-1STORE\s0 method of the \f(CW%SIGRT\fR calls \f(CW\*(C`new($rtsig, $handler, $SIGACTION_FLAGS)\*(C'\fR,
where the \f(CW$rtsig\fR ranges from zero to \f(CW\*(C`SIGRTMAX\ \-\ SIGRTMIN\ +\ 1)\*(C'\fR.
.Sp
Just as with any signal, you can use \f(CW\*(C`sigaction($rtsig, undef, $oa)\*(C'\fR to
retrieve the installed signal handler (or, rather, the signal action).
.Sp
\&\fB\s-1NOTE:\s0\fR whether \s-1POSIX\s0 realtime signals really work in your system, or
whether Perl has been compiled so that it works with them, is outside
of this discussion.
.ie n .IP """SIGRTMIN""" 8
.el .IP "\f(CWSIGRTMIN\fR" 8
.IX Item "SIGRTMIN"
Return the minimum \s-1POSIX\s0 realtime signal number available, or \f(CW\*(C`undef\*(C'\fR
if no \s-1POSIX\s0 realtime signals are available.
.ie n .IP """SIGRTMAX""" 8
.el .IP "\f(CWSIGRTMAX\fR" 8
.IX Item "SIGRTMAX"
Return the maximum \s-1POSIX\s0 realtime signal number available, or \f(CW\*(C`undef\*(C'\fR
if no \s-1POSIX\s0 realtime signals are available.
.ie n .SS """POSIX::SigSet"""
.el .SS "\f(CWPOSIX::SigSet\fP"
.IX Subsection "POSIX::SigSet"
.ie n .IP """new""" 8
.el .IP "\f(CWnew\fR" 8
.IX Item "new"
Create a new SigSet object.  This object will be destroyed automatically
when it is no longer needed.  Arguments may be supplied to initialize the
set.
.Sp
Create an empty set.
.Sp
.Vb 1
\&        $sigset = POSIX::SigSet\->new;
.Ve
.Sp
Create a set with \f(CW\*(C`SIGUSR1\*(C'\fR.
.Sp
.Vb 1
\&        $sigset = POSIX::SigSet\->new( &POSIX::SIGUSR1 );
.Ve
.ie n .IP """addset""" 8
.el .IP "\f(CWaddset\fR" 8
.IX Item "addset"
Add a signal to a SigSet object.
.Sp
.Vb 1
\&        $sigset\->addset( &POSIX::SIGUSR2 );
.Ve
.Sp
Returns \f(CW\*(C`undef\*(C'\fR on failure.
.ie n .IP """delset""" 8
.el .IP "\f(CWdelset\fR" 8
.IX Item "delset"
Remove a signal from the SigSet object.
.Sp
.Vb 1
\&        $sigset\->delset( &POSIX::SIGUSR2 );
.Ve
.Sp
Returns \f(CW\*(C`undef\*(C'\fR on failure.
.ie n .IP """emptyset""" 8
.el .IP "\f(CWemptyset\fR" 8
.IX Item "emptyset"
Initialize the SigSet object to be empty.
.Sp
.Vb 1
\&        $sigset\->emptyset();
.Ve
.Sp
Returns \f(CW\*(C`undef\*(C'\fR on failure.
.ie n .IP """fillset""" 8
.el .IP "\f(CWfillset\fR" 8
.IX Item "fillset"
Initialize the SigSet object to include all signals.
.Sp
.Vb 1
\&        $sigset\->fillset();
.Ve
.Sp
Returns \f(CW\*(C`undef\*(C'\fR on failure.
.ie n .IP """ismember""" 8
.el .IP "\f(CWismember\fR" 8
.IX Item "ismember"
Tests the SigSet object to see if it contains a specific signal.
.Sp
.Vb 3
\&        if( $sigset\->ismember( &POSIX::SIGUSR1 ) ){
\&                print "contains SIGUSR1\en";
\&        }
.Ve
.ie n .SS """POSIX::Termios"""
.el .SS "\f(CWPOSIX::Termios\fP"
.IX Subsection "POSIX::Termios"
.ie n .IP """new""" 8
.el .IP "\f(CWnew\fR" 8
.IX Item "new"
Create a new Termios object.  This object will be destroyed automatically
when it is no longer needed.  A Termios object corresponds to the \f(CW\*(C`termios\*(C'\fR
C struct.  \f(CW\*(C`new()\*(C'\fR mallocs a new one, \f(CW\*(C`getattr()\*(C'\fR fills it from a file descriptor,
and \f(CW\*(C`setattr()\*(C'\fR sets a file descriptor's parameters to match Termios' contents.
.Sp
.Vb 1
\&        $termios = POSIX::Termios\->new;
.Ve
.ie n .IP """getattr""" 8
.el .IP "\f(CWgetattr\fR" 8
.IX Item "getattr"
Get terminal control attributes.
.Sp
Obtain the attributes for \f(CW\*(C`stdin\*(C'\fR.
.Sp
.Vb 2
\&        $termios\->getattr( 0 ) # Recommended for clarity.
\&        $termios\->getattr()
.Ve
.Sp
Obtain the attributes for stdout.
.Sp
.Vb 1
\&        $termios\->getattr( 1 )
.Ve
.Sp
Returns \f(CW\*(C`undef\*(C'\fR on failure.
.ie n .IP """getcc""" 8
.el .IP "\f(CWgetcc\fR" 8
.IX Item "getcc"
Retrieve a value from the \f(CW\*(C`c_cc\*(C'\fR field of a \f(CW\*(C`termios\*(C'\fR object.  The \f(CW\*(C`c_cc\*(C'\fR field is
an array so an index must be specified.
.Sp
.Vb 1
\&        $c_cc[1] = $termios\->getcc(1);
.Ve
.ie n .IP """getcflag""" 8
.el .IP "\f(CWgetcflag\fR" 8
.IX Item "getcflag"
Retrieve the \f(CW\*(C`c_cflag\*(C'\fR field of a \f(CW\*(C`termios\*(C'\fR object.
.Sp
.Vb 1
\&        $c_cflag = $termios\->getcflag;
.Ve
.ie n .IP """getiflag""" 8
.el .IP "\f(CWgetiflag\fR" 8
.IX Item "getiflag"
Retrieve the \f(CW\*(C`c_iflag\*(C'\fR field of a \f(CW\*(C`termios\*(C'\fR object.
.Sp
.Vb 1
\&        $c_iflag = $termios\->getiflag;
.Ve
.ie n .IP """getispeed""" 8
.el .IP "\f(CWgetispeed\fR" 8
.IX Item "getispeed"
Retrieve the input baud rate.
.Sp
.Vb 1
\&        $ispeed = $termios\->getispeed;
.Ve
.ie n .IP """getlflag""" 8
.el .IP "\f(CWgetlflag\fR" 8
.IX Item "getlflag"
Retrieve the \f(CW\*(C`c_lflag\*(C'\fR field of a \f(CW\*(C`termios\*(C'\fR object.
.Sp
.Vb 1
\&        $c_lflag = $termios\->getlflag;
.Ve
.ie n .IP """getoflag""" 8
.el .IP "\f(CWgetoflag\fR" 8
.IX Item "getoflag"
Retrieve the \f(CW\*(C`c_oflag\*(C'\fR field of a \f(CW\*(C`termios\*(C'\fR object.
.Sp
.Vb 1
\&        $c_oflag = $termios\->getoflag;
.Ve
.ie n .IP """getospeed""" 8
.el .IP "\f(CWgetospeed\fR" 8
.IX Item "getospeed"
Retrieve the output baud rate.
.Sp
.Vb 1
\&        $ospeed = $termios\->getospeed;
.Ve
.ie n .IP """setattr""" 8
.el .IP "\f(CWsetattr\fR" 8
.IX Item "setattr"
Set terminal control attributes.
.Sp
Set attributes immediately for stdout.
.Sp
.Vb 1
\&        $termios\->setattr( 1, &POSIX::TCSANOW );
.Ve
.Sp
Returns \f(CW\*(C`undef\*(C'\fR on failure.
.ie n .IP """setcc""" 8
.el .IP "\f(CWsetcc\fR" 8
.IX Item "setcc"
Set a value in the \f(CW\*(C`c_cc\*(C'\fR field of a \f(CW\*(C`termios\*(C'\fR object.  The \f(CW\*(C`c_cc\*(C'\fR field is an
array so an index must be specified.
.Sp
.Vb 1
\&        $termios\->setcc( &POSIX::VEOF, 1 );
.Ve
.ie n .IP """setcflag""" 8
.el .IP "\f(CWsetcflag\fR" 8
.IX Item "setcflag"
Set the \f(CW\*(C`c_cflag\*(C'\fR field of a \f(CW\*(C`termios\*(C'\fR object.
.Sp
.Vb 1
\&        $termios\->setcflag( $c_cflag | &POSIX::CLOCAL );
.Ve
.ie n .IP """setiflag""" 8
.el .IP "\f(CWsetiflag\fR" 8
.IX Item "setiflag"
Set the \f(CW\*(C`c_iflag\*(C'\fR field of a \f(CW\*(C`termios\*(C'\fR object.
.Sp
.Vb 1
\&        $termios\->setiflag( $c_iflag | &POSIX::BRKINT );
.Ve
.ie n .IP """setispeed""" 8
.el .IP "\f(CWsetispeed\fR" 8
.IX Item "setispeed"
Set the input baud rate.
.Sp
.Vb 1
\&        $termios\->setispeed( &POSIX::B9600 );
.Ve
.Sp
Returns \f(CW\*(C`undef\*(C'\fR on failure.
.ie n .IP """setlflag""" 8
.el .IP "\f(CWsetlflag\fR" 8
.IX Item "setlflag"
Set the \f(CW\*(C`c_lflag\*(C'\fR field of a \f(CW\*(C`termios\*(C'\fR object.
.Sp
.Vb 1
\&        $termios\->setlflag( $c_lflag | &POSIX::ECHO );
.Ve
.ie n .IP """setoflag""" 8
.el .IP "\f(CWsetoflag\fR" 8
.IX Item "setoflag"
Set the \f(CW\*(C`c_oflag\*(C'\fR field of a \f(CW\*(C`termios\*(C'\fR object.
.Sp
.Vb 1
\&        $termios\->setoflag( $c_oflag | &POSIX::OPOST );
.Ve
.ie n .IP """setospeed""" 8
.el .IP "\f(CWsetospeed\fR" 8
.IX Item "setospeed"
Set the output baud rate.
.Sp
.Vb 1
\&        $termios\->setospeed( &POSIX::B9600 );
.Ve
.Sp
Returns \f(CW\*(C`undef\*(C'\fR on failure.
.IP "Baud rate values" 8
.IX Item "Baud rate values"
\&\f(CW\*(C`B38400\*(C'\fR \f(CW\*(C`B75\*(C'\fR \f(CW\*(C`B200\*(C'\fR \f(CW\*(C`B134\*(C'\fR \f(CW\*(C`B300\*(C'\fR \f(CW\*(C`B1800\*(C'\fR \f(CW\*(C`B150\*(C'\fR \f(CW\*(C`B0\*(C'\fR \f(CW\*(C`B19200\*(C'\fR \f(CW\*(C`B1200\*(C'\fR \f(CW\*(C`B9600\*(C'\fR \f(CW\*(C`B600\*(C'\fR \f(CW\*(C`B4800\*(C'\fR \f(CW\*(C`B50\*(C'\fR \f(CW\*(C`B2400\*(C'\fR \f(CW\*(C`B110\*(C'\fR
.IP "Terminal interface values" 8
.IX Item "Terminal interface values"
\&\f(CW\*(C`TCSADRAIN\*(C'\fR \f(CW\*(C`TCSANOW\*(C'\fR \f(CW\*(C`TCOON\*(C'\fR \f(CW\*(C`TCIOFLUSH\*(C'\fR \f(CW\*(C`TCOFLUSH\*(C'\fR \f(CW\*(C`TCION\*(C'\fR \f(CW\*(C`TCIFLUSH\*(C'\fR \f(CW\*(C`TCSAFLUSH\*(C'\fR \f(CW\*(C`TCIOFF\*(C'\fR \f(CW\*(C`TCOOFF\*(C'\fR
.ie n .IP """c_cc"" field values" 8
.el .IP "\f(CWc_cc\fR field values" 8
.IX Item "c_cc field values"
\&\f(CW\*(C`VEOF\*(C'\fR \f(CW\*(C`VEOL\*(C'\fR \f(CW\*(C`VERASE\*(C'\fR \f(CW\*(C`VINTR\*(C'\fR \f(CW\*(C`VKILL\*(C'\fR \f(CW\*(C`VQUIT\*(C'\fR \f(CW\*(C`VSUSP\*(C'\fR \f(CW\*(C`VSTART\*(C'\fR \f(CW\*(C`VSTOP\*(C'\fR \f(CW\*(C`VMIN\*(C'\fR \f(CW\*(C`VTIME\*(C'\fR \f(CW\*(C`NCCS\*(C'\fR
.ie n .IP """c_cflag"" field values" 8
.el .IP "\f(CWc_cflag\fR field values" 8
.IX Item "c_cflag field values"
\&\f(CW\*(C`CLOCAL\*(C'\fR \f(CW\*(C`CREAD\*(C'\fR \f(CW\*(C`CSIZE\*(C'\fR \f(CW\*(C`CS5\*(C'\fR \f(CW\*(C`CS6\*(C'\fR \f(CW\*(C`CS7\*(C'\fR \f(CW\*(C`CS8\*(C'\fR \f(CW\*(C`CSTOPB\*(C'\fR \f(CW\*(C`HUPCL\*(C'\fR \f(CW\*(C`PARENB\*(C'\fR \f(CW\*(C`PARODD\*(C'\fR
.ie n .IP """c_iflag"" field values" 8
.el .IP "\f(CWc_iflag\fR field values" 8
.IX Item "c_iflag field values"
\&\f(CW\*(C`BRKINT\*(C'\fR \f(CW\*(C`ICRNL\*(C'\fR \f(CW\*(C`IGNBRK\*(C'\fR \f(CW\*(C`IGNCR\*(C'\fR \f(CW\*(C`IGNPAR\*(C'\fR \f(CW\*(C`INLCR\*(C'\fR \f(CW\*(C`INPCK\*(C'\fR \f(CW\*(C`ISTRIP\*(C'\fR \f(CW\*(C`IXOFF\*(C'\fR \f(CW\*(C`IXON\*(C'\fR \f(CW\*(C`PARMRK\*(C'\fR
.ie n .IP """c_lflag"" field values" 8
.el .IP "\f(CWc_lflag\fR field values" 8
.IX Item "c_lflag field values"
\&\f(CW\*(C`ECHO\*(C'\fR \f(CW\*(C`ECHOE\*(C'\fR \f(CW\*(C`ECHOK\*(C'\fR \f(CW\*(C`ECHONL\*(C'\fR \f(CW\*(C`ICANON\*(C'\fR \f(CW\*(C`IEXTEN\*(C'\fR \f(CW\*(C`ISIG\*(C'\fR \f(CW\*(C`NOFLSH\*(C'\fR \f(CW\*(C`TOSTOP\*(C'\fR
.ie n .IP """c_oflag"" field values" 8
.el .IP "\f(CWc_oflag\fR field values" 8
.IX Item "c_oflag field values"
\&\f(CW\*(C`OPOST\*(C'\fR
.SH "PATHNAME CONSTANTS"
.IX Header "PATHNAME CONSTANTS"
.IP "Constants" 8
.IX Item "Constants"
\&\f(CW\*(C`_PC_CHOWN_RESTRICTED\*(C'\fR \f(CW\*(C`_PC_LINK_MAX\*(C'\fR \f(CW\*(C`_PC_MAX_CANON\*(C'\fR \f(CW\*(C`_PC_MAX_INPUT\*(C'\fR \f(CW\*(C`_PC_NAME_MAX\*(C'\fR
\&\f(CW\*(C`_PC_NO_TRUNC\*(C'\fR \f(CW\*(C`_PC_PATH_MAX\*(C'\fR \f(CW\*(C`_PC_PIPE_BUF\*(C'\fR \f(CW\*(C`_PC_VDISABLE\*(C'\fR
.SH "POSIX CONSTANTS"
.IX Header "POSIX CONSTANTS"
.IP "Constants" 8
.IX Item "Constants"
\&\f(CW\*(C`_POSIX_ARG_MAX\*(C'\fR \f(CW\*(C`_POSIX_CHILD_MAX\*(C'\fR \f(CW\*(C`_POSIX_CHOWN_RESTRICTED\*(C'\fR \f(CW\*(C`_POSIX_JOB_CONTROL\*(C'\fR
\&\f(CW\*(C`_POSIX_LINK_MAX\*(C'\fR \f(CW\*(C`_POSIX_MAX_CANON\*(C'\fR \f(CW\*(C`_POSIX_MAX_INPUT\*(C'\fR \f(CW\*(C`_POSIX_NAME_MAX\*(C'\fR
\&\f(CW\*(C`_POSIX_NGROUPS_MAX\*(C'\fR \f(CW\*(C`_POSIX_NO_TRUNC\*(C'\fR \f(CW\*(C`_POSIX_OPEN_MAX\*(C'\fR \f(CW\*(C`_POSIX_PATH_MAX\*(C'\fR
\&\f(CW\*(C`_POSIX_PIPE_BUF\*(C'\fR \f(CW\*(C`_POSIX_SAVED_IDS\*(C'\fR \f(CW\*(C`_POSIX_SSIZE_MAX\*(C'\fR \f(CW\*(C`_POSIX_STREAM_MAX\*(C'\fR
\&\f(CW\*(C`_POSIX_TZNAME_MAX\*(C'\fR \f(CW\*(C`_POSIX_VDISABLE\*(C'\fR \f(CW\*(C`_POSIX_VERSION\*(C'\fR
.SH "RESOURCE CONSTANTS"
.IX Header "RESOURCE CONSTANTS"
Imported with the \f(CW\*(C`:sys_resource_h\*(C'\fR tag.
.IP "Constants" 8
.IX Item "Constants"
\&\f(CW\*(C`PRIO_PROCESS\*(C'\fR \f(CW\*(C`PRIO_PGRP\*(C'\fR \f(CW\*(C`PRIO_USER\*(C'\fR
.SH "SYSTEM CONFIGURATION"
.IX Header "SYSTEM CONFIGURATION"
.IP "Constants" 8
.IX Item "Constants"
\&\f(CW\*(C`_SC_ARG_MAX\*(C'\fR \f(CW\*(C`_SC_CHILD_MAX\*(C'\fR \f(CW\*(C`_SC_CLK_TCK\*(C'\fR \f(CW\*(C`_SC_JOB_CONTROL\*(C'\fR \f(CW\*(C`_SC_NGROUPS_MAX\*(C'\fR
\&\f(CW\*(C`_SC_OPEN_MAX\*(C'\fR \f(CW\*(C`_SC_PAGESIZE\*(C'\fR \f(CW\*(C`_SC_SAVED_IDS\*(C'\fR \f(CW\*(C`_SC_STREAM_MAX\*(C'\fR \f(CW\*(C`_SC_TZNAME_MAX\*(C'\fR
\&\f(CW\*(C`_SC_VERSION\*(C'\fR
.SH "ERRNO"
.IX Header "ERRNO"
.IP "Constants" 8
.IX Item "Constants"
\&\f(CW\*(C`E2BIG\*(C'\fR \f(CW\*(C`EACCES\*(C'\fR \f(CW\*(C`EADDRINUSE\*(C'\fR \f(CW\*(C`EADDRNOTAVAIL\*(C'\fR \f(CW\*(C`EAFNOSUPPORT\*(C'\fR \f(CW\*(C`EAGAIN\*(C'\fR \f(CW\*(C`EALREADY\*(C'\fR \f(CW\*(C`EBADF\*(C'\fR \f(CW\*(C`EBADMSG\*(C'\fR
\&\f(CW\*(C`EBUSY\*(C'\fR \f(CW\*(C`ECANCELED\*(C'\fR \f(CW\*(C`ECHILD\*(C'\fR \f(CW\*(C`ECONNABORTED\*(C'\fR \f(CW\*(C`ECONNREFUSED\*(C'\fR \f(CW\*(C`ECONNRESET\*(C'\fR \f(CW\*(C`EDEADLK\*(C'\fR \f(CW\*(C`EDESTADDRREQ\*(C'\fR
\&\f(CW\*(C`EDOM\*(C'\fR \f(CW\*(C`EDQUOT\*(C'\fR \f(CW\*(C`EEXIST\*(C'\fR \f(CW\*(C`EFAULT\*(C'\fR \f(CW\*(C`EFBIG\*(C'\fR \f(CW\*(C`EHOSTDOWN\*(C'\fR \f(CW\*(C`EHOSTUNREACH\*(C'\fR \f(CW\*(C`EIDRM\*(C'\fR \f(CW\*(C`EILSEQ\*(C'\fR \f(CW\*(C`EINPROGRESS\*(C'\fR
\&\f(CW\*(C`EINTR\*(C'\fR \f(CW\*(C`EINVAL\*(C'\fR \f(CW\*(C`EIO\*(C'\fR \f(CW\*(C`EISCONN\*(C'\fR \f(CW\*(C`EISDIR\*(C'\fR \f(CW\*(C`ELOOP\*(C'\fR \f(CW\*(C`EMFILE\*(C'\fR \f(CW\*(C`EMLINK\*(C'\fR \f(CW\*(C`EMSGSIZE\*(C'\fR \f(CW\*(C`ENAMETOOLONG\*(C'\fR
\&\f(CW\*(C`ENETDOWN\*(C'\fR \f(CW\*(C`ENETRESET\*(C'\fR \f(CW\*(C`ENETUNREACH\*(C'\fR \f(CW\*(C`ENFILE\*(C'\fR \f(CW\*(C`ENOBUFS\*(C'\fR \f(CW\*(C`ENODATA\*(C'\fR \f(CW\*(C`ENODEV\*(C'\fR \f(CW\*(C`ENOENT\*(C'\fR \f(CW\*(C`ENOEXEC\*(C'\fR
\&\f(CW\*(C`ENOLCK\*(C'\fR \f(CW\*(C`ENOLINK\*(C'\fR \f(CW\*(C`ENOMEM\*(C'\fR \f(CW\*(C`ENOMSG\*(C'\fR \f(CW\*(C`ENOPROTOOPT\*(C'\fR \f(CW\*(C`ENOSPC\*(C'\fR \f(CW\*(C`ENOSR\*(C'\fR \f(CW\*(C`ENOSTR\*(C'\fR \f(CW\*(C`ENOSYS\*(C'\fR \f(CW\*(C`ENOTBLK\*(C'\fR
\&\f(CW\*(C`ENOTCONN\*(C'\fR \f(CW\*(C`ENOTDIR\*(C'\fR \f(CW\*(C`ENOTEMPTY\*(C'\fR \f(CW\*(C`ENOTRECOVERABLE\*(C'\fR \f(CW\*(C`ENOTSOCK\*(C'\fR \f(CW\*(C`ENOTSUP\*(C'\fR \f(CW\*(C`ENOTTY\*(C'\fR \f(CW\*(C`ENXIO\*(C'\fR
\&\f(CW\*(C`EOPNOTSUPP\*(C'\fR \f(CW\*(C`EOTHER\*(C'\fR \f(CW\*(C`EOVERFLOW\*(C'\fR \f(CW\*(C`EOWNERDEAD\*(C'\fR \f(CW\*(C`EPERM\*(C'\fR \f(CW\*(C`EPFNOSUPPORT\*(C'\fR \f(CW\*(C`EPIPE\*(C'\fR \f(CW\*(C`EPROCLIM\*(C'\fR \f(CW\*(C`EPROTO\*(C'\fR
\&\f(CW\*(C`EPROTONOSUPPORT\*(C'\fR \f(CW\*(C`EPROTOTYPE\*(C'\fR \f(CW\*(C`ERANGE\*(C'\fR \f(CW\*(C`EREMOTE\*(C'\fR \f(CW\*(C`ERESTART\*(C'\fR \f(CW\*(C`EROFS\*(C'\fR \f(CW\*(C`ESHUTDOWN\*(C'\fR
\&\f(CW\*(C`ESOCKTNOSUPPORT\*(C'\fR \f(CW\*(C`ESPIPE\*(C'\fR \f(CW\*(C`ESRCH\*(C'\fR \f(CW\*(C`ESTALE\*(C'\fR \f(CW\*(C`ETIME\*(C'\fR \f(CW\*(C`ETIMEDOUT\*(C'\fR \f(CW\*(C`ETOOMANYREFS\*(C'\fR \f(CW\*(C`ETXTBSY\*(C'\fR \f(CW\*(C`EUSERS\*(C'\fR
\&\f(CW\*(C`EWOULDBLOCK\*(C'\fR \f(CW\*(C`EXDEV\*(C'\fR
.SH "FCNTL"
.IX Header "FCNTL"
.IP "Constants" 8
.IX Item "Constants"
\&\f(CW\*(C`FD_CLOEXEC\*(C'\fR \f(CW\*(C`F_DUPFD\*(C'\fR \f(CW\*(C`F_GETFD\*(C'\fR \f(CW\*(C`F_GETFL\*(C'\fR \f(CW\*(C`F_GETLK\*(C'\fR \f(CW\*(C`F_OK\*(C'\fR \f(CW\*(C`F_RDLCK\*(C'\fR \f(CW\*(C`F_SETFD\*(C'\fR \f(CW\*(C`F_SETFL\*(C'\fR \f(CW\*(C`F_SETLK\*(C'\fR
\&\f(CW\*(C`F_SETLKW\*(C'\fR \f(CW\*(C`F_UNLCK\*(C'\fR \f(CW\*(C`F_WRLCK\*(C'\fR \f(CW\*(C`O_ACCMODE\*(C'\fR \f(CW\*(C`O_APPEND\*(C'\fR \f(CW\*(C`O_CREAT\*(C'\fR \f(CW\*(C`O_EXCL\*(C'\fR \f(CW\*(C`O_NOCTTY\*(C'\fR \f(CW\*(C`O_NONBLOCK\*(C'\fR
\&\f(CW\*(C`O_RDONLY\*(C'\fR \f(CW\*(C`O_RDWR\*(C'\fR \f(CW\*(C`O_TRUNC\*(C'\fR \f(CW\*(C`O_WRONLY\*(C'\fR
.SH "FLOAT"
.IX Header "FLOAT"
.IP "Constants" 8
.IX Item "Constants"
\&\f(CW\*(C`DBL_DIG\*(C'\fR \f(CW\*(C`DBL_EPSILON\*(C'\fR \f(CW\*(C`DBL_MANT_DIG\*(C'\fR \f(CW\*(C`DBL_MAX\*(C'\fR \f(CW\*(C`DBL_MAX_10_EXP\*(C'\fR \f(CW\*(C`DBL_MAX_EXP\*(C'\fR \f(CW\*(C`DBL_MIN\*(C'\fR
\&\f(CW\*(C`DBL_MIN_10_EXP\*(C'\fR \f(CW\*(C`DBL_MIN_EXP\*(C'\fR \f(CW\*(C`FLT_DIG\*(C'\fR \f(CW\*(C`FLT_EPSILON\*(C'\fR \f(CW\*(C`FLT_MANT_DIG\*(C'\fR \f(CW\*(C`FLT_MAX\*(C'\fR
\&\f(CW\*(C`FLT_MAX_10_EXP\*(C'\fR \f(CW\*(C`FLT_MAX_EXP\*(C'\fR \f(CW\*(C`FLT_MIN\*(C'\fR \f(CW\*(C`FLT_MIN_10_EXP\*(C'\fR \f(CW\*(C`FLT_MIN_EXP\*(C'\fR \f(CW\*(C`FLT_RADIX\*(C'\fR
\&\f(CW\*(C`FLT_ROUNDS\*(C'\fR \f(CW\*(C`LDBL_DIG\*(C'\fR \f(CW\*(C`LDBL_EPSILON\*(C'\fR \f(CW\*(C`LDBL_MANT_DIG\*(C'\fR \f(CW\*(C`LDBL_MAX\*(C'\fR \f(CW\*(C`LDBL_MAX_10_EXP\*(C'\fR
\&\f(CW\*(C`LDBL_MAX_EXP\*(C'\fR \f(CW\*(C`LDBL_MIN\*(C'\fR \f(CW\*(C`LDBL_MIN_10_EXP\*(C'\fR \f(CW\*(C`LDBL_MIN_EXP\*(C'\fR
.SH "FLOATING-POINT ENVIRONMENT"
.IX Header "FLOATING-POINT ENVIRONMENT"
.IP "Constants" 8
.IX Item "Constants"
\&\f(CW\*(C`FE_DOWNWARD\*(C'\fR \f(CW\*(C`FE_TONEAREST\*(C'\fR \f(CW\*(C`FE_TOWARDZERO\*(C'\fR \f(CW\*(C`FE_UPWARD\*(C'\fR
on systems that support them.
.SH "LIMITS"
.IX Header "LIMITS"
.IP "Constants" 8
.IX Item "Constants"
\&\f(CW\*(C`ARG_MAX\*(C'\fR \f(CW\*(C`CHAR_BIT\*(C'\fR \f(CW\*(C`CHAR_MAX\*(C'\fR \f(CW\*(C`CHAR_MIN\*(C'\fR \f(CW\*(C`CHILD_MAX\*(C'\fR \f(CW\*(C`INT_MAX\*(C'\fR \f(CW\*(C`INT_MIN\*(C'\fR \f(CW\*(C`LINK_MAX\*(C'\fR \f(CW\*(C`LONG_MAX\*(C'\fR
\&\f(CW\*(C`LONG_MIN\*(C'\fR \f(CW\*(C`MAX_CANON\*(C'\fR \f(CW\*(C`MAX_INPUT\*(C'\fR \f(CW\*(C`MB_LEN_MAX\*(C'\fR \f(CW\*(C`NAME_MAX\*(C'\fR \f(CW\*(C`NGROUPS_MAX\*(C'\fR \f(CW\*(C`OPEN_MAX\*(C'\fR \f(CW\*(C`PATH_MAX\*(C'\fR
\&\f(CW\*(C`PIPE_BUF\*(C'\fR \f(CW\*(C`SCHAR_MAX\*(C'\fR \f(CW\*(C`SCHAR_MIN\*(C'\fR \f(CW\*(C`SHRT_MAX\*(C'\fR \f(CW\*(C`SHRT_MIN\*(C'\fR \f(CW\*(C`SSIZE_MAX\*(C'\fR \f(CW\*(C`STREAM_MAX\*(C'\fR \f(CW\*(C`TZNAME_MAX\*(C'\fR
\&\f(CW\*(C`UCHAR_MAX\*(C'\fR \f(CW\*(C`UINT_MAX\*(C'\fR \f(CW\*(C`ULONG_MAX\*(C'\fR \f(CW\*(C`USHRT_MAX\*(C'\fR
.SH "LOCALE"
.IX Header "LOCALE"
.IP "Constants" 8
.IX Item "Constants"
\&\f(CW\*(C`LC_ALL\*(C'\fR \f(CW\*(C`LC_COLLATE\*(C'\fR \f(CW\*(C`LC_CTYPE\*(C'\fR \f(CW\*(C`LC_MONETARY\*(C'\fR \f(CW\*(C`LC_NUMERIC\*(C'\fR \f(CW\*(C`LC_TIME\*(C'\fR \f(CW\*(C`LC_MESSAGES\*(C'\fR
on systems that support them.
.SH "MATH"
.IX Header "MATH"
.IP "Constants" 8
.IX Item "Constants"
\&\f(CW\*(C`HUGE_VAL\*(C'\fR
.Sp
\&\f(CW\*(C`FP_ILOGB0\*(C'\fR \f(CW\*(C`FP_ILOGBNAN\*(C'\fR \f(CW\*(C`FP_INFINITE\*(C'\fR \f(CW\*(C`FP_NAN\*(C'\fR \f(CW\*(C`FP_NORMAL\*(C'\fR \f(CW\*(C`FP_SUBNORMAL\*(C'\fR \f(CW\*(C`FP_ZERO\*(C'\fR
\&\f(CW\*(C`INFINITY\*(C'\fR \f(CW\*(C`NAN\*(C'\fR \f(CW\*(C`Inf\*(C'\fR \f(CW\*(C`NaN\*(C'\fR
\&\f(CW\*(C`M_1_PI\*(C'\fR \f(CW\*(C`M_2_PI\*(C'\fR \f(CW\*(C`M_2_SQRTPI\*(C'\fR \f(CW\*(C`M_E\*(C'\fR \f(CW\*(C`M_LN10\*(C'\fR \f(CW\*(C`M_LN2\*(C'\fR \f(CW\*(C`M_LOG10E\*(C'\fR \f(CW\*(C`M_LOG2E\*(C'\fR \f(CW\*(C`M_PI\*(C'\fR
\&\f(CW\*(C`M_PI_2\*(C'\fR \f(CW\*(C`M_PI_4\*(C'\fR \f(CW\*(C`M_SQRT1_2\*(C'\fR \f(CW\*(C`M_SQRT2\*(C'\fR
on systems with C99 support.
.SH "SIGNAL"
.IX Header "SIGNAL"
.IP "Constants" 8
.IX Item "Constants"
\&\f(CW\*(C`SA_NOCLDSTOP\*(C'\fR \f(CW\*(C`SA_NOCLDWAIT\*(C'\fR \f(CW\*(C`SA_NODEFER\*(C'\fR \f(CW\*(C`SA_ONSTACK\*(C'\fR \f(CW\*(C`SA_RESETHAND\*(C'\fR \f(CW\*(C`SA_RESTART\*(C'\fR
\&\f(CW\*(C`SA_SIGINFO\*(C'\fR \f(CW\*(C`SIGABRT\*(C'\fR \f(CW\*(C`SIGALRM\*(C'\fR \f(CW\*(C`SIGCHLD\*(C'\fR \f(CW\*(C`SIGCONT\*(C'\fR \f(CW\*(C`SIGFPE\*(C'\fR \f(CW\*(C`SIGHUP\*(C'\fR \f(CW\*(C`SIGILL\*(C'\fR \f(CW\*(C`SIGINT\*(C'\fR
\&\f(CW\*(C`SIGKILL\*(C'\fR \f(CW\*(C`SIGPIPE\*(C'\fR \f(CW\*(C`SIGQUIT\*(C'\fR \f(CW\*(C`SIGSEGV\*(C'\fR \f(CW\*(C`SIGSTOP\*(C'\fR \f(CW\*(C`SIGTERM\*(C'\fR \f(CW\*(C`SIGTSTP\*(C'\fR \f(CW\*(C`SIGTTIN\*(C'\fR \f(CW\*(C`SIGTTOU\*(C'\fR
\&\f(CW\*(C`SIGUSR1\*(C'\fR \f(CW\*(C`SIGUSR2\*(C'\fR \f(CW\*(C`SIG_BLOCK\*(C'\fR \f(CW\*(C`SIG_DFL\*(C'\fR \f(CW\*(C`SIG_ERR\*(C'\fR \f(CW\*(C`SIG_IGN\*(C'\fR \f(CW\*(C`SIG_SETMASK\*(C'\fR
\&\f(CW\*(C`SIG_UNBLOCK\*(C'\fR
\&\f(CW\*(C`ILL_ILLOPC\*(C'\fR \f(CW\*(C`ILL_ILLOPN\*(C'\fR \f(CW\*(C`ILL_ILLADR\*(C'\fR \f(CW\*(C`ILL_ILLTRP\*(C'\fR \f(CW\*(C`ILL_PRVOPC\*(C'\fR \f(CW\*(C`ILL_PRVREG\*(C'\fR \f(CW\*(C`ILL_COPROC\*(C'\fR
\&\f(CW\*(C`ILL_BADSTK\*(C'\fR \f(CW\*(C`FPE_INTDIV\*(C'\fR \f(CW\*(C`FPE_INTOVF\*(C'\fR \f(CW\*(C`FPE_FLTDIV\*(C'\fR \f(CW\*(C`FPE_FLTOVF\*(C'\fR \f(CW\*(C`FPE_FLTUND\*(C'\fR \f(CW\*(C`FPE_FLTRES\*(C'\fR
\&\f(CW\*(C`FPE_FLTINV\*(C'\fR \f(CW\*(C`FPE_FLTSUB\*(C'\fR \f(CW\*(C`SEGV_MAPERR\*(C'\fR \f(CW\*(C`SEGV_ACCERR\*(C'\fR \f(CW\*(C`BUS_ADRALN\*(C'\fR \f(CW\*(C`BUS_ADRERR\*(C'\fR
\&\f(CW\*(C`BUS_OBJERR\*(C'\fR \f(CW\*(C`TRAP_BRKPT\*(C'\fR \f(CW\*(C`TRAP_TRACE\*(C'\fR \f(CW\*(C`CLD_EXITED\*(C'\fR \f(CW\*(C`CLD_KILLED\*(C'\fR \f(CW\*(C`CLD_DUMPED\*(C'\fR \f(CW\*(C`CLD_TRAPPED\*(C'\fR
\&\f(CW\*(C`CLD_STOPPED\*(C'\fR \f(CW\*(C`CLD_CONTINUED\*(C'\fR \f(CW\*(C`POLL_IN\*(C'\fR \f(CW\*(C`POLL_OUT\*(C'\fR \f(CW\*(C`POLL_MSG\*(C'\fR \f(CW\*(C`POLL_ERR\*(C'\fR \f(CW\*(C`POLL_PRI\*(C'\fR
\&\f(CW\*(C`POLL_HUP\*(C'\fR \f(CW\*(C`SI_USER\*(C'\fR \f(CW\*(C`SI_QUEUE\*(C'\fR \f(CW\*(C`SI_TIMER\*(C'\fR \f(CW\*(C`SI_ASYNCIO\*(C'\fR \f(CW\*(C`SI_MESGQ\*(C'\fR
.SH "STAT"
.IX Header "STAT"
.IP "Constants" 8
.IX Item "Constants"
\&\f(CW\*(C`S_IRGRP\*(C'\fR \f(CW\*(C`S_IROTH\*(C'\fR \f(CW\*(C`S_IRUSR\*(C'\fR \f(CW\*(C`S_IRWXG\*(C'\fR \f(CW\*(C`S_IRWXO\*(C'\fR \f(CW\*(C`S_IRWXU\*(C'\fR \f(CW\*(C`S_ISGID\*(C'\fR \f(CW\*(C`S_ISUID\*(C'\fR \f(CW\*(C`S_IWGRP\*(C'\fR \f(CW\*(C`S_IWOTH\*(C'\fR
\&\f(CW\*(C`S_IWUSR\*(C'\fR \f(CW\*(C`S_IXGRP\*(C'\fR \f(CW\*(C`S_IXOTH\*(C'\fR \f(CW\*(C`S_IXUSR\*(C'\fR
.IP "Macros" 8
.IX Item "Macros"
\&\f(CW\*(C`S_ISBLK\*(C'\fR \f(CW\*(C`S_ISCHR\*(C'\fR \f(CW\*(C`S_ISDIR\*(C'\fR \f(CW\*(C`S_ISFIFO\*(C'\fR \f(CW\*(C`S_ISREG\*(C'\fR
.SH "STDLIB"
.IX Header "STDLIB"
.IP "Constants" 8
.IX Item "Constants"
\&\f(CW\*(C`EXIT_FAILURE\*(C'\fR \f(CW\*(C`EXIT_SUCCESS\*(C'\fR \f(CW\*(C`MB_CUR_MAX\*(C'\fR \f(CW\*(C`RAND_MAX\*(C'\fR
.SH "STDIO"
.IX Header "STDIO"
.IP "Constants" 8
.IX Item "Constants"
\&\f(CW\*(C`BUFSIZ\*(C'\fR \f(CW\*(C`EOF\*(C'\fR \f(CW\*(C`FILENAME_MAX\*(C'\fR \f(CW\*(C`L_ctermid\*(C'\fR \f(CW\*(C`L_cuserid\*(C'\fR \f(CW\*(C`TMP_MAX\*(C'\fR
.SH "TIME"
.IX Header "TIME"
.IP "Constants" 8
.IX Item "Constants"
\&\f(CW\*(C`CLK_TCK\*(C'\fR \f(CW\*(C`CLOCKS_PER_SEC\*(C'\fR
.SH "UNISTD"
.IX Header "UNISTD"
.IP "Constants" 8
.IX Item "Constants"
\&\f(CW\*(C`R_OK\*(C'\fR \f(CW\*(C`SEEK_CUR\*(C'\fR \f(CW\*(C`SEEK_END\*(C'\fR \f(CW\*(C`SEEK_SET\*(C'\fR \f(CW\*(C`STDIN_FILENO\*(C'\fR \f(CW\*(C`STDOUT_FILENO\*(C'\fR \f(CW\*(C`STDERR_FILENO\*(C'\fR \f(CW\*(C`W_OK\*(C'\fR \f(CW\*(C`X_OK\*(C'\fR
.SH "WAIT"
.IX Header "WAIT"
.IP "Constants" 8
.IX Item "Constants"
\&\f(CW\*(C`WNOHANG\*(C'\fR \f(CW\*(C`WUNTRACED\*(C'\fR
.RS 8
.ie n .IP """WNOHANG""" 16
.el .IP "\f(CWWNOHANG\fR" 16
.IX Item "WNOHANG"
Do not suspend the calling process until a child process
changes state but instead return immediately.
.ie n .IP """WUNTRACED""" 16
.el .IP "\f(CWWUNTRACED\fR" 16
.IX Item "WUNTRACED"
Catch stopped child processes.
.RE
.RS 8
.RE
.IP "Macros" 8
.IX Item "Macros"
\&\f(CW\*(C`WIFEXITED\*(C'\fR \f(CW\*(C`WEXITSTATUS\*(C'\fR \f(CW\*(C`WIFSIGNALED\*(C'\fR \f(CW\*(C`WTERMSIG\*(C'\fR \f(CW\*(C`WIFSTOPPED\*(C'\fR \f(CW\*(C`WSTOPSIG\*(C'\fR
.RS 8
.ie n .IP """WIFEXITED""" 16
.el .IP "\f(CWWIFEXITED\fR" 16
.IX Item "WIFEXITED"
\&\f(CW\*(C`WIFEXITED(${^CHILD_ERROR_NATIVE})\*(C'\fR returns true if the child process
exited normally (\f(CW\*(C`exit()\*(C'\fR or by falling off the end of \f(CW\*(C`main()\*(C'\fR)
.ie n .IP """WEXITSTATUS""" 16
.el .IP "\f(CWWEXITSTATUS\fR" 16
.IX Item "WEXITSTATUS"
\&\f(CW\*(C`WEXITSTATUS(${^CHILD_ERROR_NATIVE})\*(C'\fR returns the normal exit status of
the child process (only meaningful if \f(CW\*(C`WIFEXITED(${^CHILD_ERROR_NATIVE})\*(C'\fR
is true)
.ie n .IP """WIFSIGNALED""" 16
.el .IP "\f(CWWIFSIGNALED\fR" 16
.IX Item "WIFSIGNALED"
\&\f(CW\*(C`WIFSIGNALED(${^CHILD_ERROR_NATIVE})\*(C'\fR returns true if the child process
terminated because of a signal
.ie n .IP """WTERMSIG""" 16
.el .IP "\f(CWWTERMSIG\fR" 16
.IX Item "WTERMSIG"
\&\f(CW\*(C`WTERMSIG(${^CHILD_ERROR_NATIVE})\*(C'\fR returns the signal the child process
terminated for (only meaningful if
\&\f(CW\*(C`WIFSIGNALED(${^CHILD_ERROR_NATIVE})\*(C'\fR
is true)
.ie n .IP """WIFSTOPPED""" 16
.el .IP "\f(CWWIFSTOPPED\fR" 16
.IX Item "WIFSTOPPED"
\&\f(CW\*(C`WIFSTOPPED(${^CHILD_ERROR_NATIVE})\*(C'\fR returns true if the child process is
currently stopped (can happen only if you specified the \s-1WUNTRACED\s0 flag
to \f(CW\*(C`waitpid()\*(C'\fR)
.ie n .IP """WSTOPSIG""" 16
.el .IP "\f(CWWSTOPSIG\fR" 16
.IX Item "WSTOPSIG"
\&\f(CW\*(C`WSTOPSIG(${^CHILD_ERROR_NATIVE})\*(C'\fR returns the signal the child process
was stopped for (only meaningful if
\&\f(CW\*(C`WIFSTOPPED(${^CHILD_ERROR_NATIVE})\*(C'\fR
is true)
.RE
.RS 8
.RE
.SH "WINSOCK"
.IX Header "WINSOCK"
(Windows only.)
.IP "Constants" 8
.IX Item "Constants"
\&\f(CW\*(C`WSAEINTR\*(C'\fR \f(CW\*(C`WSAEBADF\*(C'\fR \f(CW\*(C`WSAEACCES\*(C'\fR \f(CW\*(C`WSAEFAULT\*(C'\fR \f(CW\*(C`WSAEINVAL\*(C'\fR \f(CW\*(C`WSAEMFILE\*(C'\fR \f(CW\*(C`WSAEWOULDBLOCK\*(C'\fR
\&\f(CW\*(C`WSAEINPROGRESS\*(C'\fR \f(CW\*(C`WSAEALREADY\*(C'\fR \f(CW\*(C`WSAENOTSOCK\*(C'\fR \f(CW\*(C`WSAEDESTADDRREQ\*(C'\fR \f(CW\*(C`WSAEMSGSIZE\*(C'\fR
\&\f(CW\*(C`WSAEPROTOTYPE\*(C'\fR \f(CW\*(C`WSAENOPROTOOPT\*(C'\fR \f(CW\*(C`WSAEPROTONOSUPPORT\*(C'\fR \f(CW\*(C`WSAESOCKTNOSUPPORT\*(C'\fR
\&\f(CW\*(C`WSAEOPNOTSUPP\*(C'\fR \f(CW\*(C`WSAEPFNOSUPPORT\*(C'\fR \f(CW\*(C`WSAEAFNOSUPPORT\*(C'\fR \f(CW\*(C`WSAEADDRINUSE\*(C'\fR
\&\f(CW\*(C`WSAEADDRNOTAVAIL\*(C'\fR \f(CW\*(C`WSAENETDOWN\*(C'\fR \f(CW\*(C`WSAENETUNREACH\*(C'\fR \f(CW\*(C`WSAENETRESET\*(C'\fR \f(CW\*(C`WSAECONNABORTED\*(C'\fR
\&\f(CW\*(C`WSAECONNRESET\*(C'\fR \f(CW\*(C`WSAENOBUFS\*(C'\fR \f(CW\*(C`WSAEISCONN\*(C'\fR \f(CW\*(C`WSAENOTCONN\*(C'\fR \f(CW\*(C`WSAESHUTDOWN\*(C'\fR
\&\f(CW\*(C`WSAETOOMANYREFS\*(C'\fR \f(CW\*(C`WSAETIMEDOUT\*(C'\fR \f(CW\*(C`WSAECONNREFUSED\*(C'\fR \f(CW\*(C`WSAELOOP\*(C'\fR \f(CW\*(C`WSAENAMETOOLONG\*(C'\fR
\&\f(CW\*(C`WSAEHOSTDOWN\*(C'\fR \f(CW\*(C`WSAEHOSTUNREACH\*(C'\fR \f(CW\*(C`WSAENOTEMPTY\*(C'\fR \f(CW\*(C`WSAEPROCLIM\*(C'\fR \f(CW\*(C`WSAEUSERS\*(C'\fR
\&\f(CW\*(C`WSAEDQUOT\*(C'\fR \f(CW\*(C`WSAESTALE\*(C'\fR \f(CW\*(C`WSAEREMOTE\*(C'\fR \f(CW\*(C`WSAEDISCON\*(C'\fR \f(CW\*(C`WSAENOMORE\*(C'\fR \f(CW\*(C`WSAECANCELLED\*(C'\fR
\&\f(CW\*(C`WSAEINVALIDPROCTABLE\*(C'\fR \f(CW\*(C`WSAEINVALIDPROVIDER\*(C'\fR \f(CW\*(C`WSAEPROVIDERFAILEDINIT\*(C'\fR
\&\f(CW\*(C`WSAEREFUSED\*(C'\fR
