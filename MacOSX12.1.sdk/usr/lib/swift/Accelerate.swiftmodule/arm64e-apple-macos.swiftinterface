// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 5.5.2 (swiftlang-1300.0.46.202 clang-1300.0.29.30)
// swift-module-flags: -target arm64e-apple-macos12.1 -enable-objc-interop -autolink-force-load -enable-library-evolution -module-link-name swiftAccelerate -swift-version 5 -enforce-exclusivity=checked -O -module-name Accelerate
@_exported import Accelerate
@_exported import Accelerate.vecLib.BNNS
import Swift
import _Concurrency
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
public enum vImage {
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
public enum vDSP {
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
public enum vForce {
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Accelerate.vDSP {
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public struct VectorizableFloat {
    public typealias Scalar = Swift.Float
  }
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public struct VectorizableDouble {
    public typealias Scalar = Swift.Double
  }
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Accelerate.vDSP {
  @inlinable public static func convolve<T, U>(_ vector: T, withKernel kernel: U) -> [Swift.Float] where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, T.Element == Swift.Float, U.Element == Swift.Float {
            
            let n = vector.count - kernel.count
            
            let result = Array<Float>(unsafeUninitializedCapacity: n) {
                buffer, initializedCount in
                
                convolve(vector,
                         withKernel: kernel,
                         result: &buffer)
                
                initializedCount = n
            }
            
            return result
    }
  @inlinable public static func convolve<T, U, V>(_ vector: T, withKernel kernel: U, result: inout V) where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, T.Element == Swift.Float, U.Element == Swift.Float, V.Element == Swift.Float {
            
            let n = result.count
            precondition(vector.count >= n + kernel.count - 1,
                         "Source vector count must be at least the sum of the result and kernel counts, minus one.")
            
            result.withUnsafeMutableBufferPointer { dest in
                vector.withUnsafeBufferPointer { src in
                    kernel.withUnsafeBufferPointer { k in
                        vDSP_conv(src.baseAddress!, 1,
                                  k.baseAddress!.advanced(by: kernel.count - 1), -1,
                                  dest.baseAddress!, 1,
                                  vDSP_Length(n),
                                  vDSP_Length(kernel.count))
                    }
                }
            }
    }
  @inlinable public static func convolve<T, U>(_ vector: T, withKernel kernel: U) -> [Swift.Double] where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, T.Element == Swift.Double, U.Element == Swift.Double {
            
            let n = vector.count - kernel.count
            
            let result = Array<Double>(unsafeUninitializedCapacity: n) {
                buffer, initializedCount in
                
                convolve(vector,
                         withKernel: kernel,
                         result: &buffer)
                
                initializedCount = n
            }
            
            return result
    }
  @inlinable public static func convolve<T, U, V>(_ vector: T, withKernel kernel: U, result: inout V) where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, T.Element == Swift.Double, U.Element == Swift.Double, V.Element == Swift.Double {
            
            let n = result.count
            precondition(vector.count >= n + kernel.count - 1,
                         "Source vector count must be at least the sum of the result and kernel counts, minus one.")
            
            result.withUnsafeMutableBufferPointer { dest in
                vector.withUnsafeBufferPointer { src in
                    kernel.withUnsafeBufferPointer { k in
                        vDSP_convD(src.baseAddress!, 1,
                                   k.baseAddress!.advanced(by: kernel.count - 1), -1,
                                   dest.baseAddress!, 1,
                                   vDSP_Length(n),
                                   vDSP_Length(kernel.count))
                    }
                }
            }
    }
  @inlinable public static func correlate<T, U>(_ vector: T, withKernel kernel: U) -> [Swift.Float] where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, T.Element == Swift.Float, U.Element == Swift.Float {
            
            let n = vector.count - kernel.count
            
            let result = Array<Float>(unsafeUninitializedCapacity: n) {
                buffer, initializedCount in
                
                correlate(vector,
                          withKernel: kernel,
                          result: &buffer)
                
                initializedCount = n
            }
            
            return result
    }
  @inlinable public static func correlate<T, U, V>(_ vector: T, withKernel kernel: U, result: inout V) where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, T.Element == Swift.Float, U.Element == Swift.Float, V.Element == Swift.Float {
            
            let n = result.count
            precondition(vector.count >= n + kernel.count - 1,
                         "Source vector count must be at least the sum of the result and kernel counts, minus one.")
            
            result.withUnsafeMutableBufferPointer { dest in
                vector.withUnsafeBufferPointer { src in
                    kernel.withUnsafeBufferPointer { k in
                        vDSP_conv(src.baseAddress!, 1,
                                  k.baseAddress!, 1,
                                  dest.baseAddress!, 1,
                                  vDSP_Length(n),
                                  vDSP_Length(kernel.count))
                    }
                }
            }
    }
  @inlinable public static func correlate<T, U>(_ vector: T, withKernel kernel: U) -> [Swift.Double] where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, T.Element == Swift.Double, U.Element == Swift.Double {
            
            let n = vector.count - kernel.count
            
            let result = Array<Double>(unsafeUninitializedCapacity: n) {
                buffer, initializedCount in
                
                correlate(vector,
                          withKernel: kernel,
                          result: &buffer)
                
                initializedCount = n
            }
            
            return result
    }
  @inlinable public static func correlate<T, U, V>(_ vector: T, withKernel kernel: U, result: inout V) where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, T.Element == Swift.Double, U.Element == Swift.Double, V.Element == Swift.Double {
            
            let n = result.count
            precondition(vector.count >= n + kernel.count - 1,
                         "Source vector count must be at least the sum of the result and kernel counts, minus one.")
            
            result.withUnsafeMutableBufferPointer { dest in
                vector.withUnsafeBufferPointer { src in
                    kernel.withUnsafeBufferPointer { k in
                        vDSP_convD(src.baseAddress!, 1,
                                   k.baseAddress!, 1,
                                   dest.baseAddress!, 1,
                                   vDSP_Length(n),
                                   vDSP_Length(kernel.count))
                    }
                }
            }
    }
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Accelerate.vDSP {
  @inlinable public static func convolve<T, U>(_ vector: T, rowCount: Swift.Int, columnCount: Swift.Int, with3x3Kernel kernel: U) -> [Swift.Float] where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, T.Element == Swift.Float, U.Element == Swift.Float {
            
            let result = Array<Float>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                convolve(vector,
                         rowCount: rowCount, columnCount: columnCount,
                         with3x3Kernel: kernel,
                         result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func convolve<T, U, V>(_ vector: T, rowCount: Swift.Int, columnCount: Swift.Int, with3x3Kernel kernel: U, result: inout V) where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, T.Element == Swift.Float, U.Element == Swift.Float, V.Element == Swift.Float {
            
            precondition(rowCount >= 3,
                         "Row count must be greater than or equal to 3.")
            
            precondition(columnCount >= 4,
                         "Column count must be even and greater than or equal to 4")
            
            precondition(rowCount * columnCount == vector.count,
                         "Row count `x` column count must equal source vector count.")
            
            precondition(kernel.count == 9,
                         "Kernel must contain 9 elements.")
            
            result.withUnsafeMutableBufferPointer { dest in
                vector.withUnsafeBufferPointer { src in
                    kernel.withUnsafeBufferPointer { k in
                        vDSP_f3x3(src.baseAddress!,
                                  vDSP_Length(rowCount), vDSP_Length(columnCount),
                                  k.baseAddress!,
                                  dest.baseAddress!)
                    }
                }
            }
    }
  @inlinable public static func convolve<T, U>(_ vector: T, rowCount: Swift.Int, columnCount: Swift.Int, with3x3Kernel kernel: U) -> [Swift.Double] where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, T.Element == Swift.Double, U.Element == Swift.Double {
            
            let result = Array<Double>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                convolve(vector,
                         rowCount: rowCount, columnCount: columnCount,
                         with3x3Kernel: kernel,
                         result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func convolve<T, U, V>(_ vector: T, rowCount: Swift.Int, columnCount: Swift.Int, with3x3Kernel kernel: U, result: inout V) where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, T.Element == Swift.Double, U.Element == Swift.Double, V.Element == Swift.Double {
            
            precondition(rowCount >= 3,
                         "Row count must be greater than or equal to 3.")
            
            precondition(columnCount >= 4,
                         "Column count must be even and greater than or equal to 4")
            
            precondition(rowCount * columnCount == vector.count,
                         "Row count `x` column count must equal source vector count.")
            
            precondition(kernel.count == 9,
                         "Kernel must contain 9 elements.")
            
            result.withUnsafeMutableBufferPointer { dest in
                vector.withUnsafeBufferPointer { src in
                    kernel.withUnsafeBufferPointer { k in
                        vDSP_f3x3D(src.baseAddress!,
                                   vDSP_Length(rowCount), vDSP_Length(columnCount),
                                   k.baseAddress!,
                                   dest.baseAddress!)
                    }
                }
            }
    }
  @inlinable public static func convolve<T, U>(_ vector: T, rowCount: Swift.Int, columnCount: Swift.Int, with5x5Kernel kernel: U) -> [Swift.Float] where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, T.Element == Swift.Float, U.Element == Swift.Float {
            
            let result = Array<Float>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                convolve(vector,
                         rowCount: rowCount, columnCount: columnCount,
                         with5x5Kernel: kernel,
                         result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func convolve<T, U, V>(_ vector: T, rowCount: Swift.Int, columnCount: Swift.Int, with5x5Kernel kernel: U, result: inout V) where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, T.Element == Swift.Float, U.Element == Swift.Float, V.Element == Swift.Float {
            
            precondition(rowCount >= 3,
                         "Row count must be greater than or equal to 3.")
            
            precondition(columnCount >= 4,
                         "Column count must be even and greater than or equal to 4")
            
            precondition(rowCount * columnCount == vector.count,
                         "Row count `x` column count must equal source vector count.")
            
            precondition(kernel.count == 25,
                         "Kernel must contain 25 elements.")
            
            result.withUnsafeMutableBufferPointer { dest in
                vector.withUnsafeBufferPointer { src in
                    kernel.withUnsafeBufferPointer { k in
                        vDSP_f5x5(src.baseAddress!,
                                  vDSP_Length(rowCount), vDSP_Length(columnCount),
                                  k.baseAddress!,
                                  dest.baseAddress!)
                    }
                }
            }
    }
  @inlinable public static func convolve<T, U>(_ vector: T, rowCount: Swift.Int, columnCount: Swift.Int, with5x5Kernel kernel: U) -> [Swift.Double] where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, T.Element == Swift.Double, U.Element == Swift.Double {
            
            let result = Array<Double>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                convolve(vector,
                         rowCount: rowCount, columnCount: columnCount,
                         with5x5Kernel: kernel,
                         result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func convolve<T, U, V>(_ vector: T, rowCount: Swift.Int, columnCount: Swift.Int, with5x5Kernel kernel: U, result: inout V) where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, T.Element == Swift.Double, U.Element == Swift.Double, V.Element == Swift.Double {
            
            precondition(rowCount >= 3,
                         "Row count must be greater than or equal to 3.")
            
            precondition(columnCount >= 4,
                         "Column count must be even and greater than or equal to 4")
            
            precondition(rowCount * columnCount == vector.count,
                         "Row count `x` column count must equal source vector count.")
            
            precondition(kernel.count == 25,
                         "Kernel must contain 25 elements.")
            
            result.withUnsafeMutableBufferPointer { dest in
                vector.withUnsafeBufferPointer { src in
                    kernel.withUnsafeBufferPointer { k in
                        vDSP_f5x5D(src.baseAddress!,
                                   vDSP_Length(rowCount), vDSP_Length(columnCount),
                                   k.baseAddress!,
                                   dest.baseAddress!)
                    }
                }
            }
    }
  @inlinable public static func convolve<T, U>(_ vector: T, rowCount: Swift.Int, columnCount: Swift.Int, withKernel kernel: U, kernelRowCount: Swift.Int, kernelColumnCount: Swift.Int) -> [Swift.Float] where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, T.Element == Swift.Float, U.Element == Swift.Float {
            
            let result = Array<Float>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                convolve(vector,
                         rowCount: rowCount, columnCount: columnCount,
                         withKernel: kernel,
                         kernelRowCount: kernelRowCount, kernelColumnCount: kernelColumnCount,
                         result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func convolve<T, U, V>(_ vector: T, rowCount: Swift.Int, columnCount: Swift.Int, withKernel kernel: U, kernelRowCount: Swift.Int, kernelColumnCount: Swift.Int, result: inout V) where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, T.Element == Swift.Float, U.Element == Swift.Float, V.Element == Swift.Float {
            
            precondition(rowCount >= 3,
                         "Row count must be greater than or equal to 3.")
            
            precondition(columnCount >= 4,
                         "Column count must be even and greater than or equal to 4")
            
            precondition(rowCount * columnCount == vector.count,
                         "Row count `x` column count must equal source vector count.")
            
            precondition(kernelRowCount % 2 == 1,
                         "Kernel row count must be odd.")
            
            precondition(kernelColumnCount % 2 == 1,
                         "Kernel column count must be odd.")
            
            result.withUnsafeMutableBufferPointer { dest in
                vector.withUnsafeBufferPointer { src in
                    kernel.withUnsafeBufferPointer { k in
                        vDSP_imgfir(src.baseAddress!,
                                    vDSP_Length(rowCount), vDSP_Length(columnCount),
                                    k.baseAddress!,
                                    dest.baseAddress!,
                                    vDSP_Length(kernelRowCount), vDSP_Length(kernelColumnCount))
                    }
                }
            }
    }
  @inlinable public static func convolve<T, U>(_ vector: T, rowCount: Swift.Int, columnCount: Swift.Int, withKernel kernel: U, kernelRowCount: Swift.Int, kernelColumnCount: Swift.Int) -> [Swift.Double] where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, T.Element == Swift.Double, U.Element == Swift.Double {
            
            let result = Array<Double>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                convolve(vector,
                         rowCount: rowCount, columnCount: columnCount,
                         withKernel: kernel,
                         kernelRowCount: kernelRowCount, kernelColumnCount: kernelColumnCount,
                         result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func convolve<T, U, V>(_ vector: T, rowCount: Swift.Int, columnCount: Swift.Int, withKernel kernel: U, kernelRowCount: Swift.Int, kernelColumnCount: Swift.Int, result: inout V) where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, T.Element == Swift.Double, U.Element == Swift.Double, V.Element == Swift.Double {
            
            precondition(rowCount >= 3,
                         "Row count must be greater than or equal to 3.")
            
            precondition(columnCount >= 4,
                         "Column count must be even and greater than or equal to 4")
            
            precondition(rowCount * columnCount == vector.count,
                         "Row count `x` column count must equal source vector count.")
            
            precondition(kernelRowCount % 2 == 1,
                         "Kernel row count must be odd.")
            
            precondition(kernelColumnCount % 2 == 1,
                         "Kernel column count must be odd.")
            
            result.withUnsafeMutableBufferPointer { dest in
                vector.withUnsafeBufferPointer { src in
                    kernel.withUnsafeBufferPointer { k in
                        vDSP_imgfirD(src.baseAddress!,
                                     vDSP_Length(rowCount), vDSP_Length(columnCount),
                                     k.baseAddress!,
                                     dest.baseAddress!,
                                     vDSP_Length(kernelRowCount), vDSP_Length(kernelColumnCount))
                    }
                }
            }
    }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Accelerate.BNNS {
  @frozen public struct Norm : Swift.Equatable {
    @_alwaysEmitIntoClient public var rawValue: Swift.Float
    @_alwaysEmitIntoClient public init(rawValue: Swift.Float) { self.rawValue = rawValue }
    @_alwaysEmitIntoClient public static var l1: Accelerate.BNNS.Norm {
      get { Norm(rawValue: 1) }
    }
    @_alwaysEmitIntoClient public static var taxicab: Accelerate.BNNS.Norm {
      get { Norm(rawValue: 1) }
    }
    @_alwaysEmitIntoClient public static var l2: Accelerate.BNNS.Norm {
      get { Norm(rawValue: 2) }
    }
    @_alwaysEmitIntoClient public static var euclidean: Accelerate.BNNS.Norm {
      get { Norm(rawValue: 2) }
    }
    @_alwaysEmitIntoClient public static var lInfinity: Accelerate.BNNS.Norm {
      get { Norm(rawValue: .infinity) }
    }
    @_alwaysEmitIntoClient public static var maximum: Accelerate.BNNS.Norm {
      get { Norm(rawValue: .infinity) }
    }
    public static func == (a: Accelerate.BNNS.Norm, b: Accelerate.BNNS.Norm) -> Swift.Bool
  }
  @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class EmbeddingLayer : Accelerate.BNNS.Layer {
    convenience public init?(input: Accelerate.BNNSNDArrayDescriptor, output: Accelerate.BNNSNDArrayDescriptor, dictionary: Accelerate.BNNSNDArrayDescriptor, paddingIndex: Swift.Int, maximumNorm: Swift.Float, normType: Accelerate.BNNS.Norm, scalesGradientByFrequency: Swift.Bool, filterParameters: Accelerate.BNNSFilterParameters? = nil)
    public func apply(batchSize: Swift.Int, input: Accelerate.BNNSNDArrayDescriptor, output: Accelerate.BNNSNDArrayDescriptor) throws
    public func applyBackward(batchSize: Swift.Int, input: Accelerate.BNNSNDArrayDescriptor, output: Accelerate.BNNSNDArrayDescriptor, outputGradient: Accelerate.BNNSNDArrayDescriptor, generatingWeightsGradient weightsGradient: Accelerate.BNNSNDArrayDescriptor) throws
    @objc deinit
  }
}
@available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
extension Accelerate.BNNS {
  public static func transpose(input: Accelerate.BNNSNDArrayDescriptor, output: Accelerate.BNNSNDArrayDescriptor, firstTransposeAxis: Swift.Int, secondTransposeAxis: Swift.Int, filterParameters: Accelerate.BNNSFilterParameters? = nil) throws
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Accelerate.vDSP {
  @inlinable public static func downsample<T, U>(_ source: U, decimationFactor: Swift.Int, filter: T) -> [Swift.Float] where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, T.Element == Swift.Float, U.Element == Swift.Float {
            
            let n = (source.count - filter.count) / decimationFactor + 1
            
            let result = Array<Float>(unsafeUninitializedCapacity: n) {
                buffer, initializedCount in
                
                downsample(source,
                           decimationFactor: decimationFactor,
                           filter: filter,
                           result: &buffer)
                
                initializedCount = n
            }
            
            return result
    }
  @inlinable public static func downsample<T, U, V>(_ source: U, decimationFactor: Swift.Int, filter: T, result: inout V) where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, T.Element == Swift.Float, U.Element == Swift.Float, V.Element == Swift.Float {
            
            let p = filter.count
            let n = result.count
            
            precondition(source.count == decimationFactor * (n - 1) + p)
            
            result.withUnsafeMutableBufferPointer { dest in
                source.withUnsafeBufferPointer { src in
                    filter.withUnsafeBufferPointer { f in
                        
                        vDSP_desamp(src.baseAddress!,
                                    vDSP_Stride(decimationFactor),
                                    f.baseAddress!,
                                    dest.baseAddress!,
                                    vDSP_Length(n),
                                    vDSP_Length(p))
                    }
                }
            }
    }
  @inlinable public static func downsample<T, U>(_ source: U, decimationFactor: Swift.Int, filter: T) -> [Swift.Double] where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, T.Element == Swift.Double, U.Element == Swift.Double {
            let n = (source.count - filter.count) / decimationFactor + 1
            
            let result = Array<Double>(unsafeUninitializedCapacity: n) {
                buffer, initializedCount in
                
                downsample(source,
                           decimationFactor: decimationFactor,
                           filter: filter,
                           result: &buffer)
                
                initializedCount = n
            }
            
            return result
    }
  @inlinable public static func downsample<T, U, V>(_ source: U, decimationFactor: Swift.Int, filter: T, result: inout V) where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, T.Element == Swift.Double, U.Element == Swift.Double, V.Element == Swift.Double {
            
            let p = filter.count
            let n = result.count
            
            precondition(source.count == decimationFactor * (n - 1) + p)
            
            result.withUnsafeMutableBufferPointer { dest in
                source.withUnsafeBufferPointer { src in
                    filter.withUnsafeBufferPointer { f in
                        
                        vDSP_desampD(src.baseAddress!,
                                     vDSP_Stride(decimationFactor),
                                     f.baseAddress!,
                                     dest.baseAddress!,
                                     vDSP_Length(n),
                                     vDSP_Length(p))
                    }
                }
            }
    }
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Accelerate.vImage {
  public struct Options : Swift.OptionSet {
    public init(rawValue: Accelerate.vImage_Flags)
    public let rawValue: Accelerate.vImage_Flags
    public static let noFlags: Accelerate.vImage.Options
    public static let leaveAlphaUnchanged: Accelerate.vImage.Options
    public static let copyInPlace: Accelerate.vImage.Options
    public static let backgroundColorFill: Accelerate.vImage.Options
    public static let imageExtend: Accelerate.vImage.Options
    public static let doNotTile: Accelerate.vImage.Options
    public static let highQualityResampling: Accelerate.vImage.Options
    public static let truncateKernel: Accelerate.vImage.Options
    public static let getTempBufferSize: Accelerate.vImage.Options
    public static let printDiagnosticsToConsole: Accelerate.vImage.Options
    public static let noAllocate: Accelerate.vImage.Options
    public static let hdrContent: Accelerate.vImage.Options
    public static let doNotClamp: Accelerate.vImage.Options
    public var flags: Accelerate.vImage_Flags {
      get
    }
    public typealias ArrayLiteralElement = Accelerate.vImage.Options
    public typealias Element = Accelerate.vImage.Options
    public typealias RawValue = Accelerate.vImage_Flags
  }
}
@available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
extension Accelerate.BNNS {
  public enum ActivationFunction {
    case identity
    case rectifiedLinear
    case leakyRectifiedLinear(alpha: Swift.Float)
    case sigmoid
    case logSigmoid
    case tanh
    case scaledTanh(alpha: Swift.Float, beta: Swift.Float)
    case abs
    case linear(alpha: Swift.Float)
    case clamp(bounds: Swift.ClosedRange<Swift.Float>)
    case softmax
    case geluApproximation(alpha: Swift.Float, beta: Swift.Float)
    case geluApproximation2(alpha: Swift.Float, beta: Swift.Float)
    case gumbel(alpha: Swift.Float, beta: Swift.Float)
    case gumbelMax(alpha: Swift.Float, beta: Swift.Float)
    case hardSigmoid(alpha: Swift.Float, beta: Swift.Float)
    case softplus(alpha: Swift.Float, beta: Swift.Float)
    case softsign
    case elu(alpha: Swift.Float)
    case selu
    case celu(alpha: Swift.Float)
    case clampedLeakyRectifiedLinear(alpha: Swift.Float, beta: Swift.Float)
    case linearWithBias(alpha: Swift.Float, beta: Swift.Float)
    case logSoftmax
    case hardShrink(alpha: Swift.Float)
    case softShrink(alpha: Swift.Float)
    case tanhShrink
    case threshold(alpha: Swift.Float, beta: Swift.Float)
    @available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
    case hardSwish(alpha: Swift.Float, beta: Swift.Float)
    @available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
    case silu
    public var bnnsActivation: Accelerate.BNNSActivation {
      get
    }
  }
  @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class ActivationLayer : Accelerate.BNNS.UnaryLayer {
    convenience public init?(function activationFunction: Accelerate.BNNS.ActivationFunction, input: Accelerate.BNNSNDArrayDescriptor, output: Accelerate.BNNSNDArrayDescriptor, filterParameters: Accelerate.BNNSFilterParameters? = nil)
    @objc deinit
  }
  public static func applyActivation(activation: Accelerate.BNNS.ActivationFunction, input: Accelerate.BNNSNDArrayDescriptor, output: Accelerate.BNNSNDArrayDescriptor, batchSize: Swift.Int, filterParameters: Accelerate.BNNSFilterParameters? = nil) throws
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Accelerate.BNNS.ActivationLayer {
  convenience public init?(function activationFunction: Accelerate.BNNS.ActivationFunction, axes: [Swift.Int], input: Accelerate.BNNSNDArrayDescriptor, output: Accelerate.BNNSNDArrayDescriptor, filterParameters: Accelerate.BNNSFilterParameters? = nil)
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Accelerate.BNNS {
  public static func applyActivation(activation: Accelerate.BNNS.ActivationFunction, axes: [Swift.Int], input: Accelerate.BNNSNDArrayDescriptor, output: Accelerate.BNNSNDArrayDescriptor, batchSize: Swift.Int, filterParameters: Accelerate.BNNSFilterParameters? = nil) throws
}
@available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
public enum BNNS {
}
@available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
extension Accelerate.BNNS {
  public enum DataLayout : Swift.CaseIterable {
    case vector
    case matrixRowMajor
    case matrixColumnMajor
    case matrixFirstMajor
    case matrixLastMajor
    case imageCHW
    case tensor3DFirstMajor
    case tensor3DLastMajor
    case convolutionWeightsOIHW
    case tensor4DFirstMajor
    case tensor4DLastMajor
    case tensor5DFirstMajor
    case tensor5DLastMajor
    case tensor6DFirstMajor
    case tensor6DLastMajor
    case tensor7DFirstMajor
    case tensor7DLastMajor
    case tensor8DFirstMajor
    case tensor8DLastMajor
    @available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
    case tensor3DSNE
    @available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
    case tensor3DNSE
    public static var allCases: [Accelerate.BNNS.DataLayout] {
      get
    }
    public var rank: Swift.Int {
      get
    }
    public static func == (a: Accelerate.BNNS.DataLayout, b: Accelerate.BNNS.DataLayout) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public typealias AllCases = [Accelerate.BNNS.DataLayout]
    public var hashValue: Swift.Int {
      get
    }
  }
}
@available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
extension Accelerate.BNNS {
  public enum Error : Swift.Error {
    case layerApplyFail
    case unableToCreateLayer
    case arrayDescriptorInvalidData
    case optimizerStepFail
    public static func == (a: Accelerate.BNNS.Error, b: Accelerate.BNNS.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
}
extension Accelerate.BNNSFilterParameters {
  public init(options: Accelerate.BNNSFlags, threadCount: Swift.Int, allocator: Accelerate.BNNSAlloc?, deallocator: Accelerate.BNNSFree?)
  @available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
  public var options: Accelerate.BNNSFlags {
    get
    set
  }
  @available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
  public var threadCount: Swift.Int {
    get
    set
  }
  @available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
  public var allocator: Accelerate.BNNSAlloc? {
    get
    set
  }
  @available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
  public var deallocator: Accelerate.BNNSFree? {
    get
    set
  }
}
extension Accelerate.BNNSFlags : Swift.OptionSet {
  public typealias ArrayLiteralElement = Accelerate.BNNSFlags
  public typealias Element = Accelerate.BNNSFlags
}
@available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
extension Accelerate.BNNS {
  public enum PoolingType {
    case max(indices: Swift.UnsafeMutableBufferPointer<Swift.Int>? = nil, xDilationStride: Swift.Int = 0, yDilationStride: Swift.Int = 0)
    case unMax(indices: Swift.UnsafeMutableBufferPointer<Swift.Int>? = nil, xDilationStride: Swift.Int = 0, yDilationStride: Swift.Int = 0)
    case average(countIncludesPadding: Swift.Bool)
    case l2Norm
    public var bnnsPoolingFunction: Accelerate.BNNSPoolingFunction {
      get
    }
  }
}
@available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
extension Accelerate.BNNS {
  @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class PoolingLayer : Accelerate.BNNS.Layer {
    convenience public init?(type poolingType: Accelerate.BNNS.PoolingType, input: Accelerate.BNNSNDArrayDescriptor, output: Accelerate.BNNSNDArrayDescriptor, bias: Accelerate.BNNSNDArrayDescriptor?, activation: Accelerate.BNNS.ActivationFunction, kernelSize: (width: Swift.Int, height: Swift.Int), stride: (x: Swift.Int, y: Swift.Int), padding: Accelerate.BNNS.ConvolutionPadding, filterParameters: Accelerate.BNNSFilterParameters? = nil)
    public func apply(batchSize: Swift.Int, input: Accelerate.BNNSNDArrayDescriptor, output: Accelerate.BNNSNDArrayDescriptor) throws
    public func applyBackward(batchSize: Swift.Int, input: Accelerate.BNNSNDArrayDescriptor, output: Accelerate.BNNSNDArrayDescriptor, outputGradient: Accelerate.BNNSNDArrayDescriptor, generatingInputGradient inputGradient: Accelerate.BNNSNDArrayDescriptor, generatingBiasGradient biasGradient: Accelerate.BNNSNDArrayDescriptor? = nil) throws
    @objc deinit
  }
}
@available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
extension Accelerate.BNNS {
  @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class ConvolutionLayer : Accelerate.BNNS.UnaryLayer {
    convenience public init?(type convolutionType: Accelerate.BNNS.ConvolutionType, input: Accelerate.BNNSNDArrayDescriptor, weights: Accelerate.BNNSNDArrayDescriptor, output: Accelerate.BNNSNDArrayDescriptor, bias: Accelerate.BNNSNDArrayDescriptor?, padding: Accelerate.BNNS.ConvolutionPadding, activation: Accelerate.BNNS.ActivationFunction, groupCount: Swift.Int, stride: (x: Swift.Int, y: Swift.Int), dilationStride: (x: Swift.Int, y: Swift.Int), filterParameters: Accelerate.BNNSFilterParameters? = nil)
    public func applyBackward(batchSize: Swift.Int, input: Accelerate.BNNSNDArrayDescriptor, output: Accelerate.BNNSNDArrayDescriptor, outputGradient: Accelerate.BNNSNDArrayDescriptor, generatingInputGradient inputGradient: Accelerate.BNNSNDArrayDescriptor, generatingWeightsGradient weightsGradient: Accelerate.BNNSNDArrayDescriptor? = nil, generatingBiasGradient biasGradient: Accelerate.BNNSNDArrayDescriptor? = nil) throws
    @objc deinit
  }
  public enum ConvolutionPadding {
    case symmetric(x: Swift.Int, y: Swift.Int)
    case asymmetric(left: Swift.Int, right: Swift.Int, up: Swift.Int, down: Swift.Int)
    public static var zero: Accelerate.BNNS.ConvolutionPadding {
      get
    }
  }
  public enum ConvolutionType {
    case standard
    case transposed
    public static func == (a: Accelerate.BNNS.ConvolutionType, b: Accelerate.BNNS.ConvolutionType) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Accelerate.vDSP {
  @inlinable public static func convert(splitComplexVector: Accelerate.DSPSplitComplex, toInterleavedComplexVector interleavedComplexVector: inout [Accelerate.DSPComplex]) {
        
        withUnsafePointer(to: splitComplexVector) {
            vDSP_ztoc($0, 1,
                      &interleavedComplexVector, 2,
                      vDSP_Length(interleavedComplexVector.count))
        }
    }
  @inlinable public static func convert(interleavedComplexVector: [Accelerate.DSPComplex], toSplitComplexVector splitComplexVector: inout Accelerate.DSPSplitComplex) {
        
        vDSP_ctoz(interleavedComplexVector, 2,
                  &splitComplexVector, 1,
                  vDSP_Length(interleavedComplexVector.count))
    }
  @inlinable public static func convert(splitComplexVector: Accelerate.DSPDoubleSplitComplex, toInterleavedComplexVector interleavedComplexVector: inout [Accelerate.DSPDoubleComplex]) {
        
        withUnsafePointer(to: splitComplexVector) {
            vDSP_ztocD($0, 1,
                       &interleavedComplexVector, 2,
                       vDSP_Length(interleavedComplexVector.count))
        }
    }
  @inlinable public static func convert(interleavedComplexVector: [Accelerate.DSPDoubleComplex], toSplitComplexVector splitComplexVector: inout Accelerate.DSPDoubleSplitComplex) {
        
        vDSP_ctozD(interleavedComplexVector, 2,
                   &splitComplexVector, 1,
                   vDSP_Length(interleavedComplexVector.count))
    }
}
@available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
extension Accelerate.BNNS {
  @frozen public enum LearningPhase {
    case training
    case inference
    public static func == (a: Accelerate.BNNS.LearningPhase, b: Accelerate.BNNS.LearningPhase) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class FusedLayer : Accelerate.BNNS.Layer {
    public func apply(batchSize: Swift.Int, input: Accelerate.BNNSNDArrayDescriptor, output: Accelerate.BNNSNDArrayDescriptor, for learningPhase: Accelerate.BNNS.LearningPhase) throws
    public func applyBackward(batchSize: Swift.Int, input: Accelerate.BNNSNDArrayDescriptor, output: Accelerate.BNNSNDArrayDescriptor, outputGradient: Accelerate.BNNSNDArrayDescriptor, generatingInputGradient inputGradient: Accelerate.BNNSNDArrayDescriptor, generatingParameterGradients parameterGradients: [Accelerate.BNNSNDArrayDescriptor]) throws
    @objc deinit
  }
}
@available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
extension Accelerate.BNNS {
  @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class FusedConvolutionNormalizationLayer : Accelerate.BNNS.FusedLayer {
    convenience public init?(input: Accelerate.BNNSNDArrayDescriptor, output: Accelerate.BNNSNDArrayDescriptor, convolutionWeights: Accelerate.BNNSNDArrayDescriptor, convolutionBias: Accelerate.BNNSNDArrayDescriptor?, convolutionStride: (x: Swift.Int, y: Swift.Int), convolutionDilationStride: (x: Swift.Int, y: Swift.Int), convolutionPadding: Accelerate.BNNS.ConvolutionPadding, normalization: Accelerate.BNNS.NormalizationType, normalizationBeta: Accelerate.BNNSNDArrayDescriptor, normalizationGamma: Accelerate.BNNSNDArrayDescriptor, normalizationMomentum: Swift.Float, normalizationEpsilon: Swift.Float, normalizationActivation: Accelerate.BNNS.ActivationFunction, filterParameters: Accelerate.BNNSFilterParameters? = nil)
    @objc deinit
  }
  @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class FusedFullyConnectedNormalizationLayer : Accelerate.BNNS.FusedLayer {
    convenience public init?(input: Accelerate.BNNSNDArrayDescriptor, output: Accelerate.BNNSNDArrayDescriptor, fullyConnectedWeights: Accelerate.BNNSNDArrayDescriptor, fullyConnectedBias: Accelerate.BNNSNDArrayDescriptor?, normalization: Accelerate.BNNS.NormalizationType, normalizationBeta: Accelerate.BNNSNDArrayDescriptor, normalizationGamma: Accelerate.BNNSNDArrayDescriptor, normalizationMomentum: Swift.Float, normalizationEpsilon: Swift.Float, normalizationActivation: Accelerate.BNNS.ActivationFunction, filterParameters: Accelerate.BNNSFilterParameters? = nil)
    @objc deinit
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Accelerate.BNNS {
  public struct FusedNormalizationParameters : Accelerate.FusableLayerParameters {
    public init(type: Accelerate.BNNS.NormalizationType, beta: Accelerate.BNNSNDArrayDescriptor? = nil, gamma: Accelerate.BNNSNDArrayDescriptor? = nil, momentum: Swift.Float = 0, epsilon: Swift.Float, activation: Accelerate.BNNS.ActivationFunction)
    public var type: Accelerate.BNNS.NormalizationType
    public var beta: Accelerate.BNNSNDArrayDescriptor?
    public var gamma: Accelerate.BNNSNDArrayDescriptor?
    public var momentum: Swift.Float
    public var epsilon: Swift.Float
    public var activation: Accelerate.BNNS.ActivationFunction
  }
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Accelerate.vDSP {
  @inlinable public static func maximum<U>(_ vector: U) -> Swift.Float where U : Accelerate.AccelerateBuffer, U.Element == Swift.Float {
            
            let n = vDSP_Length(vector.count)
            var output = Float.nan
            
            vector.withUnsafeBufferPointer { v in
                vDSP_maxv(v.baseAddress!, 1,
                          &output,
                          n)
            }
            
            return output
    }
  @inlinable public static func maximum<U>(_ vector: U) -> Swift.Double where U : Accelerate.AccelerateBuffer, U.Element == Swift.Double {
            
            let n = vDSP_Length(vector.count)
            var output = Double.nan
            
            vector.withUnsafeBufferPointer { v in
                vDSP_maxvD(v.baseAddress!, 1,
                           &output,
                           n)
            }
            
            return output
    }
  @inlinable public static func maximumMagnitude<U>(_ vector: U) -> Swift.Float where U : Accelerate.AccelerateBuffer, U.Element == Swift.Float {
            
            let n = vDSP_Length(vector.count)
            var output = Float.nan
            
            vector.withUnsafeBufferPointer { v in
                vDSP_maxmgv(v.baseAddress!, 1,
                            &output,
                            n)
            }
            
            return output
    }
  @inlinable public static func maximumMagnitude<U>(_ vector: U) -> Swift.Double where U : Accelerate.AccelerateBuffer, U.Element == Swift.Double {
            
            let n = vDSP_Length(vector.count)
            var output = Double.nan
            
            vector.withUnsafeBufferPointer { v in
                vDSP_maxmgvD(v.baseAddress!, 1,
                             &output,
                             n)
            }
            
            return output
    }
  @inlinable public static func minimum<U>(_ vector: U) -> Swift.Float where U : Accelerate.AccelerateBuffer, U.Element == Swift.Float {
            
            let n = vDSP_Length(vector.count)
            var output = Float.nan
            
            vector.withUnsafeBufferPointer { v in
                vDSP_minv(v.baseAddress!, 1,
                          &output,
                          n)
            }
            
            return output
    }
  @inlinable public static func minimum<U>(_ vector: U) -> Swift.Double where U : Accelerate.AccelerateBuffer, U.Element == Swift.Double {
            
            let n = vDSP_Length(vector.count)
            var output = Double.nan
            
            vector.withUnsafeBufferPointer { v in
                vDSP_minvD(v.baseAddress!, 1,
                           &output,
                           n)
            }
            
            return output
    }
  @inlinable public static func sum<U>(_ vector: U) -> Swift.Float where U : Accelerate.AccelerateBuffer, U.Element == Swift.Float {
            
            let n = vDSP_Length(vector.count)
            var output = Float.nan
            
            vector.withUnsafeBufferPointer { v in
                vDSP_sve(v.baseAddress!, 1,
                         &output,
                         n)
            }
            
            return output
    }
  @inlinable public static func sum<U>(_ vector: U) -> Swift.Double where U : Accelerate.AccelerateBuffer, U.Element == Swift.Double {
            
            let n = vDSP_Length(vector.count)
            var output = Double.nan
            
            vector.withUnsafeBufferPointer { v in
                vDSP_sveD(v.baseAddress!, 1,
                          &output,
                          n)
            }
            
            return output
    }
  @inlinable public static func sumOfSquares<U>(_ vector: U) -> Swift.Float where U : Accelerate.AccelerateBuffer, U.Element == Swift.Float {
            
            let n = vDSP_Length(vector.count)
            var output = Float.nan
            
            vector.withUnsafeBufferPointer { v in
                vDSP_svesq(v.baseAddress!, 1,
                           &output,
                           n)
            }
            
            return output
    }
  @inlinable public static func sumOfSquares<U>(_ vector: U) -> Swift.Double where U : Accelerate.AccelerateBuffer, U.Element == Swift.Double {
            
            let n = vDSP_Length(vector.count)
            var output = Double.nan
            
            vector.withUnsafeBufferPointer { v in
                vDSP_svesqD(v.baseAddress!, 1,
                            &output,
                            n)
            }
            
            return output
    }
  @inlinable public static func sumAndSumOfSquares<U>(_ vector: U) -> (elementsSum: Swift.Float, squaresSum: Swift.Float) where U : Accelerate.AccelerateBuffer, U.Element == Swift.Float {
            
            let n = vDSP_Length(vector.count)
            var sum = Float.nan
            var sumOfSquares = Float.nan
            
            vector.withUnsafeBufferPointer { v in
                vDSP_sve_svesq(v.baseAddress!, 1,
                               &sum,
                               &sumOfSquares,
                               n)
            }
            
            return (elementsSum: sum, squaresSum: sumOfSquares)
    }
  @inlinable public static func sumAndSumOfSquares<U>(_ vector: U) -> (elementsSum: Swift.Double, squaresSum: Swift.Double) where U : Accelerate.AccelerateBuffer, U.Element == Swift.Double {
            
            let n = vDSP_Length(vector.count)
            var sum = Double.nan
            var sumOfSquares = Double.nan
            
            vector.withUnsafeBufferPointer { v in
                vDSP_sve_svesqD(v.baseAddress!, 1,
                                &sum,
                                &sumOfSquares,
                                n)
            }
            
            return (elementsSum: sum, squaresSum: sumOfSquares)
    }
  @inlinable public static func sumOfMagnitudes<U>(_ vector: U) -> Swift.Float where U : Accelerate.AccelerateBuffer, U.Element == Swift.Float {
            
            let n = vDSP_Length(vector.count)
            var output = Float.nan
            
            vector.withUnsafeBufferPointer { v in
                vDSP_svemg(v.baseAddress!, 1,
                           &output,
                           n)
            }
            
            return output
    }
  @inlinable public static func sumOfMagnitudes<U>(_ vector: U) -> Swift.Double where U : Accelerate.AccelerateBuffer, U.Element == Swift.Double {
            
            let n = vDSP_Length(vector.count)
            var output = Double.nan
            
            vector.withUnsafeBufferPointer { v in
                vDSP_svemgD(v.baseAddress!, 1,
                            &output,
                            n)
            }
            
            return output
    }
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Accelerate.vDSP {
  @inlinable public static func indexOfMaximum<U>(_ vector: U) -> (Swift.UInt, Swift.Float) where U : Accelerate.AccelerateBuffer, U.Element == Swift.Float {
            
            let n = vDSP_Length(vector.count)
            var output = Float.nan
            var index: vDSP_Length = 0
            
            vector.withUnsafeBufferPointer { v in
                vDSP_maxvi(v.baseAddress!, 1,
                           &output,
                           &index,
                           n)
            }
            
            return (index, output)
    }
  @inlinable public static func indexOfMaximum<U>(_ vector: U) -> (Swift.UInt, Swift.Double) where U : Accelerate.AccelerateBuffer, U.Element == Swift.Double {
            
            let n = vDSP_Length(vector.count)
            var output = Double.nan
            var index: vDSP_Length = 0
            
            vector.withUnsafeBufferPointer { v in
                vDSP_maxviD(v.baseAddress!, 1,
                            &output,
                            &index,
                            n)
            }
            
            return (index, output)
    }
  @inlinable public static func indexOfMaximumMagnitude<U>(_ vector: U) -> (Swift.UInt, Swift.Float) where U : Accelerate.AccelerateBuffer, U.Element == Swift.Float {
            
            let n = vDSP_Length(vector.count)
            var output = Float.nan
            var index: vDSP_Length = 0
            
            vector.withUnsafeBufferPointer { v in
                vDSP_maxmgvi(v.baseAddress!, 1,
                             &output,
                             &index,
                             n)
            }
            
            return (index, output)
    }
  @inlinable public static func indexOfMaximumMagnitude<U>(_ vector: U) -> (Swift.UInt, Swift.Double) where U : Accelerate.AccelerateBuffer, U.Element == Swift.Double {
            
            let n = vDSP_Length(vector.count)
            var output = Double.nan
            var index: vDSP_Length = 0
            
            vector.withUnsafeBufferPointer { v in
                vDSP_maxmgviD(v.baseAddress!, 1,
                              &output,
                              &index,
                              n)
            }
            
            return (index, output)
    }
  @inlinable public static func indexOfMinimum<U>(_ vector: U) -> (Swift.UInt, Swift.Float) where U : Accelerate.AccelerateBuffer, U.Element == Swift.Float {
            
            let n = vDSP_Length(vector.count)
            var output = Float.nan
            var index: vDSP_Length = 0
            
            vector.withUnsafeBufferPointer { v in
                vDSP_minvi(v.baseAddress!, 1,
                           &output,
                           &index,
                           n)
            }
            
            return (index, output)
    }
  @inlinable public static func indexOfMinimum<U>(_ vector: U) -> (Swift.UInt, Swift.Double) where U : Accelerate.AccelerateBuffer, U.Element == Swift.Double {
            
            let n = vDSP_Length(vector.count)
            var output = Double.nan
            var index: vDSP_Length = 0
            
            vector.withUnsafeBufferPointer { v in
                vDSP_minviD(v.baseAddress!, 1,
                            &output,
                            &index,
                            n)
            }
            
            return (index, output)
    }
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Accelerate.vDSP {
  @inlinable public static func meanSquare<U>(_ vector: U) -> Swift.Float where U : Accelerate.AccelerateBuffer, U.Element == Swift.Float {
            
            let n = vDSP_Length(vector.count)
            var output = Float.nan
            
            vector.withUnsafeBufferPointer { v in
                vDSP_measqv(v.baseAddress!, 1,
                            &output,
                            n)
            }
            
            return output
    }
  @inlinable public static func meanSquare<U>(_ vector: U) -> Swift.Double where U : Accelerate.AccelerateBuffer, U.Element == Swift.Double {
            
            let n = vDSP_Length(vector.count)
            var output = Double.nan
            
            vector.withUnsafeBufferPointer { v in
                vDSP_measqvD(v.baseAddress!, 1,
                             &output,
                             n)
            }
            
            return output
    }
  @inlinable public static func meanMagnitude<U>(_ vector: U) -> Swift.Float where U : Accelerate.AccelerateBuffer, U.Element == Swift.Float {
            
            let n = vDSP_Length(vector.count)
            var output = Float.nan
            
            vector.withUnsafeBufferPointer { v in
                vDSP_meamgv(v.baseAddress!, 1,
                            &output,
                            n)
            }
            
            return output
    }
  @inlinable public static func meanMagnitude<U>(_ vector: U) -> Swift.Double where U : Accelerate.AccelerateBuffer, U.Element == Swift.Double {
            
            let n = vDSP_Length(vector.count)
            var output = Double.nan
            
            vector.withUnsafeBufferPointer { v in
                vDSP_meamgvD(v.baseAddress!, 1,
                             &output,
                             n)
            }
            
            return output
    }
  @inlinable public static func mean<U>(_ vector: U) -> Swift.Float where U : Accelerate.AccelerateBuffer, U.Element == Swift.Float {
            
            let n = vDSP_Length(vector.count)
            var output = Float.nan
            
            vector.withUnsafeBufferPointer { v in
                vDSP_meanv(v.baseAddress!, 1,
                           &output,
                           n)
            }
            
            return output
    }
  @inlinable public static func mean<U>(_ vector: U) -> Swift.Double where U : Accelerate.AccelerateBuffer, U.Element == Swift.Double {
            
            let n = vDSP_Length(vector.count)
            var output = Double.nan
            
            vector.withUnsafeBufferPointer { v in
                vDSP_meanvD(v.baseAddress!, 1,
                            &output,
                            n)
            }
            
            return output
    }
  @inlinable public static func rootMeanSquare<U>(_ vector: U) -> Swift.Float where U : Accelerate.AccelerateBuffer, U.Element == Swift.Float {
            
            let n = vDSP_Length(vector.count)
            var output = Float.nan
            
            vector.withUnsafeBufferPointer { v in
                vDSP_rmsqv(v.baseAddress!, 1,
                           &output,
                           n)
            }
            
            return output
    }
  @inlinable public static func rootMeanSquare<U>(_ vector: U) -> Swift.Double where U : Accelerate.AccelerateBuffer, U.Element == Swift.Double {
            
            let n = vDSP_Length(vector.count)
            var output = Double.nan
            
            vector.withUnsafeBufferPointer { v in
                vDSP_rmsqvD(v.baseAddress!, 1,
                            &output,
                            n)
            }
            
            return output
    }
}
@available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
extension Accelerate.BNNS {
  @_hasMissingDesignatedInitializers public class BroadcastMatrixMultiplyLayer : Accelerate.BNNS.Layer {
    convenience public init?(inputA: Accelerate.BNNSNDArrayDescriptor, transposed transposeA: Swift.Bool, isWeights aIsWeights: Swift.Bool, inputB: Accelerate.BNNSNDArrayDescriptor, transposed transposeB: Swift.Bool, isWeights bIsWeights: Swift.Bool, output: Accelerate.BNNSNDArrayDescriptor, alpha: Swift.Float, accumulatesToOutput: Swift.Bool, isQuadratic: Swift.Bool, filterParameters: Accelerate.BNNSFilterParameters? = nil)
    @available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
    public func apply(batchSize: Swift.Int, inputA: Accelerate.BNNSNDArrayDescriptor, inputB: Accelerate.BNNSNDArrayDescriptor, output: Accelerate.BNNSNDArrayDescriptor) throws
    public func applyBackward(batchSize: Swift.Int, inputA: Accelerate.BNNSNDArrayDescriptor, inputB: Accelerate.BNNSNDArrayDescriptor, output: Accelerate.BNNSNDArrayDescriptor, outputGradient: Accelerate.BNNSNDArrayDescriptor, generatingInputAGradient inputAGradient: Accelerate.BNNSNDArrayDescriptor, generatingInputBGradient inputBGradient: Accelerate.BNNSNDArrayDescriptor) throws
    @objc deinit
  }
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Accelerate.vDSP {
  @inlinable public static func convertElements<U, V>(of source: U, to destination: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.UInt8, V.Element == Swift.Float {
            
            precondition(source.count == destination.count)
            
            let n = vDSP_Length(source.count)
            
            destination.withUnsafeMutableBufferPointer { dest in
                source.withUnsafeBufferPointer { src in
                    vDSP_vfltu8(src.baseAddress!, 1,
                                dest.baseAddress!, 1,
                                n)
                }
            }
    }
  @inlinable public static func convertElements<U, V>(of source: U, to destination: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.UInt8, V.Element == Swift.Double {
            
            precondition(source.count == destination.count)
            
            let n = vDSP_Length(source.count)
            
            destination.withUnsafeMutableBufferPointer { dest in
                source.withUnsafeBufferPointer { src in
                    vDSP_vfltu8D(src.baseAddress!, 1,
                                 dest.baseAddress!, 1,
                                 n)
                }
            }
    }
  @inlinable public static func convertElements<U, V>(of source: U, to destination: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.UInt16, V.Element == Swift.Float {
            
            precondition(source.count == destination.count)
            
            let n = vDSP_Length(source.count)
            
            destination.withUnsafeMutableBufferPointer { dest in
                source.withUnsafeBufferPointer { src in
                    vDSP_vfltu16(src.baseAddress!, 1,
                                 dest.baseAddress!, 1,
                                 n)
                }
            }
    }
  @inlinable public static func convertElements<U, V>(of source: U, to destination: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.UInt16, V.Element == Swift.Double {
            
            precondition(source.count == destination.count)
            
            let n = vDSP_Length(source.count)
            
            destination.withUnsafeMutableBufferPointer { dest in
                source.withUnsafeBufferPointer { src in
                    vDSP_vfltu16D(src.baseAddress!, 1,
                                  dest.baseAddress!, 1,
                                  n)
                }
            }
    }
  @inlinable public static func convertElements<U, V>(of source: U, to destination: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.UInt32, V.Element == Swift.Float {
            
            precondition(source.count == destination.count)
            
            let n = vDSP_Length(source.count)
            
            destination.withUnsafeMutableBufferPointer { dest in
                source.withUnsafeBufferPointer { src in
                    vDSP_vfltu32(src.baseAddress!, 1,
                                 dest.baseAddress!, 1,
                                 n)
                }
            }
    }
  @inlinable public static func convertElements<U, V>(of source: U, to destination: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.UInt32, V.Element == Swift.Double {
            
            precondition(source.count == destination.count)
            
            let n = vDSP_Length(source.count)
            
            destination.withUnsafeMutableBufferPointer { dest in
                source.withUnsafeBufferPointer { src in
                    vDSP_vfltu32D(src.baseAddress!, 1,
                                  dest.baseAddress!, 1,
                                  n)
                }
            }
    }
  @inlinable public static func convertElements<U, V>(of source: U, to destination: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Int8, V.Element == Swift.Float {
            
            precondition(source.count == destination.count)
            
            let n = vDSP_Length(source.count)
            
            destination.withUnsafeMutableBufferPointer { dest in
                source.withUnsafeBufferPointer { src in
                    vDSP_vflt8(src.baseAddress!, 1,
                               dest.baseAddress!, 1,
                               n)
                }
            }
    }
  @inlinable public static func convertElements<U, V>(of source: U, to destination: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Int8, V.Element == Swift.Double {
            
            precondition(source.count == destination.count)
            
            let n = vDSP_Length(source.count)
            
            destination.withUnsafeMutableBufferPointer { dest in
                source.withUnsafeBufferPointer { src in
                    vDSP_vflt8D(src.baseAddress!, 1,
                                dest.baseAddress!, 1,
                                n)
                }
            }
    }
  @inlinable public static func convertElements<U, V>(of source: U, to destination: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Int16, V.Element == Swift.Float {
            
            precondition(source.count == destination.count)
            
            let n = vDSP_Length(source.count)
            
            destination.withUnsafeMutableBufferPointer { dest in
                source.withUnsafeBufferPointer { src in
                    vDSP_vflt16(src.baseAddress!, 1,
                                dest.baseAddress!, 1,
                                n)
                }
            }
    }
  @inlinable public static func convertElements<U, V>(of source: U, to destination: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Int16, V.Element == Swift.Double {
            
            precondition(source.count == destination.count)
            
            let n = vDSP_Length(source.count)
            
            destination.withUnsafeMutableBufferPointer { dest in
                source.withUnsafeBufferPointer { src in
                    vDSP_vflt16D(src.baseAddress!, 1,
                                 dest.baseAddress!, 1,
                                 n)
                }
            }
    }
  @inlinable public static func convertElements<U, V>(of source: U, to destination: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Int32, V.Element == Swift.Float {
            
            precondition(source.count == destination.count)
            
            let n = vDSP_Length(source.count)
            
            destination.withUnsafeMutableBufferPointer { dest in
                source.withUnsafeBufferPointer { src in
                    vDSP_vflt32(src.baseAddress!, 1,
                                dest.baseAddress!, 1,
                                n)
                }
            }
    }
  @inlinable public static func convertElements<U, V>(of source: U, to destination: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Int32, V.Element == Swift.Double {
            
            precondition(source.count == destination.count)
            
            let n = vDSP_Length(source.count)
            
            destination.withUnsafeMutableBufferPointer { dest in
                source.withUnsafeBufferPointer { src in
                    vDSP_vflt32D(src.baseAddress!, 1,
                                 dest.baseAddress!, 1,
                                 n)
                }
            }
    }
  public enum RoundingMode {
    case towardZero
    case towardNearestInteger
    public static func == (a: Accelerate.vDSP.RoundingMode, b: Accelerate.vDSP.RoundingMode) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public static func convertElements<U, V>(of source: U, to destination: inout V, rounding: Accelerate.vDSP.RoundingMode) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Float, V.Element == Swift.Int32
  public static func convertElements<U, V>(of source: U, to destination: inout V, rounding: Accelerate.vDSP.RoundingMode) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Double, V.Element == Swift.Int32
  public static func convertElements<U, V>(of source: U, to destination: inout V, rounding: Accelerate.vDSP.RoundingMode) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Float, V.Element == Swift.UInt16
  public static func convertElements<U, V>(of source: U, to destination: inout V, rounding: Accelerate.vDSP.RoundingMode) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Double, V.Element == Swift.UInt16
  public static func convertElements<U, V>(of source: U, to destination: inout V, rounding: Accelerate.vDSP.RoundingMode) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Float, V.Element == Swift.UInt32
  public static func convertElements<U, V>(of source: U, to destination: inout V, rounding: Accelerate.vDSP.RoundingMode) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Double, V.Element == Swift.UInt32
  public static func convertElements<U, V>(of source: U, to destination: inout V, rounding: Accelerate.vDSP.RoundingMode) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Float, V.Element == Swift.Int16
  public static func convertElements<U, V>(of source: U, to destination: inout V, rounding: Accelerate.vDSP.RoundingMode) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Double, V.Element == Swift.Int16
  public static func convertElements<U, V>(of source: U, to destination: inout V, rounding: Accelerate.vDSP.RoundingMode) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Float, V.Element == Swift.Int8
  public static func convertElements<U, V>(of source: U, to destination: inout V, rounding: Accelerate.vDSP.RoundingMode) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Double, V.Element == Swift.Int8
  public static func convertElements<U, V>(of source: U, to destination: inout V, rounding: Accelerate.vDSP.RoundingMode) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Float, V.Element == Swift.UInt8
  public static func convertElements<U, V>(of source: U, to destination: inout V, rounding: Accelerate.vDSP.RoundingMode) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Double, V.Element == Swift.UInt8
  @inlinable public static func convertElements<U, V>(of source: U, to destination: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Float, V.Element == Swift.Double {
            let n = vDSP_Length(min(source.count,
                                    destination.count))
            
            destination.withUnsafeMutableBufferPointer { dest in
                source.withUnsafeBufferPointer { src in
                    vDSP_vspdp(src.baseAddress!, 1,
                               dest.baseAddress!, 1,
                               n)
                }
            }
    }
  @inlinable public static func convertElements<U, V>(of source: U, to destination: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Double, V.Element == Swift.Float {
            let n = vDSP_Length(min(source.count,
                                    destination.count))
            
            destination.withUnsafeMutableBufferPointer { dest in
                source.withUnsafeBufferPointer { src in
                    vDSP_vdpsp(src.baseAddress!, 1,
                               dest.baseAddress!, 1,
                               n)
                }
            }
    }
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
public protocol vDSP_IntegerConvertable {
}
extension Swift.UInt8 : Accelerate.vDSP_IntegerConvertable {
}
extension Swift.UInt16 : Accelerate.vDSP_IntegerConvertable {
}
extension Swift.UInt32 : Accelerate.vDSP_IntegerConvertable {
}
extension Swift.Int8 : Accelerate.vDSP_IntegerConvertable {
}
extension Swift.Int16 : Accelerate.vDSP_IntegerConvertable {
}
extension Swift.Int32 : Accelerate.vDSP_IntegerConvertable {
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
public protocol vDSP_FloatingPointConvertable {
}
extension Swift.Float : Accelerate.vDSP_FloatingPointConvertable {
}
extension Swift.Double : Accelerate.vDSP_FloatingPointConvertable {
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Accelerate.vDSP {
  @inlinable public static func integerToFloatingPoint<T, U>(_ vector: T, floatingPointType: U.Type) -> [U] where T : Accelerate.AccelerateBuffer, U : Accelerate.vDSP_FloatingPointConvertable, T.Element == Swift.UInt8 {
            
            switch floatingPointType {
            case is Float.Type:
                let result = Array<Float>(unsafeUninitializedCapacity: vector.count) {
                    buffer, initializedCount in
                    
                    convertElements(of: vector,
                                    to: &buffer)
                    
                    initializedCount = vector.count
                }
                
                return result as! [U]
            case is Double.Type:
                let result = Array<Double>(unsafeUninitializedCapacity: vector.count) {
                    buffer, initializedCount in
                    
                    convertElements(of: vector,
                                    to: &buffer)
                    
                    initializedCount = vector.count
                }
                
                return result as! [U]
                
            default:
                fatalError("\(floatingPointType) not supported as a destination type.")
            }
    }
  @inlinable public static func integerToFloatingPoint<T, U>(_ vector: T, floatingPointType: U.Type) -> [U] where T : Accelerate.AccelerateBuffer, U : Accelerate.vDSP_FloatingPointConvertable, T.Element == Swift.UInt16 {
            
            switch floatingPointType {
            case is Float.Type:
                let result = Array<Float>(unsafeUninitializedCapacity: vector.count) {
                    buffer, initializedCount in
                    
                    convertElements(of: vector,
                                    to: &buffer)
                    
                    initializedCount = vector.count
                }
                
                return result as! [U]
            case is Double.Type:
                let result = Array<Double>(unsafeUninitializedCapacity: vector.count) {
                    buffer, initializedCount in
                    
                    convertElements(of: vector,
                                    to: &buffer)
                    
                    initializedCount = vector.count
                }
                
                return result as! [U]
                
            default:
                fatalError("\(floatingPointType) not supported as a destination type.")
            }
    }
  @inlinable public static func integerToFloatingPoint<T, U>(_ vector: T, floatingPointType: U.Type) -> [U] where T : Accelerate.AccelerateBuffer, U : Accelerate.vDSP_FloatingPointConvertable, T.Element == Swift.UInt32 {
            
            switch floatingPointType {
            case is Float.Type:
                let result = Array<Float>(unsafeUninitializedCapacity: vector.count) {
                    buffer, initializedCount in
                    
                    convertElements(of: vector,
                                    to: &buffer)
                    
                    initializedCount = vector.count
                }
                
                return result as! [U]
            case is Double.Type:
                let result = Array<Double>(unsafeUninitializedCapacity: vector.count) {
                    buffer, initializedCount in
                    
                    convertElements(of: vector,
                                    to: &buffer)
                    
                    initializedCount = vector.count
                }
                
                return result as! [U]
                
            default:
                fatalError("\(floatingPointType) not supported as a destination type.")
            }
    }
  @inlinable public static func integerToFloatingPoint<T, U>(_ vector: T, floatingPointType: U.Type) -> [U] where T : Accelerate.AccelerateBuffer, U : Accelerate.vDSP_FloatingPointConvertable, T.Element == Swift.Int8 {
            
            switch floatingPointType {
            case is Float.Type:
                let result = Array<Float>(unsafeUninitializedCapacity: vector.count) {
                    buffer, initializedCount in
                    
                    convertElements(of: vector,
                                    to: &buffer)
                    
                    initializedCount = vector.count
                }
                
                return result as! [U]
            case is Double.Type:
                let result = Array<Double>(unsafeUninitializedCapacity: vector.count) {
                    buffer, initializedCount in
                    
                    convertElements(of: vector,
                                    to: &buffer)
                    
                    initializedCount = vector.count
                }
                
                return result as! [U]
                
            default:
                fatalError("\(floatingPointType) not supported as a destination type.")
            }
    }
  @inlinable public static func integerToFloatingPoint<T, U>(_ vector: T, floatingPointType: U.Type) -> [U] where T : Accelerate.AccelerateBuffer, U : Accelerate.vDSP_FloatingPointConvertable, T.Element == Swift.Int16 {
            
            switch floatingPointType {
            case is Float.Type:
                let result = Array<Float>(unsafeUninitializedCapacity: vector.count) {
                    buffer, initializedCount in
                    
                    convertElements(of: vector,
                                    to: &buffer)
                    
                    initializedCount = vector.count
                }
                
                return result as! [U]
            case is Double.Type:
                let result = Array<Double>(unsafeUninitializedCapacity: vector.count) {
                    buffer, initializedCount in
                    
                    convertElements(of: vector,
                                    to: &buffer)
                    
                    initializedCount = vector.count
                }
                
                return result as! [U]
                
            default:
                fatalError("\(floatingPointType) not supported as a destination type.")
            }
    }
  @inlinable public static func integerToFloatingPoint<T, U>(_ vector: T, floatingPointType: U.Type) -> [U] where T : Accelerate.AccelerateBuffer, U : Accelerate.vDSP_FloatingPointConvertable, T.Element == Swift.Int32 {
            
            switch floatingPointType {
            case is Float.Type:
                let result = Array<Float>(unsafeUninitializedCapacity: vector.count) {
                    buffer, initializedCount in
                    
                    convertElements(of: vector,
                                    to: &buffer)
                    
                    initializedCount = vector.count
                }
                
                return result as! [U]
            case is Double.Type:
                let result = Array<Double>(unsafeUninitializedCapacity: vector.count) {
                    buffer, initializedCount in
                    
                    convertElements(of: vector,
                                    to: &buffer)
                    
                    initializedCount = vector.count
                }
                
                return result as! [U]
                
            default:
                fatalError("\(floatingPointType) not supported as a destination type.")
            }
    }
  @inlinable public static func floatingPointToInteger<T, U>(_ vector: T, integerType: U.Type, rounding: Accelerate.vDSP.RoundingMode) -> [U] where T : Accelerate.AccelerateBuffer, U : Accelerate.vDSP_IntegerConvertable, T.Element == Swift.Float {
            
            switch integerType {
            case is UInt8.Type:
                let result = Array<UInt8>(unsafeUninitializedCapacity: vector.count) {
                    buffer, initializedCount in
                    
                    convertElements(of: vector,
                                    to: &buffer,
                                    rounding: rounding)
                    
                    initializedCount = vector.count
                }
                
                return result as! [U]
            case is UInt16.Type:
                let result = Array<UInt16>(unsafeUninitializedCapacity: vector.count) {
                    buffer, initializedCount in
                    
                    convertElements(of: vector,
                                    to: &buffer,
                                    rounding: rounding)
                    
                    initializedCount = vector.count
                }
                
                return result as! [U]
            case is UInt32.Type:
                let result = Array<UInt32>(unsafeUninitializedCapacity: vector.count) {
                    buffer, initializedCount in
                    
                    convertElements(of: vector,
                                    to: &buffer,
                                    rounding: rounding)
                    
                    initializedCount = vector.count
                }
                
                return result as! [U]
            case is Int8.Type:
                let result = Array<Int8>(unsafeUninitializedCapacity: vector.count) {
                    buffer, initializedCount in
                    
                    convertElements(of: vector,
                                    to: &buffer,
                                    rounding: rounding)
                    
                    initializedCount = vector.count
                }
                
                return result as! [U]
            case is Int16.Type:
                let result = Array<Int16>(unsafeUninitializedCapacity: vector.count) {
                    buffer, initializedCount in
                    
                    convertElements(of: vector,
                                    to: &buffer,
                                    rounding: rounding)
                    
                    initializedCount = vector.count
                }
                
                return result as! [U]
            case is Int32.Type:
                let result = Array<Int32>(unsafeUninitializedCapacity: vector.count) {
                    buffer, initializedCount in
                    
                    convertElements(of: vector,
                                    to: &buffer,
                                    rounding: rounding)
                    
                    initializedCount = vector.count
                }
                
                return result as! [U]
            default:
                fatalError("\(integerType) not supported as a destination type.")
            }
    }
  @inlinable public static func floatingPointToInteger<T, U>(_ vector: T, integerType: U.Type, rounding: Accelerate.vDSP.RoundingMode) -> [U] where T : Accelerate.AccelerateBuffer, U : Accelerate.vDSP_IntegerConvertable, T.Element == Swift.Double {
            
            switch integerType {
            case is UInt8.Type:
                let result = Array<UInt8>(unsafeUninitializedCapacity: vector.count) {
                    buffer, initializedCount in
                    
                    convertElements(of: vector,
                                    to: &buffer,
                                    rounding: rounding)
                    
                    initializedCount = vector.count
                }
                
                return result as! [U]
            case is UInt16.Type:
                let result = Array<UInt16>(unsafeUninitializedCapacity: vector.count) {
                    buffer, initializedCount in
                    
                    convertElements(of: vector,
                                    to: &buffer,
                                    rounding: rounding)
                    
                    initializedCount = vector.count
                }
                
                return result as! [U]
            case is UInt32.Type:
                let result = Array<UInt32>(unsafeUninitializedCapacity: vector.count) {
                    buffer, initializedCount in
                    
                    convertElements(of: vector,
                                    to: &buffer,
                                    rounding: rounding)
                    
                    initializedCount = vector.count
                }
                
                return result as! [U]
            case is Int8.Type:
                let result = Array<Int8>(unsafeUninitializedCapacity: vector.count) {
                    buffer, initializedCount in
                    
                    convertElements(of: vector,
                                    to: &buffer,
                                    rounding: rounding)
                    
                    initializedCount = vector.count
                }
                
                return result as! [U]
            case is Int16.Type:
                let result = Array<Int16>(unsafeUninitializedCapacity: vector.count) {
                    buffer, initializedCount in
                    
                    convertElements(of: vector,
                                    to: &buffer,
                                    rounding: rounding)
                    
                    initializedCount = vector.count
                }
                
                return result as! [U]
            case is Int32.Type:
                let result = Array<Int32>(unsafeUninitializedCapacity: vector.count) {
                    buffer, initializedCount in
                    
                    convertElements(of: vector,
                                    to: &buffer,
                                    rounding: rounding)
                    
                    initializedCount = vector.count
                }
                
                return result as! [U]
            default:
                fatalError("\(integerType) not supported as a destination type.")
            }
    }
  @inlinable public static func floatToDouble<U>(_ source: U) -> [Swift.Double] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Float {
            let result = Array<Double>(unsafeUninitializedCapacity: source.count) {
                buffer, initializedCount in
                
                convertElements(of: source,
                                to: &buffer)
                
                initializedCount = source.count
            }
            
            return result
    }
  @inlinable public static func doubleToFloat<U>(_ source: U) -> [Swift.Float] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Double {
            let result = Array<Float>(unsafeUninitializedCapacity: source.count) {
                buffer, initializedCount in
                
                convertElements(of: source,
                                to: &buffer)
                
                initializedCount = source.count
            }
            
            return result
    }
}
@available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
extension Accelerate.BNNS {
  public static func applyTopK(k: Swift.Int, input: Accelerate.BNNSNDArrayDescriptor, bestValues: Accelerate.BNNSNDArrayDescriptor, bestIndices: Accelerate.BNNSNDArrayDescriptor, axis: Swift.Int, batchSize: Swift.Int, filterParameters: Accelerate.BNNSFilterParameters? = nil) throws
  public static func applyInTopK(k: Swift.Int, input: Accelerate.BNNSNDArrayDescriptor, testIndices: Accelerate.BNNSNDArrayDescriptor, output: Accelerate.BNNSNDArrayDescriptor, axis: Swift.Int, batchSize: Swift.Int, filterParameters: Accelerate.BNNSFilterParameters? = nil) throws
}
@available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
extension Accelerate.vDSP {
  @inlinable public static func taperedMerge<T, U, V>(_ vectorA: T, _ vectorB: U, result: inout V) where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, T.Element == Swift.Float, U.Element == Swift.Float, V.Element == Swift.Float {
            
            precondition(vectorA.count == vectorB.count,
                         "The number of elements in `vectorA` must equal the number of elements in `vectorB`.")
            precondition(vectorA.count == result.count,
                         "The number of elements in `vectorA` must equal the number of elements in `result`.")
            
            let n = vDSP_Length(vectorA.count)
            
            vectorA.withUnsafeBufferPointer { a in
                vectorB.withUnsafeBufferPointer { b in
                    result.withUnsafeMutableBufferPointer { dest in
                        
                        vDSP_vtmerg(a.baseAddress!, 1,
                                    b.baseAddress!, 1,
                                    dest.baseAddress!, 1,
                                    n)
                    }
                }
            }
    }
  @inlinable public static func taperedMerge<T, U, V>(_ vectorA: T, _ vectorB: U, result: inout V) where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, T.Element == Swift.Double, U.Element == Swift.Double, V.Element == Swift.Double {
            
            precondition(vectorA.count == vectorB.count,
                         "The number of elements in `vectorA` must equal the number of elements in `vectorB`.")
            precondition(vectorA.count == result.count,
                         "The number of elements in `vectorA` must equal the number of elements in `result`.")
            
            let n = vDSP_Length(vectorA.count)
            
            vectorA.withUnsafeBufferPointer { a in
                vectorB.withUnsafeBufferPointer { b in
                    result.withUnsafeMutableBufferPointer { dest in
                        
                        vDSP_vtmergD(a.baseAddress!, 1,
                                     b.baseAddress!, 1,
                                     dest.baseAddress!, 1,
                                     n)
                    }
                }
            }
    }
  @inlinable public static func taperedMerge<T, U>(_ vectorA: T, _ vectorB: U) -> [Swift.Float] where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, T.Element == Swift.Float, U.Element == Swift.Float {
            
            let resultCount = vectorA.count
            
            let result = Array<Float>(unsafeUninitializedCapacity: resultCount) {
                buffer, initializedCount in
                
                vDSP.taperedMerge(vectorA,
                                  vectorB,
                                  result: &buffer)
                
                initializedCount = resultCount
            }
            
            return result
    }
  @inlinable public static func taperedMerge<T, U>(_ vectorA: T, _ vectorB: U) -> [Swift.Double] where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, T.Element == Swift.Double, U.Element == Swift.Double {
            
            let resultCount = vectorA.count
            
            let result = Array<Double>(unsafeUninitializedCapacity: resultCount) {
                buffer, initializedCount in
                
                vDSP.taperedMerge(vectorA,
                                  vectorB,
                                  result: &buffer)
                
                initializedCount = resultCount
            }
            
            return result
    }
  @inlinable public static func swapElements<T, U>(_ vectorA: inout T, _ vectorB: inout U) where T : Accelerate.AccelerateMutableBuffer, U : Accelerate.AccelerateMutableBuffer, T.Element == Swift.Float, U.Element == Swift.Float {
            
            precondition(vectorA.count == vectorB.count,
                         "The number of elements in `vectorA` must equal the number of elements in `vectorB`.")
            
            let n = vDSP_Length(vectorA.count)
            
            vectorA.withUnsafeMutableBufferPointer { a in
                vectorB.withUnsafeMutableBufferPointer { b in
                    vDSP_vswap(a.baseAddress!, 1,
                               b.baseAddress!, 1,
                               n)
                }
            }
    }
  @inlinable public static func swapElements<T, U>(_ vectorA: inout T, _ vectorB: inout U) where T : Accelerate.AccelerateMutableBuffer, U : Accelerate.AccelerateMutableBuffer, T.Element == Swift.Double, U.Element == Swift.Double {
            
            precondition(vectorA.count == vectorB.count,
                         "The number of elements in `vectorA` must equal the number of elements in `vectorB`.")
            
            let n = vDSP_Length(vectorA.count)
            
            vectorA.withUnsafeMutableBufferPointer { a in
                vectorB.withUnsafeMutableBufferPointer { b in
                    vDSP_vswapD(a.baseAddress!, 1,
                                b.baseAddress!, 1,
                                n)
                }
            }
    }
}
@available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
extension Accelerate.vDSP {
  @inlinable public static func gather<T, U, V>(_ vector: T, indices: U, result: inout V) where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, T.Element == Swift.Float, U.Element == Swift.UInt, V.Element == Swift.Float {
            precondition(indices.count == result.count,
                         "The number of elements in `indices` must equal the number of elements in `result`.")
            
            let n = vDSP_Length(result.count)
            
            result.withUnsafeMutableBufferPointer { r in
                vector.withUnsafeBufferPointer { v in
                    indices.withUnsafeBufferPointer { i in
                        vDSP_vgathr(v.baseAddress!,
                                    i.baseAddress!, 1,
                                    r.baseAddress!, 1,
                                    n)
                    }
                }
            }
    }
  @inlinable public static func gather<T, U, V>(_ vector: T, indices: U, result: inout V) where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, T.Element == Swift.Double, U.Element == Swift.UInt, V.Element == Swift.Double {
            precondition(indices.count == result.count,
                         "The number of elements in `indices` must equal the number of elements in `result`.")
            
            let n = vDSP_Length(result.count)
            
            result.withUnsafeMutableBufferPointer { r in
                vector.withUnsafeBufferPointer { v in
                    indices.withUnsafeBufferPointer { i in
                        vDSP_vgathrD(v.baseAddress!,
                                     i.baseAddress!, 1,
                                     r.baseAddress!, 1,
                                     n)
                    }
                }
            }
    }
  @inlinable public static func gather<T, U>(_ vector: T, indices: U) -> [Swift.Float] where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, T.Element == Swift.Float, U.Element == Swift.UInt {
            
            let resultCount = indices.count
            
            let result = Array<Float>(unsafeUninitializedCapacity: resultCount) {
                buffer, initializedCount in
                
                vDSP.gather(vector,
                            indices: indices,
                            result: &buffer)
                
                initializedCount = resultCount
            }
            
            return result
    }
  @inlinable public static func gather<T, U>(_ vector: T, indices: U) -> [Swift.Double] where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, T.Element == Swift.Double, U.Element == Swift.UInt {
            
            let resultCount = indices.count
            
            let result = Array<Double>(unsafeUninitializedCapacity: resultCount) {
                buffer, initializedCount in
                
                vDSP.gather(vector,
                            indices: indices,
                            result: &buffer)
                
                initializedCount = resultCount
            }
            
            return result
    }
  @inlinable public static func compress<T, U, V>(_ vector: T, gatingVector: U, result: inout V) where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, T.Element == Swift.Float, U.Element == Swift.Float, V.Element == Swift.Float {
            
            precondition(vector.count == gatingVector.count,
                         "The number of elements in `gatingVector` must equal the number of elements in `vector`.")
            
            let n = vDSP_Length(vector.count)
            
            result.withUnsafeMutableBufferPointer { r in
                vector.withUnsafeBufferPointer { v in
                    gatingVector.withUnsafeBufferPointer { g in
                        vDSP_vcmprs(v.baseAddress!, 1,
                                    g.baseAddress!, 1,
                                    r.baseAddress!, 1,
                                    n)
                    }
                }
            }
    }
  @inlinable public static func compress<T, U, V>(_ vector: T, gatingVector: U, result: inout V) where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, T.Element == Swift.Double, U.Element == Swift.Double, V.Element == Swift.Double {
            
            precondition(vector.count == gatingVector.count,
                         "The number of elements in `gatingVector` must equal the number of elements in `vector`.")
            
            let n = vDSP_Length(vector.count)
            
            result.withUnsafeMutableBufferPointer { r in
                vector.withUnsafeBufferPointer { v in
                    gatingVector.withUnsafeBufferPointer { g in
                        vDSP_vcmprsD(v.baseAddress!, 1,
                                     g.baseAddress!, 1,
                                     r.baseAddress!, 1,
                                     n)
                    }
                }
            }
    }
  @inlinable public static func compress<T, U>(_ vector: T, gatingVector: U, nonZeroGatingCount: Swift.Int?) -> [Swift.Float] where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, T.Element == Swift.Float, U.Element == Swift.Float {
            
            let resultCount: Int
            
            if let nonZeroGatingCount = nonZeroGatingCount {
                resultCount = nonZeroGatingCount
            } else {
                // Count elements in `gatingVector` that are non-zero.
                var lowCount: vDSP_Length = 0
                var highCount: vDSP_Length = 0
                var clippingThreshold: Float = 0
                
                _ = Array<Float>(unsafeUninitializedCapacity: gatingVector.count) {
                    buffer, initializedCount in
                    
                    gatingVector.withUnsafeBufferPointer { g in
                        vDSP_vclipc(g.baseAddress!, 1,
                                    &clippingThreshold, &clippingThreshold,
                                    buffer.baseAddress!, 1,
                                    vDSP_Length(gatingVector.count),
                                    &lowCount, &highCount)
                    }
                }
                
                resultCount = Int(lowCount + highCount)
            }
            
            let result = Array<Float>(unsafeUninitializedCapacity: resultCount) {
                buffer, initializedCount in
                
                vDSP.compress(vector,
                              gatingVector: gatingVector,
                              result: &buffer)
                
                initializedCount = resultCount
            }
            
            return result
    }
  @inlinable public static func compress<T, U>(_ vector: T, gatingVector: U, nonZeroGatingCount: Swift.Int?) -> [Swift.Double] where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, T.Element == Swift.Double, U.Element == Swift.Double {
            
            let resultCount: Int
            
            if let nonZeroGatingCount = nonZeroGatingCount {
                resultCount = nonZeroGatingCount
            } else {
                // Count elements in `gatingVector` that are non-zero.
                var lowCount: vDSP_Length = 0
                var highCount: vDSP_Length = 0
                var clippingThreshold: Double = 0
                
                _ = Array<Double>(unsafeUninitializedCapacity: gatingVector.count) {
                    buffer, initializedCount in
                    
                    gatingVector.withUnsafeBufferPointer { g in
                        vDSP_vclipcD(g.baseAddress!, 1,
                                     &clippingThreshold, &clippingThreshold,
                                     buffer.baseAddress!, 1,
                                     vDSP_Length(gatingVector.count),
                                     &lowCount, &highCount)
                    }
                }
                
                resultCount = Int(lowCount + highCount)
            }
            
            let result = Array<Double>(unsafeUninitializedCapacity: resultCount) {
                buffer, initializedCount in
                
                vDSP.compress(vector,
                              gatingVector: gatingVector,
                              result: &buffer)
                
                initializedCount = resultCount
            }
            
            return result
    }
}
@available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
extension Accelerate.BNNS {
  public enum Shape {
    public init(_ size: [Swift.Int], dataLayout: Accelerate.BNNS.DataLayout? = nil, stride: [Swift.Int]? = nil)
    case vector(_: Swift.Int, stride: Swift.Int = 0)
    case matrixColumnMajor(_: Swift.Int, _: Swift.Int, stride: (Swift.Int, Swift.Int) = (0, 0))
    case matrixRowMajor(_: Swift.Int, _: Swift.Int, stride: (Swift.Int, Swift.Int) = (0, 0))
    case matrixFirstMajor(_: Swift.Int, _: Swift.Int, stride: (Swift.Int, Swift.Int) = (0, 0))
    case matrixLastMajor(_: Swift.Int, _: Swift.Int, stride: (Swift.Int, Swift.Int) = (0, 0))
    case imageCHW(_: Swift.Int, _: Swift.Int, _: Swift.Int, stride: (Swift.Int, Swift.Int, Swift.Int) = (0, 0, 0))
    case tensor3DFirstMajor(_: Swift.Int, _: Swift.Int, _: Swift.Int, stride: (Swift.Int, Swift.Int, Swift.Int) = (0, 0, 0))
    case tensor3DLastMajor(_: Swift.Int, _: Swift.Int, _: Swift.Int, stride: (Swift.Int, Swift.Int, Swift.Int) = (0, 0, 0))
    @available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
    case tensor3DSNE(_: Swift.Int, _: Swift.Int, _: Swift.Int, stride: (Swift.Int, Swift.Int, Swift.Int) = (0, 0, 0))
    @available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
    case tensor3DNSE(_: Swift.Int, _: Swift.Int, _: Swift.Int, stride: (Swift.Int, Swift.Int, Swift.Int) = (0, 0, 0))
    case convolutionWeightsOIHW(_: Swift.Int, _: Swift.Int, _: Swift.Int, _: Swift.Int, stride: (Swift.Int, Swift.Int, Swift.Int, Swift.Int) = (0, 0, 0, 0))
    case tensor4DFirstMajor(_: Swift.Int, _: Swift.Int, _: Swift.Int, _: Swift.Int, stride: (Swift.Int, Swift.Int, Swift.Int, Swift.Int) = (0, 0, 0, 0))
    case tensor4DLastMajor(_: Swift.Int, _: Swift.Int, _: Swift.Int, _: Swift.Int, stride: (Swift.Int, Swift.Int, Swift.Int, Swift.Int) = (0, 0, 0, 0))
    case tensor5DFirstMajor(_: Swift.Int, _: Swift.Int, _: Swift.Int, _: Swift.Int, _: Swift.Int, stride: (Swift.Int, Swift.Int, Swift.Int, Swift.Int, Swift.Int) = (0, 0, 0, 0, 0))
    case tensor5DLastMajor(_: Swift.Int, _: Swift.Int, _: Swift.Int, _: Swift.Int, _: Swift.Int, stride: (Swift.Int, Swift.Int, Swift.Int, Swift.Int, Swift.Int) = (0, 0, 0, 0, 0))
    case tensor6DFirstMajor(_: Swift.Int, _: Swift.Int, _: Swift.Int, _: Swift.Int, _: Swift.Int, _: Swift.Int, stride: (Swift.Int, Swift.Int, Swift.Int, Swift.Int, Swift.Int, Swift.Int) = (0, 0, 0, 0, 0, 0))
    case tensor6DLastMajor(_: Swift.Int, _: Swift.Int, _: Swift.Int, _: Swift.Int, _: Swift.Int, _: Swift.Int, stride: (Swift.Int, Swift.Int, Swift.Int, Swift.Int, Swift.Int, Swift.Int) = (0, 0, 0, 0, 0, 0))
    case tensor7DFirstMajor(_: Swift.Int, _: Swift.Int, _: Swift.Int, _: Swift.Int, _: Swift.Int, _: Swift.Int, _: Swift.Int, stride: (Swift.Int, Swift.Int, Swift.Int, Swift.Int, Swift.Int, Swift.Int, Swift.Int) = (0, 0, 0, 0, 0, 0, 0))
    case tensor7DLastMajor(_: Swift.Int, _: Swift.Int, _: Swift.Int, _: Swift.Int, _: Swift.Int, _: Swift.Int, _: Swift.Int, stride: (Swift.Int, Swift.Int, Swift.Int, Swift.Int, Swift.Int, Swift.Int, Swift.Int) = (0, 0, 0, 0, 0, 0, 0))
    case tensor8DFirstMajor(_: Swift.Int, _: Swift.Int, _: Swift.Int, _: Swift.Int, _: Swift.Int, _: Swift.Int, _: Swift.Int, _: Swift.Int, stride: (Swift.Int, Swift.Int, Swift.Int, Swift.Int, Swift.Int, Swift.Int, Swift.Int, Swift.Int) = (0, 0, 0, 0, 0, 0, 0, 0))
    case tensor8DLastMajor(_: Swift.Int, _: Swift.Int, _: Swift.Int, _: Swift.Int, _: Swift.Int, _: Swift.Int, _: Swift.Int, _: Swift.Int, stride: (Swift.Int, Swift.Int, Swift.Int, Swift.Int, Swift.Int, Swift.Int, Swift.Int, Swift.Int) = (0, 0, 0, 0, 0, 0, 0, 0))
    public var rank: Swift.Int {
      get
    }
    public var size: (Swift.Int, Swift.Int, Swift.Int, Swift.Int, Swift.Int, Swift.Int, Swift.Int, Swift.Int) {
      get
    }
    public var stride: (Swift.Int, Swift.Int, Swift.Int, Swift.Int, Swift.Int, Swift.Int, Swift.Int, Swift.Int) {
      get
    }
    public var batchStride: Swift.Int {
      get
    }
    public var layout: Accelerate.BNNSDataLayout {
      get
    }
  }
}
@available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
extension Accelerate.BNNS.Shape : Swift.ExpressibleByArrayLiteral {
  public typealias ArrayLiteralElement = Swift.Int
  public init(arrayLiteral: Accelerate.BNNS.Shape.ArrayLiteralElement...)
}
@available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
extension Accelerate.BNNS {
  @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class PermuteLayer : Accelerate.BNNS.UnaryLayer {
    convenience public init?(input: Accelerate.BNNSNDArrayDescriptor, output: Accelerate.BNNSNDArrayDescriptor, permutation: [Swift.Int], filterParameters: Accelerate.BNNSFilterParameters? = nil)
    @objc deinit
  }
}
@available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
extension Accelerate.BNNS {
  @_hasMissingDesignatedInitializers public class Layer {
    @objc deinit
    final public let bnnsFilter: Accelerate.BNNSFilter
  }
  @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class UnaryLayer : Accelerate.BNNS.Layer {
    public func apply(batchSize: Swift.Int, input: Accelerate.BNNSNDArrayDescriptor, output: Accelerate.BNNSNDArrayDescriptor) throws
    public func applyBackward(batchSize: Swift.Int, input: Accelerate.BNNSNDArrayDescriptor, output: Accelerate.BNNSNDArrayDescriptor, outputGradient: Accelerate.BNNSNDArrayDescriptor, generatingInputGradient inputGradient: Accelerate.BNNSNDArrayDescriptor) throws
    @objc deinit
  }
  @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class BinaryLayer : Accelerate.BNNS.Layer {
    public func apply(batchSize: Swift.Int, inputA: Accelerate.BNNSNDArrayDescriptor, inputB: Accelerate.BNNSNDArrayDescriptor, output: Accelerate.BNNSNDArrayDescriptor) throws
    public func applyBackward(batchSize: Swift.Int, inputA: Accelerate.BNNSNDArrayDescriptor, inputB: Accelerate.BNNSNDArrayDescriptor, output: Accelerate.BNNSNDArrayDescriptor, outputGradient: Accelerate.BNNSNDArrayDescriptor, generatingInputAGradient inputAGradient: Accelerate.BNNSNDArrayDescriptor, generatingInputBGradient inputBGradient: Accelerate.BNNSNDArrayDescriptor) throws
    @objc deinit
  }
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Accelerate.vDSP {
  @inlinable public static func powerToDecibels<U>(_ power: U, zeroReference: Swift.Float) -> [Swift.Float] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Float {
            
            let result = Array<Float>(unsafeUninitializedCapacity: power.count) {
                buffer, initializedCount in
                
                convert(power: power,
                        toDecibels: &buffer,
                        zeroReference: zeroReference)
                
                initializedCount = power.count
            }
            
            return result
    }
  @inlinable public static func convert<U, V>(power: U, toDecibels decibels: inout V, zeroReference: Swift.Float) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Float, V.Element == Swift.Float {
            
            let n = decibels.count
            precondition(power.count == n)
            
            decibels.withUnsafeMutableBufferPointer { db in
                power.withUnsafeBufferPointer { pwr in
                    withUnsafePointer(to: zeroReference) { zref in
                        vDSP_vdbcon(pwr.baseAddress!, 1,
                                    zref,
                                    db.baseAddress!, 1,
                                    vDSP_Length(n),
                                    0)
                    }
                }
            }
    }
  @inlinable public static func powerToDecibels<U>(_ power: U, zeroReference: Swift.Double) -> [Swift.Double] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Double {
            
            let result = Array<Double>(unsafeUninitializedCapacity: power.count) {
                buffer, initializedCount in
                
                convert(power: power,
                        toDecibels: &buffer,
                        zeroReference: zeroReference)
                
                initializedCount = power.count
            }
            
            return result
    }
  @inlinable public static func convert<U, V>(power: U, toDecibels decibels: inout V, zeroReference: Swift.Double) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Double, V.Element == Swift.Double {
            
            let n = decibels.count
            precondition(power.count == n)
            
            decibels.withUnsafeMutableBufferPointer { db in
                power.withUnsafeBufferPointer { pwr in
                    withUnsafePointer(to: zeroReference) { zref in
                        vDSP_vdbconD(pwr.baseAddress!, 1,
                                     zref,
                                     db.baseAddress!, 1,
                                     vDSP_Length(n),
                                     0)
                    }
                }
            }
    }
  @inlinable public static func amplitudeToDecibels<U>(_ amplitude: U, zeroReference: Swift.Float) -> [Swift.Float] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Float {
            
            let result = Array<Float>(unsafeUninitializedCapacity: amplitude.count) {
                buffer, initializedCount in
                
                convert(amplitude: amplitude,
                        toDecibels: &buffer,
                        zeroReference: zeroReference)
                
                initializedCount = amplitude.count
            }
            
            return result
    }
  @inlinable public static func convert<U, V>(amplitude: U, toDecibels decibels: inout V, zeroReference: Swift.Float) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Float, V.Element == Swift.Float {
            
            let n = decibels.count
            precondition(amplitude.count == n)
            
            decibels.withUnsafeMutableBufferPointer { db in
                amplitude.withUnsafeBufferPointer { amp in
                    withUnsafePointer(to: zeroReference) { zref in
                        vDSP_vdbcon(amp.baseAddress!, 1,
                                    zref,
                                    db.baseAddress!, 1,
                                    vDSP_Length(n),
                                    1)
                    }
                }
            }
    }
  @inlinable public static func amplitudeToDecibels<U>(_ amplitude: U, zeroReference: Swift.Double) -> [Swift.Double] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Double {
            
            let result = Array<Double>(unsafeUninitializedCapacity: amplitude.count) {
                buffer, initializedCount in
                
                convert(amplitude: amplitude,
                        toDecibels: &buffer,
                        zeroReference: zeroReference)
                
                initializedCount = amplitude.count
            }
            
            return result
    }
  @inlinable public static func convert<U, V>(amplitude: U, toDecibels decibels: inout V, zeroReference: Swift.Double) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Double, V.Element == Swift.Double {
            
            let n = decibels.count
            precondition(amplitude.count == n)
            
            decibels.withUnsafeMutableBufferPointer { db in
                amplitude.withUnsafeBufferPointer { amp in
                    withUnsafePointer(to: zeroReference) { zref in
                        vDSP_vdbconD(amp.baseAddress!, 1,
                                     zref,
                                     db.baseAddress!, 1,
                                     vDSP_Length(n),
                                     1)
                    }
                }
            }
    }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
public protocol vDSP_DiscreteFourierTransformable {
  associatedtype DiscreteFourierTransformFunctions : Accelerate.vDSP_DiscreteTransformLifecycleFunctions
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
public protocol vDSP_DiscreteTransformLifecycleFunctions {
  static func makeDiscreteFourierTransform(previous: Swift.OpaquePointer?, count: Swift.Int, direction: Accelerate.vDSP.FourierTransformDirection, transformType: Accelerate.vDSP.DFTTransformType) throws -> Swift.OpaquePointer
  static func destroySetup(_ setup: Swift.OpaquePointer)
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Swift.Float : Accelerate.vDSP_DiscreteFourierTransformable {
  public typealias DiscreteFourierTransformFunctions = Accelerate.vDSP.DFTSinglePrecisionSplitComplexFunctions
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Swift.Double : Accelerate.vDSP_DiscreteFourierTransformable {
  public typealias DiscreteFourierTransformFunctions = Accelerate.vDSP.DFTDoublePrecisionSplitComplexFunctions
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Accelerate.DSPComplex : Accelerate.vDSP_DiscreteFourierTransformable {
  public typealias DiscreteFourierTransformFunctions = Accelerate.vDSP.DFTSinglePrecisionInterleavedFunctions
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Accelerate.DSPDoubleComplex : Accelerate.vDSP_DiscreteFourierTransformable {
  public typealias DiscreteFourierTransformFunctions = Accelerate.vDSP.DFTDoublePrecisionInterleavedFunctions
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Accelerate.vDSP {
  public struct DFTSinglePrecisionSplitComplexFunctions : Accelerate.vDSP_DiscreteTransformLifecycleFunctions {
    public static func makeDiscreteFourierTransform(previous: Swift.OpaquePointer? = nil, count: Swift.Int, direction: Accelerate.vDSP.FourierTransformDirection, transformType: Accelerate.vDSP.DFTTransformType) throws -> Swift.OpaquePointer
    public static func destroySetup(_ setup: Swift.OpaquePointer)
  }
  public struct DFTDoublePrecisionSplitComplexFunctions : Accelerate.vDSP_DiscreteTransformLifecycleFunctions {
    public static func makeDiscreteFourierTransform(previous: Swift.OpaquePointer? = nil, count: Swift.Int, direction: Accelerate.vDSP.FourierTransformDirection, transformType: Accelerate.vDSP.DFTTransformType) throws -> Swift.OpaquePointer
    public static func destroySetup(_ setup: Swift.OpaquePointer)
  }
  public struct DFTSinglePrecisionInterleavedFunctions : Accelerate.vDSP_DiscreteTransformLifecycleFunctions {
    public static func makeDiscreteFourierTransform(previous: Swift.OpaquePointer? = nil, count: Swift.Int, direction: Accelerate.vDSP.FourierTransformDirection, transformType: Accelerate.vDSP.DFTTransformType) throws -> Swift.OpaquePointer
    public static func destroySetup(_ setup: Swift.OpaquePointer)
  }
  public struct DFTDoublePrecisionInterleavedFunctions : Accelerate.vDSP_DiscreteTransformLifecycleFunctions {
    public static func makeDiscreteFourierTransform(previous: Swift.OpaquePointer? = nil, count: Swift.Int, direction: Accelerate.vDSP.FourierTransformDirection, transformType: Accelerate.vDSP.DFTTransformType) throws -> Swift.OpaquePointer
    public static func destroySetup(_ setup: Swift.OpaquePointer)
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Accelerate.vDSP {
  public enum DFTError : Swift.Error {
    case invalidSplitComplexCount(count: Swift.Int, transformType: Accelerate.vDSP.DFTTransformType)
    case invalidInterleavedCount(count: Swift.Int)
    public var errorDescription: Swift.String? {
      get
    }
  }
  public class DiscreteFourierTransform<T> where T : Accelerate.vDSP_DiscreteFourierTransformable {
    public init(previous: Accelerate.vDSP.DiscreteFourierTransform<Swift.Float>? = nil, count: Swift.Int, direction: Accelerate.vDSP.FourierTransformDirection, transformType: Accelerate.vDSP.DFTTransformType, ofType: T.Type) throws
    @objc deinit
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Accelerate.vDSP.DiscreteFourierTransform where T == Swift.Float {
  public func transform<U>(real: U, imaginary: U) -> (real: [Swift.Float], imaginary: [Swift.Float]) where U : Accelerate.AccelerateBuffer, U.Element == Swift.Float
  public func transform<U, V>(inputReal: U, inputImaginary: U, outputReal: inout V, outputImaginary: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Float, V.Element == Swift.Float
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Accelerate.vDSP.DiscreteFourierTransform where T == Swift.Double {
  public func transform<U>(real: U, imaginary: U) -> (real: [Swift.Double], imaginary: [Swift.Double]) where U : Accelerate.AccelerateBuffer, U.Element == Swift.Double
  public func transform<U, V>(inputReal: U, inputImaginary: U, outputReal: inout V, outputImaginary: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Double, V.Element == Swift.Double
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Accelerate.vDSP.DiscreteFourierTransform where T == Accelerate.DSPComplex {
  public func transform<U>(input: U) -> [Accelerate.DSPComplex] where U : Accelerate.AccelerateBuffer, U.Element == Accelerate.DSPComplex
  public func transform<U, V>(input: U, output: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Accelerate.DSPComplex, V.Element == Accelerate.DSPComplex
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Accelerate.vDSP.DiscreteFourierTransform where T == Accelerate.DSPDoubleComplex {
  public func transform<U>(input: U) -> [Accelerate.DSPDoubleComplex] where U : Accelerate.AccelerateBuffer, U.Element == Accelerate.DSPDoubleComplex
  public func transform<U, V>(input: U, output: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Accelerate.DSPDoubleComplex, V.Element == Accelerate.DSPDoubleComplex
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Accelerate.BNNS {
  public enum ArithmeticTernaryFunction {
    case multiplyAdd
    public var bnnsArithmeticFunction: Accelerate.BNNSArithmeticFunction {
      get
    }
    public static func == (a: Accelerate.BNNS.ArithmeticTernaryFunction, b: Accelerate.BNNS.ArithmeticTernaryFunction) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class TernaryArithmeticLayer : Accelerate.BNNS.Layer {
    convenience public init?(inputA: Accelerate.BNNSNDArrayDescriptor, inputADescriptorType: Accelerate.BNNS.DescriptorType, inputB: Accelerate.BNNSNDArrayDescriptor, inputBDescriptorType: Accelerate.BNNS.DescriptorType, inputC: Accelerate.BNNSNDArrayDescriptor, inputCDescriptorType: Accelerate.BNNS.DescriptorType, output: Accelerate.BNNSNDArrayDescriptor, outputDescriptorType: Accelerate.BNNS.DescriptorType, function: Accelerate.BNNS.ArithmeticTernaryFunction, activation: Accelerate.BNNS.ActivationFunction = .identity, filterParameters: Accelerate.BNNSFilterParameters? = nil)
    public func apply(batchSize: Swift.Int, inputA: Accelerate.BNNSNDArrayDescriptor, inputB: Accelerate.BNNSNDArrayDescriptor, inputC: Accelerate.BNNSNDArrayDescriptor, output: Accelerate.BNNSNDArrayDescriptor) throws
    public func applyBackward(batchSize: Swift.Int, inputA: Accelerate.BNNSNDArrayDescriptor, inputB: Accelerate.BNNSNDArrayDescriptor, inputC: Accelerate.BNNSNDArrayDescriptor, output: Accelerate.BNNSNDArrayDescriptor, outputGradient: Accelerate.BNNSNDArrayDescriptor, generatingInputAGradient inputAGradient: Accelerate.BNNSNDArrayDescriptor, generatingInputBGradient inputBGradient: Accelerate.BNNSNDArrayDescriptor, generatingInputCGradient inputCGradient: Accelerate.BNNSNDArrayDescriptor) throws
    @objc deinit
  }
}
@available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
extension Accelerate.BNNS {
  @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class GramLayer : Accelerate.BNNS.UnaryLayer {
    convenience public init?(input: Accelerate.BNNSNDArrayDescriptor, output: Accelerate.BNNSNDArrayDescriptor, alpha: Swift.Float, filterParameters: Accelerate.BNNSFilterParameters? = nil)
    @objc deinit
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Accelerate.BNNS {
  public struct FusedFullyConnectedParameters : Accelerate.FusableLayerParameters {
    public init(weights: Accelerate.BNNSNDArrayDescriptor, bias: Accelerate.BNNSNDArrayDescriptor?)
    public var weights: Accelerate.BNNSNDArrayDescriptor
    public var bias: Accelerate.BNNSNDArrayDescriptor?
  }
}
@available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
public protocol BNNSOptimizer {
  func step(parameters: [Accelerate.BNNSNDArrayDescriptor], gradients: [Accelerate.BNNSNDArrayDescriptor], accumulators: [Accelerate.BNNSNDArrayDescriptor], filterParameters: Accelerate.BNNSFilterParameters?) throws
  var bnnsOptimizerFunction: Accelerate.BNNSOptimizerFunction { get }
  var accumulatorCountMultiplier: Swift.Int { get }
}
@available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
extension Accelerate.BNNSOptimizer {
  public func step(parameters: [Accelerate.BNNSNDArrayDescriptor], gradients: [Accelerate.BNNSNDArrayDescriptor], accumulators: [Accelerate.BNNSNDArrayDescriptor], filterParameters: Accelerate.BNNSFilterParameters? = nil) throws
}
@available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
extension Accelerate.BNNS {
  public struct AdamOptimizer : Accelerate.BNNSOptimizer {
    public var accumulatorCountMultiplier: Swift.Int {
      get
    }
    public var learningRate: Swift.Float {
      get
      set
    }
    public var beta1: Swift.Float {
      get
      set
    }
    public var beta2: Swift.Float {
      get
      set
    }
    public var timeStep: Swift.Float {
      get
      set
    }
    public var epsilon: Swift.Float {
      get
      set
    }
    public var gradientScale: Swift.Float {
      get
      set
    }
    public var regularizationScale: Swift.Float {
      get
      set
    }
    public var gradientBounds: Swift.ClosedRange<Swift.Float>? {
      get
      set
    }
    public var regularizationFunction: Accelerate.BNNSOptimizerRegularizationFunction {
      get
      set
    }
    public init(learningRate: Swift.Float, beta1: Swift.Float, beta2: Swift.Float, timeStep: Swift.Float, epsilon: Swift.Float, gradientScale: Swift.Float, regularizationScale: Swift.Float, clipsGradientsTo gradientBounds: Swift.ClosedRange<Swift.Float>? = nil, regularizationFunction: Accelerate.BNNSOptimizerRegularizationFunction)
    public var bnnsOptimizerFunction: Accelerate.BNNSOptimizerFunction {
      get
    }
  }
  public struct RMSPropOptimizer : Accelerate.BNNSOptimizer {
    public var accumulatorCountMultiplier: Swift.Int {
      get
    }
    public var learningRate: Swift.Float {
      get
      set
    }
    public var alpha: Swift.Float {
      get
      set
    }
    public var epsilon: Swift.Float {
      get
      set
    }
    public var centered: Swift.Bool {
      get
      set
    }
    public var momentum: Swift.Float {
      get
      set
    }
    public var gradientScale: Swift.Float {
      get
      set
    }
    public var regularizationScale: Swift.Float {
      get
      set
    }
    public var gradientBounds: Swift.ClosedRange<Swift.Float>? {
      get
      set
    }
    public var regularizationFunction: Accelerate.BNNSOptimizerRegularizationFunction {
      get
      set
    }
    public init(learningRate: Swift.Float, alpha: Swift.Float, epsilon: Swift.Float, centered: Swift.Bool, momentum: Swift.Float, gradientScale: Swift.Float, regularizationScale: Swift.Float, clipsGradientsTo gradientBounds: Swift.ClosedRange<Swift.Float>? = nil, regularizationFunction: Accelerate.BNNSOptimizerRegularizationFunction)
    public var bnnsOptimizerFunction: Accelerate.BNNSOptimizerFunction {
      get
    }
  }
  public struct SGDMomentumOptimizer : Accelerate.BNNSOptimizer {
    public var accumulatorCountMultiplier: Swift.Int {
      get
    }
    public var learningRate: Swift.Float {
      get
      set
    }
    public var momentum: Swift.Float {
      get
      set
    }
    public var gradientScale: Swift.Float {
      get
      set
    }
    public var regularizationScale: Swift.Float {
      get
      set
    }
    public var gradientBounds: Swift.ClosedRange<Swift.Float>? {
      get
      set
    }
    @available(macOS, introduced: 11.0, deprecated: 12.0, renamed: "getter:usesNesterovMomentum(self:)")
    @available(iOS, introduced: 14.0, deprecated: 15.0, renamed: "getter:usesNesterovMomentum(self:)")
    @available(tvOS, introduced: 14.0, deprecated: 15.0, renamed: "getter:usesNesterovMomentum(self:)")
    @available(watchOS, introduced: 7.0, deprecated: 8.0, renamed: "getter:usesNesterovMomentum(self:)")
    @available(*, deprecated, renamed: "getter:usesNesterovMomentum(self:)")
    public var usesNestrovMomentum: Swift.Bool {
      get
      set
    }
    @available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
    public var usesNesterovMomentum: Swift.Bool {
      get
      set
    }
    public var regularizationFunction: Accelerate.BNNSOptimizerRegularizationFunction {
      get
      set
    }
    public var sgdMomentumVariant: Accelerate.BNNSOptimizerSGDMomentumVariant {
      get
      set
    }
    @available(macOS, introduced: 11.0, deprecated: 12.0, renamed: "init(learningRate:momentum:gradientScale:regularizationScale:clipsGradientsTo:usesNesterovMomentum:regularizationFunction:sgdMomentumVariant:)")
    @available(iOS, introduced: 14.0, deprecated: 15.0, renamed: "init(learningRate:momentum:gradientScale:regularizationScale:clipsGradientsTo:usesNesterovMomentum:regularizationFunction:sgdMomentumVariant:)")
    @available(tvOS, introduced: 14.0, deprecated: 15.0, renamed: "init(learningRate:momentum:gradientScale:regularizationScale:clipsGradientsTo:usesNesterovMomentum:regularizationFunction:sgdMomentumVariant:)")
    @available(watchOS, introduced: 7.0, deprecated: 8.0, renamed: "init(learningRate:momentum:gradientScale:regularizationScale:clipsGradientsTo:usesNesterovMomentum:regularizationFunction:sgdMomentumVariant:)")
    @available(*, deprecated, renamed: "init(learningRate:momentum:gradientScale:regularizationScale:clipsGradientsTo:usesNesterovMomentum:regularizationFunction:sgdMomentumVariant:)")
    public init(learningRate: Swift.Float, momentum: Swift.Float, gradientScale: Swift.Float, regularizationScale: Swift.Float, clipsGradientsTo gradientBounds: Swift.ClosedRange<Swift.Float>? = nil, usesNestrovMomentum: Swift.Bool, regularizationFunction: Accelerate.BNNSOptimizerRegularizationFunction, sgdMomentumVariant: Accelerate.BNNSOptimizerSGDMomentumVariant)
    @available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
    public init(learningRate: Swift.Float, momentum: Swift.Float, gradientScale: Swift.Float, regularizationScale: Swift.Float, clipsGradientsTo gradientBounds: Swift.ClosedRange<Swift.Float>? = nil, usesNesterovMomentum: Swift.Bool, regularizationFunction: Accelerate.BNNSOptimizerRegularizationFunction, sgdMomentumVariant: Accelerate.BNNSOptimizerSGDMomentumVariant)
    public var bnnsOptimizerFunction: Accelerate.BNNSOptimizerFunction {
      get
    }
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Accelerate.BNNS {
  public struct FusedTernaryArithmeticParameters : Accelerate.FusableLayerParameters {
    public var inputADescriptorType: Accelerate.BNNS.DescriptorType
    public var inputBDescriptorType: Accelerate.BNNS.DescriptorType
    public var inputCDescriptorType: Accelerate.BNNS.DescriptorType
    public var outputDescriptorType: Accelerate.BNNS.DescriptorType
    public var function: Accelerate.BNNS.ArithmeticTernaryFunction
    public init(inputADescriptorType: Accelerate.BNNS.DescriptorType, inputBDescriptorType: Accelerate.BNNS.DescriptorType, inputCDescriptorType: Accelerate.BNNS.DescriptorType, outputDescriptorType: Accelerate.BNNS.DescriptorType, function: Accelerate.BNNS.ArithmeticTernaryFunction)
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Accelerate.BNNS.FusedParametersLayer {
  convenience public init?(inputA: Accelerate.BNNSNDArrayDescriptor, inputB: Accelerate.BNNSNDArrayDescriptor, inputC: Accelerate.BNNSNDArrayDescriptor, output: Accelerate.BNNSNDArrayDescriptor, fusedLayerParameters: [Accelerate.FusableLayerParameters], filterParameters: Accelerate.BNNSFilterParameters? = nil)
  public func apply(batchSize: Swift.Int, inputA: Accelerate.BNNSNDArrayDescriptor, inputB: Accelerate.BNNSNDArrayDescriptor, inputC: Accelerate.BNNSNDArrayDescriptor, output: Accelerate.BNNSNDArrayDescriptor, for learningPhase: Accelerate.BNNS.LearningPhase) throws
  public func applyBackward(batchSize: Swift.Int, inputA: Accelerate.BNNSNDArrayDescriptor, inputB: Accelerate.BNNSNDArrayDescriptor, inputC: Accelerate.BNNSNDArrayDescriptor, output: Accelerate.BNNSNDArrayDescriptor, outputGradient: Accelerate.BNNSNDArrayDescriptor, generatingInputAGradient inputAGradient: Accelerate.BNNSNDArrayDescriptor, generatingInputBGradient inputBGradient: Accelerate.BNNSNDArrayDescriptor, generatingInputCGradient inputCGradient: Accelerate.BNNSNDArrayDescriptor, generatingParameterGradients parameterGradients: [Accelerate.BNNSNDArrayDescriptor]) throws
}
@available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
extension Accelerate.BNNS {
  @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class NormalizationLayer : Accelerate.BNNS.Layer {
    convenience public init?(type normalization: Accelerate.BNNS.NormalizationType, input: Accelerate.BNNSNDArrayDescriptor, output: Accelerate.BNNSNDArrayDescriptor, beta: Accelerate.BNNSNDArrayDescriptor, gamma: Accelerate.BNNSNDArrayDescriptor, momentum: Swift.Float = 0, epsilon: Swift.Float, activation: Accelerate.BNNS.ActivationFunction, filterParameters: Accelerate.BNNSFilterParameters? = nil)
    public func apply(batchSize: Swift.Int, input: Accelerate.BNNSNDArrayDescriptor, output: Accelerate.BNNSNDArrayDescriptor, for learningPhase: Accelerate.BNNS.LearningPhase) throws
    public func applyBackward(batchSize: Swift.Int, input: Accelerate.BNNSNDArrayDescriptor, output: Accelerate.BNNSNDArrayDescriptor, outputGradient: Accelerate.BNNSNDArrayDescriptor, generatingInputGradient inputGradient: Accelerate.BNNSNDArrayDescriptor, generatingBetaGradient betaGradient: Accelerate.BNNSNDArrayDescriptor? = nil, generatingGammaGradient gammaGradient: Accelerate.BNNSNDArrayDescriptor? = nil) throws
    @objc deinit
  }
}
@available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
extension Accelerate.BNNS {
  public enum NormalizationType {
    case batch(movingMean: Accelerate.BNNSNDArrayDescriptor?, movingVariance: Accelerate.BNNSNDArrayDescriptor?)
    case instance(movingMean: Accelerate.BNNSNDArrayDescriptor?, movingVariance: Accelerate.BNNSNDArrayDescriptor?)
    case layer(normalizationAxis: Swift.Int)
    case group(groupCount: Swift.Int)
  }
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Accelerate.vDSP {
  @inlinable public static func rectangularToPolar<U>(_ rectangularCoordinates: U) -> [Swift.Float] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Float {
            
            let result = Array<Float>(unsafeUninitializedCapacity: rectangularCoordinates.count) {
                buffer, initializedCount in
                
                convert(rectangularCoordinates: rectangularCoordinates,
                        toPolarCoordinates: &buffer)
                
                initializedCount = rectangularCoordinates.count
            }
            
            return result
    }
  @inlinable public static func convert<U, V>(rectangularCoordinates: U, toPolarCoordinates polarCoordinates: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Float, V.Element == Swift.Float {
            
            let n = rectangularCoordinates.count
            precondition(polarCoordinates.count == n)
            
            polarCoordinates.withUnsafeMutableBufferPointer { dest in
                rectangularCoordinates.withUnsafeBufferPointer { src in
                    vDSP_polar(src.baseAddress!, 2,
                               dest.baseAddress!, 2,
                               vDSP_Length(n / 2))
                }
            }
    }
  @inlinable public static func rectangularToPolar<U>(_ rectangularCoordinates: U) -> [Swift.Double] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Double {
            
            let result = Array<Double>(unsafeUninitializedCapacity: rectangularCoordinates.count) {
                buffer, initializedCount in
                
                convert(rectangularCoordinates: rectangularCoordinates,
                        toPolarCoordinates: &buffer)
                
                initializedCount = rectangularCoordinates.count
            }
            
            return result
    }
  @inlinable public static func convert<U, V>(rectangularCoordinates: U, toPolarCoordinates polarCoordinates: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Double, V.Element == Swift.Double {
            
            let n = rectangularCoordinates.count
            precondition(polarCoordinates.count == n)
            
            polarCoordinates.withUnsafeMutableBufferPointer { dest in
                rectangularCoordinates.withUnsafeBufferPointer { src in
                    vDSP_polarD(src.baseAddress!, 2,
                                dest.baseAddress!, 2,
                                vDSP_Length(n / 2))
                }
            }
    }
  @inlinable public static func polarToRectangular<U>(_ polarCoordinates: U) -> [Swift.Float] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Float {
            
            let result = Array<Float>(unsafeUninitializedCapacity: polarCoordinates.count) {
                buffer, initializedCount in
                
                convert(polarCoordinates: polarCoordinates,
                        toRectangularCoordinates: &buffer)
                
                initializedCount = polarCoordinates.count
            }
            
            return result
    }
  @inlinable public static func convert<U, V>(polarCoordinates: U, toRectangularCoordinates rectangularCoordinates: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Float, V.Element == Swift.Float {
            
            let n = rectangularCoordinates.count
            precondition(polarCoordinates.count == n)
            
            rectangularCoordinates.withUnsafeMutableBufferPointer { dest in
                polarCoordinates.withUnsafeBufferPointer { src in
                    vDSP_rect(src.baseAddress!, 2,
                              dest.baseAddress!, 2,
                              vDSP_Length(n / 2))
                }
            }
    }
  @inlinable public static func polarToRectangular<U>(_ polarCoordinates: U) -> [Swift.Double] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Double {
            
            let result = Array<Double>(unsafeUninitializedCapacity: polarCoordinates.count) {
                buffer, initializedCount in
                
                convert(polarCoordinates: polarCoordinates,
                        toRectangularCoordinates: &buffer)
                
                initializedCount = polarCoordinates.count
            }
            
            return result
    }
  @inlinable public static func convert<U, V>(polarCoordinates: U, toRectangularCoordinates rectangularCoordinates: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Double, V.Element == Swift.Double {
            
            let n = rectangularCoordinates.count
            precondition(polarCoordinates.count == n)
            
            rectangularCoordinates.withUnsafeMutableBufferPointer { dest in
                polarCoordinates.withUnsafeBufferPointer { src in
                    vDSP_rectD(src.baseAddress!, 2,
                               dest.baseAddress!, 2,
                               vDSP_Length(n / 2))
                }
            }
    }
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Accelerate.vDSP {
  public enum DFTTransformType {
    case complexComplex
    case complexReal
    public static func == (a: Accelerate.vDSP.DFTTransformType, b: Accelerate.vDSP.DFTTransformType) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  @available(macOS, deprecated, introduced: 10.15, message: "Use `vDSP.DiscreteFourierTransform`.")
  @available(iOS, deprecated, introduced: 13.0, message: "Use `vDSP.DiscreteFourierTransform`.")
  @available(watchOS, deprecated, introduced: 6.0, message: "Use `vDSP.DiscreteFourierTransform`.")
  @available(tvOS, deprecated, introduced: 13.0, message: "Use `vDSP.DiscreteFourierTransform`.")
  @available(*, deprecated, message: "Use `vDSP.DiscreteFourierTransform`.")
  public class DFT<T> where T : Accelerate.vDSP_FloatingPointDiscreteFourierTransformable {
    public init?(previous: Accelerate.vDSP.DFT<T>? = nil, count: Swift.Int, direction: Accelerate.vDSP.FourierTransformDirection, transformType: Accelerate.vDSP.DFTTransformType, ofType: T.Type)
    public func transform<U>(inputReal: U, inputImaginary: U) -> (real: [T], imaginary: [T]) where T == U.Element, U : Accelerate.AccelerateBuffer
    public func transform<U, V>(inputReal: U, inputImaginary: U, outputReal: inout V, outputImaginary: inout V) where T == U.Element, U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == V.Element
    @objc deinit
  }
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
@available(macOS, deprecated, introduced: 10.15, message: "Use `vDSP.DiscreteFourierTransform`.")
@available(iOS, deprecated, introduced: 13.0, message: "Use `vDSP.DiscreteFourierTransform`.")
@available(watchOS, deprecated, introduced: 6.0, message: "Use `vDSP.DiscreteFourierTransform`.")
@available(tvOS, deprecated, introduced: 13.0, message: "Use `vDSP.DiscreteFourierTransform`.")
@available(*, deprecated, message: "Use `vDSP.DiscreteFourierTransform`.")
public protocol vDSP_FloatingPointDiscreteFourierTransformable : Swift.BinaryFloatingPoint {
  associatedtype DFTFunctions : Accelerate.vDSP_DFTFunctions where Self == Self.DFTFunctions.Scalar
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
@available(macOS, deprecated, introduced: 10.15, message: "Use `vDSP.DiscreteFourierTransform`.")
@available(iOS, deprecated, introduced: 13.0, message: "Use `vDSP.DiscreteFourierTransform`.")
@available(watchOS, deprecated, introduced: 6.0, message: "Use `vDSP.DiscreteFourierTransform`.")
@available(tvOS, deprecated, introduced: 13.0, message: "Use `vDSP.DiscreteFourierTransform`.")
@available(*, deprecated, message: "Use `vDSP.DiscreteFourierTransform`.")
extension Swift.Float : Accelerate.vDSP_FloatingPointDiscreteFourierTransformable {
  public typealias DFTFunctions = Accelerate.vDSP.VectorizableFloat
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
@available(macOS, deprecated, introduced: 10.15, message: "Use `vDSP.DiscreteFourierTransform`.")
@available(iOS, deprecated, introduced: 13.0, message: "Use `vDSP.DiscreteFourierTransform`.")
@available(watchOS, deprecated, introduced: 6.0, message: "Use `vDSP.DiscreteFourierTransform`.")
@available(tvOS, deprecated, introduced: 13.0, message: "Use `vDSP.DiscreteFourierTransform`.")
@available(*, deprecated, message: "Use `vDSP.DiscreteFourierTransform`.")
extension Swift.Double : Accelerate.vDSP_FloatingPointDiscreteFourierTransformable {
  public typealias DFTFunctions = Accelerate.vDSP.VectorizableDouble
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
@available(macOS, deprecated, introduced: 10.15, message: "Use `vDSP.DiscreteFourierTransform`.")
@available(iOS, deprecated, introduced: 13.0, message: "Use `vDSP.DiscreteFourierTransform`.")
@available(watchOS, deprecated, introduced: 6.0, message: "Use `vDSP.DiscreteFourierTransform`.")
@available(tvOS, deprecated, introduced: 13.0, message: "Use `vDSP.DiscreteFourierTransform`.")
@available(*, deprecated, message: "Use `vDSP.DiscreteFourierTransform`.")
public protocol vDSP_DFTFunctions {
  associatedtype Scalar
  static func makeDFTSetup<T>(previous: Accelerate.vDSP.DFT<T>?, count: Swift.Int, direction: Accelerate.vDSP.FourierTransformDirection, transformType: Accelerate.vDSP.DFTTransformType) -> Swift.OpaquePointer? where T : Accelerate.vDSP_FloatingPointDiscreteFourierTransformable
  static func transform<U, V>(dftSetup: Swift.OpaquePointer, inputReal: U, inputImaginary: U, outputReal: inout V, outputImaginary: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, Self.Scalar == U.Element, U.Element == V.Element
  static func destroySetup(_ setup: Swift.OpaquePointer)
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
@available(macOS, deprecated, introduced: 10.15, message: "Use `vDSP.DiscreteFourierTransform`.")
@available(iOS, deprecated, introduced: 13.0, message: "Use `vDSP.DiscreteFourierTransform`.")
@available(watchOS, deprecated, introduced: 6.0, message: "Use `vDSP.DiscreteFourierTransform`.")
@available(tvOS, deprecated, introduced: 13.0, message: "Use `vDSP.DiscreteFourierTransform`.")
@available(*, deprecated, message: "Use `vDSP.DiscreteFourierTransform`.")
extension Accelerate.vDSP.VectorizableFloat : Accelerate.vDSP_DFTFunctions {
  public static func makeDFTSetup<T>(previous: Accelerate.vDSP.DFT<T>? = nil, count: Swift.Int, direction: Accelerate.vDSP.FourierTransformDirection, transformType: Accelerate.vDSP.DFTTransformType) -> Swift.OpaquePointer? where T : Accelerate.vDSP_FloatingPointDiscreteFourierTransformable
  public static func transform<U, V>(dftSetup: Swift.OpaquePointer, inputReal: U, inputImaginary: U, outputReal: inout V, outputImaginary: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Float, V.Element == Swift.Float
  public static func destroySetup(_ setup: Swift.OpaquePointer)
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
@available(macOS, deprecated, introduced: 10.15, message: "Use `vDSP.DiscreteFourierTransform`.")
@available(iOS, deprecated, introduced: 13.0, message: "Use `vDSP.DiscreteFourierTransform`.")
@available(watchOS, deprecated, introduced: 6.0, message: "Use `vDSP.DiscreteFourierTransform`.")
@available(tvOS, deprecated, introduced: 13.0, message: "Use `vDSP.DiscreteFourierTransform`.")
@available(*, deprecated, message: "Use `vDSP.DiscreteFourierTransform`.")
extension Accelerate.vDSP.VectorizableDouble : Accelerate.vDSP_DFTFunctions {
  public static func makeDFTSetup<T>(previous: Accelerate.vDSP.DFT<T>? = nil, count: Swift.Int, direction: Accelerate.vDSP.FourierTransformDirection, transformType: Accelerate.vDSP.DFTTransformType) -> Swift.OpaquePointer? where T : Accelerate.vDSP_FloatingPointDiscreteFourierTransformable
  public static func transform<U, V>(dftSetup: Swift.OpaquePointer, inputReal: U, inputImaginary: U, outputReal: inout V, outputImaginary: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Double, V.Element == Swift.Double
  public static func destroySetup(_ setup: Swift.OpaquePointer)
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Accelerate.vDSP {
  public enum IntegrationRule {
    case runningSum
    case simpson
    case trapezoidal
    public static func == (a: Accelerate.vDSP.IntegrationRule, b: Accelerate.vDSP.IntegrationRule) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  @inlinable public static func integrate<U>(_ vector: U, using rule: Accelerate.vDSP.IntegrationRule, stepSize: Swift.Float = 1) -> [Swift.Float] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Float {
            
            let result = Array<Float>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                integrate(vector,
                          using: rule,
                          result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  public static func integrate<U, V>(_ vector: U, using rule: Accelerate.vDSP.IntegrationRule, stepSize: Swift.Float = 1, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Float, V.Element == Swift.Float
  @inlinable public static func integrate<U>(_ vector: U, using rule: Accelerate.vDSP.IntegrationRule, stepSize: Swift.Double = 1) -> [Swift.Double] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Double {
            
            let result = Array<Double>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                integrate(vector,
                          using: rule,
                          result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  public static func integrate<U, V>(_ vector: U, using rule: Accelerate.vDSP.IntegrationRule, stepSize: Swift.Double = 1, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Double, V.Element == Swift.Double
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Accelerate.BNNS {
  public enum GradientClipping {
    case none
    case byValue(bounds: Swift.ClosedRange<Swift.Float>)
    case byNorm(threshold: Swift.Float)
    case byGlobalNorm(threshold: Swift.Float, globalNorm: Swift.Float = 0)
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Accelerate.BNNS {
  public struct AdamWOptimizer : Accelerate.BNNSOptimizer {
    public var accumulatorCountMultiplier: Swift.Int {
      get
    }
    public var learningRate: Swift.Float {
      get
      set
    }
    public var beta1: Swift.Float {
      get
      set
    }
    public var beta2: Swift.Float {
      get
      set
    }
    public var timeStep: Swift.Float {
      get
      set
    }
    public var epsilon: Swift.Float {
      get
      set
    }
    public var gradientScale: Swift.Float {
      get
      set
    }
    public var weightDecay: Swift.Float {
      get
      set
    }
    public var gradientClipping: Accelerate.BNNS.GradientClipping {
      get
      set
    }
    public init(learningRate: Swift.Float = 0.001, beta1: Swift.Float = 0.9, beta2: Swift.Float = 0.999, timeStep: Swift.Float = 1, epsilon: Swift.Float = 1e-8, gradientScale: Swift.Float, weightDecay: Swift.Float = 1e-2, gradientClipping: Accelerate.BNNS.GradientClipping, usesAMSGrad: Swift.Bool = false)
    public var bnnsOptimizerFunction: Accelerate.BNNSOptimizerFunction {
      get
    }
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Accelerate.BNNS.AdamOptimizer {
  public init(learningRate: Swift.Float = 0.001, beta1: Swift.Float = 0.9, beta2: Swift.Float = 0.999, timeStep: Swift.Float, epsilon: Swift.Float = 1e-8, gradientScale: Swift.Float, regularizationScale: Swift.Float, gradientClipping: Accelerate.BNNS.GradientClipping, regularizationFunction: Accelerate.BNNSOptimizerRegularizationFunction, usesAMSGrad: Swift.Bool = false)
  public var usesAMSGrad: Swift.Bool {
    get
    set
  }
  public var gradientClipping: Accelerate.BNNS.GradientClipping {
    get
    set
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Accelerate.BNNS.SGDMomentumOptimizer {
  public init(learningRate: Swift.Float, momentum: Swift.Float = 0, gradientScale: Swift.Float, regularizationScale: Swift.Float, gradientClipping: Accelerate.BNNS.GradientClipping, usesNesterovMomentum: Swift.Bool = false, regularizationFunction: Accelerate.BNNSOptimizerRegularizationFunction, sgdMomentumVariant: Accelerate.BNNSOptimizerSGDMomentumVariant)
  public var gradientClipping: Accelerate.BNNS.GradientClipping {
    get
    set
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Accelerate.BNNS.RMSPropOptimizer {
  public init(learningRate: Swift.Float = 1e-2, alpha: Swift.Float = 0.99, epsilon: Swift.Float = 1e-8, centered: Swift.Bool, momentum: Swift.Float = 0, gradientScale: Swift.Float, regularizationScale: Swift.Float, gradientClipping: Accelerate.BNNS.GradientClipping, regularizationFunction: Accelerate.BNNSOptimizerRegularizationFunction)
  public var gradientClipping: Accelerate.BNNS.GradientClipping {
    get
    set
  }
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Accelerate.vDSP {
  @inlinable public static func clip<U>(_ vector: U, to bounds: Swift.ClosedRange<Swift.Float>) -> [Swift.Float] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Float {
            
            let result = Array<Float>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                clip(vector,
                     to: bounds,
                     result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func clip<U, V>(_ vector: U, to bounds: Swift.ClosedRange<Swift.Float>, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Float, V.Element == Swift.Float {
            
            let n = result.count
            precondition(vector.count == n)
            
            withUnsafePointer(to: bounds.lowerBound) { lowerBound in
                withUnsafePointer(to: bounds.upperBound) { upperBound in
                    result.withUnsafeMutableBufferPointer { r in
                        vector.withUnsafeBufferPointer { v in
                            vDSP_vclip(v.baseAddress!, 1,
                                       lowerBound,
                                       upperBound,
                                       r.baseAddress!, 1,
                                       vDSP_Length(n))
                        }
                    }
                }
            }
    }
  @inlinable public static func clip<U>(_ vector: U, to bounds: Swift.ClosedRange<Swift.Double>) -> [Swift.Double] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Double {
            
            let result = Array<Double>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                clip(vector,
                     to: bounds,
                     result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func clip<U, V>(_ vector: U, to bounds: Swift.ClosedRange<Swift.Double>, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Double, V.Element == Swift.Double {
            
            let n = result.count
            precondition(vector.count == n)
            
            withUnsafePointer(to: bounds.lowerBound) { lowerBound in
                withUnsafePointer(to: bounds.upperBound) { upperBound in
                    result.withUnsafeMutableBufferPointer { r in
                        vector.withUnsafeBufferPointer { v in
                            vDSP_vclipD(v.baseAddress!, 1,
                                        lowerBound,
                                        upperBound,
                                        r.baseAddress!, 1,
                                        vDSP_Length(n))
                        }
                    }
                }
            }
    }
  @inlinable public static func invertedClip<U>(_ vector: U, to bounds: Swift.ClosedRange<Swift.Float>) -> [Swift.Float] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Float {
            
            let result = Array<Float>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                invertedClip(vector,
                             to: bounds,
                             result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func invertedClip<U, V>(_ vector: U, to bounds: Swift.ClosedRange<Swift.Float>, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Float, V.Element == Swift.Float {
            
            let n = result.count
            precondition(vector.count == n)
            
            withUnsafePointer(to: bounds.lowerBound) { lowerBound in
                withUnsafePointer(to: bounds.upperBound) { upperBound in
                    result.withUnsafeMutableBufferPointer { r in
                        vector.withUnsafeBufferPointer { v in
                            vDSP_viclip(v.baseAddress!, 1,
                                        lowerBound,
                                        upperBound,
                                        r.baseAddress!, 1,
                                        vDSP_Length(n))
                        }
                    }
                }
            }
    }
  @inlinable public static func invertedClip<U>(_ vector: U, to bounds: Swift.ClosedRange<Swift.Double>) -> [Swift.Double] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Double {
            
            let result = Array<Double>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                invertedClip(vector,
                             to: bounds,
                             result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func invertedClip<U, V>(_ vector: U, to bounds: Swift.ClosedRange<Swift.Double>, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Double, V.Element == Swift.Double {
            
            let n = result.count
            precondition(vector.count == n)
            
            withUnsafePointer(to: bounds.lowerBound) { lowerBound in
                withUnsafePointer(to: bounds.upperBound) { upperBound in
                    result.withUnsafeMutableBufferPointer { r in
                        vector.withUnsafeBufferPointer { v in
                            vDSP_viclipD(v.baseAddress!, 1,
                                         lowerBound,
                                         upperBound,
                                         r.baseAddress!, 1,
                                         vDSP_Length(n))
                        }
                    }
                }
            }
    }
  public enum ThresholdRule<T> where T : Swift.BinaryFloatingPoint {
    case clampToThreshold
    case zeroFill
    case signedConstant(_: T)
  }
  @inlinable public static func threshold<U>(_ vector: U, to lowerBound: Swift.Float, with rule: Accelerate.vDSP.ThresholdRule<Swift.Float>) -> [Swift.Float] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Float {
            
            let result = Array<Float>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                threshold(vector,
                          to: lowerBound,
                          with: rule,
                          result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  public static func threshold<U, V>(_ vector: U, to lowerBound: Swift.Float, with rule: Accelerate.vDSP.ThresholdRule<Swift.Float>, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Float, V.Element == Swift.Float
  @inlinable public static func threshold<U>(_ vector: U, to lowerBound: Swift.Double, with rule: Accelerate.vDSP.ThresholdRule<Swift.Double>) -> [Swift.Double] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Double {
            
            let result = Array<Double>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                threshold(vector,
                          to: lowerBound,
                          with: rule,
                          result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  public static func threshold<U, V>(_ vector: U, to lowerBound: Swift.Double, with rule: Accelerate.vDSP.ThresholdRule<Swift.Double>, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Double, V.Element == Swift.Double
  @inlinable public static func limit<U>(_ vector: U, limit: Swift.Float, withOutputConstant outputConstant: Swift.Float) -> [Swift.Float] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Float {
            
            let result = Array<Float>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                vDSP.limit(vector,
                           limit: limit,
                           withOutputConstant: outputConstant,
                           result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func limit<U, V>(_ vector: U, limit: Swift.Float, withOutputConstant outputConstant: Swift.Float, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Float, V.Element == Swift.Float {
            
            let n = result.count
            precondition(vector.count == n)
            
            withUnsafePointer(to: limit) { limit in
                withUnsafePointer(to: outputConstant) { x in
                    result.withUnsafeMutableBufferPointer { r in
                        vector.withUnsafeBufferPointer { v in
                            vDSP_vlim(v.baseAddress!, 1,
                                      limit,
                                      x,
                                      r.baseAddress!, 1,
                                      vDSP_Length(n))
                        }
                    }
                }
            }
    }
  @inlinable public static func limit<U>(_ vector: U, limit: Swift.Double, withOutputConstant outputConstant: Swift.Double) -> [Swift.Double] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Double {
            
            let result = Array<Double>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                vDSP.limit(vector,
                           limit: limit,
                           withOutputConstant: outputConstant,
                           result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func limit<U, V>(_ vector: U, limit: Swift.Double, withOutputConstant outputConstant: Swift.Double, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Double, V.Element == Swift.Double {
            
            let n = result.count
            precondition(vector.count == n)
            
            withUnsafePointer(to: limit) { limit in
                withUnsafePointer(to: outputConstant) { x in
                    result.withUnsafeMutableBufferPointer { r in
                        vector.withUnsafeBufferPointer { v in
                            vDSP_vlimD(v.baseAddress!, 1,
                                       limit,
                                       x,
                                       r.baseAddress!, 1,
                                       vDSP_Length(n))
                        }
                    }
                }
            }
    }
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Accelerate.vDSP {
  @inlinable public static func dot<T, U>(_ vectorA: T, _ vectorB: U) -> Swift.Float where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, T.Element == Swift.Float, U.Element == Swift.Float {
        
        precondition(vectorA.count == vectorB.count)
        
        let n = vDSP_Length(vectorA.count)
        var result = Float.nan
        
        vectorA.withUnsafeBufferPointer { a in
            vectorB.withUnsafeBufferPointer { b in
                
                vDSP_dotpr(a.baseAddress!, 1,
                           b.baseAddress!, 1,
                           &result, n)
                
            }
        }
        
        return result
    }
  @inlinable public static func dot<T, U>(_ vectorA: T, _ vectorB: U) -> Swift.Double where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, T.Element == Swift.Double, U.Element == Swift.Double {
        
        precondition(vectorA.count == vectorB.count)
        
        let n = vDSP_Length(vectorA.count)
        var result = Double.nan
        
        vectorA.withUnsafeBufferPointer { a in
            vectorB.withUnsafeBufferPointer { b in
                
                vDSP_dotprD(a.baseAddress!, 1,
                            b.baseAddress!, 1,
                            &result, n)
                
            }
        }
        
        return result
    }
  @inlinable public static func hypot<U, V>(_ x: U, _ y: V) -> [Swift.Float] where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateBuffer, U.Element == Swift.Float, V.Element == Swift.Float {
            
            precondition(x.count == y.count)
            
            let result = Array<Float>(unsafeUninitializedCapacity: x.count) {
                buffer, initializedCount in
                
                hypot(x, y,
                     result: &buffer)
                
                initializedCount = x.count
            }
            
            return result
    }
  @inlinable public static func hypot<T, U, V>(_ x: T, _ y: U, result: inout V) where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, T.Element == Swift.Float, U.Element == Swift.Float, V.Element == Swift.Float {
            
            precondition(x.count == y.count && y.count == result.count)
            let n = vDSP_Length(result.count)
            
            x.withUnsafeBufferPointer { a in
                y.withUnsafeBufferPointer { b in
                    result.withUnsafeMutableBufferPointer { dest in
                        vDSP_vdist(a.baseAddress!, 1,
                                   b.baseAddress!, 1,
                                   dest.baseAddress!, 1,
                                   n)
                    }
                }
            }
    }
  @inlinable public static func hypot<U, V>(_ x: U, _ y: V) -> [Swift.Double] where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateBuffer, U.Element == Swift.Double, V.Element == Swift.Double {
            
            precondition(x.count == y.count)
            
            let result = Array<Double>(unsafeUninitializedCapacity: x.count) {
                buffer, initializedCount in
                
                hypot(x, y,
                      result: &buffer)
                
                initializedCount = x.count
            }
            
            return result
    }
  @inlinable public static func hypot<T, U, V>(_ x: T, _ y: U, result: inout V) where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, T.Element == Swift.Double, U.Element == Swift.Double, V.Element == Swift.Double {
            
            precondition(x.count == y.count && y.count == result.count)
            let n = vDSP_Length(result.count)
            
            x.withUnsafeBufferPointer { a in
                y.withUnsafeBufferPointer { b in
                    result.withUnsafeMutableBufferPointer { dest in
                        vDSP_vdistD(a.baseAddress!, 1,
                                    b.baseAddress!, 1,
                                    dest.baseAddress!, 1,
                                    n)
                    }
                }
            }
    }
  @inlinable public static func hypot<R, S, T, U>(x0: R, x1: S, y0: T, y1: U) -> [Swift.Float] where R : Accelerate.AccelerateBuffer, S : Accelerate.AccelerateBuffer, T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, R.Element == Swift.Float, S.Element == Swift.Float, T.Element == Swift.Float, U.Element == Swift.Float {
            
            precondition(x0.count == x1.count)
            precondition(y0.count == y1.count)
            precondition(x0.count == y0.count)
            
            let result = Array<Float>(unsafeUninitializedCapacity: x0.count) {
                buffer, initializedCount in
                
                hypot(x0: x0, x1: x1,
                      y0: y0, y1: y1,
                      result: &buffer)
                
                initializedCount = x0.count
            }
            
            return result
    }
  @inlinable public static func hypot<R, S, T, U, V>(x0: R, x1: S, y0: T, y1: U, result: inout V) where R : Accelerate.AccelerateBuffer, S : Accelerate.AccelerateBuffer, T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, R.Element == Swift.Float, S.Element == Swift.Float, T.Element == Swift.Float, U.Element == Swift.Float, V.Element == Swift.Float {
            
            precondition(x0.count == x1.count && x0.count == result.count)
            precondition(y0.count == y1.count && y0.count == result.count)
            
            let n = vDSP_Length(result.count)
            
            x0.withUnsafeBufferPointer { a in
                x1.withUnsafeBufferPointer { c in
                    y0.withUnsafeBufferPointer { b in
                        y1.withUnsafeBufferPointer { d in
                            result.withUnsafeMutableBufferPointer { dest in
                                vDSP_vpythg(a.baseAddress!, 1,
                                            b.baseAddress!, 1,
                                            c.baseAddress!, 1,
                                            d.baseAddress!, 1,
                                            dest.baseAddress!, 1,
                                            n)
                            }
                        }
                    }
                }
            }
    }
  @inlinable public static func hypot<R, S, T, U>(x0: R, x1: S, y0: T, y1: U) -> [Swift.Double] where R : Accelerate.AccelerateBuffer, S : Accelerate.AccelerateBuffer, T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, R.Element == Swift.Double, S.Element == Swift.Double, T.Element == Swift.Double, U.Element == Swift.Double {
            
            precondition(x0.count == x1.count)
            precondition(y0.count == y1.count)
            precondition(x0.count == y0.count)
            
            let result = Array<Double>(unsafeUninitializedCapacity: x0.count) {
                buffer, initializedCount in
                
                hypot(x0: x0, x1: x1,
                      y0: y0, y1: y1,
                      result: &buffer)
                
                initializedCount = x0.count
            }
            
            return result
    }
  @inlinable public static func hypot<R, S, T, U, V>(x0: R, x1: S, y0: T, y1: U, result: inout V) where R : Accelerate.AccelerateBuffer, S : Accelerate.AccelerateBuffer, T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, R.Element == Swift.Double, S.Element == Swift.Double, T.Element == Swift.Double, U.Element == Swift.Double, V.Element == Swift.Double {
            
            precondition(x0.count == x1.count && x0.count == result.count)
            precondition(y0.count == y1.count && y0.count == result.count)
            
            let n = vDSP_Length(result.count)
            
            x0.withUnsafeBufferPointer { a in
                x1.withUnsafeBufferPointer { c in
                    y0.withUnsafeBufferPointer { b in
                        y1.withUnsafeBufferPointer { d in
                            result.withUnsafeMutableBufferPointer { dest in
                                vDSP_vpythgD(a.baseAddress!, 1,
                                             b.baseAddress!, 1,
                                             c.baseAddress!, 1,
                                             d.baseAddress!, 1,
                                             dest.baseAddress!, 1,
                                             n)
                            }
                        }
                    }
                }
            }
    }
  @inlinable public static func distanceSquared<U, V>(_ pointA: U, _ pointB: V) -> Swift.Float where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Float, V.Element == Swift.Float {
            
            precondition(pointA.count == pointB.count)
            
            let n = vDSP_Length(pointA.count)
            var result = Float.nan
            
            pointA.withUnsafeBufferPointer { a in
                pointB.withUnsafeBufferPointer { b in
                    vDSP_distancesq(a.baseAddress!, 1,
                                    b.baseAddress!, 1,
                                    &result,
                                    n)
                }
            }
            
            return result
    }
  @inlinable public static func distanceSquared<U, V>(_ pointA: U, _ pointB: V) -> Swift.Double where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Double, V.Element == Swift.Double {
            
            precondition(pointA.count == pointB.count)
            
            let n = vDSP_Length(pointA.count)
            var result = Double.nan
            
            pointA.withUnsafeBufferPointer { a in
                pointB.withUnsafeBufferPointer { b in
                    vDSP_distancesqD(a.baseAddress!, 1,
                                     b.baseAddress!, 1,
                                     &result,
                                     n)
                }
            }
            
            return result
    }
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Accelerate.vDSP {
  @inlinable public static func add<U>(_ scalar: Swift.Float, _ vector: U) -> [Swift.Float] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Float {
            
            let result = Array<Float>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                add(scalar,
                    vector,
                    result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func add<U, V>(_ scalar: Swift.Float, _ vector: U, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Float, V.Element == Swift.Float {
            
            let n = result.count
            precondition(vector.count == n)
            result.withUnsafeMutableBufferPointer { r in
                vector.withUnsafeBufferPointer { v in
                    withUnsafePointer(to: scalar) { s in
                        vDSP_vsadd(v.baseAddress!, 1,
                                   s,
                                   r.baseAddress!, 1,
                                   vDSP_Length(n))
                    }
                }
            }
    }
  @inlinable public static func add<U>(_ scalar: Swift.Double, _ vector: U) -> [Swift.Double] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Double {
            
            let result = Array<Double>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                add(scalar,
                    vector,
                    result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func add<U, V>(_ scalar: Swift.Double, _ vector: U, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Double, V.Element == Swift.Double {
            
            let n = result.count
            precondition(vector.count == n)
            result.withUnsafeMutableBufferPointer { r in
                vector.withUnsafeBufferPointer { v in
                    withUnsafePointer(to: scalar) { s in
                        vDSP_vsaddD(v.baseAddress!, 1,
                                    s,
                                    r.baseAddress!, 1,
                                    vDSP_Length(n))
                    }
                }
            }
    }
  @inlinable public static func add<T, U>(_ vectorA: T, _ vectorB: U) -> [Swift.Float] where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, T.Element == Swift.Float, U.Element == Swift.Float {
            
            let result = Array<Float>(unsafeUninitializedCapacity: vectorA.count) {
                buffer, initializedCount in
                
                add(vectorA,
                    vectorB,
                    result: &buffer)
                
                initializedCount = vectorA.count
            }
            
            return result
    }
  @inlinable public static func add<T, U, V>(_ vectorA: T, _ vectorB: U, result: inout V) where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, T.Element == Swift.Float, U.Element == Swift.Float, V.Element == Swift.Float {
            
            let n = result.count
            precondition(vectorA.count == n && vectorB.count == n)
            
            result.withUnsafeMutableBufferPointer { r in
                vectorA.withUnsafeBufferPointer { a in
                    vectorB.withUnsafeBufferPointer { b in
                        vDSP_vadd(a.baseAddress!, 1,
                                  b.baseAddress!, 1,
                                  r.baseAddress!, 1,
                                  vDSP_Length(n))
                    }
                }
            }
    }
  @inlinable public static func add<T, U>(_ vectorA: T, _ vectorB: U) -> [Swift.Double] where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, T.Element == Swift.Double, U.Element == Swift.Double {
            
            let result = Array<Double>(unsafeUninitializedCapacity: vectorA.count) {
                buffer, initializedCount in
                
                add(vectorA,
                    vectorB,
                    result: &buffer)
                
                initializedCount = vectorA.count
            }
            
            return result
    }
  @inlinable public static func add<T, U, V>(_ vectorA: T, _ vectorB: U, result: inout V) where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, T.Element == Swift.Double, U.Element == Swift.Double, V.Element == Swift.Double {
            
            let n = result.count
            precondition(vectorA.count == n && vectorB.count == n)
            
            result.withUnsafeMutableBufferPointer { r in
                vectorA.withUnsafeBufferPointer { a in
                    vectorB.withUnsafeBufferPointer { b in
                        vDSP_vaddD(a.baseAddress!, 1,
                                   b.baseAddress!, 1,
                                   r.baseAddress!, 1,
                                   vDSP_Length(n))
                    }
                }
            }
    }
  @inlinable public static func subtract<T, U>(_ vectorA: U, _ vectorB: T) -> [Swift.Float] where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, T.Element == Swift.Float, U.Element == Swift.Float {
            
            let result = Array<Float>(unsafeUninitializedCapacity: vectorA.count) {
                buffer, initializedCount in
                
                subtract(vectorA,
                         vectorB,
                         result: &buffer)
                
                initializedCount = vectorA.count
            }
            
            return result
    }
  @inlinable public static func subtract<T, U, V>(_ vectorA: U, _ vectorB: T, result: inout V) where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, T.Element == Swift.Float, U.Element == Swift.Float, V.Element == Swift.Float {
            
            let n = result.count
            precondition(vectorA.count == n && vectorB.count == n)
            
            result.withUnsafeMutableBufferPointer { r in
                vectorB.withUnsafeBufferPointer { b in
                    vectorA.withUnsafeBufferPointer { a in
                        vDSP_vsub(b.baseAddress!, 1,
                                  a.baseAddress!, 1,
                                  r.baseAddress!, 1,
                                  vDSP_Length(n))
                    }
                }
            }
    }
  @inlinable public static func subtract<T, U>(_ vectorA: U, _ vectorB: T) -> [Swift.Double] where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, T.Element == Swift.Double, U.Element == Swift.Double {
            
            let result = Array<Double>(unsafeUninitializedCapacity: vectorA.count) {
                buffer, initializedCount in
                
                subtract(vectorA,
                         vectorB,
                         result: &buffer)
                
                initializedCount = vectorA.count
            }
            
            return result
    }
  @inlinable public static func subtract<T, U, V>(_ vectorA: U, _ vectorB: T, result: inout V) where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, T.Element == Swift.Double, U.Element == Swift.Double, V.Element == Swift.Double {
            
            let n = result.count
            precondition(vectorA.count == n && vectorB.count == n)
            
            result.withUnsafeMutableBufferPointer { r in
                vectorB.withUnsafeBufferPointer { b in
                    vectorA.withUnsafeBufferPointer { a in
                        vDSP_vsubD(b.baseAddress!, 1,
                                   a.baseAddress!, 1,
                                   r.baseAddress!, 1,
                                   vDSP_Length(n))
                    }
                }
            }
    }
  @inlinable public static func multiply<U>(_ scalar: Swift.Float, _ vector: U) -> [Swift.Float] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Float {
            
            let result = Array<Float>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                multiply(scalar,
                         vector,
                         result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func multiply<U, V>(_ scalar: Swift.Float, _ vector: U, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Float, V.Element == Swift.Float {
            
            let n = result.count
            precondition(vector.count == n)
            result.withUnsafeMutableBufferPointer { r in
                vector.withUnsafeBufferPointer { v in
                    withUnsafePointer(to: scalar) { s in
                        vDSP_vsmul(v.baseAddress!, 1,
                                   s,
                                   r.baseAddress!, 1,
                                   vDSP_Length(n))
                    }
                }
            }
    }
  @inlinable public static func multiply<U>(_ scalar: Swift.Double, _ vector: U) -> [Swift.Double] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Double {
            
            let result = Array<Double>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                multiply(scalar,
                         vector,
                         result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func multiply<U, V>(_ scalar: Swift.Double, _ vector: U, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Double, V.Element == Swift.Double {
            
            let n = result.count
            precondition(vector.count == n)
            result.withUnsafeMutableBufferPointer { r in
                vector.withUnsafeBufferPointer { v in
                    withUnsafePointer(to: scalar) { s in
                        vDSP_vsmulD(v.baseAddress!, 1,
                                    s,
                                    r.baseAddress!, 1,
                                    vDSP_Length(n))
                    }
                }
            }
    }
  @inlinable public static func multiply<T, U>(_ vectorA: T, _ vectorB: U) -> [Swift.Float] where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, T.Element == Swift.Float, U.Element == Swift.Float {
            
            let result = Array<Float>(unsafeUninitializedCapacity: vectorA.count) {
                buffer, initializedCount in
                
                multiply(vectorA,
                         vectorB,
                         result: &buffer)
                
                initializedCount = vectorA.count
            }
            
            return result
    }
  @inlinable public static func multiply<T, U, V>(_ vectorA: T, _ vectorB: U, result: inout V) where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, T.Element == Swift.Float, U.Element == Swift.Float, V.Element == Swift.Float {
            
            let n = result.count
            precondition(vectorA.count == n && vectorB.count == n)
            result.withUnsafeMutableBufferPointer { r in
                vectorA.withUnsafeBufferPointer { a in
                    vectorB.withUnsafeBufferPointer { b in
                        vDSP_vmul(a.baseAddress!, 1,
                                  b.baseAddress!, 1,
                                  r.baseAddress!, 1,
                                  vDSP_Length(n))
                    }
                }
            }
    }
  @inlinable public static func multiply<T, U>(_ vectorA: T, _ vectorB: U) -> [Swift.Double] where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, T.Element == Swift.Double, U.Element == Swift.Double {
            
            let result = Array<Double>(unsafeUninitializedCapacity: vectorA.count) {
                buffer, initializedCount in
                
                multiply(vectorA,
                         vectorB,
                         result: &buffer)
                
                initializedCount = vectorA.count
            }
            
            return result
    }
  @inlinable public static func multiply<T, U, V>(_ vectorA: T, _ vectorB: U, result: inout V) where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, T.Element == Swift.Double, U.Element == Swift.Double, V.Element == Swift.Double {
            
            let n = result.count
            precondition(vectorA.count == n && vectorB.count == n)
            result.withUnsafeMutableBufferPointer { r in
                vectorA.withUnsafeBufferPointer { a in
                    vectorB.withUnsafeBufferPointer { b in
                        vDSP_vmulD(a.baseAddress!, 1,
                                   b.baseAddress!, 1,
                                   r.baseAddress!, 1,
                                   vDSP_Length(n))
                    }
                }
            }
    }
  @inlinable public static func divide<U>(_ vector: U, _ scalar: Swift.Float) -> [Swift.Float] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Float {
            
            let result = Array<Float>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                divide(vector,
                       scalar,
                       result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func divide<U, V>(_ vector: U, _ scalar: Swift.Float, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Float, V.Element == Swift.Float {
            
            let n = result.count
            precondition(vector.count == n)
            result.withUnsafeMutableBufferPointer { r in
                vector.withUnsafeBufferPointer { v in
                    withUnsafePointer(to: scalar) { s in
                        vDSP_vsdiv(v.baseAddress!, 1,
                                   [scalar],
                                   r.baseAddress!, 1,
                                   vDSP_Length(n))
                    }
                }
            }
    }
  @inlinable public static func divide<U>(_ vector: U, _ scalar: Swift.Double) -> [Swift.Double] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Double {
            
            let result = Array<Double>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                divide(vector,
                       scalar,
                       result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func divide<U, V>(_ vector: U, _ scalar: Swift.Double, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Double, V.Element == Swift.Double {
            
            let n = result.count
            precondition(vector.count == n)
            result.withUnsafeMutableBufferPointer { r in
                vector.withUnsafeBufferPointer { v in
                    withUnsafePointer(to: scalar) { s in
                        vDSP_vsdivD(v.baseAddress!, 1,
                                    s,
                                    r.baseAddress!, 1,
                                    vDSP_Length(n))
                    }
                }
            }
    }
  @inlinable public static func divide<U>(_ scalar: Swift.Float, _ vector: U) -> [Swift.Float] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Float {
            
            let result = Array<Float>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                divide(scalar,
                       vector,
                       result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func divide<U, V>(_ scalar: Swift.Float, _ vector: U, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Float, V.Element == Swift.Float {
            
            let n = result.count
            precondition(vector.count == n)
            result.withUnsafeMutableBufferPointer { r in
                vector.withUnsafeBufferPointer { v in
                    withUnsafePointer(to: scalar) { s in
                        vDSP_svdiv(s,
                                   v.baseAddress!, 1,
                                   r.baseAddress!, 1,
                                   vDSP_Length(n))
                    }
                }
            }
    }
  @inlinable public static func divide<U>(_ scalar: Swift.Double, _ vector: U) -> [Swift.Double] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Double {
            
            let result = Array<Double>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                divide(scalar,
                       vector,
                       result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func divide<U, V>(_ scalar: Swift.Double, _ vector: U, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Double, V.Element == Swift.Double {
            
            let n = result.count
            precondition(vector.count == n)
            result.withUnsafeMutableBufferPointer { r in
                vector.withUnsafeBufferPointer { v in
                    withUnsafePointer(to: scalar) { s in
                        vDSP_svdivD(s,
                                    v.baseAddress!, 1,
                                    r.baseAddress!, 1,
                                    vDSP_Length(n))
                    }
                }
            }
    }
  @inlinable public static func divide<T, U>(_ vectorA: T, _ vectorB: U) -> [Swift.Float] where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, T.Element == Swift.Float, U.Element == Swift.Float {
            
            let result = Array<Float>(unsafeUninitializedCapacity: vectorA.count) {
                buffer, initializedCount in
                
                divide(vectorA,
                       vectorB,
                       result: &buffer)
                
                initializedCount = vectorA.count
            }
            
            return result
    }
  @inlinable public static func divide<T, U, V>(_ vectorA: T, _ vectorB: U, result: inout V) where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, T.Element == Swift.Float, U.Element == Swift.Float, V.Element == Swift.Float {
            
            let n = result.count
            precondition(vectorA.count == n && vectorB.count == n)
            result.withUnsafeMutableBufferPointer { r in
                vectorA.withUnsafeBufferPointer { a in
                    vectorB.withUnsafeBufferPointer { b in
                        vDSP_vdiv(b.baseAddress!, 1,
                                  a.baseAddress!, 1,
                                  r.baseAddress!, 1,
                                  vDSP_Length(n))
                    }
                }
            }
    }
  @inlinable public static func divide<T, U>(_ vectorA: T, _ vectorB: U) -> [Swift.Double] where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, T.Element == Swift.Double, U.Element == Swift.Double {
            
            let result = Array<Double>(unsafeUninitializedCapacity: vectorA.count) {
                buffer, initializedCount in
                
                divide(vectorA,
                       vectorB,
                       result: &buffer)
                
                initializedCount = vectorA.count
            }
            
            return result
    }
  @inlinable public static func divide<T, U, V>(_ vectorA: T, _ vectorB: U, result: inout V) where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, T.Element == Swift.Double, U.Element == Swift.Double, V.Element == Swift.Double {
            
            let n = result.count
            precondition(vectorA.count == n && vectorB.count == n)
            result.withUnsafeMutableBufferPointer { r in
                vectorA.withUnsafeBufferPointer { a in
                    vectorB.withUnsafeBufferPointer { b in
                        vDSP_vdivD(b.baseAddress!, 1,
                                   a.baseAddress!, 1,
                                   r.baseAddress!, 1,
                                   vDSP_Length(n))
                    }
                }
            }
    }
  @inlinable public static func addSubtract<S, T, U, V>(_ vectorA: S, _ vectorB: T, addResult: inout U, subtractResult: inout V) where S : Accelerate.AccelerateBuffer, T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateMutableBuffer, V : Accelerate.AccelerateMutableBuffer, S.Element == Swift.Float, T.Element == Swift.Float, U.Element == Swift.Float, V.Element == Swift.Float {
            
            let n = addResult.count
            precondition(vectorA.count == n &&
                vectorB.count == n &&
                subtractResult.count == n)
            
            addResult.withUnsafeMutableBufferPointer { o0 in
                subtractResult.withUnsafeMutableBufferPointer { o1 in
                    vectorA.withUnsafeBufferPointer { i1 in
                        vectorB.withUnsafeBufferPointer { i0 in
                            vDSP_vaddsub(i0.baseAddress!, 1,
                                         i1.baseAddress!, 1,
                                         o0.baseAddress!, 1,
                                         o1.baseAddress!, 1,
                                         vDSP_Length(n))
                        }
                    }
                }
            }
    }
  @inlinable public static func addSubtract<S, T, U, V>(_ vectorA: S, _ vectorB: T, addResult: inout U, subtractResult: inout V) where S : Accelerate.AccelerateBuffer, T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateMutableBuffer, V : Accelerate.AccelerateMutableBuffer, S.Element == Swift.Double, T.Element == Swift.Double, U.Element == Swift.Double, V.Element == Swift.Double {
            
            let n = addResult.count
            precondition(vectorA.count == n &&
                vectorB.count == n &&
                subtractResult.count == n)
            
            addResult.withUnsafeMutableBufferPointer { o0 in
                subtractResult.withUnsafeMutableBufferPointer { o1 in
                    vectorA.withUnsafeBufferPointer { i1 in
                        vectorB.withUnsafeBufferPointer { i0 in
                            vDSP_vaddsubD(i0.baseAddress!, 1,
                                          i1.baseAddress!, 1,
                                          o0.baseAddress!, 1,
                                          o1.baseAddress!, 1,
                                          vDSP_Length(n))
                        }
                    }
                }
            }
    }
  @inlinable public static func multiply<T, U>(addition: (a: T, b: U), _ scalar: Swift.Float) -> [Swift.Float] where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, T.Element == Swift.Float, U.Element == Swift.Float {
            
            let result = Array<Float>(unsafeUninitializedCapacity: addition.a.count) {
                buffer, initializedCount in
                
                multiply(addition: addition,
                         scalar,
                         result: &buffer)
                
                initializedCount = addition.a.count
            }
            
            return result
    }
  @inlinable public static func multiply<T, U, V>(addition: (a: T, b: U), _ scalar: Swift.Float, result: inout V) where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, T.Element == Swift.Float, U.Element == Swift.Float, V.Element == Swift.Float {
            
            let n = result.count
            precondition(addition.a.count == n &&
                addition.b.count == n)
            
            result.withUnsafeMutableBufferPointer { r in
                addition.a.withUnsafeBufferPointer { a in
                    addition.b.withUnsafeBufferPointer { b in
                        withUnsafePointer(to: scalar) { s in
                            vDSP_vasm(a.baseAddress!, 1,
                                      b.baseAddress!, 1,
                                      s,
                                      r.baseAddress!, 1,
                                      vDSP_Length(n))
                        }
                    }
                }
            }
    }
  @inlinable public static func multiply<T, U>(addition: (a: T, b: U), _ scalar: Swift.Double) -> [Swift.Double] where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, T.Element == Swift.Double, U.Element == Swift.Double {
            
            let result = Array<Double>(unsafeUninitializedCapacity: addition.a.count) {
                buffer, initializedCount in
                
                multiply(addition: addition,
                         scalar,
                         result: &buffer)
                
                initializedCount = addition.a.count
            }
            
            return result
    }
  @inlinable public static func multiply<T, U, V>(addition: (a: T, b: U), _ scalar: Swift.Double, result: inout V) where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, T.Element == Swift.Double, U.Element == Swift.Double, V.Element == Swift.Double {
            
            let n = result.count
            precondition(addition.a.count == n &&
                addition.b.count == n)
            
            result.withUnsafeMutableBufferPointer { r in
                addition.a.withUnsafeBufferPointer { a in
                    addition.b.withUnsafeBufferPointer { b in
                        withUnsafePointer(to: scalar) { s in
                            vDSP_vasmD(a.baseAddress!, 1,
                                       b.baseAddress!, 1,
                                       s,
                                       r.baseAddress!, 1,
                                       vDSP_Length(n))
                        }
                    }
                }
            }
    }
  @inlinable public static func multiply<S, T, U>(addition: (a: S, b: T), _ vector: U) -> [Swift.Float] where S : Accelerate.AccelerateBuffer, T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, S.Element == Swift.Float, T.Element == Swift.Float, U.Element == Swift.Float {
            
            let result = Array<Float>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                multiply(addition: addition,
                         vector,
                         result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func multiply<S, T, U, V>(addition: (a: S, b: T), _ vector: U, result: inout V) where S : Accelerate.AccelerateBuffer, T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, S.Element == Swift.Float, T.Element == Swift.Float, U.Element == Swift.Float, V.Element == Swift.Float {
            
            let n = result.count
            precondition(addition.a.count == n &&
                addition.b.count == n)
            
            result.withUnsafeMutableBufferPointer { r in
                addition.a.withUnsafeBufferPointer { a in
                    addition.b.withUnsafeBufferPointer { b in
                        vector.withUnsafeBufferPointer { c in
                            vDSP_vam(a.baseAddress!, 1,
                                     b.baseAddress!, 1,
                                     c.baseAddress!, 1,
                                     r.baseAddress!, 1,
                                     vDSP_Length(n))
                        }
                    }
                }
            }
    }
  @inlinable public static func multiply<S, T, U>(addition: (a: S, b: T), _ vector: U) -> [Swift.Double] where S : Accelerate.AccelerateBuffer, T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, S.Element == Swift.Double, T.Element == Swift.Double, U.Element == Swift.Double {
            
            let result = Array<Double>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                multiply(addition: addition,
                         vector,
                         result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func multiply<S, T, U, V>(addition: (a: S, b: T), _ vector: U, result: inout V) where S : Accelerate.AccelerateBuffer, T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, S.Element == Swift.Double, T.Element == Swift.Double, U.Element == Swift.Double, V.Element == Swift.Double {
            
            let n = result.count
            precondition(addition.a.count == n &&
                addition.b.count == n)
            
            result.withUnsafeMutableBufferPointer { r in
                addition.a.withUnsafeBufferPointer { a in
                    addition.b.withUnsafeBufferPointer { b in
                        vector.withUnsafeBufferPointer { c in
                            vDSP_vamD(a.baseAddress!, 1,
                                      b.baseAddress!, 1,
                                      c.baseAddress!, 1,
                                      r.baseAddress!, 1,
                                      vDSP_Length(n))
                        }
                    }
                }
            }
    }
  @inlinable public static func multiply<T, U>(subtraction: (a: T, b: U), _ scalar: Swift.Float) -> [Swift.Float] where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, T.Element == Swift.Float, U.Element == Swift.Float {
            
            let result = Array<Float>(unsafeUninitializedCapacity: subtraction.a.count) {
                buffer, initializedCount in
                
                multiply(subtraction: subtraction,
                         scalar,
                         result: &buffer)
                
                initializedCount = subtraction.a.count
            }
            
            return result
    }
  @inlinable public static func multiply<T, U, V>(subtraction: (a: T, b: U), _ scalar: Swift.Float, result: inout V) where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, T.Element == Swift.Float, U.Element == Swift.Float, V.Element == Swift.Float {
            
            let n = result.count
            precondition(subtraction.a.count == n &&
                subtraction.b.count == n)
            
            result.withUnsafeMutableBufferPointer { r in
                subtraction.a.withUnsafeBufferPointer { a in
                    subtraction.b.withUnsafeBufferPointer { b in
                        withUnsafePointer(to: scalar) { s in
                            vDSP_vsbsm(a.baseAddress!, 1,
                                       b.baseAddress!, 1,
                                       s,
                                       r.baseAddress!, 1,
                                       vDSP_Length(n))
                        }
                    }
                }
            }
    }
  @inlinable public static func multiply<T, U>(subtraction: (a: T, b: U), _ scalar: Swift.Double) -> [Swift.Double] where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, T.Element == Swift.Double, U.Element == Swift.Double {
            
            let result = Array<Double>(unsafeUninitializedCapacity: subtraction.a.count) {
                buffer, initializedCount in
                
                multiply(subtraction: subtraction,
                         scalar,
                         result: &buffer)
                
                initializedCount = subtraction.a.count
            }
            
            return result
    }
  @inlinable public static func multiply<T, U, V>(subtraction: (a: T, b: U), _ scalar: Swift.Double, result: inout V) where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, T.Element == Swift.Double, U.Element == Swift.Double, V.Element == Swift.Double {
            
            let n = result.count
            precondition(subtraction.a.count == n &&
                subtraction.b.count == n)
            
            result.withUnsafeMutableBufferPointer { r in
                subtraction.a.withUnsafeBufferPointer { a in
                    subtraction.b.withUnsafeBufferPointer { b in
                        withUnsafePointer(to: scalar) { s in
                            vDSP_vsbsmD(a.baseAddress!, 1,
                                        b.baseAddress!, 1,
                                        s,
                                        r.baseAddress!, 1,
                                        vDSP_Length(n))
                        }
                    }
                }
            }
    }
  @inlinable public static func multiply<S, T, U>(subtraction: (a: S, b: T), _ vector: U) -> [Swift.Float] where S : Accelerate.AccelerateBuffer, T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, S.Element == Swift.Float, T.Element == Swift.Float, U.Element == Swift.Float {
            
            let result = Array<Float>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                multiply(subtraction: subtraction,
                         vector,
                         result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func multiply<S, T, U, V>(subtraction: (a: S, b: T), _ vector: U, result: inout V) where S : Accelerate.AccelerateBuffer, T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, S.Element == Swift.Float, T.Element == Swift.Float, U.Element == Swift.Float, V.Element == Swift.Float {
            
            let n = result.count
            precondition(subtraction.a.count == n &&
                subtraction.b.count == n)
            
            result.withUnsafeMutableBufferPointer { r in
                subtraction.a.withUnsafeBufferPointer { a in
                    subtraction.b.withUnsafeBufferPointer { b in
                        vector.withUnsafeBufferPointer { c in
                            vDSP_vsbm(a.baseAddress!, 1,
                                      b.baseAddress!, 1,
                                      c.baseAddress!, 1,
                                      r.baseAddress!, 1,
                                      vDSP_Length(n))
                        }
                    }
                }
            }
    }
  @inlinable public static func multiply<S, T, U>(subtraction: (a: S, b: T), _ vector: U) -> [Swift.Double] where S : Accelerate.AccelerateBuffer, T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, S.Element == Swift.Double, T.Element == Swift.Double, U.Element == Swift.Double {
            
            let result = Array<Double>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                multiply(subtraction: subtraction,
                         vector,
                         result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func multiply<S, T, U, V>(subtraction: (a: S, b: T), _ vector: U, result: inout V) where S : Accelerate.AccelerateBuffer, T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, S.Element == Swift.Double, T.Element == Swift.Double, U.Element == Swift.Double, V.Element == Swift.Double {
            
            let n = result.count
            precondition(subtraction.a.count == n &&
                subtraction.b.count == n)
            
            result.withUnsafeMutableBufferPointer { r in
                subtraction.a.withUnsafeBufferPointer { a in
                    subtraction.b.withUnsafeBufferPointer { b in
                        vector.withUnsafeBufferPointer { c in
                            vDSP_vsbmD(a.baseAddress!, 1,
                                       b.baseAddress!, 1,
                                       c.baseAddress!, 1,
                                       r.baseAddress!, 1,
                                       vDSP_Length(n))
                        }
                    }
                }
            }
    }
  @inlinable public static func add<T, U>(multiplication: (a: T, b: U), _ scalar: Swift.Float) -> [Swift.Float] where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, T.Element == Swift.Float, U.Element == Swift.Float {
            
            let result = Array<Float>(unsafeUninitializedCapacity: multiplication.a.count) {
                buffer, initializedCount in
                
                add(multiplication: multiplication,
                    scalar,
                    result: &buffer)
                
                initializedCount = multiplication.a.count
            }
            
            return result
    }
  @inlinable public static func add<T, U, V>(multiplication: (a: T, b: U), _ scalar: Swift.Float, result: inout V) where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, T.Element == Swift.Float, U.Element == Swift.Float, V.Element == Swift.Float {
            
            let n = result.count
            precondition(multiplication.a.count == n &&
                multiplication.b.count == n)
            
            result.withUnsafeMutableBufferPointer { r in
                multiplication.a.withUnsafeBufferPointer { a in
                    multiplication.b.withUnsafeBufferPointer { b in
                        withUnsafePointer(to: scalar) { s in
                            vDSP_vmsa(a.baseAddress!, 1,
                                      b.baseAddress!, 1,
                                      s,
                                      r.baseAddress!, 1,
                                      vDSP_Length(n))
                        }
                    }
                }
            }
    }
  @inlinable public static func add<T, U>(multiplication: (a: T, b: U), _ scalar: Swift.Double) -> [Swift.Double] where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, T.Element == Swift.Double, U.Element == Swift.Double {
            
            let result = Array<Double>(unsafeUninitializedCapacity: multiplication.a.count) {
                buffer, initializedCount in
                
                add(multiplication: multiplication,
                    scalar,
                    result: &buffer)
                
                initializedCount = multiplication.a.count
            }
            
            return result
    }
  @inlinable public static func add<T, U, V>(multiplication: (a: T, b: U), _ scalar: Swift.Double, result: inout V) where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, T.Element == Swift.Double, U.Element == Swift.Double, V.Element == Swift.Double {
            
            let n = result.count
            precondition(multiplication.a.count == n &&
                multiplication.b.count == n)
            
            result.withUnsafeMutableBufferPointer { r in
                multiplication.a.withUnsafeBufferPointer { a in
                    multiplication.b.withUnsafeBufferPointer { b in
                        withUnsafePointer(to: scalar) { s in
                            vDSP_vmsaD(a.baseAddress!, 1,
                                       b.baseAddress!, 1,
                                       s,
                                       r.baseAddress!, 1,
                                       vDSP_Length(n))
                        }
                    }
                }
            }
    }
  @inlinable public static func add<T, U>(multiplication: (a: T, b: Swift.Float), _ vector: U) -> [Swift.Float] where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, T.Element == Swift.Float, U.Element == Swift.Float {
            
            let result = Array<Float>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                add(multiplication: multiplication,
                    vector,
                    result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func add<T, U, V>(multiplication: (a: T, b: Swift.Float), _ vector: U, result: inout V) where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, T.Element == Swift.Float, U.Element == Swift.Float, V.Element == Swift.Float {
            
            let n = result.count
            precondition(multiplication.a.count == n)
            
            result.withUnsafeMutableBufferPointer { r in
                multiplication.a.withUnsafeBufferPointer { a in
                    vector.withUnsafeBufferPointer { c in
                        withUnsafePointer(to: multiplication.b) { b in
                            vDSP_vsma(a.baseAddress!, 1,
                                      b,
                                      c.baseAddress!, 1,
                                      r.baseAddress!, 1,
                                      vDSP_Length(n))
                        }
                    }
                }
            }
    }
  @inlinable public static func add<T, U>(multiplication: (a: T, b: Swift.Double), _ vector: U) -> [Swift.Double] where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, T.Element == Swift.Double, U.Element == Swift.Double {
            
            let result = Array<Double>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                add(multiplication: multiplication,
                    vector,
                    result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func add<T, U, V>(multiplication: (a: T, b: Swift.Double), _ vector: U, result: inout V) where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, T.Element == Swift.Double, U.Element == Swift.Double, V.Element == Swift.Double {
            
            let n = result.count
            precondition(multiplication.a.count == n)
            
            result.withUnsafeMutableBufferPointer { r in
                multiplication.a.withUnsafeBufferPointer { a in
                    vector.withUnsafeBufferPointer { c in
                        withUnsafePointer(to: multiplication.b) { b in
                            vDSP_vsmaD(a.baseAddress!, 1,
                                       b,
                                       c.baseAddress!, 1,
                                       r.baseAddress!, 1,
                                       vDSP_Length(n))
                        }
                    }
                }
            }
    }
  @inlinable public static func add<S, T, U>(multiplication: (a: S, b: T), _ vector: U) -> [Swift.Float] where S : Accelerate.AccelerateBuffer, T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, S.Element == Swift.Float, T.Element == Swift.Float, U.Element == Swift.Float {
            
            let result = Array<Float>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                add(multiplication: multiplication,
                    vector,
                    result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func add<S, T, U, V>(multiplication: (a: S, b: T), _ vector: U, result: inout V) where S : Accelerate.AccelerateBuffer, T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, S.Element == Swift.Float, T.Element == Swift.Float, U.Element == Swift.Float, V.Element == Swift.Float {
            
            let n = result.count
            precondition(multiplication.a.count == n &&
                multiplication.b.count == n)
            
            result.withUnsafeMutableBufferPointer { r in
                multiplication.a.withUnsafeBufferPointer { a in
                    multiplication.b.withUnsafeBufferPointer { b in
                        vector.withUnsafeBufferPointer { c in
                            vDSP_vma(a.baseAddress!, 1,
                                     b.baseAddress!, 1,
                                     c.baseAddress!, 1,
                                     r.baseAddress!, 1,
                                     vDSP_Length(n))
                        }
                    }
                }
            }
    }
  @inlinable public static func add<S, T, U>(multiplication: (a: S, b: T), _ vector: U) -> [Swift.Double] where S : Accelerate.AccelerateBuffer, T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, S.Element == Swift.Double, T.Element == Swift.Double, U.Element == Swift.Double {
            
            let result = Array<Double>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                add(multiplication: multiplication,
                    vector,
                    result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func add<S, T, U, V>(multiplication: (a: S, b: T), _ vector: U, result: inout V) where S : Accelerate.AccelerateBuffer, T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, S.Element == Swift.Double, T.Element == Swift.Double, U.Element == Swift.Double, V.Element == Swift.Double {
            
            let n = result.count
            precondition(multiplication.a.count == n &&
                multiplication.b.count == n)
            
            result.withUnsafeMutableBufferPointer { r in
                multiplication.a.withUnsafeBufferPointer { a in
                    multiplication.b.withUnsafeBufferPointer { b in
                        vector.withUnsafeBufferPointer { c in
                            vDSP_vmaD(a.baseAddress!, 1,
                                      b.baseAddress!, 1,
                                      c.baseAddress!, 1,
                                      r.baseAddress!, 1,
                                      vDSP_Length(n))
                        }
                    }
                }
            }
    }
  @inlinable public static func subtract<S, T, U>(multiplication: (a: T, b: U), _ vector: S) -> [Swift.Float] where S : Accelerate.AccelerateBuffer, T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, S.Element == Swift.Float, T.Element == Swift.Float, U.Element == Swift.Float {
            
            let result = Array<Float>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                subtract(multiplication: multiplication,
                         vector,
                         result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func subtract<S, T, U, V>(multiplication: (a: T, b: U), _ vector: S, result: inout V) where S : Accelerate.AccelerateBuffer, T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, S.Element == Swift.Float, T.Element == Swift.Float, U.Element == Swift.Float, V.Element == Swift.Float {
            
            let n = result.count
            precondition(multiplication.a.count == n &&
                multiplication.b.count == n)
            
            result.withUnsafeMutableBufferPointer { r in
                multiplication.a.withUnsafeBufferPointer { a in
                    multiplication.b.withUnsafeBufferPointer { b in
                        vector.withUnsafeBufferPointer { c in
                            vDSP_vmsb(a.baseAddress!, 1,
                                      b.baseAddress!, 1,
                                      c.baseAddress!, 1,
                                      r.baseAddress!, 1,
                                      vDSP_Length(n))
                        }
                    }
                }
            }
    }
  @inlinable public static func subtract<S, T, U>(multiplication: (a: T, b: U), _ vector: S) -> [Swift.Double] where S : Accelerate.AccelerateBuffer, T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, S.Element == Swift.Double, T.Element == Swift.Double, U.Element == Swift.Double {
            
            let result = Array<Double>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                subtract(multiplication: multiplication,
                         vector,
                         result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func subtract<S, T, U, V>(multiplication: (a: T, b: U), _ vector: S, result: inout V) where S : Accelerate.AccelerateBuffer, T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, S.Element == Swift.Double, T.Element == Swift.Double, U.Element == Swift.Double, V.Element == Swift.Double {
            
            let n = result.count
            precondition(multiplication.a.count == n &&
                multiplication.b.count == n)
            
            result.withUnsafeMutableBufferPointer { r in
                multiplication.a.withUnsafeBufferPointer { a in
                    multiplication.b.withUnsafeBufferPointer { b in
                        vector.withUnsafeBufferPointer { c in
                            vDSP_vmsbD(a.baseAddress!, 1,
                                       b.baseAddress!, 1,
                                       c.baseAddress!, 1,
                                       r.baseAddress!, 1,
                                       vDSP_Length(n))
                        }
                    }
                }
            }
    }
  @inlinable public static func add<T, U>(multiplication multiplicationAB: (a: T, b: Swift.Float), multiplication multiplicationCD: (c: U, d: Swift.Float)) -> [Swift.Float] where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, T.Element == Swift.Float, U.Element == Swift.Float {
            
            let result = Array<Float>(unsafeUninitializedCapacity: multiplicationAB.a.count) {
                buffer, initializedCount in
                
                add(multiplication: multiplicationAB,
                    multiplication: multiplicationCD,
                    result: &buffer)
                
                initializedCount = multiplicationAB.a.count
            }
            
            return result
    }
  @inlinable public static func add<T, U, V>(multiplication multiplicationAB: (a: T, b: Swift.Float), multiplication multiplicationCD: (c: U, d: Swift.Float), result: inout V) where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, T.Element == Swift.Float, U.Element == Swift.Float, V.Element == Swift.Float {
            
            let n = result.count
            precondition(multiplicationAB.a.count == n &&
                multiplicationCD.c.count == n)
            
            result.withUnsafeMutableBufferPointer { r in
                multiplicationAB.a.withUnsafeBufferPointer { a in
                    multiplicationCD.c.withUnsafeBufferPointer { c in
                        withUnsafePointer(to: multiplicationAB.b) { b in
                            withUnsafePointer(to: multiplicationCD.d) { d in
                                vDSP_vsmsma(a.baseAddress!, 1,
                                            b,
                                            c.baseAddress!, 1,
                                            d,
                                            r.baseAddress!, 1,
                                            vDSP_Length(n))
                            }
                        }
                    }
                }
            }
    }
  @inlinable public static func add<T, U>(multiplication multiplicationAB: (a: T, b: Swift.Double), multiplication multiplicationCD: (c: U, d: Swift.Double)) -> [Swift.Double] where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, T.Element == Swift.Double, U.Element == Swift.Double {
            
            let result = Array<Double>(unsafeUninitializedCapacity: multiplicationAB.a.count) {
                buffer, initializedCount in
                
                add(multiplication: multiplicationAB,
                    multiplication: multiplicationCD,
                    result: &buffer)
                
                initializedCount = multiplicationAB.a.count
            }
            
            return result
    }
  @inlinable public static func add<T, U, V>(multiplication multiplicationAB: (a: T, b: Swift.Double), multiplication multiplicationCD: (c: U, d: Swift.Double), result: inout V) where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, T.Element == Swift.Double, U.Element == Swift.Double, V.Element == Swift.Double {
            
            let n = result.count
            precondition(multiplicationAB.a.count == n &&
                multiplicationCD.c.count == n)
            
            result.withUnsafeMutableBufferPointer { r in
                multiplicationAB.a.withUnsafeBufferPointer { a in
                    multiplicationCD.c.withUnsafeBufferPointer { c in
                        withUnsafePointer(to: multiplicationAB.b) { b in
                            withUnsafePointer(to: multiplicationCD.d) { d in
                                vDSP_vsmsmaD(a.baseAddress!, 1,
                                             b,
                                             c.baseAddress!, 1,
                                             d,
                                             r.baseAddress!, 1,
                                             vDSP_Length(n))
                            }
                        }
                    }
                }
            }
    }
  @inlinable public static func add<R, S, T, U>(multiplication multiplicationAB: (a: R, b: S), multiplication multiplicationCD: (c: T, d: U)) -> [Swift.Float] where R : Accelerate.AccelerateBuffer, S : Accelerate.AccelerateBuffer, T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, R.Element == Swift.Float, S.Element == Swift.Float, T.Element == Swift.Float, U.Element == Swift.Float {
            
            let result = Array<Float>(unsafeUninitializedCapacity: multiplicationAB.a.count) {
                buffer, initializedCount in
                
                add(multiplication: multiplicationAB,
                    multiplication: multiplicationCD,
                    result: &buffer)
                
                initializedCount = multiplicationAB.a.count
            }
            
            return result
    }
  @inlinable public static func add<R, S, T, U, V>(multiplication multiplicationAB: (a: R, b: S), multiplication multiplicationCD: (c: T, d: U), result: inout V) where R : Accelerate.AccelerateBuffer, S : Accelerate.AccelerateBuffer, T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, R.Element == Swift.Float, S.Element == Swift.Float, T.Element == Swift.Float, U.Element == Swift.Float, V.Element == Swift.Float {
            
            let n = result.count
            precondition(multiplicationAB.a.count == n &&
                multiplicationAB.b.count == n &&
                multiplicationCD.c.count == n &&
                multiplicationCD.d.count == n)
            
            result.withUnsafeMutableBufferPointer { r in
                multiplicationAB.a.withUnsafeBufferPointer { a in
                    multiplicationAB.b.withUnsafeBufferPointer { b in
                        multiplicationCD.c.withUnsafeBufferPointer { c in
                            multiplicationCD.d.withUnsafeBufferPointer { d in
                                vDSP_vmma(a.baseAddress!, 1,
                                          b.baseAddress!, 1,
                                          c.baseAddress!, 1,
                                          d.baseAddress!, 1,
                                          r.baseAddress!, 1,
                                          vDSP_Length(n))
                            }
                        }
                    }
                }
            }
    }
  @inlinable public static func add<R, S, T, U>(multiplication multiplicationAB: (a: R, b: S), multiplication multiplicationCD: (c: T, d: U)) -> [Swift.Double] where R : Accelerate.AccelerateBuffer, S : Accelerate.AccelerateBuffer, T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, R.Element == Swift.Double, S.Element == Swift.Double, T.Element == Swift.Double, U.Element == Swift.Double {
            
            let result = Array<Double>(unsafeUninitializedCapacity: multiplicationAB.a.count) {
                buffer, initializedCount in
                
                add(multiplication: multiplicationAB,
                    multiplication: multiplicationCD,
                    result: &buffer)
                
                initializedCount = multiplicationAB.a.count
            }
            
            return result
    }
  @inlinable public static func add<R, S, T, U, V>(multiplication multiplicationAB: (a: R, b: S), multiplication multiplicationCD: (c: T, d: U), result: inout V) where R : Accelerate.AccelerateBuffer, S : Accelerate.AccelerateBuffer, T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, R.Element == Swift.Double, S.Element == Swift.Double, T.Element == Swift.Double, U.Element == Swift.Double, V.Element == Swift.Double {
            
            let n = result.count
            precondition(multiplicationAB.a.count == n &&
                multiplicationAB.b.count == n &&
                multiplicationCD.c.count == n &&
                multiplicationCD.d.count == n)
            
            result.withUnsafeMutableBufferPointer { r in
                multiplicationAB.a.withUnsafeBufferPointer { a in
                    multiplicationAB.b.withUnsafeBufferPointer { b in
                        multiplicationCD.c.withUnsafeBufferPointer { c in
                            multiplicationCD.d.withUnsafeBufferPointer { d in
                                vDSP_vmmaD(a.baseAddress!, 1,
                                           b.baseAddress!, 1,
                                           c.baseAddress!, 1,
                                           d.baseAddress!, 1,
                                           r.baseAddress!, 1,
                                           vDSP_Length(n))
                            }
                        }
                    }
                }
            }
    }
  @inlinable public static func multiply<S, T, U>(addition additionAB: (a: S, b: T), addition additionCD: (c: U, d: U)) -> [Swift.Float] where S : Accelerate.AccelerateBuffer, T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, S.Element == Swift.Float, T.Element == Swift.Float, U.Element == Swift.Float {
            
            let result = Array<Float>(unsafeUninitializedCapacity: additionAB.a.count) {
                buffer, initializedCount in
                
                multiply(addition: additionAB,
                         addition: additionCD,
                         result: &buffer)
                
                initializedCount = additionAB.a.count
            }
            
            return result
    }
  @inlinable public static func multiply<S, T, U, V>(addition additionAB: (a: S, b: T), addition additionCD: (c: U, d: U), result: inout V) where S : Accelerate.AccelerateBuffer, T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, S.Element == Swift.Float, T.Element == Swift.Float, U.Element == Swift.Float, V.Element == Swift.Float {
            
            let n = result.count
            precondition(additionAB.a.count == n &&
                additionAB.b.count == n &&
                additionCD.c.count == n &&
                additionCD.d.count == n)
            
            result.withUnsafeMutableBufferPointer { r in
                additionAB.a.withUnsafeBufferPointer { a in
                    additionAB.b.withUnsafeBufferPointer { b in
                        additionCD.c.withUnsafeBufferPointer { c in
                            additionCD.d.withUnsafeBufferPointer { d in
                                vDSP_vaam(a.baseAddress!, 1,
                                          b.baseAddress!, 1,
                                          c.baseAddress!, 1,
                                          d.baseAddress!, 1,
                                          r.baseAddress!, 1,
                                          vDSP_Length(n))
                            }
                        }
                    }
                }
            }
    }
  @inlinable public static func multiply<S, T, U>(addition additionAB: (a: S, b: T), addition additionCD: (c: U, d: U)) -> [Swift.Double] where S : Accelerate.AccelerateBuffer, T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, S.Element == Swift.Double, T.Element == Swift.Double, U.Element == Swift.Double {
            
            let result = Array<Double>(unsafeUninitializedCapacity: additionAB.a.count) {
                buffer, initializedCount in
                
                multiply(addition: additionAB,
                         addition: additionCD,
                         result: &buffer)
                
                initializedCount = additionAB.a.count
            }
            
            return result
    }
  @inlinable public static func multiply<S, T, U, V>(addition additionAB: (a: S, b: T), addition additionCD: (c: U, d: U), result: inout V) where S : Accelerate.AccelerateBuffer, T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, S.Element == Swift.Double, T.Element == Swift.Double, U.Element == Swift.Double, V.Element == Swift.Double {
            
            let n = result.count
            precondition(additionAB.a.count == n &&
                additionAB.b.count == n &&
                additionCD.c.count == n &&
                additionCD.d.count == n)
            
            result.withUnsafeMutableBufferPointer { r in
                additionAB.a.withUnsafeBufferPointer { a in
                    additionAB.b.withUnsafeBufferPointer { b in
                        additionCD.c.withUnsafeBufferPointer { c in
                            additionCD.d.withUnsafeBufferPointer { d in
                                vDSP_vaamD(a.baseAddress!, 1,
                                           b.baseAddress!, 1,
                                           c.baseAddress!, 1,
                                           d.baseAddress!, 1,
                                           r.baseAddress!, 1,
                                           vDSP_Length(n))
                            }
                        }
                    }
                }
            }
    }
  @inlinable public static func subtract<R, S, T, U>(multiplication multiplicationAB: (a: T, b: U), multiplication multiplicationCD: (c: R, d: S)) -> [Swift.Float] where R : Accelerate.AccelerateBuffer, S : Accelerate.AccelerateBuffer, T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, R.Element == Swift.Float, S.Element == Swift.Float, T.Element == Swift.Float, U.Element == Swift.Float {
            
            let result = Array<Float>(unsafeUninitializedCapacity: multiplicationAB.a.count) {
                buffer, initializedCount in
                
                subtract(multiplication: multiplicationAB,
                         multiplication: multiplicationCD,
                         result: &buffer)
                
                initializedCount = multiplicationAB.a.count
            }
            
            return result
    }
  @inlinable public static func subtract<R, S, T, U, V>(multiplication multiplicationAB: (a: T, b: U), multiplication multiplicationCD: (c: R, d: S), result: inout V) where R : Accelerate.AccelerateBuffer, S : Accelerate.AccelerateBuffer, T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, R.Element == Swift.Float, S.Element == Swift.Float, T.Element == Swift.Float, U.Element == Swift.Float, V.Element == Swift.Float {
            
            let n = result.count
            precondition(multiplicationAB.a.count == n &&
                multiplicationAB.b.count == n &&
                multiplicationCD.c.count == n &&
                multiplicationCD.d.count == n)
            
            result.withUnsafeMutableBufferPointer { r in
                multiplicationAB.a.withUnsafeBufferPointer { a in
                    multiplicationAB.b.withUnsafeBufferPointer { b in
                        multiplicationCD.c.withUnsafeBufferPointer { c in
                            multiplicationCD.d.withUnsafeBufferPointer { d in
                                vDSP_vmmsb(a.baseAddress!, 1,
                                           b.baseAddress!, 1,
                                           c.baseAddress!, 1,
                                           d.baseAddress!, 1,
                                           r.baseAddress!, 1,
                                           vDSP_Length(n))
                            }
                        }
                    }
                }
            }
    }
  @inlinable public static func subtract<R, S, T, U>(multiplication multiplicationAB: (a: T, b: U), multiplication multiplicationCD: (c: R, d: S)) -> [Swift.Double] where R : Accelerate.AccelerateBuffer, S : Accelerate.AccelerateBuffer, T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, R.Element == Swift.Double, S.Element == Swift.Double, T.Element == Swift.Double, U.Element == Swift.Double {
            
            let result = Array<Double>(unsafeUninitializedCapacity: multiplicationAB.a.count) {
                buffer, initializedCount in
                
                subtract(multiplication: multiplicationAB,
                         multiplication: multiplicationCD,
                         result: &buffer)
                
                initializedCount = multiplicationAB.a.count
            }
            
            return result
    }
  @inlinable public static func subtract<R, S, T, U, V>(multiplication multiplicationAB: (a: T, b: U), multiplication multiplicationCD: (c: R, d: S), result: inout V) where R : Accelerate.AccelerateBuffer, S : Accelerate.AccelerateBuffer, T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, R.Element == Swift.Double, S.Element == Swift.Double, T.Element == Swift.Double, U.Element == Swift.Double, V.Element == Swift.Double {
            
            let n = result.count
            precondition(multiplicationAB.a.count == n &&
                multiplicationAB.b.count == n &&
                multiplicationCD.c.count == n &&
                multiplicationCD.d.count == n)
            
            result.withUnsafeMutableBufferPointer { r in
                multiplicationAB.a.withUnsafeBufferPointer { a in
                    multiplicationAB.b.withUnsafeBufferPointer { b in
                        multiplicationCD.c.withUnsafeBufferPointer { c in
                            multiplicationCD.d.withUnsafeBufferPointer { d in
                                vDSP_vmmsbD(a.baseAddress!, 1,
                                            b.baseAddress!, 1,
                                            c.baseAddress!, 1,
                                            d.baseAddress!, 1,
                                            r.baseAddress!, 1,
                                            vDSP_Length(n))
                            }
                        }
                    }
                }
            }
    }
  @inlinable public static func multiply<R, S, T, U>(subtraction subtractionAB: (a: R, b: S), subtraction subtractionCD: (c: T, d: U)) -> [Swift.Float] where R : Accelerate.AccelerateBuffer, S : Accelerate.AccelerateBuffer, T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, R.Element == Swift.Float, S.Element == Swift.Float, T.Element == Swift.Float, U.Element == Swift.Float {
            
            let result = Array<Float>(unsafeUninitializedCapacity: subtractionAB.a.count) {
                buffer, initializedCount in
                
                multiply(subtraction: subtractionAB,
                         subtraction: subtractionCD,
                         result: &buffer)
                
                initializedCount = subtractionAB.a.count
            }
            
            return result
    }
  @inlinable public static func multiply<R, S, T, U, V>(subtraction subtractionAB: (a: R, b: S), subtraction subtractionCD: (c: T, d: U), result: inout V) where R : Accelerate.AccelerateBuffer, S : Accelerate.AccelerateBuffer, T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, R.Element == Swift.Float, S.Element == Swift.Float, T.Element == Swift.Float, U.Element == Swift.Float, V.Element == Swift.Float {
            
            let n = result.count
            precondition(subtractionAB.a.count == n &&
                subtractionAB.b.count == n &&
                subtractionCD.c.count == n &&
                subtractionCD.d.count == n)
            
            result.withUnsafeMutableBufferPointer { r in
                subtractionAB.a.withUnsafeBufferPointer { a in
                    subtractionAB.b.withUnsafeBufferPointer { b in
                        subtractionCD.c.withUnsafeBufferPointer { c in
                            subtractionCD.d.withUnsafeBufferPointer { d in
                                vDSP_vsbsbm(a.baseAddress!, 1,
                                            b.baseAddress!, 1,
                                            c.baseAddress!, 1,
                                            d.baseAddress!, 1,
                                            r.baseAddress!, 1,
                                            vDSP_Length(n))
                            }
                        }
                    }
                }
            }
    }
  @inlinable public static func multiply<R, S, T, U>(subtraction subtractionAB: (a: R, b: S), subtraction subtractionCD: (c: T, d: U)) -> [Swift.Double] where R : Accelerate.AccelerateBuffer, S : Accelerate.AccelerateBuffer, T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, R.Element == Swift.Double, S.Element == Swift.Double, T.Element == Swift.Double, U.Element == Swift.Double {
            
            let result = Array<Double>(unsafeUninitializedCapacity: subtractionAB.a.count) {
                buffer, initializedCount in
                
                multiply(subtraction: subtractionAB,
                         subtraction: subtractionCD,
                         result: &buffer)
                
                initializedCount = subtractionAB.a.count
            }
            
            return result
    }
  @inlinable public static func multiply<R, S, T, U, V>(subtraction subtractionAB: (a: R, b: S), subtraction subtractionCD: (c: T, d: U), result: inout V) where R : Accelerate.AccelerateBuffer, S : Accelerate.AccelerateBuffer, T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, R.Element == Swift.Double, S.Element == Swift.Double, T.Element == Swift.Double, U.Element == Swift.Double, V.Element == Swift.Double {
            
            let n = result.count
            precondition(subtractionAB.a.count == n &&
                subtractionAB.b.count == n &&
                subtractionCD.c.count == n &&
                subtractionCD.d.count == n)
            
            result.withUnsafeMutableBufferPointer { r in
                subtractionAB.a.withUnsafeBufferPointer { a in
                    subtractionAB.b.withUnsafeBufferPointer { b in
                        subtractionCD.c.withUnsafeBufferPointer { c in
                            subtractionCD.d.withUnsafeBufferPointer { d in
                                vDSP_vsbsbmD(a.baseAddress!, 1,
                                             b.baseAddress!, 1,
                                             c.baseAddress!, 1,
                                             d.baseAddress!, 1,
                                             r.baseAddress!, 1,
                                             vDSP_Length(n))
                            }
                        }
                    }
                }
            }
    }
  @inlinable public static func multiply<R, S, T, U>(addition: (a: R, b: S), subtraction: (c: T, d: U)) -> [Swift.Float] where R : Accelerate.AccelerateBuffer, S : Accelerate.AccelerateBuffer, T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, R.Element == Swift.Float, S.Element == Swift.Float, T.Element == Swift.Float, U.Element == Swift.Float {
            
            let result = Array<Float>(unsafeUninitializedCapacity: addition.a.count) {
                buffer, initializedCount in
                
                multiply(addition: addition,
                         subtraction: subtraction,
                         result: &buffer)
                
                initializedCount = addition.a.count
            }
            
            return result
    }
  @inlinable public static func multiply<R, S, T, U, V>(addition: (a: R, b: S), subtraction: (c: T, d: U), result: inout V) where R : Accelerate.AccelerateBuffer, S : Accelerate.AccelerateBuffer, T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, R.Element == Swift.Float, S.Element == Swift.Float, T.Element == Swift.Float, U.Element == Swift.Float, V.Element == Swift.Float {
            
            let n = result.count
            precondition(addition.a.count == n &&
                addition.b.count == n &&
                subtraction.c.count == n &&
                subtraction.d.count == n)
            
            result.withUnsafeMutableBufferPointer { r in
                addition.a.withUnsafeBufferPointer { a in
                    addition.b.withUnsafeBufferPointer { b in
                        subtraction.c.withUnsafeBufferPointer { c in
                            subtraction.d.withUnsafeBufferPointer { d in
                                vDSP_vasbm(a.baseAddress!, 1,
                                           b.baseAddress!, 1,
                                           c.baseAddress!, 1,
                                           d.baseAddress!, 1,
                                           r.baseAddress!, 1,
                                           vDSP_Length(n))
                            }
                        }
                    }
                }
            }
    }
  @inlinable public static func multiply<R, S, T, U>(addition: (a: R, b: S), subtraction: (c: T, d: U)) -> [Swift.Double] where R : Accelerate.AccelerateBuffer, S : Accelerate.AccelerateBuffer, T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, R.Element == Swift.Double, S.Element == Swift.Double, T.Element == Swift.Double, U.Element == Swift.Double {
            
            let result = Array<Double>(unsafeUninitializedCapacity: addition.a.count) {
                buffer, initializedCount in
                
                multiply(addition: addition,
                         subtraction: subtraction,
                         result: &buffer)
                
                initializedCount = addition.a.count
            }
            
            return result
    }
  @inlinable public static func multiply<R, S, T, U, V>(addition: (a: R, b: S), subtraction: (c: T, d: U), result: inout V) where R : Accelerate.AccelerateBuffer, S : Accelerate.AccelerateBuffer, T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, R.Element == Swift.Double, S.Element == Swift.Double, T.Element == Swift.Double, U.Element == Swift.Double, V.Element == Swift.Double {
            
            let n = result.count
            precondition(addition.a.count == n &&
                addition.b.count == n &&
                subtraction.c.count == n &&
                subtraction.d.count == n)
            
            result.withUnsafeMutableBufferPointer { r in
                addition.a.withUnsafeBufferPointer { a in
                    addition.b.withUnsafeBufferPointer { b in
                        subtraction.c.withUnsafeBufferPointer { c in
                            subtraction.d.withUnsafeBufferPointer { d in
                                vDSP_vasbmD(a.baseAddress!, 1,
                                            b.baseAddress!, 1,
                                            c.baseAddress!, 1,
                                            d.baseAddress!, 1,
                                            r.baseAddress!, 1,
                                            vDSP_Length(n))
                            }
                        }
                    }
                }
            }
    }
  @inlinable public static func add<U>(multiplication: (a: U, b: Swift.Float), _ scalar: Swift.Float) -> [Swift.Float] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Float {
            
            let result = Array<Float>(unsafeUninitializedCapacity: multiplication.a.count) {
                buffer, initializedCount in
                
                add(multiplication: multiplication,
                    scalar,
                    result: &buffer)
                
                initializedCount =  multiplication.a.count
            }
            
            return result
    }
  @inlinable public static func add<U, V>(multiplication: (a: U, b: Swift.Float), _ scalar: Swift.Float, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Float, V.Element == Swift.Float {
            let n = result.count
            precondition(multiplication.a.count == n)
            
            result.withUnsafeMutableBufferPointer { r in
                multiplication.a.withUnsafeBufferPointer { a in
                    withUnsafePointer(to: multiplication.b) { b in
                        withUnsafePointer(to: scalar) { c in
                            vDSP_vsmsa(a.baseAddress!, 1,
                                       b,
                                       c,
                                       r.baseAddress!, 1,
                                       vDSP_Length(n))
                        }
                    }
                }
            }
    }
  @inlinable public static func add<U>(multiplication: (a: U, b: Swift.Double), _ scalar: Swift.Double) -> [Swift.Double] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Double {
            
            let result = Array<Double>(unsafeUninitializedCapacity: multiplication.a.count) {
                buffer, initializedCount in
                
                add(multiplication: multiplication,
                    scalar,
                    result: &buffer)
                
                initializedCount =  multiplication.a.count
            }
            
            return result
    }
  @inlinable public static func add<U, V>(multiplication: (a: U, b: Swift.Double), _ scalar: Swift.Double, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Double, V.Element == Swift.Double {
            let n = result.count
            precondition(multiplication.a.count == n)
            
            result.withUnsafeMutableBufferPointer { r in
                multiplication.a.withUnsafeBufferPointer { a in
                    withUnsafePointer(to: multiplication.b) { b in
                        withUnsafePointer(to: scalar) { c in
                            vDSP_vsmsaD(a.baseAddress!, 1,
                                        b,
                                        c,
                                        r.baseAddress!, 1,
                                        vDSP_Length(n))
                        }
                    }
                }
            }
    }
  @inlinable public static func subtract<T, U>(multiplication: (a: U, b: Swift.Float), _ vector: T) -> [Swift.Float] where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, T.Element == Swift.Float, U.Element == Swift.Float {
            
            let result = Array<Float>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                subtract(multiplication: multiplication,
                         vector,
                         result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func subtract<T, U, V>(multiplication: (a: U, b: Swift.Float), _ vector: T, result: inout V) where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, T.Element == Swift.Float, U.Element == Swift.Float, V.Element == Swift.Float {
            
            let n = result.count
            precondition(multiplication.a.count == n)
            precondition(vector.count == n)
            
            result.withUnsafeMutableBufferPointer { r in
                multiplication.a.withUnsafeBufferPointer { a in
                    withUnsafePointer(to: multiplication.b) { b in
                        vector.withUnsafeBufferPointer { c in
                            vDSP_vsmsb(a.baseAddress!, 1,
                                       b,
                                       c.baseAddress!, 1,
                                       r.baseAddress!, 1,
                                       vDSP_Length(n))
                        }
                    }
                }
            }
    }
  @inlinable public static func subtract<T, U>(multiplication: (a: U, b: Swift.Double), _ vector: T) -> [Swift.Double] where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, T.Element == Swift.Double, U.Element == Swift.Double {
            
            let result = Array<Double>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                subtract(multiplication: multiplication,
                         vector,
                         result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func subtract<T, U, V>(multiplication: (a: U, b: Swift.Double), _ vector: T, result: inout V) where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, T.Element == Swift.Double, U.Element == Swift.Double, V.Element == Swift.Double {
            
            let n = result.count
            precondition(multiplication.a.count == n)
            precondition(vector.count == n)
            
            result.withUnsafeMutableBufferPointer { r in
                multiplication.a.withUnsafeBufferPointer { a in
                    withUnsafePointer(to: multiplication.b) { b in
                        vector.withUnsafeBufferPointer { c in
                            vDSP_vsmsbD(a.baseAddress!, 1,
                                        b,
                                        c.baseAddress!, 1,
                                        r.baseAddress!, 1,
                                        vDSP_Length(n))
                        }
                    }
                }
            }
    }
}
@available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
extension Accelerate.BNNS {
  public static func applyReduction(_ reductionFunction: Accelerate.BNNS.ReductionFunction, input: Accelerate.BNNSNDArrayDescriptor, output: Accelerate.BNNSNDArrayDescriptor, weights: Accelerate.BNNSNDArrayDescriptor?, filterParameters: Accelerate.BNNSFilterParameters? = nil) throws
}
@available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
extension Accelerate.BNNS {
  @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class ReductionLayer : Accelerate.BNNS.UnaryLayer {
    convenience public init?(function reductionFunction: Accelerate.BNNS.ReductionFunction, input: Accelerate.BNNSNDArrayDescriptor, output: Accelerate.BNNSNDArrayDescriptor, weights: Accelerate.BNNSNDArrayDescriptor?, filterParameters: Accelerate.BNNSFilterParameters? = nil)
    public func applyBackward(batchSize: Swift.Int, input: Accelerate.BNNSNDArrayDescriptor, output: Accelerate.BNNSNDArrayDescriptor, outputGradient: Accelerate.BNNSNDArrayDescriptor, generatingInputGradient inputGradient: Accelerate.BNNSNDArrayDescriptor, generatingWeightsGradient weightsGradient: Accelerate.BNNSNDArrayDescriptor? = nil) throws
    @objc deinit
  }
}
@available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
extension Accelerate.BNNS {
  public enum ReductionFunction {
    case max
    case min
    @available(macOS, deprecated, introduced: 11.0, message: "Use `argMax`.")
    @available(iOS, deprecated, introduced: 14.0, message: "Use `argMax`.")
    @available(watchOS, deprecated, introduced: 7.0, message: "Use `argMax`.")
    @available(tvOS, deprecated, introduced: 14.0, message: "Use `argMax`.")
    @available(*, deprecated, message: "Use `argMax`.")
    case maxIndex
    case argMax
    @available(macOS, deprecated, introduced: 11.0, message: "Use `argMin`.")
    @available(iOS, deprecated, introduced: 14.0, message: "Use `argMin`.")
    @available(watchOS, deprecated, introduced: 7.0, message: "Use `argMin`.")
    @available(tvOS, deprecated, introduced: 14.0, message: "Use `argMin`.")
    @available(*, deprecated, message: "Use `argMin`.")
    case minIndex
    case argMin
    case mean
    case meanNonZero
    case sum
    case sumOfSquares
    case sumOfLogs(epsilon: Swift.Float)
    case sumOfAbsolutes
    case logicalOr
    case any
    case logicalAnd
    case all
    public var bnnsReduceFunction: Accelerate.BNNSReduceFunction {
      get
    }
  }
}
@available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
extension Accelerate.vImage_Buffer {
  public init(size: CoreGraphics.CGSize, bitsPerPixel: Swift.UInt32) throws
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Accelerate.vImage_Buffer {
  public var size: CoreGraphics.CGSize {
    get
  }
  public static func preferredAlignmentAndRowBytes(width: Swift.Int, height: Swift.Int, bitsPerPixel: Swift.UInt32) throws -> (alignment: Swift.Int, rowBytes: Swift.Int)
  public init(width: Swift.Int, height: Swift.Int, bitsPerPixel: Swift.UInt32) throws
  public func free()
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Accelerate.vImage_Buffer {
  public init(cgImage: CoreGraphics.CGImage, flags options: Accelerate.vImage.Options = .noFlags) throws
  public init(cgImage: CoreGraphics.CGImage, format: Accelerate.vImage_CGImageFormat, flags options: Accelerate.vImage.Options = .noFlags) throws
  public func createCGImage(format: Accelerate.vImage_CGImageFormat, flags options: Accelerate.vImage.Options = .noFlags) throws -> CoreGraphics.CGImage
  public func copy(destinationBuffer: inout Accelerate.vImage_Buffer, pixelSize: Swift.Int, flags options: Accelerate.vImage.Options = .noFlags) throws
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Accelerate.BNNS {
  public struct FusedBinaryArithmeticParameters : Accelerate.FusableLayerParameters {
    public var inputADescriptorType: Accelerate.BNNS.DescriptorType
    public var inputBDescriptorType: Accelerate.BNNS.DescriptorType
    public var outputDescriptorType: Accelerate.BNNS.DescriptorType
    public var function: Accelerate.BNNS.ArithmeticBinaryFunction
    public init(inputADescriptorType: Accelerate.BNNS.DescriptorType, inputBDescriptorType: Accelerate.BNNS.DescriptorType, outputDescriptorType: Accelerate.BNNS.DescriptorType, function: Accelerate.BNNS.ArithmeticBinaryFunction)
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Accelerate.BNNS.FusedParametersLayer {
  convenience public init?(inputA: Accelerate.BNNSNDArrayDescriptor, inputB: Accelerate.BNNSNDArrayDescriptor, output: Accelerate.BNNSNDArrayDescriptor, fusedLayerParameters: [Accelerate.FusableLayerParameters], filterParameters: Accelerate.BNNSFilterParameters? = nil)
  public func apply(batchSize: Swift.Int, inputA: Accelerate.BNNSNDArrayDescriptor, inputB: Accelerate.BNNSNDArrayDescriptor, output: Accelerate.BNNSNDArrayDescriptor, for learningPhase: Accelerate.BNNS.LearningPhase) throws
  public func applyBackward(batchSize: Swift.Int, inputA: Accelerate.BNNSNDArrayDescriptor, inputB: Accelerate.BNNSNDArrayDescriptor, output: Accelerate.BNNSNDArrayDescriptor, outputGradient: Accelerate.BNNSNDArrayDescriptor, generatingInputAGradient inputAGradient: Accelerate.BNNSNDArrayDescriptor, generatingInputBGradient inputBGradient: Accelerate.BNNSNDArrayDescriptor, generatingParameterGradients parameterGradients: [Accelerate.BNNSNDArrayDescriptor]) throws
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
public struct Quadrature {
  public init(integrator: Accelerate.Quadrature.Integrator, absoluteTolerance: Swift.Double = 1.0e-8, relativeTolerance: Swift.Double = 1.0e-2)
  public var absoluteTolerance: Swift.Double {
    get
    set
  }
  public var relativeTolerance: Swift.Double {
    get
    set
  }
  public func integrate(over interval: Swift.ClosedRange<Swift.Double>, integrand: (_ input: Swift.UnsafeBufferPointer<Swift.Double>, _ result: Swift.UnsafeMutableBufferPointer<Swift.Double>) -> ()) -> Swift.Result<(integralResult: Swift.Double, estimatedAbsoluteError: Swift.Double), Accelerate.Quadrature.Error>
  public func integrate(over interval: Swift.ClosedRange<Swift.Double>, integrand: (Swift.Double) -> Swift.Double) -> Swift.Result<(integralResult: Swift.Double, estimatedAbsoluteError: Swift.Double), Accelerate.Quadrature.Error>
  public enum Integrator {
    case qng
    public static let nonAdaptive: Accelerate.Quadrature.Integrator
    case qag(pointsPerInterval: Accelerate.Quadrature.QAGPointsPerInterval, maxIntervals: Swift.Int)
    public static func adaptive(pointsPerInterval: Accelerate.Quadrature.QAGPointsPerInterval, maxIntervals: Swift.Int) -> Accelerate.Quadrature.Integrator
    case qags(maxIntervals: Swift.Int)
    public static func adaptiveWithSingularities(maxIntervals: Swift.Int) -> Accelerate.Quadrature.Integrator
  }
  public struct QAGPointsPerInterval {
    public let points: Swift.Int
    public static let fifteen: Accelerate.Quadrature.QAGPointsPerInterval
    public static let twentyOne: Accelerate.Quadrature.QAGPointsPerInterval
    public static let thirtyOne: Accelerate.Quadrature.QAGPointsPerInterval
    public static let fortyOne: Accelerate.Quadrature.QAGPointsPerInterval
    public static let fiftyOne: Accelerate.Quadrature.QAGPointsPerInterval
    public static let sixtyOne: Accelerate.Quadrature.QAGPointsPerInterval
  }
  public enum Error : Swift.Error {
    case generic
    case invalidArgument
    case `internal`
    case integrateMaxEval
    case badIntegrandBehaviour
    public init(quadratureStatus: Accelerate.quadrature_status)
    public var errorDescription: Swift.String {
      get
    }
    public static func == (a: Accelerate.Quadrature.Error, b: Accelerate.Quadrature.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Accelerate.vDSP {
  @inlinable public static func evaluatePolynomial<U>(usingCoefficients coefficients: [Swift.Float], withVariables variables: U) -> [Swift.Float] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Float {
            
            let result = Array<Float>(unsafeUninitializedCapacity: variables.count) {
                buffer, initializedCount in
                
                evaluatePolynomial(usingCoefficients: coefficients,
                                   withVariables: variables,
                                   result: &buffer)
                
                initializedCount = variables.count
            }
            
            return result
    }
  @inlinable public static func evaluatePolynomial<U, V>(usingCoefficients coefficients: [Swift.Float], withVariables variables: U, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Float, V.Element == Swift.Float {
            
            let n = vDSP_Length(min(variables.count,
                                    result.count))
            
            let degreeOfPolynomial = vDSP_Length(coefficients.count - 1)
            
            result.withUnsafeMutableBufferPointer { dest in
                variables.withUnsafeBufferPointer { src in
                    vDSP_vpoly(coefficients, 1,
                               src.baseAddress!, 1,
                               dest.baseAddress!, 1,
                               n,
                               degreeOfPolynomial)
                }
            }
    }
  @inlinable public static func evaluatePolynomial<U>(usingCoefficients coefficients: [Swift.Double], withVariables variables: U) -> [Swift.Double] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Double {
            
            let result = Array<Double>(unsafeUninitializedCapacity: variables.count) {
                buffer, initializedCount in
                
                evaluatePolynomial(usingCoefficients: coefficients,
                                   withVariables: variables,
                                   result: &buffer)
                
                initializedCount = variables.count
            }
            
            return result
    }
  @inlinable public static func evaluatePolynomial<U, V>(usingCoefficients coefficients: [Swift.Double], withVariables variables: U, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Double, V.Element == Swift.Double {
            
            let n = vDSP_Length(min(variables.count,
                                    result.count))
            
            let degreeOfPolynomial = vDSP_Length(coefficients.count - 1)
            
            result.withUnsafeMutableBufferPointer { dest in
                variables.withUnsafeBufferPointer { src in
                    vDSP_vpolyD(coefficients, 1,
                                src.baseAddress!, 1,
                                dest.baseAddress!, 1,
                                n,
                                degreeOfPolynomial)
                }
            }
    }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Accelerate.BNNS {
  public struct FusedConvolutionParameters : Accelerate.FusableLayerParameters {
    public init(type: Accelerate.BNNS.ConvolutionType, weights: Accelerate.BNNSNDArrayDescriptor, bias: Accelerate.BNNSNDArrayDescriptor?, stride: (x: Swift.Int, y: Swift.Int), dilationStride: (x: Swift.Int, y: Swift.Int), groupSize: Swift.Int, padding: Accelerate.BNNS.ConvolutionPadding)
    public var type: Accelerate.BNNS.ConvolutionType
    public var weights: Accelerate.BNNSNDArrayDescriptor
    public var bias: Accelerate.BNNSNDArrayDescriptor?
    public var stride: (x: Swift.Int, y: Swift.Int)
    public var dilationStride: (x: Swift.Int, y: Swift.Int)
    public var groupSize: Swift.Int
    public var padding: Accelerate.BNNS.ConvolutionPadding
  }
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Accelerate.vDSP {
  public enum Radix {
    case radix2
    case radix3
    case radix5
    public var fftRadix: Accelerate.FFTRadix {
      get
    }
    public static func == (a: Accelerate.vDSP.Radix, b: Accelerate.vDSP.Radix) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public class FFT<T> where T : Accelerate.vDSP_FourierTransformable {
    public init?(log2n: Accelerate.vDSP_Length, radix: Accelerate.vDSP.Radix, ofType: T.Type)
    public func transform<T>(input: T, output: inout T, direction: Accelerate.vDSP.FourierTransformDirection) where T : Accelerate.vDSP_FourierTransformable
    public func forward(input: Accelerate.DSPSplitComplex, output: inout Accelerate.DSPSplitComplex)
    public func inverse(input: Accelerate.DSPSplitComplex, output: inout Accelerate.DSPSplitComplex)
    @objc deinit
  }
  public class FFT2D<T> : Accelerate.vDSP.FFT<T> where T : Accelerate.vDSP_FourierTransformable {
    required public init?(width: Swift.Int, height: Swift.Int, ofType: T.Type)
    override public func transform<T>(input: T, output: inout T, direction: Accelerate.vDSP.FourierTransformDirection) where T : Accelerate.vDSP_FourierTransformable
    @objc deinit
  }
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
public protocol vDSP_FourierTransformFunctions {
  associatedtype SplitComplex
  static func makeFFTSetup(log2n: Accelerate.vDSP_Length, radix: Accelerate.vDSP.Radix) -> Swift.OpaquePointer?
  static func transform(fftSetup: Swift.OpaquePointer, log2n: Accelerate.vDSP_Length, source: Swift.UnsafePointer<Self.SplitComplex>, destination: Swift.UnsafeMutablePointer<Self.SplitComplex>, direction: Accelerate.vDSP.FourierTransformDirection)
  static func transform2D(fftSetup: Swift.OpaquePointer, width: Swift.Int, height: Swift.Int, source: Swift.UnsafePointer<Self.SplitComplex>, destination: Swift.UnsafeMutablePointer<Self.SplitComplex>, direction: Accelerate.vDSP.FourierTransformDirection)
  static func destroySetup(_ setup: Swift.OpaquePointer)
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
public struct vDSP_SplitComplexFloat : Accelerate.vDSP_FourierTransformFunctions {
  public typealias SplitComplex = Accelerate.DSPSplitComplex
  public static func makeFFTSetup(log2n: Accelerate.vDSP_Length, radix: Accelerate.vDSP.Radix) -> Swift.OpaquePointer?
  public static func transform(fftSetup: Swift.OpaquePointer, log2n: Accelerate.vDSP_Length, source: Swift.UnsafePointer<Accelerate.vDSP_SplitComplexFloat.SplitComplex>, destination: Swift.UnsafeMutablePointer<Accelerate.vDSP_SplitComplexFloat.SplitComplex>, direction: Accelerate.vDSP.FourierTransformDirection)
  public static func transform2D(fftSetup: Swift.OpaquePointer, width: Swift.Int, height: Swift.Int, source: Swift.UnsafePointer<Accelerate.vDSP_SplitComplexFloat.SplitComplex>, destination: Swift.UnsafeMutablePointer<Accelerate.vDSP_SplitComplexFloat.SplitComplex>, direction: Accelerate.vDSP.FourierTransformDirection)
  public static func destroySetup(_ setup: Swift.OpaquePointer)
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
public struct vDSP_SplitComplexDouble : Accelerate.vDSP_FourierTransformFunctions {
  public typealias SplitComplex = Accelerate.DSPDoubleSplitComplex
  public static func makeFFTSetup(log2n: Accelerate.vDSP_Length, radix: Accelerate.vDSP.Radix) -> Swift.OpaquePointer?
  public static func transform(fftSetup: Swift.OpaquePointer, log2n: Accelerate.vDSP_Length, source: Swift.UnsafePointer<Accelerate.vDSP_SplitComplexDouble.SplitComplex>, destination: Swift.UnsafeMutablePointer<Accelerate.vDSP_SplitComplexDouble.SplitComplex>, direction: Accelerate.vDSP.FourierTransformDirection)
  public static func transform2D(fftSetup: Swift.OpaquePointer, width: Swift.Int, height: Swift.Int, source: Swift.UnsafePointer<Accelerate.vDSP_SplitComplexDouble.SplitComplex>, destination: Swift.UnsafeMutablePointer<Accelerate.vDSP_SplitComplexDouble.SplitComplex>, direction: Accelerate.vDSP.FourierTransformDirection)
  public static func destroySetup(_ setup: Swift.OpaquePointer)
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
public protocol vDSP_FourierTransformable {
  associatedtype FFTFunctions : Accelerate.vDSP_FourierTransformFunctions where Self == Self.FFTFunctions.SplitComplex
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Accelerate.DSPSplitComplex : Accelerate.vDSP_FourierTransformable {
  public typealias FFTFunctions = Accelerate.vDSP_SplitComplexFloat
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Accelerate.DSPDoubleSplitComplex : Accelerate.vDSP_FourierTransformable {
  public typealias FFTFunctions = Accelerate.vDSP_SplitComplexDouble
}
@available(macOS, deprecated, introduced: 10.15, message: "Use the `withUnsafeMutableBufferPointer` method on the real and imaginary arrays to create `DSPSplitComplex` for a defined scope.")
@available(iOS, deprecated, introduced: 13.0, message: "Use the `withUnsafeMutableBufferPointer` method on the real and imaginary arrays to create `DSPSplitComplex` for a defined scope.")
@available(watchOS, deprecated, introduced: 6.0, message: "Use the `withUnsafeMutableBufferPointer` method on the real and imaginary arrays to create `DSPSplitComplex` for a defined scope.")
@available(tvOS, deprecated, introduced: 13.0, message: "Use the `withUnsafeMutableBufferPointer` method on the real and imaginary arrays to create `DSPSplitComplex` for a defined scope.")
@available(*, deprecated, message: "Use the `withUnsafeMutableBufferPointer` method on the real and imaginary arrays to create `DSPSplitComplex` for a defined scope.")
extension Accelerate.DSPSplitComplex {
  public init(fromInputArray inputArray: [Swift.Float], realParts: inout [Swift.Float], imaginaryParts: inout [Swift.Float])
}
@available(macOS, deprecated, introduced: 10.15, message: "Use the `withUnsafeMutableBufferPointer` method on the real and imaginary arrays to create `DSPSplitComplex` for a defined scope.")
@available(iOS, deprecated, introduced: 13.0, message: "Use the `withUnsafeMutableBufferPointer` method on the real and imaginary arrays to create `DSPSplitComplex` for a defined scope.")
@available(watchOS, deprecated, introduced: 6.0, message: "Use the `withUnsafeMutableBufferPointer` method on the real and imaginary arrays to create `DSPSplitComplex` for a defined scope.")
@available(tvOS, deprecated, introduced: 13.0, message: "Use the `withUnsafeMutableBufferPointer` method on the real and imaginary arrays to create `DSPSplitComplex` for a defined scope.")
@available(*, deprecated, message: "Use the `withUnsafeMutableBufferPointer` method on the real and imaginary arrays to create `DSPSplitComplex` for a defined scope.")
extension Accelerate.DSPDoubleSplitComplex {
  public init(fromInputArray inputArray: [Swift.Double], realParts: inout [Swift.Double], imaginaryParts: inout [Swift.Double])
}
extension Swift.Array where Element == Swift.Float {
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public init(fromSplitComplex splitComplex: Accelerate.DSPSplitComplex, scale: Swift.Float, count: Swift.Int)
}
extension Swift.Array where Element == Swift.Double {
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public init(fromSplitComplex splitComplex: Accelerate.DSPDoubleSplitComplex, scale: Swift.Double, count: Swift.Int)
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Accelerate.BNNS {
  public enum RandomGeneratorMethod {
    case aesCtr
    public static func == (a: Accelerate.BNNS.RandomGeneratorMethod, b: Accelerate.BNNS.RandomGeneratorMethod) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  @_hasMissingDesignatedInitializers public class RandomGeneratorState {
    @objc deinit
  }
  public class RandomGenerator {
    public init?(method: Accelerate.BNNS.RandomGeneratorMethod, seed: Swift.UInt64? = nil, filterParameters: Accelerate.BNNSFilterParameters? = nil)
    @objc deinit
    public var state: Accelerate.BNNS.RandomGeneratorState {
      get
      set
    }
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Accelerate.BNNSNDArrayDescriptor {
  public static func allocate<Scalar>(randomUniformUsing: Accelerate.BNNS.RandomGenerator, range: Swift.ClosedRange<Scalar>, shape: Accelerate.BNNS.Shape, batchSize: Swift.Int = 1) -> Accelerate.BNNSNDArrayDescriptor? where Scalar : Accelerate.BNNSScalar, Scalar : Swift.BinaryFloatingPoint
  public static func allocate<Scalar>(randomUniformUsing: Accelerate.BNNS.RandomGenerator, range: Swift.ClosedRange<Scalar>, shape: Accelerate.BNNS.Shape, batchSize: Swift.Int = 1) -> Accelerate.BNNSNDArrayDescriptor? where Scalar : Accelerate.BNNSScalar, Scalar : Swift.FixedWidthInteger
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Accelerate.vImage {
  public enum Error : Swift.Int, Swift.Error {
    case noError
    case roiLargerThanInputBuffer
    case invalidKernelSize
    case invalidEdgeStyle
    case invalidOffset_X
    case invalidOffset_Y
    case memoryAllocationError
    case nullPointerArgument
    case invalidParameter
    case bufferSizeMismatch
    case unknownFlagsBit
    case internalError
    case invalidRowBytes
    case invalidImageFormat
    case colorSyncIsAbsent
    case outOfPlaceOperationRequired
    case invalidImageObject
    case invalidCVImageFormat
    case unsupportedConversion
    case coreVideoIsAbsent
    public init(vImageError: Accelerate.vImage_Error)
    public init?(rawValue: Swift.Int)
    public typealias RawValue = Swift.Int
    public var rawValue: Swift.Int {
      get
    }
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Accelerate.BNNS {
  public static func quantize(batchSize: Swift.Int, input: Accelerate.BNNSNDArrayDescriptor, output: Accelerate.BNNSNDArrayDescriptor, axis: Swift.Int? = nil, scale: Accelerate.BNNSNDArrayDescriptor?, bias: Accelerate.BNNSNDArrayDescriptor?, filterParameters: Accelerate.BNNSFilterParameters? = nil) throws
  public static func dequantize(batchSize: Swift.Int, input: Accelerate.BNNSNDArrayDescriptor, output: Accelerate.BNNSNDArrayDescriptor, axis: Swift.Int? = nil, scale: Accelerate.BNNSNDArrayDescriptor?, bias: Accelerate.BNNSNDArrayDescriptor?, filterParameters: Accelerate.BNNSFilterParameters? = nil) throws
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Accelerate.BNNS {
  public static func computeNorm(input: Accelerate.BNNSNDArrayDescriptor, output: Accelerate.BNNSNDArrayDescriptor, axes: [Swift.Int]? = nil) throws
  public static func computeNormBackward(input: Accelerate.BNNSNDArrayDescriptor, output: Accelerate.BNNSNDArrayDescriptor, axes: [Swift.Int]? = nil, outputGradient: Accelerate.BNNSNDArrayDescriptor, generatingInputGradient inputGradient: Accelerate.BNNSNDArrayDescriptor) throws
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Accelerate.vImageConverter {
  public func sourceBuffers(colorSpace: CoreGraphics.CGColorSpace) -> [Accelerate.vImage.BufferType?]
  public func destinationBuffers(colorSpace: CoreGraphics.CGColorSpace) -> [Accelerate.vImage.BufferType?]
  public var sourceBufferCount: Swift.Int {
    get
  }
  public var destinationBufferCount: Swift.Int {
    get
  }
  public func mustOperateOutOfPlace(source: Accelerate.vImage_Buffer, destination: Accelerate.vImage_Buffer, flags options: Accelerate.vImage.Options = .noFlags) throws -> Swift.Bool
  public static func make(sourceFormat: Accelerate.vImage_CGImageFormat, destinationFormat: Accelerate.vImage_CGImageFormat, flags options: Accelerate.vImage.Options = .noFlags) throws -> Accelerate.vImageConverter
  public static func make(sourceFormat: Accelerate.vImage_CGImageFormat, destinationFormat: Accelerate.vImageCVImageFormat, flags options: Accelerate.vImage.Options = .noFlags) throws -> Accelerate.vImageConverter
  public static func make(sourceFormat: Accelerate.vImageCVImageFormat, destinationFormat: Accelerate.vImage_CGImageFormat, flags options: Accelerate.vImage.Options = .noFlags) throws -> Accelerate.vImageConverter
  public func convert(source: Accelerate.vImage_Buffer, destination: inout Accelerate.vImage_Buffer, flags options: Accelerate.vImage.Options = .noFlags) throws
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Accelerate.vDSP {
  public struct Biquad<T> where T : Accelerate.vDSP_FloatingPointBiquadFilterable {
    public init?(coefficients: [Swift.Double], channelCount: Accelerate.vDSP_Length, sectionCount: Accelerate.vDSP_Length, ofType: T.Type)
    public mutating func apply<U>(input: U) -> [T] where T == U.Element, U : Accelerate.AccelerateBuffer
    public mutating func apply<U, V>(input: U, output: inout V) where T == U.Element, U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == V.Element
  }
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
public protocol vDSP_FloatingPointBiquadFilterable : Swift.BinaryFloatingPoint {
  associatedtype BiquadFunctions : Accelerate.vDSP_BiquadFunctions where Self == Self.BiquadFunctions.Scalar
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Swift.Float : Accelerate.vDSP_FloatingPointBiquadFilterable {
  public typealias BiquadFunctions = Accelerate.vDSP.VectorizableFloat
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Swift.Double : Accelerate.vDSP_FloatingPointBiquadFilterable {
  public typealias BiquadFunctions = Accelerate.vDSP.VectorizableDouble
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
public protocol vDSP_BiquadFunctions {
  associatedtype Scalar
  static func makeBiquadSetup(channelCount: Accelerate.vDSP_Length, coefficients: [Swift.Double], sectionCount: Accelerate.vDSP_Length) -> Swift.OpaquePointer?
  static func applySingle<U, V>(source: U, destination: inout V, delays: Swift.UnsafeMutablePointer<Self.Scalar>, setup: Accelerate.vDSP_biquad_Setup, sectionCount: Accelerate.vDSP_Length, count: Accelerate.vDSP_Length) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, Self.Scalar == U.Element, U.Element == V.Element
  static func applyMulti(setup: Accelerate.vDSP_biquadm_SetupD, pInputs: Swift.UnsafeMutablePointer<Swift.UnsafePointer<Self.Scalar>>, pOutputs: Swift.UnsafeMutablePointer<Swift.UnsafeMutablePointer<Self.Scalar>>, count: Accelerate.vDSP_Length)
  static func destroySetup(channelCount: Swift.UInt, biquadSetup: Swift.OpaquePointer)
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Accelerate.vDSP.VectorizableFloat : Accelerate.vDSP_BiquadFunctions {
  @inlinable public static func makeBiquadSetup(channelCount: Swift.UInt, coefficients: [Swift.Double], sectionCount: Swift.UInt) -> Swift.OpaquePointer? {
        if channelCount == 1 {
            return vDSP_biquad_CreateSetup(coefficients,
                                           sectionCount)
        } else {
            return vDSP_biquadm_CreateSetup(coefficients,
                                            sectionCount,
                                            channelCount)
        }
    }
  @inlinable public static func applySingle<U, V>(source: U, destination: inout V, delays: Swift.UnsafeMutablePointer<Accelerate.vDSP.VectorizableFloat.Scalar>, setup: Accelerate.vDSP_biquad_Setup, sectionCount: Accelerate.vDSP_Length, count: Accelerate.vDSP_Length) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Float, V.Element == Swift.Float {
            
            destination.withUnsafeMutableBufferPointer { dest in
                source.withUnsafeBufferPointer { src in
                    vDSP_biquad(setup,
                                delays,
                                src.baseAddress!, 1,
                                dest.baseAddress!, 1,
                                count)
                }
            }
    }
  @inlinable public static func applyMulti(setup: Accelerate.vDSP_biquadm_SetupD, pInputs: Swift.UnsafeMutablePointer<Swift.UnsafePointer<Accelerate.vDSP.VectorizableFloat.Scalar>>, pOutputs: Swift.UnsafeMutablePointer<Swift.UnsafeMutablePointer<Accelerate.vDSP.VectorizableFloat.Scalar>>, count: Accelerate.vDSP_Length) {
        vDSP_biquadm(setup,
                     pInputs, 1,
                     pOutputs, 1,
                     count)
    }
  @inlinable public static func destroySetup(channelCount: Swift.UInt, biquadSetup: Swift.OpaquePointer) {
        if channelCount == 1 {
            vDSP_biquad_DestroySetup(biquadSetup)
        } else {
            vDSP_biquadm_DestroySetup(biquadSetup)
        }
    }
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Accelerate.vDSP.VectorizableDouble : Accelerate.vDSP_BiquadFunctions {
  @inlinable public static func makeBiquadSetup(channelCount: Accelerate.vDSP_Length, coefficients: [Swift.Double], sectionCount: Accelerate.vDSP_Length) -> Swift.OpaquePointer? {
        if channelCount == 1 {
            return vDSP_biquad_CreateSetupD(coefficients,
                                            sectionCount)
        } else {
            return vDSP_biquadm_CreateSetupD(coefficients,
                                             sectionCount,
                                             channelCount)
        }
    }
  @inlinable public static func applySingle<U, V>(source: U, destination: inout V, delays: Swift.UnsafeMutablePointer<Accelerate.vDSP.VectorizableDouble.Scalar>, setup: Accelerate.vDSP_biquad_Setup, sectionCount: Accelerate.vDSP_Length, count: Accelerate.vDSP_Length) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Double, V.Element == Swift.Double {
            
            destination.withUnsafeMutableBufferPointer { dest in
                source.withUnsafeBufferPointer { src in
                    vDSP_biquadD(setup,
                                 delays,
                                 src.baseAddress!, 1,
                                 dest.baseAddress!, 1,
                                 count)
                }
            }
    }
  @inlinable public static func applyMulti(setup: Accelerate.vDSP_biquadm_SetupD, pInputs: Swift.UnsafeMutablePointer<Swift.UnsafePointer<Accelerate.vDSP.VectorizableDouble.Scalar>>, pOutputs: Swift.UnsafeMutablePointer<Swift.UnsafeMutablePointer<Accelerate.vDSP.VectorizableDouble.Scalar>>, count: Accelerate.vDSP_Length) {
        vDSP_biquadmD(setup,
                      pInputs, 1,
                      pOutputs, 1,
                      count)
    }
  @inlinable public static func destroySetup(channelCount: Swift.UInt, biquadSetup: Swift.OpaquePointer) {
        if channelCount == 1 {
            vDSP_biquad_DestroySetupD(biquadSetup)
        } else {
            vDSP_biquadm_DestroySetupD(biquadSetup)
        }
    }
}
@available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
extension Accelerate.BNNS {
  @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class DropoutLayer : Accelerate.BNNS.UnaryLayer {
    convenience public init?(input: Accelerate.BNNSNDArrayDescriptor, output: Accelerate.BNNSNDArrayDescriptor, rate: Swift.Float, seed: Swift.UInt32, control: Swift.UInt8, filterParameters: Accelerate.BNNSFilterParameters? = nil)
    @objc deinit
  }
}
@available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
extension Accelerate.BNNS {
  @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class FullyConnectedLayer : Accelerate.BNNS.ConvolutionLayer {
    convenience public init?(input: Accelerate.BNNSNDArrayDescriptor, output: Accelerate.BNNSNDArrayDescriptor, weights: Accelerate.BNNSNDArrayDescriptor, bias: Accelerate.BNNSNDArrayDescriptor?, activation: Accelerate.BNNS.ActivationFunction, filterParameters: Accelerate.BNNSFilterParameters? = nil)
    @objc deinit
  }
}
@available(macOS 10.12, iOS 10.0, tvOS 10.0, watchOS 3.0, *)
extension Accelerate.BNNSDataType {
  public static var float16: Accelerate.BNNSDataType {
    get
  }
  public static var float: Accelerate.BNNSDataType {
    get
  }
  public static var int8: Accelerate.BNNSDataType {
    get
  }
  public static var int16: Accelerate.BNNSDataType {
    get
  }
  public static var int32: Accelerate.BNNSDataType {
    get
  }
  public static var indexed8: Accelerate.BNNSDataType {
    get
  }
}
@available(macOS 10.13, iOS 11.0, tvOS 11.0, watchOS 4.0, *)
extension Accelerate.BNNSDataType {
  public static var uint8: Accelerate.BNNSDataType {
    get
  }
  public static var uint16: Accelerate.BNNSDataType {
    get
  }
  public static var uint32: Accelerate.BNNSDataType {
    get
  }
}
@available(macOS 10.12, iOS 10.0, tvOS 10.0, watchOS 3.0, *)
@available(*, deprecated, renamed: "BNNSDataType.float16")
public var BNNSDataTypeFloat16: Accelerate.BNNSDataType
@available(macOS 10.12, iOS 10.0, tvOS 10.0, watchOS 3.0, *)
@available(*, deprecated, renamed: "BNNSDataType.float")
public var BNNSDataTypeFloat32: Accelerate.BNNSDataType
@available(macOS 10.12, iOS 10.0, tvOS 10.0, watchOS 3.0, *)
@available(*, deprecated, renamed: "BNNSDataType.int8")
public var BNNSDataTypeInt8: Accelerate.BNNSDataType
@available(macOS 10.12, iOS 10.0, tvOS 10.0, watchOS 3.0, *)
@available(*, deprecated, renamed: "BNNSDataType.int16")
public var BNNSDataTypeInt16: Accelerate.BNNSDataType
@available(macOS 10.12, iOS 10.0, tvOS 10.0, watchOS 3.0, *)
@available(*, deprecated, renamed: "BNNSDataType.int32")
public var BNNSDataTypeInt32: Accelerate.BNNSDataType
@available(macOS 10.12, iOS 10.0, tvOS 10.0, watchOS 3.0, *)
@available(*, deprecated, renamed: "BNNSDataType.indexed8")
public var BNNSDataTypeIndexed8: Accelerate.BNNSDataType
@available(macOS 10.12, iOS 10.0, tvOS 10.0, watchOS 3.0, *)
extension Accelerate.BNNSPoolingFunction {
  public static var max: Accelerate.BNNSPoolingFunction {
    get
  }
  @available(macOS, introduced: 10.15, deprecated: 12.0, message: "Use 'BNNSPoolingFunctionAverageCountIncludePadding' instead.")
  @available(iOS, introduced: 13.0, deprecated: 15.0, message: "Use 'BNNSPoolingFunctionAverageCountIncludePadding' instead.")
  @available(watchOS, introduced: 6.0, deprecated: 8.0, message: "Use 'BNNSPoolingFunctionAverageCountIncludePadding' instead.")
  @available(tvOS, introduced: 13.0, deprecated: 15.0, message: "Use 'BNNSPoolingFunctionAverageCountIncludePadding' instead.")
  @available(*, deprecated, message: "Use 'BNNSPoolingFunctionAverageCountIncludePadding' instead.")
  public static var average: Accelerate.BNNSPoolingFunction {
    get
  }
}
@available(macOS 10.12, iOS 10.0, tvOS 10.0, watchOS 3.0, *)
@available(*, deprecated, renamed: "BNNSPoolingFunction.max")
public var BNNSPoolingFunctionMax: Accelerate.BNNSPoolingFunction
@available(macOS 10.12, iOS 10.0, tvOS 10.0, watchOS 3.0, *)
@available(*, deprecated, renamed: "BNNSPoolingFunction.average")
public var BNNSPoolingFunctionAverage: Accelerate.BNNSPoolingFunction
@available(macOS 10.12, iOS 10.0, tvOS 10.0, watchOS 3.0, *)
extension Accelerate.BNNSActivationFunction {
  public static var identity: Accelerate.BNNSActivationFunction {
    get
  }
  public static var rectifiedLinear: Accelerate.BNNSActivationFunction {
    get
  }
  public static var leakyRectifiedLinear: Accelerate.BNNSActivationFunction {
    get
  }
  public static var sigmoid: Accelerate.BNNSActivationFunction {
    get
  }
  public static var tanh: Accelerate.BNNSActivationFunction {
    get
  }
  public static var scaledTanh: Accelerate.BNNSActivationFunction {
    get
  }
  public static var abs: Accelerate.BNNSActivationFunction {
    get
  }
}
@available(macOS 10.13, iOS 11.0, tvOS 11.0, watchOS 4.0, *)
extension Accelerate.BNNSActivationFunction {
  public static var linear: Accelerate.BNNSActivationFunction {
    get
  }
  public static var clamp: Accelerate.BNNSActivationFunction {
    get
  }
  public static var integerLinearSaturate: Accelerate.BNNSActivationFunction {
    get
  }
  public static var integerLinearSaturatePerChannel: Accelerate.BNNSActivationFunction {
    get
  }
  public static var softmax: Accelerate.BNNSActivationFunction {
    get
  }
}
@available(macOS 10.12, iOS 10.0, tvOS 10.0, watchOS 3.0, *)
@available(*, deprecated, renamed: "BNNSActivationFunction.identity")
public var BNNSActivationFunctionIdentity: Accelerate.BNNSActivationFunction
@available(macOS 10.12, iOS 10.0, tvOS 10.0, watchOS 3.0, *)
@available(*, deprecated, renamed: "BNNSActivationFunction.rectifiedLinear")
public var BNNSActivationFunctionRectifiedLinear: Accelerate.BNNSActivationFunction
@available(macOS 10.12, iOS 10.0, tvOS 10.0, watchOS 3.0, *)
@available(*, deprecated, renamed: "BNNSActivationFunction.leakyRectifiedLinear")
public var BNNSActivationFunctionLeakyRectifiedLinear: Accelerate.BNNSActivationFunction
@available(macOS 10.12, iOS 10.0, tvOS 10.0, watchOS 3.0, *)
@available(*, deprecated, renamed: "BNNSActivationFunction.sigmoid")
public var BNNSActivationFunctionSigmoid: Accelerate.BNNSActivationFunction
@available(macOS 10.12, iOS 10.0, tvOS 10.0, watchOS 3.0, *)
@available(*, deprecated, renamed: "BNNSActivationFunction.tanh")
public var BNNSActivationFunctionTanh: Accelerate.BNNSActivationFunction
@available(macOS 10.12, iOS 10.0, tvOS 10.0, watchOS 3.0, *)
@available(*, deprecated, renamed: "BNNSActivationFunction.scaledTanh")
public var BNNSActivationFunctionScaledTanh: Accelerate.BNNSActivationFunction
@available(macOS 10.12, iOS 10.0, tvOS 10.0, watchOS 3.0, *)
@available(*, deprecated, renamed: "BNNSActivationFunction.abs")
public var BNNSActivationFunctionAbs: Accelerate.BNNSActivationFunction
@available(macOS 10.12, iOS 10.0, tvOS 10.0, watchOS 3.0, *)
extension Accelerate.BNNSFlags {
  public static var useClientPointer: Accelerate.BNNSFlags {
    get
  }
}
@available(macOS 10.12, iOS 10.0, tvOS 10.0, watchOS 3.0, *)
@available(*, deprecated, renamed: "BNNSFlags.useClientPointer")
public var BNNSFlagsUseClientPtr: Accelerate.BNNSFlags
@available(macOS, introduced: 10.12, deprecated: 12.0, message: "BNNS switched to new Layer Parameters data structures.")
@available(iOS, introduced: 10.0, deprecated: 15.0, message: "BNNS switched to new Layer Parameters data structures.")
@available(watchOS, introduced: 3.0, deprecated: 8.0, message: "BNNS switched to new Layer Parameters data structures.")
@available(tvOS, introduced: 10.0, deprecated: 15.0, message: "BNNS switched to new Layer Parameters data structures.")
@available(*, deprecated, message: "BNNS switched to new Layer Parameters data structures.")
extension Accelerate.BNNSImageStackDescriptor {
  public init(width: Swift.Int, height: Swift.Int, channels: Swift.Int, row_stride: Swift.Int, image_stride: Swift.Int, data_type: Accelerate.BNNSDataType)
}
@available(macOS, introduced: 10.12, deprecated: 12.0, message: "BNNS switched to new Layer Parameters data structures.")
@available(iOS, introduced: 10.0, deprecated: 15.0, message: "BNNS switched to new Layer Parameters data structures.")
@available(watchOS, introduced: 3.0, deprecated: 8.0, message: "BNNS switched to new Layer Parameters data structures.")
@available(tvOS, introduced: 10.0, deprecated: 15.0, message: "BNNS switched to new Layer Parameters data structures.")
@available(*, deprecated, message: "BNNS switched to new Layer Parameters data structures.")
extension Accelerate.BNNSVectorDescriptor {
  public init(size: Swift.Int, data_type: Accelerate.BNNSDataType)
}
@available(macOS, introduced: 10.12, deprecated: 12.0, message: "BNNS switched to new Layer Parameters data structures.")
@available(iOS, introduced: 10.0, deprecated: 15.0, message: "BNNS switched to new Layer Parameters data structures.")
@available(watchOS, introduced: 3.0, deprecated: 8.0, message: "BNNS switched to new Layer Parameters data structures.")
@available(tvOS, introduced: 10.0, deprecated: 15.0, message: "BNNS switched to new Layer Parameters data structures.")
@available(*, deprecated, message: "BNNS switched to new Layer Parameters data structures.")
extension Accelerate.BNNSLayerData {
  public init(data: Swift.UnsafeRawPointer?, data_type: Accelerate.BNNSDataType, data_scale: Swift.Float = 1, data_bias: Swift.Float = 0)
  public static var zero: Accelerate.BNNSLayerData {
    get
  }
  public static func indexed8(data: Swift.UnsafePointer<Swift.Int8>?, data_table: Swift.UnsafePointer<Swift.Float>) -> Accelerate.BNNSLayerData
}
@available(macOS 10.12, iOS 10.0, tvOS 10.0, watchOS 3.0, *)
extension Accelerate.BNNSActivation {
  public init(function: Accelerate.BNNSActivationFunction, alpha: Swift.Float = .nan, beta: Swift.Float = .nan)
  public static var identity: Accelerate.BNNSActivation {
    get
  }
}
@available(macOS 10.13, iOS 11.0, tvOS 11.0, watchOS 4.0, *)
extension Accelerate.BNNSActivation {
  public static func integerLinearSaturate(scale: Swift.Int32 = 1, offset: Swift.Int32 = 0, shift: Swift.Int32 = 0) -> Accelerate.BNNSActivation
  public static func integerLinearSaturatePerChannel(scale: Swift.UnsafePointer<Swift.Int32>, offset: Swift.UnsafePointer<Swift.Int32>, shift: Swift.UnsafePointer<Swift.Int32>) -> Accelerate.BNNSActivation
}
@available(macOS, introduced: 10.12, deprecated: 12.0, message: "Use 'BNNSLayerParametersConvolution' instead.")
@available(iOS, introduced: 10.0, deprecated: 15.0, message: "Use 'BNNSLayerParametersConvolution' instead")
@available(watchOS, introduced: 3.0, deprecated: 8.0, message: "Use 'BNNSLayerParametersConvolution' instead")
@available(tvOS, introduced: 10.0, deprecated: 15.0, message: "Use 'BNNSLayerParametersConvolution' instead")
@available(*, deprecated, message: "Use 'BNNSLayerParametersConvolution' instead")
extension Accelerate.BNNSConvolutionLayerParameters {
  public init(x_stride: Swift.Int, y_stride: Swift.Int, x_padding: Swift.Int, y_padding: Swift.Int, k_width: Swift.Int, k_height: Swift.Int, in_channels: Swift.Int, out_channels: Swift.Int, weights: Accelerate.BNNSLayerData)
}
@available(macOS, introduced: 10.12, deprecated: 12.0, message: "Use 'BNNSLayerParametersPooling' instead.")
@available(iOS, introduced: 10.0, deprecated: 15.0, message: "Use 'BNNSLayerParametersPooling' instead")
@available(watchOS, introduced: 3.0, deprecated: 8.0, message: "Use 'BNNSLayerParametersPooling' instead")
@available(tvOS, introduced: 10.0, deprecated: 15.0, message: "Use 'BNNSLayerParametersPooling' instead")
@available(*, deprecated, message: "Use 'BNNSLayerParametersPooling' instead")
extension Accelerate.BNNSPoolingLayerParameters {
  public init(x_stride: Swift.Int, y_stride: Swift.Int, x_padding: Swift.Int, y_padding: Swift.Int, k_width: Swift.Int, k_height: Swift.Int, in_channels: Swift.Int, out_channels: Swift.Int, pooling_function: Accelerate.BNNSPoolingFunction)
}
@available(macOS, introduced: 10.12, deprecated: 12.0, message: "Use 'BNNSLayerParametersFullyConnected' instead.")
@available(iOS, introduced: 10.0, deprecated: 15.0, message: "Use 'BNNSLayerParametersFullyConnected' instead")
@available(watchOS, introduced: 3.0, deprecated: 8.0, message: "Use 'BNNSLayerParametersFullyConnected' instead")
@available(tvOS, introduced: 10.0, deprecated: 15.0, message: "Use 'BNNSLayerParametersFullyConnected' instead")
@available(*, deprecated, message: "Use 'BNNSLayerParametersFullyConnected' instead")
extension Accelerate.BNNSFullyConnectedLayerParameters {
  public init(in_size: Swift.Int, out_size: Swift.Int, weights: Accelerate.BNNSLayerData)
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
public protocol AccelerateBuffer {
  associatedtype Element
  var count: Swift.Int { get }
  func withUnsafeBufferPointer<R>(_ body: (Swift.UnsafeBufferPointer<Self.Element>) throws -> R) rethrows -> R
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
public protocol AccelerateMutableBuffer : Accelerate.AccelerateBuffer {
  mutating func withUnsafeMutableBufferPointer<R>(_ body: (inout Swift.UnsafeMutableBufferPointer<Self.Element>) throws -> R) rethrows -> R
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Accelerate.AccelerateBuffer where Self : Swift.Collection {
  @inlinable public func withUnsafeBufferPointer<R>(_ body: (Swift.UnsafeBufferPointer<Self.Element>) throws -> R) rethrows -> R {
        return try withContiguousStorageIfAvailable(body)!
    }
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Accelerate.AccelerateMutableBuffer where Self : Swift.MutableCollection {
  @inlinable public mutating func withUnsafeMutableBufferPointer<R>(_ body: (inout Swift.UnsafeMutableBufferPointer<Self.Element>) throws -> R) rethrows -> R {
        return try withContiguousMutableStorageIfAvailable(body)!
    }
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Swift.Array : Accelerate.AccelerateMutableBuffer {
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Swift.ContiguousArray : Accelerate.AccelerateMutableBuffer {
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Swift.ArraySlice : Accelerate.AccelerateMutableBuffer {
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Swift.UnsafeBufferPointer : Accelerate.AccelerateBuffer {
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Swift.UnsafeMutableBufferPointer : Accelerate.AccelerateMutableBuffer {
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Swift.Slice : Accelerate.AccelerateBuffer where Base : Accelerate.AccelerateBuffer {
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Swift.Slice : Accelerate.AccelerateMutableBuffer where Base : Accelerate.AccelerateMutableBuffer, Base : Swift.MutableCollection {
}
@available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
public protocol BNNSScalar {
  static var bnnsDataType: Accelerate.BNNSDataType { get }
}
@available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
extension Swift.Float : Accelerate.BNNSScalar {
  public static var bnnsDataType: Accelerate.BNNSDataType {
    get
  }
}
@available(iOS 14, tvOS 14, watchOS 7, *)
@available(macOS, unavailable)
@available(macCatalyst, unavailable)
extension Swift.Float16 : Accelerate.BNNSScalar {
  public static var bnnsDataType: Accelerate.BNNSDataType {
    get
  }
}
@available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
extension Swift.Int8 : Accelerate.BNNSScalar {
  public static var bnnsDataType: Accelerate.BNNSDataType {
    get
  }
}
@available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
extension Swift.Int16 : Accelerate.BNNSScalar {
  public static var bnnsDataType: Accelerate.BNNSDataType {
    get
  }
}
@available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
extension Swift.Int32 : Accelerate.BNNSScalar {
  public static var bnnsDataType: Accelerate.BNNSDataType {
    get
  }
}
@available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
extension Swift.UInt8 : Accelerate.BNNSScalar {
  public static var bnnsDataType: Accelerate.BNNSDataType {
    get
  }
}
@available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
extension Swift.UInt16 : Accelerate.BNNSScalar {
  public static var bnnsDataType: Accelerate.BNNSDataType {
    get
  }
}
@available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
extension Swift.UInt32 : Accelerate.BNNSScalar {
  public static var bnnsDataType: Accelerate.BNNSDataType {
    get
  }
}
@available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
extension Swift.Bool : Accelerate.BNNSScalar {
  public static var bnnsDataType: Accelerate.BNNSDataType {
    get
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Swift.Int64 : Accelerate.BNNSScalar {
  public static var bnnsDataType: Accelerate.BNNSDataType {
    get
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Swift.UInt64 : Accelerate.BNNSScalar {
  public static var bnnsDataType: Accelerate.BNNSDataType {
    get
  }
}
@available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
extension Accelerate.BNNSNDArrayDescriptor {
  public init(dataType: Accelerate.BNNSDataType, shape: Accelerate.BNNS.Shape)
  public init?(data: Swift.UnsafeMutableRawBufferPointer, scalarType: Accelerate.BNNSScalar.Type, shape: Accelerate.BNNS.Shape)
  public init?<T>(data: Swift.UnsafeMutableBufferPointer<T>, shape: Accelerate.BNNS.Shape) where T : Accelerate.BNNSScalar
  public static func allocateUninitialized(scalarType: Accelerate.BNNSScalar.Type, shape: Accelerate.BNNS.Shape, batchSize: Swift.Int = 1) -> Accelerate.BNNSNDArrayDescriptor
  public static func allocate<C>(initializingFrom source: C, shape: Accelerate.BNNS.Shape, batchSize: Swift.Int = 1) -> Accelerate.BNNSNDArrayDescriptor where C : Swift.Collection, C.Element : Accelerate.BNNSScalar
  public static func allocate<Scalar>(randomIn range: Swift.ClosedRange<Scalar>, shape: Accelerate.BNNS.Shape, batchSize: Swift.Int = 1) -> Accelerate.BNNSNDArrayDescriptor where Scalar : Accelerate.BNNSScalar, Scalar : Swift.FixedWidthInteger
  public static func allocate<Scalar>(randomIn range: Swift.ClosedRange<Scalar>, shape: Accelerate.BNNS.Shape, batchSize: Swift.Int = 1) -> Accelerate.BNNSNDArrayDescriptor where Scalar : Accelerate.BNNSScalar, Scalar : Swift.BinaryFloatingPoint, Scalar.RawSignificand : Swift.FixedWidthInteger
  public static func allocate<Scalar, Generator>(randomIn range: Swift.ClosedRange<Scalar>, using generator: inout Generator, shape: Accelerate.BNNS.Shape, batchSize: Swift.Int = 1) -> Accelerate.BNNSNDArrayDescriptor where Scalar : Accelerate.BNNSScalar, Scalar : Swift.FixedWidthInteger, Generator : Swift.RandomNumberGenerator
  public static func allocate<Scalar, Generator>(randomIn range: Swift.ClosedRange<Scalar>, using generator: inout Generator, shape: Accelerate.BNNS.Shape, batchSize: Swift.Int = 1) -> Accelerate.BNNSNDArrayDescriptor where Scalar : Accelerate.BNNSScalar, Scalar : Swift.BinaryFloatingPoint, Generator : Swift.RandomNumberGenerator, Scalar.RawSignificand : Swift.FixedWidthInteger
  public static func allocate<T>(repeating repeatedValue: T, shape: Accelerate.BNNS.Shape, batchSize: Swift.Int = 1) -> Accelerate.BNNSNDArrayDescriptor where T : Accelerate.BNNSScalar
  public func makeArray<T>(of scalarType: T.Type, batchSize: Swift.Int = 1) -> [T]?
  public var shape: Accelerate.BNNS.Shape {
    get
  }
  public func deallocate()
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Accelerate.BNNSNDArrayDescriptor {
  public init?(data: Swift.UnsafeMutableRawBufferPointer, scalarType: Accelerate.BNNSScalar.Type, shape: Accelerate.BNNS.Shape, batchSize: Swift.Int)
  public init?<T>(data: Swift.UnsafeMutableBufferPointer<T>, shape: Accelerate.BNNS.Shape, batchSize: Swift.Int) where T : Accelerate.BNNSScalar
}
@available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
extension Accelerate.BNNS {
  @frozen public struct RelationalOperator {
    @usableFromInline
    internal var value: Accelerate.BNNSRelationalOperator
    @usableFromInline
    @inline(__always) internal init(_ value: Accelerate.BNNSRelationalOperator)
    @inlinable public static var equal: Accelerate.BNNS.RelationalOperator {
      get { Self(BNNSRelationalOperatorEqual) }
    }
    @inlinable public static var less: Accelerate.BNNS.RelationalOperator {
      get { Self(BNNSRelationalOperatorLess) }
    }
    @inlinable public static var lessEqual: Accelerate.BNNS.RelationalOperator {
      get { Self(BNNSRelationalOperatorLessEqual) }
    }
    @inlinable public static var greater: Accelerate.BNNS.RelationalOperator {
      get { Self(BNNSRelationalOperatorGreater) }
    }
    @inlinable public static var greaterEqual: Accelerate.BNNS.RelationalOperator {
      get { Self(BNNSRelationalOperatorGreaterEqual) }
    }
    @inlinable public static var notEqual: Accelerate.BNNS.RelationalOperator {
      get { Self(BNNSRelationalOperatorNotEqual) }
    }
    @inlinable public static var and: Accelerate.BNNS.RelationalOperator {
      get { Self(BNNSRelationalOperatorLogicalAND) }
    }
    @inlinable public static var or: Accelerate.BNNS.RelationalOperator {
      get { Self(BNNSRelationalOperatorLogicalOR) }
    }
    @inlinable public static var not: Accelerate.BNNS.RelationalOperator {
      get { Self(BNNSRelationalOperatorLogicalNOT) }
    }
    @inlinable public static var nand: Accelerate.BNNS.RelationalOperator {
      get { Self(BNNSRelationalOperatorLogicalNAND) }
    }
    @inlinable public static var nor: Accelerate.BNNS.RelationalOperator {
      get { Self(BNNSRelationalOperatorLogicalNOR) }
    }
    @inlinable public static var xor: Accelerate.BNNS.RelationalOperator {
      get { Self(BNNSRelationalOperatorLogicalXOR) }
    }
  }
  public static func compare(_ inputA: Accelerate.BNNSNDArrayDescriptor, _ inputB: Accelerate.BNNSNDArrayDescriptor, using relationalOperator: Accelerate.BNNS.RelationalOperator, output: Accelerate.BNNSNDArrayDescriptor) throws
}
@available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
extension Accelerate.BNNS {
  public enum DescriptorType {
    case constant
    case sample
    case parameter
    public static func == (a: Accelerate.BNNS.DescriptorType, b: Accelerate.BNNS.DescriptorType) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public enum ArithmeticUnaryFunction : Swift.CaseIterable {
    case squareRoot
    case reciprocalSquareRoot
    case floor
    case ceil
    case round
    case sin
    case cos
    case tan
    case asin
    case acos
    case atan
    case sinh
    case cosh
    case tanh
    case asinh
    case acosh
    case atanh
    case exp
    case exp2
    case log
    case log2
    public var bnnsArithmeticFunction: Accelerate.BNNSArithmeticFunction {
      get
    }
    public static func == (a: Accelerate.BNNS.ArithmeticUnaryFunction, b: Accelerate.BNNS.ArithmeticUnaryFunction) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public typealias AllCases = [Accelerate.BNNS.ArithmeticUnaryFunction]
    public static var allCases: [Accelerate.BNNS.ArithmeticUnaryFunction] {
      get
    }
    public var hashValue: Swift.Int {
      get
    }
  }
  public enum ArithmeticBinaryFunction : Swift.CaseIterable {
    case add
    case subtract
    case multiply
    case multiplyNoNaN
    case divide
    case divideNoNaN
    case pow
    @available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
    case max
    @available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
    case min
    public static var allCases: [Accelerate.BNNS.ArithmeticBinaryFunction] {
      get
    }
    public static func == (a: Accelerate.BNNS.ArithmeticBinaryFunction, b: Accelerate.BNNS.ArithmeticBinaryFunction) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public typealias AllCases = [Accelerate.BNNS.ArithmeticBinaryFunction]
    public var hashValue: Swift.Int {
      get
    }
  }
}
@available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
extension Accelerate.BNNS {
  @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class UnaryArithmeticLayer : Accelerate.BNNS.Layer {
    convenience public init?(input: Accelerate.BNNSNDArrayDescriptor, inputDescriptorType: Accelerate.BNNS.DescriptorType, output: Accelerate.BNNSNDArrayDescriptor, outputDescriptorType: Accelerate.BNNS.DescriptorType, function: Accelerate.BNNS.ArithmeticUnaryFunction, activation: Accelerate.BNNS.ActivationFunction = .identity, filterParameters: Accelerate.BNNSFilterParameters? = nil)
    public func apply(batchSize: Swift.Int, input: Accelerate.BNNSNDArrayDescriptor, output: Accelerate.BNNSNDArrayDescriptor) throws
    public func applyBackward(batchSize: Swift.Int, input: Accelerate.BNNSNDArrayDescriptor, output: Accelerate.BNNSNDArrayDescriptor, outputGradient: Accelerate.BNNSNDArrayDescriptor, generatingInputGradient inputGradient: Accelerate.BNNSNDArrayDescriptor) throws
    @objc deinit
  }
  @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class BinaryArithmeticLayer : Accelerate.BNNS.Layer {
    convenience public init?(inputA: Accelerate.BNNSNDArrayDescriptor, inputADescriptorType: Accelerate.BNNS.DescriptorType, inputB: Accelerate.BNNSNDArrayDescriptor, inputBDescriptorType: Accelerate.BNNS.DescriptorType, output: Accelerate.BNNSNDArrayDescriptor, outputDescriptorType: Accelerate.BNNS.DescriptorType, function: Accelerate.BNNS.ArithmeticBinaryFunction, activation: Accelerate.BNNS.ActivationFunction = .identity, filterParameters: Accelerate.BNNSFilterParameters? = nil)
    public func apply(batchSize: Swift.Int, inputA: Accelerate.BNNSNDArrayDescriptor, inputB: Accelerate.BNNSNDArrayDescriptor, output: Accelerate.BNNSNDArrayDescriptor) throws
    public func applyBackward(batchSize: Swift.Int, inputA: Accelerate.BNNSNDArrayDescriptor, inputB: Accelerate.BNNSNDArrayDescriptor, output: Accelerate.BNNSNDArrayDescriptor, outputGradient: Accelerate.BNNSNDArrayDescriptor, generatingInputAGradient inputAGradient: Accelerate.BNNSNDArrayDescriptor, generatingInputBGradient inputBGradient: Accelerate.BNNSNDArrayDescriptor) throws
    @objc deinit
  }
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Accelerate.vDSP {
  @inlinable public static func linearInterpolate<T, U>(_ vectorA: T, _ vectorB: U, using interpolationConstant: Swift.Float) -> [Swift.Float] where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, T.Element == Swift.Float, U.Element == Swift.Float {
            
            let result = Array<Float>(unsafeUninitializedCapacity: vectorA.count) {
                buffer, initializedCount in
                
                linearInterpolate(vectorA,
                                  vectorB,
                                  using: interpolationConstant,
                                  result: &buffer)
                
                initializedCount = vectorA.count
            }
            
            return result
    }
  @inlinable public static func linearInterpolate<T, U, V>(_ vectorA: T, _ vectorB: U, using interpolationConstant: Swift.Float, result: inout V) where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, T.Element == Swift.Float, U.Element == Swift.Float, V.Element == Swift.Float {
            
            precondition(vectorA.count == result.count)
            precondition(vectorB.count == result.count)
            let n = vDSP_Length(result.count)
            
            vectorA.withUnsafeBufferPointer { a in
                vectorB.withUnsafeBufferPointer { b in
                    result.withUnsafeMutableBufferPointer { dest in
                        
                        vDSP_vintb(a.baseAddress!, 1,
                                   b.baseAddress!, 1,
                                   [interpolationConstant],
                                   dest.baseAddress!, 1,
                                   n)
                    }
                }
            }
    }
  @inlinable public static func linearInterpolate<T, U>(_ vectorA: T, _ vectorB: U, using interpolationConstant: Swift.Double) -> [Swift.Double] where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, T.Element == Swift.Double, U.Element == Swift.Double {
            
            let result = Array<Double>(unsafeUninitializedCapacity: vectorA.count) {
                buffer, initializedCount in
                
                linearInterpolate(vectorA,
                                  vectorB,
                                  using: interpolationConstant,
                                  result: &buffer)
                
                initializedCount = vectorA.count
            }
            
            return result
    }
  @inlinable public static func linearInterpolate<T, U, V>(_ vectorA: T, _ vectorB: U, using interpolationConstant: Swift.Double, result: inout V) where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, T.Element == Swift.Double, U.Element == Swift.Double, V.Element == Swift.Double {
            
            precondition(vectorA.count == result.count)
            precondition(vectorB.count == result.count)
            let n = vDSP_Length(result.count)
            
            vectorA.withUnsafeBufferPointer { a in
                vectorB.withUnsafeBufferPointer { b in
                    result.withUnsafeMutableBufferPointer { dest in
                        
                        vDSP_vintbD(a.baseAddress!, 1,
                                    b.baseAddress!, 1,
                                    [interpolationConstant],
                                    dest.baseAddress!, 1,
                                    n)
                    }
                }
            }
    }
  @inlinable public static func linearInterpolate<T, U>(elementsOf vector: T, using controlVector: U) -> [Swift.Float] where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, T.Element == Swift.Float, U.Element == Swift.Float {
            
            let result = Array<Float>(unsafeUninitializedCapacity: controlVector.count) {
                buffer, initializedCount in
                
                linearInterpolate(elementsOf: vector,
                                  using: controlVector,
                                  result: &buffer)
                
                initializedCount = controlVector.count
            }
            
            return result
    }
  @inlinable public static func linearInterpolate<T, U, V>(elementsOf vector: T, using controlVector: U, result: inout V) where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, T.Element == Swift.Float, U.Element == Swift.Float, V.Element == Swift.Float {
            
            precondition(controlVector.count == result.count)
            
            let n = vDSP_Length(result.count)
            let m = vDSP_Length(vector.count)
            
            vector.withUnsafeBufferPointer { a in
                controlVector.withUnsafeBufferPointer { b in
                    result.withUnsafeMutableBufferPointer { dest in
                        vDSP_vlint(a.baseAddress!,
                                   b.baseAddress!, 1,
                                   dest.baseAddress!, 1,
                                   n, m)
                    }
                }
            }
    }
  @inlinable public static func linearInterpolate<T, U>(elementsOf vector: T, using controlVector: U) -> [Swift.Double] where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, T.Element == Swift.Double, U.Element == Swift.Double {
            
            let result = Array<Double>(unsafeUninitializedCapacity: controlVector.count) {
                buffer, initializedCount in
                
                linearInterpolate(elementsOf: vector,
                                  using: controlVector,
                                  result: &buffer)
                
                initializedCount = controlVector.count
            }
            
            return result
    }
  @inlinable public static func linearInterpolate<T, U, V>(elementsOf vector: T, using controlVector: U, result: inout V) where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, T.Element == Swift.Double, U.Element == Swift.Double, V.Element == Swift.Double {
            
            precondition(controlVector.count == result.count)
            
            let n = vDSP_Length(result.count)
            let m = vDSP_Length(vector.count)
            
            vector.withUnsafeBufferPointer { a in
                controlVector.withUnsafeBufferPointer { b in
                    result.withUnsafeMutableBufferPointer { dest in
                        vDSP_vlintD(a.baseAddress!,
                                    b.baseAddress!, 1,
                                    dest.baseAddress!, 1,
                                    n, m)
                    }
                }
            }
    }
}
@available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
extension Accelerate.BNNS {
  public enum InterpolationMethod {
    case linear
    case nearestNeighbor
    public static func == (a: Accelerate.BNNS.InterpolationMethod, b: Accelerate.BNNS.InterpolationMethod) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class ResizeLayer : Accelerate.BNNS.UnaryLayer {
    convenience public init?(interpolationMethod: Accelerate.BNNS.InterpolationMethod, input: Accelerate.BNNSNDArrayDescriptor, output: Accelerate.BNNSNDArrayDescriptor, alignsCorners: Swift.Bool, filterParameters: Accelerate.BNNSFilterParameters? = nil)
    @objc deinit
  }
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Accelerate.vForce {
  @inlinable public static func ceil<U>(_ vector: U) -> [Swift.Float] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Float {
            
            let result = Array<Float>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                ceil(vector,
                     result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func ceil<U, V>(_ vector: U, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Float, V.Element == Swift.Float {
            
            precondition(vector.count == result.count)
            
            var n = Int32(vector.count)
            
            result.withUnsafeMutableBufferPointer { dest in
                vector.withUnsafeBufferPointer { src in
                    vvceilf(dest.baseAddress!,
                            src.baseAddress!,
                            &n)
                }
            }
    }
  @inlinable public static func ceil<U>(_ vector: U) -> [Swift.Double] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Double {
            
            let result = Array<Double>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                ceil(vector,
                     result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func ceil<U, V>(_ vector: U, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Double, V.Element == Swift.Double {
            
            precondition(vector.count == result.count)
            
            var n = Int32(vector.count)
            
            result.withUnsafeMutableBufferPointer { dest in
                vector.withUnsafeBufferPointer { src in
                    vvceil(dest.baseAddress!,
                           src.baseAddress!,
                           &n)
                }
            }
    }
  @inlinable public static func floor<U>(_ vector: U) -> [Swift.Float] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Float {
            
            let result = Array<Float>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                floor(vector,
                      result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func floor<U, V>(_ vector: U, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Float, V.Element == Swift.Float {
            
            precondition(vector.count == result.count)
            
            var n = Int32(vector.count)
            
            result.withUnsafeMutableBufferPointer { dest in
                vector.withUnsafeBufferPointer { src in
                    vvfloorf(dest.baseAddress!,
                             src.baseAddress!,
                             &n)
                }
            }
    }
  @inlinable public static func floor<U>(_ vector: U) -> [Swift.Double] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Double {
            
            let result = Array<Double>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                floor(vector,
                      result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func floor<U, V>(_ vector: U, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Double, V.Element == Swift.Double {
            
            precondition(vector.count == result.count)
            
            var n = Int32(vector.count)
            
            result.withUnsafeMutableBufferPointer { dest in
                vector.withUnsafeBufferPointer { src in
                    vvfloor(dest.baseAddress!,
                            src.baseAddress!,
                            &n)
                }
            }
    }
  @inlinable public static func copysign<U, V>(magnitudes: U, signs: V) -> [Swift.Float] where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Float, V.Element == Swift.Float {
            
            precondition(magnitudes.count == signs.count)
            
            let result = Array<Float>(unsafeUninitializedCapacity: magnitudes.count) {
                buffer, initializedCount in
                
                copysign(magnitudes: magnitudes,
                         signs: signs,
                         result: &buffer)
                
                initializedCount = magnitudes.count
            }
            
            return result
    }
  @inlinable public static func copysign<T, U, V>(magnitudes: T, signs: U, result: inout V) where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, T.Element == Swift.Float, U.Element == Swift.Float, V.Element == Swift.Float {
            
            precondition(magnitudes.count == signs.count && signs.count == result.count)
            
            var n = Int32(magnitudes.count)
            
            result.withUnsafeMutableBufferPointer { dest in
                magnitudes.withUnsafeBufferPointer { mag in
                    signs.withUnsafeBufferPointer { sgn in
                        vvcopysignf(dest.baseAddress!,
                                    mag.baseAddress!,
                                    sgn.baseAddress!,
                                    &n)
                    }
                }
            }
    }
  @inlinable public static func copysign<U, V>(magnitudes: U, signs: V) -> [Swift.Double] where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Double, V.Element == Swift.Double {
            
            precondition(magnitudes.count == signs.count)
            
            let result = Array<Double>(unsafeUninitializedCapacity: magnitudes.count) {
                buffer, initializedCount in
                
                copysign(magnitudes: magnitudes,
                         signs: signs,
                         result: &buffer)
                
                initializedCount = magnitudes.count
            }
            
            return result
    }
  @inlinable public static func copysign<T, U, V>(magnitudes: T, signs: U, result: inout V) where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, T.Element == Swift.Double, U.Element == Swift.Double, V.Element == Swift.Double {
            
            precondition(magnitudes.count == signs.count && signs.count == result.count)
            
            var n = Int32(magnitudes.count)
            
            result.withUnsafeMutableBufferPointer { dest in
                magnitudes.withUnsafeBufferPointer { mag in
                    signs.withUnsafeBufferPointer { sgn in
                        vvcopysign(dest.baseAddress!,
                                   mag.baseAddress!,
                                   sgn.baseAddress!,
                                   &n)
                    }
                }
            }
    }
  @inlinable public static func truncatingRemainder<U, V>(dividends: U, divisors: V) -> [Swift.Float] where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Float, V.Element == Swift.Float {
            
            precondition(dividends.count == divisors.count)
            
            let result = Array<Float>(unsafeUninitializedCapacity: dividends.count) {
                buffer, initializedCount in
                
                truncatingRemainder(dividends: dividends,
                                    divisors: divisors,
                                    result: &buffer)
                
                initializedCount = dividends.count
            }
            
            return result
    }
  @inlinable public static func truncatingRemainder<T, U, V>(dividends: T, divisors: U, result: inout V) where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, T.Element == Swift.Float, U.Element == Swift.Float, V.Element == Swift.Float {
            
            precondition(dividends.count == divisors.count && divisors.count == result.count)
            
            var n = Int32(result.count)
            
            result.withUnsafeMutableBufferPointer { dest in
                dividends.withUnsafeBufferPointer { a in
                    divisors.withUnsafeBufferPointer { b in
                        vvfmodf(dest.baseAddress!,
                                a.baseAddress!,
                                b.baseAddress!,
                                &n)
                    }
                }
            }
    }
  @inlinable public static func truncatingRemainder<U, V>(dividends: U, divisors: V) -> [Swift.Double] where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Double, V.Element == Swift.Double {
            
            precondition(dividends.count == divisors.count)
            
            let result = Array<Double>(unsafeUninitializedCapacity: dividends.count) {
                buffer, initializedCount in
                
                truncatingRemainder(dividends: dividends,
                                    divisors: divisors,
                                    result: &buffer)
                
                initializedCount = dividends.count
            }
            
            return result
    }
  @inlinable public static func truncatingRemainder<T, U, V>(dividends: T, divisors: U, result: inout V) where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, T.Element == Swift.Double, U.Element == Swift.Double, V.Element == Swift.Double {
            
            precondition(dividends.count == divisors.count && divisors.count == result.count)
            
            var n = Int32(result.count)
            
            result.withUnsafeMutableBufferPointer { dest in
                dividends.withUnsafeBufferPointer { a in
                    divisors.withUnsafeBufferPointer { b in
                        vvfmod(dest.baseAddress!,
                               a.baseAddress!,
                               b.baseAddress!,
                               &n)
                    }
                }
            }
    }
  @inlinable public static func remainder<U, V>(dividends: U, divisors: V) -> [Swift.Float] where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Float, V.Element == Swift.Float {
            
            precondition(dividends.count == divisors.count)
            
            let result = Array<Float>(unsafeUninitializedCapacity: dividends.count) {
                buffer, initializedCount in
                
                remainder(dividends: dividends,
                          divisors: divisors,
                          result: &buffer)
                
                initializedCount = dividends.count
            }
            
            return result
    }
  @inlinable public static func remainder<T, U, V>(dividends: T, divisors: U, result: inout V) where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, T.Element == Swift.Float, U.Element == Swift.Float, V.Element == Swift.Float {
            
            precondition(dividends.count == divisors.count && divisors.count == result.count)
            
            var n = Int32(result.count)
            
            result.withUnsafeMutableBufferPointer { dest in
                dividends.withUnsafeBufferPointer { a in
                    divisors.withUnsafeBufferPointer { b in
                        vvremainderf(dest.baseAddress!,
                                     a.baseAddress!,
                                     b.baseAddress!,
                                     &n)
                    }
                }
            }
    }
  @inlinable public static func remainder<U, V>(dividends: U, divisors: V) -> [Swift.Double] where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Double, V.Element == Swift.Double {
            
            precondition(dividends.count == divisors.count)
            
            let result = Array<Double>(unsafeUninitializedCapacity: dividends.count) {
                buffer, initializedCount in
                
                remainder(dividends: dividends,
                          divisors: divisors,
                          result: &buffer)
                
                initializedCount = dividends.count
            }
            
            return result
    }
  @inlinable public static func remainder<T, U, V>(dividends: T, divisors: U, result: inout V) where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, T.Element == Swift.Double, U.Element == Swift.Double, V.Element == Swift.Double {
            
            precondition(dividends.count == divisors.count && divisors.count == result.count)
            
            var n = Int32(result.count)
            
            result.withUnsafeMutableBufferPointer { dest in
                dividends.withUnsafeBufferPointer { a in
                    divisors.withUnsafeBufferPointer { b in
                        vvremainder(dest.baseAddress!,
                                    a.baseAddress!,
                                    b.baseAddress!,
                                    &n)
                    }
                }
            }
    }
  @inlinable public static func trunc<U>(_ vector: U) -> [Swift.Float] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Float {
            
            let result = Array<Float>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                trunc(vector,
                      result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func trunc<U, V>(_ vector: U, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Float, V.Element == Swift.Float {
            
            precondition(vector.count == result.count)
            
            var n = Int32(vector.count)
            
            result.withUnsafeMutableBufferPointer { dest in
                vector.withUnsafeBufferPointer { src in
                    vvintf(dest.baseAddress!,
                           src.baseAddress!,
                           &n)
                }
            }
    }
  @inlinable public static func trunc<U>(_ vector: U) -> [Swift.Double] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Double {
            
            let result = Array<Double>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                trunc(vector,
                      result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func trunc<U, V>(_ vector: U, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Double, V.Element == Swift.Double {
            
            precondition(vector.count == result.count)
            
            var n = Int32(vector.count)
            
            result.withUnsafeMutableBufferPointer { dest in
                vector.withUnsafeBufferPointer { src in
                    vvint(dest.baseAddress!,
                          src.baseAddress!,
                          &n)
                }
            }
    }
  @inlinable public static func nearestInteger<U>(_ vector: U) -> [Swift.Float] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Float {
            
            let result = Array<Float>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                nearestInteger(vector,
                               result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func nearestInteger<U, V>(_ vector: U, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Float, V.Element == Swift.Float {
            
            precondition(vector.count == result.count)
            
            var n = Int32(vector.count)
            
            result.withUnsafeMutableBufferPointer { dest in
                vector.withUnsafeBufferPointer { src in
                    vvnintf(dest.baseAddress!,
                            src.baseAddress!,
                            &n)
                }
            }
    }
  @inlinable public static func nearestInteger<U>(_ vector: U) -> [Swift.Double] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Double {
            
            let result = Array<Double>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                nearestInteger(vector,
                               result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func nearestInteger<U, V>(_ vector: U, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Double, V.Element == Swift.Double {
            
            precondition(vector.count == result.count)
            
            var n = Int32(vector.count)
            
            result.withUnsafeMutableBufferPointer { dest in
                vector.withUnsafeBufferPointer { src in
                    vvnint(dest.baseAddress!,
                           src.baseAddress!,
                           &n)
                }
            }
    }
  @inlinable public static func rsqrt<U>(_ vector: U) -> [Swift.Float] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Float {
            
            let result = Array<Float>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                rsqrt(vector,
                      result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func rsqrt<U, V>(_ vector: U, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Float, V.Element == Swift.Float {
            
            precondition(vector.count == result.count)
            
            var n = Int32(vector.count)
            
            result.withUnsafeMutableBufferPointer { dest in
                vector.withUnsafeBufferPointer { src in
                    vvrsqrtf(dest.baseAddress!,
                             src.baseAddress!,
                             &n)
                }
            }
    }
  @inlinable public static func rsqrt<U>(_ vector: U) -> [Swift.Double] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Double {
            
            let result = Array<Double>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                rsqrt(vector,
                      result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func rsqrt<U, V>(_ vector: U, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Double, V.Element == Swift.Double {
            
            precondition(vector.count == result.count)
            
            var n = Int32(vector.count)
            
            result.withUnsafeMutableBufferPointer { dest in
                vector.withUnsafeBufferPointer { src in
                    vvrsqrt(dest.baseAddress!,
                            src.baseAddress!,
                            &n)
                }
            }
    }
  @inlinable public static func sqrt<U>(_ vector: U) -> [Swift.Float] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Float {
            
            let result = Array<Float>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                sqrt(vector,
                     result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func sqrt<U, V>(_ vector: U, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Float, V.Element == Swift.Float {
            
            precondition(vector.count == result.count)
            
            var n = Int32(vector.count)
            
            result.withUnsafeMutableBufferPointer { dest in
                vector.withUnsafeBufferPointer { src in
                    vvsqrtf(dest.baseAddress!,
                            src.baseAddress!,
                            &n)
                }
            }
    }
  @inlinable public static func sqrt<U>(_ vector: U) -> [Swift.Double] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Double {
            
            let result = Array<Double>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                sqrt(vector,
                     result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func sqrt<U, V>(_ vector: U, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Double, V.Element == Swift.Double {
            
            precondition(vector.count == result.count)
            
            var n = Int32(vector.count)
            
            result.withUnsafeMutableBufferPointer { dest in
                vector.withUnsafeBufferPointer { src in
                    vvsqrt(dest.baseAddress!,
                           src.baseAddress!,
                           &n)
                }
            }
    }
  @inlinable public static func reciprocal<U>(_ vector: U) -> [Swift.Float] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Float {
            
            let result = Array<Float>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                reciprocal(vector,
                           result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func reciprocal<U, V>(_ vector: U, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Float, V.Element == Swift.Float {
            
            precondition(vector.count == result.count)
            
            var n = Int32(vector.count)
            
            result.withUnsafeMutableBufferPointer { dest in
                vector.withUnsafeBufferPointer { src in
                    vvrecf(dest.baseAddress!,
                           src.baseAddress!,
                           &n)
                }
            }
    }
  @inlinable public static func reciprocal<U>(_ vector: U) -> [Swift.Double] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Double {
            
            let result = Array<Double>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                reciprocal(vector,
                           result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func reciprocal<U, V>(_ vector: U, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Double, V.Element == Swift.Double {
            
            precondition(vector.count == result.count)
            
            var n = Int32(vector.count)
            
            result.withUnsafeMutableBufferPointer { dest in
                vector.withUnsafeBufferPointer { src in
                    vvrec(dest.baseAddress!,
                          src.baseAddress!,
                          &n)
                }
            }
    }
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Accelerate.vForce {
  @inlinable public static func exp<U>(_ vector: U) -> [Swift.Float] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Float {
            
            let result = Array<Float>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                exp(vector,
                    result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func exp<U, V>(_ vector: U, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Float, V.Element == Swift.Float {
            
            precondition(vector.count == result.count)
            
            var n = Int32(vector.count)
            
            result.withUnsafeMutableBufferPointer { dest in
                vector.withUnsafeBufferPointer { src in
                    vvexpf(dest.baseAddress!,
                           src.baseAddress!,
                           &n)
                }
            }
    }
  @inlinable public static func expm1<U>(_ vector: U) -> [Swift.Float] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Float {
            
            let result = Array<Float>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                expm1(vector,
                      result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func expm1<U, V>(_ vector: U, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Float, V.Element == Swift.Float {
            
            precondition(vector.count == result.count)
            
            var n = Int32(vector.count)
            
            result.withUnsafeMutableBufferPointer { dest in
                vector.withUnsafeBufferPointer { src in
                    vvexpm1f(dest.baseAddress!,
                             src.baseAddress!,
                             &n)
                }
            }
    }
  @inlinable public static func exp2<U>(_ vector: U) -> [Swift.Float] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Float {
            
            let result = Array<Float>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                exp2(vector,
                     result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func exp2<U, V>(_ vector: U, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Float, V.Element == Swift.Float {
            
            precondition(vector.count == result.count)
            
            var n = Int32(vector.count)
            
            result.withUnsafeMutableBufferPointer { dest in
                vector.withUnsafeBufferPointer { src in
                    vvexp2f(dest.baseAddress!,
                            src.baseAddress!,
                            &n)
                }
            }
    }
  @inlinable public static func exp<U>(_ vector: U) -> [Swift.Double] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Double {
            
            let result = Array<Double>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                exp(vector,
                    result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func exp<U, V>(_ vector: U, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Double, V.Element == Swift.Double {
            
            precondition(vector.count == result.count)
            
            var n = Int32(vector.count)
            
            result.withUnsafeMutableBufferPointer { dest in
                vector.withUnsafeBufferPointer { src in
                    vvexp(dest.baseAddress!,
                          src.baseAddress!,
                          &n)
                }
            }
    }
  @inlinable public static func expm1<U>(_ vector: U) -> [Swift.Double] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Double {
            
            let result = Array<Double>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                expm1(vector,
                      result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func expm1<U, V>(_ vector: U, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Double, V.Element == Swift.Double {
            
            precondition(vector.count == result.count)
            
            var n = Int32(vector.count)
            
            result.withUnsafeMutableBufferPointer { dest in
                vector.withUnsafeBufferPointer { src in
                    vvexpm1(dest.baseAddress!,
                            src.baseAddress!,
                            &n)
                }
            }
    }
  @inlinable public static func exp2<U>(_ vector: U) -> [Swift.Double] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Double {
            
            let result = Array<Double>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                exp2(vector,
                     result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func exp2<U, V>(_ vector: U, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Double, V.Element == Swift.Double {
            
            precondition(vector.count == result.count)
            
            var n = Int32(vector.count)
            
            result.withUnsafeMutableBufferPointer { dest in
                vector.withUnsafeBufferPointer { src in
                    vvexp2(dest.baseAddress!,
                           src.baseAddress!,
                           &n)
                }
            }
    }
  @inlinable public static func log2<U>(_ vector: U) -> [Swift.Float] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Float {
            
            let result = Array<Float>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                log2(vector,
                     result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func log2<U, V>(_ vector: U, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Float, V.Element == Swift.Float {
            
            precondition(vector.count == result.count)
            
            var n = Int32(vector.count)
            
            result.withUnsafeMutableBufferPointer { dest in
                vector.withUnsafeBufferPointer { src in
                    vvlog2f(dest.baseAddress!,
                            src.baseAddress!,
                            &n)
                }
            }
    }
  @inlinable public static func log10<U>(_ vector: U) -> [Swift.Float] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Float {
            
            let result = Array<Float>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                log10(vector,
                      result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func log10<U, V>(_ vector: U, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Float, V.Element == Swift.Float {
            
            precondition(vector.count == result.count)
            
            var n = Int32(vector.count)
            
            result.withUnsafeMutableBufferPointer { dest in
                vector.withUnsafeBufferPointer { src in
                    vvlog10f(dest.baseAddress!,
                             src.baseAddress!,
                             &n)
                }
            }
    }
  @inlinable public static func log2<U>(_ vector: U) -> [Swift.Double] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Double {
            
            let result = Array<Double>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                log2(vector,
                     result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func log2<U, V>(_ vector: U, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Double, V.Element == Swift.Double {
            
            precondition(vector.count == result.count)
            
            var n = Int32(vector.count)
            
            result.withUnsafeMutableBufferPointer { dest in
                vector.withUnsafeBufferPointer { src in
                    vvlog2(dest.baseAddress!,
                           src.baseAddress!,
                           &n)
                }
            }
    }
  @inlinable public static func log10<U>(_ vector: U) -> [Swift.Double] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Double {
            
            let result = Array<Double>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                log10(vector,
                      result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func log10<U, V>(_ vector: U, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Double, V.Element == Swift.Double {
            
            precondition(vector.count == result.count)
            
            var n = Int32(vector.count)
            
            result.withUnsafeMutableBufferPointer { dest in
                vector.withUnsafeBufferPointer { src in
                    vvlog10(dest.baseAddress!,
                            src.baseAddress!,
                            &n)
                }
            }
    }
  @inlinable public static func logb<U>(_ vector: U) -> [Swift.Float] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Float {
            
            let result = Array<Float>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                logb(vector,
                     result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func logb<U, V>(_ vector: U, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Float, V.Element == Swift.Float {
            
            precondition(vector.count == result.count)
            
            var n = Int32(vector.count)
            
            result.withUnsafeMutableBufferPointer { dest in
                vector.withUnsafeBufferPointer { src in
                    vvlogbf(dest.baseAddress!,
                            src.baseAddress!,
                            &n)
                }
            }
    }
  @inlinable public static func logb<U>(_ vector: U) -> [Swift.Double] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Double {
            
            let result = Array<Double>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                logb(vector,
                     result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func logb<U, V>(_ vector: U, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Double, V.Element == Swift.Double {
            
            precondition(vector.count == result.count)
            
            var n = Int32(vector.count)
            
            result.withUnsafeMutableBufferPointer { dest in
                vector.withUnsafeBufferPointer { src in
                    vvlogb(dest.baseAddress!,
                           src.baseAddress!,
                           &n)
                }
            }
    }
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Accelerate.vForce {
  @inlinable public static func pow<U, V>(bases: U, exponents: V) -> [Swift.Float] where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Float, V.Element == Swift.Float {
            
            precondition(bases.count == exponents.count)
            
            let result = Array<Float>(unsafeUninitializedCapacity: exponents.count) {
                buffer, initializedCount in
                
                pow(bases: bases,
                    exponents: exponents,
                    result: &buffer)
                
                initializedCount = exponents.count
            }
            
            return result
    }
  @inlinable public static func pow<T, U, V>(bases: T, exponents: U, result: inout V) where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, T.Element == Swift.Float, U.Element == Swift.Float, V.Element == Swift.Float {
            
            precondition(bases.count == exponents.count && exponents.count == result.count)
            
            var n = Int32(bases.count)
            
            result.withUnsafeMutableBufferPointer { dest in
                bases.withUnsafeBufferPointer { bases in
                    exponents.withUnsafeBufferPointer { exponents in
                        vvpowf(dest.baseAddress!,
                               exponents.baseAddress!,
                               bases.baseAddress!,
                               &n)
                    }
                }
            }
    }
  @inlinable public static func pow<U, V>(bases: U, exponents: V) -> [Swift.Double] where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Double, V.Element == Swift.Double {
            
            precondition(bases.count == exponents.count)
            
            let result = Array<Double>(unsafeUninitializedCapacity: exponents.count) {
                buffer, initializedCount in
                
                pow(bases: bases,
                    exponents: exponents,
                    result: &buffer)
                
                initializedCount = exponents.count
            }
            
            return result
    }
  @inlinable public static func pow<T, U, V>(bases: T, exponents: U, result: inout V) where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, T.Element == Swift.Double, U.Element == Swift.Double, V.Element == Swift.Double {
            
            precondition(bases.count == exponents.count && exponents.count == result.count)
            
            var n = Int32(bases.count)
            
            result.withUnsafeMutableBufferPointer { dest in
                bases.withUnsafeBufferPointer { bases in
                    exponents.withUnsafeBufferPointer { exponents in
                        vvpow(dest.baseAddress!,
                              exponents.baseAddress!,
                              bases.baseAddress!,
                              &n)
                    }
                }
            }
    }
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Accelerate.vForce {
  @inlinable public static func sin<U>(_ vector: U) -> [Swift.Float] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Float {
            
            let result = Array<Float>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                sin(vector,
                    result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func sin<U, V>(_ vector: U, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Float, V.Element == Swift.Float {
            
            precondition(vector.count == result.count)
            
            var n = Int32(vector.count)
            
            result.withUnsafeMutableBufferPointer { dest in
                vector.withUnsafeBufferPointer { src in
                    vvsinf(dest.baseAddress!,
                           src.baseAddress!,
                           &n)
                }
            }
    }
  @inlinable public static func sin<U>(_ vector: U) -> [Swift.Double] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Double {
            
            let result = Array<Double>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                sin(vector,
                    result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func sin<U, V>(_ vector: U, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Double, V.Element == Swift.Double {
            
            precondition(vector.count == result.count)
            
            var n = Int32(vector.count)
            
            result.withUnsafeMutableBufferPointer { dest in
                vector.withUnsafeBufferPointer { src in
                    vvsin(dest.baseAddress!,
                          src.baseAddress!,
                          &n)
                }
            }
    }
  @inlinable public static func sinPi<U>(_ vector: U) -> [Swift.Float] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Float {
            
            let result = Array<Float>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                sinPi(vector,
                      result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func sinPi<U, V>(_ vector: U, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Float, V.Element == Swift.Float {
            
            precondition(vector.count == result.count)
            
            var n = Int32(vector.count)
            
            result.withUnsafeMutableBufferPointer { dest in
                vector.withUnsafeBufferPointer { src in
                    vvsinpif(dest.baseAddress!,
                             src.baseAddress!,
                             &n)
                }
            }
    }
  @inlinable public static func sinPi<U>(_ vector: U) -> [Swift.Double] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Double {
            
            let result = Array<Double>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                sinPi(vector,
                      result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func sinPi<U, V>(_ vector: U, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Double, V.Element == Swift.Double {
            
            precondition(vector.count == result.count)
            
            var n = Int32(vector.count)
            
            result.withUnsafeMutableBufferPointer { dest in
                vector.withUnsafeBufferPointer { src in
                    vvsinpi(dest.baseAddress!,
                            src.baseAddress!,
                            &n)
                }
            }
    }
  @inlinable public static func cos<U>(_ vector: U) -> [Swift.Float] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Float {
            
            let result = Array<Float>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                cos(vector,
                    result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func cos<U, V>(_ vector: U, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Float, V.Element == Swift.Float {
            
            precondition(vector.count == result.count)
            
            var n = Int32(vector.count)
            
            result.withUnsafeMutableBufferPointer { dest in
                vector.withUnsafeBufferPointer { src in
                    vvcosf(dest.baseAddress!,
                           src.baseAddress!,
                           &n)
                }
            }
    }
  @inlinable public static func cos<U>(_ vector: U) -> [Swift.Double] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Double {
            
            let result = Array<Double>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                cos(vector,
                    result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func cos<U, V>(_ vector: U, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Double, V.Element == Swift.Double {
            
            precondition(vector.count == result.count)
            
            var n = Int32(vector.count)
            
            result.withUnsafeMutableBufferPointer { dest in
                vector.withUnsafeBufferPointer { src in
                    vvcos(dest.baseAddress!,
                          src.baseAddress!,
                          &n)
                }
            }
    }
  @inlinable public static func cosPi<U>(_ vector: U) -> [Swift.Float] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Float {
            
            let result = Array<Float>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                cosPi(vector,
                      result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func cosPi<U, V>(_ vector: U, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Float, V.Element == Swift.Float {
            
            precondition(vector.count == result.count)
            
            var n = Int32(vector.count)
            
            result.withUnsafeMutableBufferPointer { dest in
                vector.withUnsafeBufferPointer { src in
                    vvcospif(dest.baseAddress!,
                             src.baseAddress!,
                             &n)
                }
            }
    }
  @inlinable public static func cosPi<U>(_ vector: U) -> [Swift.Double] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Double {
            
            let result = Array<Double>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                cosPi(vector,
                      result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func cosPi<U, V>(_ vector: U, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Double, V.Element == Swift.Double {
            
            precondition(vector.count == result.count)
            
            var n = Int32(vector.count)
            
            result.withUnsafeMutableBufferPointer { dest in
                vector.withUnsafeBufferPointer { src in
                    vvcospi(dest.baseAddress!,
                            src.baseAddress!,
                            &n)
                }
            }
    }
  @inlinable public static func sincos<T, U, V>(_ vector: T, sinResult: inout U, cosResult: inout V) where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateMutableBuffer, V : Accelerate.AccelerateMutableBuffer, T.Element == Swift.Float, U.Element == Swift.Float, V.Element == Swift.Float {
            
            precondition(vector.count == sinResult.count && sinResult.count == cosResult.count)
            
            var n = Int32(vector.count)
            
            sinResult.withUnsafeMutableBufferPointer { sinDest in
                cosResult.withUnsafeMutableBufferPointer { cosDest in
                    vector.withUnsafeBufferPointer { src in
                        vvsincosf(sinDest.baseAddress!,
                                  cosDest.baseAddress!,
                                  src.baseAddress!,
                                  &n)
                    }
                }
            }
    }
  @inlinable public static func sincos<T, U, V>(_ vector: T, sinResult: inout U, cosResult: inout V) where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateMutableBuffer, V : Accelerate.AccelerateMutableBuffer, T.Element == Swift.Double, U.Element == Swift.Double, V.Element == Swift.Double {
            
            precondition(vector.count == sinResult.count && sinResult.count == cosResult.count)
            
            var n = Int32(vector.count)
            
            sinResult.withUnsafeMutableBufferPointer { sinDest in
                cosResult.withUnsafeMutableBufferPointer { cosDest in
                    vector.withUnsafeBufferPointer { src in
                        vvsincos(sinDest.baseAddress!,
                                 cosDest.baseAddress!,
                                 src.baseAddress!,
                                 &n)
                    }
                }
            }
    }
  @inlinable public static func tan<U>(_ vector: U) -> [Swift.Float] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Float {
            
            let result = Array<Float>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                tan(vector,
                    result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func tan<U, V>(_ vector: U, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Float, V.Element == Swift.Float {
            
            precondition(vector.count == result.count)
            
            var n = Int32(vector.count)
            
            result.withUnsafeMutableBufferPointer { dest in
                vector.withUnsafeBufferPointer { src in
                    vvtanf(dest.baseAddress!,
                           src.baseAddress!,
                           &n)
                }
            }
    }
  @inlinable public static func tan<U>(_ vector: U) -> [Swift.Double] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Double {
            
            let result = Array<Double>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                tan(vector,
                    result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func tan<U, V>(_ vector: U, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Double, V.Element == Swift.Double {
            
            precondition(vector.count == result.count)
            
            var n = Int32(vector.count)
            
            result.withUnsafeMutableBufferPointer { dest in
                vector.withUnsafeBufferPointer { src in
                    vvtan(dest.baseAddress!,
                          src.baseAddress!,
                          &n)
                }
            }
    }
  @inlinable public static func tanPi<U>(_ vector: U) -> [Swift.Float] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Float {
            
            let result = Array<Float>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                tanPi(vector,
                      result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func tanPi<U, V>(_ vector: U, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Float, V.Element == Swift.Float {
            
            precondition(vector.count == result.count)
            
            var n = Int32(vector.count)
            
            result.withUnsafeMutableBufferPointer { dest in
                vector.withUnsafeBufferPointer { src in
                    vvtanpif(dest.baseAddress!,
                             src.baseAddress!,
                             &n)
                }
            }
    }
  @inlinable public static func tanPi<U>(_ vector: U) -> [Swift.Double] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Double {
            
            let result = Array<Double>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                tanPi(vector,
                      result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func tanPi<U, V>(_ vector: U, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Double, V.Element == Swift.Double {
            
            precondition(vector.count == result.count)
            
            var n = Int32(vector.count)
            
            result.withUnsafeMutableBufferPointer { dest in
                vector.withUnsafeBufferPointer { src in
                    vvtanpi(dest.baseAddress!,
                            src.baseAddress!,
                            &n)
                }
            }
    }
  @inlinable public static func asin<U>(_ vector: U) -> [Swift.Float] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Float {
            
            let result = Array<Float>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                asin(vector,
                     result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func asin<U, V>(_ vector: U, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Float, V.Element == Swift.Float {
            
            precondition(vector.count == result.count)
            
            var n = Int32(vector.count)
            
            result.withUnsafeMutableBufferPointer { dest in
                vector.withUnsafeBufferPointer { src in
                    vvasinf(dest.baseAddress!,
                            src.baseAddress!,
                            &n)
                }
            }
    }
  @inlinable public static func asin<U>(_ vector: U) -> [Swift.Double] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Double {
            
            let result = Array<Double>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                asin(vector,
                     result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func asin<U, V>(_ vector: U, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Double, V.Element == Swift.Double {
            
            precondition(vector.count == result.count)
            
            var n = Int32(vector.count)
            
            result.withUnsafeMutableBufferPointer { dest in
                vector.withUnsafeBufferPointer { src in
                    vvasin(dest.baseAddress!,
                           src.baseAddress!,
                           &n)
                }
            }
    }
  @inlinable public static func acos<U>(_ vector: U) -> [Swift.Float] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Float {
            
            let result = Array<Float>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                acos(vector,
                     result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func acos<U, V>(_ vector: U, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Float, V.Element == Swift.Float {
            
            precondition(vector.count == result.count)
            
            var n = Int32(vector.count)
            
            result.withUnsafeMutableBufferPointer { dest in
                vector.withUnsafeBufferPointer { src in
                    vvacosf(dest.baseAddress!,
                            src.baseAddress!,
                            &n)
                }
            }
    }
  @inlinable public static func acos<U>(_ vector: U) -> [Swift.Double] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Double {
            
            let result = Array<Double>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                acos(vector,
                     result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func acos<U, V>(_ vector: U, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Double, V.Element == Swift.Double {
            
            precondition(vector.count == result.count)
            
            var n = Int32(vector.count)
            
            result.withUnsafeMutableBufferPointer { dest in
                vector.withUnsafeBufferPointer { src in
                    vvacos(dest.baseAddress!,
                           src.baseAddress!,
                           &n)
                }
            }
    }
  @inlinable public static func atan<U>(_ vector: U) -> [Swift.Float] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Float {
            
            let result = Array<Float>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                atan(vector,
                     result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func atan<U, V>(_ vector: U, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Float, V.Element == Swift.Float {
            
            precondition(vector.count == result.count)
            
            var n = Int32(vector.count)
            
            result.withUnsafeMutableBufferPointer { dest in
                vector.withUnsafeBufferPointer { src in
                    vvatanf(dest.baseAddress!,
                            src.baseAddress!,
                            &n)
                }
            }
    }
  @inlinable public static func atan<U>(_ vector: U) -> [Swift.Double] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Double {
            
            let result = Array<Double>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                atan(vector,
                     result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func atan<U, V>(_ vector: U, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Double, V.Element == Swift.Double {
            
            precondition(vector.count == result.count)
            
            var n = Int32(vector.count)
            
            result.withUnsafeMutableBufferPointer { dest in
                vector.withUnsafeBufferPointer { src in
                    vvatan(dest.baseAddress!,
                           src.baseAddress!,
                           &n)
                }
            }
    }
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Accelerate.vForce {
  @inlinable public static func sinh<U>(_ vector: U) -> [Swift.Float] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Float {
            
            let result = Array<Float>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                sinh(vector,
                     result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func sinh<U, V>(_ vector: U, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Float, V.Element == Swift.Float {
            
            precondition(vector.count == result.count)
            
            var n = Int32(vector.count)
            
            result.withUnsafeMutableBufferPointer { dest in
                vector.withUnsafeBufferPointer { src in
                    vvsinhf(dest.baseAddress!,
                            src.baseAddress!,
                            &n)
                }
            }
    }
  @inlinable public static func sinh<U>(_ vector: U) -> [Swift.Double] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Double {
            
            let result = Array<Double>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                sinh(vector,
                     result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func sinh<U, V>(_ vector: U, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Double, V.Element == Swift.Double {
            
            precondition(vector.count == result.count)
            
            var n = Int32(vector.count)
            
            result.withUnsafeMutableBufferPointer { dest in
                vector.withUnsafeBufferPointer { src in
                    vvsinh(dest.baseAddress!,
                           src.baseAddress!,
                           &n)
                }
            }
    }
  @inlinable public static func cosh<U>(_ vector: U) -> [Swift.Float] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Float {
            
            let result = Array<Float>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                cosh(vector,
                     result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func cosh<U, V>(_ vector: U, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Float, V.Element == Swift.Float {
            
            precondition(vector.count == result.count)
            
            var n = Int32(vector.count)
            
            result.withUnsafeMutableBufferPointer { dest in
                vector.withUnsafeBufferPointer { src in
                    vvcoshf(dest.baseAddress!,
                            src.baseAddress!,
                            &n)
                }
            }
    }
  @inlinable public static func cosh<U>(_ vector: U) -> [Swift.Double] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Double {
            
            let result = Array<Double>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                cosh(vector,
                     result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func cosh<U, V>(_ vector: U, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Double, V.Element == Swift.Double {
            
            precondition(vector.count == result.count)
            
            var n = Int32(vector.count)
            
            result.withUnsafeMutableBufferPointer { dest in
                vector.withUnsafeBufferPointer { src in
                    vvcosh(dest.baseAddress!,
                           src.baseAddress!,
                           &n)
                }
            }
    }
  @inlinable public static func tanh<U>(_ vector: U) -> [Swift.Float] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Float {
            
            let result = Array<Float>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                tanh(vector,
                     result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func tanh<U, V>(_ vector: U, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Float, V.Element == Swift.Float {
            
            precondition(vector.count == result.count)
            
            var n = Int32(vector.count)
            
            result.withUnsafeMutableBufferPointer { dest in
                vector.withUnsafeBufferPointer { src in
                    vvtanhf(dest.baseAddress!,
                            src.baseAddress!,
                            &n)
                }
            }
    }
  @inlinable public static func tanh<U>(_ vector: U) -> [Swift.Double] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Double {
            
            let result = Array<Double>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                tanh(vector,
                     result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func tanh<U, V>(_ vector: U, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Double, V.Element == Swift.Double {
            
            precondition(vector.count == result.count)
            
            var n = Int32(vector.count)
            
            result.withUnsafeMutableBufferPointer { dest in
                vector.withUnsafeBufferPointer { src in
                    vvtanh(dest.baseAddress!,
                           src.baseAddress!,
                           &n)
                }
            }
    }
  @inlinable public static func asinh<U>(_ vector: U) -> [Swift.Float] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Float {
            
            let result = Array<Float>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                asinh(vector,
                      result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func asinh<U, V>(_ vector: U, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Float, V.Element == Swift.Float {
            
            precondition(vector.count == result.count)
            
            var n = Int32(vector.count)
            
            result.withUnsafeMutableBufferPointer { dest in
                vector.withUnsafeBufferPointer { src in
                    vvasinhf(dest.baseAddress!,
                             src.baseAddress!,
                             &n)
                }
            }
    }
  @inlinable public static func asinh<U>(_ vector: U) -> [Swift.Double] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Double {
            
            let result = Array<Double>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                asinh(vector,
                      result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func asinh<U, V>(_ vector: U, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Double, V.Element == Swift.Double {
            
            precondition(vector.count == result.count)
            
            var n = Int32(vector.count)
            
            result.withUnsafeMutableBufferPointer { dest in
                vector.withUnsafeBufferPointer { src in
                    vvasinh(dest.baseAddress!,
                            src.baseAddress!,
                            &n)
                }
            }
    }
  @inlinable public static func acosh<U>(_ vector: U) -> [Swift.Float] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Float {
            
            let result = Array<Float>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                acosh(vector,
                      result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func acosh<U, V>(_ vector: U, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Float, V.Element == Swift.Float {
            
            precondition(vector.count == result.count)
            
            var n = Int32(vector.count)
            
            result.withUnsafeMutableBufferPointer { dest in
                vector.withUnsafeBufferPointer { src in
                    vvacoshf(dest.baseAddress!,
                             src.baseAddress!,
                             &n)
                }
            }
    }
  @inlinable public static func acosh<U>(_ vector: U) -> [Swift.Double] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Double {
            
            let result = Array<Double>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                acosh(vector,
                      result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func acosh<U, V>(_ vector: U, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Double, V.Element == Swift.Double {
            
            precondition(vector.count == result.count)
            
            var n = Int32(vector.count)
            
            result.withUnsafeMutableBufferPointer { dest in
                vector.withUnsafeBufferPointer { src in
                    vvacosh(dest.baseAddress!,
                            src.baseAddress!,
                            &n)
                }
            }
    }
  @inlinable public static func atanh<U>(_ vector: U) -> [Swift.Float] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Float {
            
            let result = Array<Float>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                atanh(vector,
                      result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func atanh<U, V>(_ vector: U, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Float, V.Element == Swift.Float {
            
            precondition(vector.count == result.count)
            
            var n = Int32(vector.count)
            
            result.withUnsafeMutableBufferPointer { dest in
                vector.withUnsafeBufferPointer { src in
                    vvatanhf(dest.baseAddress!,
                             src.baseAddress!,
                             &n)
                }
            }
    }
  @inlinable public static func atanh<U>(_ vector: U) -> [Swift.Double] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Double {
            
            let result = Array<Double>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                atanh(vector,
                      result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func atanh<U, V>(_ vector: U, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Double, V.Element == Swift.Double {
            
            precondition(vector.count == result.count)
            
            var n = Int32(vector.count)
            
            result.withUnsafeMutableBufferPointer { dest in
                vector.withUnsafeBufferPointer { src in
                    vvatanh(dest.baseAddress!,
                            src.baseAddress!,
                            &n)
                }
            }
    }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Accelerate.BNNS {
  public struct FusedUnaryArithmeticParameters : Accelerate.FusableLayerParameters {
    public var inputDescriptorType: Accelerate.BNNS.DescriptorType
    public var outputDescriptorType: Accelerate.BNNS.DescriptorType
    public var function: Accelerate.BNNS.ArithmeticUnaryFunction
    public init(inputDescriptorType: Accelerate.BNNS.DescriptorType, outputDescriptorType: Accelerate.BNNS.DescriptorType, function: Accelerate.BNNS.ArithmeticUnaryFunction)
  }
}
@available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
extension Accelerate.BNNS {
  public static func copy(_ source: Accelerate.BNNSNDArrayDescriptor, to destination: Accelerate.BNNSNDArrayDescriptor, filterParameters: Accelerate.BNNSFilterParameters? = nil) throws
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Accelerate.BNNS {
  public struct FusedQuantizationParameters : Accelerate.FusableLayerParameters {
    public init(scale: Accelerate.BNNSNDArrayDescriptor?, bias: Accelerate.BNNSNDArrayDescriptor?)
    public var axis: Swift.Int?
    public var scale: Accelerate.BNNSNDArrayDescriptor?
    public var bias: Accelerate.BNNSNDArrayDescriptor?
  }
  public struct FusedDequantizationParameters : Accelerate.FusableLayerParameters {
    public init(scale: Accelerate.BNNSNDArrayDescriptor?, bias: Accelerate.BNNSNDArrayDescriptor?)
    public var axis: Swift.Int?
    public var scale: Accelerate.BNNSNDArrayDescriptor?
    public var bias: Accelerate.BNNSNDArrayDescriptor?
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
public protocol FusableLayerParameters {
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Accelerate.BNNS {
  @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class FusedParametersLayer : Accelerate.BNNS.FusedLayer {
    convenience public init?(input: Accelerate.BNNSNDArrayDescriptor, output: Accelerate.BNNSNDArrayDescriptor, fusedLayerParameters: [Accelerate.FusableLayerParameters], filterParameters: Accelerate.BNNSFilterParameters? = nil)
    @objc deinit
  }
}
@available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
extension Accelerate.BNNS {
  public enum PaddingMode {
    case constantBitPattern(Swift.UInt32)
    case constantScalar(Swift.Float)
    case reflect
    case symmetric
    public var bnnsPaddingMode: Accelerate.BNNSPaddingMode {
      get
    }
    public var paddingBitPattern: Swift.UInt32 {
      get
    }
  }
  @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class PaddingLayer : Accelerate.BNNS.UnaryLayer {
    convenience public init?(input: Accelerate.BNNSNDArrayDescriptor, output: Accelerate.BNNSNDArrayDescriptor, mode: Accelerate.BNNS.PaddingMode, size: [(x: Swift.Int, y: Swift.Int)], filterParameters: Accelerate.BNNSFilterParameters? = nil)
    @objc deinit
  }
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Accelerate.vDSP {
  @inlinable public static func slidingWindowSum<U>(_ vector: U, usingWindowLength windowLength: Swift.Int) -> [Swift.Float] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Float {
            
            let n = vector.count - windowLength + 1
            
            let result = Array<Float>(unsafeUninitializedCapacity: n) {
                buffer, initializedCount in
                
                slidingWindowSum(vector,
                                 usingWindowLength: windowLength,
                                 result: &buffer)
                
                initializedCount = n
            }
            
            return result
    }
  @inlinable public static func slidingWindowSum<U, V>(_ vector: U, usingWindowLength windowLength: Swift.Int, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Float, V.Element == Swift.Float {
            
            let n = result.count
            precondition(vector.count == n + windowLength - 1)
            
            result.withUnsafeMutableBufferPointer { dest in
                vector.withUnsafeBufferPointer { src in
                    vDSP_vswsum(src.baseAddress!, 1,
                                dest.baseAddress!, 1,
                                vDSP_Length(n),
                                vDSP_Length(windowLength))
                }
            }
            
    }
  @inlinable public static func slidingWindowSum<U>(_ vector: U, usingWindowLength windowLength: Swift.Int) -> [Swift.Double] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Double {
            
            let n = vector.count - windowLength + 1
            
            let result = Array<Double>(unsafeUninitializedCapacity: n) {
                buffer, initializedCount in
                
                slidingWindowSum(vector,
                                 usingWindowLength: windowLength,
                                 result: &buffer)
                
                initializedCount = n
            }
            
            return result
    }
  @inlinable public static func slidingWindowSum<U, V>(_ vector: U, usingWindowLength windowLength: Swift.Int, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Double, V.Element == Swift.Double {
            
            let n = result.count
            precondition(vector.count == n + windowLength - 1)
            
            result.withUnsafeMutableBufferPointer { dest in
                vector.withUnsafeBufferPointer { src in
                    vDSP_vswsumD(src.baseAddress!, 1,
                                 dest.baseAddress!, 1,
                                 vDSP_Length(n),
                                 vDSP_Length(windowLength))
                }
            }
            
    }
}
@available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
extension Accelerate.vForce {
  @inlinable public static func log<U>(_ vector: U) -> [Swift.Float] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Float {
        
        let result = Array<Float>(unsafeUninitializedCapacity: vector.count) {
            buffer, initializedCount in
            
            log(vector,
                result: &buffer)
            
            initializedCount = vector.count
        }
        
        return result
    }
  @inlinable public static func log<U, V>(_ vector: U, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Float, V.Element == Swift.Float {
        
        precondition(vector.count == result.count)
        
        var n = Int32(vector.count)
        
        result.withUnsafeMutableBufferPointer { dest in
            vector.withUnsafeBufferPointer { src in
                vvlogf(dest.baseAddress!,
                       src.baseAddress!,
                       &n)
            }
        }
    }
  @inlinable public static func log<U>(_ vector: U) -> [Swift.Double] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Double {
        
        let result = Array<Double>(unsafeUninitializedCapacity: vector.count) {
            buffer, initializedCount in
            
            log(vector,
                result: &buffer)
            
            initializedCount = vector.count
        }
        
        return result
    }
  @inlinable public static func log<U, V>(_ vector: U, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Double, V.Element == Swift.Double {
        
        precondition(vector.count == result.count)
        
        var n = Int32(vector.count)
        
        result.withUnsafeMutableBufferPointer { dest in
            vector.withUnsafeBufferPointer { src in
                vvlog(dest.baseAddress!,
                      src.baseAddress!,
                      &n)
            }
        }
    }
  @inlinable public static func log1p<U>(_ vector: U) -> [Swift.Float] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Float {
        
        let result = Array<Float>(unsafeUninitializedCapacity: vector.count) {
            buffer, initializedCount in
            
            log1p(vector,
                  result: &buffer)
            
            initializedCount = vector.count
        }
        
        return result
    }
  @inlinable public static func log1p<U, V>(_ vector: U, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Float, V.Element == Swift.Float {
        
        precondition(vector.count == result.count)
        
        var n = Int32(vector.count)
        
        result.withUnsafeMutableBufferPointer { dest in
            vector.withUnsafeBufferPointer { src in
                vvlog1pf(dest.baseAddress!,
                         src.baseAddress!,
                         &n)
            }
        }
    }
  @inlinable public static func log1p<U>(_ vector: U) -> [Swift.Double] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Double {
        
        let result = Array<Double>(unsafeUninitializedCapacity: vector.count) {
            buffer, initializedCount in
            
            log1p(vector,
                  result: &buffer)
            
            initializedCount = vector.count
        }
        
        return result
    }
  @inlinable public static func log1p<U, V>(_ vector: U, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Double, V.Element == Swift.Double {
        
        precondition(vector.count == result.count)
        
        var n = Int32(vector.count)
        
        result.withUnsafeMutableBufferPointer { dest in
            vector.withUnsafeBufferPointer { src in
                vvlog1p(dest.baseAddress!,
                        src.baseAddress!,
                        &n)
            }
        }
    }
  @inlinable public static func atan2<T, U, V>(x: T, y: U, result: inout V) where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, T.Element == Swift.Float, U.Element == Swift.Float, V.Element == Swift.Float {
        
        precondition(x.count == result.count && y.count == result.count)
        
        var n = Int32(result.count)
        
        result.withUnsafeMutableBufferPointer { dest in
            x.withUnsafeBufferPointer { xPtr in
                y.withUnsafeBufferPointer { yPtr in
                    vvatan2f(dest.baseAddress!,
                             yPtr.baseAddress!,
                             xPtr.baseAddress!,
                             &n)
                }
            }
        }
    }
  @inlinable public static func atan2<U, V>(x: U, y: V) -> [Swift.Float] where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Float, V.Element == Swift.Float {
        
        precondition(x.count == y.count)
        
        let result = Array<Float>(unsafeUninitializedCapacity: x.count) {
            buffer, initializedCount in
            
            atan2(x: x,
                  y: y,
                  result: &buffer)
            
            initializedCount = x.count
        }
        
        return result
    }
  @inlinable public static func atan2<T, U, V>(x: T, y: U, result: inout V) where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, T.Element == Swift.Double, U.Element == Swift.Double, V.Element == Swift.Double {
        
        precondition(x.count == result.count && y.count == result.count)
        
        var n = Int32(result.count)
        
        result.withUnsafeMutableBufferPointer { dest in
            x.withUnsafeBufferPointer { xPtr in
                y.withUnsafeBufferPointer { yPtr in
                    vvatan2(dest.baseAddress!,
                            yPtr.baseAddress!,
                            xPtr.baseAddress!,
                            &n)
                }
            }
        }
    }
  @inlinable public static func atan2<U, V>(x: U, y: V) -> [Swift.Double] where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Double, V.Element == Swift.Double {
        
        precondition(x.count == y.count)
        
        let result = Array<Double>(unsafeUninitializedCapacity: x.count) {
            buffer, initializedCount in
            
            atan2(x: x,
                  y: y,
                  result: &buffer)
            
            initializedCount = x.count
        }
        
        return result
    }
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Accelerate.vDSP {
  public enum FourierTransformDirection {
    case forward
    case inverse
    public var dftDirection: Accelerate.vDSP_DFT_Direction {
      get
    }
    public var fftDirection: Accelerate.FFTDirection {
      get
    }
    public static func == (a: Accelerate.vDSP.FourierTransformDirection, b: Accelerate.vDSP.FourierTransformDirection) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Accelerate.vDSP {
  @inlinable public static func twoPoleTwoZeroFilter<U>(_ source: U, coefficients: (Swift.Float, Swift.Float, Swift.Float, Swift.Float, Swift.Float)) -> [Swift.Float] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Float {
            
            let result = Array<Float>(unsafeUninitializedCapacity: source.count) {
                buffer, initializedCount in
                
                buffer[0] = 0
                buffer[1] = 0
                
                twoPoleTwoZeroFilter(source,
                                     coefficients: coefficients,
                                     result: &buffer)
                
                initializedCount = source.count
            }
            
            return result
    }
  @inlinable public static func twoPoleTwoZeroFilter<U, V>(_ source: U, coefficients: (Swift.Float, Swift.Float, Swift.Float, Swift.Float, Swift.Float), result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Float, V.Element == Swift.Float {
            
            precondition(source.count == result.count)
            
            let n = vDSP_Length(source.count - 2)
            
            result.withUnsafeMutableBufferPointer { dest in
                source.withUnsafeBufferPointer { src in
                    vDSP_deq22(src.baseAddress!, 1,
                               [coefficients.0, coefficients.1,
                                coefficients.2, coefficients.3,
                                coefficients.4],
                               dest.baseAddress!, 1,
                               n)
                }
            }
    }
  @inlinable public static func twoPoleTwoZeroFilter<U>(_ source: U, coefficients: (Swift.Double, Swift.Double, Swift.Double, Swift.Double, Swift.Double)) -> [Swift.Double] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Double {
            
            let result = Array<Double>(unsafeUninitializedCapacity: source.count) {
                buffer, initializedCount in
                
                buffer[0] = 0
                buffer[1] = 0
                
                twoPoleTwoZeroFilter(source,
                                     coefficients: coefficients,
                                     result: &buffer)
                
                initializedCount = source.count
            }
            
            return result
    }
  @inlinable public static func twoPoleTwoZeroFilter<U, V>(_ source: U, coefficients: (Swift.Double, Swift.Double, Swift.Double, Swift.Double, Swift.Double), result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Double, V.Element == Swift.Double {
            
            precondition(source.count == result.count)
            
            let n = vDSP_Length(source.count - 2)
            
            result.withUnsafeMutableBufferPointer { dest in
                source.withUnsafeBufferPointer { src in
                    vDSP_deq22D(src.baseAddress!, 1,
                                [coefficients.0, coefficients.1,
                                 coefficients.2, coefficients.3,
                                 coefficients.4],
                                dest.baseAddress!, 1,
                                n)
                }
            }
    }
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Accelerate.vDSP {
  @inlinable public static func minimum<U>(_ vectorA: U, _ vectorB: U) -> [Swift.Float] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Float {
            precondition(vectorA.count == vectorB.count)
            
            let result = Array<Float>(unsafeUninitializedCapacity: vectorA.count) {
                buffer, initializedCount in
                
                minimum(vectorA,
                        vectorB,
                        result: &buffer)
                
                initializedCount = vectorA.count
            }
            
            return result
    }
  @inlinable public static func minimum<U, V>(_ vectorA: U, _ vectorB: U, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Float, V.Element == Swift.Float {
            
            let n = vDSP_Length(min(vectorA.count,
                                    vectorB.count,
                                    result.count))
            
            result.withUnsafeMutableBufferPointer { r in
                vectorA.withUnsafeBufferPointer { a in
                    vectorB.withUnsafeBufferPointer { b in
                        vDSP_vmin(a.baseAddress!, 1,
                                  b.baseAddress!, 1,
                                  r.baseAddress!, 1,
                                  n)
                    }
                }
            }
    }
  @inlinable public static func minimum<U>(_ vectorA: U, _ vectorB: U) -> [Swift.Double] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Double {
            precondition(vectorA.count == vectorB.count)
            
            let result = Array<Double>(unsafeUninitializedCapacity: vectorA.count) {
                buffer, initializedCount in
                
                minimum(vectorA,
                        vectorB,
                        result: &buffer)
                
                initializedCount = vectorA.count
            }
            
            return result
    }
  @inlinable public static func minimum<U, V>(_ vectorA: U, _ vectorB: U, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Double, V.Element == Swift.Double {
            
            let n = vDSP_Length(min(vectorA.count,
                                    vectorB.count,
                                    result.count))
            
            result.withUnsafeMutableBufferPointer { r in
                vectorA.withUnsafeBufferPointer { a in
                    vectorB.withUnsafeBufferPointer { b in
                        vDSP_vminD(a.baseAddress!, 1,
                                   b.baseAddress!, 1,
                                   r.baseAddress!, 1,
                                   n)
                    }
                }
            }
    }
  @inlinable public static func maximum<U>(_ vectorA: U, _ vectorB: U) -> [Swift.Float] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Float {
            precondition(vectorA.count == vectorB.count)
            
            let result = Array<Float>(unsafeUninitializedCapacity: vectorA.count) {
                buffer, initializedCount in
                
                maximum(vectorA,
                        vectorB,
                        result: &buffer)
                
                initializedCount = vectorA.count
            }
            
            return result
    }
  @inlinable public static func maximum<U, V>(_ vectorA: U, _ vectorB: U, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Float, V.Element == Swift.Float {
            
            let n = vDSP_Length(min(vectorA.count,
                                    vectorB.count,
                                    result.count))
            
            result.withUnsafeMutableBufferPointer { r in
                vectorA.withUnsafeBufferPointer { a in
                    vectorB.withUnsafeBufferPointer { b in
                        vDSP_vmax(a.baseAddress!, 1,
                                  b.baseAddress!, 1,
                                  r.baseAddress!, 1,
                                  n)
                    }
                }
            }
    }
  @inlinable public static func maximum<U>(_ vectorA: U, _ vectorB: U) -> [Swift.Double] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Double {
            precondition(vectorA.count == vectorB.count)
            
            let result = Array<Double>(unsafeUninitializedCapacity: vectorA.count) {
                buffer, initializedCount in
                
                maximum(vectorA,
                        vectorB,
                        result: &buffer)
                
                initializedCount = vectorA.count
            }
            
            return result
    }
  @inlinable public static func maximum<U, V>(_ vectorA: U, _ vectorB: U, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Double, V.Element == Swift.Double {
            
            let n = vDSP_Length(min(vectorA.count,
                                    vectorB.count,
                                    result.count))
            
            result.withUnsafeMutableBufferPointer { r in
                vectorA.withUnsafeBufferPointer { a in
                    vectorB.withUnsafeBufferPointer { b in
                        vDSP_vmaxD(a.baseAddress!, 1,
                                   b.baseAddress!, 1,
                                   r.baseAddress!, 1,
                                   n)
                    }
                }
            }
    }
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Accelerate.vDSP {
  @inlinable public static func absolute<U>(_ vector: U) -> [Swift.Float] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Float {
            
            let result = Array<Float>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                absolute(vector,
                         result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func absolute<U, V>(_ vector: U, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Float, V.Element == Swift.Float {
            
            let n = result.count
            precondition(vector.count == n)
            result.withUnsafeMutableBufferPointer { r in
                vector.withUnsafeBufferPointer { v in
                    vDSP_vabs(v.baseAddress!, 1,
                              r.baseAddress!, 1,
                              vDSP_Length(n))
                }
            }
            
    }
  @inlinable public static func absolute<U>(_ vector: U) -> [Swift.Double] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Double {
            
            let result = Array<Double>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                absolute(vector,
                         result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func absolute<U, V>(_ vector: U, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Double, V.Element == Swift.Double {
            
            let n = result.count
            precondition(vector.count == n)
            result.withUnsafeMutableBufferPointer { r in
                vector.withUnsafeBufferPointer { v in
                    vDSP_vabsD(v.baseAddress!, 1,
                               r.baseAddress!, 1,
                               vDSP_Length(n))
                }
            }
    }
  @inlinable public static func negativeAbsolute<U>(_ vector: U) -> [Swift.Float] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Float {
            
            let result = Array<Float>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                negativeAbsolute(vector,
                                 result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func negativeAbsolute<U, V>(_ vector: U, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Float, V.Element == Swift.Float {
            
            let n = result.count
            precondition(vector.count == n)
            result.withUnsafeMutableBufferPointer { r in
                vector.withUnsafeBufferPointer { v in
                    vDSP_vnabs(v.baseAddress!, 1,
                               r.baseAddress!, 1,
                               vDSP_Length(n))
                }
            }
    }
  @inlinable public static func negativeAbsolute<U>(_ vector: U) -> [Swift.Double] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Double {
            
            let result = Array<Double>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                negativeAbsolute(vector,
                                 result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func negativeAbsolute<U, V>(_ vector: U, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Double, V.Element == Swift.Double {
            
            let n = result.count
            precondition(vector.count == n)
            result.withUnsafeMutableBufferPointer { r in
                vector.withUnsafeBufferPointer { v in
                    vDSP_vnabsD(v.baseAddress!, 1,
                                r.baseAddress!, 1,
                                vDSP_Length(n))
                }
            }
    }
  @inlinable public static func negative<U>(_ vector: U) -> [Swift.Float] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Float {
            
            let result = Array<Float>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                negative(vector,
                         result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func negative<U, V>(_ vector: U, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Float, V.Element == Swift.Float {
            
            let n = result.count
            precondition(vector.count == n)
            result.withUnsafeMutableBufferPointer { r in
                vector.withUnsafeBufferPointer { v in
                    vDSP_vneg(v.baseAddress!, 1,
                              r.baseAddress!, 1,
                              vDSP_Length(n))
                }
            }
    }
  @inlinable public static func negative<U>(_ vector: U) -> [Swift.Double] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Double {
            
            let result = Array<Double>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                negative(vector,
                         result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func negative<U, V>(_ vector: U, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Double, V.Element == Swift.Double {
            
            let n = result.count
            precondition(vector.count == n)
            result.withUnsafeMutableBufferPointer { r in
                vector.withUnsafeBufferPointer { v in
                    vDSP_vnegD(v.baseAddress!, 1,
                               r.baseAddress!, 1,
                               vDSP_Length(n))
                }
            }
    }
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Accelerate.vDSP {
  @inlinable public static func reverse<V>(_ vector: inout V) where V : Accelerate.AccelerateMutableBuffer, V.Element == Swift.Float {
            
            let n = vDSP_Length(vector.count)
            
            vector.withUnsafeMutableBufferPointer { v in
                vDSP_vrvrs(v.baseAddress!, 1,
                           n)
            }
    }
  @inlinable public static func reverse<V>(_ vector: inout V) where V : Accelerate.AccelerateMutableBuffer, V.Element == Swift.Double {
            
            let n = vDSP_Length(vector.count)
            
            vector.withUnsafeMutableBufferPointer { v in
                vDSP_vrvrsD(v.baseAddress!, 1,
                            n)
            }
    }
  public enum SortOrder : Swift.Int32 {
    case ascending
    case descending
    public init?(rawValue: Swift.Int32)
    public typealias RawValue = Swift.Int32
    public var rawValue: Swift.Int32 {
      get
    }
  }
  @inlinable public static func sort<V>(_ vector: inout V, sortOrder: Accelerate.vDSP.SortOrder) where V : Accelerate.AccelerateMutableBuffer, V.Element == Swift.Float {
            
            let n = vDSP_Length(vector.count)
            
            vector.withUnsafeMutableBufferPointer { v in
                vDSP_vsort(v.baseAddress!,
                           n,
                           sortOrder.rawValue)
            }
    }
  @inlinable public static func sort<V>(_ vector: inout V, sortOrder: Accelerate.vDSP.SortOrder) where V : Accelerate.AccelerateMutableBuffer, V.Element == Swift.Double {
            
            let n = vDSP_Length(vector.count)
            
            vector.withUnsafeMutableBufferPointer { v in
                vDSP_vsortD(v.baseAddress!,
                            n,
                            sortOrder.rawValue)
            }
    }
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Accelerate.vDSP {
  @inlinable public static func square<U>(_ vector: U) -> [Swift.Float] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Float {
            
            let result = Array<Float>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                square(vector,
                       result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func square<U, V>(_ vector: U, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Float, V.Element == Swift.Float {
            
            precondition(vector.count == result.count)
            
            let n = vDSP_Length(vector.count)
            
            result.withUnsafeMutableBufferPointer { dest in
                vector.withUnsafeBufferPointer { src in
                    vDSP_vsq(src.baseAddress!, 1,
                             dest.baseAddress!, 1,
                             n)
                }
            }
    }
  @inlinable public static func square<U>(_ vector: U) -> [Swift.Double] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Double {
            
            let result = Array<Double>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                square(vector,
                       result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func square<U, V>(_ vector: U, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Double, V.Element == Swift.Double {
            
            precondition(vector.count == result.count)
            
            let n = vDSP_Length(vector.count)
            
            result.withUnsafeMutableBufferPointer { dest in
                vector.withUnsafeBufferPointer { src in
                    vDSP_vsqD(src.baseAddress!, 1,
                              dest.baseAddress!, 1,
                              n)
                }
            }
    }
  @inlinable public static func signedSquare<U>(_ vector: U) -> [Swift.Float] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Float {
            
            let result = Array<Float>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                signedSquare(vector,
                             result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func signedSquare<U, V>(_ vector: U, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Float, V.Element == Swift.Float {
            
            precondition(vector.count == result.count)
            
            let n = vDSP_Length(vector.count)
            
            result.withUnsafeMutableBufferPointer { dest in
                vector.withUnsafeBufferPointer { src in
                    vDSP_vssq(src.baseAddress!, 1,
                              dest.baseAddress!, 1,
                              n)
                }
            }
    }
  @inlinable public static func signedSquare<U>(_ vector: U) -> [Swift.Double] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Double {
            
            let result = Array<Double>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                signedSquare(vector,
                             result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func signedSquare<U, V>(_ vector: U, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Double, V.Element == Swift.Double {
            
            precondition(vector.count == result.count)
            
            let n = vDSP_Length(vector.count)
            
            result.withUnsafeMutableBufferPointer { dest in
                vector.withUnsafeBufferPointer { src in
                    vDSP_vssqD(src.baseAddress!, 1,
                               dest.baseAddress!, 1,
                               n)
                }
            }
    }
  @inlinable public static func trunc<U>(_ vector: U) -> [Swift.Float] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Float {
            
            let result = Array<Float>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                trunc(vector,
                      result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func trunc<U, V>(_ vector: U, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Float, V.Element == Swift.Float {
            
            precondition(vector.count == result.count)
            
            let n = vDSP_Length(vector.count)
            
            result.withUnsafeMutableBufferPointer { dest in
                vector.withUnsafeBufferPointer { src in
                    vDSP_vfrac(src.baseAddress!, 1,
                               dest.baseAddress!, 1,
                               n)
                }
            }
    }
  @inlinable public static func trunc<U>(_ vector: U) -> [Swift.Double] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Double {
            
            let result = Array<Double>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                trunc(vector,
                      result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func trunc<U, V>(_ vector: U, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Double, V.Element == Swift.Double {
            
            precondition(vector.count == result.count)
            
            let n = vDSP_Length(vector.count)
            
            result.withUnsafeMutableBufferPointer { dest in
                vector.withUnsafeBufferPointer { src in
                    vDSP_vfracD(src.baseAddress!, 1,
                                dest.baseAddress!, 1,
                                n)
                }
            }
    }
  @inlinable public static func countZeroCrossings<U>(_ vector: U) -> Swift.UInt where U : Accelerate.AccelerateBuffer, U.Element == Swift.Float {
            
            let n = vDSP_Length(vector.count)
            var crossingCount: vDSP_Length = 0
            var lastCrossingIndex: vDSP_Length = 0
            
            vector.withUnsafeBufferPointer { src in
                vDSP_nzcros(src.baseAddress!, 1,
                            n,
                            &lastCrossingIndex,
                            &crossingCount,
                            n)
            }
            
            return crossingCount
    }
  @inlinable public static func countZeroCrossings<U>(_ vector: U) -> Swift.UInt where U : Accelerate.AccelerateBuffer, U.Element == Swift.Double {
            
            let n = vDSP_Length(vector.count)
            var crossingCount: vDSP_Length = 0
            var lastCrossingIndex: vDSP_Length = 0
            
            vector.withUnsafeBufferPointer { src in
                vDSP_nzcrosD(src.baseAddress!, 1,
                             n,
                             &lastCrossingIndex,
                             &crossingCount,
                             n)
            }
            
            return crossingCount
    }
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Accelerate.vImage_CGImageFormat {
  public init?(cgImage: CoreGraphics.CGImage)
  public init?(bitsPerComponent: Swift.Int, bitsPerPixel: Swift.Int, colorSpace: CoreGraphics.CGColorSpace, bitmapInfo: CoreGraphics.CGBitmapInfo, renderingIntent: CoreGraphics.CGColorRenderingIntent = .defaultIntent)
  public var componentCount: Swift.Int {
    get
  }
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Accelerate.vDSP {
  @inlinable public static func phase<V>(_ splitComplex: Accelerate.DSPSplitComplex, result: inout V) where V : Accelerate.AccelerateMutableBuffer, V.Element == Swift.Float {
            
            let n = vDSP_Length(result.count)
            
            result.withUnsafeMutableBufferPointer { dest in
                withUnsafePointer(to: splitComplex) { src in
                    vDSP_zvphas(src, 1,
                                dest.baseAddress!, 1,
                                n)
                }
            }
    }
  @inlinable public static func phase<V>(_ splitComplex: Accelerate.DSPDoubleSplitComplex, result: inout V) where V : Accelerate.AccelerateMutableBuffer, V.Element == Swift.Double {
            
            let n = vDSP_Length(result.count)
            
            result.withUnsafeMutableBufferPointer { dest in
                withUnsafePointer(to: splitComplex) { src in
                    vDSP_zvphasD(src, 1,
                                 dest.baseAddress!, 1,
                                 n)
                }
            }
    }
  @inlinable public static func copy(_ source: Accelerate.DSPSplitComplex, to destination: inout Accelerate.DSPSplitComplex, count: Swift.Int) {
        
        let n = vDSP_Length(count)
        
        withUnsafePointer(to: source) { src in
            vDSP_zvmov(src, 1,
                       &destination, 1,
                       n)
        }
    }
  @inlinable public static func copy(_ source: Accelerate.DSPDoubleSplitComplex, to destination: inout Accelerate.DSPDoubleSplitComplex, count: Swift.Int) {
        
        let n = vDSP_Length(count)
        
        withUnsafePointer(to: source) { src in
            vDSP_zvmovD(src, 1,
                        &destination, 1,
                        n)
        }
    }
  @inlinable public static func conjugate(_ splitComplex: Accelerate.DSPSplitComplex, count: Swift.Int, result: inout Accelerate.DSPSplitComplex) {
        
        withUnsafePointer(to: splitComplex) { a in
            vDSP_zvconj(a, 1,
                        &result, 1,
                        vDSP_Length(count))
        }
    }
  @inlinable public static func conjugate(_ splitComplex: Accelerate.DSPDoubleSplitComplex, count: Swift.Int, result: inout Accelerate.DSPDoubleSplitComplex) {
        
        withUnsafePointer(to: splitComplex) { a in
            vDSP_zvconjD(a, 1,
                         &result, 1,
                         vDSP_Length(count))
        }
    }
  @inlinable public static func divide<U>(_ splitComplex: Accelerate.DSPSplitComplex, by vector: U, result: inout Accelerate.DSPSplitComplex) where U : Accelerate.AccelerateBuffer, U.Element == Swift.Float {
            
            withUnsafePointer(to: splitComplex) { a in
                vector.withUnsafeBufferPointer { b in
                    vDSP_zrvdiv(a, 1,
                                b.baseAddress!, 1,
                                &result, 1,
                                vDSP_Length(vector.count))
                }
            }
    }
  @inlinable public static func divide<U>(_ splitComplex: Accelerate.DSPDoubleSplitComplex, by vector: U, result: inout Accelerate.DSPDoubleSplitComplex) where U : Accelerate.AccelerateBuffer, U.Element == Swift.Double {
            
            withUnsafePointer(to: splitComplex) { a in
                vector.withUnsafeBufferPointer { b in
                    vDSP_zrvdivD(a, 1,
                                 b.baseAddress!, 1,
                                 &result, 1,
                                 vDSP_Length(vector.count))
                }
            }
    }
  @inlinable public static func multiply<U>(_ splitComplex: Accelerate.DSPSplitComplex, by vector: U, result: inout Accelerate.DSPSplitComplex) where U : Accelerate.AccelerateBuffer, U.Element == Swift.Float {
            
            withUnsafePointer(to: splitComplex) { a in
                vector.withUnsafeBufferPointer { b in
                    vDSP_zrvmul(a, 1,
                                b.baseAddress!, 1,
                                &result, 1,
                                vDSP_Length(vector.count))
                }
            }
    }
  @inlinable public static func multiply<U>(_ splitComplex: Accelerate.DSPDoubleSplitComplex, by vector: U, result: inout Accelerate.DSPDoubleSplitComplex) where U : Accelerate.AccelerateBuffer, U.Element == Swift.Double {
            
            withUnsafePointer(to: splitComplex) { a in
                vector.withUnsafeBufferPointer { b in
                    vDSP_zrvmulD(a, 1,
                                 b.baseAddress!, 1,
                                 &result, 1,
                                 vDSP_Length(vector.count))
                }
            }
    }
  @inlinable public static func multiply(_ splitComplexA: Accelerate.DSPSplitComplex, by splitComplexB: Accelerate.DSPSplitComplex, count: Swift.Int, useConjugate: Swift.Bool, result: inout Accelerate.DSPSplitComplex) {
        
        let conjugate: Int32 = useConjugate ? -1 : 1
        
        withUnsafePointer(to: splitComplexA) { a in
            withUnsafePointer(to: splitComplexB) { b in
                vDSP_zvmul(a, 1,
                           b, 1,
                           &result, 1,
                           vDSP_Length(count),
                           conjugate)
            }
        }
    }
  @inlinable public static func multiply(_ splitComplexA: Accelerate.DSPDoubleSplitComplex, by splitComplexB: Accelerate.DSPDoubleSplitComplex, count: Swift.Int, useConjugate: Swift.Bool, result: inout Accelerate.DSPDoubleSplitComplex) {
        
        let conjugate: Int32 = useConjugate ? -1 : 1
        
        withUnsafePointer(to: splitComplexA) { a in
            withUnsafePointer(to: splitComplexB) { b in
                vDSP_zvmulD(a, 1,
                            b, 1,
                            &result, 1,
                            vDSP_Length(count),
                            conjugate)
            }
        }
    }
  @inlinable public static func add(_ splitComplexA: Accelerate.DSPSplitComplex, to splitComplexB: Accelerate.DSPSplitComplex, count: Swift.Int, result: inout Accelerate.DSPSplitComplex) {
        
        withUnsafePointer(to: splitComplexA) { a in
            withUnsafePointer(to: splitComplexB) { b in
                vDSP_zvadd(a, 1,
                           b, 1,
                           &result, 1,
                           vDSP_Length(count))
            }
        }
    }
  @inlinable public static func add(_ splitComplexA: Accelerate.DSPDoubleSplitComplex, to splitComplexB: Accelerate.DSPDoubleSplitComplex, count: Swift.Int, result: inout Accelerate.DSPDoubleSplitComplex) {
        
        withUnsafePointer(to: splitComplexA) { a in
            withUnsafePointer(to: splitComplexB) { b in
                vDSP_zvaddD(a, 1,
                            b, 1,
                            &result, 1,
                            vDSP_Length(count))
            }
        }
    }
  @inlinable public static func divide(_ splitComplexA: Accelerate.DSPSplitComplex, by splitComplexB: Accelerate.DSPSplitComplex, count: Swift.Int, result: inout Accelerate.DSPSplitComplex) {
        
        withUnsafePointer(to: splitComplexA) { a in
            withUnsafePointer(to: splitComplexB) { b in
                vDSP_zvdiv(b, 1,
                           a, 1,
                           &result, 1,
                           vDSP_Length(count))
            }
        }
    }
  @inlinable public static func divide(_ splitComplexA: Accelerate.DSPDoubleSplitComplex, by splitComplexB: Accelerate.DSPDoubleSplitComplex, count: Swift.Int, result: inout Accelerate.DSPDoubleSplitComplex) {
        
        withUnsafePointer(to: splitComplexA) { a in
            withUnsafePointer(to: splitComplexB) { b in
                vDSP_zvdivD(b, 1,
                            a, 1,
                            &result, 1,
                            vDSP_Length(count))
            }
        }
    }
  @inlinable public static func subtract(_ splitComplexB: Accelerate.DSPSplitComplex, from splitComplexA: Accelerate.DSPSplitComplex, count: Swift.Int, result: inout Accelerate.DSPSplitComplex) {
        
        withUnsafePointer(to: splitComplexA) { a in
            withUnsafePointer(to: splitComplexB) { b in
                vDSP_zvsub(b, 1,
                           a, 1,
                           &result, 1,
                           vDSP_Length(count))
            }
        }
    }
  @inlinable public static func subtract(_ splitComplexB: Accelerate.DSPDoubleSplitComplex, from splitComplexA: Accelerate.DSPDoubleSplitComplex, count: Swift.Int, result: inout Accelerate.DSPDoubleSplitComplex) {
        
        withUnsafePointer(to: splitComplexA) { a in
            withUnsafePointer(to: splitComplexB) { b in
                vDSP_zvsubD(b, 1,
                            a, 1,
                            &result, 1,
                            vDSP_Length(count))
            }
        }
    }
  @inlinable public static func absolute<V>(_ vector: Accelerate.DSPSplitComplex, result: inout V) where V : Accelerate.AccelerateMutableBuffer, V.Element == Swift.Float {
            
            let n = result.count
            
            result.withUnsafeMutableBufferPointer { r in
                withUnsafePointer(to: vector) { v in
                    vDSP_zvabs(v, 1,
                               r.baseAddress!, 1,
                               vDSP_Length(n))
                }
            }
    }
  @inlinable public static func absolute<V>(_ vector: Accelerate.DSPDoubleSplitComplex, result: inout V) where V : Accelerate.AccelerateMutableBuffer, V.Element == Swift.Double {
            
            let n = result.count
            
            result.withUnsafeMutableBufferPointer { r in
                withUnsafePointer(to: vector) { v in
                    vDSP_zvabsD(v, 1,
                                r.baseAddress!, 1,
                                vDSP_Length(n))
                }
            }
    }
  @inlinable public static func squareMagnitudes<V>(_ splitComplex: Accelerate.DSPSplitComplex, result: inout V) where V : Accelerate.AccelerateMutableBuffer, V.Element == Swift.Float {
            
            let n = vDSP_Length(result.count)
            
            result.withUnsafeMutableBufferPointer { dest in
                withUnsafePointer(to: splitComplex) { src in
                    vDSP_zvmags(src, 1,
                                dest.baseAddress!, 1,
                                n)
                }
            }
    }
  @inlinable public static func squareMagnitudes<V>(_ splitComplex: Accelerate.DSPDoubleSplitComplex, result: inout V) where V : Accelerate.AccelerateMutableBuffer, V.Element == Swift.Double {
            
            let n = vDSP_Length(result.count)
            
            result.withUnsafeMutableBufferPointer { dest in
                withUnsafePointer(to: splitComplex) { src in
                    vDSP_zvmagsD(src, 1,
                                 dest.baseAddress!, 1,
                                 n)
                }
            }
    }
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Accelerate.vDSP {
  public enum DCTTransformType : Swift.CaseIterable {
    case II
    case III
    case IV
    public var dctType: Accelerate.vDSP_DCT_Type {
      get
    }
    public static func == (a: Accelerate.vDSP.DCTTransformType, b: Accelerate.vDSP.DCTTransformType) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public typealias AllCases = [Accelerate.vDSP.DCTTransformType]
    public static var allCases: [Accelerate.vDSP.DCTTransformType] {
      get
    }
    public var hashValue: Swift.Int {
      get
    }
  }
  public class DCT {
    public init?(previous: Accelerate.vDSP.DCT? = nil, count: Swift.Int, transformType: Accelerate.vDSP.DCTTransformType)
    public func transform<U>(_ vector: U) -> [Swift.Float] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Float
    public func transform<U, V>(_ vector: U, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Float, V.Element == Swift.Float
    @objc deinit
  }
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
public protocol vDSP_FloatingPointGeneratable : Swift.BinaryFloatingPoint {
}
extension Swift.Float : Accelerate.vDSP_FloatingPointGeneratable {
}
extension Swift.Double : Accelerate.vDSP_FloatingPointGeneratable {
}
@available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
extension Accelerate.vDSP {
  @available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
  @inlinable public static func linearInterpolate<T, U, V>(values: T, atIndices indices: U, result: inout V) where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, T.Element == Swift.Float, U.Element == Swift.Float, V.Element == Swift.Float {
            
            precondition(indices.count == values.count,
                         "The number of elements in `values` must equal the number of elements in `indices`.")
            
            let n = vDSP_Length(result.count)
            let m = vDSP_Length(indices.count)
            
            result.withUnsafeMutableBufferPointer { r in
                values.withUnsafeBufferPointer { v in
                    indices.withUnsafeBufferPointer { i in
                        vDSP_vgenp(v.baseAddress!, 1,
                                   i.baseAddress!, 1,
                                   r.baseAddress!, 1,
                                   n,
                                   m)
                    }
                }
            }
    }
  @available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
  @inlinable public static func linearInterpolate<T, U>(values: T, atIndices indices: U) -> [Swift.Float] where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, T.Element == Swift.Float, U.Element == Swift.Float {
            
            let resultCount = 1 + Int(Accelerate.vDSP.maximum(indices))
            
            let result = Array<Float>(unsafeUninitializedCapacity: resultCount) {
                buffer, initializedCount in
                
                vDSP.linearInterpolate(values: values,
                                       atIndices: indices,
                                       result: &buffer)
                
                initializedCount = resultCount
            }
            
            return result
    }
  @available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
  @inlinable public static func linearInterpolate<T, U, V>(values: T, atIndices indices: U, result: inout V) where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, T.Element == Swift.Double, U.Element == Swift.Double, V.Element == Swift.Double {
            
            precondition(indices.count == values.count,
                         "The number of elements in `values` must equal the number of elements in `indices`.")
            
            let n = vDSP_Length(result.count)
            let m = vDSP_Length(indices.count)
            
            result.withUnsafeMutableBufferPointer { r in
                values.withUnsafeBufferPointer { v in
                    indices.withUnsafeBufferPointer { i in
                        vDSP_vgenpD(v.baseAddress!, 1,
                                    i.baseAddress!, 1,
                                    r.baseAddress!, 1,
                                    n,
                                    m)
                    }
                }
            }
    }
  @available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
  @inlinable public static func linearInterpolate<T, U>(values: T, atIndices indices: U) -> [Swift.Double] where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, T.Element == Swift.Double, U.Element == Swift.Double {
            
            let resultCount = 1 + Int(Accelerate.vDSP.maximum(indices))
            
            let result = Array<Double>(unsafeUninitializedCapacity: resultCount) {
                buffer, initializedCount in
                
                vDSP.linearInterpolate(values: values,
                                       atIndices: indices,
                                       result: &buffer)
                
                initializedCount = resultCount
            }
            
            return result
    }
  @available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
  @inlinable public static func linearInterpolate<T, U, V>(lookupTable: T, withOffsets offsets: U, scale: Swift.Float = 1, baseOffset: Swift.Float = 0, result: inout V) where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, T.Element == Swift.Float, U.Element == Swift.Float, V.Element == Swift.Float {
            
            precondition(offsets.count == result.count,
                         "The number of elements in `offsets` must equal the number of elements in `result`.")
            
            let m = vDSP_Length(lookupTable.count)
            let n = vDSP_Length(result.count)
            
            result.withUnsafeMutableBufferPointer { r in
                lookupTable.withUnsafeBufferPointer { lut in
                    offsets.withUnsafeBufferPointer { o in
                        vDSP_vtabi(o.baseAddress!, 1,
                                   [scale],
                                   [baseOffset],
                                   lut.baseAddress!, m,
                                   r.baseAddress!, 1, n)
                    }
                }
            }
    }
  @available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
  @inlinable public static func linearInterpolate<T, U>(lookupTable: T, withOffsets offsets: U, scale: Swift.Float = 1, baseOffset: Swift.Float = 0) -> [Swift.Float] where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, T.Element == Swift.Float, U.Element == Swift.Float {
            
            let result = Array<Float>(unsafeUninitializedCapacity: offsets.count) {
                buffer, initializedCount in
                
                vDSP.linearInterpolate(lookupTable: lookupTable,
                                       withOffsets: offsets,
                                       scale: scale,
                                       baseOffset: baseOffset,
                                       result: &buffer)
                
                initializedCount = offsets.count
            }
            
            return result
    }
  @available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
  @inlinable public static func linearInterpolate<T, U, V>(lookupTable: T, withOffsets offsets: U, scale: Swift.Double = 1, baseOffset: Swift.Double = 0, result: inout V) where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, T.Element == Swift.Double, U.Element == Swift.Double, V.Element == Swift.Double {
            
            precondition(offsets.count == result.count,
                         "The number of elements in `offsets` must equal the number of elements in `result`.")
            
            let m = vDSP_Length(lookupTable.count)
            let n = vDSP_Length(result.count)
            
            result.withUnsafeMutableBufferPointer { r in
                lookupTable.withUnsafeBufferPointer { lut in
                    offsets.withUnsafeBufferPointer { o in
                        vDSP_vtabiD(o.baseAddress!, 1,
                                    [scale],
                                    [baseOffset],
                                    lut.baseAddress!, m,
                                    r.baseAddress!, 1, n)
                    }
                }
            }
    }
  @available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
  @inlinable public static func linearInterpolate<T, U>(lookupTable: T, withOffsets offsets: U, scale: Swift.Double = 1, baseOffset: Swift.Double = 0) -> [Swift.Double] where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, T.Element == Swift.Double, U.Element == Swift.Double {
            
            let result = Array<Double>(unsafeUninitializedCapacity: offsets.count) {
                buffer, initializedCount in
                
                vDSP.linearInterpolate(lookupTable: lookupTable,
                                       withOffsets: offsets,
                                       scale: scale,
                                       baseOffset: baseOffset,
                                       result: &buffer)
                
                initializedCount = offsets.count
            }
            
            return result
    }
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Accelerate.vDSP {
  @inlinable public static func fill<V>(_ vector: inout V, with value: Swift.Float) where V : Accelerate.AccelerateMutableBuffer, V.Element == Swift.Float {
            
            let n = vDSP_Length(vector.count)
            
            vector.withUnsafeMutableBufferPointer { v in
                withUnsafePointer(to: value) {
                    vDSP_vfill($0,
                               v.baseAddress!, 1,
                               n)
                }
            }
    }
  @inlinable public static func fill<V>(_ vector: inout V, with value: Swift.Double) where V : Accelerate.AccelerateMutableBuffer, V.Element == Swift.Double {
            
            let n = vDSP_Length(vector.count)
            
            vector.withUnsafeMutableBufferPointer { v in
                withUnsafePointer(to: value) {
                    vDSP_vfillD($0,
                                v.baseAddress!, 1,
                                n)
                }
            }
    }
  @inlinable public static func clear<V>(_ vector: inout V) where V : Accelerate.AccelerateMutableBuffer, V.Element == Swift.Float {
            
            let n = vDSP_Length(vector.count)
            
            vector.withUnsafeMutableBufferPointer { v in
                vDSP_vclr(v.baseAddress!, 1,
                          n)
            }
    }
  @inlinable public static func clear<V>(_ vector: inout V) where V : Accelerate.AccelerateMutableBuffer, V.Element == Swift.Double {
            
            let n = vDSP_Length(vector.count)
            
            vector.withUnsafeMutableBufferPointer { v in
                vDSP_vclrD(v.baseAddress!, 1,
                           n)
            }
    }
  public enum WindowSequence {
    case hanningNormalized
    case hanningDenormalized
    case hamming
    case blackman
    public static func == (a: Accelerate.vDSP.WindowSequence, b: Accelerate.vDSP.WindowSequence) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  @inlinable public static func window<T>(ofType: T.Type, usingSequence sequence: Accelerate.vDSP.WindowSequence, count: Swift.Int, isHalfWindow: Swift.Bool) -> [T] where T : Accelerate.vDSP_FloatingPointGeneratable {
        
        precondition(count > 0)
        
        if T.self == Float.self {
            
            let result = Array<Float>(unsafeUninitializedCapacity: count) {
                buffer, initializedCount in
                
                formWindow(usingSequence: sequence,
                           result: &buffer,
                           isHalfWindow: isHalfWindow)
                
                initializedCount = count
            }
            return result as! [T]
            
        } else if T.self == Double.self {
            
            let result = Array<Double>(unsafeUninitializedCapacity: count) {
                buffer, initializedCount in
                
                formWindow(usingSequence: sequence,
                           result: &buffer,
                           isHalfWindow: isHalfWindow)
                
                initializedCount = count
            }
            return result as! [T]
            
        } else {
            fatalError("This operation only supports `Float` and `Double` types.")
        }
    }
  public static func formWindow<V>(usingSequence sequence: Accelerate.vDSP.WindowSequence, result: inout V, isHalfWindow: Swift.Bool) where V : Accelerate.AccelerateMutableBuffer, V.Element == Swift.Float
  public static func formWindow<V>(usingSequence sequence: Accelerate.vDSP.WindowSequence, result: inout V, isHalfWindow: Swift.Bool) where V : Accelerate.AccelerateMutableBuffer, V.Element == Swift.Double
  @inlinable public static func ramp(withInitialValue initialValue: Swift.Float, increment: Swift.Float, count: Swift.Int) -> [Swift.Float] {
        
        precondition(count > 0)
        
        let result = Array<Float>(unsafeUninitializedCapacity: count) {
            buffer, initializedCount in
            
            formRamp(withInitialValue: initialValue,
                     increment: increment,
                     result: &buffer)
            
            initializedCount = count
        }
        
        return result
    }
  @inlinable public static func formRamp<V>(withInitialValue initialValue: Swift.Float, increment: Swift.Float, result: inout V) where V : Accelerate.AccelerateMutableBuffer, V.Element == Swift.Float {
            
            let n = vDSP_Length(result.count)
            
            withUnsafePointer(to: initialValue) { a in
                withUnsafePointer(to: increment) { b in
                    result.withUnsafeMutableBufferPointer { c in
                        vDSP_vramp(a,
                                   b,
                                   c.baseAddress!, 1,
                                   n)
                    }
                }
            }
    }
  @inlinable public static func ramp(withInitialValue initialValue: Swift.Double, increment: Swift.Double, count: Swift.Int) -> [Swift.Double] {
        
        precondition(count > 0)
        
        let result = Array<Double>(unsafeUninitializedCapacity: count) {
            buffer, initializedCount in
            
            formRamp(withInitialValue: initialValue,
                     increment: increment,
                     result: &buffer)
            
            initializedCount = count
        }
        
        return result
    }
  @inlinable public static func formRamp<V>(withInitialValue initialValue: Swift.Double, increment: Swift.Double, result: inout V) where V : Accelerate.AccelerateMutableBuffer, V.Element == Swift.Double {
            
            let n = vDSP_Length(result.count)
            
            withUnsafePointer(to: initialValue) { a in
                withUnsafePointer(to: increment) { b in
                    result.withUnsafeMutableBufferPointer { c in
                        vDSP_vrampD(a,
                                    b,
                                    c.baseAddress!, 1,
                                    n)
                    }
                }
            }
    }
  @inlinable public static func ramp(in range: Swift.ClosedRange<Swift.Float>, count: Swift.Int) -> [Swift.Float] {
        
        precondition(count > 0)
        
        let result = Array<Float>(unsafeUninitializedCapacity: count) {
            buffer, initializedCount in
            
            formRamp(in: range,
                     result: &buffer)
            
            initializedCount = count
        }
        
        return result
    }
  @inlinable public static func formRamp<V>(in range: Swift.ClosedRange<Swift.Float>, result: inout V) where V : Accelerate.AccelerateMutableBuffer, V.Element == Swift.Float {
            
            let n = vDSP_Length(result.count)
            
            withUnsafePointer(to: range.lowerBound) { a in
                withUnsafePointer(to: range.upperBound) { b in
                    result.withUnsafeMutableBufferPointer { c in
                        vDSP_vgen(a,
                                  b,
                                  c.baseAddress!, 1,
                                  n)
                    }
                }
            }
    }
  @inlinable public static func ramp(in range: Swift.ClosedRange<Swift.Double>, count: Swift.Int) -> [Swift.Double] {
        
        precondition(count > 0)
        
        let result = Array<Double>(unsafeUninitializedCapacity: count) {
            buffer, initializedCount in
            
            formRamp(in: range,
                     result: &buffer)
            
            initializedCount = count
        }
        
        return result
    }
  @inlinable public static func formRamp<V>(in range: Swift.ClosedRange<Swift.Double>, result: inout V) where V : Accelerate.AccelerateMutableBuffer, V.Element == Swift.Double {
            
            let n = vDSP_Length(result.count)
            
            withUnsafePointer(to: range.lowerBound) { a in
                withUnsafePointer(to: range.upperBound) { b in
                    result.withUnsafeMutableBufferPointer { c in
                        vDSP_vgenD(a,
                                   b,
                                   c.baseAddress!, 1,
                                   n)
                    }
                }
            }
    }
  @inlinable public static func ramp<U>(withInitialValue initialValue: inout Swift.Float, multiplyingBy vector: U, increment: Swift.Float) -> [Swift.Float] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Float {
            
            let result = Array<Float>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                formRamp(withInitialValue: &initialValue,
                         multiplyingBy: vector,
                         increment: increment,
                         result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func formRamp<U, V>(withInitialValue initialValue: inout Swift.Float, multiplyingBy vector: U, increment: Swift.Float, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Float, V.Element == Swift.Float {
            
            precondition(vector.count == result.count)
            let n = vDSP_Length(result.count)
            
            result.withUnsafeMutableBufferPointer { dest in
                vector.withUnsafeBufferPointer { src in
                    withUnsafePointer(to: increment) { step in
                        vDSP_vrampmul(src.baseAddress!, 1,
                                      &initialValue,
                                      step,
                                      dest.baseAddress!, 1,
                                      n)
                    }
                }
            }
    }
  @inlinable public static func ramp<U>(withInitialValue initialValue: inout Swift.Double, multiplyingBy vector: U, increment: Swift.Double) -> [Swift.Double] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Double {
            
            let result = Array<Double>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                formRamp(withInitialValue: &initialValue,
                         multiplyingBy: vector,
                         increment: increment,
                         result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func formRamp<U, V>(withInitialValue initialValue: inout Swift.Double, multiplyingBy vector: U, increment: Swift.Double, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Double, V.Element == Swift.Double {
            
            precondition(vector.count == result.count)
            let n = vDSP_Length(result.count)
            
            result.withUnsafeMutableBufferPointer { dest in
                vector.withUnsafeBufferPointer { src in
                    withUnsafePointer(to: increment) { step in
                        vDSP_vrampmulD(src.baseAddress!, 1,
                                       &initialValue,
                                       step,
                                       dest.baseAddress!, 1,
                                       n)
                    }
                }
            }
    }
  @inlinable public static func stereoRamp<U>(withInitialValue initialValue: inout Swift.Float, multiplyingBy multiplierOne: U, _ multiplierTwo: U, increment: Swift.Float) -> (firstOutput: [Swift.Float], secondOutput: [Swift.Float]) where U : Accelerate.AccelerateBuffer, U.Element == Swift.Float {
            
            let n = multiplierOne.count
            
            var firstOutput: Array<Float>!
            
            let secondOutput = Array<Float>(unsafeUninitializedCapacity: n) {
                secondBuffer, secondInitializedCount in
                
                firstOutput = Array<Float>(unsafeUninitializedCapacity: n) {
                    firstBuffer, firstInitializedCount in
                    
                    formStereoRamp(withInitialValue: &initialValue,
                                   multiplyingBy: multiplierOne, multiplierTwo,
                                   increment: increment,
                                   results: &firstBuffer, &secondBuffer)
                    
                    firstInitializedCount = n
                }
                
                secondInitializedCount = n
            }
            
            return (firstOutput: firstOutput,
                    secondOutput: secondOutput)
    }
  @inlinable public static func formStereoRamp<U, V>(withInitialValue initialValue: inout Swift.Float, multiplyingBy multiplierOne: U, _ multiplierTwo: U, increment: Swift.Float, results resultOne: inout V, _ resultTwo: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Float, V.Element == Swift.Float {
            
            precondition(multiplierOne.count == multiplierTwo.count)
            precondition(resultOne.count == resultTwo.count)
            precondition(multiplierOne.count == resultOne.count)
            let n = vDSP_Length(resultTwo.count)
            
            resultOne.withUnsafeMutableBufferPointer { o0 in
                resultTwo.withUnsafeMutableBufferPointer { o1 in
                    multiplierOne.withUnsafeBufferPointer { i0 in
                        multiplierTwo.withUnsafeBufferPointer { i1 in
                            withUnsafePointer(to: increment) { step in
                                vDSP_vrampmul2(i0.baseAddress!,
                                               i1.baseAddress!, 1,
                                               &initialValue,
                                               step,
                                               o0.baseAddress!,
                                               o1.baseAddress!, 1,
                                               n)
                            }
                        }
                    }
                }
            }
    }
  @inlinable public static func stereoRamp<U>(withInitialValue initialValue: inout Swift.Double, multiplyingBy multiplierOne: U, _ multiplierTwo: U, increment: Swift.Double) -> (firstOutput: [Swift.Double], secondOutput: [Swift.Double]) where U : Accelerate.AccelerateBuffer, U.Element == Swift.Double {
            
            let n = multiplierOne.count
            
            var firstOutput: Array<Double>!
            
            let secondOutput = Array<Double>(unsafeUninitializedCapacity: n) {
                secondBuffer, secondInitializedCount in
                
                firstOutput = Array<Double>(unsafeUninitializedCapacity: n) {
                    firstBuffer, firstInitializedCount in
                    
                    formStereoRamp(withInitialValue: &initialValue,
                                   multiplyingBy: multiplierOne, multiplierTwo,
                                   increment: increment,
                                   results: &firstBuffer, &secondBuffer)
                    
                    firstInitializedCount = n
                }
                
                secondInitializedCount = n
            }
            
            return (firstOutput: firstOutput,
                    secondOutput: secondOutput)
    }
  @inlinable public static func formStereoRamp<U, V>(withInitialValue initialValue: inout Swift.Double, multiplyingBy multiplierOne: U, _ multiplierTwo: U, increment: Swift.Double, results resultOne: inout V, _ resultTwo: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Double, V.Element == Swift.Double {
            
            precondition(multiplierOne.count == multiplierTwo.count)
            precondition(resultOne.count == resultTwo.count)
            precondition(multiplierOne.count == resultOne.count)
            let n = vDSP_Length(resultTwo.count)
            
            resultOne.withUnsafeMutableBufferPointer { o0 in
                resultTwo.withUnsafeMutableBufferPointer { o1 in
                    multiplierOne.withUnsafeBufferPointer { i0 in
                        multiplierTwo.withUnsafeBufferPointer { i1 in
                            withUnsafePointer(to: increment) { step in
                                vDSP_vrampmul2D(i0.baseAddress!,
                                                i1.baseAddress!, 1,
                                                &initialValue,
                                                step,
                                                o0.baseAddress!,
                                                o1.baseAddress!, 1,
                                                n)
                            }
                        }
                    }
                }
            }
    }
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Accelerate.vImageCVImageFormat {
  public static func make(format: Accelerate.vImageCVImageFormat.Format, matrix: Accelerate.vImage_ARGBToYpCbCrMatrix, chromaSiting: Accelerate.vImageCVImageFormat.ChromaSiting, colorSpace: CoreGraphics.CGColorSpace, alphaIsOpaqueHint: Swift.Bool) -> Accelerate.vImageCVImageFormat?
  public static func make(buffer: CoreVideo.CVPixelBuffer) -> Accelerate.vImageCVImageFormat?
  public var alphaIsOpaqueHint: Swift.Bool {
    get
    set
  }
  public var channelCount: Swift.UInt32 {
    get
  }
  public var channels: [Accelerate.vImage.BufferType] {
    get
  }
  public func channelDescription(bufferType: Accelerate.vImage.BufferType) -> Accelerate.vImageChannelDescription?
  public var chromaSiting: Accelerate.vImageCVImageFormat.ChromaSiting? {
    get
    set
  }
  public var colorSpace: CoreGraphics.CGColorSpace? {
    get
    set
  }
  public var formatCode: Swift.UInt32 {
    get
  }
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Accelerate.vImage {
  public enum BufferType : Swift.Int {
    case alpha
    case coreGraphics
    case cmykBlack
    case cmykCyan
    case cmykMagenta
    case cmykYellow
    case YCbCr
    case Cb
    case Cr
    case chroma
    case chunky
    case indexed
    case labA
    case labB
    case labL
    case luminance
    case monochrome
    case rgbRed
    case rgbGreen
    case rgbBlue
    case xyzX
    case xyzY
    case xyzZ
    public init?(rawValue: Swift.Int)
    public init?(bufferTypeCode: Swift.Int, model: CoreGraphics.CGColorSpaceModel?)
    public var bufferTypeCode: Accelerate.vImageBufferTypeCode {
      get
    }
    public typealias RawValue = Swift.Int
    public var rawValue: Swift.Int {
      get
    }
  }
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Accelerate.vImageCVImageFormat {
  public enum Format {
    case format1Monochrome
    case format2Indexed
    case format4Indexed
    case format8Indexed
    case format1IndexedGray_WhiteIsZero
    case format2IndexedGray_WhiteIsZero
    case format4IndexedGray_WhiteIsZero
    case format8IndexedGray_WhiteIsZero
    case format16BE555
    case format16LE555
    case format16LE5551
    case format16BE565
    case format16LE565
    case format24RGB
    case format24BGR
    case format32ARGB
    case format32BGRA
    case format32ABGR
    case format32RGBA
    case format64ARGB
    case format48RGB
    case format32AlphaGray
    case format16Gray
    case format30RGB
    case format422YpCbCr8
    case format4444YpCbCrA8
    case format4444YpCbCrA8R
    case format4444AYpCbCr8
    case format4444AYpCbCr16
    case format444YpCbCr8
    case format422YpCbCr16
    case format422YpCbCr10
    case format444YpCbCr10
    case format420YpCbCr8Planar
    case format420YpCbCr8PlanarFullRange
    case format422YpCbCr_4A_8BiPlanar
    case format420YpCbCr8BiPlanarVideoRange
    case format420YpCbCr8BiPlanarFullRange
    case format422YpCbCr8_yuvs
    case format422YpCbCr8FullRange
    case formatOneComponent8
    case formatTwoComponent8
    case format30RGBLEPackedWideGamut
    case formatARGB2101010LEPacked
    case formatOneComponent16Half
    case formatOneComponent32Float
    case formatTwoComponent16Half
    case formatTwoComponent32Float
    case format64RGBAHalf
    case format128RGBAFloat
    case format14Bayer_GRBG
    case format14Bayer_RGGB
    case format14Bayer_BGGR
    case format14Bayer_GBRG
    case formatDisparityFloat16
    case formatDisparityFloat32
    case formatDepthFloat16
    case formatDepthFloat32
    case format420YpCbCr10BiPlanarVideoRange
    case format422YpCbCr10BiPlanarVideoRange
    case format444YpCbCr10BiPlanarVideoRange
    case format420YpCbCr10BiPlanarFullRange
    case format422YpCbCr10BiPlanarFullRange
    case format444YpCbCr10BiPlanarFullRange
    public static func == (a: Accelerate.vImageCVImageFormat.Format, b: Accelerate.vImageCVImageFormat.Format) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public enum ChromaSiting {
    case left
    case center
    case topLeft
    case top
    case bottomLeft
    case bottom
    case dv420
    public static func == (a: Accelerate.vImageCVImageFormat.ChromaSiting, b: Accelerate.vImageCVImageFormat.ChromaSiting) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
}
@available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
extension Accelerate.BNNS {
  @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class LossLayer : Accelerate.BNNS.Layer {
    convenience public init?(input: Accelerate.BNNSNDArrayDescriptor, output: Accelerate.BNNSNDArrayDescriptor, lossFunction: Accelerate.BNNS.LossFunction, lossReduction: Accelerate.BNNS.LossReduction, filterParameters: Accelerate.BNNSFilterParameters? = nil)
    public func apply(batchSize: Swift.Int, input: Accelerate.BNNSNDArrayDescriptor, labels: Accelerate.BNNSNDArrayDescriptor, output: Accelerate.BNNSNDArrayDescriptor, generatingInputGradient inputGradient: Accelerate.BNNSNDArrayDescriptor) throws
    @objc deinit
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Accelerate.BNNS.LossLayer {
  public func apply(batchSize: Swift.Int, input: Accelerate.BNNSNDArrayDescriptor, labels: Accelerate.BNNSNDArrayDescriptor, output: Accelerate.BNNSNDArrayDescriptor, weights: Accelerate.BNNSNDArrayDescriptor?, broadcastsWeights: Swift.Bool, generatingInputGradient inputGradient: Accelerate.BNNSNDArrayDescriptor) throws
}
@available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
extension Accelerate.BNNS {
  public enum LossFunction {
    public struct YoloParameters {
      @available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
      public init(huberDelta: Swift.Float, gridColumnCount: Swift.Int, gridRowsCount: Swift.Int, anchorBoxCount: Swift.Int, anchorBoxSize: Swift.Int, rescore: Swift.Bool, xyScale: Swift.Float, whScale: Swift.Float, objectScale: Swift.Float, noObjectScale: Swift.Float, classificationScale: Swift.Float, objectMinimumIoU: Swift.Float, noObjectMaximumIoU: Swift.Float, anchorsData: Swift.UnsafeMutablePointer<Swift.Float>)
      public let huberDelta: Swift.Float
      public let gridColumnCount: Swift.Int
      public let gridRowsCount: Swift.Int
      public let anchorBoxCount: Swift.Int
      public let anchorBoxSize: Swift.Int
      public let rescore: Swift.Bool
      public let xyScale: Swift.Float
      public let whScale: Swift.Float
      public let objectScale: Swift.Float
      public let noObjectScale: Swift.Float
      public let classificationScale: Swift.Float
      public let objectMinimumIoU: Swift.Float
      public let noObjectMaximumIoU: Swift.Float
      public let anchorsData: Swift.UnsafeMutablePointer<Swift.Float>
    }
    case softmaxCrossEntropy(labelSmoothing: Swift.Float)
    case sigmoidCrossEntropy(labelSmoothing: Swift.Float)
    case huber(huberDelta: Swift.Float)
    case yolo(parameters: Accelerate.BNNS.LossFunction.YoloParameters)
    case meanSquareError
    case log
    case cosineDistance
    case hinge
    case meanAbsoluteError
    case categoricalCrossEntropy
    public var bnnsLossFunction: Accelerate.BNNSLossFunction {
      get
    }
  }
  public enum LossReduction {
    case none
    case sum
    case weightedMean
    case reductionMean
    case zeroWeightMean
    public var bnnsLossReductionFunction: Accelerate.BNNSLossReductionFunction {
      get
    }
    public static func == (a: Accelerate.BNNS.LossReduction, b: Accelerate.BNNS.LossReduction) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Accelerate.BNNS {
  public static func clipByGlobalNorm(threshold: Swift.Float, inputs: [Accelerate.BNNSNDArrayDescriptor], outputs: [Accelerate.BNNSNDArrayDescriptor], globalNorm: Swift.Float = 0) throws
  public static func clip(to bounds: Swift.ClosedRange<Swift.Float>, input: Accelerate.BNNSNDArrayDescriptor, output: Accelerate.BNNSNDArrayDescriptor) throws
  public static func clipByNorm(threshold: Swift.Float, input: Accelerate.BNNSNDArrayDescriptor, output: Accelerate.BNNSNDArrayDescriptor, axes: [Swift.Int]? = nil) throws
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Accelerate.BNNS.Norm : Swift.Sendable {}
@available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
extension Accelerate.BNNS.DataLayout : Swift.Equatable {}
@available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
extension Accelerate.BNNS.DataLayout : Swift.Hashable {}
@available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
extension Accelerate.BNNS.Error : Swift.Equatable {}
@available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
extension Accelerate.BNNS.Error : Swift.Hashable {}
@available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
extension Accelerate.BNNS.ConvolutionType : Swift.Equatable {}
@available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
extension Accelerate.BNNS.ConvolutionType : Swift.Hashable {}
@available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
extension Accelerate.BNNS.LearningPhase : Swift.Equatable {}
@available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
extension Accelerate.BNNS.LearningPhase : Swift.Hashable {}
@available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
extension Accelerate.BNNS.LearningPhase : Swift.Sendable {}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Accelerate.vDSP.RoundingMode : Swift.Equatable {}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Accelerate.vDSP.RoundingMode : Swift.Hashable {}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Accelerate.BNNS.ArithmeticTernaryFunction : Swift.Equatable {}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Accelerate.BNNS.ArithmeticTernaryFunction : Swift.Hashable {}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Accelerate.vDSP.DFTTransformType : Swift.Equatable {}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Accelerate.vDSP.DFTTransformType : Swift.Hashable {}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Accelerate.vDSP.IntegrationRule : Swift.Equatable {}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Accelerate.vDSP.IntegrationRule : Swift.Hashable {}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Accelerate.Quadrature.Error : Swift.Equatable {}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Accelerate.Quadrature.Error : Swift.Hashable {}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Accelerate.vDSP.Radix : Swift.Equatable {}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Accelerate.vDSP.Radix : Swift.Hashable {}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Accelerate.BNNS.RandomGeneratorMethod : Swift.Equatable {}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Accelerate.BNNS.RandomGeneratorMethod : Swift.Hashable {}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Accelerate.vImage.Error : Swift.Equatable {}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Accelerate.vImage.Error : Swift.Hashable {}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Accelerate.vImage.Error : Swift.RawRepresentable {}
@available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
extension Accelerate.BNNS.RelationalOperator : Swift.Sendable {}
@available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
extension Accelerate.BNNS.DescriptorType : Swift.Equatable {}
@available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
extension Accelerate.BNNS.DescriptorType : Swift.Hashable {}
@available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
extension Accelerate.BNNS.ArithmeticUnaryFunction : Swift.Equatable {}
@available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
extension Accelerate.BNNS.ArithmeticUnaryFunction : Swift.Hashable {}
@available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
extension Accelerate.BNNS.ArithmeticBinaryFunction : Swift.Equatable {}
@available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
extension Accelerate.BNNS.ArithmeticBinaryFunction : Swift.Hashable {}
@available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
extension Accelerate.BNNS.InterpolationMethod : Swift.Equatable {}
@available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
extension Accelerate.BNNS.InterpolationMethod : Swift.Hashable {}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Accelerate.vDSP.FourierTransformDirection : Swift.Equatable {}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Accelerate.vDSP.FourierTransformDirection : Swift.Hashable {}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Accelerate.vDSP.SortOrder : Swift.Equatable {}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Accelerate.vDSP.SortOrder : Swift.Hashable {}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Accelerate.vDSP.SortOrder : Swift.RawRepresentable {}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Accelerate.vDSP.DCTTransformType : Swift.Equatable {}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Accelerate.vDSP.DCTTransformType : Swift.Hashable {}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Accelerate.vDSP.WindowSequence : Swift.Equatable {}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Accelerate.vDSP.WindowSequence : Swift.Hashable {}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Accelerate.vImage.BufferType : Swift.Equatable {}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Accelerate.vImage.BufferType : Swift.Hashable {}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Accelerate.vImage.BufferType : Swift.RawRepresentable {}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Accelerate.vImageCVImageFormat.Format : Swift.Equatable {}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Accelerate.vImageCVImageFormat.Format : Swift.Hashable {}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Accelerate.vImageCVImageFormat.ChromaSiting : Swift.Equatable {}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Accelerate.vImageCVImageFormat.ChromaSiting : Swift.Hashable {}
@available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
extension Accelerate.BNNS.LossReduction : Swift.Equatable {}
@available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
extension Accelerate.BNNS.LossReduction : Swift.Hashable {}
