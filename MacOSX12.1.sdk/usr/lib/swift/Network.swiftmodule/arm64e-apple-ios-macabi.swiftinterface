// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 5.5.2 (swiftlang-1300.0.46.202 clang-1300.0.29.30)
// swift-module-flags: -target arm64e-apple-ios15.2-macabi -enable-objc-interop -autolink-force-load -enable-library-evolution -module-link-name swiftNetwork -swift-version 5 -enforce-exclusivity=checked -O -module-name Network
import Darwin
import Dispatch
import Foundation
@_exported import Network
import Security
import Swift
import _Concurrency
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers @available(macOS 10.14, iOS 12.0, watchOS 5.0, tvOS 12.0, *)
@_objcRuntimeName(_TtC7Network14_NWProtocolUDP) public class NWProtocolUDP : Network.NWProtocol {
  public static let definition: Network.NWProtocolDefinition
  @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers @_objcRuntimeName(_TtCC7Network14_NWProtocolUDP7Options) public class Options : Network.NWProtocolOptions {
    public var preferNoChecksum: Swift.Bool {
      get
      set
    }
    public init()
    @objc deinit
  }
  @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers @_objcRuntimeName(_TtCC7Network14_NWProtocolUDP8Metadata) public class Metadata : Network.NWProtocolMetadata {
    public init()
    @objc deinit
  }
  @objc deinit
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers @available(macOS 10.14, iOS 12.0, watchOS 5.0, tvOS 12.0, *)
@_objcRuntimeName(_TtC7Network14_NWProtocolTCP) public class NWProtocolTCP : Network.NWProtocol {
  public static let definition: Network.NWProtocolDefinition
  @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers @_objcRuntimeName(_TtCC7Network14_NWProtocolTCP7Options) public class Options : Network.NWProtocolOptions {
    public var noDelay: Swift.Bool {
      get
      set
    }
    public var noPush: Swift.Bool {
      get
      set
    }
    public var noOptions: Swift.Bool {
      get
      set
    }
    public var enableKeepalive: Swift.Bool {
      get
      set
    }
    public var keepaliveCount: Swift.Int {
      get
      set
    }
    public var keepaliveIdle: Swift.Int {
      get
      set
    }
    public var keepaliveInterval: Swift.Int {
      get
      set
    }
    public var maximumSegmentSize: Swift.Int {
      get
      set
    }
    public var connectionTimeout: Swift.Int {
      get
      set
    }
    public var persistTimeout: Swift.Int {
      get
      set
    }
    public var connectionDropTime: Swift.Int {
      get
      set
    }
    public var retransmitFinDrop: Swift.Bool {
      get
      set
    }
    public var disableAckStretching: Swift.Bool {
      get
      set
    }
    public var enableFastOpen: Swift.Bool {
      get
      set
    }
    public var disableECN: Swift.Bool {
      get
      set
    }
    public init()
    @objc deinit
  }
  @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers @_objcRuntimeName(_TtCC7Network14_NWProtocolTCP8Metadata) public class Metadata : Network.NWProtocolMetadata {
    public var availableReceiveBuffer: Swift.UInt32 {
      get
    }
    public var availableSendBuffer: Swift.UInt32 {
      get
    }
    @objc deinit
  }
  @objc deinit
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers @available(macOS 10.14, iOS 12.0, watchOS 5.0, tvOS 12.0, *)
@_objcRuntimeName(_TtC7Network13_NWProtocolIP) public class NWProtocolIP : Network.NWProtocol {
  public static let definition: Network.NWProtocolDefinition
  @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers @_objcRuntimeName(_TtCC7Network13_NWProtocolIP7Options) public class Options : Network.NWProtocolOptions {
    public enum Version {
      case any
      case v4
      case v6
      public static func == (a: Network.NWProtocolIP.Options.Version, b: Network.NWProtocolIP.Options.Version) -> Swift.Bool
      public func hash(into hasher: inout Swift.Hasher)
      public var hashValue: Swift.Int {
        get
      }
    }
    public var version: Network.NWProtocolIP.Options.Version {
      get
      set
    }
    public var hopLimit: Swift.UInt8 {
      get
      set
    }
    public var useMinimumMTU: Swift.Bool {
      get
      set
    }
    public var disableFragmentation: Swift.Bool {
      get
      set
    }
    public var shouldCalculateReceiveTime: Swift.Bool {
      get
      set
    }
    @available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
    public enum AddressPreference {
      case `default`
      case temporary
      case stable
      public static func == (a: Network.NWProtocolIP.Options.AddressPreference, b: Network.NWProtocolIP.Options.AddressPreference) -> Swift.Bool
      public func hash(into hasher: inout Swift.Hasher)
      public var hashValue: Swift.Int {
        get
      }
    }
    @available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
    public var localAddressPreference: Network.NWProtocolIP.Options.AddressPreference {
      get
      set
    }
    @available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
    public var disableMulticastLoopback: Swift.Bool {
      get
      set
    }
    @objc deinit
  }
  public enum ECN {
    case nonECT
    case ect0
    case ect1
    case ce
    public static func == (a: Network.NWProtocolIP.ECN, b: Network.NWProtocolIP.ECN) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers @_objcRuntimeName(_TtCC7Network13_NWProtocolIP8Metadata) public class Metadata : Network.NWProtocolMetadata {
    public var ecn: Network.NWProtocolIP.ECN {
      get
      set
    }
    public var serviceClass: Network.NWParameters.ServiceClass {
      get
      set
    }
    public var receiveTime: Swift.UInt64 {
      get
    }
    public init()
    @objc deinit
  }
  @objc deinit
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers @available(macOS 10.14, iOS 12.0, watchOS 5.0, tvOS 12.0, *)
@_objcRuntimeName(_TtC7Network14_NWProtocolTLS) public class NWProtocolTLS : Network.NWProtocol {
  public static let definition: Network.NWProtocolDefinition
  @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers @_objcRuntimeName(_TtCC7Network14_NWProtocolTLS7Options) public class Options : Network.NWProtocolOptions {
    public var securityProtocolOptions: Security.sec_protocol_options_t {
      get
    }
    public init()
    @objc deinit
  }
  @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers @_objcRuntimeName(_TtCC7Network14_NWProtocolTLS8Metadata) public class Metadata : Network.NWProtocolMetadata {
    public var securityProtocolMetadata: Security.sec_protocol_metadata_t {
      get
    }
    @objc deinit
  }
  @objc deinit
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
public class NWProtocolWebSocket : Network.NWProtocol {
  public static let definition: Network.NWProtocolDefinition
  public enum Version {
    case version13
    public static func == (a: Network.NWProtocolWebSocket.Version, b: Network.NWProtocolWebSocket.Version) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public enum Opcode : Swift.UInt8 {
    case cont
    case text
    case binary
    case close
    case ping
    case pong
    public init?(rawValue: Swift.UInt8)
    public typealias RawValue = Swift.UInt8
    public var rawValue: Swift.UInt8 {
      get
    }
  }
  public enum CloseCode : Swift.Equatable {
    public enum Defined : Swift.UInt16 {
      case normalClosure
      case goingAway
      case protocolError
      case unsupportedData
      case noStatusReceived
      case abnormalClosure
      case invalidFramePayloadData
      case policyViolation
      case messageTooBig
      case mandatoryExtension
      case internalServerError
      case tlsHandshake
      public init?(rawValue: Swift.UInt16)
      public typealias RawValue = Swift.UInt16
      public var rawValue: Swift.UInt16 {
        get
      }
    }
    case protocolCode(Network.NWProtocolWebSocket.CloseCode.Defined)
    case applicationCode(Swift.UInt16)
    case privateCode(Swift.UInt16)
    public init(rawValue: Swift.UInt16) throws
    public static func == (a: Network.NWProtocolWebSocket.CloseCode, b: Network.NWProtocolWebSocket.CloseCode) -> Swift.Bool
  }
  @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class Options : Network.NWProtocolOptions {
    public var autoReplyPing: Swift.Bool {
      get
      set
    }
    public var maximumMessageSize: Swift.Int {
      get
      set
    }
    public var skipHandshake: Swift.Bool {
      get
      set
    }
    public init(_ version: Network.NWProtocolWebSocket.Version = .version13)
    public func setAdditionalHeaders(_ headers: [(name: Swift.String, value: Swift.String)])
    public func setSubprotocols(_ subprotocols: [Swift.String])
    public func setClientRequestHandler(_ queue: Dispatch.DispatchQueue, handler: @escaping ((_ subprotocols: [Swift.String], _ additionalHeaders: [(name: Swift.String, value: Swift.String)]) -> Network.NWProtocolWebSocket.Response))
    @objc deinit
  }
  @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class Metadata : Network.NWProtocolMetadata {
    final public let opcode: Network.NWProtocolWebSocket.Opcode
    public init(opcode: Network.NWProtocolWebSocket.Opcode)
    public var closeCode: Network.NWProtocolWebSocket.CloseCode {
      get
      set
    }
    public func setPongHandler(_ queue: Dispatch.DispatchQueue, handler: @escaping ((Network.NWError?) -> Swift.Void))
    public var selectedSubprotocol: Swift.String? {
      get
    }
    public var additionalServerHeaders: [(Swift.String, Swift.String)]? {
      get
    }
    @objc deinit
  }
  public struct Response {
    public enum Status {
      case accept
      case reject
      public static func == (a: Network.NWProtocolWebSocket.Response.Status, b: Network.NWProtocolWebSocket.Response.Status) -> Swift.Bool
      public func hash(into hasher: inout Swift.Hasher)
      public var hashValue: Swift.Int {
        get
      }
    }
    public let status: Network.NWProtocolWebSocket.Response.Status
    public let subprotocol: Swift.String?
    public let additionalHeaders: [(name: Swift.String, value: Swift.String)]?
    public init(status: Network.NWProtocolWebSocket.Response.Status, subprotocol: Swift.String?, additionalHeaders: [(name: Swift.String, value: Swift.String)]? = nil)
  }
  @objc deinit
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
public struct NWTXTRecord {
  public enum Entry : Swift.Hashable, Swift.CustomDebugStringConvertible {
    case none
    case empty
    case string(Swift.String)
    public var debugDescription: Swift.String {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: Network.NWTXTRecord.Entry, b: Network.NWTXTRecord.Entry) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
  }
  public init(_ dictionary: [Swift.String : Swift.String] = [:])
  @discardableResult
  public mutating func removeEntry(key: Swift.String) -> Swift.Bool
  public func getEntry(for key: Swift.String) -> Network.NWTXTRecord.Entry?
  @discardableResult
  public mutating func setEntry(_ entry: Network.NWTXTRecord.Entry, for key: Swift.String) -> Swift.Bool
  public subscript(key: Swift.String) -> Swift.String? {
    get
    set
  }
  public var dictionary: [Swift.String : Swift.String] {
    get
  }
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension Network.NWTXTRecord : Swift.Equatable {
  public static func == (lhs: Network.NWTXTRecord, rhs: Network.NWTXTRecord) -> Swift.Bool
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension Network.NWTXTRecord : Swift.Collection {
  public typealias Element = (key: Swift.String, value: Network.NWTXTRecord.Entry)
  public subscript(position: Network.NWTXTRecord.Index) -> Network.NWTXTRecord.Element {
    get
  }
  public struct Index : Swift.Comparable {
    public static func == (lhs: Network.NWTXTRecord.Index, rhs: Network.NWTXTRecord.Index) -> Swift.Bool
    public static func < (lhs: Network.NWTXTRecord.Index, rhs: Network.NWTXTRecord.Index) -> Swift.Bool
  }
  public var startIndex: Network.NWTXTRecord.Index {
    get
  }
  public var endIndex: Network.NWTXTRecord.Index {
    get
  }
  public func index(after i: Network.NWTXTRecord.Index) -> Network.NWTXTRecord.Index
  public typealias Indices = Swift.DefaultIndices<Network.NWTXTRecord>
  public typealias Iterator = Swift.IndexingIterator<Network.NWTXTRecord>
  public typealias SubSequence = Swift.Slice<Network.NWTXTRecord>
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension Network.NWTXTRecord : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
public class NWProtocolFramer : Network.NWProtocol {
  @_hasMissingDesignatedInitializers public class Definition : Network.NWProtocolDefinition {
    public init(implementation: Network.NWProtocolFramerImplementation.Type)
    @objc deinit
  }
  @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class Options : Network.NWProtocolOptions {
    public init(definition: Network.NWProtocolFramer.Definition)
    @objc deinit
  }
  @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class Message : Network.NWProtocolMetadata {
    public init(definition: Network.NWProtocolFramer.Definition)
    public init(instance: Network.NWProtocolFramer.Instance)
    public subscript(key: Swift.String) -> Any? {
      get
      set(value)
    }
    @objc deinit
  }
  @_hasMissingDesignatedInitializers final public class Instance : Swift.CustomDebugStringConvertible {
    final public var debugDescription: Swift.String {
      get
    }
    final public func markReady()
    final public func markFailed(error: Network.NWError?)
    final public func parseInput(minimumIncompleteLength: Swift.Int, maximumLength: Swift.Int, parse: (_ buffer: Swift.UnsafeMutableRawBufferPointer?, _ isComplete: Swift.Bool) -> Swift.Int) -> Swift.Bool
    final public func deliverInput(data: Foundation.Data, message: Network.NWProtocolFramer.Message, isComplete: Swift.Bool)
    final public func deliverInputNoCopy(length: Swift.Int, message: Network.NWProtocolFramer.Message, isComplete: Swift.Bool) -> Swift.Bool
    final public func passThroughInput()
    final public func parseOutput(minimumIncompleteLength: Swift.Int, maximumLength: Swift.Int, parse: (_ buffer: Swift.UnsafeMutableRawBufferPointer?, _ isComplete: Swift.Bool) -> Swift.Int) -> Swift.Bool
    final public func writeOutput(data: Foundation.Data)
    @usableFromInline
    final internal func writeOutput(discontiguousData: Dispatch.DispatchData)
    @inlinable final public func writeOutput<Output>(data: Output) where Output : Foundation.DataProtocol {
			if let dispatchData = data as? DispatchData {
				writeOutput(discontiguousData: dispatchData)
			} else if let data = data as? Data {
				writeOutput(data: data)
			} else {
				writeOutput(data: Data(data))
			}
		}
    final public func writeOutputNoCopy(length: Swift.Int) throws
    final public func passThroughOutput()
    public enum WakeupTime {
      case milliseconds(Swift.UInt64)
      case forever
    }
    final public func scheduleWakeup(wakeupTime: Network.NWProtocolFramer.Instance.WakeupTime)
    final public func async(execute: @escaping () -> Swift.Void)
    final public var remote: Network.NWEndpoint? {
      get
    }
    final public var local: Network.NWEndpoint? {
      get
    }
    final public var parameters: Network.NWParameters? {
      get
    }
    final public func prependApplicationProtocol(options: Network.NWProtocolOptions) throws
    @objc deinit
  }
  public enum StartResult {
    case ready
    case willMarkReady
    public static func == (a: Network.NWProtocolFramer.StartResult, b: Network.NWProtocolFramer.StartResult) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  @objc deinit
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
public protocol NWProtocolFramerImplementation : AnyObject {
  static var label: Swift.String { get }
  init(framer: Network.NWProtocolFramer.Instance)
  func start(framer: Network.NWProtocolFramer.Instance) -> Network.NWProtocolFramer.StartResult
  func handleInput(framer: Network.NWProtocolFramer.Instance) -> Swift.Int
  func handleOutput(framer: Network.NWProtocolFramer.Instance, message: Network.NWProtocolFramer.Message, messageLength: Swift.Int, isComplete: Swift.Bool)
  func wakeup(framer: Network.NWProtocolFramer.Instance)
  func stop(framer: Network.NWProtocolFramer.Instance) -> Swift.Bool
  func cleanup(framer: Network.NWProtocolFramer.Instance)
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers @available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
public class NWProtocolQUIC : Network.NWProtocol {
  public static let definition: Network.NWProtocolDefinition
  @_hasMissingDesignatedInitializers public class Options : Network.NWProtocolOptions {
    public init()
    convenience public init(alpn: [Swift.String])
    public var alpn: [Swift.String] {
      get
      set
    }
    public enum Direction {
      case bidirectional
      case unidirectional
      public static func == (a: Network.NWProtocolQUIC.Options.Direction, b: Network.NWProtocolQUIC.Options.Direction) -> Swift.Bool
      public func hash(into hasher: inout Swift.Hasher)
      public var hashValue: Swift.Int {
        get
      }
    }
    public var direction: Network.NWProtocolQUIC.Options.Direction {
      get
      set
    }
    public var securityProtocolOptions: Security.sec_protocol_options_t {
      get
    }
    public var idleTimeout: Swift.Int {
      get
      set
    }
    public var maxUDPPayloadSize: Swift.Int {
      get
      set
    }
    public var initialMaxData: Swift.Int {
      get
      set
    }
    public var initialMaxStreamDataBidirectionalRemote: Swift.Int {
      get
      set
    }
    public var initialMaxStreamDataBidirectionalLocal: Swift.Int {
      get
      set
    }
    public var initialMaxStreamDataUnidirectional: Swift.Int {
      get
      set
    }
    public var initialMaxStreamsBidirectional: Swift.Int {
      get
      set
    }
    public var initialMaxStreamsUnidirectional: Swift.Int {
      get
      set
    }
    @objc deinit
  }
  public struct ApplicationError : Swift.ExpressibleByIntegerLiteral {
    public let code: Swift.UInt64
    public let reason: Swift.String?
    public init(integerLiteral code: Swift.UInt64)
    public init(code: Swift.UInt64, reason: Swift.String? = nil)
    public typealias IntegerLiteralType = Swift.UInt64
  }
  @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class Metadata : Network.NWProtocolMetadata {
    public var securityProtocolMetadata: Security.sec_protocol_metadata_t {
      get
    }
    public var negotiatedALPN: Swift.String? {
      get
    }
    public var streamIdentifier: Swift.UInt64 {
      get
    }
    public var remoteIdleTimeout: Swift.Int {
      get
    }
    public var applicationError: Network.NWProtocolQUIC.ApplicationError {
      get
      set
    }
    public var streamApplicationErrorCode: Swift.UInt64 {
      get
      set
    }
    public var localMaxStreamsUnidirectional: Swift.Int {
      get
      set
    }
    public var remoteMaxStreamsUnidirectional: Swift.Int {
      get
    }
    public var localMaxStreamsBidirectional: Swift.Int {
      get
      set
    }
    public var remoteMaxStreamsBidirectional: Swift.Int {
      get
    }
    public enum KeepAliveBehavior {
      case on
      case off
      case seconds(Swift.Int)
    }
    public var keepAlive: Network.NWProtocolQUIC.Metadata.KeepAliveBehavior {
      get
      set
    }
    @objc deinit
  }
  @objc deinit
}
@available(macOS 10.14, iOS 12.0, watchOS 5.0, tvOS 12.0, *)
public enum NWError : Swift.Error, Swift.CustomDebugStringConvertible, Swift.Equatable {
  case posix(Darwin.POSIXErrorCode)
  case dns(dnssd.DNSServiceErrorType)
  case tls(Darwin.OSStatus)
  public var debugDescription: Swift.String {
    get
  }
  public static func == (a: Network.NWError, b: Network.NWError) -> Swift.Bool
}
@_hasMissingDesignatedInitializers @available(macOS 10.14, iOS 12.0, watchOS 5.0, tvOS 12.0, *)
@_objcRuntimeName(_TtC7Network13_NWConnection) final public class NWConnection : Swift.CustomDebugStringConvertible {
  final public var debugDescription: Swift.String {
    get
  }
  public enum State : Swift.Equatable {
    case setup
    case waiting(Network.NWError)
    case preparing
    case ready
    case failed(Network.NWError)
    case cancelled
    public static func == (a: Network.NWConnection.State, b: Network.NWConnection.State) -> Swift.Bool
  }
  final public var state: Network.NWConnection.State {
    get
  }
  final public var stateUpdateHandler: ((_ state: Network.NWConnection.State) -> Swift.Void)? {
    get
    set
  }
  @available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, *)
  final public var maximumDatagramSize: Swift.Int {
    get
  }
  final public var currentPath: Network.NWPath? {
    get
  }
  final public var pathUpdateHandler: ((_ newPath: Network.NWPath) -> Swift.Void)? {
    get
    set
  }
  final public var viabilityUpdateHandler: ((_ isViable: Swift.Bool) -> Swift.Void)? {
    get
    set
  }
  final public var betterPathUpdateHandler: ((_ betterPathAvailable: Swift.Bool) -> Swift.Void)? {
    get
    set
  }
  final public let endpoint: Network.NWEndpoint
  final public let parameters: Network.NWParameters
  public init(to: Network.NWEndpoint, using: Network.NWParameters)
  convenience public init(host: Network.NWEndpoint.Host, port: Network.NWEndpoint.Port, using: Network.NWParameters)
  final public func start(queue: Dispatch.DispatchQueue)
  final public var queue: Dispatch.DispatchQueue? {
    get
  }
  final public func cancel()
  final public func forceCancel()
  final public func cancelCurrentEndpoint()
  final public func restart()
  @_hasMissingDesignatedInitializers @_objcRuntimeName(_TtCC7Network13_NWConnection14ContentContext) public class ContentContext {
    final public let identifier: Swift.String
    final public let expirationMilliseconds: Swift.UInt64
    final public let relativePriority: Swift.Double
    final public let antecedent: Network.NWConnection.ContentContext?
    final public let isFinal: Swift.Bool
    public var protocolMetadata: [Network.NWProtocolMetadata] {
      get
    }
    public func protocolMetadata(definition: Network.NWProtocolDefinition) -> Network.NWProtocolMetadata?
    public init(identifier: Swift.String, expiration: Swift.UInt64 = 0, priority: Swift.Double = 0.5, isFinal: Swift.Bool = false, antecedent: Network.NWConnection.ContentContext? = nil, metadata: [Network.NWProtocolMetadata]? = [])
    public static let defaultMessage: Network.NWConnection.ContentContext
    public static let finalMessage: Network.NWConnection.ContentContext
    public static let defaultStream: Network.NWConnection.ContentContext
    @objc deinit
  }
  final public func receive(minimumIncompleteLength: Swift.Int, maximumLength: Swift.Int, completion: @escaping (_ content: Foundation.Data?, _ contentContext: Network.NWConnection.ContentContext?, _ isComplete: Swift.Bool, _ error: Network.NWError?) -> Swift.Void)
  @available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
  final public func receiveDiscontiguous(minimumIncompleteLength: Swift.Int, maximumLength: Swift.Int, completion: @escaping (_ content: Dispatch.DispatchData?, _ contentContext: Network.NWConnection.ContentContext?, _ isComplete: Swift.Bool, _ error: Network.NWError?) -> Swift.Void)
  final public func receiveMessage(completion: @escaping (_ completeContent: Foundation.Data?, _ contentContext: Network.NWConnection.ContentContext?, _ isComplete: Swift.Bool, _ error: Network.NWError?) -> Swift.Void)
  @available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
  final public func receiveMessageDiscontiguous(completion: @escaping (_ completeContent: Dispatch.DispatchData?, _ contentContext: Network.NWConnection.ContentContext?, _ isComplete: Swift.Bool, _ error: Network.NWError?) -> Swift.Void)
  public enum SendCompletion {
    case contentProcessed((_ error: Network.NWError?) -> Swift.Void)
    case idempotent
  }
  final public func send(content: Foundation.Data?, contentContext: Network.NWConnection.ContentContext = .defaultMessage, isComplete: Swift.Bool = true, completion: Network.NWConnection.SendCompletion)
  @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
  @usableFromInline
  final internal func send(discontiguousContent: Dispatch.DispatchData, contentContext: Network.NWConnection.ContentContext = .defaultMessage, isComplete: Swift.Bool = true, completion: Network.NWConnection.SendCompletion)
  @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
  @inlinable final public func send<Content>(content: Content?, contentContext: Network.NWConnection.ContentContext = .defaultMessage, isComplete: Swift.Bool = true, completion: Network.NWConnection.SendCompletion) where Content : Foundation.DataProtocol {
		if let dispatchData = content as? DispatchData {
			send(discontiguousContent: dispatchData, contentContext: contentContext, isComplete: isComplete, completion: completion)
		} else if let data = content as? Data {
			send(content: data, contentContext: contentContext, isComplete: isComplete, completion: completion)
		} else if let content = content {
			send(content: Data(content), contentContext: contentContext, isComplete: isComplete, completion: completion)
		} else {
			send(content: nil, contentContext: contentContext, isComplete: isComplete, completion: completion)
		}
	}
  final public func batch(_ block: () -> Swift.Void)
  final public func metadata(definition: Network.NWProtocolDefinition) -> Network.NWProtocolMetadata?
  @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
  public struct EstablishmentReport : Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
      get
    }
    public let duration: Foundation.TimeInterval
    public let attemptStartedAfterInterval: Foundation.TimeInterval
    public let previousAttemptCount: Swift.Int
    public let usedProxy: Swift.Bool
    public let proxyConfigured: Swift.Bool
    public let proxyEndpoint: Network.NWEndpoint?
    public struct Resolution {
      public enum Source {
        case query
        case cache
        case expiredCache
        public static func == (a: Network.NWConnection.EstablishmentReport.Resolution.Source, b: Network.NWConnection.EstablishmentReport.Resolution.Source) -> Swift.Bool
        public func hash(into hasher: inout Swift.Hasher)
        public var hashValue: Swift.Int {
          get
        }
      }
      public let source: Network.NWConnection.EstablishmentReport.Resolution.Source
      public let duration: Foundation.TimeInterval
      public let endpointCount: Swift.Int
      public let successfulEndpoint: Network.NWEndpoint
      public let preferredEndpoint: Network.NWEndpoint
      @available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
      public enum DNSProtocol {
        case unknown
        case udp
        case tcp
        case tls
        case https
        public static func == (a: Network.NWConnection.EstablishmentReport.Resolution.DNSProtocol, b: Network.NWConnection.EstablishmentReport.Resolution.DNSProtocol) -> Swift.Bool
        public func hash(into hasher: inout Swift.Hasher)
        public var hashValue: Swift.Int {
          get
        }
      }
      @available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
      public var dnsProtocol: Network.NWConnection.EstablishmentReport.Resolution.DNSProtocol {
        get
      }
    }
    public let resolutions: [Network.NWConnection.EstablishmentReport.Resolution]
    public struct Handshake {
      public let definition: Network.NWProtocolDefinition
      public let handshakeDuration: Foundation.TimeInterval
      public let handshakeRTT: Foundation.TimeInterval
    }
    public let handshakes: [Network.NWConnection.EstablishmentReport.Handshake]
  }
  @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
  final public func requestEstablishmentReport(queue: Dispatch.DispatchQueue, completion: @escaping (_ report: Network.NWConnection.EstablishmentReport?) -> Swift.Void)
  @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
  public struct DataTransferReport : Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
      get
    }
    public let duration: Foundation.TimeInterval
    public struct PathReport {
      public let interface: Network.NWInterface
      @available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
      public var radioType: Network.NWInterface.RadioType? {
        get
      }
      public let receivedIPPacketCount: Swift.UInt64
      public let sentIPPacketCount: Swift.UInt64
      public let receivedTransportByteCount: Swift.UInt64
      public let receivedTransportDuplicateByteCount: Swift.UInt64
      public let receivedTransportOutOfOrderByteCount: Swift.UInt64
      public let sentTransportByteCount: Swift.UInt64
      public let retransmittedTransportByteCount: Swift.UInt64
      public let transportSmoothedRTT: Foundation.TimeInterval
      public let transportMinimumRTT: Foundation.TimeInterval
      public let transportRTTVariance: Foundation.TimeInterval
      public let receivedApplicationByteCount: Swift.UInt64
      public let sentApplicationByteCount: Swift.UInt64
    }
    public let aggregatePathReport: Network.NWConnection.DataTransferReport.PathReport
    public let pathReports: [Network.NWConnection.DataTransferReport.PathReport]
  }
  @_hasMissingDesignatedInitializers @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
  public class PendingDataTransferReport {
    public func collect(queue: Dispatch.DispatchQueue, completion: @escaping (_ report: Network.NWConnection.DataTransferReport) -> Swift.Void)
    @objc deinit
  }
  @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
  final public func startDataTransferReport() -> Network.NWConnection.PendingDataTransferReport
  @objc deinit
}
@_hasMissingDesignatedInitializers @available(macOS 10.14, iOS 12.0, watchOS 5.0, tvOS 12.0, *)
@_objcRuntimeName(_TtC7Network21_NWProtocolDefinition) public class NWProtocolDefinition : Swift.Equatable, Swift.CustomDebugStringConvertible {
  public static func == (lhs: Network.NWProtocolDefinition, rhs: Network.NWProtocolDefinition) -> Swift.Bool
  final public let name: Swift.String
  public var debugDescription: Swift.String {
    get
  }
  @objc deinit
}
@_hasMissingDesignatedInitializers @available(macOS 10.14, iOS 12.0, watchOS 5.0, tvOS 12.0, *)
@_objcRuntimeName(_TtC7Network18_NWProtocolOptions) public class NWProtocolOptions {
  @objc deinit
}
@_hasMissingDesignatedInitializers @available(macOS 10.14, iOS 12.0, watchOS 5.0, tvOS 12.0, *)
@_objcRuntimeName(_TtC7Network19_NWProtocolMetadata) public class NWProtocolMetadata {
  @objc deinit
}
@_hasMissingDesignatedInitializers @available(macOS 10.14, iOS 12.0, watchOS 5.0, tvOS 12.0, *)
@_objcRuntimeName(_TtC7Network11_NWProtocol) public class NWProtocol {
  @objc deinit
}
@available(macOS 10.14, iOS 12.0, watchOS 5.0, tvOS 12.0, *)
public protocol IPAddress {
  var rawValue: Foundation.Data { get }
  init?(_ rawValue: Foundation.Data, _ interface: Network.NWInterface?)
  init?(_ string: Swift.String)
  var interface: Network.NWInterface? { get }
  var isLoopback: Swift.Bool { get }
  var isLinkLocal: Swift.Bool { get }
  var isMulticast: Swift.Bool { get }
}
@available(macOS 10.14, iOS 12.0, watchOS 5.0, tvOS 12.0, *)
public struct IPv4Address : Network.IPAddress, Swift.Hashable, Swift.CustomDebugStringConvertible {
  public static let any: Network.IPv4Address
  public static let broadcast: Network.IPv4Address
  public static let loopback: Network.IPv4Address
  public static let allHostsGroup: Network.IPv4Address
  public static let allRoutersGroup: Network.IPv4Address
  public static let allReportsGroup: Network.IPv4Address
  public static let mdnsGroup: Network.IPv4Address
  public var isLoopback: Swift.Bool {
    get
  }
  public var isLinkLocal: Swift.Bool {
    get
  }
  public var isMulticast: Swift.Bool {
    get
  }
  public var rawValue: Foundation.Data {
    get
  }
  public init?(_ rawValue: Foundation.Data, _ interface: Network.NWInterface? = nil)
  public init?(_ string: Swift.String)
  public let interface: Network.NWInterface?
  public static func == (lhs: Network.IPv4Address, rhs: Network.IPv4Address) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var debugDescription: Swift.String {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
@available(macOS 10.14, iOS 12.0, watchOS 5.0, tvOS 12.0, *)
public struct IPv6Address : Network.IPAddress, Swift.Hashable, Swift.CustomDebugStringConvertible {
  public static let any: Network.IPv6Address
  public static let broadcast: Network.IPv6Address
  public static let loopback: Network.IPv6Address
  public static let nodeLocalNodes: Network.IPv6Address
  public static let linkLocalNodes: Network.IPv6Address
  public static let linkLocalRouters: Network.IPv6Address
  public enum Scope : Swift.UInt8 {
    case nodeLocal
    case linkLocal
    case siteLocal
    case organizationLocal
    case global
    public init?(rawValue: Swift.UInt8)
    public typealias RawValue = Swift.UInt8
    public var rawValue: Swift.UInt8 {
      get
    }
  }
  public var isAny: Swift.Bool {
    get
  }
  public var isLoopback: Swift.Bool {
    get
  }
  public var isIPv4Compatabile: Swift.Bool {
    get
  }
  public var isIPv4Mapped: Swift.Bool {
    get
  }
  public var asIPv4: Network.IPv4Address? {
    get
  }
  public var is6to4: Swift.Bool {
    get
  }
  public var isLinkLocal: Swift.Bool {
    get
  }
  public var isMulticast: Swift.Bool {
    get
  }
  public var multicastScope: Network.IPv6Address.Scope? {
    get
  }
  public init?(_ rawValue: Foundation.Data, _ interface: Network.NWInterface? = nil)
  public init?(_ string: Swift.String)
  public let interface: Network.NWInterface?
  public var rawValue: Foundation.Data {
    get
  }
  public static func == (lhs: Network.IPv6Address, rhs: Network.IPv6Address) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var debugDescription: Swift.String {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
@available(macOS 10.14, iOS 12.0, watchOS 5.0, tvOS 12.0, *)
public enum NWEndpoint : Swift.Hashable, Swift.CustomDebugStringConvertible {
  case hostPort(host: Network.NWEndpoint.Host, port: Network.NWEndpoint.Port)
  case service(name: Swift.String, type: Swift.String, domain: Swift.String, interface: Network.NWInterface?)
  case unix(path: Swift.String)
  @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
  case url(_: Foundation.URL)
  public enum Host : Swift.Hashable, Swift.CustomDebugStringConvertible, Swift.ExpressibleByStringLiteral {
    public typealias StringLiteralType = Swift.String
    public func hash(into hasher: inout Swift.Hasher)
    case name(Swift.String, Network.NWInterface?)
    case ipv4(Network.IPv4Address)
    case ipv6(Network.IPv6Address)
    public init(stringLiteral: Network.NWEndpoint.Host.StringLiteralType)
    public init(_ string: Swift.String)
    public var interface: Network.NWInterface? {
      get
    }
    public var debugDescription: Swift.String {
      get
    }
    public static func == (a: Network.NWEndpoint.Host, b: Network.NWEndpoint.Host) -> Swift.Bool
    public typealias ExtendedGraphemeClusterLiteralType = Network.NWEndpoint.Host.StringLiteralType
    public typealias UnicodeScalarLiteralType = Network.NWEndpoint.Host.StringLiteralType
    public var hashValue: Swift.Int {
      get
    }
  }
  public struct Port : Swift.Hashable, Swift.CustomDebugStringConvertible, Swift.ExpressibleByIntegerLiteral, Swift.RawRepresentable {
    public typealias IntegerLiteralType = Swift.UInt16
    public static let any: Network.NWEndpoint.Port
    public static let ssh: Network.NWEndpoint.Port
    public static let smtp: Network.NWEndpoint.Port
    public static let http: Network.NWEndpoint.Port
    public static let pop: Network.NWEndpoint.Port
    public static let imap: Network.NWEndpoint.Port
    public static let https: Network.NWEndpoint.Port
    public static let imaps: Network.NWEndpoint.Port
    public static let socks: Network.NWEndpoint.Port
    public var rawValue: Swift.UInt16 {
      get
    }
    public init?(_ service: Swift.String)
    public init(integerLiteral value: Network.NWEndpoint.Port.IntegerLiteralType)
    public init?(rawValue: Swift.UInt16)
    public var debugDescription: Swift.String {
      get
    }
    public typealias RawValue = Swift.UInt16
  }
  public var interface: Network.NWInterface? {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
  public var debugDescription: Swift.String {
    get
  }
  public static func == (a: Network.NWEndpoint, b: Network.NWEndpoint) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
@available(macOS 10.14, iOS 12.0, watchOS 5.0, tvOS 12.0, *)
public struct NWInterface : Swift.Hashable, Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
  public static func == (lhs: Network.NWInterface, rhs: Network.NWInterface) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public enum InterfaceType {
    case other
    case wifi
    case cellular
    case wiredEthernet
    case loopback
    public static func == (a: Network.NWInterface.InterfaceType, b: Network.NWInterface.InterfaceType) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public let type: Network.NWInterface.InterfaceType
  @available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
  public enum RadioType {
    public enum WiFi {
      case b
      case a
      case g
      case n
      case ac
      case ax
      public static func == (a: Network.NWInterface.RadioType.WiFi, b: Network.NWInterface.RadioType.WiFi) -> Swift.Bool
      public func hash(into hasher: inout Swift.Hasher)
      public var hashValue: Swift.Int {
        get
      }
    }
    public enum Cellular {
      public enum NewRadio5GVariant {
        case sub6GHz
        case mmWave
        public static func == (a: Network.NWInterface.RadioType.Cellular.NewRadio5GVariant, b: Network.NWInterface.RadioType.Cellular.NewRadio5GVariant) -> Swift.Bool
        public func hash(into hasher: inout Swift.Hasher)
        public var hashValue: Swift.Int {
          get
        }
      }
      case lte
      case dualConnectivity5G(Network.NWInterface.RadioType.Cellular.NewRadio5GVariant)
      case standalone5G(Network.NWInterface.RadioType.Cellular.NewRadio5GVariant)
      case wcdma
      case gsm
      case cdma
      case evdo
    }
    case wifi(Network.NWInterface.RadioType.WiFi)
    case cell(Network.NWInterface.RadioType.Cellular)
  }
  public let name: Swift.String
  public let index: Swift.Int
  public var hashValue: Swift.Int {
    get
  }
}
@available(macOS 10.14, iOS 12.0, watchOS 5.0, tvOS 12.0, *)
public struct NWPath : Swift.Equatable, Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
  public enum Status {
    case satisfied
    case unsatisfied
    case requiresConnection
    public static func == (a: Network.NWPath.Status, b: Network.NWPath.Status) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public let status: Network.NWPath.Status
  @available(macOS 11.0, iOS 14.2, watchOS 7.1, tvOS 14.2, *)
  public enum UnsatisfiedReason {
    case notAvailable
    case cellularDenied
    case wifiDenied
    case localNetworkDenied
    public static func == (a: Network.NWPath.UnsatisfiedReason, b: Network.NWPath.UnsatisfiedReason) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  @available(macOS 11.0, iOS 14.2, watchOS 7.1, tvOS 14.2, *)
  public var unsatisfiedReason: Network.NWPath.UnsatisfiedReason {
    get
  }
  public let availableInterfaces: [Network.NWInterface]
  public let isExpensive: Swift.Bool
  @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
  public var isConstrained: Swift.Bool {
    get
  }
  public let supportsIPv4: Swift.Bool
  public let supportsIPv6: Swift.Bool
  public let supportsDNS: Swift.Bool
  @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
  public var gateways: [Network.NWEndpoint] {
    get
  }
  public let localEndpoint: Network.NWEndpoint?
  public let remoteEndpoint: Network.NWEndpoint?
  public func usesInterfaceType(_ type: Network.NWInterface.InterfaceType) -> Swift.Bool
  public static func == (lhs: Network.NWPath, rhs: Network.NWPath) -> Swift.Bool
}
@available(macOS 10.14, iOS 12.0, watchOS 5.0, tvOS 12.0, *)
@_objcRuntimeName(_TtC7Network14_NWPathMonitor) final public class NWPathMonitor {
  final public var currentPath: Network.NWPath
  final public var pathUpdateHandler: ((_ newPath: Network.NWPath) -> Swift.Void)? {
    get
    set
  }
  final public func start(queue: Dispatch.DispatchQueue)
  final public func cancel()
  final public var queue: Dispatch.DispatchQueue? {
    get
  }
  public init()
  public init(requiredInterfaceType: Network.NWInterface.InterfaceType)
  @available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
  public init(prohibitedInterfaceTypes: [Network.NWInterface.InterfaceType])
  @objc deinit
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
final public class NWBrowser : Swift.CustomDebugStringConvertible {
  final public var debugDescription: Swift.String {
    get
  }
  public enum Descriptor {
    case bonjour(type: Swift.String, domain: Swift.String?)
    case bonjourWithTXTRecord(type: Swift.String, domain: Swift.String?)
  }
  public struct Result : Swift.Hashable {
    public let endpoint: Network.NWEndpoint
    public let interfaces: [Network.NWInterface]
    public let metadata: Network.NWBrowser.Result.Metadata
    public enum Metadata : Swift.CustomDebugStringConvertible & Swift.Equatable {
      case none
      case bonjour(_: Network.NWTXTRecord)
      public static func == (lhs: Network.NWBrowser.Result.Metadata, rhs: Network.NWBrowser.Result.Metadata) -> Swift.Bool
      public var debugDescription: Swift.String {
        get
      }
    }
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (lhs: Network.NWBrowser.Result, rhs: Network.NWBrowser.Result) -> Swift.Bool
    public enum Change : Swift.Hashable {
      case identical
      case added(Network.NWBrowser.Result)
      case removed(Network.NWBrowser.Result)
      case changed(old: Network.NWBrowser.Result, new: Network.NWBrowser.Result, flags: Network.NWBrowser.Result.Change.Flags)
      public func hash(into hasher: inout Swift.Hasher)
      public static func == (lhs: Network.NWBrowser.Result.Change, rhs: Network.NWBrowser.Result.Change) -> Swift.Bool
      public struct Flags : Swift.OptionSet, Swift.Hashable {
        public let rawValue: Swift.UInt8
        public init(rawValue: Swift.UInt8)
        public static let identical: Network.NWBrowser.Result.Change.Flags
        public static let interfaceAdded: Network.NWBrowser.Result.Change.Flags
        public static let interfaceRemoved: Network.NWBrowser.Result.Change.Flags
        public static let metadataChanged: Network.NWBrowser.Result.Change.Flags
        public typealias ArrayLiteralElement = Network.NWBrowser.Result.Change.Flags
        public typealias Element = Network.NWBrowser.Result.Change.Flags
        public typealias RawValue = Swift.UInt8
      }
      public init(between old: Network.NWBrowser.Result?, _ new: Network.NWBrowser.Result?)
      public var hashValue: Swift.Int {
        get
      }
    }
    public var hashValue: Swift.Int {
      get
    }
  }
  public enum State : Swift.Equatable {
    case setup
    case ready
    case failed(Network.NWError)
    case cancelled
    @available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
    case waiting(Network.NWError)
    public static func == (a: Network.NWBrowser.State, b: Network.NWBrowser.State) -> Swift.Bool
  }
  final public let descriptor: Network.NWBrowser.Descriptor
  final public let parameters: Network.NWParameters
  final public var state: Network.NWBrowser.State {
    get
  }
  final public var browseResults: Swift.Set<Network.NWBrowser.Result> {
    get
  }
  final public var queue: Dispatch.DispatchQueue? {
    get
  }
  final public var stateUpdateHandler: ((_ newState: Network.NWBrowser.State) -> Swift.Void)? {
    get
    set
  }
  final public var browseResultsChangedHandler: ((_ newResults: Swift.Set<Network.NWBrowser.Result>, _ changes: Swift.Set<Network.NWBrowser.Result.Change>) -> Swift.Void)? {
    get
    set
  }
  public init(for descriptor: Network.NWBrowser.Descriptor, using parameters: Network.NWParameters)
  final public func start(queue: Dispatch.DispatchQueue)
  final public func cancel()
  @objc deinit
}
@available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
public protocol NWGroupDescriptor : AnyObject {
  var members: [Network.NWEndpoint] { get }
}
@_hasMissingDesignatedInitializers @available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
public class NWMulticastGroup : Network.NWGroupDescriptor {
  public var members: [Network.NWEndpoint] {
    get
  }
  final public let sourceFilter: Network.NWEndpoint?
  final public let isUnicastDisabled: Swift.Bool
  public init(for groupAddresses: [Network.NWEndpoint], from: Network.NWEndpoint? = nil, disableUnicast: Swift.Bool = false) throws
  @objc deinit
}
@_hasMissingDesignatedInitializers @available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
public class NWMultiplexGroup : Network.NWGroupDescriptor {
  public var members: [Network.NWEndpoint] {
    get
  }
  public init(to: Network.NWEndpoint)
  @objc deinit
}
@_hasMissingDesignatedInitializers @available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
final public class NWConnectionGroup : Swift.CustomDebugStringConvertible {
  final public var debugDescription: Swift.String {
    get
  }
  public enum State : Swift.Equatable {
    case setup
    case waiting(Network.NWError)
    case ready
    case failed(Network.NWError)
    case cancelled
    public static func == (a: Network.NWConnectionGroup.State, b: Network.NWConnectionGroup.State) -> Swift.Bool
  }
  final public var state: Network.NWConnectionGroup.State {
    get
  }
  final public var stateUpdateHandler: ((_ state: Network.NWConnectionGroup.State) -> Swift.Void)? {
    get
    set
  }
  @available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
  final public func metadata(definition: Network.NWProtocolDefinition) -> Network.NWProtocolMetadata?
  @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class Message : Network.NWConnection.ContentContext {
    public static let `default`: Network.NWConnectionGroup.Message
    public var remoteEndpoint: Network.NWEndpoint? {
      get
    }
    public var localEndpoint: Network.NWEndpoint? {
      get
    }
    @available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
    public func metadata(definition: Network.NWProtocolDefinition) -> Network.NWProtocolMetadata?
    public var path: Network.NWPath? {
      get
    }
    public func reply(content: Foundation.Data?, message: Network.NWConnectionGroup.Message = .default)
    public func extractConnection() -> Network.NWConnection?
    override public init(identifier: Swift.String, expiration: Swift.UInt64 = super, priority: Swift.Double = super, isFinal: Swift.Bool = super, antecedent: Network.NWConnection.ContentContext? = nil, metadata: [Network.NWProtocolMetadata]? = super)
    @objc deinit
  }
  final public func setReceiveHandler(maximumMessageSize: Swift.Int = Int.max, rejectOversizedMessages: Swift.Bool = true, handler: ((_ message: Network.NWConnectionGroup.Message, _ content: Foundation.Data?, _ isComplete: Swift.Bool) -> Swift.Void)?)
  final public func send(content: Foundation.Data?, to: Network.NWEndpoint? = nil, message: Network.NWConnectionGroup.Message = .default, completion: @escaping (_ error: Network.NWError?) -> Swift.Void)
  @available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
  final public var newConnectionHandler: ((_ connection: Network.NWConnection) -> Swift.Void)? {
    get
    set
  }
  @available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
  final public func extract(connectionTo: Network.NWEndpoint? = nil, using: Network.NWProtocolOptions? = nil) -> Network.NWConnection?
  @available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
  final public func reinsert(connection: Network.NWConnection) -> Swift.Bool
  final public let descriptor: Network.NWGroupDescriptor
  final public let parameters: Network.NWParameters
  public init(with: Network.NWGroupDescriptor, using: Network.NWParameters)
  final public func start(queue: Dispatch.DispatchQueue)
  final public var queue: Dispatch.DispatchQueue? {
    get
  }
  final public func cancel()
  @objc deinit
}
@available(macOS 10.14, iOS 12.0, watchOS 5.0, tvOS 12.0, *)
extension Network.NWConnection {
  @available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
  convenience public init?(message: Network.NWConnectionGroup.Message)
  @available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
  convenience public init?(from: Network.NWConnectionGroup, to: Network.NWEndpoint? = nil, using: Network.NWProtocolOptions? = nil)
}
@_hasMissingDesignatedInitializers @available(macOS 10.14, iOS 12.0, watchOS 5.0, tvOS 12.0, *)
@_objcRuntimeName(_TtC7Network11_NWListener) final public class NWListener : Swift.CustomDebugStringConvertible {
  final public var debugDescription: Swift.String {
    get
  }
  public struct Service : Swift.Equatable, Swift.CustomDebugStringConvertible {
    public static func == (lhs: Network.NWListener.Service, rhs: Network.NWListener.Service) -> Swift.Bool
    public var debugDescription: Swift.String {
      get
    }
    public let name: Swift.String?
    public let type: Swift.String
    public let domain: Swift.String?
    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    public var txtRecordObject: Network.NWTXTRecord? {
      get
      set
    }
    public let txtRecord: Foundation.Data?
    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    public var noAutoRename: Swift.Bool {
      get
      set
    }
    public init(name: Swift.String? = nil, type: Swift.String, domain: Swift.String? = nil, txtRecord: Foundation.Data? = nil)
    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    public init(name: Swift.String? = nil, type: Swift.String, domain: Swift.String? = nil, txtRecord: Network.NWTXTRecord)
  }
  public enum State : Swift.Equatable {
    case setup
    case waiting(Network.NWError)
    case ready
    case failed(Network.NWError)
    case cancelled
    public static func == (a: Network.NWListener.State, b: Network.NWListener.State) -> Swift.Bool
  }
  final public var newConnectionHandler: ((_ connection: Network.NWConnection) -> Swift.Void)? {
    get
    set
  }
  @available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
  final public var newConnectionGroupHandler: ((_ group: Network.NWConnectionGroup) -> Swift.Void)? {
    get
    set
  }
  final public var state: Network.NWListener.State {
    get
  }
  final public var stateUpdateHandler: ((_ state: Network.NWListener.State) -> Swift.Void)? {
    get
    set
  }
  final public let parameters: Network.NWParameters
  final public var service: Network.NWListener.Service? {
    get
    set
  }
  @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
  public static let InfiniteConnectionLimit: Swift.Int
  @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
  final public var newConnectionLimit: Swift.Int {
    get
    set
  }
  final public var port: Network.NWEndpoint.Port? {
    get
  }
  public enum ServiceRegistrationChange {
    case add(Network.NWEndpoint)
    case remove(Network.NWEndpoint)
  }
  final public var serviceRegistrationUpdateHandler: ((_ change: Network.NWListener.ServiceRegistrationChange) -> Swift.Void)? {
    get
    set
  }
  public init(using: Network.NWParameters, on: Network.NWEndpoint.Port = .any) throws
  final public func start(queue: Dispatch.DispatchQueue)
  final public var queue: Dispatch.DispatchQueue? {
    get
  }
  final public func cancel()
  @objc deinit
}
@_hasMissingDesignatedInitializers @available(macOS 10.14, iOS 12.0, watchOS 5.0, tvOS 12.0, *)
@_objcRuntimeName(_TtC7Network13_NWParameters) final public class NWParameters : Swift.CustomDebugStringConvertible {
  final public var debugDescription: Swift.String {
    get
  }
  convenience public init(tls: Network.NWProtocolTLS.Options?, tcp: Network.NWProtocolTCP.Options = NWProtocolTCP.Options())
  convenience public init(dtls: Network.NWProtocolTLS.Options?, udp: Network.NWProtocolUDP.Options = NWProtocolUDP.Options())
  @available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
  convenience public init(quic: Network.NWProtocolQUIC.Options)
  public init()
  @available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
  final public class func quic(alpn: [Swift.String]) -> Network.NWParameters
  final public class var tls: Network.NWParameters {
    get
  }
  final public class var dtls: Network.NWParameters {
    get
  }
  final public class var tcp: Network.NWParameters {
    get
  }
  final public class var udp: Network.NWParameters {
    get
  }
  final public var requiredInterface: Network.NWInterface? {
    get
    set
  }
  final public var requiredInterfaceType: Network.NWInterface.InterfaceType {
    get
    set
  }
  final public var prohibitedInterfaces: [Network.NWInterface]? {
    get
    set
  }
  final public var prohibitedInterfaceTypes: [Network.NWInterface.InterfaceType]? {
    get
    set
  }
  final public var prohibitExpensivePaths: Swift.Bool {
    get
    set
  }
  @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
  final public var prohibitConstrainedPaths: Swift.Bool {
    get
    set
  }
  final public var preferNoProxies: Swift.Bool {
    get
    set
  }
  final public var requiredLocalEndpoint: Network.NWEndpoint? {
    get
    set
  }
  final public var allowLocalEndpointReuse: Swift.Bool {
    get
    set
  }
  final public var acceptLocalOnly: Swift.Bool {
    get
    set
  }
  final public var includePeerToPeer: Swift.Bool {
    get
    set
  }
  public enum ServiceClass {
    case bestEffort
    case background
    case interactiveVideo
    case interactiveVoice
    case responsiveData
    case signaling
    public static func == (a: Network.NWParameters.ServiceClass, b: Network.NWParameters.ServiceClass) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  final public var serviceClass: Network.NWParameters.ServiceClass {
    get
    set
  }
  public enum MultipathServiceType {
    case disabled
    case handover
    case interactive
    case aggregate
    public static func == (a: Network.NWParameters.MultipathServiceType, b: Network.NWParameters.MultipathServiceType) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  final public var multipathServiceType: Network.NWParameters.MultipathServiceType {
    get
    set
  }
  final public var allowFastOpen: Swift.Bool {
    get
    set
  }
  public enum ExpiredDNSBehavior {
    case systemDefault
    case allow
    case prohibit
    public static func == (a: Network.NWParameters.ExpiredDNSBehavior, b: Network.NWParameters.ExpiredDNSBehavior) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  final public var expiredDNSBehavior: Network.NWParameters.ExpiredDNSBehavior {
    get
    set
  }
  @_hasMissingDesignatedInitializers @_objcRuntimeName(_TtCC7Network13_NWParameters13ProtocolStack) public class ProtocolStack {
    public var applicationProtocols: [Network.NWProtocolOptions] {
      get
      set
    }
    public var transportProtocol: Network.NWProtocolOptions? {
      get
      set
    }
    public var internetProtocol: Network.NWProtocolOptions? {
      get
      set
    }
    @objc deinit
  }
  final public var defaultProtocolStack: Network.NWParameters.ProtocolStack {
    get
  }
  @_hasMissingDesignatedInitializers @available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
  public class PrivacyContext : Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
      get
    }
    public static let `default`: Network.NWParameters.PrivacyContext
    public init(description: Swift.String)
    public func flushCache()
    public func disableLogging()
    public enum ResolverConfiguration : Swift.CustomDebugStringConvertible {
      public var debugDescription: Swift.String {
        get
      }
      case tls(_: Network.NWEndpoint, serverAddresses: [Network.NWEndpoint])
      case https(_: Foundation.URL, serverAddresses: [Network.NWEndpoint])
    }
    public func requireEncryptedNameResolution(_ requireEncryption: Swift.Bool, fallbackResolver: Network.NWParameters.PrivacyContext.ResolverConfiguration?)
    @objc deinit
  }
  @available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
  final public func setPrivacyContext(_ privacyContext: Network.NWParameters.PrivacyContext)
  final public func copy() -> Network.NWParameters
  @available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
  public enum Attribution : Swift.Equatable {
    case developer
    case user
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: Network.NWParameters.Attribution, b: Network.NWParameters.Attribution) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
  }
  @available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
  final public var attribution: Network.NWParameters.Attribution {
    get
    set
  }
  @objc deinit
}
@available(macOS 10.14, iOS 12.0, watchOS 5.0, tvOS 12.0, *)
extension Network.NWProtocolIP.Options.Version : Swift.Equatable {}
@available(macOS 10.14, iOS 12.0, watchOS 5.0, tvOS 12.0, *)
extension Network.NWProtocolIP.Options.Version : Swift.Hashable {}
@available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
extension Network.NWProtocolIP.Options.AddressPreference : Swift.Equatable {}
@available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
extension Network.NWProtocolIP.Options.AddressPreference : Swift.Hashable {}
@available(macOS 10.14, iOS 12.0, watchOS 5.0, tvOS 12.0, *)
extension Network.NWProtocolIP.ECN : Swift.Equatable {}
@available(macOS 10.14, iOS 12.0, watchOS 5.0, tvOS 12.0, *)
extension Network.NWProtocolIP.ECN : Swift.Hashable {}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension Network.NWProtocolWebSocket.Version : Swift.Equatable {}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension Network.NWProtocolWebSocket.Version : Swift.Hashable {}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension Network.NWProtocolWebSocket.Opcode : Swift.Equatable {}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension Network.NWProtocolWebSocket.Opcode : Swift.Hashable {}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension Network.NWProtocolWebSocket.Opcode : Swift.RawRepresentable {}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension Network.NWProtocolWebSocket.CloseCode.Defined : Swift.Equatable {}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension Network.NWProtocolWebSocket.CloseCode.Defined : Swift.Hashable {}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension Network.NWProtocolWebSocket.CloseCode.Defined : Swift.RawRepresentable {}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension Network.NWProtocolWebSocket.Response.Status : Swift.Equatable {}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension Network.NWProtocolWebSocket.Response.Status : Swift.Hashable {}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension Network.NWProtocolFramer.StartResult : Swift.Equatable {}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension Network.NWProtocolFramer.StartResult : Swift.Hashable {}
@available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
extension Network.NWProtocolQUIC.Options.Direction : Swift.Equatable {}
@available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
extension Network.NWProtocolQUIC.Options.Direction : Swift.Hashable {}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension Network.NWConnection.EstablishmentReport.Resolution.Source : Swift.Equatable {}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension Network.NWConnection.EstablishmentReport.Resolution.Source : Swift.Hashable {}
@available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
extension Network.NWConnection.EstablishmentReport.Resolution.DNSProtocol : Swift.Equatable {}
@available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
extension Network.NWConnection.EstablishmentReport.Resolution.DNSProtocol : Swift.Hashable {}
@available(macOS 10.14, iOS 12.0, watchOS 5.0, tvOS 12.0, *)
extension Network.IPv6Address.Scope : Swift.Equatable {}
@available(macOS 10.14, iOS 12.0, watchOS 5.0, tvOS 12.0, *)
extension Network.IPv6Address.Scope : Swift.Hashable {}
@available(macOS 10.14, iOS 12.0, watchOS 5.0, tvOS 12.0, *)
extension Network.IPv6Address.Scope : Swift.RawRepresentable {}
@available(macOS 10.14, iOS 12.0, watchOS 5.0, tvOS 12.0, *)
extension Network.NWInterface.InterfaceType : Swift.Equatable {}
@available(macOS 10.14, iOS 12.0, watchOS 5.0, tvOS 12.0, *)
extension Network.NWInterface.InterfaceType : Swift.Hashable {}
@available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
extension Network.NWInterface.RadioType.WiFi : Swift.Equatable {}
@available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
extension Network.NWInterface.RadioType.WiFi : Swift.Hashable {}
@available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
extension Network.NWInterface.RadioType.Cellular.NewRadio5GVariant : Swift.Equatable {}
@available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
extension Network.NWInterface.RadioType.Cellular.NewRadio5GVariant : Swift.Hashable {}
@available(macOS 10.14, iOS 12.0, watchOS 5.0, tvOS 12.0, *)
extension Network.NWPath.Status : Swift.Equatable {}
@available(macOS 10.14, iOS 12.0, watchOS 5.0, tvOS 12.0, *)
extension Network.NWPath.Status : Swift.Hashable {}
@available(macOS 11.0, iOS 14.2, watchOS 7.1, tvOS 14.2, *)
extension Network.NWPath.UnsatisfiedReason : Swift.Equatable {}
@available(macOS 11.0, iOS 14.2, watchOS 7.1, tvOS 14.2, *)
extension Network.NWPath.UnsatisfiedReason : Swift.Hashable {}
@available(macOS 10.14, iOS 12.0, watchOS 5.0, tvOS 12.0, *)
extension Network.NWParameters.ServiceClass : Swift.Equatable {}
@available(macOS 10.14, iOS 12.0, watchOS 5.0, tvOS 12.0, *)
extension Network.NWParameters.ServiceClass : Swift.Hashable {}
@available(macOS 10.14, iOS 12.0, watchOS 5.0, tvOS 12.0, *)
extension Network.NWParameters.MultipathServiceType : Swift.Equatable {}
@available(macOS 10.14, iOS 12.0, watchOS 5.0, tvOS 12.0, *)
extension Network.NWParameters.MultipathServiceType : Swift.Hashable {}
@available(macOS 10.14, iOS 12.0, watchOS 5.0, tvOS 12.0, *)
extension Network.NWParameters.ExpiredDNSBehavior : Swift.Equatable {}
@available(macOS 10.14, iOS 12.0, watchOS 5.0, tvOS 12.0, *)
extension Network.NWParameters.ExpiredDNSBehavior : Swift.Hashable {}
@available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
extension Network.NWParameters.Attribution : Swift.Hashable {}
