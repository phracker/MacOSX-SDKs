// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 5.5.2 (swiftlang-1300.0.46.202 clang-1300.0.29.30)
// swift-module-flags: -disable-objc-attr-requires-foundation-module -target x86_64-apple-macosx10.15 -enable-objc-interop -enable-library-evolution -module-link-name swift_Concurrency -parse-stdlib -swift-version 5 -O -enforce-exclusivity=unchecked -enable-experimental-concurrency -module-name _Concurrency -disable-availability-checking
import Swift
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
public protocol Actor : AnyObject, Swift.Sendable {
  nonisolated var unownedExecutor: _Concurrency.UnownedSerialExecutor { get }
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@_silgen_name("swift_defaultActor_initialize")
public func _defaultActorInitialize(_ actor: Swift.AnyObject)
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@_silgen_name("swift_defaultActor_destroy")
public func _defaultActorDestroy(_ actor: Swift.AnyObject)
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@_silgen_name("swift_task_enqueueMainExecutor")
@usableFromInline
internal func _enqueueOnMain(_ job: _Concurrency.UnownedJob)

#if compiler(>=5.3) && $AsyncAwait && $Sendable
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@_silgen_name("swift_asyncLet_start")
public func _asyncLetStart<T>(asyncLet: Builtin.RawPointer, options: Builtin.RawPointer?, operation: @Sendable () async throws -> T)
#endif


#if compiler(>=5.3) && $AsyncAwait
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@_silgen_name("swift_asyncLet_wait")
public func _asyncLetGet<T>(asyncLet: Builtin.RawPointer) async -> T
#endif


#if compiler(>=5.3) && $AsyncAwait
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@_silgen_name("swift_asyncLet_wait_throwing")
public func _asyncLetGetThrowing<T>(asyncLet: Builtin.RawPointer) async throws -> T
#endif

@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@_silgen_name("swift_asyncLet_end")
public func _asyncLetEnd(asyncLet: Builtin.RawPointer)

#if compiler(>=5.3) && $AsyncAwait
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@_silgen_name("swift_asyncLet_get")
public func _asyncLet_get(_ asyncLet: Builtin.RawPointer, _ resultBuffer: Builtin.RawPointer) async -> Builtin.RawPointer
#endif


#if compiler(>=5.3) && $AsyncAwait
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@_silgen_name("swift_asyncLet_get_throwing")
public func _asyncLet_get_throwing(_ asyncLet: Builtin.RawPointer, _ resultBuffer: Builtin.RawPointer) async throws -> Builtin.RawPointer
#endif


#if compiler(>=5.3) && $AsyncAwait
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@_silgen_name("swift_asyncLet_finish")
public func _asyncLet_finish(_ asyncLet: Builtin.RawPointer, _ resultBuffer: Builtin.RawPointer) async
#endif

@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
public struct CheckedContinuation<T, E> where E : Swift.Error {
  public init(continuation: _Concurrency.UnsafeContinuation<T, E>, function: Swift.String = #function)
  public func resume(returning x: __owned T)
  public func resume(throwing x: __owned E)
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.CheckedContinuation {
  @_alwaysEmitIntoClient public func resume<Er>(with result: Swift.Result<T, Er>) where E == Swift.Error, Er : Swift.Error {
    switch result {
      case .success(let val):
        self.resume(returning: val)
      case .failure(let err):
        self.resume(throwing: err)
    }
  }
  @_alwaysEmitIntoClient public func resume(with result: Swift.Result<T, E>) {
    switch result {
      case .success(let val):
        self.resume(returning: val)
      case .failure(let err):
        self.resume(throwing: err)
    }
  }
  @_alwaysEmitIntoClient public func resume() where T == Swift.Void {
    self.resume(returning: ())
  }
}

#if compiler(>=5.3) && $AsyncAwait
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
public func withCheckedContinuation<T>(function: Swift.String = #function, _ body: (_Concurrency.CheckedContinuation<T, Swift.Never>) -> Swift.Void) async -> T
#endif


#if compiler(>=5.3) && $AsyncAwait
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
public func withCheckedThrowingContinuation<T>(function: Swift.String = #function, _ body: (_Concurrency.CheckedContinuation<T, Swift.Error>) -> Swift.Void) async throws -> T
#endif


#if compiler(>=5.3) && $AsyncAwait
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@_silgen_name("swift_deletedAsyncMethodError")
public func swift_deletedAsyncMethodError() async
#endif

@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
public protocol Executor : AnyObject, Swift.Sendable {
  func enqueue(_ job: _Concurrency.UnownedJob)
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
public protocol SerialExecutor : _Concurrency.Executor {
  @_nonoverride func enqueue(_ job: _Concurrency.UnownedJob)
  func asUnownedSerialExecutor() -> _Concurrency.UnownedSerialExecutor
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@frozen public struct UnownedSerialExecutor {
  
  #if compiler(>=5.3) && $BuiltinExecutor
  @usableFromInline
  internal var executor: Builtin.Executor
  #endif

  
  #if compiler(>=5.3) && $BuiltinExecutor
  @inlinable internal init(_ executor: Builtin.Executor) {
    #if compiler(>=5.5) && $BuiltinExecutor
    self.executor = executor
    #endif
  }
  #endif

  @inlinable public init<E>(ordinary executor: __shared E) where E : _Concurrency.SerialExecutor {
    #if compiler(>=5.5) && $BuiltinBuildExecutor
    self.executor = Builtin.buildOrdinarySerialExecutorRef(executor)
    #else
    fatalError("Swift compiler is incompatible with this SDK version")
    #endif
  }
}

#if compiler(>=5.3) && $BuiltinExecutor
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@_transparent public func _checkExpectedExecutor(_filenameStart: Builtin.RawPointer, _filenameLength: Builtin.Word, _filenameIsASCII: Builtin.Int1, _line: Builtin.Word, _executor: Builtin.Executor) {
  if _taskIsCurrentExecutor(_executor) {
    return
  }

  _reportUnexpectedExecutor(
    _filenameStart, _filenameLength, _filenameIsASCII, _line, _executor)
}
#endif


#if compiler(>=5.3) && $RethrowsProtocol
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.AsyncSequence {
  
  #if compiler(>=5.3) && $AsyncAwait
  @inlinable __consuming public func compactMap<ElementOfResult>(_ transform: @escaping (Self.Element) async -> ElementOfResult?) -> _Concurrency.AsyncCompactMapSequence<Self, ElementOfResult> {
    return AsyncCompactMapSequence(self, transform: transform)
  }
  #endif

}
#endif


#if compiler(>=5.3) && $RethrowsProtocol
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
public struct AsyncCompactMapSequence<Base, ElementOfResult> where Base : _Concurrency.AsyncSequence {
  @usableFromInline
  internal let base: Base
  @usableFromInline
  internal let transform: (Base.Element) async -> ElementOfResult?
  
  #if compiler(>=5.3) && $AsyncAwait
  @usableFromInline
  internal init(_ base: Base, transform: @escaping (Base.Element) async -> ElementOfResult?)
  #endif

}
#endif


#if compiler(>=5.3) && $RethrowsProtocol
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.AsyncCompactMapSequence : _Concurrency.AsyncSequence {
  public typealias Element = ElementOfResult
  public typealias AsyncIterator = _Concurrency.AsyncCompactMapSequence<Base, ElementOfResult>.Iterator
  public struct Iterator : _Concurrency.AsyncIteratorProtocol {
    public typealias Element = ElementOfResult
    @usableFromInline
    internal var baseIterator: Base.AsyncIterator
    @usableFromInline
    internal let transform: (Base.Element) async -> ElementOfResult?
    
    #if compiler(>=5.3) && $AsyncAwait
    @usableFromInline
    internal init(_ baseIterator: Base.AsyncIterator, transform: @escaping (Base.Element) async -> ElementOfResult?)
    #endif

    
    #if compiler(>=5.3) && $AsyncAwait
    @inlinable public mutating func next() async rethrows -> ElementOfResult? {
      while true {
        guard let element = try await baseIterator.next() else {
          return nil
        }

        if let transformed = await transform(element) {
          return transformed
        }
      }
    }
    #endif

  }
  @inlinable __consuming public func makeAsyncIterator() -> _Concurrency.AsyncCompactMapSequence<Base, ElementOfResult>.Iterator {
    return Iterator(base.makeAsyncIterator(), transform: transform)
  }
}
#endif


#if compiler(>=5.3) && $RethrowsProtocol
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.AsyncSequence {
  @inlinable __consuming public func dropFirst(_ count: Swift.Int = 1) -> _Concurrency.AsyncDropFirstSequence<Self> {
    precondition(count >= 0, 
      "Can't drop a negative number of elements from an async sequence")
    return AsyncDropFirstSequence(self, dropping: count)
  }
}
#endif


#if compiler(>=5.3) && $RethrowsProtocol
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
public struct AsyncDropFirstSequence<Base> where Base : _Concurrency.AsyncSequence {
  @usableFromInline
  internal let base: Base
  @usableFromInline
  internal let count: Swift.Int
  @usableFromInline
  internal init(_ base: Base, dropping count: Swift.Int)
}
#endif


#if compiler(>=5.3) && $RethrowsProtocol
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.AsyncDropFirstSequence : _Concurrency.AsyncSequence {
  public typealias Element = Base.Element
  public typealias AsyncIterator = _Concurrency.AsyncDropFirstSequence<Base>.Iterator
  public struct Iterator : _Concurrency.AsyncIteratorProtocol {
    @usableFromInline
    internal var baseIterator: Base.AsyncIterator
    @usableFromInline
    internal var count: Swift.Int
    @usableFromInline
    internal init(_ baseIterator: Base.AsyncIterator, count: Swift.Int)
    
    #if compiler(>=5.3) && $AsyncAwait
    @inlinable public mutating func next() async rethrows -> Base.Element? {
      var remainingToDrop = count
      while remainingToDrop > 0 {
        guard try await baseIterator.next() != nil else {
          count = 0
          return nil
        }
        remainingToDrop -= 1
      }
      count = 0
      return try await baseIterator.next()
    }
    #endif

    public typealias Element = Base.Element
  }
  @inlinable __consuming public func makeAsyncIterator() -> _Concurrency.AsyncDropFirstSequence<Base>.Iterator {
    return Iterator(base.makeAsyncIterator(), count: count)
  }
}
#endif


#if compiler(>=5.3) && $RethrowsProtocol
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.AsyncDropFirstSequence {
  @inlinable __consuming public func dropFirst(_ count: Swift.Int = 1) -> _Concurrency.AsyncDropFirstSequence<Base> {
    // If this is already a AsyncDropFirstSequence, we can just sum the current 
    // drop count and additional drop count.
    precondition(count >= 0, 
      "Can't drop a negative number of elements from an async sequence")
    return AsyncDropFirstSequence(base, dropping: self.count + count)
  }
}
#endif


#if compiler(>=5.3) && $RethrowsProtocol
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.AsyncSequence {
  
  #if compiler(>=5.3) && $AsyncAwait
  @inlinable __consuming public func drop(while predicate: @escaping (Self.Element) async -> Swift.Bool) -> _Concurrency.AsyncDropWhileSequence<Self> {
    AsyncDropWhileSequence(self, predicate: predicate)
  }
  #endif

}
#endif


#if compiler(>=5.3) && $RethrowsProtocol
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
public struct AsyncDropWhileSequence<Base> where Base : _Concurrency.AsyncSequence {
  @usableFromInline
  internal let base: Base
  @usableFromInline
  internal let predicate: (Base.Element) async -> Swift.Bool
  
  #if compiler(>=5.3) && $AsyncAwait
  @usableFromInline
  internal init(_ base: Base, predicate: @escaping (Base.Element) async -> Swift.Bool)
  #endif

}
#endif


#if compiler(>=5.3) && $RethrowsProtocol
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.AsyncDropWhileSequence : _Concurrency.AsyncSequence {
  public typealias Element = Base.Element
  public typealias AsyncIterator = _Concurrency.AsyncDropWhileSequence<Base>.Iterator
  public struct Iterator : _Concurrency.AsyncIteratorProtocol {
    @usableFromInline
    internal var baseIterator: Base.AsyncIterator
    @usableFromInline
    internal var predicate: ((Base.Element) async -> Swift.Bool)?
    
    #if compiler(>=5.3) && $AsyncAwait
    @usableFromInline
    internal init(_ baseIterator: Base.AsyncIterator, predicate: @escaping (Base.Element) async -> Swift.Bool)
    #endif

    
    #if compiler(>=5.3) && $AsyncAwait
    @inlinable public mutating func next() async rethrows -> Base.Element? {
      while let predicate = self.predicate {
        guard let element = try await baseIterator.next() else {
          return nil
        }
        if await predicate(element) == false {
          self.predicate = nil
          return element
        }
      }
      return try await baseIterator.next()
    }
    #endif

    public typealias Element = Base.Element
  }
  @inlinable __consuming public func makeAsyncIterator() -> _Concurrency.AsyncDropWhileSequence<Base>.Iterator {
    return Iterator(base.makeAsyncIterator(), predicate: predicate)
  }
}
#endif


#if compiler(>=5.3) && $RethrowsProtocol
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.AsyncSequence {
  
  #if compiler(>=5.3) && $AsyncAwait
  @inlinable __consuming public func filter(_ isIncluded: @escaping (Self.Element) async -> Swift.Bool) -> _Concurrency.AsyncFilterSequence<Self> {
    return AsyncFilterSequence(self, isIncluded: isIncluded)
  }
  #endif

}
#endif


#if compiler(>=5.3) && $RethrowsProtocol
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
public struct AsyncFilterSequence<Base> where Base : _Concurrency.AsyncSequence {
  @usableFromInline
  internal let base: Base
  @usableFromInline
  internal let isIncluded: (_Concurrency.AsyncFilterSequence<Base>.Element) async -> Swift.Bool
  
  #if compiler(>=5.3) && $AsyncAwait
  @usableFromInline
  internal init(_ base: Base, isIncluded: @escaping (Base.Element) async -> Swift.Bool)
  #endif

}
#endif


#if compiler(>=5.3) && $RethrowsProtocol
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.AsyncFilterSequence : _Concurrency.AsyncSequence {
  public typealias Element = Base.Element
  public typealias AsyncIterator = _Concurrency.AsyncFilterSequence<Base>.Iterator
  public struct Iterator : _Concurrency.AsyncIteratorProtocol {
    @usableFromInline
    internal var baseIterator: Base.AsyncIterator
    @usableFromInline
    internal let isIncluded: (Base.Element) async -> Swift.Bool
    
    #if compiler(>=5.3) && $AsyncAwait
    @usableFromInline
    internal init(_ baseIterator: Base.AsyncIterator, isIncluded: @escaping (Base.Element) async -> Swift.Bool)
    #endif

    
    #if compiler(>=5.3) && $AsyncAwait
    @inlinable public mutating func next() async rethrows -> Base.Element? {
      while true {
        guard let element = try await baseIterator.next() else {
          return nil
        }
        if await isIncluded(element) {
          return element
        }
      }
    }
    #endif

    public typealias Element = Base.Element
  }
  @inlinable __consuming public func makeAsyncIterator() -> _Concurrency.AsyncFilterSequence<Base>.Iterator {
    return Iterator(base.makeAsyncIterator(), isIncluded: isIncluded)
  }
}
#endif


#if compiler(>=5.3) && $RethrowsProtocol
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.AsyncSequence {
  
  #if compiler(>=5.3) && $AsyncAwait
  @inlinable __consuming public func flatMap<SegmentOfResult>(_ transform: @escaping (Self.Element) async -> SegmentOfResult) -> _Concurrency.AsyncFlatMapSequence<Self, SegmentOfResult> where SegmentOfResult : _Concurrency.AsyncSequence {
    return AsyncFlatMapSequence(self, transform: transform)
  }
  #endif

}
#endif


#if compiler(>=5.3) && $RethrowsProtocol
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
public struct AsyncFlatMapSequence<Base, SegmentOfResult> where Base : _Concurrency.AsyncSequence, SegmentOfResult : _Concurrency.AsyncSequence {
  @usableFromInline
  internal let base: Base
  @usableFromInline
  internal let transform: (Base.Element) async -> SegmentOfResult
  
  #if compiler(>=5.3) && $AsyncAwait
  @usableFromInline
  internal init(_ base: Base, transform: @escaping (Base.Element) async -> SegmentOfResult)
  #endif

}
#endif


#if compiler(>=5.3) && $RethrowsProtocol
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.AsyncFlatMapSequence : _Concurrency.AsyncSequence {
  public typealias Element = SegmentOfResult.Element
  public typealias AsyncIterator = _Concurrency.AsyncFlatMapSequence<Base, SegmentOfResult>.Iterator
  public struct Iterator : _Concurrency.AsyncIteratorProtocol {
    @usableFromInline
    internal var baseIterator: Base.AsyncIterator
    @usableFromInline
    internal let transform: (Base.Element) async -> SegmentOfResult
    @usableFromInline
    internal var currentIterator: SegmentOfResult.AsyncIterator?
    @usableFromInline
    internal var finished: Swift.Bool
    
    #if compiler(>=5.3) && $AsyncAwait
    @usableFromInline
    internal init(_ baseIterator: Base.AsyncIterator, transform: @escaping (Base.Element) async -> SegmentOfResult)
    #endif

    
    #if compiler(>=5.3) && $AsyncAwait
    @inlinable public mutating func next() async rethrows -> SegmentOfResult.Element? {
      while !finished {
        if var iterator = currentIterator {
          do {
            guard let element = try await iterator.next() else {
              currentIterator = nil
              continue
            }
            // restore the iterator since we just mutated it with next
            currentIterator = iterator
            return element
          } catch {
            finished = true
            throw error
          }
        } else {
          guard let item = try await baseIterator.next() else {
            finished = true
            return nil
          }
          do { 
            let segment = await transform(item)
            var iterator = segment.makeAsyncIterator()
            guard let element = try await iterator.next() else {
              currentIterator = nil
              continue
            }
            currentIterator = iterator
            return element
          } catch {
            finished = true
            throw error
          }
        }
      }
      return nil
    }
    #endif

    public typealias Element = SegmentOfResult.Element
  }
  @inlinable __consuming public func makeAsyncIterator() -> _Concurrency.AsyncFlatMapSequence<Base, SegmentOfResult>.Iterator {
    return Iterator(base.makeAsyncIterator(), transform: transform)
  }
}
#endif


#if compiler(>=5.3) && $RethrowsProtocol
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@rethrows public protocol AsyncIteratorProtocol {
  associatedtype Element
  
  #if compiler(>=5.3) && $AsyncAwait
  mutating func next() async throws -> Self.Element?
  #endif

}
#endif


#if compiler(>=5.3) && $RethrowsProtocol
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.AsyncSequence {
  
  #if compiler(>=5.3) && $AsyncAwait
  @inlinable __consuming public func map<Transformed>(_ transform: @escaping (Self.Element) async -> Transformed) -> _Concurrency.AsyncMapSequence<Self, Transformed> {
    return AsyncMapSequence(self, transform: transform)
  }
  #endif

}
#endif


#if compiler(>=5.3) && $RethrowsProtocol
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
public struct AsyncMapSequence<Base, Transformed> where Base : _Concurrency.AsyncSequence {
  @usableFromInline
  internal let base: Base
  @usableFromInline
  internal let transform: (Base.Element) async -> Transformed
  
  #if compiler(>=5.3) && $AsyncAwait
  @usableFromInline
  internal init(_ base: Base, transform: @escaping (Base.Element) async -> Transformed)
  #endif

}
#endif


#if compiler(>=5.3) && $RethrowsProtocol
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.AsyncMapSequence : _Concurrency.AsyncSequence {
  public typealias Element = Transformed
  public typealias AsyncIterator = _Concurrency.AsyncMapSequence<Base, Transformed>.Iterator
  public struct Iterator : _Concurrency.AsyncIteratorProtocol {
    @usableFromInline
    internal var baseIterator: Base.AsyncIterator
    @usableFromInline
    internal let transform: (Base.Element) async -> Transformed
    
    #if compiler(>=5.3) && $AsyncAwait
    @usableFromInline
    internal init(_ baseIterator: Base.AsyncIterator, transform: @escaping (Base.Element) async -> Transformed)
    #endif

    
    #if compiler(>=5.3) && $AsyncAwait
    @inlinable public mutating func next() async rethrows -> Transformed? {
      guard let element = try await baseIterator.next() else {
        return nil
      }
      return await transform(element)
    }
    #endif

    public typealias Element = Transformed
  }
  @inlinable __consuming public func makeAsyncIterator() -> _Concurrency.AsyncMapSequence<Base, Transformed>.Iterator {
    return Iterator(base.makeAsyncIterator(), transform: transform)
  }
}
#endif


#if compiler(>=5.3) && $RethrowsProtocol
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.AsyncSequence {
  @inlinable __consuming public func prefix(_ count: Swift.Int) -> _Concurrency.AsyncPrefixSequence<Self> {
    precondition(count >= 0,
      "Can't prefix a negative number of elements from an async sequence")
    return AsyncPrefixSequence(self, count: count)
  }
}
#endif


#if compiler(>=5.3) && $RethrowsProtocol
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
public struct AsyncPrefixSequence<Base> where Base : _Concurrency.AsyncSequence {
  @usableFromInline
  internal let base: Base
  @usableFromInline
  internal let count: Swift.Int
  @usableFromInline
  internal init(_ base: Base, count: Swift.Int)
}
#endif


#if compiler(>=5.3) && $RethrowsProtocol
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.AsyncPrefixSequence : _Concurrency.AsyncSequence {
  public typealias Element = Base.Element
  public typealias AsyncIterator = _Concurrency.AsyncPrefixSequence<Base>.Iterator
  public struct Iterator : _Concurrency.AsyncIteratorProtocol {
    @usableFromInline
    internal var baseIterator: Base.AsyncIterator
    @usableFromInline
    internal var remaining: Swift.Int
    @usableFromInline
    internal init(_ baseIterator: Base.AsyncIterator, count: Swift.Int)
    
    #if compiler(>=5.3) && $AsyncAwait
    @inlinable public mutating func next() async rethrows -> Base.Element? {
      if remaining != 0 {
        remaining &-= 1
        return try await baseIterator.next()
      } else {
        return nil
      }
    }
    #endif

    public typealias Element = Base.Element
  }
  @inlinable __consuming public func makeAsyncIterator() -> _Concurrency.AsyncPrefixSequence<Base>.Iterator {
    return Iterator(base.makeAsyncIterator(), count: count)
  }
}
#endif


#if compiler(>=5.3) && $RethrowsProtocol
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.AsyncSequence {
  
  #if compiler(>=5.3) && $AsyncAwait
  @inlinable __consuming public func prefix(while predicate: @escaping (Self.Element) async -> Swift.Bool) rethrows -> _Concurrency.AsyncPrefixWhileSequence<Self> {
    return AsyncPrefixWhileSequence(self, predicate: predicate)
  }
  #endif

}
#endif


#if compiler(>=5.3) && $RethrowsProtocol
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
public struct AsyncPrefixWhileSequence<Base> where Base : _Concurrency.AsyncSequence {
  @usableFromInline
  internal let base: Base
  @usableFromInline
  internal let predicate: (Base.Element) async -> Swift.Bool
  
  #if compiler(>=5.3) && $AsyncAwait
  @usableFromInline
  internal init(_ base: Base, predicate: @escaping (Base.Element) async -> Swift.Bool)
  #endif

}
#endif


#if compiler(>=5.3) && $RethrowsProtocol
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.AsyncPrefixWhileSequence : _Concurrency.AsyncSequence {
  public typealias Element = Base.Element
  public typealias AsyncIterator = _Concurrency.AsyncPrefixWhileSequence<Base>.Iterator
  public struct Iterator : _Concurrency.AsyncIteratorProtocol {
    @usableFromInline
    internal var predicateHasFailed: Swift.Bool
    @usableFromInline
    internal var baseIterator: Base.AsyncIterator
    @usableFromInline
    internal let predicate: (Base.Element) async -> Swift.Bool
    
    #if compiler(>=5.3) && $AsyncAwait
    @usableFromInline
    internal init(_ baseIterator: Base.AsyncIterator, predicate: @escaping (Base.Element) async -> Swift.Bool)
    #endif

    
    #if compiler(>=5.3) && $AsyncAwait
    @inlinable public mutating func next() async rethrows -> Base.Element? {
      if !predicateHasFailed, let nextElement = try await baseIterator.next() {
        if await predicate(nextElement) {
          return nextElement
        } else {
          predicateHasFailed = true
        }
      }
      return nil
    }
    #endif

    public typealias Element = Base.Element
  }
  @inlinable __consuming public func makeAsyncIterator() -> _Concurrency.AsyncPrefixWhileSequence<Base>.Iterator {
    return Iterator(base.makeAsyncIterator(), predicate: predicate)
  }
}
#endif


#if compiler(>=5.3) && $RethrowsProtocol
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@rethrows public protocol AsyncSequence {
  associatedtype AsyncIterator : _Concurrency.AsyncIteratorProtocol
  associatedtype Element where Self.Element == Self.AsyncIterator.Element
  __consuming func makeAsyncIterator() -> Self.AsyncIterator
}
#endif


#if compiler(>=5.3) && $RethrowsProtocol
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.AsyncSequence {
  
  #if compiler(>=5.3) && $AsyncAwait
  @inlinable public func reduce<Result>(_ initialResult: Result, _ nextPartialResult: (_ partialResult: Result, Self.Element) async throws -> Result) async rethrows -> Result {
    var accumulator = initialResult
    var iterator = makeAsyncIterator()
    while let element = try await iterator.next() {
      accumulator = try await nextPartialResult(accumulator, element)
    }
    return accumulator
  }
  #endif

  
  #if compiler(>=5.3) && $AsyncAwait
  @inlinable public func reduce<Result>(into initialResult: __owned Result, _ updateAccumulatingResult: (_ partialResult: inout Result, Self.Element) async throws -> Swift.Void) async rethrows -> Result {
    var accumulator = initialResult
    var iterator = makeAsyncIterator()
    while let element = try await iterator.next() {
      try await updateAccumulatingResult(&accumulator, element)
    }
    return accumulator
  }
  #endif

}
#endif


#if compiler(>=5.3) && $AsyncAwait && $RethrowsProtocol
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@inlinable @inline(__always) internal func _contains<Source>(_ self: Source, where predicate: (Source.Element) async throws -> Swift.Bool) async rethrows -> Swift.Bool where Source : _Concurrency.AsyncSequence {
  for try await element in self {
    if try await predicate(element) {
      return true
    }
  }
  return false
}
#endif


#if compiler(>=5.3) && $RethrowsProtocol
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.AsyncSequence {
  
  #if compiler(>=5.3) && $AsyncAwait
  @inlinable public func contains(where predicate: (Self.Element) async throws -> Swift.Bool) async rethrows -> Swift.Bool {
    return try await _contains(self, where: predicate)
  }
  #endif

  
  #if compiler(>=5.3) && $AsyncAwait
  @inlinable public func allSatisfy(_ predicate: (Self.Element) async throws -> Swift.Bool) async rethrows -> Swift.Bool {
    return try await !contains { try await !predicate($0) }
  }
  #endif

}
#endif


#if compiler(>=5.3) && $RethrowsProtocol
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.AsyncSequence where Self.Element : Swift.Equatable {
  
  #if compiler(>=5.3) && $AsyncAwait
  @inlinable public func contains(_ search: Self.Element) async rethrows -> Swift.Bool {
    for try await element in self {
      if element == search {
        return true
      }
    }
    return false
  }
  #endif

}
#endif


#if compiler(>=5.3) && $AsyncAwait && $RethrowsProtocol
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@inlinable @inline(__always) internal func _first<Source>(_ self: Source, where predicate: (Source.Element) async throws -> Swift.Bool) async rethrows -> Source.Element? where Source : _Concurrency.AsyncSequence {
  for try await element in self {
    if try await predicate(element) {
      return element
    }
  }
  return nil
}
#endif


#if compiler(>=5.3) && $RethrowsProtocol
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.AsyncSequence {
  
  #if compiler(>=5.3) && $AsyncAwait
  @inlinable public func first(where predicate: (Self.Element) async throws -> Swift.Bool) async rethrows -> Self.Element? {
    return try await _first(self, where: predicate)
  }
  #endif

}
#endif


#if compiler(>=5.3) && $RethrowsProtocol
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.AsyncSequence {
  
  #if compiler(>=5.3) && $AsyncAwait
  @warn_unqualified_access
  @inlinable public func min(by areInIncreasingOrder: (Self.Element, Self.Element) async throws -> Swift.Bool) async rethrows -> Self.Element? {
    var it = makeAsyncIterator()
    guard var result = try await it.next() else { 
      return nil 
    }
    while let e = try await it.next() {
      if try await areInIncreasingOrder(e, result) { 
        result = e 
      }
    }
    return result
  }
  #endif

  
  #if compiler(>=5.3) && $AsyncAwait
  @warn_unqualified_access
  @inlinable public func max(by areInIncreasingOrder: (Self.Element, Self.Element) async throws -> Swift.Bool) async rethrows -> Self.Element? {
    var it = makeAsyncIterator()
    guard var result = try await it.next() else { 
      return nil 
    }
    while let e = try await it.next() {
      if try await areInIncreasingOrder(result, e) { 
        result = e 
      }
    }
    return result
  }
  #endif

}
#endif


#if compiler(>=5.3) && $RethrowsProtocol
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.AsyncSequence where Self.Element : Swift.Comparable {
  
  #if compiler(>=5.3) && $AsyncAwait
  @warn_unqualified_access
  @inlinable public func min() async rethrows -> Self.Element? {
    return try await self.min(by: <)
  }
  #endif

  
  #if compiler(>=5.3) && $AsyncAwait
  @warn_unqualified_access
  @inlinable public func max() async rethrows -> Self.Element? {
    return try await self.max(by: <)
  }
  #endif

}
#endif


#if compiler(>=5.3) && $RethrowsProtocol
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.AsyncSequence {
  
  #if compiler(>=5.3) && $AsyncAwait
  @inlinable __consuming public func compactMap<ElementOfResult>(_ transform: @escaping (Self.Element) async throws -> ElementOfResult?) -> _Concurrency.AsyncThrowingCompactMapSequence<Self, ElementOfResult> {
    return AsyncThrowingCompactMapSequence(self, transform: transform)
  }
  #endif

}
#endif


#if compiler(>=5.3) && $RethrowsProtocol
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
public struct AsyncThrowingCompactMapSequence<Base, ElementOfResult> where Base : _Concurrency.AsyncSequence {
  @usableFromInline
  internal let base: Base
  @usableFromInline
  internal let transform: (Base.Element) async throws -> ElementOfResult?
  
  #if compiler(>=5.3) && $AsyncAwait
  @usableFromInline
  internal init(_ base: Base, transform: @escaping (Base.Element) async throws -> ElementOfResult?)
  #endif

}
#endif


#if compiler(>=5.3) && $RethrowsProtocol
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.AsyncThrowingCompactMapSequence : _Concurrency.AsyncSequence {
  public typealias Element = ElementOfResult
  public typealias AsyncIterator = _Concurrency.AsyncThrowingCompactMapSequence<Base, ElementOfResult>.Iterator
  public struct Iterator : _Concurrency.AsyncIteratorProtocol {
    public typealias Element = ElementOfResult
    @usableFromInline
    internal var baseIterator: Base.AsyncIterator
    @usableFromInline
    internal let transform: (Base.Element) async throws -> ElementOfResult?
    @usableFromInline
    internal var finished: Swift.Bool
    
    #if compiler(>=5.3) && $AsyncAwait
    @usableFromInline
    internal init(_ baseIterator: Base.AsyncIterator, transform: @escaping (Base.Element) async throws -> ElementOfResult?)
    #endif

    
    #if compiler(>=5.3) && $AsyncAwait
    @inlinable public mutating func next() async throws -> ElementOfResult? {
      while !finished {
        guard let element = try await baseIterator.next() else {
          finished = true
          return nil
        }
        do {
          if let transformed = try await transform(element) {
            return transformed
          }
        } catch {
          finished = true
          throw error
        }
      }
      return nil
    }
    #endif

  }
  @inlinable __consuming public func makeAsyncIterator() -> _Concurrency.AsyncThrowingCompactMapSequence<Base, ElementOfResult>.Iterator {
    return Iterator(base.makeAsyncIterator(), transform: transform)
  }
}
#endif


#if compiler(>=5.3) && $RethrowsProtocol
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.AsyncSequence {
  
  #if compiler(>=5.3) && $AsyncAwait
  @inlinable __consuming public func drop(while predicate: @escaping (Self.Element) async throws -> Swift.Bool) -> _Concurrency.AsyncThrowingDropWhileSequence<Self> {
    AsyncThrowingDropWhileSequence(self, predicate: predicate)
  }
  #endif

}
#endif


#if compiler(>=5.3) && $RethrowsProtocol
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
public struct AsyncThrowingDropWhileSequence<Base> where Base : _Concurrency.AsyncSequence {
  @usableFromInline
  internal let base: Base
  @usableFromInline
  internal let predicate: (Base.Element) async throws -> Swift.Bool
  
  #if compiler(>=5.3) && $AsyncAwait
  @usableFromInline
  internal init(_ base: Base, predicate: @escaping (Base.Element) async throws -> Swift.Bool)
  #endif

}
#endif


#if compiler(>=5.3) && $RethrowsProtocol
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.AsyncThrowingDropWhileSequence : _Concurrency.AsyncSequence {
  public typealias Element = Base.Element
  public typealias AsyncIterator = _Concurrency.AsyncThrowingDropWhileSequence<Base>.Iterator
  public struct Iterator : _Concurrency.AsyncIteratorProtocol {
    @usableFromInline
    internal var baseIterator: Base.AsyncIterator
    @usableFromInline
    internal let predicate: (Base.Element) async throws -> Swift.Bool
    @usableFromInline
    internal var finished: Swift.Bool
    @usableFromInline
    internal var doneDropping: Swift.Bool
    
    #if compiler(>=5.3) && $AsyncAwait
    @usableFromInline
    internal init(_ baseIterator: Base.AsyncIterator, predicate: @escaping (Base.Element) async throws -> Swift.Bool)
    #endif

    
    #if compiler(>=5.3) && $AsyncAwait
    @inlinable public mutating func next() async throws -> Base.Element? {
      while !finished && !doneDropping {
        guard let element = try await baseIterator.next() else {
          return nil
        }
        do {
          if try await predicate(element) == false {
            doneDropping = true
            return element
          }
        } catch {
          finished = true
          throw error
        }
      }
      guard !finished else { 
        return nil
      }
      return try await baseIterator.next()
    }
    #endif

    public typealias Element = Base.Element
  }
  @inlinable __consuming public func makeAsyncIterator() -> _Concurrency.AsyncThrowingDropWhileSequence<Base>.Iterator {
    return Iterator(base.makeAsyncIterator(), predicate: predicate)
  }
}
#endif


#if compiler(>=5.3) && $RethrowsProtocol
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.AsyncSequence {
  
  #if compiler(>=5.3) && $AsyncAwait
  @inlinable __consuming public func filter(_ isIncluded: @escaping (Self.Element) async throws -> Swift.Bool) -> _Concurrency.AsyncThrowingFilterSequence<Self> {
    return AsyncThrowingFilterSequence(self, isIncluded: isIncluded)
  }
  #endif

}
#endif


#if compiler(>=5.3) && $RethrowsProtocol
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
public struct AsyncThrowingFilterSequence<Base> where Base : _Concurrency.AsyncSequence {
  @usableFromInline
  internal let base: Base
  @usableFromInline
  internal let isIncluded: (_Concurrency.AsyncThrowingFilterSequence<Base>.Element) async throws -> Swift.Bool
  
  #if compiler(>=5.3) && $AsyncAwait
  @usableFromInline
  internal init(_ base: Base, isIncluded: @escaping (Base.Element) async throws -> Swift.Bool)
  #endif

}
#endif


#if compiler(>=5.3) && $RethrowsProtocol
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.AsyncThrowingFilterSequence : _Concurrency.AsyncSequence {
  public typealias Element = Base.Element
  public typealias AsyncIterator = _Concurrency.AsyncThrowingFilterSequence<Base>.Iterator
  public struct Iterator : _Concurrency.AsyncIteratorProtocol {
    @usableFromInline
    internal var baseIterator: Base.AsyncIterator
    @usableFromInline
    internal let isIncluded: (Base.Element) async throws -> Swift.Bool
    @usableFromInline
    internal var finished: Swift.Bool
    
    #if compiler(>=5.3) && $AsyncAwait
    @usableFromInline
    internal init(_ baseIterator: Base.AsyncIterator, isIncluded: @escaping (Base.Element) async throws -> Swift.Bool)
    #endif

    
    #if compiler(>=5.3) && $AsyncAwait
    @inlinable public mutating func next() async throws -> Base.Element? {
      while !finished {
        guard let element = try await baseIterator.next() else {
          return nil
        }
        do {
          if try await isIncluded(element) {
            return element
          }
        } catch {
          finished = true
          throw error
        }
      }

      return nil
    }
    #endif

    public typealias Element = Base.Element
  }
  @inlinable __consuming public func makeAsyncIterator() -> _Concurrency.AsyncThrowingFilterSequence<Base>.Iterator {
    return Iterator(base.makeAsyncIterator(), isIncluded: isIncluded)
  }
}
#endif


#if compiler(>=5.3) && $RethrowsProtocol
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.AsyncSequence {
  
  #if compiler(>=5.3) && $AsyncAwait
  @inlinable __consuming public func flatMap<SegmentOfResult>(_ transform: @escaping (Self.Element) async throws -> SegmentOfResult) -> _Concurrency.AsyncThrowingFlatMapSequence<Self, SegmentOfResult> where SegmentOfResult : _Concurrency.AsyncSequence {
    return AsyncThrowingFlatMapSequence(self, transform: transform)
  }
  #endif

}
#endif


#if compiler(>=5.3) && $RethrowsProtocol
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
public struct AsyncThrowingFlatMapSequence<Base, SegmentOfResult> where Base : _Concurrency.AsyncSequence, SegmentOfResult : _Concurrency.AsyncSequence {
  @usableFromInline
  internal let base: Base
  @usableFromInline
  internal let transform: (Base.Element) async throws -> SegmentOfResult
  
  #if compiler(>=5.3) && $AsyncAwait
  @usableFromInline
  internal init(_ base: Base, transform: @escaping (Base.Element) async throws -> SegmentOfResult)
  #endif

}
#endif


#if compiler(>=5.3) && $RethrowsProtocol
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.AsyncThrowingFlatMapSequence : _Concurrency.AsyncSequence {
  public typealias Element = SegmentOfResult.Element
  public typealias AsyncIterator = _Concurrency.AsyncThrowingFlatMapSequence<Base, SegmentOfResult>.Iterator
  public struct Iterator : _Concurrency.AsyncIteratorProtocol {
    @usableFromInline
    internal var baseIterator: Base.AsyncIterator
    @usableFromInline
    internal let transform: (Base.Element) async throws -> SegmentOfResult
    @usableFromInline
    internal var currentIterator: SegmentOfResult.AsyncIterator?
    @usableFromInline
    internal var finished: Swift.Bool
    
    #if compiler(>=5.3) && $AsyncAwait
    @usableFromInline
    internal init(_ baseIterator: Base.AsyncIterator, transform: @escaping (Base.Element) async throws -> SegmentOfResult)
    #endif

    
    #if compiler(>=5.3) && $AsyncAwait
    @inlinable public mutating func next() async throws -> SegmentOfResult.Element? {
      while !finished {
        if var iterator = currentIterator {
          do {
            guard let element = try await iterator.next() else {
              currentIterator = nil
              continue
            }
            // restore the iterator since we just mutated it with next
            currentIterator = iterator
            return element
          } catch {
            finished = true
            throw error
          }
        } else {
          guard let item = try await baseIterator.next() else {
            return nil
          }
          let segment: SegmentOfResult
          do {
            segment = try await transform(item)
            var iterator = segment.makeAsyncIterator()
            guard let element = try await iterator.next() else {
              currentIterator = nil
              continue
            }
            currentIterator = iterator
            return element
          } catch {
            finished = true
            currentIterator = nil
            throw error
          }
        }
      }
      return nil
    }
    #endif

    public typealias Element = SegmentOfResult.Element
  }
  @inlinable __consuming public func makeAsyncIterator() -> _Concurrency.AsyncThrowingFlatMapSequence<Base, SegmentOfResult>.Iterator {
    return Iterator(base.makeAsyncIterator(), transform: transform)
  }
}
#endif


#if compiler(>=5.3) && $RethrowsProtocol
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.AsyncSequence {
  
  #if compiler(>=5.3) && $AsyncAwait
  @inlinable __consuming public func map<Transformed>(_ transform: @escaping (Self.Element) async throws -> Transformed) -> _Concurrency.AsyncThrowingMapSequence<Self, Transformed> {
    return AsyncThrowingMapSequence(self, transform: transform)
  }
  #endif

}
#endif


#if compiler(>=5.3) && $RethrowsProtocol
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
public struct AsyncThrowingMapSequence<Base, Transformed> where Base : _Concurrency.AsyncSequence {
  @usableFromInline
  internal let base: Base
  @usableFromInline
  internal let transform: (Base.Element) async throws -> Transformed
  
  #if compiler(>=5.3) && $AsyncAwait
  @usableFromInline
  internal init(_ base: Base, transform: @escaping (Base.Element) async throws -> Transformed)
  #endif

}
#endif


#if compiler(>=5.3) && $RethrowsProtocol
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.AsyncThrowingMapSequence : _Concurrency.AsyncSequence {
  public typealias Element = Transformed
  public typealias AsyncIterator = _Concurrency.AsyncThrowingMapSequence<Base, Transformed>.Iterator
  public struct Iterator : _Concurrency.AsyncIteratorProtocol {
    @usableFromInline
    internal var baseIterator: Base.AsyncIterator
    @usableFromInline
    internal let transform: (Base.Element) async throws -> Transformed
    @usableFromInline
    internal var finished: Swift.Bool
    
    #if compiler(>=5.3) && $AsyncAwait
    @usableFromInline
    internal init(_ baseIterator: Base.AsyncIterator, transform: @escaping (Base.Element) async throws -> Transformed)
    #endif

    
    #if compiler(>=5.3) && $AsyncAwait
    @inlinable public mutating func next() async throws -> Transformed? {
      guard !finished, let element = try await baseIterator.next() else {
        return nil
      }
      do {
        return try await transform(element)
      } catch {
        finished = true
        throw error   
      }
    }
    #endif

    public typealias Element = Transformed
  }
  @inlinable __consuming public func makeAsyncIterator() -> _Concurrency.AsyncThrowingMapSequence<Base, Transformed>.Iterator {
    return Iterator(base.makeAsyncIterator(), transform: transform)
  }
}
#endif


#if compiler(>=5.3) && $RethrowsProtocol
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.AsyncSequence {
  
  #if compiler(>=5.3) && $AsyncAwait
  @inlinable __consuming public func prefix(while predicate: @escaping (Self.Element) async throws -> Swift.Bool) rethrows -> _Concurrency.AsyncThrowingPrefixWhileSequence<Self> {
    return AsyncThrowingPrefixWhileSequence(self, predicate: predicate)
  }
  #endif

}
#endif


#if compiler(>=5.3) && $RethrowsProtocol
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
public struct AsyncThrowingPrefixWhileSequence<Base> where Base : _Concurrency.AsyncSequence {
  @usableFromInline
  internal let base: Base
  @usableFromInline
  internal let predicate: (Base.Element) async throws -> Swift.Bool
  
  #if compiler(>=5.3) && $AsyncAwait
  @usableFromInline
  internal init(_ base: Base, predicate: @escaping (Base.Element) async throws -> Swift.Bool)
  #endif

}
#endif


#if compiler(>=5.3) && $RethrowsProtocol
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.AsyncThrowingPrefixWhileSequence : _Concurrency.AsyncSequence {
  public typealias Element = Base.Element
  public typealias AsyncIterator = _Concurrency.AsyncThrowingPrefixWhileSequence<Base>.Iterator
  public struct Iterator : _Concurrency.AsyncIteratorProtocol {
    @usableFromInline
    internal var predicateHasFailed: Swift.Bool
    @usableFromInline
    internal var baseIterator: Base.AsyncIterator
    @usableFromInline
    internal let predicate: (Base.Element) async throws -> Swift.Bool
    
    #if compiler(>=5.3) && $AsyncAwait
    @usableFromInline
    internal init(_ baseIterator: Base.AsyncIterator, predicate: @escaping (Base.Element) async throws -> Swift.Bool)
    #endif

    
    #if compiler(>=5.3) && $AsyncAwait
    @inlinable public mutating func next() async throws -> Base.Element? {
      if !predicateHasFailed, let nextElement = try await baseIterator.next() {
        do { 
          if try await predicate(nextElement) {
            return nextElement
          } else {
            predicateHasFailed = true
          }
        } catch {
          predicateHasFailed = true
          throw error
        }
      }
      return nil
    }
    #endif

    public typealias Element = Base.Element
  }
  @inlinable __consuming public func makeAsyncIterator() -> _Concurrency.AsyncThrowingPrefixWhileSequence<Base>.Iterator {
    return Iterator(base.makeAsyncIterator(), predicate: predicate)
  }
}
#endif

@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
public protocol GlobalActor {
  associatedtype ActorType : _Concurrency.Actor
  static var shared: Self.ActorType { get }
  static var sharedUnownedExecutor: _Concurrency.UnownedSerialExecutor { get }
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.GlobalActor {
  public static var sharedUnownedExecutor: _Concurrency.UnownedSerialExecutor {
    get
  }
}

#if compiler(>=5.3) && $Actors && $GlobalActors
@_hasMissingDesignatedInitializers @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@globalActor final public actor MainActor : _Concurrency.GlobalActor {
  public static let shared: _Concurrency.MainActor
  @inlinable nonisolated final public var unownedExecutor: _Concurrency.UnownedSerialExecutor {
    get {
    #if compiler(>=5.5) && $BuiltinBuildMainExecutor
    return UnownedSerialExecutor(Builtin.buildMainActorExecutorRef())
    #else
    fatalError("Swift compiler is incompatible with this SDK version")
    #endif
  }
  }
  @inlinable public static var sharedUnownedExecutor: _Concurrency.UnownedSerialExecutor {
    get {
    #if compiler(>=5.5) && $BuiltinBuildMainExecutor
    return UnownedSerialExecutor(Builtin.buildMainActorExecutorRef())
    #else
    fatalError("Swift compiler is incompatible with this SDK version")
    #endif
  }
  }
  @inlinable nonisolated final public func enqueue(_ job: _Concurrency.UnownedJob) {
    _enqueueOnMain(job)
  }
  public typealias ActorType = _Concurrency.MainActor
  @objc deinit
}
#endif


#if compiler(>=5.3) && $Actors && $GlobalActors
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.MainActor {
  
  #if compiler(>=5.3) && $AsyncAwait && $Sendable
  @_silgen_name("$sScM3run10resultType4bodyxxm_xyYbKScMYcXEtYaKlFZ")
  @usableFromInline
  internal static func _historicalRunForABI<T>(resultType: T.Type = T.self, body: @_Concurrency.MainActor @Sendable () throws -> T) async rethrows -> T
  #endif

  
  #if compiler(>=5.3) && $AsyncAwait && $Sendable
  @_silgen_name("$sScM12runAndReturn10resultType4bodyxxm_xyYbKScMYcXEtYaKlFZ")
  @_alwaysEmitIntoClient public static func run<T>(resultType: T.Type = T.self, body: @_Concurrency.MainActor @Sendable () throws -> T) async rethrows -> T {
    return try await body()
  }
  #endif

}
#endif

@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@_silgen_name("swift_job_run")
@usableFromInline
internal func _swiftJobRun(_ job: _Concurrency.UnownedJob, _ executor: _Concurrency.UnownedSerialExecutor)
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@frozen public struct UnownedJob {
  
  #if compiler(>=5.3) && $BuiltinJob
  private var context: Builtin.Job
  #endif

  @_alwaysEmitIntoClient @inlinable public func _runSynchronously(on executor: _Concurrency.UnownedSerialExecutor) {
      _swiftJobRun(self, executor)
  }
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@frozen public struct UnsafeContinuation<T, E> where E : Swift.Error {
  @usableFromInline
  internal var context: Builtin.RawUnsafeContinuation
  @_alwaysEmitIntoClient internal init(_ context: Builtin.RawUnsafeContinuation) {
    self.context = context
  }
  @_alwaysEmitIntoClient public func resume(returning value: __owned T) where E == Swift.Never {
    #if compiler(>=5.5) && $BuiltinContinuation
    Builtin.resumeNonThrowingContinuationReturning(context, value)
    #else
    fatalError("Swift compiler is incompatible with this SDK version")
    #endif
  }
  @_alwaysEmitIntoClient public func resume(returning value: __owned T) {
    #if compiler(>=5.5) && $BuiltinContinuation
    Builtin.resumeThrowingContinuationReturning(context, value)
    #else
    fatalError("Swift compiler is incompatible with this SDK version")
    #endif
  }
  @_alwaysEmitIntoClient public func resume(throwing error: __owned E) {
#if compiler(>=5.5) && $BuiltinContinuation
    Builtin.resumeThrowingContinuationThrowing(context, error)
#else
    fatalError("Swift compiler is incompatible with this SDK version")
#endif
  }
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.UnsafeContinuation {
  @_alwaysEmitIntoClient public func resume<Er>(with result: Swift.Result<T, Er>) where E == Swift.Error, Er : Swift.Error {
    switch result {
      case .success(let val):
        self.resume(returning: val)
      case .failure(let err):
        self.resume(throwing: err)
    }
  }
  @_alwaysEmitIntoClient public func resume(with result: Swift.Result<T, E>) {
    switch result {
      case .success(let val):
        self.resume(returning: val)
      case .failure(let err):
        self.resume(throwing: err)
    }
  }
  @_alwaysEmitIntoClient public func resume() where T == Swift.Void {
    self.resume(returning: ())
  }
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@_alwaysEmitIntoClient internal func _resumeUnsafeContinuation<T>(_ continuation: _Concurrency.UnsafeContinuation<T, Swift.Never>, _ value: __owned T) {
  continuation.resume(returning: value)
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@_alwaysEmitIntoClient internal func _resumeUnsafeThrowingContinuation<T>(_ continuation: _Concurrency.UnsafeContinuation<T, Swift.Error>, _ value: __owned T) {
  continuation.resume(returning: value)
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@_alwaysEmitIntoClient internal func _resumeUnsafeThrowingContinuationWithError<T>(_ continuation: _Concurrency.UnsafeContinuation<T, Swift.Error>, _ error: __owned Swift.Error) {
  continuation.resume(throwing: error)
}

#if compiler(>=5.3) && $AsyncAwait
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@_alwaysEmitIntoClient public func withUnsafeContinuation<T>(_ fn: (_Concurrency.UnsafeContinuation<T, Swift.Never>) -> Swift.Void) async -> T {
  return await Builtin.withUnsafeContinuation {
    fn(UnsafeContinuation<T, Never>($0))
  }
}
#endif


#if compiler(>=5.3) && $AsyncAwait
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@_alwaysEmitIntoClient public func withUnsafeThrowingContinuation<T>(_ fn: (_Concurrency.UnsafeContinuation<T, Swift.Error>) -> Swift.Void) async throws -> T {
  return try await Builtin.withUnsafeThrowingContinuation {
    fn(UnsafeContinuation<T, Error>($0))
  }
}
#endif

@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@_alwaysEmitIntoClient public func _abiEnableAwaitContinuation() {
  fatalError("never use this function")
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.Task where Success == Swift.Never, Failure == Swift.Never {
  @available(*, deprecated, message: "Task.Priority has been removed; use TaskPriority")
  public typealias Priority = _Concurrency.TaskPriority
  @available(*, deprecated, message: "Task.Handle has been removed; use Task")
  public typealias Handle = _Concurrency.Task
  @available(*, deprecated, message: "Task.CancellationError has been removed; use CancellationError")
  @_alwaysEmitIntoClient public static func CancellationError() -> _Concurrency.CancellationError {
    return _Concurrency.CancellationError()
  }
  
  #if compiler(>=5.3) && $AsyncAwait
  @available(*, deprecated, renamed: "yield()")
  @_alwaysEmitIntoClient public static func suspend() async {
    await yield()
  }
  #endif

}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.TaskPriority {
  @available(*, deprecated, message: "unspecified priority will be removed; use nil")
  @_alwaysEmitIntoClient public static var unspecified: _Concurrency.TaskPriority {
    get {
    .init(rawValue: 0x00)
  }
  }
  @available(*, deprecated, message: "userInteractive priority will be removed")
  @_alwaysEmitIntoClient public static var userInteractive: _Concurrency.TaskPriority {
    get {
    .init(rawValue: 0x21)
  }
  }
}

#if compiler(>=5.3) && $AsyncAwait && $Sendable
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@_alwaysEmitIntoClient public func withTaskCancellationHandler<T>(handler: @Sendable () -> (), operation: () async throws -> T) async rethrows -> T {
  try await withTaskCancellationHandler(operation: operation, onCancel: handler)
}
#endif

@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.Task where Success == Swift.Never, Failure == Swift.Never {
  
  #if compiler(>=5.3) && $AsyncAwait && $Sendable
  @available(*, deprecated, message: "`Task.withCancellationHandler` has been replaced by `withTaskCancellationHandler` and will be removed shortly.")
  @_alwaysEmitIntoClient public static func withCancellationHandler<T>(handler: @Sendable () -> (), operation: () async throws -> T) async rethrows -> T {
    try await withTaskCancellationHandler(handler: handler, operation: operation)
  }
  #endif

}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.Task where Failure == Swift.Error {
  
  #if compiler(>=5.3) && $AsyncAwait && $Sendable
  @discardableResult
  @available(*, deprecated, message: "`Task.runDetached` was replaced by `Task.detached` and will be removed shortly.")
  @_alwaysEmitIntoClient public static func runDetached(priority: _Concurrency.TaskPriority? = nil, operation: __owned @escaping @Sendable () async throws -> Success) -> _Concurrency.Task<Success, Failure> {
    detached(priority: priority, operation: operation)
  }
  #endif

}

#if compiler(>=5.3) && $AsyncAwait && $Sendable
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@discardableResult
@available(*, deprecated, message: "`detach` was replaced by `Task.detached` and will be removed shortly.")
@_alwaysEmitIntoClient public func detach<T>(priority: _Concurrency.TaskPriority? = nil, operation: __owned @escaping @Sendable () async -> T) -> _Concurrency.Task<T, Swift.Never> {
  Task.detached(priority: priority, operation: operation)
}
#endif


#if compiler(>=5.3) && $AsyncAwait && $Sendable
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@discardableResult
@available(*, deprecated, message: "`detach` was replaced by `Task.detached` and will be removed shortly.")
@_alwaysEmitIntoClient public func detach<T>(priority: _Concurrency.TaskPriority? = nil, operation: __owned @escaping @Sendable () async throws -> T) -> _Concurrency.Task<T, Swift.Error> {
  Task.detached(priority: priority, operation: operation)
}
#endif


#if compiler(>=5.3) && $AsyncAwait && $Sendable && $ImplicitSelfCapture
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@discardableResult
@available(*, deprecated, message: "`asyncDetached` was replaced by `Task.detached` and will be removed shortly.")
@_alwaysEmitIntoClient public func asyncDetached<T>(priority: _Concurrency.TaskPriority? = nil, @_implicitSelfCapture operation: __owned @escaping @Sendable () async -> T) -> _Concurrency.Task<T, Swift.Never> {
  return Task.detached(priority: priority, operation: operation)
}
#endif


#if compiler(>=5.3) && $AsyncAwait && $Sendable && $ImplicitSelfCapture
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@discardableResult
@available(*, deprecated, message: "`asyncDetached` was replaced by `Task.detached` and will be removed shortly.")
@_alwaysEmitIntoClient public func asyncDetached<T>(priority: _Concurrency.TaskPriority? = nil, @_implicitSelfCapture operation: __owned @escaping @Sendable () async throws -> T) -> _Concurrency.Task<T, Swift.Error> {
  return Task.detached(priority: priority, operation: operation)
}
#endif


#if compiler(>=5.3) && $AsyncAwait && $Sendable && $InheritActorContext && $ImplicitSelfCapture
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@available(*, deprecated, message: "`async` was replaced by `Task.init` and will be removed shortly.")
@discardableResult
@_alwaysEmitIntoClient public func async<T>(priority: _Concurrency.TaskPriority? = nil, @_inheritActorContext @_implicitSelfCapture operation: __owned @escaping @Sendable () async -> T) -> _Concurrency.Task<T, Swift.Never> {
  .init(priority: priority, operation: operation)
}
#endif


#if compiler(>=5.3) && $AsyncAwait && $Sendable && $InheritActorContext && $ImplicitSelfCapture
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@available(*, deprecated, message: "`async` was replaced by `Task.init` and will be removed shortly.")
@discardableResult
@_alwaysEmitIntoClient public func async<T>(priority: _Concurrency.TaskPriority? = nil, @_inheritActorContext @_implicitSelfCapture operation: __owned @escaping @Sendable () async throws -> T) -> _Concurrency.Task<T, Swift.Error> {
  .init(priority: priority, operation: operation)
}
#endif

@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.Task where Success == Swift.Never, Failure == Swift.Never {
  @available(*, deprecated, message: "`Task.Group` was replaced by `ThrowingTaskGroup` and `TaskGroup` and will be removed shortly.")
  public typealias Group<TaskResult> = _Concurrency.ThrowingTaskGroup<TaskResult, Swift.Error>
  
  #if compiler(>=5.3) && $AsyncAwait
  @available(*, deprecated, message: "`Task.withGroup` was replaced by `withThrowingTaskGroup` and `withTaskGroup` and will be removed shortly.")
  @_alwaysEmitIntoClient public static func withGroup<TaskResult, BodyResult>(resultType: TaskResult.Type, returning returnType: BodyResult.Type = BodyResult.self, body: (inout _Concurrency.Task<Success, Failure>.Group<TaskResult>) async throws -> BodyResult) async rethrows -> BodyResult {
    try await withThrowingTaskGroup(of: resultType) { group in
      try await body(&group)
    }
  }
  #endif

}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.Task {
  
  #if compiler(>=5.3) && $AsyncAwait
  @available(*, deprecated, message: "get() has been replaced by .value")
  @_alwaysEmitIntoClient public func get() async throws -> Success {
    return try await value
  }
  #endif

  
  #if compiler(>=5.3) && $AsyncAwait
  @available(*, deprecated, message: "getResult() has been replaced by .result")
  @_alwaysEmitIntoClient public func getResult() async -> Swift.Result<Success, Failure> {
    return await result
  }
  #endif

}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.Task where Failure == Swift.Never {
  
  #if compiler(>=5.3) && $AsyncAwait
  @available(*, deprecated, message: "get() has been replaced by .value")
  @_alwaysEmitIntoClient public func get() async -> Success {
    return await value
  }
  #endif

}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.TaskGroup {
  
  #if compiler(>=5.3) && $AsyncAwait && $Sendable
  @available(*, deprecated, renamed: "addTask(priority:operation:)")
  @_alwaysEmitIntoClient public mutating func add(priority: _Concurrency.TaskPriority? = nil, operation: __owned @escaping @Sendable () async -> ChildTaskResult) async -> Swift.Bool {
    return self.addTaskUnlessCancelled(priority: priority) {
      await operation()
    }
  }
  #endif

  
  #if compiler(>=5.3) && $AsyncAwait && $Sendable
  @available(*, deprecated, renamed: "addTask(priority:operation:)")
  @_alwaysEmitIntoClient public mutating func spawn(priority: _Concurrency.TaskPriority? = nil, operation: __owned @escaping @Sendable () async -> ChildTaskResult) {
    addTask(priority: priority, operation: operation)
  }
  #endif

  
  #if compiler(>=5.3) && $AsyncAwait && $Sendable
  @available(*, deprecated, renamed: "addTaskUnlessCancelled(priority:operation:)")
  @_alwaysEmitIntoClient public mutating func spawnUnlessCancelled(priority: _Concurrency.TaskPriority? = nil, operation: __owned @escaping @Sendable () async -> ChildTaskResult) -> Swift.Bool {
    addTaskUnlessCancelled(priority: priority, operation: operation)
  }
  #endif

  
  #if compiler(>=5.3) && $AsyncAwait && $Sendable
  @available(*, deprecated, renamed: "addTask(priority:operation:)")
  @_alwaysEmitIntoClient public mutating func async(priority: _Concurrency.TaskPriority? = nil, operation: __owned @escaping @Sendable () async -> ChildTaskResult) {
    addTask(priority: priority, operation: operation)
  }
  #endif

  
  #if compiler(>=5.3) && $AsyncAwait && $Sendable
  @available(*, deprecated, renamed: "addTaskUnlessCancelled(priority:operation:)")
  @_alwaysEmitIntoClient public mutating func asyncUnlessCancelled(priority: _Concurrency.TaskPriority? = nil, operation: __owned @escaping @Sendable () async -> ChildTaskResult) -> Swift.Bool {
    addTaskUnlessCancelled(priority: priority, operation: operation)
  }
  #endif

}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.ThrowingTaskGroup {
  
  #if compiler(>=5.3) && $AsyncAwait && $Sendable
  @available(*, deprecated, renamed: "addTask(priority:operation:)")
  @_alwaysEmitIntoClient public mutating func add(priority: _Concurrency.TaskPriority? = nil, operation: __owned @escaping @Sendable () async throws -> ChildTaskResult) async -> Swift.Bool {
    return self.addTaskUnlessCancelled(priority: priority) {
      try await operation()
    }
  }
  #endif

  
  #if compiler(>=5.3) && $AsyncAwait && $Sendable
  @available(*, deprecated, renamed: "addTask(priority:operation:)")
  @_alwaysEmitIntoClient public mutating func spawn(priority: _Concurrency.TaskPriority? = nil, operation: __owned @escaping @Sendable () async throws -> ChildTaskResult) {
    addTask(priority: priority, operation: operation)
  }
  #endif

  
  #if compiler(>=5.3) && $AsyncAwait && $Sendable
  @available(*, deprecated, renamed: "addTaskUnlessCancelled(priority:operation:)")
  @_alwaysEmitIntoClient public mutating func spawnUnlessCancelled(priority: _Concurrency.TaskPriority? = nil, operation: __owned @escaping @Sendable () async throws -> ChildTaskResult) -> Swift.Bool {
    addTaskUnlessCancelled(priority: priority, operation: operation)
  }
  #endif

  
  #if compiler(>=5.3) && $AsyncAwait && $Sendable
  @available(*, deprecated, renamed: "addTask(priority:operation:)")
  @_alwaysEmitIntoClient public mutating func async(priority: _Concurrency.TaskPriority? = nil, operation: __owned @escaping @Sendable () async throws -> ChildTaskResult) {
    addTask(priority: priority, operation: operation)
  }
  #endif

  
  #if compiler(>=5.3) && $AsyncAwait && $Sendable
  @available(*, deprecated, renamed: "addTaskUnlessCancelled(priority:operation:)")
  @_alwaysEmitIntoClient public mutating func asyncUnlessCancelled(priority: _Concurrency.TaskPriority? = nil, operation: __owned @escaping @Sendable () async throws -> ChildTaskResult) -> Swift.Bool {
    addTaskUnlessCancelled(priority: priority, operation: operation)
  }
  #endif

}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@available(*, deprecated, message: "please use UnsafeContination<..., Error>")
public typealias UnsafeThrowingContinuation<T> = _Concurrency.UnsafeContinuation<T, Swift.Error>
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@available(*, deprecated, renamed: "UnownedJob")
public typealias PartialAsyncTask = _Concurrency.UnownedJob
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@frozen public struct Task<Success, Failure> : Swift.Sendable where Failure : Swift.Error {
  @usableFromInline
  internal let _task: Builtin.NativeObject
  @_alwaysEmitIntoClient internal init(_ task: Builtin.NativeObject) {
    self._task = task
  }
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.Task {
  
  #if compiler(>=5.3) && $EffectfulProp
  public var value: Success {
    get async throws
  }
  #endif

  
  #if compiler(>=5.3) && $EffectfulProp
  public var result: Swift.Result<Success, Failure> {
    get async
  }
  #endif

  public func cancel()
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.Task where Failure == Swift.Never {
  
  #if compiler(>=5.3) && $EffectfulProp
  public var value: Success {
    get async
  }
  #endif

}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.Task : Swift.Hashable {
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.Task : Swift.Equatable {
  public static func == (lhs: _Concurrency.Task<Success, Failure>, rhs: _Concurrency.Task<Success, Failure>) -> Swift.Bool
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
public struct TaskPriority : Swift.RawRepresentable, Swift.Sendable {
  public typealias RawValue = Swift.UInt8
  public var rawValue: Swift.UInt8
  public init(rawValue: Swift.UInt8)
  public static let high: _Concurrency.TaskPriority
  @_alwaysEmitIntoClient public static var medium: _Concurrency.TaskPriority {
    get {
    .init(rawValue: 0x15)
  }
  }
  public static let low: _Concurrency.TaskPriority
  public static let userInitiated: _Concurrency.TaskPriority
  public static let utility: _Concurrency.TaskPriority
  public static let background: _Concurrency.TaskPriority
  @available(*, deprecated, renamed: "medium")
  public static let `default`: _Concurrency.TaskPriority
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.TaskPriority : Swift.Equatable {
  public static func == (lhs: _Concurrency.TaskPriority, rhs: _Concurrency.TaskPriority) -> Swift.Bool
  public static func != (lhs: _Concurrency.TaskPriority, rhs: _Concurrency.TaskPriority) -> Swift.Bool
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.TaskPriority : Swift.Comparable {
  public static func < (lhs: _Concurrency.TaskPriority, rhs: _Concurrency.TaskPriority) -> Swift.Bool
  public static func <= (lhs: _Concurrency.TaskPriority, rhs: _Concurrency.TaskPriority) -> Swift.Bool
  public static func > (lhs: _Concurrency.TaskPriority, rhs: _Concurrency.TaskPriority) -> Swift.Bool
  public static func >= (lhs: _Concurrency.TaskPriority, rhs: _Concurrency.TaskPriority) -> Swift.Bool
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.TaskPriority : Swift.Codable {
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.Task where Success == Swift.Never, Failure == Swift.Never {
  public static var currentPriority: _Concurrency.TaskPriority {
    get
  }
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@_alwaysEmitIntoClient internal func taskCreateFlags(priority: _Concurrency.TaskPriority?, isChildTask: Swift.Bool, copyTaskLocals: Swift.Bool, inheritContext: Swift.Bool, enqueueJob: Swift.Bool, addPendingGroupTaskUnconditionally: Swift.Bool) -> Swift.Int {
  var bits = 0
  bits |= (bits & ~0xFF) | Int(priority?.rawValue ?? 0)
  if isChildTask {
    bits |= 1 << 8
  }
  if copyTaskLocals {
    bits |= 1 << 10
  }
  if inheritContext {
    bits |= 1 << 11
  }
  if enqueueJob {
    bits |= 1 << 12
  }
  if addPendingGroupTaskUnconditionally {
    bits |= 1 << 13
  }
  return bits
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.Task where Failure == Swift.Never {
  
  #if compiler(>=5.3) && $AsyncAwait && $Sendable && $InheritActorContext && $ImplicitSelfCapture
  @discardableResult
  @_alwaysEmitIntoClient public init(priority: _Concurrency.TaskPriority? = nil, @_inheritActorContext @_implicitSelfCapture operation: __owned @escaping @Sendable () async -> Success) {
#if compiler(>=5.5) && $BuiltinCreateAsyncTaskInGroup
    // Set up the job flags for a new task.
    let flags = taskCreateFlags(
      priority: priority, isChildTask: false, copyTaskLocals: true,
      inheritContext: true, enqueueJob: true,
      addPendingGroupTaskUnconditionally: false)

    // Create the asynchronous task.
    let (task, _) = Builtin.createAsyncTask(flags, operation)

    self._task = task
#else
    fatalError("Unsupported Swift compiler")
#endif
  }
  #endif

}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.Task where Failure == Swift.Error {
  
  #if compiler(>=5.3) && $AsyncAwait && $Sendable && $InheritActorContext && $ImplicitSelfCapture
  @discardableResult
  @_alwaysEmitIntoClient public init(priority: _Concurrency.TaskPriority? = nil, @_inheritActorContext @_implicitSelfCapture operation: __owned @escaping @Sendable () async throws -> Success) {
#if compiler(>=5.5) && $BuiltinCreateAsyncTaskInGroup
    // Set up the task flags for a new task.
    let flags = taskCreateFlags(
      priority: priority, isChildTask: false, copyTaskLocals: true,
      inheritContext: true, enqueueJob: true,
      addPendingGroupTaskUnconditionally: false
    )

    // Create the asynchronous task future.
    let (task, _) = Builtin.createAsyncTask(flags, operation)

    self._task = task
#else
    fatalError("Unsupported Swift compiler")
#endif
  }
  #endif

}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.Task where Failure == Swift.Never {
  
  #if compiler(>=5.3) && $AsyncAwait && $Sendable
  @discardableResult
  @_alwaysEmitIntoClient public static func detached(priority: _Concurrency.TaskPriority? = nil, operation: __owned @escaping @Sendable () async -> Success) -> _Concurrency.Task<Success, Failure> {
#if compiler(>=5.5) && $BuiltinCreateAsyncTaskInGroup
    // Set up the job flags for a new task.
    let flags = taskCreateFlags(
      priority: priority, isChildTask: false, copyTaskLocals: false,
      inheritContext: false, enqueueJob: true,
      addPendingGroupTaskUnconditionally: false)

    // Create the asynchronous task future.
    let (task, _) = Builtin.createAsyncTask(flags, operation)

    return Task(task)
#else
    fatalError("Unsupported Swift compiler")
#endif
  }
  #endif

}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.Task where Failure == Swift.Error {
  
  #if compiler(>=5.3) && $AsyncAwait && $Sendable
  @discardableResult
  @_alwaysEmitIntoClient public static func detached(priority: _Concurrency.TaskPriority? = nil, operation: __owned @escaping @Sendable () async throws -> Success) -> _Concurrency.Task<Success, Failure> {
#if compiler(>=5.5) && $BuiltinCreateAsyncTaskInGroup
    // Set up the job flags for a new task.
    let flags = taskCreateFlags(
      priority: priority, isChildTask: false, copyTaskLocals: false,
      inheritContext: false, enqueueJob: true,
      addPendingGroupTaskUnconditionally: false
    )

    // Create the asynchronous task future.
    let (task, _) = Builtin.createAsyncTask(flags, operation)

    return Task(task)
#else
    fatalError("Unsupported Swift compiler")
#endif
  }
  #endif

}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.Task where Success == Swift.Never, Failure == Swift.Never {
  
  #if compiler(>=5.3) && $AsyncAwait
  public static func yield() async
  #endif

}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
public func withUnsafeCurrentTask<T>(body: (_Concurrency.UnsafeCurrentTask?) throws -> T) rethrows -> T
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
public struct UnsafeCurrentTask {
  public var isCancelled: Swift.Bool {
    get
  }
  public var priority: _Concurrency.TaskPriority {
    get
  }
  public func cancel()
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.UnsafeCurrentTask : Swift.Hashable {
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.UnsafeCurrentTask : Swift.Equatable {
  public static func == (lhs: _Concurrency.UnsafeCurrentTask, rhs: _Concurrency.UnsafeCurrentTask) -> Swift.Bool
}

#if compiler(>=5.3) && $BuiltinJob
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@_silgen_name("swift_task_enqueueGlobal")
@usableFromInline
internal func _enqueueJobGlobal(_ task: Builtin.Job)
#endif


#if compiler(>=5.3) && $BuiltinJob
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@_silgen_name("swift_task_enqueueGlobalWithDelay")
@usableFromInline
internal func _enqueueJobGlobalWithDelay(_ delay: Swift.UInt64, _ task: Builtin.Job)
#endif


#if compiler(>=5.3) && $AsyncAwait
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
public func _runAsyncMain(_ asyncFun: @escaping () async throws -> ())
#endif


#if compiler(>=5.3) && $AsyncAwait
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@_silgen_name("swift_task_future_wait")
public func _taskFutureGet<T>(_ task: Builtin.NativeObject) async -> T
#endif


#if compiler(>=5.3) && $AsyncAwait
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@_silgen_name("swift_task_future_wait_throwing")
public func _taskFutureGetThrowing<T>(_ task: Builtin.NativeObject) async throws -> T
#endif

@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@_silgen_name("swift_task_isCancelled")
@usableFromInline
internal func _taskIsCancelled(_ task: Builtin.NativeObject) -> Swift.Bool

#if compiler(>=5.3) && $BuiltinExecutor
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@usableFromInline
@_silgen_name("swift_task_isCurrentExecutor")
internal func _taskIsCurrentExecutor(_ executor: Builtin.Executor) -> Swift.Bool
#endif


#if compiler(>=5.3) && $BuiltinExecutor
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@usableFromInline
@_silgen_name("swift_task_reportUnexpectedExecutor")
internal func _reportUnexpectedExecutor(_ _filenameStart: Builtin.RawPointer, _ _filenameLength: Builtin.Word, _ _filenameIsASCII: Builtin.Int1, _ _line: Builtin.Word, _ _executor: Builtin.Executor)
#endif


#if compiler(>=5.3) && $AsyncAwait && $Sendable && $InheritActorContext
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@usableFromInline
@_alwaysEmitIntoClient internal func _runTaskForBridgedAsyncMethod(@_inheritActorContext _ body: __owned @escaping @Sendable () async -> Swift.Void) {
#if compiler(>=5.6)
  Task(operation: body)
#else
  Task<Int, Error> {
    await body()
    return 0
  }
#endif
}
#endif


#if compiler(>=5.3) && $AsyncAwait && $Sendable
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
public func withTaskCancellationHandler<T>(operation: () async throws -> T, onCancel handler: @Sendable () -> Swift.Void) async rethrows -> T
#endif

@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.Task {
  @_transparent public var isCancelled: Swift.Bool {
    @_transparent get {
    _taskIsCancelled(_task)
  }
  }
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.Task where Success == Swift.Never, Failure == Swift.Never {
  public static var isCancelled: Swift.Bool {
    get
  }
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.Task where Success == Swift.Never, Failure == Swift.Never {
  public static func checkCancellation() throws
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
public struct CancellationError : Swift.Error {
  public init()
}

#if compiler(>=5.3) && $AsyncAwait
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@inlinable public func withTaskGroup<ChildTaskResult, GroupResult>(of childTaskResultType: ChildTaskResult.Type, returning returnType: GroupResult.Type = GroupResult.self, body: (inout _Concurrency.TaskGroup<ChildTaskResult>) async -> GroupResult) async -> GroupResult {
  #if compiler(>=5.5) && $BuiltinTaskGroupWithArgument

  let _group = Builtin.createTaskGroup(ChildTaskResult.self)
  var group = TaskGroup<ChildTaskResult>(group: _group)

  // Run the withTaskGroup body.
  let result = await body(&group)

  await group.awaitAllRemainingTasks()

  Builtin.destroyTaskGroup(_group)
  return result

  #else
  fatalError("Swift compiler is incompatible with this SDK version")
  #endif
}
#endif


#if compiler(>=5.3) && $AsyncAwait
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@inlinable public func withThrowingTaskGroup<ChildTaskResult, GroupResult>(of childTaskResultType: ChildTaskResult.Type, returning returnType: GroupResult.Type = GroupResult.self, body: (inout _Concurrency.ThrowingTaskGroup<ChildTaskResult, Swift.Error>) async throws -> GroupResult) async rethrows -> GroupResult {
  #if compiler(>=5.5) && $BuiltinTaskGroupWithArgument

  let _group = Builtin.createTaskGroup(ChildTaskResult.self)
  var group = ThrowingTaskGroup<ChildTaskResult, Error>(group: _group)

  do {
    // Run the withTaskGroup body.
    let result = try await body(&group)

    await group.awaitAllRemainingTasks()
    Builtin.destroyTaskGroup(_group)

    return result
  } catch {
    group.cancelAll()

    await group.awaitAllRemainingTasks()
    Builtin.destroyTaskGroup(_group)

    throw error
  }

  #else
  fatalError("Swift compiler is incompatible with this SDK version")
  #endif
}
#endif

@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@frozen public struct TaskGroup<ChildTaskResult> {
  @usableFromInline
  internal let _group: Builtin.RawPointer
  @inlinable internal init(group: Builtin.RawPointer) {
    self._group = group
  }
  
  #if compiler(>=5.3) && $AsyncAwait && $Sendable
  @_alwaysEmitIntoClient public mutating func addTask(priority: _Concurrency.TaskPriority? = nil, operation: __owned @escaping @Sendable () async -> ChildTaskResult) {
#if compiler(>=5.5) && $BuiltinCreateAsyncTaskInGroup
    let flags = taskCreateFlags(
      priority: priority, isChildTask: true, copyTaskLocals: false,
      inheritContext: false, enqueueJob: true,
      addPendingGroupTaskUnconditionally: true
    )

    // Create the task in this group.
    _ = Builtin.createAsyncTaskInGroup(flags, _group, operation)
#else
    fatalError("Unsupported Swift compiler")
#endif
  }
  #endif

  
  #if compiler(>=5.3) && $AsyncAwait && $Sendable
  @_alwaysEmitIntoClient public mutating func addTaskUnlessCancelled(priority: _Concurrency.TaskPriority? = nil, operation: __owned @escaping @Sendable () async -> ChildTaskResult) -> Swift.Bool {
#if compiler(>=5.5) && $BuiltinCreateAsyncTaskInGroup
    let canAdd = _taskGroupAddPendingTask(group: _group, unconditionally: false)

    guard canAdd else {
      // the group is cancelled and is not accepting any new work
      return false
    }

    let flags = taskCreateFlags(
      priority: priority, isChildTask: true, copyTaskLocals: false,
      inheritContext: false, enqueueJob: true,
      addPendingGroupTaskUnconditionally: false
    )

    // Create the task in this group.
    _ = Builtin.createAsyncTaskInGroup(flags, _group, operation)

    return true
#else
    fatalError("Unsupported Swift compiler")
#endif
  }
  #endif

  
  #if compiler(>=5.3) && $AsyncAwait
  public mutating func next() async -> ChildTaskResult?
  #endif

  
  #if compiler(>=5.3) && $AsyncAwait
  @usableFromInline
  internal mutating func awaitAllRemainingTasks() async
  #endif

  
  #if compiler(>=5.3) && $AsyncAwait
  @_alwaysEmitIntoClient public mutating func waitForAll() async {
    await awaitAllRemainingTasks()
  }
  #endif

  public var isEmpty: Swift.Bool {
    get
  }
  public func cancelAll()
  public var isCancelled: Swift.Bool {
    get
  }
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@frozen public struct ThrowingTaskGroup<ChildTaskResult, Failure> where Failure : Swift.Error {
  @usableFromInline
  internal let _group: Builtin.RawPointer
  @inlinable internal init(group: Builtin.RawPointer) {
    self._group = group
  }
  
  #if compiler(>=5.3) && $AsyncAwait
  @usableFromInline
  internal mutating func awaitAllRemainingTasks() async
  #endif

  
  #if compiler(>=5.3) && $AsyncAwait
  @usableFromInline
  internal mutating func _waitForAll() async throws
  #endif

  
  #if compiler(>=5.3) && $AsyncAwait
  @_alwaysEmitIntoClient public mutating func waitForAll() async throws {
    while let _ = try await next() { }
  }
  #endif

  
  #if compiler(>=5.3) && $AsyncAwait && $Sendable
  @_alwaysEmitIntoClient public mutating func addTask(priority: _Concurrency.TaskPriority? = nil, operation: __owned @escaping @Sendable () async throws -> ChildTaskResult) {
#if compiler(>=5.5) && $BuiltinCreateAsyncTaskInGroup
    let flags = taskCreateFlags(
      priority: priority, isChildTask: true, copyTaskLocals: false,
      inheritContext: false, enqueueJob: true,
      addPendingGroupTaskUnconditionally: true
    )

    // Create the task in this group.
    _ = Builtin.createAsyncTaskInGroup(flags, _group, operation)
#else
    fatalError("Unsupported Swift compiler")
#endif
  }
  #endif

  
  #if compiler(>=5.3) && $AsyncAwait && $Sendable
  @_alwaysEmitIntoClient public mutating func addTaskUnlessCancelled(priority: _Concurrency.TaskPriority? = nil, operation: __owned @escaping @Sendable () async throws -> ChildTaskResult) -> Swift.Bool {
#if compiler(>=5.5) && $BuiltinCreateAsyncTaskInGroup
    let canAdd = _taskGroupAddPendingTask(group: _group, unconditionally: false)

    guard canAdd else {
      // the group is cancelled and is not accepting any new work
      return false
    }

    let flags = taskCreateFlags(
      priority: priority, isChildTask: true, copyTaskLocals: false,
      inheritContext: false, enqueueJob: true,
      addPendingGroupTaskUnconditionally: false
    )

    // Create the task in this group.
    _ = Builtin.createAsyncTaskInGroup(flags, _group, operation)

    return true
#else
    fatalError("Unsupported Swift compiler")
#endif
  }
  #endif

  
  #if compiler(>=5.3) && $AsyncAwait
  public mutating func next() async throws -> ChildTaskResult?
  #endif

  
  #if compiler(>=5.3) && $AsyncAwait
  @_silgen_name("$sScg10nextResults0B0Oyxq_GSgyYaKF")
  @usableFromInline
  internal mutating func nextResultForABI() async throws -> Swift.Result<ChildTaskResult, Failure>?
  #endif

  
  #if compiler(>=5.3) && $AsyncAwait
  @_alwaysEmitIntoClient public mutating func nextResult() async -> Swift.Result<ChildTaskResult, Failure>? {
    return try! await nextResultForABI()
  }
  #endif

  public var isEmpty: Swift.Bool {
    get
  }
  public func cancelAll()
  public var isCancelled: Swift.Bool {
    get
  }
}

#if compiler(>=5.3) && $RethrowsProtocol
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.TaskGroup : _Concurrency.AsyncSequence {
  public typealias AsyncIterator = _Concurrency.TaskGroup<ChildTaskResult>.Iterator
  public typealias Element = ChildTaskResult
  public func makeAsyncIterator() -> _Concurrency.TaskGroup<ChildTaskResult>.Iterator
  @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
  public struct Iterator : _Concurrency.AsyncIteratorProtocol {
    public typealias Element = ChildTaskResult
    @usableFromInline
    internal var group: _Concurrency.TaskGroup<ChildTaskResult>
    @usableFromInline
    internal var finished: Swift.Bool
    
    #if compiler(>=5.3) && $AsyncAwait
    public mutating func next() async -> _Concurrency.TaskGroup<ChildTaskResult>.Iterator.Element?
    #endif

    public mutating func cancel()
  }
}
#endif


#if compiler(>=5.3) && $RethrowsProtocol
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.ThrowingTaskGroup : _Concurrency.AsyncSequence {
  public typealias AsyncIterator = _Concurrency.ThrowingTaskGroup<ChildTaskResult, Failure>.Iterator
  public typealias Element = ChildTaskResult
  public func makeAsyncIterator() -> _Concurrency.ThrowingTaskGroup<ChildTaskResult, Failure>.Iterator
  @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
  public struct Iterator : _Concurrency.AsyncIteratorProtocol {
    public typealias Element = ChildTaskResult
    @usableFromInline
    internal var group: _Concurrency.ThrowingTaskGroup<ChildTaskResult, Failure>
    @usableFromInline
    internal var finished: Swift.Bool
    
    #if compiler(>=5.3) && $AsyncAwait
    public mutating func next() async throws -> _Concurrency.ThrowingTaskGroup<ChildTaskResult, Failure>.Iterator.Element?
    #endif

    public mutating func cancel()
  }
}
#endif

@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@_silgen_name("swift_taskGroup_addPending")
@usableFromInline
internal func _taskGroupAddPendingTask(group: Builtin.RawPointer, unconditionally: Swift.Bool) -> Swift.Bool
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@propertyWrapper final public class TaskLocal<Value> : Swift.UnsafeSendable, Swift.CustomStringConvertible {
  public init(wrappedValue defaultValue: Value)
  final public func get() -> Value
  
  #if compiler(>=5.3) && $AsyncAwait
  @discardableResult
  final public func withValue<R>(_ valueDuringOperation: Value, operation: () async throws -> R, file: Swift.String = #file, line: Swift.UInt = #line) async rethrows -> R
  #endif

  @discardableResult
  final public func withValue<R>(_ valueDuringOperation: Value, operation: () throws -> R, file: Swift.String = #file, line: Swift.UInt = #line) rethrows -> R
  final public var projectedValue: _Concurrency.TaskLocal<Value> {
    get
    @available(*, unavailable, message: "use '$myTaskLocal.withValue(_:do:)' instead")
    set
  }
  public static subscript(_enclosingInstance object: Swift.Never, wrapped wrappedKeyPath: Swift.ReferenceWritableKeyPath<Swift.Never, Value>, storage storageKeyPath: Swift.ReferenceWritableKeyPath<Swift.Never, _Concurrency.TaskLocal<Value>>) -> Value {
    get
  }
  final public var wrappedValue: Value {
    get
  }
  final public var description: Swift.String {
    get
  }
  @objc deinit
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@usableFromInline
internal func _checkIllegalTaskLocalBindingWithinWithTaskGroup(file: Swift.String, line: Swift.UInt)
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@usableFromInline
@_silgen_name("swift_task_reportIllegalTaskLocalBindingWithinWithTaskGroup")
internal func _reportIllegalTaskLocalBindingWithinWithTaskGroup(_ _filenameStart: Swift.UnsafePointer<Swift.Int8>, _ _filenameLength: Swift.Int, _ _filenameIsASCII: Swift.Bool, _ _line: Swift.UInt)
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.Task where Success == Swift.Never, Failure == Swift.Never {
  
  #if compiler(>=5.3) && $AsyncAwait
  @available(*, deprecated, renamed: "Task.sleep(nanoseconds:)")
  public static func sleep(_ duration: Swift.UInt64) async
  #endif

  
  #if compiler(>=5.3) && $AsyncAwait
  public static func sleep(nanoseconds duration: Swift.UInt64) async throws
  #endif

}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
public struct AsyncStream<Element> {
  public struct Continuation : Swift.Sendable {
    public enum Termination {
      case finished
      case cancelled
      public static func == (a: _Concurrency.AsyncStream<Element>.Continuation.Termination, b: _Concurrency.AsyncStream<Element>.Continuation.Termination) -> Swift.Bool
      public func hash(into hasher: inout Swift.Hasher)
      public var hashValue: Swift.Int {
        get
      }
    }
    public enum YieldResult {
      case enqueued(remaining: Swift.Int)
      case dropped(Element)
      case terminated
    }
    public enum BufferingPolicy {
      case unbounded
      case bufferingOldest(Swift.Int)
      case bufferingNewest(Swift.Int)
    }
    @discardableResult
    public func yield(_ value: __owned Element) -> _Concurrency.AsyncStream<Element>.Continuation.YieldResult
    public func finish()
    
    #if compiler(>=5.3) && $Sendable
    public var onTermination: (@Sendable (_Concurrency.AsyncStream<Element>.Continuation.Termination) -> Swift.Void)? {
      get
      nonmutating set
    }
    #endif

  }
  public init(_ elementType: Element.Type = Element.self, bufferingPolicy limit: _Concurrency.AsyncStream<Element>.Continuation.BufferingPolicy = .unbounded, _ build: (_Concurrency.AsyncStream<Element>.Continuation) -> Swift.Void)
  
  #if compiler(>=5.3) && $AsyncAwait && $Sendable
  public init(unfolding produce: @escaping () async -> Element?, onCancel: (@Sendable () -> Swift.Void)? = nil)
  #endif

}

#if compiler(>=5.3) && $RethrowsProtocol
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.AsyncStream : _Concurrency.AsyncSequence {
  public struct Iterator : _Concurrency.AsyncIteratorProtocol {
    
    #if compiler(>=5.3) && $AsyncAwait
    public mutating func next() async -> Element?
    #endif

  }
  public func makeAsyncIterator() -> _Concurrency.AsyncStream<Element>.Iterator
  public typealias AsyncIterator = _Concurrency.AsyncStream<Element>.Iterator
}
#endif

@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.AsyncStream.Continuation {
  @discardableResult
  public func yield(with result: Swift.Result<Element, Swift.Never>) -> _Concurrency.AsyncStream<Element>.Continuation.YieldResult
  @discardableResult
  public func yield() -> _Concurrency.AsyncStream<Element>.Continuation.YieldResult where Element == Swift.Void
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
public struct AsyncThrowingStream<Element, Failure> where Failure : Swift.Error {
  public struct Continuation : Swift.Sendable {
    public enum Termination {
      case finished(Failure?)
      case cancelled
    }
    public enum YieldResult {
      case enqueued(remaining: Swift.Int)
      case dropped(Element)
      case terminated
    }
    public enum BufferingPolicy {
      case unbounded
      case bufferingOldest(Swift.Int)
      case bufferingNewest(Swift.Int)
    }
    @discardableResult
    public func yield(_ value: __owned Element) -> _Concurrency.AsyncThrowingStream<Element, Failure>.Continuation.YieldResult
    public func finish(throwing error: __owned Failure? = nil)
    
    #if compiler(>=5.3) && $Sendable
    public var onTermination: (@Sendable (_Concurrency.AsyncThrowingStream<Element, Failure>.Continuation.Termination) -> Swift.Void)? {
      get
      nonmutating set
    }
    #endif

  }
  public init(_ elementType: Element.Type = Element.self, bufferingPolicy limit: _Concurrency.AsyncThrowingStream<Element, Failure>.Continuation.BufferingPolicy = .unbounded, _ build: (_Concurrency.AsyncThrowingStream<Element, Failure>.Continuation) -> Swift.Void) where Failure == Swift.Error
  
  #if compiler(>=5.3) && $AsyncAwait
  public init(unfolding produce: @escaping () async throws -> Element?) where Failure == Swift.Error
  #endif

}

#if compiler(>=5.3) && $RethrowsProtocol
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.AsyncThrowingStream : _Concurrency.AsyncSequence {
  public struct Iterator : _Concurrency.AsyncIteratorProtocol {
    
    #if compiler(>=5.3) && $AsyncAwait
    public mutating func next() async throws -> Element?
    #endif

  }
  public func makeAsyncIterator() -> _Concurrency.AsyncThrowingStream<Element, Failure>.Iterator
  public typealias AsyncIterator = _Concurrency.AsyncThrowingStream<Element, Failure>.Iterator
}
#endif

@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.AsyncThrowingStream.Continuation {
  @discardableResult
  public func yield(with result: Swift.Result<Element, Failure>) -> _Concurrency.AsyncThrowingStream<Element, Failure>.Continuation.YieldResult where Failure == Swift.Error
  @discardableResult
  public func yield() -> _Concurrency.AsyncThrowingStream<Element, Failure>.Continuation.YieldResult where Element == Swift.Void
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@available(*, deprecated, message: "`YieldingContinuation` was replaced by `AsyncStream` and will be removed shortly.")
public struct YieldingContinuation<Element, Failure> : Swift.Sendable where Failure : Swift.Error {
  public init()
  public init(yielding: Element.Type, throwing: Failure.Type)
  public func yield(_ value: __owned Element) -> Swift.Bool
  public func yield(throwing error: __owned Failure) -> Swift.Bool
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.YieldingContinuation where Failure == Swift.Error {
  
  #if compiler(>=5.3) && $AsyncAwait
  @available(*, deprecated, message: "`YieldingContinuation` was replaced by `AsyncStream` and will be removed shortly.")
  public func next() async throws -> Element
  #endif

}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.YieldingContinuation where Failure == Swift.Never {
  @available(*, deprecated, message: "`YieldingContinuation` was replaced by `AsyncStream` and will be removed shortly.")
  public init(yielding: Element.Type)
  
  #if compiler(>=5.3) && $AsyncAwait
  @available(*, deprecated, message: "`YieldingContinuation` was replaced by `AsyncStream` and will be removed shortly.")
  public func next() async -> Element
  #endif

}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.YieldingContinuation {
  @available(*, deprecated, message: "`YieldingContinuation` was replaced by `AsyncStream` and will be removed shortly.")
  public func yield<Er>(with result: Swift.Result<Element, Er>) -> Swift.Bool where Failure == Swift.Error, Er : Swift.Error
  @available(*, deprecated, message: "`YieldingContinuation` was replaced by `AsyncStream` and will be removed shortly.")
  public func yield(with result: Swift.Result<Element, Failure>) -> Swift.Bool
  @available(*, deprecated, message: "`YieldingContinuation` was replaced by `AsyncStream` and will be removed shortly.")
  public func yield() -> Swift.Bool where Element == Swift.Void
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.UnownedSerialExecutor : Swift.Sendable {}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.UnownedJob : Swift.Sendable {}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.UnsafeContinuation : Swift.Sendable {}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.TaskGroup : Swift.Sendable {}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.ThrowingTaskGroup : Swift.Sendable {}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.AsyncStream.Continuation.Termination : Swift.Equatable {}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.AsyncStream.Continuation.Termination : Swift.Hashable {}
