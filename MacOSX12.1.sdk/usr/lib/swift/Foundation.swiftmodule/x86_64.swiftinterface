// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 5.5.2 (swiftlang-1300.0.46.202 clang-1300.0.29.30)
// swift-module-flags: -target x86_64-apple-macos12.1 -enable-objc-interop -autolink-force-load -enable-library-evolution -module-link-name swiftFoundation -swift-version 5 -enforce-exclusivity=unchecked -O -enable-experimental-concurrency -enable-experimental-concurrency -module-name Foundation
import Combine
import CoreFoundation
import CoreGraphics
import Darwin
import Dispatch
@_exported import Foundation
import ObjectiveC
import Swift
import _Concurrency
import Darwin.uuid
extension Swift.String {
  public init(_ cocoaString: Foundation.NSString)
}
extension Swift.String : Swift._ObjectiveCBridgeable {
  @_semantics("convertToObjectiveC") public func _bridgeToObjectiveC() -> Foundation.NSString
  public static func _forceBridgeFromObjectiveC(_ x: Foundation.NSString, result: inout Swift.String?)
  public static func _conditionallyBridgeFromObjectiveC(_ x: Foundation.NSString, result: inout Swift.String?) -> Swift.Bool
  @_effects(readonly) public static func _unconditionallyBridgeFromObjectiveC(_ source: Foundation.NSString?) -> Swift.String
  public typealias _ObjectiveCType = Foundation.NSString
}
extension Swift.Substring : Swift._ObjectiveCBridgeable {
  @_semantics("convertToObjectiveC") public func _bridgeToObjectiveC() -> Foundation.NSString
  public static func _forceBridgeFromObjectiveC(_ x: Foundation.NSString, result: inout Swift.Substring?)
  public static func _conditionallyBridgeFromObjectiveC(_ x: Foundation.NSString, result: inout Swift.Substring?) -> Swift.Bool
  @_effects(readonly) public static func _unconditionallyBridgeFromObjectiveC(_ source: Foundation.NSString?) -> Swift.Substring
  public typealias _ObjectiveCType = Foundation.NSString
}
extension Swift.String : Swift.CVarArg {
}
extension Foundation.NSURL : Swift._CustomPlaygroundQuickLookable {
  @available(*, deprecated, message: "NSURL.customPlaygroundQuickLook will be removed in a future Swift version")
  public var customPlaygroundQuickLook: Swift.PlaygroundQuickLook {
    get
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.Measurement where UnitType : Foundation.Dimension {
  public struct AttributedStyle : Foundation.FormatStyle {
    public func format(_ measurement: Foundation.Measurement<UnitType>) -> Foundation.AttributedString
    public func locale(_ locale: Foundation.Locale) -> Foundation.Measurement<UnitType>.AttributedStyle
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: Foundation.Measurement<UnitType>.AttributedStyle, b: Foundation.Measurement<UnitType>.AttributedStyle) -> Swift.Bool
    public typealias FormatInput = Foundation.Measurement<UnitType>
    public typealias FormatOutput = Foundation.AttributedString
    public func encode(to encoder: Swift.Encoder) throws
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: Swift.Decoder) throws
  }
}
public protocol DataProtocol : Swift.RandomAccessCollection where Self.Element == Swift.UInt8, Self.SubSequence : Foundation.DataProtocol {
  associatedtype Regions : Swift.BidirectionalCollection where Self.Regions.Element : Foundation.ContiguousBytes, Self.Regions.Element : Foundation.DataProtocol, Self.Regions.Element.SubSequence : Foundation.ContiguousBytes
  var regions: Self.Regions { get }
  func firstRange<D, R>(of: D, in: R) -> Swift.Range<Self.Index>? where D : Foundation.DataProtocol, R : Swift.RangeExpression, Self.Index == R.Bound
  func lastRange<D, R>(of: D, in: R) -> Swift.Range<Self.Index>? where D : Foundation.DataProtocol, R : Swift.RangeExpression, Self.Index == R.Bound
  @discardableResult
  func copyBytes(to: Swift.UnsafeMutableRawBufferPointer, count: Swift.Int) -> Swift.Int
  @discardableResult
  func copyBytes<DestinationType>(to: Swift.UnsafeMutableBufferPointer<DestinationType>, count: Swift.Int) -> Swift.Int
  @discardableResult
  func copyBytes<R>(to: Swift.UnsafeMutableRawBufferPointer, from: R) -> Swift.Int where R : Swift.RangeExpression, Self.Index == R.Bound
  @discardableResult
  func copyBytes<DestinationType, R>(to: Swift.UnsafeMutableBufferPointer<DestinationType>, from: R) -> Swift.Int where R : Swift.RangeExpression, Self.Index == R.Bound
}
public protocol MutableDataProtocol : Foundation.DataProtocol, Swift.MutableCollection, Swift.RangeReplaceableCollection {
  mutating func resetBytes<R>(in range: R) where R : Swift.RangeExpression, Self.Index == R.Bound
}
extension Foundation.DataProtocol {
  public func firstRange<D>(of data: D) -> Swift.Range<Self.Index>? where D : Foundation.DataProtocol
  public func lastRange<D>(of data: D) -> Swift.Range<Self.Index>? where D : Foundation.DataProtocol
  @discardableResult
  public func copyBytes(to ptr: Swift.UnsafeMutableRawBufferPointer) -> Swift.Int
  @discardableResult
  public func copyBytes<DestinationType>(to ptr: Swift.UnsafeMutableBufferPointer<DestinationType>) -> Swift.Int
  @discardableResult
  public func copyBytes(to ptr: Swift.UnsafeMutableRawBufferPointer, count: Swift.Int) -> Swift.Int
  @discardableResult
  public func copyBytes<DestinationType>(to ptr: Swift.UnsafeMutableBufferPointer<DestinationType>, count: Swift.Int) -> Swift.Int
  @discardableResult
  public func copyBytes<R>(to ptr: Swift.UnsafeMutableRawBufferPointer, from range: R) -> Swift.Int where R : Swift.RangeExpression, Self.Index == R.Bound
  @discardableResult
  public func copyBytes<DestinationType, R>(to ptr: Swift.UnsafeMutableBufferPointer<DestinationType>, from range: R) -> Swift.Int where R : Swift.RangeExpression, Self.Index == R.Bound
  public func firstRange<D, R>(of data: D, in range: R) -> Swift.Range<Self.Index>? where D : Foundation.DataProtocol, R : Swift.RangeExpression, Self.Index == R.Bound
  public func lastRange<D, R>(of data: D, in range: R) -> Swift.Range<Self.Index>? where D : Foundation.DataProtocol, R : Swift.RangeExpression, Self.Index == R.Bound
}
extension Foundation.DataProtocol where Self : Foundation.ContiguousBytes {
  public func copyBytes<DestinationType, R>(to ptr: Swift.UnsafeMutableBufferPointer<DestinationType>, from range: R) where R : Swift.RangeExpression, Self.Index == R.Bound
}
extension Foundation.MutableDataProtocol {
  public mutating func resetBytes<R>(in range: R) where R : Swift.RangeExpression, Self.Index == R.Bound
}
extension Swift.Slice : Foundation.DataProtocol where Base : Foundation.DataProtocol {
  public typealias Regions = [Base.Regions.Element.SubSequence]
  public var regions: [Base.Regions.Element.SubSequence] {
    get
  }
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Foundation.Date {
  public typealias Stride = Foundation.TimeInterval
  public func distance(to other: Foundation.Date) -> Foundation.TimeInterval
  public func advanced(by n: Foundation.TimeInterval) -> Foundation.Date
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension Foundation.URLSessionWebSocketTask {
  public enum Message {
    case data(Foundation.Data)
    case string(Swift.String)
  }
  public func send(_ message: Foundation.URLSessionWebSocketTask.Message, completionHandler: @escaping (Swift.Error?) -> Swift.Void)
  
  #if compiler(>=5.3) && $AsyncAwait
  @available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
  public func send(_ message: Foundation.URLSessionWebSocketTask.Message) async throws
  #endif

  public func receive(completionHandler: @escaping (Swift.Result<Foundation.URLSessionWebSocketTask.Message, Swift.Error>) -> Swift.Void)
  
  #if compiler(>=5.3) && $AsyncAwait
  @available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
  public func receive() async throws -> Foundation.URLSessionWebSocketTask.Message
  #endif

}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension Foundation.URLSessionTaskTransactionMetrics {
  public var localPort: Swift.Int? {
    get
  }
  public var remotePort: Swift.Int? {
    get
  }
  public var negotiatedTLSProtocolVersion: Security.tls_protocol_version_t? {
    get
  }
  public var negotiatedTLSCipherSuite: Security.tls_ciphersuite_t? {
    get
  }
}
@available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
extension Foundation.URLSession {
  
  #if compiler(>=5.3) && $AsyncAwait
  public func data(for request: Foundation.URLRequest, delegate: Foundation.URLSessionTaskDelegate? = nil) async throws -> (Foundation.Data, Foundation.URLResponse)
  #endif

  
  #if compiler(>=5.3) && $AsyncAwait
  public func data(from url: Foundation.URL, delegate: Foundation.URLSessionTaskDelegate? = nil) async throws -> (Foundation.Data, Foundation.URLResponse)
  #endif

  
  #if compiler(>=5.3) && $AsyncAwait
  public func upload(for request: Foundation.URLRequest, fromFile fileURL: Foundation.URL, delegate: Foundation.URLSessionTaskDelegate? = nil) async throws -> (Foundation.Data, Foundation.URLResponse)
  #endif

  
  #if compiler(>=5.3) && $AsyncAwait
  public func upload(for request: Foundation.URLRequest, from bodyData: Foundation.Data, delegate: Foundation.URLSessionTaskDelegate? = nil) async throws -> (Foundation.Data, Foundation.URLResponse)
  #endif

  
  #if compiler(>=5.3) && $AsyncAwait
  public func download(for request: Foundation.URLRequest, delegate: Foundation.URLSessionTaskDelegate? = nil) async throws -> (Foundation.URL, Foundation.URLResponse)
  #endif

  
  #if compiler(>=5.3) && $AsyncAwait
  public func download(from url: Foundation.URL, delegate: Foundation.URLSessionTaskDelegate? = nil) async throws -> (Foundation.URL, Foundation.URLResponse)
  #endif

  
  #if compiler(>=5.3) && $AsyncAwait
  public func download(resumeFrom resumeData: Foundation.Data, delegate: Foundation.URLSessionTaskDelegate? = nil) async throws -> (Foundation.URL, Foundation.URLResponse)
  #endif

  
  #if compiler(>=5.3) && $RethrowsProtocol
  public struct AsyncBytes : _Concurrency.AsyncSequence {
    public var task: Foundation.URLSessionDataTask {
      get
    }
    public typealias Element = Swift.UInt8
    public typealias AsyncIterator = Foundation.URLSession.AsyncBytes.Iterator
    @frozen public struct Iterator : _Concurrency.AsyncIteratorProtocol {
      public typealias Element = Swift.UInt8
      @usableFromInline
      internal var buffer: Foundation._AsyncBytesBuffer
      
      #if compiler(>=5.3) && $AsyncAwait
      @inlinable @inline(__always) public mutating func next() async throws -> Swift.UInt8? {
                return try await buffer.next()
            }
      #endif

    }
    __consuming public func makeAsyncIterator() -> Foundation.URLSession.AsyncBytes.Iterator
  }
  #endif

  
  #if compiler(>=5.3) && $AsyncAwait && $RethrowsProtocol
  public func bytes(for request: Foundation.URLRequest, delegate: Foundation.URLSessionTaskDelegate? = nil) async throws -> (Foundation.URLSession.AsyncBytes, Foundation.URLResponse)
  #endif

  
  #if compiler(>=5.3) && $AsyncAwait && $RethrowsProtocol
  public func bytes(from url: Foundation.URL, delegate: Foundation.URLSessionTaskDelegate? = nil) async throws -> (Foundation.URLSession.AsyncBytes, Foundation.URLResponse)
  #endif

}
public struct DateComponents : Foundation.ReferenceConvertible, Swift.Hashable, Swift.Equatable {
  public typealias ReferenceType = Foundation.NSDateComponents
  public init(calendar: Foundation.Calendar? = nil, timeZone: Foundation.TimeZone? = nil, era: Swift.Int? = nil, year: Swift.Int? = nil, month: Swift.Int? = nil, day: Swift.Int? = nil, hour: Swift.Int? = nil, minute: Swift.Int? = nil, second: Swift.Int? = nil, nanosecond: Swift.Int? = nil, weekday: Swift.Int? = nil, weekdayOrdinal: Swift.Int? = nil, quarter: Swift.Int? = nil, weekOfMonth: Swift.Int? = nil, weekOfYear: Swift.Int? = nil, yearForWeekOfYear: Swift.Int? = nil)
  public var calendar: Foundation.Calendar? {
    get
    set
  }
  public var timeZone: Foundation.TimeZone? {
    get
    set
  }
  public var era: Swift.Int? {
    get
    set
  }
  public var year: Swift.Int? {
    get
    set
  }
  public var month: Swift.Int? {
    get
    set
  }
  public var day: Swift.Int? {
    get
    set
  }
  public var hour: Swift.Int? {
    get
    set
  }
  public var minute: Swift.Int? {
    get
    set
  }
  public var second: Swift.Int? {
    get
    set
  }
  public var nanosecond: Swift.Int? {
    get
    set
  }
  public var weekday: Swift.Int? {
    get
    set
  }
  public var weekdayOrdinal: Swift.Int? {
    get
    set
  }
  public var quarter: Swift.Int? {
    get
    set
  }
  public var weekOfMonth: Swift.Int? {
    get
    set
  }
  public var weekOfYear: Swift.Int? {
    get
    set
  }
  public var yearForWeekOfYear: Swift.Int? {
    get
    set
  }
  public var isLeapMonth: Swift.Bool? {
    get
    set
  }
  public var date: Foundation.Date? {
    get
  }
  @available(macOS 10.9, iOS 8.0, *)
  public mutating func setValue(_ value: Swift.Int?, for component: Foundation.Calendar.Component)
  @available(macOS 10.9, iOS 8.0, *)
  public func value(for component: Foundation.Calendar.Component) -> Swift.Int?
  @available(macOS 10.9, iOS 8.0, *)
  public var isValidDate: Swift.Bool {
    get
  }
  @available(macOS 10.9, iOS 8.0, *)
  public func isValidDate(in calendar: Foundation.Calendar) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (lhs: Foundation.DateComponents, rhs: Foundation.DateComponents) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
extension Foundation.DateComponents : Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible, Swift.CustomReflectable {
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
  public var customMirror: Swift.Mirror {
    get
  }
}
extension Foundation.DateComponents : Swift._ObjectiveCBridgeable {
  public static func _getObjectiveCType() -> Any.Type
  @_semantics("convertToObjectiveC") public func _bridgeToObjectiveC() -> Foundation.NSDateComponents
  public static func _forceBridgeFromObjectiveC(_ dateComponents: Foundation.NSDateComponents, result: inout Foundation.DateComponents?)
  public static func _conditionallyBridgeFromObjectiveC(_ dateComponents: Foundation.NSDateComponents, result: inout Foundation.DateComponents?) -> Swift.Bool
  @_effects(readonly) public static func _unconditionallyBridgeFromObjectiveC(_ source: Foundation.NSDateComponents?) -> Foundation.DateComponents
  public typealias _ObjectiveCType = Foundation.NSDateComponents
}
extension Foundation.NSDateComponents : Swift._HasCustomAnyHashableRepresentation {
  @nonobjc public func _toCustomAnyHashable() -> Swift.AnyHashable?
}
extension Foundation.DateComponents : Swift.Codable {
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
public protocol EncodableAttributedStringKey : Foundation.AttributedStringKey {
  static func encode(_ value: Self.Value, to encoder: Swift.Encoder) throws
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
public protocol DecodableAttributedStringKey : Foundation.AttributedStringKey {
  static func decode(from decoder: Swift.Decoder) throws -> Self.Value
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
public typealias CodableAttributedStringKey = Foundation.DecodableAttributedStringKey & Foundation.EncodableAttributedStringKey
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.EncodableAttributedStringKey where Self.Value : Swift.Encodable {
  public static func encode(_ value: Self.Value, to encoder: Swift.Encoder) throws
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.DecodableAttributedStringKey where Self.Value : Swift.Decodable {
  public static func decode(from decoder: Swift.Decoder) throws -> Self.Value
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
public protocol MarkdownDecodableAttributedStringKey : Foundation.AttributedStringKey {
  static func decodeMarkdown(from decoder: Swift.Decoder) throws -> Self.Value
  static var markdownName: Swift.String { get }
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.MarkdownDecodableAttributedStringKey {
  public static var markdownName: Swift.String {
    get
  }
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.MarkdownDecodableAttributedStringKey where Self : Foundation.DecodableAttributedStringKey {
  public static func decodeMarkdown(from decoder: Swift.Decoder) throws -> Self.Value
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.EncodableAttributedStringKey where Self.Value : ObjectiveC.NSObject, Self.Value : Foundation.NSSecureCoding {
  public static func encode(_ value: Self.Value, to encoder: Swift.Encoder) throws
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.DecodableAttributedStringKey where Self.Value : ObjectiveC.NSObject, Self.Value : Foundation.NSSecureCoding {
  public static func decode(from decoder: Swift.Decoder) throws -> Self.Value
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
public protocol EncodingConfigurationProviding {
  associatedtype EncodingConfiguration
  static var encodingConfiguration: Self.EncodingConfiguration { get }
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
public protocol EncodableWithConfiguration {
  associatedtype EncodingConfiguration
  func encode(to encoder: Swift.Encoder, configuration: Self.EncodingConfiguration) throws
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
public protocol DecodingConfigurationProviding {
  associatedtype DecodingConfiguration
  static var decodingConfiguration: Self.DecodingConfiguration { get }
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
public protocol DecodableWithConfiguration {
  associatedtype DecodingConfiguration
  init(from decoder: Swift.Decoder, configuration: Self.DecodingConfiguration) throws
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
public typealias CodableWithConfiguration = Foundation.DecodableWithConfiguration & Foundation.EncodableWithConfiguration
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Swift.KeyedEncodingContainer {
  public mutating func encode<T, C>(_ wrapper: Foundation.CodableConfiguration<T?, C>, forKey key: Swift.KeyedEncodingContainer<K>.Key) throws where T : Foundation.DecodableWithConfiguration, T : Foundation.EncodableWithConfiguration, C : Foundation.DecodingConfigurationProviding, C : Foundation.EncodingConfigurationProviding, T.DecodingConfiguration == C.DecodingConfiguration, T.EncodingConfiguration == C.EncodingConfiguration
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Swift.KeyedDecodingContainer {
  public func decode<T, C>(_: Foundation.CodableConfiguration<T?, C>.Type, forKey key: Swift.KeyedDecodingContainer<K>.Key) throws -> Foundation.CodableConfiguration<T?, C> where T : Foundation.DecodableWithConfiguration, T : Foundation.EncodableWithConfiguration, C : Foundation.DecodingConfigurationProviding, C : Foundation.EncodingConfigurationProviding, T.DecodingConfiguration == C.DecodingConfiguration, T.EncodingConfiguration == C.EncodingConfiguration
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Swift.KeyedEncodingContainer {
  public mutating func encode<T, C>(_ t: T, forKey key: Swift.KeyedEncodingContainer<K>.Key, configuration: C.Type) throws where T : Foundation.EncodableWithConfiguration, C : Foundation.EncodingConfigurationProviding, T.EncodingConfiguration == C.EncodingConfiguration
  public mutating func encodeIfPresent<T, C>(_ t: T?, forKey key: Swift.KeyedEncodingContainer<K>.Key, configuration: C.Type) throws where T : Foundation.EncodableWithConfiguration, C : Foundation.EncodingConfigurationProviding, T.EncodingConfiguration == C.EncodingConfiguration
  public mutating func encode<T>(_ t: T, forKey key: Swift.KeyedEncodingContainer<K>.Key, configuration: T.EncodingConfiguration) throws where T : Foundation.EncodableWithConfiguration
  public mutating func encodeIfPresent<T>(_ t: T?, forKey key: Swift.KeyedEncodingContainer<K>.Key, configuration: T.EncodingConfiguration) throws where T : Foundation.EncodableWithConfiguration
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Swift.KeyedDecodingContainer {
  public func decode<T, C>(_: T.Type, forKey key: Swift.KeyedDecodingContainer<K>.Key, configuration: C.Type) throws -> T where T : Foundation.DecodableWithConfiguration, C : Foundation.DecodingConfigurationProviding, T.DecodingConfiguration == C.DecodingConfiguration
  public func decodeIfPresent<T, C>(_: T.Type, forKey key: Swift.KeyedDecodingContainer<K>.Key, configuration: C.Type) throws -> T? where T : Foundation.DecodableWithConfiguration, C : Foundation.DecodingConfigurationProviding, T.DecodingConfiguration == C.DecodingConfiguration
  public func decode<T>(_: T.Type, forKey key: Swift.KeyedDecodingContainer<K>.Key, configuration: T.DecodingConfiguration) throws -> T where T : Foundation.DecodableWithConfiguration
  public func decodeIfPresent<T>(_: T.Type, forKey key: Swift.KeyedDecodingContainer<K>.Key, configuration: T.DecodingConfiguration) throws -> T? where T : Foundation.DecodableWithConfiguration
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Swift.UnkeyedEncodingContainer {
  public mutating func encode<T, C>(_ t: T, configuration: C.Type) throws where T : Foundation.EncodableWithConfiguration, C : Foundation.EncodingConfigurationProviding, T.EncodingConfiguration == C.EncodingConfiguration
  public mutating func encode<T>(_ t: T, configuration: T.EncodingConfiguration) throws where T : Foundation.EncodableWithConfiguration
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Swift.UnkeyedDecodingContainer {
  public mutating func decode<T, C>(_: T.Type, configuration: C.Type) throws -> T where T : Foundation.DecodableWithConfiguration, C : Foundation.DecodingConfigurationProviding, T.DecodingConfiguration == C.DecodingConfiguration
  public mutating func decodeIfPresent<T, C>(_: T.Type, configuration: C.Type) throws -> T? where T : Foundation.DecodableWithConfiguration, C : Foundation.DecodingConfigurationProviding, T.DecodingConfiguration == C.DecodingConfiguration
  public mutating func decode<T>(_: T.Type, configuration: T.DecodingConfiguration) throws -> T where T : Foundation.DecodableWithConfiguration
  public mutating func decodeIfPresent<T>(_: T.Type, configuration: T.DecodingConfiguration) throws -> T? where T : Foundation.DecodableWithConfiguration
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
@propertyWrapper public struct CodableConfiguration<T, ConfigurationProvider> : Swift.Codable where T : Foundation.DecodableWithConfiguration, T : Foundation.EncodableWithConfiguration, ConfigurationProvider : Foundation.DecodingConfigurationProviding, ConfigurationProvider : Foundation.EncodingConfigurationProviding, T.DecodingConfiguration == ConfigurationProvider.DecodingConfiguration, T.EncodingConfiguration == ConfigurationProvider.EncodingConfiguration {
  public var wrappedValue: T
  public init(wrappedValue: T)
  public init(wrappedValue: T, from configurationProvider: ConfigurationProvider.Type)
  public func encode(to encoder: Swift.Encoder) throws
  public init(from decoder: Swift.Decoder) throws
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.CodableConfiguration : Swift.Equatable where T : Swift.Equatable {
  public static func == (a: Foundation.CodableConfiguration<T, ConfigurationProvider>, b: Foundation.CodableConfiguration<T, ConfigurationProvider>) -> Swift.Bool
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.CodableConfiguration : Swift.Hashable where T : Swift.Hashable {
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Swift.Optional : Foundation.EncodableWithConfiguration where Wrapped : Foundation.EncodableWithConfiguration {
  public func encode(to encoder: Swift.Encoder, configuration: Wrapped.EncodingConfiguration) throws
  public typealias EncodingConfiguration = Wrapped.EncodingConfiguration
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Swift.Optional : Foundation.DecodableWithConfiguration where Wrapped : Foundation.DecodableWithConfiguration {
  public init(from decoder: Swift.Decoder, configuration: Wrapped.DecodingConfiguration) throws
  public typealias DecodingConfiguration = Wrapped.DecodingConfiguration
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Swift.Array : Foundation.EncodableWithConfiguration where Element : Foundation.EncodableWithConfiguration {
  public func encode(to encoder: Swift.Encoder, configuration: Element.EncodingConfiguration) throws
  public typealias EncodingConfiguration = Element.EncodingConfiguration
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Swift.Array : Foundation.DecodableWithConfiguration where Element : Foundation.DecodableWithConfiguration {
  public init(from decoder: Swift.Decoder, configuration: Element.DecodingConfiguration) throws
  public typealias DecodingConfiguration = Element.DecodingConfiguration
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
public struct AttributeScopeCodableConfiguration {
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.AttributeScope {
  public static var encodingConfiguration: Foundation.AttributeScopeCodableConfiguration {
    get
  }
  public static var decodingConfiguration: Foundation.AttributeScopeCodableConfiguration {
    get
  }
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.AttributedString : Swift.Codable {
  public func encode(to encoder: Swift.Encoder) throws
  public init(from decoder: Swift.Decoder) throws
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.AttributedString : Foundation.CodableWithConfiguration {
  public func encode(to encoder: Swift.Encoder, configuration: Foundation.AttributeScopeCodableConfiguration) throws
  public init(from decoder: Swift.Decoder, configuration: Foundation.AttributeScopeCodableConfiguration) throws
  public typealias DecodingConfiguration = Foundation.AttributeScopeCodableConfiguration
  public typealias EncodingConfiguration = Foundation.AttributeScopeCodableConfiguration
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.AttributeContainer : Foundation.CodableWithConfiguration {
  public func encode(to encoder: Swift.Encoder, configuration: Foundation.AttributeScopeCodableConfiguration) throws
  public init(from decoder: Swift.Decoder, configuration: Foundation.AttributeScopeCodableConfiguration) throws
  public typealias DecodingConfiguration = Foundation.AttributeScopeCodableConfiguration
  public typealias EncodingConfiguration = Foundation.AttributeScopeCodableConfiguration
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.CodableConfiguration where ConfigurationProvider : Foundation.AttributeScope {
  public init(wrappedValue: T, from keyPath: Swift.KeyPath<Foundation.AttributeScopes, ConfigurationProvider.Type>)
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.Date {
  public struct VerbatimFormatStyle : Foundation.FormatStyle {
    public var timeZone: Foundation.TimeZone
    public var calendar: Foundation.Calendar
    public var locale: Foundation.Locale?
    public init(format: Foundation.Date.FormatString, locale: Foundation.Locale? = nil, timeZone: Foundation.TimeZone, calendar: Foundation.Calendar)
    public var attributed: Foundation.Date.AttributedStyle {
      get
    }
    public func format(_ value: Foundation.Date) -> Swift.String
    public func locale(_ locale: Foundation.Locale) -> Foundation.Date.VerbatimFormatStyle
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: Foundation.Date.VerbatimFormatStyle, b: Foundation.Date.VerbatimFormatStyle) -> Swift.Bool
    public typealias FormatInput = Foundation.Date
    public typealias FormatOutput = Swift.String
    public func encode(to encoder: Swift.Encoder) throws
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: Swift.Decoder) throws
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.Date.VerbatimFormatStyle : Foundation.ParseableFormatStyle {
  public var parseStrategy: Foundation.Date.ParseStrategy {
    get
  }
  public typealias Strategy = Foundation.Date.ParseStrategy
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
public protocol _KeyValueCodingAndObservingPublishing {
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension ObjectiveC.NSObject : Foundation._KeyValueCodingAndObservingPublishing {
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Foundation._KeyValueCodingAndObservingPublishing where Self : ObjectiveC.NSObject {
  public func publisher<Value>(for keyPath: Swift.KeyPath<Self, Value>, options: Foundation.NSKeyValueObservingOptions = [.initial, .new]) -> ObjectiveC.NSObject.KeyValueObservingPublisher<Self, Value>
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension ObjectiveC.NSObject.KeyValueObservingPublisher {
  public func didChange() -> Combine.Publishers.Map<ObjectiveC.NSObject.KeyValueObservingPublisher<Subject, Value>, Swift.Void>
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension ObjectiveC.NSObject {
  public struct KeyValueObservingPublisher<Subject, Value> : Swift.Equatable where Subject : ObjectiveC.NSObject {
    public let object: Subject
    public let keyPath: Swift.KeyPath<Subject, Value>
    public let options: Foundation.NSKeyValueObservingOptions
    public init(object: Subject, keyPath: Swift.KeyPath<Subject, Value>, options: Foundation.NSKeyValueObservingOptions)
    public static func == (lhs: ObjectiveC.NSObject.KeyValueObservingPublisher<Subject, Value>, rhs: ObjectiveC.NSObject.KeyValueObservingPublisher<Subject, Value>) -> Swift.Bool
  }
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension ObjectiveC.NSObject.KeyValueObservingPublisher : Combine.Publisher {
  public typealias Output = Value
  public typealias Failure = Swift.Never
  public func receive<S>(subscriber: S) where Value == S.Input, S : Combine.Subscriber, S.Failure == ObjectiveC.NSObject.KeyValueObservingPublisher<Subject, Value>.Failure
}
public protocol _KeyValueCodingAndObserving {
}
extension ObjectiveC.NSObject : Foundation._KeyValueCodingAndObserving {
}
public struct NSKeyValueObservedChange<Value> {
  public typealias Kind = Foundation.NSKeyValueChange
  public let kind: Foundation.NSKeyValueObservedChange<Value>.Kind
  public let newValue: Value?
  public let oldValue: Value?
  public let indexes: Foundation.IndexSet?
  public let isPrior: Swift.Bool
}
public protocol NSKeyValueObservingCustomization : ObjectiveC.NSObjectProtocol {
  static func keyPathsAffectingValue(for key: Swift.AnyKeyPath) -> Swift.Set<Swift.AnyKeyPath>
  static func automaticallyNotifiesObservers(for key: Swift.AnyKeyPath) -> Swift.Bool
}
@_hasMissingDesignatedInitializers @objc(_NSKeyValueObservation) public class NSKeyValueObservation : ObjectiveC.NSObject {
  @objc public func invalidate()
  @objc deinit
}
extension Foundation._KeyValueCodingAndObserving {
  public func observe<Value>(_ keyPath: Swift.KeyPath<Self, Value>, options: Foundation.NSKeyValueObservingOptions = [], changeHandler: @escaping (Self, Foundation.NSKeyValueObservedChange<Value>) -> Swift.Void) -> Foundation.NSKeyValueObservation
  public func willChangeValue<Value>(for keyPath: __owned Swift.KeyPath<Self, Value>)
  public func willChange<Value>(_ changeKind: Foundation.NSKeyValueChange, valuesAt indexes: Foundation.IndexSet, for keyPath: __owned Swift.KeyPath<Self, Value>)
  public func willChangeValue<Value>(for keyPath: __owned Swift.KeyPath<Self, Value>, withSetMutation mutation: Foundation.NSKeyValueSetMutationKind, using set: Swift.Set<Value>) where Value : Swift.Hashable
  public func didChangeValue<Value>(for keyPath: __owned Swift.KeyPath<Self, Value>)
  public func didChange<Value>(_ changeKind: Foundation.NSKeyValueChange, valuesAt indexes: Foundation.IndexSet, for keyPath: __owned Swift.KeyPath<Self, Value>)
  public func didChangeValue<Value>(for keyPath: __owned Swift.KeyPath<Self, Value>, withSetMutation mutation: Foundation.NSKeyValueSetMutationKind, using set: Swift.Set<Value>) where Value : Swift.Hashable
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.AttributedString {
  @available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
  public func inflected() -> Foundation.AttributedString
}
extension Foundation.Progress {
  @available(macOS 10.13, iOS 11.0, watchOS 4.0, tvOS 11.0, *)
  public var estimatedTimeRemaining: Foundation.TimeInterval? {
    get
    set
  }
  @available(macOS 10.13, iOS 11.0, watchOS 4.0, tvOS 11.0, *)
  public var throughput: Swift.Int? {
    get
    set
  }
  @available(macOS 10.13, iOS 11.0, watchOS 4.0, tvOS 11.0, *)
  public var fileTotalCount: Swift.Int? {
    get
    set
  }
  @available(macOS 10.13, iOS 11.0, watchOS 4.0, tvOS 11.0, *)
  public var fileCompletedCount: Swift.Int? {
    get
    set
  }
  public func performAsCurrent<ReturnType>(withPendingUnitCount unitCount: Swift.Int64, using work: () throws -> ReturnType) rethrows -> ReturnType
}
public struct AffineTransform : Foundation.ReferenceConvertible, Swift.Hashable, Swift.CustomStringConvertible {
  public var m11: CoreGraphics.CGFloat, m12: CoreGraphics.CGFloat, m21: CoreGraphics.CGFloat, m22: CoreGraphics.CGFloat, tX: CoreGraphics.CGFloat, tY: CoreGraphics.CGFloat
  public typealias ReferenceType = Foundation.NSAffineTransform
  public init(m11: CoreGraphics.CGFloat, m12: CoreGraphics.CGFloat, m21: CoreGraphics.CGFloat, m22: CoreGraphics.CGFloat, tX: CoreGraphics.CGFloat, tY: CoreGraphics.CGFloat)
  public init()
  public init(translationByX x: CoreGraphics.CGFloat, byY y: CoreGraphics.CGFloat)
  public init(scaleByX x: CoreGraphics.CGFloat, byY y: CoreGraphics.CGFloat)
  public init(scale factor: CoreGraphics.CGFloat)
  public init(rotationByRadians angle: CoreGraphics.CGFloat)
  public init(rotationByDegrees angle: CoreGraphics.CGFloat)
  public static let identity: Foundation.AffineTransform
  public mutating func translate(x: CoreGraphics.CGFloat, y: CoreGraphics.CGFloat)
  public mutating func rotate(byDegrees angle: CoreGraphics.CGFloat)
  public mutating func rotate(byRadians angle: CoreGraphics.CGFloat)
  public mutating func scale(_ scale: CoreGraphics.CGFloat)
  public mutating func scale(x: CoreGraphics.CGFloat, y: CoreGraphics.CGFloat)
  public mutating func invert()
  public func inverted() -> Foundation.AffineTransform?
  public mutating func append(_ transform: Foundation.AffineTransform)
  public mutating func prepend(_ transform: Foundation.AffineTransform)
  public func transform(_ point: Foundation.NSPoint) -> Foundation.NSPoint
  public func transform(_ size: Foundation.NSSize) -> Foundation.NSSize
  public func hash(into hasher: inout Swift.Hasher)
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
  public static func == (lhs: Foundation.AffineTransform, rhs: Foundation.AffineTransform) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
extension Foundation.AffineTransform : Swift._ObjectiveCBridgeable {
  public static func _getObjectiveCType() -> Any.Type
  @_semantics("convertToObjectiveC") public func _bridgeToObjectiveC() -> Foundation.NSAffineTransform
  public static func _forceBridgeFromObjectiveC(_ x: Foundation.NSAffineTransform, result: inout Foundation.AffineTransform?)
  public static func _conditionallyBridgeFromObjectiveC(_ x: Foundation.NSAffineTransform, result: inout Foundation.AffineTransform?) -> Swift.Bool
  @_effects(readonly) public static func _unconditionallyBridgeFromObjectiveC(_ x: Foundation.NSAffineTransform?) -> Foundation.AffineTransform
  public typealias _ObjectiveCType = Foundation.NSAffineTransform
}
extension Foundation.NSAffineTransform : Swift._HasCustomAnyHashableRepresentation {
  @nonobjc public func _toCustomAnyHashable() -> Swift.AnyHashable?
}
extension Foundation.AffineTransform : Swift.Codable {
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
extension Foundation.Date {
  @available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
  public struct RelativeFormatStyle : Foundation.FormatStyle, Swift.Codable, Swift.Hashable {
    public struct UnitsStyle : Swift.Codable, Swift.Hashable {
      public static var wide: Foundation.Date.RelativeFormatStyle.UnitsStyle {
        get
      }
      public static var spellOut: Foundation.Date.RelativeFormatStyle.UnitsStyle {
        get
      }
      public static var abbreviated: Foundation.Date.RelativeFormatStyle.UnitsStyle {
        get
      }
      public static var narrow: Foundation.Date.RelativeFormatStyle.UnitsStyle {
        get
      }
      public func hash(into hasher: inout Swift.Hasher)
      public static func == (a: Foundation.Date.RelativeFormatStyle.UnitsStyle, b: Foundation.Date.RelativeFormatStyle.UnitsStyle) -> Swift.Bool
      public func encode(to encoder: Swift.Encoder) throws
      public var hashValue: Swift.Int {
        get
      }
      public init(from decoder: Swift.Decoder) throws
    }
    public struct Presentation : Swift.Codable, Swift.Hashable {
      public static var numeric: Foundation.Date.RelativeFormatStyle.Presentation {
        get
      }
      public static var named: Foundation.Date.RelativeFormatStyle.Presentation {
        get
      }
      public func hash(into hasher: inout Swift.Hasher)
      public static func == (a: Foundation.Date.RelativeFormatStyle.Presentation, b: Foundation.Date.RelativeFormatStyle.Presentation) -> Swift.Bool
      public func encode(to encoder: Swift.Encoder) throws
      public var hashValue: Swift.Int {
        get
      }
      public init(from decoder: Swift.Decoder) throws
    }
    public var presentation: Foundation.Date.RelativeFormatStyle.Presentation
    public var unitsStyle: Foundation.Date.RelativeFormatStyle.UnitsStyle
    public var capitalizationContext: Foundation.FormatStyleCapitalizationContext
    public var locale: Foundation.Locale
    public var calendar: Foundation.Calendar
    public init(presentation: Foundation.Date.RelativeFormatStyle.Presentation = .numeric, unitsStyle: Foundation.Date.RelativeFormatStyle.UnitsStyle = .wide, locale: Foundation.Locale = .autoupdatingCurrent, calendar: Foundation.Calendar = .autoupdatingCurrent, capitalizationContext: Foundation.FormatStyleCapitalizationContext = .unknown)
    public func format(_ destDate: Foundation.Date) -> Swift.String
    public func locale(_ locale: Foundation.Locale) -> Foundation.Date.RelativeFormatStyle
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: Foundation.Date.RelativeFormatStyle, b: Foundation.Date.RelativeFormatStyle) -> Swift.Bool
    public typealias FormatInput = Foundation.Date
    public typealias FormatOutput = Swift.String
    public func encode(to encoder: Swift.Encoder) throws
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: Swift.Decoder) throws
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.FormatStyle where Self == Foundation.Date.RelativeFormatStyle {
  public static func relative(presentation: Foundation.Date.RelativeFormatStyle.Presentation, unitsStyle: Foundation.Date.RelativeFormatStyle.UnitsStyle = .wide) -> Self
}
extension Foundation.NSString : Swift.ExpressibleByStringLiteral {
  required convenience public init(stringLiteral value: Swift.StaticString)
  public typealias ExtendedGraphemeClusterLiteralType = Swift.StaticString
  public typealias StringLiteralType = Swift.StaticString
  public typealias UnicodeScalarLiteralType = Swift.StaticString
}
extension Foundation.NSString : Swift._HasCustomAnyHashableRepresentation {
  @nonobjc public func _toCustomAnyHashable() -> Swift.AnyHashable?
}
extension Foundation.NSString {
  convenience public init(format: __shared Foundation.NSString, _ args: Swift.CVarArg...)
  convenience public init(format: __shared Foundation.NSString, locale: Foundation.Locale?, _ args: Swift.CVarArg...)
  public class func localizedStringWithFormat(_ format: Foundation.NSString, _ args: Swift.CVarArg...) -> Self
  public func appendingFormat(_ format: Foundation.NSString, _ args: Swift.CVarArg...) -> Foundation.NSString
}
extension Foundation.NSMutableString {
  public func appendFormat(_ format: Foundation.NSString, _ args: Swift.CVarArg...)
}
extension Foundation.NSString {
  @nonobjc convenience public init(string aString: __shared Foundation.NSString)
}
extension Foundation.NSString : Swift._CustomPlaygroundQuickLookable {
  @available(*, deprecated, message: "NSString.customPlaygroundQuickLook will be removed in a future Swift version")
  public var customPlaygroundQuickLook: Swift.PlaygroundQuickLook {
    get
  }
}
extension Foundation.UndoManager {
  @available(*, unavailable, renamed: "registerUndo(withTarget:handler:)")
  public func registerUndoWithTarget<TargetType>(_ target: TargetType, handler: (TargetType) -> Swift.Void) where TargetType : AnyObject
  @available(macOS 10.11, iOS 9.0, *)
  public func registerUndo<TargetType>(withTarget target: TargetType, handler: @escaping (TargetType) -> Swift.Void) where TargetType : AnyObject
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.Date {
  public struct ParseStrategy : Swift.Hashable {
    public var isLenient: Swift.Bool
    public var twoDigitStartDate: Foundation.Date
    public var locale: Foundation.Locale?
    public var timeZone: Foundation.TimeZone
    public var calendar: Foundation.Calendar
    public var format: Swift.String {
      get
    }
    public init(format: Foundation.Date.FormatString, locale: Foundation.Locale? = nil, timeZone: Foundation.TimeZone, calendar: Foundation.Calendar = Calendar(identifier: .gregorian), isLenient: Swift.Bool = true, twoDigitStartDate: Foundation.Date = Date(timeIntervalSince1970: 0))
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: Foundation.Date.ParseStrategy, b: Foundation.Date.ParseStrategy) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.Date.ParseStrategy : Foundation.ParseStrategy {
  public func parse(_ value: Swift.String) throws -> Foundation.Date
  public typealias ParseInput = Swift.String
  public typealias ParseOutput = Foundation.Date
  public func encode(to encoder: Swift.Encoder) throws
  public init(from decoder: Swift.Decoder) throws
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.ParseStrategy {
  public static func fixed(format: Foundation.Date.FormatString, timeZone: Foundation.TimeZone, locale: Foundation.Locale? = nil) -> Self where Self == Foundation.Date.ParseStrategy
}
public struct IndexPath : Foundation.ReferenceConvertible, Swift.Equatable, Swift.Hashable, Swift.MutableCollection, Swift.RandomAccessCollection, Swift.Comparable, Swift.ExpressibleByArrayLiteral {
  public typealias ReferenceType = Foundation.NSIndexPath
  public typealias Element = Swift.Int
  public typealias Index = Swift.Array<Swift.Int>.Index
  public typealias Indices = Swift.DefaultIndices<Foundation.IndexPath>
  public init()
  public init<ElementSequence>(indexes: ElementSequence) where ElementSequence : Swift.Sequence, ElementSequence.Element == Foundation.IndexPath.Element
  public init(arrayLiteral indexes: Foundation.IndexPath.Element...)
  public init(indexes: Swift.Array<Foundation.IndexPath.Element>)
  public init(index: Foundation.IndexPath.Element)
  public func dropLast() -> Foundation.IndexPath
  public mutating func append(_ other: Foundation.IndexPath)
  public mutating func append(_ other: Foundation.IndexPath.Element)
  public mutating func append(_ other: Swift.Array<Foundation.IndexPath.Element>)
  public func appending(_ other: Foundation.IndexPath.Element) -> Foundation.IndexPath
  public func appending(_ other: Foundation.IndexPath) -> Foundation.IndexPath
  public func appending(_ other: Swift.Array<Foundation.IndexPath.Element>) -> Foundation.IndexPath
  public subscript(index: Foundation.IndexPath.Index) -> Foundation.IndexPath.Element {
    get
    set
  }
  public subscript(range: Swift.Range<Foundation.IndexPath.Index>) -> Foundation.IndexPath {
    get
    set
  }
  public func makeIterator() -> Swift.IndexingIterator<Foundation.IndexPath>
  public var count: Swift.Int {
    get
  }
  public var startIndex: Foundation.IndexPath.Index {
    get
  }
  public var endIndex: Foundation.IndexPath.Index {
    get
  }
  public func index(before i: Foundation.IndexPath.Index) -> Foundation.IndexPath.Index
  public func index(after i: Foundation.IndexPath.Index) -> Foundation.IndexPath.Index
  public func compare(_ other: Foundation.IndexPath) -> Foundation.ComparisonResult
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (lhs: Foundation.IndexPath, rhs: Foundation.IndexPath) -> Swift.Bool
  public static func + (lhs: Foundation.IndexPath, rhs: Foundation.IndexPath) -> Foundation.IndexPath
  public static func += (lhs: inout Foundation.IndexPath, rhs: Foundation.IndexPath)
  public static func < (lhs: Foundation.IndexPath, rhs: Foundation.IndexPath) -> Swift.Bool
  public static func <= (lhs: Foundation.IndexPath, rhs: Foundation.IndexPath) -> Swift.Bool
  public static func > (lhs: Foundation.IndexPath, rhs: Foundation.IndexPath) -> Swift.Bool
  public static func >= (lhs: Foundation.IndexPath, rhs: Foundation.IndexPath) -> Swift.Bool
  public typealias ArrayLiteralElement = Foundation.IndexPath.Element
  public typealias Iterator = Swift.IndexingIterator<Foundation.IndexPath>
  public typealias SubSequence = Foundation.IndexPath
  public var hashValue: Swift.Int {
    get
  }
}
extension Foundation.IndexPath : Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible, Swift.CustomReflectable {
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
  public var customMirror: Swift.Mirror {
    get
  }
}
extension Foundation.IndexPath : Swift._ObjectiveCBridgeable {
  public static func _getObjectiveCType() -> Any.Type
  @_semantics("convertToObjectiveC") public func _bridgeToObjectiveC() -> Foundation.NSIndexPath
  public static func _forceBridgeFromObjectiveC(_ x: Foundation.NSIndexPath, result: inout Foundation.IndexPath?)
  public static func _conditionallyBridgeFromObjectiveC(_ x: Foundation.NSIndexPath, result: inout Foundation.IndexPath?) -> Swift.Bool
  @_effects(readonly) public static func _unconditionallyBridgeFromObjectiveC(_ source: Foundation.NSIndexPath?) -> Foundation.IndexPath
  public typealias _ObjectiveCType = Foundation.NSIndexPath
}
extension Foundation.NSIndexPath : Swift._HasCustomAnyHashableRepresentation {
  @nonobjc public func _toCustomAnyHashable() -> Swift.AnyHashable?
}
extension Foundation.IndexPath : Swift.Codable {
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
extension Swift.Array : Foundation.DataProtocol where Element == Swift.UInt8 {
  public var regions: Swift.CollectionOfOne<Swift.Array<Swift.UInt8>> {
    get
  }
  public typealias Regions = Swift.CollectionOfOne<Swift.Array<Swift.UInt8>>
}
extension Swift.ArraySlice : Foundation.DataProtocol where Element == Swift.UInt8 {
  public var regions: Swift.CollectionOfOne<Swift.ArraySlice<Swift.UInt8>> {
    get
  }
  public typealias Regions = Swift.CollectionOfOne<Swift.ArraySlice<Swift.UInt8>>
}
extension Swift.ContiguousArray : Foundation.DataProtocol where Element == Swift.UInt8 {
  public var regions: Swift.CollectionOfOne<Swift.ContiguousArray<Swift.UInt8>> {
    get
  }
  public typealias Regions = Swift.CollectionOfOne<Swift.ContiguousArray<Swift.UInt8>>
}
extension Swift.EmptyCollection : Foundation.DataProtocol where Element == Swift.UInt8 {
  public var regions: Swift.EmptyCollection<Foundation.Data> {
    get
  }
  public typealias Regions = Swift.EmptyCollection<Foundation.Data>
}
extension Swift.Repeated : Foundation.DataProtocol where Element == Swift.UInt8 {
  public typealias Regions = Swift.Repeated<Foundation.Data>
  public var regions: Swift.Repeated<Foundation.Data> {
    get
  }
}
extension Swift.Array : Foundation.MutableDataProtocol where Element == Swift.UInt8 {
}
extension Swift.ContiguousArray : Foundation.MutableDataProtocol where Element == Swift.UInt8 {
}
public struct TimeZone : Swift.Hashable, Swift.Equatable, Foundation.ReferenceConvertible {
  public typealias ReferenceType = Foundation.NSTimeZone
  public static var current: Foundation.TimeZone {
    get
  }
  public static var autoupdatingCurrent: Foundation.TimeZone {
    get
  }
  public init?(identifier: __shared Swift.String)
  @available(*, unavailable, renamed: "init(secondsFromGMT:)")
  public init(forSecondsFromGMT seconds: Swift.Int)
  public init?(secondsFromGMT seconds: Swift.Int)
  public init?(abbreviation: __shared Swift.String)
  @available(*, unavailable, renamed: "identifier")
  public var name: Swift.String {
    get
  }
  public var identifier: Swift.String {
    get
  }
  @available(*, unavailable, message: "use the identifier instead")
  public var data: Foundation.Data {
    get
  }
  public func secondsFromGMT(for date: Foundation.Date = Date()) -> Swift.Int
  public func abbreviation(for date: Foundation.Date = Date()) -> Swift.String?
  public func isDaylightSavingTime(for date: Foundation.Date = Date()) -> Swift.Bool
  public func daylightSavingTimeOffset(for date: Foundation.Date = Date()) -> Foundation.TimeInterval
  public func nextDaylightSavingTimeTransition(after date: Foundation.Date) -> Foundation.Date?
  public static var knownTimeZoneIdentifiers: [Swift.String] {
    get
  }
  public static var abbreviationDictionary: [Swift.String : Swift.String] {
    get
    set
  }
  public static var timeZoneDataVersion: Swift.String {
    get
  }
  public var nextDaylightSavingTimeTransition: Foundation.Date? {
    get
  }
  @available(*, unavailable, renamed: "localizedName(for:locale:)")
  public func localizedName(_ style: Foundation.NSTimeZone.NameStyle, locale: Foundation.Locale?) -> Swift.String?
  public func localizedName(for style: Foundation.NSTimeZone.NameStyle, locale: Foundation.Locale?) -> Swift.String?
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (lhs: Foundation.TimeZone, rhs: Foundation.TimeZone) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
extension Foundation.TimeZone : Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible, Swift.CustomReflectable {
  public var customMirror: Swift.Mirror {
    get
  }
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
}
extension Foundation.TimeZone : Swift._ObjectiveCBridgeable {
  @_semantics("convertToObjectiveC") public func _bridgeToObjectiveC() -> Foundation.NSTimeZone
  public static func _forceBridgeFromObjectiveC(_ input: Foundation.NSTimeZone, result: inout Foundation.TimeZone?)
  public static func _conditionallyBridgeFromObjectiveC(_ input: Foundation.NSTimeZone, result: inout Foundation.TimeZone?) -> Swift.Bool
  @_effects(readonly) public static func _unconditionallyBridgeFromObjectiveC(_ source: Foundation.NSTimeZone?) -> Foundation.TimeZone
  public typealias _ObjectiveCType = Foundation.NSTimeZone
}
extension Foundation.NSTimeZone : Swift._HasCustomAnyHashableRepresentation {
  @nonobjc public func _toCustomAnyHashable() -> Swift.AnyHashable?
}
extension Foundation.TimeZone : Swift.Codable {
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
extension Foundation.IndexSet.Index {
  public static func == (lhs: Foundation.IndexSet.Index, rhs: Foundation.IndexSet.Index) -> Swift.Bool
  public static func < (lhs: Foundation.IndexSet.Index, rhs: Foundation.IndexSet.Index) -> Swift.Bool
  public static func <= (lhs: Foundation.IndexSet.Index, rhs: Foundation.IndexSet.Index) -> Swift.Bool
  public static func > (lhs: Foundation.IndexSet.Index, rhs: Foundation.IndexSet.Index) -> Swift.Bool
  public static func >= (lhs: Foundation.IndexSet.Index, rhs: Foundation.IndexSet.Index) -> Swift.Bool
}
extension Foundation.IndexSet.RangeView {
  public static func == (lhs: Foundation.IndexSet.RangeView, rhs: Foundation.IndexSet.RangeView) -> Swift.Bool
}
public struct IndexSet : Foundation.ReferenceConvertible, Swift.Equatable, Swift.BidirectionalCollection, Swift.SetAlgebra {
  public struct RangeView : Swift.Equatable, Swift.BidirectionalCollection {
    public typealias Index = Swift.Int
    public let startIndex: Foundation.IndexSet.RangeView.Index
    public let endIndex: Foundation.IndexSet.RangeView.Index
    public func makeIterator() -> Swift.IndexingIterator<Foundation.IndexSet.RangeView>
    public subscript(index: Foundation.IndexSet.RangeView.Index) -> Swift.Range<Foundation.IndexSet.Element> {
      get
    }
    public subscript(bounds: Swift.Range<Foundation.IndexSet.RangeView.Index>) -> Swift.Slice<Foundation.IndexSet.RangeView> {
      get
    }
    public func index(after i: Foundation.IndexSet.RangeView.Index) -> Foundation.IndexSet.RangeView.Index
    public func index(before i: Foundation.IndexSet.RangeView.Index) -> Foundation.IndexSet.RangeView.Index
    public typealias Element = Swift.Range<Foundation.IndexSet.Element>
    public typealias Indices = Swift.DefaultIndices<Foundation.IndexSet.RangeView>
    public typealias Iterator = Swift.IndexingIterator<Foundation.IndexSet.RangeView>
    public typealias SubSequence = Swift.Slice<Foundation.IndexSet.RangeView>
  }
  public struct Index : Swift.CustomStringConvertible, Swift.Comparable {
    public var description: Swift.String {
      get
    }
  }
  public typealias ReferenceType = Foundation.NSIndexSet
  public typealias Element = Swift.Int
  public init(integersIn range: Swift.Range<Foundation.IndexSet.Element>)
  public init<R>(integersIn range: R) where R : Swift.RangeExpression, R.Bound == Foundation.IndexSet.Element
  public init(integer: Foundation.IndexSet.Element)
  public init()
  public func hash(into hasher: inout Swift.Hasher)
  public var count: Swift.Int {
    get
  }
  public func makeIterator() -> Swift.IndexingIterator<Foundation.IndexSet>
  public var rangeView: Foundation.IndexSet.RangeView {
    get
  }
  public func rangeView(of range: Swift.Range<Foundation.IndexSet.Element>) -> Foundation.IndexSet.RangeView
  public func rangeView<R>(of range: R) -> Foundation.IndexSet.RangeView where R : Swift.RangeExpression, R.Bound == Foundation.IndexSet.Element
  public var startIndex: Foundation.IndexSet.Index {
    get
  }
  public var endIndex: Foundation.IndexSet.Index {
    get
  }
  public subscript(index: Foundation.IndexSet.Index) -> Foundation.IndexSet.Element {
    get
  }
  public subscript(bounds: Swift.Range<Foundation.IndexSet.Index>) -> Swift.Slice<Foundation.IndexSet> {
    get
  }
  public var first: Foundation.IndexSet.Element? {
    get
  }
  public var last: Foundation.IndexSet.Element? {
    get
  }
  public func integerGreaterThan(_ integer: Foundation.IndexSet.Element) -> Foundation.IndexSet.Element?
  public func integerLessThan(_ integer: Foundation.IndexSet.Element) -> Foundation.IndexSet.Element?
  public func integerGreaterThanOrEqualTo(_ integer: Foundation.IndexSet.Element) -> Foundation.IndexSet.Element?
  public func integerLessThanOrEqualTo(_ integer: Foundation.IndexSet.Element) -> Foundation.IndexSet.Element?
  public func indexRange(in range: Swift.Range<Foundation.IndexSet.Element>) -> Swift.Range<Foundation.IndexSet.Index>
  public func indexRange<R>(in range: R) -> Swift.Range<Foundation.IndexSet.Index> where R : Swift.RangeExpression, R.Bound == Foundation.IndexSet.Element
  public func count(in range: Swift.Range<Foundation.IndexSet.Element>) -> Swift.Int
  public func count<R>(in range: R) -> Swift.Int where R : Swift.RangeExpression, R.Bound == Foundation.IndexSet.Element
  public func contains(_ integer: Foundation.IndexSet.Element) -> Swift.Bool
  public func contains(integersIn range: Swift.Range<Foundation.IndexSet.Element>) -> Swift.Bool
  public func contains<R>(integersIn range: R) -> Swift.Bool where R : Swift.RangeExpression, R.Bound == Foundation.IndexSet.Element
  public func contains(integersIn indexSet: Foundation.IndexSet) -> Swift.Bool
  public func intersects(integersIn range: Swift.Range<Foundation.IndexSet.Element>) -> Swift.Bool
  public func intersects<R>(integersIn range: R) -> Swift.Bool where R : Swift.RangeExpression, R.Bound == Foundation.IndexSet.Element
  public func index(after i: Foundation.IndexSet.Index) -> Foundation.IndexSet.Index
  public func formIndex(after i: inout Foundation.IndexSet.Index)
  public func index(before i: Foundation.IndexSet.Index) -> Foundation.IndexSet.Index
  public func formIndex(before i: inout Foundation.IndexSet.Index)
  public mutating func formUnion(_ other: Foundation.IndexSet)
  public func union(_ other: Foundation.IndexSet) -> Foundation.IndexSet
  public func symmetricDifference(_ other: Foundation.IndexSet) -> Foundation.IndexSet
  public mutating func formSymmetricDifference(_ other: Foundation.IndexSet)
  public func intersection(_ other: Foundation.IndexSet) -> Foundation.IndexSet
  public mutating func formIntersection(_ other: Foundation.IndexSet)
  @discardableResult
  public mutating func insert(_ integer: Foundation.IndexSet.Element) -> (inserted: Swift.Bool, memberAfterInsert: Foundation.IndexSet.Element)
  @discardableResult
  public mutating func update(with integer: Foundation.IndexSet.Element) -> Foundation.IndexSet.Element?
  @discardableResult
  public mutating func remove(_ integer: Foundation.IndexSet.Element) -> Foundation.IndexSet.Element?
  public mutating func removeAll()
  public mutating func insert(integersIn range: Swift.Range<Foundation.IndexSet.Element>)
  public mutating func insert<R>(integersIn range: R) where R : Swift.RangeExpression, R.Bound == Foundation.IndexSet.Element
  public mutating func remove(integersIn range: Swift.Range<Foundation.IndexSet.Element>)
  public mutating func remove(integersIn range: Swift.ClosedRange<Foundation.IndexSet.Element>)
  public var isEmpty: Swift.Bool {
    get
  }
  public func filteredIndexSet(in range: Swift.Range<Foundation.IndexSet.Element>, includeInteger: (Foundation.IndexSet.Element) throws -> Swift.Bool) rethrows -> Foundation.IndexSet
  public func filteredIndexSet(in range: Swift.ClosedRange<Foundation.IndexSet.Element>, includeInteger: (Foundation.IndexSet.Element) throws -> Swift.Bool) rethrows -> Foundation.IndexSet
  public func filteredIndexSet(includeInteger: (Foundation.IndexSet.Element) throws -> Swift.Bool) rethrows -> Foundation.IndexSet
  public mutating func shift(startingAt integer: Foundation.IndexSet.Element, by delta: Swift.Int)
  public typealias ArrayLiteralElement = Foundation.IndexSet.Element
  public typealias Indices = Swift.DefaultIndices<Foundation.IndexSet>
  public typealias Iterator = Swift.IndexingIterator<Foundation.IndexSet>
  public typealias SubSequence = Swift.Slice<Foundation.IndexSet>
  public var hashValue: Swift.Int {
    get
  }
}
extension Foundation.IndexSet : Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible, Swift.CustomReflectable {
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
  public var customMirror: Swift.Mirror {
    get
  }
}
extension Foundation.IndexSet {
  public static func == (lhs: Foundation.IndexSet, rhs: Foundation.IndexSet) -> Swift.Bool
}
extension Foundation.IndexSet : Swift._ObjectiveCBridgeable {
  public static func _getObjectiveCType() -> Any.Type
  @_semantics("convertToObjectiveC") public func _bridgeToObjectiveC() -> Foundation.NSIndexSet
  public static func _forceBridgeFromObjectiveC(_ x: Foundation.NSIndexSet, result: inout Foundation.IndexSet?)
  public static func _conditionallyBridgeFromObjectiveC(_ x: Foundation.NSIndexSet, result: inout Foundation.IndexSet?) -> Swift.Bool
  @_effects(readonly) public static func _unconditionallyBridgeFromObjectiveC(_ source: Foundation.NSIndexSet?) -> Foundation.IndexSet
  public typealias _ObjectiveCType = Foundation.NSIndexSet
}
extension Foundation.NSIndexSet : Swift._HasCustomAnyHashableRepresentation {
  @nonobjc public func _toCustomAnyHashable() -> Swift.AnyHashable?
}
extension Foundation.IndexSet : Swift.Codable {
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
public struct NSFastEnumerationIterator : Swift.IteratorProtocol {
  public init(_ enumerable: Foundation.NSFastEnumeration)
  public mutating func next() -> Any?
  public typealias Element = Any
}
extension Foundation.NSEnumerator : Swift.Sequence {
  public func makeIterator() -> Foundation.NSFastEnumerationIterator
  public typealias Element = Any
  public typealias Iterator = Foundation.NSFastEnumerationIterator
}
extension Foundation.NSTextCheckingResult.CheckingType {
  public static var allSystemTypes: Foundation.NSTextCheckingResult.CheckingType {
    get
  }
  public static var allCustomTypes: Foundation.NSTextCheckingResult.CheckingType {
    get
  }
  public static var allTypes: Foundation.NSTextCheckingResult.CheckingType {
    get
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
public struct FloatingPointParseStrategy<Format> : Swift.Codable, Swift.Hashable where Format : Foundation.FormatStyle, Format.FormatInput : Swift.BinaryFloatingPoint {
  public var formatStyle: Format
  public var lenient: Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: Foundation.FloatingPointParseStrategy<Format>, b: Foundation.FloatingPointParseStrategy<Format>) -> Swift.Bool
  public func encode(to encoder: Swift.Encoder) throws
  public var hashValue: Swift.Int {
    get
  }
  public init(from decoder: Swift.Decoder) throws
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.FloatingPointParseStrategy : Foundation.ParseStrategy {
  @available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
  public func parse(_ value: Swift.String) throws -> Format.FormatInput
  public typealias ParseInput = Swift.String
  public typealias ParseOutput = Format.FormatInput
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.FloatingPointParseStrategy {
  public init<Value>(format: Format, lenient: Swift.Bool = true) where Format == Foundation.FloatingPointFormatStyle<Value>, Value : Swift.BinaryFloatingPoint
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.FloatingPointParseStrategy {
  public init<Value>(format: Format, lenient: Swift.Bool = true) where Format == Foundation.FloatingPointFormatStyle<Value>.Currency, Value : Swift.BinaryFloatingPoint
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.FloatingPointParseStrategy {
  public init<Value>(format: Format, lenient: Swift.Bool = true) where Format == Foundation.FloatingPointFormatStyle<Value>.Percent, Value : Swift.BinaryFloatingPoint
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.AttributeScopes {
  public var foundation: Foundation.AttributeScopes.FoundationAttributes.Type {
    get
  }
  public struct FoundationAttributes : Foundation.AttributeScope {
    public let link: Foundation.AttributeScopes.FoundationAttributes.LinkAttribute
    public let morphology: Foundation.AttributeScopes.FoundationAttributes.MorphologyAttribute
    public let inflect: Foundation.AttributeScopes.FoundationAttributes.InflectionRuleAttribute
    public let languageIdentifier: Foundation.AttributeScopes.FoundationAttributes.LanguageIdentifierAttribute
    public let personNameComponent: Foundation.AttributeScopes.FoundationAttributes.PersonNameComponentAttribute
    public let numberFormat: Foundation.AttributeScopes.FoundationAttributes.NumberFormatAttributes
    public let dateField: Foundation.AttributeScopes.FoundationAttributes.DateFieldAttribute
    public let inlinePresentationIntent: Foundation.AttributeScopes.FoundationAttributes.InlinePresentationIntentAttribute
    public let presentationIntent: Foundation.AttributeScopes.FoundationAttributes.PresentationIntentAttribute
    public let alternateDescription: Foundation.AttributeScopes.FoundationAttributes.AlternateDescriptionAttribute
    public let imageURL: Foundation.AttributeScopes.FoundationAttributes.ImageURLAttribute
    public let replacementIndex: Foundation.AttributeScopes.FoundationAttributes.ReplacementIndexAttribute
    public let measurement: Foundation.AttributeScopes.FoundationAttributes.MeasurementAttribute
    public let inflectionAlternative: Foundation.AttributeScopes.FoundationAttributes.InflectionAlternativeAttribute
    public let byteCount: Foundation.AttributeScopes.FoundationAttributes.ByteCountAttribute
    public typealias DecodingConfiguration = Foundation.AttributeScopeCodableConfiguration
    public typealias EncodingConfiguration = Foundation.AttributeScopeCodableConfiguration
  }
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.AttributeDynamicLookup {
  public subscript<T>(dynamicMember keyPath: Swift.KeyPath<Foundation.AttributeScopes.FoundationAttributes, T>) -> T where T : Foundation.AttributedStringKey {
    get
  }
  public subscript<T>(dynamicMember keyPath: Swift.KeyPath<Foundation.AttributeScopes.FoundationAttributes.NumberFormatAttributes, T>) -> T where T : Foundation.AttributedStringKey {
    get
  }
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.AttributeScopes.FoundationAttributes {
  @available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
  @frozen public enum LinkAttribute : Foundation.CodableAttributedStringKey, Foundation.ObjectiveCConvertibleAttributedStringKey {
    public typealias Value = Foundation.URL
    public typealias ObjectiveCValue = ObjectiveC.NSObject
    public static var name: Swift.String
    public static func objectiveCValue(for value: Foundation.URL) throws -> ObjectiveC.NSObject
    public static func value(for object: ObjectiveC.NSObject) throws -> Foundation.URL
  }
  @available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
  @frozen public enum MorphologyAttribute : Foundation.CodableAttributedStringKey, Foundation.MarkdownDecodableAttributedStringKey {
    public typealias Value = Foundation.Morphology
    public static let name: Swift.String
    public static let markdownName: Swift.String
  }
  @available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
  @frozen public enum InflectionRuleAttribute : Foundation.CodableAttributedStringKey, Foundation.MarkdownDecodableAttributedStringKey {
    public typealias Value = Foundation.InflectionRule
    public static let name: Swift.String
    public static let markdownName: Swift.String
  }
  @available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
  @frozen public enum LanguageIdentifierAttribute : Foundation.CodableAttributedStringKey, Foundation.MarkdownDecodableAttributedStringKey {
    public typealias Value = Swift.String
    public static let name: Swift.String
    public static let markdownName: Swift.String
  }
  @available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
  @frozen public enum PersonNameComponentAttribute : Foundation.CodableAttributedStringKey, Foundation.ObjectiveCConvertibleAttributedStringKey {
    public typealias Value = Foundation.AttributeScopes.FoundationAttributes.PersonNameComponentAttribute.Component
    public typealias ObjectiveCValue = Foundation.NSString
    public static let name: Swift.String
    public enum Component : Swift.String, Swift.Codable {
      case givenName, familyName, middleName, namePrefix, nameSuffix, nickname, delimiter
      public init?(rawValue: Swift.String)
      public typealias RawValue = Swift.String
      public var rawValue: Swift.String {
        get
      }
    }
  }
  @available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
  public struct NumberFormatAttributes : Foundation.AttributeScope {
    public let numberSymbol: Foundation.AttributeScopes.FoundationAttributes.NumberFormatAttributes.SymbolAttribute
    public let numberPart: Foundation.AttributeScopes.FoundationAttributes.NumberFormatAttributes.NumberPartAttribute
    @frozen public enum NumberPartAttribute : Foundation.CodableAttributedStringKey {
      public enum NumberPart : Swift.Int, Swift.Codable {
        case integer
        case fraction
        public init?(rawValue: Swift.Int)
        public typealias RawValue = Swift.Int
        public var rawValue: Swift.Int {
          get
        }
      }
      public static let name: Swift.String
      public typealias Value = Foundation.AttributeScopes.FoundationAttributes.NumberFormatAttributes.NumberPartAttribute.NumberPart
    }
    @frozen public enum SymbolAttribute : Foundation.CodableAttributedStringKey {
      public enum Symbol : Swift.Int, Swift.Codable {
        case groupingSeparator
        case sign
        case decimalSeparator
        case currency
        case percent
        public init?(rawValue: Swift.Int)
        public typealias RawValue = Swift.Int
        public var rawValue: Swift.Int {
          get
        }
      }
      public static let name: Swift.String
      public typealias Value = Foundation.AttributeScopes.FoundationAttributes.NumberFormatAttributes.SymbolAttribute.Symbol
    }
    public typealias DecodingConfiguration = Foundation.AttributeScopeCodableConfiguration
    public typealias EncodingConfiguration = Foundation.AttributeScopeCodableConfiguration
  }
  @available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
  @frozen public enum DateFieldAttribute : Foundation.CodableAttributedStringKey {
    public enum Field : Swift.Hashable, Swift.Codable {
      case era
      case year
      case relatedGregorianYear
      case quarter
      case month
      case weekOfYear
      case weekOfMonth
      case weekday
      case weekdayOrdinal
      case day
      case dayOfYear
      case amPM
      case hour
      case minute
      case second
      case secondFraction
      case timeZone
      public init(from decoder: Swift.Decoder) throws
      public func encode(to encoder: Swift.Encoder) throws
      public static func == (a: Foundation.AttributeScopes.FoundationAttributes.DateFieldAttribute.Field, b: Foundation.AttributeScopes.FoundationAttributes.DateFieldAttribute.Field) -> Swift.Bool
      public func hash(into hasher: inout Swift.Hasher)
      public var hashValue: Swift.Int {
        get
      }
    }
    public static let name: Swift.String
    public typealias Value = Foundation.AttributeScopes.FoundationAttributes.DateFieldAttribute.Field
  }
  @available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
  @frozen public enum InflectionAlternativeAttribute : Foundation.CodableAttributedStringKey, Foundation.MarkdownDecodableAttributedStringKey, Foundation.ObjectiveCConvertibleAttributedStringKey {
    public typealias Value = Foundation.AttributedString
    public typealias ObjectiveCValue = ObjectiveC.NSObject
    public static let name: Swift.String
    public static let markdownName: Swift.String
    public static func decodeMarkdown(from decoder: Swift.Decoder) throws -> Foundation.AttributedString
    public static func objectiveCValue(for value: Foundation.AttributedString) throws -> ObjectiveC.NSObject
    public static func value(for object: ObjectiveC.NSObject) throws -> Foundation.AttributedString
  }
  @available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
  @frozen public enum InlinePresentationIntentAttribute : Foundation.CodableAttributedStringKey, Foundation.ObjectiveCConvertibleAttributedStringKey {
    public typealias Value = Foundation.InlinePresentationIntent
    public typealias ObjectiveCValue = Foundation.NSNumber
    public static let name: Swift.String
    public static func objectiveCValue(for value: Foundation.InlinePresentationIntent) throws -> Foundation.NSNumber
    public static func value(for object: Foundation.NSNumber) throws -> Foundation.InlinePresentationIntent
  }
  @available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
  @frozen public enum PresentationIntentAttribute : Foundation.CodableAttributedStringKey {
    public typealias Value = Foundation.PresentationIntent
    public static let name: Swift.String
  }
  @available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
  @frozen public enum AlternateDescriptionAttribute : Foundation.CodableAttributedStringKey {
    public typealias Value = Swift.String
    public static let name: Swift.String
  }
  @available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
  @frozen public enum ImageURLAttribute : Foundation.CodableAttributedStringKey {
    public typealias Value = Foundation.URL
    public static let name: Swift.String
  }
  @available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
  @frozen public enum ReplacementIndexAttribute : Foundation.CodableAttributedStringKey {
    public typealias Value = Swift.Int
    public static let name: Swift.String
  }
  @available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
  public struct MeasurementAttribute : Foundation.CodableAttributedStringKey {
    public typealias Value = Foundation.AttributeScopes.FoundationAttributes.MeasurementAttribute.Component
    public static let name: Swift.String
    public enum Component : Swift.Int, Swift.Codable {
      case value
      case unit
      public init?(rawValue: Swift.Int)
      public typealias RawValue = Swift.Int
      public var rawValue: Swift.Int {
        get
      }
    }
  }
  @available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
  @frozen public enum ByteCountAttribute : Foundation.CodableAttributedStringKey {
    public typealias Value = Foundation.AttributeScopes.FoundationAttributes.ByteCountAttribute.Component
    public static let name: Swift.String
    public enum Component : Swift.Codable, Swift.Hashable {
      case value
      case spelledOutValue
      case unit(Foundation.AttributeScopes.FoundationAttributes.ByteCountAttribute.Unit)
      case actualByteCount
      public func hash(into hasher: inout Swift.Hasher)
      public static func == (a: Foundation.AttributeScopes.FoundationAttributes.ByteCountAttribute.Component, b: Foundation.AttributeScopes.FoundationAttributes.ByteCountAttribute.Component) -> Swift.Bool
      public func encode(to encoder: Swift.Encoder) throws
      public var hashValue: Swift.Int {
        get
      }
      public init(from decoder: Swift.Decoder) throws
    }
    public enum Unit : Swift.Codable {
      case byte
      case kb
      case mb
      case gb
      case tb
      case pb
      case eb
      case zb
      case yb
      public static func == (a: Foundation.AttributeScopes.FoundationAttributes.ByteCountAttribute.Unit, b: Foundation.AttributeScopes.FoundationAttributes.ByteCountAttribute.Unit) -> Swift.Bool
      public func hash(into hasher: inout Swift.Hasher)
      public func encode(to encoder: Swift.Encoder) throws
      public var hashValue: Swift.Int {
        get
      }
      public init(from decoder: Swift.Decoder) throws
    }
  }
}
extension Foundation.NSDictionary : Swift.ExpressibleByDictionaryLiteral {
  required convenience public init(dictionaryLiteral elements: (Any, Any)...)
  public typealias Key = Any
  public typealias Value = Any
}
extension Swift.Dictionary : Swift._ObjectiveCBridgeable {
  @_semantics("convertToObjectiveC") public func _bridgeToObjectiveC() -> Foundation.NSDictionary
  @_specialize(exported: false, kind: full, where Key == Swift.String, Value == Any)
  public static func _forceBridgeFromObjectiveC(_ d: Foundation.NSDictionary, result: inout Swift.Dictionary<Key, Value>?)
  @_specialize(exported: false, kind: full, where Key == Swift.String, Value == Any)
  public static func _conditionallyBridgeFromObjectiveC(_ x: Foundation.NSDictionary, result: inout Swift.Dictionary<Key, Value>?) -> Swift.Bool
  @_effects(readonly) public static func _unconditionallyBridgeFromObjectiveC(_ d: Foundation.NSDictionary?) -> Swift.Dictionary<Key, Value>
  public typealias _ObjectiveCType = Foundation.NSDictionary
}
extension Foundation.NSDictionary : Swift._HasCustomAnyHashableRepresentation {
  @nonobjc public func _toCustomAnyHashable() -> Swift.AnyHashable?
}
extension Foundation.NSDictionary : Swift.Sequence {
  @_hasMissingDesignatedInitializers @_objcRuntimeName(_TtCE10FoundationCSo12NSDictionary9_Iterator) final public class Iterator : Swift.IteratorProtocol {
    final public func next() -> (key: Any, value: Any)?
    public typealias Element = (key: Any, value: Any)
    @objc deinit
  }
  @objc dynamic public subscript(key: Any) -> Any? {
    @objc(__swift_objectForKeyedSubscript:) get
  }
  public func makeIterator() -> Foundation.NSDictionary.Iterator
  @_alwaysEmitIntoClient @nonobjc public var underestimatedCount: Swift.Int {
    get { count }
  }
  public typealias Element = (key: Any, value: Any)
}
extension Foundation.NSMutableDictionary {
  @objc override dynamic public subscript(key: Any) -> Any? {
    @objc(__swift_objectForKeyedSubscript:) get
    @objc(__swift_setObject:forKeyedSubscript:) set
  }
}
extension Foundation.NSDictionary {
  @objc(__swiftInitWithDictionary_NSDictionary:) convenience dynamic public init(dictionary otherDictionary: __shared Foundation.NSDictionary)
}
extension Foundation.NSDictionary : Swift.CustomReflectable {
  public var customMirror: Swift.Mirror {
    get
  }
}
extension Swift.Dictionary : Swift.CVarArg {
}
extension ObjectiveC.NSObject : Swift.CustomStringConvertible {
}
extension ObjectiveC.NSObject : Swift.CustomDebugStringConvertible {
}
public let NSNotFound: Swift.Int
public func NSLocalizedString(_ key: Swift.String, tableName: Swift.String? = nil, bundle: Foundation.Bundle = Bundle.main, value: Swift.String = "", comment: Swift.String) -> Swift.String
public func NSLog(_ format: Swift.String, _ args: Swift.CVarArg...)
extension Swift.AnyHashable : Swift._ObjectiveCBridgeable {
  public func _bridgeToObjectiveC() -> ObjectiveC.NSObject
  public static func _forceBridgeFromObjectiveC(_ x: ObjectiveC.NSObject, result: inout Swift.AnyHashable?)
  public static func _conditionallyBridgeFromObjectiveC(_ x: ObjectiveC.NSObject, result: inout Swift.AnyHashable?) -> Swift.Bool
  @_effects(readonly) public static func _unconditionallyBridgeFromObjectiveC(_ source: ObjectiveC.NSObject?) -> Swift.AnyHashable
  public typealias _ObjectiveCType = ObjectiveC.NSObject
}
extension Swift.CVarArg where Self : Swift._ObjectiveCBridgeable {
  public var _cVarArgEncoding: [Swift.Int] {
    get
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.Measurement where UnitType : Foundation.Dimension {
  public struct FormatStyle : Foundation.FormatStyle {
    public struct UnitWidth : Swift.Codable, Swift.Hashable {
      public static var wide: Foundation.Measurement<UnitType>.FormatStyle.UnitWidth {
        get
      }
      public static var abbreviated: Foundation.Measurement<UnitType>.FormatStyle.UnitWidth {
        get
      }
      public static var narrow: Foundation.Measurement<UnitType>.FormatStyle.UnitWidth {
        get
      }
      public func hash(into hasher: inout Swift.Hasher)
      public static func == (a: Foundation.Measurement<UnitType>.FormatStyle.UnitWidth, b: Foundation.Measurement<UnitType>.FormatStyle.UnitWidth) -> Swift.Bool
      public func encode(to encoder: Swift.Encoder) throws
      public var hashValue: Swift.Int {
        get
      }
      public init(from decoder: Swift.Decoder) throws
    }
    public var width: Foundation.Measurement<UnitType>.FormatStyle.UnitWidth
    public var locale: Foundation.Locale
    public var numberFormatStyle: Foundation.FloatingPointFormatStyle<Swift.Double>?
    public var usage: Foundation.MeasurementFormatUnitUsage<UnitType>?
    public var attributed: Foundation.Measurement<UnitType>.AttributedStyle {
      get
    }
    public init(width: Foundation.Measurement<UnitType>.FormatStyle.UnitWidth, locale: Foundation.Locale = .autoupdatingCurrent, usage: Foundation.MeasurementFormatUnitUsage<UnitType> = .general, numberFormatStyle: Foundation.FloatingPointFormatStyle<Swift.Double>? = nil)
    public func locale(_ locale: Foundation.Locale) -> Foundation.Measurement<UnitType>.FormatStyle
    public func format(_ measurement: Foundation.Measurement<UnitType>) -> Swift.String
    public static func == (a: Foundation.Measurement<UnitType>.FormatStyle, b: Foundation.Measurement<UnitType>.FormatStyle) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public typealias FormatInput = Foundation.Measurement<UnitType>
    public typealias FormatOutput = Swift.String
    public func encode(to encoder: Swift.Encoder) throws
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: Swift.Decoder) throws
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.Measurement.FormatStyle where UnitType == Foundation.UnitTemperature {
  public var hidesScaleName: Swift.Bool {
    get
    set
  }
  public init(width: Foundation.Measurement<UnitType>.FormatStyle.UnitWidth = .abbreviated, locale: Foundation.Locale = .autoupdatingCurrent, usage: Foundation.MeasurementFormatUnitUsage<UnitType> = .general, hidesScaleName: Swift.Bool = false, numberFormatStyle: Foundation.FloatingPointFormatStyle<Swift.Double>? = nil)
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
public struct MeasurementFormatUnitUsage<UnitType> : Swift.Codable, Swift.Hashable where UnitType : Foundation.Dimension {
  public static var general: Foundation.MeasurementFormatUnitUsage<UnitType> {
    get
  }
  public static var asProvided: Foundation.MeasurementFormatUnitUsage<UnitType> {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: Foundation.MeasurementFormatUnitUsage<UnitType>, b: Foundation.MeasurementFormatUnitUsage<UnitType>) -> Swift.Bool
  public func encode(to encoder: Swift.Encoder) throws
  public var hashValue: Swift.Int {
    get
  }
  public init(from decoder: Swift.Decoder) throws
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.MeasurementFormatUnitUsage where UnitType == Foundation.UnitTemperature {
  public static var weather: Foundation.MeasurementFormatUnitUsage<Foundation.UnitTemperature> {
    get
  }
  public static var person: Foundation.MeasurementFormatUnitUsage<Foundation.UnitTemperature> {
    get
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.MeasurementFormatUnitUsage where UnitType == Foundation.UnitLength {
  public static var person: Foundation.MeasurementFormatUnitUsage<Foundation.UnitLength> {
    get
  }
  public static var road: Foundation.MeasurementFormatUnitUsage<Foundation.UnitLength> {
    get
  }
  public static var personHeight: Foundation.MeasurementFormatUnitUsage<Foundation.UnitLength> {
    get
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.MeasurementFormatUnitUsage where UnitType == Foundation.UnitEnergy {
  public static var food: Foundation.MeasurementFormatUnitUsage<Foundation.UnitEnergy> {
    get
  }
  public static var workout: Foundation.MeasurementFormatUnitUsage<Foundation.UnitEnergy> {
    get
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.MeasurementFormatUnitUsage where UnitType == Foundation.UnitMass {
  public static var personWeight: Foundation.MeasurementFormatUnitUsage<Foundation.UnitMass> {
    get
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.Measurement where UnitType : Foundation.Dimension {
  public func formatted<S>(_ style: S) -> S.FormatOutput where S : Foundation.FormatStyle, S.FormatInput == Foundation.Measurement<UnitType>
  public func formatted() -> Swift.String
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.FormatStyle {
  public static func measurement<UnitType>(width: Foundation.Measurement<UnitType>.FormatStyle.UnitWidth, usage: Foundation.MeasurementFormatUnitUsage<UnitType> = .general, numberFormatStyle: Foundation.FloatingPointFormatStyle<Swift.Double>? = nil) -> Self where Self == Foundation.Measurement<UnitType>.FormatStyle, UnitType : Foundation.Dimension
  public static func measurement(width: Foundation.Measurement<Foundation.UnitTemperature>.FormatStyle.UnitWidth = .abbreviated, usage: Foundation.MeasurementFormatUnitUsage<Foundation.UnitTemperature> = .general, hidesScaleName: Swift.Bool = false, numberFormatStyle: Foundation.FloatingPointFormatStyle<Swift.Double>? = nil) -> Self where Self == Foundation.Measurement<Foundation.UnitTemperature>.FormatStyle
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Foundation.Timer {
  public static func publish(every interval: Foundation.TimeInterval, tolerance: Foundation.TimeInterval? = nil, on runLoop: Foundation.RunLoop, in mode: Foundation.RunLoop.Mode, options: Foundation.RunLoop.SchedulerOptions? = nil) -> Foundation.Timer.TimerPublisher
  final public class TimerPublisher : Combine.ConnectablePublisher {
    public typealias Output = Foundation.Date
    public typealias Failure = Swift.Never
    final public let interval: Foundation.TimeInterval
    final public let tolerance: Foundation.TimeInterval?
    final public let runLoop: Foundation.RunLoop
    final public let mode: Foundation.RunLoop.Mode
    final public let options: Foundation.RunLoop.SchedulerOptions?
    public init(interval: Foundation.TimeInterval, tolerance: Foundation.TimeInterval? = nil, runLoop: Foundation.RunLoop, mode: Foundation.RunLoop.Mode, options: Foundation.RunLoop.SchedulerOptions? = nil)
    @objc deinit
    final public func connect() -> Combine.Cancellable
    final public func receive<S>(subscriber: S) where S : Combine.Subscriber, S.Failure == Foundation.Timer.TimerPublisher.Failure, S.Input == Foundation.Timer.TimerPublisher.Output
  }
}
@available(macOS 10.13, iOS 11.0, watchOS 4.0, tvOS 11.0, *)
extension Foundation.NSItemProvider {
  @available(macOS 10.13, iOS 11.0, watchOS 4.0, tvOS 11.0, *)
  public func registerObject<T>(ofClass: T.Type, visibility: Foundation.NSItemProviderRepresentationVisibility, loadHandler: @escaping ((T?, Swift.Error?) -> Swift.Void) -> Foundation.Progress?) where T : Swift._ObjectiveCBridgeable, T._ObjectiveCType : Foundation.NSItemProviderWriting
  @available(macOS 10.13, iOS 11.0, watchOS 4.0, tvOS 11.0, *)
  public func canLoadObject<T>(ofClass: T.Type) -> Swift.Bool where T : Swift._ObjectiveCBridgeable, T._ObjectiveCType : Foundation.NSItemProviderReading
  @available(macOS 10.13, iOS 11.0, watchOS 4.0, tvOS 11.0, *)
  public func loadObject<T>(ofClass: T.Type, completionHandler: @escaping (T?, Swift.Error?) -> Swift.Void) -> Foundation.Progress where T : Swift._ObjectiveCBridgeable, T._ObjectiveCType : Foundation.NSItemProviderReading
}
extension Foundation.NSArray : Swift.ExpressibleByArrayLiteral {
  required convenience public init(arrayLiteral elements: Any...)
  public typealias ArrayLiteralElement = Any
}
extension Swift.Array : Swift._ObjectiveCBridgeable {
  @_semantics("convertToObjectiveC") public func _bridgeToObjectiveC() -> Foundation.NSArray
  public static func _forceBridgeFromObjectiveC(_ source: Foundation.NSArray, result: inout Swift.Array<Element>?)
  public static func _conditionallyBridgeFromObjectiveC(_ source: Foundation.NSArray, result: inout Swift.Array<Element>?) -> Swift.Bool
  @_effects(readonly) public static func _unconditionallyBridgeFromObjectiveC(_ source: Foundation.NSArray?) -> Swift.Array<Element>
  public typealias _ObjectiveCType = Foundation.NSArray
}
extension Foundation.NSArray : Swift._HasCustomAnyHashableRepresentation {
  @nonobjc public func _toCustomAnyHashable() -> Swift.AnyHashable?
}
extension Foundation.NSArray : Swift.Sequence {
  final public func makeIterator() -> Foundation.NSFastEnumerationIterator
  @_alwaysEmitIntoClient @nonobjc public var underestimatedCount: Swift.Int {
    get { count }
  }
  public typealias Element = Any
  public typealias Iterator = Foundation.NSFastEnumerationIterator
}
extension Foundation.NSArray {
  convenience public init(objects elements: Any...)
}
extension Foundation.NSArray {
  @nonobjc convenience public init(array anArray: __shared Foundation.NSArray)
}
extension Foundation.NSArray : Swift.CustomReflectable {
  public var customMirror: Swift.Mirror {
    get
  }
}
extension Swift.Array : Swift.CVarArg {
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Swift.Range where Bound == Foundation.Date {
  public func formatted<S>(_ style: S) -> S.FormatOutput where S : Foundation.FormatStyle, S.FormatInput == Swift.Range<Foundation.Date>
  public func formatted() -> Swift.String
  public func formatted(date: Foundation.Date.IntervalFormatStyle.DateStyle, time: Foundation.Date.IntervalFormatStyle.TimeStyle) -> Swift.String
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.NSAttributedString {
  convenience public init(contentsOf url: Foundation.URL, options: Foundation.AttributedString.MarkdownParsingOptions = .init(), baseURL: Foundation.URL? = nil) throws
  convenience public init(markdown: Foundation.Data, options: Foundation.AttributedString.MarkdownParsingOptions = .init(), baseURL: Foundation.URL? = nil) throws
  convenience public init(markdown: Swift.String, options: Foundation.AttributedString.MarkdownParsingOptions = .init(), baseURL: Foundation.URL? = nil) throws
}

#if compiler(>=5.3) && $RethrowsProtocol
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
public struct AsyncCharacterSequence<Base> : _Concurrency.AsyncSequence where Base : _Concurrency.AsyncSequence, Base.Element == Swift.UInt8 {
  public typealias Element = Swift.Character
  @frozen public struct AsyncIterator : _Concurrency.AsyncIteratorProtocol {
    @usableFromInline
    internal var remaining: Foundation.AsyncUnicodeScalarSequence<Base>.AsyncIterator
    @usableFromInline
    internal var accumulator: Swift.String = ""
    
    #if compiler(>=5.3) && $AsyncAwait
    @inlinable @inline(__always) public mutating func next() async rethrows -> Swift.Character? {
            while let scalar = try await remaining.next() {
                accumulator.unicodeScalars.append(scalar)
                if accumulator.count > 1 {
                    return accumulator.removeFirst()
                }
            }
            return accumulator.count > 0 ? accumulator.removeFirst() : nil
        }
    #endif

    public typealias Element = Swift.Character
  }
  public func makeAsyncIterator() -> Foundation.AsyncCharacterSequence<Base>.AsyncIterator
}
#endif


#if compiler(>=5.3) && $RethrowsProtocol
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension _Concurrency.AsyncSequence where Self.Element == Swift.UInt8 {
  @available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
  public var characters: Foundation.AsyncCharacterSequence<Self> {
    get
  }
}
#endif

@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Foundation.NotificationCenter {
  public func publisher(for name: Foundation.Notification.Name, object: Swift.AnyObject? = nil) -> Foundation.NotificationCenter.Publisher
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Foundation.NotificationCenter {
  public struct Publisher : Combine.Publisher {
    public typealias Output = Foundation.Notification
    public typealias Failure = Swift.Never
    public let center: Foundation.NotificationCenter
    public let name: Foundation.Notification.Name
    public let object: Swift.AnyObject?
    public init(center: Foundation.NotificationCenter, name: Foundation.Notification.Name, object: Swift.AnyObject? = nil)
    public func receive<S>(subscriber: S) where S : Combine.Subscriber, S.Failure == Foundation.NotificationCenter.Publisher.Failure, S.Input == Foundation.NotificationCenter.Publisher.Output
  }
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Foundation.NotificationCenter.Publisher : Swift.Equatable {
  public static func == (lhs: Foundation.NotificationCenter.Publisher, rhs: Foundation.NotificationCenter.Publisher) -> Swift.Bool
}
@_objcRuntimeName(_TtC10Foundation20_PropertyListEncoder) open class PropertyListEncoder {
  open var outputFormat: Foundation.PropertyListSerialization.PropertyListFormat
  open var userInfo: [Swift.CodingUserInfoKey : Any]
  public init()
  open func encode<Value>(_ value: Value) throws -> Foundation.Data where Value : Swift.Encodable
  @objc deinit
}
@_objcRuntimeName(_TtC10Foundation20_PropertyListDecoder) open class PropertyListDecoder {
  open var userInfo: [Swift.CodingUserInfoKey : Any]
  public init()
  open func decode<T>(_ type: T.Type, from data: Foundation.Data) throws -> T where T : Swift.Decodable
  open func decode<T>(_ type: T.Type, from data: Foundation.Data, format: inout Foundation.PropertyListSerialization.PropertyListFormat) throws -> T where T : Swift.Decodable
  @objc deinit
}
@_alwaysEmitIntoClient internal func _withStackOrHeapBuffer(capacity: Swift.Int, _ body: (Swift.UnsafeMutableBufferPointer<Swift.UInt8>) -> Swift.Void) {
    guard capacity > 0 else {
        body(UnsafeMutableBufferPointer(start: nil, count: 0))
        return
    }
    typealias InlineBuffer = ( // 32 bytes
        UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8,
        UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8,
        UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8,
        UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8
    )
    let inlineCount = MemoryLayout<InlineBuffer>.size
    if capacity <= inlineCount {
        var buffer: InlineBuffer = (
            0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0
        )
        withUnsafeMutableBytes(of: &buffer) { buffer in
            assert(buffer.count == inlineCount)
            let start = buffer.baseAddress!.assumingMemoryBound(to: UInt8.self)
            body(UnsafeMutableBufferPointer(start: start, count: capacity))
        }
        return
    }

    let buffer = UnsafeMutableBufferPointer<UInt8>.allocate(capacity: capacity)
    defer { buffer.deallocate() }
    body(buffer)
}
@usableFromInline
final internal class __DataStorage {
  @usableFromInline
  internal static let maxSize: Swift.Int
  @usableFromInline
  internal static let vmOpsThreshold: Swift.Int
  @inlinable internal static func allocate(_ size: Swift.Int, _ clear: Swift.Bool) -> Swift.UnsafeMutableRawPointer? {
        if clear {
            return calloc(1, size)
        } else {
            return malloc(size)
        }
    }
  @usableFromInline
  internal static func move(_ dest_: Swift.UnsafeMutableRawPointer, _ source_: Swift.UnsafeRawPointer?, _ num_: Swift.Int)
  @inlinable internal static func shouldAllocateCleared(_ size: Swift.Int) -> Swift.Bool {
        return (size > (128 * 1024))
    }
  @usableFromInline
  final internal var _bytes: Swift.UnsafeMutableRawPointer?
  @usableFromInline
  final internal var _length: Swift.Int
  @usableFromInline
  final internal var _capacity: Swift.Int
  @usableFromInline
  final internal var _offset: Swift.Int
  @usableFromInline
  final internal var _deallocator: ((Swift.UnsafeMutableRawPointer, Swift.Int) -> Swift.Void)?
  @usableFromInline
  final internal var _needToZero: Swift.Bool
  @inlinable final internal var bytes: Swift.UnsafeRawPointer? {
    get {
        return UnsafeRawPointer(_bytes)?.advanced(by: -_offset)
    }
  }
  @discardableResult
  @inlinable final internal func withUnsafeBytes<Result>(in range: Swift.Range<Swift.Int>, apply: (Swift.UnsafeRawBufferPointer) throws -> Result) rethrows -> Result {
        return try apply(UnsafeRawBufferPointer(start: _bytes?.advanced(by: range.lowerBound - _offset), count: Swift.min(range.upperBound - range.lowerBound, _length)))
    }
  @discardableResult
  @inlinable final internal func withUnsafeMutableBytes<Result>(in range: Swift.Range<Swift.Int>, apply: (Swift.UnsafeMutableRawBufferPointer) throws -> Result) rethrows -> Result {
        return try apply(UnsafeMutableRawBufferPointer(start: _bytes!.advanced(by:range.lowerBound - _offset), count: Swift.min(range.upperBound - range.lowerBound, _length)))
    }
  @inlinable final internal var mutableBytes: Swift.UnsafeMutableRawPointer? {
    get {
        return _bytes?.advanced(by: -_offset)
    }
  }
  @inlinable final internal var capacity: Swift.Int {
    get {
        return _capacity
    }
  }
  @inlinable final internal var length: Swift.Int {
    get {
            return _length
        }
    set {
            setLength(newValue)
        }
  }
  @inlinable final internal var isExternallyOwned: Swift.Bool {
    get {
        // all __DataStorages will have some sort of capacity, because empty cases hit the .empty enum _Representation
        // anything with 0 capacity means that we have not allocated this pointer and concequently mutation is not ours to make.
        return _capacity == 0
    }
  }
  @usableFromInline
  final internal func ensureUniqueBufferReference(growingTo newLength: Swift.Int = 0, clear: Swift.Bool = false)
  @inlinable final internal func _freeBytes() {
        if let bytes = _bytes {
            if let dealloc = _deallocator {
                dealloc(bytes, length)
            } else {
                free(bytes)
            }
        }
        _deallocator = nil
    }
  @inlinable final internal func enumerateBytes(in range: Swift.Range<Swift.Int>, _ block: (_ buffer: Swift.UnsafeBufferPointer<Swift.UInt8>, _ byteIndex: Foundation.Data.Index, _ stop: inout Swift.Bool) -> Swift.Void) {
        var stopv: Bool = false
        block(UnsafeBufferPointer<UInt8>(start: _bytes?.advanced(by: range.lowerBound - _offset).assumingMemoryBound(to: UInt8.self), count: Swift.min(range.upperBound - range.lowerBound, _length)), 0, &stopv)
    }
  @inlinable final internal func setLength(_ length: Swift.Int) {
        let origLength = _length
        let newLength = length
        if _capacity < newLength || _bytes == nil {
            ensureUniqueBufferReference(growingTo: newLength, clear: true)
        } else if origLength < newLength && _needToZero {
            memset(_bytes! + origLength, 0, newLength - origLength)
        } else if newLength < origLength {
            _needToZero = true
        }
        _length = newLength
    }
  @inlinable final internal func append(_ bytes: Swift.UnsafeRawPointer, length: Swift.Int) {
        precondition(length >= 0, "Length of appending bytes must not be negative")
        let origLength = _length
        let newLength = origLength + length
        if _capacity < newLength || _bytes == nil {
            ensureUniqueBufferReference(growingTo: newLength, clear: false)
        }
        _length = newLength
        __DataStorage.move(_bytes!.advanced(by: origLength), bytes, length)
    }
  @inlinable final internal func get(_ index: Swift.Int) -> Swift.UInt8 {
        return _bytes!.advanced(by: index - _offset).assumingMemoryBound(to: UInt8.self).pointee
    }
  @inlinable final internal func set(_ index: Swift.Int, to value: Swift.UInt8) {
        ensureUniqueBufferReference()
        _bytes!.advanced(by: index - _offset).assumingMemoryBound(to: UInt8.self).pointee = value
    }
  @inlinable final internal func copyBytes(to pointer: Swift.UnsafeMutableRawPointer, from range: Swift.Range<Swift.Int>) {
        let offsetPointer = UnsafeRawBufferPointer(start: _bytes?.advanced(by: range.lowerBound - _offset), count: Swift.min(range.upperBound - range.lowerBound, _length))
        UnsafeMutableRawBufferPointer(start: pointer, count: range.upperBound - range.lowerBound).copyMemory(from: offsetPointer)
    }
  @usableFromInline
  final internal func replaceBytes(in range_: Foundation.NSRange, with replacementBytes: Swift.UnsafeRawPointer?, length replacementLength: Swift.Int)
  @usableFromInline
  final internal func resetBytes(in range_: Swift.Range<Swift.Int>)
  @usableFromInline
  internal init(length: Swift.Int)
  @usableFromInline
  internal init(capacity capacity_: Swift.Int = 0)
  @usableFromInline
  internal init(bytes: Swift.UnsafeRawPointer?, length: Swift.Int)
  @usableFromInline
  internal init(bytes: Swift.UnsafeMutableRawPointer?, length: Swift.Int, copy: Swift.Bool, deallocator: ((Swift.UnsafeMutableRawPointer, Swift.Int) -> Swift.Void)?, offset: Swift.Int)
  @usableFromInline
  internal init(immutableReference: Foundation.NSData, offset: Swift.Int)
  @usableFromInline
  internal init(mutableReference: Foundation.NSMutableData, offset: Swift.Int)
  @usableFromInline
  internal init(customReference: Foundation.NSData, offset: Swift.Int)
  @usableFromInline
  internal init(customMutableReference: Foundation.NSMutableData, offset: Swift.Int)
  @objc deinit
  @inlinable final internal func mutableCopy(_ range: Swift.Range<Swift.Int>) -> Foundation.__DataStorage {
        return __DataStorage(bytes: _bytes?.advanced(by: range.lowerBound - _offset), length: range.upperBound - range.lowerBound, copy: true, deallocator: nil, offset: range.lowerBound)
    }
  @inlinable final internal func withInteriorPointerReference<T>(_ range: Swift.Range<Swift.Int>, _ work: (Foundation.NSData) throws -> T) rethrows -> T {
        if range.isEmpty {
            return try work(NSData()) // zero length data can be optimized as a singleton
        }
        return try work(NSData(bytesNoCopy: _bytes!.advanced(by: range.lowerBound - _offset), length: range.upperBound - range.lowerBound, freeWhenDone: false))
    }
  @usableFromInline
  @inline(never) final internal func bridgedReference(_ range: Swift.Range<Swift.Int>) -> Foundation.NSData
}
@frozen public struct Data : Foundation.ReferenceConvertible, Swift.Equatable, Swift.Hashable, Swift.RandomAccessCollection, Swift.MutableCollection, Swift.RangeReplaceableCollection, Foundation.MutableDataProtocol, Foundation.ContiguousBytes {
  public typealias ReferenceType = Foundation.NSData
  public typealias ReadingOptions = Foundation.NSData.ReadingOptions
  public typealias WritingOptions = Foundation.NSData.WritingOptions
  public typealias SearchOptions = Foundation.NSData.SearchOptions
  public typealias Base64EncodingOptions = Foundation.NSData.Base64EncodingOptions
  public typealias Base64DecodingOptions = Foundation.NSData.Base64DecodingOptions
  public typealias Index = Swift.Int
  public typealias Indices = Swift.Range<Swift.Int>
  @usableFromInline
  @frozen internal struct InlineData {
    @usableFromInline
    internal typealias Buffer = (Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8)
    @usableFromInline
    internal var bytes: Foundation.Data.InlineData.Buffer
    @usableFromInline
    internal var length: Swift.UInt8
    @inlinable internal static func canStore(count: Swift.Int) -> Swift.Bool {
            return count <= MemoryLayout<Buffer>.size
        }
    @inlinable internal init(_ srcBuffer: Swift.UnsafeRawBufferPointer) {
            self.init(count: srcBuffer.count)
            if !srcBuffer.isEmpty {
                Swift.withUnsafeMutableBytes(of: &bytes) { dstBuffer in
                    dstBuffer.baseAddress?.copyMemory(from: srcBuffer.baseAddress!, byteCount: srcBuffer.count)
                }
            }
        }
    @inlinable internal init(count: Swift.Int = 0) {
            assert(count <= MemoryLayout<Buffer>.size)
            bytes = (UInt8(0), UInt8(0), UInt8(0), UInt8(0), UInt8(0), UInt8(0), UInt8(0), UInt8(0), UInt8(0), UInt8(0), UInt8(0), UInt8(0), UInt8(0), UInt8(0))
            length = UInt8(count)
        }
    @inlinable internal init(_ slice: Foundation.Data.InlineSlice, count: Swift.Int) {
            self.init(count: count)
            Swift.withUnsafeMutableBytes(of: &bytes) { dstBuffer in
                slice.withUnsafeBytes { srcBuffer in
                    dstBuffer.copyMemory(from: UnsafeRawBufferPointer(start: srcBuffer.baseAddress, count: count))
                }
            }
        }
    @inlinable internal init(_ slice: Foundation.Data.LargeSlice, count: Swift.Int) {
            self.init(count: count)
            Swift.withUnsafeMutableBytes(of: &bytes) { dstBuffer in
                slice.withUnsafeBytes { srcBuffer in
                    dstBuffer.copyMemory(from: UnsafeRawBufferPointer(start: srcBuffer.baseAddress, count: count))
                }
            }
        }
    @inlinable internal var capacity: Swift.Int {
      get {
            return MemoryLayout<Buffer>.size
        }
    }
    @inlinable internal var count: Swift.Int {
      get {
                return Int(length)
            }
      set(newValue) {
                assert(newValue <= MemoryLayout<Buffer>.size)
                if newValue > length {
                    resetBytes(in: Int(length) ..< newValue) // Also extends length
                } else {
                    length = UInt8(newValue)
                }
            }
    }
    @inlinable internal var startIndex: Swift.Int {
      get {
            return 0
        }
    }
    @inlinable internal var endIndex: Swift.Int {
      get {
            return count
        }
    }
    @inlinable internal func withUnsafeBytes<Result>(_ apply: (Swift.UnsafeRawBufferPointer) throws -> Result) rethrows -> Result {
            let count = Int(length)
            return try Swift.withUnsafeBytes(of: bytes) { (rawBuffer) throws -> Result in
                return try apply(UnsafeRawBufferPointer(start: rawBuffer.baseAddress, count: count))
            }
        }
    @inlinable internal mutating func withUnsafeMutableBytes<Result>(_ apply: (Swift.UnsafeMutableRawBufferPointer) throws -> Result) rethrows -> Result {
            let count = Int(length)
            return try Swift.withUnsafeMutableBytes(of: &bytes) { (rawBuffer) throws -> Result in
                return try apply(UnsafeMutableRawBufferPointer(start: rawBuffer.baseAddress, count: count))
            }
        }
    @inlinable internal mutating func append(byte: Swift.UInt8) {
            let count = self.count
            assert(count + 1 <= MemoryLayout<Buffer>.size)
            Swift.withUnsafeMutableBytes(of: &bytes) { $0[count] = byte }
            self.length += 1
        }
    @inlinable internal mutating func append(contentsOf buffer: Swift.UnsafeRawBufferPointer) {
            guard !buffer.isEmpty else { return }
            assert(count + buffer.count <= MemoryLayout<Buffer>.size)
            let cnt = count
            _ = Swift.withUnsafeMutableBytes(of: &bytes) { rawBuffer in
                rawBuffer.baseAddress?.advanced(by: cnt).copyMemory(from: buffer.baseAddress!, byteCount: buffer.count)
            }

            length += UInt8(buffer.count)
        }
    @inlinable internal subscript(index: Foundation.Data.Index) -> Swift.UInt8 {
      get {
                assert(index <= MemoryLayout<Buffer>.size)
                precondition(index < length, "index \(index) is out of bounds of 0..<\(length)")
                return Swift.withUnsafeBytes(of: bytes) { rawBuffer -> UInt8 in
                    return rawBuffer[index]
                }
            }
      set(newValue) {
                assert(index <= MemoryLayout<Buffer>.size)
                precondition(index < length, "index \(index) is out of bounds of 0..<\(length)")
                Swift.withUnsafeMutableBytes(of: &bytes) { rawBuffer in
                    rawBuffer[index] = newValue
                }
            }
    }
    @inlinable internal mutating func resetBytes(in range: Swift.Range<Foundation.Data.Index>) {
            assert(range.lowerBound <= MemoryLayout<Buffer>.size)
            assert(range.upperBound <= MemoryLayout<Buffer>.size)
            precondition(range.lowerBound <= length, "index \(range.lowerBound) is out of bounds of 0..<\(length)")
            if length < range.upperBound {
                length = UInt8(range.upperBound)
            }

            let _ = Swift.withUnsafeMutableBytes(of: &bytes) { rawBuffer in
              memset(rawBuffer.baseAddress?.advanced(by: range.lowerBound), 0, range.upperBound - range.lowerBound)
            }
        }
    @usableFromInline
    internal mutating func replaceSubrange(_ subrange: Swift.Range<Foundation.Data.Index>, with replacementBytes: Swift.UnsafeRawPointer?, count replacementLength: Swift.Int)
    @inlinable internal func copyBytes(to pointer: Swift.UnsafeMutableRawPointer, from range: Swift.Range<Swift.Int>) {
            precondition(startIndex <= range.lowerBound, "index \(range.lowerBound) is out of bounds of \(startIndex)..<\(endIndex)")
            precondition(range.lowerBound <= endIndex, "index \(range.lowerBound) is out of bounds of \(startIndex)..<\(endIndex)")
            precondition(startIndex <= range.upperBound, "index \(range.upperBound) is out of bounds of \(startIndex)..<\(endIndex)")
            precondition(range.upperBound <= endIndex, "index \(range.upperBound) is out of bounds of \(startIndex)..<\(endIndex)")

            Swift.withUnsafeBytes(of: bytes) {
                let cnt = Swift.min($0.count, range.upperBound - range.lowerBound)
                guard cnt > 0 else { return }
                pointer.copyMemory(from: $0.baseAddress!.advanced(by: range.lowerBound), byteCount: cnt)
            }
        }
  }
  @usableFromInline
  internal typealias HalfInt = Swift.Int32
  @usableFromInline
  @frozen internal struct InlineSlice {
    @usableFromInline
    internal var slice: Swift.Range<Foundation.Data.HalfInt>
    @usableFromInline
    internal var storage: Foundation.__DataStorage
    @inlinable internal static func canStore(count: Swift.Int) -> Swift.Bool {
            return count < HalfInt.max
        }
    @inlinable internal init(_ buffer: Swift.UnsafeRawBufferPointer) {
            assert(buffer.count < HalfInt.max)
            self.init(__DataStorage(bytes: buffer.baseAddress, length: buffer.count), count: buffer.count)
        }
    @inlinable internal init(capacity: Swift.Int) {
            assert(capacity < HalfInt.max)
            self.init(__DataStorage(capacity: capacity), count: 0)
        }
    @inlinable internal init(count: Swift.Int) {
            assert(count < HalfInt.max)
            self.init(__DataStorage(length: count), count: count)
        }
    @inlinable internal init(_ inline: Foundation.Data.InlineData) {
            assert(inline.count < HalfInt.max)
            self.init(inline.withUnsafeBytes { return __DataStorage(bytes: $0.baseAddress, length: $0.count) }, count: inline.count)
        }
    @inlinable internal init(_ inline: Foundation.Data.InlineData, range: Swift.Range<Swift.Int>) {
            assert(range.lowerBound < HalfInt.max)
            assert(range.upperBound < HalfInt.max)
            self.init(inline.withUnsafeBytes { return __DataStorage(bytes: $0.baseAddress, length: $0.count) }, range: range)
        }
    @inlinable internal init(_ large: Foundation.Data.LargeSlice) {
            assert(large.range.lowerBound < HalfInt.max)
            assert(large.range.upperBound < HalfInt.max)
            self.init(large.storage, range: large.range)
        }
    @inlinable internal init(_ large: Foundation.Data.LargeSlice, range: Swift.Range<Swift.Int>) {
            assert(range.lowerBound < HalfInt.max)
            assert(range.upperBound < HalfInt.max)
            self.init(large.storage, range: range)
        }
    @inlinable internal init(_ storage: Foundation.__DataStorage, count: Swift.Int) {
            assert(count < HalfInt.max)
            self.storage = storage
            slice = 0..<HalfInt(count)
        }
    @inlinable internal init(_ storage: Foundation.__DataStorage, range: Swift.Range<Swift.Int>) {
            assert(range.lowerBound < HalfInt.max)
            assert(range.upperBound < HalfInt.max)
            self.storage = storage
            slice = HalfInt(range.lowerBound)..<HalfInt(range.upperBound)
        }
    @inlinable internal mutating func ensureUniqueReference() {
            if !isKnownUniquelyReferenced(&storage) {
                storage = storage.mutableCopy(self.range)
            }
        }
    @inlinable internal var startIndex: Swift.Int {
      get {
            return Int(slice.lowerBound)
        }
    }
    @inlinable internal var endIndex: Swift.Int {
      get {
            return Int(slice.upperBound)
        }
    }
    @inlinable internal var capacity: Swift.Int {
      get {
            return storage.capacity
        }
    }
    @inlinable internal mutating func reserveCapacity(_ minimumCapacity: Swift.Int) {
            ensureUniqueReference()
            // the current capacity can be zero (representing externally owned buffer), and count can be greater than the capacity
            storage.ensureUniqueBufferReference(growingTo: Swift.max(minimumCapacity, count))
        }
    @inlinable internal var count: Swift.Int {
      get {
                return Int(slice.upperBound - slice.lowerBound)
            }
      set(newValue) {
                assert(newValue < HalfInt.max)
                ensureUniqueReference()
                
                let difference = newValue - count
                if difference > 0 {
                    let additionalRange = Int(slice.upperBound) ..< Int(slice.upperBound) + difference
                    storage.resetBytes(in: additionalRange) // Also extends storage length
                } else {
                    storage.length += difference
                }
                slice = slice.lowerBound..<(slice.lowerBound + HalfInt(newValue))
            }
    }
    @inlinable internal var range: Swift.Range<Swift.Int> {
      get {
                return Int(slice.lowerBound)..<Int(slice.upperBound)
            }
      set(newValue) {
                assert(newValue.lowerBound < HalfInt.max)
                assert(newValue.upperBound < HalfInt.max)
                slice = HalfInt(newValue.lowerBound)..<HalfInt(newValue.upperBound)
            }
    }
    @inlinable internal func withUnsafeBytes<Result>(_ apply: (Swift.UnsafeRawBufferPointer) throws -> Result) rethrows -> Result {
            return try storage.withUnsafeBytes(in: range, apply: apply)
        }
    @inlinable internal mutating func withUnsafeMutableBytes<Result>(_ apply: (Swift.UnsafeMutableRawBufferPointer) throws -> Result) rethrows -> Result {
            ensureUniqueReference()
            return try storage.withUnsafeMutableBytes(in: range, apply: apply)
        }
    @inlinable internal mutating func append(contentsOf buffer: Swift.UnsafeRawBufferPointer) {
            assert(endIndex + buffer.count < HalfInt.max)
            ensureUniqueReference()
            storage.replaceBytes(in: NSRange(location: range.upperBound, length: storage.length - (range.upperBound - storage._offset)), with: buffer.baseAddress, length: buffer.count)
            slice = slice.lowerBound..<HalfInt(Int(slice.upperBound) + buffer.count)
        }
    @inlinable internal subscript(index: Foundation.Data.Index) -> Swift.UInt8 {
      get {
                assert(index < HalfInt.max)
                precondition(startIndex <= index, "index \(index) is out of bounds of \(startIndex)..<\(endIndex)")
                precondition(index < endIndex, "index \(index) is out of bounds of \(startIndex)..<\(endIndex)")
                return storage.get(index)
            }
      set(newValue) {
                assert(index < HalfInt.max)
                precondition(startIndex <= index, "index \(index) is out of bounds of \(startIndex)..<\(endIndex)")
                precondition(index < endIndex, "index \(index) is out of bounds of \(startIndex)..<\(endIndex)")
                ensureUniqueReference()
                storage.set(index, to: newValue)
            }
    }
    @inlinable internal func bridgedReference() -> Foundation.NSData {
            return storage.bridgedReference(self.range)
        }
    @inlinable internal mutating func resetBytes(in range: Swift.Range<Foundation.Data.Index>) {
            assert(range.lowerBound < HalfInt.max)
            assert(range.upperBound < HalfInt.max)
            precondition(range.lowerBound <= endIndex, "index \(range.lowerBound) is out of bounds of \(startIndex)..<\(endIndex)")
            ensureUniqueReference()
            storage.resetBytes(in: range)
            if slice.upperBound < range.upperBound {
                slice = slice.lowerBound..<HalfInt(range.upperBound)
            }
        }
    @inlinable internal mutating func replaceSubrange(_ subrange: Swift.Range<Foundation.Data.Index>, with bytes: Swift.UnsafeRawPointer?, count cnt: Swift.Int) {
            precondition(startIndex <= subrange.lowerBound, "index \(subrange.lowerBound) is out of bounds of \(startIndex)..<\(endIndex)")
            precondition(subrange.lowerBound <= endIndex, "index \(subrange.lowerBound) is out of bounds of \(startIndex)..<\(endIndex)")
            precondition(startIndex <= subrange.upperBound, "index \(subrange.upperBound) is out of bounds of \(startIndex)..<\(endIndex)")
            precondition(subrange.upperBound <= endIndex, "index \(subrange.upperBound) is out of bounds of \(startIndex)..<\(endIndex)")

            let nsRange = NSRange(location: subrange.lowerBound, length: subrange.upperBound - subrange.lowerBound)
            ensureUniqueReference()
            let upper = range.upperBound
            storage.replaceBytes(in: nsRange, with: bytes, length: cnt)
            let resultingUpper = upper - nsRange.length + cnt
            slice = slice.lowerBound..<HalfInt(resultingUpper)
        }
    @inlinable internal func copyBytes(to pointer: Swift.UnsafeMutableRawPointer, from range: Swift.Range<Swift.Int>) {
            precondition(startIndex <= range.lowerBound, "index \(range.lowerBound) is out of bounds of \(startIndex)..<\(endIndex)")
            precondition(range.lowerBound <= endIndex, "index \(range.lowerBound) is out of bounds of \(startIndex)..<\(endIndex)")
            precondition(startIndex <= range.upperBound, "index \(range.upperBound) is out of bounds of \(startIndex)..<\(endIndex)")
            precondition(range.upperBound <= endIndex, "index \(range.upperBound) is out of bounds of \(startIndex)..<\(endIndex)")
            storage.copyBytes(to: pointer, from: range)
        }
  }
  @usableFromInline
  @_fixed_layout final internal class RangeReference {
    @usableFromInline
    final internal var range: Swift.Range<Swift.Int>
    @inlinable @inline(__always) final internal var lowerBound: Swift.Int {
      get {
            return range.lowerBound
        }
    }
    @inlinable @inline(__always) final internal var upperBound: Swift.Int {
      get {
            return range.upperBound
        }
    }
    @inlinable @inline(__always) final internal var count: Swift.Int {
      get {
            return range.upperBound - range.lowerBound
        }
    }
    @inlinable @inline(__always) internal init(_ range: Swift.Range<Swift.Int>) {
            self.range = range
        }
    @objc @usableFromInline
    deinit
  }
  @usableFromInline
  @frozen internal struct LargeSlice {
    @usableFromInline
    internal var slice: Foundation.Data.RangeReference
    @usableFromInline
    internal var storage: Foundation.__DataStorage
    @inlinable internal init(_ buffer: Swift.UnsafeRawBufferPointer) {
            self.init(__DataStorage(bytes: buffer.baseAddress, length: buffer.count), count: buffer.count)
        }
    @inlinable internal init(capacity: Swift.Int) {
            self.init(__DataStorage(capacity: capacity), count: 0)
        }
    @inlinable internal init(count: Swift.Int) {
            self.init(__DataStorage(length: count), count: count)
        }
    @inlinable internal init(_ inline: Foundation.Data.InlineData) {
            let storage = inline.withUnsafeBytes { return __DataStorage(bytes: $0.baseAddress, length: $0.count) }
            self.init(storage, count: inline.count)
        }
    @inlinable internal init(_ slice: Foundation.Data.InlineSlice) {
            self.storage = slice.storage
            self.slice = RangeReference(slice.range)
        }
    @inlinable internal init(_ storage: Foundation.__DataStorage, count: Swift.Int) {
            self.storage = storage
            self.slice = RangeReference(0..<count)
        }
    @inlinable internal mutating func ensureUniqueReference() {
            if !isKnownUniquelyReferenced(&storage) {
                storage = storage.mutableCopy(range)
            }
            if !isKnownUniquelyReferenced(&slice) {
                slice = RangeReference(range)
            }
        }
    @inlinable internal var startIndex: Swift.Int {
      get {
            return slice.range.lowerBound
        }
    }
    @inlinable internal var endIndex: Swift.Int {
      get {
          return slice.range.upperBound
        }
    }
    @inlinable internal var capacity: Swift.Int {
      get {
            return storage.capacity
        }
    }
    @inlinable internal mutating func reserveCapacity(_ minimumCapacity: Swift.Int) {
            ensureUniqueReference()
            // the current capacity can be zero (representing externally owned buffer), and count can be greater than the capacity
            storage.ensureUniqueBufferReference(growingTo: Swift.max(minimumCapacity, count))
        }
    @inlinable internal var count: Swift.Int {
      get {
                return slice.count
            }
      set(newValue) {
                ensureUniqueReference()
                let difference = newValue - count
                if difference > 0 {
                    let additionalRange = Int(slice.upperBound) ..< Int(slice.upperBound) + difference
                    storage.resetBytes(in: additionalRange) // Already sets the length
                } else {
                    storage.length += difference
                }
                slice.range = slice.range.lowerBound..<(slice.range.lowerBound + newValue)
            }
    }
    @inlinable internal var range: Swift.Range<Swift.Int> {
      get {
            return slice.range
        }
    }
    @inlinable internal func withUnsafeBytes<Result>(_ apply: (Swift.UnsafeRawBufferPointer) throws -> Result) rethrows -> Result {
            return try storage.withUnsafeBytes(in: range, apply: apply)
        }
    @inlinable internal mutating func withUnsafeMutableBytes<Result>(_ apply: (Swift.UnsafeMutableRawBufferPointer) throws -> Result) rethrows -> Result {
            ensureUniqueReference()
            return try storage.withUnsafeMutableBytes(in: range, apply: apply)
        }
    @inlinable internal mutating func append(contentsOf buffer: Swift.UnsafeRawBufferPointer) {
            ensureUniqueReference()
            storage.replaceBytes(in: NSRange(location: range.upperBound, length: storage.length - (range.upperBound - storage._offset)), with: buffer.baseAddress, length: buffer.count)
            slice.range = slice.range.lowerBound..<slice.range.upperBound + buffer.count
        }
    @inlinable internal subscript(index: Foundation.Data.Index) -> Swift.UInt8 {
      get {
                precondition(startIndex <= index, "index \(index) is out of bounds of \(startIndex)..<\(endIndex)")
                precondition(index < endIndex, "index \(index) is out of bounds of \(startIndex)..<\(endIndex)")
                return storage.get(index)
            }
      set(newValue) {
                precondition(startIndex <= index, "index \(index) is out of bounds of \(startIndex)..<\(endIndex)")
                precondition(index < endIndex, "index \(index) is out of bounds of \(startIndex)..<\(endIndex)")
                ensureUniqueReference()
                storage.set(index, to: newValue)
            }
    }
    @inlinable internal func bridgedReference() -> Foundation.NSData {
            return storage.bridgedReference(self.range)
        }
    @inlinable internal mutating func resetBytes(in range: Swift.Range<Swift.Int>) {
            precondition(range.lowerBound <= endIndex, "index \(range.lowerBound) is out of bounds of \(startIndex)..<\(endIndex)")
            ensureUniqueReference()
            storage.resetBytes(in: range)
            if slice.range.upperBound < range.upperBound {
                slice.range = slice.range.lowerBound..<range.upperBound
            }
        }
    @inlinable internal mutating func replaceSubrange(_ subrange: Swift.Range<Foundation.Data.Index>, with bytes: Swift.UnsafeRawPointer?, count cnt: Swift.Int) {
            precondition(startIndex <= subrange.lowerBound, "index \(subrange.lowerBound) is out of bounds of \(startIndex)..<\(endIndex)")
            precondition(subrange.lowerBound <= endIndex, "index \(subrange.lowerBound) is out of bounds of \(startIndex)..<\(endIndex)")
            precondition(startIndex <= subrange.upperBound, "index \(subrange.upperBound) is out of bounds of \(startIndex)..<\(endIndex)")
            precondition(subrange.upperBound <= endIndex, "index \(subrange.upperBound) is out of bounds of \(startIndex)..<\(endIndex)")

            let nsRange = NSRange(location: subrange.lowerBound, length: subrange.upperBound - subrange.lowerBound)
            ensureUniqueReference()
            let upper = range.upperBound
            storage.replaceBytes(in: nsRange, with: bytes, length: cnt)
            let resultingUpper = upper - nsRange.length + cnt
            slice.range = slice.range.lowerBound..<resultingUpper
        }
    @inlinable internal func copyBytes(to pointer: Swift.UnsafeMutableRawPointer, from range: Swift.Range<Swift.Int>) {
            precondition(startIndex <= range.lowerBound, "index \(range.lowerBound) is out of bounds of \(startIndex)..<\(endIndex)")
            precondition(range.lowerBound <= endIndex, "index \(range.lowerBound) is out of bounds of \(startIndex)..<\(endIndex)")
            precondition(startIndex <= range.upperBound, "index \(range.upperBound) is out of bounds of \(startIndex)..<\(endIndex)")
            precondition(range.upperBound <= endIndex, "index \(range.upperBound) is out of bounds of \(startIndex)..<\(endIndex)")
            storage.copyBytes(to: pointer, from: range)
        }
  }
  @usableFromInline
  @frozen internal enum _Representation {
    case empty
    case inline(Foundation.Data.InlineData)
    case slice(Foundation.Data.InlineSlice)
    case large(Foundation.Data.LargeSlice)
    @inlinable internal init(_ buffer: Swift.UnsafeRawBufferPointer) {
            if buffer.isEmpty {
                self = .empty
            } else if InlineData.canStore(count: buffer.count) {
                self = .inline(InlineData(buffer))
            } else if InlineSlice.canStore(count: buffer.count) {
                self = .slice(InlineSlice(buffer))
            } else {
                self = .large(LargeSlice(buffer))
            }
        }
    @inlinable internal init(_ buffer: Swift.UnsafeRawBufferPointer, owner: Swift.AnyObject) {
            if buffer.isEmpty {
                self = .empty
            } else if InlineData.canStore(count: buffer.count) {
                self = .inline(InlineData(buffer))
            } else {
                let count = buffer.count
                let storage = __DataStorage(bytes: UnsafeMutableRawPointer(mutating: buffer.baseAddress), length: count, copy: false, deallocator: { _, _ in
                    _fixLifetime(owner)
                }, offset: 0)
                if InlineSlice.canStore(count: count) {
                    self = .slice(InlineSlice(storage, count: count))
                } else {
                    self = .large(LargeSlice(storage, count: count))
                }
            }
        }
    @inlinable internal init(capacity: Swift.Int) {
            if capacity == 0 {
                self = .empty
            } else if InlineData.canStore(count: capacity) {
                self = .inline(InlineData())
            } else if InlineSlice.canStore(count: capacity) {
                self = .slice(InlineSlice(capacity: capacity))
            } else {
                self = .large(LargeSlice(capacity: capacity))
            }
        }
    @inlinable internal init(count: Swift.Int) {
            if count == 0 {
                self = .empty
            } else if InlineData.canStore(count: count) {
                self = .inline(InlineData(count: count))
            } else if InlineSlice.canStore(count: count) {
                self = .slice(InlineSlice(count: count))
            } else {
                self = .large(LargeSlice(count: count))
            }
        }
    @inlinable internal init(_ storage: Foundation.__DataStorage, count: Swift.Int) {
            if count == 0 {
                self = .empty
            } else if InlineData.canStore(count: count) {
                self = .inline(storage.withUnsafeBytes(in: 0..<count) { InlineData($0) })
            } else if InlineSlice.canStore(count: count) {
                self = .slice(InlineSlice(storage, count: count))
            } else {
                self = .large(LargeSlice(storage, count: count))
            }
        }
    @usableFromInline
    internal mutating func reserveCapacity(_ minimumCapacity: Swift.Int)
    @inlinable internal var count: Swift.Int {
      get {
                switch self {
                case .empty: return 0
                case .inline(let inline): return inline.count
                case .slice(let slice): return slice.count
                case .large(let slice): return slice.count
                }
            }
      set(newValue) {
                // HACK: The definition of this inline function takes an inout reference to self, giving the optimizer a unique referencing guarantee.
                //       This allows us to avoid excessive retain-release traffic around modifying enum values, and inlining the function then avoids the additional frame.
                @inline(__always)
                func apply(_ representation: inout _Representation, _ newValue: Int) -> _Representation? {
                    switch representation {
                    case .empty:
                        if newValue == 0 {
                            return nil
                        } else if InlineData.canStore(count: newValue) {
                            return .inline(InlineData(count: newValue))
                        } else if InlineSlice.canStore(count: newValue) {
                            return .slice(InlineSlice(count: newValue))
                        } else {
                            return .large(LargeSlice(count: newValue))
                        }
                    case .inline(var inline):
                        if newValue == 0 {
                            return .empty
                        } else if InlineData.canStore(count: newValue) {
                            guard inline.count != newValue else { return nil }
                            inline.count = newValue
                            return .inline(inline)
                        } else if InlineSlice.canStore(count: newValue) {
                            var slice = InlineSlice(inline)
                            slice.count = newValue
                            return .slice(slice)
                        } else {
                            var slice = LargeSlice(inline)
                            slice.count = newValue
                            return .large(slice)
                        }
                    case .slice(var slice):
                        if newValue == 0 && slice.startIndex == 0 {
                            return .empty
                        } else if slice.startIndex == 0 && InlineData.canStore(count: newValue) {
                            return .inline(InlineData(slice, count: newValue))
                        } else if InlineSlice.canStore(count: newValue + slice.startIndex) {
                            guard slice.count != newValue else { return nil }
                            representation = .empty // TODO: remove this when mgottesman lands optimizations
                            slice.count = newValue
                            return .slice(slice)
                        } else {
                            var newSlice = LargeSlice(slice)
                            newSlice.count = newValue
                            return .large(newSlice)
                        }
                    case .large(var slice):
                        if newValue == 0 && slice.startIndex == 0 {
                            return .empty
                        } else if slice.startIndex == 0 && InlineData.canStore(count: newValue) {
                            return .inline(InlineData(slice, count: newValue))
                        } else {
                            guard slice.count != newValue else { return nil}
                            representation = .empty // TODO: remove this when mgottesman lands optimizations
                            slice.count = newValue
                            return .large(slice)
                        }
                    }
                }

                if let rep = apply(&self, newValue) {
                    self = rep
                }
            }
    }
    @inlinable internal func withUnsafeBytes<Result>(_ apply: (Swift.UnsafeRawBufferPointer) throws -> Result) rethrows -> Result {
            switch self {
            case .empty:
                let empty = InlineData()
                return try empty.withUnsafeBytes(apply)
            case .inline(let inline):
                return try inline.withUnsafeBytes(apply)
            case .slice(let slice):
                return try slice.withUnsafeBytes(apply)
            case .large(let slice):
                return try slice.withUnsafeBytes(apply)
            }
        }
    @inlinable internal mutating func withUnsafeMutableBytes<Result>(_ apply: (Swift.UnsafeMutableRawBufferPointer) throws -> Result) rethrows -> Result {
            switch self {
            case .empty:
                var empty = InlineData()
                return try empty.withUnsafeMutableBytes(apply)
            case .inline(var inline):
                defer { self = .inline(inline) }
                return try inline.withUnsafeMutableBytes(apply)
            case .slice(var slice):
                self = .empty
                defer { self = .slice(slice) }
                return try slice.withUnsafeMutableBytes(apply)
            case .large(var slice):
                self = .empty
                defer { self = .large(slice) }
                return try slice.withUnsafeMutableBytes(apply)
            }
        }
    @inlinable internal func withInteriorPointerReference<T>(_ work: (Foundation.NSData) throws -> T) rethrows -> T {
            switch self {
            case .empty:
                return try work(NSData())
            case .inline(let inline):
                return try inline.withUnsafeBytes {
                    return try work(NSData(bytesNoCopy: UnsafeMutableRawPointer(mutating: $0.baseAddress ?? UnsafeRawPointer(bitPattern: 0xBAD0)!), length: $0.count, freeWhenDone: false))
                }
            case .slice(let slice):
                return try slice.storage.withInteriorPointerReference(slice.range, work)
            case .large(let slice):
                return try slice.storage.withInteriorPointerReference(slice.range, work)
            }
        }
    @usableFromInline
    internal func enumerateBytes(_ block: (_ buffer: Swift.UnsafeBufferPointer<Swift.UInt8>, _ byteIndex: Foundation.Data.Index, _ stop: inout Swift.Bool) -> Swift.Void)
    @inlinable internal mutating func append(contentsOf buffer: Swift.UnsafeRawBufferPointer) {
            switch self {
            case .empty:
                self = _Representation(buffer)
            case .inline(var inline):
                if InlineData.canStore(count: inline.count + buffer.count) {
                    inline.append(contentsOf: buffer)
                    self = .inline(inline)
                } else if InlineSlice.canStore(count: inline.count + buffer.count) {
                    var newSlice = InlineSlice(inline)
                    newSlice.append(contentsOf: buffer)
                    self = .slice(newSlice)
                } else {
                    var newSlice = LargeSlice(inline)
                    newSlice.append(contentsOf: buffer)
                    self = .large(newSlice)
                }
            case .slice(var slice):
                if InlineSlice.canStore(count: slice.range.upperBound + buffer.count) {
                    self = .empty
                    defer { self = .slice(slice) }
                    slice.append(contentsOf: buffer)
                } else {
                    self = .empty
                    var newSlice = LargeSlice(slice)
                    newSlice.append(contentsOf: buffer)
                    self = .large(newSlice)
                }
            case .large(var slice):
                self = .empty
                defer { self = .large(slice) }
                slice.append(contentsOf: buffer)
            }
        }
    @inlinable internal mutating func resetBytes(in range: Swift.Range<Foundation.Data.Index>) {
            switch self {
            case .empty:
                if range.upperBound == 0 {
                    self = .empty
                } else if InlineData.canStore(count: range.upperBound) {
                    precondition(range.lowerBound <= endIndex, "index \(range.lowerBound) is out of bounds of \(startIndex)..<\(endIndex)")
                    self = .inline(InlineData(count: range.upperBound))
                } else if InlineSlice.canStore(count: range.upperBound) {
                    precondition(range.lowerBound <= endIndex, "index \(range.lowerBound) is out of bounds of \(startIndex)..<\(endIndex)")
                    self = .slice(InlineSlice(count: range.upperBound))
                } else {
                    precondition(range.lowerBound <= endIndex, "index \(range.lowerBound) is out of bounds of \(startIndex)..<\(endIndex)")
                    self = .large(LargeSlice(count: range.upperBound))
                }
            case .inline(var inline):
                if inline.count < range.upperBound {
                    if InlineSlice.canStore(count: range.upperBound) {
                        var slice = InlineSlice(inline)
                        slice.resetBytes(in: range)
                        self = .slice(slice)
                    } else {
                        var slice = LargeSlice(inline)
                        slice.resetBytes(in: range)
                        self = .large(slice)
                    }
                } else {
                    inline.resetBytes(in: range)
                    self = .inline(inline)
                }
            case .slice(var slice):
                if InlineSlice.canStore(count: range.upperBound) {
                    self = .empty
                    slice.resetBytes(in: range)
                    self = .slice(slice)
                } else {
                    self = .empty
                    var newSlice = LargeSlice(slice)
                    newSlice.resetBytes(in: range)
                    self = .large(newSlice)
                }
            case .large(var slice):
                self = .empty
                slice.resetBytes(in: range)
                self = .large(slice)
            }
        }
    @usableFromInline
    internal mutating func replaceSubrange(_ subrange: Swift.Range<Foundation.Data.Index>, with bytes: Swift.UnsafeRawPointer?, count cnt: Swift.Int)
    @inlinable internal subscript(index: Foundation.Data.Index) -> Swift.UInt8 {
      get {
                switch self {
                case .empty: preconditionFailure("index \(index) out of range of 0")
                case .inline(let inline): return inline[index]
                case .slice(let slice): return slice[index]
                case .large(let slice): return slice[index]
                }
            }
      set(newValue) {
                switch self {
                case .empty: preconditionFailure("index \(index) out of range of 0")
                case .inline(var inline):
                    inline[index] = newValue
                    self = .inline(inline)
                case .slice(var slice):
                    self = .empty
                    slice[index] = newValue
                    self = .slice(slice)
                case .large(var slice):
                    self = .empty
                    slice[index] = newValue
                    self = .large(slice)
                }
            }
    }
    @inlinable internal subscript(bounds: Swift.Range<Foundation.Data.Index>) -> Foundation.Data {
      get {
                switch self {
                case .empty:
                    precondition(bounds.lowerBound == 0 && (bounds.upperBound - bounds.lowerBound) == 0, "Range \(bounds) out of bounds 0..<0")
                    return Data()
                case .inline(let inline):
                    precondition(bounds.upperBound <= inline.count, "Range \(bounds) out of bounds 0..<\(inline.count)")
                    if bounds.lowerBound == 0 {
                        var newInline = inline
                        newInline.count = bounds.upperBound
                        return Data(representation: .inline(newInline))
                    } else {
                        return Data(representation: .slice(InlineSlice(inline, range: bounds)))
                    }
                case .slice(let slice):
                    precondition(slice.startIndex <= bounds.lowerBound, "Range \(bounds) out of bounds \(slice.range)")
                    precondition(bounds.lowerBound <= slice.endIndex, "Range \(bounds) out of bounds \(slice.range)")
                    precondition(slice.startIndex <= bounds.upperBound, "Range \(bounds) out of bounds \(slice.range)")
                    precondition(bounds.upperBound <= slice.endIndex, "Range \(bounds) out of bounds \(slice.range)")
                    if bounds.lowerBound == 0 && bounds.upperBound == 0 {
                        return Data()
                    } else if bounds.lowerBound == 0 && InlineData.canStore(count: bounds.count) {
                        return Data(representation: .inline(InlineData(slice, count: bounds.count)))
                    } else {
                        var newSlice = slice
                        newSlice.range = bounds
                        return Data(representation: .slice(newSlice))
                    }
                case .large(let slice):
                    precondition(slice.startIndex <= bounds.lowerBound, "Range \(bounds) out of bounds \(slice.range)")
                    precondition(bounds.lowerBound <= slice.endIndex, "Range \(bounds) out of bounds \(slice.range)")
                    precondition(slice.startIndex <= bounds.upperBound, "Range \(bounds) out of bounds \(slice.range)")
                    precondition(bounds.upperBound <= slice.endIndex, "Range \(bounds) out of bounds \(slice.range)")
                    if bounds.lowerBound == 0 && bounds.upperBound == 0 {
                        return Data()
                    } else if bounds.lowerBound == 0 && InlineData.canStore(count: bounds.upperBound) {
                        return Data(representation: .inline(InlineData(slice, count: bounds.upperBound)))
                    } else if InlineSlice.canStore(count: bounds.lowerBound) && InlineSlice.canStore(count: bounds.upperBound) {
                        return Data(representation: .slice(InlineSlice(slice, range: bounds)))
                    } else {
                        var newSlice = slice
                        newSlice.slice = RangeReference(bounds)
                        return Data(representation: .large(newSlice))
                    }
                }
            }
    }
    @inlinable internal var startIndex: Swift.Int {
      get {
            switch self {
            case .empty: return 0
            case .inline: return 0
            case .slice(let slice): return slice.startIndex
            case .large(let slice): return slice.startIndex
            }
        }
    }
    @inlinable internal var endIndex: Swift.Int {
      get {
            switch self {
            case .empty: return 0
            case .inline(let inline): return inline.count
            case .slice(let slice): return slice.endIndex
            case .large(let slice): return slice.endIndex
            }
        }
    }
    @inlinable internal func bridgedReference() -> Foundation.NSData {
            switch self {
            case .empty: return NSData()
            case .inline(let inline):
                return inline.withUnsafeBytes {
                    return NSData(bytes: $0.baseAddress, length: $0.count)
                }
            case .slice(let slice):
                return slice.bridgedReference()
            case .large(let slice):
                return slice.bridgedReference()
            }
        }
    @inlinable internal func copyBytes(to pointer: Swift.UnsafeMutableRawPointer, from range: Swift.Range<Swift.Int>) {
            switch self {
            case .empty:
                precondition(range.lowerBound == 0 && range.upperBound == 0, "Range \(range) out of bounds 0..<0")
                return
            case .inline(let inline):
                inline.copyBytes(to: pointer, from: range)
            case .slice(let slice):
                slice.copyBytes(to: pointer, from: range)
            case .large(let slice):
                slice.copyBytes(to: pointer, from: range)
            }
        }
  }
  @usableFromInline
  internal var _representation: Foundation.Data._Representation
  public enum Deallocator {
    case virtualMemory
    case unmap
    case free
    case none
    case custom((Swift.UnsafeMutableRawPointer, Swift.Int) -> Swift.Void)
    @usableFromInline
    internal var _deallocator: ((Swift.UnsafeMutableRawPointer, Swift.Int) -> Swift.Void) {
      get
    }
  }
  @inlinable public init(bytes: Swift.UnsafeRawPointer, count: Swift.Int) {
        _representation = _Representation(UnsafeRawBufferPointer(start: bytes, count: count))
    }
  @inlinable public init<SourceType>(buffer: Swift.UnsafeBufferPointer<SourceType>) {
        _representation = _Representation(UnsafeRawBufferPointer(buffer))
    }
  @inlinable public init<SourceType>(buffer: Swift.UnsafeMutableBufferPointer<SourceType>) {
        _representation = _Representation(UnsafeRawBufferPointer(buffer))
    }
  @inlinable public init(repeating repeatedValue: Swift.UInt8, count: Swift.Int) {
        self.init(count: count)
        withUnsafeMutableBytes { (buffer: UnsafeMutableRawBufferPointer) -> Void in
            memset(buffer.baseAddress, Int32(repeatedValue), buffer.count)
        }
    }
  @inlinable public init(capacity: Swift.Int) {
        _representation = _Representation(capacity: capacity)
    }
  @inlinable public init(count: Swift.Int) {
        _representation = _Representation(count: count)
    }
  @inlinable public init() {
        _representation = .empty
    }
  @inlinable public init(bytesNoCopy bytes: Swift.UnsafeMutableRawPointer, count: Swift.Int, deallocator: Foundation.Data.Deallocator) {
        let whichDeallocator = deallocator._deallocator
        if count == 0 {
            deallocator._deallocator(bytes, count)
            _representation = .empty
        } else {
            _representation = _Representation(__DataStorage(bytes: bytes, length: count, copy: false, deallocator: whichDeallocator, offset: 0), count: count)
        }
    }
  @inlinable public init(contentsOf url: __shared Foundation.URL, options: Foundation.Data.ReadingOptions = []) throws {
        let d = try NSData(contentsOf: url, options: ReadingOptions(rawValue: options.rawValue))
        self.init(referencing: d)
    }
  @inlinable public init?(base64Encoded base64String: __shared Swift.String, options: Foundation.Data.Base64DecodingOptions = []) {
        if let d = NSData(base64Encoded: base64String, options: Base64DecodingOptions(rawValue: options.rawValue)) {
            self.init(referencing: d)
        } else {
            return nil
        }
    }
  @inlinable public init?(base64Encoded base64Data: __shared Foundation.Data, options: Foundation.Data.Base64DecodingOptions = []) {
        if let d = NSData(base64Encoded: base64Data, options: Base64DecodingOptions(rawValue: options.rawValue)) {
            self.init(referencing: d)
        } else {
            return nil
        }
    }
  public init(referencing reference: __shared Foundation.NSData)
  @inlinable public init<S>(_ elements: S) where S : Swift.Sequence, S.Element == Swift.UInt8 {
        // If the sequence is already contiguous, access the underlying raw memory directly.
        if let contiguous = elements as? ContiguousBytes {
            _representation = contiguous.withUnsafeBytes { return _Representation($0) }
            return
        }

        // The sequence might still be able to provide direct access to typed memory.
        // NOTE: It's safe to do this because we're already guarding on S's element as `UInt8`. This would not be safe on arbitrary sequences.
        let representation = elements.withContiguousStorageIfAvailable {
            _Representation(UnsafeRawBufferPointer($0))
        }
        if let representation = representation {
            _representation = representation
            return
        }

        // Copy as much as we can in one shot from the sequence.
        let underestimatedCount = elements.underestimatedCount
        _representation = _Representation(count: underestimatedCount)
        var (iter, endIndex): (S.Iterator, Int) = _representation.withUnsafeMutableBytes { buffer in
            let start = buffer.baseAddress!.assumingMemoryBound(to: UInt8.self)
            let b = UnsafeMutableBufferPointer(start: start, count: buffer.count)
            return elements._copyContents(initializing: b)
        }
        guard endIndex == _representation.count else {
            // We can't trap here. We have to allow an underfilled buffer
            // to emulate the previous implementation.
            _representation.replaceSubrange(endIndex ..< _representation.endIndex, with: nil, count: 0)
            return
        }

        // Append the rest byte-wise, buffering through an InlineData.
        var buffer = InlineData()
        while let element = iter.next() {
            buffer.append(byte: element)
            if buffer.count == buffer.capacity {
                buffer.withUnsafeBytes { _representation.append(contentsOf: $0) }
                buffer.count = 0
            }
        }

        // If we've still got bytes left in the buffer (i.e. the loop ended before we filled up the buffer and cleared it out), append them.
        if buffer.count > 0 {
            buffer.withUnsafeBytes { _representation.append(contentsOf: $0) }
            buffer.count = 0
        }
    }
  @available(swift 4.2)
  @available(swift, deprecated: 5, message: "use `init(_:)` instead")
  public init<S>(bytes elements: S) where S : Swift.Sequence, S.Element == Swift.UInt8
  @available(swift, obsoleted: 4.2)
  public init(bytes: Swift.Array<Swift.UInt8>)
  @available(swift, obsoleted: 4.2)
  public init(bytes: Swift.ArraySlice<Swift.UInt8>)
  @inlinable internal init(representation: Foundation.Data._Representation) {
        _representation = representation
    }
  @inlinable public mutating func reserveCapacity(_ minimumCapacity: Swift.Int) {
        _representation.reserveCapacity(minimumCapacity)
    }
  @inlinable public var count: Swift.Int {
    get {
            return _representation.count
        }
    set(newValue) {
            precondition(newValue >= 0, "count must not be negative")
            _representation.count = newValue
        }
  }
  @inlinable public var regions: Swift.CollectionOfOne<Foundation.Data> {
    get {
        return CollectionOfOne(self)
    }
  }
  @available(swift, deprecated: 5, message: "use `withUnsafeBytes<R>(_: (UnsafeRawBufferPointer) throws -> R) rethrows -> R` instead")
  public func withUnsafeBytes<ResultType, ContentType>(_ body: (Swift.UnsafePointer<ContentType>) throws -> ResultType) rethrows -> ResultType
  @inlinable public func withUnsafeBytes<ResultType>(_ body: (Swift.UnsafeRawBufferPointer) throws -> ResultType) rethrows -> ResultType {
        return try _representation.withUnsafeBytes(body)
    }
  @available(swift, deprecated: 5, message: "use `withUnsafeMutableBytes<R>(_: (UnsafeMutableRawBufferPointer) throws -> R) rethrows -> R` instead")
  public mutating func withUnsafeMutableBytes<ResultType, ContentType>(_ body: (Swift.UnsafeMutablePointer<ContentType>) throws -> ResultType) rethrows -> ResultType
  @inlinable public mutating func withUnsafeMutableBytes<ResultType>(_ body: (Swift.UnsafeMutableRawBufferPointer) throws -> ResultType) rethrows -> ResultType {
        return try _representation.withUnsafeMutableBytes(body)
    }
  @inlinable public func copyBytes(to pointer: Swift.UnsafeMutablePointer<Swift.UInt8>, count: Swift.Int) {
        precondition(count >= 0, "count of bytes to copy must not be negative")
        if count == 0 { return }
        _copyBytesHelper(to: UnsafeMutableRawPointer(pointer), from: startIndex..<(startIndex + count))
    }
  @inlinable internal func _copyBytesHelper(to pointer: Swift.UnsafeMutableRawPointer, from range: Swift.Range<Swift.Int>) {
        if range.isEmpty { return }
        _representation.copyBytes(to: pointer, from: range)
    }
  @inlinable public func copyBytes(to pointer: Swift.UnsafeMutablePointer<Swift.UInt8>, from range: Swift.Range<Foundation.Data.Index>) {
        _copyBytesHelper(to: pointer, from: range)
    }
  @inlinable public func copyBytes<DestinationType>(to buffer: Swift.UnsafeMutableBufferPointer<DestinationType>, from range: Swift.Range<Foundation.Data.Index>? = nil) -> Swift.Int {
        let cnt = count
        guard cnt > 0 else { return 0 }
        
        let copyRange : Range<Index>
        if let r = range {
            guard !r.isEmpty else { return 0 }
            copyRange = r.lowerBound..<(r.lowerBound + Swift.min(buffer.count * MemoryLayout<DestinationType>.stride, r.upperBound - r.lowerBound))
        } else {
            copyRange = 0..<Swift.min(buffer.count * MemoryLayout<DestinationType>.stride, cnt)
        }
        
        guard !copyRange.isEmpty else { return 0 }
        
        _copyBytesHelper(to: buffer.baseAddress!, from: copyRange)
        return copyRange.upperBound - copyRange.lowerBound
    }
  public func write(to url: Foundation.URL, options: Foundation.Data.WritingOptions = []) throws
  public func range(of dataToFind: Foundation.Data, options: Foundation.Data.SearchOptions = [], in range: Swift.Range<Foundation.Data.Index>? = nil) -> Swift.Range<Foundation.Data.Index>?
  @available(swift, deprecated: 5, message: "use `regions` or `for-in` instead")
  public func enumerateBytes(_ block: (_ buffer: Swift.UnsafeBufferPointer<Swift.UInt8>, _ byteIndex: Foundation.Data.Index, _ stop: inout Swift.Bool) -> Swift.Void)
  @inlinable internal mutating func _append<SourceType>(_ buffer: Swift.UnsafeBufferPointer<SourceType>) {
        if buffer.isEmpty { return }
        _representation.append(contentsOf: UnsafeRawBufferPointer(buffer))
    }
  @inlinable public mutating func append(_ bytes: Swift.UnsafePointer<Swift.UInt8>, count: Swift.Int) {
        if count == 0 { return }
        _append(UnsafeBufferPointer(start: bytes, count: count))
    }
  public mutating func append(_ other: Foundation.Data)
  @inlinable public mutating func append<SourceType>(_ buffer: Swift.UnsafeBufferPointer<SourceType>) {
        _append(buffer)
    }
  @inlinable public mutating func append(contentsOf bytes: [Swift.UInt8]) {
        bytes.withUnsafeBufferPointer { (buffer: UnsafeBufferPointer<UInt8>) -> Void in
            _append(buffer)
        }
    }
  @inlinable public mutating func append<S>(contentsOf elements: S) where S : Swift.Sequence, S.Element == Foundation.Data.Element {
        // If the sequence is already contiguous, access the underlying raw memory directly.
        if let contiguous = elements as? ContiguousBytes {
            contiguous.withUnsafeBytes {
                _representation.append(contentsOf: $0)
            }

            return
        }

        // The sequence might still be able to provide direct access to typed memory.
        // NOTE: It's safe to do this because we're already guarding on S's element as `UInt8`. This would not be safe on arbitrary sequences.
        let appended: Void? = elements.withContiguousStorageIfAvailable {
            _representation.append(contentsOf: UnsafeRawBufferPointer($0))
        }
        guard appended == nil else { return }

        // The sequence is really not contiguous.
        // Copy as much as we can in one shot.
        let underestimatedCount = elements.underestimatedCount
        let originalCount = _representation.count
        resetBytes(in: self.endIndex ..< self.endIndex + underestimatedCount)
        var (iter, copiedCount): (S.Iterator, Int) = _representation.withUnsafeMutableBytes { buffer in
            assert(buffer.count == originalCount + underestimatedCount)
            let start = buffer.baseAddress!.assumingMemoryBound(to: UInt8.self) + originalCount
            let b = UnsafeMutableBufferPointer(start: start, count: buffer.count - originalCount)
            return elements._copyContents(initializing: b)
        }
        guard copiedCount == underestimatedCount else {
            // We can't trap here. We have to allow an underfilled buffer
            // to emulate the previous implementation.
            _representation.replaceSubrange(startIndex + originalCount + copiedCount ..< endIndex, with: nil, count: 0)
            return
        }

        // Append the rest byte-wise, buffering through an InlineData.
        var buffer = InlineData()
        while let element = iter.next() {
            buffer.append(byte: element)
            if buffer.count == buffer.capacity {
                buffer.withUnsafeBytes { _representation.append(contentsOf: $0) }
                buffer.count = 0
            }
        }

        // If we've still got bytes left in the buffer (i.e. the loop ended before we filled up the buffer and cleared it out), append them.
        if buffer.count > 0 {
            buffer.withUnsafeBytes { _representation.append(contentsOf: $0) }
            buffer.count = 0
        }
    }
  @inlinable public mutating func resetBytes(in range: Swift.Range<Foundation.Data.Index>) {
        // it is worth noting that the range here may be out of bounds of the Data itself (which triggers a growth)
        precondition(range.lowerBound >= 0, "Ranges must not be negative bounds")
        precondition(range.upperBound >= 0, "Ranges must not be negative bounds")
        _representation.resetBytes(in: range)
    }
  @inlinable public mutating func replaceSubrange(_ subrange: Swift.Range<Foundation.Data.Index>, with data: Foundation.Data) {
        data.withUnsafeBytes { (buffer: UnsafeRawBufferPointer) in
            _representation.replaceSubrange(subrange, with: buffer.baseAddress, count: buffer.count)
        }
    }
  @inlinable public mutating func replaceSubrange<SourceType>(_ subrange: Swift.Range<Foundation.Data.Index>, with buffer: Swift.UnsafeBufferPointer<SourceType>) {
        guard !buffer.isEmpty  else { return }
        replaceSubrange(subrange, with: buffer.baseAddress!, count: buffer.count * MemoryLayout<SourceType>.stride)
    }
  @inlinable public mutating func replaceSubrange<ByteCollection>(_ subrange: Swift.Range<Foundation.Data.Index>, with newElements: ByteCollection) where ByteCollection : Swift.Collection, ByteCollection.Element == Foundation.Data.Iterator.Element {
        // If the collection is already contiguous, access the underlying raw memory directly.
        if let contiguous = newElements as? ContiguousBytes {
            contiguous.withUnsafeBytes { buffer in
                _representation.replaceSubrange(subrange, with: buffer.baseAddress, count: buffer.count)
            }
            return
        }
        // The collection might still be able to provide direct access to typed memory.
        // NOTE: It's safe to do this because we're already guarding on ByteCollection's element as `UInt8`. This would not be safe on arbitrary collections.
        let replaced: Void? = newElements.withContiguousStorageIfAvailable { buffer in
            _representation.replaceSubrange(subrange, with: buffer.baseAddress, count: buffer.count)
        }
        guard replaced == nil else { return }

        let totalCount = Int(newElements.count)
        _withStackOrHeapBuffer(capacity: totalCount) { buffer in
            var (iterator, index) = newElements._copyContents(initializing: buffer)
            precondition(index == buffer.endIndex, "Collection has less elements than its count")
            precondition(iterator.next() == nil, "Collection has more elements than its count")
            _representation.replaceSubrange(subrange, with: buffer.baseAddress, count: totalCount)
        }
    }
  @inlinable public mutating func replaceSubrange(_ subrange: Swift.Range<Foundation.Data.Index>, with bytes: Swift.UnsafeRawPointer, count cnt: Swift.Int) {
        _representation.replaceSubrange(subrange, with: bytes, count: cnt)
    }
  public func subdata(in range: Swift.Range<Foundation.Data.Index>) -> Foundation.Data
  @inlinable public func base64EncodedString(options: Foundation.Data.Base64EncodingOptions = []) -> Swift.String {
        return _representation.withInteriorPointerReference {
            return $0.base64EncodedString(options: options)
        }
    }
  @inlinable public func base64EncodedData(options: Foundation.Data.Base64EncodingOptions = []) -> Foundation.Data {
        return _representation.withInteriorPointerReference {
            return $0.base64EncodedData(options: options)
        }
    }
  @inline(never) public func hash(into hasher: inout Swift.Hasher)
  public func advanced(by amount: Swift.Int) -> Foundation.Data
  @inlinable public subscript(index: Foundation.Data.Index) -> Swift.UInt8 {
    get {
            return _representation[index]
        }
    set(newValue) {
            _representation[index] = newValue
        }
  }
  @inlinable public subscript(bounds: Swift.Range<Foundation.Data.Index>) -> Foundation.Data {
    get {
            return _representation[bounds]
        }
    set {
            replaceSubrange(bounds, with: newValue)
        }
  }
  @inlinable public subscript<R>(rangeExpression: R) -> Foundation.Data where R : Swift.RangeExpression, R.Bound : Swift.FixedWidthInteger {
    get {
            let lower = R.Bound(startIndex)
            let upper = R.Bound(endIndex)
            let range = rangeExpression.relative(to: lower..<upper)
            let start = Int(range.lowerBound)
            let end = Int(range.upperBound)
            let r: Range<Int> = start..<end
            return _representation[r]
        }
    set {
            let lower = R.Bound(startIndex)
            let upper = R.Bound(endIndex)
            let range = rangeExpression.relative(to: lower..<upper)
            let start = Int(range.lowerBound)
            let end = Int(range.upperBound)
            let r: Range<Int> = start..<end
            replaceSubrange(r, with: newValue)
        }
  }
  @inlinable public var startIndex: Foundation.Data.Index {
    get {
            return _representation.startIndex
        }
  }
  @inlinable public var endIndex: Foundation.Data.Index {
    get {
            return _representation.endIndex
        }
  }
  @inlinable public func index(before i: Foundation.Data.Index) -> Foundation.Data.Index {
        return i - 1
    }
  @inlinable public func index(after i: Foundation.Data.Index) -> Foundation.Data.Index {
        return i + 1
    }
  @inlinable public var indices: Swift.Range<Swift.Int> {
    get {
            return startIndex..<endIndex
        }
  }
  @inlinable public func _copyContents(initializing buffer: Swift.UnsafeMutableBufferPointer<Swift.UInt8>) -> (Foundation.Data.Iterator, Swift.UnsafeMutableBufferPointer<Swift.UInt8>.Index) {
        guard !isEmpty else { return (makeIterator(), buffer.startIndex) }
        let cnt = Swift.min(count, buffer.count)
        
        withUnsafeBytes { (bytes: UnsafeRawBufferPointer) in
            _ = memcpy(UnsafeMutableRawPointer(buffer.baseAddress), bytes.baseAddress, cnt)
        }
        
        return (Iterator(self, at: startIndex + cnt), buffer.index(buffer.startIndex, offsetBy: cnt))
    }
  @inlinable public func makeIterator() -> Foundation.Data.Iterator {
        return Iterator(self, at: startIndex)
    }
  public struct Iterator : Swift.IteratorProtocol {
    @usableFromInline
    internal typealias Buffer = (Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8)
    @usableFromInline
    internal let _data: Foundation.Data
    @usableFromInline
    internal var _buffer: Foundation.Data.Iterator.Buffer
    @usableFromInline
    internal var _idx: Foundation.Data.Index
    @usableFromInline
    internal let _endIdx: Foundation.Data.Index
    @usableFromInline
    internal init(_ data: Foundation.Data, at loc: Foundation.Data.Index)
    public mutating func next() -> Swift.UInt8?
    public typealias Element = Swift.UInt8
  }
  @available(*, unavailable, renamed: "count")
  public var length: Swift.Int {
    get
    set
  }
  @available(*, unavailable, message: "use withUnsafeBytes instead")
  public var bytes: Swift.UnsafeRawPointer {
    get
  }
  @available(*, unavailable, message: "use withUnsafeMutableBytes instead")
  public var mutableBytes: Swift.UnsafeMutableRawPointer {
    get
  }
  @inlinable public static func == (d1: Foundation.Data, d2: Foundation.Data) -> Swift.Bool {
        let length1 = d1.count
        if length1 != d2.count {
            return false
        }
        if length1 > 0 {
            return d1.withUnsafeBytes { (b1: UnsafeRawBufferPointer) in
                return d2.withUnsafeBytes { (b2: UnsafeRawBufferPointer) in
                    return memcmp(b1.baseAddress!, b2.baseAddress!, b2.count) == 0
                }
            }
        }
        return true
    }
  public typealias Element = Swift.UInt8
  public typealias Regions = Swift.CollectionOfOne<Foundation.Data>
  public typealias SubSequence = Foundation.Data
  public var hashValue: Swift.Int {
    get
  }
}
extension Foundation.Data : Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible, Swift.CustomReflectable {
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
  public var customMirror: Swift.Mirror {
    get
  }
}
extension Foundation.Data {
  @available(*, unavailable, renamed: "copyBytes(to:count:)")
  public func getBytes<UnsafeMutablePointerVoid>(_ buffer: UnsafeMutablePointerVoid, length: Swift.Int) where UnsafeMutablePointerVoid : Swift._Pointer
  @available(*, unavailable, renamed: "copyBytes(to:from:)")
  public func getBytes<UnsafeMutablePointerVoid>(_ buffer: UnsafeMutablePointerVoid, range: Foundation.NSRange) where UnsafeMutablePointerVoid : Swift._Pointer
}
extension Foundation.Data : Swift._ObjectiveCBridgeable {
  @_semantics("convertToObjectiveC") public func _bridgeToObjectiveC() -> Foundation.NSData
  public static func _forceBridgeFromObjectiveC(_ input: Foundation.NSData, result: inout Foundation.Data?)
  public static func _conditionallyBridgeFromObjectiveC(_ input: Foundation.NSData, result: inout Foundation.Data?) -> Swift.Bool
  public static func _unconditionallyBridgeFromObjectiveC(_ source: Foundation.NSData?) -> Foundation.Data
  public typealias _ObjectiveCType = Foundation.NSData
}
extension Foundation.NSData : Swift._HasCustomAnyHashableRepresentation {
  @nonobjc public func _toCustomAnyHashable() -> Swift.AnyHashable?
}
extension Foundation.Data : Swift.Codable {
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
public typealias Published = Combine.Published
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
public typealias ObservableObject = Combine.ObservableObject
extension Foundation.NSPredicate {
  convenience public init(format predicateFormat: __shared Swift.String, _ args: Swift.CVarArg...)
}
extension Foundation.NSSortDescriptor {
  convenience public init<Root, Value>(keyPath: Swift.KeyPath<Root, Value>, ascending: Swift.Bool)
  convenience public init<Root, Value>(keyPath: Swift.KeyPath<Root, Value>, ascending: Swift.Bool, comparator cmptr: @escaping Foundation.Comparator)
  public var keyPath: Swift.AnyKeyPath? {
    get
  }
}
extension Foundation.FileHandle {
  @available(macOS 10.15.4, iOS 13.4, watchOS 6.2, tvOS 13.4, *)
  public func readToEnd() throws -> Foundation.Data?
  @available(macOS 10.15.4, iOS 13.4, watchOS 6.2, tvOS 13.4, *)
  public func read(upToCount count: Swift.Int) throws -> Foundation.Data?
  @available(macOS 10.15.4, iOS 13.4, watchOS 6.2, tvOS 13.4, *)
  public func offset() throws -> Swift.UInt64
  @available(macOS 10.15.4, iOS 13.4, watchOS 6.2, tvOS 13.4, *)
  @discardableResult
  public func seekToEnd() throws -> Swift.UInt64
  @available(macOS 10.15.4, iOS 13.4, watchOS 6.2, tvOS 13.4, *)
  @_specialize(exported: false, kind: full, where T == Foundation.Data)
  @_specialize(exported: false, kind: full, where T == Dispatch.DispatchData)
  public func write<T>(contentsOf data: T) throws where T : Foundation.DataProtocol
}
extension Swift.EncodingError : Foundation.LocalizedError {
}
extension Swift.DecodingError : Foundation.LocalizedError {
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Foundation.JSONEncoder : Combine.TopLevelEncoder {
  public typealias Output = Foundation.Data
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Foundation.PropertyListEncoder : Combine.TopLevelEncoder {
  public typealias Output = Foundation.Data
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Foundation.JSONDecoder : Combine.TopLevelDecoder {
  public typealias Input = Foundation.Data
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Foundation.PropertyListDecoder : Combine.TopLevelDecoder {
  public typealias Input = Foundation.Data
}
extension Foundation._NSRange : Swift.Hashable {
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (lhs: Foundation.NSRange, rhs: Foundation.NSRange) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
extension Foundation._NSRange : Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible {
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
}
extension Foundation._NSRange {
  public init?(_ string: __shared Swift.String)
}
extension Foundation._NSRange {
  public var lowerBound: Swift.Int {
    get
  }
  public var upperBound: Swift.Int {
    get
  }
  public func contains(_ index: Swift.Int) -> Swift.Bool
  public mutating func formUnion(_ other: Foundation.NSRange)
  public func union(_ other: Foundation.NSRange) -> Foundation.NSRange
  public func intersection(_ other: Foundation.NSRange) -> Foundation.NSRange?
}
extension Foundation._NSRange {
  public init<R>(_ region: R) where R : Swift.RangeExpression, R.Bound : Swift.FixedWidthInteger
  public init<R, S>(_ region: R, in target: S) where R : Swift.RangeExpression, S : Swift.StringProtocol, R.Bound == Swift.String.Index
  @available(swift, deprecated: 4, message: "Use Range.init(_:) instead")
  public func toRange() -> Swift.Range<Swift.Int>?
}
extension Swift.Range where Bound : Swift.BinaryInteger {
  public init?(_ range: Foundation.NSRange)
}
extension Swift.Range where Bound == Swift.Int {
  public init?(_ range: Foundation.NSRange)
}
extension Swift.Range where Bound == Swift.String.Index {
  public init?(_ range: Foundation.NSRange, in string: __shared Swift.String)
  @available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
  public init?<S>(_ range: Foundation.NSRange, in string: __shared S) where S : Swift.StringProtocol
}
extension Foundation._NSRange : Swift.CustomReflectable {
  public var customMirror: Swift.Mirror {
    get
  }
}
extension Foundation._NSRange : Swift._CustomPlaygroundQuickLookable {
  @available(*, deprecated, message: "NSRange.customPlaygroundQuickLook will be removed in a future Swift version")
  public var customPlaygroundQuickLook: Swift.PlaygroundQuickLook {
    get
  }
}
extension Foundation._NSRange : Swift.Codable {
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.Decimal {
  public struct FormatStyle : Foundation.FormatStyle {
    public var locale: Foundation.Locale
    public init(locale: Foundation.Locale = .autoupdatingCurrent)
    public var attributed: Foundation.Decimal.FormatStyle.Attributed {
      get
    }
    public typealias Configuration = Foundation.NumberFormatStyleConfiguration
    public func grouping(_ group: Foundation.Decimal.FormatStyle.Configuration.Grouping) -> Foundation.Decimal.FormatStyle
    public func precision(_ p: Foundation.Decimal.FormatStyle.Configuration.Precision) -> Foundation.Decimal.FormatStyle
    public func sign(strategy: Foundation.Decimal.FormatStyle.Configuration.SignDisplayStrategy) -> Foundation.Decimal.FormatStyle
    public func decimalSeparator(strategy: Foundation.Decimal.FormatStyle.Configuration.DecimalSeparatorDisplayStrategy) -> Foundation.Decimal.FormatStyle
    public func rounded(rule: Foundation.Decimal.FormatStyle.Configuration.RoundingRule = .toNearestOrEven, increment: Swift.Int? = nil) -> Foundation.Decimal.FormatStyle
    public func scale(_ multiplicand: Swift.Double) -> Foundation.Decimal.FormatStyle
    public func notation(_ notation: Foundation.Decimal.FormatStyle.Configuration.Notation) -> Foundation.Decimal.FormatStyle
    public func format(_ value: Foundation.Decimal) -> Swift.String
    public func locale(_ locale: Foundation.Locale) -> Foundation.Decimal.FormatStyle
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: Foundation.Decimal.FormatStyle, b: Foundation.Decimal.FormatStyle) -> Swift.Bool
    public typealias FormatInput = Foundation.Decimal
    public typealias FormatOutput = Swift.String
    public func encode(to encoder: Swift.Encoder) throws
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: Swift.Decoder) throws
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.Decimal.FormatStyle {
  public struct Percent : Foundation.FormatStyle {
    public var locale: Foundation.Locale
    public init(locale: Foundation.Locale = .autoupdatingCurrent)
    public var attributed: Foundation.Decimal.FormatStyle.Attributed {
      get
    }
    public typealias Configuration = Foundation.NumberFormatStyleConfiguration
    public func grouping(_ group: Foundation.Decimal.FormatStyle.Percent.Configuration.Grouping) -> Foundation.Decimal.FormatStyle.Percent
    public func precision(_ p: Foundation.Decimal.FormatStyle.Percent.Configuration.Precision) -> Foundation.Decimal.FormatStyle.Percent
    public func sign(strategy: Foundation.Decimal.FormatStyle.Percent.Configuration.SignDisplayStrategy) -> Foundation.Decimal.FormatStyle.Percent
    public func decimalSeparator(strategy: Foundation.Decimal.FormatStyle.Percent.Configuration.DecimalSeparatorDisplayStrategy) -> Foundation.Decimal.FormatStyle.Percent
    public func rounded(rule: Foundation.Decimal.FormatStyle.Percent.Configuration.RoundingRule = .toNearestOrEven, increment: Swift.Int? = nil) -> Foundation.Decimal.FormatStyle.Percent
    public func scale(_ multiplicand: Swift.Double) -> Foundation.Decimal.FormatStyle.Percent
    public func notation(_ notation: Foundation.Decimal.FormatStyle.Percent.Configuration.Notation) -> Foundation.Decimal.FormatStyle.Percent
    public func format(_ value: Foundation.Decimal) -> Swift.String
    public func locale(_ locale: Foundation.Locale) -> Foundation.Decimal.FormatStyle.Percent
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: Foundation.Decimal.FormatStyle.Percent, b: Foundation.Decimal.FormatStyle.Percent) -> Swift.Bool
    public typealias FormatInput = Foundation.Decimal
    public typealias FormatOutput = Swift.String
    public func encode(to encoder: Swift.Encoder) throws
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: Swift.Decoder) throws
  }
  @available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
  public struct Currency : Foundation.FormatStyle {
    public typealias Configuration = Foundation.CurrencyFormatStyleConfiguration
    public var locale: Foundation.Locale
    public var currencyCode: Swift.String
    public init(code: Swift.String, locale: Foundation.Locale = .autoupdatingCurrent)
    public var attributed: Foundation.Decimal.FormatStyle.Attributed {
      get
    }
    public func grouping(_ group: Foundation.Decimal.FormatStyle.Currency.Configuration.Grouping) -> Foundation.Decimal.FormatStyle.Currency
    public func precision(_ p: Foundation.Decimal.FormatStyle.Currency.Configuration.Precision) -> Foundation.Decimal.FormatStyle.Currency
    public func sign(strategy: Foundation.Decimal.FormatStyle.Currency.Configuration.SignDisplayStrategy) -> Foundation.Decimal.FormatStyle.Currency
    public func decimalSeparator(strategy: Foundation.Decimal.FormatStyle.Currency.Configuration.DecimalSeparatorDisplayStrategy) -> Foundation.Decimal.FormatStyle.Currency
    public func rounded(rule: Foundation.Decimal.FormatStyle.Currency.Configuration.RoundingRule = .toNearestOrEven, increment: Swift.Int? = nil) -> Foundation.Decimal.FormatStyle.Currency
    public func scale(_ multiplicand: Swift.Double) -> Foundation.Decimal.FormatStyle.Currency
    public func presentation(_ p: Foundation.Decimal.FormatStyle.Currency.Configuration.Presentation) -> Foundation.Decimal.FormatStyle.Currency
    public func format(_ value: Foundation.Decimal) -> Swift.String
    public func locale(_ locale: Foundation.Locale) -> Foundation.Decimal.FormatStyle.Currency
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: Foundation.Decimal.FormatStyle.Currency, b: Foundation.Decimal.FormatStyle.Currency) -> Swift.Bool
    public typealias FormatInput = Foundation.Decimal
    public typealias FormatOutput = Swift.String
    public func encode(to encoder: Swift.Encoder) throws
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: Swift.Decoder) throws
  }
  public struct Attributed : Foundation.FormatStyle {
    public func format(_ value: Foundation.Decimal) -> Foundation.AttributedString
    public func locale(_ locale: Foundation.Locale) -> Foundation.Decimal.FormatStyle.Attributed
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: Foundation.Decimal.FormatStyle.Attributed, b: Foundation.Decimal.FormatStyle.Attributed) -> Swift.Bool
    public typealias FormatInput = Foundation.Decimal
    public typealias FormatOutput = Foundation.AttributedString
    public func encode(to encoder: Swift.Encoder) throws
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: Swift.Decoder) throws
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.Decimal.FormatStyle : Foundation.ParseableFormatStyle {
  public var parseStrategy: Foundation.Decimal.ParseStrategy<Foundation.Decimal.FormatStyle> {
    get
  }
  public typealias Strategy = Foundation.Decimal.ParseStrategy<Foundation.Decimal.FormatStyle>
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.Decimal.FormatStyle.Currency : Foundation.ParseableFormatStyle {
  public var parseStrategy: Foundation.Decimal.ParseStrategy<Foundation.Decimal.FormatStyle.Currency> {
    get
  }
  public typealias Strategy = Foundation.Decimal.ParseStrategy<Foundation.Decimal.FormatStyle.Currency>
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.Decimal.FormatStyle.Percent : Foundation.ParseableFormatStyle {
  public var parseStrategy: Foundation.Decimal.ParseStrategy<Foundation.Decimal.FormatStyle.Percent> {
    get
  }
  public typealias Strategy = Foundation.Decimal.ParseStrategy<Foundation.Decimal.FormatStyle.Percent>
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.FormatStyle where Self == Foundation.Decimal.FormatStyle {
  public static var number: Foundation.Decimal.FormatStyle {
    get
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.FormatStyle where Self == Foundation.Decimal.FormatStyle.Percent {
  public static var percent: Foundation.Decimal.FormatStyle.Percent {
    get
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.FormatStyle where Self == Foundation.Decimal.FormatStyle.Currency {
  public static func currency(code: Swift.String) -> Self
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.ParseableFormatStyle where Self == Foundation.Decimal.FormatStyle {
  public static var number: Foundation.Decimal.FormatStyle {
    get
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.ParseableFormatStyle where Self == Foundation.Decimal.FormatStyle.Percent {
  public static var percent: Foundation.Decimal.FormatStyle.Percent {
    get
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.ParseableFormatStyle where Self == Foundation.Decimal.FormatStyle.Currency {
  public static func currency(code: Swift.String) -> Self
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.Decimal {
  public func formatted() -> Swift.String
  public func formatted<S>(_ format: S) -> S.FormatOutput where S : Foundation.FormatStyle, S.FormatInput == Foundation.Decimal
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Foundation.OperationQueue : Combine.Scheduler {
  public struct SchedulerTimeType : Swift.Strideable, Swift.Codable, Swift.Hashable {
    public var date: Foundation.Date
    public init(_ date: Foundation.Date)
    public func distance(to other: Foundation.OperationQueue.SchedulerTimeType) -> Foundation.OperationQueue.SchedulerTimeType.Stride
    public func advanced(by n: Foundation.OperationQueue.SchedulerTimeType.Stride) -> Foundation.OperationQueue.SchedulerTimeType
    public struct Stride : Swift.ExpressibleByFloatLiteral, Swift.Comparable, Swift.SignedNumeric, Swift.Codable, Combine.SchedulerTimeIntervalConvertible {
      public typealias FloatLiteralType = Foundation.TimeInterval
      public typealias IntegerLiteralType = Foundation.TimeInterval
      public typealias Magnitude = Foundation.TimeInterval
      public var magnitude: Foundation.TimeInterval
      public var timeInterval: Foundation.TimeInterval {
        get
      }
      public init(integerLiteral value: Foundation.TimeInterval)
      public init(floatLiteral value: Foundation.TimeInterval)
      public init(_ timeInterval: Foundation.TimeInterval)
      public init?<T>(exactly source: T) where T : Swift.BinaryInteger
      public static func < (lhs: Foundation.OperationQueue.SchedulerTimeType.Stride, rhs: Foundation.OperationQueue.SchedulerTimeType.Stride) -> Swift.Bool
      public static func * (lhs: Foundation.OperationQueue.SchedulerTimeType.Stride, rhs: Foundation.OperationQueue.SchedulerTimeType.Stride) -> Foundation.OperationQueue.SchedulerTimeType.Stride
      public static func + (lhs: Foundation.OperationQueue.SchedulerTimeType.Stride, rhs: Foundation.OperationQueue.SchedulerTimeType.Stride) -> Foundation.OperationQueue.SchedulerTimeType.Stride
      public static func - (lhs: Foundation.OperationQueue.SchedulerTimeType.Stride, rhs: Foundation.OperationQueue.SchedulerTimeType.Stride) -> Foundation.OperationQueue.SchedulerTimeType.Stride
      public static func *= (lhs: inout Foundation.OperationQueue.SchedulerTimeType.Stride, rhs: Foundation.OperationQueue.SchedulerTimeType.Stride)
      public static func += (lhs: inout Foundation.OperationQueue.SchedulerTimeType.Stride, rhs: Foundation.OperationQueue.SchedulerTimeType.Stride)
      public static func -= (lhs: inout Foundation.OperationQueue.SchedulerTimeType.Stride, rhs: Foundation.OperationQueue.SchedulerTimeType.Stride)
      public static func seconds(_ s: Swift.Int) -> Foundation.OperationQueue.SchedulerTimeType.Stride
      public static func seconds(_ s: Swift.Double) -> Foundation.OperationQueue.SchedulerTimeType.Stride
      public static func milliseconds(_ ms: Swift.Int) -> Foundation.OperationQueue.SchedulerTimeType.Stride
      public static func microseconds(_ us: Swift.Int) -> Foundation.OperationQueue.SchedulerTimeType.Stride
      public static func nanoseconds(_ ns: Swift.Int) -> Foundation.OperationQueue.SchedulerTimeType.Stride
      public static func == (a: Foundation.OperationQueue.SchedulerTimeType.Stride, b: Foundation.OperationQueue.SchedulerTimeType.Stride) -> Swift.Bool
      public func encode(to encoder: Swift.Encoder) throws
      public init(from decoder: Swift.Decoder) throws
    }
    public func hash(into hasher: inout Swift.Hasher)
    public func encode(to encoder: Swift.Encoder) throws
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: Swift.Decoder) throws
  }
  public struct SchedulerOptions {
  }
  public func schedule(options: Foundation.OperationQueue.SchedulerOptions?, _ action: @escaping () -> Swift.Void)
  public func schedule(after date: Foundation.OperationQueue.SchedulerTimeType, tolerance: Foundation.OperationQueue.SchedulerTimeType.Stride, options: Foundation.OperationQueue.SchedulerOptions?, _ action: @escaping () -> Swift.Void)
  public func schedule(after date: Foundation.OperationQueue.SchedulerTimeType, interval: Foundation.OperationQueue.SchedulerTimeType.Stride, tolerance: Foundation.OperationQueue.SchedulerTimeType.Stride, options: Foundation.OperationQueue.SchedulerOptions?, _ action: @escaping () -> Swift.Void) -> Combine.Cancellable
  public var now: Foundation.OperationQueue.SchedulerTimeType {
    get
  }
  public var minimumTolerance: Foundation.OperationQueue.SchedulerTimeType.Stride {
    get
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.Decimal {
  public struct ParseStrategy<Format> : Foundation.ParseStrategy, Swift.Codable, Swift.Hashable where Format : Foundation.FormatStyle, Format.FormatInput == Foundation.Decimal {
    public var formatStyle: Format
    public var lenient: Swift.Bool
    public func parse(_ value: Swift.String) throws -> Format.FormatInput
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: Foundation.Decimal.ParseStrategy<Format>, b: Foundation.Decimal.ParseStrategy<Format>) -> Swift.Bool
    public typealias ParseInput = Swift.String
    public typealias ParseOutput = Foundation.Decimal
    public func encode(to encoder: Swift.Encoder) throws
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: Swift.Decoder) throws
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.Decimal {
  public init<S>(_ value: S.ParseInput, strategy: S) throws where S : Foundation.ParseStrategy, S.ParseOutput == Foundation.Decimal
  public init(_ value: Swift.String, format: Foundation.Decimal.FormatStyle, lenient: Swift.Bool = true) throws
  public init(_ value: Swift.String, format: Foundation.Decimal.FormatStyle.Percent, lenient: Swift.Bool = true) throws
  public init(_ value: Swift.String, format: Foundation.Decimal.FormatStyle.Currency, lenient: Swift.Bool = true) throws
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.Decimal.ParseStrategy where Format == Foundation.Decimal.FormatStyle {
  public init(format: Format, lenient: Swift.Bool = true)
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.Decimal.ParseStrategy where Format == Foundation.Decimal.FormatStyle.Percent {
  public init(format: Format, lenient: Swift.Bool = true)
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.Decimal.ParseStrategy where Format == Foundation.Decimal.FormatStyle.Currency {
  public init(format: Format, lenient: Swift.Bool = true)
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.Date {
  public func formatted<F>(_ format: F) -> F.FormatOutput where F : Foundation.FormatStyle, F.FormatInput == Foundation.Date
  public func formatted(date: Foundation.Date.FormatStyle.DateStyle, time: Foundation.Date.FormatStyle.TimeStyle) -> Swift.String
  public func formatted() -> Swift.String
  public init<T>(_ value: T.ParseInput, strategy: T) throws where T : Foundation.ParseStrategy, T.ParseOutput == Foundation.Date
  @_disfavoredOverload public init<T, Value>(_ value: Value, strategy: T) throws where T : Foundation.ParseStrategy, Value : Swift.StringProtocol, T.ParseInput == Swift.String, T.ParseOutput == Foundation.Date
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.Date {
  public struct FormatStyle {
    public var locale: Foundation.Locale
    public var timeZone: Foundation.TimeZone
    public var calendar: Foundation.Calendar
    public var capitalizationContext: Foundation.FormatStyleCapitalizationContext
    public var attributed: Foundation.Date.AttributedStyle {
      get
    }
    public init(date: Foundation.Date.FormatStyle.DateStyle? = nil, time: Foundation.Date.FormatStyle.TimeStyle? = nil, locale: Foundation.Locale = .autoupdatingCurrent, calendar: Foundation.Calendar = .autoupdatingCurrent, timeZone: Foundation.TimeZone = .autoupdatingCurrent, capitalizationContext: Foundation.FormatStyleCapitalizationContext = .unknown)
  }
  public struct AttributedStyle : Foundation.FormatStyle {
    public func format(_ value: Foundation.Date) -> Foundation.AttributedString
    public func locale(_ locale: Foundation.Locale) -> Foundation.Date.AttributedStyle
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: Foundation.Date.AttributedStyle, b: Foundation.Date.AttributedStyle) -> Swift.Bool
    public typealias FormatInput = Foundation.Date
    public typealias FormatOutput = Foundation.AttributedString
    public func encode(to encoder: Swift.Encoder) throws
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: Swift.Decoder) throws
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.Date.FormatStyle {
  public func era(_ format: Foundation.Date.FormatStyle.Symbol.Era = .abbreviated) -> Foundation.Date.FormatStyle
  public func year(_ format: Foundation.Date.FormatStyle.Symbol.Year = .defaultDigits) -> Foundation.Date.FormatStyle
  public func quarter(_ format: Foundation.Date.FormatStyle.Symbol.Quarter = .abbreviated) -> Foundation.Date.FormatStyle
  public func month(_ format: Foundation.Date.FormatStyle.Symbol.Month = .abbreviated) -> Foundation.Date.FormatStyle
  public func week(_ format: Foundation.Date.FormatStyle.Symbol.Week = .defaultDigits) -> Foundation.Date.FormatStyle
  public func day(_ format: Foundation.Date.FormatStyle.Symbol.Day = .defaultDigits) -> Foundation.Date.FormatStyle
  public func dayOfYear(_ format: Foundation.Date.FormatStyle.Symbol.DayOfYear = .defaultDigits) -> Foundation.Date.FormatStyle
  public func weekday(_ format: Foundation.Date.FormatStyle.Symbol.Weekday = .abbreviated) -> Foundation.Date.FormatStyle
  public func hour(_ format: Foundation.Date.FormatStyle.Symbol.Hour = .defaultDigits(amPM: .abbreviated)) -> Foundation.Date.FormatStyle
  public func minute(_ format: Foundation.Date.FormatStyle.Symbol.Minute = .defaultDigits) -> Foundation.Date.FormatStyle
  public func second(_ format: Foundation.Date.FormatStyle.Symbol.Second = .defaultDigits) -> Foundation.Date.FormatStyle
  public func secondFraction(_ format: Foundation.Date.FormatStyle.Symbol.SecondFraction) -> Foundation.Date.FormatStyle
  public func timeZone(_ format: Foundation.Date.FormatStyle.Symbol.TimeZone = .specificName(.short)) -> Foundation.Date.FormatStyle
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.Date.FormatStyle : Foundation.FormatStyle {
  public func format(_ value: Foundation.Date) -> Swift.String
  public func locale(_ locale: Foundation.Locale) -> Foundation.Date.FormatStyle
  public typealias FormatInput = Foundation.Date
  public typealias FormatOutput = Swift.String
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.Date.FormatStyle : Foundation.ParseStrategy {
  public func parse(_ value: Swift.String) throws -> Foundation.Date
  public typealias ParseInput = Swift.String
  public typealias ParseOutput = Foundation.Date
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.Date.FormatStyle : Swift.Codable, Swift.Hashable {
  public func encode(to encoder: Swift.Encoder) throws
  public init(from decoder: Swift.Decoder) throws
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: Foundation.Date.FormatStyle, b: Foundation.Date.FormatStyle) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.Date.FormatStyle {
  public struct DateStyle : Swift.Codable, Swift.Hashable {
    public static let omitted: Foundation.Date.FormatStyle.DateStyle
    public static let numeric: Foundation.Date.FormatStyle.DateStyle
    public static let abbreviated: Foundation.Date.FormatStyle.DateStyle
    public static let long: Foundation.Date.FormatStyle.DateStyle
    public static let complete: Foundation.Date.FormatStyle.DateStyle
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: Foundation.Date.FormatStyle.DateStyle, b: Foundation.Date.FormatStyle.DateStyle) -> Swift.Bool
    public func encode(to encoder: Swift.Encoder) throws
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: Swift.Decoder) throws
  }
  public struct TimeStyle : Swift.Codable, Swift.Hashable {
    public static let omitted: Foundation.Date.FormatStyle.TimeStyle
    public static let shortened: Foundation.Date.FormatStyle.TimeStyle
    public static let standard: Foundation.Date.FormatStyle.TimeStyle
    public static let complete: Foundation.Date.FormatStyle.TimeStyle
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: Foundation.Date.FormatStyle.TimeStyle, b: Foundation.Date.FormatStyle.TimeStyle) -> Swift.Bool
    public func encode(to encoder: Swift.Encoder) throws
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: Swift.Decoder) throws
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.Date.FormatStyle : Foundation.ParseableFormatStyle {
  public var parseStrategy: Foundation.Date.FormatStyle {
    get
  }
  public typealias Strategy = Foundation.Date.FormatStyle
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.FormatStyle where Self == Foundation.Date.FormatStyle {
  public static var dateTime: Foundation.Date.FormatStyle {
    get
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.ParseableFormatStyle where Self == Foundation.Date.FormatStyle {
  public static var dateTime: Foundation.Date.FormatStyle {
    get
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.ParseStrategy where Self == Foundation.Date.FormatStyle {
  @_disfavoredOverload public static var dateTime: Foundation.Date.FormatStyle {
    get
  }
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension Foundation.Scanner {
  public enum NumberRepresentation {
    case decimal
    case hexadecimal
    public static func == (a: Foundation.Scanner.NumberRepresentation, b: Foundation.Scanner.NumberRepresentation) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public var currentIndex: Swift.String.Index {
    get
    set
  }
  public func scanInt(representation: Foundation.Scanner.NumberRepresentation = .decimal) -> Swift.Int?
  public func scanInt32(representation: Foundation.Scanner.NumberRepresentation = .decimal) -> Swift.Int32?
  public func scanInt64(representation: Foundation.Scanner.NumberRepresentation = .decimal) -> Swift.Int64?
  public func scanUInt64(representation: Foundation.Scanner.NumberRepresentation = .decimal) -> Swift.UInt64?
  public func scanFloat(representation: Foundation.Scanner.NumberRepresentation = .decimal) -> Swift.Float?
  public func scanDouble(representation: Foundation.Scanner.NumberRepresentation = .decimal) -> Swift.Double?
  public func scanDecimal() -> Foundation.Decimal?
  public func scanString(_ searchString: Swift.String) -> Swift.String?
  public func scanCharacters(from set: Foundation.CharacterSet) -> Swift.String?
  public func scanUpToString(_ substring: Swift.String) -> Swift.String?
  public func scanUpToCharacters(from set: Foundation.CharacterSet) -> Swift.String?
  public func scanCharacter() -> Swift.Character?
}
public protocol ReferenceConvertible : Swift.CustomDebugStringConvertible, Swift.CustomStringConvertible, Swift.Hashable, Swift._ObjectiveCBridgeable {
  associatedtype ReferenceType : ObjectiveC.NSObject, Foundation.NSCopying
}
extension Foundation.NotificationCenter {
  
  #if compiler(>=5.3) && $RethrowsProtocol
  @available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
  public func notifications(named name: Foundation.Notification.Name, object: Swift.AnyObject? = nil) -> Foundation.NotificationCenter.Notifications
  #endif

  
  #if compiler(>=5.3) && $RethrowsProtocol
  @_hasMissingDesignatedInitializers @available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
  final public class Notifications : _Concurrency.AsyncSequence {
    public typealias Element = Foundation.Notification
    @available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
    public struct Iterator : _Concurrency.AsyncIteratorProtocol {
      
      #if compiler(>=5.3) && $AsyncAwait
      public func next() async -> Foundation.Notification?
      #endif

      public typealias Element = Foundation.Notification
    }
    @objc deinit
    __consuming final public func makeAsyncIterator() -> Foundation.NotificationCenter.Notifications.Iterator
    public typealias AsyncIterator = Foundation.NotificationCenter.Notifications.Iterator
  }
  #endif

}
public struct Locale : Swift.Hashable, Swift.Equatable, Foundation.ReferenceConvertible {
  public typealias ReferenceType = Foundation.NSLocale
  public typealias LanguageDirection = Foundation.NSLocale.LanguageDirection
  public static var autoupdatingCurrent: Foundation.Locale {
    get
  }
  public static var current: Foundation.Locale {
    get
  }
  @available(*, unavailable, message: "Consider using the user's locale or nil instead, depending on use case")
  public static var system: Foundation.Locale {
    get
  }
  public init(identifier: Swift.String)
  public func localizedString(forIdentifier identifier: Swift.String) -> Swift.String?
  public func localizedString(forLanguageCode languageCode: Swift.String) -> Swift.String?
  public func localizedString(forRegionCode regionCode: Swift.String) -> Swift.String?
  public func localizedString(forScriptCode scriptCode: Swift.String) -> Swift.String?
  public func localizedString(forVariantCode variantCode: Swift.String) -> Swift.String?
  public func localizedString(for calendarIdentifier: Foundation.Calendar.Identifier) -> Swift.String?
  public func localizedString(forCurrencyCode currencyCode: Swift.String) -> Swift.String?
  public func localizedString(forCollationIdentifier collationIdentifier: Swift.String) -> Swift.String?
  public func localizedString(forCollatorIdentifier collatorIdentifier: Swift.String) -> Swift.String?
  public var identifier: Swift.String {
    get
  }
  public var languageCode: Swift.String? {
    get
  }
  public var regionCode: Swift.String? {
    get
  }
  public var scriptCode: Swift.String? {
    get
  }
  public var variantCode: Swift.String? {
    get
  }
  public var exemplarCharacterSet: Foundation.CharacterSet? {
    get
  }
  public var calendar: Foundation.Calendar {
    get
  }
  public var collationIdentifier: Swift.String? {
    get
  }
  public var usesMetricSystem: Swift.Bool {
    get
  }
  public var decimalSeparator: Swift.String? {
    get
  }
  public var groupingSeparator: Swift.String? {
    get
  }
  public var currencySymbol: Swift.String? {
    get
  }
  public var currencyCode: Swift.String? {
    get
  }
  public var collatorIdentifier: Swift.String? {
    get
  }
  public var quotationBeginDelimiter: Swift.String? {
    get
  }
  public var quotationEndDelimiter: Swift.String? {
    get
  }
  public var alternateQuotationBeginDelimiter: Swift.String? {
    get
  }
  public var alternateQuotationEndDelimiter: Swift.String? {
    get
  }
  public static var availableIdentifiers: [Swift.String] {
    get
  }
  public static var isoLanguageCodes: [Swift.String] {
    get
  }
  public static var isoRegionCodes: [Swift.String] {
    get
  }
  public static var isoCurrencyCodes: [Swift.String] {
    get
  }
  public static var commonISOCurrencyCodes: [Swift.String] {
    get
  }
  public static var preferredLanguages: [Swift.String] {
    get
  }
  public static func components(fromIdentifier string: Swift.String) -> [Swift.String : Swift.String]
  public static func identifier(fromComponents components: [Swift.String : Swift.String]) -> Swift.String
  public static func canonicalIdentifier(from string: Swift.String) -> Swift.String
  public static func canonicalLanguageIdentifier(from string: Swift.String) -> Swift.String
  public static func identifier(fromWindowsLocaleCode code: Swift.Int) -> Swift.String?
  public static func windowsLocaleCode(fromIdentifier identifier: Swift.String) -> Swift.Int?
  public static func characterDirection(forLanguage isoLangCode: Swift.String) -> Foundation.Locale.LanguageDirection
  public static func lineDirection(forLanguage isoLangCode: Swift.String) -> Foundation.Locale.LanguageDirection
  @available(*, unavailable, renamed: "init(identifier:)")
  public init(localeIdentifier: Swift.String)
  @available(*, unavailable, renamed: "identifier")
  public var localeIdentifier: Swift.String {
    get
  }
  @available(*, unavailable, renamed: "localizedString(forIdentifier:)")
  public func localizedString(forLocaleIdentifier localeIdentifier: Swift.String) -> Swift.String
  @available(*, unavailable, renamed: "availableIdentifiers")
  public static var availableLocaleIdentifiers: [Swift.String] {
    get
  }
  @available(*, unavailable, renamed: "components(fromIdentifier:)")
  public static func components(fromLocaleIdentifier string: Swift.String) -> [Swift.String : Swift.String]
  @available(*, unavailable, renamed: "identifier(fromComponents:)")
  public static func localeIdentifier(fromComponents dict: [Swift.String : Swift.String]) -> Swift.String
  @available(*, unavailable, renamed: "canonicalIdentifier(from:)")
  public static func canonicalLocaleIdentifier(from string: Swift.String) -> Swift.String
  @available(*, unavailable, renamed: "identifier(fromWindowsLocaleCode:)")
  public static func localeIdentifier(fromWindowsLocaleCode lcid: Swift.UInt32) -> Swift.String?
  @available(*, unavailable, renamed: "windowsLocaleCode(fromIdentifier:)")
  public static func windowsLocaleCode(fromLocaleIdentifier localeIdentifier: Swift.String) -> Swift.UInt32
  @available(*, unavailable, message: "use regionCode instead")
  public var countryCode: Swift.String {
    get
  }
  @available(*, unavailable, message: "use localizedString(forRegionCode:) instead")
  public func localizedString(forCountryCode countryCode: Swift.String) -> Swift.String
  @available(*, unavailable, renamed: "isoRegionCodes")
  public static var isoCountryCodes: [Swift.String] {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (lhs: Foundation.Locale, rhs: Foundation.Locale) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
extension Foundation.Locale : Swift.CustomDebugStringConvertible, Swift.CustomStringConvertible, Swift.CustomReflectable {
  public var customMirror: Swift.Mirror {
    get
  }
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
}
extension Foundation.Locale : Swift._ObjectiveCBridgeable {
  @_semantics("convertToObjectiveC") public func _bridgeToObjectiveC() -> Foundation.NSLocale
  public static func _forceBridgeFromObjectiveC(_ input: Foundation.NSLocale, result: inout Foundation.Locale?)
  public static func _conditionallyBridgeFromObjectiveC(_ input: Foundation.NSLocale, result: inout Foundation.Locale?) -> Swift.Bool
  @_effects(readonly) public static func _unconditionallyBridgeFromObjectiveC(_ source: Foundation.NSLocale?) -> Foundation.Locale
  public typealias _ObjectiveCType = Foundation.NSLocale
}
extension Foundation.NSLocale : Swift._HasCustomAnyHashableRepresentation {
  @nonobjc public func _toCustomAnyHashable() -> Swift.AnyHashable?
}
extension Foundation.Locale : Swift.Codable {
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.Date.FormatStyle {
  public struct Symbol : Swift.Hashable {
    public struct Era : Swift.Hashable {
      public func hash(into hasher: inout Swift.Hasher)
      public static func == (a: Foundation.Date.FormatStyle.Symbol.Era, b: Foundation.Date.FormatStyle.Symbol.Era) -> Swift.Bool
      public var hashValue: Swift.Int {
        get
      }
    }
    public struct Year : Swift.Hashable {
      public func hash(into hasher: inout Swift.Hasher)
      public static func == (a: Foundation.Date.FormatStyle.Symbol.Year, b: Foundation.Date.FormatStyle.Symbol.Year) -> Swift.Bool
      public var hashValue: Swift.Int {
        get
      }
    }
    public struct YearForWeekOfYear : Swift.Hashable {
      public func hash(into hasher: inout Swift.Hasher)
      public static func == (a: Foundation.Date.FormatStyle.Symbol.YearForWeekOfYear, b: Foundation.Date.FormatStyle.Symbol.YearForWeekOfYear) -> Swift.Bool
      public var hashValue: Swift.Int {
        get
      }
    }
    public struct CyclicYear : Swift.Hashable {
      public func hash(into hasher: inout Swift.Hasher)
      public static func == (a: Foundation.Date.FormatStyle.Symbol.CyclicYear, b: Foundation.Date.FormatStyle.Symbol.CyclicYear) -> Swift.Bool
      public var hashValue: Swift.Int {
        get
      }
    }
    public struct Quarter : Swift.Hashable {
      public func hash(into hasher: inout Swift.Hasher)
      public static func == (a: Foundation.Date.FormatStyle.Symbol.Quarter, b: Foundation.Date.FormatStyle.Symbol.Quarter) -> Swift.Bool
      public var hashValue: Swift.Int {
        get
      }
    }
    public struct Month : Swift.Hashable {
      public func hash(into hasher: inout Swift.Hasher)
      public static func == (a: Foundation.Date.FormatStyle.Symbol.Month, b: Foundation.Date.FormatStyle.Symbol.Month) -> Swift.Bool
      public var hashValue: Swift.Int {
        get
      }
    }
    public struct Week : Swift.Hashable {
      public func hash(into hasher: inout Swift.Hasher)
      public static func == (a: Foundation.Date.FormatStyle.Symbol.Week, b: Foundation.Date.FormatStyle.Symbol.Week) -> Swift.Bool
      public var hashValue: Swift.Int {
        get
      }
    }
    public struct Day : Swift.Hashable {
      public func hash(into hasher: inout Swift.Hasher)
      public static func == (a: Foundation.Date.FormatStyle.Symbol.Day, b: Foundation.Date.FormatStyle.Symbol.Day) -> Swift.Bool
      public var hashValue: Swift.Int {
        get
      }
    }
    public struct DayOfYear : Swift.Hashable {
      public func hash(into hasher: inout Swift.Hasher)
      public static func == (a: Foundation.Date.FormatStyle.Symbol.DayOfYear, b: Foundation.Date.FormatStyle.Symbol.DayOfYear) -> Swift.Bool
      public var hashValue: Swift.Int {
        get
      }
    }
    public struct Weekday : Swift.Hashable {
      public func hash(into hasher: inout Swift.Hasher)
      public static func == (a: Foundation.Date.FormatStyle.Symbol.Weekday, b: Foundation.Date.FormatStyle.Symbol.Weekday) -> Swift.Bool
      public var hashValue: Swift.Int {
        get
      }
    }
    public struct DayPeriod : Swift.Hashable {
      public func hash(into hasher: inout Swift.Hasher)
      public static func == (a: Foundation.Date.FormatStyle.Symbol.DayPeriod, b: Foundation.Date.FormatStyle.Symbol.DayPeriod) -> Swift.Bool
      public var hashValue: Swift.Int {
        get
      }
    }
    public struct Hour : Swift.Hashable {
      public func hash(into hasher: inout Swift.Hasher)
      public static func == (a: Foundation.Date.FormatStyle.Symbol.Hour, b: Foundation.Date.FormatStyle.Symbol.Hour) -> Swift.Bool
      public var hashValue: Swift.Int {
        get
      }
    }
    public struct Minute : Swift.Hashable {
      public func hash(into hasher: inout Swift.Hasher)
      public static func == (a: Foundation.Date.FormatStyle.Symbol.Minute, b: Foundation.Date.FormatStyle.Symbol.Minute) -> Swift.Bool
      public var hashValue: Swift.Int {
        get
      }
    }
    public struct Second : Swift.Hashable {
      public func hash(into hasher: inout Swift.Hasher)
      public static func == (a: Foundation.Date.FormatStyle.Symbol.Second, b: Foundation.Date.FormatStyle.Symbol.Second) -> Swift.Bool
      public var hashValue: Swift.Int {
        get
      }
    }
    public struct SecondFraction : Swift.Hashable {
      public func hash(into hasher: inout Swift.Hasher)
      public static func == (a: Foundation.Date.FormatStyle.Symbol.SecondFraction, b: Foundation.Date.FormatStyle.Symbol.SecondFraction) -> Swift.Bool
      public var hashValue: Swift.Int {
        get
      }
    }
    public struct TimeZone : Swift.Hashable {
      public func hash(into hasher: inout Swift.Hasher)
      public static func == (a: Foundation.Date.FormatStyle.Symbol.TimeZone, b: Foundation.Date.FormatStyle.Symbol.TimeZone) -> Swift.Bool
      public var hashValue: Swift.Int {
        get
      }
    }
    public struct StandaloneQuarter : Swift.Hashable {
      public func hash(into hasher: inout Swift.Hasher)
      public static func == (a: Foundation.Date.FormatStyle.Symbol.StandaloneQuarter, b: Foundation.Date.FormatStyle.Symbol.StandaloneQuarter) -> Swift.Bool
      public var hashValue: Swift.Int {
        get
      }
    }
    public struct StandaloneMonth : Swift.Hashable {
      public func hash(into hasher: inout Swift.Hasher)
      public static func == (a: Foundation.Date.FormatStyle.Symbol.StandaloneMonth, b: Foundation.Date.FormatStyle.Symbol.StandaloneMonth) -> Swift.Bool
      public var hashValue: Swift.Int {
        get
      }
    }
    public struct StandaloneWeekday : Swift.Hashable {
      public func hash(into hasher: inout Swift.Hasher)
      public static func == (a: Foundation.Date.FormatStyle.Symbol.StandaloneWeekday, b: Foundation.Date.FormatStyle.Symbol.StandaloneWeekday) -> Swift.Bool
      public var hashValue: Swift.Int {
        get
      }
    }
    public struct VerbatimHour : Swift.Hashable {
      public func hash(into hasher: inout Swift.Hasher)
      public static func == (a: Foundation.Date.FormatStyle.Symbol.VerbatimHour, b: Foundation.Date.FormatStyle.Symbol.VerbatimHour) -> Swift.Bool
      public var hashValue: Swift.Int {
        get
      }
    }
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: Foundation.Date.FormatStyle.Symbol, b: Foundation.Date.FormatStyle.Symbol) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.Date.FormatStyle.Symbol.Era {
  public static var abbreviated: Foundation.Date.FormatStyle.Symbol.Era {
    get
  }
  public static var wide: Foundation.Date.FormatStyle.Symbol.Era {
    get
  }
  public static var narrow: Foundation.Date.FormatStyle.Symbol.Era {
    get
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.Date.FormatStyle.Symbol.Year {
  public static var defaultDigits: Foundation.Date.FormatStyle.Symbol.Year {
    get
  }
  public static var twoDigits: Foundation.Date.FormatStyle.Symbol.Year {
    get
  }
  public static func padded(_ length: Swift.Int) -> Foundation.Date.FormatStyle.Symbol.Year
  public static func relatedGregorian(minimumLength: Swift.Int = 1) -> Foundation.Date.FormatStyle.Symbol.Year
  public static func extended(minimumLength: Swift.Int = 1) -> Foundation.Date.FormatStyle.Symbol.Year
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.Date.FormatStyle.Symbol.YearForWeekOfYear {
  public static var defaultDigits: Foundation.Date.FormatStyle.Symbol.YearForWeekOfYear {
    get
  }
  public static var twoDigits: Foundation.Date.FormatStyle.Symbol.YearForWeekOfYear {
    get
  }
  public static func padded(_ length: Swift.Int) -> Foundation.Date.FormatStyle.Symbol.YearForWeekOfYear
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.Date.FormatStyle.Symbol.CyclicYear {
  public static var abbreviated: Foundation.Date.FormatStyle.Symbol.CyclicYear {
    get
  }
  public static var wide: Foundation.Date.FormatStyle.Symbol.CyclicYear {
    get
  }
  public static var narrow: Foundation.Date.FormatStyle.Symbol.CyclicYear {
    get
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.Date.FormatStyle.Symbol.Quarter {
  public static var oneDigit: Foundation.Date.FormatStyle.Symbol.Quarter {
    get
  }
  public static var twoDigits: Foundation.Date.FormatStyle.Symbol.Quarter {
    get
  }
  public static var abbreviated: Foundation.Date.FormatStyle.Symbol.Quarter {
    get
  }
  public static var wide: Foundation.Date.FormatStyle.Symbol.Quarter {
    get
  }
  public static var narrow: Foundation.Date.FormatStyle.Symbol.Quarter {
    get
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.Date.FormatStyle.Symbol.StandaloneQuarter {
  public static var oneDigit: Foundation.Date.FormatStyle.Symbol.StandaloneQuarter {
    get
  }
  public static var twoDigits: Foundation.Date.FormatStyle.Symbol.StandaloneQuarter {
    get
  }
  public static var abbreviated: Foundation.Date.FormatStyle.Symbol.StandaloneQuarter {
    get
  }
  public static var wide: Foundation.Date.FormatStyle.Symbol.StandaloneQuarter {
    get
  }
  public static var narrow: Foundation.Date.FormatStyle.Symbol.StandaloneQuarter {
    get
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.Date.FormatStyle.Symbol.Month {
  public static var defaultDigits: Foundation.Date.FormatStyle.Symbol.Month {
    get
  }
  public static var twoDigits: Foundation.Date.FormatStyle.Symbol.Month {
    get
  }
  public static var abbreviated: Foundation.Date.FormatStyle.Symbol.Month {
    get
  }
  public static var wide: Foundation.Date.FormatStyle.Symbol.Month {
    get
  }
  public static var narrow: Foundation.Date.FormatStyle.Symbol.Month {
    get
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.Date.FormatStyle.Symbol.StandaloneMonth {
  public static var defaultDigits: Foundation.Date.FormatStyle.Symbol.StandaloneMonth {
    get
  }
  public static var twoDigits: Foundation.Date.FormatStyle.Symbol.StandaloneMonth {
    get
  }
  public static var abbreviated: Foundation.Date.FormatStyle.Symbol.StandaloneMonth {
    get
  }
  public static var wide: Foundation.Date.FormatStyle.Symbol.StandaloneMonth {
    get
  }
  public static var narrow: Foundation.Date.FormatStyle.Symbol.StandaloneMonth {
    get
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.Date.FormatStyle.Symbol.Week {
  public static var defaultDigits: Foundation.Date.FormatStyle.Symbol.Week {
    get
  }
  public static var twoDigits: Foundation.Date.FormatStyle.Symbol.Week {
    get
  }
  public static var weekOfMonth: Foundation.Date.FormatStyle.Symbol.Week {
    get
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.Date.FormatStyle.Symbol.Day {
  public static var defaultDigits: Foundation.Date.FormatStyle.Symbol.Day {
    get
  }
  public static var twoDigits: Foundation.Date.FormatStyle.Symbol.Day {
    get
  }
  public static var ordinalOfDayInMonth: Foundation.Date.FormatStyle.Symbol.Day {
    get
  }
  public static func julianModified(minimumLength: Swift.Int = 1) -> Foundation.Date.FormatStyle.Symbol.Day
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.Date.FormatStyle.Symbol.DayOfYear {
  public static var defaultDigits: Foundation.Date.FormatStyle.Symbol.DayOfYear {
    get
  }
  public static var twoDigits: Foundation.Date.FormatStyle.Symbol.DayOfYear {
    get
  }
  public static var threeDigits: Foundation.Date.FormatStyle.Symbol.DayOfYear {
    get
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.Date.FormatStyle.Symbol.Weekday {
  public static var abbreviated: Foundation.Date.FormatStyle.Symbol.Weekday {
    get
  }
  public static var wide: Foundation.Date.FormatStyle.Symbol.Weekday {
    get
  }
  public static var narrow: Foundation.Date.FormatStyle.Symbol.Weekday {
    get
  }
  public static var short: Foundation.Date.FormatStyle.Symbol.Weekday {
    get
  }
  public static var oneDigit: Foundation.Date.FormatStyle.Symbol.Weekday {
    get
  }
  public static var twoDigits: Foundation.Date.FormatStyle.Symbol.Weekday {
    get
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.Date.FormatStyle.Symbol.StandaloneWeekday {
  public static var oneDigit: Foundation.Date.FormatStyle.Symbol.StandaloneWeekday {
    get
  }
  public static var abbreviated: Foundation.Date.FormatStyle.Symbol.StandaloneWeekday {
    get
  }
  public static var wide: Foundation.Date.FormatStyle.Symbol.StandaloneWeekday {
    get
  }
  public static var narrow: Foundation.Date.FormatStyle.Symbol.StandaloneWeekday {
    get
  }
  public static var short: Foundation.Date.FormatStyle.Symbol.StandaloneWeekday {
    get
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.Date.FormatStyle.Symbol.DayPeriod {
  public enum Width {
    case abbreviated
    case wide
    case narrow
    public static func == (a: Foundation.Date.FormatStyle.Symbol.DayPeriod.Width, b: Foundation.Date.FormatStyle.Symbol.DayPeriod.Width) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public static func standard(_ width: Foundation.Date.FormatStyle.Symbol.DayPeriod.Width) -> Foundation.Date.FormatStyle.Symbol.DayPeriod
  public static func with12s(_ width: Foundation.Date.FormatStyle.Symbol.DayPeriod.Width) -> Foundation.Date.FormatStyle.Symbol.DayPeriod
  public static func conversational(_ width: Foundation.Date.FormatStyle.Symbol.DayPeriod.Width) -> Foundation.Date.FormatStyle.Symbol.DayPeriod
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.Date.FormatStyle.Symbol.Hour {
  public struct AMPMStyle : Swift.Codable, Swift.Hashable {
    public static let omitted: Foundation.Date.FormatStyle.Symbol.Hour.AMPMStyle
    public static let narrow: Foundation.Date.FormatStyle.Symbol.Hour.AMPMStyle
    public static let abbreviated: Foundation.Date.FormatStyle.Symbol.Hour.AMPMStyle
    public static let wide: Foundation.Date.FormatStyle.Symbol.Hour.AMPMStyle
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: Foundation.Date.FormatStyle.Symbol.Hour.AMPMStyle, b: Foundation.Date.FormatStyle.Symbol.Hour.AMPMStyle) -> Swift.Bool
    public func encode(to encoder: Swift.Encoder) throws
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: Swift.Decoder) throws
  }
  public static func defaultDigits(amPM: Foundation.Date.FormatStyle.Symbol.Hour.AMPMStyle) -> Foundation.Date.FormatStyle.Symbol.Hour
  public static func twoDigits(amPM: Foundation.Date.FormatStyle.Symbol.Hour.AMPMStyle) -> Foundation.Date.FormatStyle.Symbol.Hour
  public static func conversationalDefaultDigits(amPM: Foundation.Date.FormatStyle.Symbol.Hour.AMPMStyle) -> Foundation.Date.FormatStyle.Symbol.Hour
  public static func conversationalTwoDigits(amPM: Foundation.Date.FormatStyle.Symbol.Hour.AMPMStyle) -> Foundation.Date.FormatStyle.Symbol.Hour
  @available(*, deprecated, renamed: "defaultDigits(amPM:)")
  public static var defaultDigitsNoAMPM: Foundation.Date.FormatStyle.Symbol.Hour {
    get
  }
  @available(*, deprecated, renamed: "twoDigits(amPM:)")
  public static var twoDigitsNoAMPM: Foundation.Date.FormatStyle.Symbol.Hour {
    get
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.Date.FormatStyle.Symbol.VerbatimHour {
  public struct HourCycle : Swift.Codable, Swift.Hashable {
    public static let zeroBased: Foundation.Date.FormatStyle.Symbol.VerbatimHour.HourCycle
    public static let oneBased: Foundation.Date.FormatStyle.Symbol.VerbatimHour.HourCycle
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: Foundation.Date.FormatStyle.Symbol.VerbatimHour.HourCycle, b: Foundation.Date.FormatStyle.Symbol.VerbatimHour.HourCycle) -> Swift.Bool
    public func encode(to encoder: Swift.Encoder) throws
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: Swift.Decoder) throws
  }
  public struct Clock : Swift.Codable, Swift.Hashable {
    public static let twelveHour: Foundation.Date.FormatStyle.Symbol.VerbatimHour.Clock
    public static let twentyFourHour: Foundation.Date.FormatStyle.Symbol.VerbatimHour.Clock
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: Foundation.Date.FormatStyle.Symbol.VerbatimHour.Clock, b: Foundation.Date.FormatStyle.Symbol.VerbatimHour.Clock) -> Swift.Bool
    public func encode(to encoder: Swift.Encoder) throws
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: Swift.Decoder) throws
  }
  public static func defaultDigits(clock: Foundation.Date.FormatStyle.Symbol.VerbatimHour.Clock, hourCycle: Foundation.Date.FormatStyle.Symbol.VerbatimHour.HourCycle) -> Foundation.Date.FormatStyle.Symbol.VerbatimHour
  public static func twoDigits(clock: Foundation.Date.FormatStyle.Symbol.VerbatimHour.Clock, hourCycle: Foundation.Date.FormatStyle.Symbol.VerbatimHour.HourCycle) -> Foundation.Date.FormatStyle.Symbol.VerbatimHour
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.Date.FormatStyle.Symbol.Minute {
  public static var defaultDigits: Foundation.Date.FormatStyle.Symbol.Minute {
    get
  }
  public static var twoDigits: Foundation.Date.FormatStyle.Symbol.Minute {
    get
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.Date.FormatStyle.Symbol.Second {
  public static var defaultDigits: Foundation.Date.FormatStyle.Symbol.Second {
    get
  }
  public static var twoDigits: Foundation.Date.FormatStyle.Symbol.Second {
    get
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.Date.FormatStyle.Symbol.SecondFraction {
  public static func fractional(_ val: Swift.Int) -> Foundation.Date.FormatStyle.Symbol.SecondFraction
  public static func milliseconds(_ val: Swift.Int) -> Foundation.Date.FormatStyle.Symbol.SecondFraction
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.Date.FormatStyle.Symbol.TimeZone {
  public enum Width {
    case short
    case long
    public static func == (a: Foundation.Date.FormatStyle.Symbol.TimeZone.Width, b: Foundation.Date.FormatStyle.Symbol.TimeZone.Width) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public static func specificName(_ width: Foundation.Date.FormatStyle.Symbol.TimeZone.Width) -> Foundation.Date.FormatStyle.Symbol.TimeZone
  public static func genericName(_ width: Foundation.Date.FormatStyle.Symbol.TimeZone.Width) -> Foundation.Date.FormatStyle.Symbol.TimeZone
  public static func iso8601(_ width: Foundation.Date.FormatStyle.Symbol.TimeZone.Width) -> Foundation.Date.FormatStyle.Symbol.TimeZone
  public static func localizedGMT(_ width: Foundation.Date.FormatStyle.Symbol.TimeZone.Width) -> Foundation.Date.FormatStyle.Symbol.TimeZone
  public static func identifier(_ width: Foundation.Date.FormatStyle.Symbol.TimeZone.Width) -> Foundation.Date.FormatStyle.Symbol.TimeZone
  public static var exemplarLocation: Foundation.Date.FormatStyle.Symbol.TimeZone {
    get
  }
  public static var genericLocation: Foundation.Date.FormatStyle.Symbol.TimeZone {
    get
  }
}
@available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
extension Swift.CollectionDifference.Change : Swift._ObjectiveCBridgeable {
  @_semantics("convertToObjectiveC") public func _bridgeToObjectiveC() -> Foundation.NSOrderedCollectionChange
  public static func _forceBridgeFromObjectiveC(_ input: Foundation.NSOrderedCollectionChange, result: inout Swift.CollectionDifference<ChangeElement>.Change?)
  public static func _conditionallyBridgeFromObjectiveC(_ x: Foundation.NSOrderedCollectionChange, result: inout Swift.CollectionDifference<ChangeElement>.Change?) -> Swift.Bool
  @_effects(readonly) public static func _unconditionallyBridgeFromObjectiveC(_ s: Foundation.NSOrderedCollectionChange?) -> Swift.CollectionDifference<ChangeElement>.Change
  public typealias _ObjectiveCType = Foundation.NSOrderedCollectionChange
}
@available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
extension Swift.CollectionDifference : Swift._ObjectiveCBridgeable {
  @_semantics("convertToObjectiveC") public func _bridgeToObjectiveC() -> Foundation.NSOrderedCollectionDifference
  public static func _forceBridgeFromObjectiveC(_ input: Foundation.NSOrderedCollectionDifference, result: inout Swift.CollectionDifference<ChangeElement>?)
  public static func _conditionallyBridgeFromObjectiveC(_ input: Foundation.NSOrderedCollectionDifference, result: inout Swift.CollectionDifference<ChangeElement>?) -> Swift.Bool
  @_effects(readonly) public static func _unconditionallyBridgeFromObjectiveC(_ s: Foundation.NSOrderedCollectionDifference?) -> Swift.CollectionDifference<ChangeElement>
  public typealias _ObjectiveCType = Foundation.NSOrderedCollectionDifference
}
@available(macOS 10.12, iOS 10.0, watchOS 3.0, tvOS 10.0, *)
public struct DateInterval : Foundation.ReferenceConvertible, Swift.Comparable, Swift.Hashable, Swift.Codable {
  public typealias ReferenceType = Foundation.NSDateInterval
  public var start: Foundation.Date
  public var end: Foundation.Date {
    get
    set
  }
  public var duration: Foundation.TimeInterval {
    get
    set
  }
  public init()
  public init(start: Foundation.Date, end: Foundation.Date)
  public init(start: Foundation.Date, duration: Foundation.TimeInterval)
  public func compare(_ dateInterval: Foundation.DateInterval) -> Foundation.ComparisonResult
  public func intersects(_ dateInterval: Foundation.DateInterval) -> Swift.Bool
  public func intersection(with dateInterval: Foundation.DateInterval) -> Foundation.DateInterval?
  public func contains(_ date: Foundation.Date) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  @available(macOS 10.12, iOS 10.0, watchOS 3.0, tvOS 10.0, *)
  public static func == (lhs: Foundation.DateInterval, rhs: Foundation.DateInterval) -> Swift.Bool
  @available(macOS 10.12, iOS 10.0, watchOS 3.0, tvOS 10.0, *)
  public static func < (lhs: Foundation.DateInterval, rhs: Foundation.DateInterval) -> Swift.Bool
  public func encode(to encoder: Swift.Encoder) throws
  public var hashValue: Swift.Int {
    get
  }
  public init(from decoder: Swift.Decoder) throws
}
@available(macOS 10.12, iOS 10.0, watchOS 3.0, tvOS 10.0, *)
extension Foundation.DateInterval : Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible, Swift.CustomReflectable {
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
  public var customMirror: Swift.Mirror {
    get
  }
}
@available(macOS 10.12, iOS 10.0, watchOS 3.0, tvOS 10.0, *)
extension Foundation.DateInterval : Swift._ObjectiveCBridgeable {
  public static func _getObjectiveCType() -> Any.Type
  @_semantics("convertToObjectiveC") public func _bridgeToObjectiveC() -> Foundation.NSDateInterval
  public static func _forceBridgeFromObjectiveC(_ dateInterval: Foundation.NSDateInterval, result: inout Foundation.DateInterval?)
  public static func _conditionallyBridgeFromObjectiveC(_ dateInterval: Foundation.NSDateInterval, result: inout Foundation.DateInterval?) -> Swift.Bool
  @_effects(readonly) public static func _unconditionallyBridgeFromObjectiveC(_ source: Foundation.NSDateInterval?) -> Foundation.DateInterval
  public typealias _ObjectiveCType = Foundation.NSDateInterval
}
@available(macOS 10.12, iOS 10.0, watchOS 3.0, tvOS 10.0, *)
extension Foundation.NSDateInterval : Swift._HasCustomAnyHashableRepresentation {
  @nonobjc public func _toCustomAnyHashable() -> Swift.AnyHashable?
}
public struct URLResourceValues {
  public init()
  public var allValues: [Foundation.URLResourceKey : Any] {
    get
  }
  public var name: Swift.String? {
    get
    set
  }
  public var localizedName: Swift.String? {
    get
  }
  public var isRegularFile: Swift.Bool? {
    get
  }
  public var isDirectory: Swift.Bool? {
    get
  }
  public var isSymbolicLink: Swift.Bool? {
    get
  }
  public var isVolume: Swift.Bool? {
    get
  }
  public var isPackage: Swift.Bool? {
    get
    set
  }
  @available(macOS 10.11, iOS 9.0, *)
  public var isApplication: Swift.Bool? {
    get
  }
  @available(macOS 10.11, *)
  public var applicationIsScriptable: Swift.Bool? {
    get
  }
  public var isSystemImmutable: Swift.Bool? {
    get
  }
  public var isUserImmutable: Swift.Bool? {
    get
    set
  }
  public var isHidden: Swift.Bool? {
    get
    set
  }
  public var hasHiddenExtension: Swift.Bool? {
    get
    set
  }
  public var creationDate: Foundation.Date? {
    get
    set
  }
  public var contentAccessDate: Foundation.Date? {
    get
    set
  }
  public var contentModificationDate: Foundation.Date? {
    get
    set
  }
  public var attributeModificationDate: Foundation.Date? {
    get
  }
  public var linkCount: Swift.Int? {
    get
  }
  public var parentDirectory: Foundation.URL? {
    get
  }
  public var volume: Foundation.URL? {
    get
  }
  @available(macOS, introduced: 10.6, deprecated: 100000.0, message: "Use .contentType instead")
  @available(iOS, introduced: 4.0, deprecated: 100000.0, message: "Use .contentType instead")
  @available(watchOS, introduced: 2.0, deprecated: 100000.0, message: "Use .contentType instead")
  @available(tvOS, introduced: 9.0, deprecated: 100000.0, message: "Use .contentType instead")
  public var typeIdentifier: Swift.String? {
    get
  }
  public var localizedTypeDescription: Swift.String? {
    get
  }
  public var labelNumber: Swift.Int? {
    get
    set
  }
  public var localizedLabel: Swift.String? {
    get
  }
  public var fileResourceIdentifier: (Foundation.NSCopying & Foundation.NSSecureCoding & ObjectiveC.NSObjectProtocol)? {
    get
  }
  public var volumeIdentifier: (Foundation.NSCopying & Foundation.NSSecureCoding & ObjectiveC.NSObjectProtocol)? {
    get
  }
  @available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
  public var fileContentIdentifier: Swift.Int64? {
    get
  }
  public var preferredIOBlockSize: Swift.Int? {
    get
  }
  public var isReadable: Swift.Bool? {
    get
  }
  public var isWritable: Swift.Bool? {
    get
  }
  public var isExecutable: Swift.Bool? {
    get
  }
  public var fileSecurity: Foundation.NSFileSecurity? {
    get
    set
  }
  public var isExcludedFromBackup: Swift.Bool? {
    get
    set
  }
  public var tagNames: [Swift.String]? {
    get
  }
  public var path: Swift.String? {
    get
  }
  @available(macOS 10.12, iOS 10.0, tvOS 10.0, watchOS 3.0, *)
  public var canonicalPath: Swift.String? {
    get
  }
  public var isMountTrigger: Swift.Bool? {
    get
  }
  @available(macOS 10.10, iOS 8.0, *)
  public var generationIdentifier: (Foundation.NSCopying & Foundation.NSSecureCoding & ObjectiveC.NSObjectProtocol)? {
    get
  }
  @available(macOS 10.10, iOS 8.0, *)
  public var documentIdentifier: Swift.Int? {
    get
  }
  @available(macOS 10.10, iOS 8.0, *)
  public var addedToDirectoryDate: Foundation.Date? {
    get
  }
  @available(macOS 10.10, *)
  public var quarantineProperties: [Swift.String : Any]? {
    get
    set
  }
  @available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
  public var mayHaveExtendedAttributes: Swift.Bool? {
    get
  }
  @available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
  public var isPurgeable: Swift.Bool? {
    get
  }
  @available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
  public var isSparse: Swift.Bool? {
    get
  }
  @available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
  public var mayShareFileContent: Swift.Bool? {
    get
  }
  public var fileResourceType: Foundation.URLFileResourceType? {
    get
  }
  public var volumeLocalizedFormatDescription: Swift.String? {
    get
  }
  public var volumeTotalCapacity: Swift.Int? {
    get
  }
  public var volumeAvailableCapacity: Swift.Int? {
    get
  }
  @available(macOS 10.13, iOS 11.0, *)
  @available(tvOS, unavailable)
  @available(watchOS, unavailable)
  public var volumeAvailableCapacityForImportantUsage: Swift.Int64? {
    get
  }
  @available(macOS 10.13, iOS 11.0, *)
  @available(tvOS, unavailable)
  @available(watchOS, unavailable)
  public var volumeAvailableCapacityForOpportunisticUsage: Swift.Int64? {
    get
  }
  public var volumeResourceCount: Swift.Int? {
    get
  }
  public var volumeSupportsPersistentIDs: Swift.Bool? {
    get
  }
  public var volumeSupportsSymbolicLinks: Swift.Bool? {
    get
  }
  public var volumeSupportsHardLinks: Swift.Bool? {
    get
  }
  public var volumeSupportsJournaling: Swift.Bool? {
    get
  }
  public var volumeIsJournaling: Swift.Bool? {
    get
  }
  public var volumeSupportsSparseFiles: Swift.Bool? {
    get
  }
  public var volumeSupportsZeroRuns: Swift.Bool? {
    get
  }
  public var volumeSupportsCaseSensitiveNames: Swift.Bool? {
    get
  }
  public var volumeSupportsCasePreservedNames: Swift.Bool? {
    get
  }
  public var volumeSupportsRootDirectoryDates: Swift.Bool? {
    get
  }
  public var volumeSupportsVolumeSizes: Swift.Bool? {
    get
  }
  public var volumeSupportsRenaming: Swift.Bool? {
    get
  }
  public var volumeSupportsAdvisoryFileLocking: Swift.Bool? {
    get
  }
  public var volumeSupportsExtendedSecurity: Swift.Bool? {
    get
  }
  public var volumeIsBrowsable: Swift.Bool? {
    get
  }
  public var volumeMaximumFileSize: Swift.Int? {
    get
  }
  public var volumeIsEjectable: Swift.Bool? {
    get
  }
  public var volumeIsRemovable: Swift.Bool? {
    get
  }
  public var volumeIsInternal: Swift.Bool? {
    get
  }
  public var volumeIsAutomounted: Swift.Bool? {
    get
  }
  public var volumeIsLocal: Swift.Bool? {
    get
  }
  public var volumeIsReadOnly: Swift.Bool? {
    get
  }
  public var volumeCreationDate: Foundation.Date? {
    get
  }
  public var volumeURLForRemounting: Foundation.URL? {
    get
  }
  public var volumeUUIDString: Swift.String? {
    get
  }
  public var volumeName: Swift.String? {
    get
    set
  }
  public var volumeLocalizedName: Swift.String? {
    get
  }
  @available(macOS 10.12, iOS 10.0, tvOS 10.0, watchOS 3.0, *)
  public var volumeIsEncrypted: Swift.Bool? {
    get
  }
  @available(macOS 10.12, iOS 10.0, tvOS 10.0, watchOS 3.0, *)
  public var volumeIsRootFileSystem: Swift.Bool? {
    get
  }
  @available(macOS 10.12, iOS 10.0, tvOS 10.0, watchOS 3.0, *)
  public var volumeSupportsCompression: Swift.Bool? {
    get
  }
  @available(macOS 10.12, iOS 10.0, tvOS 10.0, watchOS 3.0, *)
  public var volumeSupportsFileCloning: Swift.Bool? {
    get
  }
  @available(macOS 10.12, iOS 10.0, tvOS 10.0, watchOS 3.0, *)
  public var volumeSupportsSwapRenaming: Swift.Bool? {
    get
  }
  @available(macOS 10.12, iOS 10.0, tvOS 10.0, watchOS 3.0, *)
  public var volumeSupportsExclusiveRenaming: Swift.Bool? {
    get
  }
  @available(macOS 10.13, iOS 11.0, tvOS 11.0, watchOS 4.0, *)
  public var volumeSupportsImmutableFiles: Swift.Bool? {
    get
  }
  @available(macOS 10.13, iOS 11.0, tvOS 11.0, watchOS 4.0, *)
  public var volumeSupportsAccessPermissions: Swift.Bool? {
    get
  }
  public var isUbiquitousItem: Swift.Bool? {
    get
  }
  public var ubiquitousItemHasUnresolvedConflicts: Swift.Bool? {
    get
  }
  public var ubiquitousItemIsDownloading: Swift.Bool? {
    get
  }
  public var ubiquitousItemIsUploaded: Swift.Bool? {
    get
  }
  public var ubiquitousItemIsUploading: Swift.Bool? {
    get
  }
  public var ubiquitousItemDownloadingStatus: Foundation.URLUbiquitousItemDownloadingStatus? {
    get
  }
  public var ubiquitousItemDownloadingError: Foundation.NSError? {
    get
  }
  public var ubiquitousItemUploadingError: Foundation.NSError? {
    get
  }
  @available(macOS 10.10, iOS 8.0, *)
  public var ubiquitousItemDownloadRequested: Swift.Bool? {
    get
  }
  @available(macOS 10.10, iOS 8.0, *)
  public var ubiquitousItemContainerDisplayName: Swift.String? {
    get
  }
  @available(macOS 11.3, iOS 14.5, watchOS 7.4, tvOS 14.5, *)
  public var ubiquitousItemIsExcludedFromSync: Swift.Bool? {
    get
    set
  }
  @available(macOS 10.13, iOS 11.0, *)
  @available(tvOS, unavailable)
  @available(watchOS, unavailable)
  public var ubiquitousItemIsShared: Swift.Bool? {
    get
  }
  @available(macOS 10.13, iOS 11.0, *)
  @available(tvOS, unavailable)
  @available(watchOS, unavailable)
  public var ubiquitousSharedItemCurrentUserRole: Foundation.URLUbiquitousSharedItemRole? {
    get
  }
  @available(macOS 10.13, iOS 11.0, *)
  @available(tvOS, unavailable)
  @available(watchOS, unavailable)
  public var ubiquitousSharedItemCurrentUserPermissions: Foundation.URLUbiquitousSharedItemPermissions? {
    get
  }
  @available(macOS 10.13, iOS 11.0, *)
  @available(tvOS, unavailable)
  @available(watchOS, unavailable)
  public var ubiquitousSharedItemOwnerNameComponents: Foundation.PersonNameComponents? {
    get
  }
  @available(macOS 10.13, iOS 11.0, *)
  @available(tvOS, unavailable)
  @available(watchOS, unavailable)
  public var ubiquitousSharedItemMostRecentEditorNameComponents: Foundation.PersonNameComponents? {
    get
  }
  @available(macOS 11.0, iOS 9.0, *)
  public var fileProtection: Foundation.URLFileProtection? {
    get
  }
  public var fileSize: Swift.Int? {
    get
  }
  public var fileAllocatedSize: Swift.Int? {
    get
  }
  public var totalFileSize: Swift.Int? {
    get
  }
  public var totalFileAllocatedSize: Swift.Int? {
    get
  }
  public var isAliasFile: Swift.Bool? {
    get
  }
}
public struct URL : Foundation.ReferenceConvertible, Swift.Equatable {
  public typealias ReferenceType = Foundation.NSURL
  public typealias BookmarkResolutionOptions = Foundation.NSURL.BookmarkResolutionOptions
  public typealias BookmarkCreationOptions = Foundation.NSURL.BookmarkCreationOptions
  public init?(string: __shared Swift.String)
  public init?(string: __shared Swift.String, relativeTo url: __shared Foundation.URL?)
  @available(macOS 10.11, iOS 9.0, *)
  public init(fileURLWithPath path: __shared Swift.String, isDirectory: Swift.Bool, relativeTo base: __shared Foundation.URL?)
  @available(macOS 10.11, iOS 9.0, *)
  public init(fileURLWithPath path: __shared Swift.String, relativeTo base: __shared Foundation.URL?)
  public init(fileURLWithPath path: __shared Swift.String, isDirectory: Swift.Bool)
  public init(fileURLWithPath path: __shared Swift.String)
  @available(macOS 10.11, iOS 9.0, *)
  public init?(dataRepresentation: __shared Foundation.Data, relativeTo url: __shared Foundation.URL?, isAbsolute: Swift.Bool = false)
  @available(swift, obsoleted: 4.2)
  public init?(resolvingBookmarkData data: __shared Foundation.Data, options: Foundation.URL.BookmarkResolutionOptions = [], relativeTo url: __shared Foundation.URL? = nil, bookmarkDataIsStale: inout Swift.Bool) throws
  @available(swift 4.2)
  public init(resolvingBookmarkData data: __shared Foundation.Data, options: Foundation.URL.BookmarkResolutionOptions = [], relativeTo url: __shared Foundation.URL? = nil, bookmarkDataIsStale: inout Swift.Bool) throws
  @available(macOS 10.10, iOS 8.0, *)
  public init(resolvingAliasFileAt url: __shared Foundation.URL, options: Foundation.URL.BookmarkResolutionOptions = []) throws
  public init(fileURLWithFileSystemRepresentation path: Swift.UnsafePointer<Swift.Int8>, isDirectory: Swift.Bool, relativeTo baseURL: __shared Foundation.URL?)
  public func hash(into hasher: inout Swift.Hasher)
  @available(macOS 10.11, iOS 9.0, *)
  public var dataRepresentation: Foundation.Data {
    get
  }
  public var absoluteString: Swift.String {
    get
  }
  public var relativeString: Swift.String {
    get
  }
  public var baseURL: Foundation.URL? {
    get
  }
  public var absoluteURL: Foundation.URL {
    get
  }
  public var scheme: Swift.String? {
    get
  }
  public var isFileURL: Swift.Bool {
    get
  }
  @available(*, unavailable, message: "Use `path`, `query`, and `fragment` instead")
  public var resourceSpecifier: Swift.String {
    get
  }
  public var host: Swift.String? {
    get
  }
  public var port: Swift.Int? {
    get
  }
  public var user: Swift.String? {
    get
  }
  public var password: Swift.String? {
    get
  }
  public var path: Swift.String {
    get
  }
  public var relativePath: Swift.String {
    get
  }
  public var fragment: Swift.String? {
    get
  }
  @available(*, unavailable, message: "use the 'path' property")
  public var parameterString: Swift.String? {
    get
  }
  public var query: Swift.String? {
    get
  }
  @available(macOS 10.11, iOS 9.0, *)
  public var hasDirectoryPath: Swift.Bool {
    get
  }
  @available(macOS 10.9, iOS 7.0, *)
  public func withUnsafeFileSystemRepresentation<ResultType>(_ block: (Swift.UnsafePointer<Swift.Int8>?) throws -> ResultType) rethrows -> ResultType
  public var pathComponents: [Swift.String] {
    get
  }
  public var lastPathComponent: Swift.String {
    get
  }
  public var pathExtension: Swift.String {
    get
  }
  public func appendingPathComponent(_ pathComponent: Swift.String, isDirectory: Swift.Bool) -> Foundation.URL
  public func appendingPathComponent(_ pathComponent: Swift.String) -> Foundation.URL
  public func deletingLastPathComponent() -> Foundation.URL
  public func appendingPathExtension(_ pathExtension: Swift.String) -> Foundation.URL
  public func deletingPathExtension() -> Foundation.URL
  public mutating func appendPathComponent(_ pathComponent: Swift.String, isDirectory: Swift.Bool)
  public mutating func appendPathComponent(_ pathComponent: Swift.String)
  public mutating func appendPathExtension(_ pathExtension: Swift.String)
  public mutating func deleteLastPathComponent()
  public mutating func deletePathExtension()
  public var standardized: Foundation.URL {
    get
  }
  public mutating func standardize()
  public var standardizedFileURL: Foundation.URL {
    get
  }
  public func resolvingSymlinksInPath() -> Foundation.URL
  public mutating func resolveSymlinksInPath()
  public func checkResourceIsReachable() throws -> Swift.Bool
  @available(macOS 10.10, iOS 8.0, *)
  public func checkPromisedItemIsReachable() throws -> Swift.Bool
  public mutating func setResourceValues(_ values: Foundation.URLResourceValues) throws
  public func resourceValues(forKeys keys: Swift.Set<Foundation.URLResourceKey>) throws -> Foundation.URLResourceValues
  public mutating func setTemporaryResourceValue(_ value: Any, forKey key: Foundation.URLResourceKey)
  public mutating func removeAllCachedResourceValues()
  public mutating func removeCachedResourceValue(forKey key: Foundation.URLResourceKey)
  @available(macOS 10.10, iOS 8.0, *)
  public func promisedItemResourceValues(forKeys keys: Swift.Set<Foundation.URLResourceKey>) throws -> Foundation.URLResourceValues
  @available(*, unavailable, message: "Use struct URLResourceValues and URL.setResourceValues(_:) instead")
  public func setResourceValue(_ value: Swift.AnyObject?, forKey key: Foundation.URLResourceKey) throws
  @available(*, unavailable, message: "Use struct URLResourceValues and URL.setResourceValues(_:) instead")
  public func setResourceValues(_ keyedValues: [Foundation.URLResourceKey : Swift.AnyObject]) throws
  @available(*, unavailable, message: "Use struct URLResourceValues and URL.setResourceValues(_:) instead")
  public func getResourceValue(_ value: Swift.AutoreleasingUnsafeMutablePointer<Swift.AnyObject?>, forKey key: Foundation.URLResourceKey) throws
  public func bookmarkData(options: Foundation.URL.BookmarkCreationOptions = [], includingResourceValuesForKeys keys: Swift.Set<Foundation.URLResourceKey>? = nil, relativeTo url: Foundation.URL? = nil) throws -> Foundation.Data
  public static func resourceValues(forKeys keys: Swift.Set<Foundation.URLResourceKey>, fromBookmarkData data: Foundation.Data) -> Foundation.URLResourceValues?
  public static func writeBookmarkData(_ data: Foundation.Data, to url: Foundation.URL) throws
  public static func bookmarkData(withContentsOf url: Foundation.URL) throws -> Foundation.Data
  @available(macOS 10.7, iOS 8.0, *)
  public func startAccessingSecurityScopedResource() -> Swift.Bool
  @available(macOS 10.7, iOS 8.0, *)
  public func stopAccessingSecurityScopedResource()
  public static func == (lhs: Foundation.URL, rhs: Foundation.URL) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
extension Foundation.URL : Swift._ObjectiveCBridgeable {
  @_semantics("convertToObjectiveC") public func _bridgeToObjectiveC() -> Foundation.NSURL
  public static func _forceBridgeFromObjectiveC(_ source: Foundation.NSURL, result: inout Foundation.URL?)
  public static func _conditionallyBridgeFromObjectiveC(_ source: Foundation.NSURL, result: inout Foundation.URL?) -> Swift.Bool
  @_effects(readonly) public static func _unconditionallyBridgeFromObjectiveC(_ source: Foundation.NSURL?) -> Foundation.URL
  public typealias _ObjectiveCType = Foundation.NSURL
}
extension Foundation.URL : Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible {
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
}
extension Foundation.NSURL : Swift._HasCustomAnyHashableRepresentation {
  @nonobjc public func _toCustomAnyHashable() -> Swift.AnyHashable?
}
extension Foundation.URL : Swift._CustomPlaygroundQuickLookable {
  @available(*, deprecated, message: "URL.customPlaygroundQuickLook will be removed in a future Swift version")
  public var customPlaygroundQuickLook: Swift.PlaygroundQuickLook {
    get
  }
}
extension Foundation.URL : Swift.Codable {
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
extension Foundation.URL : Swift._ExpressibleByFileReferenceLiteral {
  public init(fileReferenceLiteralResourceName name: Swift.String)
}
public typealias _FileReferenceLiteralType = Foundation.URL
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Foundation.URLSession {
  public func dataTaskPublisher(for url: Foundation.URL) -> Foundation.URLSession.DataTaskPublisher
  public func dataTaskPublisher(for request: Foundation.URLRequest) -> Foundation.URLSession.DataTaskPublisher
  public struct DataTaskPublisher : Combine.Publisher {
    public typealias Output = (data: Foundation.Data, response: Foundation.URLResponse)
    public typealias Failure = Foundation.URLError
    public let request: Foundation.URLRequest
    public let session: Foundation.URLSession
    public init(request: Foundation.URLRequest, session: Foundation.URLSession)
    public func receive<S>(subscriber: S) where S : Combine.Subscriber, S.Failure == Foundation.URLSession.DataTaskPublisher.Failure, S.Input == Foundation.URLSession.DataTaskPublisher.Output
  }
}
@_objcRuntimeName(_TtC10Foundation13__JSONEncoder) open class JSONEncoder {
  public struct OutputFormatting : Swift.OptionSet {
    public let rawValue: Swift.UInt
    public init(rawValue: Swift.UInt)
    public static let prettyPrinted: Foundation.JSONEncoder.OutputFormatting
    @available(macOS 10.13, iOS 11.0, watchOS 4.0, tvOS 11.0, *)
    public static let sortedKeys: Foundation.JSONEncoder.OutputFormatting
    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    public static let withoutEscapingSlashes: Foundation.JSONEncoder.OutputFormatting
    public typealias ArrayLiteralElement = Foundation.JSONEncoder.OutputFormatting
    public typealias Element = Foundation.JSONEncoder.OutputFormatting
    public typealias RawValue = Swift.UInt
  }
  public enum DateEncodingStrategy {
    case deferredToDate
    case secondsSince1970
    case millisecondsSince1970
    @available(macOS 10.12, iOS 10.0, watchOS 3.0, tvOS 10.0, *)
    case iso8601
    case formatted(Foundation.DateFormatter)
    case custom((Foundation.Date, Swift.Encoder) throws -> Swift.Void)
  }
  public enum DataEncodingStrategy {
    case deferredToData
    case base64
    case custom((Foundation.Data, Swift.Encoder) throws -> Swift.Void)
  }
  public enum NonConformingFloatEncodingStrategy {
    case `throw`
    case convertToString(positiveInfinity: Swift.String, negativeInfinity: Swift.String, nan: Swift.String)
  }
  public enum KeyEncodingStrategy {
    case useDefaultKeys
    case convertToSnakeCase
    case custom((_ codingPath: [Swift.CodingKey]) -> Swift.CodingKey)
  }
  open var outputFormatting: Foundation.JSONEncoder.OutputFormatting
  open var dateEncodingStrategy: Foundation.JSONEncoder.DateEncodingStrategy
  open var dataEncodingStrategy: Foundation.JSONEncoder.DataEncodingStrategy
  open var nonConformingFloatEncodingStrategy: Foundation.JSONEncoder.NonConformingFloatEncodingStrategy
  open var keyEncodingStrategy: Foundation.JSONEncoder.KeyEncodingStrategy
  open var userInfo: [Swift.CodingUserInfoKey : Any]
  public init()
  open func encode<T>(_ value: T) throws -> Foundation.Data where T : Swift.Encodable
  @objc deinit
}
@_objcRuntimeName(_TtC10Foundation13__JSONDecoder) open class JSONDecoder {
  public enum DateDecodingStrategy {
    case deferredToDate
    case secondsSince1970
    case millisecondsSince1970
    @available(macOS 10.12, iOS 10.0, watchOS 3.0, tvOS 10.0, *)
    case iso8601
    case formatted(Foundation.DateFormatter)
    case custom((_ decoder: Swift.Decoder) throws -> Foundation.Date)
  }
  public enum DataDecodingStrategy {
    case deferredToData
    case base64
    case custom((_ decoder: Swift.Decoder) throws -> Foundation.Data)
  }
  public enum NonConformingFloatDecodingStrategy {
    case `throw`
    case convertFromString(positiveInfinity: Swift.String, negativeInfinity: Swift.String, nan: Swift.String)
  }
  public enum KeyDecodingStrategy {
    case useDefaultKeys
    case convertFromSnakeCase
    case custom((_ codingPath: [Swift.CodingKey]) -> Swift.CodingKey)
  }
  open var dateDecodingStrategy: Foundation.JSONDecoder.DateDecodingStrategy
  open var dataDecodingStrategy: Foundation.JSONDecoder.DataDecodingStrategy
  open var nonConformingFloatDecodingStrategy: Foundation.JSONDecoder.NonConformingFloatDecodingStrategy
  open var keyDecodingStrategy: Foundation.JSONDecoder.KeyDecodingStrategy
  open var userInfo: [Swift.CodingUserInfoKey : Any]
  @available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
  open var allowsJSON5: Swift.Bool {
    get
    set
  }
  @available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
  open var assumesTopLevelDictionary: Swift.Bool {
    get
    set
  }
  public init()
  open func decode<T>(_ type: T.Type, from data: Foundation.Data) throws -> T where T : Swift.Decodable
  @objc deinit
}
extension Foundation.NSDate : Swift._CustomPlaygroundQuickLookable {
  @available(*, deprecated, message: "NSDate.customPlaygroundQuickLook will be removed in a future Swift version")
  public var customPlaygroundQuickLook: Swift.PlaygroundQuickLook {
    get
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
public struct IntegerFormatStyle<Value> : Swift.Codable, Swift.Hashable where Value : Swift.BinaryInteger {
  public var locale: Foundation.Locale
  public init(locale: Foundation.Locale = .autoupdatingCurrent)
  public var attributed: Foundation.IntegerFormatStyle<Value>.Attributed {
    get
  }
  public typealias Configuration = Foundation.NumberFormatStyleConfiguration
  public func grouping(_ group: Foundation.IntegerFormatStyle<Value>.Configuration.Grouping) -> Foundation.IntegerFormatStyle<Value>
  public func precision(_ p: Foundation.IntegerFormatStyle<Value>.Configuration.Precision) -> Foundation.IntegerFormatStyle<Value>
  public func sign(strategy: Foundation.IntegerFormatStyle<Value>.Configuration.SignDisplayStrategy) -> Foundation.IntegerFormatStyle<Value>
  public func decimalSeparator(strategy: Foundation.IntegerFormatStyle<Value>.Configuration.DecimalSeparatorDisplayStrategy) -> Foundation.IntegerFormatStyle<Value>
  public func rounded(rule: Foundation.IntegerFormatStyle<Value>.Configuration.RoundingRule = .toNearestOrEven, increment: Swift.Int? = nil) -> Foundation.IntegerFormatStyle<Value>
  public func scale(_ multiplicand: Swift.Double) -> Foundation.IntegerFormatStyle<Value>
  public func notation(_ notation: Foundation.IntegerFormatStyle<Value>.Configuration.Notation) -> Foundation.IntegerFormatStyle<Value>
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: Foundation.IntegerFormatStyle<Value>, b: Foundation.IntegerFormatStyle<Value>) -> Swift.Bool
  public func encode(to encoder: Swift.Encoder) throws
  public var hashValue: Swift.Int {
    get
  }
  public init(from decoder: Swift.Decoder) throws
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.IntegerFormatStyle {
  public struct Percent : Swift.Codable, Swift.Hashable {
    public var locale: Foundation.Locale
    public init(locale: Foundation.Locale = .autoupdatingCurrent)
    public var attributed: Foundation.IntegerFormatStyle<Value>.Attributed {
      get
    }
    public typealias Configuration = Foundation.NumberFormatStyleConfiguration
    public func grouping(_ group: Foundation.IntegerFormatStyle<Value>.Percent.Configuration.Grouping) -> Foundation.IntegerFormatStyle<Value>.Percent
    public func precision(_ p: Foundation.IntegerFormatStyle<Value>.Percent.Configuration.Precision) -> Foundation.IntegerFormatStyle<Value>.Percent
    public func sign(strategy: Foundation.IntegerFormatStyle<Value>.Percent.Configuration.SignDisplayStrategy) -> Foundation.IntegerFormatStyle<Value>.Percent
    public func decimalSeparator(strategy: Foundation.IntegerFormatStyle<Value>.Percent.Configuration.DecimalSeparatorDisplayStrategy) -> Foundation.IntegerFormatStyle<Value>.Percent
    public func rounded(rule: Foundation.IntegerFormatStyle<Value>.Percent.Configuration.RoundingRule = .toNearestOrEven, increment: Swift.Int? = nil) -> Foundation.IntegerFormatStyle<Value>.Percent
    public func scale(_ multiplicand: Swift.Double) -> Foundation.IntegerFormatStyle<Value>.Percent
    public func notation(_ notation: Foundation.IntegerFormatStyle<Value>.Percent.Configuration.Notation) -> Foundation.IntegerFormatStyle<Value>.Percent
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: Foundation.IntegerFormatStyle<Value>.Percent, b: Foundation.IntegerFormatStyle<Value>.Percent) -> Swift.Bool
    public func encode(to encoder: Swift.Encoder) throws
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: Swift.Decoder) throws
  }
  @available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
  public struct Currency : Swift.Codable, Swift.Hashable {
    public typealias Configuration = Foundation.CurrencyFormatStyleConfiguration
    public var locale: Foundation.Locale
    public let currencyCode: Swift.String
    public init(code: Swift.String, locale: Foundation.Locale = .autoupdatingCurrent)
    public var attributed: Foundation.IntegerFormatStyle<Value>.Attributed {
      get
    }
    public func grouping(_ group: Foundation.IntegerFormatStyle<Value>.Currency.Configuration.Grouping) -> Foundation.IntegerFormatStyle<Value>.Currency
    public func precision(_ p: Foundation.IntegerFormatStyle<Value>.Currency.Configuration.Precision) -> Foundation.IntegerFormatStyle<Value>.Currency
    public func sign(strategy: Foundation.IntegerFormatStyle<Value>.Currency.Configuration.SignDisplayStrategy) -> Foundation.IntegerFormatStyle<Value>.Currency
    public func decimalSeparator(strategy: Foundation.IntegerFormatStyle<Value>.Currency.Configuration.DecimalSeparatorDisplayStrategy) -> Foundation.IntegerFormatStyle<Value>.Currency
    public func rounded(rule: Foundation.IntegerFormatStyle<Value>.Currency.Configuration.RoundingRule = .toNearestOrEven, increment: Swift.Int? = nil) -> Foundation.IntegerFormatStyle<Value>.Currency
    public func scale(_ multiplicand: Swift.Double) -> Foundation.IntegerFormatStyle<Value>.Currency
    public func presentation(_ p: Foundation.IntegerFormatStyle<Value>.Currency.Configuration.Presentation) -> Foundation.IntegerFormatStyle<Value>.Currency
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: Foundation.IntegerFormatStyle<Value>.Currency, b: Foundation.IntegerFormatStyle<Value>.Currency) -> Swift.Bool
    public func encode(to encoder: Swift.Encoder) throws
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: Swift.Decoder) throws
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.IntegerFormatStyle : Foundation.FormatStyle {
  @available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
  public func format(_ value: Value) -> Swift.String
  public func locale(_ locale: Foundation.Locale) -> Foundation.IntegerFormatStyle<Value>
  public typealias FormatInput = Value
  public typealias FormatOutput = Swift.String
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.IntegerFormatStyle.Percent : Foundation.FormatStyle {
  @available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
  public func format(_ value: Value) -> Swift.String
  public func locale(_ locale: Foundation.Locale) -> Foundation.IntegerFormatStyle<Value>.Percent
  public typealias FormatInput = Value
  public typealias FormatOutput = Swift.String
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.IntegerFormatStyle.Currency : Foundation.FormatStyle {
  @available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
  public func format(_ value: Value) -> Swift.String
  public func locale(_ locale: Foundation.Locale) -> Foundation.IntegerFormatStyle<Value>.Currency
  public typealias FormatInput = Value
  public typealias FormatOutput = Swift.String
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.IntegerFormatStyle : Foundation.ParseableFormatStyle {
  public var parseStrategy: Foundation.IntegerParseStrategy<Foundation.IntegerFormatStyle<Value>> {
    get
  }
  public typealias Strategy = Foundation.IntegerParseStrategy<Foundation.IntegerFormatStyle<Value>>
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.IntegerFormatStyle.Currency : Foundation.ParseableFormatStyle {
  public var parseStrategy: Foundation.IntegerParseStrategy<Foundation.IntegerFormatStyle<Value>.Currency> {
    get
  }
  public typealias Strategy = Foundation.IntegerParseStrategy<Foundation.IntegerFormatStyle<Value>.Currency>
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.IntegerFormatStyle.Percent : Foundation.ParseableFormatStyle {
  public var parseStrategy: Foundation.IntegerParseStrategy<Foundation.IntegerFormatStyle<Value>.Percent> {
    get
  }
  public typealias Strategy = Foundation.IntegerParseStrategy<Foundation.IntegerFormatStyle<Value>.Percent>
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.FormatStyle where Self == Foundation.IntegerFormatStyle<Swift.Int> {
  @_alwaysEmitIntoClient public static var number: Foundation.IntegerFormatStyle<Swift.Int> {
    get { Self() }
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.FormatStyle where Self == Foundation.IntegerFormatStyle<Swift.Int16> {
  @_alwaysEmitIntoClient public static var number: Foundation.IntegerFormatStyle<Swift.Int16> {
    get { Self() }
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.FormatStyle where Self == Foundation.IntegerFormatStyle<Swift.Int32> {
  @_alwaysEmitIntoClient public static var number: Foundation.IntegerFormatStyle<Swift.Int32> {
    get { Self() }
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.FormatStyle where Self == Foundation.IntegerFormatStyle<Swift.Int64> {
  @_alwaysEmitIntoClient public static var number: Foundation.IntegerFormatStyle<Swift.Int64> {
    get { Self() }
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.FormatStyle where Self == Foundation.IntegerFormatStyle<Swift.Int8> {
  @_alwaysEmitIntoClient public static var number: Foundation.IntegerFormatStyle<Swift.Int8> {
    get { Self() }
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.FormatStyle where Self == Foundation.IntegerFormatStyle<Swift.UInt> {
  @_alwaysEmitIntoClient public static var number: Foundation.IntegerFormatStyle<Swift.UInt> {
    get { Self() }
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.FormatStyle where Self == Foundation.IntegerFormatStyle<Swift.UInt16> {
  @_alwaysEmitIntoClient public static var number: Foundation.IntegerFormatStyle<Swift.UInt16> {
    get { Self() }
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.FormatStyle where Self == Foundation.IntegerFormatStyle<Swift.UInt32> {
  @_alwaysEmitIntoClient public static var number: Foundation.IntegerFormatStyle<Swift.UInt32> {
    get { Self() }
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.FormatStyle where Self == Foundation.IntegerFormatStyle<Swift.UInt64> {
  @_alwaysEmitIntoClient public static var number: Foundation.IntegerFormatStyle<Swift.UInt64> {
    get { Self() }
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.FormatStyle where Self == Foundation.IntegerFormatStyle<Swift.UInt8> {
  @_alwaysEmitIntoClient public static var number: Foundation.IntegerFormatStyle<Swift.UInt8> {
    get { Self() }
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.FormatStyle where Self == Foundation.IntegerFormatStyle<Swift.Int>.Percent {
  @_alwaysEmitIntoClient public static var percent: Foundation.IntegerFormatStyle<Swift.Int>.Percent {
    get { Self() }
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.FormatStyle where Self == Foundation.IntegerFormatStyle<Swift.Int16>.Percent {
  @_alwaysEmitIntoClient public static var percent: Foundation.IntegerFormatStyle<Swift.Int16>.Percent {
    get { Self() }
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.FormatStyle where Self == Foundation.IntegerFormatStyle<Swift.Int32>.Percent {
  @_alwaysEmitIntoClient public static var percent: Foundation.IntegerFormatStyle<Swift.Int32>.Percent {
    get { Self() }
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.FormatStyle where Self == Foundation.IntegerFormatStyle<Swift.Int64>.Percent {
  @_alwaysEmitIntoClient public static var percent: Foundation.IntegerFormatStyle<Swift.Int64>.Percent {
    get { Self() }
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.FormatStyle where Self == Foundation.IntegerFormatStyle<Swift.Int8>.Percent {
  @_alwaysEmitIntoClient public static var percent: Foundation.IntegerFormatStyle<Swift.Int8>.Percent {
    get { Self() }
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.FormatStyle where Self == Foundation.IntegerFormatStyle<Swift.UInt>.Percent {
  @_alwaysEmitIntoClient public static var percent: Foundation.IntegerFormatStyle<Swift.UInt>.Percent {
    get { Self() }
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.FormatStyle where Self == Foundation.IntegerFormatStyle<Swift.UInt16>.Percent {
  @_alwaysEmitIntoClient public static var percent: Foundation.IntegerFormatStyle<Swift.UInt16>.Percent {
    get { Self() }
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.FormatStyle where Self == Foundation.IntegerFormatStyle<Swift.UInt32>.Percent {
  @_alwaysEmitIntoClient public static var percent: Foundation.IntegerFormatStyle<Swift.UInt32>.Percent {
    get { Self() }
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.FormatStyle where Self == Foundation.IntegerFormatStyle<Swift.UInt64>.Percent {
  @_alwaysEmitIntoClient public static var percent: Foundation.IntegerFormatStyle<Swift.UInt64>.Percent {
    get { Self() }
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.FormatStyle where Self == Foundation.IntegerFormatStyle<Swift.UInt8>.Percent {
  @_alwaysEmitIntoClient public static var percent: Foundation.IntegerFormatStyle<Swift.UInt8>.Percent {
    get { Self() }
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.FormatStyle {
  public static func currency<V>(code: Swift.String) -> Self where Self == Foundation.IntegerFormatStyle<V>.Currency, V : Swift.BinaryInteger
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.IntegerFormatStyle {
  public struct Attributed : Swift.Codable, Swift.Hashable, Foundation.FormatStyle {
    public func format(_ value: Value) -> Foundation.AttributedString
    public func locale(_ locale: Foundation.Locale) -> Foundation.IntegerFormatStyle<Value>.Attributed
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: Foundation.IntegerFormatStyle<Value>.Attributed, b: Foundation.IntegerFormatStyle<Value>.Attributed) -> Swift.Bool
    public typealias FormatInput = Value
    public typealias FormatOutput = Foundation.AttributedString
    public func encode(to encoder: Swift.Encoder) throws
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: Swift.Decoder) throws
  }
}
extension Foundation.FileManager {
  @available(*, deprecated, renamed: "replaceItemAt(_:withItemAt:backupItemName:options:)")
  public func replaceItemAtURL(originalItemURL: Foundation.NSURL, withItemAtURL newItemURL: Foundation.NSURL, backupItemName: Swift.String? = nil, options: Foundation.FileManager.ItemReplacementOptions = []) throws -> Foundation.NSURL?
  @available(macOS 10.6, iOS 4.0, *)
  @available(swift, obsoleted: 4)
  public func replaceItemAt(_ originalItemURL: Foundation.URL, withItemAt newItemURL: Foundation.URL, backupItemName: Swift.String? = nil, options: Foundation.FileManager.ItemReplacementOptions = []) throws -> Foundation.NSURL?
  @available(swift 4)
  @available(macOS 10.6, iOS 4.0, *)
  public func replaceItemAt(_ originalItemURL: Foundation.URL, withItemAt newItemURL: Foundation.URL, backupItemName: Swift.String? = nil, options: Foundation.FileManager.ItemReplacementOptions = []) throws -> Foundation.URL?
  @available(macOS 10.6, iOS 4.0, *)
  @nonobjc public func enumerator(at url: Foundation.URL, includingPropertiesForKeys keys: [Foundation.URLResourceKey]?, options mask: Foundation.FileManager.DirectoryEnumerationOptions = [], errorHandler handler: ((Foundation.URL, Swift.Error) -> Swift.Bool)? = nil) -> Foundation.FileManager.DirectoryEnumerator?
}
extension Foundation.NSExpression {
  convenience public init(format expressionFormat: __shared Swift.String, _ args: Swift.CVarArg...)
}
extension Foundation.NSExpression {
  convenience public init<Root, Value>(forKeyPath keyPath: Swift.KeyPath<Root, Value>)
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
public struct KeyPathComparator<Compared> : Foundation.SortComparator {
  public let keyPath: Swift.PartialKeyPath<Compared>
  public var order: Foundation.SortOrder {
    get
    set
  }
  public init<Value>(_ keyPath: Swift.KeyPath<Compared, Value>, order: Foundation.SortOrder = .forward) where Value : Swift.Comparable
  public init<Value>(_ keyPath: Swift.KeyPath<Compared, Value?>, order: Foundation.SortOrder = .forward) where Value : Swift.Comparable
  public init<Value, Comparator>(_ keyPath: Swift.KeyPath<Compared, Value>, comparator: Comparator) where Value == Comparator.Compared, Comparator : Foundation.SortComparator
  public init<Value, Comparator>(_ keyPath: Swift.KeyPath<Compared, Value?>, comparator: Comparator) where Value == Comparator.Compared, Comparator : Foundation.SortComparator
  public init<Value, Comparator>(_ keyPath: Swift.KeyPath<Compared, Value>, comparator: Comparator, order: Foundation.SortOrder) where Value == Comparator.Compared, Comparator : Foundation.SortComparator
  public init<Value, Comparator>(_ keyPath: Swift.KeyPath<Compared, Value?>, comparator: Comparator, order: Foundation.SortOrder) where Value == Comparator.Compared, Comparator : Foundation.SortComparator
  public func compare(_ lhs: Compared, _ rhs: Compared) -> Foundation.ComparisonResult
  public static func == (lhs: Foundation.KeyPathComparator<Compared>, rhs: Foundation.KeyPathComparator<Compared>) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension Foundation.NSData : Foundation.DataProtocol {
  @nonobjc public var startIndex: Swift.Int {
    get
  }
  @nonobjc public var endIndex: Swift.Int {
    get
  }
  @nonobjc public func lastRange<D, R>(of data: D, in r: R) -> Swift.Range<Swift.Int>? where D : Foundation.DataProtocol, R : Swift.RangeExpression, R.Bound == Foundation.NSData.Index
  @nonobjc public func firstRange<D, R>(of data: D, in r: R) -> Swift.Range<Swift.Int>? where D : Foundation.DataProtocol, R : Swift.RangeExpression, R.Bound == Foundation.NSData.Index
  @nonobjc public var regions: [Foundation.Data] {
    get
  }
  @nonobjc public subscript(position: Swift.Int) -> Swift.UInt8 {
    get
  }
  public typealias Element = Swift.UInt8
  public typealias Index = Swift.Int
  public typealias Indices = Swift.Range<Swift.Int>
  public typealias Iterator = Swift.IndexingIterator<Foundation.NSData>
  public typealias Regions = [Foundation.Data]
  public typealias SubSequence = Swift.Slice<Foundation.NSData>
}
extension Foundation.NSCoder {
  @available(*, unavailable, renamed: "decodeObject(of:forKey:)")
  public func decodeObjectOfClass<DecodedObjectType>(_ cls: DecodedObjectType.Type, forKey key: Swift.String) -> DecodedObjectType? where DecodedObjectType : ObjectiveC.NSObject, DecodedObjectType : Foundation.NSCoding
  public func decodeObject<DecodedObjectType>(of cls: DecodedObjectType.Type, forKey key: Swift.String) -> DecodedObjectType? where DecodedObjectType : ObjectiveC.NSObject, DecodedObjectType : Foundation.NSCoding
  @available(*, unavailable, renamed: "decodeObject(of:forKey:)")
  @nonobjc public func decodeObjectOfClasses(_ classes: Foundation.NSSet?, forKey key: Swift.String) -> Swift.AnyObject?
  @nonobjc public func decodeObject(of classes: [Swift.AnyClass]?, forKey key: Swift.String) -> Any?
  @available(macOS 10.11, iOS 9.0, *)
  @available(macOS, introduced: 10.11, deprecated: 100000.0, message: "Use decodeTopLevelObject(of:forKey:) instead")
  @available(iOS, introduced: 9.0, deprecated: 100000.0, message: "Use decodeTopLevelObject(of:forKey:) instead")
  @available(tvOS, introduced: 9.0, deprecated: 100000.0, message: "Use decodeTopLevelObject(of:forKey:) instead")
  @available(watchOS, introduced: 2.0, deprecated: 100000.0, message: "Use decodeTopLevelObject(of:forKey:) instead")
  @nonobjc public func decodeTopLevelObject() throws -> Any?
  @available(*, unavailable, renamed: "decodeTopLevelObject(forKey:)")
  public func decodeTopLevelObjectForKey(_ key: Swift.String) throws -> Swift.AnyObject?
  @available(macOS 10.11, iOS 9.0, *)
  @available(swift, obsoleted: 4)
  @available(macOS, introduced: 10.11, deprecated: 100000.0, message: "Use decodeTopLevelObject(of:forKey:) instead")
  @available(iOS, introduced: 9.0, deprecated: 100000.0, message: "Use decodeTopLevelObject(of:forKey:) instead")
  @available(tvOS, introduced: 9.0, deprecated: 100000.0, message: "Use decodeTopLevelObject(of:forKey:) instead")
  @available(watchOS, introduced: 2.0, deprecated: 100000.0, message: "Use decodeTopLevelObject(of:forKey:) instead")
  @nonobjc public func decodeTopLevelObject(forKey key: Swift.String) throws -> Swift.AnyObject?
  @available(swift 4)
  @available(macOS 10.11, iOS 9.0, *)
  @available(macOS, introduced: 10.11, deprecated: 100000.0, message: "Use decodeTopLevelObject(of:forKey:) instead")
  @available(iOS, introduced: 9.0, deprecated: 100000.0, message: "Use decodeTopLevelObject(of:forKey:) instead")
  @available(tvOS, introduced: 9.0, deprecated: 100000.0, message: "Use decodeTopLevelObject(of:forKey:) instead")
  @available(watchOS, introduced: 2.0, deprecated: 100000.0, message: "Use decodeTopLevelObject(of:forKey:) instead")
  @nonobjc public func decodeTopLevelObject(forKey key: Swift.String) throws -> Any?
  @available(*, unavailable, renamed: "decodeTopLevelObject(of:forKey:)")
  public func decodeTopLevelObjectOfClass<DecodedObjectType>(_ cls: DecodedObjectType.Type, forKey key: Swift.String) throws -> DecodedObjectType? where DecodedObjectType : ObjectiveC.NSObject, DecodedObjectType : Foundation.NSCoding
  @available(macOS 10.11, iOS 9.0, *)
  public func decodeTopLevelObject<DecodedObjectType>(of cls: DecodedObjectType.Type, forKey key: Swift.String) throws -> DecodedObjectType? where DecodedObjectType : ObjectiveC.NSObject, DecodedObjectType : Foundation.NSCoding
  @available(*, unavailable, renamed: "decodeTopLevelObject(of:forKey:)")
  @nonobjc public func decodeTopLevelObjectOfClasses(_ classes: Foundation.NSSet?, forKey key: Swift.String) throws -> Swift.AnyObject?
  @available(macOS 10.11, iOS 9.0, *)
  @nonobjc public func decodeTopLevelObject(of classes: [Swift.AnyClass]?, forKey key: Swift.String) throws -> Any?
  @available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
  @nonobjc public func decodeArrayOfObjects<DecodedObject>(ofClass cls: DecodedObject.Type, forKey key: Swift.String) -> [DecodedObject]? where DecodedObject : ObjectiveC.NSObject, DecodedObject : Foundation.NSSecureCoding
  @available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
  @nonobjc public func decodeArrayOfObjects(ofClasses classes: [Swift.AnyClass], forKey key: Swift.String) -> [Any]?
  @available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
  @nonobjc public func decodeDictionary<DecodedKey, DecodedObject>(withKeyClass keyClass: DecodedKey.Type, objectClass: DecodedObject.Type, forKey key: Swift.String) -> [DecodedKey : DecodedObject]? where DecodedKey : ObjectiveC.NSObject, DecodedKey : Foundation.NSCopying, DecodedKey : Foundation.NSSecureCoding, DecodedObject : ObjectiveC.NSObject, DecodedObject : Foundation.NSSecureCoding
  @available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
  @nonobjc public func decodeDictionary(withKeysOfClasses keyClasses: [Swift.AnyClass], objectsOfClasses classes: [Swift.AnyClass], forKey key: Swift.String) -> [Swift.AnyHashable : Any]?
}
extension Foundation.NSKeyedArchiver {
  @available(macOS 10.11, iOS 9.0, *)
  @nonobjc public func encodeEncodable<T>(_ value: T, forKey key: Swift.String) throws where T : Swift.Encodable
}
extension Foundation.NSKeyedUnarchiver {
  @available(macOS 10.11, iOS 9.0, *)
  @available(swift, obsoleted: 4)
  @available(macOS, introduced: 10.11, deprecated: 100000.0, message: "Use unarchivedObject(ofClass:from:) instead")
  @available(iOS, introduced: 9.0, deprecated: 100000.0, message: "Use unarchivedObject(ofClass:from:) instead")
  @available(tvOS, introduced: 9.0, deprecated: 100000.0, message: "Use unarchivedObject(ofClass:from:) instead")
  @available(watchOS, introduced: 2.0, deprecated: 100000.0, message: "Use unarchivedObject(ofClass:from:) instead")
  @nonobjc public class func unarchiveTopLevelObjectWithData(_ data: Foundation.NSData) throws -> Swift.AnyObject?
  @available(swift 4)
  @available(macOS 10.11, iOS 9.0, *)
  @available(macOS, introduced: 10.11, deprecated: 100000.0, message: "Use unarchivedObject(ofClass:from:) instead")
  @available(iOS, introduced: 9.0, deprecated: 100000.0, message: "Use unarchivedObject(ofClass:from:) instead")
  @available(tvOS, introduced: 9.0, deprecated: 100000.0, message: "Use unarchivedObject(ofClass:from:) instead")
  @available(watchOS, introduced: 2.0, deprecated: 100000.0, message: "Use unarchivedObject(ofClass:from:) instead")
  @nonobjc public class func unarchiveTopLevelObjectWithData(_ data: Foundation.Data) throws -> Any?
  @available(macOS 10.13, iOS 11.0, watchOS 4.0, tvOS 11.0, *)
  @nonobjc public static func unarchivedObject<DecodedObjectType>(ofClass cls: DecodedObjectType.Type, from data: Foundation.Data) throws -> DecodedObjectType? where DecodedObjectType : ObjectiveC.NSObject, DecodedObjectType : Foundation.NSCoding
  @available(macOS 10.13, iOS 11.0, watchOS 4.0, tvOS 11.0, *)
  @nonobjc public static func unarchivedObject(ofClasses classes: [Swift.AnyClass], from data: Foundation.Data) throws -> Any?
  @available(macOS 10.11, iOS 9.0, *)
  @nonobjc public func decodeDecodable<T>(_ type: T.Type, forKey key: Swift.String) -> T? where T : Swift.Decodable
  @available(macOS 10.11, iOS 9.0, *)
  @nonobjc public func decodeTopLevelDecodable<T>(_ type: T.Type, forKey key: Swift.String) throws -> T? where T : Swift.Decodable
  @available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
  @nonobjc public static func unarchivedArrayOfObjects<DecodedObject>(ofClass cls: DecodedObject.Type, from data: Foundation.Data) throws -> [DecodedObject]? where DecodedObject : ObjectiveC.NSObject, DecodedObject : Foundation.NSSecureCoding
  @available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
  @nonobjc public static func unarchivedArrayOfObjects(ofClasses classes: [Swift.AnyClass], from data: Foundation.Data) throws -> [Any]?
  @available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
  @nonobjc public static func unarchivedDictionary<DecodedKey, DecodedObject>(ofKeyClass keyClass: DecodedKey.Type, objectClass: DecodedObject.Type, from data: Foundation.Data) throws -> [DecodedKey : DecodedObject]? where DecodedKey : ObjectiveC.NSObject, DecodedKey : Foundation.NSCopying, DecodedKey : Foundation.NSSecureCoding, DecodedObject : ObjectiveC.NSObject, DecodedObject : Foundation.NSSecureCoding
  @available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
  @nonobjc public static func unarchivedDictionary(keysOfClasses keyClasses: [Swift.AnyClass], objectsOfClasses objectClasses: [Swift.AnyClass], from data: Foundation.Data) throws -> [Swift.AnyHashable : Any]?
}

#if compiler(>=5.3) && $RethrowsProtocol
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
public struct AsyncLineSequence<Base> : _Concurrency.AsyncSequence where Base : _Concurrency.AsyncSequence, Base.Element == Swift.UInt8 {
  public typealias Element = Swift.String
  public struct AsyncIterator : _Concurrency.AsyncIteratorProtocol {
    public typealias Element = Swift.String
    
    #if compiler(>=5.3) && $AsyncAwait
    @_specialize(exported: false, kind: full, where Base == Foundation.URL.AsyncBytes)
    @_specialize(exported: false, kind: full, where Base == Foundation.FileHandle.AsyncBytes)
    @_specialize(exported: false, kind: full, where Base == Foundation.URLSession.AsyncBytes)
    public mutating func next() async rethrows -> Swift.String?
    #endif

  }
  public func makeAsyncIterator() -> Foundation.AsyncLineSequence<Base>.AsyncIterator
}
#endif


#if compiler(>=5.3) && $RethrowsProtocol
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension _Concurrency.AsyncSequence where Self.Element == Swift.UInt8 {
  @available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
  public var lines: Foundation.AsyncLineSequence<Self> {
    get
  }
}
#endif

extension Dispatch.DispatchData : Foundation.DataProtocol {
  public struct Region : Foundation.DataProtocol, Foundation.ContiguousBytes {
    public var regions: Swift.CollectionOfOne<Dispatch.DispatchData.Region> {
      get
    }
    public subscript(position: Dispatch.DispatchData.Index) -> Swift.UInt8 {
      get
    }
    public var startIndex: Dispatch.DispatchData.Index {
      get
    }
    public var endIndex: Dispatch.DispatchData.Index {
      get
    }
    public func withUnsafeBytes<ResultType>(_ body: (Swift.UnsafeRawBufferPointer) throws -> ResultType) rethrows -> ResultType
    public typealias Element = Swift.UInt8
    public typealias Index = Dispatch.DispatchData.Index
    public typealias Indices = Swift.Range<Dispatch.DispatchData.Index>
    public typealias Iterator = Swift.IndexingIterator<Dispatch.DispatchData.Region>
    public typealias Regions = Swift.CollectionOfOne<Dispatch.DispatchData.Region>
    public typealias SubSequence = Swift.Slice<Dispatch.DispatchData.Region>
  }
  public var regions: [Dispatch.DispatchData.Region] {
    get
  }
  public typealias Regions = [Dispatch.DispatchData.Region]
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
public struct IntegerParseStrategy<Format> : Swift.Codable, Swift.Hashable where Format : Foundation.FormatStyle, Format.FormatInput : Swift.BinaryInteger {
  public var formatStyle: Format
  public var lenient: Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: Foundation.IntegerParseStrategy<Format>, b: Foundation.IntegerParseStrategy<Format>) -> Swift.Bool
  public func encode(to encoder: Swift.Encoder) throws
  public var hashValue: Swift.Int {
    get
  }
  public init(from decoder: Swift.Decoder) throws
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.IntegerParseStrategy : Foundation.ParseStrategy {
  public func parse(_ value: Swift.String) throws -> Format.FormatInput
  public typealias ParseInput = Swift.String
  public typealias ParseOutput = Format.FormatInput
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.IntegerParseStrategy {
  public init<Value>(format: Format, lenient: Swift.Bool = true) where Format == Foundation.IntegerFormatStyle<Value>, Value : Swift.BinaryInteger
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.IntegerParseStrategy {
  public init<Value>(format: Format, lenient: Swift.Bool = true) where Format == Foundation.IntegerFormatStyle<Value>.Percent, Value : Swift.BinaryInteger
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.IntegerParseStrategy {
  public init<Value>(format: Format, lenient: Swift.Bool = true) where Format == Foundation.IntegerFormatStyle<Value>.Currency, Value : Swift.BinaryInteger
}
extension Foundation.URL {
  
  #if compiler(>=5.3) && $RethrowsProtocol
  @available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
  public struct AsyncBytes : _Concurrency.AsyncSequence {
    public typealias Element = Swift.UInt8
    @frozen public struct AsyncIterator : _Concurrency.AsyncIteratorProtocol {
      @usableFromInline
      internal var buffer: Foundation._AsyncBytesBuffer = _AsyncBytesBuffer(capacity: 0)
      
      #if compiler(>=5.3) && $AsyncAwait
      @inlinable @inline(__always) public mutating func next() async throws -> Swift.UInt8? {
                return try await buffer.next()
            }
      #endif

      public typealias Element = Swift.UInt8
    }
    public func makeAsyncIterator() -> Foundation.URL.AsyncBytes.AsyncIterator
  }
  #endif

  
  #if compiler(>=5.3) && $RethrowsProtocol
  @available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
  public var resourceBytes: Foundation.URL.AsyncBytes {
    get
  }
  #endif

  
  #if compiler(>=5.3) && $RethrowsProtocol
  @available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
  public var lines: Foundation.AsyncLineSequence<Foundation.URL.AsyncBytes> {
    get
  }
  #endif

}
@available(macOS 10.8, iOS 6.0, *)
public struct UUID : Foundation.ReferenceConvertible, Swift.Hashable, Swift.Equatable, Swift.CustomStringConvertible {
  public typealias ReferenceType = Foundation.NSUUID
  public var uuid: (Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8) {
    get
  }
  public init()
  public init?(uuidString string: __shared Swift.String)
  public init(uuid: Darwin.uuid_t)
  public var uuidString: Swift.String {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
  public static func == (lhs: Foundation.UUID, rhs: Foundation.UUID) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
extension Foundation.UUID : Swift.CustomReflectable {
  public var customMirror: Swift.Mirror {
    get
  }
}
extension Foundation.UUID : Swift._ObjectiveCBridgeable {
  @_semantics("convertToObjectiveC") public func _bridgeToObjectiveC() -> Foundation.NSUUID
  public static func _forceBridgeFromObjectiveC(_ x: Foundation.NSUUID, result: inout Foundation.UUID?)
  public static func _conditionallyBridgeFromObjectiveC(_ input: Foundation.NSUUID, result: inout Foundation.UUID?) -> Swift.Bool
  @_effects(readonly) public static func _unconditionallyBridgeFromObjectiveC(_ source: Foundation.NSUUID?) -> Foundation.UUID
  public typealias _ObjectiveCType = Foundation.NSUUID
}
extension Foundation.NSUUID : Swift._HasCustomAnyHashableRepresentation {
  @nonobjc public func _toCustomAnyHashable() -> Swift.AnyHashable?
}
extension Foundation.UUID : Swift.Codable {
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
extension Foundation.Decimal {
  public typealias RoundingMode = Foundation.NSDecimalNumber.RoundingMode
  public typealias CalculationError = Foundation.NSDecimalNumber.CalculationError
}
public func pow(_ x: Foundation.Decimal, _ y: Swift.Int) -> Foundation.Decimal
extension Foundation.Decimal : Swift.Hashable, Swift.Comparable {
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (lhs: Foundation.Decimal, rhs: Foundation.Decimal) -> Swift.Bool
  public static func < (lhs: Foundation.Decimal, rhs: Foundation.Decimal) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
extension Foundation.Decimal : Swift.CustomStringConvertible {
  public init?(string: __shared Swift.String, locale: __shared Foundation.Locale? = nil)
  public var description: Swift.String {
    get
  }
}
extension Foundation.Decimal : Swift.Codable {
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
extension Foundation.Decimal : Swift.ExpressibleByFloatLiteral {
  public init(floatLiteral value: Swift.Double)
  public typealias FloatLiteralType = Swift.Double
}
extension Foundation.Decimal : Swift.ExpressibleByIntegerLiteral {
  public init(integerLiteral value: Swift.Int)
  public typealias IntegerLiteralType = Swift.Int
}
extension Foundation.Decimal : Swift.SignedNumeric {
  public var magnitude: Foundation.Decimal {
    get
  }
  public init?<T>(exactly source: T) where T : Swift.BinaryInteger
  public static func += (lhs: inout Foundation.Decimal, rhs: Foundation.Decimal)
  public static func -= (lhs: inout Foundation.Decimal, rhs: Foundation.Decimal)
  public static func *= (lhs: inout Foundation.Decimal, rhs: Foundation.Decimal)
  public static func /= (lhs: inout Foundation.Decimal, rhs: Foundation.Decimal)
  public static func + (lhs: Foundation.Decimal, rhs: Foundation.Decimal) -> Foundation.Decimal
  public static func - (lhs: Foundation.Decimal, rhs: Foundation.Decimal) -> Foundation.Decimal
  public static func * (lhs: Foundation.Decimal, rhs: Foundation.Decimal) -> Foundation.Decimal
  public static func / (lhs: Foundation.Decimal, rhs: Foundation.Decimal) -> Foundation.Decimal
  public mutating func negate()
  public typealias Magnitude = Foundation.Decimal
}
extension Foundation.Decimal {
  @available(swift, obsoleted: 4, message: "Please use arithmetic operators instead")
  @_transparent public mutating func add(_ other: Foundation.Decimal) {
        self += other
    }
  @available(swift, obsoleted: 4, message: "Please use arithmetic operators instead")
  @_transparent public mutating func subtract(_ other: Foundation.Decimal) {
        self -= other
    }
  @available(swift, obsoleted: 4, message: "Please use arithmetic operators instead")
  @_transparent public mutating func multiply(by other: Foundation.Decimal) {
        self *= other
    }
  @available(swift, obsoleted: 4, message: "Please use arithmetic operators instead")
  @_transparent public mutating func divide(by other: Foundation.Decimal) {
        self /= other
    }
}
extension Foundation.Decimal : Swift.Strideable {
  public func distance(to other: Foundation.Decimal) -> Foundation.Decimal
  public func advanced(by n: Foundation.Decimal) -> Foundation.Decimal
  public typealias Stride = Foundation.Decimal
}
extension Foundation.Decimal {
  public static let leastFiniteMagnitude: Foundation.Decimal
  public static let greatestFiniteMagnitude: Foundation.Decimal
  public static let leastNormalMagnitude: Foundation.Decimal
  public static let leastNonzeroMagnitude: Foundation.Decimal
  public static let pi: Foundation.Decimal
  @available(*, unavailable, message: "Decimal does not yet fully adopt FloatingPoint.")
  public static var infinity: Foundation.Decimal {
    get
  }
  @available(*, unavailable, message: "Decimal does not yet fully adopt FloatingPoint.")
  public static var signalingNaN: Foundation.Decimal {
    get
  }
  public static var quietNaN: Foundation.Decimal {
    get
  }
  public static var nan: Foundation.Decimal {
    get
  }
  public static var radix: Swift.Int {
    get
  }
  public init(_ value: Swift.UInt8)
  public init(_ value: Swift.Int8)
  public init(_ value: Swift.UInt16)
  public init(_ value: Swift.Int16)
  public init(_ value: Swift.UInt32)
  public init(_ value: Swift.Int32)
  public init(_ value: Swift.UInt64)
  public init(_ value: Swift.Int64)
  public init(_ value: Swift.UInt)
  public init(_ value: Swift.Int)
  public init(_ value: Swift.Double)
  public init(sign: Swift.FloatingPointSign, exponent: Swift.Int, significand: Foundation.Decimal)
  public init(signOf: Foundation.Decimal, magnitudeOf magnitude: Foundation.Decimal)
  public var exponent: Swift.Int {
    get
  }
  public var significand: Foundation.Decimal {
    get
  }
  public var sign: Swift.FloatingPointSign {
    get
  }
  public var ulp: Foundation.Decimal {
    get
  }
  public var nextUp: Foundation.Decimal {
    get
  }
  public var nextDown: Foundation.Decimal {
    get
  }
  public var floatingPointClass: Swift.FloatingPointClassification {
    get
  }
  public var isCanonical: Swift.Bool {
    get
  }
  public var isSignMinus: Swift.Bool {
    get
  }
  public var isZero: Swift.Bool {
    get
  }
  public var isSubnormal: Swift.Bool {
    get
  }
  public var isNormal: Swift.Bool {
    get
  }
  public var isFinite: Swift.Bool {
    get
  }
  public var isInfinite: Swift.Bool {
    get
  }
  public var isNaN: Swift.Bool {
    get
  }
  public var isSignaling: Swift.Bool {
    get
  }
  public var isSignalingNaN: Swift.Bool {
    get
  }
  public func isEqual(to other: Foundation.Decimal) -> Swift.Bool
  public func isLess(than other: Foundation.Decimal) -> Swift.Bool
  public func isLessThanOrEqualTo(_ other: Foundation.Decimal) -> Swift.Bool
  public func isTotallyOrdered(belowOrEqualTo other: Foundation.Decimal) -> Swift.Bool
  @available(*, unavailable, message: "Decimal does not yet fully adopt FloatingPoint.")
  public mutating func formTruncatingRemainder(dividingBy other: Foundation.Decimal)
}
extension Foundation.Decimal : Swift._ObjectiveCBridgeable {
  @_semantics("convertToObjectiveC") public func _bridgeToObjectiveC() -> Foundation.NSDecimalNumber
  public static func _forceBridgeFromObjectiveC(_ x: Foundation.NSDecimalNumber, result: inout Foundation.Decimal?)
  public static func _conditionallyBridgeFromObjectiveC(_ input: Foundation.NSDecimalNumber, result: inout Foundation.Decimal?) -> Swift.Bool
  @_effects(readonly) public static func _unconditionallyBridgeFromObjectiveC(_ source: Foundation.NSDecimalNumber?) -> Foundation.Decimal
  public typealias _ObjectiveCType = Foundation.NSDecimalNumber
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.PersonNameComponents {
  public struct FormatStyle : Foundation.FormatStyle {
    public var style: Foundation.PersonNameComponents.FormatStyle.Style
    public var locale: Foundation.Locale
    public var attributed: Foundation.PersonNameComponents.AttributedStyle {
      get
    }
    public init(style: Foundation.PersonNameComponents.FormatStyle.Style = .medium, locale: Foundation.Locale = .autoupdatingCurrent)
    public func locale(_ locale: Foundation.Locale) -> Foundation.PersonNameComponents.FormatStyle
    public func format(_ value: Foundation.PersonNameComponents) -> Swift.String
    public enum Style : Swift.Int, Swift.Codable, Swift.Hashable {
      case short
      case medium
      case long
      case abbreviated
      public init?(rawValue: Swift.Int)
      public typealias RawValue = Swift.Int
      public var rawValue: Swift.Int {
        get
      }
    }
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: Foundation.PersonNameComponents.FormatStyle, b: Foundation.PersonNameComponents.FormatStyle) -> Swift.Bool
    public typealias FormatInput = Foundation.PersonNameComponents
    public typealias FormatOutput = Swift.String
    public func encode(to encoder: Swift.Encoder) throws
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: Swift.Decoder) throws
  }
  public struct AttributedStyle : Foundation.FormatStyle {
    public var style: Foundation.PersonNameComponents.FormatStyle.Style
    public var locale: Foundation.Locale
    public init(style: Foundation.PersonNameComponents.FormatStyle.Style = .medium, locale: Foundation.Locale = .autoupdatingCurrent)
    public func format(_ value: Foundation.PersonNameComponents) -> Foundation.AttributedString
    public func locale(_ locale: Foundation.Locale) -> Foundation.PersonNameComponents.AttributedStyle
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: Foundation.PersonNameComponents.AttributedStyle, b: Foundation.PersonNameComponents.AttributedStyle) -> Swift.Bool
    public typealias FormatInput = Foundation.PersonNameComponents
    public typealias FormatOutput = Foundation.AttributedString
    public func encode(to encoder: Swift.Encoder) throws
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: Swift.Decoder) throws
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.PersonNameComponents {
  public struct ParseStrategy : Foundation.ParseStrategy {
    public init()
    public func parse(_ value: Swift.String) throws -> Foundation.PersonNameComponents
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: Foundation.PersonNameComponents.ParseStrategy, b: Foundation.PersonNameComponents.ParseStrategy) -> Swift.Bool
    public typealias ParseInput = Swift.String
    public typealias ParseOutput = Foundation.PersonNameComponents
    public func encode(to encoder: Swift.Encoder) throws
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: Swift.Decoder) throws
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.PersonNameComponents {
  public func formatted<S>(_ style: S) -> S.FormatOutput where S : Foundation.FormatStyle, S.FormatInput == Foundation.PersonNameComponents
  public func formatted() -> Swift.String
  public init<S>(_ value: S.ParseInput, strategy: S) throws where S : Foundation.ParseStrategy, S.ParseOutput == Foundation.PersonNameComponents
  public init(_ value: Swift.String) throws
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.PersonNameComponents.FormatStyle : Foundation.ParseableFormatStyle {
  public var parseStrategy: Foundation.PersonNameComponents.ParseStrategy {
    get
  }
  public typealias Strategy = Foundation.PersonNameComponents.ParseStrategy
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.FormatStyle where Self == Foundation.PersonNameComponents.FormatStyle {
  public static func name(style: Foundation.PersonNameComponents.FormatStyle.Style) -> Self
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.ParseableFormatStyle where Self == Foundation.PersonNameComponents.FormatStyle {
  public static func name(style: Foundation.PersonNameComponents.FormatStyle.Style) -> Self
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.ParseStrategy where Self == Foundation.PersonNameComponents.ParseStrategy {
  public static var name: Foundation.PersonNameComponents.ParseStrategy {
    get
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.Date {
  public struct FormatString : Swift.Hashable {
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: Foundation.Date.FormatString, b: Foundation.Date.FormatString) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.Date.FormatString : Swift.ExpressibleByStringInterpolation {
  public init(stringInterpolation: Foundation.Date.FormatString.StringInterpolation)
  public init(stringLiteral value: Swift.String)
  public struct StringInterpolation : Swift.StringInterpolationProtocol {
    public typealias StringLiteralType = Swift.String
    public init(literalCapacity: Swift.Int, interpolationCount: Swift.Int)
    public mutating func appendLiteral(_ literal: Swift.String)
    public mutating func appendInterpolation(era: Foundation.Date.FormatStyle.Symbol.Era)
    public mutating func appendInterpolation(year: Foundation.Date.FormatStyle.Symbol.Year)
    public mutating func appendInterpolation(yearForWeekOfYear: Foundation.Date.FormatStyle.Symbol.YearForWeekOfYear)
    public mutating func appendInterpolation(cyclicYear: Foundation.Date.FormatStyle.Symbol.CyclicYear)
    public mutating func appendInterpolation(quarter: Foundation.Date.FormatStyle.Symbol.Quarter)
    public mutating func appendInterpolation(standaloneQuarter: Foundation.Date.FormatStyle.Symbol.StandaloneQuarter)
    public mutating func appendInterpolation(month: Foundation.Date.FormatStyle.Symbol.Month)
    public mutating func appendInterpolation(standaloneMonth: Foundation.Date.FormatStyle.Symbol.StandaloneMonth)
    public mutating func appendInterpolation(week: Foundation.Date.FormatStyle.Symbol.Week)
    public mutating func appendInterpolation(day: Foundation.Date.FormatStyle.Symbol.Day)
    public mutating func appendInterpolation(dayOfYear: Foundation.Date.FormatStyle.Symbol.DayOfYear)
    public mutating func appendInterpolation(weekday: Foundation.Date.FormatStyle.Symbol.Weekday)
    public mutating func appendInterpolation(standaloneWeekday: Foundation.Date.FormatStyle.Symbol.StandaloneWeekday)
    public mutating func appendInterpolation(dayPeriod: Foundation.Date.FormatStyle.Symbol.DayPeriod)
    public mutating func appendInterpolation(hour: Foundation.Date.FormatStyle.Symbol.VerbatimHour)
    public mutating func appendInterpolation(minute: Foundation.Date.FormatStyle.Symbol.Minute)
    public mutating func appendInterpolation(second: Foundation.Date.FormatStyle.Symbol.Second)
    public mutating func appendInterpolation(secondFraction: Foundation.Date.FormatStyle.Symbol.SecondFraction)
    public mutating func appendInterpolation(timeZone: Foundation.Date.FormatStyle.Symbol.TimeZone)
  }
  public typealias ExtendedGraphemeClusterLiteralType = Swift.String
  public typealias StringLiteralType = Swift.String
  public typealias UnicodeScalarLiteralType = Swift.String
}
extension Foundation.Date {
  @available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
  public struct IntervalFormatStyle : Foundation.FormatStyle, Swift.Codable, Swift.Hashable {
    public typealias DateStyle = Foundation.Date.FormatStyle.DateStyle
    public typealias TimeStyle = Foundation.Date.FormatStyle.TimeStyle
    public var locale: Foundation.Locale
    public var timeZone: Foundation.TimeZone
    public var calendar: Foundation.Calendar
    public init(date: Foundation.Date.IntervalFormatStyle.DateStyle? = nil, time: Foundation.Date.IntervalFormatStyle.TimeStyle? = nil, locale: Foundation.Locale = .autoupdatingCurrent, calendar: Foundation.Calendar = .autoupdatingCurrent, timeZone: Foundation.TimeZone = .autoupdatingCurrent)
    public func format(_ v: Swift.Range<Foundation.Date>) -> Swift.String
    public func locale(_ locale: Foundation.Locale) -> Foundation.Date.IntervalFormatStyle
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: Foundation.Date.IntervalFormatStyle, b: Foundation.Date.IntervalFormatStyle) -> Swift.Bool
    public typealias FormatInput = Swift.Range<Foundation.Date>
    public typealias FormatOutput = Swift.String
    public func encode(to encoder: Swift.Encoder) throws
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: Swift.Decoder) throws
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.Date.IntervalFormatStyle {
  public typealias Symbol = Foundation.Date.FormatStyle.Symbol
  public func year() -> Foundation.Date.IntervalFormatStyle
  public func month(_ format: Foundation.Date.IntervalFormatStyle.Symbol.Month = .abbreviated) -> Foundation.Date.IntervalFormatStyle
  public func day() -> Foundation.Date.IntervalFormatStyle
  public func weekday(_ format: Foundation.Date.IntervalFormatStyle.Symbol.Weekday = .abbreviated) -> Foundation.Date.IntervalFormatStyle
  public func hour(_ format: Foundation.Date.IntervalFormatStyle.Symbol.Hour = .defaultDigits(amPM: .abbreviated)) -> Foundation.Date.IntervalFormatStyle
  public func minute() -> Foundation.Date.IntervalFormatStyle
  public func second() -> Foundation.Date.IntervalFormatStyle
  public func timeZone(_ format: Foundation.Date.IntervalFormatStyle.Symbol.TimeZone = .genericName(.short)) -> Foundation.Date.IntervalFormatStyle
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.FormatStyle where Self == Foundation.Date.IntervalFormatStyle {
  public static var interval: Foundation.Date.IntervalFormatStyle {
    get
  }
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
public protocol SortComparator : Swift.Hashable {
  associatedtype Compared
  func compare(_ lhs: Self.Compared, _ rhs: Self.Compared) -> Foundation.ComparisonResult
  var order: Foundation.SortOrder { get set }
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
@frozen public enum SortOrder : Swift.Hashable, Swift.Codable {
  case forward
  case reverse
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
  public static func == (a: Foundation.SortOrder, b: Foundation.SortOrder) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
public struct ComparableComparator<Compared> : Foundation.SortComparator where Compared : Swift.Comparable {
  public var order: Foundation.SortOrder
  public func compare(_ lhs: Compared, _ rhs: Compared) -> Foundation.ComparisonResult
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: Foundation.ComparableComparator<Compared>, b: Foundation.ComparableComparator<Compared>) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
extension Swift.String {
  public struct StandardComparator : Foundation.SortComparator, Swift.Codable {
    public static let localizedStandard: Swift.String.StandardComparator
    public static let localized: Swift.String.StandardComparator
    public static let lexical: Swift.String.StandardComparator
    public var order: Foundation.SortOrder
    public init(_ base: Swift.String.StandardComparator, order: Foundation.SortOrder = .forward)
    public init(from decoder: Swift.Decoder) throws
    public func compare(_ lhs: Swift.String, _ rhs: Swift.String) -> Foundation.ComparisonResult
    public func hash(into hasher: inout Swift.Hasher)
    public func encode(to encoder: Swift.Encoder) throws
    public static func == (a: Swift.String.StandardComparator, b: Swift.String.StandardComparator) -> Swift.Bool
    public typealias Compared = Swift.String
    public var hashValue: Swift.Int {
      get
    }
  }
  public struct Comparator : Foundation.SortComparator, Swift.Codable {
    public let options: Swift.String.CompareOptions
    public let locale: Foundation.Locale?
    public var order: Foundation.SortOrder
    public init(options: Swift.String.CompareOptions, locale: Foundation.Locale? = Locale.current, order: Foundation.SortOrder = .forward)
    public init(_ standardComparison: Swift.String.StandardComparator)
    public init(from decoder: Swift.Decoder) throws
    public func compare(_ lhs: Swift.String, _ rhs: Swift.String) -> Foundation.ComparisonResult
    public func hash(into hasher: inout Swift.Hasher)
    public func encode(to encoder: Swift.Encoder) throws
    public static func == (a: Swift.String.Comparator, b: Swift.String.Comparator) -> Swift.Bool
    public typealias Compared = Swift.String
    public var hashValue: Swift.Int {
      get
    }
  }
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.SortComparator where Self == Swift.String.Comparator {
  public static var localizedStandard: Swift.String.Comparator {
    get
  }
  public static var localized: Swift.String.Comparator {
    get
  }
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
extension Swift.Never : Foundation.SortComparator {
  public typealias Compared = Swift.Never
  public func compare(_ lhs: Swift.Never, _ rhs: Swift.Never) -> Foundation.ComparisonResult
  public var order: Foundation.SortOrder {
    get
    set
  }
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
extension Swift.Sequence {
  public func sorted<Comparator>(using comparator: Comparator) -> [Self.Element] where Comparator : Foundation.SortComparator, Self.Element == Comparator.Compared
  public func sorted<S, Comparator>(using comparators: S) -> [Self.Element] where S : Swift.Sequence, Comparator : Foundation.SortComparator, Comparator == S.Element, Self.Element == Comparator.Compared
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
extension Swift.Sequence {
  public func compare<Comparator>(_ lhs: Comparator.Compared, _ rhs: Comparator.Compared) -> Foundation.ComparisonResult where Comparator : Foundation.SortComparator, Comparator == Self.Element
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
extension Swift.MutableCollection where Self : Swift.RandomAccessCollection {
  public mutating func sort<Comparator>(using comparator: Comparator) where Comparator : Foundation.SortComparator, Self.Element == Comparator.Compared
  public mutating func sort<S, Comparator>(using comparators: S) where S : Swift.Sequence, Comparator : Foundation.SortComparator, Comparator == S.Element, Self.Element == Comparator.Compared
}
extension Foundation.URLCache {
  @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
  convenience public init(memoryCapacity: Swift.Int, diskCapacity: Swift.Int, directory: Foundation.URL? = nil)
}
extension Swift.UnsafeRawBufferPointer : Foundation.DataProtocol {
  public var regions: Swift.CollectionOfOne<Swift.UnsafeRawBufferPointer> {
    get
  }
  public typealias Regions = Swift.CollectionOfOne<Swift.UnsafeRawBufferPointer>
}
extension Swift.UnsafeBufferPointer : Foundation.DataProtocol where Element == Swift.UInt8 {
  public var regions: Swift.CollectionOfOne<Swift.UnsafeBufferPointer<Swift.UInt8>> {
    get
  }
  public typealias Regions = Swift.CollectionOfOne<Swift.UnsafeBufferPointer<Swift.UInt8>>
}
extension Foundation.NSRectEdge {
  @inlinable public init(rectEdge: CoreGraphics.CGRectEdge) {
        self = NSRectEdge(rawValue: UInt(rectEdge.rawValue))!
    }
}
extension CoreGraphics.CGRectEdge {
  @inlinable public init(rectEdge: Foundation.NSRectEdge) {
        self = CGRectEdge(rawValue: UInt32(rectEdge.rawValue))!
    }
}
public typealias NSErrorPointer = Swift.AutoreleasingUnsafeMutablePointer<Foundation.NSError?>?
public typealias ErrorPointer = Foundation.NSErrorPointer
public func _convertNSErrorToError(_ error: Foundation.NSError?) -> Swift.Error
public func _convertErrorToNSError(_ error: Swift.Error) -> Foundation.NSError
public protocol LocalizedError : Swift.Error {
  var errorDescription: Swift.String? { get }
  var failureReason: Swift.String? { get }
  var recoverySuggestion: Swift.String? { get }
  var helpAnchor: Swift.String? { get }
}
extension Foundation.LocalizedError {
  public var errorDescription: Swift.String? {
    get
  }
  public var failureReason: Swift.String? {
    get
  }
  public var recoverySuggestion: Swift.String? {
    get
  }
  public var helpAnchor: Swift.String? {
    get
  }
}
public protocol RecoverableError : Swift.Error {
  var recoveryOptions: [Swift.String] { get }
  func attemptRecovery(optionIndex recoveryOptionIndex: Swift.Int, resultHandler handler: @escaping (_ recovered: Swift.Bool) -> Swift.Void)
  func attemptRecovery(optionIndex recoveryOptionIndex: Swift.Int) -> Swift.Bool
}
extension Foundation.RecoverableError {
  public func attemptRecovery(optionIndex recoveryOptionIndex: Swift.Int, resultHandler handler: @escaping (_ recovered: Swift.Bool) -> Swift.Void)
}
public protocol CustomNSError : Swift.Error {
  static var errorDomain: Swift.String { get }
  var errorCode: Swift.Int { get }
  var errorUserInfo: [Swift.String : Any] { get }
}
extension Foundation.CustomNSError {
  public static var errorDomain: Swift.String {
    get
  }
  public var errorCode: Swift.Int {
    get
  }
  public var errorUserInfo: [Swift.String : Any] {
    get
  }
}
extension Foundation.CustomNSError where Self : Swift.RawRepresentable, Self.RawValue : Swift.FixedWidthInteger {
  public var errorCode: Swift.Int {
    get
  }
}
extension Swift.Error where Self : Foundation.CustomNSError {
  public var _domain: Swift.String {
    get
  }
  public var _code: Swift.Int {
    get
  }
}
extension Swift.Error where Self : Foundation.CustomNSError, Self : Swift.RawRepresentable, Self.RawValue : Swift.FixedWidthInteger {
  public var _code: Swift.Int {
    get
  }
}
extension Swift.Error {
  public var localizedDescription: Swift.String {
    get
  }
}
public func _getErrorDefaultUserInfo<T>(_ error: T) -> Swift.AnyObject? where T : Swift.Error
extension Foundation.NSError : Swift.Error {
  @nonobjc public var _domain: Swift.String {
    get
  }
  @nonobjc public var _code: Swift.Int {
    get
  }
  @nonobjc public var _userInfo: Swift.AnyObject? {
    get
  }
  @nonobjc public func _getEmbeddedNSError() -> Swift.AnyObject?
}
extension CoreFoundation.CFError : Swift.Error {
  public var _domain: Swift.String {
    get
  }
  public var _code: Swift.Int {
    get
  }
  public var _userInfo: Swift.AnyObject? {
    get
  }
  public func _getEmbeddedNSError() -> Swift.AnyObject?
}
public protocol _ObjectiveCBridgeableError : Swift.Error {
  init?(_bridgedNSError: __shared Foundation.NSError)
}
public func _bridgeNSErrorToError<T>(_ error: Foundation.NSError, out: Swift.UnsafeMutablePointer<T>) -> Swift.Bool where T : Foundation._ObjectiveCBridgeableError
public protocol _BridgedNSError : Foundation._ObjectiveCBridgeableError, Swift.Hashable, Swift.RawRepresentable where Self.RawValue : Swift.FixedWidthInteger {
  static var _nsErrorDomain: Swift.String { get }
}
extension Foundation._BridgedNSError {
  public var _domain: Swift.String {
    get
  }
}
extension Foundation._BridgedNSError {
  public var _code: Swift.Int {
    get
  }
  public init?(_bridgedNSError: __shared Foundation.NSError)
  public func hash(into hasher: inout Swift.Hasher)
}
public protocol _BridgedStoredNSError : Foundation.CustomNSError, Foundation._ObjectiveCBridgeableError, Swift.Hashable {
  associatedtype Code : Foundation._ErrorCodeProtocol, Swift.RawRepresentable where Self.Code.RawValue : Swift.FixedWidthInteger
  var _nsError: Foundation.NSError { get }
  init(_nsError error: Foundation.NSError)
}
extension Foundation._BridgedStoredNSError {
  public var code: Self.Code {
    get
  }
  public init(_ code: Self.Code, userInfo: [Swift.String : Any] = [:])
  public var userInfo: [Swift.String : Any] {
    get
  }
}
extension Foundation._BridgedStoredNSError {
  public init?(_bridgedNSError error: Foundation.NSError)
}
extension Foundation._BridgedStoredNSError {
  public var errorCode: Swift.Int {
    get
  }
  public var errorUserInfo: [Swift.String : Any] {
    get
  }
}
extension Foundation._BridgedStoredNSError {
  public func hash(into hasher: inout Swift.Hasher)
  @_alwaysEmitIntoClient public var hashValue: Swift.Int {
    get {
        return _nsError.hashValue
    }
  }
}
public protocol _ErrorCodeProtocol : Swift.Equatable {
  associatedtype _ErrorType : Foundation._BridgedStoredNSError where Self == Self._ErrorType.Code
}
extension Foundation._ErrorCodeProtocol {
  public static func ~= (match: Self, error: Swift.Error) -> Swift.Bool
}
extension Foundation._BridgedStoredNSError {
  public func _getEmbeddedNSError() -> Swift.AnyObject?
  public static func == (lhs: Self, rhs: Self) -> Swift.Bool
}
extension Swift._SwiftNewtypeWrapper where Self.RawValue == Swift.Error {
  @inlinable public func _bridgeToObjectiveC() -> Foundation.NSError {
        return rawValue as NSError
    }
  @inlinable public static func _forceBridgeFromObjectiveC(_ source: Foundation.NSError, result: inout Self?) {
        result = Self(rawValue: source)
    }
  @inlinable public static func _conditionallyBridgeFromObjectiveC(_ source: Foundation.NSError, result: inout Self?) -> Swift.Bool {
        result = Self(rawValue: source)
        return result != nil
    }
  @inlinable @_effects(readonly) public static func _unconditionallyBridgeFromObjectiveC(_ source: Foundation.NSError?) -> Self {
        return Self(rawValue: _convertNSErrorToError(source))!
    }
}
@available(*, unavailable, renamed: "CocoaError")
public typealias NSCocoaError = Foundation.CocoaError
public struct CocoaError : Foundation._BridgedStoredNSError {
  public let _nsError: Foundation.NSError
  public init(_nsError error: Foundation.NSError)
  public static var errorDomain: Swift.String {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
  public struct Code : Swift.RawRepresentable, Swift.Hashable, Foundation._ErrorCodeProtocol {
    public typealias _ErrorType = Foundation.CocoaError
    public let rawValue: Swift.Int
    public init(rawValue: Swift.Int)
    public typealias RawValue = Swift.Int
  }
}
extension Foundation.CocoaError {
  public var filePath: Swift.String? {
    get
  }
  public var stringEncoding: Swift.String.Encoding? {
    get
  }
  public var underlying: Swift.Error? {
    get
  }
  public var underlyingErrors: [Swift.Error] {
    get
  }
  public var url: Foundation.URL? {
    get
  }
}
extension Foundation.CocoaError {
  public static func error(_ code: Foundation.CocoaError.Code, userInfo: [Swift.AnyHashable : Any]? = nil, url: Foundation.URL? = nil) -> Swift.Error
}
extension Foundation.CocoaError.Code {
  public static var fileNoSuchFile: Foundation.CocoaError.Code {
    get
  }
  public static var fileLocking: Foundation.CocoaError.Code {
    get
  }
  public static var fileReadUnknown: Foundation.CocoaError.Code {
    get
  }
  public static var fileReadNoPermission: Foundation.CocoaError.Code {
    get
  }
  public static var fileReadInvalidFileName: Foundation.CocoaError.Code {
    get
  }
  public static var fileReadCorruptFile: Foundation.CocoaError.Code {
    get
  }
  public static var fileReadNoSuchFile: Foundation.CocoaError.Code {
    get
  }
  public static var fileReadInapplicableStringEncoding: Foundation.CocoaError.Code {
    get
  }
  public static var fileReadUnsupportedScheme: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.5, iOS 2.0, *)
  public static var fileReadTooLarge: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.5, iOS 2.0, *)
  public static var fileReadUnknownStringEncoding: Foundation.CocoaError.Code {
    get
  }
  public static var fileWriteUnknown: Foundation.CocoaError.Code {
    get
  }
  public static var fileWriteNoPermission: Foundation.CocoaError.Code {
    get
  }
  public static var fileWriteInvalidFileName: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.7, iOS 5.0, *)
  public static var fileWriteFileExists: Foundation.CocoaError.Code {
    get
  }
  public static var fileWriteInapplicableStringEncoding: Foundation.CocoaError.Code {
    get
  }
  public static var fileWriteUnsupportedScheme: Foundation.CocoaError.Code {
    get
  }
  public static var fileWriteOutOfSpace: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.6, iOS 4.0, *)
  public static var fileWriteVolumeReadOnly: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.11, *)
  @available(iOS, unavailable)
  public static var fileManagerUnmountUnknown: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.11, *)
  @available(iOS, unavailable)
  public static var fileManagerUnmountBusy: Foundation.CocoaError.Code {
    get
  }
  public static var keyValueValidation: Foundation.CocoaError.Code {
    get
  }
  public static var formatting: Foundation.CocoaError.Code {
    get
  }
  public static var userCancelled: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.8, iOS 6.0, *)
  public static var featureUnsupported: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.5, iOS 2.0, *)
  public static var executableNotLoadable: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.5, iOS 2.0, *)
  public static var executableArchitectureMismatch: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.5, iOS 2.0, *)
  public static var executableRuntimeMismatch: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.5, iOS 2.0, *)
  public static var executableLoad: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.5, iOS 2.0, *)
  public static var executableLink: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.6, iOS 4.0, *)
  public static var propertyListReadCorrupt: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.6, iOS 4.0, *)
  public static var propertyListReadUnknownVersion: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.6, iOS 4.0, *)
  public static var propertyListReadStream: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.6, iOS 4.0, *)
  public static var propertyListWriteStream: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.10, iOS 8.0, *)
  public static var propertyListWriteInvalid: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.8, iOS 6.0, *)
  public static var xpcConnectionInterrupted: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.8, iOS 6.0, *)
  public static var xpcConnectionInvalid: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.8, iOS 6.0, *)
  public static var xpcConnectionReplyInvalid: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.9, iOS 7.0, *)
  public static var ubiquitousFileUnavailable: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.9, iOS 7.0, *)
  public static var ubiquitousFileNotUploadedDueToQuota: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.9, iOS 7.0, *)
  public static var ubiquitousFileUbiquityServerNotAvailable: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.10, iOS 8.0, *)
  public static var userActivityHandoffFailed: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.10, iOS 8.0, *)
  public static var userActivityConnectionUnavailable: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.10, iOS 8.0, *)
  public static var userActivityRemoteApplicationTimedOut: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.10, iOS 8.0, *)
  public static var userActivityHandoffUserInfoTooLarge: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.11, iOS 9.0, *)
  public static var coderReadCorrupt: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.11, iOS 9.0, *)
  public static var coderValueNotFound: Foundation.CocoaError.Code {
    get
  }
  public static var coderInvalidValue: Foundation.CocoaError.Code {
    get
  }
}
extension Foundation.CocoaError.Code {
  @available(*, deprecated, renamed: "fileNoSuchFile")
  public static var fileNoSuchFileError: Foundation.CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "fileLocking")
  public static var fileLockingError: Foundation.CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "fileReadUnknown")
  public static var fileReadUnknownError: Foundation.CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "fileReadNoPermission")
  public static var fileReadNoPermissionError: Foundation.CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "fileReadInvalidFileName")
  public static var fileReadInvalidFileNameError: Foundation.CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "fileReadCorruptFile")
  public static var fileReadCorruptFileError: Foundation.CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "fileReadNoSuchFile")
  public static var fileReadNoSuchFileError: Foundation.CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "fileReadInapplicableStringEncoding")
  public static var fileReadInapplicableStringEncodingError: Foundation.CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "fileReadUnsupportedScheme")
  public static var fileReadUnsupportedSchemeError: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.5, iOS 2.0, *)
  @available(*, deprecated, renamed: "fileReadTooLarge")
  public static var fileReadTooLargeError: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.5, iOS 2.0, *)
  @available(*, deprecated, renamed: "fileReadUnknownStringEncoding")
  public static var fileReadUnknownStringEncodingError: Foundation.CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "fileWriteUnknown")
  public static var fileWriteUnknownError: Foundation.CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "fileWriteNoPermission")
  public static var fileWriteNoPermissionError: Foundation.CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "fileWriteInvalidFileName")
  public static var fileWriteInvalidFileNameError: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.7, iOS 5.0, *)
  @available(*, deprecated, renamed: "fileWriteFileExists")
  public static var fileWriteFileExistsError: Foundation.CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "fileWriteInapplicableStringEncoding")
  public static var fileWriteInapplicableStringEncodingError: Foundation.CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "fileWriteUnsupportedScheme")
  public static var fileWriteUnsupportedSchemeError: Foundation.CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "fileWriteOutOfSpace")
  public static var fileWriteOutOfSpaceError: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.6, iOS 4.0, *)
  @available(*, deprecated, renamed: "fileWriteVolumeReadOnly")
  public static var fileWriteVolumeReadOnlyError: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.11, *)
  @available(iOS, unavailable)
  @available(*, deprecated, renamed: "fileManagerUnmountUnknown")
  public static var fileManagerUnmountUnknownError: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.11, *)
  @available(iOS, unavailable)
  @available(*, deprecated, renamed: "fileManagerUnmountBusy")
  public static var fileManagerUnmountBusyError: Foundation.CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "keyValueValidation")
  public static var keyValueValidationError: Foundation.CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "formatting")
  public static var formattingError: Foundation.CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "userCancelled")
  public static var userCancelledError: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.8, iOS 6.0, *)
  @available(*, deprecated, renamed: "featureUnsupported")
  public static var featureUnsupportedError: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.5, iOS 2.0, *)
  @available(*, deprecated, renamed: "executableNotLoadable")
  public static var executableNotLoadableError: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.5, iOS 2.0, *)
  @available(*, deprecated, renamed: "executableArchitectureMismatch")
  public static var executableArchitectureMismatchError: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.5, iOS 2.0, *)
  @available(*, deprecated, renamed: "executableRuntimeMismatch")
  public static var executableRuntimeMismatchError: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.5, iOS 2.0, *)
  @available(*, deprecated, renamed: "executableLoad")
  public static var executableLoadError: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.5, iOS 2.0, *)
  @available(*, deprecated, renamed: "executableLink")
  public static var executableLinkError: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.6, iOS 4.0, *)
  @available(*, deprecated, renamed: "propertyListReadCorrupt")
  public static var propertyListReadCorruptError: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.6, iOS 4.0, *)
  @available(*, deprecated, renamed: "propertyListReadUnknownVersion")
  public static var propertyListReadUnknownVersionError: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.6, iOS 4.0, *)
  @available(*, deprecated, renamed: "propertyListReadStream")
  public static var propertyListReadStreamError: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.6, iOS 4.0, *)
  @available(*, deprecated, renamed: "propertyListWriteStream")
  public static var propertyListWriteStreamError: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.10, iOS 8.0, *)
  @available(*, deprecated, renamed: "propertyListWriteInvalid")
  public static var propertyListWriteInvalidError: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.9, iOS 7.0, *)
  @available(*, deprecated, renamed: "ubiquitousFileUnavailable")
  public static var ubiquitousFileUnavailableError: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.9, iOS 7.0, *)
  @available(*, deprecated, renamed: "ubiquitousFileNotUploadedDueToQuota")
  public static var ubiquitousFileNotUploadedDueToQuotaError: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.10, iOS 8.0, *)
  @available(*, deprecated, renamed: "userActivityHandoffFailed")
  public static var userActivityHandoffFailedError: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.10, iOS 8.0, *)
  @available(*, deprecated, renamed: "userActivityConnectionUnavailable")
  public static var userActivityConnectionUnavailableError: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.10, iOS 8.0, *)
  @available(*, deprecated, renamed: "userActivityRemoteApplicationTimedOut")
  public static var userActivityRemoteApplicationTimedOutError: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.10, iOS 8.0, *)
  @available(*, deprecated, renamed: "userActivityHandoffUserInfoTooLarge")
  public static var userActivityHandoffUserInfoTooLargeError: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.11, iOS 9.0, *)
  @available(*, deprecated, renamed: "coderReadCorrupt")
  public static var coderReadCorruptError: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.11, iOS 9.0, *)
  @available(*, deprecated, renamed: "coderValueNotFound")
  public static var coderValueNotFoundError: Foundation.CocoaError.Code {
    get
  }
}
extension Foundation.CocoaError {
  public static var fileNoSuchFile: Foundation.CocoaError.Code {
    get
  }
  public static var fileLocking: Foundation.CocoaError.Code {
    get
  }
  public static var fileReadUnknown: Foundation.CocoaError.Code {
    get
  }
  public static var fileReadNoPermission: Foundation.CocoaError.Code {
    get
  }
  public static var fileReadInvalidFileName: Foundation.CocoaError.Code {
    get
  }
  public static var fileReadCorruptFile: Foundation.CocoaError.Code {
    get
  }
  public static var fileReadNoSuchFile: Foundation.CocoaError.Code {
    get
  }
  public static var fileReadInapplicableStringEncoding: Foundation.CocoaError.Code {
    get
  }
  public static var fileReadUnsupportedScheme: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.5, iOS 2.0, *)
  public static var fileReadTooLarge: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.5, iOS 2.0, *)
  public static var fileReadUnknownStringEncoding: Foundation.CocoaError.Code {
    get
  }
  public static var fileWriteUnknown: Foundation.CocoaError.Code {
    get
  }
  public static var fileWriteNoPermission: Foundation.CocoaError.Code {
    get
  }
  public static var fileWriteInvalidFileName: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.7, iOS 5.0, *)
  public static var fileWriteFileExists: Foundation.CocoaError.Code {
    get
  }
  public static var fileWriteInapplicableStringEncoding: Foundation.CocoaError.Code {
    get
  }
  public static var fileWriteUnsupportedScheme: Foundation.CocoaError.Code {
    get
  }
  public static var fileWriteOutOfSpace: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.6, iOS 4.0, *)
  public static var fileWriteVolumeReadOnly: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.11, *)
  @available(iOS, unavailable)
  public static var fileManagerUnmountUnknown: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.11, *)
  @available(iOS, unavailable)
  public static var fileManagerUnmountBusy: Foundation.CocoaError.Code {
    get
  }
  public static var keyValueValidation: Foundation.CocoaError.Code {
    get
  }
  public static var formatting: Foundation.CocoaError.Code {
    get
  }
  public static var userCancelled: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.8, iOS 6.0, *)
  public static var featureUnsupported: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.5, iOS 2.0, *)
  public static var executableNotLoadable: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.5, iOS 2.0, *)
  public static var executableArchitectureMismatch: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.5, iOS 2.0, *)
  public static var executableRuntimeMismatch: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.5, iOS 2.0, *)
  public static var executableLoad: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.5, iOS 2.0, *)
  public static var executableLink: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.6, iOS 4.0, *)
  public static var propertyListReadCorrupt: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.6, iOS 4.0, *)
  public static var propertyListReadUnknownVersion: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.6, iOS 4.0, *)
  public static var propertyListReadStream: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.6, iOS 4.0, *)
  public static var propertyListWriteStream: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.10, iOS 8.0, *)
  public static var propertyListWriteInvalid: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.8, iOS 6.0, *)
  public static var xpcConnectionInterrupted: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.8, iOS 6.0, *)
  public static var xpcConnectionInvalid: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.8, iOS 6.0, *)
  public static var xpcConnectionReplyInvalid: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.9, iOS 7.0, *)
  public static var ubiquitousFileUnavailable: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.9, iOS 7.0, *)
  public static var ubiquitousFileNotUploadedDueToQuota: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.9, iOS 7.0, *)
  public static var ubiquitousFileUbiquityServerNotAvailable: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.10, iOS 8.0, *)
  public static var userActivityHandoffFailed: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.10, iOS 8.0, *)
  public static var userActivityConnectionUnavailable: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.10, iOS 8.0, *)
  public static var userActivityRemoteApplicationTimedOut: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.10, iOS 8.0, *)
  public static var userActivityHandoffUserInfoTooLarge: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.11, iOS 9.0, *)
  public static var coderReadCorrupt: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.11, iOS 9.0, *)
  public static var coderValueNotFound: Foundation.CocoaError.Code {
    get
  }
  public static var coderInvalidValue: Foundation.CocoaError.Code {
    get
  }
}
extension Foundation.CocoaError {
  @available(*, deprecated, renamed: "fileNoSuchFile")
  public static var fileNoSuchFileError: Foundation.CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "fileLocking")
  public static var fileLockingError: Foundation.CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "fileReadUnknown")
  public static var fileReadUnknownError: Foundation.CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "fileReadNoPermission")
  public static var fileReadNoPermissionError: Foundation.CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "fileReadInvalidFileName")
  public static var fileReadInvalidFileNameError: Foundation.CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "fileReadCorruptFile")
  public static var fileReadCorruptFileError: Foundation.CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "fileReadNoSuchFile")
  public static var fileReadNoSuchFileError: Foundation.CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "fileReadInapplicableStringEncoding")
  public static var fileReadInapplicableStringEncodingError: Foundation.CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "fileReadUnsupportedScheme")
  public static var fileReadUnsupportedSchemeError: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.5, iOS 2.0, *)
  @available(*, deprecated, renamed: "fileReadTooLarge")
  public static var fileReadTooLargeError: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.5, iOS 2.0, *)
  @available(*, deprecated, renamed: "fileReadUnknownStringEncoding")
  public static var fileReadUnknownStringEncodingError: Foundation.CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "fileWriteUnknown")
  public static var fileWriteUnknownError: Foundation.CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "fileWriteNoPermission")
  public static var fileWriteNoPermissionError: Foundation.CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "fileWriteInvalidFileName")
  public static var fileWriteInvalidFileNameError: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.7, iOS 5.0, *)
  @available(*, deprecated, renamed: "fileWriteFileExists")
  public static var fileWriteFileExistsError: Foundation.CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "fileWriteInapplicableStringEncoding")
  public static var fileWriteInapplicableStringEncodingError: Foundation.CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "fileWriteUnsupportedScheme")
  public static var fileWriteUnsupportedSchemeError: Foundation.CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "fileWriteOutOfSpace")
  public static var fileWriteOutOfSpaceError: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.6, iOS 4.0, *)
  @available(*, deprecated, renamed: "fileWriteVolumeReadOnly")
  public static var fileWriteVolumeReadOnlyError: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.11, *)
  @available(iOS, unavailable)
  @available(*, deprecated, renamed: "fileManagerUnmountUnknown")
  public static var fileManagerUnmountUnknownError: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.11, *)
  @available(iOS, unavailable)
  @available(*, deprecated, renamed: "fileManagerUnmountBusy")
  public static var fileManagerUnmountBusyError: Foundation.CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "keyValueValidation")
  public static var keyValueValidationError: Foundation.CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "formatting")
  public static var formattingError: Foundation.CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "userCancelled")
  public static var userCancelledError: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.8, iOS 6.0, *)
  @available(*, deprecated, renamed: "featureUnsupported")
  public static var featureUnsupportedError: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.5, iOS 2.0, *)
  @available(*, deprecated, renamed: "executableNotLoadable")
  public static var executableNotLoadableError: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.5, iOS 2.0, *)
  @available(*, deprecated, renamed: "executableArchitectureMismatch")
  public static var executableArchitectureMismatchError: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.5, iOS 2.0, *)
  @available(*, deprecated, renamed: "executableRuntimeMismatch")
  public static var executableRuntimeMismatchError: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.5, iOS 2.0, *)
  @available(*, deprecated, renamed: "executableLoad")
  public static var executableLoadError: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.5, iOS 2.0, *)
  @available(*, deprecated, renamed: "executableLink")
  public static var executableLinkError: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.6, iOS 4.0, *)
  @available(*, deprecated, renamed: "propertyListReadCorrupt")
  public static var propertyListReadCorruptError: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.6, iOS 4.0, *)
  @available(*, deprecated, renamed: "propertyListReadUnknownVersion")
  public static var propertyListReadUnknownVersionError: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.6, iOS 4.0, *)
  @available(*, deprecated, renamed: "propertyListReadStream")
  public static var propertyListReadStreamError: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.6, iOS 4.0, *)
  @available(*, deprecated, renamed: "propertyListWriteStream")
  public static var propertyListWriteStreamError: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.10, iOS 8.0, *)
  @available(*, deprecated, renamed: "propertyListWriteInvalid")
  public static var propertyListWriteInvalidError: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.9, iOS 7.0, *)
  @available(*, deprecated, renamed: "ubiquitousFileUnavailable")
  public static var ubiquitousFileUnavailableError: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.9, iOS 7.0, *)
  @available(*, deprecated, renamed: "ubiquitousFileNotUploadedDueToQuota")
  public static var ubiquitousFileNotUploadedDueToQuotaError: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.10, iOS 8.0, *)
  @available(*, deprecated, renamed: "userActivityHandoffFailed")
  public static var userActivityHandoffFailedError: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.10, iOS 8.0, *)
  @available(*, deprecated, renamed: "userActivityConnectionUnavailable")
  public static var userActivityConnectionUnavailableError: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.10, iOS 8.0, *)
  @available(*, deprecated, renamed: "userActivityRemoteApplicationTimedOut")
  public static var userActivityRemoteApplicationTimedOutError: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.10, iOS 8.0, *)
  @available(*, deprecated, renamed: "userActivityHandoffUserInfoTooLarge")
  public static var userActivityHandoffUserInfoTooLargeError: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.11, iOS 9.0, *)
  @available(*, deprecated, renamed: "coderReadCorrupt")
  public static var coderReadCorruptError: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.11, iOS 9.0, *)
  @available(*, deprecated, renamed: "coderValueNotFound")
  public static var coderValueNotFoundError: Foundation.CocoaError.Code {
    get
  }
}
extension Foundation.CocoaError {
  @available(macOS 10.11, iOS 9.0, *)
  public var isCoderError: Swift.Bool {
    get
  }
  @available(macOS 10.5, iOS 2.0, *)
  public var isExecutableError: Swift.Bool {
    get
  }
  public var isFileError: Swift.Bool {
    get
  }
  public var isFormattingError: Swift.Bool {
    get
  }
  @available(macOS 10.6, iOS 4.0, *)
  public var isPropertyListError: Swift.Bool {
    get
  }
  @available(macOS 10.9, iOS 7.0, *)
  public var isUbiquitousFileError: Swift.Bool {
    get
  }
  @available(macOS 10.10, iOS 8.0, *)
  public var isUserActivityError: Swift.Bool {
    get
  }
  public var isValidationError: Swift.Bool {
    get
  }
  @available(macOS 10.8, iOS 6.0, *)
  public var isXPCConnectionError: Swift.Bool {
    get
  }
}
extension Foundation.CocoaError.Code {
  @available(*, unavailable, renamed: "fileNoSuchFile")
  public static var FileNoSuchFileError: Foundation.CocoaError.Code {
    get
  }
  @available(*, unavailable, renamed: "fileLocking")
  public static var FileLockingError: Foundation.CocoaError.Code {
    get
  }
  @available(*, unavailable, renamed: "fileReadUnknown")
  public static var FileReadUnknownError: Foundation.CocoaError.Code {
    get
  }
  @available(*, unavailable, renamed: "fileReadNoPermission")
  public static var FileReadNoPermissionError: Foundation.CocoaError.Code {
    get
  }
  @available(*, unavailable, renamed: "fileReadInvalidFileName")
  public static var FileReadInvalidFileNameError: Foundation.CocoaError.Code {
    get
  }
  @available(*, unavailable, renamed: "fileReadCorruptFile")
  public static var FileReadCorruptFileError: Foundation.CocoaError.Code {
    get
  }
  @available(*, unavailable, renamed: "fileReadNoSuchFile")
  public static var FileReadNoSuchFileError: Foundation.CocoaError.Code {
    get
  }
  @available(*, unavailable, renamed: "fileReadInapplicableStringEncoding")
  public static var FileReadInapplicableStringEncodingError: Foundation.CocoaError.Code {
    get
  }
  @available(*, unavailable, renamed: "fileReadUnsupportedScheme")
  public static var FileReadUnsupportedSchemeError: Foundation.CocoaError.Code {
    get
  }
  @available(*, unavailable, renamed: "fileReadTooLarge")
  public static var FileReadTooLargeError: Foundation.CocoaError.Code {
    get
  }
  @available(*, unavailable, renamed: "fileReadUnknownStringEncoding")
  public static var FileReadUnknownStringEncodingError: Foundation.CocoaError.Code {
    get
  }
  @available(*, unavailable, renamed: "fileWriteUnknown")
  public static var FileWriteUnknownError: Foundation.CocoaError.Code {
    get
  }
  @available(*, unavailable, renamed: "fileWriteNoPermission")
  public static var FileWriteNoPermissionError: Foundation.CocoaError.Code {
    get
  }
  @available(*, unavailable, renamed: "fileWriteInvalidFileName")
  public static var FileWriteInvalidFileNameError: Foundation.CocoaError.Code {
    get
  }
  @available(*, unavailable, renamed: "fileWriteFileExists")
  public static var FileWriteFileExistsError: Foundation.CocoaError.Code {
    get
  }
  @available(*, unavailable, renamed: "fileWriteInapplicableStringEncoding")
  public static var FileWriteInapplicableStringEncodingError: Foundation.CocoaError.Code {
    get
  }
  @available(*, unavailable, renamed: "fileWriteUnsupportedScheme")
  public static var FileWriteUnsupportedSchemeError: Foundation.CocoaError.Code {
    get
  }
  @available(*, unavailable, renamed: "fileWriteOutOfSpace")
  public static var FileWriteOutOfSpaceError: Foundation.CocoaError.Code {
    get
  }
  @available(*, unavailable, renamed: "fileWriteVolumeReadOnly")
  public static var FileWriteVolumeReadOnlyError: Foundation.CocoaError.Code {
    get
  }
  @available(*, unavailable, renamed: "fileManagerUnmountUnknown")
  public static var FileManagerUnmountUnknownError: Foundation.CocoaError.Code {
    get
  }
  @available(*, unavailable, renamed: "fileManagerUnmountBusy")
  public static var FileManagerUnmountBusyError: Foundation.CocoaError.Code {
    get
  }
  @available(*, unavailable, renamed: "keyValueValidation")
  public static var KeyValueValidationError: Foundation.CocoaError.Code {
    get
  }
  @available(*, unavailable, renamed: "formatting")
  public static var FormattingError: Foundation.CocoaError.Code {
    get
  }
  @available(*, unavailable, renamed: "userCancelled")
  public static var UserCancelledError: Foundation.CocoaError.Code {
    get
  }
  @available(*, unavailable, renamed: "featureUnsupported")
  public static var FeatureUnsupportedError: Foundation.CocoaError.Code {
    get
  }
  @available(*, unavailable, renamed: "executableNotLoadable")
  public static var ExecutableNotLoadableError: Foundation.CocoaError.Code {
    get
  }
  @available(*, unavailable, renamed: "executableArchitectureMismatch")
  public static var ExecutableArchitectureMismatchError: Foundation.CocoaError.Code {
    get
  }
  @available(*, unavailable, renamed: "executableRuntimeMismatch")
  public static var ExecutableRuntimeMismatchError: Foundation.CocoaError.Code {
    get
  }
  @available(*, unavailable, renamed: "executableLoad")
  public static var ExecutableLoadError: Foundation.CocoaError.Code {
    get
  }
  @available(*, unavailable, renamed: "executableLink")
  public static var ExecutableLinkError: Foundation.CocoaError.Code {
    get
  }
  @available(*, unavailable, renamed: "propertyListReadCorrupt")
  public static var PropertyListReadCorruptError: Foundation.CocoaError.Code {
    get
  }
  @available(*, unavailable, renamed: "propertyListReadUnknownVersion")
  public static var PropertyListReadUnknownVersionError: Foundation.CocoaError.Code {
    get
  }
  @available(*, unavailable, renamed: "propertyListReadStream")
  public static var PropertyListReadStreamError: Foundation.CocoaError.Code {
    get
  }
  @available(*, unavailable, renamed: "propertyListWriteStream")
  public static var PropertyListWriteStreamError: Foundation.CocoaError.Code {
    get
  }
  @available(*, unavailable, renamed: "propertyListWriteInvalid")
  public static var PropertyListWriteInvalidError: Foundation.CocoaError.Code {
    get
  }
  @available(*, unavailable, renamed: "xpcConnectionInterrupted")
  public static var XPCConnectionInterrupted: Foundation.CocoaError.Code {
    get
  }
  @available(*, unavailable, renamed: "xpcConnectionInvalid")
  public static var XPCConnectionInvalid: Foundation.CocoaError.Code {
    get
  }
  @available(*, unavailable, renamed: "xpcConnectionReplyInvalid")
  public static var XPCConnectionReplyInvalid: Foundation.CocoaError.Code {
    get
  }
  @available(*, unavailable, renamed: "ubiquitousFileUnavailable")
  public static var UbiquitousFileUnavailableError: Foundation.CocoaError.Code {
    get
  }
  @available(*, unavailable, renamed: "ubiquitousFileNotUploadedDueToQuota")
  public static var UbiquitousFileNotUploadedDueToQuotaError: Foundation.CocoaError.Code {
    get
  }
  @available(*, unavailable, renamed: "ubiquitousFileUbiquityServerNotAvailable")
  public static var UbiquitousFileUbiquityServerNotAvailable: Foundation.CocoaError.Code {
    get
  }
  @available(*, unavailable, renamed: "userActivityHandoffFailed")
  public static var UserActivityHandoffFailedError: Foundation.CocoaError.Code {
    get
  }
  @available(*, unavailable, renamed: "userActivityConnectionUnavailable")
  public static var UserActivityConnectionUnavailableError: Foundation.CocoaError.Code {
    get
  }
  @available(*, unavailable, renamed: "userActivityRemoteApplicationTimedOut")
  public static var UserActivityRemoteApplicationTimedOutError: Foundation.CocoaError.Code {
    get
  }
  @available(*, unavailable, renamed: "userActivityHandoffUserInfoTooLarge")
  public static var UserActivityHandoffUserInfoTooLargeError: Foundation.CocoaError.Code {
    get
  }
  @available(*, unavailable, renamed: "coderReadCorrupt")
  public static var CoderReadCorruptError: Foundation.CocoaError.Code {
    get
  }
  @available(*, unavailable, renamed: "coderValueNotFound")
  public static var CoderValueNotFoundError: Foundation.CocoaError.Code {
    get
  }
}
public struct URLError : Foundation._BridgedStoredNSError {
  public let _nsError: Foundation.NSError
  public init(_nsError error: Foundation.NSError)
  public static var errorDomain: Swift.String {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
  public struct Code : Swift.RawRepresentable, Swift.Hashable, Foundation._ErrorCodeProtocol {
    public typealias _ErrorType = Foundation.URLError
    public let rawValue: Swift.Int
    public init(rawValue: Swift.Int)
    public typealias RawValue = Swift.Int
  }
}
extension Foundation.URLError.Code {
  public static var unknown: Foundation.URLError.Code {
    get
  }
  public static var cancelled: Foundation.URLError.Code {
    get
  }
  public static var badURL: Foundation.URLError.Code {
    get
  }
  public static var timedOut: Foundation.URLError.Code {
    get
  }
  public static var unsupportedURL: Foundation.URLError.Code {
    get
  }
  public static var cannotFindHost: Foundation.URLError.Code {
    get
  }
  public static var cannotConnectToHost: Foundation.URLError.Code {
    get
  }
  public static var networkConnectionLost: Foundation.URLError.Code {
    get
  }
  public static var dnsLookupFailed: Foundation.URLError.Code {
    get
  }
  public static var httpTooManyRedirects: Foundation.URLError.Code {
    get
  }
  public static var resourceUnavailable: Foundation.URLError.Code {
    get
  }
  public static var notConnectedToInternet: Foundation.URLError.Code {
    get
  }
  public static var redirectToNonExistentLocation: Foundation.URLError.Code {
    get
  }
  public static var badServerResponse: Foundation.URLError.Code {
    get
  }
  public static var userCancelledAuthentication: Foundation.URLError.Code {
    get
  }
  public static var userAuthenticationRequired: Foundation.URLError.Code {
    get
  }
  public static var zeroByteResource: Foundation.URLError.Code {
    get
  }
  public static var cannotDecodeRawData: Foundation.URLError.Code {
    get
  }
  public static var cannotDecodeContentData: Foundation.URLError.Code {
    get
  }
  public static var cannotParseResponse: Foundation.URLError.Code {
    get
  }
  @available(macOS 10.11, iOS 9.0, *)
  public static var appTransportSecurityRequiresSecureConnection: Foundation.URLError.Code {
    get
  }
  public static var fileDoesNotExist: Foundation.URLError.Code {
    get
  }
  public static var fileIsDirectory: Foundation.URLError.Code {
    get
  }
  public static var noPermissionsToReadFile: Foundation.URLError.Code {
    get
  }
  @available(macOS 10.5, iOS 2.0, *)
  public static var dataLengthExceedsMaximum: Foundation.URLError.Code {
    get
  }
  public static var secureConnectionFailed: Foundation.URLError.Code {
    get
  }
  public static var serverCertificateHasBadDate: Foundation.URLError.Code {
    get
  }
  public static var serverCertificateUntrusted: Foundation.URLError.Code {
    get
  }
  public static var serverCertificateHasUnknownRoot: Foundation.URLError.Code {
    get
  }
  public static var serverCertificateNotYetValid: Foundation.URLError.Code {
    get
  }
  public static var clientCertificateRejected: Foundation.URLError.Code {
    get
  }
  public static var clientCertificateRequired: Foundation.URLError.Code {
    get
  }
  public static var cannotLoadFromNetwork: Foundation.URLError.Code {
    get
  }
  public static var cannotCreateFile: Foundation.URLError.Code {
    get
  }
  public static var cannotOpenFile: Foundation.URLError.Code {
    get
  }
  public static var cannotCloseFile: Foundation.URLError.Code {
    get
  }
  public static var cannotWriteToFile: Foundation.URLError.Code {
    get
  }
  public static var cannotRemoveFile: Foundation.URLError.Code {
    get
  }
  public static var cannotMoveFile: Foundation.URLError.Code {
    get
  }
  public static var downloadDecodingFailedMidStream: Foundation.URLError.Code {
    get
  }
  public static var downloadDecodingFailedToComplete: Foundation.URLError.Code {
    get
  }
  @available(macOS 10.7, iOS 3.0, *)
  public static var internationalRoamingOff: Foundation.URLError.Code {
    get
  }
  @available(macOS 10.7, iOS 3.0, *)
  public static var callIsActive: Foundation.URLError.Code {
    get
  }
  @available(macOS 10.7, iOS 3.0, *)
  public static var dataNotAllowed: Foundation.URLError.Code {
    get
  }
  @available(macOS 10.7, iOS 3.0, *)
  public static var requestBodyStreamExhausted: Foundation.URLError.Code {
    get
  }
  @available(macOS 10.10, iOS 8.0, *)
  public static var backgroundSessionRequiresSharedContainer: Foundation.URLError.Code {
    get
  }
  @available(macOS 10.10, iOS 8.0, *)
  public static var backgroundSessionInUseByAnotherProcess: Foundation.URLError.Code {
    get
  }
  @available(macOS 10.10, iOS 8.0, *)
  public static var backgroundSessionWasDisconnected: Foundation.URLError.Code {
    get
  }
}
extension Foundation.URLError {
  @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
  public enum BackgroundTaskCancelledReason : Swift.Int {
    case userForceQuitApplication
    case backgroundUpdatesDisabled
    case insufficientSystemResources
    public init?(rawValue: Swift.Int)
    public typealias RawValue = Swift.Int
    public var rawValue: Swift.Int {
      get
    }
  }
}
extension Foundation.URLError {
  @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
  public enum NetworkUnavailableReason : Swift.Int {
    case cellular
    case expensive
    case constrained
    public init?(rawValue: Swift.Int)
    public typealias RawValue = Swift.Int
    public var rawValue: Swift.Int {
      get
    }
  }
}
extension Foundation.URLError {
  public var failingURL: Foundation.URL? {
    get
  }
  public var failureURLString: Swift.String? {
    get
  }
  public var failureURLPeerTrust: Security.SecTrust? {
    get
  }
  @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
  public var backgroundTaskCancelledReason: Foundation.URLError.BackgroundTaskCancelledReason? {
    get
  }
  @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
  public var networkUnavailableReason: Foundation.URLError.NetworkUnavailableReason? {
    get
  }
  @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
  public var downloadTaskResumeData: Foundation.Data? {
    get
  }
}
extension Foundation.URLError {
  public static var unknown: Foundation.URLError.Code {
    get
  }
  public static var cancelled: Foundation.URLError.Code {
    get
  }
  public static var badURL: Foundation.URLError.Code {
    get
  }
  public static var timedOut: Foundation.URLError.Code {
    get
  }
  public static var unsupportedURL: Foundation.URLError.Code {
    get
  }
  public static var cannotFindHost: Foundation.URLError.Code {
    get
  }
  public static var cannotConnectToHost: Foundation.URLError.Code {
    get
  }
  public static var networkConnectionLost: Foundation.URLError.Code {
    get
  }
  public static var dnsLookupFailed: Foundation.URLError.Code {
    get
  }
  public static var httpTooManyRedirects: Foundation.URLError.Code {
    get
  }
  public static var resourceUnavailable: Foundation.URLError.Code {
    get
  }
  public static var notConnectedToInternet: Foundation.URLError.Code {
    get
  }
  public static var redirectToNonExistentLocation: Foundation.URLError.Code {
    get
  }
  public static var badServerResponse: Foundation.URLError.Code {
    get
  }
  public static var userCancelledAuthentication: Foundation.URLError.Code {
    get
  }
  public static var userAuthenticationRequired: Foundation.URLError.Code {
    get
  }
  public static var zeroByteResource: Foundation.URLError.Code {
    get
  }
  public static var cannotDecodeRawData: Foundation.URLError.Code {
    get
  }
  public static var cannotDecodeContentData: Foundation.URLError.Code {
    get
  }
  public static var cannotParseResponse: Foundation.URLError.Code {
    get
  }
  @available(macOS 10.11, iOS 9.0, *)
  public static var appTransportSecurityRequiresSecureConnection: Foundation.URLError.Code {
    get
  }
  public static var fileDoesNotExist: Foundation.URLError.Code {
    get
  }
  public static var fileIsDirectory: Foundation.URLError.Code {
    get
  }
  public static var noPermissionsToReadFile: Foundation.URLError.Code {
    get
  }
  @available(macOS 10.5, iOS 2.0, *)
  public static var dataLengthExceedsMaximum: Foundation.URLError.Code {
    get
  }
  public static var secureConnectionFailed: Foundation.URLError.Code {
    get
  }
  public static var serverCertificateHasBadDate: Foundation.URLError.Code {
    get
  }
  public static var serverCertificateUntrusted: Foundation.URLError.Code {
    get
  }
  public static var serverCertificateHasUnknownRoot: Foundation.URLError.Code {
    get
  }
  public static var serverCertificateNotYetValid: Foundation.URLError.Code {
    get
  }
  public static var clientCertificateRejected: Foundation.URLError.Code {
    get
  }
  public static var clientCertificateRequired: Foundation.URLError.Code {
    get
  }
  public static var cannotLoadFromNetwork: Foundation.URLError.Code {
    get
  }
  public static var cannotCreateFile: Foundation.URLError.Code {
    get
  }
  public static var cannotOpenFile: Foundation.URLError.Code {
    get
  }
  public static var cannotCloseFile: Foundation.URLError.Code {
    get
  }
  public static var cannotWriteToFile: Foundation.URLError.Code {
    get
  }
  public static var cannotRemoveFile: Foundation.URLError.Code {
    get
  }
  public static var cannotMoveFile: Foundation.URLError.Code {
    get
  }
  public static var downloadDecodingFailedMidStream: Foundation.URLError.Code {
    get
  }
  public static var downloadDecodingFailedToComplete: Foundation.URLError.Code {
    get
  }
  @available(macOS 10.7, iOS 3.0, *)
  public static var internationalRoamingOff: Foundation.URLError.Code {
    get
  }
  @available(macOS 10.7, iOS 3.0, *)
  public static var callIsActive: Foundation.URLError.Code {
    get
  }
  @available(macOS 10.7, iOS 3.0, *)
  public static var dataNotAllowed: Foundation.URLError.Code {
    get
  }
  @available(macOS 10.7, iOS 3.0, *)
  public static var requestBodyStreamExhausted: Foundation.URLError.Code {
    get
  }
  @available(macOS 10.10, iOS 8.0, *)
  public static var backgroundSessionRequiresSharedContainer: Foundation.URLError.Code {
    get
  }
  @available(macOS 10.10, iOS 8.0, *)
  public static var backgroundSessionInUseByAnotherProcess: Foundation.URLError.Code {
    get
  }
  @available(macOS 10.10, iOS 8.0, *)
  public static var backgroundSessionWasDisconnected: Foundation.URLError.Code {
    get
  }
}
extension Foundation.URLError {
  @available(*, unavailable, renamed: "unknown")
  public static var Unknown: Foundation.URLError.Code {
    get
  }
  @available(*, unavailable, renamed: "cancelled")
  public static var Cancelled: Foundation.URLError.Code {
    get
  }
  @available(*, unavailable, renamed: "badURL")
  public static var BadURL: Foundation.URLError.Code {
    get
  }
  @available(*, unavailable, renamed: "timedOut")
  public static var TimedOut: Foundation.URLError.Code {
    get
  }
  @available(*, unavailable, renamed: "unsupportedURL")
  public static var UnsupportedURL: Foundation.URLError.Code {
    get
  }
  @available(*, unavailable, renamed: "cannotFindHost")
  public static var CannotFindHost: Foundation.URLError.Code {
    get
  }
  @available(*, unavailable, renamed: "cannotConnectToHost")
  public static var CannotConnectToHost: Foundation.URLError.Code {
    get
  }
  @available(*, unavailable, renamed: "networkConnectionLost")
  public static var NetworkConnectionLost: Foundation.URLError.Code {
    get
  }
  @available(*, unavailable, renamed: "dnsLookupFailed")
  public static var DNSLookupFailed: Foundation.URLError.Code {
    get
  }
  @available(*, unavailable, renamed: "httpTooManyRedirects")
  public static var HTTPTooManyRedirects: Foundation.URLError.Code {
    get
  }
  @available(*, unavailable, renamed: "resourceUnavailable")
  public static var ResourceUnavailable: Foundation.URLError.Code {
    get
  }
  @available(*, unavailable, renamed: "notConnectedToInternet")
  public static var NotConnectedToInternet: Foundation.URLError.Code {
    get
  }
  @available(*, unavailable, renamed: "redirectToNonExistentLocation")
  public static var RedirectToNonExistentLocation: Foundation.URLError.Code {
    get
  }
  @available(*, unavailable, renamed: "badServerResponse")
  public static var BadServerResponse: Foundation.URLError.Code {
    get
  }
  @available(*, unavailable, renamed: "userCancelledAuthentication")
  public static var UserCancelledAuthentication: Foundation.URLError.Code {
    get
  }
  @available(*, unavailable, renamed: "userAuthenticationRequired")
  public static var UserAuthenticationRequired: Foundation.URLError.Code {
    get
  }
  @available(*, unavailable, renamed: "zeroByteResource")
  public static var ZeroByteResource: Foundation.URLError.Code {
    get
  }
  @available(*, unavailable, renamed: "cannotDecodeRawData")
  public static var CannotDecodeRawData: Foundation.URLError.Code {
    get
  }
  @available(*, unavailable, renamed: "cannotDecodeContentData")
  public static var CannotDecodeContentData: Foundation.URLError.Code {
    get
  }
  @available(*, unavailable, renamed: "cannotParseResponse")
  public static var CannotParseResponse: Foundation.URLError.Code {
    get
  }
  @available(*, unavailable, renamed: "appTransportSecurityRequiresSecureConnection")
  public static var AppTransportSecurityRequiresSecureConnection: Foundation.URLError.Code {
    get
  }
  @available(*, unavailable, renamed: "fileDoesNotExist")
  public static var FileDoesNotExist: Foundation.URLError.Code {
    get
  }
  @available(*, unavailable, renamed: "fileIsDirectory")
  public static var FileIsDirectory: Foundation.URLError.Code {
    get
  }
  @available(*, unavailable, renamed: "noPermissionsToReadFile")
  public static var NoPermissionsToReadFile: Foundation.URLError.Code {
    get
  }
  @available(*, unavailable, renamed: "dataLengthExceedsMaximum")
  public static var DataLengthExceedsMaximum: Foundation.URLError.Code {
    get
  }
  @available(*, unavailable, renamed: "secureConnectionFailed")
  public static var SecureConnectionFailed: Foundation.URLError.Code {
    get
  }
  @available(*, unavailable, renamed: "serverCertificateHasBadDate")
  public static var ServerCertificateHasBadDate: Foundation.URLError.Code {
    get
  }
  @available(*, unavailable, renamed: "serverCertificateUntrusted")
  public static var ServerCertificateUntrusted: Foundation.URLError.Code {
    get
  }
  @available(*, unavailable, renamed: "serverCertificateHasUnknownRoot")
  public static var ServerCertificateHasUnknownRoot: Foundation.URLError.Code {
    get
  }
  @available(*, unavailable, renamed: "serverCertificateNotYetValid")
  public static var ServerCertificateNotYetValid: Foundation.URLError.Code {
    get
  }
  @available(*, unavailable, renamed: "clientCertificateRejected")
  public static var ClientCertificateRejected: Foundation.URLError.Code {
    get
  }
  @available(*, unavailable, renamed: "clientCertificateRequired")
  public static var ClientCertificateRequired: Foundation.URLError.Code {
    get
  }
  @available(*, unavailable, renamed: "cannotLoadFromNetwork")
  public static var CannotLoadFromNetwork: Foundation.URLError.Code {
    get
  }
  @available(*, unavailable, renamed: "cannotCreateFile")
  public static var CannotCreateFile: Foundation.URLError.Code {
    get
  }
  @available(*, unavailable, renamed: "cannotOpenFile")
  public static var CannotOpenFile: Foundation.URLError.Code {
    get
  }
  @available(*, unavailable, renamed: "cannotCloseFile")
  public static var CannotCloseFile: Foundation.URLError.Code {
    get
  }
  @available(*, unavailable, renamed: "cannotWriteToFile")
  public static var CannotWriteToFile: Foundation.URLError.Code {
    get
  }
  @available(*, unavailable, renamed: "cannotRemoveFile")
  public static var CannotRemoveFile: Foundation.URLError.Code {
    get
  }
  @available(*, unavailable, renamed: "cannotMoveFile")
  public static var CannotMoveFile: Foundation.URLError.Code {
    get
  }
  @available(*, unavailable, renamed: "downloadDecodingFailedMidStream")
  public static var DownloadDecodingFailedMidStream: Foundation.URLError.Code {
    get
  }
  @available(*, unavailable, renamed: "downloadDecodingFailedToComplete")
  public static var DownloadDecodingFailedToComplete: Foundation.URLError.Code {
    get
  }
  @available(*, unavailable, renamed: "internationalRoamingOff")
  public static var InternationalRoamingOff: Foundation.URLError.Code {
    get
  }
  @available(*, unavailable, renamed: "callIsActive")
  public static var CallIsActive: Foundation.URLError.Code {
    get
  }
  @available(*, unavailable, renamed: "dataNotAllowed")
  public static var DataNotAllowed: Foundation.URLError.Code {
    get
  }
  @available(*, unavailable, renamed: "requestBodyStreamExhausted")
  public static var RequestBodyStreamExhausted: Foundation.URLError.Code {
    get
  }
  @available(*, unavailable, renamed: "backgroundSessionRequiresSharedContainer")
  public static var BackgroundSessionRequiresSharedContainer: Foundation.URLError.Code {
    get
  }
  @available(*, unavailable, renamed: "backgroundSessionInUseByAnotherProcess")
  public static var BackgroundSessionInUseByAnotherProcess: Foundation.URLError.Code {
    get
  }
  @available(*, unavailable, renamed: "backgroundSessionWasDisconnected")
  public static var BackgroundSessionWasDisconnected: Foundation.URLError.Code {
    get
  }
}
public struct POSIXError : Foundation._BridgedStoredNSError {
  public let _nsError: Foundation.NSError
  public init(_nsError error: Foundation.NSError)
  public static var errorDomain: Swift.String {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
  public typealias Code = Darwin.POSIXErrorCode
}
extension Darwin.POSIXErrorCode : Foundation._ErrorCodeProtocol {
  public typealias _ErrorType = Foundation.POSIXError
}
extension Foundation.POSIXError {
  public static var EPERM: Darwin.POSIXErrorCode {
    get
  }
  public static var ENOENT: Darwin.POSIXErrorCode {
    get
  }
  public static var ESRCH: Darwin.POSIXErrorCode {
    get
  }
  public static var EINTR: Darwin.POSIXErrorCode {
    get
  }
  public static var EIO: Darwin.POSIXErrorCode {
    get
  }
  public static var ENXIO: Darwin.POSIXErrorCode {
    get
  }
  public static var E2BIG: Darwin.POSIXErrorCode {
    get
  }
  public static var ENOEXEC: Darwin.POSIXErrorCode {
    get
  }
  public static var EBADF: Darwin.POSIXErrorCode {
    get
  }
  public static var ECHILD: Darwin.POSIXErrorCode {
    get
  }
  public static var EDEADLK: Darwin.POSIXErrorCode {
    get
  }
  public static var ENOMEM: Darwin.POSIXErrorCode {
    get
  }
  public static var EACCES: Darwin.POSIXErrorCode {
    get
  }
  public static var EFAULT: Darwin.POSIXErrorCode {
    get
  }
  public static var ENOTBLK: Darwin.POSIXErrorCode {
    get
  }
  public static var EBUSY: Darwin.POSIXErrorCode {
    get
  }
  public static var EEXIST: Darwin.POSIXErrorCode {
    get
  }
  public static var EXDEV: Darwin.POSIXErrorCode {
    get
  }
  public static var ENODEV: Darwin.POSIXErrorCode {
    get
  }
  public static var ENOTDIR: Darwin.POSIXErrorCode {
    get
  }
  public static var EISDIR: Darwin.POSIXErrorCode {
    get
  }
  public static var EINVAL: Darwin.POSIXErrorCode {
    get
  }
  public static var ENFILE: Darwin.POSIXErrorCode {
    get
  }
  public static var EMFILE: Darwin.POSIXErrorCode {
    get
  }
  public static var ENOTTY: Darwin.POSIXErrorCode {
    get
  }
  public static var ETXTBSY: Darwin.POSIXErrorCode {
    get
  }
  public static var EFBIG: Darwin.POSIXErrorCode {
    get
  }
  public static var ENOSPC: Darwin.POSIXErrorCode {
    get
  }
  public static var ESPIPE: Darwin.POSIXErrorCode {
    get
  }
  public static var EROFS: Darwin.POSIXErrorCode {
    get
  }
  public static var EMLINK: Darwin.POSIXErrorCode {
    get
  }
  public static var EPIPE: Darwin.POSIXErrorCode {
    get
  }
  public static var EDOM: Darwin.POSIXErrorCode {
    get
  }
  public static var ERANGE: Darwin.POSIXErrorCode {
    get
  }
  public static var EAGAIN: Darwin.POSIXErrorCode {
    get
  }
  public static var EWOULDBLOCK: Darwin.POSIXErrorCode {
    get
  }
  public static var EINPROGRESS: Darwin.POSIXErrorCode {
    get
  }
  public static var EALREADY: Darwin.POSIXErrorCode {
    get
  }
  public static var ENOTSOCK: Darwin.POSIXErrorCode {
    get
  }
  public static var EDESTADDRREQ: Darwin.POSIXErrorCode {
    get
  }
  public static var EMSGSIZE: Darwin.POSIXErrorCode {
    get
  }
  public static var EPROTOTYPE: Darwin.POSIXErrorCode {
    get
  }
  public static var ENOPROTOOPT: Darwin.POSIXErrorCode {
    get
  }
  public static var EPROTONOSUPPORT: Darwin.POSIXErrorCode {
    get
  }
  public static var ESOCKTNOSUPPORT: Darwin.POSIXErrorCode {
    get
  }
  public static var ENOTSUP: Darwin.POSIXErrorCode {
    get
  }
  public static var EPFNOSUPPORT: Darwin.POSIXErrorCode {
    get
  }
  public static var EAFNOSUPPORT: Darwin.POSIXErrorCode {
    get
  }
  public static var EADDRINUSE: Darwin.POSIXErrorCode {
    get
  }
  public static var EADDRNOTAVAIL: Darwin.POSIXErrorCode {
    get
  }
  public static var ENETDOWN: Darwin.POSIXErrorCode {
    get
  }
  public static var ENETUNREACH: Darwin.POSIXErrorCode {
    get
  }
  public static var ENETRESET: Darwin.POSIXErrorCode {
    get
  }
  public static var ECONNABORTED: Darwin.POSIXErrorCode {
    get
  }
  public static var ECONNRESET: Darwin.POSIXErrorCode {
    get
  }
  public static var ENOBUFS: Darwin.POSIXErrorCode {
    get
  }
  public static var EISCONN: Darwin.POSIXErrorCode {
    get
  }
  public static var ENOTCONN: Darwin.POSIXErrorCode {
    get
  }
  public static var ESHUTDOWN: Darwin.POSIXErrorCode {
    get
  }
  public static var ETOOMANYREFS: Darwin.POSIXErrorCode {
    get
  }
  public static var ETIMEDOUT: Darwin.POSIXErrorCode {
    get
  }
  public static var ECONNREFUSED: Darwin.POSIXErrorCode {
    get
  }
  public static var ELOOP: Darwin.POSIXErrorCode {
    get
  }
  public static var ENAMETOOLONG: Darwin.POSIXErrorCode {
    get
  }
  public static var EHOSTDOWN: Darwin.POSIXErrorCode {
    get
  }
  public static var EHOSTUNREACH: Darwin.POSIXErrorCode {
    get
  }
  public static var ENOTEMPTY: Darwin.POSIXErrorCode {
    get
  }
  public static var EPROCLIM: Darwin.POSIXErrorCode {
    get
  }
  public static var EUSERS: Darwin.POSIXErrorCode {
    get
  }
  public static var EDQUOT: Darwin.POSIXErrorCode {
    get
  }
  public static var ESTALE: Darwin.POSIXErrorCode {
    get
  }
  public static var EREMOTE: Darwin.POSIXErrorCode {
    get
  }
  public static var EBADRPC: Darwin.POSIXErrorCode {
    get
  }
  public static var ERPCMISMATCH: Darwin.POSIXErrorCode {
    get
  }
  public static var EPROGUNAVAIL: Darwin.POSIXErrorCode {
    get
  }
  public static var EPROGMISMATCH: Darwin.POSIXErrorCode {
    get
  }
  public static var EPROCUNAVAIL: Darwin.POSIXErrorCode {
    get
  }
  public static var ENOLCK: Darwin.POSIXErrorCode {
    get
  }
  public static var ENOSYS: Darwin.POSIXErrorCode {
    get
  }
  public static var EFTYPE: Darwin.POSIXErrorCode {
    get
  }
  public static var EAUTH: Darwin.POSIXErrorCode {
    get
  }
  public static var ENEEDAUTH: Darwin.POSIXErrorCode {
    get
  }
  public static var EPWROFF: Darwin.POSIXErrorCode {
    get
  }
  public static var EDEVERR: Darwin.POSIXErrorCode {
    get
  }
  public static var EOVERFLOW: Darwin.POSIXErrorCode {
    get
  }
  public static var EBADEXEC: Darwin.POSIXErrorCode {
    get
  }
  public static var EBADARCH: Darwin.POSIXErrorCode {
    get
  }
  public static var ESHLIBVERS: Darwin.POSIXErrorCode {
    get
  }
  public static var EBADMACHO: Darwin.POSIXErrorCode {
    get
  }
  public static var ECANCELED: Darwin.POSIXErrorCode {
    get
  }
  public static var EIDRM: Darwin.POSIXErrorCode {
    get
  }
  public static var ENOMSG: Darwin.POSIXErrorCode {
    get
  }
  public static var EILSEQ: Darwin.POSIXErrorCode {
    get
  }
  public static var ENOATTR: Darwin.POSIXErrorCode {
    get
  }
  public static var EBADMSG: Darwin.POSIXErrorCode {
    get
  }
  public static var EMULTIHOP: Darwin.POSIXErrorCode {
    get
  }
  public static var ENODATA: Darwin.POSIXErrorCode {
    get
  }
  public static var ENOLINK: Darwin.POSIXErrorCode {
    get
  }
  public static var ENOSR: Darwin.POSIXErrorCode {
    get
  }
  public static var ENOSTR: Darwin.POSIXErrorCode {
    get
  }
  public static var EPROTO: Darwin.POSIXErrorCode {
    get
  }
  public static var ETIME: Darwin.POSIXErrorCode {
    get
  }
  public static var ENOPOLICY: Darwin.POSIXErrorCode {
    get
  }
  public static var ENOTRECOVERABLE: Darwin.POSIXErrorCode {
    get
  }
  public static var EOWNERDEAD: Darwin.POSIXErrorCode {
    get
  }
  public static var EQFULL: Darwin.POSIXErrorCode {
    get
  }
}
public struct MachError : Foundation._BridgedStoredNSError {
  public let _nsError: Foundation.NSError
  public init(_nsError error: Foundation.NSError)
  public static var errorDomain: Swift.String {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
  public typealias Code = Darwin.MachErrorCode
}
extension Darwin.MachErrorCode : Foundation._ErrorCodeProtocol {
  public typealias _ErrorType = Foundation.MachError
}
extension Foundation.MachError {
  public static var success: Foundation.MachError.Code {
    get
  }
  public static var invalidAddress: Foundation.MachError.Code {
    get
  }
  public static var protectionFailure: Foundation.MachError.Code {
    get
  }
  public static var noSpace: Foundation.MachError.Code {
    get
  }
  public static var invalidArgument: Foundation.MachError.Code {
    get
  }
  public static var failure: Foundation.MachError.Code {
    get
  }
  public static var resourceShortage: Foundation.MachError.Code {
    get
  }
  public static var notReceiver: Foundation.MachError.Code {
    get
  }
  public static var noAccess: Foundation.MachError.Code {
    get
  }
  public static var memoryFailure: Foundation.MachError.Code {
    get
  }
  public static var memoryError: Foundation.MachError.Code {
    get
  }
  public static var alreadyInSet: Foundation.MachError.Code {
    get
  }
  public static var notInSet: Foundation.MachError.Code {
    get
  }
  public static var nameExists: Foundation.MachError.Code {
    get
  }
  public static var aborted: Foundation.MachError.Code {
    get
  }
  public static var invalidName: Foundation.MachError.Code {
    get
  }
  public static var invalidTask: Foundation.MachError.Code {
    get
  }
  public static var invalidRight: Foundation.MachError.Code {
    get
  }
  public static var invalidValue: Foundation.MachError.Code {
    get
  }
  public static var userReferencesOverflow: Foundation.MachError.Code {
    get
  }
  public static var invalidCapability: Foundation.MachError.Code {
    get
  }
  public static var rightExists: Foundation.MachError.Code {
    get
  }
  public static var invalidHost: Foundation.MachError.Code {
    get
  }
  public static var memoryPresent: Foundation.MachError.Code {
    get
  }
  public static var memoryDataMoved: Foundation.MachError.Code {
    get
  }
  public static var memoryRestartCopy: Foundation.MachError.Code {
    get
  }
  public static var invalidProcessorSet: Foundation.MachError.Code {
    get
  }
  public static var policyLimit: Foundation.MachError.Code {
    get
  }
  public static var invalidPolicy: Foundation.MachError.Code {
    get
  }
  public static var invalidObject: Foundation.MachError.Code {
    get
  }
  public static var alreadyWaiting: Foundation.MachError.Code {
    get
  }
  public static var defaultSet: Foundation.MachError.Code {
    get
  }
  public static var exceptionProtected: Foundation.MachError.Code {
    get
  }
  public static var invalidLedger: Foundation.MachError.Code {
    get
  }
  public static var invalidMemoryControl: Foundation.MachError.Code {
    get
  }
  public static var invalidSecurity: Foundation.MachError.Code {
    get
  }
  public static var notDepressed: Foundation.MachError.Code {
    get
  }
  public static var terminated: Foundation.MachError.Code {
    get
  }
  public static var lockSetDestroyed: Foundation.MachError.Code {
    get
  }
  public static var lockUnstable: Foundation.MachError.Code {
    get
  }
  public static var lockOwned: Foundation.MachError.Code {
    get
  }
  public static var lockOwnedSelf: Foundation.MachError.Code {
    get
  }
  public static var semaphoreDestroyed: Foundation.MachError.Code {
    get
  }
  public static var rpcServerTerminated: Foundation.MachError.Code {
    get
  }
  public static var rpcTerminateOrphan: Foundation.MachError.Code {
    get
  }
  public static var rpcContinueOrphan: Foundation.MachError.Code {
    get
  }
  public static var notSupported: Foundation.MachError.Code {
    get
  }
  public static var nodeDown: Foundation.MachError.Code {
    get
  }
  public static var notWaiting: Foundation.MachError.Code {
    get
  }
  public static var operationTimedOut: Foundation.MachError.Code {
    get
  }
  public static var codesignError: Foundation.MachError.Code {
    get
  }
  public static var policyStatic: Foundation.MachError.Code {
    get
  }
}
public struct ErrorUserInfoKey : Swift.RawRepresentable, Swift._SwiftNewtypeWrapper, Swift.Equatable, Swift.Hashable, Swift._ObjectiveCBridgeable {
  public typealias _ObjectiveCType = Foundation.NSString
  public init(rawValue: Swift.String)
  public var rawValue: Swift.String
  public typealias RawValue = Swift.String
}
extension Foundation.ErrorUserInfoKey {
  @available(*, deprecated, renamed: "NSUnderlyingErrorKey")
  public static let underlyingErrorKey: Foundation.ErrorUserInfoKey
  @available(*, deprecated, renamed: "NSLocalizedDescriptionKey")
  public static let localizedDescriptionKey: Foundation.ErrorUserInfoKey
  @available(*, deprecated, renamed: "NSLocalizedFailureReasonErrorKey")
  public static let localizedFailureReasonErrorKey: Foundation.ErrorUserInfoKey
  @available(*, deprecated, renamed: "NSLocalizedRecoverySuggestionErrorKey")
  public static let localizedRecoverySuggestionErrorKey: Foundation.ErrorUserInfoKey
  @available(*, deprecated, renamed: "NSLocalizedRecoveryOptionsErrorKey")
  public static let localizedRecoveryOptionsErrorKey: Foundation.ErrorUserInfoKey
  @available(*, deprecated, renamed: "NSRecoveryAttempterErrorKey")
  public static let recoveryAttempterErrorKey: Foundation.ErrorUserInfoKey
  @available(*, deprecated, renamed: "NSHelpAnchorErrorKey")
  public static let helpAnchorErrorKey: Foundation.ErrorUserInfoKey
  @available(*, deprecated, renamed: "NSStringEncodingErrorKey")
  public static let stringEncodingErrorKey: Foundation.ErrorUserInfoKey
  @available(*, deprecated, renamed: "NSURLErrorKey")
  public static let NSURLErrorKey: Foundation.ErrorUserInfoKey
  @available(*, deprecated, renamed: "NSFilePathErrorKey")
  public static let filePathErrorKey: Foundation.ErrorUserInfoKey
}
extension Foundation.Date {
  @available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
  public struct ComponentsFormatStyle : Foundation.FormatStyle, Swift.Codable, Swift.Hashable {
    public struct Field : Swift.Codable, Swift.Hashable {
      public static var year: Foundation.Date.ComponentsFormatStyle.Field {
        get
      }
      public static var month: Foundation.Date.ComponentsFormatStyle.Field {
        get
      }
      public static var week: Foundation.Date.ComponentsFormatStyle.Field {
        get
      }
      public static var day: Foundation.Date.ComponentsFormatStyle.Field {
        get
      }
      public static var hour: Foundation.Date.ComponentsFormatStyle.Field {
        get
      }
      public static var minute: Foundation.Date.ComponentsFormatStyle.Field {
        get
      }
      public static var second: Foundation.Date.ComponentsFormatStyle.Field {
        get
      }
      public func hash(into hasher: inout Swift.Hasher)
      public static func == (a: Foundation.Date.ComponentsFormatStyle.Field, b: Foundation.Date.ComponentsFormatStyle.Field) -> Swift.Bool
      public func encode(to encoder: Swift.Encoder) throws
      public var hashValue: Swift.Int {
        get
      }
      public init(from decoder: Swift.Decoder) throws
    }
    public struct Style : Swift.Codable, Swift.Hashable {
      public static var wide: Foundation.Date.ComponentsFormatStyle.Style {
        get
      }
      public static var abbreviated: Foundation.Date.ComponentsFormatStyle.Style {
        get
      }
      public static var condensedAbbreviated: Foundation.Date.ComponentsFormatStyle.Style {
        get
      }
      public static var narrow: Foundation.Date.ComponentsFormatStyle.Style {
        get
      }
      public static var spellOut: Foundation.Date.ComponentsFormatStyle.Style {
        get
      }
      public func hash(into hasher: inout Swift.Hasher)
      public static func == (a: Foundation.Date.ComponentsFormatStyle.Style, b: Foundation.Date.ComponentsFormatStyle.Style) -> Swift.Bool
      public func encode(to encoder: Swift.Encoder) throws
      public var hashValue: Swift.Int {
        get
      }
      public init(from decoder: Swift.Decoder) throws
    }
    public var style: Foundation.Date.ComponentsFormatStyle.Style
    public var fields: Swift.Set<Foundation.Date.ComponentsFormatStyle.Field>?
    public var calendar: Foundation.Calendar
    public var locale: Foundation.Locale
    public init(style: Foundation.Date.ComponentsFormatStyle.Style, locale: Foundation.Locale = .autoupdatingCurrent, calendar: Foundation.Calendar = .autoupdatingCurrent, fields: Swift.Set<Foundation.Date.ComponentsFormatStyle.Field>? = nil)
    public func format(_ v: Swift.Range<Foundation.Date>) -> Swift.String
    public func calendar(_ calendar: Foundation.Calendar) -> Foundation.Date.ComponentsFormatStyle
    public func locale(_ locale: Foundation.Locale) -> Foundation.Date.ComponentsFormatStyle
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: Foundation.Date.ComponentsFormatStyle, b: Foundation.Date.ComponentsFormatStyle) -> Swift.Bool
    public typealias FormatInput = Swift.Range<Foundation.Date>
    public typealias FormatOutput = Swift.String
    public func encode(to encoder: Swift.Encoder) throws
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: Swift.Decoder) throws
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.FormatStyle where Self == Foundation.Date.ComponentsFormatStyle {
  public static func components(style: Foundation.Date.ComponentsFormatStyle.Style, fields: Swift.Set<Foundation.Date.ComponentsFormatStyle.Field>? = nil) -> Self
  public static var timeDuration: Foundation.Date.ComponentsFormatStyle {
    get
  }
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
public protocol ObjectiveCConvertibleAttributedStringKey : Foundation.AttributedStringKey {
  associatedtype ObjectiveCValue : ObjectiveC.NSObject
  static func objectiveCValue(for value: Self.Value) throws -> Self.ObjectiveCValue
  static func value(for object: Self.ObjectiveCValue) throws -> Self.Value
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.ObjectiveCConvertibleAttributedStringKey where Self.ObjectiveCValue == Foundation.NSNumber, Self.Value : Swift.RawRepresentable, Self.Value.RawValue == Swift.Int {
  public static func objectiveCValue(for value: Self.Value) throws -> Self.ObjectiveCValue
  public static func value(for object: Self.ObjectiveCValue) throws -> Self.Value
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.ObjectiveCConvertibleAttributedStringKey where Self.ObjectiveCValue == Foundation.NSString, Self.Value : Swift.RawRepresentable, Self.Value.RawValue == Swift.String {
  public static func objectiveCValue(for value: Self.Value) throws -> Self.ObjectiveCValue
  public static func value(for object: Self.ObjectiveCValue) throws -> Self.Value
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.AttributeContainer {
  public init(_ dictionary: [Foundation.NSAttributedString.Key : Any])
  public init<S>(_ dictionary: [Foundation.NSAttributedString.Key : Any], including scope: Swift.KeyPath<Foundation.AttributeScopes, S.Type>) throws where S : Foundation.AttributeScope
  public init<S>(_ dictionary: [Foundation.NSAttributedString.Key : Any], including scope: S.Type) throws where S : Foundation.AttributeScope
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Swift.Dictionary where Key == Foundation.NSAttributedString.Key, Value == Any {
  public init(_ container: Foundation.AttributeContainer)
  public init<S>(_ container: Foundation.AttributeContainer, including scope: Swift.KeyPath<Foundation.AttributeScopes, S.Type>) throws where S : Foundation.AttributeScope
  public init<S>(_ container: Foundation.AttributeContainer, including scope: S.Type) throws where S : Foundation.AttributeScope
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.NSAttributedString {
  convenience public init(_ attrStr: Foundation.AttributedString)
  convenience public init<S>(_ attrStr: Foundation.AttributedString, including scope: Swift.KeyPath<Foundation.AttributeScopes, S.Type>) throws where S : Foundation.AttributeScope
  convenience public init<S>(_ attrStr: Foundation.AttributedString, including scope: S.Type) throws where S : Foundation.AttributeScope
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.AttributedString {
  public init(_ nsStr: Foundation.NSAttributedString)
  public init<S>(_ nsStr: Foundation.NSAttributedString, including scope: Swift.KeyPath<Foundation.AttributeScopes, S.Type>) throws where S : Foundation.AttributeScope
  public init<S>(_ nsStr: Foundation.NSAttributedString, including scope: S.Type) throws where S : Foundation.AttributeScope
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Swift.String.Index {
  public init?<S>(_ sourcePosition: Foundation.AttributedString.Index, within target: S) where S : Swift.StringProtocol
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.AttributedString.Index {
  public init?<S>(_ sourcePosition: Swift.String.Index, within target: S) where S : Foundation.AttributedStringProtocol
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation._NSRange {
  public init<R, S>(_ region: R, in target: S) where R : Swift.RangeExpression, S : Foundation.AttributedStringProtocol, R.Bound == Foundation.AttributedString.Index
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Swift.Range where Bound == Foundation.AttributedString.Index {
  public init?<S>(_ range: Foundation.NSRange, in attrStr: S) where S : Foundation.AttributedStringProtocol
  public init?<R, S>(_ region: R, in attrStr: S) where R : Swift.RangeExpression, S : Foundation.AttributedStringProtocol, R.Bound == Swift.String.Index
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Swift.Range where Bound == Swift.String.Index {
  public init?<R, S>(_ region: R, in string: S) where R : Swift.RangeExpression, S : Swift.StringProtocol, R.Bound == Foundation.AttributedString.Index
}
extension Swift.Int8 : Swift._ObjectiveCBridgeable {
  @available(swift, deprecated: 4, renamed: "init(truncating:)")
  public init(_ number: __shared Foundation.NSNumber)
  public init(truncating number: __shared Foundation.NSNumber)
  public init?(exactly number: __shared Foundation.NSNumber)
  @_semantics("convertToObjectiveC") public func _bridgeToObjectiveC() -> Foundation.NSNumber
  public static func _forceBridgeFromObjectiveC(_ x: Foundation.NSNumber, result: inout Swift.Int8?)
  public static func _conditionallyBridgeFromObjectiveC(_ x: Foundation.NSNumber, result: inout Swift.Int8?) -> Swift.Bool
  @_effects(readonly) public static func _unconditionallyBridgeFromObjectiveC(_ source: Foundation.NSNumber?) -> Swift.Int8
  public typealias _ObjectiveCType = Foundation.NSNumber
}
extension Swift.UInt8 : Swift._ObjectiveCBridgeable {
  @available(swift, deprecated: 4, renamed: "init(truncating:)")
  public init(_ number: __shared Foundation.NSNumber)
  public init(truncating number: __shared Foundation.NSNumber)
  public init?(exactly number: __shared Foundation.NSNumber)
  @_semantics("convertToObjectiveC") public func _bridgeToObjectiveC() -> Foundation.NSNumber
  public static func _forceBridgeFromObjectiveC(_ x: Foundation.NSNumber, result: inout Swift.UInt8?)
  public static func _conditionallyBridgeFromObjectiveC(_ x: Foundation.NSNumber, result: inout Swift.UInt8?) -> Swift.Bool
  @_effects(readonly) public static func _unconditionallyBridgeFromObjectiveC(_ source: Foundation.NSNumber?) -> Swift.UInt8
  public typealias _ObjectiveCType = Foundation.NSNumber
}
extension Swift.Int16 : Swift._ObjectiveCBridgeable {
  @available(swift, deprecated: 4, renamed: "init(truncating:)")
  public init(_ number: __shared Foundation.NSNumber)
  public init(truncating number: __shared Foundation.NSNumber)
  public init?(exactly number: __shared Foundation.NSNumber)
  @_semantics("convertToObjectiveC") public func _bridgeToObjectiveC() -> Foundation.NSNumber
  public static func _forceBridgeFromObjectiveC(_ x: Foundation.NSNumber, result: inout Swift.Int16?)
  public static func _conditionallyBridgeFromObjectiveC(_ x: Foundation.NSNumber, result: inout Swift.Int16?) -> Swift.Bool
  @_effects(readonly) public static func _unconditionallyBridgeFromObjectiveC(_ source: Foundation.NSNumber?) -> Swift.Int16
  public typealias _ObjectiveCType = Foundation.NSNumber
}
extension Swift.UInt16 : Swift._ObjectiveCBridgeable {
  @available(swift, deprecated: 4, renamed: "init(truncating:)")
  public init(_ number: __shared Foundation.NSNumber)
  public init(truncating number: __shared Foundation.NSNumber)
  public init?(exactly number: __shared Foundation.NSNumber)
  @_semantics("convertToObjectiveC") public func _bridgeToObjectiveC() -> Foundation.NSNumber
  public static func _forceBridgeFromObjectiveC(_ x: Foundation.NSNumber, result: inout Swift.UInt16?)
  public static func _conditionallyBridgeFromObjectiveC(_ x: Foundation.NSNumber, result: inout Swift.UInt16?) -> Swift.Bool
  @_effects(readonly) public static func _unconditionallyBridgeFromObjectiveC(_ source: Foundation.NSNumber?) -> Swift.UInt16
  public typealias _ObjectiveCType = Foundation.NSNumber
}
extension Swift.Int32 : Swift._ObjectiveCBridgeable {
  @available(swift, deprecated: 4, renamed: "init(truncating:)")
  public init(_ number: __shared Foundation.NSNumber)
  public init(truncating number: __shared Foundation.NSNumber)
  public init?(exactly number: __shared Foundation.NSNumber)
  @_semantics("convertToObjectiveC") public func _bridgeToObjectiveC() -> Foundation.NSNumber
  public static func _forceBridgeFromObjectiveC(_ x: Foundation.NSNumber, result: inout Swift.Int32?)
  public static func _conditionallyBridgeFromObjectiveC(_ x: Foundation.NSNumber, result: inout Swift.Int32?) -> Swift.Bool
  @_effects(readonly) public static func _unconditionallyBridgeFromObjectiveC(_ source: Foundation.NSNumber?) -> Swift.Int32
  public typealias _ObjectiveCType = Foundation.NSNumber
}
extension Swift.UInt32 : Swift._ObjectiveCBridgeable {
  @available(swift, deprecated: 4, renamed: "init(truncating:)")
  public init(_ number: __shared Foundation.NSNumber)
  public init(truncating number: __shared Foundation.NSNumber)
  public init?(exactly number: __shared Foundation.NSNumber)
  @_semantics("convertToObjectiveC") public func _bridgeToObjectiveC() -> Foundation.NSNumber
  public static func _forceBridgeFromObjectiveC(_ x: Foundation.NSNumber, result: inout Swift.UInt32?)
  public static func _conditionallyBridgeFromObjectiveC(_ x: Foundation.NSNumber, result: inout Swift.UInt32?) -> Swift.Bool
  @_effects(readonly) public static func _unconditionallyBridgeFromObjectiveC(_ source: Foundation.NSNumber?) -> Swift.UInt32
  public typealias _ObjectiveCType = Foundation.NSNumber
}
extension Swift.Int64 : Swift._ObjectiveCBridgeable {
  @available(swift, deprecated: 4, renamed: "init(truncating:)")
  public init(_ number: __shared Foundation.NSNumber)
  public init(truncating number: __shared Foundation.NSNumber)
  public init?(exactly number: __shared Foundation.NSNumber)
  @_semantics("convertToObjectiveC") public func _bridgeToObjectiveC() -> Foundation.NSNumber
  public static func _forceBridgeFromObjectiveC(_ x: Foundation.NSNumber, result: inout Swift.Int64?)
  public static func _conditionallyBridgeFromObjectiveC(_ x: Foundation.NSNumber, result: inout Swift.Int64?) -> Swift.Bool
  @_effects(readonly) public static func _unconditionallyBridgeFromObjectiveC(_ source: Foundation.NSNumber?) -> Swift.Int64
  public typealias _ObjectiveCType = Foundation.NSNumber
}
extension Swift.UInt64 : Swift._ObjectiveCBridgeable {
  @available(swift, deprecated: 4, renamed: "init(truncating:)")
  public init(_ number: __shared Foundation.NSNumber)
  public init(truncating number: __shared Foundation.NSNumber)
  public init?(exactly number: __shared Foundation.NSNumber)
  @_semantics("convertToObjectiveC") public func _bridgeToObjectiveC() -> Foundation.NSNumber
  public static func _forceBridgeFromObjectiveC(_ x: Foundation.NSNumber, result: inout Swift.UInt64?)
  public static func _conditionallyBridgeFromObjectiveC(_ x: Foundation.NSNumber, result: inout Swift.UInt64?) -> Swift.Bool
  @_effects(readonly) public static func _unconditionallyBridgeFromObjectiveC(_ source: Foundation.NSNumber?) -> Swift.UInt64
  public typealias _ObjectiveCType = Foundation.NSNumber
}
extension Swift.Int : Swift._ObjectiveCBridgeable {
  @available(swift, deprecated: 4, renamed: "init(truncating:)")
  public init(_ number: __shared Foundation.NSNumber)
  public init(truncating number: __shared Foundation.NSNumber)
  public init?(exactly number: __shared Foundation.NSNumber)
  @_semantics("convertToObjectiveC") public func _bridgeToObjectiveC() -> Foundation.NSNumber
  public static func _forceBridgeFromObjectiveC(_ x: Foundation.NSNumber, result: inout Swift.Int?)
  public static func _conditionallyBridgeFromObjectiveC(_ x: Foundation.NSNumber, result: inout Swift.Int?) -> Swift.Bool
  @_effects(readonly) public static func _unconditionallyBridgeFromObjectiveC(_ source: Foundation.NSNumber?) -> Swift.Int
  public typealias _ObjectiveCType = Foundation.NSNumber
}
extension Swift.UInt : Swift._ObjectiveCBridgeable {
  @available(swift, deprecated: 4, renamed: "init(truncating:)")
  public init(_ number: __shared Foundation.NSNumber)
  public init(truncating number: __shared Foundation.NSNumber)
  public init?(exactly number: __shared Foundation.NSNumber)
  @_semantics("convertToObjectiveC") public func _bridgeToObjectiveC() -> Foundation.NSNumber
  public static func _forceBridgeFromObjectiveC(_ x: Foundation.NSNumber, result: inout Swift.UInt?)
  public static func _conditionallyBridgeFromObjectiveC(_ x: Foundation.NSNumber, result: inout Swift.UInt?) -> Swift.Bool
  @_effects(readonly) public static func _unconditionallyBridgeFromObjectiveC(_ source: Foundation.NSNumber?) -> Swift.UInt
  public typealias _ObjectiveCType = Foundation.NSNumber
}
extension Swift.Float : Swift._ObjectiveCBridgeable {
  @available(swift, deprecated: 4, renamed: "init(truncating:)")
  public init(_ number: __shared Foundation.NSNumber)
  public init(truncating number: __shared Foundation.NSNumber)
  public init?(exactly number: __shared Foundation.NSNumber)
  @_semantics("convertToObjectiveC") public func _bridgeToObjectiveC() -> Foundation.NSNumber
  public static func _forceBridgeFromObjectiveC(_ x: Foundation.NSNumber, result: inout Swift.Float?)
  public static func _conditionallyBridgeFromObjectiveC(_ x: Foundation.NSNumber, result: inout Swift.Float?) -> Swift.Bool
  @_effects(readonly) public static func _unconditionallyBridgeFromObjectiveC(_ source: Foundation.NSNumber?) -> Swift.Float
  public typealias _ObjectiveCType = Foundation.NSNumber
}
extension Swift.Double : Swift._ObjectiveCBridgeable {
  @available(swift, deprecated: 4, renamed: "init(truncating:)")
  public init(_ number: __shared Foundation.NSNumber)
  public init(truncating number: __shared Foundation.NSNumber)
  public init?(exactly number: __shared Foundation.NSNumber)
  @_semantics("convertToObjectiveC") public func _bridgeToObjectiveC() -> Foundation.NSNumber
  public static func _forceBridgeFromObjectiveC(_ x: Foundation.NSNumber, result: inout Swift.Double?)
  public static func _conditionallyBridgeFromObjectiveC(_ x: Foundation.NSNumber, result: inout Swift.Double?) -> Swift.Bool
  @_effects(readonly) public static func _unconditionallyBridgeFromObjectiveC(_ source: Foundation.NSNumber?) -> Swift.Double
  public typealias _ObjectiveCType = Foundation.NSNumber
}
extension Swift.Bool : Swift._ObjectiveCBridgeable {
  @available(swift, deprecated: 4, renamed: "init(truncating:)")
  public init(_ number: __shared Foundation.NSNumber)
  public init(truncating number: __shared Foundation.NSNumber)
  public init?(exactly number: __shared Foundation.NSNumber)
  @_semantics("convertToObjectiveC") public func _bridgeToObjectiveC() -> Foundation.NSNumber
  public static func _forceBridgeFromObjectiveC(_ x: Foundation.NSNumber, result: inout Swift.Bool?)
  public static func _conditionallyBridgeFromObjectiveC(_ x: Foundation.NSNumber, result: inout Swift.Bool?) -> Swift.Bool
  @_effects(readonly) public static func _unconditionallyBridgeFromObjectiveC(_ source: Foundation.NSNumber?) -> Swift.Bool
  public typealias _ObjectiveCType = Foundation.NSNumber
}
extension CoreGraphics.CGFloat : Swift._ObjectiveCBridgeable {
  @available(swift, deprecated: 4, renamed: "init(truncating:)")
  public init(_ number: __shared Foundation.NSNumber)
  public init(truncating number: __shared Foundation.NSNumber)
  public init?(exactly number: __shared Foundation.NSNumber)
  @_semantics("convertToObjectiveC") public func _bridgeToObjectiveC() -> Foundation.NSNumber
  public static func _forceBridgeFromObjectiveC(_ x: Foundation.NSNumber, result: inout CoreGraphics.CGFloat?)
  public static func _conditionallyBridgeFromObjectiveC(_ x: Foundation.NSNumber, result: inout CoreGraphics.CGFloat?) -> Swift.Bool
  @_effects(readonly) public static func _unconditionallyBridgeFromObjectiveC(_ source: Foundation.NSNumber?) -> CoreGraphics.CGFloat
  public typealias _ObjectiveCType = Foundation.NSNumber
}
extension Foundation.NSNumber : Swift.ExpressibleByFloatLiteral, Swift.ExpressibleByIntegerLiteral, Swift.ExpressibleByBooleanLiteral {
  @nonobjc required convenience public init(integerLiteral value: Swift.Int)
  @nonobjc required convenience public init(floatLiteral value: Swift.Double)
  @nonobjc required convenience public init(booleanLiteral value: Swift.Bool)
  public typealias BooleanLiteralType = Swift.Bool
  public typealias FloatLiteralType = Swift.Double
  public typealias IntegerLiteralType = Swift.Int
}
extension Foundation.NSNumber : Swift._HasCustomAnyHashableRepresentation {
  @nonobjc public func _toCustomAnyHashable() -> Swift.AnyHashable?
}
@available(macOS 10.12, iOS 10.0, watchOS 3.0, tvOS 10.0, *)
public struct Measurement<UnitType> : Foundation.ReferenceConvertible, Swift.Comparable, Swift.Equatable where UnitType : Foundation.Unit {
  public typealias ReferenceType = Foundation.NSMeasurement
  public let unit: UnitType
  public var value: Swift.Double
  public init(value: Swift.Double, unit: UnitType)
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@available(macOS 10.12, iOS 10.0, watchOS 3.0, tvOS 10.0, *)
extension Foundation.Measurement : Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible, Swift.CustomReflectable {
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
  public var customMirror: Swift.Mirror {
    get
  }
}
@available(macOS 10.12, iOS 10.0, watchOS 3.0, tvOS 10.0, *)
extension Foundation.Measurement where UnitType : Foundation.Dimension {
  public func converted(to otherUnit: UnitType) -> Foundation.Measurement<UnitType>
  public mutating func convert(to otherUnit: UnitType)
  public static func + (lhs: Foundation.Measurement<UnitType>, rhs: Foundation.Measurement<UnitType>) -> Foundation.Measurement<UnitType>
  public static func - (lhs: Foundation.Measurement<UnitType>, rhs: Foundation.Measurement<UnitType>) -> Foundation.Measurement<UnitType>
}
@available(macOS 10.12, iOS 10.0, watchOS 3.0, tvOS 10.0, *)
extension Foundation.Measurement {
  public static func + (lhs: Foundation.Measurement<UnitType>, rhs: Foundation.Measurement<UnitType>) -> Foundation.Measurement<UnitType>
  public static func - (lhs: Foundation.Measurement<UnitType>, rhs: Foundation.Measurement<UnitType>) -> Foundation.Measurement<UnitType>
  public static func * (lhs: Foundation.Measurement<UnitType>, rhs: Swift.Double) -> Foundation.Measurement<UnitType>
  public static func * (lhs: Swift.Double, rhs: Foundation.Measurement<UnitType>) -> Foundation.Measurement<UnitType>
  public static func / (lhs: Foundation.Measurement<UnitType>, rhs: Swift.Double) -> Foundation.Measurement<UnitType>
  public static func / (lhs: Swift.Double, rhs: Foundation.Measurement<UnitType>) -> Foundation.Measurement<UnitType>
  public static func == <LeftHandSideType, RightHandSideType>(lhs: Foundation.Measurement<LeftHandSideType>, rhs: Foundation.Measurement<RightHandSideType>) -> Swift.Bool where LeftHandSideType : Foundation.Unit, RightHandSideType : Foundation.Unit
  public static func < <LeftHandSideType, RightHandSideType>(lhs: Foundation.Measurement<LeftHandSideType>, rhs: Foundation.Measurement<RightHandSideType>) -> Swift.Bool where LeftHandSideType : Foundation.Unit, RightHandSideType : Foundation.Unit
}
@usableFromInline
internal typealias MeasurementBridgeType = Swift._ObjectiveCBridgeable
@available(macOS 10.12, iOS 10.0, watchOS 3.0, tvOS 10.0, *)
extension Foundation.Measurement : Foundation.MeasurementBridgeType {
  @_semantics("convertToObjectiveC") public func _bridgeToObjectiveC() -> Foundation.NSMeasurement
  public static func _forceBridgeFromObjectiveC(_ source: Foundation.NSMeasurement, result: inout Foundation.Measurement<UnitType>?)
  public static func _conditionallyBridgeFromObjectiveC(_ source: Foundation.NSMeasurement, result: inout Foundation.Measurement<UnitType>?) -> Swift.Bool
  @_effects(readonly) public static func _unconditionallyBridgeFromObjectiveC(_ source: Foundation.NSMeasurement?) -> Foundation.Measurement<UnitType>
  public typealias _ObjectiveCType = Foundation.NSMeasurement
}
@available(macOS 10.12, iOS 10.0, watchOS 3.0, tvOS 10.0, *)
extension Foundation.NSMeasurement : Swift._HasCustomAnyHashableRepresentation {
  @nonobjc public func _toCustomAnyHashable() -> Swift.AnyHashable?
}
@available(macOS 10.12, iOS 10.0, watchOS 3.0, tvOS 10.0, *)
extension Foundation.MeasurementFormatter {
  public func string<UnitType>(from measurement: Foundation.Measurement<UnitType>) -> Swift.String where UnitType : Foundation.Unit
}
@available(macOS 10.12, iOS 10.0, watchOS 3.0, tvOS 10.0, *)
extension Foundation.Measurement : Swift.Codable {
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
public struct FloatingPointFormatStyle<Value> : Swift.Codable, Swift.Hashable where Value : Swift.BinaryFloatingPoint {
  public var locale: Foundation.Locale
  public init(locale: Foundation.Locale = .autoupdatingCurrent)
  public var attributed: Foundation.FloatingPointFormatStyle<Value>.Attributed {
    get
  }
  public typealias Configuration = Foundation.NumberFormatStyleConfiguration
  public func grouping(_ group: Foundation.FloatingPointFormatStyle<Value>.Configuration.Grouping) -> Foundation.FloatingPointFormatStyle<Value>
  public func precision(_ p: Foundation.FloatingPointFormatStyle<Value>.Configuration.Precision) -> Foundation.FloatingPointFormatStyle<Value>
  public func sign(strategy: Foundation.FloatingPointFormatStyle<Value>.Configuration.SignDisplayStrategy) -> Foundation.FloatingPointFormatStyle<Value>
  public func decimalSeparator(strategy: Foundation.FloatingPointFormatStyle<Value>.Configuration.DecimalSeparatorDisplayStrategy) -> Foundation.FloatingPointFormatStyle<Value>
  public func rounded(rule: Foundation.FloatingPointFormatStyle<Value>.Configuration.RoundingRule = .toNearestOrEven, increment: Swift.Double? = nil) -> Foundation.FloatingPointFormatStyle<Value>
  public func scale(_ multiplicand: Swift.Double) -> Foundation.FloatingPointFormatStyle<Value>
  public func notation(_ notation: Foundation.FloatingPointFormatStyle<Value>.Configuration.Notation) -> Foundation.FloatingPointFormatStyle<Value>
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: Foundation.FloatingPointFormatStyle<Value>, b: Foundation.FloatingPointFormatStyle<Value>) -> Swift.Bool
  public func encode(to encoder: Swift.Encoder) throws
  public var hashValue: Swift.Int {
    get
  }
  public init(from decoder: Swift.Decoder) throws
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.FloatingPointFormatStyle {
  public struct Percent : Swift.Codable, Swift.Hashable {
    public var locale: Foundation.Locale
    public init(locale: Foundation.Locale = .autoupdatingCurrent)
    public var attributed: Foundation.FloatingPointFormatStyle<Value>.Attributed {
      get
    }
    public typealias Configuration = Foundation.NumberFormatStyleConfiguration
    public func grouping(_ group: Foundation.FloatingPointFormatStyle<Value>.Percent.Configuration.Grouping) -> Foundation.FloatingPointFormatStyle<Value>.Percent
    public func precision(_ p: Foundation.FloatingPointFormatStyle<Value>.Percent.Configuration.Precision) -> Foundation.FloatingPointFormatStyle<Value>.Percent
    public func sign(strategy: Foundation.FloatingPointFormatStyle<Value>.Percent.Configuration.SignDisplayStrategy) -> Foundation.FloatingPointFormatStyle<Value>.Percent
    public func decimalSeparator(strategy: Foundation.FloatingPointFormatStyle<Value>.Percent.Configuration.DecimalSeparatorDisplayStrategy) -> Foundation.FloatingPointFormatStyle<Value>.Percent
    public func rounded(rule: Foundation.FloatingPointFormatStyle<Value>.Percent.Configuration.RoundingRule = .toNearestOrEven, increment: Swift.Double? = nil) -> Foundation.FloatingPointFormatStyle<Value>.Percent
    public func scale(_ multiplicand: Swift.Double) -> Foundation.FloatingPointFormatStyle<Value>.Percent
    public func notation(_ notation: Foundation.FloatingPointFormatStyle<Value>.Percent.Configuration.Notation) -> Foundation.FloatingPointFormatStyle<Value>.Percent
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: Foundation.FloatingPointFormatStyle<Value>.Percent, b: Foundation.FloatingPointFormatStyle<Value>.Percent) -> Swift.Bool
    public func encode(to encoder: Swift.Encoder) throws
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: Swift.Decoder) throws
  }
  @available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
  public struct Currency : Swift.Codable, Swift.Hashable {
    public var locale: Foundation.Locale
    public let currencyCode: Swift.String
    public typealias Configuration = Foundation.CurrencyFormatStyleConfiguration
    public init(code: Swift.String, locale: Foundation.Locale = .autoupdatingCurrent)
    public var attributed: Foundation.FloatingPointFormatStyle<Value>.Attributed {
      get
    }
    public func grouping(_ group: Foundation.FloatingPointFormatStyle<Value>.Currency.Configuration.Grouping) -> Foundation.FloatingPointFormatStyle<Value>.Currency
    public func precision(_ p: Foundation.FloatingPointFormatStyle<Value>.Currency.Configuration.Precision) -> Foundation.FloatingPointFormatStyle<Value>.Currency
    public func sign(strategy: Foundation.FloatingPointFormatStyle<Value>.Currency.Configuration.SignDisplayStrategy) -> Foundation.FloatingPointFormatStyle<Value>.Currency
    public func decimalSeparator(strategy: Foundation.FloatingPointFormatStyle<Value>.Currency.Configuration.DecimalSeparatorDisplayStrategy) -> Foundation.FloatingPointFormatStyle<Value>.Currency
    public func rounded(rule: Foundation.FloatingPointFormatStyle<Value>.Currency.Configuration.RoundingRule = .toNearestOrEven, increment: Swift.Double? = nil) -> Foundation.FloatingPointFormatStyle<Value>.Currency
    public func scale(_ multiplicand: Swift.Double) -> Foundation.FloatingPointFormatStyle<Value>.Currency
    public func presentation(_ p: Foundation.FloatingPointFormatStyle<Value>.Currency.Configuration.Presentation) -> Foundation.FloatingPointFormatStyle<Value>.Currency
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: Foundation.FloatingPointFormatStyle<Value>.Currency, b: Foundation.FloatingPointFormatStyle<Value>.Currency) -> Swift.Bool
    public func encode(to encoder: Swift.Encoder) throws
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: Swift.Decoder) throws
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.FloatingPointFormatStyle : Foundation.FormatStyle {
  public func format(_ value: Value) -> Swift.String
  public func locale(_ locale: Foundation.Locale) -> Foundation.FloatingPointFormatStyle<Value>
  public typealias FormatInput = Value
  public typealias FormatOutput = Swift.String
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.FloatingPointFormatStyle.Percent : Foundation.FormatStyle {
  public func format(_ value: Value) -> Swift.String
  public func locale(_ locale: Foundation.Locale) -> Foundation.FloatingPointFormatStyle<Value>.Percent
  public typealias FormatInput = Value
  public typealias FormatOutput = Swift.String
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.FloatingPointFormatStyle.Currency : Foundation.FormatStyle {
  public func format(_ value: Value) -> Swift.String
  public func locale(_ locale: Foundation.Locale) -> Foundation.FloatingPointFormatStyle<Value>.Currency
  public typealias FormatInput = Value
  public typealias FormatOutput = Swift.String
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.FloatingPointFormatStyle : Foundation.ParseableFormatStyle {
  public var parseStrategy: Foundation.FloatingPointParseStrategy<Foundation.FloatingPointFormatStyle<Value>> {
    get
  }
  public typealias Strategy = Foundation.FloatingPointParseStrategy<Foundation.FloatingPointFormatStyle<Value>>
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.FloatingPointFormatStyle.Currency : Foundation.ParseableFormatStyle {
  public var parseStrategy: Foundation.FloatingPointParseStrategy<Foundation.FloatingPointFormatStyle<Value>.Currency> {
    get
  }
  public typealias Strategy = Foundation.FloatingPointParseStrategy<Foundation.FloatingPointFormatStyle<Value>.Currency>
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.FloatingPointFormatStyle.Percent : Foundation.ParseableFormatStyle {
  public var parseStrategy: Foundation.FloatingPointParseStrategy<Foundation.FloatingPointFormatStyle<Value>.Percent> {
    get
  }
  public typealias Strategy = Foundation.FloatingPointParseStrategy<Foundation.FloatingPointFormatStyle<Value>.Percent>
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.FormatStyle where Self == Foundation.FloatingPointFormatStyle<Swift.Double> {
  @_alwaysEmitIntoClient public static var number: Foundation.FloatingPointFormatStyle<Swift.Double> {
    get { Self() }
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.FormatStyle where Self == Foundation.FloatingPointFormatStyle<Swift.Float> {
  @_alwaysEmitIntoClient public static var number: Foundation.FloatingPointFormatStyle<Swift.Float> {
    get { Self() }
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.FormatStyle where Self == Foundation.FloatingPointFormatStyle<Swift.Double>.Percent {
  @_alwaysEmitIntoClient public static var percent: Foundation.FloatingPointFormatStyle<Swift.Double>.Percent {
    get { Self() }
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.FormatStyle where Self == Foundation.FloatingPointFormatStyle<Swift.Float>.Percent {
  @_alwaysEmitIntoClient public static var percent: Foundation.FloatingPointFormatStyle<Swift.Float>.Percent {
    get { Self() }
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.FormatStyle {
  @_alwaysEmitIntoClient public static func currency<Value>(code: Swift.String) -> Self where Self == Foundation.FloatingPointFormatStyle<Value>.Currency, Value : Swift.BinaryFloatingPoint {
        return Self(code: code)
    }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.FloatingPointFormatStyle {
  public struct Attributed : Swift.Codable, Swift.Hashable, Foundation.FormatStyle {
    public func format(_ value: Value) -> Foundation.AttributedString
    public func locale(_ locale: Foundation.Locale) -> Foundation.FloatingPointFormatStyle<Value>.Attributed
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: Foundation.FloatingPointFormatStyle<Value>.Attributed, b: Foundation.FloatingPointFormatStyle<Value>.Attributed) -> Swift.Bool
    public typealias FormatInput = Value
    public typealias FormatOutput = Foundation.AttributedString
    public func encode(to encoder: Swift.Encoder) throws
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: Swift.Decoder) throws
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
public struct FormatStyleCapitalizationContext : Swift.Codable, Swift.Hashable {
  public static var unknown: Foundation.FormatStyleCapitalizationContext {
    get
  }
  public static var standalone: Foundation.FormatStyleCapitalizationContext {
    get
  }
  public static var listItem: Foundation.FormatStyleCapitalizationContext {
    get
  }
  public static var beginningOfSentence: Foundation.FormatStyleCapitalizationContext {
    get
  }
  public static var middleOfSentence: Foundation.FormatStyleCapitalizationContext {
    get
  }
  public static func == (a: Foundation.FormatStyleCapitalizationContext, b: Foundation.FormatStyleCapitalizationContext) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public func encode(to encoder: Swift.Encoder) throws
  public var hashValue: Swift.Int {
    get
  }
  public init(from decoder: Swift.Decoder) throws
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
public enum NumberFormatStyleConfiguration {
  public typealias RoundingRule = Swift.FloatingPointRoundingRule
  public struct Grouping : Swift.Codable, Swift.Hashable, Swift.CustomStringConvertible {
    public static var automatic: Foundation.NumberFormatStyleConfiguration.Grouping {
      get
    }
    public static var never: Foundation.NumberFormatStyleConfiguration.Grouping {
      get
    }
    public var description: Swift.String {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: Foundation.NumberFormatStyleConfiguration.Grouping, b: Foundation.NumberFormatStyleConfiguration.Grouping) -> Swift.Bool
    public func encode(to encoder: Swift.Encoder) throws
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: Swift.Decoder) throws
  }
  public struct Precision : Swift.Codable, Swift.Hashable {
    public static func significantDigits<R>(_ limits: R) -> Foundation.NumberFormatStyleConfiguration.Precision where R : Swift.RangeExpression, R.Bound == Swift.Int
    public static func significantDigits(_ digits: Swift.Int) -> Foundation.NumberFormatStyleConfiguration.Precision
    public static func integerAndFractionLength<R1, R2>(integerLimits: R1, fractionLimits: R2) -> Foundation.NumberFormatStyleConfiguration.Precision where R1 : Swift.RangeExpression, R2 : Swift.RangeExpression, R1.Bound == Swift.Int, R2.Bound == Swift.Int
    public static func integerAndFractionLength(integer: Swift.Int, fraction: Swift.Int) -> Foundation.NumberFormatStyleConfiguration.Precision
    public static func integerLength<R>(_ limits: R) -> Foundation.NumberFormatStyleConfiguration.Precision where R : Swift.RangeExpression
    public static func integerLength(_ length: Swift.Int) -> Foundation.NumberFormatStyleConfiguration.Precision
    public static func fractionLength<R>(_ limits: R) -> Foundation.NumberFormatStyleConfiguration.Precision where R : Swift.RangeExpression, R.Bound == Swift.Int
    public static func fractionLength(_ length: Swift.Int) -> Foundation.NumberFormatStyleConfiguration.Precision
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: Foundation.NumberFormatStyleConfiguration.Precision, b: Foundation.NumberFormatStyleConfiguration.Precision) -> Swift.Bool
    public func encode(to encoder: Swift.Encoder) throws
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: Swift.Decoder) throws
  }
  public struct DecimalSeparatorDisplayStrategy : Swift.Codable, Swift.Hashable, Swift.CustomStringConvertible {
    public static var automatic: Foundation.NumberFormatStyleConfiguration.DecimalSeparatorDisplayStrategy {
      get
    }
    public static var always: Foundation.NumberFormatStyleConfiguration.DecimalSeparatorDisplayStrategy {
      get
    }
    public var description: Swift.String {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: Foundation.NumberFormatStyleConfiguration.DecimalSeparatorDisplayStrategy, b: Foundation.NumberFormatStyleConfiguration.DecimalSeparatorDisplayStrategy) -> Swift.Bool
    public func encode(to encoder: Swift.Encoder) throws
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: Swift.Decoder) throws
  }
  public struct SignDisplayStrategy : Swift.Codable, Swift.Hashable, Swift.CustomStringConvertible {
    public static var automatic: Foundation.NumberFormatStyleConfiguration.SignDisplayStrategy {
      get
    }
    public static var never: Foundation.NumberFormatStyleConfiguration.SignDisplayStrategy {
      get
    }
    public static func always(includingZero: Swift.Bool = true) -> Foundation.NumberFormatStyleConfiguration.SignDisplayStrategy
    public var description: Swift.String {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: Foundation.NumberFormatStyleConfiguration.SignDisplayStrategy, b: Foundation.NumberFormatStyleConfiguration.SignDisplayStrategy) -> Swift.Bool
    public func encode(to encoder: Swift.Encoder) throws
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: Swift.Decoder) throws
  }
  public struct Notation : Swift.Codable, Swift.Hashable, Swift.CustomStringConvertible {
    public static var scientific: Foundation.NumberFormatStyleConfiguration.Notation {
      get
    }
    public static var automatic: Foundation.NumberFormatStyleConfiguration.Notation {
      get
    }
    public static var compactName: Foundation.NumberFormatStyleConfiguration.Notation {
      get
    }
    public var description: Swift.String {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: Foundation.NumberFormatStyleConfiguration.Notation, b: Foundation.NumberFormatStyleConfiguration.Notation) -> Swift.Bool
    public func encode(to encoder: Swift.Encoder) throws
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: Swift.Decoder) throws
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
public enum CurrencyFormatStyleConfiguration {
  public typealias Grouping = Foundation.NumberFormatStyleConfiguration.Grouping
  public typealias Precision = Foundation.NumberFormatStyleConfiguration.Precision
  public typealias DecimalSeparatorDisplayStrategy = Foundation.NumberFormatStyleConfiguration.DecimalSeparatorDisplayStrategy
  public typealias RoundingRule = Foundation.NumberFormatStyleConfiguration.RoundingRule
  public struct SignDisplayStrategy : Swift.Codable, Swift.Hashable {
    public static var automatic: Foundation.CurrencyFormatStyleConfiguration.SignDisplayStrategy {
      get
    }
    public static var never: Foundation.CurrencyFormatStyleConfiguration.SignDisplayStrategy {
      get
    }
    public static func always(showZero: Swift.Bool = true) -> Foundation.CurrencyFormatStyleConfiguration.SignDisplayStrategy
    public static var accounting: Foundation.CurrencyFormatStyleConfiguration.SignDisplayStrategy {
      get
    }
    public static func accountingAlways(showZero: Swift.Bool = false) -> Foundation.CurrencyFormatStyleConfiguration.SignDisplayStrategy
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: Foundation.CurrencyFormatStyleConfiguration.SignDisplayStrategy, b: Foundation.CurrencyFormatStyleConfiguration.SignDisplayStrategy) -> Swift.Bool
    public func encode(to encoder: Swift.Encoder) throws
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: Swift.Decoder) throws
  }
  public struct Presentation : Swift.Codable, Swift.Hashable {
    public static var narrow: Foundation.CurrencyFormatStyleConfiguration.Presentation {
      get
    }
    public static var standard: Foundation.CurrencyFormatStyleConfiguration.Presentation {
      get
    }
    public static var isoCode: Foundation.CurrencyFormatStyleConfiguration.Presentation {
      get
    }
    public static var fullName: Foundation.CurrencyFormatStyleConfiguration.Presentation {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: Foundation.CurrencyFormatStyleConfiguration.Presentation, b: Foundation.CurrencyFormatStyleConfiguration.Presentation) -> Swift.Bool
    public func encode(to encoder: Swift.Encoder) throws
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: Swift.Decoder) throws
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
public enum DescriptiveNumberFormatConfiguration {
  public typealias CapitalizationContext = Foundation.FormatStyleCapitalizationContext
  public struct Presentation : Swift.Codable, Swift.Hashable {
    public static var spellOut: Foundation.DescriptiveNumberFormatConfiguration.Presentation {
      get
    }
    public static var ordinal: Foundation.DescriptiveNumberFormatConfiguration.Presentation {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: Foundation.DescriptiveNumberFormatConfiguration.Presentation, b: Foundation.DescriptiveNumberFormatConfiguration.Presentation) -> Swift.Bool
    public func encode(to encoder: Swift.Encoder) throws
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: Swift.Decoder) throws
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Swift.FloatingPointRoundingRule : Swift.Codable {
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Swift.BinaryFloatingPoint {
  public func formatted() -> Swift.String
  public func formatted<S>(_ format: S) -> S.FormatOutput where Self == S.FormatInput, S : Foundation.FormatStyle
  public func formatted<S>(_ format: S) -> S.FormatOutput where S : Foundation.FormatStyle, S.FormatInput : Swift.BinaryFloatingPoint
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Swift.BinaryFloatingPoint {
  public init<S>(_ value: S.ParseInput, strategy: S) throws where S : Foundation.ParseStrategy, S.ParseOutput : Swift.BinaryFloatingPoint
  public init<S>(_ value: S.ParseInput, strategy: S) throws where Self == S.ParseOutput, S : Foundation.ParseStrategy
  public init(_ value: Swift.String, format: Foundation.FloatingPointFormatStyle<Self>, lenient: Swift.Bool = true) throws
  public init(_ value: Swift.String, format: Foundation.FloatingPointFormatStyle<Self>.Percent, lenient: Swift.Bool = true) throws
  public init(_ value: Swift.String, format: Foundation.FloatingPointFormatStyle<Self>.Currency, lenient: Swift.Bool = true) throws
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
public protocol ParseableFormatStyle : Foundation.FormatStyle {
  associatedtype Strategy : Foundation.ParseStrategy where Self.FormatInput == Self.Strategy.ParseOutput, Self.FormatOutput == Self.Strategy.ParseInput
  var parseStrategy: Self.Strategy { get }
}
public var kCFStringEncodingASCII: CoreFoundation.CFStringEncoding {
  get
}
extension Swift.String {
  public struct Encoding : Swift.RawRepresentable {
    public var rawValue: Swift.UInt
    public init(rawValue: Swift.UInt)
    public static let ascii: Swift.String.Encoding
    public static let nextstep: Swift.String.Encoding
    public static let japaneseEUC: Swift.String.Encoding
    public static let utf8: Swift.String.Encoding
    public static let isoLatin1: Swift.String.Encoding
    public static let symbol: Swift.String.Encoding
    public static let nonLossyASCII: Swift.String.Encoding
    public static let shiftJIS: Swift.String.Encoding
    public static let isoLatin2: Swift.String.Encoding
    public static let unicode: Swift.String.Encoding
    public static let windowsCP1251: Swift.String.Encoding
    public static let windowsCP1252: Swift.String.Encoding
    public static let windowsCP1253: Swift.String.Encoding
    public static let windowsCP1254: Swift.String.Encoding
    public static let windowsCP1250: Swift.String.Encoding
    public static let iso2022JP: Swift.String.Encoding
    public static let macOSRoman: Swift.String.Encoding
    public static let utf16: Swift.String.Encoding
    public static let utf16BigEndian: Swift.String.Encoding
    public static let utf16LittleEndian: Swift.String.Encoding
    public static let utf32: Swift.String.Encoding
    public static let utf32BigEndian: Swift.String.Encoding
    public static let utf32LittleEndian: Swift.String.Encoding
    public typealias RawValue = Swift.UInt
  }
  public typealias EncodingConversionOptions = Foundation.NSString.EncodingConversionOptions
  public typealias EnumerationOptions = Foundation.NSString.EnumerationOptions
  public typealias CompareOptions = Foundation.NSString.CompareOptions
}
extension Swift.String.Encoding : Swift.Hashable {
  public var hashValue: Swift.Int {
    get
  }
  @_alwaysEmitIntoClient public func hash(into hasher: inout Swift.Hasher) {
        // Note: `hash(only:)` is only defined here because we also define
        // `hashValue`.
        //
        // In 5.0, `hash(into:)` was resolved to RawRepresentable's functionally
        // equivalent definition; we added this definition in 5.1 to make it
        // clear this `hash(into:)` isn't synthesized by the compiler.
        // (Otherwise someone may be tempted to define it, possibly breaking the
        // hash encoding and thus the ABI. RawRepresentable's definition is
        // inlinable.)
        hasher.combine(rawValue)
    }
  public static func == (lhs: Swift.String.Encoding, rhs: Swift.String.Encoding) -> Swift.Bool
}
extension Swift.String.Encoding : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
@available(*, unavailable, renamed: "String.Encoding")
public typealias NSStringEncoding = Swift.UInt
@available(*, unavailable, renamed: "String.Encoding.ascii")
public var NSASCIIStringEncoding: Swift.String.Encoding {
  get
}
@available(*, unavailable, renamed: "String.Encoding.nextstep")
public var NSNEXTSTEPStringEncoding: Swift.String.Encoding {
  get
}
@available(*, unavailable, renamed: "String.Encoding.japaneseEUC")
public var NSJapaneseEUCStringEncoding: Swift.String.Encoding {
  get
}
@available(*, unavailable, renamed: "String.Encoding.utf8")
public var NSUTF8StringEncoding: Swift.String.Encoding {
  get
}
@available(*, unavailable, renamed: "String.Encoding.isoLatin1")
public var NSISOLatin1StringEncoding: Swift.String.Encoding {
  get
}
@available(*, unavailable, renamed: "String.Encoding.symbol")
public var NSSymbolStringEncoding: Swift.String.Encoding {
  get
}
@available(*, unavailable, renamed: "String.Encoding.nonLossyASCII")
public var NSNonLossyASCIIStringEncoding: Swift.String.Encoding {
  get
}
@available(*, unavailable, renamed: "String.Encoding.shiftJIS")
public var NSShiftJISStringEncoding: Swift.String.Encoding {
  get
}
@available(*, unavailable, renamed: "String.Encoding.isoLatin2")
public var NSISOLatin2StringEncoding: Swift.String.Encoding {
  get
}
@available(*, unavailable, renamed: "String.Encoding.unicode")
public var NSUnicodeStringEncoding: Swift.String.Encoding {
  get
}
@available(*, unavailable, renamed: "String.Encoding.windowsCP1251")
public var NSWindowsCP1251StringEncoding: Swift.String.Encoding {
  get
}
@available(*, unavailable, renamed: "String.Encoding.windowsCP1252")
public var NSWindowsCP1252StringEncoding: Swift.String.Encoding {
  get
}
@available(*, unavailable, renamed: "String.Encoding.windowsCP1253")
public var NSWindowsCP1253StringEncoding: Swift.String.Encoding {
  get
}
@available(*, unavailable, renamed: "String.Encoding.windowsCP1254")
public var NSWindowsCP1254StringEncoding: Swift.String.Encoding {
  get
}
@available(*, unavailable, renamed: "String.Encoding.windowsCP1250")
public var NSWindowsCP1250StringEncoding: Swift.String.Encoding {
  get
}
@available(*, unavailable, renamed: "String.Encoding.iso2022JP")
public var NSISO2022JPStringEncoding: Swift.String.Encoding {
  get
}
@available(*, unavailable, renamed: "String.Encoding.macOSRoman")
public var NSMacOSRomanStringEncoding: Swift.String.Encoding {
  get
}
@available(*, unavailable, renamed: "String.Encoding.utf16")
public var NSUTF16StringEncoding: Swift.String.Encoding {
  get
}
@available(*, unavailable, renamed: "String.Encoding.utf16BigEndian")
public var NSUTF16BigEndianStringEncoding: Swift.String.Encoding {
  get
}
@available(*, unavailable, renamed: "String.Encoding.utf16LittleEndian")
public var NSUTF16LittleEndianStringEncoding: Swift.String.Encoding {
  get
}
@available(*, unavailable, renamed: "String.Encoding.utf32")
public var NSUTF32StringEncoding: Swift.String.Encoding {
  get
}
@available(*, unavailable, renamed: "String.Encoding.utf32BigEndian")
public var NSUTF32BigEndianStringEncoding: Swift.String.Encoding {
  get
}
@available(*, unavailable, renamed: "String.Encoding.utf32LittleEndian")
public var NSUTF32LittleEndianStringEncoding: Swift.String.Encoding {
  get
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
public protocol AttributedStringKey {
  associatedtype Value : Swift.Hashable
  static var name: Swift.String { get }
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.AttributedStringKey {
  public var description: Swift.String {
    get
  }
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
public protocol AttributeScope : Foundation.DecodingConfigurationProviding, Foundation.EncodingConfigurationProviding {
  static var decodingConfiguration: Foundation.AttributeScopeCodableConfiguration { get }
  static var encodingConfiguration: Foundation.AttributeScopeCodableConfiguration { get }
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
@frozen public enum AttributeScopes {
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
@dynamicMemberLookup @frozen public enum AttributeDynamicLookup {
  public subscript<T>(_: T.Type) -> T where T : Foundation.AttributedStringKey {
    get
  }
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
@dynamicMemberLookup public struct ScopedAttributeContainer<S> where S : Foundation.AttributeScope {
  public subscript<T>(dynamicMember keyPath: Swift.KeyPath<S, T>) -> T.Value? where T : Foundation.AttributedStringKey {
    get
    set
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
public struct ListFormatStyle<Style, Base> : Foundation.FormatStyle where Style : Foundation.FormatStyle, Base : Swift.Sequence, Style.FormatInput == Base.Element, Style.FormatOutput == Swift.String {
  public var width: Foundation.ListFormatStyle<Style, Base>.Width
  public var listType: Foundation.ListFormatStyle<Style, Base>.ListType
  public var locale: Foundation.Locale
  public init(memberStyle: Style)
  public func format(_ value: Base) -> Swift.String
  public enum Width : Swift.Int, Swift.Codable {
    case standard
    case short
    case narrow
    public init?(rawValue: Swift.Int)
    public typealias RawValue = Swift.Int
    public var rawValue: Swift.Int {
      get
    }
  }
  public enum ListType : Swift.Int, Swift.Codable {
    case and
    case or
    public init?(rawValue: Swift.Int)
    public typealias RawValue = Swift.Int
    public var rawValue: Swift.Int {
      get
    }
  }
  public func locale(_ locale: Foundation.Locale) -> Foundation.ListFormatStyle<Style, Base>
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: Foundation.ListFormatStyle<Style, Base>, b: Foundation.ListFormatStyle<Style, Base>) -> Swift.Bool
  public typealias FormatInput = Base
  public typealias FormatOutput = Swift.String
  public func encode(to encoder: Swift.Encoder) throws
  public var hashValue: Swift.Int {
    get
  }
  public init(from decoder: Swift.Decoder) throws
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
public struct StringStyle : Foundation.FormatStyle {
  public func format(_ value: Swift.String) -> Swift.String
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: Foundation.StringStyle, b: Foundation.StringStyle) -> Swift.Bool
  public typealias FormatInput = Swift.String
  public typealias FormatOutput = Swift.String
  public func encode(to encoder: Swift.Encoder) throws
  public var hashValue: Swift.Int {
    get
  }
  public init(from decoder: Swift.Decoder) throws
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Swift.Sequence {
  public func formatted<S>(_ style: S) -> S.FormatOutput where Self == S.FormatInput, S : Foundation.FormatStyle
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Swift.Sequence where Self.Element == Swift.String {
  public func formatted() -> Swift.String
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.FormatStyle {
  public static func list<MemberStyle, Base>(memberStyle: MemberStyle, type: Foundation.ListFormatStyle<MemberStyle, Base>.ListType, width: Foundation.ListFormatStyle<MemberStyle, Base>.Width = .standard) -> Self where Self == Foundation.ListFormatStyle<MemberStyle, Base>, MemberStyle : Foundation.FormatStyle, Base : Swift.Sequence, MemberStyle.FormatInput == Base.Element, MemberStyle.FormatOutput == Swift.String
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.FormatStyle {
  public static func list<Base>(type: Foundation.ListFormatStyle<Foundation.StringStyle, Base>.ListType, width: Foundation.ListFormatStyle<Foundation.StringStyle, Base>.Width = .standard) -> Self where Self == Foundation.ListFormatStyle<Foundation.StringStyle, Base>, Base : Swift.Sequence, Base.Element == Swift.String
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
public protocol FormatStyle : Swift.Decodable, Swift.Encodable, Swift.Hashable {
  associatedtype FormatInput
  associatedtype FormatOutput
  func format(_ value: Self.FormatInput) -> Self.FormatOutput
  func locale(_ locale: Foundation.Locale) -> Self
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.FormatStyle {
  public func locale(_ locale: Foundation.Locale) -> Self
}
public protocol ContiguousBytes {
  func withUnsafeBytes<R>(_ body: (Swift.UnsafeRawBufferPointer) throws -> R) rethrows -> R
}
extension Swift.Array : Foundation.ContiguousBytes where Element == Swift.UInt8 {
}
extension Swift.ArraySlice : Foundation.ContiguousBytes where Element == Swift.UInt8 {
}
extension Swift.ContiguousArray : Foundation.ContiguousBytes where Element == Swift.UInt8 {
}
extension Swift.UnsafeRawBufferPointer : Foundation.ContiguousBytes {
  @inlinable public func withUnsafeBytes<R>(_ body: (Swift.UnsafeRawBufferPointer) throws -> R) rethrows -> R {
        return try body(self)
    }
}
extension Swift.UnsafeMutableRawBufferPointer : Foundation.ContiguousBytes {
  @inlinable public func withUnsafeBytes<R>(_ body: (Swift.UnsafeRawBufferPointer) throws -> R) rethrows -> R {
        return try body(UnsafeRawBufferPointer(self))
    }
}
extension Swift.UnsafeBufferPointer : Foundation.ContiguousBytes where Element == Swift.UInt8 {
  @inlinable public func withUnsafeBytes<R>(_ body: (Swift.UnsafeRawBufferPointer) throws -> R) rethrows -> R {
        return try body(UnsafeRawBufferPointer(self))
    }
}
extension Swift.UnsafeMutableBufferPointer : Foundation.ContiguousBytes where Element == Swift.UInt8 {
  @inlinable public func withUnsafeBytes<R>(_ body: (Swift.UnsafeRawBufferPointer) throws -> R) rethrows -> R {
        return try body(UnsafeRawBufferPointer(self))
    }
}
extension Swift.EmptyCollection : Foundation.ContiguousBytes where Element == Swift.UInt8 {
  @inlinable public func withUnsafeBytes<R>(_ body: (Swift.UnsafeRawBufferPointer) throws -> R) rethrows -> R {
        return try body(UnsafeRawBufferPointer(start: nil, count: 0))
    }
}
extension Swift.CollectionOfOne : Foundation.ContiguousBytes where Element == Swift.UInt8 {
  @inlinable public func withUnsafeBytes<R>(_ body: (Swift.UnsafeRawBufferPointer) throws -> R) rethrows -> R {
        let element = self.first!
        return try Swift.withUnsafeBytes(of: element) {
            return try body($0)
        }
    }
}
extension Swift.Slice : Foundation.ContiguousBytes where Base : Foundation.ContiguousBytes {
  public func withUnsafeBytes<ResultType>(_ body: (Swift.UnsafeRawBufferPointer) throws -> ResultType) rethrows -> ResultType
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
public struct ByteCountFormatStyle : Foundation.FormatStyle {
  public var style: Foundation.ByteCountFormatStyle.Style {
    get
    set
  }
  public var allowedUnits: Foundation.ByteCountFormatStyle.Units {
    get
    set
  }
  public var spellsOutZero: Swift.Bool {
    get
    set
  }
  public var includesActualByteCount: Swift.Bool {
    get
    set
  }
  public var locale: Foundation.Locale {
    get
    set
  }
  public var attributed: Foundation.ByteCountFormatStyle.Attributed
  public func format(_ value: Swift.Int64) -> Swift.String
  public func locale(_ locale: Foundation.Locale) -> Foundation.ByteCountFormatStyle
  public init(style: Foundation.ByteCountFormatStyle.Style = .file, allowedUnits: Foundation.ByteCountFormatStyle.Units = .all, spellsOutZero: Swift.Bool = true, includesActualByteCount: Swift.Bool = false, locale: Foundation.Locale = .autoupdatingCurrent)
  public enum Style : Swift.Int, Swift.Codable, Swift.Hashable {
    case file, memory, decimal, binary
    public init?(rawValue: Swift.Int)
    public typealias RawValue = Swift.Int
    public var rawValue: Swift.Int {
      get
    }
  }
  public struct Units : Swift.OptionSet, Swift.Codable, Swift.Hashable {
    public var rawValue: Swift.UInt
    public init(rawValue: Swift.UInt)
    public static var bytes: Foundation.ByteCountFormatStyle.Units {
      get
    }
    public static var kb: Foundation.ByteCountFormatStyle.Units {
      get
    }
    public static var mb: Foundation.ByteCountFormatStyle.Units {
      get
    }
    public static var gb: Foundation.ByteCountFormatStyle.Units {
      get
    }
    public static var tb: Foundation.ByteCountFormatStyle.Units {
      get
    }
    public static var pb: Foundation.ByteCountFormatStyle.Units {
      get
    }
    public static var eb: Foundation.ByteCountFormatStyle.Units {
      get
    }
    public static var zb: Foundation.ByteCountFormatStyle.Units {
      get
    }
    public static var ybOrHigher: Foundation.ByteCountFormatStyle.Units {
      get
    }
    public static var all: Foundation.ByteCountFormatStyle.Units {
      get
    }
    public static var `default`: Foundation.ByteCountFormatStyle.Units {
      get
    }
    public typealias ArrayLiteralElement = Foundation.ByteCountFormatStyle.Units
    public typealias Element = Foundation.ByteCountFormatStyle.Units
    public typealias RawValue = Swift.UInt
  }
  public struct Attributed : Foundation.FormatStyle {
    public var style: Foundation.ByteCountFormatStyle.Style
    public var allowedUnits: Foundation.ByteCountFormatStyle.Units
    public var spellsOutZero: Swift.Bool
    public var includesActualByteCount: Swift.Bool
    public var locale: Foundation.Locale
    public func locale(_ locale: Foundation.Locale) -> Foundation.ByteCountFormatStyle.Attributed
    public func format(_ value: Swift.Int64) -> Foundation.AttributedString
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: Foundation.ByteCountFormatStyle.Attributed, b: Foundation.ByteCountFormatStyle.Attributed) -> Swift.Bool
    public typealias FormatInput = Swift.Int64
    public typealias FormatOutput = Foundation.AttributedString
    public func encode(to encoder: Swift.Encoder) throws
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: Swift.Decoder) throws
  }
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: Foundation.ByteCountFormatStyle, b: Foundation.ByteCountFormatStyle) -> Swift.Bool
  public typealias FormatInput = Swift.Int64
  public typealias FormatOutput = Swift.String
  public func encode(to encoder: Swift.Encoder) throws
  public var hashValue: Swift.Int {
    get
  }
  public init(from decoder: Swift.Decoder) throws
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.FormatStyle where Self == Foundation.ByteCountFormatStyle {
  public static func byteCount(style: Foundation.ByteCountFormatStyle.Style, allowedUnits: Foundation.ByteCountFormatStyle.Units = .all, spellsOutZero: Swift.Bool = true, includesActualByteCount: Swift.Bool = false) -> Self
}
extension Foundation._NSRange : Swift._ObjectiveCBridgeable {
  public func _bridgeToObjectiveC() -> Foundation.NSValue
  public static func _forceBridgeFromObjectiveC(_ source: Foundation.NSValue, result: inout Foundation.NSRange?)
  public static func _conditionallyBridgeFromObjectiveC(_ source: Foundation.NSValue, result: inout Foundation.NSRange?) -> Swift.Bool
  public static func _unconditionallyBridgeFromObjectiveC(_ source: Foundation.NSValue?) -> Foundation.NSRange
  public typealias _ObjectiveCType = Foundation.NSValue
}
extension CoreGraphics.CGRect : Swift._ObjectiveCBridgeable {
  public func _bridgeToObjectiveC() -> Foundation.NSValue
  public static func _forceBridgeFromObjectiveC(_ source: Foundation.NSValue, result: inout CoreGraphics.CGRect?)
  public static func _conditionallyBridgeFromObjectiveC(_ source: Foundation.NSValue, result: inout CoreGraphics.CGRect?) -> Swift.Bool
  public static func _unconditionallyBridgeFromObjectiveC(_ source: Foundation.NSValue?) -> CoreGraphics.CGRect
  public typealias _ObjectiveCType = Foundation.NSValue
}
extension CoreGraphics.CGPoint : Swift._ObjectiveCBridgeable {
  public func _bridgeToObjectiveC() -> Foundation.NSValue
  public static func _forceBridgeFromObjectiveC(_ source: Foundation.NSValue, result: inout CoreGraphics.CGPoint?)
  public static func _conditionallyBridgeFromObjectiveC(_ source: Foundation.NSValue, result: inout CoreGraphics.CGPoint?) -> Swift.Bool
  public static func _unconditionallyBridgeFromObjectiveC(_ source: Foundation.NSValue?) -> CoreGraphics.CGPoint
  public typealias _ObjectiveCType = Foundation.NSValue
}
extension CoreGraphics.CGVector : Swift._ObjectiveCBridgeable {
  public func _bridgeToObjectiveC() -> Foundation.NSValue
  public static func _forceBridgeFromObjectiveC(_ source: Foundation.NSValue, result: inout CoreGraphics.CGVector?)
  public static func _conditionallyBridgeFromObjectiveC(_ source: Foundation.NSValue, result: inout CoreGraphics.CGVector?) -> Swift.Bool
  public static func _unconditionallyBridgeFromObjectiveC(_ source: Foundation.NSValue?) -> CoreGraphics.CGVector
  public typealias _ObjectiveCType = Foundation.NSValue
}
extension CoreGraphics.CGSize : Swift._ObjectiveCBridgeable {
  public func _bridgeToObjectiveC() -> Foundation.NSValue
  public static func _forceBridgeFromObjectiveC(_ source: Foundation.NSValue, result: inout CoreGraphics.CGSize?)
  public static func _conditionallyBridgeFromObjectiveC(_ source: Foundation.NSValue, result: inout CoreGraphics.CGSize?) -> Swift.Bool
  public static func _unconditionallyBridgeFromObjectiveC(_ source: Foundation.NSValue?) -> CoreGraphics.CGSize
  public typealias _ObjectiveCType = Foundation.NSValue
}
extension CoreGraphics.CGAffineTransform : Swift._ObjectiveCBridgeable {
  public func _bridgeToObjectiveC() -> Foundation.NSValue
  public static func _forceBridgeFromObjectiveC(_ source: Foundation.NSValue, result: inout CoreGraphics.CGAffineTransform?)
  public static func _conditionallyBridgeFromObjectiveC(_ source: Foundation.NSValue, result: inout CoreGraphics.CGAffineTransform?) -> Swift.Bool
  public static func _unconditionallyBridgeFromObjectiveC(_ source: Foundation.NSValue?) -> CoreGraphics.CGAffineTransform
  public typealias _ObjectiveCType = Foundation.NSValue
}
extension Foundation.NSValue {
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public func value<StoredType>(of type: StoredType.Type) -> StoredType?
}
@available(macOS 12, iOS 15, watchOS 8, tvOS 15, *)
public struct PresentationIntent : Swift.Hashable, Swift.Codable, Swift.CustomDebugStringConvertible {
  public var components: [Foundation.PresentationIntent.IntentType]
  public var count: Swift.Int {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
  public enum Kind : Swift.Hashable, Swift.Codable, Swift.CustomDebugStringConvertible {
    case paragraph
    case header(level: Swift.Int)
    case orderedList
    case unorderedList
    case listItem(ordinal: Swift.Int)
    case codeBlock(languageHint: Swift.String?)
    case blockQuote
    case thematicBreak
    case table(columns: [Foundation.PresentationIntent.TableColumn])
    case tableHeaderRow
    case tableRow(rowIndex: Swift.Int)
    case tableCell(columnIndex: Swift.Int)
    public var debugDescription: Swift.String {
      get
    }
    public init(from decoder: Swift.Decoder) throws
    public func encode(to encoder: Swift.Encoder) throws
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: Foundation.PresentationIntent.Kind, b: Foundation.PresentationIntent.Kind) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
  }
  public struct TableColumn : Swift.Hashable, Swift.Codable {
    public enum Alignment : Swift.Int, Swift.Hashable, Swift.Codable {
      case left
      case center
      case right
      public init?(rawValue: Swift.Int)
      public typealias RawValue = Swift.Int
      public var rawValue: Swift.Int {
        get
      }
    }
    public var alignment: Foundation.PresentationIntent.TableColumn.Alignment
    public init(alignment: Foundation.PresentationIntent.TableColumn.Alignment)
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: Foundation.PresentationIntent.TableColumn, b: Foundation.PresentationIntent.TableColumn) -> Swift.Bool
    public func encode(to encoder: Swift.Encoder) throws
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: Swift.Decoder) throws
  }
  public struct IntentType : Swift.Hashable, Swift.Codable, Swift.CustomDebugStringConvertible {
    public var kind: Foundation.PresentationIntent.Kind
    public var identity: Swift.Int
    public var debugDescription: Swift.String {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: Foundation.PresentationIntent.IntentType, b: Foundation.PresentationIntent.IntentType) -> Swift.Bool
    public func encode(to encoder: Swift.Encoder) throws
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: Swift.Decoder) throws
  }
  public init(_ kind: Foundation.PresentationIntent.Kind, identity: Swift.Int, parent: Foundation.PresentationIntent? = nil)
  public init(types: [Foundation.PresentationIntent.IntentType])
  public var isValid: Swift.Bool {
    get
  }
  public var indentationLevel: Swift.Int {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: Foundation.PresentationIntent, b: Foundation.PresentationIntent) -> Swift.Bool
  public func encode(to encoder: Swift.Encoder) throws
  public var hashValue: Swift.Int {
    get
  }
  public init(from decoder: Swift.Decoder) throws
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.PresentationIntent : Swift._ObjectiveCBridgeable {
  public static func _getObjectiveCType() -> Any.Type
  @_semantics("convertToObjectiveC") public func _bridgeToObjectiveC() -> Foundation.__NSPresentationIntent
  public static func _forceBridgeFromObjectiveC(_ source: Foundation.__NSPresentationIntent, result: inout Foundation.PresentationIntent?)
  public static func _conditionallyBridgeFromObjectiveC(_ source: Foundation.__NSPresentationIntent, result: inout Foundation.PresentationIntent?) -> Swift.Bool
  @_effects(readonly) public static func _unconditionallyBridgeFromObjectiveC(_ source: Foundation.__NSPresentationIntent?) -> Foundation.PresentationIntent
  public typealias _ObjectiveCType = Foundation.__NSPresentationIntent
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
@dynamicMemberLookup public struct AttributeContainer : Swift.Equatable, Swift.CustomStringConvertible {
  public static func == (lhs: Foundation.AttributeContainer, rhs: Foundation.AttributeContainer) -> Swift.Bool
  public var description: Swift.String {
    get
  }
  public subscript<T>(_: T.Type) -> T.Value? where T : Foundation.AttributedStringKey {
    get
    set
  }
  public subscript<K>(dynamicMember keyPath: Swift.KeyPath<Foundation.AttributeDynamicLookup, K>) -> K.Value? where K : Foundation.AttributedStringKey {
    get
    set
  }
  public subscript<S>(dynamicMember keyPath: Swift.KeyPath<Foundation.AttributeScopes, S.Type>) -> Foundation.ScopedAttributeContainer<S> where S : Foundation.AttributeScope {
    get
    _modify
  }
  public static subscript<K>(dynamicMember keyPath: Swift.KeyPath<Foundation.AttributeDynamicLookup, K>) -> Foundation.AttributeContainer.Builder<K> where K : Foundation.AttributedStringKey {
    get
  }
  @_disfavoredOverload public subscript<K>(dynamicMember keyPath: Swift.KeyPath<Foundation.AttributeDynamicLookup, K>) -> Foundation.AttributeContainer.Builder<K> where K : Foundation.AttributedStringKey {
    get
  }
  public struct Builder<T> where T : Foundation.AttributedStringKey {
    public func callAsFunction(_ value: T.Value) -> Foundation.AttributeContainer
  }
  public init()
  public mutating func merge(_ other: Foundation.AttributeContainer, mergePolicy: Foundation.AttributedString.AttributeMergePolicy = .keepNew)
  public func merging(_ other: Foundation.AttributeContainer, mergePolicy: Foundation.AttributedString.AttributeMergePolicy = .keepNew) -> Foundation.AttributeContainer
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
public protocol AttributedStringAttributeMutation {
  mutating func setAttributes(_ attributes: Foundation.AttributeContainer)
  mutating func mergeAttributes(_ attributes: Foundation.AttributeContainer, mergePolicy: Foundation.AttributedString.AttributeMergePolicy)
  mutating func replaceAttributes(_ attributes: Foundation.AttributeContainer, with others: Foundation.AttributeContainer)
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
@dynamicMemberLookup public protocol AttributedStringProtocol : Foundation.AttributedStringAttributeMutation, Swift.CustomStringConvertible, Swift.Hashable {
  var startIndex: Foundation.AttributedString.Index { get }
  var endIndex: Foundation.AttributedString.Index { get }
  var runs: Foundation.AttributedString.Runs { get }
  var characters: Foundation.AttributedString.CharacterView { get }
  var unicodeScalars: Foundation.AttributedString.UnicodeScalarView { get }
  subscript<K>(_: K.Type) -> K.Value? where K : Foundation.AttributedStringKey { get set }
  subscript<K>(dynamicMember keyPath: Swift.KeyPath<Foundation.AttributeDynamicLookup, K>) -> K.Value? where K : Foundation.AttributedStringKey { get set }
  subscript<S>(dynamicMember keyPath: Swift.KeyPath<Foundation.AttributeScopes, S.Type>) -> Foundation.ScopedAttributeContainer<S> where S : Foundation.AttributeScope { get set }
  subscript<R>(bounds: R) -> Foundation.AttributedSubstring where R : Swift.RangeExpression, R.Bound == Foundation.AttributedString.Index { get }
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.AttributedStringProtocol {
  public func settingAttributes(_ attributes: Foundation.AttributeContainer) -> Foundation.AttributedString
  public func mergingAttributes(_ attributes: Foundation.AttributeContainer, mergePolicy: Foundation.AttributedString.AttributeMergePolicy = .keepNew) -> Foundation.AttributedString
  public func replacingAttributes(_ attributes: Foundation.AttributeContainer, with others: Foundation.AttributeContainer) -> Foundation.AttributedString
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.AttributedStringProtocol {
  public var description: Swift.String {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
  @_specialize(exported: false, kind: full, where Self == Foundation.AttributedString, RHS == Foundation.AttributedString)
  @_specialize(exported: false, kind: full, where Self == Foundation.AttributedString, RHS == Foundation.AttributedSubstring)
  @_specialize(exported: false, kind: full, where Self == Foundation.AttributedSubstring, RHS == Foundation.AttributedString)
  @_specialize(exported: false, kind: full, where Self == Foundation.AttributedSubstring, RHS == Foundation.AttributedSubstring)
  public static func == <RHS>(lhs: Self, rhs: RHS) -> Swift.Bool where RHS : Foundation.AttributedStringProtocol
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.AttributedStringProtocol {
  public func index(afterCharacter i: Foundation.AttributedString.Index) -> Foundation.AttributedString.Index
  public func index(beforeCharacter i: Foundation.AttributedString.Index) -> Foundation.AttributedString.Index
  public func index(_ i: Foundation.AttributedString.Index, offsetByCharacters distance: Swift.Int) -> Foundation.AttributedString.Index
  public func index(afterUnicodeScalar i: Foundation.AttributedString.Index) -> Foundation.AttributedString.Index
  public func index(beforeUnicodeScalar i: Foundation.AttributedString.Index) -> Foundation.AttributedString.Index
  public func index(_ i: Foundation.AttributedString.Index, offsetByUnicodeScalars distance: Swift.Int) -> Foundation.AttributedString.Index
  public func index(afterRun i: Foundation.AttributedString.Index) -> Foundation.AttributedString.Index
  public func index(beforeRun i: Foundation.AttributedString.Index) -> Foundation.AttributedString.Index
  public func index(_ i: Foundation.AttributedString.Index, offsetByRuns distance: Swift.Int) -> Foundation.AttributedString.Index
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.AttributedStringProtocol {
  public func range<T>(of stringToFind: T, options: Swift.String.CompareOptions = [], locale: Foundation.Locale? = nil) -> Swift.Range<Foundation.AttributedString.Index>? where T : Swift.StringProtocol
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
@dynamicMemberLookup public struct AttributedString : Foundation.AttributedStringProtocol {
  public enum AttributeMergePolicy {
    case keepNew
    case keepCurrent
    public static func == (a: Foundation.AttributedString.AttributeMergePolicy, b: Foundation.AttributedString.AttributeMergePolicy) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public subscript<K>(_: K.Type) -> K.Value? where K : Foundation.AttributedStringKey {
    get
    set
  }
  public subscript<K>(dynamicMember keyPath: Swift.KeyPath<Foundation.AttributeDynamicLookup, K>) -> K.Value? where K : Foundation.AttributedStringKey {
    get
    set
  }
  public subscript<S>(dynamicMember keyPath: Swift.KeyPath<Foundation.AttributeScopes, S.Type>) -> Foundation.ScopedAttributeContainer<S> where S : Foundation.AttributeScope {
    get
    _modify
  }
  public mutating func setAttributes(_ attributes: Foundation.AttributeContainer)
  public mutating func mergeAttributes(_ attributes: Foundation.AttributeContainer, mergePolicy: Foundation.AttributedString.AttributeMergePolicy = .keepNew)
  public mutating func replaceAttributes(_ attributes: Foundation.AttributeContainer, with others: Foundation.AttributeContainer)
  public func transformingAttributes<K>(_ k: K.Type, _ c: (inout Foundation.AttributedString.SingleAttributeTransformer<K>) -> Swift.Void) -> Foundation.AttributedString where K : Foundation.AttributedStringKey
  public func transformingAttributes<K1, K2>(_ k: K1.Type, _ k2: K2.Type, _ c: (inout Foundation.AttributedString.SingleAttributeTransformer<K1>, inout Foundation.AttributedString.SingleAttributeTransformer<K2>) -> Swift.Void) -> Foundation.AttributedString where K1 : Foundation.AttributedStringKey, K2 : Foundation.AttributedStringKey
  public func transformingAttributes<K1, K2, K3>(_ k: K1.Type, _ k2: K2.Type, _ k3: K3.Type, _ c: (inout Foundation.AttributedString.SingleAttributeTransformer<K1>, inout Foundation.AttributedString.SingleAttributeTransformer<K2>, inout Foundation.AttributedString.SingleAttributeTransformer<K3>) -> Swift.Void) -> Foundation.AttributedString where K1 : Foundation.AttributedStringKey, K2 : Foundation.AttributedStringKey, K3 : Foundation.AttributedStringKey
  public func transformingAttributes<K1, K2, K3, K4>(_ k: K1.Type, _ k2: K2.Type, _ k3: K3.Type, _ k4: K4.Type, _ c: (inout Foundation.AttributedString.SingleAttributeTransformer<K1>, inout Foundation.AttributedString.SingleAttributeTransformer<K2>, inout Foundation.AttributedString.SingleAttributeTransformer<K3>, inout Foundation.AttributedString.SingleAttributeTransformer<K4>) -> Swift.Void) -> Foundation.AttributedString where K1 : Foundation.AttributedStringKey, K2 : Foundation.AttributedStringKey, K3 : Foundation.AttributedStringKey, K4 : Foundation.AttributedStringKey
  public func transformingAttributes<K1, K2, K3, K4, K5>(_ k: K1.Type, _ k2: K2.Type, _ k3: K3.Type, _ k4: K4.Type, _ k5: K5.Type, _ c: (inout Foundation.AttributedString.SingleAttributeTransformer<K1>, inout Foundation.AttributedString.SingleAttributeTransformer<K2>, inout Foundation.AttributedString.SingleAttributeTransformer<K3>, inout Foundation.AttributedString.SingleAttributeTransformer<K4>, inout Foundation.AttributedString.SingleAttributeTransformer<K5>) -> Swift.Void) -> Foundation.AttributedString where K1 : Foundation.AttributedStringKey, K2 : Foundation.AttributedStringKey, K3 : Foundation.AttributedStringKey, K4 : Foundation.AttributedStringKey, K5 : Foundation.AttributedStringKey
  public func transformingAttributes<K>(_ k: Swift.KeyPath<Foundation.AttributeDynamicLookup, K>, _ c: (inout Foundation.AttributedString.SingleAttributeTransformer<K>) -> Swift.Void) -> Foundation.AttributedString where K : Foundation.AttributedStringKey
  public func transformingAttributes<K1, K2>(_ k: Swift.KeyPath<Foundation.AttributeDynamicLookup, K1>, _ k2: Swift.KeyPath<Foundation.AttributeDynamicLookup, K2>, _ c: (inout Foundation.AttributedString.SingleAttributeTransformer<K1>, inout Foundation.AttributedString.SingleAttributeTransformer<K2>) -> Swift.Void) -> Foundation.AttributedString where K1 : Foundation.AttributedStringKey, K2 : Foundation.AttributedStringKey
  public func transformingAttributes<K1, K2, K3>(_ k: Swift.KeyPath<Foundation.AttributeDynamicLookup, K1>, _ k2: Swift.KeyPath<Foundation.AttributeDynamicLookup, K2>, _ k3: Swift.KeyPath<Foundation.AttributeDynamicLookup, K3>, _ c: (inout Foundation.AttributedString.SingleAttributeTransformer<K1>, inout Foundation.AttributedString.SingleAttributeTransformer<K2>, inout Foundation.AttributedString.SingleAttributeTransformer<K3>) -> Swift.Void) -> Foundation.AttributedString where K1 : Foundation.AttributedStringKey, K2 : Foundation.AttributedStringKey, K3 : Foundation.AttributedStringKey
  public func transformingAttributes<K1, K2, K3, K4>(_ k: Swift.KeyPath<Foundation.AttributeDynamicLookup, K1>, _ k2: Swift.KeyPath<Foundation.AttributeDynamicLookup, K2>, _ k3: Swift.KeyPath<Foundation.AttributeDynamicLookup, K3>, _ k4: Swift.KeyPath<Foundation.AttributeDynamicLookup, K4>, _ c: (inout Foundation.AttributedString.SingleAttributeTransformer<K1>, inout Foundation.AttributedString.SingleAttributeTransformer<K2>, inout Foundation.AttributedString.SingleAttributeTransformer<K3>, inout Foundation.AttributedString.SingleAttributeTransformer<K4>) -> Swift.Void) -> Foundation.AttributedString where K1 : Foundation.AttributedStringKey, K2 : Foundation.AttributedStringKey, K3 : Foundation.AttributedStringKey, K4 : Foundation.AttributedStringKey
  public func transformingAttributes<K1, K2, K3, K4, K5>(_ k: Swift.KeyPath<Foundation.AttributeDynamicLookup, K1>, _ k2: Swift.KeyPath<Foundation.AttributeDynamicLookup, K2>, _ k3: Swift.KeyPath<Foundation.AttributeDynamicLookup, K3>, _ k4: Swift.KeyPath<Foundation.AttributeDynamicLookup, K4>, _ k5: Swift.KeyPath<Foundation.AttributeDynamicLookup, K5>, _ c: (inout Foundation.AttributedString.SingleAttributeTransformer<K1>, inout Foundation.AttributedString.SingleAttributeTransformer<K2>, inout Foundation.AttributedString.SingleAttributeTransformer<K3>, inout Foundation.AttributedString.SingleAttributeTransformer<K4>, inout Foundation.AttributedString.SingleAttributeTransformer<K5>) -> Swift.Void) -> Foundation.AttributedString where K1 : Foundation.AttributedStringKey, K2 : Foundation.AttributedStringKey, K3 : Foundation.AttributedStringKey, K4 : Foundation.AttributedStringKey, K5 : Foundation.AttributedStringKey
  public struct SingleAttributeTransformer<T> where T : Foundation.AttributedStringKey {
    public var range: Swift.Range<Foundation.AttributedString.Index>
    public var value: T.Value? {
      get
      set
    }
    public mutating func replace<U>(with key: U.Type, value: U.Value) where U : Foundation.AttributedStringKey
    public mutating func replace<U>(with keyPath: Swift.KeyPath<Foundation.AttributeDynamicLookup, U>, value: U.Value) where U : Foundation.AttributedStringKey
  }
  public struct Index : Swift.Comparable {
    public static func < (lhs: Foundation.AttributedString.Index, rhs: Foundation.AttributedString.Index) -> Swift.Bool
    public static func == (a: Foundation.AttributedString.Index, b: Foundation.AttributedString.Index) -> Swift.Bool
  }
  public struct Runs : Swift.BidirectionalCollection, Swift.Equatable, Swift.CustomStringConvertible {
    public struct Index : Swift.Comparable, Swift.Strideable {
      public static func < (lhs: Foundation.AttributedString.Runs.Index, rhs: Foundation.AttributedString.Runs.Index) -> Swift.Bool
      public func distance(to other: Foundation.AttributedString.Runs.Index) -> Swift.Int
      public func advanced(by n: Swift.Int) -> Foundation.AttributedString.Runs.Index
      public typealias Stride = Swift.Int
    }
    @dynamicMemberLookup public struct Run : Swift.Equatable, Swift.CustomStringConvertible {
      public var range: Swift.Range<Foundation.AttributedString.Index> {
        get
      }
      public static func == (lhs: Foundation.AttributedString.Runs.Run, rhs: Foundation.AttributedString.Runs.Run) -> Swift.Bool
      public var description: Swift.String {
        get
      }
      public subscript<K>(dynamicMember keyPath: Swift.KeyPath<Foundation.AttributeDynamicLookup, K>) -> K.Value? where K : Foundation.AttributedStringKey {
        get
      }
      public subscript<K>(_: K.Type) -> K.Value? where K : Foundation.AttributedStringKey {
        get
      }
      public subscript<S>(dynamicMember keyPath: Swift.KeyPath<Foundation.AttributeScopes, S.Type>) -> Foundation.ScopedAttributeContainer<S> where S : Foundation.AttributeScope {
        get
      }
      public var attributes: Foundation.AttributeContainer {
        get
      }
    }
    public typealias Element = Foundation.AttributedString.Runs.Run
    public static func == (lhs: Foundation.AttributedString.Runs, rhs: Foundation.AttributedString.Runs) -> Swift.Bool
    public var description: Swift.String {
      get
    }
    public func index(before i: Foundation.AttributedString.Runs.Index) -> Foundation.AttributedString.Runs.Index
    public func index(after i: Foundation.AttributedString.Runs.Index) -> Foundation.AttributedString.Runs.Index
    public var startIndex: Foundation.AttributedString.Runs.Index {
      get
    }
    public var endIndex: Foundation.AttributedString.Runs.Index {
      get
    }
    public subscript(position: Foundation.AttributedString.Runs.Index) -> Foundation.AttributedString.Runs.Run {
      get
    }
    public subscript(position: Foundation.AttributedString.Index) -> Foundation.AttributedString.Runs.Run {
      get
    }
    public struct AttributesSlice1<T> : Swift.BidirectionalCollection where T : Foundation.AttributedStringKey {
      public typealias Index = Foundation.AttributedString.Index
      public typealias Element = (T.Value?, Swift.Range<Foundation.AttributedString.Index>)
      public struct Iterator : Swift.IteratorProtocol {
        public typealias Element = Foundation.AttributedString.Runs.AttributesSlice1<T>.Element
        public mutating func next() -> Foundation.AttributedString.Runs.AttributesSlice1<T>.Iterator.Element?
      }
      public func makeIterator() -> Foundation.AttributedString.Runs.AttributesSlice1<T>.Iterator
      public var startIndex: Foundation.AttributedString.Runs.AttributesSlice1<T>.Index {
        get
      }
      public var endIndex: Foundation.AttributedString.Runs.AttributesSlice1<T>.Index {
        get
      }
      public func index(before i: Foundation.AttributedString.Runs.AttributesSlice1<T>.Index) -> Foundation.AttributedString.Runs.AttributesSlice1<T>.Index
      public func index(after i: Foundation.AttributedString.Runs.AttributesSlice1<T>.Index) -> Foundation.AttributedString.Runs.AttributesSlice1<T>.Index
      public subscript(position: Foundation.AttributedString.Index) -> Foundation.AttributedString.Runs.AttributesSlice1<T>.Element {
        get
      }
      public typealias Indices = Swift.DefaultIndices<Foundation.AttributedString.Runs.AttributesSlice1<T>>
      public typealias SubSequence = Swift.Slice<Foundation.AttributedString.Runs.AttributesSlice1<T>>
    }
    public struct AttributesSlice2<T, U> : Swift.BidirectionalCollection where T : Foundation.AttributedStringKey, U : Foundation.AttributedStringKey {
      public typealias Index = Foundation.AttributedString.Index
      public typealias Element = (T.Value?, U.Value?, Swift.Range<Foundation.AttributedString.Index>)
      public struct Iterator : Swift.IteratorProtocol {
        public typealias Element = Foundation.AttributedString.Runs.AttributesSlice2<T, U>.Element
        public mutating func next() -> Foundation.AttributedString.Runs.AttributesSlice2<T, U>.Iterator.Element?
      }
      public func makeIterator() -> Foundation.AttributedString.Runs.AttributesSlice2<T, U>.Iterator
      public var startIndex: Foundation.AttributedString.Runs.AttributesSlice2<T, U>.Index {
        get
      }
      public var endIndex: Foundation.AttributedString.Runs.AttributesSlice2<T, U>.Index {
        get
      }
      public func index(before i: Foundation.AttributedString.Runs.AttributesSlice2<T, U>.Index) -> Foundation.AttributedString.Runs.AttributesSlice2<T, U>.Index
      public func index(after i: Foundation.AttributedString.Runs.AttributesSlice2<T, U>.Index) -> Foundation.AttributedString.Runs.AttributesSlice2<T, U>.Index
      public subscript(position: Foundation.AttributedString.Index) -> Foundation.AttributedString.Runs.AttributesSlice2<T, U>.Element {
        get
      }
      public typealias Indices = Swift.DefaultIndices<Foundation.AttributedString.Runs.AttributesSlice2<T, U>>
      public typealias SubSequence = Swift.Slice<Foundation.AttributedString.Runs.AttributesSlice2<T, U>>
    }
    public struct AttributesSlice3<T, U, V> : Swift.BidirectionalCollection where T : Foundation.AttributedStringKey, U : Foundation.AttributedStringKey, V : Foundation.AttributedStringKey {
      public typealias Index = Foundation.AttributedString.Index
      public typealias Element = (T.Value?, U.Value?, V.Value?, Swift.Range<Foundation.AttributedString.Index>)
      public struct Iterator : Swift.IteratorProtocol {
        public typealias Element = Foundation.AttributedString.Runs.AttributesSlice3<T, U, V>.Element
        public mutating func next() -> Foundation.AttributedString.Runs.AttributesSlice3<T, U, V>.Iterator.Element?
      }
      public func makeIterator() -> Foundation.AttributedString.Runs.AttributesSlice3<T, U, V>.Iterator
      public var startIndex: Foundation.AttributedString.Runs.AttributesSlice3<T, U, V>.Index {
        get
      }
      public var endIndex: Foundation.AttributedString.Runs.AttributesSlice3<T, U, V>.Index {
        get
      }
      public func index(before i: Foundation.AttributedString.Runs.AttributesSlice3<T, U, V>.Index) -> Foundation.AttributedString.Runs.AttributesSlice3<T, U, V>.Index
      public func index(after i: Foundation.AttributedString.Runs.AttributesSlice3<T, U, V>.Index) -> Foundation.AttributedString.Runs.AttributesSlice3<T, U, V>.Index
      public subscript(position: Foundation.AttributedString.Index) -> Foundation.AttributedString.Runs.AttributesSlice3<T, U, V>.Element {
        get
      }
      public typealias Indices = Swift.DefaultIndices<Foundation.AttributedString.Runs.AttributesSlice3<T, U, V>>
      public typealias SubSequence = Swift.Slice<Foundation.AttributedString.Runs.AttributesSlice3<T, U, V>>
    }
    public struct AttributesSlice4<T, U, V, W> : Swift.BidirectionalCollection where T : Foundation.AttributedStringKey, U : Foundation.AttributedStringKey, V : Foundation.AttributedStringKey, W : Foundation.AttributedStringKey {
      public typealias Index = Foundation.AttributedString.Index
      public typealias Element = (T.Value?, U.Value?, V.Value?, W.Value?, Swift.Range<Foundation.AttributedString.Index>)
      public struct Iterator : Swift.IteratorProtocol {
        public typealias Element = Foundation.AttributedString.Runs.AttributesSlice4<T, U, V, W>.Element
        public mutating func next() -> Foundation.AttributedString.Runs.AttributesSlice4<T, U, V, W>.Iterator.Element?
      }
      public func makeIterator() -> Foundation.AttributedString.Runs.AttributesSlice4<T, U, V, W>.Iterator
      public var startIndex: Foundation.AttributedString.Runs.AttributesSlice4<T, U, V, W>.Index {
        get
      }
      public var endIndex: Foundation.AttributedString.Runs.AttributesSlice4<T, U, V, W>.Index {
        get
      }
      public func index(before i: Foundation.AttributedString.Runs.AttributesSlice4<T, U, V, W>.Index) -> Foundation.AttributedString.Runs.AttributesSlice4<T, U, V, W>.Index
      public func index(after i: Foundation.AttributedString.Runs.AttributesSlice4<T, U, V, W>.Index) -> Foundation.AttributedString.Runs.AttributesSlice4<T, U, V, W>.Index
      public subscript(position: Foundation.AttributedString.Index) -> Foundation.AttributedString.Runs.AttributesSlice4<T, U, V, W>.Element {
        get
      }
      public typealias Indices = Swift.DefaultIndices<Foundation.AttributedString.Runs.AttributesSlice4<T, U, V, W>>
      public typealias SubSequence = Swift.Slice<Foundation.AttributedString.Runs.AttributesSlice4<T, U, V, W>>
    }
    public struct AttributesSlice5<T, U, V, W, X> : Swift.BidirectionalCollection where T : Foundation.AttributedStringKey, U : Foundation.AttributedStringKey, V : Foundation.AttributedStringKey, W : Foundation.AttributedStringKey, X : Foundation.AttributedStringKey {
      public typealias Index = Foundation.AttributedString.Index
      public typealias Element = (T.Value?, U.Value?, V.Value?, W.Value?, X.Value?, Swift.Range<Foundation.AttributedString.Index>)
      public struct Iterator : Swift.IteratorProtocol {
        public typealias Element = Foundation.AttributedString.Runs.AttributesSlice5<T, U, V, W, X>.Element
        public mutating func next() -> Foundation.AttributedString.Runs.AttributesSlice5<T, U, V, W, X>.Iterator.Element?
      }
      public func makeIterator() -> Foundation.AttributedString.Runs.AttributesSlice5<T, U, V, W, X>.Iterator
      public var startIndex: Foundation.AttributedString.Runs.AttributesSlice5<T, U, V, W, X>.Index {
        get
      }
      public var endIndex: Foundation.AttributedString.Runs.AttributesSlice5<T, U, V, W, X>.Index {
        get
      }
      public func index(before i: Foundation.AttributedString.Runs.AttributesSlice5<T, U, V, W, X>.Index) -> Foundation.AttributedString.Runs.AttributesSlice5<T, U, V, W, X>.Index
      public func index(after i: Foundation.AttributedString.Runs.AttributesSlice5<T, U, V, W, X>.Index) -> Foundation.AttributedString.Runs.AttributesSlice5<T, U, V, W, X>.Index
      public subscript(position: Foundation.AttributedString.Index) -> Foundation.AttributedString.Runs.AttributesSlice5<T, U, V, W, X>.Element {
        get
      }
      public typealias Indices = Swift.DefaultIndices<Foundation.AttributedString.Runs.AttributesSlice5<T, U, V, W, X>>
      public typealias SubSequence = Swift.Slice<Foundation.AttributedString.Runs.AttributesSlice5<T, U, V, W, X>>
    }
    public subscript<T, U, V, W, X>(t: Swift.KeyPath<Foundation.AttributeDynamicLookup, T>, u: Swift.KeyPath<Foundation.AttributeDynamicLookup, U>, v: Swift.KeyPath<Foundation.AttributeDynamicLookup, V>, w: Swift.KeyPath<Foundation.AttributeDynamicLookup, W>, x: Swift.KeyPath<Foundation.AttributeDynamicLookup, X>) -> Foundation.AttributedString.Runs.AttributesSlice5<T, U, V, W, X> where T : Foundation.AttributedStringKey, U : Foundation.AttributedStringKey, V : Foundation.AttributedStringKey, W : Foundation.AttributedStringKey, X : Foundation.AttributedStringKey {
      get
    }
    public subscript<T, U, V, W>(t: Swift.KeyPath<Foundation.AttributeDynamicLookup, T>, u: Swift.KeyPath<Foundation.AttributeDynamicLookup, U>, v: Swift.KeyPath<Foundation.AttributeDynamicLookup, V>, w: Swift.KeyPath<Foundation.AttributeDynamicLookup, W>) -> Foundation.AttributedString.Runs.AttributesSlice4<T, U, V, W> where T : Foundation.AttributedStringKey, U : Foundation.AttributedStringKey, V : Foundation.AttributedStringKey, W : Foundation.AttributedStringKey {
      get
    }
    public subscript<T, U, V>(t: Swift.KeyPath<Foundation.AttributeDynamicLookup, T>, u: Swift.KeyPath<Foundation.AttributeDynamicLookup, U>, v: Swift.KeyPath<Foundation.AttributeDynamicLookup, V>) -> Foundation.AttributedString.Runs.AttributesSlice3<T, U, V> where T : Foundation.AttributedStringKey, U : Foundation.AttributedStringKey, V : Foundation.AttributedStringKey {
      get
    }
    public subscript<T, U>(t: Swift.KeyPath<Foundation.AttributeDynamicLookup, T>, u: Swift.KeyPath<Foundation.AttributeDynamicLookup, U>) -> Foundation.AttributedString.Runs.AttributesSlice2<T, U> where T : Foundation.AttributedStringKey, U : Foundation.AttributedStringKey {
      get
    }
    public subscript<T>(keyPath: Swift.KeyPath<Foundation.AttributeDynamicLookup, T>) -> Foundation.AttributedString.Runs.AttributesSlice1<T> where T : Foundation.AttributedStringKey {
      get
    }
    public subscript<T, U, V, W, X>(t: T.Type, u: U.Type, v: V.Type, w: W.Type, x: X.Type) -> Foundation.AttributedString.Runs.AttributesSlice5<T, U, V, W, X> where T : Foundation.AttributedStringKey, U : Foundation.AttributedStringKey, V : Foundation.AttributedStringKey, W : Foundation.AttributedStringKey, X : Foundation.AttributedStringKey {
      get
    }
    public subscript<T, U, V, W>(t: T.Type, u: U.Type, v: V.Type, w: W.Type) -> Foundation.AttributedString.Runs.AttributesSlice4<T, U, V, W> where T : Foundation.AttributedStringKey, U : Foundation.AttributedStringKey, V : Foundation.AttributedStringKey, W : Foundation.AttributedStringKey {
      get
    }
    public subscript<T, U, V>(t: T.Type, u: U.Type, v: V.Type) -> Foundation.AttributedString.Runs.AttributesSlice3<T, U, V> where T : Foundation.AttributedStringKey, U : Foundation.AttributedStringKey, V : Foundation.AttributedStringKey {
      get
    }
    public subscript<T, U>(t: T.Type, u: U.Type) -> Foundation.AttributedString.Runs.AttributesSlice2<T, U> where T : Foundation.AttributedStringKey, U : Foundation.AttributedStringKey {
      get
    }
    public subscript<T>(t: T.Type) -> Foundation.AttributedString.Runs.AttributesSlice1<T> where T : Foundation.AttributedStringKey {
      get
    }
    public typealias Indices = Swift.DefaultIndices<Foundation.AttributedString.Runs>
    public typealias Iterator = Swift.IndexingIterator<Foundation.AttributedString.Runs>
    public typealias SubSequence = Swift.Slice<Foundation.AttributedString.Runs>
  }
  public var runs: Foundation.AttributedString.Runs {
    get
  }
  public struct CharacterView : Swift.BidirectionalCollection, Swift.RangeReplaceableCollection {
    public typealias Element = Swift.Character
    public typealias Index = Foundation.AttributedString.Index
    public init()
    public var startIndex: Foundation.AttributedString.Index {
      get
    }
    public var endIndex: Foundation.AttributedString.Index {
      get
    }
    public func index(before i: Foundation.AttributedString.Index) -> Foundation.AttributedString.Index
    public func index(after i: Foundation.AttributedString.Index) -> Foundation.AttributedString.Index
    public subscript(index: Foundation.AttributedString.Index) -> Swift.Character {
      get
      set
    }
    public subscript(bounds: Swift.Range<Foundation.AttributedString.Index>) -> Swift.Slice<Foundation.AttributedString.CharacterView> {
      get
      set
    }
    public mutating func replaceSubrange<C>(_ subrange: Swift.Range<Foundation.AttributedString.CharacterView.Index>, with newElements: C) where C : Swift.Collection, C.Element == Swift.Character
    public typealias Indices = Swift.DefaultIndices<Foundation.AttributedString.CharacterView>
    public typealias Iterator = Swift.IndexingIterator<Foundation.AttributedString.CharacterView>
    public typealias SubSequence = Swift.Slice<Foundation.AttributedString.CharacterView>
  }
  public struct UnicodeScalarView : Swift.RangeReplaceableCollection, Swift.BidirectionalCollection {
    public typealias Element = Swift.UnicodeScalar
    public typealias Index = Foundation.AttributedString.Index
    public init()
    public var startIndex: Foundation.AttributedString.Index {
      get
    }
    public var endIndex: Foundation.AttributedString.Index {
      get
    }
    public func index(before i: Foundation.AttributedString.Index) -> Foundation.AttributedString.Index
    public func index(after i: Foundation.AttributedString.Index) -> Foundation.AttributedString.Index
    public func index(_ i: Foundation.AttributedString.Index, offsetBy distance: Swift.Int) -> Foundation.AttributedString.Index
    public subscript(index: Foundation.AttributedString.Index) -> Swift.UnicodeScalar {
      get
    }
    public subscript(bounds: Swift.Range<Foundation.AttributedString.Index>) -> Swift.Slice<Foundation.AttributedString.UnicodeScalarView> {
      get
    }
    public mutating func replaceSubrange<C>(_ subrange: Swift.Range<Foundation.AttributedString.UnicodeScalarView.Index>, with newElements: C) where C : Swift.Collection, C.Element == Swift.UnicodeScalar
    public typealias Indices = Swift.DefaultIndices<Foundation.AttributedString.UnicodeScalarView>
    public typealias Iterator = Swift.IndexingIterator<Foundation.AttributedString.UnicodeScalarView>
    public typealias SubSequence = Swift.Slice<Foundation.AttributedString.UnicodeScalarView>
  }
  public var characters: Foundation.AttributedString.CharacterView {
    get
    set
    _modify
  }
  public var unicodeScalars: Foundation.AttributedString.UnicodeScalarView {
    get
    set
    _modify
  }
  public static func == (lhs: Foundation.AttributedString, rhs: Foundation.AttributedString) -> Swift.Bool
  public init()
  public init(_ string: Swift.String, attributes: Foundation.AttributeContainer = .init())
  public init(_ substring: Swift.Substring, attributes: Foundation.AttributeContainer = .init())
  public init<S>(_ elements: S, attributes: Foundation.AttributeContainer = .init()) where S : Swift.Sequence, S.Element == Swift.Character
  public init(_ substring: Foundation.AttributedSubstring)
  public init<S, T>(_ other: T, including scope: Swift.KeyPath<Foundation.AttributeScopes, S.Type>) where S : Foundation.AttributeScope, T : Foundation.AttributedStringProtocol
  public init<S, T>(_ other: T, including scope: S.Type) where S : Foundation.AttributeScope, T : Foundation.AttributedStringProtocol
  public static func + <T>(lhs: Foundation.AttributedString, rhs: T) -> Foundation.AttributedString where T : Foundation.AttributedStringProtocol
  public static func += <T>(lhs: inout Foundation.AttributedString, rhs: T) where T : Foundation.AttributedStringProtocol
  public static func + (lhs: Foundation.AttributedString, rhs: Foundation.AttributedString) -> Foundation.AttributedString
  public static func += (lhs: inout Foundation.AttributedString, rhs: Foundation.AttributedString)
  public subscript<R>(bounds: R) -> Foundation.AttributedSubstring where R : Swift.RangeExpression, R.Bound == Foundation.AttributedString.Index {
    get
    set
    _modify
  }
  public mutating func append<S>(_ s: S) where S : Foundation.AttributedStringProtocol
  public mutating func insert<S>(_ s: S, at index: Foundation.AttributedString.Index) where S : Foundation.AttributedStringProtocol
  public mutating func removeSubrange<R>(_ range: R) where R : Swift.RangeExpression, R.Bound == Foundation.AttributedString.Index
  public mutating func replaceSubrange<R, S>(_ range: R, with s: S) where R : Swift.RangeExpression, S : Foundation.AttributedStringProtocol, R.Bound == Foundation.AttributedString.Index
  public var startIndex: Foundation.AttributedString.Index {
    get
  }
  public var endIndex: Foundation.AttributedString.Index {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.AttributedString : Swift.ExpressibleByStringLiteral {
  public init(stringLiteral value: Swift.String)
  public typealias ExtendedGraphemeClusterLiteralType = Swift.String
  public typealias StringLiteralType = Swift.String
  public typealias UnicodeScalarLiteralType = Swift.String
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
@dynamicMemberLookup public struct AttributedSubstring {
  public init()
  public var base: Foundation.AttributedString {
    get
  }
  public var description: Swift.String {
    get
  }
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.AttributedSubstring : Foundation.AttributedStringProtocol {
  public var startIndex: Foundation.AttributedString.Index {
    get
  }
  public var endIndex: Foundation.AttributedString.Index {
    get
  }
  public static func == (lhs: Foundation.AttributedSubstring, rhs: Foundation.AttributedSubstring) -> Swift.Bool
  public mutating func setAttributes(_ attributes: Foundation.AttributeContainer)
  public mutating func mergeAttributes(_ attributes: Foundation.AttributeContainer, mergePolicy: Foundation.AttributedString.AttributeMergePolicy = .keepNew)
  public mutating func replaceAttributes(_ attributes: Foundation.AttributeContainer, with others: Foundation.AttributeContainer)
  public var runs: Foundation.AttributedString.Runs {
    get
  }
  public var characters: Foundation.AttributedString.CharacterView {
    get
  }
  public var unicodeScalars: Foundation.AttributedString.UnicodeScalarView {
    get
  }
  public subscript<R>(bounds: R) -> Foundation.AttributedSubstring where R : Swift.RangeExpression, R.Bound == Foundation.AttributedString.Index {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.AttributedSubstring {
  public subscript<K>(_: K.Type) -> K.Value? where K : Foundation.AttributedStringKey {
    get
    set
  }
  public subscript<K>(dynamicMember keyPath: Swift.KeyPath<Foundation.AttributeDynamicLookup, K>) -> K.Value? where K : Foundation.AttributedStringKey {
    get
    set
  }
  public subscript<S>(dynamicMember keyPath: Swift.KeyPath<Foundation.AttributeScopes, S.Type>) -> Foundation.ScopedAttributeContainer<S> where S : Foundation.AttributeScope {
    get
    _modify
  }
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Swift.String {
  public init(_ attrStrSlice: Swift.Slice<Foundation.AttributedString.CharacterView>)
}
public struct NSIndexSetIterator : Swift.IteratorProtocol {
  public typealias Element = Swift.Int
  public mutating func next() -> Swift.Int?
}
extension Foundation.NSIndexSet : Swift.Sequence {
  public func makeIterator() -> Foundation.NSIndexSetIterator
  @_alwaysEmitIntoClient @nonobjc public var underestimatedCount: Swift.Int {
    get { count }
  }
  public typealias Element = Foundation.NSIndexSetIterator.Element
  public typealias Iterator = Foundation.NSIndexSetIterator
}
@available(macOS 10.11, iOS 9.0, *)
public struct PersonNameComponents : Foundation.ReferenceConvertible, Swift.Hashable, Swift.Equatable {
  public typealias ReferenceType = Foundation.NSPersonNameComponents
  public init()
  @available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
  public init(namePrefix: Swift.String? = nil, givenName: Swift.String? = nil, middleName: Swift.String? = nil, familyName: Swift.String? = nil, nameSuffix: Swift.String? = nil, nickname: Swift.String? = nil, phoneticRepresentation: Foundation.PersonNameComponents? = nil)
  public var namePrefix: Swift.String? {
    get
    set
  }
  public var givenName: Swift.String? {
    get
    set
  }
  public var middleName: Swift.String? {
    get
    set
  }
  public var familyName: Swift.String? {
    get
    set
  }
  public var nameSuffix: Swift.String? {
    get
    set
  }
  public var nickname: Swift.String? {
    get
    set
  }
  public var phoneticRepresentation: Foundation.PersonNameComponents? {
    get
    set
  }
  public func hash(into hasher: inout Swift.Hasher)
  @available(macOS 10.11, iOS 9.0, *)
  public static func == (lhs: Foundation.PersonNameComponents, rhs: Foundation.PersonNameComponents) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
@available(macOS 10.11, iOS 9.0, *)
extension Foundation.PersonNameComponents : Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible, Swift.CustomReflectable {
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
  public var customMirror: Swift.Mirror {
    get
  }
}
@available(macOS 10.11, iOS 9.0, *)
extension Foundation.PersonNameComponents : Swift._ObjectiveCBridgeable {
  public static func _getObjectiveCType() -> Any.Type
  @_semantics("convertToObjectiveC") public func _bridgeToObjectiveC() -> Foundation.NSPersonNameComponents
  public static func _forceBridgeFromObjectiveC(_ personNameComponents: Foundation.NSPersonNameComponents, result: inout Foundation.PersonNameComponents?)
  public static func _conditionallyBridgeFromObjectiveC(_ personNameComponents: Foundation.NSPersonNameComponents, result: inout Foundation.PersonNameComponents?) -> Swift.Bool
  @_effects(readonly) public static func _unconditionallyBridgeFromObjectiveC(_ source: Foundation.NSPersonNameComponents?) -> Foundation.PersonNameComponents
  public typealias _ObjectiveCType = Foundation.NSPersonNameComponents
}
@available(macOS 10.11, iOS 9.0, *)
extension Foundation.NSPersonNameComponents : Swift._HasCustomAnyHashableRepresentation {
  @nonobjc public func _toCustomAnyHashable() -> Swift.AnyHashable?
}
@available(macOS 10.11, iOS 9.0, *)
extension Foundation.PersonNameComponents : Swift.Codable {
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.AttributedString {
  public struct MarkdownParsingOptions {
    public enum FailurePolicy : Swift.Int {
      case throwError
      case returnPartiallyParsedIfPossible
      public init?(rawValue: Swift.Int)
      public typealias RawValue = Swift.Int
      public var rawValue: Swift.Int {
        get
      }
    }
    public enum InterpretedSyntax : Swift.Int {
      case full
      case inlineOnly
      case inlineOnlyPreservingWhitespace
      public init?(rawValue: Swift.Int)
      public typealias RawValue = Swift.Int
      public var rawValue: Swift.Int {
        get
      }
    }
    public var allowsExtendedAttributes: Swift.Bool
    public var interpretedSyntax: Foundation.AttributedString.MarkdownParsingOptions.InterpretedSyntax
    public var failurePolicy: Foundation.AttributedString.MarkdownParsingOptions.FailurePolicy
    public var languageCode: Swift.String?
    public init(allowsExtendedAttributes: Swift.Bool = false, interpretedSyntax: Foundation.AttributedString.MarkdownParsingOptions.InterpretedSyntax = .full, failurePolicy: Foundation.AttributedString.MarkdownParsingOptions.FailurePolicy = .throwError, languageCode: Swift.String? = nil)
  }
  public init<S>(markdown: Swift.String, including scope: Swift.KeyPath<Foundation.AttributeScopes, S.Type>, options: Foundation.AttributedString.MarkdownParsingOptions = .init(), baseURL: Foundation.URL? = nil) throws where S : Foundation.AttributeScope
  public init(markdown: Swift.String, options: Foundation.AttributedString.MarkdownParsingOptions = .init(), baseURL: Foundation.URL? = nil) throws
  public init<S>(markdown: Swift.String, including scope: S.Type, options: Foundation.AttributedString.MarkdownParsingOptions = .init(), baseURL: Foundation.URL? = nil) throws where S : Foundation.AttributeScope
  public init<S>(markdown: Foundation.Data, including scope: Swift.KeyPath<Foundation.AttributeScopes, S.Type>, options: Foundation.AttributedString.MarkdownParsingOptions = .init(), baseURL: Foundation.URL? = nil) throws where S : Foundation.AttributeScope
  public init(markdown: Foundation.Data, options: Foundation.AttributedString.MarkdownParsingOptions = .init(), baseURL: Foundation.URL? = nil) throws
  public init<S>(markdown: Foundation.Data, including scope: S.Type, options: Foundation.AttributedString.MarkdownParsingOptions = .init(), baseURL: Foundation.URL? = nil) throws where S : Foundation.AttributeScope
  public init<S>(contentsOf url: Foundation.URL, including scope: Swift.KeyPath<Foundation.AttributeScopes, S.Type>, options: Foundation.AttributedString.MarkdownParsingOptions = .init(), baseURL: Foundation.URL? = nil) throws where S : Foundation.AttributeScope
  public init(contentsOf url: Foundation.URL, options: Foundation.AttributedString.MarkdownParsingOptions = .init(), baseURL: Foundation.URL? = nil) throws
  public init<S>(contentsOf url: Foundation.URL, including scope: S.Type, options: Foundation.AttributedString.MarkdownParsingOptions = .init(), baseURL: Foundation.URL? = nil) throws where S : Foundation.AttributeScope
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.InlinePresentationIntent : Swift.Hashable, Swift.Codable {
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.AttributedString.MarkdownParsingOptions : Swift._ObjectiveCBridgeable {
  @_semantics("convertToObjectiveC") public func _bridgeToObjectiveC() -> Foundation.__NSAttributedStringMarkdownParsingOptions
  public static func _forceBridgeFromObjectiveC(_ x: Foundation.__NSAttributedStringMarkdownParsingOptions, result: inout Foundation.AttributedString.MarkdownParsingOptions?)
  public static func _conditionallyBridgeFromObjectiveC(_ x: Foundation.__NSAttributedStringMarkdownParsingOptions, result: inout Foundation.AttributedString.MarkdownParsingOptions?) -> Swift.Bool
  @_effects(readonly) public static func _unconditionallyBridgeFromObjectiveC(_ source: Foundation.__NSAttributedStringMarkdownParsingOptions?) -> Foundation.AttributedString.MarkdownParsingOptions
  public typealias _ObjectiveCType = Foundation.__NSAttributedStringMarkdownParsingOptions
}
public struct CharacterSet : Foundation.ReferenceConvertible, Swift.Equatable, Swift.Hashable, Swift.SetAlgebra {
  public typealias ReferenceType = Foundation.NSCharacterSet
  public init()
  public init(charactersIn range: Swift.Range<Swift.Unicode.Scalar>)
  public init(charactersIn range: Swift.ClosedRange<Swift.Unicode.Scalar>)
  public init(charactersIn string: __shared Swift.String)
  public init(bitmapRepresentation data: __shared Foundation.Data)
  public init?(contentsOfFile file: __shared Swift.String)
  public static var controlCharacters: Foundation.CharacterSet {
    get
  }
  public static var whitespaces: Foundation.CharacterSet {
    get
  }
  public static var whitespacesAndNewlines: Foundation.CharacterSet {
    get
  }
  public static var decimalDigits: Foundation.CharacterSet {
    get
  }
  public static var letters: Foundation.CharacterSet {
    get
  }
  public static var lowercaseLetters: Foundation.CharacterSet {
    get
  }
  public static var uppercaseLetters: Foundation.CharacterSet {
    get
  }
  public static var nonBaseCharacters: Foundation.CharacterSet {
    get
  }
  public static var alphanumerics: Foundation.CharacterSet {
    get
  }
  public static var decomposables: Foundation.CharacterSet {
    get
  }
  public static var illegalCharacters: Foundation.CharacterSet {
    get
  }
  @available(*, unavailable, renamed: "punctuationCharacters")
  public static var punctuation: Foundation.CharacterSet {
    get
  }
  public static var punctuationCharacters: Foundation.CharacterSet {
    get
  }
  public static var capitalizedLetters: Foundation.CharacterSet {
    get
  }
  public static var symbols: Foundation.CharacterSet {
    get
  }
  public static var newlines: Foundation.CharacterSet {
    get
  }
  public static var urlUserAllowed: Foundation.CharacterSet {
    get
  }
  public static var urlPasswordAllowed: Foundation.CharacterSet {
    get
  }
  public static var urlHostAllowed: Foundation.CharacterSet {
    get
  }
  public static var urlPathAllowed: Foundation.CharacterSet {
    get
  }
  public static var urlQueryAllowed: Foundation.CharacterSet {
    get
  }
  public static var urlFragmentAllowed: Foundation.CharacterSet {
    get
  }
  @nonobjc public var bitmapRepresentation: Foundation.Data {
    get
  }
  @nonobjc public var inverted: Foundation.CharacterSet {
    get
  }
  public func hasMember(inPlane plane: Swift.UInt8) -> Swift.Bool
  public mutating func insert(charactersIn range: Swift.Range<Swift.Unicode.Scalar>)
  public mutating func insert(charactersIn range: Swift.ClosedRange<Swift.Unicode.Scalar>)
  public mutating func remove(charactersIn range: Swift.Range<Swift.Unicode.Scalar>)
  public mutating func remove(charactersIn range: Swift.ClosedRange<Swift.Unicode.Scalar>)
  public mutating func insert(charactersIn string: Swift.String)
  public mutating func remove(charactersIn string: Swift.String)
  public mutating func invert()
  @discardableResult
  public mutating func insert(_ character: Swift.Unicode.Scalar) -> (inserted: Swift.Bool, memberAfterInsert: Swift.Unicode.Scalar)
  @discardableResult
  public mutating func update(with character: Swift.Unicode.Scalar) -> Swift.Unicode.Scalar?
  @discardableResult
  public mutating func remove(_ character: Swift.Unicode.Scalar) -> Swift.Unicode.Scalar?
  public func contains(_ member: Swift.Unicode.Scalar) -> Swift.Bool
  public func union(_ other: Foundation.CharacterSet) -> Foundation.CharacterSet
  public mutating func formUnion(_ other: Foundation.CharacterSet)
  public func intersection(_ other: Foundation.CharacterSet) -> Foundation.CharacterSet
  public mutating func formIntersection(_ other: Foundation.CharacterSet)
  public func subtracting(_ other: Foundation.CharacterSet) -> Foundation.CharacterSet
  public mutating func subtract(_ other: Foundation.CharacterSet)
  public func symmetricDifference(_ other: Foundation.CharacterSet) -> Foundation.CharacterSet
  public mutating func formSymmetricDifference(_ other: Foundation.CharacterSet)
  public func isSuperset(of other: Foundation.CharacterSet) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (lhs: Foundation.CharacterSet, rhs: Foundation.CharacterSet) -> Swift.Bool
  public typealias ArrayLiteralElement = Swift.Unicode.Scalar
  public typealias Element = Swift.Unicode.Scalar
  public var hashValue: Swift.Int {
    get
  }
}
extension Foundation.CharacterSet : Swift._ObjectiveCBridgeable {
  public static func _getObjectiveCType() -> Any.Type
  @_semantics("convertToObjectiveC") public func _bridgeToObjectiveC() -> Foundation.NSCharacterSet
  public static func _forceBridgeFromObjectiveC(_ input: Foundation.NSCharacterSet, result: inout Foundation.CharacterSet?)
  public static func _conditionallyBridgeFromObjectiveC(_ input: Foundation.NSCharacterSet, result: inout Foundation.CharacterSet?) -> Swift.Bool
  @_effects(readonly) public static func _unconditionallyBridgeFromObjectiveC(_ source: Foundation.NSCharacterSet?) -> Foundation.CharacterSet
  public typealias _ObjectiveCType = Foundation.NSCharacterSet
}
extension Foundation.CharacterSet : Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible {
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
}
extension Foundation.NSCharacterSet : Swift._HasCustomAnyHashableRepresentation {
  @nonobjc public func _toCustomAnyHashable() -> Swift.AnyHashable?
}
extension Foundation.CharacterSet : Swift.Codable {
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
public struct SortDescriptor<Compared> : Foundation.SortComparator, Swift.Codable {
  public var order: Foundation.SortOrder
  public init(_ keyPath: Swift.KeyPath<Compared, Swift.Bool>, order: Foundation.SortOrder = .forward) where Compared : ObjectiveC.NSObject
  public init(_ keyPath: Swift.KeyPath<Compared, Swift.Bool?>, order: Foundation.SortOrder = .forward) where Compared : ObjectiveC.NSObject
  public init(_ keyPath: Swift.KeyPath<Compared, Swift.Double>, order: Foundation.SortOrder = .forward) where Compared : ObjectiveC.NSObject
  public init(_ keyPath: Swift.KeyPath<Compared, Swift.Double?>, order: Foundation.SortOrder = .forward) where Compared : ObjectiveC.NSObject
  public init(_ keyPath: Swift.KeyPath<Compared, Swift.Float>, order: Foundation.SortOrder = .forward) where Compared : ObjectiveC.NSObject
  public init(_ keyPath: Swift.KeyPath<Compared, Swift.Float?>, order: Foundation.SortOrder = .forward) where Compared : ObjectiveC.NSObject
  public init(_ keyPath: Swift.KeyPath<Compared, Swift.Int8>, order: Foundation.SortOrder = .forward) where Compared : ObjectiveC.NSObject
  public init(_ keyPath: Swift.KeyPath<Compared, Swift.Int8?>, order: Foundation.SortOrder = .forward) where Compared : ObjectiveC.NSObject
  public init(_ keyPath: Swift.KeyPath<Compared, Swift.Int16>, order: Foundation.SortOrder = .forward) where Compared : ObjectiveC.NSObject
  public init(_ keyPath: Swift.KeyPath<Compared, Swift.Int16?>, order: Foundation.SortOrder = .forward) where Compared : ObjectiveC.NSObject
  public init(_ keyPath: Swift.KeyPath<Compared, Swift.Int32>, order: Foundation.SortOrder = .forward) where Compared : ObjectiveC.NSObject
  public init(_ keyPath: Swift.KeyPath<Compared, Swift.Int32?>, order: Foundation.SortOrder = .forward) where Compared : ObjectiveC.NSObject
  public init(_ keyPath: Swift.KeyPath<Compared, Swift.Int64>, order: Foundation.SortOrder = .forward) where Compared : ObjectiveC.NSObject
  public init(_ keyPath: Swift.KeyPath<Compared, Swift.Int64?>, order: Foundation.SortOrder = .forward) where Compared : ObjectiveC.NSObject
  public init(_ keyPath: Swift.KeyPath<Compared, Swift.Int>, order: Foundation.SortOrder = .forward) where Compared : ObjectiveC.NSObject
  public init(_ keyPath: Swift.KeyPath<Compared, Swift.Int?>, order: Foundation.SortOrder = .forward) where Compared : ObjectiveC.NSObject
  public init(_ keyPath: Swift.KeyPath<Compared, Swift.UInt8>, order: Foundation.SortOrder = .forward) where Compared : ObjectiveC.NSObject
  public init(_ keyPath: Swift.KeyPath<Compared, Swift.UInt8?>, order: Foundation.SortOrder = .forward) where Compared : ObjectiveC.NSObject
  public init(_ keyPath: Swift.KeyPath<Compared, Swift.UInt16>, order: Foundation.SortOrder = .forward) where Compared : ObjectiveC.NSObject
  public init(_ keyPath: Swift.KeyPath<Compared, Swift.UInt16?>, order: Foundation.SortOrder = .forward) where Compared : ObjectiveC.NSObject
  public init(_ keyPath: Swift.KeyPath<Compared, Swift.UInt32>, order: Foundation.SortOrder = .forward) where Compared : ObjectiveC.NSObject
  public init(_ keyPath: Swift.KeyPath<Compared, Swift.UInt32?>, order: Foundation.SortOrder = .forward) where Compared : ObjectiveC.NSObject
  public init(_ keyPath: Swift.KeyPath<Compared, Swift.UInt64>, order: Foundation.SortOrder = .forward) where Compared : ObjectiveC.NSObject
  public init(_ keyPath: Swift.KeyPath<Compared, Swift.UInt64?>, order: Foundation.SortOrder = .forward) where Compared : ObjectiveC.NSObject
  public init(_ keyPath: Swift.KeyPath<Compared, Swift.UInt>, order: Foundation.SortOrder = .forward) where Compared : ObjectiveC.NSObject
  public init(_ keyPath: Swift.KeyPath<Compared, Swift.UInt?>, order: Foundation.SortOrder = .forward) where Compared : ObjectiveC.NSObject
  public init(_ keyPath: Swift.KeyPath<Compared, Foundation.Date>, order: Foundation.SortOrder = .forward) where Compared : ObjectiveC.NSObject
  public init(_ keyPath: Swift.KeyPath<Compared, Foundation.Date?>, order: Foundation.SortOrder = .forward) where Compared : ObjectiveC.NSObject
  public init(_ keyPath: Swift.KeyPath<Compared, Foundation.UUID>, order: Foundation.SortOrder = .forward) where Compared : ObjectiveC.NSObject
  public init(_ keyPath: Swift.KeyPath<Compared, Foundation.UUID?>, order: Foundation.SortOrder = .forward) where Compared : ObjectiveC.NSObject
  public init(_ keyPath: Swift.KeyPath<Compared, Swift.String>, comparator: Swift.String.StandardComparator = .localizedStandard) where Compared : ObjectiveC.NSObject
  public init(_ keyPath: Swift.KeyPath<Compared, Swift.String?>, comparator: Swift.String.StandardComparator = .localizedStandard) where Compared : ObjectiveC.NSObject
  public init(_ keyPath: Swift.KeyPath<Compared, Swift.String>, comparator: Swift.String.StandardComparator = .localizedStandard, order: Foundation.SortOrder) where Compared : ObjectiveC.NSObject
  public init(_ keyPath: Swift.KeyPath<Compared, Swift.String?>, comparator: Swift.String.StandardComparator = .localizedStandard, order: Foundation.SortOrder) where Compared : ObjectiveC.NSObject
  public init?(_ descriptor: Foundation.NSSortDescriptor, comparing comparedType: Compared.Type) where Compared : ObjectiveC.NSObject
  public func compare(_ lhs: Compared, _ rhs: Compared) -> Foundation.ComparisonResult
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: Foundation.SortDescriptor<Compared>, b: Foundation.SortDescriptor<Compared>) -> Swift.Bool
  public func encode(to encoder: Swift.Encoder) throws
  public var hashValue: Swift.Int {
    get
  }
  public init(from decoder: Swift.Decoder) throws
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.NSSortDescriptor {
  convenience public init<Compared>(_ sortDescriptor: Foundation.SortDescriptor<Compared>)
}

#if compiler(>=5.3) && $RethrowsProtocol
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
public struct AsyncUnicodeScalarSequence<Base> : _Concurrency.AsyncSequence where Base : _Concurrency.AsyncSequence, Base.Element == Swift.UInt8 {
  public typealias Element = Swift.UnicodeScalar
  @frozen public struct AsyncIterator : _Concurrency.AsyncIteratorProtocol {
    @usableFromInline
    internal var _base: Base.AsyncIterator
    @usableFromInline
    internal var _leftover: Swift.UInt8? = nil
    @inlinable @inline(__always) internal func _expectedContinuationCountForByte(_ byte: Swift.UInt8) -> Swift.Int? {
            if byte & 0b11100000 == 0b11000000 {
                return 1
            }
            if byte & 0b11110000 == 0b11100000 {
                return 2
            }
            if byte & 0b11111000 == 0b11110000 {
                return 3
            }
            if byte & 0b10000000 == 0b00000000 {
                return 0
            }
            if byte & 0b11000000 == 0b10000000 {
                //is a continuation itself
                return nil
            }
            //is an invalid value
            return nil
        }
    
    #if compiler(>=5.3) && $AsyncAwait
    @inlinable internal mutating func _nextComplexScalar(_ first: Swift.UInt8) async rethrows -> Swift.UnicodeScalar? {
            guard let expectedContinuationCount = _expectedContinuationCountForByte(first) else {
                //We only reach here for invalid UTF8, so just return a replacement character directly
                return "\u{FFFD}"
            }
            var bytes: (UInt8, UInt8, UInt8, UInt8) = (first, 0, 0, 0)
            var numContinuations = 0
            while numContinuations < expectedContinuationCount, let next = try await _base.next() {
                guard UTF8.isContinuation(next) else {
                    //We read one more byte than we needed due to an invalid missing continuation byte. Store it in `leftover` for next time
                    _leftover = next
                    break
                }
                
                numContinuations += 1
                withUnsafeMutableBytes(of: &bytes) {
                    $0[numContinuations] = next
                }
            }
            return withUnsafeBytes(of: &bytes) {
                return String(decoding: $0, as: UTF8.self).unicodeScalars.first
            }
        }
    #endif

    
    #if compiler(>=5.3) && $AsyncAwait
    @inlinable @inline(__always) public mutating func next() async rethrows -> Swift.UnicodeScalar? {
            if let leftover = _leftover {
                self._leftover = nil
                return try await _nextComplexScalar(leftover)
            }
            if let byte = try await _base.next() {
                if UTF8.isASCII(byte) {
                    _onFastPath()
                    return UnicodeScalar(byte)
                }
                return try await _nextComplexScalar(byte)
            }
            
            return nil
        }
    #endif

    public typealias Element = Swift.Unicode.Scalar
  }
  public func makeAsyncIterator() -> Foundation.AsyncUnicodeScalarSequence<Base>.AsyncIterator
}
#endif


#if compiler(>=5.3) && $RethrowsProtocol
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension _Concurrency.AsyncSequence where Self.Element == Swift.UInt8 {
  @available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
  public var unicodeScalars: Foundation.AsyncUnicodeScalarSequence<Self> {
    get
  }
}
#endif

public struct URLComponents : Foundation.ReferenceConvertible, Swift.Hashable, Swift.Equatable {
  public typealias ReferenceType = Foundation.NSURLComponents
  public init()
  public init?(url: __shared Foundation.URL, resolvingAgainstBaseURL resolve: Swift.Bool)
  public init?(string: __shared Swift.String)
  public var url: Foundation.URL? {
    get
  }
  public func url(relativeTo base: Foundation.URL?) -> Foundation.URL?
  @available(macOS 10.10, iOS 8.0, *)
  public var string: Swift.String? {
    get
  }
  public var scheme: Swift.String? {
    get
    set
  }
  public var user: Swift.String? {
    get
    set
  }
  public var password: Swift.String? {
    get
    set
  }
  public var host: Swift.String? {
    get
    set
  }
  public var port: Swift.Int? {
    get
    set
  }
  public var path: Swift.String {
    get
    set
  }
  public var query: Swift.String? {
    get
    set
  }
  public var fragment: Swift.String? {
    get
    set
  }
  public var percentEncodedUser: Swift.String? {
    get
    set
  }
  public var percentEncodedPassword: Swift.String? {
    get
    set
  }
  public var percentEncodedHost: Swift.String? {
    get
    set
  }
  public var percentEncodedPath: Swift.String {
    get
    set
  }
  public var percentEncodedQuery: Swift.String? {
    get
    set
  }
  public var percentEncodedFragment: Swift.String? {
    get
    set
  }
  @available(macOS 10.11, iOS 9.0, *)
  public var rangeOfScheme: Swift.Range<Swift.String.Index>? {
    get
  }
  @available(macOS 10.11, iOS 9.0, *)
  public var rangeOfUser: Swift.Range<Swift.String.Index>? {
    get
  }
  @available(macOS 10.11, iOS 9.0, *)
  public var rangeOfPassword: Swift.Range<Swift.String.Index>? {
    get
  }
  @available(macOS 10.11, iOS 9.0, *)
  public var rangeOfHost: Swift.Range<Swift.String.Index>? {
    get
  }
  @available(macOS 10.11, iOS 9.0, *)
  public var rangeOfPort: Swift.Range<Swift.String.Index>? {
    get
  }
  @available(macOS 10.11, iOS 9.0, *)
  public var rangeOfPath: Swift.Range<Swift.String.Index>? {
    get
  }
  @available(macOS 10.11, iOS 9.0, *)
  public var rangeOfQuery: Swift.Range<Swift.String.Index>? {
    get
  }
  @available(macOS 10.11, iOS 9.0, *)
  public var rangeOfFragment: Swift.Range<Swift.String.Index>? {
    get
  }
  @available(macOS 10.10, iOS 8.0, *)
  public var queryItems: [Foundation.URLQueryItem]? {
    get
    set
  }
  @available(macOS 10.13, iOS 11.0, tvOS 11.0, watchOS 4.0, *)
  public var percentEncodedQueryItems: [Foundation.URLQueryItem]? {
    get
    set
  }
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (lhs: Foundation.URLComponents, rhs: Foundation.URLComponents) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
extension Foundation.URLComponents : Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible, Swift.CustomReflectable {
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
  public var customMirror: Swift.Mirror {
    get
  }
}
extension Foundation.URLComponents : Swift._ObjectiveCBridgeable {
  public static func _getObjectiveCType() -> Any.Type
  @_semantics("convertToObjectiveC") public func _bridgeToObjectiveC() -> Foundation.NSURLComponents
  public static func _forceBridgeFromObjectiveC(_ x: Foundation.NSURLComponents, result: inout Foundation.URLComponents?)
  public static func _conditionallyBridgeFromObjectiveC(_ x: Foundation.NSURLComponents, result: inout Foundation.URLComponents?) -> Swift.Bool
  @_effects(readonly) public static func _unconditionallyBridgeFromObjectiveC(_ source: Foundation.NSURLComponents?) -> Foundation.URLComponents
  public typealias _ObjectiveCType = Foundation.NSURLComponents
}
extension Foundation.NSURLComponents : Swift._HasCustomAnyHashableRepresentation {
  @nonobjc public func _toCustomAnyHashable() -> Swift.AnyHashable?
}
@available(macOS 10.10, iOS 8.0, *)
public struct URLQueryItem : Foundation.ReferenceConvertible, Swift.Hashable, Swift.Equatable {
  public typealias ReferenceType = Foundation.NSURLQueryItem
  public init(name: __shared Swift.String, value: __shared Swift.String?)
  public var name: Swift.String {
    get
    set
  }
  public var value: Swift.String? {
    get
    set
  }
  public func hash(into hasher: inout Swift.Hasher)
  @available(macOS 10.10, iOS 8.0, *)
  public static func == (lhs: Foundation.URLQueryItem, rhs: Foundation.URLQueryItem) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
@available(macOS 10.10, iOS 8.0, *)
extension Foundation.URLQueryItem : Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible, Swift.CustomReflectable {
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
  public var customMirror: Swift.Mirror {
    get
  }
}
@available(macOS 10.10, iOS 8.0, *)
extension Foundation.URLQueryItem : Swift._ObjectiveCBridgeable {
  public static func _getObjectiveCType() -> Any.Type
  @_semantics("convertToObjectiveC") public func _bridgeToObjectiveC() -> Foundation.NSURLQueryItem
  public static func _forceBridgeFromObjectiveC(_ x: Foundation.NSURLQueryItem, result: inout Foundation.URLQueryItem?)
  public static func _conditionallyBridgeFromObjectiveC(_ x: Foundation.NSURLQueryItem, result: inout Foundation.URLQueryItem?) -> Swift.Bool
  @_effects(readonly) public static func _unconditionallyBridgeFromObjectiveC(_ source: Foundation.NSURLQueryItem?) -> Foundation.URLQueryItem
  public typealias _ObjectiveCType = Foundation.NSURLQueryItem
}
@available(macOS 10.10, iOS 8.0, *)
extension Foundation.NSURLQueryItem : Swift._HasCustomAnyHashableRepresentation {
  @nonobjc public func _toCustomAnyHashable() -> Swift.AnyHashable?
}
extension Foundation.URLComponents : Swift.Codable {
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
@available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
public struct Morphology {
  public init()
  @available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
  public enum GrammaticalGender : Swift.Int, Swift.Hashable {
    case feminine
    case masculine
    case neuter
    public init?(rawValue: Swift.Int)
    public typealias RawValue = Swift.Int
    public var rawValue: Swift.Int {
      get
    }
  }
  public var grammaticalGender: Foundation.Morphology.GrammaticalGender?
  @available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
  public enum PartOfSpeech : Swift.Int, Swift.Hashable {
    case determiner
    case pronoun
    case letter
    case adverb
    case particle
    case adjective
    case adposition
    case verb
    case noun
    case conjunction
    case numeral
    case interjection
    case preposition
    case abbreviation
    public init?(rawValue: Swift.Int)
    public typealias RawValue = Swift.Int
    public var rawValue: Swift.Int {
      get
    }
  }
  public var partOfSpeech: Foundation.Morphology.PartOfSpeech?
  @available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
  public enum GrammaticalNumber : Swift.Int, Swift.Hashable {
    case singular
    case zero
    case plural
    case pluralTwo
    case pluralFew
    case pluralMany
    public init?(rawValue: Swift.Int)
    public typealias RawValue = Swift.Int
    public var rawValue: Swift.Int {
      get
    }
  }
  public var number: Foundation.Morphology.GrammaticalNumber?
}
@available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
public enum InflectionRule {
  case automatic
  case explicit(Foundation.Morphology)
  public init(morphology: Foundation.Morphology)
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.Morphology : Swift.Hashable {
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: Foundation.Morphology, b: Foundation.Morphology) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.Morphology.CustomPronoun : Swift.Hashable {
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: Foundation.Morphology.CustomPronoun, b: Foundation.Morphology.CustomPronoun) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.InflectionRule : Swift.Hashable {
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: Foundation.InflectionRule, b: Foundation.InflectionRule) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.Morphology : Swift.Codable {
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.Morphology.CustomPronoun : Swift.Codable {
  public func encode(to encoder: Swift.Encoder) throws
  public init(from decoder: Swift.Decoder) throws
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.Morphology.GrammaticalGender : Swift.Codable {
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.Morphology.GrammaticalNumber : Swift.Codable {
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.Morphology.PartOfSpeech : Swift.Codable {
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.InflectionRule : Swift.Codable {
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.InflectionRule {
  public static func canInflect(language: Swift.String) -> Swift.Bool
  public static var canInflectPreferredLocalization: Swift.Bool {
    get
  }
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.Morphology {
  public func customPronoun(forLanguage language: Swift.String) -> Foundation.Morphology.CustomPronoun?
  public mutating func setCustomPronoun(_ pronoun: Foundation.Morphology.CustomPronoun?, forLanguage language: Swift.String) throws
  @available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
  public struct CustomPronoun {
    public init()
    public static func isSupported(forLanguage language: Swift.String) -> Swift.Bool
    public static func requiredKeys(forLanguage language: Swift.String) -> [Swift.PartialKeyPath<Foundation.Morphology.CustomPronoun>]
    public var subjectForm: Swift.String?
    public var objectForm: Swift.String?
    public var possessiveForm: Swift.String?
    public var possessiveAdjectiveForm: Swift.String?
    public var reflexiveForm: Swift.String?
  }
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.Morphology {
  public var isUnspecified: Swift.Bool {
    get
  }
  public static let user: Foundation.Morphology
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.Morphology.CustomPronoun : Swift._ObjectiveCBridgeable {
  public func _bridgeToObjectiveC() -> Foundation.__NSMorphologyCustomPronoun
  public static func _forceBridgeFromObjectiveC(_ morphology: Foundation.__NSMorphologyCustomPronoun, result: inout Foundation.Morphology.CustomPronoun?)
  public static func _conditionallyBridgeFromObjectiveC(_ morphology: Foundation.__NSMorphologyCustomPronoun, result: inout Foundation.Morphology.CustomPronoun?) -> Swift.Bool
  public static func _unconditionallyBridgeFromObjectiveC(_ morphology: Foundation.__NSMorphologyCustomPronoun?) -> Foundation.Morphology.CustomPronoun
  public typealias _ObjectiveCType = Foundation.__NSMorphologyCustomPronoun
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.InflectionRule : Swift._ObjectiveCBridgeable {
  public func _bridgeToObjectiveC() -> Foundation.__NSInflectionRule
  public static func _forceBridgeFromObjectiveC(_ rule: Foundation.__NSInflectionRule, result: inout Foundation.InflectionRule?)
  public static func _conditionallyBridgeFromObjectiveC(_ rule: Foundation.__NSInflectionRule, result: inout Foundation.InflectionRule?) -> Swift.Bool
  public static func _unconditionallyBridgeFromObjectiveC(_ rule: Foundation.__NSInflectionRule?) -> Foundation.InflectionRule
  public typealias _ObjectiveCType = Foundation.__NSInflectionRule
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.Morphology : Swift._ObjectiveCBridgeable {
  public func _bridgeToObjectiveC() -> Foundation.__NSMorphology
  public static func _forceBridgeFromObjectiveC(_ morphology: Foundation.__NSMorphology, result: inout Foundation.Morphology?)
  public static func _conditionallyBridgeFromObjectiveC(_ morphology: Foundation.__NSMorphology, result: inout Foundation.Morphology?) -> Swift.Bool
  public static func _unconditionallyBridgeFromObjectiveC(_ morphology: Foundation.__NSMorphology?) -> Foundation.Morphology
  public typealias _ObjectiveCType = Foundation.__NSMorphology
}
public struct Date : Foundation.ReferenceConvertible, Swift.Comparable, Swift.Equatable {
  public typealias ReferenceType = Foundation.NSDate
  public static let timeIntervalBetween1970AndReferenceDate: Swift.Double
  public static var timeIntervalSinceReferenceDate: Foundation.TimeInterval {
    get
  }
  public init()
  public init(timeIntervalSinceNow: Foundation.TimeInterval)
  public init(timeIntervalSince1970: Foundation.TimeInterval)
  public init(timeInterval: Foundation.TimeInterval, since date: Foundation.Date)
  public init(timeIntervalSinceReferenceDate ti: Foundation.TimeInterval)
  public var timeIntervalSinceReferenceDate: Foundation.TimeInterval {
    get
  }
  public func timeIntervalSince(_ date: Foundation.Date) -> Foundation.TimeInterval
  public var timeIntervalSinceNow: Foundation.TimeInterval {
    get
  }
  public var timeIntervalSince1970: Foundation.TimeInterval {
    get
  }
  public func addingTimeInterval(_ timeInterval: Foundation.TimeInterval) -> Foundation.Date
  public mutating func addTimeInterval(_ timeInterval: Foundation.TimeInterval)
  public static let distantFuture: Foundation.Date
  public static let distantPast: Foundation.Date
  @available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
  public static var now: Foundation.Date {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
  public func compare(_ other: Foundation.Date) -> Foundation.ComparisonResult
  public static func == (lhs: Foundation.Date, rhs: Foundation.Date) -> Swift.Bool
  public static func < (lhs: Foundation.Date, rhs: Foundation.Date) -> Swift.Bool
  public static func > (lhs: Foundation.Date, rhs: Foundation.Date) -> Swift.Bool
  public static func + (lhs: Foundation.Date, rhs: Foundation.TimeInterval) -> Foundation.Date
  public static func - (lhs: Foundation.Date, rhs: Foundation.TimeInterval) -> Foundation.Date
  public static func += (lhs: inout Foundation.Date, rhs: Foundation.TimeInterval)
  public static func -= (lhs: inout Foundation.Date, rhs: Foundation.TimeInterval)
  public var hashValue: Swift.Int {
    get
  }
}
extension Foundation.Date : Swift.CustomDebugStringConvertible, Swift.CustomStringConvertible, Swift.CustomReflectable {
  public var description: Swift.String {
    get
  }
  public func description(with locale: Foundation.Locale?) -> Swift.String
  public var debugDescription: Swift.String {
    get
  }
  public var customMirror: Swift.Mirror {
    get
  }
}
extension Foundation.Date : Swift._ObjectiveCBridgeable {
  @_semantics("convertToObjectiveC") public func _bridgeToObjectiveC() -> Foundation.NSDate
  public static func _forceBridgeFromObjectiveC(_ x: Foundation.NSDate, result: inout Foundation.Date?)
  public static func _conditionallyBridgeFromObjectiveC(_ x: Foundation.NSDate, result: inout Foundation.Date?) -> Swift.Bool
  @_effects(readonly) public static func _unconditionallyBridgeFromObjectiveC(_ source: Foundation.NSDate?) -> Foundation.Date
  public typealias _ObjectiveCType = Foundation.NSDate
}
extension Foundation.NSDate : Swift._HasCustomAnyHashableRepresentation {
  @nonobjc public func _toCustomAnyHashable() -> Swift.AnyHashable?
}
extension Foundation.Date : Swift._CustomPlaygroundQuickLookable {
  @available(*, deprecated, message: "Date.customPlaygroundQuickLook will be removed in a future Swift version")
  public var customPlaygroundQuickLook: Swift.PlaygroundQuickLook {
    get
  }
}
extension Foundation.Date : Swift.Codable {
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
@usableFromInline
@frozen internal struct _AsyncBytesBuffer {
  internal var storage: Swift.AnyObject? = nil
  @usableFromInline
  internal var nextPointer: Swift.UnsafeMutableRawPointer
  @usableFromInline
  internal var endPointer: Swift.UnsafeMutableRawPointer
  @usableFromInline
  internal init(capacity: Swift.Int)
  
  #if compiler(>=5.3) && $AsyncAwait
  @usableFromInline
  @inline(never) internal mutating func reloadBufferAndNext() async throws -> Swift.UInt8?
  #endif

  
  #if compiler(>=5.3) && $AsyncAwait
  @inlinable @inline(__always) internal mutating func next() async throws -> Swift.UInt8? {
        if _fastPath(nextPointer != endPointer) {
            let byte = nextPointer.load(fromByteOffset: 0, as: UInt8.self)
            nextPointer = nextPointer + 1
            return byte
        }
        return try await reloadBufferAndNext()
    }
  #endif

}
extension Foundation.FileHandle {
  
  #if compiler(>=5.3) && $RethrowsProtocol
  @available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
  public struct AsyncBytes : _Concurrency.AsyncSequence {
    public typealias Element = Swift.UInt8
    public typealias AsyncIterator = Foundation.FileHandle.AsyncBytes.Iterator
    public func makeAsyncIterator() -> Foundation.FileHandle.AsyncBytes.Iterator
    @frozen public struct Iterator : _Concurrency.AsyncIteratorProtocol {
      public typealias Element = Swift.UInt8
      @usableFromInline
      internal var buffer: Foundation._AsyncBytesBuffer
      
      #if compiler(>=5.3) && $AsyncAwait
      @inlinable @inline(__always) public mutating func next() async throws -> Swift.UInt8? {
                return try await buffer.next()
            }
      #endif

    }
  }
  #endif

  
  #if compiler(>=5.3) && $RethrowsProtocol
  @available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
  public var bytes: Foundation.FileHandle.AsyncBytes {
    get
  }
  #endif

}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.Date {
  public func ISO8601Format(_ style: Foundation.Date.ISO8601FormatStyle = .init()) -> Swift.String
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.Date {
  public struct ISO8601FormatStyle {
    public enum TimeZoneSeparator : Swift.String, Swift.Codable {
      case colon
      case omitted
      public init?(rawValue: Swift.String)
      public typealias RawValue = Swift.String
      public var rawValue: Swift.String {
        get
      }
    }
    public enum DateSeparator : Swift.String, Swift.Codable {
      case dash
      case omitted
      public init?(rawValue: Swift.String)
      public typealias RawValue = Swift.String
      public var rawValue: Swift.String {
        get
      }
    }
    public enum TimeSeparator : Swift.String, Swift.Codable {
      case colon
      case omitted
      public init?(rawValue: Swift.String)
      public typealias RawValue = Swift.String
      public var rawValue: Swift.String {
        get
      }
    }
    public enum DateTimeSeparator : Swift.String, Swift.Codable {
      case space
      case standard
      public init?(rawValue: Swift.String)
      public typealias RawValue = Swift.String
      public var rawValue: Swift.String {
        get
      }
    }
    public var timeSeparator: Foundation.Date.ISO8601FormatStyle.TimeSeparator {
      get
    }
    public var includingFractionalSeconds: Swift.Bool {
      get
    }
    public var timeZoneSeparator: Foundation.Date.ISO8601FormatStyle.TimeZoneSeparator {
      get
    }
    public var dateSeparator: Foundation.Date.ISO8601FormatStyle.DateSeparator {
      get
    }
    public var dateTimeSeparator: Foundation.Date.ISO8601FormatStyle.DateTimeSeparator {
      get
    }
    public var timeZone: Foundation.TimeZone
    @_disfavoredOverload public init(dateSeparator: Foundation.Date.ISO8601FormatStyle.DateSeparator = .dash, dateTimeSeparator: Foundation.Date.ISO8601FormatStyle.DateTimeSeparator = .standard, timeZone: Foundation.TimeZone = TimeZone(secondsFromGMT: 0)!)
    public init(dateSeparator: Foundation.Date.ISO8601FormatStyle.DateSeparator = .dash, dateTimeSeparator: Foundation.Date.ISO8601FormatStyle.DateTimeSeparator = .standard, timeSeparator: Foundation.Date.ISO8601FormatStyle.TimeSeparator = .colon, timeZoneSeparator: Foundation.Date.ISO8601FormatStyle.TimeZoneSeparator = .omitted, includingFractionalSeconds: Swift.Bool = false, timeZone: Foundation.TimeZone = TimeZone(secondsFromGMT: 0)!)
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.Date.ISO8601FormatStyle {
  public func year() -> Foundation.Date.ISO8601FormatStyle
  public func weekOfYear() -> Foundation.Date.ISO8601FormatStyle
  public func month() -> Foundation.Date.ISO8601FormatStyle
  public func day() -> Foundation.Date.ISO8601FormatStyle
  public func time(includingFractionalSeconds: Swift.Bool) -> Foundation.Date.ISO8601FormatStyle
  public func timeZone(separator: Foundation.Date.ISO8601FormatStyle.TimeZoneSeparator) -> Foundation.Date.ISO8601FormatStyle
  public func dateSeparator(_ separator: Foundation.Date.ISO8601FormatStyle.DateSeparator) -> Foundation.Date.ISO8601FormatStyle
  public func dateTimeSeparator(_ separator: Foundation.Date.ISO8601FormatStyle.DateTimeSeparator) -> Foundation.Date.ISO8601FormatStyle
  public func timeSeparator(_ separator: Foundation.Date.ISO8601FormatStyle.TimeSeparator) -> Foundation.Date.ISO8601FormatStyle
  public func timeZoneSeparator(_ separator: Foundation.Date.ISO8601FormatStyle.TimeZoneSeparator) -> Foundation.Date.ISO8601FormatStyle
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.ISO8601DateFormatter.Options : Swift.Hashable {
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.Date.ISO8601FormatStyle : Foundation.FormatStyle {
  public func format(_ value: Foundation.Date) -> Swift.String
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: Foundation.Date.ISO8601FormatStyle, b: Foundation.Date.ISO8601FormatStyle) -> Swift.Bool
  public typealias FormatInput = Foundation.Date
  public typealias FormatOutput = Swift.String
  public func encode(to encoder: Swift.Encoder) throws
  public var hashValue: Swift.Int {
    get
  }
  public init(from decoder: Swift.Decoder) throws
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.Date.ISO8601FormatStyle : Foundation.ParseStrategy {
  public func parse(_ value: Swift.String) throws -> Foundation.Date
  public typealias ParseInput = Swift.String
  public typealias ParseOutput = Foundation.Date
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.Date.ISO8601FormatStyle : Foundation.ParseableFormatStyle {
  public var parseStrategy: Foundation.Date.ISO8601FormatStyle {
    get
  }
  public typealias Strategy = Foundation.Date.ISO8601FormatStyle
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.FormatStyle where Self == Foundation.Date.ISO8601FormatStyle {
  public static var iso8601: Foundation.Date.ISO8601FormatStyle {
    get
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.ParseableFormatStyle where Self == Foundation.Date.ISO8601FormatStyle {
  public static var iso8601: Foundation.Date.ISO8601FormatStyle {
    get
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.ParseStrategy where Self == Foundation.Date.ISO8601FormatStyle {
  @_disfavoredOverload public static var iso8601: Foundation.Date.ISO8601FormatStyle {
    get
  }
}
public struct Notification : Foundation.ReferenceConvertible, Swift.Equatable, Swift.Hashable {
  public typealias ReferenceType = Foundation.NSNotification
  public var name: Foundation.Notification.Name
  public var object: Any?
  public var userInfo: [Swift.AnyHashable : Any]?
  public init(name: Foundation.Notification.Name, object: Any? = nil, userInfo: [Swift.AnyHashable : Any]? = nil)
  public func hash(into hasher: inout Swift.Hasher)
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
  public typealias Name = Foundation.NSNotification.Name
  public static func == (lhs: Foundation.Notification, rhs: Foundation.Notification) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
extension Foundation.Notification : Swift.CustomReflectable {
  public var customMirror: Swift.Mirror {
    get
  }
}
extension Foundation.Notification : Swift._ObjectiveCBridgeable {
  public static func _getObjectiveCType() -> Any.Type
  @_semantics("convertToObjectiveC") public func _bridgeToObjectiveC() -> Foundation.NSNotification
  public static func _forceBridgeFromObjectiveC(_ x: Foundation.NSNotification, result: inout Foundation.Notification?)
  public static func _conditionallyBridgeFromObjectiveC(_ x: Foundation.NSNotification, result: inout Foundation.Notification?) -> Swift.Bool
  @_effects(readonly) public static func _unconditionallyBridgeFromObjectiveC(_ source: Foundation.NSNotification?) -> Foundation.Notification
  public typealias _ObjectiveCType = Foundation.NSNotification
}
extension Foundation.NSNotification : Swift._HasCustomAnyHashableRepresentation {
  @nonobjc public func _toCustomAnyHashable() -> Swift.AnyHashable?
}
public struct Calendar : Swift.Hashable, Swift.Equatable, Foundation.ReferenceConvertible {
  public typealias ReferenceType = Foundation.NSCalendar
  public enum Identifier {
    case gregorian
    case buddhist
    case chinese
    case coptic
    case ethiopicAmeteMihret
    case ethiopicAmeteAlem
    case hebrew
    case iso8601
    case indian
    case islamic
    case islamicCivil
    case japanese
    case persian
    case republicOfChina
    @available(macOS 10.10, iOS 8.0, *)
    case islamicTabular
    @available(macOS 10.10, iOS 8.0, *)
    case islamicUmmAlQura
    public static func == (a: Foundation.Calendar.Identifier, b: Foundation.Calendar.Identifier) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public enum Component {
    case era
    case year
    case month
    case day
    case hour
    case minute
    case second
    case weekday
    case weekdayOrdinal
    case quarter
    case weekOfMonth
    case weekOfYear
    case yearForWeekOfYear
    case nanosecond
    case calendar
    case timeZone
    public static func == (a: Foundation.Calendar.Component, b: Foundation.Calendar.Component) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public static var current: Foundation.Calendar {
    get
  }
  public static var autoupdatingCurrent: Foundation.Calendar {
    get
  }
  public init(identifier: __shared Foundation.Calendar.Identifier)
  public var identifier: Foundation.Calendar.Identifier {
    get
  }
  public var locale: Foundation.Locale? {
    get
    set
  }
  public var timeZone: Foundation.TimeZone {
    get
    set
  }
  public var firstWeekday: Swift.Int {
    get
    set
  }
  public var minimumDaysInFirstWeek: Swift.Int {
    get
    set
  }
  public var eraSymbols: [Swift.String] {
    get
  }
  public var longEraSymbols: [Swift.String] {
    get
  }
  public var monthSymbols: [Swift.String] {
    get
  }
  public var shortMonthSymbols: [Swift.String] {
    get
  }
  public var veryShortMonthSymbols: [Swift.String] {
    get
  }
  public var standaloneMonthSymbols: [Swift.String] {
    get
  }
  public var shortStandaloneMonthSymbols: [Swift.String] {
    get
  }
  public var veryShortStandaloneMonthSymbols: [Swift.String] {
    get
  }
  public var weekdaySymbols: [Swift.String] {
    get
  }
  public var shortWeekdaySymbols: [Swift.String] {
    get
  }
  public var veryShortWeekdaySymbols: [Swift.String] {
    get
  }
  public var standaloneWeekdaySymbols: [Swift.String] {
    get
  }
  public var shortStandaloneWeekdaySymbols: [Swift.String] {
    get
  }
  public var veryShortStandaloneWeekdaySymbols: [Swift.String] {
    get
  }
  public var quarterSymbols: [Swift.String] {
    get
  }
  public var shortQuarterSymbols: [Swift.String] {
    get
  }
  public var standaloneQuarterSymbols: [Swift.String] {
    get
  }
  public var shortStandaloneQuarterSymbols: [Swift.String] {
    get
  }
  public var amSymbol: Swift.String {
    get
  }
  public var pmSymbol: Swift.String {
    get
  }
  public func minimumRange(of component: Foundation.Calendar.Component) -> Swift.Range<Swift.Int>?
  public func maximumRange(of component: Foundation.Calendar.Component) -> Swift.Range<Swift.Int>?
  @available(*, unavailable, message: "use range(of:in:for:) instead")
  public func range(of smaller: Foundation.NSCalendar.Unit, in larger: Foundation.NSCalendar.Unit, for date: Foundation.Date) -> Foundation.NSRange
  public func range(of smaller: Foundation.Calendar.Component, in larger: Foundation.Calendar.Component, for date: Foundation.Date) -> Swift.Range<Swift.Int>?
  @available(*, unavailable, message: "use range(of:in:for:) instead")
  public func range(of unit: Foundation.NSCalendar.Unit, start datep: Swift.AutoreleasingUnsafeMutablePointer<Foundation.NSDate?>?, interval tip: Swift.UnsafeMutablePointer<Foundation.TimeInterval>?, for date: Foundation.Date) -> Swift.Bool
  public func dateInterval(of component: Foundation.Calendar.Component, start: inout Foundation.Date, interval: inout Foundation.TimeInterval, for date: Foundation.Date) -> Swift.Bool
  @available(macOS 10.12, iOS 10.0, tvOS 10.0, watchOS 3.0, *)
  public func dateInterval(of component: Foundation.Calendar.Component, for date: Foundation.Date) -> Foundation.DateInterval?
  public func ordinality(of smaller: Foundation.Calendar.Component, in larger: Foundation.Calendar.Component, for date: Foundation.Date) -> Swift.Int?
  @available(*, unavailable, message: "use dateComponents(_:from:) instead")
  public func getEra(_ eraValuePointer: Swift.UnsafeMutablePointer<Swift.Int>?, year yearValuePointer: Swift.UnsafeMutablePointer<Swift.Int>?, month monthValuePointer: Swift.UnsafeMutablePointer<Swift.Int>?, day dayValuePointer: Swift.UnsafeMutablePointer<Swift.Int>?, from date: Foundation.Date)
  @available(*, unavailable, message: "use dateComponents(_:from:) instead")
  public func getEra(_ eraValuePointer: Swift.UnsafeMutablePointer<Swift.Int>?, yearForWeekOfYear yearValuePointer: Swift.UnsafeMutablePointer<Swift.Int>?, weekOfYear weekValuePointer: Swift.UnsafeMutablePointer<Swift.Int>?, weekday weekdayValuePointer: Swift.UnsafeMutablePointer<Swift.Int>?, from date: Foundation.Date)
  @available(*, unavailable, message: "use dateComponents(_:from:) instead")
  public func getHour(_ hourValuePointer: Swift.UnsafeMutablePointer<Swift.Int>?, minute minuteValuePointer: Swift.UnsafeMutablePointer<Swift.Int>?, second secondValuePointer: Swift.UnsafeMutablePointer<Swift.Int>?, nanosecond nanosecondValuePointer: Swift.UnsafeMutablePointer<Swift.Int>?, from date: Foundation.Date)
  @available(*, unavailable, message: "use date(byAdding:to:wrappingComponents:) instead")
  public func date(byAdding unit: Foundation.NSCalendar.Unit, value: Swift.Int, to date: Foundation.Date, options: Foundation.NSCalendar.Options = []) -> Foundation.Date?
  public func date(byAdding components: Foundation.DateComponents, to date: Foundation.Date, wrappingComponents: Swift.Bool = false) -> Foundation.Date?
  @available(*, unavailable, message: "use date(byAdding:to:wrappingComponents:) instead")
  public func date(byAdding comps: Foundation.DateComponents, to date: Foundation.Date, options opts: Foundation.NSCalendar.Options = []) -> Foundation.Date?
  @available(iOS 8.0, *)
  public func date(byAdding component: Foundation.Calendar.Component, value: Swift.Int, to date: Foundation.Date, wrappingComponents: Swift.Bool = false) -> Foundation.Date?
  public func date(from components: Foundation.DateComponents) -> Foundation.Date?
  @available(*, unavailable, renamed: "dateComponents(_:from:)")
  public func components(_ unitFlags: Foundation.NSCalendar.Unit, from date: Foundation.Date) -> Foundation.DateComponents
  public func dateComponents(_ components: Swift.Set<Foundation.Calendar.Component>, from date: Foundation.Date) -> Foundation.DateComponents
  @available(*, unavailable, renamed: "dateComponents(in:from:)")
  public func components(in timezone: Foundation.TimeZone, from date: Foundation.Date) -> Foundation.DateComponents
  @available(iOS 8.0, *)
  public func dateComponents(in timeZone: Foundation.TimeZone, from date: Foundation.Date) -> Foundation.DateComponents
  @available(*, unavailable, renamed: "dateComponents(_:from:to:)")
  public func components(_ unitFlags: Foundation.NSCalendar.Unit, from startingDate: Foundation.Date, to resultDate: Foundation.Date, options opts: Foundation.NSCalendar.Options = []) -> Foundation.DateComponents
  public func dateComponents(_ components: Swift.Set<Foundation.Calendar.Component>, from start: Foundation.Date, to end: Foundation.Date) -> Foundation.DateComponents
  @available(*, unavailable, renamed: "dateComponents(_:from:to:)")
  public func components(_ unitFlags: Foundation.NSCalendar.Unit, from startingDateComp: Foundation.DateComponents, to resultDateComp: Foundation.DateComponents, options: Foundation.NSCalendar.Options = []) -> Foundation.DateComponents
  @available(iOS 8.0, *)
  public func dateComponents(_ components: Swift.Set<Foundation.Calendar.Component>, from start: Foundation.DateComponents, to end: Foundation.DateComponents) -> Foundation.DateComponents
  @available(iOS 8.0, *)
  public func component(_ component: Foundation.Calendar.Component, from date: Foundation.Date) -> Swift.Int
  @available(*, unavailable, message: "Use date(from:) instead")
  public func date(era: Swift.Int, year: Swift.Int, month: Swift.Int, day: Swift.Int, hour: Swift.Int, minute: Swift.Int, second: Swift.Int, nanosecond: Swift.Int) -> Foundation.Date?
  @available(*, unavailable, message: "Use date(from:) instead")
  public func date(era: Swift.Int, yearForWeekOfYear: Swift.Int, weekOfYear: Swift.Int, weekday: Swift.Int, hour: Swift.Int, minute: Swift.Int, second: Swift.Int, nanosecond: Swift.Int) -> Foundation.Date?
  @available(iOS 8.0, *)
  public func startOfDay(for date: Foundation.Date) -> Foundation.Date
  @available(*, unavailable, renamed: "compare(_:to:toGranularity:)")
  public func compare(_ date1: Foundation.Date, to date2: Foundation.Date, toUnitGranularity unit: Foundation.NSCalendar.Unit) -> Foundation.ComparisonResult
  @available(iOS 8.0, *)
  public func compare(_ date1: Foundation.Date, to date2: Foundation.Date, toGranularity component: Foundation.Calendar.Component) -> Foundation.ComparisonResult
  @available(*, unavailable, renamed: "isDate(_:equalTo:toGranularity:)")
  public func isDate(_ date1: Foundation.Date, equalTo date2: Foundation.Date, toUnitGranularity unit: Foundation.NSCalendar.Unit) -> Swift.Bool
  @available(iOS 8.0, *)
  public func isDate(_ date1: Foundation.Date, equalTo date2: Foundation.Date, toGranularity component: Foundation.Calendar.Component) -> Swift.Bool
  @available(iOS 8.0, *)
  public func isDate(_ date1: Foundation.Date, inSameDayAs date2: Foundation.Date) -> Swift.Bool
  @available(iOS 8.0, *)
  public func isDateInToday(_ date: Foundation.Date) -> Swift.Bool
  @available(iOS 8.0, *)
  public func isDateInYesterday(_ date: Foundation.Date) -> Swift.Bool
  @available(iOS 8.0, *)
  public func isDateInTomorrow(_ date: Foundation.Date) -> Swift.Bool
  @available(iOS 8.0, *)
  public func isDateInWeekend(_ date: Foundation.Date) -> Swift.Bool
  @available(*, unavailable, message: "use dateIntervalOfWeekend(containing:start:interval:) instead")
  public func range(ofWeekendStart datep: Swift.AutoreleasingUnsafeMutablePointer<Foundation.NSDate?>?, interval tip: Swift.UnsafeMutablePointer<Foundation.TimeInterval>?, containing date: Foundation.Date) -> Swift.Bool
  @available(iOS 8.0, *)
  public func dateIntervalOfWeekend(containing date: Foundation.Date, start: inout Foundation.Date, interval: inout Foundation.TimeInterval) -> Swift.Bool
  @available(macOS 10.12, iOS 10.0, tvOS 10.0, watchOS 3.0, *)
  public func dateIntervalOfWeekend(containing date: Foundation.Date) -> Foundation.DateInterval?
  @available(*, unavailable, message: "use nextWeekend(startingAfter:start:interval:direction:) instead")
  public func nextWeekendStart(_ datep: Swift.AutoreleasingUnsafeMutablePointer<Foundation.NSDate?>?, interval tip: Swift.UnsafeMutablePointer<Foundation.TimeInterval>?, options: Foundation.NSCalendar.Options = [], after date: Foundation.Date) -> Swift.Bool
  @available(iOS 8.0, *)
  public func nextWeekend(startingAfter date: Foundation.Date, start: inout Foundation.Date, interval: inout Foundation.TimeInterval, direction: Foundation.Calendar.SearchDirection = .forward) -> Swift.Bool
  @available(macOS 10.12, iOS 10.0, tvOS 10.0, watchOS 3.0, *)
  public func nextWeekend(startingAfter date: Foundation.Date, direction: Foundation.Calendar.SearchDirection = .forward) -> Foundation.DateInterval?
  public enum SearchDirection {
    case forward
    case backward
    public static func == (a: Foundation.Calendar.SearchDirection, b: Foundation.Calendar.SearchDirection) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public enum RepeatedTimePolicy {
    case first
    case last
    public static func == (a: Foundation.Calendar.RepeatedTimePolicy, b: Foundation.Calendar.RepeatedTimePolicy) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public enum MatchingPolicy {
    case nextTime
    case nextTimePreservingSmallerComponents
    case previousTimePreservingSmallerComponents
    case strict
    public static func == (a: Foundation.Calendar.MatchingPolicy, b: Foundation.Calendar.MatchingPolicy) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  @available(*, unavailable, message: "use nextWeekend(startingAfter:matching:matchingPolicy:repeatedTimePolicy:direction:using:) instead")
  public func enumerateDates(startingAfter start: Foundation.Date, matching comps: Foundation.DateComponents, options opts: Foundation.NSCalendar.Options = [], using block: (Foundation.Date?, Swift.Bool, Swift.UnsafeMutablePointer<ObjectiveC.ObjCBool>) -> Swift.Void)
  @available(iOS 8.0, *)
  public func enumerateDates(startingAfter start: Foundation.Date, matching components: Foundation.DateComponents, matchingPolicy: Foundation.Calendar.MatchingPolicy, repeatedTimePolicy: Foundation.Calendar.RepeatedTimePolicy = .first, direction: Foundation.Calendar.SearchDirection = .forward, using block: (_ result: Foundation.Date?, _ exactMatch: Swift.Bool, _ stop: inout Swift.Bool) -> Swift.Void)
  @available(*, unavailable, message: "use nextDate(after:matching:matchingPolicy:repeatedTimePolicy:direction:) instead")
  public func nextDate(after date: Foundation.Date, matching comps: Foundation.DateComponents, options: Foundation.NSCalendar.Options = []) -> Foundation.Date?
  @available(iOS 8.0, *)
  public func nextDate(after date: Foundation.Date, matching components: Foundation.DateComponents, matchingPolicy: Foundation.Calendar.MatchingPolicy, repeatedTimePolicy: Foundation.Calendar.RepeatedTimePolicy = .first, direction: Foundation.Calendar.SearchDirection = .forward) -> Foundation.Date?
  @available(*, unavailable, message: "use nextDate(after:matching:matchingPolicy:repeatedTimePolicy:direction:) instead")
  public func nextDate(after date: Foundation.Date, matchingHour hourValue: Swift.Int, minute minuteValue: Swift.Int, second secondValue: Swift.Int, options: Foundation.NSCalendar.Options = []) -> Foundation.Date?
  @available(*, unavailable, renamed: "date(bySetting:value:of:)")
  public func date(bySettingUnit unit: Foundation.NSCalendar.Unit, value v: Swift.Int, of date: Foundation.Date, options opts: Foundation.NSCalendar.Options = []) -> Foundation.Date?
  @available(iOS 8.0, *)
  public func date(bySetting component: Foundation.Calendar.Component, value: Swift.Int, of date: Foundation.Date) -> Foundation.Date?
  @available(*, unavailable, message: "use date(bySettingHour:minute:second:of:matchingPolicy:repeatedTimePolicy:direction:) instead")
  public func date(bySettingHour h: Swift.Int, minute m: Swift.Int, second s: Swift.Int, of date: Foundation.Date, options opts: Foundation.NSCalendar.Options = []) -> Foundation.Date?
  @available(iOS 8.0, *)
  public func date(bySettingHour hour: Swift.Int, minute: Swift.Int, second: Swift.Int, of date: Foundation.Date, matchingPolicy: Foundation.Calendar.MatchingPolicy = .nextTime, repeatedTimePolicy: Foundation.Calendar.RepeatedTimePolicy = .first, direction: Foundation.Calendar.SearchDirection = .forward) -> Foundation.Date?
  @available(iOS 8.0, *)
  public func date(_ date: Foundation.Date, matchesComponents components: Foundation.DateComponents) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (lhs: Foundation.Calendar, rhs: Foundation.Calendar) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
extension Foundation.Calendar : Swift.CustomDebugStringConvertible, Swift.CustomStringConvertible, Swift.CustomReflectable {
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
  public var customMirror: Swift.Mirror {
    get
  }
}
extension Foundation.Calendar : Swift._ObjectiveCBridgeable {
  @_semantics("convertToObjectiveC") public func _bridgeToObjectiveC() -> Foundation.NSCalendar
  public static func _forceBridgeFromObjectiveC(_ input: Foundation.NSCalendar, result: inout Foundation.Calendar?)
  public static func _conditionallyBridgeFromObjectiveC(_ input: Foundation.NSCalendar, result: inout Foundation.Calendar?) -> Swift.Bool
  @_effects(readonly) public static func _unconditionallyBridgeFromObjectiveC(_ source: Foundation.NSCalendar?) -> Foundation.Calendar
  public typealias _ObjectiveCType = Foundation.NSCalendar
}
extension Foundation.NSCalendar : Swift._HasCustomAnyHashableRepresentation {
  @nonobjc public func _toCustomAnyHashable() -> Swift.AnyHashable?
}
extension Foundation.Calendar : Swift.Codable {
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
extension Swift.String {
  public static var availableStringEncodings: [Swift.String.Encoding] {
    get
  }
  public static var defaultCStringEncoding: Swift.String.Encoding {
    get
  }
  public static func localizedName(of encoding: Swift.String.Encoding) -> Swift.String
  public static func localizedStringWithFormat(_ format: Swift.String, _ arguments: Swift.CVarArg...) -> Swift.String
  public init?(utf8String bytes: Swift.UnsafePointer<Swift.CChar>)
}
extension Swift.String {
  public init?<S>(bytes: __shared S, encoding: Swift.String.Encoding) where S : Swift.Sequence, S.Element == Swift.UInt8
  public init?(bytesNoCopy bytes: Swift.UnsafeMutableRawPointer, length: Swift.Int, encoding: Swift.String.Encoding, freeWhenDone flag: Swift.Bool)
  public init(utf16CodeUnits: Swift.UnsafePointer<Foundation.unichar>, count: Swift.Int)
  public init(utf16CodeUnitsNoCopy: Swift.UnsafePointer<Foundation.unichar>, count: Swift.Int, freeWhenDone flag: Swift.Bool)
  public init(contentsOfFile path: __shared Swift.String, encoding enc: Swift.String.Encoding) throws
  public init(contentsOfFile path: __shared Swift.String, usedEncoding: inout Swift.String.Encoding) throws
  public init(contentsOfFile path: __shared Swift.String) throws
  public init(contentsOf url: __shared Foundation.URL, encoding enc: Swift.String.Encoding) throws
  public init(contentsOf url: __shared Foundation.URL, usedEncoding: inout Swift.String.Encoding) throws
  public init(contentsOf url: __shared Foundation.URL) throws
  public init?(cString: Swift.UnsafePointer<Swift.CChar>, encoding enc: Swift.String.Encoding)
  public init?(data: __shared Foundation.Data, encoding: Swift.String.Encoding)
  public init(format: __shared Swift.String, _ arguments: Swift.CVarArg...)
  public init(format: __shared Swift.String, arguments: __shared [Swift.CVarArg])
  public init(format: __shared Swift.String, locale: __shared Foundation.Locale?, _ args: Swift.CVarArg...)
  public init(format: __shared Swift.String, locale: __shared Foundation.Locale?, arguments: __shared [Swift.CVarArg])
}
extension Swift.StringProtocol {
  @inlinable internal func _toRelativeNSRange(_ r: Swift.Range<Swift.String.Index>) -> Foundation.NSRange {
        return NSRange(self._toUTF16Offsets(r))
    }
  public func canBeConverted(to encoding: Swift.String.Encoding) -> Swift.Bool
  public var capitalized: Swift.String {
    get
  }
  @available(macOS 10.11, iOS 9.0, *)
  public var localizedCapitalized: Swift.String {
    get
  }
  public func capitalized(with locale: Foundation.Locale?) -> Swift.String
  public func caseInsensitiveCompare<T>(_ aString: T) -> Foundation.ComparisonResult where T : Swift.StringProtocol
  public func commonPrefix<T>(with aString: T, options: Swift.String.CompareOptions = []) -> Swift.String where T : Swift.StringProtocol
  public func compare<T>(_ aString: T, options mask: Swift.String.CompareOptions = [], range: Swift.Range<Self.Index>? = nil, locale: Foundation.Locale? = nil) -> Foundation.ComparisonResult where T : Swift.StringProtocol
  public func completePath(into outputName: Swift.UnsafeMutablePointer<Swift.String>? = nil, caseSensitive: Swift.Bool, matchesInto outputArray: Swift.UnsafeMutablePointer<[Swift.String]>? = nil, filterTypes: [Swift.String]? = nil) -> Swift.Int
  public func components(separatedBy separator: Foundation.CharacterSet) -> [Swift.String]
  public func components<T>(separatedBy separator: T) -> [Swift.String] where T : Swift.StringProtocol
  public func cString(using encoding: Swift.String.Encoding) -> [Swift.CChar]?
  public func data(using encoding: Swift.String.Encoding, allowLossyConversion: Swift.Bool = false) -> Foundation.Data?
  public var decomposedStringWithCanonicalMapping: Swift.String {
    get
  }
  public var decomposedStringWithCompatibilityMapping: Swift.String {
    get
  }
  public func enumerateLines(invoking body: @escaping (_ line: Swift.String, _ stop: inout Swift.Bool) -> Swift.Void)
  public var fastestEncoding: Swift.String.Encoding {
    get
  }
  public func getCString(_ buffer: inout [Swift.CChar], maxLength: Swift.Int, encoding: Swift.String.Encoding) -> Swift.Bool
  public var hash: Swift.Int {
    get
  }
  public func lengthOfBytes(using encoding: Swift.String.Encoding) -> Swift.Int
  public func localizedCaseInsensitiveCompare<T>(_ aString: T) -> Foundation.ComparisonResult where T : Swift.StringProtocol
  public func localizedCompare<T>(_ aString: T) -> Foundation.ComparisonResult where T : Swift.StringProtocol
  public func localizedStandardCompare<T>(_ string: T) -> Foundation.ComparisonResult where T : Swift.StringProtocol
  @available(macOS 10.11, iOS 9.0, *)
  public var localizedLowercase: Swift.String {
    get
  }
  public func lowercased(with locale: Foundation.Locale?) -> Swift.String
  public func maximumLengthOfBytes(using encoding: Swift.String.Encoding) -> Swift.Int
  public var precomposedStringWithCanonicalMapping: Swift.String {
    get
  }
  public var precomposedStringWithCompatibilityMapping: Swift.String {
    get
  }
  public func propertyList() -> Any
  public func propertyListFromStringsFileFormat() -> [Swift.String : Swift.String]
  @available(macOS 10.11, iOS 9.0, *)
  public func localizedStandardContains<T>(_ string: T) -> Swift.Bool where T : Swift.StringProtocol
  public var smallestEncoding: Swift.String.Encoding {
    get
  }
  public func addingPercentEncoding(withAllowedCharacters allowedCharacters: Foundation.CharacterSet) -> Swift.String?
  public func appendingFormat<T>(_ format: T, _ arguments: Swift.CVarArg...) -> Swift.String where T : Swift.StringProtocol
  public func appending<T>(_ aString: T) -> Swift.String where T : Swift.StringProtocol
  public func folding(options: Swift.String.CompareOptions = [], locale: Foundation.Locale?) -> Swift.String
  public func padding<T>(toLength newLength: Swift.Int, withPad padString: T, startingAt padIndex: Swift.Int) -> Swift.String where T : Swift.StringProtocol
  public var removingPercentEncoding: Swift.String? {
    get
  }
  public func replacingCharacters<T, R>(in range: R, with replacement: T) -> Swift.String where T : Swift.StringProtocol, R : Swift.RangeExpression, R.Bound == Swift.String.Index
  public func replacingOccurrences<Target, Replacement>(of target: Target, with replacement: Replacement, options: Swift.String.CompareOptions = [], range searchRange: Swift.Range<Self.Index>? = nil) -> Swift.String where Target : Swift.StringProtocol, Replacement : Swift.StringProtocol
  @available(swift, deprecated: 3.0, obsoleted: 4.0, message: "Use removingPercentEncoding instead, which always uses the recommended UTF-8 encoding.")
  public func replacingPercentEscapes(using encoding: Swift.String.Encoding) -> Swift.String?
  public func trimmingCharacters(in set: Foundation.CharacterSet) -> Swift.String
  @available(macOS 10.11, iOS 9.0, *)
  public var localizedUppercase: Swift.String {
    get
  }
  public func uppercased(with locale: Foundation.Locale?) -> Swift.String
  public func write<T>(toFile path: T, atomically useAuxiliaryFile: Swift.Bool, encoding enc: Swift.String.Encoding) throws where T : Swift.StringProtocol
  public func write(to url: Foundation.URL, atomically useAuxiliaryFile: Swift.Bool, encoding enc: Swift.String.Encoding) throws
  @available(macOS 10.11, iOS 9.0, *)
  public func applyingTransform(_ transform: Foundation.StringTransform, reverse: Swift.Bool) -> Swift.String?
  public func enumerateLinguisticTags<T, R>(in range: R, scheme tagScheme: T, options opts: Foundation.NSLinguisticTagger.Options = [], orthography: Foundation.NSOrthography? = nil, invoking body: (Swift.String, Swift.Range<Self.Index>, Swift.Range<Self.Index>, inout Swift.Bool) -> Swift.Void) where T : Swift.StringProtocol, R : Swift.RangeExpression, R.Bound == Swift.String.Index
  public func enumerateSubstrings<R>(in range: R, options opts: Swift.String.EnumerationOptions = [], _ body: @escaping (_ substring: Swift.String?, _ substringRange: Swift.Range<Self.Index>, _ enclosingRange: Swift.Range<Self.Index>, inout Swift.Bool) -> Swift.Void) where R : Swift.RangeExpression, R.Bound == Swift.String.Index
  public func getBytes<R>(_ buffer: inout [Swift.UInt8], maxLength maxBufferCount: Swift.Int, usedLength usedBufferCount: Swift.UnsafeMutablePointer<Swift.Int>, encoding: Swift.String.Encoding, options: Swift.String.EncodingConversionOptions = [], range: R, remaining leftover: Swift.UnsafeMutablePointer<Swift.Range<Self.Index>>) -> Swift.Bool where R : Swift.RangeExpression, R.Bound == Swift.String.Index
  public func getLineStart<R>(_ start: Swift.UnsafeMutablePointer<Self.Index>, end: Swift.UnsafeMutablePointer<Self.Index>, contentsEnd: Swift.UnsafeMutablePointer<Self.Index>, for range: R) where R : Swift.RangeExpression, R.Bound == Swift.String.Index
  public func getParagraphStart<R>(_ start: Swift.UnsafeMutablePointer<Self.Index>, end: Swift.UnsafeMutablePointer<Self.Index>, contentsEnd: Swift.UnsafeMutablePointer<Self.Index>, for range: R) where R : Swift.RangeExpression, R.Bound == Swift.String.Index
  public func lineRange<R>(for aRange: R) -> Swift.Range<Self.Index> where R : Swift.RangeExpression, R.Bound == Swift.String.Index
  public func linguisticTags<T, R>(in range: R, scheme tagScheme: T, options opts: Foundation.NSLinguisticTagger.Options = [], orthography: Foundation.NSOrthography? = nil, tokenRanges: Swift.UnsafeMutablePointer<[Swift.Range<Self.Index>]>? = nil) -> [Swift.String] where T : Swift.StringProtocol, R : Swift.RangeExpression, R.Bound == Swift.String.Index
  public func paragraphRange<R>(for aRange: R) -> Swift.Range<Self.Index> where R : Swift.RangeExpression, R.Bound == Swift.String.Index
  public func rangeOfCharacter(from aSet: Foundation.CharacterSet, options mask: Swift.String.CompareOptions = [], range aRange: Swift.Range<Self.Index>? = nil) -> Swift.Range<Self.Index>?
  public func rangeOfComposedCharacterSequence(at anIndex: Self.Index) -> Swift.Range<Self.Index>
  public func rangeOfComposedCharacterSequences<R>(for range: R) -> Swift.Range<Self.Index> where R : Swift.RangeExpression, R.Bound == Swift.String.Index
  public func range<T>(of aString: T, options mask: Swift.String.CompareOptions = [], range searchRange: Swift.Range<Self.Index>? = nil, locale: Foundation.Locale? = nil) -> Swift.Range<Self.Index>? where T : Swift.StringProtocol
  @available(macOS 10.11, iOS 9.0, *)
  public func localizedStandardRange<T>(of string: T) -> Swift.Range<Self.Index>? where T : Swift.StringProtocol
  @available(swift, deprecated: 3.0, obsoleted: 4.0, message: "Use addingPercentEncoding(withAllowedCharacters:) instead, which always uses the recommended UTF-8 encoding, and which encodes for a specific URL component or subcomponent since each URL component or subcomponent has different rules for what characters are valid.")
  public func addingPercentEscapes(using encoding: Swift.String.Encoding) -> Swift.String?
  public func contains<T>(_ other: T) -> Swift.Bool where T : Swift.StringProtocol
  public func localizedCaseInsensitiveContains<T>(_ other: T) -> Swift.Bool where T : Swift.StringProtocol
}
extension Swift.StringProtocol {
  @available(swift, deprecated: 4.0, message: "Please use String slicing subscript with a 'partial range from' operator.")
  public func substring(from index: Self.Index) -> Swift.String
  @available(swift, deprecated: 4.0, message: "Please use String slicing subscript with a 'partial range upto' operator.")
  public func substring(to index: Self.Index) -> Swift.String
  @available(swift, deprecated: 4.0, message: "Please use String slicing subscript.")
  public func substring(with aRange: Swift.Range<Self.Index>) -> Swift.String
}
extension Swift.StringProtocol {
  @available(*, unavailable, message: "Use getFileSystemRepresentation on URL instead.")
  public var fileSystemRepresentation: [Swift.CChar] {
    get
  }
  @available(*, unavailable, message: "Use getFileSystemRepresentation on URL instead.")
  public func getFileSystemRepresentation(_ buffer: inout [Swift.CChar], maxLength: Swift.Int) -> Swift.Bool
  @available(*, unavailable, message: "Use lastPathComponent on URL instead.")
  public var lastPathComponent: Swift.String {
    get
  }
  @available(*, unavailable, message: "Take the count of a UTF-16 view instead, i.e. str.utf16.count")
  public var utf16Count: Swift.Int {
    get
  }
  @available(*, unavailable, message: "Use pathComponents on URL instead.")
  public var pathComponents: [Swift.String] {
    get
  }
  @available(*, unavailable, message: "Use pathExtension on URL instead.")
  public var pathExtension: Swift.String {
    get
  }
  @available(*, unavailable, message: "Use abbreviatingWithTildeInPath on NSString instead.")
  public var abbreviatingWithTildeInPath: Swift.String {
    get
  }
  @available(*, unavailable, message: "Use appendingPathComponent on URL instead.")
  public func appendingPathComponent(_ aString: Swift.String) -> Swift.String
  @available(*, unavailable, message: "Use appendingPathExtension on URL instead.")
  public func appendingPathExtension(_ ext: Swift.String) -> Swift.String?
  @available(*, unavailable, message: "Use deletingLastPathComponent on URL instead.")
  public var deletingLastPathComponent: Swift.String {
    get
  }
  @available(*, unavailable, message: "Use deletingPathExtension on URL instead.")
  public var deletingPathExtension: Swift.String {
    get
  }
  @available(*, unavailable, message: "Use expandingTildeInPath on NSString instead.")
  public var expandingTildeInPath: Swift.String {
    get
  }
  @available(*, unavailable, renamed: "folding(options:locale:)")
  public func folding(_ options: Swift.String.CompareOptions = [], locale: Foundation.Locale?) -> Swift.String
  @available(*, unavailable, message: "Use resolvingSymlinksInPath on URL instead.")
  public var resolvingSymlinksInPath: Swift.String {
    get
  }
  @available(*, unavailable, message: "Use standardizingPath on URL instead.")
  public var standardizingPath: Swift.String {
    get
  }
  @available(*, unavailable, message: "Map over paths with appendingPathComponent instead.")
  public func strings(byAppendingPaths paths: [Swift.String]) -> [Swift.String]
}
extension Swift.String {
  @available(*, unavailable, renamed: "localizedName(of:)")
  public static func localizedNameOfStringEncoding(_ encoding: Swift.String.Encoding) -> Swift.String
  @available(*, unavailable, message: "Use fileURL(withPathComponents:) on URL instead.")
  public static func pathWithComponents(_ components: [Swift.String]) -> Swift.String
  @available(*, unavailable, message: "Use fileURL(withPathComponents:) on URL instead.")
  public static func path(withComponents components: [Swift.String]) -> Swift.String
}
extension Swift.StringProtocol {
  @available(*, unavailable, renamed: "canBeConverted(to:)")
  public func canBeConvertedToEncoding(_ encoding: Swift.String.Encoding) -> Swift.Bool
  @available(*, unavailable, renamed: "capitalizedString(with:)")
  public func capitalizedStringWith(_ locale: Foundation.Locale?) -> Swift.String
  @available(*, unavailable, renamed: "commonPrefix(with:options:)")
  public func commonPrefixWith(_ aString: Swift.String, options: Swift.String.CompareOptions) -> Swift.String
  @available(*, unavailable, renamed: "completePath(into:outputName:caseSensitive:matchesInto:filterTypes:)")
  public func completePathInto(_ outputName: Swift.UnsafeMutablePointer<Swift.String>? = nil, caseSensitive: Swift.Bool, matchesInto matchesIntoArray: Swift.UnsafeMutablePointer<[Swift.String]>? = nil, filterTypes: [Swift.String]? = nil) -> Swift.Int
  @available(*, unavailable, renamed: "components(separatedBy:)")
  public func componentsSeparatedByCharactersIn(_ separator: Foundation.CharacterSet) -> [Swift.String]
  @available(*, unavailable, renamed: "components(separatedBy:)")
  public func componentsSeparatedBy(_ separator: Swift.String) -> [Swift.String]
  @available(*, unavailable, renamed: "cString(usingEncoding:)")
  public func cStringUsingEncoding(_ encoding: Swift.String.Encoding) -> [Swift.CChar]?
  @available(*, unavailable, renamed: "data(usingEncoding:allowLossyConversion:)")
  public func dataUsingEncoding(_ encoding: Swift.String.Encoding, allowLossyConversion: Swift.Bool = false) -> Foundation.Data?
  @available(*, unavailable, renamed: "enumerateLinguisticTags(in:scheme:options:orthography:_:)")
  public func enumerateLinguisticTagsIn(_ range: Swift.Range<Self.Index>, scheme tagScheme: Swift.String, options opts: Foundation.NSLinguisticTagger.Options, orthography: Foundation.NSOrthography?, _ body: (Swift.String, Swift.Range<Self.Index>, Swift.Range<Self.Index>, inout Swift.Bool) -> Swift.Void)
  @available(*, unavailable, renamed: "enumerateSubstrings(in:options:_:)")
  public func enumerateSubstringsIn(_ range: Swift.Range<Self.Index>, options opts: Swift.String.EnumerationOptions = [], _ body: (_ substring: Swift.String?, _ substringRange: Swift.Range<Self.Index>, _ enclosingRange: Swift.Range<Self.Index>, inout Swift.Bool) -> Swift.Void)
  @available(*, unavailable, renamed: "getBytes(_:maxLength:usedLength:encoding:options:range:remaining:)")
  public func getBytes(_ buffer: inout [Swift.UInt8], maxLength maxBufferCount: Swift.Int, usedLength usedBufferCount: Swift.UnsafeMutablePointer<Swift.Int>, encoding: Swift.String.Encoding, options: Swift.String.EncodingConversionOptions = [], range: Swift.Range<Self.Index>, remainingRange leftover: Swift.UnsafeMutablePointer<Swift.Range<Self.Index>>) -> Swift.Bool
  @available(*, unavailable, renamed: "getLineStart(_:end:contentsEnd:for:)")
  public func getLineStart(_ start: Swift.UnsafeMutablePointer<Self.Index>, end: Swift.UnsafeMutablePointer<Self.Index>, contentsEnd: Swift.UnsafeMutablePointer<Self.Index>, forRange: Swift.Range<Self.Index>)
  @available(*, unavailable, renamed: "getParagraphStart(_:end:contentsEnd:for:)")
  public func getParagraphStart(_ start: Swift.UnsafeMutablePointer<Self.Index>, end: Swift.UnsafeMutablePointer<Self.Index>, contentsEnd: Swift.UnsafeMutablePointer<Self.Index>, forRange: Swift.Range<Self.Index>)
  @available(*, unavailable, renamed: "lengthOfBytes(using:)")
  public func lengthOfBytesUsingEncoding(_ encoding: Swift.String.Encoding) -> Swift.Int
  @available(*, unavailable, renamed: "lineRange(for:)")
  public func lineRangeFor(_ aRange: Swift.Range<Self.Index>) -> Swift.Range<Self.Index>
  @available(*, unavailable, renamed: "linguisticTags(in:scheme:options:orthography:tokenRanges:)")
  public func linguisticTagsIn(_ range: Swift.Range<Self.Index>, scheme tagScheme: Swift.String, options opts: Foundation.NSLinguisticTagger.Options = [], orthography: Foundation.NSOrthography? = nil, tokenRanges: Swift.UnsafeMutablePointer<[Swift.Range<Self.Index>]>? = nil) -> [Swift.String]
  @available(*, unavailable, renamed: "lowercased(with:)")
  public func lowercaseStringWith(_ locale: Foundation.Locale?) -> Swift.String
  @available(*, unavailable, renamed: "maximumLengthOfBytes(using:)")
  public func maximumLengthOfBytesUsingEncoding(_ encoding: Swift.String.Encoding) -> Swift.Int
  @available(*, unavailable, renamed: "paragraphRange(for:)")
  public func paragraphRangeFor(_ aRange: Swift.Range<Self.Index>) -> Swift.Range<Self.Index>
  @available(*, unavailable, renamed: "rangeOfCharacter(from:options:range:)")
  public func rangeOfCharacterFrom(_ aSet: Foundation.CharacterSet, options mask: Swift.String.CompareOptions = [], range aRange: Swift.Range<Self.Index>? = nil) -> Swift.Range<Self.Index>?
  @available(*, unavailable, renamed: "rangeOfComposedCharacterSequence(at:)")
  public func rangeOfComposedCharacterSequenceAt(_ anIndex: Self.Index) -> Swift.Range<Self.Index>
  @available(*, unavailable, renamed: "rangeOfComposedCharacterSequences(for:)")
  public func rangeOfComposedCharacterSequencesFor(_ range: Swift.Range<Self.Index>) -> Swift.Range<Self.Index>
  @available(*, unavailable, renamed: "range(of:options:range:locale:)")
  public func rangeOf(_ aString: Swift.String, options mask: Swift.String.CompareOptions = [], range searchRange: Swift.Range<Self.Index>? = nil, locale: Foundation.Locale? = nil) -> Swift.Range<Self.Index>?
  @available(*, unavailable, renamed: "localizedStandardRange(of:)")
  public func localizedStandardRangeOf(_ string: Swift.String) -> Swift.Range<Self.Index>?
  @available(*, unavailable, renamed: "addingPercentEncoding(withAllowedCharacters:)")
  public func addingPercentEncodingWithAllowedCharacters(_ allowedCharacters: Foundation.CharacterSet) -> Swift.String?
  @available(*, unavailable, renamed: "addingPercentEscapes(using:)")
  public func addingPercentEscapesUsingEncoding(_ encoding: Swift.String.Encoding) -> Swift.String?
  @available(*, unavailable, renamed: "appendingFormat")
  public func stringByAppendingFormat(_ format: Swift.String, _ arguments: Swift.CVarArg...) -> Swift.String
  @available(*, unavailable, renamed: "padding(toLength:with:startingAt:)")
  public func byPaddingToLength(_ newLength: Swift.Int, withString padString: Swift.String, startingAt padIndex: Swift.Int) -> Swift.String
  @available(*, unavailable, renamed: "replacingCharacters(in:with:)")
  public func replacingCharactersIn(_ range: Swift.Range<Self.Index>, withString replacement: Swift.String) -> Swift.String
  @available(*, unavailable, renamed: "replacingOccurrences(of:with:options:range:)")
  public func replacingOccurrencesOf(_ target: Swift.String, withString replacement: Swift.String, options: Swift.String.CompareOptions = [], range searchRange: Swift.Range<Self.Index>? = nil) -> Swift.String
  @available(*, unavailable, renamed: "replacingPercentEscapes(usingEncoding:)")
  public func replacingPercentEscapesUsingEncoding(_ encoding: Swift.String.Encoding) -> Swift.String?
  @available(*, unavailable, renamed: "trimmingCharacters(in:)")
  public func byTrimmingCharactersIn(_ set: Foundation.CharacterSet) -> Swift.String
  @available(*, unavailable, renamed: "strings(byAppendingPaths:)")
  public func stringsByAppendingPaths(_ paths: [Swift.String]) -> [Swift.String]
  @available(*, unavailable, renamed: "substring(from:)")
  public func substringFrom(_ index: Self.Index) -> Swift.String
  @available(*, unavailable, renamed: "substring(to:)")
  public func substringTo(_ index: Self.Index) -> Swift.String
  @available(*, unavailable, renamed: "substring(with:)")
  public func substringWith(_ aRange: Swift.Range<Self.Index>) -> Swift.String
  @available(*, unavailable, renamed: "uppercased(with:)")
  public func uppercaseStringWith(_ locale: Foundation.Locale?) -> Swift.String
  @available(*, unavailable, renamed: "write(toFile:atomically:encoding:)")
  public func writeToFile(_ path: Swift.String, atomically useAuxiliaryFile: Swift.Bool, encoding enc: Swift.String.Encoding) throws
  @available(*, unavailable, renamed: "write(to:atomically:encoding:)")
  public func writeToURL(_ url: Foundation.URL, atomically useAuxiliaryFile: Swift.Bool, encoding enc: Swift.String.Encoding) throws
}
extension Foundation.NSSet : Swift.Sequence {
  public func makeIterator() -> Foundation.NSFastEnumerationIterator
  @_alwaysEmitIntoClient @nonobjc public var underestimatedCount: Swift.Int {
    get { count }
  }
  public typealias Element = Any
  public typealias Iterator = Foundation.NSFastEnumerationIterator
}
extension Foundation.NSOrderedSet : Swift.Sequence {
  public func makeIterator() -> Foundation.NSFastEnumerationIterator
  @_alwaysEmitIntoClient @nonobjc public var underestimatedCount: Swift.Int {
    get { count }
  }
  public typealias Element = Any
  public typealias Iterator = Foundation.NSFastEnumerationIterator
}
extension Swift.Set : Swift._ObjectiveCBridgeable {
  @_semantics("convertToObjectiveC") public func _bridgeToObjectiveC() -> Foundation.NSSet
  public static func _forceBridgeFromObjectiveC(_ s: Foundation.NSSet, result: inout Swift.Set<Element>?)
  public static func _conditionallyBridgeFromObjectiveC(_ x: Foundation.NSSet, result: inout Swift.Set<Element>?) -> Swift.Bool
  @_effects(readonly) public static func _unconditionallyBridgeFromObjectiveC(_ s: Foundation.NSSet?) -> Swift.Set<Element>
  public typealias _ObjectiveCType = Foundation.NSSet
}
extension Foundation.NSSet : Swift._HasCustomAnyHashableRepresentation {
  @nonobjc public func _toCustomAnyHashable() -> Swift.AnyHashable?
}
extension Foundation.NSOrderedSet {
  convenience public init(objects elements: Any...)
}
extension Foundation.NSSet {
  convenience public init(objects elements: Any...)
}
extension Foundation.NSSet : Swift.ExpressibleByArrayLiteral {
  required convenience public init(arrayLiteral elements: Any...)
  public typealias ArrayLiteralElement = Any
}
extension Foundation.NSOrderedSet : Swift.ExpressibleByArrayLiteral {
  required convenience public init(arrayLiteral elements: Any...)
  public typealias ArrayLiteralElement = Any
}
extension Foundation.NSSet {
  @nonobjc convenience public init(set anSet: __shared Foundation.NSSet)
}
extension Foundation.NSSet : Swift.CustomReflectable {
  public var customMirror: Swift.Mirror {
    get
  }
}
extension Swift.Set : Swift.CVarArg {
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Swift.String {
  public struct LocalizationValue : Swift.Equatable, Swift.ExpressibleByStringInterpolation {
    public init(_ value: Swift.String)
    @_semantics("localization_key.init_literal") public init(stringLiteral value: Swift.String)
    @_semantics("localization_key.init_interpolation") public init(stringInterpolation: Swift.String.LocalizationValue.StringInterpolation)
    public struct StringInterpolation : Swift.StringInterpolationProtocol {
      @_semantics("localization.interpolation_init") public init(literalCapacity: Swift.Int, interpolationCount: Swift.Int)
      @_semantics("localization.interpolation.appendLiteral") public mutating func appendLiteral(_ literal: Swift.String)
      @_semantics("localization.interpolation.appendInterpolation_@_specifier") public mutating func appendInterpolation(_ string: Swift.String)
      @_semantics("localization.interpolation.appendInterpolation_@_specifier") public mutating func appendInterpolation<Subject>(_ subject: Subject) where Subject : ObjectiveC.NSObject
      @_transparent public mutating func appendInterpolation<T>(_ value: T) where T : Foundation._FormatSpecifiable {
                appendInterpolation(value, specifier: formatSpecifier(T.self))
            }
      @_semantics("localization.interpolation.appendInterpolation_param_specifier") public mutating func appendInterpolation<T>(_ value: T, specifier: Swift.String) where T : Foundation._FormatSpecifiable
      @_semantics("localization.interpolation.appendInterpolation_@_specifier") public mutating func appendInterpolation<T, F>(_ value: T, format: F) where T == F.FormatInput, F : Foundation.FormatStyle, F.FormatOutput : Swift.StringProtocol
      @_semantics("localization.interpolation.appendInterpolation_@_specifier") public mutating func appendInterpolation<T, F>(_ value: T, format: F) where T == F.FormatInput, F : Foundation.FormatStyle, F.FormatOutput : Foundation.AttributedStringProtocol
      @_semantics("localization.interpolation.appendInterpolation_@_specifier") public mutating func appendInterpolation(_ attrStr: Foundation.AttributedString, options: Foundation.AttributedString.InterpolationOptions = [])
      public typealias StringLiteralType = Swift.String
    }
    public static func == (a: Swift.String.LocalizationValue, b: Swift.String.LocalizationValue) -> Swift.Bool
    public typealias ExtendedGraphemeClusterLiteralType = Swift.String
    public typealias StringLiteralType = Swift.String
    public typealias UnicodeScalarLiteralType = Swift.String
  }
  @_semantics("string.init_localized") public init(localized keyAndValue: Swift.String.LocalizationValue, table: Swift.String? = nil, bundle: Foundation.Bundle? = nil, locale: Foundation.Locale = .current, comment: Swift.StaticString? = nil)
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.AttributedString {
  public struct FormattingOptions : Swift.OptionSet {
    public let rawValue: Swift.UInt
    public init(rawValue: Swift.UInt)
    public static let applyReplacementIndexAttribute: Foundation.AttributedString.FormattingOptions
    public typealias ArrayLiteralElement = Foundation.AttributedString.FormattingOptions
    public typealias Element = Foundation.AttributedString.FormattingOptions
    public typealias RawValue = Swift.UInt
  }
  public struct InterpolationOptions : Swift.OptionSet {
    public let rawValue: Swift.UInt
    public init(rawValue: Swift.UInt)
    public static let insertAttributesWithoutMerging: Foundation.AttributedString.InterpolationOptions
    public typealias ArrayLiteralElement = Foundation.AttributedString.InterpolationOptions
    public typealias Element = Foundation.AttributedString.InterpolationOptions
    public typealias RawValue = Swift.UInt
  }
  @_semantics("attributed_string.init_localized") public init(localized key: Swift.String.LocalizationValue, options: Foundation.AttributedString.FormattingOptions = [], table: Swift.String? = nil, bundle: Foundation.Bundle? = nil, locale: Foundation.Locale? = nil, comment: Swift.StaticString? = nil)
  @_semantics("attributed_string.init_localized") public init<S>(localized key: Swift.String.LocalizationValue, options: Foundation.AttributedString.FormattingOptions = [], table: Swift.String? = nil, bundle: Foundation.Bundle? = nil, locale: Foundation.Locale? = nil, comment: Swift.StaticString? = nil, including scope: Swift.KeyPath<Foundation.AttributeScopes, S.Type>) where S : Foundation.AttributeScope
  @_semantics("attributed_string.init_localized") public init<S>(localized key: Swift.String.LocalizationValue, options: Foundation.AttributedString.FormattingOptions = [], table: Swift.String? = nil, bundle: Foundation.Bundle? = nil, locale: Foundation.Locale? = nil, comment: Swift.StaticString? = nil, including scope: S.Type) where S : Foundation.AttributeScope
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Swift.String.LocalizationValue {
  @usableFromInline
  internal struct FormatArgument : Swift.Equatable {
    @usableFromInline
    internal static func == (a: Swift.String.LocalizationValue.FormatArgument, b: Swift.String.LocalizationValue.FormatArgument) -> Swift.Bool
  }
}
@_alwaysEmitIntoClient @_semantics("constant_evaluable") private func formatSpecifier<T>(_ type: T.Type) -> Swift.String {
    switch type {
    case is Int.Type:
        fallthrough
    case is Int64.Type:
        return int64Specifier
    case is Int8.Type:
        fallthrough
    case is Int16.Type:
        fallthrough
    case is Int32.Type:
        return int32Specifier
    case is UInt.Type:
        fallthrough
    case is UInt64.Type:
        return uint64Specifier
    case is UInt8.Type:
        fallthrough
    case is UInt16.Type:
        fallthrough
    case is UInt32.Type:
        return uint32Specifier
    case is Float.Type:
        return floatSpecifier
    case is CGFloat.Type:
        fallthrough
    case is Float80.Type:
        fallthrough
    case is Double.Type:
        return doubleSpecifier
    default:
        return "%@"
    }
}
@_alwaysEmitIntoClient private var int64Specifier: Swift.String {
  get { "%lld" }
}
@_alwaysEmitIntoClient private var int32Specifier: Swift.String {
  get { "%d" }
}
@_alwaysEmitIntoClient private var uint64Specifier: Swift.String {
  get { "%llu" }
}
@_alwaysEmitIntoClient private var uint32Specifier: Swift.String {
  get { "%u" }
}
@_alwaysEmitIntoClient private var floatSpecifier: Swift.String {
  get { "%f" }
}
@_alwaysEmitIntoClient private var doubleSpecifier: Swift.String {
  get { "%lf" }
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
public protocol _FormatSpecifiable : Swift.Equatable {
  associatedtype _Arg : Swift.CVarArg
  var _arg: Self._Arg { get }
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Swift.Int : Foundation._FormatSpecifiable {
  public var _arg: Swift.Int64 {
    get
  }
  public typealias _Arg = Swift.Int64
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Swift.Int8 : Foundation._FormatSpecifiable {
  public var _arg: Swift.Int32 {
    get
  }
  public typealias _Arg = Swift.Int32
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Swift.Int16 : Foundation._FormatSpecifiable {
  public var _arg: Swift.Int32 {
    get
  }
  public typealias _Arg = Swift.Int32
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Swift.Int32 : Foundation._FormatSpecifiable {
  public var _arg: Swift.Int32 {
    get
  }
  public typealias _Arg = Swift.Int32
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Swift.Int64 : Foundation._FormatSpecifiable {
  public var _arg: Swift.Int64 {
    get
  }
  public typealias _Arg = Swift.Int64
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Swift.UInt : Foundation._FormatSpecifiable {
  public var _arg: Swift.UInt64 {
    get
  }
  public typealias _Arg = Swift.UInt64
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Swift.UInt8 : Foundation._FormatSpecifiable {
  public var _arg: Swift.UInt32 {
    get
  }
  public typealias _Arg = Swift.UInt32
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Swift.UInt16 : Foundation._FormatSpecifiable {
  public var _arg: Swift.UInt32 {
    get
  }
  public typealias _Arg = Swift.UInt32
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Swift.UInt32 : Foundation._FormatSpecifiable {
  public var _arg: Swift.UInt32 {
    get
  }
  public typealias _Arg = Swift.UInt32
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Swift.UInt64 : Foundation._FormatSpecifiable {
  public var _arg: Swift.UInt64 {
    get
  }
  public typealias _Arg = Swift.UInt64
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Swift.Float : Foundation._FormatSpecifiable {
  public var _arg: Swift.Float {
    get
  }
  public typealias _Arg = Swift.Float
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Swift.Float80 : Foundation._FormatSpecifiable {
  public var _arg: Swift.Float80 {
    get
  }
  public typealias _Arg = Swift.Float80
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Swift.Double : Foundation._FormatSpecifiable {
  public var _arg: Swift.Double {
    get
  }
  public typealias _Arg = Swift.Double
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension CoreGraphics.CGFloat : Foundation._FormatSpecifiable {
  public var _arg: CoreGraphics.CGFloat {
    get
  }
  public typealias _Arg = CoreGraphics.CGFloat
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Swift.BinaryInteger {
  public func formatted() -> Swift.String
  public func formatted<S>(_ format: S) -> S.FormatOutput where Self == S.FormatInput, S : Foundation.FormatStyle
  public func formatted<S>(_ format: S) -> S.FormatOutput where S : Foundation.FormatStyle, S.FormatInput : Swift.BinaryInteger
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Swift.BinaryInteger {
  public init<S>(_ value: S.ParseInput, strategy: S) throws where S : Foundation.ParseStrategy, S.ParseOutput : Swift.BinaryInteger
  public init<S>(_ value: S.ParseInput, strategy: S) throws where Self == S.ParseOutput, S : Foundation.ParseStrategy
  public init(_ value: Swift.String, format: Foundation.IntegerFormatStyle<Self>, lenient: Swift.Bool = true) throws
  public init(_ value: Swift.String, format: Foundation.IntegerFormatStyle<Self>.Percent, lenient: Swift.Bool = true) throws
  public init(_ value: Swift.String, format: Foundation.IntegerFormatStyle<Self>.Currency, lenient: Swift.Bool = true) throws
}
@available(*, deprecated, message: "Please use the struct type URLRequest")
public typealias MutableURLRequest = Foundation.NSMutableURLRequest
public struct URLRequest : Foundation.ReferenceConvertible, Swift.Equatable, Swift.Hashable {
  public typealias ReferenceType = Foundation.NSURLRequest
  public typealias CachePolicy = Foundation.NSURLRequest.CachePolicy
  public typealias NetworkServiceType = Foundation.NSURLRequest.NetworkServiceType
  @available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
  public typealias Attribution = Foundation.NSURLRequest.Attribution
  public init(url: Foundation.URL, cachePolicy: Foundation.URLRequest.CachePolicy = .useProtocolCachePolicy, timeoutInterval: Foundation.TimeInterval = 60.0)
  public var url: Foundation.URL? {
    get
    set
  }
  public var cachePolicy: Foundation.URLRequest.CachePolicy {
    get
    set
  }
  public var timeoutInterval: Foundation.TimeInterval {
    get
    set
  }
  public var mainDocumentURL: Foundation.URL? {
    get
    set
  }
  @available(macOS 10.7, iOS 4.0, *)
  public var networkServiceType: Foundation.URLRequest.NetworkServiceType {
    get
    set
  }
  @available(macOS 10.8, iOS 6.0, *)
  public var allowsCellularAccess: Swift.Bool {
    get
    set
  }
  @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
  public var allowsExpensiveNetworkAccess: Swift.Bool {
    get
    set
  }
  @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
  public var allowsConstrainedNetworkAccess: Swift.Bool {
    get
    set
  }
  @available(macOS 11.3, iOS 14.5, watchOS 7.4, tvOS 14.5, *)
  public var assumesHTTP3Capable: Swift.Bool {
    get
    set
  }
  @available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
  public var attribution: Foundation.URLRequest.Attribution {
    get
    set
  }
  public var httpMethod: Swift.String? {
    get
    set
  }
  public var allHTTPHeaderFields: [Swift.String : Swift.String]? {
    get
    set
  }
  public func value(forHTTPHeaderField field: Swift.String) -> Swift.String?
  public mutating func setValue(_ value: Swift.String?, forHTTPHeaderField field: Swift.String)
  public mutating func addValue(_ value: Swift.String, forHTTPHeaderField field: Swift.String)
  public var httpBody: Foundation.Data? {
    get
    set
  }
  public var httpBodyStream: Foundation.InputStream? {
    get
    set
  }
  public var httpShouldHandleCookies: Swift.Bool {
    get
    set
  }
  @available(macOS 10.7, iOS 4.0, *)
  public var httpShouldUsePipelining: Swift.Bool {
    get
    set
  }
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (lhs: Foundation.URLRequest, rhs: Foundation.URLRequest) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
extension Foundation.URLRequest : Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible, Swift.CustomReflectable {
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
  public var customMirror: Swift.Mirror {
    get
  }
}
extension Foundation.URLRequest : Swift._ObjectiveCBridgeable {
  public static func _getObjectiveCType() -> Any.Type
  @_semantics("convertToObjectiveC") public func _bridgeToObjectiveC() -> Foundation.NSURLRequest
  public static func _forceBridgeFromObjectiveC(_ input: Foundation.NSURLRequest, result: inout Foundation.URLRequest?)
  public static func _conditionallyBridgeFromObjectiveC(_ input: Foundation.NSURLRequest, result: inout Foundation.URLRequest?) -> Swift.Bool
  @_effects(readonly) public static func _unconditionallyBridgeFromObjectiveC(_ source: Foundation.NSURLRequest?) -> Foundation.URLRequest
  public typealias _ObjectiveCType = Foundation.NSURLRequest
}
extension Foundation.NSURLRequest : Swift._HasCustomAnyHashableRepresentation {
  @nonobjc public func _toCustomAnyHashable() -> Swift.AnyHashable?
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
public protocol ParseStrategy : Swift.Decodable, Swift.Encodable, Swift.Hashable {
  associatedtype ParseInput
  associatedtype ParseOutput
  func parse(_ value: Self.ParseInput) throws -> Self.ParseOutput
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Foundation.RunLoop : Combine.Scheduler {
  public struct SchedulerTimeType : Swift.Strideable, Swift.Codable, Swift.Hashable {
    public var date: Foundation.Date
    public init(_ date: Foundation.Date)
    public func distance(to other: Foundation.RunLoop.SchedulerTimeType) -> Foundation.RunLoop.SchedulerTimeType.Stride
    public func advanced(by n: Foundation.RunLoop.SchedulerTimeType.Stride) -> Foundation.RunLoop.SchedulerTimeType
    public struct Stride : Swift.ExpressibleByFloatLiteral, Swift.Comparable, Swift.SignedNumeric, Swift.Codable, Combine.SchedulerTimeIntervalConvertible {
      public typealias FloatLiteralType = Foundation.TimeInterval
      public typealias IntegerLiteralType = Foundation.TimeInterval
      public typealias Magnitude = Foundation.TimeInterval
      public var magnitude: Foundation.TimeInterval
      public var timeInterval: Foundation.TimeInterval {
        get
      }
      public init(integerLiteral value: Foundation.TimeInterval)
      public init(floatLiteral value: Foundation.TimeInterval)
      public init(_ timeInterval: Foundation.TimeInterval)
      public init?<T>(exactly source: T) where T : Swift.BinaryInteger
      public static func < (lhs: Foundation.RunLoop.SchedulerTimeType.Stride, rhs: Foundation.RunLoop.SchedulerTimeType.Stride) -> Swift.Bool
      public static func * (lhs: Foundation.RunLoop.SchedulerTimeType.Stride, rhs: Foundation.RunLoop.SchedulerTimeType.Stride) -> Foundation.RunLoop.SchedulerTimeType.Stride
      public static func + (lhs: Foundation.RunLoop.SchedulerTimeType.Stride, rhs: Foundation.RunLoop.SchedulerTimeType.Stride) -> Foundation.RunLoop.SchedulerTimeType.Stride
      public static func - (lhs: Foundation.RunLoop.SchedulerTimeType.Stride, rhs: Foundation.RunLoop.SchedulerTimeType.Stride) -> Foundation.RunLoop.SchedulerTimeType.Stride
      public static func *= (lhs: inout Foundation.RunLoop.SchedulerTimeType.Stride, rhs: Foundation.RunLoop.SchedulerTimeType.Stride)
      public static func += (lhs: inout Foundation.RunLoop.SchedulerTimeType.Stride, rhs: Foundation.RunLoop.SchedulerTimeType.Stride)
      public static func -= (lhs: inout Foundation.RunLoop.SchedulerTimeType.Stride, rhs: Foundation.RunLoop.SchedulerTimeType.Stride)
      public static func seconds(_ s: Swift.Int) -> Foundation.RunLoop.SchedulerTimeType.Stride
      public static func seconds(_ s: Swift.Double) -> Foundation.RunLoop.SchedulerTimeType.Stride
      public static func milliseconds(_ ms: Swift.Int) -> Foundation.RunLoop.SchedulerTimeType.Stride
      public static func microseconds(_ us: Swift.Int) -> Foundation.RunLoop.SchedulerTimeType.Stride
      public static func nanoseconds(_ ns: Swift.Int) -> Foundation.RunLoop.SchedulerTimeType.Stride
      public static func == (a: Foundation.RunLoop.SchedulerTimeType.Stride, b: Foundation.RunLoop.SchedulerTimeType.Stride) -> Swift.Bool
      public func encode(to encoder: Swift.Encoder) throws
      public init(from decoder: Swift.Decoder) throws
    }
    public func hash(into hasher: inout Swift.Hasher)
    public func encode(to encoder: Swift.Encoder) throws
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: Swift.Decoder) throws
  }
  public struct SchedulerOptions {
  }
  public func schedule(options: Foundation.RunLoop.SchedulerOptions?, _ action: @escaping () -> Swift.Void)
  public func schedule(after date: Foundation.RunLoop.SchedulerTimeType, tolerance: Foundation.RunLoop.SchedulerTimeType.Stride, options: Foundation.RunLoop.SchedulerOptions?, _ action: @escaping () -> Swift.Void)
  public func schedule(after date: Foundation.RunLoop.SchedulerTimeType, interval: Foundation.RunLoop.SchedulerTimeType.Stride, tolerance: Foundation.RunLoop.SchedulerTimeType.Stride, options: Foundation.RunLoop.SchedulerOptions?, _ action: @escaping () -> Swift.Void) -> Combine.Cancellable
  public var now: Foundation.RunLoop.SchedulerTimeType {
    get
  }
  public var minimumTolerance: Foundation.RunLoop.SchedulerTimeType.Stride {
    get
  }
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.AttributeScopes : Swift.Sendable {}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.AttributeDynamicLookup : Swift.Sendable {}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.AttributeScopes.FoundationAttributes.LinkAttribute : Swift.Sendable {}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.AttributeScopes.FoundationAttributes.MorphologyAttribute : Swift.Sendable {}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.AttributeScopes.FoundationAttributes.InflectionRuleAttribute : Swift.Sendable {}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.AttributeScopes.FoundationAttributes.LanguageIdentifierAttribute : Swift.Sendable {}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.AttributeScopes.FoundationAttributes.PersonNameComponentAttribute : Swift.Sendable {}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.AttributeScopes.FoundationAttributes.PersonNameComponentAttribute.Component : Swift.Equatable {}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.AttributeScopes.FoundationAttributes.PersonNameComponentAttribute.Component : Swift.Hashable {}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.AttributeScopes.FoundationAttributes.PersonNameComponentAttribute.Component : Swift.RawRepresentable {}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.AttributeScopes.FoundationAttributes.NumberFormatAttributes.NumberPartAttribute : Swift.Sendable {}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.AttributeScopes.FoundationAttributes.NumberFormatAttributes.NumberPartAttribute.NumberPart : Swift.Equatable {}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.AttributeScopes.FoundationAttributes.NumberFormatAttributes.NumberPartAttribute.NumberPart : Swift.Hashable {}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.AttributeScopes.FoundationAttributes.NumberFormatAttributes.NumberPartAttribute.NumberPart : Swift.RawRepresentable {}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.AttributeScopes.FoundationAttributes.NumberFormatAttributes.SymbolAttribute : Swift.Sendable {}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.AttributeScopes.FoundationAttributes.NumberFormatAttributes.SymbolAttribute.Symbol : Swift.Equatable {}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.AttributeScopes.FoundationAttributes.NumberFormatAttributes.SymbolAttribute.Symbol : Swift.Hashable {}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.AttributeScopes.FoundationAttributes.NumberFormatAttributes.SymbolAttribute.Symbol : Swift.RawRepresentable {}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.AttributeScopes.FoundationAttributes.DateFieldAttribute : Swift.Sendable {}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.AttributeScopes.FoundationAttributes.InflectionAlternativeAttribute : Swift.Sendable {}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.AttributeScopes.FoundationAttributes.InlinePresentationIntentAttribute : Swift.Sendable {}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.AttributeScopes.FoundationAttributes.PresentationIntentAttribute : Swift.Sendable {}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.AttributeScopes.FoundationAttributes.AlternateDescriptionAttribute : Swift.Sendable {}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.AttributeScopes.FoundationAttributes.ImageURLAttribute : Swift.Sendable {}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.AttributeScopes.FoundationAttributes.ReplacementIndexAttribute : Swift.Sendable {}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.AttributeScopes.FoundationAttributes.MeasurementAttribute.Component : Swift.Equatable {}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.AttributeScopes.FoundationAttributes.MeasurementAttribute.Component : Swift.Hashable {}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.AttributeScopes.FoundationAttributes.MeasurementAttribute.Component : Swift.RawRepresentable {}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.AttributeScopes.FoundationAttributes.ByteCountAttribute : Swift.Sendable {}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.AttributeScopes.FoundationAttributes.ByteCountAttribute.Unit : Swift.Equatable {}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.AttributeScopes.FoundationAttributes.ByteCountAttribute.Unit : Swift.Hashable {}
extension Foundation.Data.InlineData : Swift.Sendable {}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension Foundation.Scanner.NumberRepresentation : Swift.Equatable {}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension Foundation.Scanner.NumberRepresentation : Swift.Hashable {}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.Date.FormatStyle.Symbol.DayPeriod.Width : Swift.Equatable {}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.Date.FormatStyle.Symbol.DayPeriod.Width : Swift.Hashable {}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.Date.FormatStyle.Symbol.TimeZone.Width : Swift.Equatable {}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.Date.FormatStyle.Symbol.TimeZone.Width : Swift.Hashable {}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.PersonNameComponents.FormatStyle.Style : Swift.RawRepresentable {}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.SortOrder : Swift.Sendable {}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension Foundation.URLError.BackgroundTaskCancelledReason : Swift.Equatable {}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension Foundation.URLError.BackgroundTaskCancelledReason : Swift.Hashable {}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension Foundation.URLError.BackgroundTaskCancelledReason : Swift.RawRepresentable {}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension Foundation.URLError.NetworkUnavailableReason : Swift.Equatable {}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension Foundation.URLError.NetworkUnavailableReason : Swift.Hashable {}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension Foundation.URLError.NetworkUnavailableReason : Swift.RawRepresentable {}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.ListFormatStyle.Width : Swift.Equatable {}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.ListFormatStyle.Width : Swift.Hashable {}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.ListFormatStyle.Width : Swift.RawRepresentable {}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.ListFormatStyle.ListType : Swift.Equatable {}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.ListFormatStyle.ListType : Swift.Hashable {}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.ListFormatStyle.ListType : Swift.RawRepresentable {}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.ByteCountFormatStyle.Style : Swift.RawRepresentable {}
@available(macOS 12, iOS 15, watchOS 8, tvOS 15, *)
extension Foundation.PresentationIntent.TableColumn.Alignment : Swift.RawRepresentable {}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.AttributedString.AttributeMergePolicy : Swift.Equatable {}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.AttributedString.AttributeMergePolicy : Swift.Hashable {}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.AttributedString.MarkdownParsingOptions.FailurePolicy : Swift.Equatable {}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.AttributedString.MarkdownParsingOptions.FailurePolicy : Swift.Hashable {}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.AttributedString.MarkdownParsingOptions.FailurePolicy : Swift.RawRepresentable {}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.AttributedString.MarkdownParsingOptions.InterpretedSyntax : Swift.Equatable {}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.AttributedString.MarkdownParsingOptions.InterpretedSyntax : Swift.Hashable {}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.AttributedString.MarkdownParsingOptions.InterpretedSyntax : Swift.RawRepresentable {}
@available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
extension Foundation.Morphology.GrammaticalGender : Swift.RawRepresentable {}
@available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
extension Foundation.Morphology.PartOfSpeech : Swift.RawRepresentable {}
@available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
extension Foundation.Morphology.GrammaticalNumber : Swift.RawRepresentable {}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.Date.ISO8601FormatStyle.TimeZoneSeparator : Swift.Equatable {}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.Date.ISO8601FormatStyle.TimeZoneSeparator : Swift.Hashable {}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.Date.ISO8601FormatStyle.TimeZoneSeparator : Swift.RawRepresentable {}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.Date.ISO8601FormatStyle.DateSeparator : Swift.Equatable {}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.Date.ISO8601FormatStyle.DateSeparator : Swift.Hashable {}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.Date.ISO8601FormatStyle.DateSeparator : Swift.RawRepresentable {}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.Date.ISO8601FormatStyle.TimeSeparator : Swift.Equatable {}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.Date.ISO8601FormatStyle.TimeSeparator : Swift.Hashable {}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.Date.ISO8601FormatStyle.TimeSeparator : Swift.RawRepresentable {}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.Date.ISO8601FormatStyle.DateTimeSeparator : Swift.Equatable {}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.Date.ISO8601FormatStyle.DateTimeSeparator : Swift.Hashable {}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.Date.ISO8601FormatStyle.DateTimeSeparator : Swift.RawRepresentable {}
extension Foundation.Calendar.Identifier : Swift.Equatable {}
extension Foundation.Calendar.Identifier : Swift.Hashable {}
extension Foundation.Calendar.Component : Swift.Equatable {}
extension Foundation.Calendar.Component : Swift.Hashable {}
extension Foundation.Calendar.SearchDirection : Swift.Equatable {}
extension Foundation.Calendar.SearchDirection : Swift.Hashable {}
extension Foundation.Calendar.RepeatedTimePolicy : Swift.Equatable {}
extension Foundation.Calendar.RepeatedTimePolicy : Swift.Hashable {}
extension Foundation.Calendar.MatchingPolicy : Swift.Equatable {}
extension Foundation.Calendar.MatchingPolicy : Swift.Hashable {}
