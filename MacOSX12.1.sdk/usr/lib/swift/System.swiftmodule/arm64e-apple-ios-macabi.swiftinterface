// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 5.5.2 (swiftlang-1300.0.46.202 clang-1300.0.29.30)
// swift-module-flags: -target arm64e-apple-ios15.0-macabi -enable-objc-interop -enable-library-evolution -module-link-name swiftSystem -swift-version 5 -enforce-exclusivity=checked -O -module-name System
import Darwin
import Swift
import _Concurrency
@available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
@frozen public struct FileDescriptor : Swift.RawRepresentable, Swift.Hashable, Swift.Codable {
  @_alwaysEmitIntoClient public let rawValue: Swift.CInt
  @_alwaysEmitIntoClient public init(rawValue: Swift.CInt) { self.rawValue = rawValue }
  public typealias RawValue = Swift.CInt
}
@available(macOS 11, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
extension System.FileDescriptor {
  @_alwaysEmitIntoClient public static var standardInput: System.FileDescriptor {
    get { .init(rawValue: 0) }
  }
  @_alwaysEmitIntoClient public static var standardOutput: System.FileDescriptor {
    get { .init(rawValue: 1) }
  }
  @_alwaysEmitIntoClient public static var standardError: System.FileDescriptor {
    get { .init(rawValue: 2) }
  }
}
@available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
extension System.FileDescriptor {
  @frozen public struct AccessMode : Swift.RawRepresentable, Swift.Hashable, Swift.Codable {
    @_alwaysEmitIntoClient public var rawValue: Swift.CInt
    @_alwaysEmitIntoClient public init(rawValue: Swift.CInt) { self.rawValue = rawValue }
    @_alwaysEmitIntoClient public static var readOnly: System.FileDescriptor.AccessMode {
      get { AccessMode(rawValue: _O_RDONLY) }
    }
    @available(*, unavailable, renamed: "readOnly")
    @_alwaysEmitIntoClient public static var O_RDONLY: System.FileDescriptor.AccessMode {
      get { readOnly }
    }
    @_alwaysEmitIntoClient public static var writeOnly: System.FileDescriptor.AccessMode {
      get { AccessMode(rawValue: _O_WRONLY) }
    }
    @available(*, unavailable, renamed: "writeOnly")
    @_alwaysEmitIntoClient public static var O_WRONLY: System.FileDescriptor.AccessMode {
      get { writeOnly }
    }
    @_alwaysEmitIntoClient public static var readWrite: System.FileDescriptor.AccessMode {
      get { AccessMode(rawValue: _O_RDWR) }
    }
    @available(*, unavailable, renamed: "readWrite")
    @_alwaysEmitIntoClient public static var O_RDWR: System.FileDescriptor.AccessMode {
      get { readWrite }
    }
    public typealias RawValue = Swift.CInt
  }
  @frozen public struct OpenOptions : Swift.OptionSet, Swift.Hashable, Swift.Codable {
    @_alwaysEmitIntoClient public var rawValue: Swift.CInt
    @_alwaysEmitIntoClient public init(rawValue: Swift.CInt) { self.rawValue = rawValue }
    @_alwaysEmitIntoClient private init(_ raw: Swift.CInt) { self.init(rawValue: raw) }
    @_alwaysEmitIntoClient public static var nonBlocking: System.FileDescriptor.OpenOptions {
      get { OpenOptions(_O_NONBLOCK) }
    }
    @available(*, unavailable, renamed: "nonBlocking")
    @_alwaysEmitIntoClient public static var O_NONBLOCK: System.FileDescriptor.OpenOptions {
      get { nonBlocking }
    }
    @_alwaysEmitIntoClient public static var append: System.FileDescriptor.OpenOptions {
      get { OpenOptions(_O_APPEND) }
    }
    @available(*, unavailable, renamed: "append")
    @_alwaysEmitIntoClient public static var O_APPEND: System.FileDescriptor.OpenOptions {
      get { append }
    }
    @_alwaysEmitIntoClient public static var create: System.FileDescriptor.OpenOptions {
      get { OpenOptions(_O_CREAT) }
    }
    @available(*, unavailable, renamed: "create")
    @_alwaysEmitIntoClient public static var O_CREAT: System.FileDescriptor.OpenOptions {
      get { create }
    }
    @_alwaysEmitIntoClient public static var truncate: System.FileDescriptor.OpenOptions {
      get { OpenOptions(_O_TRUNC) }
    }
    @available(*, unavailable, renamed: "truncate")
    @_alwaysEmitIntoClient public static var O_TRUNC: System.FileDescriptor.OpenOptions {
      get { truncate }
    }
    @_alwaysEmitIntoClient public static var exclusiveCreate: System.FileDescriptor.OpenOptions {
      get { OpenOptions(_O_EXCL) }
    }
    @available(*, unavailable, renamed: "exclusiveCreate")
    @_alwaysEmitIntoClient public static var O_EXCL: System.FileDescriptor.OpenOptions {
      get { exclusiveCreate }
    }
    @_alwaysEmitIntoClient public static var sharedLock: System.FileDescriptor.OpenOptions {
      get { OpenOptions(_O_SHLOCK) }
    }
    @available(*, unavailable, renamed: "sharedLock")
    @_alwaysEmitIntoClient public static var O_SHLOCK: System.FileDescriptor.OpenOptions {
      get { sharedLock }
    }
    @_alwaysEmitIntoClient public static var exclusiveLock: System.FileDescriptor.OpenOptions {
      get { OpenOptions(_O_EXLOCK) }
    }
    @available(*, unavailable, renamed: "exclusiveLock")
    @_alwaysEmitIntoClient public static var O_EXLOCK: System.FileDescriptor.OpenOptions {
      get { exclusiveLock }
    }
    @_alwaysEmitIntoClient public static var noFollow: System.FileDescriptor.OpenOptions {
      get { OpenOptions(_O_NOFOLLOW) }
    }
    @available(*, unavailable, renamed: "noFollow")
    @_alwaysEmitIntoClient public static var O_NOFOLLOW: System.FileDescriptor.OpenOptions {
      get { noFollow }
    }
    @_alwaysEmitIntoClient public static var symlink: System.FileDescriptor.OpenOptions {
      get { OpenOptions(_O_SYMLINK) }
    }
    @available(*, unavailable, renamed: "symlink")
    @_alwaysEmitIntoClient public static var O_SYMLINK: System.FileDescriptor.OpenOptions {
      get { symlink }
    }
    @_alwaysEmitIntoClient public static var eventOnly: System.FileDescriptor.OpenOptions {
      get { OpenOptions(_O_EVTONLY) }
    }
    @available(*, unavailable, renamed: "eventOnly")
    @_alwaysEmitIntoClient public static var O_EVTONLY: System.FileDescriptor.OpenOptions {
      get { eventOnly }
    }
    @_alwaysEmitIntoClient public static var closeOnExec: System.FileDescriptor.OpenOptions {
      get { OpenOptions(_O_CLOEXEC) }
    }
    @available(*, unavailable, renamed: "closeOnExec")
    @_alwaysEmitIntoClient public static var O_CLOEXEC: System.FileDescriptor.OpenOptions {
      get { closeOnExec }
    }
    public typealias ArrayLiteralElement = System.FileDescriptor.OpenOptions
    public typealias Element = System.FileDescriptor.OpenOptions
    public typealias RawValue = Swift.CInt
  }
  @frozen public struct SeekOrigin : Swift.RawRepresentable, Swift.Hashable, Swift.Codable {
    @_alwaysEmitIntoClient public var rawValue: Swift.CInt
    @_alwaysEmitIntoClient public init(rawValue: Swift.CInt) { self.rawValue = rawValue }
    @_alwaysEmitIntoClient public static var start: System.FileDescriptor.SeekOrigin {
      get { SeekOrigin(rawValue: _SEEK_SET) }
    }
    @available(*, unavailable, renamed: "start")
    @_alwaysEmitIntoClient public static var SEEK_SET: System.FileDescriptor.SeekOrigin {
      get { start }
    }
    @_alwaysEmitIntoClient public static var current: System.FileDescriptor.SeekOrigin {
      get { SeekOrigin(rawValue: _SEEK_CUR) }
    }
    @available(*, unavailable, renamed: "current")
    @_alwaysEmitIntoClient public static var SEEK_CUR: System.FileDescriptor.SeekOrigin {
      get { current }
    }
    @_alwaysEmitIntoClient public static var end: System.FileDescriptor.SeekOrigin {
      get { SeekOrigin(rawValue: _SEEK_END) }
    }
    @available(*, unavailable, renamed: "end")
    @_alwaysEmitIntoClient public static var SEEK_END: System.FileDescriptor.SeekOrigin {
      get { end }
    }
    @_alwaysEmitIntoClient public static var nextHole: System.FileDescriptor.SeekOrigin {
      get { SeekOrigin(rawValue: _SEEK_HOLE) }
    }
    @available(*, unavailable, renamed: "nextHole")
    @_alwaysEmitIntoClient public static var SEEK_HOLE: System.FileDescriptor.SeekOrigin {
      get { nextHole }
    }
    @_alwaysEmitIntoClient public static var nextData: System.FileDescriptor.SeekOrigin {
      get { SeekOrigin(rawValue: _SEEK_DATA) }
    }
    @available(*, unavailable, renamed: "nextData")
    @_alwaysEmitIntoClient public static var SEEK_DATA: System.FileDescriptor.SeekOrigin {
      get { nextData }
    }
    public typealias RawValue = Swift.CInt
  }
}
@available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
extension System.FileDescriptor.AccessMode : Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible {
  @inline(never) public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
}
@available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
extension System.FileDescriptor.SeekOrigin : Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible {
  @inline(never) public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
}
@available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
extension System.FileDescriptor.OpenOptions : Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible {
  @inline(never) public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
}
@available(macOS 12, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
extension System.FilePath {
  public var isAbsolute: Swift.Bool {
    get
  }
  public var isRelative: Swift.Bool {
    get
  }
  public func starts(with other: System.FilePath) -> Swift.Bool
  public func ends(with other: System.FilePath) -> Swift.Bool
  public var isEmpty: Swift.Bool {
    get
  }
}
@available(macOS 12, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
extension System.FilePath {
  public var root: System.FilePath.Root? {
    get
    set
  }
  __consuming public func removingRoot() -> System.FilePath
}
@available(macOS 12, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
extension System.FilePath {
  public var lastComponent: System.FilePath.Component? {
    get
  }
  __consuming public func removingLastComponent() -> System.FilePath
  @discardableResult
  public mutating func removeLastComponent() -> Swift.Bool
}
@available(macOS 12, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
extension System.FilePath.Component {
  public var `extension`: Swift.String? {
    get
  }
  public var stem: Swift.String {
    get
  }
}
@available(macOS 12, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
extension System.FilePath {
  public var `extension`: Swift.String? {
    get
    set
  }
  public var stem: Swift.String? {
    get
  }
}
@available(macOS 12, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
extension System.FilePath {
  public var isLexicallyNormal: Swift.Bool {
    get
  }
  public mutating func lexicallyNormalize()
  __consuming public func lexicallyNormalized() -> System.FilePath
  __consuming public func lexicallyResolving(_ subpath: __owned System.FilePath) -> System.FilePath?
}
@available(macOS 12, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
extension System.FilePath {
  public mutating func removePrefix(_ prefix: System.FilePath) -> Swift.Bool
  public mutating func append(_ component: __owned System.FilePath.Component)
  public mutating func append<C>(_ components: __owned C) where C : Swift.Collection, C.Element == System.FilePath.Component
  public mutating func append(_ other: __owned Swift.String)
  __consuming public func appending(_ other: __owned System.FilePath.Component) -> System.FilePath
  __consuming public func appending<C>(_ components: __owned C) -> System.FilePath where C : Swift.Collection, C.Element == System.FilePath.Component
  __consuming public func appending(_ other: __owned Swift.String) -> System.FilePath
  public mutating func push(_ other: __owned System.FilePath)
  __consuming public func pushing(_ other: __owned System.FilePath) -> System.FilePath
  public mutating func removeAll(keepingCapacity: Swift.Bool = false)
  public mutating func reserveCapacity(_ minimumCapacity: Swift.Int)
}
@available(macOS 12, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
extension System.FilePath {
  @available(*, unavailable, renamed: "removingLastComponent()")
  public var dirname: System.FilePath {
    get
  }
  @available(*, unavailable, renamed: "lastComponent")
  public var basename: System.FilePath.Component? {
    get
  }
}
@available(macOS 12, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
extension Swift.String {
  public init(platformString: Swift.UnsafePointer<System.CInterop.PlatformChar>)
  public init?(validatingPlatformString platformString: Swift.UnsafePointer<System.CInterop.PlatformChar>)
  public func withPlatformString<Result>(_ body: (Swift.UnsafePointer<System.CInterop.PlatformChar>) throws -> Result) rethrows -> Result
}
@available(macOS 12, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
extension System.FilePath {
  public struct Root {
  }
  public struct Component {
  }
}
@available(macOS 12, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
extension System.FilePath.Component {
  @frozen public enum Kind {
    case currentDirectory
    case parentDirectory
    case regular
    public static func == (a: System.FilePath.Component.Kind, b: System.FilePath.Component.Kind) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public var kind: System.FilePath.Component.Kind {
    get
  }
}
@available(macOS 12, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
extension System.FilePath.Component {
  public func encode(to encoder: Swift.Encoder) throws
  public var hashValue: Swift.Int {
    get
  }
  public init(from decoder: Swift.Decoder) throws
}
@available(macOS 12, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
extension System.FilePath.Root {
  public func encode(to encoder: Swift.Encoder) throws
  public var hashValue: Swift.Int {
    get
  }
  public init(from decoder: Swift.Decoder) throws
}
@available(macOS 12, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
extension System.FilePath {
  public struct ComponentView {
  }
  public var components: System.FilePath.ComponentView {
    __consuming get
    _modify
  }
}
@available(macOS 12, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
extension System.FilePath.ComponentView : Swift.BidirectionalCollection {
  public typealias Element = System.FilePath.Component
  public struct Index : Swift.Comparable, Swift.Hashable {
    public static func < (lhs: System.FilePath.ComponentView.Index, rhs: System.FilePath.ComponentView.Index) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: System.FilePath.ComponentView.Index, b: System.FilePath.ComponentView.Index) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
  }
  public var startIndex: System.FilePath.ComponentView.Index {
    get
  }
  public var endIndex: System.FilePath.ComponentView.Index {
    get
  }
  public func index(after i: System.FilePath.ComponentView.Index) -> System.FilePath.ComponentView.Index
  public func index(before i: System.FilePath.ComponentView.Index) -> System.FilePath.ComponentView.Index
  public subscript(position: System.FilePath.ComponentView.Index) -> System.FilePath.Component {
    get
  }
  public typealias Indices = Swift.DefaultIndices<System.FilePath.ComponentView>
  public typealias Iterator = Swift.IndexingIterator<System.FilePath.ComponentView>
  public typealias SubSequence = Swift.Slice<System.FilePath.ComponentView>
}
@available(macOS 12, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
extension System.FilePath.ComponentView : Swift.RangeReplaceableCollection {
  public init()
  public mutating func replaceSubrange<C>(_ subrange: Swift.Range<System.FilePath.ComponentView.Index>, with newElements: C) where C : Swift.Collection, C.Element == System.FilePath.ComponentView.Element
}
@available(macOS 12, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
extension System.FilePath {
  public init<C>(root: System.FilePath.Root?, _ components: C) where C : Swift.Collection, C.Element == System.FilePath.Component
  public init(root: System.FilePath.Root?, components: System.FilePath.Component...)
  public init(root: System.FilePath.Root?, _ components: System.FilePath.ComponentView.SubSequence)
}
@available(macOS 12, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
extension System.FilePath.ComponentView {
  public func encode(to encoder: Swift.Encoder) throws
  public var hashValue: Swift.Int {
    get
  }
  public init(from decoder: Swift.Decoder) throws
}
@available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
@frozen public struct FilePermissions : Swift.OptionSet, Swift.Hashable, Swift.Codable {
  @_alwaysEmitIntoClient public let rawValue: System.CModeT
  @_alwaysEmitIntoClient public init(rawValue: System.CModeT) { self.rawValue = rawValue }
  @_alwaysEmitIntoClient private init(_ raw: System.CModeT) { self.init(rawValue: raw) }
  @_alwaysEmitIntoClient public static var otherRead: System.FilePermissions {
    get { FilePermissions(0o4) }
  }
  @_alwaysEmitIntoClient public static var otherWrite: System.FilePermissions {
    get { FilePermissions(0o2) }
  }
  @_alwaysEmitIntoClient public static var otherExecute: System.FilePermissions {
    get { FilePermissions(0o1) }
  }
  @_alwaysEmitIntoClient public static var otherReadWrite: System.FilePermissions {
    get { FilePermissions(0o6) }
  }
  @_alwaysEmitIntoClient public static var otherReadExecute: System.FilePermissions {
    get { FilePermissions(0o5) }
  }
  @_alwaysEmitIntoClient public static var otherWriteExecute: System.FilePermissions {
    get { FilePermissions(0o3) }
  }
  @_alwaysEmitIntoClient public static var otherReadWriteExecute: System.FilePermissions {
    get { FilePermissions(0o7) }
  }
  @_alwaysEmitIntoClient public static var groupRead: System.FilePermissions {
    get { FilePermissions(0o40) }
  }
  @_alwaysEmitIntoClient public static var groupWrite: System.FilePermissions {
    get { FilePermissions(0o20) }
  }
  @_alwaysEmitIntoClient public static var groupExecute: System.FilePermissions {
    get { FilePermissions(0o10) }
  }
  @_alwaysEmitIntoClient public static var groupReadWrite: System.FilePermissions {
    get { FilePermissions(0o60) }
  }
  @_alwaysEmitIntoClient public static var groupReadExecute: System.FilePermissions {
    get { FilePermissions(0o50) }
  }
  @_alwaysEmitIntoClient public static var groupWriteExecute: System.FilePermissions {
    get { FilePermissions(0o30) }
  }
  @_alwaysEmitIntoClient public static var groupReadWriteExecute: System.FilePermissions {
    get { FilePermissions(0o70) }
  }
  @_alwaysEmitIntoClient public static var ownerRead: System.FilePermissions {
    get { FilePermissions(0o400) }
  }
  @_alwaysEmitIntoClient public static var ownerWrite: System.FilePermissions {
    get { FilePermissions(0o200) }
  }
  @_alwaysEmitIntoClient public static var ownerExecute: System.FilePermissions {
    get { FilePermissions(0o100) }
  }
  @_alwaysEmitIntoClient public static var ownerReadWrite: System.FilePermissions {
    get { FilePermissions(0o600) }
  }
  @_alwaysEmitIntoClient public static var ownerReadExecute: System.FilePermissions {
    get { FilePermissions(0o500) }
  }
  @_alwaysEmitIntoClient public static var ownerWriteExecute: System.FilePermissions {
    get { FilePermissions(0o300) }
  }
  @_alwaysEmitIntoClient public static var ownerReadWriteExecute: System.FilePermissions {
    get { FilePermissions(0o700) }
  }
  @_alwaysEmitIntoClient public static var setUserID: System.FilePermissions {
    get { FilePermissions(0o4000) }
  }
  @_alwaysEmitIntoClient public static var setGroupID: System.FilePermissions {
    get { FilePermissions(0o2000) }
  }
  @_alwaysEmitIntoClient public static var saveText: System.FilePermissions {
    get { FilePermissions(0o1000) }
  }
  public typealias ArrayLiteralElement = System.FilePermissions
  public typealias Element = System.FilePermissions
  public typealias RawValue = System.CModeT
}
@available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
extension System.FilePermissions : Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible {
  @inline(never) public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
}
@available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
public typealias CModeT = Darwin.mode_t
@available(macOS 12, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
public enum CInterop {
  public typealias Char = Swift.CChar
  public typealias PlatformChar = System.CInterop.Char
  public typealias PlatformUnicodeEncoding = Swift.UTF8
  public typealias Mode = Darwin.mode_t
}
@_alwaysEmitIntoClient internal var _ERRNO_NOT_USED: Swift.CInt {
  get { 0 }
}
@_alwaysEmitIntoClient internal var _EPERM: Swift.CInt {
  get { EPERM }
}
@_alwaysEmitIntoClient internal var _ENOENT: Swift.CInt {
  get { ENOENT }
}
@_alwaysEmitIntoClient internal var _ESRCH: Swift.CInt {
  get { ESRCH }
}
@_alwaysEmitIntoClient internal var _EINTR: Swift.CInt {
  get { EINTR }
}
@_alwaysEmitIntoClient internal var _EIO: Swift.CInt {
  get { EIO }
}
@_alwaysEmitIntoClient internal var _ENXIO: Swift.CInt {
  get { ENXIO }
}
@_alwaysEmitIntoClient internal var _E2BIG: Swift.CInt {
  get { E2BIG }
}
@_alwaysEmitIntoClient internal var _ENOEXEC: Swift.CInt {
  get { ENOEXEC }
}
@_alwaysEmitIntoClient internal var _EBADF: Swift.CInt {
  get { EBADF }
}
@_alwaysEmitIntoClient internal var _ECHILD: Swift.CInt {
  get { ECHILD }
}
@_alwaysEmitIntoClient internal var _EDEADLK: Swift.CInt {
  get { EDEADLK }
}
@_alwaysEmitIntoClient internal var _ENOMEM: Swift.CInt {
  get { ENOMEM }
}
@_alwaysEmitIntoClient internal var _EACCES: Swift.CInt {
  get { EACCES }
}
@_alwaysEmitIntoClient internal var _EFAULT: Swift.CInt {
  get { EFAULT }
}
@_alwaysEmitIntoClient internal var _ENOTBLK: Swift.CInt {
  get { ENOTBLK }
}
@_alwaysEmitIntoClient internal var _EBUSY: Swift.CInt {
  get { EBUSY }
}
@_alwaysEmitIntoClient internal var _EEXIST: Swift.CInt {
  get { EEXIST }
}
@_alwaysEmitIntoClient internal var _EXDEV: Swift.CInt {
  get { EXDEV }
}
@_alwaysEmitIntoClient internal var _ENODEV: Swift.CInt {
  get { ENODEV }
}
@_alwaysEmitIntoClient internal var _ENOTDIR: Swift.CInt {
  get { ENOTDIR }
}
@_alwaysEmitIntoClient internal var _EISDIR: Swift.CInt {
  get { EISDIR }
}
@_alwaysEmitIntoClient internal var _EINVAL: Swift.CInt {
  get { EINVAL }
}
@_alwaysEmitIntoClient internal var _ENFILE: Swift.CInt {
  get { ENFILE }
}
@_alwaysEmitIntoClient internal var _EMFILE: Swift.CInt {
  get { EMFILE }
}
@_alwaysEmitIntoClient internal var _ENOTTY: Swift.CInt {
  get { ENOTTY }
}
@_alwaysEmitIntoClient internal var _ETXTBSY: Swift.CInt {
  get { ETXTBSY }
}
@_alwaysEmitIntoClient internal var _EFBIG: Swift.CInt {
  get { EFBIG }
}
@_alwaysEmitIntoClient internal var _ENOSPC: Swift.CInt {
  get { ENOSPC }
}
@_alwaysEmitIntoClient internal var _ESPIPE: Swift.CInt {
  get { ESPIPE }
}
@_alwaysEmitIntoClient internal var _EROFS: Swift.CInt {
  get { EROFS }
}
@_alwaysEmitIntoClient internal var _EMLINK: Swift.CInt {
  get { EMLINK }
}
@_alwaysEmitIntoClient internal var _EPIPE: Swift.CInt {
  get { EPIPE }
}
@_alwaysEmitIntoClient internal var _EDOM: Swift.CInt {
  get { EDOM }
}
@_alwaysEmitIntoClient internal var _ERANGE: Swift.CInt {
  get { ERANGE }
}
@_alwaysEmitIntoClient internal var _EAGAIN: Swift.CInt {
  get { EAGAIN }
}
@_alwaysEmitIntoClient internal var _EWOULDBLOCK: Swift.CInt {
  get { EWOULDBLOCK }
}
@_alwaysEmitIntoClient internal var _EINPROGRESS: Swift.CInt {
  get { EINPROGRESS }
}
@_alwaysEmitIntoClient internal var _EALREADY: Swift.CInt {
  get { EALREADY }
}
@_alwaysEmitIntoClient internal var _ENOTSOCK: Swift.CInt {
  get { ENOTSOCK }
}
@_alwaysEmitIntoClient internal var _EDESTADDRREQ: Swift.CInt {
  get { EDESTADDRREQ }
}
@_alwaysEmitIntoClient internal var _EMSGSIZE: Swift.CInt {
  get { EMSGSIZE }
}
@_alwaysEmitIntoClient internal var _EPROTOTYPE: Swift.CInt {
  get { EPROTOTYPE }
}
@_alwaysEmitIntoClient internal var _ENOPROTOOPT: Swift.CInt {
  get { ENOPROTOOPT }
}
@_alwaysEmitIntoClient internal var _EPROTONOSUPPORT: Swift.CInt {
  get { EPROTONOSUPPORT }
}
@_alwaysEmitIntoClient internal var _ESOCKTNOSUPPORT: Swift.CInt {
  get { ESOCKTNOSUPPORT }
}
@_alwaysEmitIntoClient internal var _ENOTSUP: Swift.CInt {
  get { ENOTSUP }
}
@_alwaysEmitIntoClient internal var _EPFNOSUPPORT: Swift.CInt {
  get { EPFNOSUPPORT }
}
@_alwaysEmitIntoClient internal var _EAFNOSUPPORT: Swift.CInt {
  get { EAFNOSUPPORT }
}
@_alwaysEmitIntoClient internal var _EADDRINUSE: Swift.CInt {
  get { EADDRINUSE }
}
@_alwaysEmitIntoClient internal var _EADDRNOTAVAIL: Swift.CInt {
  get { EADDRNOTAVAIL }
}
@_alwaysEmitIntoClient internal var _ENETDOWN: Swift.CInt {
  get { ENETDOWN }
}
@_alwaysEmitIntoClient internal var _ENETUNREACH: Swift.CInt {
  get { ENETUNREACH }
}
@_alwaysEmitIntoClient internal var _ENETRESET: Swift.CInt {
  get { ENETRESET }
}
@_alwaysEmitIntoClient internal var _ECONNABORTED: Swift.CInt {
  get { ECONNABORTED }
}
@_alwaysEmitIntoClient internal var _ECONNRESET: Swift.CInt {
  get { ECONNRESET }
}
@_alwaysEmitIntoClient internal var _ENOBUFS: Swift.CInt {
  get { ENOBUFS }
}
@_alwaysEmitIntoClient internal var _EISCONN: Swift.CInt {
  get { EISCONN }
}
@_alwaysEmitIntoClient internal var _ENOTCONN: Swift.CInt {
  get { ENOTCONN }
}
@_alwaysEmitIntoClient internal var _ESHUTDOWN: Swift.CInt {
  get { ESHUTDOWN }
}
@_alwaysEmitIntoClient internal var _ETOOMANYREFS: Swift.CInt {
  get { ETOOMANYREFS }
}
@_alwaysEmitIntoClient internal var _ETIMEDOUT: Swift.CInt {
  get { ETIMEDOUT }
}
@_alwaysEmitIntoClient internal var _ECONNREFUSED: Swift.CInt {
  get { ECONNREFUSED }
}
@_alwaysEmitIntoClient internal var _ELOOP: Swift.CInt {
  get { ELOOP }
}
@_alwaysEmitIntoClient internal var _ENAMETOOLONG: Swift.CInt {
  get { ENAMETOOLONG }
}
@_alwaysEmitIntoClient internal var _EHOSTDOWN: Swift.CInt {
  get { EHOSTDOWN }
}
@_alwaysEmitIntoClient internal var _EHOSTUNREACH: Swift.CInt {
  get { EHOSTUNREACH }
}
@_alwaysEmitIntoClient internal var _ENOTEMPTY: Swift.CInt {
  get { ENOTEMPTY }
}
@_alwaysEmitIntoClient internal var _EPROCLIM: Swift.CInt {
  get { EPROCLIM }
}
@_alwaysEmitIntoClient internal var _EUSERS: Swift.CInt {
  get { EUSERS }
}
@_alwaysEmitIntoClient internal var _EDQUOT: Swift.CInt {
  get { EDQUOT }
}
@_alwaysEmitIntoClient internal var _ESTALE: Swift.CInt {
  get { ESTALE }
}
@_alwaysEmitIntoClient internal var _EREMOTE: Swift.CInt {
  get { EREMOTE }
}
@_alwaysEmitIntoClient internal var _EBADRPC: Swift.CInt {
  get { EBADRPC }
}
@_alwaysEmitIntoClient internal var _ERPCMISMATCH: Swift.CInt {
  get { ERPCMISMATCH }
}
@_alwaysEmitIntoClient internal var _EPROGUNAVAIL: Swift.CInt {
  get { EPROGUNAVAIL }
}
@_alwaysEmitIntoClient internal var _EPROGMISMATCH: Swift.CInt {
  get { EPROGMISMATCH }
}
@_alwaysEmitIntoClient internal var _EPROCUNAVAIL: Swift.CInt {
  get { EPROCUNAVAIL }
}
@_alwaysEmitIntoClient internal var _ENOLCK: Swift.CInt {
  get { ENOLCK }
}
@_alwaysEmitIntoClient internal var _ENOSYS: Swift.CInt {
  get { ENOSYS }
}
@_alwaysEmitIntoClient internal var _EFTYPE: Swift.CInt {
  get { EFTYPE }
}
@_alwaysEmitIntoClient internal var _EAUTH: Swift.CInt {
  get { EAUTH }
}
@_alwaysEmitIntoClient internal var _ENEEDAUTH: Swift.CInt {
  get { ENEEDAUTH }
}
@_alwaysEmitIntoClient internal var _EPWROFF: Swift.CInt {
  get { EPWROFF }
}
@_alwaysEmitIntoClient internal var _EDEVERR: Swift.CInt {
  get { EDEVERR }
}
@_alwaysEmitIntoClient internal var _EOVERFLOW: Swift.CInt {
  get { EOVERFLOW }
}
@_alwaysEmitIntoClient internal var _EBADEXEC: Swift.CInt {
  get { EBADEXEC }
}
@_alwaysEmitIntoClient internal var _EBADARCH: Swift.CInt {
  get { EBADARCH }
}
@_alwaysEmitIntoClient internal var _ESHLIBVERS: Swift.CInt {
  get { ESHLIBVERS }
}
@_alwaysEmitIntoClient internal var _EBADMACHO: Swift.CInt {
  get { EBADMACHO }
}
@_alwaysEmitIntoClient internal var _ECANCELED: Swift.CInt {
  get { ECANCELED }
}
@_alwaysEmitIntoClient internal var _EIDRM: Swift.CInt {
  get { EIDRM }
}
@_alwaysEmitIntoClient internal var _ENOMSG: Swift.CInt {
  get { ENOMSG }
}
@_alwaysEmitIntoClient internal var _EILSEQ: Swift.CInt {
  get { EILSEQ }
}
@_alwaysEmitIntoClient internal var _ENOATTR: Swift.CInt {
  get { ENOATTR }
}
@_alwaysEmitIntoClient internal var _EBADMSG: Swift.CInt {
  get { EBADMSG }
}
@_alwaysEmitIntoClient internal var _EMULTIHOP: Swift.CInt {
  get { EMULTIHOP }
}
@_alwaysEmitIntoClient internal var _ENODATA: Swift.CInt {
  get { ENODATA }
}
@_alwaysEmitIntoClient internal var _ENOLINK: Swift.CInt {
  get { ENOLINK }
}
@_alwaysEmitIntoClient internal var _ENOSR: Swift.CInt {
  get { ENOSR }
}
@_alwaysEmitIntoClient internal var _ENOSTR: Swift.CInt {
  get { ENOSTR }
}
@_alwaysEmitIntoClient internal var _EPROTO: Swift.CInt {
  get { EPROTO }
}
@_alwaysEmitIntoClient internal var _ETIME: Swift.CInt {
  get { ETIME }
}
@_alwaysEmitIntoClient internal var _EOPNOTSUPP: Swift.CInt {
  get { EOPNOTSUPP }
}
@_alwaysEmitIntoClient internal var _ENOPOLICY: Swift.CInt {
  get { ENOPOLICY }
}
@_alwaysEmitIntoClient internal var _ENOTRECOVERABLE: Swift.CInt {
  get { ENOTRECOVERABLE }
}
@_alwaysEmitIntoClient internal var _EOWNERDEAD: Swift.CInt {
  get { EOWNERDEAD }
}
@_alwaysEmitIntoClient internal var _EQFULL: Swift.CInt {
  get { EQFULL }
}
@_alwaysEmitIntoClient internal var _ELAST: Swift.CInt {
  get { ELAST }
}
@_alwaysEmitIntoClient internal var _O_RDONLY: Swift.CInt {
  get { O_RDONLY }
}
@_alwaysEmitIntoClient internal var _O_WRONLY: Swift.CInt {
  get { O_WRONLY }
}
@_alwaysEmitIntoClient internal var _O_RDWR: Swift.CInt {
  get { O_RDWR }
}
@_alwaysEmitIntoClient internal var _O_ACCMODE: Swift.CInt {
  get { O_ACCMODE }
}
@_alwaysEmitIntoClient internal var _O_NONBLOCK: Swift.CInt {
  get { O_NONBLOCK }
}
@_alwaysEmitIntoClient internal var _O_APPEND: Swift.CInt {
  get { O_APPEND }
}
@_alwaysEmitIntoClient internal var _O_SHLOCK: Swift.CInt {
  get { O_SHLOCK }
}
@_alwaysEmitIntoClient internal var _O_EXLOCK: Swift.CInt {
  get { O_EXLOCK }
}
@_alwaysEmitIntoClient internal var _O_ASYNC: Swift.CInt {
  get { O_ASYNC }
}
@_alwaysEmitIntoClient internal var _O_NOFOLLOW: Swift.CInt {
  get { O_NOFOLLOW }
}
@_alwaysEmitIntoClient internal var _O_CREAT: Swift.CInt {
  get { O_CREAT }
}
@_alwaysEmitIntoClient internal var _O_TRUNC: Swift.CInt {
  get { O_TRUNC }
}
@_alwaysEmitIntoClient internal var _O_EXCL: Swift.CInt {
  get { O_EXCL }
}
@_alwaysEmitIntoClient internal var _O_EVTONLY: Swift.CInt {
  get { O_EVTONLY }
}
@_alwaysEmitIntoClient internal var _O_NOCTTY: Swift.CInt {
  get { O_NOCTTY }
}
@_alwaysEmitIntoClient internal var _O_DIRECTORY: Swift.CInt {
  get { O_DIRECTORY }
}
@_alwaysEmitIntoClient internal var _O_SYMLINK: Swift.CInt {
  get { O_SYMLINK }
}
@_alwaysEmitIntoClient internal var _O_CLOEXEC: Swift.CInt {
  get { O_CLOEXEC }
}
@_alwaysEmitIntoClient internal var _SEEK_SET: Swift.CInt {
  get { SEEK_SET }
}
@_alwaysEmitIntoClient internal var _SEEK_CUR: Swift.CInt {
  get { SEEK_CUR }
}
@_alwaysEmitIntoClient internal var _SEEK_END: Swift.CInt {
  get { SEEK_END }
}
@_alwaysEmitIntoClient internal var _SEEK_HOLE: Swift.CInt {
  get { SEEK_HOLE }
}
@_alwaysEmitIntoClient internal var _SEEK_DATA: Swift.CInt {
  get { SEEK_DATA }
}
@available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
extension System.FileDescriptor {
  public func closeAfter<R>(_ body: () throws -> R) throws -> R
  @discardableResult
  @_alwaysEmitIntoClient public func writeAll<S>(_ sequence: S) throws -> Swift.Int where S : Swift.Sequence, S.Element == Swift.UInt8 {
    return try _writeAll(sequence).get()
  }
  @usableFromInline
  internal func _writeAll<S>(_ sequence: S) -> Swift.Result<Swift.Int, System.Errno> where S : Swift.Sequence, S.Element == Swift.UInt8
  @discardableResult
  @_alwaysEmitIntoClient public func writeAll<S>(toAbsoluteOffset offset: Swift.Int64, _ sequence: S) throws -> Swift.Int where S : Swift.Sequence, S.Element == Swift.UInt8 {
    try _writeAll(toAbsoluteOffset: offset, sequence).get()
  }
  @usableFromInline
  internal func _writeAll<S>(toAbsoluteOffset offset: Swift.Int64, _ sequence: S) -> Swift.Result<Swift.Int, System.Errno> where S : Swift.Sequence, S.Element == Swift.UInt8
}
@available(macOS 12, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
extension System.FilePath {
  public init(platformString: Swift.UnsafePointer<System.CInterop.PlatformChar>)
  @_alwaysEmitIntoClient public func withPlatformString<Result>(_ body: (Swift.UnsafePointer<System.CInterop.PlatformChar>) throws -> Result) rethrows -> Result {
    // For backwards deployment, call withCString if available.
    return try withCString(body)
  }
}
@available(macOS 12, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
extension System.FilePath.Component {
  public init?(platformString: Swift.UnsafePointer<System.CInterop.PlatformChar>)
  public func withPlatformString<Result>(_ body: (Swift.UnsafePointer<System.CInterop.PlatformChar>) throws -> Result) rethrows -> Result
}
@available(macOS 12, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
extension System.FilePath.Root {
  public init?(platformString: Swift.UnsafePointer<System.CInterop.PlatformChar>)
  public func withPlatformString<Result>(_ body: (Swift.UnsafePointer<System.CInterop.PlatformChar>) throws -> Result) rethrows -> Result
}
@available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
extension System.FilePath : Swift.ExpressibleByStringLiteral {
  public init(stringLiteral: Swift.String)
  public init(_ string: Swift.String)
  public typealias ExtendedGraphemeClusterLiteralType = Swift.String
  public typealias StringLiteralType = Swift.String
  public typealias UnicodeScalarLiteralType = Swift.String
}
@available(macOS 12, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
extension System.FilePath.Component : Swift.ExpressibleByStringLiteral {
  public init(stringLiteral: Swift.String)
  public init?(_ string: Swift.String)
  public typealias ExtendedGraphemeClusterLiteralType = Swift.String
  public typealias StringLiteralType = Swift.String
  public typealias UnicodeScalarLiteralType = Swift.String
}
@available(macOS 12, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
extension System.FilePath.Root : Swift.ExpressibleByStringLiteral {
  public init(stringLiteral: Swift.String)
  public init?(_ string: Swift.String)
  public typealias ExtendedGraphemeClusterLiteralType = Swift.String
  public typealias StringLiteralType = Swift.String
  public typealias UnicodeScalarLiteralType = Swift.String
}
@available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
extension System.FilePath : Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible {
  @inline(never) public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
}
@available(macOS 12, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
extension System.FilePath.Component : Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible {
  @inline(never) public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
}
@available(macOS 12, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
extension System.FilePath.Root : Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible {
  @inline(never) public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
}
@available(macOS 12, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
extension System.FilePath {
  public var string: Swift.String {
    get
  }
}
@available(macOS 12, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
extension System.FilePath.Component {
  public var string: Swift.String {
    get
  }
}
@available(macOS 12, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
extension System.FilePath.Root {
  public var string: Swift.String {
    get
  }
}
@available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
extension Swift.String {
  public init(decoding path: System.FilePath)
  public init?(validating path: System.FilePath)
}
@available(macOS 12, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
extension Swift.String {
  public init(decoding component: System.FilePath.Component)
  public init?(validating component: System.FilePath.Component)
}
@available(macOS 12, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
extension Swift.String {
  public init(decoding root: System.FilePath.Root)
  public init?(validating root: System.FilePath.Root)
}
extension Swift.String {
  @available(macOS, introduced: 11.0, deprecated: 12.0, renamed: "init(decoding:)")
  @available(iOS, introduced: 14.0, deprecated: 15.0, renamed: "init(decoding:)")
  @available(watchOS, introduced: 7.0, deprecated: 8.0, renamed: "init(decoding:)")
  @available(tvOS, introduced: 14.0, deprecated: 15.0, renamed: "init(decoding:)")
  public init(_ path: System.FilePath)
  @available(macOS, introduced: 11.0, deprecated: 12.0, renamed: "init(validating:)")
  @available(iOS, introduced: 14.0, deprecated: 15.0, renamed: "init(validating:)")
  @available(watchOS, introduced: 7.0, deprecated: 8.0, renamed: "init(validating:)")
  @available(tvOS, introduced: 14.0, deprecated: 15.0, renamed: "init(validating:)")
  public init?(validatingUTF8 path: System.FilePath)
}
@available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
extension System.FilePath {
  public init(cString: Swift.UnsafePointer<Swift.CChar>)
  public func withCString<Result>(_ body: (Swift.UnsafePointer<Swift.CChar>) throws -> Result) rethrows -> Result
}
@available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
public struct FilePath {
  public init()
}
@available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
extension System.FilePath {
  public var length: Swift.Int {
    get
  }
}
@available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
extension System.FilePath : Swift.Hashable, Swift.Codable {
  public static func == (a: System.FilePath, b: System.FilePath) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public func encode(to encoder: Swift.Encoder) throws
  public var hashValue: Swift.Int {
    get
  }
  public init(from decoder: Swift.Decoder) throws
}
@available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
extension System.FileDescriptor {
  @_alwaysEmitIntoClient public static func open(_ path: System.FilePath, _ mode: System.FileDescriptor.AccessMode, options: System.FileDescriptor.OpenOptions = FileDescriptor.OpenOptions(), permissions: System.FilePermissions? = nil, retryOnInterrupt: Swift.Bool = true) throws -> System.FileDescriptor {
    try path.withCString {
      try FileDescriptor.open(
        $0, mode, options: options, permissions: permissions, retryOnInterrupt: retryOnInterrupt)
    }
  }
  @_alwaysEmitIntoClient public static func open(_ path: Swift.UnsafePointer<System.CInterop.PlatformChar>, _ mode: System.FileDescriptor.AccessMode, options: System.FileDescriptor.OpenOptions = FileDescriptor.OpenOptions(), permissions: System.FilePermissions? = nil, retryOnInterrupt: Swift.Bool = true) throws -> System.FileDescriptor {
    try FileDescriptor._open(
      path, mode, options: options, permissions: permissions, retryOnInterrupt: retryOnInterrupt
    ).get()
  }
  @usableFromInline
  internal static func _open(_ path: Swift.UnsafePointer<System.CInterop.PlatformChar>, _ mode: System.FileDescriptor.AccessMode, options: System.FileDescriptor.OpenOptions, permissions: System.FilePermissions?, retryOnInterrupt: Swift.Bool = true) -> Swift.Result<System.FileDescriptor, System.Errno>
  @_alwaysEmitIntoClient public func close() throws { try _close().get() }
  @usableFromInline
  internal func _close() -> Swift.Result<(), System.Errno>
  @discardableResult
  @_alwaysEmitIntoClient public func seek(offset: Swift.Int64, from whence: System.FileDescriptor.SeekOrigin) throws -> Swift.Int64 {
    try _seek(offset: offset, from: whence).get()
  }
  @usableFromInline
  internal func _seek(offset: Swift.Int64, from whence: System.FileDescriptor.SeekOrigin) -> Swift.Result<Swift.Int64, System.Errno>
  @available(*, unavailable, renamed: "seek")
  @_alwaysEmitIntoClient public func lseek(offset: Swift.Int64, from whence: System.FileDescriptor.SeekOrigin) throws -> Swift.Int64 {
    try seek(offset: offset, from: whence)
  }
  @_alwaysEmitIntoClient public func read(into buffer: Swift.UnsafeMutableRawBufferPointer, retryOnInterrupt: Swift.Bool = true) throws -> Swift.Int {
    try _read(into: buffer, retryOnInterrupt: retryOnInterrupt).get()
  }
  @usableFromInline
  internal func _read(into buffer: Swift.UnsafeMutableRawBufferPointer, retryOnInterrupt: Swift.Bool = true) throws -> Swift.Result<Swift.Int, System.Errno>
  @_alwaysEmitIntoClient public func read(fromAbsoluteOffset offset: Swift.Int64, into buffer: Swift.UnsafeMutableRawBufferPointer, retryOnInterrupt: Swift.Bool = true) throws -> Swift.Int {
    try _read(
      fromAbsoluteOffset: offset,
      into: buffer,
      retryOnInterrupt: retryOnInterrupt
    ).get()
  }
  @usableFromInline
  internal func _read(fromAbsoluteOffset offset: Swift.Int64, into buffer: Swift.UnsafeMutableRawBufferPointer, retryOnInterrupt: Swift.Bool) -> Swift.Result<Swift.Int, System.Errno>
  @available(*, unavailable, renamed: "read")
  @_alwaysEmitIntoClient public func pread(fromAbsoluteOffset offset: Swift.Int64, into buffer: Swift.UnsafeMutableRawBufferPointer, retryOnInterrupt: Swift.Bool = true) throws -> Swift.Int {
    try read(
      fromAbsoluteOffset: offset,
      into: buffer,
      retryOnInterrupt: retryOnInterrupt)
  }
  @_alwaysEmitIntoClient public func write(_ buffer: Swift.UnsafeRawBufferPointer, retryOnInterrupt: Swift.Bool = true) throws -> Swift.Int {
    try _write(buffer, retryOnInterrupt: retryOnInterrupt).get()
  }
  @usableFromInline
  internal func _write(_ buffer: Swift.UnsafeRawBufferPointer, retryOnInterrupt: Swift.Bool) -> Swift.Result<Swift.Int, System.Errno>
  @_alwaysEmitIntoClient public func write(toAbsoluteOffset offset: Swift.Int64, _ buffer: Swift.UnsafeRawBufferPointer, retryOnInterrupt: Swift.Bool = true) throws -> Swift.Int {
    try _write(toAbsoluteOffset: offset, buffer, retryOnInterrupt: retryOnInterrupt).get()
  }
  @usableFromInline
  internal func _write(toAbsoluteOffset offset: Swift.Int64, _ buffer: Swift.UnsafeRawBufferPointer, retryOnInterrupt: Swift.Bool) -> Swift.Result<Swift.Int, System.Errno>
  @available(*, unavailable, renamed: "write")
  @_alwaysEmitIntoClient public func pwrite(toAbsoluteOffset offset: Swift.Int64, into buffer: Swift.UnsafeRawBufferPointer, retryOnInterrupt: Swift.Bool = true) throws -> Swift.Int {
    try write(
      toAbsoluteOffset: offset,
      buffer,
      retryOnInterrupt: retryOnInterrupt)
  }
}
@available(macOS 12, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
extension System.FileDescriptor {
  @_alwaysEmitIntoClient public func duplicate(as target: System.FileDescriptor? = nil, retryOnInterrupt: Swift.Bool = true) throws -> System.FileDescriptor {
    try _duplicate(as: target, retryOnInterrupt: retryOnInterrupt).get()
  }
  @usableFromInline
  internal func _duplicate(as target: System.FileDescriptor?, retryOnInterrupt: Swift.Bool) throws -> Swift.Result<System.FileDescriptor, System.Errno>
  @available(*, unavailable, renamed: "duplicate")
  @_alwaysEmitIntoClient public func dup() throws -> System.FileDescriptor {
    fatalError("Not implemented")
  }
  @available(*, unavailable, renamed: "duplicate")
  @_alwaysEmitIntoClient public func dup2() throws -> System.FileDescriptor {
    fatalError("Not implemented")
  }
}
@available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
@frozen public struct Errno : Swift.RawRepresentable, Swift.Error, Swift.Hashable, Swift.Codable {
  @_alwaysEmitIntoClient public let rawValue: Swift.CInt
  @_alwaysEmitIntoClient public init(rawValue: Swift.CInt) { self.rawValue = rawValue }
  @_alwaysEmitIntoClient private init(_ raw: Swift.CInt) { self.init(rawValue: raw) }
  @_alwaysEmitIntoClient public static var notUsed: System.Errno {
    get { Errno(_ERRNO_NOT_USED) }
  }
  @available(*, unavailable, renamed: "notUsed")
  @_alwaysEmitIntoClient public static var ERRNO_NOT_USED: System.Errno {
    get { notUsed }
  }
  @_alwaysEmitIntoClient public static var notPermitted: System.Errno {
    get { Errno(_EPERM) }
  }
  @available(*, unavailable, renamed: "notPermitted")
  @_alwaysEmitIntoClient public static var EPERM: System.Errno {
    get { notPermitted }
  }
  @_alwaysEmitIntoClient public static var noSuchFileOrDirectory: System.Errno {
    get { Errno(_ENOENT) }
  }
  @available(*, unavailable, renamed: "noSuchFileOrDirectory")
  @_alwaysEmitIntoClient public static var ENOENT: System.Errno {
    get { noSuchFileOrDirectory }
  }
  @_alwaysEmitIntoClient public static var noSuchProcess: System.Errno {
    get { Errno(_ESRCH) }
  }
  @available(*, unavailable, renamed: "noSuchProcess")
  @_alwaysEmitIntoClient public static var ESRCH: System.Errno {
    get { noSuchProcess }
  }
  @_alwaysEmitIntoClient public static var interrupted: System.Errno {
    get { Errno(_EINTR) }
  }
  @available(*, unavailable, renamed: "interrupted")
  @_alwaysEmitIntoClient public static var EINTR: System.Errno {
    get { interrupted }
  }
  @_alwaysEmitIntoClient public static var ioError: System.Errno {
    get { Errno(_EIO) }
  }
  @available(*, unavailable, renamed: "ioError")
  @_alwaysEmitIntoClient public static var EIO: System.Errno {
    get { ioError }
  }
  @_alwaysEmitIntoClient public static var noSuchAddressOrDevice: System.Errno {
    get { Errno(_ENXIO) }
  }
  @available(*, unavailable, renamed: "noSuchAddressOrDevice")
  @_alwaysEmitIntoClient public static var ENXIO: System.Errno {
    get { noSuchAddressOrDevice }
  }
  @_alwaysEmitIntoClient public static var argListTooLong: System.Errno {
    get { Errno(_E2BIG) }
  }
  @available(*, unavailable, renamed: "argListTooLong")
  @_alwaysEmitIntoClient public static var E2BIG: System.Errno {
    get { argListTooLong }
  }
  @_alwaysEmitIntoClient public static var execFormatError: System.Errno {
    get { Errno(_ENOEXEC) }
  }
  @available(*, unavailable, renamed: "noExec")
  @_alwaysEmitIntoClient public static var ENOEXEC: System.Errno {
    get { execFormatError }
  }
  @_alwaysEmitIntoClient public static var badFileDescriptor: System.Errno {
    get { Errno(_EBADF) }
  }
  @available(*, unavailable, renamed: "badFileDescriptor")
  @_alwaysEmitIntoClient public static var EBADF: System.Errno {
    get { badFileDescriptor }
  }
  @_alwaysEmitIntoClient public static var noChildProcess: System.Errno {
    get { Errno(_ECHILD) }
  }
  @available(*, unavailable, renamed: "noChildProcess")
  @_alwaysEmitIntoClient public static var ECHILD: System.Errno {
    get { noChildProcess }
  }
  @_alwaysEmitIntoClient public static var deadlock: System.Errno {
    get { Errno(_EDEADLK) }
  }
  @available(*, unavailable, renamed: "deadlock")
  @_alwaysEmitIntoClient public static var EDEADLK: System.Errno {
    get { deadlock }
  }
  @_alwaysEmitIntoClient public static var noMemory: System.Errno {
    get { Errno(_ENOMEM) }
  }
  @available(*, unavailable, renamed: "noMemory")
  @_alwaysEmitIntoClient public static var ENOMEM: System.Errno {
    get { noMemory }
  }
  @_alwaysEmitIntoClient public static var permissionDenied: System.Errno {
    get { Errno(_EACCES) }
  }
  @available(*, unavailable, renamed: "permissionDenied")
  @_alwaysEmitIntoClient public static var EACCES: System.Errno {
    get { permissionDenied }
  }
  @_alwaysEmitIntoClient public static var badAddress: System.Errno {
    get { Errno(_EFAULT) }
  }
  @available(*, unavailable, renamed: "badAddress")
  @_alwaysEmitIntoClient public static var EFAULT: System.Errno {
    get { badAddress }
  }
  @_alwaysEmitIntoClient public static var notBlockDevice: System.Errno {
    get { Errno(_ENOTBLK) }
  }
  @available(*, unavailable, renamed: "notBlockDevice")
  @_alwaysEmitIntoClient public static var ENOTBLK: System.Errno {
    get { notBlockDevice }
  }
  @_alwaysEmitIntoClient public static var resourceBusy: System.Errno {
    get { Errno(_EBUSY) }
  }
  @available(*, unavailable, renamed: "resourceBusy")
  @_alwaysEmitIntoClient public static var EBUSY: System.Errno {
    get { resourceBusy }
  }
  @_alwaysEmitIntoClient public static var fileExists: System.Errno {
    get { Errno(_EEXIST) }
  }
  @available(*, unavailable, renamed: "fileExists")
  @_alwaysEmitIntoClient public static var EEXIST: System.Errno {
    get { fileExists }
  }
  @_alwaysEmitIntoClient public static var improperLink: System.Errno {
    get { Errno(_EXDEV) }
  }
  @available(*, unavailable, renamed: "improperLink")
  @_alwaysEmitIntoClient public static var EXDEV: System.Errno {
    get { improperLink }
  }
  @_alwaysEmitIntoClient public static var operationNotSupportedByDevice: System.Errno {
    get { Errno(_ENODEV) }
  }
  @available(*, unavailable, renamed: "operationNotSupportedByDevice")
  @_alwaysEmitIntoClient public static var ENODEV: System.Errno {
    get { operationNotSupportedByDevice }
  }
  @_alwaysEmitIntoClient public static var notDirectory: System.Errno {
    get { Errno(_ENOTDIR) }
  }
  @available(*, unavailable, renamed: "notDirectory")
  @_alwaysEmitIntoClient public static var ENOTDIR: System.Errno {
    get { notDirectory }
  }
  @_alwaysEmitIntoClient public static var isDirectory: System.Errno {
    get { Errno(_EISDIR) }
  }
  @available(*, unavailable, renamed: "isDirectory")
  @_alwaysEmitIntoClient public static var EISDIR: System.Errno {
    get { isDirectory }
  }
  @_alwaysEmitIntoClient public static var invalidArgument: System.Errno {
    get { Errno(_EINVAL) }
  }
  @available(*, unavailable, renamed: "invalidArgument")
  @_alwaysEmitIntoClient public static var EINVAL: System.Errno {
    get { invalidArgument }
  }
  @_alwaysEmitIntoClient public static var tooManyOpenFilesInSystem: System.Errno {
    get { Errno(_ENFILE) }
  }
  @available(*, unavailable, renamed: "tooManyOpenFilesInSystem")
  @_alwaysEmitIntoClient public static var ENFILE: System.Errno {
    get { tooManyOpenFilesInSystem }
  }
  @_alwaysEmitIntoClient public static var tooManyOpenFiles: System.Errno {
    get { Errno(_EMFILE) }
  }
  @available(*, unavailable, renamed: "tooManyOpenFiles")
  @_alwaysEmitIntoClient public static var EMFILE: System.Errno {
    get { tooManyOpenFiles }
  }
  @_alwaysEmitIntoClient public static var inappropriateIOCTLForDevice: System.Errno {
    get { Errno(_ENOTTY) }
  }
  @available(*, unavailable, renamed: "inappropriateIOCTLForDevice")
  @_alwaysEmitIntoClient public static var ENOTTY: System.Errno {
    get { inappropriateIOCTLForDevice }
  }
  @_alwaysEmitIntoClient public static var textFileBusy: System.Errno {
    get { Errno(_ETXTBSY) }
  }
  @available(*, unavailable, renamed: "textFileBusy")
  @_alwaysEmitIntoClient public static var ETXTBSY: System.Errno {
    get { textFileBusy }
  }
  @_alwaysEmitIntoClient public static var fileTooLarge: System.Errno {
    get { Errno(_EFBIG) }
  }
  @available(*, unavailable, renamed: "fileTooLarge")
  @_alwaysEmitIntoClient public static var EFBIG: System.Errno {
    get { fileTooLarge }
  }
  @_alwaysEmitIntoClient public static var noSpace: System.Errno {
    get { Errno(_ENOSPC) }
  }
  @available(*, unavailable, renamed: "noSpace")
  @_alwaysEmitIntoClient public static var ENOSPC: System.Errno {
    get { noSpace }
  }
  @_alwaysEmitIntoClient public static var illegalSeek: System.Errno {
    get { Errno(_ESPIPE) }
  }
  @available(*, unavailable, renamed: "illegalSeek")
  @_alwaysEmitIntoClient public static var ESPIPE: System.Errno {
    get { illegalSeek }
  }
  @_alwaysEmitIntoClient public static var readOnlyFileSystem: System.Errno {
    get { Errno(_EROFS) }
  }
  @available(*, unavailable, renamed: "readOnlyFileSystem")
  @_alwaysEmitIntoClient public static var EROFS: System.Errno {
    get { readOnlyFileSystem }
  }
  @_alwaysEmitIntoClient public static var tooManyLinks: System.Errno {
    get { Errno(_EMLINK) }
  }
  @available(*, unavailable, renamed: "tooManyLinks")
  @_alwaysEmitIntoClient public static var EMLINK: System.Errno {
    get { tooManyLinks }
  }
  @_alwaysEmitIntoClient public static var brokenPipe: System.Errno {
    get { Errno(_EPIPE) }
  }
  @available(*, unavailable, renamed: "brokenPipe")
  @_alwaysEmitIntoClient public static var EPIPE: System.Errno {
    get { brokenPipe }
  }
  @_alwaysEmitIntoClient public static var outOfDomain: System.Errno {
    get { Errno(_EDOM) }
  }
  @available(*, unavailable, renamed: "outOfDomain")
  @_alwaysEmitIntoClient public static var EDOM: System.Errno {
    get { outOfDomain }
  }
  @_alwaysEmitIntoClient public static var outOfRange: System.Errno {
    get { Errno(_ERANGE) }
  }
  @available(*, unavailable, renamed: "outOfRange")
  @_alwaysEmitIntoClient public static var ERANGE: System.Errno {
    get { outOfRange }
  }
  @_alwaysEmitIntoClient public static var resourceTemporarilyUnavailable: System.Errno {
    get { Errno(_EAGAIN) }
  }
  @available(*, unavailable, renamed: "resourceTemporarilyUnavailable")
  @_alwaysEmitIntoClient public static var EAGAIN: System.Errno {
    get { resourceTemporarilyUnavailable }
  }
  @_alwaysEmitIntoClient public static var nowInProgress: System.Errno {
    get { Errno(_EINPROGRESS) }
  }
  @available(*, unavailable, renamed: "nowInProcess")
  @_alwaysEmitIntoClient public static var EINPROGRESS: System.Errno {
    get { nowInProgress }
  }
  @_alwaysEmitIntoClient public static var alreadyInProcess: System.Errno {
    get { Errno(_EALREADY) }
  }
  @available(*, unavailable, renamed: "alreadyInProcess")
  @_alwaysEmitIntoClient public static var EALREADY: System.Errno {
    get { alreadyInProcess }
  }
  @_alwaysEmitIntoClient public static var notSocket: System.Errno {
    get { Errno(_ENOTSOCK) }
  }
  @available(*, unavailable, renamed: "notSocket")
  @_alwaysEmitIntoClient public static var ENOTSOCK: System.Errno {
    get { notSocket }
  }
  @_alwaysEmitIntoClient public static var addressRequired: System.Errno {
    get { Errno(_EDESTADDRREQ) }
  }
  @available(*, unavailable, renamed: "addressRequired")
  @_alwaysEmitIntoClient public static var EDESTADDRREQ: System.Errno {
    get { addressRequired }
  }
  @_alwaysEmitIntoClient public static var messageTooLong: System.Errno {
    get { Errno(_EMSGSIZE) }
  }
  @available(*, unavailable, renamed: "messageTooLong")
  @_alwaysEmitIntoClient public static var EMSGSIZE: System.Errno {
    get { messageTooLong }
  }
  @_alwaysEmitIntoClient public static var protocolWrongTypeForSocket: System.Errno {
    get { Errno(_EPROTOTYPE) }
  }
  @available(*, unavailable, renamed: "protocolWrongTypeForSocket")
  @_alwaysEmitIntoClient public static var EPROTOTYPE: System.Errno {
    get { protocolWrongTypeForSocket }
  }
  @_alwaysEmitIntoClient public static var protocolNotAvailable: System.Errno {
    get { Errno(_ENOPROTOOPT) }
  }
  @available(*, unavailable, renamed: "protocolNotAvailable")
  @_alwaysEmitIntoClient public static var ENOPROTOOPT: System.Errno {
    get { protocolNotAvailable }
  }
  @_alwaysEmitIntoClient public static var protocolNotSupported: System.Errno {
    get { Errno(_EPROTONOSUPPORT) }
  }
  @available(*, unavailable, renamed: "protocolNotSupported")
  @_alwaysEmitIntoClient public static var EPROTONOSUPPORT: System.Errno {
    get { protocolNotSupported }
  }
  @_alwaysEmitIntoClient public static var socketTypeNotSupported: System.Errno {
    get { Errno(_ESOCKTNOSUPPORT) }
  }
  @available(*, unavailable, renamed: "socketTypeNotSupported")
  @_alwaysEmitIntoClient public static var ESOCKTNOSUPPORT: System.Errno {
    get { socketTypeNotSupported }
  }
  @_alwaysEmitIntoClient public static var notSupported: System.Errno {
    get { Errno(_ENOTSUP) }
  }
  @available(*, unavailable, renamed: "notSupported")
  @_alwaysEmitIntoClient public static var ENOTSUP: System.Errno {
    get { notSupported }
  }
  @_alwaysEmitIntoClient public static var protocolFamilyNotSupported: System.Errno {
    get { Errno(_EPFNOSUPPORT) }
  }
  @available(*, unavailable, renamed: "protocolFamilyNotSupported")
  @_alwaysEmitIntoClient public static var EPFNOSUPPORT: System.Errno {
    get { protocolFamilyNotSupported }
  }
  @_alwaysEmitIntoClient public static var addressFamilyNotSupported: System.Errno {
    get { Errno(_EAFNOSUPPORT) }
  }
  @available(*, unavailable, renamed: "addressFamilyNotSupported")
  @_alwaysEmitIntoClient public static var EAFNOSUPPORT: System.Errno {
    get { addressFamilyNotSupported }
  }
  @_alwaysEmitIntoClient public static var addressInUse: System.Errno {
    get { Errno(_EADDRINUSE) }
  }
  @available(*, unavailable, renamed: "addressInUse")
  @_alwaysEmitIntoClient public static var EADDRINUSE: System.Errno {
    get { addressInUse }
  }
  @_alwaysEmitIntoClient public static var addressNotAvailable: System.Errno {
    get { Errno(_EADDRNOTAVAIL) }
  }
  @available(*, unavailable, renamed: "addressNotAvailable")
  @_alwaysEmitIntoClient public static var EADDRNOTAVAIL: System.Errno {
    get { addressNotAvailable }
  }
  @_alwaysEmitIntoClient public static var networkDown: System.Errno {
    get { Errno(_ENETDOWN) }
  }
  @available(*, unavailable, renamed: "networkDown")
  @_alwaysEmitIntoClient public static var ENETDOWN: System.Errno {
    get { networkDown }
  }
  @_alwaysEmitIntoClient public static var networkUnreachable: System.Errno {
    get { Errno(_ENETUNREACH) }
  }
  @available(*, unavailable, renamed: "networkUnreachable")
  @_alwaysEmitIntoClient public static var ENETUNREACH: System.Errno {
    get { networkUnreachable }
  }
  @_alwaysEmitIntoClient public static var networkReset: System.Errno {
    get { Errno(_ENETRESET) }
  }
  @available(*, unavailable, renamed: "networkReset")
  @_alwaysEmitIntoClient public static var ENETRESET: System.Errno {
    get { networkReset }
  }
  @_alwaysEmitIntoClient public static var connectionAbort: System.Errno {
    get { Errno(_ECONNABORTED) }
  }
  @available(*, unavailable, renamed: "connectionAbort")
  @_alwaysEmitIntoClient public static var ECONNABORTED: System.Errno {
    get { connectionAbort }
  }
  @_alwaysEmitIntoClient public static var connectionReset: System.Errno {
    get { Errno(_ECONNRESET) }
  }
  @available(*, unavailable, renamed: "connectionReset")
  @_alwaysEmitIntoClient public static var ECONNRESET: System.Errno {
    get { connectionReset }
  }
  @_alwaysEmitIntoClient public static var noBufferSpace: System.Errno {
    get { Errno(_ENOBUFS) }
  }
  @available(*, unavailable, renamed: "noBufferSpace")
  @_alwaysEmitIntoClient public static var ENOBUFS: System.Errno {
    get { noBufferSpace }
  }
  @_alwaysEmitIntoClient public static var socketIsConnected: System.Errno {
    get { Errno(_EISCONN) }
  }
  @available(*, unavailable, renamed: "socketIsConnected")
  @_alwaysEmitIntoClient public static var EISCONN: System.Errno {
    get { socketIsConnected }
  }
  @_alwaysEmitIntoClient public static var socketNotConnected: System.Errno {
    get { Errno(_ENOTCONN) }
  }
  @available(*, unavailable, renamed: "socketNotConnected")
  @_alwaysEmitIntoClient public static var ENOTCONN: System.Errno {
    get { socketNotConnected }
  }
  @_alwaysEmitIntoClient public static var socketShutdown: System.Errno {
    get { Errno(_ESHUTDOWN) }
  }
  @available(*, unavailable, renamed: "socketShutdown")
  @_alwaysEmitIntoClient public static var ESHUTDOWN: System.Errno {
    get { socketShutdown }
  }
  @_alwaysEmitIntoClient public static var timedOut: System.Errno {
    get { Errno(_ETIMEDOUT) }
  }
  @available(*, unavailable, renamed: "timedOut")
  @_alwaysEmitIntoClient public static var ETIMEDOUT: System.Errno {
    get { timedOut }
  }
  @_alwaysEmitIntoClient public static var connectionRefused: System.Errno {
    get { Errno(_ECONNREFUSED) }
  }
  @available(*, unavailable, renamed: "connectionRefused")
  @_alwaysEmitIntoClient public static var ECONNREFUSED: System.Errno {
    get { connectionRefused }
  }
  @_alwaysEmitIntoClient public static var tooManySymbolicLinkLevels: System.Errno {
    get { Errno(_ELOOP) }
  }
  @available(*, unavailable, renamed: "tooManySymbolicLinkLevels")
  @_alwaysEmitIntoClient public static var ELOOP: System.Errno {
    get { tooManySymbolicLinkLevels }
  }
  @_alwaysEmitIntoClient public static var fileNameTooLong: System.Errno {
    get { Errno(_ENAMETOOLONG) }
  }
  @available(*, unavailable, renamed: "fileNameTooLong")
  @_alwaysEmitIntoClient public static var ENAMETOOLONG: System.Errno {
    get { fileNameTooLong }
  }
  @_alwaysEmitIntoClient public static var hostIsDown: System.Errno {
    get { Errno(_EHOSTDOWN) }
  }
  @available(*, unavailable, renamed: "hostIsDown")
  @_alwaysEmitIntoClient public static var EHOSTDOWN: System.Errno {
    get { hostIsDown }
  }
  @_alwaysEmitIntoClient public static var noRouteToHost: System.Errno {
    get { Errno(_EHOSTUNREACH) }
  }
  @available(*, unavailable, renamed: "noRouteToHost")
  @_alwaysEmitIntoClient public static var EHOSTUNREACH: System.Errno {
    get { noRouteToHost }
  }
  @_alwaysEmitIntoClient public static var directoryNotEmpty: System.Errno {
    get { Errno(_ENOTEMPTY) }
  }
  @available(*, unavailable, renamed: "directoryNotEmpty")
  @_alwaysEmitIntoClient public static var ENOTEMPTY: System.Errno {
    get { directoryNotEmpty }
  }
  @_alwaysEmitIntoClient public static var tooManyProcesses: System.Errno {
    get { Errno(_EPROCLIM) }
  }
  @available(*, unavailable, renamed: "tooManyProcesses")
  @_alwaysEmitIntoClient public static var EPROCLIM: System.Errno {
    get { tooManyProcesses }
  }
  @_alwaysEmitIntoClient public static var tooManyUsers: System.Errno {
    get { Errno(_EUSERS) }
  }
  @available(*, unavailable, renamed: "tooManyUsers")
  @_alwaysEmitIntoClient public static var EUSERS: System.Errno {
    get { tooManyUsers }
  }
  @_alwaysEmitIntoClient public static var diskQuotaExceeded: System.Errno {
    get { Errno(_EDQUOT) }
  }
  @available(*, unavailable, renamed: "diskQuotaExceeded")
  @_alwaysEmitIntoClient public static var EDQUOT: System.Errno {
    get { diskQuotaExceeded }
  }
  @_alwaysEmitIntoClient public static var staleNFSFileHandle: System.Errno {
    get { Errno(_ESTALE) }
  }
  @available(*, unavailable, renamed: "staleNFSFileHandle")
  @_alwaysEmitIntoClient public static var ESTALE: System.Errno {
    get { staleNFSFileHandle }
  }
  @_alwaysEmitIntoClient public static var rpcUnsuccessful: System.Errno {
    get { Errno(_EBADRPC) }
  }
  @available(*, unavailable, renamed: "rpcUnsuccessful")
  @_alwaysEmitIntoClient public static var EBADRPC: System.Errno {
    get { rpcUnsuccessful }
  }
  @_alwaysEmitIntoClient public static var rpcVersionMismatch: System.Errno {
    get { Errno(_ERPCMISMATCH) }
  }
  @available(*, unavailable, renamed: "rpcVersionMismatch")
  @_alwaysEmitIntoClient public static var ERPCMISMATCH: System.Errno {
    get { rpcVersionMismatch }
  }
  @_alwaysEmitIntoClient public static var rpcProgramUnavailable: System.Errno {
    get { Errno(_EPROGUNAVAIL) }
  }
  @available(*, unavailable, renamed: "rpcProgramUnavailable")
  @_alwaysEmitIntoClient public static var EPROGUNAVAIL: System.Errno {
    get { rpcProgramUnavailable }
  }
  @_alwaysEmitIntoClient public static var rpcProgramVersionMismatch: System.Errno {
    get { Errno(_EPROGMISMATCH) }
  }
  @available(*, unavailable, renamed: "rpcProgramVersionMismatch")
  @_alwaysEmitIntoClient public static var EPROGMISMATCH: System.Errno {
    get { rpcProgramVersionMismatch }
  }
  @_alwaysEmitIntoClient public static var rpcProcedureUnavailable: System.Errno {
    get { Errno(_EPROCUNAVAIL) }
  }
  @available(*, unavailable, renamed: "rpcProcedureUnavailable")
  @_alwaysEmitIntoClient public static var EPROCUNAVAIL: System.Errno {
    get { rpcProcedureUnavailable }
  }
  @_alwaysEmitIntoClient public static var noLocks: System.Errno {
    get { Errno(_ENOLCK) }
  }
  @available(*, unavailable, renamed: "noLocks")
  @_alwaysEmitIntoClient public static var ENOLCK: System.Errno {
    get { noLocks }
  }
  @_alwaysEmitIntoClient public static var noFunction: System.Errno {
    get { Errno(_ENOSYS) }
  }
  @available(*, unavailable, renamed: "noFunction")
  @_alwaysEmitIntoClient public static var ENOSYS: System.Errno {
    get { noFunction }
  }
  @_alwaysEmitIntoClient public static var badFileTypeOrFormat: System.Errno {
    get { Errno(_EFTYPE) }
  }
  @available(*, unavailable, renamed: "badFileTypeOrFormat")
  @_alwaysEmitIntoClient public static var EFTYPE: System.Errno {
    get { badFileTypeOrFormat }
  }
  @_alwaysEmitIntoClient public static var authenticationError: System.Errno {
    get { Errno(_EAUTH) }
  }
  @available(*, unavailable, renamed: "authenticationError")
  @_alwaysEmitIntoClient public static var EAUTH: System.Errno {
    get { authenticationError }
  }
  @_alwaysEmitIntoClient public static var needAuthenticator: System.Errno {
    get { Errno(_ENEEDAUTH) }
  }
  @available(*, unavailable, renamed: "needAuthenticator")
  @_alwaysEmitIntoClient public static var ENEEDAUTH: System.Errno {
    get { needAuthenticator }
  }
  @_alwaysEmitIntoClient public static var devicePowerIsOff: System.Errno {
    get { Errno(_EPWROFF) }
  }
  @available(*, unavailable, renamed: "devicePowerIsOff")
  @_alwaysEmitIntoClient public static var EPWROFF: System.Errno {
    get { devicePowerIsOff }
  }
  @_alwaysEmitIntoClient public static var deviceError: System.Errno {
    get { Errno(_EDEVERR) }
  }
  @available(*, unavailable, renamed: "deviceError")
  @_alwaysEmitIntoClient public static var EDEVERR: System.Errno {
    get { deviceError }
  }
  @_alwaysEmitIntoClient public static var overflow: System.Errno {
    get { Errno(_EOVERFLOW) }
  }
  @available(*, unavailable, renamed: "overflow")
  @_alwaysEmitIntoClient public static var EOVERFLOW: System.Errno {
    get { overflow }
  }
  @_alwaysEmitIntoClient public static var badExecutable: System.Errno {
    get { Errno(_EBADEXEC) }
  }
  @available(*, unavailable, renamed: "badExecutable")
  @_alwaysEmitIntoClient public static var EBADEXEC: System.Errno {
    get { badExecutable }
  }
  @_alwaysEmitIntoClient public static var badCPUType: System.Errno {
    get { Errno(_EBADARCH) }
  }
  @available(*, unavailable, renamed: "badCPUType")
  @_alwaysEmitIntoClient public static var EBADARCH: System.Errno {
    get { badCPUType }
  }
  @_alwaysEmitIntoClient public static var sharedLibraryVersionMismatch: System.Errno {
    get { Errno(_ESHLIBVERS) }
  }
  @available(*, unavailable, renamed: "sharedLibraryVersionMismatch")
  @_alwaysEmitIntoClient public static var ESHLIBVERS: System.Errno {
    get { sharedLibraryVersionMismatch }
  }
  @_alwaysEmitIntoClient public static var malformedMachO: System.Errno {
    get { Errno(_EBADMACHO) }
  }
  @available(*, unavailable, renamed: "malformedMachO")
  @_alwaysEmitIntoClient public static var EBADMACHO: System.Errno {
    get { malformedMachO }
  }
  @_alwaysEmitIntoClient public static var canceled: System.Errno {
    get { Errno(_ECANCELED) }
  }
  @available(*, unavailable, renamed: "canceled")
  @_alwaysEmitIntoClient public static var ECANCELED: System.Errno {
    get { canceled }
  }
  @_alwaysEmitIntoClient public static var identifierRemoved: System.Errno {
    get { Errno(_EIDRM) }
  }
  @available(*, unavailable, renamed: "identifierRemoved")
  @_alwaysEmitIntoClient public static var EIDRM: System.Errno {
    get { identifierRemoved }
  }
  @_alwaysEmitIntoClient public static var noMessage: System.Errno {
    get { Errno(_ENOMSG) }
  }
  @available(*, unavailable, renamed: "noMessage")
  @_alwaysEmitIntoClient public static var ENOMSG: System.Errno {
    get { noMessage }
  }
  @_alwaysEmitIntoClient public static var illegalByteSequence: System.Errno {
    get { Errno(_EILSEQ) }
  }
  @available(*, unavailable, renamed: "illegalByteSequence")
  @_alwaysEmitIntoClient public static var EILSEQ: System.Errno {
    get { illegalByteSequence }
  }
  @_alwaysEmitIntoClient public static var attributeNotFound: System.Errno {
    get { Errno(_ENOATTR) }
  }
  @available(*, unavailable, renamed: "attributeNotFound")
  @_alwaysEmitIntoClient public static var ENOATTR: System.Errno {
    get { attributeNotFound }
  }
  @_alwaysEmitIntoClient public static var badMessage: System.Errno {
    get { Errno(_EBADMSG) }
  }
  @available(*, unavailable, renamed: "badMessage")
  @_alwaysEmitIntoClient public static var EBADMSG: System.Errno {
    get { badMessage }
  }
  @_alwaysEmitIntoClient public static var multiHop: System.Errno {
    get { Errno(_EMULTIHOP) }
  }
  @available(*, unavailable, renamed: "multiHop")
  @_alwaysEmitIntoClient public static var EMULTIHOP: System.Errno {
    get { multiHop }
  }
  @_alwaysEmitIntoClient public static var noData: System.Errno {
    get { Errno(_ENODATA) }
  }
  @available(*, unavailable, renamed: "noData")
  @_alwaysEmitIntoClient public static var ENODATA: System.Errno {
    get { noData }
  }
  @_alwaysEmitIntoClient public static var noLink: System.Errno {
    get { Errno(_ENOLINK) }
  }
  @available(*, unavailable, renamed: "noLink")
  @_alwaysEmitIntoClient public static var ENOLINK: System.Errno {
    get { noLink }
  }
  @_alwaysEmitIntoClient public static var noStreamResources: System.Errno {
    get { Errno(_ENOSR) }
  }
  @available(*, unavailable, renamed: "noStreamResources")
  @_alwaysEmitIntoClient public static var ENOSR: System.Errno {
    get { noStreamResources }
  }
  @_alwaysEmitIntoClient public static var notStream: System.Errno {
    get { Errno(_ENOSTR) }
  }
  @available(*, unavailable, renamed: "notStream")
  @_alwaysEmitIntoClient public static var ENOSTR: System.Errno {
    get { notStream }
  }
  @_alwaysEmitIntoClient public static var protocolError: System.Errno {
    get { Errno(_EPROTO) }
  }
  @available(*, unavailable, renamed: "protocolError")
  @_alwaysEmitIntoClient public static var EPROTO: System.Errno {
    get { protocolError }
  }
  @_alwaysEmitIntoClient public static var timeout: System.Errno {
    get { Errno(_ETIME) }
  }
  @available(*, unavailable, renamed: "timeout")
  @_alwaysEmitIntoClient public static var ETIME: System.Errno {
    get { timeout }
  }
  @_alwaysEmitIntoClient public static var notSupportedOnSocket: System.Errno {
    get { Errno(_EOPNOTSUPP) }
  }
  @available(*, unavailable, renamed: "notSupportedOnSocket")
  @_alwaysEmitIntoClient public static var EOPNOTSUPP: System.Errno {
    get { notSupportedOnSocket }
  }
  public typealias RawValue = Swift.CInt
}
@available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
extension System.Errno {
  @_alwaysEmitIntoClient public static var wouldBlock: System.Errno {
    get { Errno(_EWOULDBLOCK) }
  }
  @available(*, unavailable, renamed: "wouldBlock")
  @_alwaysEmitIntoClient public static var EWOULDBLOCK: System.Errno {
    get { wouldBlock }
  }
  @_alwaysEmitIntoClient public static var tooManyReferences: System.Errno {
    get { Errno(_ETOOMANYREFS) }
  }
  @available(*, unavailable, renamed: "tooManyReferences")
  @_alwaysEmitIntoClient public static var ETOOMANYREFS: System.Errno {
    get { tooManyReferences }
  }
  @_alwaysEmitIntoClient public static var tooManyRemoteLevels: System.Errno {
    get { Errno(_EREMOTE) }
  }
  @available(*, unavailable, renamed: "tooManyRemoteLevels")
  @_alwaysEmitIntoClient public static var EREMOTE: System.Errno {
    get { tooManyRemoteLevels }
  }
  @_alwaysEmitIntoClient public static var noSuchPolicy: System.Errno {
    get { Errno(_ENOPOLICY) }
  }
  @available(*, unavailable, renamed: "noSuchPolicy")
  @_alwaysEmitIntoClient public static var ENOPOLICY: System.Errno {
    get { noSuchPolicy }
  }
  @_alwaysEmitIntoClient public static var notRecoverable: System.Errno {
    get { Errno(_ENOTRECOVERABLE) }
  }
  @available(*, unavailable, renamed: "notRecoverable")
  @_alwaysEmitIntoClient public static var ENOTRECOVERABLE: System.Errno {
    get { notRecoverable }
  }
  @_alwaysEmitIntoClient public static var previousOwnerDied: System.Errno {
    get { Errno(_EOWNERDEAD) }
  }
  @available(*, unavailable, renamed: "previousOwnerDied")
  @_alwaysEmitIntoClient public static var EOWNERDEAD: System.Errno {
    get { previousOwnerDied }
  }
  @_alwaysEmitIntoClient public static var outputQueueFull: System.Errno {
    get { Errno(_EQFULL) }
  }
  @available(*, unavailable, renamed: "outputQueueFull")
  @_alwaysEmitIntoClient public static var EQFULL: System.Errno {
    get { outputQueueFull }
  }
  @_alwaysEmitIntoClient public static var lastErrnoValue: System.Errno {
    get { Errno(_ELAST) }
  }
  @available(*, unavailable, renamed: "lastErrnoValue")
  @_alwaysEmitIntoClient public static var ELAST: System.Errno {
    get { lastErrnoValue }
  }
}
@available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
extension System.Errno {
  public var _code: Swift.Int {
    get
  }
  public var _domain: Swift.String {
    get
  }
}
@available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
extension System.Errno : Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible {
  @inline(never) public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
}
@available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
extension System.Errno {
  @_alwaysEmitIntoClient public static func ~= (lhs: System.Errno, rhs: Swift.Error) -> Swift.Bool {
    guard let value = rhs as? Errno else { return false }
    return lhs == value
  }
}
@available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
extension System.FileDescriptor : Swift.Sendable {}
@available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
extension System.FileDescriptor.AccessMode : Swift.Sendable {}
@available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
extension System.FileDescriptor.OpenOptions : Swift.Sendable {}
@available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
extension System.FileDescriptor.SeekOrigin : Swift.Sendable {}
@available(macOS 12, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
extension System.FilePath.Component : Swift.Encodable {}
@available(macOS 12, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
extension System.FilePath.Component : Swift.Decodable {}
@available(macOS 12, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
extension System.FilePath.Component : Swift.Hashable {}
@available(macOS 12, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
extension System.FilePath.Root : Swift.Encodable {}
@available(macOS 12, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
extension System.FilePath.Root : Swift.Decodable {}
@available(macOS 12, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
extension System.FilePath.Root : Swift.Hashable {}
@available(macOS 12, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
extension System.FilePath.Component.Kind : Swift.Equatable {}
@available(macOS 12, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
extension System.FilePath.Component.Kind : Swift.Hashable {}
@available(macOS 12, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
extension System.FilePath.Component.Kind : Swift.Sendable {}
@available(macOS 12, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
extension System.FilePath.ComponentView : Swift.Encodable {}
@available(macOS 12, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
extension System.FilePath.ComponentView : Swift.Decodable {}
@available(macOS 12, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
extension System.FilePath.ComponentView : Swift.Hashable {}
@available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
extension System.FilePermissions : Swift.Sendable {}
