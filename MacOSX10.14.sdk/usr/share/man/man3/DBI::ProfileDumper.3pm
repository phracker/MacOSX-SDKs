.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "DBI::ProfileDumper 3"
.TH DBI::ProfileDumper 3 "2013-06-24" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
DBI::ProfileDumper \- profile DBI usage and output data to a file
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
To profile an existing program using DBI::ProfileDumper, set the
\&\s-1DBI_PROFILE\s0 environment variable and run your program as usual.  For
example, using bash:
.PP
.Vb 1
\&  DBI_PROFILE=2/DBI::ProfileDumper program.pl
.Ve
.PP
Then analyze the generated file (\fIdbi.prof\fR) with dbiprof:
.PP
.Vb 1
\&  dbiprof
.Ve
.PP
You can also activate DBI::ProfileDumper from within your code:
.PP
.Vb 1
\&  use DBI;
\&
\&  # profile with default path (2) and output file (dbi.prof)
\&  $dbh\->{Profile} = "!Statement/DBI::ProfileDumper";
\&
\&  # same thing, spelled out
\&  $dbh\->{Profile} = "!Statement/DBI::ProfileDumper/File:dbi.prof";
\&
\&  # another way to say it
\&  use DBI::ProfileDumper;
\&  $dbh\->{Profile} = DBI::ProfileDumper\->new(
\&                        Path => [ \*(Aq!Statement\*(Aq ],
\&                        File => \*(Aqdbi.prof\*(Aq );
\&
\&  # using a custom path
\&  $dbh\->{Profile} = DBI::ProfileDumper\->new(
\&      Path => [ "foo", "bar" ],
\&      File => \*(Aqdbi.prof\*(Aq,
\&  );
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
DBI::ProfileDumper is a subclass of DBI::Profile which
dumps profile data to disk instead of printing a summary to your
screen.  You can then use dbiprof to analyze the data in
a number of interesting ways, or you can roll your own analysis using
DBI::ProfileData.
.PP
\&\fB\s-1NOTE:\s0\fR For Apache/mod_perl applications, use
DBI::ProfileDumper::Apache.
.SH "USAGE"
.IX Header "USAGE"
One way to use this module is just to enable it in your \f(CW$dbh\fR:
.PP
.Vb 1
\&  $dbh\->{Profile} = "1/DBI::ProfileDumper";
.Ve
.PP
This will write out profile data by statement into a file called
\&\fIdbi.prof\fR.  If you want to modify either of these properties, you
can construct the DBI::ProfileDumper object yourself:
.PP
.Vb 5
\&  use DBI::ProfileDumper;
\&  $dbh\->{Profile} = DBI::ProfileDumper\->new(
\&      Path => [ \*(Aq!Statement\*(Aq ],
\&      File => \*(Aqdbi.prof\*(Aq
\&  );
.Ve
.PP
The \f(CW\*(C`Path\*(C'\fR option takes the same values as in
DBI::Profile.  The \f(CW\*(C`File\*(C'\fR option gives the name of the
file where results will be collected.  If it already exists it will be
overwritten.
.PP
You can also activate this module by setting the \s-1DBI_PROFILE\s0
environment variable:
.PP
.Vb 1
\&  $ENV{DBI_PROFILE} = "!Statement/DBI::ProfileDumper";
.Ve
.PP
This will cause all \s-1DBI\s0 handles to share the same profiling object.
.SH "METHODS"
.IX Header "METHODS"
The following methods are available to be called using the profile
object.  You can get access to the profile object from the Profile key
in any \s-1DBI\s0 handle:
.PP
.Vb 1
\&  my $profile = $dbh\->{Profile};
.Ve
.SS "flush_to_disk"
.IX Subsection "flush_to_disk"
.Vb 1
\&  $profile\->flush_to_disk()
.Ve
.PP
Flushes all collected profile data to disk and empties the Data hash.  Returns
the filename written to.  If no profile data has been collected then the file is
not written and \fIflush_to_disk()\fR returns undef.
.PP
The file is locked while it's being written. A process 'consuming' the files
while they're being written to, should rename the file first, then lock it,
then read it, then close and delete it. The \f(CW\*(C`DeleteFiles\*(C'\fR option to
DBI::ProfileData does the right thing.
.PP
This method may be called multiple times during a program run.
.SS "empty"
.IX Subsection "empty"
.Vb 1
\&  $profile\->empty()
.Ve
.PP
Clears the Data hash without writing to disk.
.SS "filename"
.IX Subsection "filename"
.Vb 1
\&  $filename = $profile\->filename();
.Ve
.PP
Get or set the filename.
.PP
The filename can be specified as a \s-1CODE\s0 reference, in which case the referenced
code should return the filename to be used. The code will be called with the
profile object as its first argument.
.SH "DATA FORMAT"
.IX Header "DATA FORMAT"
The data format written by DBI::ProfileDumper starts with a header
containing the version number of the module used to generate it.  Then
a block of variable declarations describes the profile.  After two
newlines, the profile data forms the body of the file.  For example:
.PP
.Vb 3
\&  DBI::ProfileDumper 2.003762
\&  Path = [ \*(Aq!Statement\*(Aq, \*(Aq!MethodName\*(Aq ]
\&  Program = t/42profile_data.t
\&
\&  + 1 SELECT name FROM users WHERE id = ?
\&  + 2 prepare
\&  = 1 0.0312958955764771 0.000490069389343262 0.000176072120666504 0.00140702724456787 1023115819.83019 1023115819.86576
\&  + 2 execute
\&  1 0.0312958955764771 0.000490069389343262 0.000176072120666504 0.00140702724456787 1023115819.83019 1023115819.86576
\&  + 2 fetchrow_hashref
\&  = 1 0.0312958955764771 0.000490069389343262 0.000176072120666504 0.00140702724456787 1023115819.83019 1023115819.86576
\&  + 1 UPDATE users SET name = ? WHERE id = ?
\&  + 2 prepare
\&  = 1 0.0312958955764771 0.000490069389343262 0.000176072120666504 0.00140702724456787 1023115819.83019 1023115819.86576
\&  + 2 execute
\&  = 1 0.0312958955764771 0.000490069389343262 0.000176072120666504 0.00140702724456787 1023115819.83019 1023115819.86576
.Ve
.PP
The lines beginning with \f(CW\*(C`+\*(C'\fR signs signify keys.  The number after
the \f(CW\*(C`+\*(C'\fR sign shows the nesting level of the key.  Lines beginning
with \f(CW\*(C`=\*(C'\fR are the actual profile data, in the same order as
in DBI::Profile.
.PP
Note that the same path may be present multiple times in the data file
since \f(CW\*(C`format()\*(C'\fR may be called more than once.  When read by
DBI::ProfileData the data points will be merged to produce a single
data set for each distinct path.
.PP
The key strings are transformed in three ways.  First, all backslashes
are doubled.  Then all newlines and carriage-returns are transformed
into \f(CW\*(C`\en\*(C'\fR and \f(CW\*(C`\er\*(C'\fR respectively.  Finally, any \s-1NULL\s0 bytes (\f(CW\*(C`\e0\*(C'\fR)
are entirely removed.  When DBI::ProfileData reads the file the first
two transformations will be reversed, but \s-1NULL\s0 bytes will not be
restored.
.SH "AUTHOR"
.IX Header "AUTHOR"
Sam Tregar <sam@tregar.com>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright (C) 2002 Sam Tregar
.PP
This program is free software; you can redistribute it and/or modify
it under the same terms as Perl 5 itself.
