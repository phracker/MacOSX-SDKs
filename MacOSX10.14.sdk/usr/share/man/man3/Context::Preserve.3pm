.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Context::Preserve 3"
.TH Context::Preserve 3 "2008-01-15" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Context::Preserve \- run code after a subroutine call, preserving the context the subroutine would have seen if it were the last statement in the caller
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
Have you ever written this?
.PP
.Vb 1
\&    my ($result, @result);
\&
\&    # run a sub in the correct context
\&    if(!defined wantarray){
\&        some::code();
\&    }
\&    elsif(wantarray){
\&        @result = some::code();
\&    }
\&    else {
\&        $result = some::code();
\&    }
\&  
\&    # do something after some::code
\&    $_ += 42 for (@result, $result);
\&  
\&    # finally return the correct value
\&    if(!defined wantarray){
\&        return;
\&    }
\&    elsif(wantarray){
\&        return @result;
\&    }
\&    else {
\&        return $result;
\&    }
.Ve
.PP
Now you can just write this instead:
.PP
.Vb 1
\&  use Context::Preserve;
\&
\&  return preserve_context { some::code() }
\&             after => sub { $_ += 42 for @_ };
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Sometimes you need to call a function, get the results, act on the
results, then return the result of the function.  This is painful
because of contexts; the original function can behave different if
it's called in void, scalar, or list context.  You can ignore the
various cases and just pick one, but that's fragile.  To do things
right, you need to see which case you're being called in, and then
call the function in that context.  This results in 3 code paths,
which is a pain to type in (and maintain).
.PP
This module automates the process.  You provide a coderef that is the
\&\*(L"original function\*(R", and another coderef to run after the original
runs.  You can modify the return value (aliased to \f(CW@_\fR) here, and do
whatever else you need to do.  \f(CW\*(C`wantarray\*(C'\fR is correct inside both
coderefs; in \*(L"after\*(R", though, the return value is ignored and the
value \f(CW\*(C`wantarray\*(C'\fR returns is related to the context that the original
function was called in.
.SH "EXPORT"
.IX Header "EXPORT"
\&\f(CW\*(C`preserve_context\*(C'\fR
.SH "FUNCTIONS"
.IX Header "FUNCTIONS"
.SS "preserve_context { original } [after|replace] => sub { after }"
.IX Subsection "preserve_context { original } [after|replace] => sub { after }"
Invokes \f(CW\*(C`original\*(C'\fR in the same context as \f(CW\*(C`preserve_context\*(C'\fR was
called in, save the results, runs \f(CW\*(C`after\*(C'\fR in the same context, then
returns the result of \f(CW\*(C`original\*(C'\fR (or \f(CW\*(C`after\*(C'\fR if \f(CW\*(C`replace\*(C'\fR is used).
.PP
If the second argument is \f(CW\*(C`after\*(C'\fR, then you can modify \f(CW@_\fR to
affect the return value.  \f(CW\*(C`after\*(C'\fR's return value is ignored.
.PP
If the second argument is \f(CW\*(C`replace\*(C'\fR, then modifying \f(CW@_\fR doesn't do
anything.  The return value of \f(CW\*(C`after\*(C'\fR is returned from
\&\f(CW\*(C`preserve_context\*(C'\fR instead.
.PP
Run \f(CW\*(C`preserve_context\*(C'\fR like this:
.PP
.Vb 5
\&  sub whatever {
\&      ...
\&      return preserve_context { orginal_function() }
\&                 after => sub { modify @_          };
\&  }
\&
\&  or
\&
\&  sub whatever {
\&      ...
\&      return preserve_context   { orginal_function() }
\&                 replace => sub { return @new_return };
\&  }
.Ve
.PP
Note that there's no comma between the first block and the \f(CW\*(C`after
=>\*(C'\fR part.  This is how perl parses functions with the \f(CW\*(C`(&@)\*(C'\fR
prototype.  The alternative is to say:
.PP
.Vb 1
\&      preserve_context(sub { original }, after => sub { after });
.Ve
.PP
You can pick the one you like, but I think the first version is much
prettier.
.SH "AUTHOR AND COPYRIGHT"
.IX Header "AUTHOR AND COPYRIGHT"
Jonathan Rockway \f(CW\*(C`<jrockway@cpan.org>\*(C'\fR
.PP
Copyright (c) 2008 Infinity Interactive.  You may redistribute this
module under the same terms as Perl itself.
