.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "install::TempContent::Objects::mod_perl-2.0.9::docs::api::Apache2::RequestIO 3"
.TH install::TempContent::Objects::mod_perl-2.0.9::docs::api::Apache2::RequestIO 3 "2015-06-18" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Apache2::RequestIO \- Perl API for Apache request record IO
.SH "Synopsis"
.IX Header "Synopsis"
.Vb 1
\&  use Apache2::RequestIO ();
\&  
\&  $rc = $r\->discard_request_body();
\&  
\&  $r\->print("foo", "bar");
\&  $r\->puts("foo", "bar"); # same as print, but no flushing
\&  $r\->printf("%s $d", "foo", 5);
\&  
\&  $r\->read($buffer, $len);
\&  
\&  $r\->rflush();
\&  
\&  $r\->sendfile($filename);
\&  
\&  $r\->write("foobartarcar", 3, 5);
.Ve
.SH "Description"
.IX Header "Description"
\&\f(CW\*(C`Apache2::RequestIO\*(C'\fR provides the \s-1API\s0 to perform \s-1IO\s0 on the Apache
request object.
.SH "API"
.IX Header "API"
\&\f(CW\*(C`Apache2::RequestIO\*(C'\fR provides the following functions and/or methods:
.ie n .SS """discard_request_body"""
.el .SS "\f(CWdiscard_request_body\fP"
.IX Subsection "discard_request_body"
In \s-1HTTP/1.1,\s0 any method can have a body.  However, most \s-1GET\s0 handlers
wouldn't know what to do with a request body if they received one.
This helper routine tests for and reads any message body in the
request, simply discarding whatever it receives.  We need to do this
because failing to read the request body would cause it to be
interpreted as the next request on a persistent connection.
.PP
.Vb 1
\&  $rc = $r\->discard_request_body();
.Ve
.ie n .IP "obj: $r ( ""Apache2::RequestRec object"" )" 4
.el .IP "obj: \f(CW$r\fR ( \f(CWApache2::RequestRec object\fR )" 4
.IX Item "obj: $r ( Apache2::RequestRec object )"
The current request
.ie n .IP "ret: $rc ( integer )" 4
.el .IP "ret: \f(CW$rc\fR ( integer )" 4
.IX Item "ret: $rc ( integer )"
\&\f(CW\*(C`APR::Const status constant\*(C'\fR if request
is malformed, \f(CW\*(C`Apache2::Const::OK\*(C'\fR otherwise.
.IP "since: 2.0.00" 4
.IX Item "since: 2.0.00"
.PP
Since we return an error status if the request is malformed, this
routine should be called at the beginning of a no-body handler, e.g.,
.PP
.Vb 3
\&   use Apache2::Const \-compile => qw(OK);
\&   $rc = $r\->discard_request_body;
\&   return $rc if $rc != Apache2::Const::OK;
.Ve
.ie n .SS """print"""
.el .SS "\f(CWprint\fP"
.IX Subsection "print"
Send data to the client.
.PP
.Vb 1
\&  $cnt = $r\->print(@msg);
.Ve
.ie n .IP "obj: $r ( ""Apache2::RequestRec object"" )" 4
.el .IP "obj: \f(CW$r\fR ( \f(CWApache2::RequestRec object\fR )" 4
.IX Item "obj: $r ( Apache2::RequestRec object )"
.PD 0
.ie n .IP "arg1: @msg ( \s-1ARRAY \s0)" 4
.el .IP "arg1: \f(CW@msg\fR ( \s-1ARRAY \s0)" 4
.IX Item "arg1: @msg ( ARRAY )"
.PD
Data to send
.ie n .IP "ret: $cnt ( number )" 4
.el .IP "ret: \f(CW$cnt\fR ( number )" 4
.IX Item "ret: $cnt ( number )"
How many bytes were sent (or buffered).  If zero bytes were
sent, \f(CW\*(C`print\*(C'\fR will return \f(CW0E0\fR, or \*(L"zero but true,\*(R" which
will still evaluate to \f(CW0\fR in a numerical context.
.ie n .IP "excpt: ""APR::Error""" 4
.el .IP "excpt: \f(CWAPR::Error\fR" 4
.IX Item "excpt: APR::Error"
.PD 0
.IP "since: 2.0.00" 4
.IX Item "since: 2.0.00"
.PD
.PP
The data is flushed only if \s-1STDOUT\s0 stream's \f(CW$|\fR is true. Otherwise
it's buffered up to the size of the buffer, flushing only excessive
data.
.ie n .SS """printf"""
.el .SS "\f(CWprintf\fP"
.IX Subsection "printf"
Format and send data to the client (same as \f(CW\*(C`printf\*(C'\fR).
.PP
.Vb 1
\&  $cnt = $r\->printf($format, @args);
.Ve
.ie n .IP "obj: $r ( ""Apache2::RequestRec object"" )" 4
.el .IP "obj: \f(CW$r\fR ( \f(CWApache2::RequestRec object\fR )" 4
.IX Item "obj: $r ( Apache2::RequestRec object )"
.PD 0
.ie n .IP "arg1: $format ( string )" 4
.el .IP "arg1: \f(CW$format\fR ( string )" 4
.IX Item "arg1: $format ( string )"
.PD
Format string, as in the Perl core \f(CW\*(C`printf\*(C'\fR function.
.ie n .IP "arg2: @args ( \s-1ARRAY \s0)" 4
.el .IP "arg2: \f(CW@args\fR ( \s-1ARRAY \s0)" 4
.IX Item "arg2: @args ( ARRAY )"
Arguments to be formatted, as in the Perl core \f(CW\*(C`printf\*(C'\fR function.
.ie n .IP "ret: $cnt ( number )" 4
.el .IP "ret: \f(CW$cnt\fR ( number )" 4
.IX Item "ret: $cnt ( number )"
How many bytes were sent (or buffered)
.ie n .IP "excpt: ""APR::Error""" 4
.el .IP "excpt: \f(CWAPR::Error\fR" 4
.IX Item "excpt: APR::Error"
.PD 0
.IP "since: 2.0.00" 4
.IX Item "since: 2.0.00"
.PD
.PP
The data is flushed only if \s-1STDOUT\s0 stream's \f(CW$|\fR is true. Otherwise
it's buffered up to the size of the buffer, flushing only excessive
data.
.ie n .SS """puts"""
.el .SS "\f(CWputs\fP"
.IX Subsection "puts"
Send data to the client
.PP
.Vb 1
\&  $cnt = $r\->puts(@msg);
.Ve
.ie n .IP "obj: $r ( ""Apache2::RequestRec object"" )" 4
.el .IP "obj: \f(CW$r\fR ( \f(CWApache2::RequestRec object\fR )" 4
.IX Item "obj: $r ( Apache2::RequestRec object )"
.PD 0
.ie n .IP "arg1: @msg ( \s-1ARRAY \s0)" 4
.el .IP "arg1: \f(CW@msg\fR ( \s-1ARRAY \s0)" 4
.IX Item "arg1: @msg ( ARRAY )"
.PD
Data to send
.ie n .IP "ret: $cnt ( number )" 4
.el .IP "ret: \f(CW$cnt\fR ( number )" 4
.IX Item "ret: $cnt ( number )"
How many bytes were sent (or buffered)
.ie n .IP "excpt: ""APR::Error""" 4
.el .IP "excpt: \f(CWAPR::Error\fR" 4
.IX Item "excpt: APR::Error"
.PD 0
.IP "since: 2.0.00" 4
.IX Item "since: 2.0.00"
.PD
.PP
\&\f(CW\*(C`puts()\*(C'\fR is similar to \f(CW\*(C`print()\*(C'\fR, but it won't attempt
to flush data, no matter what the value of \s-1STDOUT\s0 stream's \f(CW$|\fR
is. Therefore assuming that \s-1STDOUT\s0 stream's \f(CW$|\fR is true, this method
should be a tiny bit faster than \f(CW\*(C`print()\*(C'\fR, especially
if small strings are printed.
.ie n .SS """read"""
.el .SS "\f(CWread\fP"
.IX Subsection "read"
Read data from the client.
.PP
.Vb 2
\&  $cnt = $r\->read($buffer, $len);
\&  $cnt = $r\->read($buffer, $len, $offset);
.Ve
.ie n .IP "obj: $r ( ""Apache2::RequestRec object"" )" 4
.el .IP "obj: \f(CW$r\fR ( \f(CWApache2::RequestRec object\fR )" 4
.IX Item "obj: $r ( Apache2::RequestRec object )"
.PD 0
.ie n .IP "arg1: $buffer ( \s-1SCALAR \s0)" 4
.el .IP "arg1: \f(CW$buffer\fR ( \s-1SCALAR \s0)" 4
.IX Item "arg1: $buffer ( SCALAR )"
.PD
The buffer to populate with the read data
.ie n .IP "arg2: $len ( number )" 4
.el .IP "arg2: \f(CW$len\fR ( number )" 4
.IX Item "arg2: $len ( number )"
How many bytes to attempt to read
.ie n .IP "opt arg3: $offset ( number )" 4
.el .IP "opt arg3: \f(CW$offset\fR ( number )" 4
.IX Item "opt arg3: $offset ( number )"
If a non-zero \f(CW$offset\fR is specified, the read data will be placed at
that offset in the \f(CW$buffer\fR.
.Sp
\&\s-1META:\s0 negative offset and \e0 padding are not supported at the moment
.ie n .IP "ret: $cnt ( number )" 4
.el .IP "ret: \f(CW$cnt\fR ( number )" 4
.IX Item "ret: $cnt ( number )"
How many characters were actually read
.ie n .IP "excpt: ""APR::Error""" 4
.el .IP "excpt: \f(CWAPR::Error\fR" 4
.IX Item "excpt: APR::Error"
.PD 0
.IP "since: 2.0.00" 4
.IX Item "since: 2.0.00"
.PD
.PP
This method shares a lot of similarities with the Perl core \f(CW\*(C`read()\*(C'\fR
function. The main difference in the error handling, which is done via
\&\f(CW\*(C`APR::Error exceptions\*(C'\fR
.ie n .SS """rflush"""
.el .SS "\f(CWrflush\fP"
.IX Subsection "rflush"
Flush any buffered data to the client.
.PP
.Vb 1
\&  $r\->rflush();
.Ve
.ie n .IP "obj: $r ( ""Apache2::RequestRec object"" )" 4
.el .IP "obj: \f(CW$r\fR ( \f(CWApache2::RequestRec object\fR )" 4
.IX Item "obj: $r ( Apache2::RequestRec object )"
.PD 0
.IP "ret: no return value" 4
.IX Item "ret: no return value"
.IP "since: 2.0.00" 4
.IX Item "since: 2.0.00"
.PD
.PP
Unless \s-1STDOUT\s0 stream's \f(CW$|\fR is false, data sent via
\&\f(CW\*(C`$r\->print()\*(C'\fR is buffered. This method flushes that
data to the client.
.ie n .SS """sendfile"""
.el .SS "\f(CWsendfile\fP"
.IX Subsection "sendfile"
Send a file or a part of it
.PP
.Vb 3
\&  $rc = $r\->sendfile($filename);
\&  $rc = $r\->sendfile($filename, $offset);
\&  $rc = $r\->sendfile($filename, $offset, $len);
.Ve
.ie n .IP "obj: $r ( ""Apache2::RequestRec object"" )" 4
.el .IP "obj: \f(CW$r\fR ( \f(CWApache2::RequestRec object\fR )" 4
.IX Item "obj: $r ( Apache2::RequestRec object )"
.PD 0
.ie n .IP "arg1: $filename ( string )" 4
.el .IP "arg1: \f(CW$filename\fR ( string )" 4
.IX Item "arg1: $filename ( string )"
.PD
The full path to the file (using \f(CW\*(C`/\*(C'\fR on all systems)
.ie n .IP "opt arg2: $offset ( integer )" 4
.el .IP "opt arg2: \f(CW$offset\fR ( integer )" 4
.IX Item "opt arg2: $offset ( integer )"
Offset into the file to start sending.
.Sp
No offset is used if \f(CW$offset\fR is not specified.
.ie n .IP "opt arg3: $len ( integer )" 4
.el .IP "opt arg3: \f(CW$len\fR ( integer )" 4
.IX Item "opt arg3: $len ( integer )"
How many bytes to send.
.Sp
If not specified the whole file is sent (or a part of it, if
\&\f(CW$offset\fR if specified)
.ie n .IP "ret: $rc ( ""APR::Const status constant"" )" 4
.el .IP "ret: \f(CW$rc\fR ( \f(CWAPR::Const status constant\fR )" 4
.IX Item "ret: $rc ( APR::Const status constant )"
On success,
\&\f(CW\*(C`APR::Const::SUCCESS\*(C'\fR is
returned.
.Sp
In case of a failure \*(-- a failure code is returned, in which case
normally it should be returned to the caller.
.ie n .IP "excpt: ""APR::Error""" 4
.el .IP "excpt: \f(CWAPR::Error\fR" 4
.IX Item "excpt: APR::Error"
Exceptions are thrown only when this function is called in the \s-1VOID\s0
context. So if you don't want to handle the errors, just don't ask for
a return value and the function will handle all the errors on its own.
.IP "since: 2.0.00" 4
.IX Item "since: 2.0.00"
.ie n .SS """write"""
.el .SS "\f(CWwrite\fP"
.IX Subsection "write"
Send partial string to the client
.PP
.Vb 3
\&  $cnt = $r\->write($buffer);
\&  $cnt = $r\->write($buffer, $len);
\&  $cnt = $r\->write($buffer, $len, $offset);
.Ve
.ie n .IP "obj: $r ( ""Apache2::RequestRec object"" )" 4
.el .IP "obj: \f(CW$r\fR ( \f(CWApache2::RequestRec object\fR )" 4
.IX Item "obj: $r ( Apache2::RequestRec object )"
.PD 0
.ie n .IP "arg1: $buffer ( \s-1SCALAR \s0)" 4
.el .IP "arg1: \f(CW$buffer\fR ( \s-1SCALAR \s0)" 4
.IX Item "arg1: $buffer ( SCALAR )"
.PD
The string with data
.ie n .IP "opt arg2: $len ( \s-1SCALAR \s0)" 4
.el .IP "opt arg2: \f(CW$len\fR ( \s-1SCALAR \s0)" 4
.IX Item "opt arg2: $len ( SCALAR )"
How many bytes to send. If not specified, or \-1 is specified, all the
data in \f(CW$buffer\fR (or starting from \f(CW$offset\fR) will be sent.
.ie n .IP "opt arg3: $offset ( number )" 4
.el .IP "opt arg3: \f(CW$offset\fR ( number )" 4
.IX Item "opt arg3: $offset ( number )"
Offset into the \f(CW$buffer\fR string.
.ie n .IP "ret: $cnt ( number )" 4
.el .IP "ret: \f(CW$cnt\fR ( number )" 4
.IX Item "ret: $cnt ( number )"
How many bytes were sent (or buffered)
.ie n .IP "excpt: ""APR::Error""" 4
.el .IP "excpt: \f(CWAPR::Error\fR" 4
.IX Item "excpt: APR::Error"
.PD 0
.IP "since: 2.0.00" 4
.IX Item "since: 2.0.00"
.PD
.PP
Examples:
.PP
Assuming that we have a string:
.PP
.Vb 1
\&  $string = "123456789";
.Ve
.PP
Then:
.PP
.Vb 1
\&  $r\->write($string);
.Ve
.PP
sends:
.PP
.Vb 1
\&  123456789
.Ve
.PP
Whereas:
.PP
.Vb 1
\&  $r\->write($string, 3);
.Ve
.PP
sends:
.PP
.Vb 1
\&  123
.Ve
.PP
And:
.PP
.Vb 1
\&  $r\->write($string, 3, 5);
.Ve
.PP
sends:
.PP
.Vb 1
\&  678
.Ve
.PP
Finally:
.PP
.Vb 1
\&  $r\->write($string, \-1, 5);
.Ve
.PP
sends:
.PP
.Vb 1
\&  6789
.Ve
.SH "TIE Interface"
.IX Header "TIE Interface"
The \s-1TIE\s0 interface implementation. This interface is used for \s-1HTTP\s0
request handlers, when running under \f(CW\*(C`SetHandler
perl\-script\*(C'\fR and
Perl doesn't have perlio enabled.
.PP
See the \fIperltie\fR manpage for more information.
.ie n .SS """BINMODE"""
.el .SS "\f(CWBINMODE\fP"
.IX Subsection "BINMODE"
.IP "since: 2.0.00" 4
.IX Item "since: 2.0.00"
.PP
NoOP
.PP
See the \fIbinmode\fR Perl entry in the \fIperlfunc\fR manpage
.ie n .SS """CLOSE"""
.el .SS "\f(CWCLOSE\fP"
.IX Subsection "CLOSE"
.IP "since: 2.0.00" 4
.IX Item "since: 2.0.00"
.PP
NoOP
.PP
See the \fIclose\fR Perl entry in the \fIperlfunc\fR manpage
.ie n .SS """FILENO"""
.el .SS "\f(CWFILENO\fP"
.IX Subsection "FILENO"
.IP "since: 2.0.00" 4
.IX Item "since: 2.0.00"
.PP
See the \fIfileno\fR Perl entry in the \fIperlfunc\fR manpage
.ie n .SS """GETC"""
.el .SS "\f(CWGETC\fP"
.IX Subsection "GETC"
.IP "since: 2.0.00" 4
.IX Item "since: 2.0.00"
.PP
See the \fIgetc\fR Perl entry in the \fIperlfunc\fR manpage
.ie n .SS """OPEN"""
.el .SS "\f(CWOPEN\fP"
.IX Subsection "OPEN"
.IP "since: 2.0.00" 4
.IX Item "since: 2.0.00"
.PP
See the \fIopen\fR Perl entry in the \fIperlfunc\fR manpage
.ie n .SS """PRINT"""
.el .SS "\f(CWPRINT\fP"
.IX Subsection "PRINT"
.IP "since: 2.0.00" 4
.IX Item "since: 2.0.00"
.PP
See the \fIprint\fR Perl entry in the \fIperlfunc\fR manpage
.ie n .SS """PRINTF"""
.el .SS "\f(CWPRINTF\fP"
.IX Subsection "PRINTF"
.IP "since: 2.0.00" 4
.IX Item "since: 2.0.00"
.PP
See the \fIprintf\fR Perl entry in the \fIperlfunc\fR manpage
.ie n .SS """READ"""
.el .SS "\f(CWREAD\fP"
.IX Subsection "READ"
.IP "since: 2.0.00" 4
.IX Item "since: 2.0.00"
.PP
See the \fIread\fR Perl entry in the \fIperlfunc\fR manpage
.ie n .SS """TIEHANDLE"""
.el .SS "\f(CWTIEHANDLE\fP"
.IX Subsection "TIEHANDLE"
.IP "since: 2.0.00" 4
.IX Item "since: 2.0.00"
.PP
See the \fItie\fR Perl entry in the \fIperlfunc\fR manpage
.ie n .SS """UNTIE"""
.el .SS "\f(CWUNTIE\fP"
.IX Subsection "UNTIE"
.IP "since: 2.0.00" 4
.IX Item "since: 2.0.00"
.PP
NoOP
.PP
See the \fIuntie\fR Perl entry in the \fIperlfunc\fR manpage
.ie n .SS """WRITE"""
.el .SS "\f(CWWRITE\fP"
.IX Subsection "WRITE"
.IP "since: 2.0.00" 4
.IX Item "since: 2.0.00"
.PP
See the \fIwrite\fR Perl entry in the \fIperlfunc\fR manpage
.SH "Deprecated API"
.IX Header "Deprecated API"
The following methods are deprecated, Apache plans to remove those in
the future, therefore avoid using them.
.ie n .SS """get_client_block"""
.el .SS "\f(CWget_client_block\fP"
.IX Subsection "get_client_block"
This method is deprecated since the C implementation is buggy and we
don't want you to use it at all. Instead use the plain
\&\f(CW\*(C`$r\->read()\*(C'\fR.
.ie n .SS """setup_client_block"""
.el .SS "\f(CWsetup_client_block\fP"
.IX Subsection "setup_client_block"
This method is deprecated since
\&\f(CW\*(C`$r\->get_client_block\*(C'\fR is deprecated.
.ie n .SS """should_client_block"""
.el .SS "\f(CWshould_client_block\fP"
.IX Subsection "should_client_block"
This method is deprecated since
\&\f(CW\*(C`$r\->get_client_block\*(C'\fR is deprecated.
.SH "See Also"
.IX Header "See Also"
mod_perl 2.0 documentation.
.SH "Copyright"
.IX Header "Copyright"
mod_perl 2.0 and its core modules are copyrighted under
The Apache Software License, Version 2.0.
.SH "Authors"
.IX Header "Authors"
The mod_perl development team and numerous
contributors.
