.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PPI 3"
.TH PPI 3 "2011-02-25" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
PPI \- Parse, Analyze and Manipulate Perl (without perl)
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use PPI;
\&  
\&  # Create a new empty document
\&  my $Document = PPI::Document\->new;
\&  
\&  # Create a document from source
\&  $Document = PPI::Document\->new(\e\*(Aqprint "Hello World!\en"\*(Aq);
\&  
\&  # Load a Document from a file
\&  $Document = PPI::Document\->new(\*(AqModule.pm\*(Aq);
\&  
\&  # Does it contain any POD?
\&  if ( $Document\->find_any(\*(AqPPI::Token::Pod\*(Aq) ) {
\&      print "Module contains POD\en";
\&  }
\&  
\&  # Get the name of the main package
\&  $pkg = $Document\->find_first(\*(AqPPI::Statement::Package\*(Aq)\->namespace;
\&  
\&  # Remove all that nasty documentation
\&  $Document\->prune(\*(AqPPI::Token::Pod\*(Aq);
\&  $Document\->prune(\*(AqPPI::Token::Comment\*(Aq);
\&  
\&  # Save the file
\&  $Document\->save(\*(AqModule.pm.stripped\*(Aq);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
.SS "About this Document"
.IX Subsection "About this Document"
This is the \s-1PPI\s0 manual. It describes its reason for existing, its general
structure, its use, an overview of the \s-1API,\s0 and provides a few
implementation samples.
.SS "Background"
.IX Subsection "Background"
The ability to read, and manipulate Perl (the language) programmatically
other than with perl (the application) was one that caused difficulty
for a long time.
.PP
The cause of this problem was Perl's complex and dynamic grammar.
Although there is typically not a huge diversity in the grammar of most
Perl code, certain issues cause large problems when it comes to parsing.
.PP
Indeed, quite early in Perl's history Tom Christenson introduced the Perl
community to the quote \fI\*(L"Nothing but perl can parse Perl\*(R"\fR, or as it is
more often stated now as a truism:
.PP
\&\fB\*(L"Only perl can parse Perl\*(R"\fR
.PP
One example of the sorts of things the prevent Perl being easily parsed are
function signatures, as demonstrated by the following.
.PP
.Vb 1
\&  @result = (dothis $foo, $bar);
\&  
\&  # Which of the following is it equivalent to?
\&  @result = (dothis($foo), $bar);
\&  @result = dothis($foo, $bar);
.Ve
.PP
The first line above can be interpreted in two different ways, depending
on whether the \f(CW&dothis\fR function is expecting one argument, or two,
or several.
.PP
A \*(L"code parser\*(R" (something that parses for the purpose of execution) such
as perl needs information that is not found in the immediate vicinity of
the statement being parsed.
.PP
The information might not just be elsewhere in the file, it might not even be
in the same file at all. It might also not be able to determine this
information without the prior execution of a \f(CW\*(C`BEGIN {}\*(C'\fR block, or the
loading and execution of one or more external modules. Or worse the &dothis
function may not even have been written yet.
.PP
\&\fBWhen parsing Perl as code, you must also execute it\fR
.PP
Even perl itself never really fully understands the structure of the source
code after and indeed \fBas\fR it processes it, and in that sense doesn't
\&\*(L"parse\*(R" Perl source into anything remotely like a structured document.
This makes it of no real use for any task that needs to treat the source
code as a document, and do so reliably and robustly.
.PP
For more information on why it is impossible to parse perl, see Randal
Schwartz's seminal response to the question of \*(L"Why can't you parse Perl\*(R".
.PP
<http://www.perlmonks.org/index.pl?node_id=44722>
.PP
The purpose of \s-1PPI\s0 is \fBnot\fR to parse Perl \fICode\fR, but to parse Perl
\&\fIDocuments\fR. By treating the problem this way, we are able to parse a
single file containing Perl source code \*(L"isolated\*(R" from any other
resources, such as libraries upon which the code may depend, and
without needing to run an instance of perl alongside or inside the parser.
.PP
Historically, using an embedded perl parser was widely considered to be
the most likely avenue for finding a solution to \f(CW\*(C`Parse::Perl\*(C'\fR. It was
investigated from time to time and attempts have generally failed or
suffered from sufficiently bad corner cases that they were abandoned.
.SS "What Does \s-1PPI\s0 Stand For?"
.IX Subsection "What Does PPI Stand For?"
\&\f(CW\*(C`PPI\*(C'\fR is an acronym for the longer original module name
\&\f(CW\*(C`Parse::Perl::Isolated\*(C'\fR. And in the spirit or the silly acronym games
played by certain unnamed Open Source projects you may have \fIhurd\fR of,
it also a reverse backronym of \*(L"I Parse Perl\*(R".
.PP
Of course, I could just be lying and have just made that second bit up
10 minutes before the release of \s-1PPI 1.000.\s0 Besides, \fBall\fR the cool
Perl packages have TLAs (Three Letter Acronyms). It's a rule or something.
.PP
Why don't you just think of it as the \fBPerl Parsing Interface\fR for simplicity.
.PP
The original name was shortened to prevent the author (and you the users)
from contracting \s-1RSI\s0 by having to type crazy things like
\&\f(CW\*(C`Parse::Perl::Isolated::Token::QuoteLike::Backtick\*(C'\fR 100 times a day.
.PP
In acknowledgment that someone may some day come up with a valid solution
for the grammar problem it was decided at the commencement of the project
to leave the \f(CW\*(C`Parse::Perl\*(C'\fR namespace free for any such effort.
.PP
Since that time I've been able to prove to my own satisfaction that it
\&\fBis\fR truly impossible to accurately parse Perl as both code and document
at once. For the academics, parsing Perl suffers from the \*(L"Halting Problem\*(R".
.PP
With this in mind \f(CW\*(C`Parse::Perl\*(C'\fR has now been co-opted as the title for
the SourceForge project that publishes \s-1PPI\s0 and a large collection of other
applications and modules related to the (document) parsing of Perl source
code.
.PP
You can find this project at <http://sf.net/projects/parseperl>,
however we no longer use the SourceForge \s-1CVS\s0 server.  Instead, the
current development version of \s-1PPI\s0 is available via \s-1SVN\s0 at
<http://svn.ali.as/cpan/trunk/PPI/>.
.SS "Why Parse Perl?"
.IX Subsection "Why Parse Perl?"
Once you can accept that we will never be able to parse Perl well enough
to meet the standards of things that treat Perl as code, it is worth
re-examining \f(CW\*(C`why\*(C'\fR we want to \*(L"parse\*(R" Perl at all.
.PP
What are the things that people might want a \*(L"Perl parser\*(R" for.
.IP "Documentation" 4
.IX Item "Documentation"
Analyzing the contents of a Perl document to automatically generate
documentation, in parallel to, or as a replacement for, \s-1POD\s0 documentation.
.Sp
Allow an indexer to to locate and process all the comments and
documentation from code for \*(L"full text search\*(R" applications.
.IP "Structural and Quality Analysis" 4
.IX Item "Structural and Quality Analysis"
Determine quality or other metrics across a body of code, and identify
situations relating to particular phrases, techniques or locations.
.Sp
Index functions, variables and packages within Perl code, and doing search
and graph (in the node/edge sense) analysis of large code bases.
.IP "Refactoring" 4
.IX Item "Refactoring"
Make structural, syntax, or other changes to code in an automated manner,
either independently or in assistance to an editor. This sort of task list
includes backporting, forward porting, partial evaluation, \*(L"improving\*(R" code,
or whatever. All the sort of things you'd want from a Perl::Editor.
.IP "Layout" 4
.IX Item "Layout"
Change the layout of code without changing its meaning. This includes
techniques such as tidying (like perltidy), obfuscation, compressing and
\&\*(L"squishing\*(R", or to implement formatting preferences or policies.
.IP "Presentation" 4
.IX Item "Presentation"
This includes methods of improving the presentation of code, without changing
the content of the code. Modify, improve, syntax colour etc the presentation
of a Perl document. Generating \*(L"IntelliText\*(R"\-like functions.
.PP
If we treat this as a baseline for the sort of things we are going to have
to build on top of Perl, then it becomes possible to identify a standard
for how good a Perl parser needs to be.
.SS "How good is Good Enough(\s-1TM\s0)"
.IX Subsection "How good is Good Enough(TM)"
\&\s-1PPI\s0 seeks to be good enough to achieve all of the above tasks, or to provide
a sufficiently good \s-1API\s0 on which to allow others to implement modules in
these and related areas.
.PP
However, there are going to be limits to this process. Because \s-1PPI\s0 cannot
adapt to changing grammars, any code written using source filters should not
be assumed to be parsable.
.PP
At one extreme, this includes anything munged by Acme::Bleach, as well
as (arguably) more common cases like Switch. We do not pretend to be
able to always parse code using these modules, although as long as it still
follows a format that looks like Perl syntax, it may be possible to extend
the lexer to handle them.
.PP
The ability to extend \s-1PPI\s0 to handle lexical additions to the language is on
the drawing board to be done some time post\-1.0
.PP
The goal for success was originally to be able to successfully parse 99% of
all Perl documents contained in \s-1CPAN.\s0 This means the entire file in each
case.
.PP
\&\s-1PPI\s0 has succeeded in this goal far beyond the expectations of even the
author. At time of writing there are only 28 non-Acme Perl modules in \s-1CPAN\s0
that \s-1PPI\s0 is incapable of parsing. Most of these are so badly broken they
do not compile as Perl code anyway.
.PP
So unless you are actively going out of your way to break \s-1PPI,\s0 you should
expect that it will handle your code just fine.
.SS "Internationalisation"
.IX Subsection "Internationalisation"
\&\s-1PPI\s0 provides partial support for internationalisation and localisation.
.PP
Specifically, it allows the use characters from the Latin\-1 character
set to be used in quotes, comments, and \s-1POD.\s0 Primarily, this covers
languages from Europe and South America.
.PP
\&\s-1PPI\s0 does \fBnot\fR currently provide support for Unicode, although there
is an initial implementation available in a development branch from
\&\s-1CVS.\s0
.PP
If you need Unicode support, and would like to help stress test the
Unicode support so we can move it to the main branch and enable it
in the main release should contact the author. (contact details below)
.SS "Round Trip Safe"
.IX Subsection "Round Trip Safe"
When \s-1PPI\s0 parses a file it builds \fBeverything\fR into the model, including
whitespace. This is needed in order to make the Document fully \*(L"Round Trip\*(R"
safe.
.PP
The general concept behind a \*(L"Round Trip\*(R" parser is that it knows what it
is parsing is somewhat uncertain, and so \fBexpects\fR to get things wrong
from time to time. In the cases where it parses code wrongly the tree
will serialize back out to the same string of code that was read in,
repairing the parser's mistake as it heads back out to the file.
.PP
The end result is that if you parse in a file and serialize it back out
without changing the tree, you are guaranteed to get the same file you
started with. \s-1PPI\s0 does this correctly and reliably for 100% of all known
cases.
.PP
\&\fBWhat goes in, will come out. Every time.\fR
.PP
The one minor exception at this time is that if the newlines for your file
are wrong (meaning not matching the platform newline format), \s-1PPI\s0 will
localise them for you. (It isn't to be convenient, supporting
arbitrary newlines would make some of the code more complicated)
.PP
Better control of the newline type is on the wish list though, and
anyone wanting to help out is encouraged to contact the author.
.SH "IMPLEMENTATION"
.IX Header "IMPLEMENTATION"
.SS "General Layout"
.IX Subsection "General Layout"
\&\s-1PPI\s0 is built upon two primary \*(L"parsing\*(R" components, PPI::Tokenizer
and PPI::Lexer, and a large tree of about 50 classes which implement
the various the \fIPerl Document Object Model\fR (\s-1PDOM\s0).
.PP
The \s-1PDOM\s0 is conceptually similar in style and intent to the regular \s-1DOM\s0 or
other code Abstract Syntax Trees (ASTs), but contains some differences
to handle perl-specific cases, and to assist in treating the code as a
document. Please note that it is \fBnot\fR an implementation of the official
Document Object Model specification, only somewhat similar to it.
.PP
On top of the Tokenizer, Lexer and the classes of the \s-1PDOM,\s0 sit a number
of classes intended to make life a little easier when dealing with \s-1PDOM\s0
trees.
.PP
Both the major parsing components were hand-coded from scratch with only
plain Perl code and a few small utility modules. There are no grammar or
patterns mini-languages, no \s-1YACC\s0 or \s-1LEX\s0 style tools and only a small number
of regular expressions.
.PP
This is primarily because of the sheer volume of accumulated cruft that
exists in Perl. Not even perl itself is capable of parsing Perl documents
(remember, it just parses and executes it as code).
.PP
As a result, \s-1PPI\s0 needed to be cruftier than perl itself. Feel free to
shudder at this point, and hope you never have to understand the Tokenizer
codebase. Speaking of which...
.SS "The Tokenizer"
.IX Subsection "The Tokenizer"
The Tokenizer takes source code and converts it into a series of tokens. It
does this using a slow but thorough character by character manual process,
rather than using a pattern system or complex regexes.
.PP
Or at least it does so conceptually. If you were to actually trace the code
you would find it's not truly character by character due to a number of
regexps and optimisations throughout the code. This lets the Tokenizer
\&\*(L"skip ahead\*(R" when it can find shortcuts, so it tends to jump around a line
a bit wildly at times.
.PP
In practice, the number of times the Tokenizer will \fBactually\fR move the
character cursor itself is only about 5% \- 10% higher than the number of
tokens contained in the file. This makes it about as optimal as it can be
made without implementing it in something other than Perl.
.PP
In 2001 when \s-1PPI\s0 was started, this structure made \s-1PPI\s0 quite slow, and not
really suitable for interactive tasks. This situation has improved greatly
with multi-gigahertz processors, but can still be painful when working with
very large files.
.PP
The target parsing rate for \s-1PPI\s0 is about 5000 lines per gigacycle. It is
currently believed to be at about 1500, and main avenue for making it to
the target speed has now become \s-1PPI::XS\s0, a drop-in \s-1XS\s0 accelerator for
\&\s-1PPI.\s0
.PP
Since \s-1PPI::XS\s0 has only just gotten off the ground and is currently only
at proof-of-concept stage, this may take a little while. Anyone interested
in helping out with \s-1PPI::XS\s0 is \fBhighly\fR encouraged to contact the
author. In fact, the design of \s-1PPI::XS\s0 means it's possible to port
one function at a time safely and reliably. So every little bit will help.
.SS "The Lexer"
.IX Subsection "The Lexer"
The Lexer takes a token stream, and converts it to a lexical tree. Because
we are parsing Perl \fBdocuments\fR this includes whitespace, comments, and
all number of weird things that have no relevance when code is actually
executed.
.PP
An instantiated PPI::Lexer consumes PPI::Tokenizer objects and
produces PPI::Document objects. However you should probably never be
working with the Lexer directly. You should just be able to create
PPI::Document objects and work with them directly.
.SS "The Perl Document Object Model"
.IX Subsection "The Perl Document Object Model"
The \s-1PDOM\s0 is a structured collection of data classes that together provide
a correct and scalable model for documents that follow the standard Perl
syntax.
.SS "The \s-1PDOM\s0 Class Tree"
.IX Subsection "The PDOM Class Tree"
The following lists all of the 67 current \s-1PDOM\s0 classes, listing with indentation
based on inheritance.
.PP
.Vb 10
\&   PPI::Element
\&      PPI::Node
\&         PPI::Document
\&            PPI::Document::Fragment
\&         PPI::Statement
\&            PPI::Statement::Package
\&            PPI::Statement::Include
\&            PPI::Statement::Sub
\&               PPI::Statement::Scheduled
\&            PPI::Statement::Compound
\&            PPI::Statement::Break
\&            PPI::Statement::Given
\&            PPI::Statement::When
\&            PPI::Statement::Data
\&            PPI::Statement::End
\&            PPI::Statement::Expression
\&               PPI::Statement::Variable
\&            PPI::Statement::Null
\&            PPI::Statement::UnmatchedBrace
\&            PPI::Statement::Unknown
\&         PPI::Structure
\&            PPI::Structure::Block
\&            PPI::Structure::Subscript
\&            PPI::Structure::Constructor
\&            PPI::Structure::Condition
\&            PPI::Structure::List
\&            PPI::Structure::For
\&            PPI::Structure::Given
\&            PPI::Structure::When
\&            PPI::Structure::Unknown
\&      PPI::Token
\&         PPI::Token::Whitespace
\&         PPI::Token::Comment
\&         PPI::Token::Pod
\&         PPI::Token::Number
\&            PPI::Token::Number::Binary
\&            PPI::Token::Number::Octal
\&            PPI::Token::Number::Hex
\&            PPI::Token::Number::Float
\&               PPI::Token::Number::Exp
\&            PPI::Token::Number::Version
\&         PPI::Token::Word
\&         PPI::Token::DashedWord
\&         PPI::Token::Symbol
\&            PPI::Token::Magic
\&         PPI::Token::ArrayIndex
\&         PPI::Token::Operator
\&         PPI::Token::Quote
\&            PPI::Token::Quote::Single
\&            PPI::Token::Quote::Double
\&            PPI::Token::Quote::Literal
\&            PPI::Token::Quote::Interpolate
\&         PPI::Token::QuoteLike
\&            PPI::Token::QuoteLike::Backtick
\&            PPI::Token::QuoteLike::Command
\&            PPI::Token::QuoteLike::Regexp
\&            PPI::Token::QuoteLike::Words
\&            PPI::Token::QuoteLike::Readline
\&         PPI::Token::Regexp
\&            PPI::Token::Regexp::Match
\&            PPI::Token::Regexp::Substitute
\&            PPI::Token::Regexp::Transliterate
\&         PPI::Token::HereDoc
\&         PPI::Token::Cast
\&         PPI::Token::Structure
\&         PPI::Token::Label
\&         PPI::Token::Separator
\&         PPI::Token::Data
\&         PPI::Token::End
\&         PPI::Token::Prototype
\&         PPI::Token::Attribute
\&         PPI::Token::Unknown
.Ve
.PP
To summarize the above layout, all \s-1PDOM\s0 objects inherit from the
PPI::Element class.
.PP
Under this are PPI::Token, strings of content with a known type,
and PPI::Node, syntactically significant containers that hold other
Elements.
.PP
The three most important of these are the PPI::Document, the
PPI::Statement and the PPI::Structure classes.
.SS "The Document, Statement and Structure"
.IX Subsection "The Document, Statement and Structure"
At the top of all complete \s-1PDOM\s0 trees is a PPI::Document object. It
represents a complete file of Perl source code as you might find it on
disk.
.PP
There are some specialised types of document, such as PPI::Document::File
and PPI::Document::Normalized but for the purposes of the \s-1PDOM\s0 they are
all just considered to be the same thing.
.PP
Each Document will contain a number of \fBStatements\fR, \fBStructures\fR and
\&\fBTokens\fR.
.PP
A PPI::Statement is any series of Tokens and Structures that are treated
as a single contiguous statement by perl itself. You should note that a
Statement is as close as \s-1PPI\s0 can get to \*(L"parsing\*(R" the code in the sense that
perl-itself parses Perl code when it is building the op-tree.
.PP
Because of the isolation and Perl's syntax, it is provably impossible for
\&\s-1PPI\s0 to accurately determine precedence of operators or which tokens are
implicit arguments to a sub call.
.PP
So rather than lead you on with a bad guess that has a strong chance of
being wrong, \s-1PPI\s0 does not attempt to determine precedence or sub parameters
at all.
.PP
At a fundamental level, it only knows that this series of elements
represents a single Statement as perl sees it, but it can do so with
enough certainty that it can be trusted.
.PP
However, for specific Statement types the \s-1PDOM\s0 is able to derive additional
useful information about their meaning. For the best, most useful, and most
heavily used example, see PPI::Statement::Include.
.PP
A PPI::Structure is any series of tokens contained within matching braces.
This includes code blocks, conditions, function argument braces, anonymous
array and hash constructors, lists, scoping braces and all other syntactic
structures represented by a matching pair of braces, including (although it
may not seem obvious at first) \f(CW\*(C`<READLINE>\*(C'\fR braces.
.PP
Each Structure contains none, one, or many Tokens and Structures (the rules
for which vary for the different Structure subclasses)
.PP
Under the \s-1PDOM\s0 structure rules, a Statement can \fBnever\fR directly contain
another child Statement, a Structure can \fBnever\fR directly contain another
child Structure, and a Document can \fBnever\fR contain another Document
anywhere in the tree.
.PP
Aside from these three rules, the \s-1PDOM\s0 tree is extremely flexible.
.SS "The \s-1PDOM\s0 at Work"
.IX Subsection "The PDOM at Work"
To demonstrate the \s-1PDOM\s0 in use lets start with an example showing how the
tree might look for the following chunk of simple Perl code.
.PP
.Vb 1
\&  #!/usr/bin/perl
\&
\&  print( "Hello World!" );
\&
\&  exit();
.Ve
.PP
Translated into a \s-1PDOM\s0 tree it would have the following structure (as shown
via the included PPI::Dumper).
.PP
.Vb 10
\&  PPI::Document
\&    PPI::Token::Comment                \*(Aq#!/usr/bin/perl\en\*(Aq
\&    PPI::Token::Whitespace             \*(Aq\en\*(Aq
\&    PPI::Statement::Expression
\&      PPI::Token::Bareword             \*(Aqprint\*(Aq
\&      PPI::Structure::List             ( ... )
\&        PPI::Token::Whitespace         \*(Aq \*(Aq
\&        PPI::Statement::Expression
\&          PPI::Token::Quote::Double    \*(Aq"Hello World!"\*(Aq
\&        PPI::Token::Whitespace         \*(Aq \*(Aq
\&      PPI::Token::Structure            \*(Aq;\*(Aq
\&    PPI::Token::Whitespace             \*(Aq\en\*(Aq
\&    PPI::Token::Whitespace             \*(Aq\en\*(Aq
\&    PPI::Statement::Expression
\&      PPI::Token::Bareword             \*(Aqexit\*(Aq
\&      PPI::Structure::List             ( ... )
\&      PPI::Token::Structure            \*(Aq;\*(Aq
\&    PPI::Token::Whitespace             \*(Aq\en\*(Aq
.Ve
.PP
Please note that in this this example, strings are only listed for the
\&\fBactual\fR PPI::Token that contains that string. Structures are listed
with the type of brace characters it represents noted.
.PP
The PPI::Dumper module can be used to generate similar trees yourself.
.PP
We can make that \s-1PDOM\s0 dump a little easier to read if we strip out all the
whitespace. Here it is again, sans the distracting whitespace tokens.
.PP
.Vb 12
\&  PPI::Document
\&    PPI::Token::Comment                \*(Aq#!/usr/bin/perl\en\*(Aq
\&    PPI::Statement::Expression
\&      PPI::Token::Bareword             \*(Aqprint\*(Aq
\&      PPI::Structure::List             ( ... )
\&        PPI::Statement::Expression
\&          PPI::Token::Quote::Double    \*(Aq"Hello World!"\*(Aq
\&      PPI::Token::Structure            \*(Aq;\*(Aq
\&    PPI::Statement::Expression
\&      PPI::Token::Bareword             \*(Aqexit\*(Aq
\&      PPI::Structure::List             ( ... )
\&      PPI::Token::Structure            \*(Aq;\*(Aq
.Ve
.PP
As you can see, the tree can get fairly deep at time, especially when every
isolated token in a bracket becomes its own statement. This is needed to
allow anything inside the tree the ability to grow. It also makes the
search and analysis algorithms much more flexible.
.PP
Because of the depth and complexity of \s-1PDOM\s0 trees, a vast number of very easy
to use methods have been added wherever possible to help people working with
\&\s-1PDOM\s0 trees do normal tasks relatively quickly and efficiently.
.SS "Overview of the Primary Classes"
.IX Subsection "Overview of the Primary Classes"
The main \s-1PPI\s0 classes, and links to their own documentation, are listed
here in alphabetical order.
.IP "PPI::Document" 4
.IX Item "PPI::Document"
The Document object, the root of the \s-1PDOM.\s0
.IP "PPI::Document::Fragment" 4
.IX Item "PPI::Document::Fragment"
A cohesive fragment of a larger Document. Although not of any real current
use, it is needed for use in certain internal tree manipulation
algorithms.
.Sp
For example, doing things like cut/copy/paste etc. Very similar to a
PPI::Document, but has some additional methods and does not represent
a lexical scope boundary.
.Sp
A document fragment is also non-serializable, and so cannot be written out
to a file.
.IP "PPI::Dumper" 4
.IX Item "PPI::Dumper"
A simple class for dumping readable debugging versions of \s-1PDOM\s0 structures,
such as in the demonstration above.
.IP "PPI::Element" 4
.IX Item "PPI::Element"
The Element class is the abstract base class for all objects within the \s-1PDOM\s0
.IP "PPI::Find" 4
.IX Item "PPI::Find"
Implements an instantiable object form of a \s-1PDOM\s0 tree search.
.IP "PPI::Lexer" 4
.IX Item "PPI::Lexer"
The \s-1PPI\s0 Lexer. Converts Token streams into \s-1PDOM\s0 trees.
.IP "PPI::Node" 4
.IX Item "PPI::Node"
The Node object, the abstract base class for all \s-1PDOM\s0 objects that can
contain other Elements, such as the Document, Statement and Structure
objects.
.IP "PPI::Statement" 4
.IX Item "PPI::Statement"
The base class for all Perl statements. Generic \*(L"evaluate for side-effects\*(R"
statements are of this actual type. Other more interesting statement types
belong to one of its children.
.Sp
See it's own documentation for a longer description and list of all of the
different statement types and sub-classes.
.IP "PPI::Structure" 4
.IX Item "PPI::Structure"
The abstract base class for all structures. A Structure is a language
construct consisting of matching braces containing a set of other elements.
.Sp
See the PPI::Structure documentation for a description and
list of all of the different structure types and sub-classes.
.IP "PPI::Token" 4
.IX Item "PPI::Token"
A token is the basic unit of content. At its most basic, a Token is just
a string tagged with metadata (its class, and some additional flags in
some cases).
.IP "PPI::Token::_QuoteEngine" 4
.IX Item "PPI::Token::_QuoteEngine"
The PPI::Token::Quote and PPI::Token::QuoteLike classes provide
abstract base classes for the many and varied types of quote and
quote-like things in Perl. However, much of the actual quote login is
implemented in a separate quote engine, based at
PPI::Token::_QuoteEngine.
.Sp
Classes that inherit from PPI::Token::Quote, PPI::Token::QuoteLike
and PPI::Token::Regexp are generally parsed only by the Quote Engine.
.IP "PPI::Tokenizer" 4
.IX Item "PPI::Tokenizer"
The \s-1PPI\s0 Tokenizer. One Tokenizer consumes a chunk of text and provides
access to a stream of PPI::Token objects.
.Sp
The Tokenizer is very very complicated, to the point where even the author
treads carefully when working with it.
.Sp
Most of the complication is the result of optimizations which have tripled
the tokenization speed, at the expense of maintainability. We cope with the
spaghetti by heavily commenting everything.
.IP "PPI::Transform" 4
.IX Item "PPI::Transform"
The Perl Document Transformation \s-1API.\s0 Provides a standard interface and
abstract base class for objects and classes that manipulate Documents.
.SH "INSTALLING"
.IX Header "INSTALLING"
The core \s-1PPI\s0 distribution is pure Perl and has been kept as tight as
possible and with as few dependencies as possible.
.PP
It should download and install normally on any platform from within
the \s-1CPAN\s0 and \s-1CPANPLUS\s0 applications, or directly using the distribution
tarball. If installing by hand, you may need to install a few small
utility modules first. The exact ones will depend on your version of
perl.
.PP
There are no special install instructions for \s-1PPI,\s0 and the normal
\&\f(CW\*(C`Perl Makefile.PL\*(C'\fR, \f(CW\*(C`make\*(C'\fR, \f(CW\*(C`make test\*(C'\fR, \f(CW\*(C`make install\*(C'\fR instructions
apply.
.SH "EXTENDING"
.IX Header "EXTENDING"
The \s-1PPI\s0 namespace itself is reserved for the sole use of the modules under
the umbrella of the \f(CW\*(C`Parse::Perl\*(C'\fR SourceForge project.
.PP
<http://sf.net/projects/parseperl>
.PP
You are recommended to use the PPIx:: namespace for PPI-specific
modifications or prototypes thereof, or Perl:: for modules which provide
a general Perl language-related functions.
.PP
If what you wish to implement looks like it fits into PPIx:: namespace,
you should consider contacting the \f(CW\*(C`Parse::Perl\*(C'\fR mailing list (detailed on
the SourceForge site) first, as what you want may already be in progress,
or you may wish to consider joining the team and doing it within the
\&\f(CW\*(C`Parse::Perl\*(C'\fR project itself.
.SH "TO DO"
.IX Header "TO DO"
\&\- Many more analysis and utility methods for \s-1PDOM\s0 classes
.PP
\&\- Creation of a PPI::Tutorial document
.PP
\&\- Add many more key functions to \s-1PPI::XS\s0
.PP
\&\- We can \fBalways\fR write more and better unit tests
.PP
\&\- Complete the full implementation of \->literal (1.200)
.PP
\&\- Full understanding of scoping (due 1.300)
.SH "SUPPORT"
.IX Header "SUPPORT"
This module is stored in an Open Repository at the following address.
.PP
<http://svn.ali.as/cpan/trunk/PPI>
.PP
Write access to the repository is made available automatically to any
published \s-1CPAN\s0 author, and to most other volunteers on request.
.PP
If you are able to submit your bug report in the form of new (failing)
unit tests, or can apply your fix directly instead of submitting a patch,
you are \fBstrongly\fR encouraged to do so, as the author currently maintains
over 100 modules and it can take some time to deal with non\-\*(L"Critical\*(R" bug
reports or patches.
.PP
This will also guarentee that your issue will be addressed in the next
release of the module.
.PP
For large changes though, please consider creating a branch so that they
can be properly reviewed and trialed before being applied to the trunk.
.PP
If you cannot provide a direct test or fix, or don't have time to do so,
then regular bug reports are still accepted and appreciated via the \s-1CPAN\s0
bug tracker.
.PP
<http://rt.cpan.org/NoAuth/ReportBug.html?Queue=PPI>
.PP
For other issues or questions, contact the \f(CW\*(C`Parse::Perl\*(C'\fR project mailing
list.
.PP
For commercial or media-related enquiries, or to have your \s-1SVN\s0 commit bit
enabled, contact the author.
.SH "AUTHOR"
.IX Header "AUTHOR"
Adam Kennedy <adamk@cpan.org>
.SH "ACKNOWLEDGMENTS"
.IX Header "ACKNOWLEDGMENTS"
A huge thank you to Phase N Australia (<http://phase\-n.com/>) for
permitting the original open sourcing and release of this distribution
from what was originally several thousand hours of commercial work.
.PP
Another big thank you to The Perl Foundation
(<http://www.perlfoundation.org/>) for funding for the final big
refactoring and completion run.
.PP
Also, to the various co-maintainers that have contributed both large and
small with tests and patches and especially to those rare few who have
deep-dived into the guts to (gasp) add a feature.
.PP
.Vb 4
\&  \- Dan Brook       : PPIx::XPath, Acme::PerlML
\&  \- Audrey Tang     : "Line Noise" Testing
\&  \- Arjen Laarhoven : Three\-element \->location support
\&  \- Elliot Shank    : Perl 5.10 support, five\-element \->location
.Ve
.PP
And finally, thanks to those brave ( and foolish :) ) souls willing to dive
in and use, test drive and provide feedback on \s-1PPI\s0 before version 1.000,
in some cases before it made it to beta quality, and still did extremely
distasteful things (like eating 50 meg of \s-1RAM\s0 a second).
.PP
I owe you all a beer. Corner me somewhere and collect at your convenience.
If I missed someone who wasn't in my email history, thank you too :)
.PP
.Vb 10
\&  # In approximate order of appearance
\&  \- Claes Jacobsson
\&  \- Michael Schwern
\&  \- Jeff T. Parsons
\&  \- CPAN Author "CHOCOLATEBOY"
\&  \- Robert Rotherberg
\&  \- CPAN Author "PODMASTER"
\&  \- Richard Soderberg
\&  \- Nadim ibn Hamouda el Khemir
\&  \- Graciliano M. P.
\&  \- Leon Brocard
\&  \- Jody Belka
\&  \- Curtis Ovid
\&  \- Yuval Kogman
\&  \- Michael Schilli
\&  \- Slaven Rezic
\&  \- Lars Thegler
\&  \- Tony Stubblebine
\&  \- Tatsuhiko Miyagawa
\&  \- CPAN Author "CHROMATIC"
\&  \- Matisse Enzer
\&  \- Roy Fulbright
\&  \- Dan Brook
\&  \- Johnny Lee
\&  \- Johan Lindstrom
.Ve
.PP
And to single one person out, thanks go to Randal Schwartz who
spent a great number of hours in \s-1IRC\s0 over a critical 6 month period
explaining why Perl is impossibly unparsable and constantly shoving evil
and ugly corner cases in my face. He remained a tireless devil's advocate,
and without his support this project genuinely could never have been
completed.
.PP
So for my schooling in the Deep Magiks, you have my deepest gratitude Randal.
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright 2001 \- 2011 Adam Kennedy.
.PP
This program is free software; you can redistribute
it and/or modify it under the same terms as Perl itself.
.PP
The full text of the license can be found in the
\&\s-1LICENSE\s0 file included with this module.
