.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Moose::Manual::BestPractices 3"
.TH Moose::Manual::BestPractices 3 "2014-01-19" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Moose::Manual::BestPractices \- Get the most out of Moose
.SH "VERSION"
.IX Header "VERSION"
version 2.1202
.SH "RECOMMENDATIONS"
.IX Header "RECOMMENDATIONS"
Moose has a lot of features, and there's definitely more than one way
to do it. However, we think that picking a subset of these features
and using them consistently makes everyone's life easier.
.PP
Of course, as with any list of \*(L"best practices\*(R", these are really just
opinions. Feel free to ignore us.
.ie n .SS """namespace::autoclean"" and immutabilize"
.el .SS "\f(CWnamespace::autoclean\fP and immutabilize"
.IX Subsection "namespace::autoclean and immutabilize"
We recommend that you remove the Moose sugar and end your Moose class
definitions by making your class immutable.
.PP
.Vb 1
\&  package Person;
\&
\&  use Moose;
\&  use namespace::autoclean;
\&
\&  # extends, roles, attributes, etc.
\&
\&  # methods
\&
\&  _\|_PACKAGE_\|_\->meta\->make_immutable;
\&
\&  1;
.Ve
.PP
The \f(CW\*(C`use namespace::autoclean\*(C'\fR bit is simply good code hygiene, as it removes
imported symbols from your class's namespace at the end of your package's
compile cycle, including Moose keywords.  Once the class has been built, these
keywords are not needed. (This is preferred to placing \f(CW\*(C`no Moose\*(C'\fR at the end
of your package).
.PP
The \f(CW\*(C`make_immutable\*(C'\fR call allows Moose to speed up a lot of things, most
notably object construction. The trade-off is that you can no longer change
the class definition.
.ie n .SS "Never override ""new"""
.el .SS "Never override \f(CWnew\fP"
.IX Subsection "Never override new"
Overriding \f(CW\*(C`new\*(C'\fR is a very bad practice. Instead, you should use a
\&\f(CW\*(C`BUILD\*(C'\fR or \f(CW\*(C`BUILDARGS\*(C'\fR methods to do the same thing. When you
override \f(CW\*(C`new\*(C'\fR, Moose can no longer inline a constructor when your
class is immutabilized.
.PP
There are two good reasons to override \f(CW\*(C`new\*(C'\fR. One, you are writing a
MooseX extension that provides its own Moose::Object subclass
\&\fIand\fR a subclass of Moose::Meta::Method::Constructor to inline the
constructor. Two, you are subclassing a non-Moose parent.
.PP
If you know how to do that, you know when to ignore this best practice
;)
.ie n .SS "Always call the original/parent ""BUILDARGS"""
.el .SS "Always call the original/parent \f(CWBUILDARGS\fP"
.IX Subsection "Always call the original/parent BUILDARGS"
If you \f(CW\*(C`override\*(C'\fR the \f(CW\*(C`BUILDARGS\*(C'\fR method in your class, make sure to play
nice and call \f(CW\*(C`super()\*(C'\fR to handle cases you're not checking for explicitly.
.PP
The default \f(CW\*(C`BUILDARGS\*(C'\fR method in Moose::Object handles both a
list and hashref of named parameters correctly, and also checks for a
\&\fInon-hashref\fR single argument.
.ie n .SS "Provide defaults whenever possible, otherwise use ""required"""
.el .SS "Provide defaults whenever possible, otherwise use \f(CWrequired\fP"
.IX Subsection "Provide defaults whenever possible, otherwise use required"
When your class provides defaults, this makes constructing new objects
simpler. If you cannot provide a default, consider making the
attribute \f(CW\*(C`required\*(C'\fR.
.PP
If you don't do either, an attribute can simply be left unset,
increasing the complexity of your object, because it has more possible
states that you or the user of your class must account for.
.ie n .SS "Use ""builder"" instead of ""default"" most of the time"
.el .SS "Use \f(CWbuilder\fP instead of \f(CWdefault\fP most of the time"
.IX Subsection "Use builder instead of default most of the time"
Builders can be inherited, they have explicit names, and they're just
plain cleaner.
.PP
However, \fIdo\fR use a default when the default is a non-reference,
\&\fIor\fR when the default is simply an empty reference of some sort.
.PP
Also, keep your builder methods private.
.ie n .SS "Be ""lazy"""
.el .SS "Be \f(CWlazy\fP"
.IX Subsection "Be lazy"
Lazy is good, and often solves initialization ordering problems. It's also
good for deferring work that may never have to be done. Make your attributes
\&\f(CW\*(C`lazy\*(C'\fR unless they're \f(CW\*(C`required\*(C'\fR or have trivial defaults.
.SS "Consider keeping clearers and predicates private"
.IX Subsection "Consider keeping clearers and predicates private"
Does everyone \fIreally\fR need to be able to clear an attribute?
Probably not. Don't expose this functionality outside your class
by default.
.PP
Predicates are less problematic, but there's no reason to make your
public \s-1API\s0 bigger than it has to be.
.ie n .SS "Avoid ""lazy_build"""
.el .SS "Avoid \f(CWlazy_build\fP"
.IX Subsection "Avoid lazy_build"
As described above, you rarely actually need a clearer or a predicate.
\&\f(CW\*(C`lazy_build\*(C'\fR adds both to your public \s-1API,\s0 which exposes you to use cases that
you must now test for. It's much better to avoid adding them until you really
need them \- use explicit \f(CW\*(C`lazy\*(C'\fR and \f(CW\*(C`builder\*(C'\fR options instead.
.SS "Default to read-only, and consider keeping writers private"
.IX Subsection "Default to read-only, and consider keeping writers private"
Making attributes mutable just means more complexity to account for in
your program. The alternative to mutable state is to encourage users
of your class to simply make new objects as needed.
.PP
If you \fImust\fR make an attribute read-write, consider making the
writer a separate private method. Narrower APIs are easy to maintain,
and mutable state is trouble.
.PP
In order to declare such attributes, provide a private \f(CW\*(C`writer\*(C'\fR
parameter:
.PP
.Vb 5
\&    has pizza => (
\&        is     => \*(Aqro\*(Aq,
\&        isa    => \*(AqPizza\*(Aq,
\&        writer => \*(Aq_pizza\*(Aq,
\&    );
.Ve
.SS "Think twice before changing an attribute's type in a subclass"
.IX Subsection "Think twice before changing an attribute's type in a subclass"
Down this path lies great confusion. If the attribute is an object
itself, at least make sure that it has the same interface as the type
of object in the parent class.
.ie n .SS "Don't use the ""initializer"" feature"
.el .SS "Don't use the \f(CWinitializer\fP feature"
.IX Subsection "Don't use the initializer feature"
Don't know what we're talking about? That's fine.
.ie n .SS "Use Moose::Meta::Attribute::Native traits instead of ""auto_deref"""
.el .SS "Use Moose::Meta::Attribute::Native traits instead of \f(CWauto_deref\fP"
.IX Subsection "Use Moose::Meta::Attribute::Native traits instead of auto_deref"
The \f(CW\*(C`auto_deref\*(C'\fR feature is a bit troublesome. Directly exposing a complex
attribute is ugly. Instead, consider using Moose::Meta::Attribute::Native
traits to define an \s-1API\s0 that only exposes the necessary pieces of
functionality.
.ie n .SS "Always call ""inner"" in the most specific subclass"
.el .SS "Always call \f(CWinner\fP in the most specific subclass"
.IX Subsection "Always call inner in the most specific subclass"
When using \f(CW\*(C`augment\*(C'\fR and \f(CW\*(C`inner\*(C'\fR, we recommend that you call
\&\f(CW\*(C`inner\*(C'\fR in the most specific subclass of your hierarchy. This makes
it possible to subclass further and extend the hierarchy without
changing the parents.
.SS "Namespace your types"
.IX Subsection "Namespace your types"
Use some sort of namespacing convention for type names. We recommend something
like \*(L"MyApp::Type::Foo\*(R". We also recommend considering MooseX::Types.
.SS "Do not coerce Moose built-ins directly"
.IX Subsection "Do not coerce Moose built-ins directly"
If you define a coercion for a Moose built-in like \f(CW\*(C`ArrayRef\*(C'\fR, this
will affect every application in the Perl interpreter that uses this
type.
.PP
.Vb 4
\&    # very naughty!
\&    coerce \*(AqArrayRef\*(Aq
\&        => from Str
\&        => via { [ split /,/ ] };
.Ve
.PP
Instead, create a subtype and coerce that:
.PP
.Vb 1
\&    subtype \*(AqMy::ArrayRef\*(Aq => as \*(AqArrayRef\*(Aq;
\&
\&    coerce \*(AqMy::ArrayRef\*(Aq
\&        => from \*(AqStr\*(Aq
\&        => via { [ split /,/ ] };
.Ve
.SS "Do not coerce class names directly"
.IX Subsection "Do not coerce class names directly"
Just as with Moose built-in types, a class type is global for the
entire interpreter. If you add a coercion for that class name, it can
have magical side effects elsewhere:
.PP
.Vb 4
\&    # also very naughty!
\&    coerce \*(AqHTTP::Headers\*(Aq
\&        => from \*(AqHashRef\*(Aq
\&        => via { HTTP::Headers\->new( %{$_} ) };
.Ve
.PP
Instead, we can create an \*(L"empty\*(R" subtype for the coercion:
.PP
.Vb 1
\&    subtype \*(AqMy::HTTP::Headers\*(Aq => as class_type(\*(AqHTTP::Headers\*(Aq);
\&
\&    coerce \*(AqMy::HTTP::Headers\*(Aq
\&        => from \*(AqHashRef\*(Aq
\&        => via { HTTP::Headers\->new( %{$_} ) };
.Ve
.SS "Use coercion instead of unions"
.IX Subsection "Use coercion instead of unions"
Consider using a type coercion instead of a type union. This was
covered in Moose::Manual::Types.
.SS "Define all your types in one module"
.IX Subsection "Define all your types in one module"
Define all your types and coercions in one module. This was also
covered in Moose::Manual::Types.
.SH "BENEFITS OF BEST PRACTICES"
.IX Header "BENEFITS OF BEST PRACTICES"
Following these practices has a number of benefits.
.PP
It helps ensure that your code will play nice with others, making it
more reusable and easier to extend.
.PP
Following an accepted set of idioms will make maintenance easier,
especially when someone else has to maintain your code. It will also
make it easier to get support from other Moose users, since your code
will be easier to digest quickly.
.PP
Some of these practices are designed to help Moose do the right thing,
especially when it comes to immutabilization. This means your code
will be faster when immutabilized.
.PP
Many of these practices also help get the most out of meta
programming. If you used an overridden \f(CW\*(C`new\*(C'\fR to do type coercion by
hand, rather than defining a real coercion, there is no introspectable
metadata. This sort of thing is particularly problematic for MooseX
extensions which rely on introspection to do the right thing.
.SH "AUTHORS"
.IX Header "AUTHORS"
.IP "\(bu" 4
Stevan Little <stevan.little@iinteractive.com>
.IP "\(bu" 4
Dave Rolsky <autarch@urth.org>
.IP "\(bu" 4
Jesse Luehrs <doy@tozt.net>
.IP "\(bu" 4
Shawn M Moore <code@sartak.org>
.IP "\(bu" 4
\&\s-1XXXX XXX\s0'\s-1XX \s0(Yuval Kogman) <nothingmuch@woobling.org>
.IP "\(bu" 4
Karen Etheridge <ether@cpan.org>
.IP "\(bu" 4
Florian Ragwitz <rafl@debian.org>
.IP "\(bu" 4
Hans Dieter Pearcey <hdp@weftsoar.net>
.IP "\(bu" 4
Chris Prather <chris@prather.org>
.IP "\(bu" 4
Matt S Trout <mst@shadowcat.co.uk>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is copyright (c) 2006 by Infinity Interactive, Inc..
.PP
This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.
