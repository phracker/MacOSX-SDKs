.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Locale::Maketext::Lexicon 3"
.TH Locale::Maketext::Lexicon 3 "2014-02-03" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Locale::Maketext::Lexicon \- Use other catalog formats in Maketext
.SH "VERSION"
.IX Header "VERSION"
version 0.99
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
As part of a localization class, automatically glob for available
lexicons:
.PP
.Vb 10
\&    package Hello::I18N;
\&    use base \*(AqLocale::Maketext\*(Aq;
\&    use Locale::Maketext::Lexicon {
\&        \*(Aq*\*(Aq => [Gettext => \*(Aq/usr/local/share/locale/*/LC_MESSAGES/hello.mo\*(Aq],
\&        ### Uncomment to fallback when a key is missing from lexicons
\&        # _auto   => 1,
\&        ### Uncomment to decode lexicon entries into Unicode strings
\&        # _decode => 1,
\&        ### Uncomment to load and parse everything right away
\&        # _preload => 1,
\&        ### Uncomment to use %1 / %quant(%1) instead of [_1] / [quant, _1]
\&        # _style  => \*(Aqgettext\*(Aq,
\&    };
.Ve
.PP
Explicitly specify languages, during compile\- or run-time:
.PP
.Vb 10
\&    package Hello::I18N;
\&    use base \*(AqLocale::Maketext\*(Aq;
\&    use Locale::Maketext::Lexicon {
\&        de => [Gettext => \*(Aqhello_de.po\*(Aq],
\&        fr => [
\&            Gettext => \*(Aqhello_fr.po\*(Aq,
\&            Gettext => \*(Aqlocal/hello/fr.po\*(Aq,
\&        ],
\&    };
\&    # ... incrementally add new lexicons
\&    Locale::Maketext::Lexicon\->import({
\&        de => [Gettext => \*(Aqlocal/hello/de.po\*(Aq],
\&    })
.Ve
.PP
Alternatively, as part of a localization subclass:
.PP
.Vb 11
\&    package Hello::I18N::de;
\&    use base \*(AqHello::I18N\*(Aq;
\&    use Locale::Maketext::Lexicon (Gettext => \e*DATA);
\&    _\|_DATA_\|_
\&    # Some sample data
\&    msgid ""
\&    msgstr ""
\&    "Project\-Id\-Version: Hello 1.3.22.1\en"
\&    "MIME\-Version: 1.0\en"
\&    "Content\-Type: text/plain; charset=iso8859\-1\en"
\&    "Content\-Transfer\-Encoding: 8bit\en"
\&
\&    #: Hello.pm:10
\&    msgid "Hello, World!"
\&    msgstr "Hallo, Welt!"
\&
\&    #: Hello.pm:11
\&    msgid "You have %quant(%1,piece) of mail."
\&    msgstr "Sie haben %quant(%1,Poststueck,Poststuecken)."
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module provides lexicon-handling modules to read from other
localization formats, such as \fIGettext\fR, \fIMsgcat\fR, and so on.
.PP
If you are unfamiliar with the concept of lexicon modules, please
consult Locale::Maketext and the \f(CW\*(C`webl10n\*(C'\fR \s-1HTML\s0 files in the \f(CW\*(C`docs/\*(C'\fR
directory of this module.
.PP
A command-line utility xgettext.pl is also installed with this
module, for extracting translatable strings from source files.
.ie n .SS "The ""import"" function"
.el .SS "The \f(CWimport\fP function"
.IX Subsection "The import function"
The \f(CW\*(C`import()\*(C'\fR function accepts two forms of arguments:
.IP "(\fIformat\fR => \fIsource\fR ... )" 4
.IX Item "(format => source ... )"
This form takes any number of argument pairs (usually one);
\&\fIsource\fR may be a file name, a filehandle, or an array reference.
.Sp
For each such pair, it pass the contents specified by the second
argument to \fBLocale::Maketext::Lexicon::\f(BIformat\fB\fR\->parse as a
plain list, and export its return value as the \f(CW%Lexicon\fR hash
in the calling package.
.Sp
In the case that there are multiple such pairs, the lexicon
defined by latter ones overrides earlier ones.
.IP "{ \fIlanguage\fR => [ \fIformat\fR, \fIsource\fR ... ] ... }" 4
.IX Item "{ language => [ format, source ... ] ... }"
This form accepts a hash reference.  It will export a \f(CW%Lexicon\fR
into the subclasses specified by each \fIlanguage\fR, using the process
described above.  It is designed to alleviate the need to set up a
separate subclass for each localized language, and just use the catalog
files.
.Sp
This module will convert the \fIlanguage\fR arguments into lowercase,
and replace all \f(CW\*(C`\-\*(C'\fR with \f(CW\*(C`_\*(C'\fR, so \f(CW\*(C`zh_TW\*(C'\fR and \f(CW\*(C`zh\-tw\*(C'\fR will both
map to the \f(CW\*(C`zh_tw\*(C'\fR subclass.
.Sp
If \fIlanguage\fR begins with \f(CW\*(C`_\*(C'\fR, it is taken as an option that
controls how lexicons are parsed.  See \*(L"Options\*(R" for a list
of available options.
.Sp
The \f(CW\*(C`*\*(C'\fR is a special \fIlanguage\fR; it must be used in conjunction
with a filename that also contains \f(CW\*(C`*\*(C'\fR; all matched files with
a valid language code in the place of \f(CW\*(C`*\*(C'\fR will be automatically
prepared as a lexicon subclass.  If there is multiple \f(CW\*(C`*\*(C'\fR in
the filename, the last one is used as the language name.
.SS "Options"
.IX Subsection "Options"
.ie n .IP """_auto""" 4
.el .IP "\f(CW_auto\fR" 4
.IX Item "_auto"
If set to a true value, missing lookups on lexicons are handled
silently, as if an \f(CW\*(C`Auto\*(C'\fR lexicon has been appended on all
language lexicons.
.ie n .IP """_decode""" 4
.el .IP "\f(CW_decode\fR" 4
.IX Item "_decode"
If set to a true value, source entries will be converted into
utf8\-strings (available in Perl 5.6.1 or later).  This feature
needs the \fBEncode\fR or \fBEncode::compat\fR module.
.Sp
Currently, only the \f(CW\*(C`Gettext\*(C'\fR backend supports this option.
.ie n .IP """_encoding""" 4
.el .IP "\f(CW_encoding\fR" 4
.IX Item "_encoding"
This option only has effect when \f(CW\*(C`_decode\*(C'\fR is set to true.
It specifies an encoding to store lexicon entries, instead of
utf8\-strings.
.Sp
If \f(CW\*(C`_encoding\*(C'\fR is set to \f(CW\*(C`locale\*(C'\fR, the encoding from the
current locale setting is used.
.ie n .IP """_preload""" 4
.el .IP "\f(CW_preload\fR" 4
.IX Item "_preload"
By default parsing is delayed until first use of the lexicon,
set this option to true value to parse it asap. Increment
adding lexicons forces parsing.
.SS "Subclassing format handlers"
.IX Subsection "Subclassing format handlers"
If you wish to override how sources specified in different data types
are handled, please use a subclass that overrides \f(CW\*(C`lexicon_get_\f(CITYPE\f(CW\*(C'\fR.
.PP
\&\s-1XXX:\s0 not documented well enough yet.  Patches welcome.
.SH "VERSION"
.IX Header "VERSION"
This document describes version 0.91 of Locale::Maketext::Lexicon.
.SH "NOTES"
.IX Header "NOTES"
When you attempt to localize an entry missing in the lexicon, Maketext
will throw an exception by default.  To inhibit this behaviour, override
the \f(CW\*(C`_AUTO\*(C'\fR key in your language subclasses, for example:
.PP
.Vb 1
\&    $Hello::I18N::en::Lexicon{_AUTO} = 1; # autocreate missing keys
.Ve
.PP
If you want to implement a new \f(CW\*(C`Lexicon::*\*(C'\fR backend module, please note
that \f(CW\*(C`parse()\*(C'\fR takes an array containing the \fBsource strings\fR from the
specified filehandle or filename, which are \fInot\fR \f(CW\*(C`chomp\*(C'\fRed.  Although
if the source is an array reference, its elements will probably not contain
any newline characters anyway.
.PP
The \f(CW\*(C`parse()\*(C'\fR function should return a hash reference, which will be
assigned to the \fItypeglob\fR (\f(CW*Lexicon\fR) of the language module.  All
it amounts to is that if the returned reference points to a tied hash,
the \f(CW%Lexicon\fR will be aliased to the same tied hash if it was not
initialized previously.
.SH "ACKNOWLEDGMENTS"
.IX Header "ACKNOWLEDGMENTS"
Thanks to Jesse Vincent for suggesting this module to be written.
.PP
Thanks also to Sean M. Burke for coming up with \fBLocale::Maketext\fR
in the first place, and encouraging me to experiment with alternative
Lexicon syntaxes.
.PP
Thanks also to Yi Ma Mao for providing the \s-1MO\s0 file parsing subroutine,
as well as inspiring me to implement file globbing and transcoding
support.
.PP
See the \fI\s-1AUTHORS\s0\fR file in the distribution for a list of people who
have sent helpful patches, ideas or comments.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
xgettext.pl for extracting translatable strings from common template
systems and perl source files.
.PP
Locale::Maketext, Locale::Maketext::Lexicon::Auto,
Locale::Maketext::Lexicon::Gettext, Locale::Maketext::Lexicon::Msgcat,
Locale::Maketext::Lexicon::Tie
.SH "AUTHORS"
.IX Header "AUTHORS"
Audrey Tang <cpan@audreyt.org>
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright 2002\-2013 by Audrey Tang <cpan@audreyt.org>.
.PP
This software is released under the \s-1MIT\s0 license cited below.
.ie n .SS "The ""\s-1MIT""\s0 License"
.el .SS "The ``\s-1MIT''\s0 License"
.IX Subsection "The MIT License"
Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the \*(L"Software\*(R"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:
.PP
The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.
.PP
\&\s-1THE SOFTWARE IS PROVIDED \*(L"AS IS\*(R", WITHOUT WARRANTY OF ANY KIND, EXPRESS
OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.\s0
.SH "AUTHORS"
.IX Header "AUTHORS"
.IP "\(bu" 4
Clinton Gormley <drtech@cpan.org>
.IP "\(bu" 4
Audrey Tang <cpan@audreyt.org>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is Copyright (c) 2014 by Audrey Tang.
.PP
This is free software, licensed under:
.PP
.Vb 1
\&  The MIT (X11) License
.Ve
