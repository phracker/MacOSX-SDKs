.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "RSA 3"
.TH RSA 3 "2011-08-24" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Crypt::OpenSSL::RSA \- RSA encoding and decoding, using the openSSL libraries
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&  use Crypt::OpenSSL::Random;
\&  use Crypt::OpenSSL::RSA;
\&
\&  # not necessary if we have /dev/random:
\&  Crypt::OpenSSL::Random::random_seed($good_entropy);
\&  Crypt::OpenSSL::RSA\->import_random_seed();
\&  $rsa_pub = Crypt::OpenSSL::RSA\->new_public_key($key_string);
\&  $rsa_pub\->use_sslv23_padding(); # use_pkcs1_oaep_padding is the default
\&  $ciphertext = $rsa\->encrypt($plaintext);
\&
\&  $rsa_priv = Crypt::OpenSSL::RSA\->new_private_key($key_string);
\&  $plaintext = $rsa\->encrypt($ciphertext);
\&
\&  $rsa = Crypt::OpenSSL::RSA\->generate_key(1024); # or
\&  $rsa = Crypt::OpenSSL::RSA\->generate_key(1024, $prime);
\&
\&  print "private key is:\en", $rsa\->get_private_key_string();
\&  print "public key (in PKCS1 format) is:\en",
\&        $rsa\->get_public_key_string();
\&  print "public key (in X509 format) is:\en",
\&        $rsa\->get_public_key_x509_string();
\&
\&  $rsa_priv\->use_md5_hash(); # use_sha1_hash is the default
\&  $signature = $rsa_priv\->sign($plaintext);
\&  print "Signed correctly\en" if ($rsa\->verify($plaintext, $signature));
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Crypt::OpenSSL::RSA provides the ability to \s-1RSA\s0 encrypt strings which are
somewhat shorter than the block size of a key.  It also allows for decryption,
signatures and signature verification.
.PP
\&\fI\s-1NOTE\s0\fR: Many of the methods in this package can croak, so use eval, or
Error.pm's try/catch mechanism to capture errors.  Also, while some
methods from earlier versions of this package return true on success,
this (never documented) behavior is no longer the case.
.SH "Class Methods"
.IX Header "Class Methods"
.IP "new_public_key" 4
.IX Item "new_public_key"
Create a new Crypt::OpenSSL::RSA object by loading a public key in
from a string containing Base64/DER\-encoding of either the \s-1PKCS1\s0 or
X.509 representation of the key.  The string should include the
\&\-\-\-\-\-BEGIN...\-\-\-\-\- and \-\-\-\-\-END...\-\-\-\-\- lines.
.Sp
The padding is set to \s-1PKCS1_OAEP,\s0 but can be changed with the
use_xxx_padding methods
.IP "new_private_key" 4
.IX Item "new_private_key"
Create a new Crypt::OpenSSL::RSA object by loading a private key in
from an string containing the Base64/DER encoding of the \s-1PKCS1\s0
representation of the key.  The string should include the
\&\-\-\-\-\-BEGIN...\-\-\-\-\- and \-\-\-\-\-END...\-\-\-\-\- lines.  The padding is set to
\&\s-1PKCS1_OAEP,\s0 but can be changed with use_xxx_padding.
.IP "generate_key" 4
.IX Item "generate_key"
Create a new Crypt::OpenSSL::RSA object by constructing a
private/public key pair.  The first (mandetory) argument is the key
size, while the second optional argument specifies the public exponent
(the default public exponent is 65537).  The padding is set to
\&\s-1PKCS1_OAEP,\s0 but can be changed with use_xxx_padding methods.
.IP "new_key_from_parameters" 4
.IX Item "new_key_from_parameters"
Given Crypt::OpenSSL::Bignum objects for n, e, and optionally d, p,
and q, where p and q are the prime factors of n, e is the public
exponent and d is the private exponent, create a new
Crypt::OpenSSL::RSA object using these values.  If p and q are
provided and d is undef, d is computed.  Note that while p and q are
not necessary for a private key, their presence will speed up
computation.
.IP "import_random_seed" 4
.IX Item "import_random_seed"
Import a random seed from Crypt::OpenSSL::Random, since the OpenSSL
libraries won't allow sharing of random structures across perl \s-1XS\s0
modules.
.SH "Instance Methods"
.IX Header "Instance Methods"
.IP "\s-1DESTROY\s0" 4
.IX Item "DESTROY"
Clean up after ourselves.  In particular, erase and free the memory
occupied by the \s-1RSA\s0 key structure.
.IP "get_public_key_string" 4
.IX Item "get_public_key_string"
Return the Base64/DER\-encoded \s-1PKCS1\s0 representation of the public
key.  This string has
header and footer lines:
.Sp
.Vb 2
\&  \-\-\-\-\-BEGIN RSA PUBLIC KEY\-\-\-\-\-\-
\&  \-\-\-\-\-END RSA PUBLIC KEY\-\-\-\-\-\-
.Ve
.IP "get_public_key_x509_string" 4
.IX Item "get_public_key_x509_string"
Return the Base64/DER\-encoded representation of the \*(L"subject
public key\*(R", suitable for use in X509 certificates.  This string has
header and footer lines:
.Sp
.Vb 2
\&  \-\-\-\-\-BEGIN PUBLIC KEY\-\-\-\-\-\-
\&  \-\-\-\-\-END PUBLIC KEY\-\-\-\-\-\-
.Ve
.Sp
and is the format that is produced by running \f(CW\*(C`openssl rsa \-pubout\*(C'\fR.
.IP "get_private_key_string" 4
.IX Item "get_private_key_string"
Return the DER-encoded \s-1PKCS1\s0 representation of the private key.
.IP "encrypt" 4
.IX Item "encrypt"
Encrypt a binary \*(L"string\*(R" using the public (portion of the) key.
.IP "decrypt" 4
.IX Item "decrypt"
Decrypt a binary \*(L"string\*(R".  Croaks if the key is public only.
.IP "private_encrypt" 4
.IX Item "private_encrypt"
Encrypt a binary \*(L"string\*(R" using the private key.  Croaks if the key is
public only.
.IP "public_decrypt" 4
.IX Item "public_decrypt"
Decrypt a binary \*(L"string\*(R" using the public (portion of the) key.
.IP "sign" 4
.IX Item "sign"
Sign a string using the secret (portion of the) key.
.IP "verify" 4
.IX Item "verify"
Check the signature on a text.
.IP "use_no_padding" 4
.IX Item "use_no_padding"
Use raw \s-1RSA\s0 encryption. This mode should only be used to implement
cryptographically sound padding modes in the application code.
Encrypting user data directly with \s-1RSA\s0 is insecure.
.IP "use_pkcs1_padding" 4
.IX Item "use_pkcs1_padding"
Use \s-1PKCS\s0 #1 v1.5 padding. This currently is the most widely used mode
of padding.
.IP "use_pkcs1_oaep_padding" 4
.IX Item "use_pkcs1_oaep_padding"
Use EME-OAEP padding as defined in \s-1PKCS\s0 #1 v2.0 with \s-1SHA\-1, MGF1\s0 and
an empty encoding parameter. This mode of padding is recommended for
all new applications.  It is the default mode used by
Crypt::OpenSSL::RSA.
.IP "use_sslv23_padding" 4
.IX Item "use_sslv23_padding"
Use \s-1PKCS\s0 #1 v1.5 padding with an SSL-specific modification that
denotes that the server is \s-1SSL3\s0 capable.
.IP "use_md5_hash" 4
.IX Item "use_md5_hash"
Use the \s-1RFC 1321 MD5\s0 hashing algorithm by Ron Rivest when signing and
verifying messages.
.IP "use_sha1_hash" 4
.IX Item "use_sha1_hash"
Use the \s-1RFC 3174\s0 Secure Hashing Algorithm (\s-1FIPS 180\-1\s0) when signing
and verifying messages. This is the default.
.IP "use_sha224_hash, use_sha256_hash, use_sha384_hash, use_sha512_hash" 4
.IX Item "use_sha224_hash, use_sha256_hash, use_sha384_hash, use_sha512_hash"
These \s-1FIPS 180\-2\s0 hash algorithms, for use when signing and verifying
messages, are only available with newer openssl versions (>= 0.9.8).
.IP "use_ripemd160_hash" 4
.IX Item "use_ripemd160_hash"
Dobbertin, Bosselaers and Preneel's \s-1RIPEMD\s0 hashing algorithm when
signing and verifying messages.
.IP "size" 4
.IX Item "size"
Returns the size, in bytes, of the key.  All encrypted text will be of
this size, and depending on the padding mode used, the length of
the text to be encrypted should be:
.RS 4
.IP "pkcs1_oaep_padding" 4
.IX Item "pkcs1_oaep_padding"
at most 42 bytes less than this size.
.IP "pkcs1_padding or sslv23_padding" 4
.IX Item "pkcs1_padding or sslv23_padding"
at most 11 bytes less than this size.
.IP "no_padding" 4
.IX Item "no_padding"
exactly this size.
.RE
.RS 4
.RE
.IP "check_key" 4
.IX Item "check_key"
This function validates the \s-1RSA\s0 key, returning a true value if the key
is valid, and a false value otherwise.  Croaks if the key is public only.
.IP "get_key_parameters" 4
.IX Item "get_key_parameters"
Return Crypt::OpenSSL::Bignum objects representing the values of n, e,
d, p, q, d mod (p\-1), d mod (q\-1), and 1/q mod p, where p and q are
the prime factors of n, e is the public exponent and d is the private
exponent.  Some of these values may return as undef; only n and e will
be defined for a public key.  The Crypt::OpenSSL::Bignum module must
be installed for this to work.
.IP "is_private" 4
.IX Item "is_private"
Return true if this is a private key, and false if it is private only.
.SH "BUGS"
.IX Header "BUGS"
There is a small memory leak when generating new keys of more than 512 bits.
.SH "AUTHOR"
.IX Header "AUTHOR"
Ian Robertson, iroberts@cpan.org.  For support, please email
perl\-openssl\-users@lists.sourceforge.net.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fIperl\fR\|(1), \fICrypt::OpenSSL::Random\fR\|(3), \fICrypt::OpenSSL::Bignum\fR\|(3),
\&\fIrsa\fR\|(3), \fIRSA_new\fR\|(3), \fIRSA_public_encrypt\fR\|(3), \fIRSA_size\fR\|(3),
\&\fIRSA_generate_key\fR\|(3), \fIRSA_check_key\fR\|(3)
