.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "install::TempContent::Objects::mod_perl-2.0.9::docs::api::Apache2::Log 3"
.TH install::TempContent::Objects::mod_perl-2.0.9::docs::api::Apache2::Log 3 "2015-06-18" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Apache2::Log \- Perl API for Apache Logging Methods
.SH "Synopsis"
.IX Header "Synopsis"
.Vb 3
\&  # in startup.pl
\&  #\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&  use Apache2::Log;
\&  
\&  use Apache2::Const \-compile => qw(OK :log);
\&  use APR::Const    \-compile => qw(:error SUCCESS);
\&  
\&  my $s = Apache2::ServerUtil\->server;
\&  
\&  $s\->log_error("server: log_error");
\&  $s\->log_serror(_\|_FILE_\|_, _\|_LINE_\|_, Apache2::Const::LOG_ERR,
\&                 APR::Const::SUCCESS, "log_serror logging at err level");
\&  $s\->log_serror(Apache2::Log::LOG_MARK, Apache2::Const::LOG_DEBUG,
\&                 APR::Const::ENOTIME, "debug print");
\&  Apache2::ServerRec\->log_error("routine warning");
\&  
\&  Apache2::ServerRec::warn("routine warning");
\&
\&  # in a handler
\&  #\-\-\-\-\-\-\-\-\-\-\-\-\-
\&  package Foo;
\&  
\&  use strict;
\&  use warnings FATAL => \*(Aqall\*(Aq;
\&  
\&  use Apache2::Log;
\&  
\&  use Apache2::Const \-compile => qw(OK :log);
\&  use APR::Const    \-compile => qw(:error SUCCESS);
\&  
\&  sub handler {
\&      my $r = shift;
\&      $r\->log_error("request: log_error");
\&  
\&      my $rlog = $r\->log;
\&      for my $level qw(emerg alert crit error warn notice info debug) {
\&          no strict \*(Aqrefs\*(Aq;
\&          $rlog\->$level($package, "request: $level log level");
\&      }
\&  
\&      # can use server methods as well
\&      my $s = $r\->server;
\&      $s\->log_error("server: log_error");
\&  
\&      $r\->log_rerror(Apache2::Log::LOG_MARK, Apache2::Const::LOG_DEBUG,
\&                     APR::Const::ENOTIME, "in debug");
\&  
\&      $s\->log_serror(Apache2::Log::LOG_MARK, Apache2::Const::LOG_INFO,
\&                     APR::Const::SUCCESS, "server info");
\&  
\&      $s\->log_serror(Apache2::Log::LOG_MARK, Apache2::Const::LOG_ERR,
\&                     APR::Const::ENOTIME, "fatal error");
\&  
\&      $r\->log_reason("fatal error");
\&      $r\->warn(\*(Aqroutine request warning\*(Aq);
\&      $s\->warn(\*(Aqroutine server warning\*(Aq);
\&  
\&      return Apache2::Const::OK;
\&  }
\&  1;
\&
\&  # in a registry script
\&  # httpd.conf: PerlOptions +GlobalRequest
\&  use Apache2::ServerRec qw(warn); # override warn locally
\&  print "Content\-type: text/plain\en\en";
\&  warn "my warning";
.Ve
.SH "Description"
.IX Header "Description"
\&\f(CW\*(C`Apache2::Log\*(C'\fR provides the Perl \s-1API\s0 for Apache logging methods.
.PP
Depending on the the current \f(CW\*(C`LogLevel\*(C'\fR setting, only logging with
the same log level or higher will be loaded. For example if the
current \f(CW\*(C`LogLevel\*(C'\fR is set to \fIwarning\fR, only messages with log level
of the level \fIwarning\fR or higher (\fIerr\fR, \fIcrit\fR, \fIelert\fR and
\&\fIemerg\fR) will be logged. Therefore this:
.PP
.Vb 2
\&  $r\->log_rerror(Apache2::Log::LOG_MARK, Apache2::Const::LOG_WARNING,
\&                 APR::Const::ENOTIME, "warning!");
.Ve
.PP
will log the message, but this one won't:
.PP
.Vb 2
\&  $r\->log_rerror(Apache2::Log::LOG_MARK, Apache2::Const::LOG_INFO,
\&                 APR::Const::ENOTIME, "just an info");
.Ve
.PP
It will be logged only if the server log level is set to \fIinfo\fR or
\&\fIdebug\fR. \f(CW\*(C`LogLevel\*(C'\fR is set in the configuration file, but can be
changed using the
\&\f(CW\*(C`$s\->loglevel()\*(C'\fR
method.
.PP
The filename and the line number of the caller are logged only if
\&\f(CW\*(C`Apache2::Const::LOG_DEBUG\*(C'\fR is used (because that's how Apache 2.0 logging
mechanism works).
.PP
Note: On Win32 Apache attempts to lock all writes to a file whenever
it's opened for append (which is the case with logging functions), as
Unix has this behavior built-in, while Win32 does not. Therefore
\&\f(CW\*(C`Apache2::Log\*(C'\fR functions could be slower than Perl's \fIprint()\fR/\fIwarn()\fR.
.SH "Constants"
.IX Header "Constants"
Log level constants can be compiled all at once:
.PP
.Vb 1
\&  use Apache2::Const \-compile => qw(:log);
.Ve
.PP
or individually:
.PP
.Vb 1
\&  use Apache2::Const \-compile => qw(LOG_DEBUG LOG_INFO);
.Ve
.SS "LogLevel Constants"
.IX Subsection "LogLevel Constants"
The following constants (sorted from the most severe level to the
least severe) are used in logging methods to specify the log level at
which the message should be logged:
.PP
\fI\f(CI\*(C`Apache2::Const::LOG_EMERG\*(C'\fI\fR
.IX Subsection "Apache2::Const::LOG_EMERG"
.PP
\fI\f(CI\*(C`Apache2::Const::LOG_ALERT\*(C'\fI\fR
.IX Subsection "Apache2::Const::LOG_ALERT"
.PP
\fI\f(CI\*(C`Apache2::Const::LOG_CRIT\*(C'\fI\fR
.IX Subsection "Apache2::Const::LOG_CRIT"
.PP
\fI\f(CI\*(C`Apache2::Const::LOG_ERR\*(C'\fI\fR
.IX Subsection "Apache2::Const::LOG_ERR"
.PP
\fI\f(CI\*(C`Apache2::Const::LOG_WARNING\*(C'\fI\fR
.IX Subsection "Apache2::Const::LOG_WARNING"
.PP
\fI\f(CI\*(C`Apache2::Const::LOG_NOTICE\*(C'\fI\fR
.IX Subsection "Apache2::Const::LOG_NOTICE"
.PP
\fI\f(CI\*(C`Apache2::Const::LOG_INFO\*(C'\fI\fR
.IX Subsection "Apache2::Const::LOG_INFO"
.PP
\fI\f(CI\*(C`Apache2::Const::LOG_DEBUG\*(C'\fI\fR
.IX Subsection "Apache2::Const::LOG_DEBUG"
.SS "Other Constants"
.IX Subsection "Other Constants"
Make sure to compile the \s-1APR\s0 status constants before using them. For
example to compile \f(CW\*(C`APR::Const::SUCCESS\*(C'\fR and all the \s-1APR\s0 error status
constants do:
.PP
.Vb 1
\&  use APR::Const    \-compile => qw(:error SUCCESS);
.Ve
.PP
Here is the rest of the logging related constants:
.PP
\fI\f(CI\*(C`Apache2::Const::LOG_LEVELMASK\*(C'\fI\fR
.IX Subsection "Apache2::Const::LOG_LEVELMASK"
.PP
used to mask off the level value, to make sure that the log level's
value is within the proper bits range. e.g.:
.PP
.Vb 1
\&  $loglevel &= LOG_LEVELMASK;
.Ve
.PP
\fI\f(CI\*(C`Apache2::Const::LOG_TOCLIENT\*(C'\fI\fR
.IX Subsection "Apache2::Const::LOG_TOCLIENT"
.PP
used to give content handlers the option of including the error text
in the \f(CW\*(C`ErrorDocument\*(C'\fR sent back to the client. When
\&\f(CW\*(C`Apache2::Const::LOG_TOCLIENT\*(C'\fR is passed to \f(CW\*(C`log_rerror()\*(C'\fR the error message
will be saved in the \f(CW$r\fR's notes table, keyed to the string
\&\fI\*(L"error-notes\*(R"\fR, if and only if the severity level of the message is
\&\f(CW\*(C`Apache2::Const::LOG_WARNING\*(C'\fR or greater and there are no other
\&\fI\*(L"error-notes\*(R"\fR entry already set in the request record's notes
table. Once the \fI\*(L"error-notes\*(R"\fR entry is set, it is up to the error
handler to determine whether this text should be sent back to the
client.  For example:
.PP
.Vb 6
\&  use Apache2::Const \-compile => qw(:log);
\&  use APR::Const    \-compile => qw(ENOTIME);
\&  $r\->log_rerror(Apache2::Log::LOG_MARK,
\&                 Apache2::Const::LOG_ERR|Apache2::Const::LOG_TOCLIENT,
\&                 APR::Const::ENOTIME,
\&                 "request log_rerror");
.Ve
.PP
now the log message can be retrieved via:
.PP
.Vb 1
\&  $r\->notes\->get("error\-notes");
.Ve
.PP
Remember that client-generated text streams sent back to the client
\&\fB\s-1MUST\s0\fR be escaped to prevent \s-1CSS\s0 attacks.
.PP
\fI\f(CI\*(C`Apache2::Const::LOG_STARTUP\*(C'\fI\fR
.IX Subsection "Apache2::Const::LOG_STARTUP"
.PP
is useful for startup message where no timestamps, logging level is
wanted. For example:
.PP
.Vb 6
\&  use Apache2::Const \-compile => qw(:log);
\&  use APR::Const    \-compile => qw(SUCCESS);
\&  $s\->log_serror(Apache2::Log::LOG_MARK,
\&                 Apache2::Const::LOG_INFO,
\&                 APR::Const::SUCCESS,
\&                 "This log message comes with a header");
.Ve
.PP
will print:
.PP
.Vb 1
\&  [Wed May 14 16:47:09 2003] [info] This log message comes with a header
.Ve
.PP
whereas, when \f(CW\*(C`Apache2::Const::LOG_STARTUP\*(C'\fR is binary ORed as in:
.PP
.Vb 6
\&  use Apache2::Const \-compile => qw(:log);
\&  use APR::Const    \-compile => qw(SUCCESS);
\&  $s\->log_serror(Apache2::Log::LOG_MARK,
\&                 Apache2::Const::LOG_INFO|Apache2::Const::LOG_STARTUP,
\&                 APR::Const::SUCCESS,
\&                 "This log message comes with no header");
.Ve
.PP
then the logging will be:
.PP
.Vb 1
\&  This log message comes with no header
.Ve
.SH "Server Logging Methods"
.IX Header "Server Logging Methods"
.ie n .SS """$s\->log"""
.el .SS "\f(CW$s\->log\fP"
.IX Subsection "$s->log"
get a log handle which can be used to log messages of different
levels.
.PP
.Vb 1
\&  my $slog = $s\->log;
.Ve
.ie n .IP "obj: $s ( ""Apache2::ServerRec object"" )" 4
.el .IP "obj: \f(CW$s\fR ( \f(CWApache2::ServerRec object\fR )" 4
.IX Item "obj: $s ( Apache2::ServerRec object )"
.PD 0
.ie n .IP "ret: $slog ( ""Apache2::Log::Server"" object )" 4
.el .IP "ret: \f(CW$slog\fR ( \f(CWApache2::Log::Server\fR object )" 4
.IX Item "ret: $slog ( Apache2::Log::Server object )"
.PD
\&\f(CW\*(C`Apache2::Log::Server\*(C'\fR object to be used with LogLevel
methods.
.IP "since: 2.0.00" 4
.IX Item "since: 2.0.00"
.ie n .SS """$s\->log_error"""
.el .SS "\f(CW$s\->log_error\fP"
.IX Subsection "$s->log_error"
just logs the supplied message to \fIerror_log\fR
.PP
.Vb 1
\&  $s\->log_error(@message);
.Ve
.ie n .IP "obj: $s ( ""Apache2::ServerRec object"" )" 4
.el .IP "obj: \f(CW$s\fR ( \f(CWApache2::ServerRec object\fR )" 4
.IX Item "obj: $s ( Apache2::ServerRec object )"
.PD 0
.ie n .IP "arg1: @message ( strings \s-1ARRAY \s0)" 4
.el .IP "arg1: \f(CW@message\fR ( strings \s-1ARRAY \s0)" 4
.IX Item "arg1: @message ( strings ARRAY )"
.PD
what to log
.IP "ret: no return value" 4
.IX Item "ret: no return value"
.PD 0
.IP "since: 2.0.00" 4
.IX Item "since: 2.0.00"
.PD
.PP
For example:
.PP
.Vb 1
\&  $s\->log_error("running low on memory");
.Ve
.ie n .SS """$s\->log_serror"""
.el .SS "\f(CW$s\->log_serror\fP"
.IX Subsection "$s->log_serror"
This function provides a fine control of when the message is logged,
gives an access to built-in status codes.
.PP
.Vb 1
\&  $s\->log_serror($file, $line, $level, $status, @message);
.Ve
.ie n .IP "obj: $s ( ""Apache2::ServerRec object"" )" 4
.el .IP "obj: \f(CW$s\fR ( \f(CWApache2::ServerRec object\fR )" 4
.IX Item "obj: $s ( Apache2::ServerRec object )"
.PD 0
.ie n .IP "arg1: $file ( string )" 4
.el .IP "arg1: \f(CW$file\fR ( string )" 4
.IX Item "arg1: $file ( string )"
.PD
The file in which this function is called
.ie n .IP "arg2: $line ( number )" 4
.el .IP "arg2: \f(CW$line\fR ( number )" 4
.IX Item "arg2: $line ( number )"
The line number on which this function is called
.ie n .IP "arg3: $level ( ""Apache2::LOG_* constant"" )" 4
.el .IP "arg3: \f(CW$level\fR ( \f(CWApache2::LOG_* constant\fR )" 4
.IX Item "arg3: $level ( Apache2::LOG_* constant )"
The level of this error message
.ie n .IP "arg4: $status ( ""APR::Const status constant"" )" 4
.el .IP "arg4: \f(CW$status\fR ( \f(CWAPR::Const status constant\fR )" 4
.IX Item "arg4: $status ( APR::Const status constant )"
The status code from the last command (similar to $! in perl), usually
\&\f(CW\*(C`APR::Const constant\*(C'\fR or coming from an
exception object.
.ie n .IP "arg5: @message ( strings \s-1ARRAY \s0)" 4
.el .IP "arg5: \f(CW@message\fR ( strings \s-1ARRAY \s0)" 4
.IX Item "arg5: @message ( strings ARRAY )"
The log message(s)
.IP "ret: no return value" 4
.IX Item "ret: no return value"
.PD 0
.IP "since: 2.0.00" 4
.IX Item "since: 2.0.00"
.PD
.PP
For example:
.PP
.Vb 4
\&  use Apache2::Const \-compile => qw(:log);
\&  use APR::Const    \-compile => qw(ENOTIME SUCCESS);
\&  $s\->log_serror(Apache2::Log::LOG_MARK, Apache2::Const::LOG_ERR,
\&                 APR::Const::SUCCESS, "log_serror logging at err level");
\&  
\&  $s\->log_serror(Apache2::Log::LOG_MARK, Apache2::Const::LOG_DEBUG,
\&                 APR::Const::ENOTIME, "debug print");
.Ve
.ie n .SS """$s\->warn"""
.el .SS "\f(CW$s\->warn\fP"
.IX Subsection "$s->warn"
.Vb 1
\&  $s\->warn(@warnings);
.Ve
.PP
is the same as:
.PP
.Vb 2
\&  $s\->log_serror(Apache2::Log::LOG_MARK, Apache2::Const::LOG_WARNING,
\&                 APR::Const::SUCCESS, @warnings)
.Ve
.ie n .IP "obj: $s ( ""Apache2::ServerRec object"" )" 4
.el .IP "obj: \f(CW$s\fR ( \f(CWApache2::ServerRec object\fR )" 4
.IX Item "obj: $s ( Apache2::ServerRec object )"
.PD 0
.ie n .IP "arg1: @warnings ( strings \s-1ARRAY \s0)" 4
.el .IP "arg1: \f(CW@warnings\fR ( strings \s-1ARRAY \s0)" 4
.IX Item "arg1: @warnings ( strings ARRAY )"
.PD
array of warning strings
.IP "ret: no return value" 4
.IX Item "ret: no return value"
.PD 0
.IP "since: 2.0.00" 4
.IX Item "since: 2.0.00"
.PD
.PP
For example:
.PP
.Vb 1
\&  $s\->warn(\*(Aqroutine server warning\*(Aq);
.Ve
.SH "Request Logging Methods"
.IX Header "Request Logging Methods"
.ie n .SS """$r\->log"""
.el .SS "\f(CW$r\->log\fP"
.IX Subsection "$r->log"
get a log handle which can be used to log messages of different
levels.
.PP
.Vb 1
\&  $rlog = $r\->log;
.Ve
.ie n .IP "obj: $r ( ""Apache2::RequestRec object"" )" 4
.el .IP "obj: \f(CW$r\fR ( \f(CWApache2::RequestRec object\fR )" 4
.IX Item "obj: $r ( Apache2::RequestRec object )"
.PD 0
.ie n .IP "ret: $rlog ( ""Apache2::Log::Request"" object )" 4
.el .IP "ret: \f(CW$rlog\fR ( \f(CWApache2::Log::Request\fR object )" 4
.IX Item "ret: $rlog ( Apache2::Log::Request object )"
.PD
\&\f(CW\*(C`Apache2::Log::Request\*(C'\fR object to be used with LogLevel
methods.
.IP "since: 2.0.00" 4
.IX Item "since: 2.0.00"
.ie n .SS """$r\->log_error"""
.el .SS "\f(CW$r\->log_error\fP"
.IX Subsection "$r->log_error"
just logs the supplied message (similar to
\&\f(CW\*(C`$s\->log_error\*(C'\fR ).
.PP
.Vb 1
\&  $r\->log_error(@message);
.Ve
.ie n .IP "obj: $r ( ""Apache2::RequestRec object"" )" 4
.el .IP "obj: \f(CW$r\fR ( \f(CWApache2::RequestRec object\fR )" 4
.IX Item "obj: $r ( Apache2::RequestRec object )"
.PD 0
.ie n .IP "arg1: @message ( strings \s-1ARRAY \s0)" 4
.el .IP "arg1: \f(CW@message\fR ( strings \s-1ARRAY \s0)" 4
.IX Item "arg1: @message ( strings ARRAY )"
.PD
what to log
.IP "ret: no return value" 4
.IX Item "ret: no return value"
.PD 0
.IP "since: 2.0.00" 4
.IX Item "since: 2.0.00"
.PD
.PP
For example:
.PP
.Vb 1
\&  $r\->log_error("the request is about to end");
.Ve
.ie n .SS """$r\->log_reason"""
.el .SS "\f(CW$r\->log_reason\fP"
.IX Subsection "$r->log_reason"
This function provides a convenient way to log errors in a
preformatted way:
.PP
.Vb 2
\&  $r\->log_reason($message);
\&  $r\->log_reason($message, $filename);
.Ve
.ie n .IP "obj: $r ( ""Apache2::RequestRec object"" )" 4
.el .IP "obj: \f(CW$r\fR ( \f(CWApache2::RequestRec object\fR )" 4
.IX Item "obj: $r ( Apache2::RequestRec object )"
.PD 0
.ie n .IP "arg1: $message ( string )" 4
.el .IP "arg1: \f(CW$message\fR ( string )" 4
.IX Item "arg1: $message ( string )"
.PD
the message to log
.ie n .IP "opt arg2: $filename ( string )" 4
.el .IP "opt arg2: \f(CW$filename\fR ( string )" 4
.IX Item "opt arg2: $filename ( string )"
where to report the error as coming from (e.g. \f(CW\*(C`_\|_FILE_\|_\*(C'\fR)
.IP "ret: no return value" 4
.IX Item "ret: no return value"
.PD 0
.IP "since: 2.0.00" 4
.IX Item "since: 2.0.00"
.PD
.PP
For example:
.PP
.Vb 1
\&  $r\->log_reason("There is no enough data");
.Ve
.PP
will generate a log entry similar to the following:
.PP
.Vb 2
\&  [Fri Sep 24 11:58:36 2004] [error] access to /someuri
\&  failed for 127.0.0.1, reason: There is no enough data.
.Ve
.ie n .SS """$r\->log_rerror"""
.el .SS "\f(CW$r\->log_rerror\fP"
.IX Subsection "$r->log_rerror"
This function provides a fine control of when the message is logged,
gives an access to built-in status codes.
.PP
.Vb 1
\&  $r\->log_rerror($file, $line, $level, $status, @message);
.Ve
.PP
arguments are identical to
\&\f(CW\*(C`$s\->log_serror\*(C'\fR.
.IP "since: 2.0.00" 4
.IX Item "since: 2.0.00"
.PP
For example:
.PP
.Vb 4
\&  use Apache2::Const \-compile => qw(:log);
\&  use APR::Const    \-compile => qw(ENOTIME SUCCESS);
\&  $r\->log_rerror(Apache2::Log::LOG_MARK, Apache2::Const::LOG_ERR,
\&                 APR::Const::SUCCESS, "log_rerror logging at err level");
\&  
\&  $r\->log_rerror(Apache2::Log::LOG_MARK, Apache2::Const::LOG_DEBUG,
\&                 APR::Const::ENOTIME, "debug print");
.Ve
.ie n .SS """$r\->warn"""
.el .SS "\f(CW$r\->warn\fP"
.IX Subsection "$r->warn"
.Vb 1
\&  $r\->warn(@warnings);
.Ve
.PP
is the same as:
.PP
.Vb 2
\&  $r\->log_rerror(Apache2::Log::LOG_MARK, Apache2::Const::LOG_WARNING,
\&                 APR::Const::SUCCESS, @warnings)
.Ve
.ie n .IP "obj: $r ( ""Apache2::RequestRec object"" )" 4
.el .IP "obj: \f(CW$r\fR ( \f(CWApache2::RequestRec object\fR )" 4
.IX Item "obj: $r ( Apache2::RequestRec object )"
.PD 0
.ie n .IP "arg1: @warnings ( strings \s-1ARRAY \s0)" 4
.el .IP "arg1: \f(CW@warnings\fR ( strings \s-1ARRAY \s0)" 4
.IX Item "arg1: @warnings ( strings ARRAY )"
.PD
array of warning strings
.IP "ret: no return value" 4
.IX Item "ret: no return value"
.PD 0
.IP "since: 2.0.00" 4
.IX Item "since: 2.0.00"
.PD
.PP
For example:
.PP
.Vb 1
\&  $r\->warn(\*(Aqroutine server warning\*(Aq);
.Ve
.SH "Other Logging Methods"
.IX Header "Other Logging Methods"
.SS "LogLevel Methods"
.IX Subsection "LogLevel Methods"
after getting the log handle with \f(CW\*(C`$s\->log\*(C'\fR or
\&\f(CW\*(C`$r\->log\*(C'\fR, use one of the following methods
(corresponding to the \f(CW\*(C`LogLevel\*(C'\fR levels):
.PP
.Vb 1
\&  emerg(), alert(), crit(), error(), warn(), notice(), info(), debug()
.Ve
.PP
to control when messages should be logged:
.PP
.Vb 2
\&  $s\->log\->emerg(@message);
\&  $r\->log\->emerg(@message);
.Ve
.ie n .IP "obj: $slog ( server or request log handle )" 4
.el .IP "obj: \f(CW$slog\fR ( server or request log handle )" 4
.IX Item "obj: $slog ( server or request log handle )"
.PD 0
.ie n .IP "arg1: @message ( strings \s-1ARRAY \s0)" 4
.el .IP "arg1: \f(CW@message\fR ( strings \s-1ARRAY \s0)" 4
.IX Item "arg1: @message ( strings ARRAY )"
.IP "ret: no return value" 4
.IX Item "ret: no return value"
.IP "since: 2.0.00" 4
.IX Item "since: 2.0.00"
.PD
.PP
For example if the \f(CW\*(C`LogLevel\*(C'\fR is \f(CW\*(C`error\*(C'\fR and the following code is
executed:
.PP
.Vb 4
\&  my $slog = $s\->log;
\&  $slog\->debug("just ", "some debug info");
\&  $slog\->warn(@warnings);
\&  $slog\->crit("dying");
.Ve
.PP
only the last command's logging will be performed. This is because
\&\fIwarn\fR, \fIdebug\fR and other logging command which are listed right to
\&\fIerror\fR will be disabled.
.ie n .SS """alert"""
.el .SS "\f(CWalert\fP"
.IX Subsection "alert"
See LogLevel Methods.
.ie n .SS """crit"""
.el .SS "\f(CWcrit\fP"
.IX Subsection "crit"
See LogLevel Methods.
.ie n .SS """debug"""
.el .SS "\f(CWdebug\fP"
.IX Subsection "debug"
See LogLevel Methods.
.ie n .SS """emerg"""
.el .SS "\f(CWemerg\fP"
.IX Subsection "emerg"
See LogLevel Methods.
.ie n .SS """error"""
.el .SS "\f(CWerror\fP"
.IX Subsection "error"
See LogLevel Methods.
.ie n .SS """info"""
.el .SS "\f(CWinfo\fP"
.IX Subsection "info"
See LogLevel Methods.
.ie n .SS """notice"""
.el .SS "\f(CWnotice\fP"
.IX Subsection "notice"
See LogLevel Methods.
.PP
Though Apache treats \f(CW\*(C`notice()\*(C'\fR calls as special. The message is
always logged regardless the value of \f(CW\*(C`ErrorLog\*(C'\fR, unless the error
log is set to use syslog. (For details see httpd\-2.0/server/log.c.)
.ie n .SS """warn"""
.el .SS "\f(CWwarn\fP"
.IX Subsection "warn"
See LogLevel Methods.
.SH "General Functions"
.IX Header "General Functions"
.ie n .SS """LOG_MARK"""
.el .SS "\f(CWLOG_MARK\fP"
.IX Subsection "LOG_MARK"
Though looking like a constant, this is a function, which returns a
list of two items: \f(CW\*(C`(_\|_FILE_\|_, _\|_LINE_\|_)\*(C'\fR, i.e. the file and the line
where the function was called from.
.PP
.Vb 1
\&  my ($file, $line) = Apache2::Log::LOG_MARK();
.Ve
.ie n .IP "ret1: $file ( string )" 4
.el .IP "ret1: \f(CW$file\fR ( string )" 4
.IX Item "ret1: $file ( string )"
.PD 0
.ie n .IP "ret2: $line ( number )" 4
.el .IP "ret2: \f(CW$line\fR ( number )" 4
.IX Item "ret2: $line ( number )"
.IP "since: 2.0.00" 4
.IX Item "since: 2.0.00"
.PD
.PP
It's mostly useful to be passed as the first argument to those logging
methods, expecting the filename and the line number as the first
arguments (e.g., \f(CW\*(C`$s\->log_serror\*(C'\fR and
\&\f(CW\*(C`$r\->log_rerror\*(C'\fR ).
.SH "Virtual Hosts"
.IX Header "Virtual Hosts"
Code running from within a virtual host needs to be able to log into
its \f(CW\*(C`ErrorLog\*(C'\fR file, if different from the main log. Calling any of
the logging methods on the \f(CW$r\fR and \f(CW$s\fR objects will do the logging
correctly.
.PP
If the core \f(CW\*(C`warn()\*(C'\fR is called, it'll be always logged to the main
log file. Here is how to make it log into the vhost \fIerror_log\fR file.
Let's say that we start with the following code:
.PP
.Vb 1
\&  warn "the code is smoking";
.Ve
.IP "1." 4
First, we need to use mod_perl's logging function, instead of
\&\f(CW\*(C`CORE::warn\*(C'\fR
.Sp
Either replace \f(CW\*(C`warn\*(C'\fR with \f(CW\*(C`Apache2::ServerRec::warn\*(C'\fR:
.Sp
.Vb 2
\&  use Apache2::Log ();
\&  Apache2::ServerRec::warn("the code is smoking");
.Ve
.Sp
or import it into your code:
.Sp
.Vb 2
\&  use Apache2::ServerRec qw(warn); # override warn locally
\&  warn "the code is smoking";
.Ve
.Sp
or override \f(CW\*(C`CORE::warn\*(C'\fR:
.Sp
.Vb 3
\&  use Apache2::Log ();
\&  *CORE::GLOBAL::warn = \e&Apache2::ServerRec::warn;
\&  warn "the code is smoking";
.Ve
.Sp
Avoid using the latter suggestion, since it'll affect all the code
running on the server, which may break things. Of course you can
localize that as well:
.Sp
.Vb 3
\&  use Apache2::Log ();
\&  local *CORE::GLOBAL::warn = \e&Apache2::ServerRec::warn;
\&  warn "the code is smoking";
.Ve
.Sp
Chances are that you need to make the internal Perl warnings go into
the vhost's \fIerror_log\fR file as well. Here is how to do that:
.Sp
.Vb 3
\&  use Apache2::Log ();
\&  local $SIG{_\|_WARN_\|_} = \e&Apache2::ServerRec::warn;
\&  eval q[my $x = "aaa" + 1;]; # this issues a warning
.Ve
.Sp
Notice that it'll override any previous setting you may have had,
disabling modules like \f(CW\*(C`CGI::Carp\*(C'\fR which also use \f(CW$SIG{_\|_WARN_\|_}\fR
.IP "2." 4
Next we need to figure out how to get hold of the vhost's server
object.
.Sp
Inside \s-1HTTP\s0 request handlers this is possible via
\&\f(CW\*(C`Apache2\->request\*(C'\fR.
Which requires either \f(CW\*(C`PerlOptions
+GlobalRequest\*(C'\fR
setting or can be also done at runtime if \f(CW$r\fR is available:
.Sp
.Vb 5
\&  use Apache2::RequestUtil ();
\&  sub handler {
\&      my $r = shift;
\&      Apache2::RequestUtil\->request($r);
\&      ...
.Ve
.Sp
Outside \s-1HTTP\s0 handlers at the moment it is not possible, to get hold of
the vhost's \fIerror_log\fR file. This shouldn't be a problem for the
code that runs only under mod_perl, since the always available \f(CW$s\fR
object can invoke a plethora of methods supplied by
\&\f(CW\*(C`Apache2::Log\*(C'\fR. This is only a problem for modules, which are supposed
to run outside mod_perl as well.
.Sp
\&\s-1META:\s0 To solve this we think to introduce 'PerlOptions +GlobalServer',
a big brother for 'PerlOptions +GlobalRequest', which will be set in
modperl_hook_pre_connection.
.SH "Unsupported API"
.IX Header "Unsupported API"
\&\f(CW\*(C`Apache2::Log\*(C'\fR also provides auto-generated Perl interface for a few
other methods which aren't tested at the moment and therefore their
\&\s-1API\s0 is a subject to change. These methods will be finalized later as a
need arises. If you want to rely on any of the following methods
please contact the the mod_perl development mailing
list so we can help each other take the steps necessary
to shift the method to an officially supported \s-1API.\s0
.ie n .SS """log_pid"""
.el .SS "\f(CWlog_pid\fP"
.IX Subsection "log_pid"
\&\s-1META:\s0 what is this method good for? it just calls getpid and logs
it. In any case it has nothing to do with the logging \s-1API.\s0 And it uses
static variables, it probably shouldn't be in the Apache public \s-1API.\s0
.PP
Log the current pid
.PP
.Vb 1
\&  Apache2::Log::log_pid($pool, $fname);
.Ve
.ie n .IP "obj: $p ( ""APR::Pool object"" )" 4
.el .IP "obj: \f(CW$p\fR ( \f(CWAPR::Pool object\fR )" 4
.IX Item "obj: $p ( APR::Pool object )"
The pool to use for logging
.ie n .IP "arg1: $fname ( file path )" 4
.el .IP "arg1: \f(CW$fname\fR ( file path )" 4
.IX Item "arg1: $fname ( file path )"
The name of the file to log to
.IP "ret: no return value" 4
.IX Item "ret: no return value"
.PD 0
.IP "since: subject to change" 4
.IX Item "since: subject to change"
.PD
.SH "See Also"
.IX Header "See Also"
mod_perl 2.0 documentation.
.SH "Copyright"
.IX Header "Copyright"
mod_perl 2.0 and its core modules are copyrighted under
The Apache Software License, Version 2.0.
.SH "Authors"
.IX Header "Authors"
The mod_perl development team and numerous
contributors.
