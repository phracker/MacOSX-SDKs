.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Parse::Eyapp::Base 3"
.TH Parse::Eyapp::Base 3 "2012-03-23" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Parse::Eyapp::Base \- Miscellaneous support functions for Parse::Eyapp
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use Parse::Eyapp::Base qw(:all)
.Ve
.SH "INTRODUCTION"
.IX Header "INTRODUCTION"
\&\f(CW\*(C`Parse::Eyapp::Base\*(C'\fR holds a set of utility functions that give support to the other 
modules that made \f(CW\*(C`Parse::Eyapp\*(C'\fR. Several of them are related to the dynamic use of methods 
and subroutines.
.SH "SUBROUTINES"
.IX Header "SUBROUTINES"
.ie n .SS "Function ""insert_method"""
.el .SS "Function \f(CWinsert_method\fP"
.IX Subsection "Function insert_method"
Function \f(CW\*(C`insert_method\*(C'\fR receives as arguments
a list of class names, the name of the method that will be inserted in such classes
and a reference to the code implementing such method.
.PP
.Vb 1
\&          insert_method( qw{CLASS1 CLASS2 ... }, \*(Aqsubname\*(Aq, sub { ... } )
.Ve
.PP
It inserts the method in the specified classes. 
A second way to call it is without the last argument, the handler:
.PP
.Vb 1
\&          insert_method( qw{CLASS1 CLASS2 ... }, \*(Aqsubname\*(Aq )
.Ve
.PP
In such case the function is  deleted from all the specified classes
and it no longer exists.
.PP
The caller class is assumed if no classes are specified:
.PP
.Vb 1
\&          insert_method(\*(Aqsubname\*(Aq, sub { ... } )
.Ve
.PP
See the following session with the debugger:
.PP
.Vb 8
\&  pl@nereida:~/src/perl/YappWithDefaultAction/lib/Parse/Eyapp$ perl \-wde 0
\&  main::(\-e:1):   0
\&    DB<1> use Parse::Eyapp::Base qw(:all)
\&    DB<2> insert_method( qw{PLUS MINUS TIMES }, \*(Aqprintclass\*(Aq, sub { print "$_[0]\en" } )
\&    DB<3> $_\->printclass for qw{PLUS MINUS TIMES }
\&  PLUS
\&  MINUS
\&  TIMES
\&
\&    DB<4> insert_method( qw{PLUS MINUS TIMES }, \*(Aqprintclass\*(Aq)
\&    DB<5> print $_\->can(\*(Aqprintclass\*(Aq)?"Yes\en":"No\en"  for qw{PLUS MINUS TIMES }
\&  No
\&  No
\&  No
.Ve
.ie n .SS "Function ""insert_function"""
.el .SS "Function \f(CWinsert_function\fP"
.IX Subsection "Function insert_function"
It works as \f(CW\*(C`insert_method\*(C'\fR (see section \*(L"Function insert_method\*(R"), 
only that instead of classes 
receives the full names of the functions to install and a reference 
to the code implementing such function. See an example of call:
.PP
.Vb 4
\&  insert_function(
\&    qw{ FUNCTIONCALL::type_info VARARRAY::type_info VAR::type_info },
\&    \e&type_info
\&  );
.Ve
.PP
When the package is unspecified the caller package is assumed. See the following 
example:
.PP
.Vb 6
\&  pl@nereida:~/src/perl/YappWithDefaultAction/lib/Parse/Eyapp$ perl \-wde 0
\&  main::(\-e:1):   0
\&    DB<1> use Parse::Eyapp::Base qw(:all)
\&    DB<2> insert_function(\*(AqTutu::tata\*(Aq, \*(Aqtiti\*(Aq, sub{ print "Inside titi\en"})
\&    DB<3> titi()
\&  Inside titi
\&
\&    DB<4> Tutu::tata()
\&  Inside titi
.Ve
.ie n .SS "Function ""empty_method"""
.el .SS "Function \f(CWempty_method\fP"
.IX Subsection "Function empty_method"
The call to
.PP
.Vb 1
\&                           empty_method(qw{CLASSES ... }, \*(Aqsubname\*(Aq)
.Ve
.PP
is equivalent to
.PP
.Vb 1
\&                          insert_method(qw{CLASSES ... }, \*(Aqsubname\*(Aq, sub {})
.Ve
.PP
Consequently \f(CW\*(C`empty_method\*(C'\fR replaces the current \f(CW\*(C`CODE\*(C'\fR for
function \f(CW\*(C`subname\*(C'\fR by an empty subroutine
.ie n .SS "Function ""push_method"""
.el .SS "Function \f(CWpush_method\fP"
.IX Subsection "Function push_method"
The call
.PP
.Vb 1
\&      push_method( qw{CLASS1 CLASS2 ... }, \*(Aqsubname\*(Aq, sub { ... } )
.Ve
.PP
saves the current methods \f(CW\*(C`CLASS1::subname\*(C'\fR, \f(CW\*(C`CLASS2::subname\*(C'\fR, etc. in a stack
and proceeds to install the new handler specified through the last argument.
See an example:
.PP
.Vb 7
\&  pl@nereida:~/src/perl/YappWithDefaultAction/lib/Parse/Eyapp$ perl \-wde 0
\&  main::(\-e:1):   0
\&    DB<1> use Parse::Eyapp::Base qw(:all)
\&    DB<2> sub Tutu::titi { print "Inside first Tutu::titi!\en" }
\&    DB<3> push_method(\*(AqTutu\*(Aq, \*(Aqtiti\*(Aq, sub { print "New titi!\en" })
\&    DB<4> Tutu::titi()
\&  New titi!
\&
\&    DB<5> pop_method(\*(AqTutu\*(Aq, \*(Aqtiti\*(Aq)
\&    DB<6> Tutu::titi()
\&  Inside first Tutu::titi!
\&
\&    DB<7> push_method(\*(AqTutu\*(Aq, \*(Aqtiti\*(Aq) # No handler: sub Tutu::titi no longer exists
\&    DB<8> print "Can\*(Aqt titi\en" unless Tutu\->can(\*(Aqtiti\*(Aq)
\&  Can\*(Aqt titi
\&
\&    DB<9> pop_method(\*(AqTutu\*(Aq, \*(Aqtiti\*(Aq) # Give me the old sub
\&    DB<10> Tutu::titi()
\&  Inside first Tutu::titi!
.Ve
.PP
The caller class is assumed if no classes are specified.
.PP
In list context the \f(CW\*(C`push_method\*(C'\fR  function returns an array of pointers to the old
versions of the function. In a scalar context returns the first \f(CW\*(C`CODE\*(C'\fR reference. 
See the following example:
.PP
.Vb 10
\&  pl@nereida:~/src/perl/YappWithDefaultAction/examples$ cat \-n returnedbypushmethod.pl
\&     1  #!/usr/local/bin/perl \-w
\&     2  use strict;
\&     3  use Parse::Eyapp::Base qw(:all);
\&     4
\&     5  sub tutu { "tutu" }
\&     6  sub Chum::tutu { "chum" }
\&     7
\&     8  my @classes = qw{main Cham Chum};
\&     9
\&    10  my %oldf;
\&    11  our $tutu = 5;
\&    12  our @tutu = 9..12;
\&    13  $Cham::tutu = 8;
\&    14  @Cham::tutu = 1..3;
\&    15
\&    16  @oldf{@classes} = push_method(@classes, \*(Aqtutu\*(Aq, sub { "titi" });
\&    17
\&    18  print "Calling new function \*(Aqtutu\*(Aq:".&tutu()."\en";
\&    19
\&    20  for (@classes) {
\&    21    if (defined($oldf{$_})) {
\&    22      print "Old function \*(Aqtutu\*(Aq in $_ gives: ".$oldf{$_}\->()."\en";
\&    23    }
\&    24    else {
\&    25       print "Function \*(Aqtutu\*(Aq wasn\*(Aqt defined in $_\en";
\&    26    }
\&    27  }
.Ve
.PP
The following session with the debugger shows that:
.IP "\(bu" 2
Package variables with the same name 
like \f(CW$tutu\fR or \f(CW@tutu\fR aren't changed by
\&\f(CW\*(C`insert_method\*(C'\fR
.IP "\(bu" 2
References to the old versions of function \f(CW\*(C`tutu\*(C'\fR
are returned by \f(CW\*(C`insert_method\*(C'\fR
.PP
.Vb 10
\&  pl@nereida:~/LEyapp/examples$ perl \-wd returnedbypushmethod.pl
\&  main::(returnedbypushmethod.pl:8):
\&  8:      my @classes = qw{main Cham Chum};
\&    DB<1> c 18
\&  main::(returnedbypushmethod.pl:18):
\&  18:     print "Calling new function \*(Aqtutu\*(Aq:".&tutu()."\en";
\&    DB<2> n
\&  Calling new function \*(Aqtutu\*(Aq:titi
\&  main::(returnedbypushmethod.pl:20):
\&  20:     for (@classes) {
\&    DB<2> x @tutu
\&  0  9
\&  1  10
\&  2  11
\&  3  12
\&    DB<3> x @Cham::tutu
\&  0  1
\&  1  2
\&  2  3
\&    DB<4> p $Cham::tutu
\&  8
\&    DB<5> c
\&  Old function \*(Aqtutu\*(Aq in main gives: tutu
\&  Function \*(Aqtutu\*(Aq wasn\*(Aqt defined in Cham
\&  Old function \*(Aqtutu\*(Aq in Chum gives: chum
.Ve
.ie n .SS "Function ""pop_method"""
.el .SS "Function \f(CWpop_method\fP"
.IX Subsection "Function pop_method"
The call
.PP
.Vb 1
\&                     pop_method(qw{CLASS1 CLASS2 ... }, \*(Aqsubname\*(Aq )
.Ve
.PP
pops the methods in the tops of the stacks associated with
\&\f(CW\*(C`CLASS1::subname\*(C'\fR, \f(CW\*(C`CLASS2::subname\*(C'\fR, etc. 
See the example in the section push_method above.
.IP "\(bu" 4
The caller class is assumed if no classes are specified.
.IP "\(bu" 4
If the stack for \f(CW\*(C`CLASS::subname\*(C'\fR is empty the old specification
of \f(CW\*(C`subname\*(C'\fR will remain.
.Sp
.Vb 4
\&  pl@nereida:~/LEyapp/examples$ cat returnedbypopmethod.pl
\&  #!/usr/local/bin/perl \-w
\&  use strict;
\&  use Parse::Eyapp::Base qw(:all);
\&
\&  sub tutu { "tutu" }
\&
\&  my $old = pop_method(\*(Aqtutu\*(Aq);
\&
\&  print "Function \*(Aqtutu\*(Aq is available\en" if main\->can(\*(Aqtutu\*(Aq);
\&  print "Old function \*(Aqtutu\*(Aq gives: ".$old\->()."\en";
.Ve
.Sp
When executed gives the following output:
.Sp
.Vb 3
\&  pl@nereida:~/LEyapp/examples$ returnedbypopmethod.pl
\&  Function \*(Aqtutu\*(Aq is available
\&  Old function \*(Aqtutu\*(Aq gives: tutu
.Ve
.IP "\(bu" 4
In list context the \f(CW\*(C`pop_method\*(C'\fR  function returns an array of pointers to the old
versions of the function. In a scalar context returns the first function 
reference. When the stack is empty the function(s) are deleted.
.ie n .SS "Examples of ""push_method"" and ""pop_method"""
.el .SS "Examples of \f(CWpush_method\fP and \f(CWpop_method\fP"
.IX Subsection "Examples of push_method and pop_method"
\fIHiding functions\fR
.IX Subsection "Hiding functions"
.PP
See the following example:
.PP
.Vb 2
\&  package Tutu;
\&  use Parse::Eyapp::Base qw(:all);
\&
\&  sub tutu {
\&    print "Inside tutu\en"
\&  }
\&
\&  sub plim {
\&
\&    # When the stack is empty the old \*(Aqtutu\*(Aq remains ...
\&    pop_method(\*(Aqtutu\*(Aq);
\&
\&    &tutu(); # Inside tutu
\&
\&    push_method(\*(Aqtutu\*(Aq); # Tutu disapears
\&  }
\&
\&  package main;
\&
\&  Tutu::plim(); 
\&  # main can\*(Aqt call \*(Aqtutu\*(Aq
\&  print "Can\*(Aqt tutu\en" unless Tutu\->can(\*(Aqtutu\*(Aq);
\&  Tutu::plim();
.Ve
.PP
When executed the former program produces this output:
.PP
.Vb 4
\&  pl@nereida:~/LEyapp/examples$ localsubbase.pl
\&  Inside tutu
\&  Can\*(Aqt tutu
\&  Inside tutu
.Ve
.PP
\fIChanging the Behavior of Method-parametric Methods\fR
.IX Subsection "Changing the Behavior of Method-parametric Methods"
.PP
A common situation where I need the couple (\f(CW\*(C`push_method\*(C'\fR, \f(CW\*(C`pop_method\*(C'\fR) 
is to control the behavior of method \f(CW\*(C`str\*(C'\fR when debugging:
.PP
.Vb 12
\&  pl@nereida:~/Lbook/code/Simple\-Types/script$ perl \-wd usetypes.pl prueba26.c 2
\&  Loading DB routines from perl5db.pl version 1.28
\&  Editor support available.
\&  main::(usetypes.pl:5):  my $filename = shift || die "Usage:\en$0 file.c\en";
\&    DB<1> c Parse::Eyapp::Node::str
\&  1 int f() {
\&  2   int a[30];
\&  3
\&  4   return;
\&  5 }
\&  Parse::Eyapp::Node::str(/home/pl/src/perl/YappWithDefaultAction/lib//Parse/Eyapp/Node.pm:716):
\&  716:      my @terms;
.Ve
.PP
Let us assume I want to see the syntax tree for this program. 
I can see it using \f(CW\*(C`$_[0]\->str\*(C'\fR
but the problem is that nodes \f(CW\*(C`PROGRAM\*(C'\fR and \f(CW\*(C`FUNCTION\*(C'\fR
have defined a \f(CW\*(C`footnote\*(C'\fR method that will dump their symbol and type tables producing 
hundred of lines of output and making difficult to see the shape of the tree.
This is because method \f(CW\*(C`str\*(C'\fR calls method \f(CW\*(C`footnote\*(C'\fR wherever the node being
visited \fIcan\fR do \f(CW\*(C`footnote\*(C'\fR. The solution is to use \f(CW\*(C`push_method\*(C'\fR to make
the \f(CW\*(C`footnote\*(C'\fR methods disappear:
.PP
.Vb 2
\&    DB<2> use Parse::Eyapp::Base qw(:all)
\&    DB<3> push_method(qw{PROGRAM FUNCTION}, \*(Aqfootnote\*(Aq)
.Ve
.PP
The use of \f(CW\*(C`push_method\*(C'\fR without an explicit code handler eliminates
the \s-1CODE\s0 entry for \f(CW\*(C`footnote\*(C'\fR:
.PP
.Vb 3
\&    DB<4> p $_\->can(\*(Aqfootnote\*(Aq)? "1\en" : "0\en" for (qw{PROGRAM FUNCTION})
\&  0
\&  0
.Ve
.PP
Now I can see the shape of the tree:
.PP
.Vb 1
\&    DB<5> p $_[0]\->str
\&
\&  PROGRAM(
\&    FUNCTION[f](
\&      EMPTYRETURN
\&    )
\&  ) # PROGRAM
.Ve
.PP
If I want back the \f(CW\*(C`footnote\*(C'\fR methods I can use \f(CW\*(C`pop_method\*(C'\fR:
.PP
.Vb 4
\&    DB<6> pop_method(qw{PROGRAM FUNCTION}, \*(Aqfootnote\*(Aq)
\&    DB<7> p $_\->can(\*(Aqfootnote\*(Aq)? "1\en" : "0\en" for (qw{PROGRAM FUNCTION})
\&    1
\&    1
.Ve
.PP
Now the information will be profuse:
.PP
.Vb 1
\&    DB<8> p $_[0]\->str
\&
\&  PROGRAM^{0}(
\&    FUNCTION[f]^{1}(
\&      EMPTYRETURN
\&    )
\&  ) # PROGRAM
\&  \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&  0)
\&  Types:
\&  $VAR1 = {
\&    \*(AqCHAR\*(Aq => bless( {
\&      \*(Aqchildren\*(Aq => []
\&    }, \*(AqCHAR\*(Aq ),
\&    ..... etc, etc.
\&    \*(AqA_30(INT)\*(Aq => bless( {
\&      \*(Aqchildren\*(Aq => [
\&        $VAR1\->{\*(AqINT\*(Aq}
\&      ]
\&    }, \*(AqA_30\*(Aq )
\&  };
\&  Symbol Table:
\&  $VAR1 = {
\&    \*(Aqf\*(Aq => {
\&      \*(Aqtype\*(Aq => \*(AqF(X_0(),INT)\*(Aq,
\&      \*(Aqline\*(Aq => 1
\&    }
\&  };
\&
\&  \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&  1)
\&  $VAR1 = {
\&    \*(Aqa\*(Aq => {
\&      \*(Aqtype\*(Aq => \*(AqA_30(INT)\*(Aq,
\&      \*(Aqline\*(Aq => 2
\&    }
\&  };
.Ve
.PP
You can still do something like this to achieve a similar effect:
.PP
.Vb 1
\&  DB<9> p eval { local (*PROGRAM::footnote, *FUNCTION::footnote) = (sub {}, sub {}); $_[0]\->str }
\&
\&  PROGRAM(
\&    FUNCTION[f](
\&      EMPTYRETURN
\&    )
\&  ) # PROGRAM
.Ve
.PP
but is certainly more verbose and does not eliminate function \f(CW\*(C`footnote\*(C'\fR
from the \f(CW\*(C`PROGRAM\*(C'\fR and \f(CW\*(C`FUNCTION\*(C'\fR classes.
.PP
Therefore the usefulness of \f(CW\*(C`push_method\*(C'\fR is when you either want to
temporarily delete your function/methods or localize them not necessarily in a 
scope basis.
.ie n .SS "Function ""compute_lines"""
.el .SS "Function \f(CWcompute_lines\fP"
.IX Subsection "Function compute_lines"
The call
.PP
.Vb 1
\&                compute_lines(\e$text, $filename, $pattern)
.Ve
.PP
Substitutes all the occurrences of 
\&\f(CW$pattern\fR by \f(CW\*(C`#line $number $filename\*(C'\fR in string \f(CW$text\fR.
where \f(CW$number\fR is the line number.
.ie n .SS "Function ""slurp_file"""
.el .SS "Function \f(CWslurp_file\fP"
.IX Subsection "Function slurp_file"
The call
.PP
.Vb 1
\&                my $input = slurp_file($filename, "c");
.Ve
.PP
returns a string with the contents of the file \f(CW$filename\fR assuming
extension \f(CW"c"\fR.
.PP
.Vb 8
\&  pl@nereida:~/src/perl/YappWithDefaultAction/lib/Parse/Eyapp$ perl \-wde 0
\&  main::(\-e:1):   0
\&    DB<1> use Parse::Eyapp::Base qw(:all)
\&    DB<2> !!ls *yp # There are two files with extension .yp in this directory
\&  Parse.yp  Treeregexp.yp
\&    DB<3> $x = slurp_file(\*(AqParse\*(Aq, \*(Aqyp\*(Aq) # read the whole file
\&    DB<4> p $x =~ tr/\en// # file Parse.yp has 1038 lines
\&  1038
.Ve
.ie n .SS "Function ""valid_keys"""
.el .SS "Function \f(CWvalid_keys\fP"
.IX Subsection "Function valid_keys"
The call
.PP
.Vb 1
\&              valid_keys(%hash)
.Ve
.PP
Returns a string with the keys of the \f(CW%hash\fR separated by commas:
.PP
.Vb 7
\&  pl@nereida:~/src/perl/YappWithDefaultAction/lib/Parse/Eyapp$ perl \-wde 0
\&  main::(\-e:1):   0
\&    DB<1> use Parse::Eyapp::Base qw(:all)
\&    DB<2> %h = ( SCOPE_NAME => \*(AqSTRING\*(Aq, ENTRY_NAME => \*(AqSTRING\*(Aq, SCOPE_DEPTH => \*(AqSTRING\*(Aq)
\&    DB<3> $x = valid_keys(%h)
\&    DB<4> p $x
\&  ENTRY_NAME, SCOPE_DEPTH, SCOPE_NAME
.Ve
.ie n .SS "Function ""invalid_keys"""
.el .SS "Function \f(CWinvalid_keys\fP"
.IX Subsection "Function invalid_keys"
It is called with two hash references:
.PP
.Vb 2
\&    DB<5> p invalid_keys(\e%h, { SCOPE_NAME => \*(Aqa\*(Aq, ENTRY_NAMe => \*(Aqb\*(Aq, SCOPE_DEPTH => \*(Aqc\*(Aq})
\&  ENTRY_NAMe
.Ve
.PP
It returns the first key in the second hash that does not appear in the first hash.
See a more complete example:
.PP
.Vb 10
\&  pl@nereida:~/src/perl/YappWithDefaultAction/lib/Parse/Eyapp$ head \-31 Scope.pm | cat \-n
\&     1  package Parse::Eyapp::Scope;
\&     2  use strict;
\&     3  use warnings;
\&     4  use Carp;
\&     5  use List::MoreUtils qw(part);
\&     6  use Parse::Eyapp::Base qw(valid_keys invalid_keys);
\&     7
\&     8  my %_new_scope = (
\&     9    SCOPE_NAME      => \*(AqSTRING\*(Aq,
\&    10    ENTRY_NAME      => \*(AqSTRING\*(Aq,
\&    11    SCOPE_DEPTH     => \*(AqSTRING\*(Aq,
\&    12  );
\&    13  my $valid_scope_keys = valid_keys(%_new_scope);
\&    14
\&    15  sub new {
\&    16   my $class = shift;
\&    17    my %args = @_;
\&    18
\&    19    if (defined($a = invalid_keys(\e%_new_scope, \e%args))) {
\&    20      croak("Parse::Eyapp::Scope::new Error!:\en"
\&    21           ."unknown argument $a. Valid arguments for new are:\en  $valid_scope_keys")
\&    22    }
\&    23    $args{ENTRY_NAME}      = \*(Aqentry\*(Aq unless defined($args{ENTRY_NAME});
\&    24    $args{SCOPE_NAME}      = \*(Aqscope\*(Aq unless defined($args{SCOPE_NAME});
\&    25    $args{SCOPE_DEPTH}     = \*(Aq\*(Aq      unless defined($args{SCOPE_DEPTH});
\&    26    $args{PENDING_DECL}    = [];
\&    27    $args{SCOPE_MARK}      = 0;
\&    28    $args{DEPTH}           = \-1; # first depth is 0
\&    29
\&    30    bless \e%args, $class;
\&    31  }
.Ve
.ie n .SS "Function ""write_file"""
.el .SS "Function \f(CWwrite_file\fP"
.IX Subsection "Function write_file"
The call
.PP
.Vb 1
\&              write_file($filename, $textref)
.Ve
.PP
simply opens a file  with name \f(CW$filename\fR
writes in it the text referenced by \f(CW$texterf\fR and closes the file
.ie n .SS "Function ""numbered"""
.el .SS "Function \f(CWnumbered\fP"
.IX Subsection "Function numbered"
The call
.PP
.Vb 1
\&                numbered($input)
.Ve
.PP
Returns a string like \f(CW$input\fR but with lines numbered and the numbers correctly
indented. See an example:
.PP
.Vb 10
\&    DB<1> use Parse::Eyapp::Base qw(:all)
\&    DB<2> $input = "Another line!\en"x12
\&    DB<3> $output = numbered($input)
\&    DB<4> p $output
\&   1 Another line!
\&   2 Another line!
\&   3 Another line!
\&   4 Another line!
\&   5 Another line!
\&   6 Another line!
\&   7 Another line!
\&   8 Another line!
\&   9 Another line!
\&  10 Another line!
\&  11 Another line!
\&  12 Another line!
.Ve
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.IP "\(bu" 4
Parse::Eyapp,
.SH "CONTRIBUTORS"
.IX Header "CONTRIBUTORS"
.IP "\(bu" 2
Hal Finkel <http://www.halssoftware.com/>
.IP "\(bu" 2
G. Williams <http://kasei.us/>
.IP "\(bu" 2
Thomas L. Shinnick <http://search.cpan.org/~tshinnic/>
.IP "\(bu" 2
Frank Leray
.SH "AUTHOR"
.IX Header "AUTHOR"
Casiano Rodriguez-Leon (casiano@ull.es)
.SH "ACKNOWLEDGMENTS"
.IX Header "ACKNOWLEDGMENTS"
This work has been supported by \s-1CEE \s0(\s-1FEDER\s0) and the Spanish Ministry of
\&\fIEducacion y Ciencia\fR through \fIPlan Nacional I+D+I\fR number \s-1TIN2005\-08818\-C04\-04
\&\s0(\s-1ULL::OPLINK\s0 project <http://www.oplink.ull.es/>). 
Support from Gobierno de Canarias was through \s-1GC02210601
\&\s0(\fIGrupos Consolidados\fR).
The University of La Laguna has also supported my work in many ways
and for many years.
.PP
A large percentage of  code is verbatim taken from Parse::Yapp 1.05.
The author of Parse::Yapp is Francois Desarmenien.
.PP
I wish to thank Francois Desarmenien for his Parse::Yapp module, 
to my students at La Laguna and to the Perl Community. Thanks to 
the people who have contributed to improve the module (see \*(L"\s-1CONTRIBUTORS\*(R"\s0 in Parse::Eyapp).
Thanks to Larry Wall for giving us Perl.
Special thanks to Juana.
.SH "LICENCE AND COPYRIGHT"
.IX Header "LICENCE AND COPYRIGHT"
Copyright (c) 2006\-2008 Casiano Rodriguez-Leon (casiano@ull.es). All rights reserved.
.PP
Parse::Yapp copyright is of Francois Desarmenien, all rights reserved. 1998\-2001
.PP
These modules are free software; you can redistribute it and/or
modify it under the same terms as Perl itself. See perlartistic.
.PP
This program is distributed in the hope that it will be useful,
but \s-1WITHOUT ANY WARRANTY\s0; without even the implied warranty of
\&\s-1MERCHANTABILITY\s0 or \s-1FITNESS FOR A PARTICULAR PURPOSE. \s0
