.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "ExtUtils::Install 3pm"
.TH ExtUtils::Install 3pm "2014-01-06" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
ExtUtils::Install \- install files from here to there
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use ExtUtils::Install;
\&
\&  install({ \*(Aqblib/lib\*(Aq => \*(Aqsome/install/dir\*(Aq } );
\&
\&  uninstall($packlist);
\&
\&  pm_to_blib({ \*(Aqlib/Foo/Bar.pm\*(Aq => \*(Aqblib/lib/Foo/Bar.pm\*(Aq });
.Ve
.SH "VERSION"
.IX Header "VERSION"
1.59
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Handles the installing and uninstalling of perl modules, scripts, man
pages, etc...
.PP
Both \fIinstall()\fR and \fIuninstall()\fR are specific to the way
ExtUtils::MakeMaker handles the installation and deinstallation of
perl modules. They are not designed as general purpose tools.
.PP
On some operating systems such as Win32 installation may not be possible
until after a reboot has occured. This can have varying consequences:
removing an old \s-1DLL\s0 does not impact programs using the new one, but if
a new \s-1DLL\s0 cannot be installed properly until reboot then anything
depending on it must wait. The package variable
.PP
.Vb 1
\&  $ExtUtils::Install::MUST_REBOOT
.Ve
.PP
is used to store this status.
.PP
If this variable is true then such an operation has occured and
anything depending on this module cannot proceed until a reboot
has occured.
.PP
If this value is defined but false then such an operation has
ocurred, but should not impact later operations.
.SS "Functions"
.IX Subsection "Functions"
.IP "\fBinstall\fR" 4
.IX Item "install"
.Vb 4
\&    # deprecated forms
\&    install(\e%from_to);
\&    install(\e%from_to, $verbose, $dry_run, $uninstall_shadows,
\&                $skip, $always_copy, \e%result);
\&
\&    # recommended form as of 1.47
\&    install([
\&        from_to => \e%from_to,
\&        verbose => 1,
\&        dry_run => 0,
\&        uninstall_shadows => 1,
\&        skip => undef,
\&        always_copy => 1,
\&        result => \e%install_results,
\&    ]);
.Ve
.Sp
Copies each directory tree of \f(CW%from_to\fR to its corresponding value
preserving timestamps and permissions.
.Sp
There are two keys with a special meaning in the hash: \*(L"read\*(R" and
\&\*(L"write\*(R".  These contain packlist files.  After the copying is done,
\&\fIinstall()\fR will write the list of target files to \f(CW$from_to\fR{write}. If
\&\f(CW$from_to\fR{read} is given the contents of this file will be merged into
the written file. The read and the written file may be identical, but
on \s-1AFS\s0 it is quite likely that people are installing to a different
directory than the one where the files later appear.
.Sp
If \f(CW$verbose\fR is true, will print out each file removed.  Default is
false.  This is \*(L"make install VERBINST=1\*(R". \f(CW$verbose\fR values going
up to 5 show increasingly more diagnostics output.
.Sp
If \f(CW$dry_run\fR is true it will only print what it was going to do
without actually doing it.  Default is false.
.Sp
If \f(CW$uninstall_shadows\fR is true any differing versions throughout \f(CW@INC\fR
will be uninstalled.  This is \*(L"make install UNINST=1\*(R"
.Sp
As of 1.37_02 \fIinstall()\fR supports the use of a list of patterns to filter out
files that shouldn't be installed. If \f(CW$skip\fR is omitted or undefined then
install will try to read the list from \s-1INSTALL.SKIP\s0 in the \s-1CWD.\s0 This file is
a list of regular expressions and is just like the \s-1MANIFEST.SKIP\s0 file used
by ExtUtils::Manifest.
.Sp
A default site \s-1INSTALL.SKIP\s0 may be provided by setting then environment
variable \s-1EU_INSTALL_SITE_SKIPFILE,\s0 this will only be used when there isn't a
distribution specific \s-1INSTALL.SKIP.\s0 If the environment variable
\&\s-1EU_INSTALL_IGNORE_SKIP\s0 is true then no install file filtering will be
performed.
.Sp
If \f(CW$skip\fR is undefined then the skip file will be autodetected and used if it
is found. If \f(CW$skip\fR is a reference to an array then it is assumed the array
contains the list of patterns, if \f(CW$skip\fR is a true non reference it is
assumed to be the filename holding the list of patterns, any other value of
\&\f(CW$skip\fR is taken to mean that no install filtering should occur.
.Sp
\&\fBChanges As of Version 1.47\fR
.Sp
As of version 1.47 the following additions were made to the install interface.
Note that the new argument style and use of the \f(CW%result\fR hash is recommended.
.Sp
The \f(CW$always_copy\fR parameter which when true causes files to be updated
regardles as to whether they have changed, if it is defined but false then
copies are made only if the files have changed, if it is undefined then the
value of the environment variable \s-1EU_INSTALL_ALWAYS_COPY\s0 is used as default.
.Sp
The \f(CW%result\fR hash will be populated with the various keys/subhashes reflecting
the install. Currently these keys and their structure are:
.Sp
.Vb 3
\&    install             => { $target    => $source },
\&    install_fail        => { $target    => $source },
\&    install_unchanged   => { $target    => $source },
\&
\&    install_filtered    => { $source    => $pattern },
\&
\&    uninstall           => { $uninstalled => $source },
\&    uninstall_fail      => { $uninstalled => $source },
.Ve
.Sp
where \f(CW$source\fR is the filespec of the file being installed. \f(CW$target\fR is where
it is being installed to, and \f(CW$uninstalled\fR is any shadow file that is in \f(CW@INC\fR
or \f(CW$ENV{PERL5LIB}\fR or other standard locations, and \f(CW$pattern\fR is the pattern that
caused a source file to be skipped. In future more keys will be added, such as to
show created directories, however this requires changes in other modules and must
therefore wait.
.Sp
These keys will be populated before any exceptions are thrown should there be an
error.
.Sp
Note that all updates of the \f(CW%result\fR are additive, the hash will not be
cleared before use, thus allowing status results of many installs to be easily
aggregated.
.Sp
\&\fB\s-1NEW ARGUMENT STYLE\s0\fR
.Sp
If there is only one argument and it is a reference to an array then
the array is assumed to contain a list of key-value pairs specifying
the options. In this case the option \*(L"from_to\*(R" is mandatory. This style
means that you dont have to supply a cryptic list of arguments and can
use a self documenting argument list that is easier to understand.
.Sp
This is now the recommended interface to \fIinstall()\fR.
.Sp
\&\fB\s-1RETURN\s0\fR
.Sp
If all actions were successful install will return a hashref of the results
as described above for the \f(CW$result\fR parameter. If any action is a failure
then install will die, therefore it is recommended to pass in the \f(CW$result\fR
parameter instead of using the return value. If the result parameter is
provided then the returned hashref will be the passed in hashref.
.IP "\fBinstall_default\fR \fI\s-1DISCOURAGED\s0\fR" 4
.IX Item "install_default DISCOURAGED"
.Vb 2
\&    install_default();
\&    install_default($fullext);
.Ve
.Sp
Calls \fIinstall()\fR with arguments to copy a module from blib/ to the
default site installation location.
.Sp
\&\f(CW$fullext\fR is the name of the module converted to a directory
(ie. Foo::Bar would be Foo/Bar).  If \f(CW$fullext\fR is not specified, it
will attempt to read it from \f(CW@ARGV\fR.
.Sp
This is primarily useful for install scripts.
.Sp
\&\fB\s-1NOTE\s0\fR This function is not really useful because of the hard-coded
install location with no way to control site vs core vs vendor
directories and the strange way in which the module name is given.
Consider its use discouraged.
.IP "\fBuninstall\fR" 4
.IX Item "uninstall"
.Vb 2
\&    uninstall($packlist_file);
\&    uninstall($packlist_file, $verbose, $dont_execute);
.Ve
.Sp
Removes the files listed in a \f(CW$packlist_file\fR.
.Sp
If \f(CW$verbose\fR is true, will print out each file removed.  Default is
false.
.Sp
If \f(CW$dont_execute\fR is true it will only print what it was going to do
without actually doing it.  Default is false.
.IP "\fBpm_to_blib\fR" 4
.IX Item "pm_to_blib"
.Vb 2
\&    pm_to_blib(\e%from_to, $autosplit_dir);
\&    pm_to_blib(\e%from_to, $autosplit_dir, $filter_cmd);
.Ve
.Sp
Copies each key of \f(CW%from_to\fR to its corresponding value efficiently.
Filenames with the extension .pm are autosplit into the \f(CW$autosplit_dir\fR.
Any destination directories are created.
.Sp
\&\f(CW$filter_cmd\fR is an optional shell command to run each .pm file through
prior to splitting and copying.  Input is the contents of the module,
output the new module contents.
.Sp
You can have an environment variable \s-1PERL_INSTALL_ROOT\s0 set which will
be prepended as a directory to each installed file (and directory).
.SH "ENVIRONMENT"
.IX Header "ENVIRONMENT"
.IP "\fB\s-1PERL_INSTALL_ROOT\s0\fR" 4
.IX Item "PERL_INSTALL_ROOT"
Will be prepended to each install path.
.IP "\fB\s-1EU_INSTALL_IGNORE_SKIP\s0\fR" 4
.IX Item "EU_INSTALL_IGNORE_SKIP"
Will prevent the automatic use of \s-1INSTALL.SKIP\s0 as the install skip file.
.IP "\fB\s-1EU_INSTALL_SITE_SKIPFILE\s0\fR" 4
.IX Item "EU_INSTALL_SITE_SKIPFILE"
If there is no \s-1INSTALL.SKIP\s0 file in the make directory then this value
can be used to provide a default.
.IP "\fB\s-1EU_INSTALL_ALWAYS_COPY\s0\fR" 4
.IX Item "EU_INSTALL_ALWAYS_COPY"
If this environment variable is true then normal install processes will
always overwrite older identical files during the install process.
.Sp
Note that the alias \s-1EU_ALWAYS_COPY\s0 will be supported if \s-1EU_INSTALL_ALWAYS_COPY\s0
is not defined until at least the 1.50 release. Please ensure you use the
correct \s-1EU_INSTALL_ALWAYS_COPY.\s0
.SH "AUTHOR"
.IX Header "AUTHOR"
Original author lost in the mists of time.  Probably the same as Makemaker.
.PP
Production release currently maintained by demerphq \f(CW\*(C`yves at cpan.org\*(C'\fR,
extensive changes by Michael G. Schwern.
.PP
Send bug reports via http://rt.cpan.org/.  Please send your
generated Makefile along with your report.
.SH "LICENSE"
.IX Header "LICENSE"
This program is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.
.PP
See <http://www.perl.com/perl/misc/Artistic.html>
.SH "POD ERRORS"
.IX Header "POD ERRORS"
Hey! \fBThe above document had some coding errors, which are explained below:\fR
.IP "Around line 298:" 4
.IX Item "Around line 298:"
You forgot a '=back' before '=head2'
.IP "Around line 545:" 4
.IX Item "Around line 545:"
\&'=item' outside of any '=over'
