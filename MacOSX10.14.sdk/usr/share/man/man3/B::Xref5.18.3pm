.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "B::Xref 3pm"
.TH B::Xref 3pm "2013-11-04" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
B::Xref \- Generates cross reference reports for Perl programs
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
perl \-MO=Xref[,OPTIONS] foo.pl
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The B::Xref module is used to generate a cross reference listing of all
definitions and uses of variables, subroutines and formats in a Perl program.
It is implemented as a backend for the Perl compiler.
.PP
The report generated is in the following format:
.PP
.Vb 8
\&    File filename1
\&      Subroutine subname1
\&        Package package1
\&          object1        line numbers
\&          object2        line numbers
\&          ...
\&        Package package2
\&        ...
.Ve
.PP
Each \fBFile\fR section reports on a single file. Each \fBSubroutine\fR section
reports on a single subroutine apart from the special cases
\&\*(L"(definitions)\*(R" and \*(L"(main)\*(R". These report, respectively, on subroutine
definitions found by the initial symbol table walk and on the main part of
the program or module external to all subroutines.
.PP
The report is then grouped by the \fBPackage\fR of each variable,
subroutine or format with the special case \*(L"(lexicals)\*(R" meaning
lexical variables. Each \fBobject\fR name (implicitly qualified by its
containing \fBPackage\fR) includes its type character(s) at the beginning
where possible. Lexical variables are easier to track and even
included dereferencing information where possible.
.PP
The \f(CW\*(C`line numbers\*(C'\fR are a comma separated list of line numbers (some
preceded by code letters) where that object is used in some way.
Simple uses aren't preceded by a code letter. Introductions (such as
where a lexical is first defined with \f(CW\*(C`my\*(C'\fR) are indicated with the
letter \*(L"i\*(R". Subroutine and method calls are indicated by the character
\&\*(L"&\*(R".  Subroutine definitions are indicated by \*(L"s\*(R" and format
definitions by \*(L"f\*(R".
.PP
For instance, here's part of the report from the \fIpod2man\fR program that
comes with Perl:
.PP
.Vb 12
\&  Subroutine clear_noremap
\&    Package (lexical)
\&      $ready_to_print   i1069, 1079
\&    Package main
\&      $&                1086
\&      $.                1086
\&      $0                1086
\&      $1                1087
\&      $2                1085, 1085
\&      $3                1085, 1085
\&      $ARGV             1086
\&      %HTML_Escapes     1085, 1085
.Ve
.PP
This shows the variables used in the subroutine \f(CW\*(C`clear_noremap\*(C'\fR.  The
variable \f(CW$ready_to_print\fR is a \fImy()\fR (lexical) variable,
\&\fBi\fRntroduced (first declared with \fImy()\fR) on line 1069, and used on
line 1079.  The variable \f(CW$&\fR from the main package is used on 1086,
and so on.
.PP
A line number may be prefixed by a single letter:
.IP "i" 4
.IX Item "i"
Lexical variable introduced (declared with \fImy()\fR) for the first time.
.IP "&" 4
Subroutine or method call.
.IP "s" 4
.IX Item "s"
Subroutine defined.
.IP "r" 4
.IX Item "r"
Format defined.
.PP
The most useful option the cross referencer has is to save the report
to a separate file.  For instance, to save the report on
\&\fImyperlprogram\fR to the file \fIreport\fR:
.PP
.Vb 1
\&  $ perl \-MO=Xref,\-oreport myperlprogram
.Ve
.SH "OPTIONS"
.IX Header "OPTIONS"
Option words are separated by commas (not whitespace) and follow the
usual conventions of compiler backend options.
.ie n .IP """\-oFILENAME""" 8
.el .IP "\f(CW\-oFILENAME\fR" 8
.IX Item "-oFILENAME"
Directs output to \f(CW\*(C`FILENAME\*(C'\fR instead of standard output.
.ie n .IP """\-r""" 8
.el .IP "\f(CW\-r\fR" 8
.IX Item "-r"
Raw output. Instead of producing a human-readable report, outputs a line
in machine-readable form for each definition/use of a variable/sub/format.
.ie n .IP """\-d""" 8
.el .IP "\f(CW\-d\fR" 8
.IX Item "-d"
Don't output the \*(L"(definitions)\*(R" sections.
.ie n .IP """\-D[tO]""" 8
.el .IP "\f(CW\-D[tO]\fR" 8
.IX Item "-D[tO]"
(Internal) debug options, probably only useful if \f(CW\*(C`\-r\*(C'\fR included.
The \f(CW\*(C`t\*(C'\fR option prints the object on the top of the stack as it's
being tracked. The \f(CW\*(C`O\*(C'\fR option prints each operator as it's being
processed in the execution order of the program.
.SH "BUGS"
.IX Header "BUGS"
Non-lexical variables are quite difficult to track through a program.
Sometimes the type of a non-lexical variable's use is impossible to
determine. Introductions of non-lexical non-scalars don't seem to be
reported properly.
.SH "AUTHOR"
.IX Header "AUTHOR"
Malcolm Beattie, mbeattie@sable.ox.ac.uk.
