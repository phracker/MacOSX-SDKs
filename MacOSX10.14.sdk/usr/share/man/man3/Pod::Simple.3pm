.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Pod::Simple 3pm"
.TH Pod::Simple 3pm "2013-11-04" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Pod::Simple \- framework for parsing Pod
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& TODO
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Pod::Simple is a Perl library for parsing text in the Pod (\*(L"plain old
documentation\*(R") markup language that is typically used for writing
documentation for Perl and for Perl modules. The Pod format is explained
perlpod; the most common formatter is called \f(CW\*(C`perldoc\*(C'\fR.
.PP
Be sure to read \*(L"\s-1ENCODING\*(R"\s0 if your Pod contains non-ASCII characters.
.PP
Pod formatters can use Pod::Simple to parse Pod documents and render them into
plain text, \s-1HTML,\s0 or any number of other formats. Typically, such formatters
will be subclasses of Pod::Simple, and so they will inherit its methods, like
\&\f(CW\*(C`parse_file\*(C'\fR.
.PP
If you're reading this document just because you have a Pod-processing
subclass that you want to use, this document (plus the documentation for the
subclass) is probably all you need to read.
.PP
If you're reading this document because you want to write a formatter
subclass, continue reading it and then read Pod::Simple::Subclassing, and
then possibly even read perlpodspec (some of which is for parser-writers,
but much of which is notes to formatter-writers).
.SH "MAIN METHODS"
.IX Header "MAIN METHODS"
.ie n .IP """$parser = \f(CISomeClass\f(CW\->new();""" 4
.el .IP "\f(CW$parser = \f(CISomeClass\f(CW\->new();\fR" 4
.IX Item "$parser = SomeClass->new();"
This returns a new parser object, where \fI\f(CI\*(C`SomeClass\*(C'\fI\fR is a subclass
of Pod::Simple.
.ie n .IP """$parser\->output_fh( *OUT );""" 4
.el .IP "\f(CW$parser\->output_fh( *OUT );\fR" 4
.IX Item "$parser->output_fh( *OUT );"
This sets the filehandle that \f(CW$parser\fR's output will be written to.
You can pass \f(CW*STDOUT\fR, otherwise you should probably do something
like this:
.Sp
.Vb 3
\&    my $outfile = "output.txt";
\&    open TXTOUT, ">$outfile" or die "Can\*(Aqt write to $outfile: $!";
\&    $parser\->output_fh(*TXTOUT);
.Ve
.Sp
\&...before you call one of the \f(CW\*(C`$parser\->parse_\f(CIwhatever\f(CW\*(C'\fR methods.
.ie n .IP """$parser\->output_string( \e$somestring );""" 4
.el .IP "\f(CW$parser\->output_string( \e$somestring );\fR" 4
.IX Item "$parser->output_string( $somestring );"
This sets the string that \f(CW$parser\fR's output will be sent to,
instead of any filehandle.
.ie n .IP """$parser\->parse_file( \f(CI$some_filename\f(CW );""" 4
.el .IP "\f(CW$parser\->parse_file( \f(CI$some_filename\f(CW );\fR" 4
.IX Item "$parser->parse_file( $some_filename );"
.PD 0
.ie n .IP """$parser\->parse_file( *INPUT_FH );""" 4
.el .IP "\f(CW$parser\->parse_file( *INPUT_FH );\fR" 4
.IX Item "$parser->parse_file( *INPUT_FH );"
.PD
This reads the Pod content of the file (or filehandle) that you specify,
and processes it with that \f(CW$parser\fR object, according to however
\&\f(CW$parser\fR's class works, and according to whatever parser options you
have set up for this \f(CW$parser\fR object.
.ie n .IP """$parser\->parse_string_document( \f(CI$all_content\f(CW );""" 4
.el .IP "\f(CW$parser\->parse_string_document( \f(CI$all_content\f(CW );\fR" 4
.IX Item "$parser->parse_string_document( $all_content );"
This works just like \f(CW\*(C`parse_file\*(C'\fR except that it reads the Pod
content not from a file, but from a string that you have already
in memory.
.ie n .IP """$parser\->parse_lines( \f(CI...@lines...\f(CW, undef );""" 4
.el .IP "\f(CW$parser\->parse_lines( \f(CI...@lines...\f(CW, undef );\fR" 4
.IX Item "$parser->parse_lines( ...@lines..., undef );"
This processes the lines in \f(CW@lines\fR (where each list item must be a
defined value, and must contain exactly one line of content \*(-- so no
items like \f(CW"foo\enbar"\fR are allowed).  The final \f(CW\*(C`undef\*(C'\fR is used to
indicate the end of document being parsed.
.Sp
The other \f(CW\*(C`parser_\f(CIwhatever\f(CW\*(C'\fR methods are meant to be called only once
per \f(CW$parser\fR object; but \f(CW\*(C`parse_lines\*(C'\fR can be called as many times per
\&\f(CW$parser\fR object as you want, as long as the last call (and only
the last call) ends with an \f(CW\*(C`undef\*(C'\fR value.
.ie n .IP """$parser\->content_seen""" 4
.el .IP "\f(CW$parser\->content_seen\fR" 4
.IX Item "$parser->content_seen"
This returns true only if there has been any real content seen for this
document. Returns false in cases where the document contains content,
but does not make use of any Pod markup.
.ie n .IP """\f(CISomeClass\f(CW\->filter( \f(CI$filename\f(CW );""" 4
.el .IP "\f(CW\f(CISomeClass\f(CW\->filter( \f(CI$filename\f(CW );\fR" 4
.IX Item "SomeClass->filter( $filename );"
.PD 0
.ie n .IP """\f(CISomeClass\f(CW\->filter( \f(CI*INPUT_FH\f(CW );""" 4
.el .IP "\f(CW\f(CISomeClass\f(CW\->filter( \f(CI*INPUT_FH\f(CW );\fR" 4
.IX Item "SomeClass->filter( *INPUT_FH );"
.ie n .IP """\f(CISomeClass\f(CW\->filter( \f(CI\e$document_content\f(CW );""" 4
.el .IP "\f(CW\f(CISomeClass\f(CW\->filter( \f(CI\e$document_content\f(CW );\fR" 4
.IX Item "SomeClass->filter( $document_content );"
.PD
This is a shortcut method for creating a new parser object, setting the
output handle to \s-1STDOUT,\s0 and then processing the specified file (or
filehandle, or in-memory document). This is handy for one-liners like
this:
.Sp
.Vb 1
\&  perl \-MPod::Simple::Text \-e "Pod::Simple::Text\->filter(\*(Aqthingy.pod\*(Aq)"
.Ve
.SH "SECONDARY METHODS"
.IX Header "SECONDARY METHODS"
Some of these methods might be of interest to general users, as
well as of interest to formatter-writers.
.PP
Note that the general pattern here is that the accessor-methods
read the attribute's value with \f(CW\*(C`$value = $parser\->\f(CIattribute\f(CW\*(C'\fR
and set the attribute's value with
\&\f(CW\*(C`$parser\->\f(CIattribute\f(CW(\f(CInewvalue\f(CW)\*(C'\fR.  For each accessor, I typically
only mention one syntax or another, based on which I think you are actually
most likely to use.
.ie n .IP """$parser\->parse_characters( \f(CISOMEVALUE\f(CW )""" 4
.el .IP "\f(CW$parser\->parse_characters( \f(CISOMEVALUE\f(CW )\fR" 4
.IX Item "$parser->parse_characters( SOMEVALUE )"
The Pod parser normally expects to read octets and to convert those octets
to characters based on the \f(CW\*(C`=encoding\*(C'\fR declaration in the Pod source.  Set
this option to a true value to indicate that the Pod source is already a Perl
character stream.  This tells the parser to ignore any \f(CW\*(C`=encoding\*(C'\fR command
and to skip all the code paths involving decoding octets.
.ie n .IP """$parser\->no_whining( \f(CISOMEVALUE\f(CW )""" 4
.el .IP "\f(CW$parser\->no_whining( \f(CISOMEVALUE\f(CW )\fR" 4
.IX Item "$parser->no_whining( SOMEVALUE )"
If you set this attribute to a true value, you will suppress the
parser's complaints about irregularities in the Pod coding. By default,
this attribute's value is false, meaning that irregularities will
be reported.
.Sp
Note that turning this attribute to true won't suppress one or two kinds
of complaints about rarely occurring unrecoverable errors.
.ie n .IP """$parser\->no_errata_section( \f(CISOMEVALUE\f(CW )""" 4
.el .IP "\f(CW$parser\->no_errata_section( \f(CISOMEVALUE\f(CW )\fR" 4
.IX Item "$parser->no_errata_section( SOMEVALUE )"
If you set this attribute to a true value, you will stop the parser from
generating a \*(L"\s-1POD ERRORS\*(R"\s0 section at the end of the document. By
default, this attribute's value is false, meaning that an errata section
will be generated, as necessary.
.ie n .IP """$parser\->complain_stderr( \f(CISOMEVALUE\f(CW )""" 4
.el .IP "\f(CW$parser\->complain_stderr( \f(CISOMEVALUE\f(CW )\fR" 4
.IX Item "$parser->complain_stderr( SOMEVALUE )"
If you set this attribute to a true value, it will send reports of
parsing errors to \s-1STDERR.\s0 By default, this attribute's value is false,
meaning that no output is sent to \s-1STDERR.\s0
.Sp
Setting \f(CW\*(C`complain_stderr\*(C'\fR also sets \f(CW\*(C`no_errata_section\*(C'\fR.
.ie n .IP """$parser\->source_filename""" 4
.el .IP "\f(CW$parser\->source_filename\fR" 4
.IX Item "$parser->source_filename"
This returns the filename that this parser object was set to read from.
.ie n .IP """$parser\->doc_has_started""" 4
.el .IP "\f(CW$parser\->doc_has_started\fR" 4
.IX Item "$parser->doc_has_started"
This returns true if \f(CW$parser\fR has read from a source, and has seen
Pod content in it.
.ie n .IP """$parser\->source_dead""" 4
.el .IP "\f(CW$parser\->source_dead\fR" 4
.IX Item "$parser->source_dead"
This returns true if \f(CW$parser\fR has read from a source, and come to the
end of that source.
.ie n .IP """$parser\->strip_verbatim_indent( \f(CISOMEVALUE\f(CW )""" 4
.el .IP "\f(CW$parser\->strip_verbatim_indent( \f(CISOMEVALUE\f(CW )\fR" 4
.IX Item "$parser->strip_verbatim_indent( SOMEVALUE )"
The perlpod spec for a Verbatim paragraph is \*(L"It should be reproduced
exactly...\*(R", which means that the whitespace you've used to indent your
verbatim blocks will be preserved in the output. This can be annoying for
outputs such as \s-1HTML,\s0 where that whitespace will remain in front of every
line. It's an unfortunate case where syntax is turned into semantics.
.Sp
If the \s-1POD\s0 your parsing adheres to a consistent indentation policy, you can
have such indentation stripped from the beginning of every line of your
verbatim blocks. This method tells Pod::Simple what to strip. For two-space
indents, you'd use:
.Sp
.Vb 1
\&  $parser\->strip_verbatim_indent(\*(Aq  \*(Aq);
.Ve
.Sp
For tab indents, you'd use a tab character:
.Sp
.Vb 1
\&  $parser\->strip_verbatim_indent("\et");
.Ve
.Sp
If the \s-1POD\s0 is inconsistent about the indentation of verbatim blocks, but you
have figured out a heuristic to determine how much a particular verbatim block
is indented, you can pass a code reference instead. The code reference will be
executed with one argument, an array reference of all the lines in the
verbatim block, and should return the value to be stripped from each line. For
example, if you decide that you're fine to use the first line of the verbatim
block to set the standard for indentation of the rest of the block, you can
look at the first line and return the appropriate value, like so:
.Sp
.Vb 5
\&  $new\->strip_verbatim_indent(sub {
\&      my $lines = shift;
\&      (my $indent = $lines\->[0]) =~ s/\eS.*//;
\&      return $indent;
\&  });
.Ve
.Sp
If you'd rather treat each line individually, you can do that, too, by just
transforming them in-place in the code reference and returning \f(CW\*(C`undef\*(C'\fR. Say
that you don't want \fIany\fR lines indented. You can do something like this:
.Sp
.Vb 5
\&  $new\->strip_verbatim_indent(sub {
\&      my $lines = shift;
\&      sub { s/^\es+// for @{ $lines },
\&      return undef;
\&  });
.Ve
.SH "TERTIARY METHODS"
.IX Header "TERTIARY METHODS"
.ie n .IP """$parser\->abandon_output_fh()""" 4
.el .IP "\f(CW$parser\->abandon_output_fh()\fR" 4
.IX Xref "abandon_output_fh"
.IX Item "$parser->abandon_output_fh()"
Cancel output to the file handle. Any \s-1POD\s0 read by the \f(CW$parser\fR is not
effected.
.ie n .IP """$parser\->abandon_output_string()""" 4
.el .IP "\f(CW$parser\->abandon_output_string()\fR" 4
.IX Xref "abandon_output_string"
.IX Item "$parser->abandon_output_string()"
Cancel output to the output string. Any \s-1POD\s0 read by the \f(CW$parser\fR is not
effected.
.ie n .IP """$parser\->accept_code( @codes )""" 4
.el .IP "\f(CW$parser\->accept_code( @codes )\fR" 4
.IX Xref "accept_code"
.IX Item "$parser->accept_code( @codes )"
Alias for accept_codes.
.ie n .IP """$parser\->accept_codes( @codes )""" 4
.el .IP "\f(CW$parser\->accept_codes( @codes )\fR" 4
.IX Xref "accept_codes"
.IX Item "$parser->accept_codes( @codes )"
Allows \f(CW$parser\fR to accept a list of \*(L"Formatting Codes\*(R" in perlpod. This can be
used to implement user-defined codes.
.ie n .IP """$parser\->accept_directive_as_data( @directives )""" 4
.el .IP "\f(CW$parser\->accept_directive_as_data( @directives )\fR" 4
.IX Xref "accept_directive_as_data"
.IX Item "$parser->accept_directive_as_data( @directives )"
Allows \f(CW$parser\fR to accept a list of directives for data paragraphs. A
directive is the label of a \*(L"Command Paragraph\*(R" in perlpod. A data paragraph is
one delimited by \f(CW\*(C`=begin/=for/=end\*(C'\fR directives. This can be used to
implement user-defined directives.
.ie n .IP """$parser\->accept_directive_as_processed( @directives )""" 4
.el .IP "\f(CW$parser\->accept_directive_as_processed( @directives )\fR" 4
.IX Xref "accept_directive_as_processed"
.IX Item "$parser->accept_directive_as_processed( @directives )"
Allows \f(CW$parser\fR to accept a list of directives for processed paragraphs. A
directive is the label of a \*(L"Command Paragraph\*(R" in perlpod. A processed
paragraph is also known as \*(L"Ordinary Paragraph\*(R" in perlpod. This can be used to
implement user-defined directives.
.ie n .IP """$parser\->accept_directive_as_verbatim( @directives )""" 4
.el .IP "\f(CW$parser\->accept_directive_as_verbatim( @directives )\fR" 4
.IX Xref "accept_directive_as_verbatim"
.IX Item "$parser->accept_directive_as_verbatim( @directives )"
Allows \f(CW$parser\fR to accept a list of directives for \*(L"Verbatim
Paragraph\*(R" in perlpod. A directive is the label of a \*(L"Command Paragraph\*(R" in perlpod. This
can be used to implement user-defined directives.
.ie n .IP """$parser\->accept_target( @targets )""" 4
.el .IP "\f(CW$parser\->accept_target( @targets )\fR" 4
.IX Xref "accept_target"
.IX Item "$parser->accept_target( @targets )"
Alias for accept_targets.
.ie n .IP """$parser\->accept_target_as_text( @targets )""" 4
.el .IP "\f(CW$parser\->accept_target_as_text( @targets )\fR" 4
.IX Xref "accept_target_as_text"
.IX Item "$parser->accept_target_as_text( @targets )"
Alias for accept_targets_as_text.
.ie n .IP """$parser\->accept_targets( @targets )""" 4
.el .IP "\f(CW$parser\->accept_targets( @targets )\fR" 4
.IX Xref "accept_targets"
.IX Item "$parser->accept_targets( @targets )"
Accepts targets for \f(CW\*(C`=begin/=for/=end\*(C'\fR sections of the \s-1POD.\s0
.ie n .IP """$parser\->accept_targets_as_text( @targets )""" 4
.el .IP "\f(CW$parser\->accept_targets_as_text( @targets )\fR" 4
.IX Xref "accept_targets_as_text"
.IX Item "$parser->accept_targets_as_text( @targets )"
Accepts targets for \f(CW\*(C`=begin/=for/=end\*(C'\fR sections that should be parsed as
\&\s-1POD.\s0 For details, see \*(L"About Data Paragraphs\*(R" in perlpodspec.
.ie n .IP """$parser\->any_errata_seen()""" 4
.el .IP "\f(CW$parser\->any_errata_seen()\fR" 4
.IX Xref "any_errata_seen"
.IX Item "$parser->any_errata_seen()"
Used to check if any errata was seen.
.Sp
\&\fIExample:\fR
.Sp
.Vb 1
\&  die "too many errors\en" if $parser\->any_errata_seen();
.Ve
.ie n .IP """$parser\->detected_encoding()""" 4
.el .IP "\f(CW$parser\->detected_encoding()\fR" 4
.IX Xref "detected_encoding"
.IX Item "$parser->detected_encoding()"
Return the encoding corresponding to \f(CW\*(C`=encoding\*(C'\fR, but only if the
encoding was recognized and handled.
.ie n .IP """$parser\->encoding()""" 4
.el .IP "\f(CW$parser\->encoding()\fR" 4
.IX Xref "encoding"
.IX Item "$parser->encoding()"
Return encoding of the document, even if the encoding is not correctly
handled.
.ie n .IP """$parser\->parse_from_file( $source, $to )""" 4
.el .IP "\f(CW$parser\->parse_from_file( $source, $to )\fR" 4
.IX Xref "parse_from_file"
.IX Item "$parser->parse_from_file( $source, $to )"
Parses from \f(CW$source\fR file to \f(CW$to\fR file. Similar to \*(L"parse_from_file\*(R" in Pod::Parser.
.ie n .IP """$parser\->scream( @error_messages )""" 4
.el .IP "\f(CW$parser\->scream( @error_messages )\fR" 4
.IX Xref "scream"
.IX Item "$parser->scream( @error_messages )"
Log an error that can't be ignored.
.ie n .IP """$parser\->unaccept_code( @codes )""" 4
.el .IP "\f(CW$parser\->unaccept_code( @codes )\fR" 4
.IX Xref "unaccept_code"
.IX Item "$parser->unaccept_code( @codes )"
Alias for unaccept_codes.
.ie n .IP """$parser\->unaccept_codes( @codes )""" 4
.el .IP "\f(CW$parser\->unaccept_codes( @codes )\fR" 4
.IX Xref "unaccept_codes"
.IX Item "$parser->unaccept_codes( @codes )"
Removes \f(CW@codes\fR as valid codes for the parse.
.ie n .IP """$parser\->unaccept_directive( @directives )""" 4
.el .IP "\f(CW$parser\->unaccept_directive( @directives )\fR" 4
.IX Xref "unaccept_directive"
.IX Item "$parser->unaccept_directive( @directives )"
Alias for unaccept_directives.
.ie n .IP """$parser\->unaccept_directives( @directives )""" 4
.el .IP "\f(CW$parser\->unaccept_directives( @directives )\fR" 4
.IX Xref "unaccept_directives"
.IX Item "$parser->unaccept_directives( @directives )"
Removes \f(CW@directives\fR as valid directives for the parse.
.ie n .IP """$parser\->unaccept_target( @targets )""" 4
.el .IP "\f(CW$parser\->unaccept_target( @targets )\fR" 4
.IX Xref "unaccept_target"
.IX Item "$parser->unaccept_target( @targets )"
Alias for unaccept_targets.
.ie n .IP """$parser\->unaccept_targets( @targets )""" 4
.el .IP "\f(CW$parser\->unaccept_targets( @targets )\fR" 4
.IX Xref "unaccept_targets"
.IX Item "$parser->unaccept_targets( @targets )"
Removes \f(CW@targets\fR as valid targets for the parse.
.ie n .IP """$parser\->version_report()""" 4
.el .IP "\f(CW$parser\->version_report()\fR" 4
.IX Xref "version_report"
.IX Item "$parser->version_report()"
Returns a string describing the version.
.ie n .IP """$parser\->whine( @error_messages )""" 4
.el .IP "\f(CW$parser\->whine( @error_messages )\fR" 4
.IX Xref "whine"
.IX Item "$parser->whine( @error_messages )"
Log an error unless \f(CW\*(C`$parser\->no_whining( TRUE );\*(C'\fR.
.SH "ENCODING"
.IX Header "ENCODING"
The Pod::Simple parser expects to read \fBoctets\fR.  The parser will decode the
octets into Perl's internal character string representation using the value of
the \f(CW\*(C`=encoding\*(C'\fR declaration in the \s-1POD\s0 source.
.PP
If the \s-1POD\s0 source does not include an \f(CW\*(C`=encoding\*(C'\fR declaration, the parser will
attempt to guess the encoding (selecting one of \s-1UTF\-8\s0 or Latin\-1) by examining
the first non-ASCII bytes and applying the heuristic described in
perlpodspec.
.PP
If you set the \f(CW\*(C`parse_characters\*(C'\fR option to a true value the parser will
expect characters rather than octets; will ignore any \f(CW\*(C`=encoding\*(C'\fR; and will
make no attempt to decode the input.
.SH "CAVEATS"
.IX Header "CAVEATS"
This is just a beta release \*(-- there are a good number of things still
left to do.  Notably, support for \s-1EBCDIC\s0 platforms is still half-done,
an untested.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Pod::Simple::Subclassing
.PP
perlpod
.PP
perlpodspec
.PP
Pod::Escapes
.PP
perldoc
.SH "SUPPORT"
.IX Header "SUPPORT"
Questions or discussion about \s-1POD\s0 and Pod::Simple should be sent to the
pod\-people@perl.org mail list. Send an empty email to
pod\-people\-subscribe@perl.org to subscribe.
.PP
This module is managed in an open GitHub repository,
<https://github.com/theory/pod\-simple/>. Feel free to fork and contribute, or
to clone <git://github.com/theory/pod\-simple.git> and send patches!
.PP
Patches against Pod::Simple are welcome. Please send bug reports to
<bug\-pod\-simple@rt.cpan.org>.
.SH "COPYRIGHT AND DISCLAIMERS"
.IX Header "COPYRIGHT AND DISCLAIMERS"
Copyright (c) 2002 Sean M. Burke.
.PP
This library is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.
.PP
This program is distributed in the hope that it will be useful, but
without any warranty; without even the implied warranty of
merchantability or fitness for a particular purpose.
.SH "AUTHOR"
.IX Header "AUTHOR"
Pod::Simple was created by Sean M. Burke <sburke@cpan.org>.
But don't bother him, he's retired.
.PP
Pod::Simple is maintained by:
.IP "\(bu" 4
Allison Randal \f(CW\*(C`allison@perl.org\*(C'\fR
.IP "\(bu" 4
Hans Dieter Pearcey \f(CW\*(C`hdp@cpan.org\*(C'\fR
.IP "\(bu" 4
David E. Wheeler \f(CW\*(C`dwheeler@cpan.org\*(C'\fR
.PP
Documentation has been contributed by:
.IP "\(bu" 4
Gabor Szabo \f(CW\*(C`szabgab@gmail.com\*(C'\fR
.IP "\(bu" 4
Shawn H Corey  \f(CW\*(C`SHCOREY at cpan.org\*(C'\fR
