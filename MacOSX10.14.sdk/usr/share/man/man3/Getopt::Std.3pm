.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Getopt::Std 3pm"
.TH Getopt::Std 3pm "2014-01-06" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
getopt, getopts \- Process single\-character switches with switch clustering
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use Getopt::Std;
\&
\&    getopt(\*(AqoDI\*(Aq);    # \-o, \-D & \-I take arg.  Sets $opt_* as a side effect.
\&    getopt(\*(AqoDI\*(Aq, \e%opts);    # \-o, \-D & \-I take arg.  Values in %opts
\&    getopts(\*(Aqoif:\*(Aq);  # \-o & \-i are boolean flags, \-f takes an argument
\&                      # Sets $opt_* as a side effect.
\&    getopts(\*(Aqoif:\*(Aq, \e%opts);  # options as above. Values in %opts
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The \fIgetopt()\fR function processes single-character switches with switch
clustering.  Pass one argument which is a string containing all switches
that take an argument.  For each switch found, sets \f(CW$opt_x\fR (where x is the
switch name) to the value of the argument if an argument is expected,
or 1 otherwise.  Switches which take an argument don't care whether
there is a space between the switch and the argument.
.PP
The \fIgetopts()\fR function is similar, but you should pass to it the list of all
switches to be recognized.  If unspecified switches are found on the
command-line, the user will be warned that an unknown option was given.
The \fIgetopts()\fR function returns true unless an invalid option was found.
.PP
Note that, if your code is running under the recommended \f(CW\*(C`use strict
\&\*(Aqvars\*(Aq\*(C'\fR pragma, you will need to declare these package variables
with \*(L"our\*(R":
.PP
.Vb 1
\&    our($opt_x, $opt_y);
.Ve
.PP
For those of you who don't like additional global variables being created, \fIgetopt()\fR
and \fIgetopts()\fR will also accept a hash reference as an optional second argument. 
Hash keys will be x (where x is the switch name) with key values the value of
the argument or 1 if no argument is specified.
.PP
To allow programs to process arguments that look like switches, but aren't,
both functions will stop processing switches when they see the argument
\&\f(CW\*(C`\-\-\*(C'\fR.  The \f(CW\*(C`\-\-\*(C'\fR will be removed from \f(CW@ARGV\fR.
.ie n .SH """\-\-help"" and ""\-\-version"""
.el .SH "\f(CW\-\-help\fP and \f(CW\-\-version\fP"
.IX Header "--help and --version"
If \f(CW\*(C`\-\*(C'\fR is not a recognized switch letter, \fIgetopts()\fR supports arguments
\&\f(CW\*(C`\-\-help\*(C'\fR and \f(CW\*(C`\-\-version\*(C'\fR.  If \f(CW\*(C`main::HELP_MESSAGE()\*(C'\fR and/or
\&\f(CW\*(C`main::VERSION_MESSAGE()\*(C'\fR are defined, they are called; the arguments are
the output file handle, the name of option-processing package, its version,
and the switches string.  If the subroutines are not defined, an attempt is
made to generate intelligent messages; for best results, define \f(CW$main::VERSION\fR.
.PP
If embedded documentation (in pod format, see perlpod) is detected
in the script, \f(CW\*(C`\-\-help\*(C'\fR will also show how to access the documentation.
.PP
Note that due to excessive paranoia, if \f(CW$Getopt::Std::STANDARD_HELP_VERSION\fR
isn't true (the default is false), then the messages are printed on \s-1STDERR,\s0
and the processing continues after the messages are printed.  This being
the opposite of the standard-conforming behaviour, it is strongly recommended
to set \f(CW$Getopt::Std::STANDARD_HELP_VERSION\fR to true.
.PP
One can change the output file handle of the messages by setting
\&\f(CW$Getopt::Std::OUTPUT_HELP_VERSION\fR.  One can print the messages of \f(CW\*(C`\-\-help\*(C'\fR
(without the \f(CW\*(C`Usage:\*(C'\fR line) and \f(CW\*(C`\-\-version\*(C'\fR by calling functions \fIhelp_mess()\fR
and \fIversion_mess()\fR with the switches string as an argument.
