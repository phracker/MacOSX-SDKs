.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "ExtUtils::XSSymSet 3pm"
.TH ExtUtils::XSSymSet 3pm "2014-01-06" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
ExtUtils::XSSymSet \- keep sets of symbol names palatable to the VMS linker
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use ExtUtils::XSSymSet;
\&
\&  $set = new ExtUtils::XSSymSet;
\&  while ($sym = make_symbol()) { $set\->addsym($sym); }
\&  foreach $safesym ($set\->all_trimmed) {
\&    print "Processing $safesym (derived from ",$self\->get_orig($safesym),")\en";
\&    do_stuff($safesym);
\&  }
\&
\&  $safesym = ExtUtils::XSSymSet\->trimsym($onesym);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Since the \s-1VMS\s0 linker distinguishes symbols based only on the first 31
characters of their names, it is occasionally necessary to shorten
symbol names in order to avoid collisions.  (This is especially true of
names generated by xsubpp, since prefixes generated by nested package
names can become quite long.)  \f(CW\*(C`ExtUtils::XSSymSet\*(C'\fR provides functions to
shorten names in a consistent fashion, and to track a set of names to
insure that each is unique.  While designed with \fIxsubpp\fR in mind, it
may be used with any set of strings.
.PP
This package supplies the following functions, all of which should be
called as methods.
.IP "new([$maxlen[,$silent]])" 4
.IX Item "new([$maxlen[,$silent]])"
Creates an empty \f(CW\*(C`ExtUtils::XSSymset\*(C'\fR set of symbols.  This function may be
called as a static method or via an existing object.  If \f(CW$maxlen\fR or
\&\f(CW$silent\fR are specified, they are used as the defaults for maximum
name length and warning behavior in future calls to \fIaddsym()\fR or
\&\fItrimsym()\fR via this object.  If the compiler has been instructed to do its
own symbol shortening via \f(CW$Config{\*(Aquseshortenedsymbols\*(Aq}\fR, a value of
2048 is assumed for \f(CW$maxlen\fR as a way of bypassing the shortening done by
this module.
.IP "addsym($name[,$maxlen[,$silent]])" 4
.IX Item "addsym($name[,$maxlen[,$silent]])"
Creates a symbol name from \f(CW$name\fR, using the methods described
under \fItrimsym()\fR, which is unique in this set of symbols, and returns
the new name.  \f(CW$name\fR and its resultant are added to the set, and
any future calls to \fIaddsym()\fR specifying the same \f(CW$name\fR will return
the same result, regardless of the value of \f(CW$maxlen\fR specified.
Unless \f(CW$silent\fR is true, warnings are output if \f(CW$name\fR had to be
trimmed or changed in order to avoid collision with an existing symbol
name.  \f(CW$maxlen\fR and \f(CW$silent\fR default to the values specified when
this set of symbols was created.  This method must be called via an
existing object.
.IP "trimsym($name[,$maxlen[,$silent]])" 4
.IX Item "trimsym($name[,$maxlen[,$silent]])"
Creates a symbol name \f(CW$maxlen\fR or fewer characters long from
\&\f(CW$name\fR and returns it. If \f(CW$name\fR is too long, it first tries to
shorten it by removing duplicate characters, then by periodically
removing non-underscore characters, and finally, if necessary, by
periodically removing characters of any type.  \f(CW$maxlen\fR defaults
to 31.  Unless \f(CW$silent\fR is true, a warning is output if \f(CW$name\fR
is altered in any way.  This function may be called either as a
static method or via an existing object, but in the latter case no
check is made to insure that the resulting name is unique in the
set of symbols.    If the compiler has been instructed to do its
own symbol shortening via \f(CW$Config{\*(Aquseshortenedsymbols\*(Aq}\fR, a value
of 2048 is assumed for \f(CW$maxlen\fR as a way of bypassing the shortening
done by this module.
.IP "delsym($name)" 4
.IX Item "delsym($name)"
Removes \f(CW$name\fR from the set of symbols, where \f(CW$name\fR is the
original symbol name passed previously to \fIaddsym()\fR.  If \f(CW$name\fR
existed in the set of symbols, returns its \*(L"trimmed\*(R" equivalent,
otherwise returns \f(CW\*(C`undef\*(C'\fR.  This method must be called via an
existing object.
.IP "get_orig($trimmed)" 4
.IX Item "get_orig($trimmed)"
Returns the original name which was trimmed to \f(CW$trimmed\fR by a
previous call to \fIaddsym()\fR, or \f(CW\*(C`undef\*(C'\fR if \f(CW$trimmed\fR does not
correspond to a member of this set of symbols.  This method must be
called via an existing object.
.IP "get_trimmed($name)" 4
.IX Item "get_trimmed($name)"
Returns the trimmed name which was generated from \f(CW$name\fR by a
previous call to \fIaddsym()\fR, or \f(CW\*(C`undef\*(C'\fR if \f(CW$name\fR is not a member
of this set of symbols.  This method must be called via an
existing object.
.IP "\fIall_orig()\fR" 4
.IX Item "all_orig()"
Returns a list containing all of the original symbol names
from this set.
.IP "\fIall_trimmed()\fR" 4
.IX Item "all_trimmed()"
Returns a list containing all of the trimmed symbol names
from this set.
.SH "AUTHOR"
.IX Header "AUTHOR"
Charles Bailey  <\fIbailey@newman.upenn.edu\fR>
.SH "REVISION"
.IX Header "REVISION"
Last revised 8\-Oct\-2010, for Perl 5.13.6.
