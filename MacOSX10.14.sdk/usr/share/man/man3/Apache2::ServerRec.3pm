.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "install::TempContent::Objects::mod_perl-2.0.9::docs::api::Apache2::ServerRec 3"
.TH install::TempContent::Objects::mod_perl-2.0.9::docs::api::Apache2::ServerRec 3 "2015-06-18" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Apache2::ServerRec \- Perl API for Apache server record accessors
.SH "Synopsis"
.IX Header "Synopsis"
.Vb 1
\&  use Apache2::ServerRec ();
\&  
\&  $error_fname = $s\->error_fname();
\&  
\&  $is_virtual = $s\->is_virtual();
\&  
\&  $keep_alive         = $s\->keep_alive();
\&  $keep_alive_max     = $s\->keep_alive_max();
\&  $keep_alive_timeout = $s\->keep_alive_timeout();
\&  
\&  $limit_req_fields    = $s\->limit_req_fields();
\&  $limit_req_fieldsize = $s\->limit_req_fieldsize();
\&  $limit_req_line      = $s\->limit_req_line();
\&  
\&  $path = $s\->path();
\&  
\&  $hostname = $s\->server_hostname();
\&  $port     = $s\->port();
\&  
\&  $server_admin = $s\->server_admin();
\&  
\&  $proc = $s\->process();
\&  
\&  $timeout  = $s\->timeout();
\&  $loglevel = $s\->loglevel();
\&  
\&  my $server = Apache2::ServerUtil\->server;
\&  my $vhosts = 0;
\&  for (my $s = $server\->next; $s; $s = $s\->next) {
\&      $vhosts++;
\&  }
\&  print "There are $vhosts virtual hosts";
.Ve
.SH "Description"
.IX Header "Description"
\&\f(CW\*(C`Apache2::ServerRec\*(C'\fR provides the Perl \s-1API\s0 for Apache server_rec
object.
.PP
\&\f(CW\*(C`Apache2::ServerUtil\*(C'\fR provides
an extra functionality.
.SH "API"
.IX Header "API"
\&\f(CW\*(C`Apache2::ServerRec\*(C'\fR provides the following functions and/or methods:
.ie n .SS """error_fname"""
.el .SS "\f(CWerror_fname\fP"
.IX Subsection "error_fname"
Get/set the \f(CW\*(C`ErrorLog\*(C'\fR file value (e.g. \fIlogs/error_log\fR)
.PP
.Vb 2
\&  $error_fname      = $s\->error_fname();
\&  $prev_error_fname = $s\->error_fname($new_error_fname);
.Ve
.ie n .IP "obj: $s ( ""Apache2::ServerRec object"" )" 4
.el .IP "obj: \f(CW$s\fR ( \f(CWApache2::ServerRec object\fR )" 4
.IX Item "obj: $s ( Apache2::ServerRec object )"
.PD 0
.ie n .IP "opt arg1: $new_error_fname ( string )" 4
.el .IP "opt arg1: \f(CW$new_error_fname\fR ( string )" 4
.IX Item "opt arg1: $new_error_fname ( string )"
.PD
If passed, sets the new value for \f(CW\*(C`ErrorLog\*(C'\fR
.Sp
Note the limited functionality under threaded
MPMs.
.ie n .IP "ret: $error_fname ( string )" 4
.el .IP "ret: \f(CW$error_fname\fR ( string )" 4
.IX Item "ret: $error_fname ( string )"
Returns the \f(CW\*(C`ErrorLog\*(C'\fR value setting.
.Sp
If \f(CW$new_error_fname\fR is passed returns the setting before the change.
.IP "since: 2.0.00" 4
.IX Item "since: 2.0.00"
.ie n .SS """is_virtual"""
.el .SS "\f(CWis_virtual\fP"
.IX Subsection "is_virtual"
Test whether \f(CW$s\fR is a virtual host object
.PP
.Vb 1
\&  $is_virtual = $s\->is_virtual();
.Ve
.ie n .IP "obj: $s ( ""Apache2::ServerRec object"" )" 4
.el .IP "obj: \f(CW$s\fR ( \f(CWApache2::ServerRec object\fR )" 4
.IX Item "obj: $s ( Apache2::ServerRec object )"
.PD 0
.ie n .IP "ret: $is_virtual ( boolean )" 4
.el .IP "ret: \f(CW$is_virtual\fR ( boolean )" 4
.IX Item "ret: $is_virtual ( boolean )"
.PD
Returns the is_virtual setting.
.Sp
If \f(CW$new_is_virtual\fR is passed, returns the setting before the
change.
.IP "since: 2.0.00" 4
.IX Item "since: 2.0.00"
.PP
Example:
.PP
.Vb 1
\&  print "This is a virtual host" if $s\->is_virtual();
.Ve
.ie n .SS """keep_alive"""
.el .SS "\f(CWkeep_alive\fP"
.IX Subsection "keep_alive"
Get/set the \f(CW\*(C`KeepAlive\*(C'\fR setting, which specifies whether Apache
should accept more than one request over the same connection from the
same client.
.PP
.Vb 2
\&  $keep_alive      = $s\->keep_alive();
\&  $prev_keep_alive = $s\->keep_alive($new_keep_alive);
.Ve
.ie n .IP "obj: $s ( ""Apache2::ServerRec object"" )" 4
.el .IP "obj: \f(CW$s\fR ( \f(CWApache2::ServerRec object\fR )" 4
.IX Item "obj: $s ( Apache2::ServerRec object )"
.PD 0
.ie n .IP "opt arg1: $new_keep_alive ( boolean )" 4
.el .IP "opt arg1: \f(CW$new_keep_alive\fR ( boolean )" 4
.IX Item "opt arg1: $new_keep_alive ( boolean )"
.PD
If passed, sets the new keep_alive.
.Sp
Note the limited functionality under threaded
MPMs.
.ie n .IP "ret: $keep_alive ( boolean )" 4
.el .IP "ret: \f(CW$keep_alive\fR ( boolean )" 4
.IX Item "ret: $keep_alive ( boolean )"
Returns the \f(CW\*(C`KeepAlive\*(C'\fR setting.
.Sp
If \f(CW$new_keep_alive\fR is passed, returns the setting before the
change.
.IP "since: 2.0.00" 4
.IX Item "since: 2.0.00"
.ie n .SS """keep_alive_max"""
.el .SS "\f(CWkeep_alive_max\fP"
.IX Subsection "keep_alive_max"
Get/set the \f(CW\*(C`MaxKeepAliveRequest\*(C'\fR setting, which specifies the
maximum number of requests Apache will serve over a \f(CW\*(C`KeepAlive\*(C'\fR
connection.
.PP
.Vb 2
\&  $keep_alive_max      = $s\->keep_alive_max();
\&  $prev_keep_alive_max = $s\->keep_alive_max($new_keep_alive_max);
.Ve
.ie n .IP "obj: $s ( ""Apache2::ServerRec object"" )" 4
.el .IP "obj: \f(CW$s\fR ( \f(CWApache2::ServerRec object\fR )" 4
.IX Item "obj: $s ( Apache2::ServerRec object )"
.PD 0
.ie n .IP "opt arg1: $new_keep_alive_max ( integer )" 4
.el .IP "opt arg1: \f(CW$new_keep_alive_max\fR ( integer )" 4
.IX Item "opt arg1: $new_keep_alive_max ( integer )"
.PD
If passed, sets the new keep_alive_max.
.Sp
Note the limited functionality under threaded
MPMs.
.ie n .IP "ret: $keep_alive_max ( integer )" 4
.el .IP "ret: \f(CW$keep_alive_max\fR ( integer )" 4
.IX Item "ret: $keep_alive_max ( integer )"
Returns the keep_alive_max setting.
.Sp
If \f(CW$new_keep_alive_max\fR is passed, returns the setting before the
change.
.IP "since: 2.0.00" 4
.IX Item "since: 2.0.00"
.ie n .SS """keep_alive_timeout"""
.el .SS "\f(CWkeep_alive_timeout\fP"
.IX Subsection "keep_alive_timeout"
Get/set the \f(CW\*(C`KeepAliveTimeout\*(C'\fR setting (in microsecs), which
specifies how long Apache will wait for another request before
breaking a \f(CW\*(C`KeepAlive\*(C'\fR connection.
.PP
.Vb 2
\&  $keep_alive_timeout      = $s\->keep_alive_timeout();
\&  $prev_keep_alive_timeout = $s\->keep_alive_timeout($new_timeout);
.Ve
.ie n .IP "obj: $s ( ""Apache2::ServerRec object"" )" 4
.el .IP "obj: \f(CW$s\fR ( \f(CWApache2::ServerRec object\fR )" 4
.IX Item "obj: $s ( Apache2::ServerRec object )"
.PD 0
.ie n .IP "opt arg1: $new_keep_alive_timeout ( integer )" 4
.el .IP "opt arg1: \f(CW$new_keep_alive_timeout\fR ( integer )" 4
.IX Item "opt arg1: $new_keep_alive_timeout ( integer )"
.PD
The expected value is in microsecs.
.Sp
If passed, sets the new \f(CW\*(C`KeepAlive\*(C'\fR timeout.
.Sp
Note the limited functionality under threaded
MPMs.
.ie n .IP "ret: $keep_alive_timeout ( integer )" 4
.el .IP "ret: \f(CW$keep_alive_timeout\fR ( integer )" 4
.IX Item "ret: $keep_alive_timeout ( integer )"
Returns the \f(CW\*(C`KeepAlive\*(C'\fR timeout value (in microsecs).
.Sp
If \f(CW$new_timeout\fR is passed, returns the setting before the change.
.IP "since: 2.0.00" 4
.IX Item "since: 2.0.00"
.ie n .SS """limit_req_fields"""
.el .SS "\f(CWlimit_req_fields\fP"
.IX Subsection "limit_req_fields"
Get/set limit on number of request header fields
.PP
.Vb 2
\&  $limit_req_fields      = $s\->limit_req_fields();
\&  $prev_limit_req_fields = $s\->limit_req_fields($new_limit_req_fields);
.Ve
.ie n .IP "obj: $s ( ""Apache2::ServerRec object"" )" 4
.el .IP "obj: \f(CW$s\fR ( \f(CWApache2::ServerRec object\fR )" 4
.IX Item "obj: $s ( Apache2::ServerRec object )"
.PD 0
.ie n .IP "opt arg1: $new_limit_req_fields ( integer )" 4
.el .IP "opt arg1: \f(CW$new_limit_req_fields\fR ( integer )" 4
.IX Item "opt arg1: $new_limit_req_fields ( integer )"
.PD
If passed, sets the new request headers number limit.
.Sp
Note the limited functionality under threaded
MPMs.
.ie n .IP "ret: $limit_req_fields ( integer )" 4
.el .IP "ret: \f(CW$limit_req_fields\fR ( integer )" 4
.IX Item "ret: $limit_req_fields ( integer )"
Returns the request headers number limit.
.Sp
If \f(CW$new_limit_req_fields\fR is passed, returns the setting before the
change.
.IP "since: 2.0.00" 4
.IX Item "since: 2.0.00"
.ie n .SS """limit_req_fieldsize"""
.el .SS "\f(CWlimit_req_fieldsize\fP"
.IX Subsection "limit_req_fieldsize"
Get/set limit on size of any request header field
.PP
.Vb 2
\&  $limit_req_fieldsize = $s\->limit_req_fieldsize();
\&  $prev_limit          = $s\->limit_req_fieldsize($new_limit);
.Ve
.ie n .IP "obj: $s ( ""Apache2::ServerRec object"" )" 4
.el .IP "obj: \f(CW$s\fR ( \f(CWApache2::ServerRec object\fR )" 4
.IX Item "obj: $s ( Apache2::ServerRec object )"
.PD 0
.ie n .IP "opt arg1: $new_limit_req_fieldsize ( integer )" 4
.el .IP "opt arg1: \f(CW$new_limit_req_fieldsize\fR ( integer )" 4
.IX Item "opt arg1: $new_limit_req_fieldsize ( integer )"
.PD
If passed, sets the new request header size limit.
.Sp
Note the limited functionality under threaded
MPMs.
.ie n .IP "ret: $limit_req_fieldsize ( integer )" 4
.el .IP "ret: \f(CW$limit_req_fieldsize\fR ( integer )" 4
.IX Item "ret: $limit_req_fieldsize ( integer )"
Returns the request header size limit.
.Sp
If \f(CW$new_limit\fR is passed, returns the setting before the change.
.IP "since: 2.0.00" 4
.IX Item "since: 2.0.00"
.ie n .SS """limit_req_line"""
.el .SS "\f(CWlimit_req_line\fP"
.IX Subsection "limit_req_line"
Get/set limit on size of the \s-1HTTP\s0 request line
.PP
.Vb 2
\&  $limit_req_line      = $s\->limit_req_line();
\&  $prev_limit_req_line = $s\->limit_req_line($new_limit_req_line);
.Ve
.ie n .IP "obj: $s ( ""Apache2::ServerRec object"" )" 4
.el .IP "obj: \f(CW$s\fR ( \f(CWApache2::ServerRec object\fR )" 4
.IX Item "obj: $s ( Apache2::ServerRec object )"
.PD 0
.ie n .IP "opt arg1: $new_limit_req_line ( integer )" 4
.el .IP "opt arg1: \f(CW$new_limit_req_line\fR ( integer )" 4
.IX Item "opt arg1: $new_limit_req_line ( integer )"
.PD
If passed, sets the new request line limit value.
.Sp
Note the limited functionality under threaded
MPMs.
.ie n .IP "ret: $limit_req_line ( integer )" 4
.el .IP "ret: \f(CW$limit_req_line\fR ( integer )" 4
.IX Item "ret: $limit_req_line ( integer )"
Returns the request line limit value
.Sp
If \f(CW$new_limit_req_line\fR is passed, returns the setting before the
change.
.IP "since: 2.0.00" 4
.IX Item "since: 2.0.00"
.ie n .SS """loglevel"""
.el .SS "\f(CWloglevel\fP"
.IX Subsection "loglevel"
Get/set the \f(CW\*(C`LogLevel\*(C'\fR directive value
.PP
.Vb 2
\&  $loglevel      = $s\->loglevel();
\&  $prev_loglevel = $s\->loglevel($new_loglevel);
.Ve
.ie n .IP "obj: $s ( ""Apache2::ServerRec object"" )" 4
.el .IP "obj: \f(CW$s\fR ( \f(CWApache2::ServerRec object\fR )" 4
.IX Item "obj: $s ( Apache2::ServerRec object )"
.PD 0
.ie n .IP "opt arg1: $new_loglevel ( ""Apache2::Const :log constant"" )" 4
.el .IP "opt arg1: \f(CW$new_loglevel\fR ( \f(CWApache2::Const :log constant\fR )" 4
.IX Item "opt arg1: $new_loglevel ( Apache2::Const :log constant )"
.PD
If passed, sets a new \f(CW\*(C`LogLevel\*(C'\fR value
.Sp
Note the limited functionality under threaded
MPMs.
.ie n .IP "ret: $loglevel ( ""Apache2::Const :log constant"" )" 4
.el .IP "ret: \f(CW$loglevel\fR ( \f(CWApache2::Const :log constant\fR )" 4
.IX Item "ret: $loglevel ( Apache2::Const :log constant )"
Returns the \f(CW\*(C`LogLevel\*(C'\fR value as a constant.
.Sp
If \f(CW$new_loglevel\fR is passed, returns the setting before the change.
.IP "since: 2.0.00" 4
.IX Item "since: 2.0.00"
.PP
For example, to set the \f(CW\*(C`LogLevel\*(C'\fR value to \f(CW\*(C`info\*(C'\fR:
.PP
.Vb 2
\&  use Apache2::Const \-compile => qw(LOG_INFO);
\&  $s\->loglevel(Apache2::Const::LOG_INFO);
.Ve
.ie n .SS """next"""
.el .SS "\f(CWnext\fP"
.IX Subsection "next"
The next server record in the list (if there are vhosts)
.PP
.Vb 1
\&  $s_next = $s\->next();
.Ve
.ie n .IP "obj: $s ( ""Apache2::ServerRec object"" )" 4
.el .IP "obj: \f(CW$s\fR ( \f(CWApache2::ServerRec object\fR )" 4
.IX Item "obj: $s ( Apache2::ServerRec object )"
.PD 0
.ie n .IP "ret: $s_next ( ""Apache2::ServerRec object"" )" 4
.el .IP "ret: \f(CW$s_next\fR ( \f(CWApache2::ServerRec object\fR )" 4
.IX Item "ret: $s_next ( Apache2::ServerRec object )"
.IP "since: 2.0.00" 4
.IX Item "since: 2.0.00"
.PD
.PP
For example the following code traverses all the servers, starting
from the base server and continuing to vhost servers, counting all
available vhosts:
.PP
.Vb 8
\&  use Apache2::ServerRec ();
\&  use Apache2::ServerUtil ();
\&  my $server = Apache2::ServerUtil\->server;
\&  my $vhosts = 0;
\&  for (my $s = $server\->next; $s; $s = $s\->next) {
\&      $vhosts++;
\&  }
\&  print "There are $vhosts virtual hosts";
.Ve
.ie n .SS """path"""
.el .SS "\f(CWpath\fP"
.IX Subsection "path"
Get/set pathname for the \f(CW\*(C`ServerPath\*(C'\fR setting
.PP
.Vb 2
\&  $path      = $s\->path();
\&  $prev_path = $s\->path($new_path);
.Ve
.ie n .IP "obj: $s ( ""Apache2::ServerRec object"" )" 4
.el .IP "obj: \f(CW$s\fR ( \f(CWApache2::ServerRec object\fR )" 4
.IX Item "obj: $s ( Apache2::ServerRec object )"
.PD 0
.ie n .IP "opt arg1: $new_path ( string )" 4
.el .IP "opt arg1: \f(CW$new_path\fR ( string )" 4
.IX Item "opt arg1: $new_path ( string )"
.PD
If passed, sets the new path.
.Sp
Note the limited functionality under threaded
MPMs.
.ie n .IP "ret: $path ( string )" 4
.el .IP "ret: \f(CW$path\fR ( string )" 4
.IX Item "ret: $path ( string )"
Returns the path setting.
.Sp
If \f(CW$new_path\fR is passed, returns the setting before the change.
.IP "since: 2.0.00" 4
.IX Item "since: 2.0.00"
.ie n .SS """port"""
.el .SS "\f(CWport\fP"
.IX Subsection "port"
Get/set the port value
.PP
.Vb 2
\&  $port      = $s\->port();
\&  $prev_port = $s\->port($new_port);
.Ve
.ie n .IP "obj: $s ( ""Apache2::ServerRec object"" )" 4
.el .IP "obj: \f(CW$s\fR ( \f(CWApache2::ServerRec object\fR )" 4
.IX Item "obj: $s ( Apache2::ServerRec object )"
.PD 0
.ie n .IP "opt arg1: $new_port ( integer )" 4
.el .IP "opt arg1: \f(CW$new_port\fR ( integer )" 4
.IX Item "opt arg1: $new_port ( integer )"
.PD
If passed, sets the new port.
.Sp
Note the limited functionality under threaded
MPMs.
.Sp
\&\s-1META: I\s0 don't think one should be allowed to change port number after
the server has started.
.ie n .IP "ret: $port ( integer )" 4
.el .IP "ret: \f(CW$port\fR ( integer )" 4
.IX Item "ret: $port ( integer )"
Returns the port setting.
.Sp
If \f(CW$new_port\fR is passed returns the setting before the change.
.IP "since: 2.0.00" 4
.IX Item "since: 2.0.00"
.ie n .SS """process"""
.el .SS "\f(CWprocess\fP"
.IX Subsection "process"
The process this server is running in
.PP
.Vb 1
\&  $proc = $s\->process();
.Ve
.ie n .IP "obj: $s ( ""Apache2::ServerRec object"" )" 4
.el .IP "obj: \f(CW$s\fR ( \f(CWApache2::ServerRec object\fR )" 4
.IX Item "obj: $s ( Apache2::ServerRec object )"
.PD 0
.ie n .IP "ret: $proc ( ""Apache2::Process object"" )" 4
.el .IP "ret: \f(CW$proc\fR ( \f(CWApache2::Process object\fR )" 4
.IX Item "ret: $proc ( Apache2::Process object )"
.IP "since: 2.0.00" 4
.IX Item "since: 2.0.00"
.PD
.ie n .SS """server_admin"""
.el .SS "\f(CWserver_admin\fP"
.IX Subsection "server_admin"
Get/set the \f(CW\*(C`ServerAdmin\*(C'\fR value
.PP
.Vb 2
\&  $server_admin      = $s\->server_admin();
\&  $prev_server_admin = $s\->server_admin($new_server_admin);
.Ve
.ie n .IP "obj: $s ( ""Apache2::ServerRec object"" )" 4
.el .IP "obj: \f(CW$s\fR ( \f(CWApache2::ServerRec object\fR )" 4
.IX Item "obj: $s ( Apache2::ServerRec object )"
.PD 0
.ie n .IP "opt arg1: $new_server_admin ( string )" 4
.el .IP "opt arg1: \f(CW$new_server_admin\fR ( string )" 4
.IX Item "opt arg1: $new_server_admin ( string )"
.PD
If passed, sets the new \f(CW\*(C`ServerAdmin\*(C'\fR value.
.Sp
Note the limited functionality under threaded
MPMs.
.ie n .IP "ret: $server_admin ( string )" 4
.el .IP "ret: \f(CW$server_admin\fR ( string )" 4
.IX Item "ret: $server_admin ( string )"
Returns the \f(CW\*(C`ServerAdmin\*(C'\fR value.
.Sp
If \f(CW$new_server_admin\fR is passed, returns the setting before the
change.
.IP "since: 2.0.00" 4
.IX Item "since: 2.0.00"
.ie n .SS """server_hostname"""
.el .SS "\f(CWserver_hostname\fP"
.IX Subsection "server_hostname"
Get/set the \f(CW\*(C`ServerName\*(C'\fR value
.PP
.Vb 2
\&  $server_hostname      = $s\->server_hostname();
\&  $prev_server_hostname = $s\->server_hostname($new_server_hostname);
.Ve
.ie n .IP "obj: $s ( ""Apache2::ServerRec object"" )" 4
.el .IP "obj: \f(CW$s\fR ( \f(CWApache2::ServerRec object\fR )" 4
.IX Item "obj: $s ( Apache2::ServerRec object )"
.PD 0
.ie n .IP "opt arg1: $new_server_hostname ( string )" 4
.el .IP "opt arg1: \f(CW$new_server_hostname\fR ( string )" 4
.IX Item "opt arg1: $new_server_hostname ( string )"
.PD
If passed, sets the \f(CW\*(C`ServerName\*(C'\fR value
.Sp
Note the limited functionality under threaded
MPMs.
.ie n .IP "ret: $server_hostname ( string )" 4
.el .IP "ret: \f(CW$server_hostname\fR ( string )" 4
.IX Item "ret: $server_hostname ( string )"
Returns the \f(CW\*(C`ServerName\*(C'\fR value
.Sp
If \f(CW$new_server_hostname\fR is passed, returns the setting before the
change.
.IP "since: 2.0.00" 4
.IX Item "since: 2.0.00"
.ie n .SS """timeout"""
.el .SS "\f(CWtimeout\fP"
.IX Subsection "timeout"
Get/set the timeout (\f(CW\*(C`TimeOut\*(C'\fR) (in microsecs), which Apache will
wait for before it gives up doing something
.PP
.Vb 2
\&  $timeout      = $s\->timeout();
\&  $prev_timeout = $s\->timeout($new_timeout);
.Ve
.ie n .IP "obj: $s ( ""Apache2::ServerRec object"" )" 4
.el .IP "obj: \f(CW$s\fR ( \f(CWApache2::ServerRec object\fR )" 4
.IX Item "obj: $s ( Apache2::ServerRec object )"
.PD 0
.ie n .IP "opt arg1: $new_timeout ( integer )" 4
.el .IP "opt arg1: \f(CW$new_timeout\fR ( integer )" 4
.IX Item "opt arg1: $new_timeout ( integer )"
.PD
If passed, sets the new timeout (the value should be in microseconds).
.Sp
Note the limited functionality under threaded
MPMs.
.ie n .IP "ret: $timeout ( integer )" 4
.el .IP "ret: \f(CW$timeout\fR ( integer )" 4
.IX Item "ret: $timeout ( integer )"
Returns the timeout setting in microseconds.
.Sp
If \f(CW$new_timeout\fR is passed, returns the setting before the change.
.IP "since: 2.0.00" 4
.IX Item "since: 2.0.00"
.PP
Let us repeat again: the timeout values is microseconds. For example
to set the timeout to 20 secs:
.PP
.Vb 1
\&  $s\->timeout(20_000_000);
.Ve
.SH "Notes"
.IX Header "Notes"
.SS "Limited Functionality under Threaded MPMs"
.IX Subsection "Limited Functionality under Threaded MPMs"
Note that under threaded MPMs, some of the read/write accessors, will
be able to set values only before threads are spawned (i.e. before the
\&\f(CW\*(C`ChildInit
phase\*(C'\fR).
Therefore if you are developing your application on the non-threaded
\&\s-1MPM,\s0 but planning to have it run under threaded mpm, you should not
use those methods to set values after the ChildInit phase.
.PP
The affected accessor methods are marked as such in their respective
documentation entries.
.SH "Unsupported API"
.IX Header "Unsupported API"
\&\f(CW\*(C`Apache2::ServerRec\*(C'\fR also provides auto-generated Perl interface for a
few other methods which aren't tested at the moment and therefore
their \s-1API\s0 is a subject to change. These methods will be finalized
later as a need arises. If you want to rely on any of the following
methods please contact the the mod_perl development mailing
list so we can help each other take the steps necessary
to shift the method to an officially supported \s-1API.\s0
.ie n .SS """addrs"""
.el .SS "\f(CWaddrs\fP"
.IX Subsection "addrs"
Get the addrs value
.PP
.Vb 1
\&  $addrs = $s\->addrs();
.Ve
.ie n .IP "obj: $s ( ""Apache2::ServerRec object"" )" 4
.el .IP "obj: \f(CW$s\fR ( \f(CWApache2::ServerRec object\fR )" 4
.IX Item "obj: $s ( Apache2::ServerRec object )"
.PD 0
.ie n .IP "ret: $addrs ( ""Apache2::ServerAddr"" )" 4
.el .IP "ret: \f(CW$addrs\fR ( \f(CWApache2::ServerAddr\fR )" 4
.IX Item "ret: $addrs ( Apache2::ServerAddr )"
.PD
Returns the addrs setting.
.IP "since: subject to change" 4
.IX Item "since: subject to change"
.PP
\&\s-1META:\s0 this methods returns a vhost-specific Apache2::ServerAddr object,
which is not implemented at the moment. See the struct server_addr_rec
entry in httpd\-2.0/include/httpd.h for more information. It seems that
most (all?) of the information in that record is available through
other APIs.
.ie n .SS """lookup_defaults"""
.el .SS "\f(CWlookup_defaults\fP"
.IX Subsection "lookup_defaults"
Get the lookup_defaults value.  \s-1MIME\s0 type info, etc., before we start
checking per-directory info.
.PP
.Vb 1
\&  $lookup_defaults = $s\->lookup_defaults();
.Ve
.ie n .IP "obj: $s ( ""Apache2::ServerRec object"" )" 4
.el .IP "obj: \f(CW$s\fR ( \f(CWApache2::ServerRec object\fR )" 4
.IX Item "obj: $s ( Apache2::ServerRec object )"
.PD 0
.ie n .IP "ret: $lookup_defaults ( ""Apache2::ConfVector"" )" 4
.el .IP "ret: \f(CW$lookup_defaults\fR ( \f(CWApache2::ConfVector\fR )" 4
.IX Item "ret: $lookup_defaults ( Apache2::ConfVector )"
.PD
Returns the lookup_defaults setting.
.IP "since: subject to change" 4
.IX Item "since: subject to change"
.ie n .SS """module_config"""
.el .SS "\f(CWmodule_config\fP"
.IX Subsection "module_config"
Get config vector containing pointers to modules' per-server config
structures.
.PP
.Vb 1
\&  $module_config = $s\->module_config();
.Ve
.ie n .IP "obj: $s ( ""Apache2::ServerRec object"" )" 4
.el .IP "obj: \f(CW$s\fR ( \f(CWApache2::ServerRec object\fR )" 4
.IX Item "obj: $s ( Apache2::ServerRec object )"
.PD 0
.ie n .IP "ret: $module_config ( ""Apache2::ConfVector"" )" 4
.el .IP "ret: \f(CW$module_config\fR ( \f(CWApache2::ConfVector\fR )" 4
.IX Item "ret: $module_config ( Apache2::ConfVector )"
.PD
Returns the module_config setting.
.IP "since: subject to change" 4
.IX Item "since: subject to change"
.ie n .SS """names"""
.el .SS "\f(CWnames\fP"
.IX Subsection "names"
Get/set the value(s) for the \f(CW\*(C`ServerAlias\*(C'\fR setting
.PP
.Vb 2
\&  $names      = $s\->names();
\&  $prev_names = $s\->names($new_names);
.Ve
.ie n .IP "obj: $s ( ""Apache2::ServerRec object"" )" 4
.el .IP "obj: \f(CW$s\fR ( \f(CWApache2::ServerRec object\fR )" 4
.IX Item "obj: $s ( Apache2::ServerRec object )"
.PD 0
.ie n .IP "opt arg1: $new_names ( ""APR::ArrayHeader"" )" 4
.el .IP "opt arg1: \f(CW$new_names\fR ( \f(CWAPR::ArrayHeader\fR )" 4
.IX Item "opt arg1: $new_names ( APR::ArrayHeader )"
.PD
If passed, sets the new names.
.Sp
Note the limited functionality under threaded
MPMs.
.ie n .IP "ret: $names ( ""APR::ArrayHeader"" )" 4
.el .IP "ret: \f(CW$names\fR ( \f(CWAPR::ArrayHeader\fR )" 4
.IX Item "ret: $names ( APR::ArrayHeader )"
Returns the names setting.
.Sp
If \f(CW$new_names\fR is passed, returns the setting before the change.
.IP "since: 2.0.00" 4
.IX Item "since: 2.0.00"
.PP
\&\s-1META:\s0 we don't have \f(CW\*(C`APR::ArrayHeader\*(C'\fR yet
.ie n .SS """wild_names"""
.el .SS "\f(CWwild_names\fP"
.IX Subsection "wild_names"
Wildcarded names for ServerAlias servers
.PP
.Vb 2
\&  $wild_names      = $s\->wild_names();
\&  $prev_wild_names = $s\->wild_names($new_wild_names);
.Ve
.ie n .IP "obj: $s ( ""Apache2::ServerRec object"" )" 4
.el .IP "obj: \f(CW$s\fR ( \f(CWApache2::ServerRec object\fR )" 4
.IX Item "obj: $s ( Apache2::ServerRec object )"
.PD 0
.ie n .IP "opt arg1: $new_wild_names ( ""APR::ArrayHeader"" )" 4
.el .IP "opt arg1: \f(CW$new_wild_names\fR ( \f(CWAPR::ArrayHeader\fR )" 4
.IX Item "opt arg1: $new_wild_names ( APR::ArrayHeader )"
.PD
If passed, sets the new wild_names.
.Sp
Note the limited functionality under threaded
MPMs.
.ie n .IP "ret: $wild_names ( ""APR::ArrayHeader"" )" 4
.el .IP "ret: \f(CW$wild_names\fR ( \f(CWAPR::ArrayHeader\fR )" 4
.IX Item "ret: $wild_names ( APR::ArrayHeader )"
Returns the wild_names setting.
.Sp
If \f(CW$new_wild_names\fR is passed, returns the setting before the
change.
.IP "since: 2.0.00" 4
.IX Item "since: 2.0.00"
.PP
\&\s-1META:\s0 we don't have \f(CW\*(C`APR::ArrayHeader\*(C'\fR yet
.SH "See Also"
.IX Header "See Also"
mod_perl 2.0 documentation.
.SH "Copyright"
.IX Header "Copyright"
mod_perl 2.0 and its core modules are copyrighted under
The Apache Software License, Version 2.0.
.SH "Authors"
.IX Header "Authors"
The mod_perl development team and numerous
contributors.
