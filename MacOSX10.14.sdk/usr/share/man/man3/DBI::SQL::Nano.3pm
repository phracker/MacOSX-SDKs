.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "DBI::SQL::Nano 3"
.TH DBI::SQL::Nano 3 "2013-06-24" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
DBI::SQL::Nano \- a very tiny SQL engine
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 7
\& BEGIN { $ENV{DBI_SQL_NANO}=1 } # forces use of Nano rather than SQL::Statement
\& use DBI::SQL::Nano;
\& use Data::Dumper;
\& my $stmt = DBI::SQL::Nano::Statement\->new(
\&     "SELECT bar,baz FROM foo WHERE qux = 1"
\& ) or die "Couldn\*(Aqt parse";
\& print Dumper $stmt;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\f(CW\*(C`DBI::SQL::Nano\*(C'\fR is meant as a \fIvery\fR minimal \s-1SQL\s0 engine for use in
situations where SQL::Statement is not available. In most situations you are
better off installing SQL::Statement although DBI::SQL::Nano may be faster
for some \fBvery\fR simple tasks.
.PP
DBI::SQL::Nano, like SQL::Statement is primarily intended to provide a \s-1SQL\s0
engine for use with some pure perl DBDs including \s-1DBD::DBM\s0, \s-1DBD::CSV\s0,
DBD::AnyData, and DBD::Excel. It is not of much use in and of itself.
You can dump out the structure of a parsed \s-1SQL\s0 statement, but that is about
it.
.SH "USAGE"
.IX Header "USAGE"
.SS "Setting the \s-1DBI_SQL_NANO\s0 flag"
.IX Subsection "Setting the DBI_SQL_NANO flag"
By default, when a \f(CW\*(C`DBD\*(C'\fR uses \f(CW\*(C`DBI::SQL::Nano\*(C'\fR, the module will
look to see if \f(CW\*(C`SQL::Statement\*(C'\fR is installed. If it is, SQL::Statement
objects are used.  If SQL::Statement is not available, DBI::SQL::Nano
objects are used.
.PP
In some cases, you may wish to use DBI::SQL::Nano objects even if
SQL::Statement is available.  To force usage of DBI::SQL::Nano objects
regardless of the availability of SQL::Statement, set the environment
variable \s-1DBI_SQL_NANO\s0 to 1.
.PP
You can set the environment variable in your shell prior to running your
script (with \s-1SET\s0 or \s-1EXPORT\s0 or whatever), or else you can set it in your
script by putting this at the top of the script:
.PP
.Vb 1
\& BEGIN { $ENV{DBI_SQL_NANO} = 1 }
.Ve
.SS "Supported \s-1SQL\s0 syntax"
.IX Subsection "Supported SQL syntax"
.Vb 2
\& Here\*(Aqs a pseudo\-BNF.  Square brackets [] indicate optional items;
\& Angle brackets <> indicate items defined elsewhere in the BNF.
\&
\&  statement ::=
\&      DROP TABLE [IF EXISTS] <table_name>
\&    | CREATE TABLE <table_name> <col_def_list>
\&    | INSERT INTO <table_name> [<insert_col_list>] VALUES <val_list>
\&    | DELETE FROM <table_name> [<where_clause>]
\&    | UPDATE <table_name> SET <set_clause> <where_clause>
\&    | SELECT <select_col_list> FROM <table_name> [<where_clause>]
\&                                                 [<order_clause>]
\&
\&  the optional IF EXISTS clause ::=
\&    * similar to MySQL \- prevents errors when trying to drop
\&      a table that doesn\*(Aqt exist
\&
\&  identifiers ::=
\&    * table and column names should be valid SQL identifiers
\&    * especially avoid using spaces and commas in identifiers
\&    * note: there is no error checking for invalid names, some
\&      will be accepted, others will cause parse failures
\&
\&  table_name ::=
\&    * only one table (no multiple table operations)
\&    * see identifier for valid table names
\&
\&  col_def_list ::=
\&    * a parens delimited, comma\-separated list of column names
\&    * see identifier for valid column names
\&    * column types and column constraints may be included but are ignored
\&      e.g. these are all the same:
\&        (id,phrase)
\&        (id INT, phrase VARCHAR(40))
\&        (id INT PRIMARY KEY, phrase VARCHAR(40) NOT NULL)
\&    * you are *strongly* advised to put in column types even though
\&      they are ignored ... it increases portability
\&
\&  insert_col_list ::=
\&    * a parens delimited, comma\-separated list of column names
\&    * as in standard SQL, this is optional
\&
\&  select_col_list ::=
\&    * a comma\-separated list of column names
\&    * or an asterisk denoting all columns
\&
\&  val_list ::=
\&    * a parens delimited, comma\-separated list of values which can be:
\&       * placeholders (an unquoted question mark)
\&       * numbers (unquoted numbers)
\&       * column names (unquoted strings)
\&       * nulls (unquoted word NULL)
\&       * strings (delimited with single quote marks);
\&       * note: leading and trailing percent mark (%) and underscore (_)
\&         can be used as wildcards in quoted strings for use with
\&         the LIKE and CLIKE operators
\&       * note: escaped single quotation marks within strings are not
\&         supported, neither are embedded commas, use placeholders instead
\&
\&  set_clause ::=
\&    * a comma\-separated list of column = value pairs
\&    * see val_list for acceptable value formats
\&
\&  where_clause ::=
\&    * a single "column/value <op> column/value" predicate, optionally
\&      preceded by "NOT"
\&    * note: multiple predicates combined with ORs or ANDs are not supported
\&    * see val_list for acceptable value formats
\&    * op may be one of:
\&         < > >= <= = <> LIKE CLIKE IS
\&    * CLIKE is a case insensitive LIKE
\&
\&  order_clause ::= column_name [ASC|DESC]
\&    * a single column optional ORDER BY clause is supported
\&    * as in standard SQL, if neither ASC (ascending) nor
\&      DESC (descending) is specified, ASC becomes the default
.Ve
.SH "TABLES"
.IX Header "TABLES"
DBI::SQL::Nano::Statement operates on exactly one table. This table will be
opened by inherit from DBI::SQL::Nano::Statement and implements the
\&\f(CW\*(C`open_table\*(C'\fR method.
.PP
.Vb 5
\&  sub open_table ($$$$$)
\&  {
\&      ...
\&      return Your::Table\->new( \e%attributes );
\&  }
.Ve
.PP
DBI::SQL::Nano::Statement_ expects a rudimentary interface is implemented by
the table object, as well as SQL::Statement expects.
.PP
.Vb 1
\&  package Your::Table;
\&
\&  use vars qw(@ISA);
\&  @ISA = qw(DBI::SQL::Nano::Table);
\&
\&  sub drop ($$)        { ... }
\&  sub fetch_row ($$$)  { ... }
\&  sub push_row ($$$)   { ... }
\&  sub push_names ($$$) { ... }
\&  sub truncate ($$)    { ... }
\&  sub seek ($$$$)      { ... }
.Ve
.PP
The base class interfaces are provided by DBI::SQL::Nano::Table_ in case of
relying on DBI::SQL::Nano or SQL::Eval::Table (see SQL::Eval for details)
otherwise.
.SH "BUGS AND LIMITATIONS"
.IX Header "BUGS AND LIMITATIONS"
There are no known bugs in DBI::SQL::Nano::Statement. If you find a one
and want to report, please see \s-1DBI\s0 for how to report bugs.
.PP
DBI::SQL::Nano::Statement is designed to provide a minimal subset for
executing \s-1SQL\s0 statements.
.PP
The most important limitation might be the restriction on one table per
statement. This implies, that no JOINs are supported and there cannot be
any foreign key relation between tables.
.PP
The where clause evaluation of DBI::SQL::Nano::Statement is very slow
(SQL::Statement uses a precompiled evaluation).
.PP
\&\s-1INSERT\s0 can handle only one row per statement. To insert multiple rows,
use placeholders as explained in \s-1DBI.\s0
.PP
The DBI::SQL::Nano parser is very limited and does not support any
additional syntax such as brackets, comments, functions, aggregations
etc.
.PP
In contrast to SQL::Statement, temporary tables are not supported.
.SH "ACKNOWLEDGEMENTS"
.IX Header "ACKNOWLEDGEMENTS"
Tim Bunce provided the original idea for this module, helped me out of the
tangled trap of namespaces, and provided help and advice all along the way.
Although I wrote it from the ground up, it is based on Jochen Wiedmann's
original design of SQL::Statement, so much of the credit for the \s-1API\s0 goes
to him.
.SH "AUTHOR AND COPYRIGHT"
.IX Header "AUTHOR AND COPYRIGHT"
This module is originally written by Jeff Zucker < jzucker \s-1AT\s0 cpan.org >
.PP
This module is currently maintained by Jens Rehsack < jrehsack \s-1AT\s0 cpan.org >
.PP
Copyright (C) 2010 by Jens Rehsack, all rights reserved.
Copyright (C) 2004 by Jeff Zucker, all rights reserved.
.PP
You may freely distribute and/or modify this module under the terms of
either the \s-1GNU\s0 General Public License (\s-1GPL\s0) or the Artistic License,
as specified in the Perl \s-1README\s0 file.
