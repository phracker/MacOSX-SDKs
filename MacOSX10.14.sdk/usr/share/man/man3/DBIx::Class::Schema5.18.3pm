.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "DBIx::Class::Schema 3"
.TH DBIx::Class::Schema 3 "2014-01-22" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
DBIx::Class::Schema \- composable schemas
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&  package Library::Schema;
\&  use base qw/DBIx::Class::Schema/;
\&
\&  # load all Result classes in Library/Schema/Result/
\&  _\|_PACKAGE_\|_\->load_namespaces();
\&
\&  package Library::Schema::Result::CD;
\&  use base qw/DBIx::Class::Core/;
\&
\&  _\|_PACKAGE_\|_\->load_components(qw/InflateColumn::DateTime/); # for example
\&  _\|_PACKAGE_\|_\->table(\*(Aqcd\*(Aq);
\&
\&  # Elsewhere in your code:
\&  my $schema1 = Library::Schema\->connect(
\&    $dsn,
\&    $user,
\&    $password,
\&    { AutoCommit => 1 },
\&  );
\&
\&  my $schema2 = Library::Schema\->connect($coderef_returning_dbh);
\&
\&  # fetch objects using Library::Schema::Result::DVD
\&  my $resultset = $schema1\->resultset(\*(AqDVD\*(Aq)\->search( ... );
\&  my @dvd_objects = $schema2\->resultset(\*(AqDVD\*(Aq)\->search( ... );
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Creates database classes based on a schema. This is the recommended way to
use DBIx::Class and allows you to use more than one concurrent connection
with your classes.
.PP
\&\s-1NB:\s0 If you're used to Class::DBI it's worth reading the \*(L"\s-1SYNOPSIS\*(R"\s0
carefully, as DBIx::Class does things a little differently. Note in
particular which module inherits off which.
.SH "SETUP METHODS"
.IX Header "SETUP METHODS"
.SS "load_namespaces"
.IX Subsection "load_namespaces"
.ie n .IP "Arguments: %options?" 4
.el .IP "Arguments: \f(CW%options\fR?" 4
.IX Item "Arguments: %options?"
.PP
.Vb 2
\&  package MyApp::Schema;
\&  _\|_PACKAGE_\|_\->load_namespaces();
\&
\&  _\|_PACKAGE_\|_\->load_namespaces(
\&     result_namespace => \*(AqRes\*(Aq,
\&     resultset_namespace => \*(AqRSet\*(Aq,
\&     default_resultset_class => \*(Aq+MyApp::Othernamespace::RSet\*(Aq,
\&  );
.Ve
.PP
With no arguments, this method uses Module::Find to load all of the
Result and ResultSet classes under the namespace of the schema from
which it is called.  For example, \f(CW\*(C`My::Schema\*(C'\fR will by default find
and load Result classes named \f(CW\*(C`My::Schema::Result::*\*(C'\fR and ResultSet
classes named \f(CW\*(C`My::Schema::ResultSet::*\*(C'\fR.
.PP
ResultSet classes are associated with Result class of the same name.
For example, \f(CW\*(C`My::Schema::Result::CD\*(C'\fR will get the ResultSet class
\&\f(CW\*(C`My::Schema::ResultSet::CD\*(C'\fR if it is present.
.PP
Both Result and ResultSet namespaces are configurable via the
\&\f(CW\*(C`result_namespace\*(C'\fR and \f(CW\*(C`resultset_namespace\*(C'\fR options.
.PP
Another option, \f(CW\*(C`default_resultset_class\*(C'\fR specifies a custom default
ResultSet class for Result classes with no corresponding ResultSet.
.PP
All of the namespace and classname options are by default relative to
the schema classname.  To specify a fully-qualified name, prefix it
with a literal \f(CW\*(C`+\*(C'\fR.  For example, \f(CW\*(C`+Other::NameSpace::Result\*(C'\fR.
.PP
\fIWarnings\fR
.IX Subsection "Warnings"
.PP
You will be warned if ResultSet classes are discovered for which there
are no matching Result classes like this:
.PP
.Vb 1
\&  load_namespaces found ResultSet class $classname with no corresponding Result class
.Ve
.PP
If a Result class is found to already have a ResultSet class set using
\&\*(L"resultset_class\*(R" to some other class, you will be warned like this:
.PP
.Vb 2
\&  We found ResultSet class \*(Aq$rs_class\*(Aq for \*(Aq$result\*(Aq, but it seems
\&  that you had already set \*(Aq$result\*(Aq to use \*(Aq$rs_set\*(Aq instead
.Ve
.PP
\fIExamples\fR
.IX Subsection "Examples"
.PP
.Vb 3
\&  # load My::Schema::Result::CD, My::Schema::Result::Artist,
\&  #    My::Schema::ResultSet::CD, etc...
\&  My::Schema\->load_namespaces;
\&
\&  # Override everything to use ugly names.
\&  # In this example, if there is a My::Schema::Res::Foo, but no matching
\&  #   My::Schema::RSets::Foo, then Foo will have its
\&  #   resultset_class set to My::Schema::RSetBase
\&  My::Schema\->load_namespaces(
\&    result_namespace => \*(AqRes\*(Aq,
\&    resultset_namespace => \*(AqRSets\*(Aq,
\&    default_resultset_class => \*(AqRSetBase\*(Aq,
\&  );
\&
\&  # Put things in other namespaces
\&  My::Schema\->load_namespaces(
\&    result_namespace => \*(Aq+Some::Place::Results\*(Aq,
\&    resultset_namespace => \*(Aq+Another::Place::RSets\*(Aq,
\&  );
.Ve
.PP
To search multiple namespaces for either Result or ResultSet classes,
use an arrayref of namespaces for that option.  In the case that the
same result (or resultset) class exists in multiple namespaces, later
entries in the list of namespaces will override earlier ones.
.PP
.Vb 5
\&  My::Schema\->load_namespaces(
\&    # My::Schema::Results_C::Foo takes precedence over My::Schema::Results_B::Foo :
\&    result_namespace => [ \*(AqResults_A\*(Aq, \*(AqResults_B\*(Aq, \*(AqResults_C\*(Aq ],
\&    resultset_namespace => [ \*(Aq+Some::Place::RSets\*(Aq, \*(AqRSets\*(Aq ],
\&  );
.Ve
.SS "load_classes"
.IX Subsection "load_classes"
.ie n .IP "Arguments: @classes?, { $namespace => [ @classes ] }+" 4
.el .IP "Arguments: \f(CW@classes\fR?, { \f(CW$namespace\fR => [ \f(CW@classes\fR ] }+" 4
.IX Item "Arguments: @classes?, { $namespace => [ @classes ] }+"
.PP
\&\*(L"load_classes\*(R" is an alternative method to \*(L"load_namespaces\*(R", both of
which serve similar purposes, each with different advantages and disadvantages.
In the general case you should use \*(L"load_namespaces\*(R", unless you need to
be able to specify that only specific classes are loaded at runtime.
.PP
With no arguments, this method uses Module::Find to find all classes under
the schema's namespace. Otherwise, this method loads the classes you specify
(using use), and registers them (using \*(L"register_class\*(R").
.PP
It is possible to comment out classes with a leading \f(CW\*(C`#\*(C'\fR, but note that perl
will think it's a mistake (trying to use a comment in a qw list), so you'll
need to add \f(CW\*(C`no warnings \*(Aqqw\*(Aq;\*(C'\fR before your load_classes call.
.PP
If any classes found do not appear to be Result class files, you will
get the following warning:
.PP
.Vb 3
\&   Failed to load $comp_class. Can\*(Aqt find source_name method. Is
\&   $comp_class really a full DBIC result class? Fix it, move it elsewhere,
\&   or make your load_classes call more specific.
.Ve
.PP
Example:
.PP
.Vb 2
\&  My::Schema\->load_classes(); # loads My::Schema::CD, My::Schema::Artist,
\&                              # etc. (anything under the My::Schema namespace)
\&
\&  # loads My::Schema::CD, My::Schema::Artist, Other::Namespace::Producer but
\&  # not Other::Namespace::LinerNotes nor My::Schema::Track
\&  My::Schema\->load_classes(qw/ CD Artist #Track /, {
\&    Other::Namespace => [qw/ Producer #LinerNotes /],
\&  });
.Ve
.SS "storage_type"
.IX Subsection "storage_type"
.ie n .IP "Arguments: $storage_type|{$storage_type, \e%args}" 4
.el .IP "Arguments: \f(CW$storage_type\fR|{$storage_type, \e%args}" 4
.IX Item "Arguments: $storage_type|{$storage_type, %args}"
.PD 0
.ie n .IP "Return Value: $storage_type|{$storage_type, \e%args}" 4
.el .IP "Return Value: \f(CW$storage_type\fR|{$storage_type, \e%args}" 4
.IX Item "Return Value: $storage_type|{$storage_type, %args}"
.IP "Default value: DBIx::Class::Storage::DBI" 4
.IX Item "Default value: DBIx::Class::Storage::DBI"
.PD
.PP
Set the storage class that will be instantiated when \*(L"connect\*(R" is called.
If the classname starts with \f(CW\*(C`::\*(C'\fR, the prefix \f(CW\*(C`DBIx::Class::Storage\*(C'\fR is
assumed by \*(L"connect\*(R".
.PP
You want to use this to set subclasses of DBIx::Class::Storage::DBI
in cases where the appropriate subclass is not autodetected.
.PP
If your storage type requires instantiation arguments, those are
defined as a second argument in the form of a hashref and the entire
value needs to be wrapped into an arrayref or a hashref.  We support
both types of refs here in order to play nice with your
Config::[class] or your choice. See
DBIx::Class::Storage::DBI::Replicated for an example of this.
.SS "exception_action"
.IX Subsection "exception_action"
.ie n .IP "Arguments: $code_reference" 4
.el .IP "Arguments: \f(CW$code_reference\fR" 4
.IX Item "Arguments: $code_reference"
.PD 0
.ie n .IP "Return Value: $code_reference" 4
.el .IP "Return Value: \f(CW$code_reference\fR" 4
.IX Item "Return Value: $code_reference"
.IP "Default value: None" 4
.IX Item "Default value: None"
.PD
.PP
When \*(L"throw_exception\*(R" is invoked and \*(L"exception_action\*(R" is set to a code
reference, this reference will be called instead of
\&\*(L"throw\*(R" in DBIx::Class::Exception, with the exception message passed as the only
argument.
.PP
Your custom throw code \fBmust\fR rethrow the exception, as \*(L"throw_exception\*(R" is
an integral part of \s-1DBIC\s0's internal execution control flow.
.PP
Example:
.PP
.Vb 5
\&   package My::Schema;
\&   use base qw/DBIx::Class::Schema/;
\&   use My::ExceptionClass;
\&   _\|_PACKAGE_\|_\->exception_action(sub { My::ExceptionClass\->throw(@_) });
\&   _\|_PACKAGE_\|_\->load_classes;
\&
\&   # or:
\&   my $schema_obj = My::Schema\->connect( .... );
\&   $schema_obj\->exception_action(sub { My::ExceptionClass\->throw(@_) });
.Ve
.SS "stacktrace"
.IX Subsection "stacktrace"
.IP "Arguments: boolean" 4
.IX Item "Arguments: boolean"
.PP
Whether \*(L"throw_exception\*(R" should include stack trace information.
Defaults to false normally, but defaults to true if \f(CW$ENV{DBIC_TRACE}\fR
is true.
.SS "sqlt_deploy_hook"
.IX Subsection "sqlt_deploy_hook"
.ie n .IP "Arguments: $sqlt_schema" 4
.el .IP "Arguments: \f(CW$sqlt_schema\fR" 4
.IX Item "Arguments: $sqlt_schema"
.PP
An optional sub which you can declare in your own Schema class that will get
passed the SQL::Translator::Schema object when you deploy the schema via
\&\*(L"create_ddl_dir\*(R" or \*(L"deploy\*(R".
.PP
For an example of what you can do with this, see
\&\*(L"Adding Indexes And Functions To Your \s-1SQL\*(R"\s0 in DBIx::Class::Manual::Cookbook.
.PP
Note that sqlt_deploy_hook is called by \*(L"deployment_statements\*(R", which in turn
is called before \*(L"deploy\*(R". Therefore the hook can be used only to manipulate
the SQL::Translator::Schema object before it is turned into \s-1SQL\s0 fed to the
database. If you want to execute post-deploy statements which can not be generated
by SQL::Translator, the currently suggested method is to overload \*(L"deploy\*(R"
and use dbh_do.
.SH "METHODS"
.IX Header "METHODS"
.SS "connect"
.IX Subsection "connect"
.ie n .IP "Arguments: @connectinfo" 4
.el .IP "Arguments: \f(CW@connectinfo\fR" 4
.IX Item "Arguments: @connectinfo"
.PD 0
.ie n .IP "Return Value: $new_schema" 4
.el .IP "Return Value: \f(CW$new_schema\fR" 4
.IX Item "Return Value: $new_schema"
.PD
.PP
Creates and returns a new Schema object. The connection info set on it
is used to create a new instance of the storage backend and set it on
the Schema object.
.PP
See \*(L"connect_info\*(R" in DBIx::Class::Storage::DBI for DBI-specific
syntax on the \f(CW@connectinfo\fR argument, or DBIx::Class::Storage in
general.
.PP
Note that \f(CW\*(C`connect_info\*(C'\fR expects an arrayref of arguments, but
\&\f(CW\*(C`connect\*(C'\fR does not. \f(CW\*(C`connect\*(C'\fR wraps its arguments in an arrayref
before passing them to \f(CW\*(C`connect_info\*(C'\fR.
.PP
\fIOverloading\fR
.IX Subsection "Overloading"
.PP
\&\f(CW\*(C`connect\*(C'\fR is a convenience method. It is equivalent to calling
\&\f(CW$schema\fR\->clone\->connection(@connectinfo). To write your own overloaded
version, overload \*(L"connection\*(R" instead.
.SS "resultset"
.IX Subsection "resultset"
.ie n .IP "Arguments: $source_name" 4
.el .IP "Arguments: \f(CW$source_name\fR" 4
.IX Item "Arguments: $source_name"
.PD 0
.ie n .IP "Return Value: $resultset" 4
.el .IP "Return Value: \f(CW$resultset\fR" 4
.IX Item "Return Value: $resultset"
.PD
.PP
.Vb 1
\&  my $rs = $schema\->resultset(\*(AqDVD\*(Aq);
.Ve
.PP
Returns the DBIx::Class::ResultSet object for the registered source
name.
.SS "sources"
.IX Subsection "sources"
.ie n .IP "Return Value: @source_names" 4
.el .IP "Return Value: \f(CW@source_names\fR" 4
.IX Item "Return Value: @source_names"
.PP
.Vb 1
\&  my @source_names = $schema\->sources;
.Ve
.PP
Lists names of all the sources registered on this Schema object.
.SS "source"
.IX Subsection "source"
.ie n .IP "Arguments: $source_name" 4
.el .IP "Arguments: \f(CW$source_name\fR" 4
.IX Item "Arguments: $source_name"
.PD 0
.ie n .IP "Return Value: $result_source" 4
.el .IP "Return Value: \f(CW$result_source\fR" 4
.IX Item "Return Value: $result_source"
.PD
.PP
.Vb 1
\&  my $source = $schema\->source(\*(AqBook\*(Aq);
.Ve
.PP
Returns the DBIx::Class::ResultSource object for the registered
source name.
.SS "class"
.IX Subsection "class"
.ie n .IP "Arguments: $source_name" 4
.el .IP "Arguments: \f(CW$source_name\fR" 4
.IX Item "Arguments: $source_name"
.PD 0
.ie n .IP "Return Value: $classname" 4
.el .IP "Return Value: \f(CW$classname\fR" 4
.IX Item "Return Value: $classname"
.PD
.PP
.Vb 1
\&  my $class = $schema\->class(\*(AqCD\*(Aq);
.Ve
.PP
Retrieves the Result class name for the given source name.
.SS "txn_do"
.IX Subsection "txn_do"
.ie n .IP "Arguments: $coderef, @coderef_args?" 4
.el .IP "Arguments: \f(CW$coderef\fR, \f(CW@coderef_args\fR?" 4
.IX Item "Arguments: $coderef, @coderef_args?"
.PD 0
.ie n .IP "Return Value: The return value of $coderef" 4
.el .IP "Return Value: The return value of \f(CW$coderef\fR" 4
.IX Item "Return Value: The return value of $coderef"
.PD
.PP
Executes \f(CW$coderef\fR with (optional) arguments \f(CW@coderef_args\fR atomically,
returning its result (if any). Equivalent to calling \f(CW$schema\fR\->storage\->txn_do.
See \*(L"txn_do\*(R" in DBIx::Class::Storage for more information.
.PP
This interface is preferred over using the individual methods \*(L"txn_begin\*(R",
\&\*(L"txn_commit\*(R", and \*(L"txn_rollback\*(R" below.
.PP
\&\s-1WARNING:\s0 If you are connected with \f(CW\*(C`AutoCommit => 0\*(C'\fR the transaction is
considered nested, and you will still need to call \*(L"txn_commit\*(R" to write your
changes when appropriate. You will also want to connect with \f(CW\*(C`auto_savepoint =>
1\*(C'\fR to get partial rollback to work, if the storage driver for your database
supports it.
.PP
Connecting with \f(CW\*(C`AutoCommit => 1\*(C'\fR is recommended.
.SS "txn_scope_guard"
.IX Subsection "txn_scope_guard"
Runs \f(CW\*(C`txn_scope_guard\*(C'\fR on the schema's storage. See
\&\*(L"txn_scope_guard\*(R" in DBIx::Class::Storage.
.SS "txn_begin"
.IX Subsection "txn_begin"
Begins a transaction (does nothing if AutoCommit is off). Equivalent to
calling \f(CW$schema\fR\->storage\->txn_begin. See
\&\*(L"txn_begin\*(R" in DBIx::Class::Storage for more information.
.SS "txn_commit"
.IX Subsection "txn_commit"
Commits the current transaction. Equivalent to calling
\&\f(CW$schema\fR\->storage\->txn_commit. See \*(L"txn_commit\*(R" in DBIx::Class::Storage
for more information.
.SS "txn_rollback"
.IX Subsection "txn_rollback"
Rolls back the current transaction. Equivalent to calling
\&\f(CW$schema\fR\->storage\->txn_rollback. See
\&\*(L"txn_rollback\*(R" in DBIx::Class::Storage for more information.
.SS "storage"
.IX Subsection "storage"
.Vb 1
\&  my $storage = $schema\->storage;
.Ve
.PP
Returns the DBIx::Class::Storage object for this Schema. Grab this
if you want to turn on \s-1SQL\s0 statement debugging at runtime, or set the
quote character. For the default storage, the documentation can be
found in DBIx::Class::Storage::DBI.
.SS "populate"
.IX Subsection "populate"
.ie n .IP "Arguments: $source_name, [ \e@column_list, \e@row_values+ ] | [ \e%col_data+ ]" 4
.el .IP "Arguments: \f(CW$source_name\fR, [ \e@column_list, \e@row_values+ ] | [ \e%col_data+ ]" 4
.IX Item "Arguments: $source_name, [ @column_list, @row_values+ ] | [ %col_data+ ]"
.PD 0
.ie n .IP "Return Value: \e@result_objects (scalar context) | @result_objects (list context)" 4
.el .IP "Return Value: \e@result_objects (scalar context) | \f(CW@result_objects\fR (list context)" 4
.IX Item "Return Value: @result_objects (scalar context) | @result_objects (list context)"
.PD
.PP
A convenience shortcut to \*(L"populate\*(R" in DBIx::Class::ResultSet. Equivalent to:
.PP
.Vb 1
\& $schema\->resultset($source_name)\->populate([...]);
.Ve
.IP "\s-1NOTE\s0" 4
.IX Item "NOTE"
The context of this method call has an important effect on what is
submitted to storage. In void context data is fed directly to fastpath
insertion routines provided by the underlying storage (most often
\&\*(L"execute_for_fetch\*(R" in \s-1DBI\s0), bypassing the new and
insert calls on the
Result class, including any
augmentation of these methods provided by components. For example if you
are using something like DBIx::Class::UUIDColumns to create primary
keys for you, you will find that your PKs are empty.  In this case you
will have to explicitly force scalar or list context in order to create
those values.
.SS "connection"
.IX Subsection "connection"
.ie n .IP "Arguments: @args" 4
.el .IP "Arguments: \f(CW@args\fR" 4
.IX Item "Arguments: @args"
.PD 0
.ie n .IP "Return Value: $new_schema" 4
.el .IP "Return Value: \f(CW$new_schema\fR" 4
.IX Item "Return Value: $new_schema"
.PD
.PP
Similar to \*(L"connect\*(R" except sets the storage object and connection
data in-place on the Schema class. You should probably be calling
\&\*(L"connect\*(R" to get a proper Schema object instead.
.PP
\fIOverloading\fR
.IX Subsection "Overloading"
.PP
Overload \f(CW\*(C`connection\*(C'\fR to change the behaviour of \f(CW\*(C`connect\*(C'\fR.
.SS "compose_namespace"
.IX Subsection "compose_namespace"
.ie n .IP "Arguments: $target_namespace, $additional_base_class?" 4
.el .IP "Arguments: \f(CW$target_namespace\fR, \f(CW$additional_base_class\fR?" 4
.IX Item "Arguments: $target_namespace, $additional_base_class?"
.PD 0
.ie n .IP "Return Value: $new_schema" 4
.el .IP "Return Value: \f(CW$new_schema\fR" 4
.IX Item "Return Value: $new_schema"
.PD
.PP
For each DBIx::Class::ResultSource in the schema, this method creates a
class in the target namespace (e.g. \f(CW$target_namespace::CD\fR,
\&\f(CW$target_namespace::Artist\fR) that inherits from the corresponding classes
attached to the current schema.
.PP
It also attaches a corresponding DBIx::Class::ResultSource object to the
new \f(CW$schema\fR object. If \f(CW$additional_base_class\fR is given, the new composed
classes will inherit from first the corresponding class from the current
schema then the base class.
.PP
For example, for a schema with My::Schema::CD and My::Schema::Artist classes,
.PP
.Vb 3
\&  $schema\->compose_namespace(\*(AqMy::DB\*(Aq, \*(AqBase::Class\*(Aq);
\&  print join (\*(Aq, \*(Aq, @My::DB::CD::ISA) . "\en";
\&  print join (\*(Aq, \*(Aq, @My::DB::Artist::ISA) ."\en";
.Ve
.PP
will produce the output
.PP
.Vb 2
\&  My::Schema::CD, Base::Class
\&  My::Schema::Artist, Base::Class
.Ve
.SS "svp_begin"
.IX Subsection "svp_begin"
Creates a new savepoint (does nothing outside a transaction).
Equivalent to calling \f(CW$schema\fR\->storage\->svp_begin.  See
\&\*(L"svp_begin\*(R" in DBIx::Class::Storage for more information.
.SS "svp_release"
.IX Subsection "svp_release"
Releases a savepoint (does nothing outside a transaction).
Equivalent to calling \f(CW$schema\fR\->storage\->svp_release.  See
\&\*(L"svp_release\*(R" in DBIx::Class::Storage for more information.
.SS "svp_rollback"
.IX Subsection "svp_rollback"
Rollback to a savepoint (does nothing outside a transaction).
Equivalent to calling \f(CW$schema\fR\->storage\->svp_rollback.  See
\&\*(L"svp_rollback\*(R" in DBIx::Class::Storage for more information.
.SS "clone"
.IX Subsection "clone"
.ie n .IP "Arguments: %attrs?" 4
.el .IP "Arguments: \f(CW%attrs\fR?" 4
.IX Item "Arguments: %attrs?"
.PD 0
.ie n .IP "Return Value: $new_schema" 4
.el .IP "Return Value: \f(CW$new_schema\fR" 4
.IX Item "Return Value: $new_schema"
.PD
.PP
Clones the schema and its associated result_source objects and returns the
copy. The resulting copy will have the same attributes as the source schema,
except for those attributes explicitly overridden by the provided \f(CW%attrs\fR.
.SS "throw_exception"
.IX Subsection "throw_exception"
.ie n .IP "Arguments: $message" 4
.el .IP "Arguments: \f(CW$message\fR" 4
.IX Item "Arguments: $message"
.PP
Throws an exception. Obeys the exemption rules of DBIx::Class::Carp to report
errors from outer-user's perspective. See \*(L"exception_action\*(R" for details on overriding
this method's behavior.  If \*(L"stacktrace\*(R" is turned on, \f(CW\*(C`throw_exception\*(C'\fR's
default behavior will provide a detailed stack trace.
.SS "deploy"
.IX Subsection "deploy"
.ie n .IP "Arguments: \e%sqlt_args, $dir" 4
.el .IP "Arguments: \e%sqlt_args, \f(CW$dir\fR" 4
.IX Item "Arguments: %sqlt_args, $dir"
.PP
Attempts to deploy the schema to the current storage using SQL::Translator.
.PP
See \*(L"\s-1METHODS\*(R"\s0 in SQL::Translator for a list of values for \f(CW\*(C`\e%sqlt_args\*(C'\fR.
The most common value for this would be \f(CW\*(C`{ add_drop_table => 1 }\*(C'\fR
to have the \s-1SQL\s0 produced include a \f(CW\*(C`DROP TABLE\*(C'\fR statement for each table
created. For quoting purposes supply \f(CW\*(C`quote_identifiers\*(C'\fR.
.PP
Additionally, the DBIx::Class parser accepts a \f(CW\*(C`sources\*(C'\fR parameter as a hash
ref or an array ref, containing a list of source to deploy. If present, then
only the sources listed will get deployed. Furthermore, you can use the
\&\f(CW\*(C`add_fk_index\*(C'\fR parser parameter to prevent the parser from creating an index for each
\&\s-1FK.\s0
.SS "deployment_statements"
.IX Subsection "deployment_statements"
.ie n .IP "Arguments: See ""deployment_statements"" in DBIx::Class::Storage::DBI" 4
.el .IP "Arguments: See ``deployment_statements'' in DBIx::Class::Storage::DBI" 4
.IX Item "Arguments: See deployment_statements in DBIx::Class::Storage::DBI"
.PD 0
.ie n .IP "Return Value: $listofstatements" 4
.el .IP "Return Value: \f(CW$listofstatements\fR" 4
.IX Item "Return Value: $listofstatements"
.PD
.PP
A convenient shortcut to
\&\f(CW\*(C`$self\->storage\->deployment_statements($self, @args)\*(C'\fR.
Returns the \s-1SQL\s0 statements used by \*(L"deploy\*(R" and
\&\*(L"deploy\*(R" in DBIx::Class::Schema::Storage.
.SS "create_ddl_dir"
.IX Subsection "create_ddl_dir"
.ie n .IP "Arguments: See ""create_ddl_dir"" in DBIx::Class::Storage::DBI" 4
.el .IP "Arguments: See ``create_ddl_dir'' in DBIx::Class::Storage::DBI" 4
.IX Item "Arguments: See create_ddl_dir in DBIx::Class::Storage::DBI"
.PP
A convenient shortcut to
\&\f(CW\*(C`$self\->storage\->create_ddl_dir($self, @args)\*(C'\fR.
.PP
Creates an \s-1SQL\s0 file based on the Schema, for each of the specified
database types, in the given directory.
.SS "ddl_filename"
.IX Subsection "ddl_filename"
.ie n .IP "Arguments: $database\-type, $version, $directory, $preversion" 4
.el .IP "Arguments: \f(CW$database\fR\-type, \f(CW$version\fR, \f(CW$directory\fR, \f(CW$preversion\fR" 4
.IX Item "Arguments: $database-type, $version, $directory, $preversion"
.PD 0
.ie n .IP "Return Value: $normalised_filename" 4
.el .IP "Return Value: \f(CW$normalised_filename\fR" 4
.IX Item "Return Value: $normalised_filename"
.PD
.PP
.Vb 1
\&  my $filename = $table\->ddl_filename($type, $version, $dir, $preversion)
.Ve
.PP
This method is called by \f(CW\*(C`create_ddl_dir\*(C'\fR to compose a file name out of
the supplied directory, database type and version number. The default file
name format is: \f(CW\*(C`$dir$schema\-$version\-$type.sql\*(C'\fR.
.PP
You may override this method in your schema if you wish to use a different
format.
.PP
.Vb 1
\& WARNING
\&
\& Prior to DBIx::Class version 0.08100 this method had a different signature:
\&
\&    my $filename = $table\->ddl_filename($type, $dir, $version, $preversion)
\&
\& In recent versions variables $dir and $version were reversed in order to
\& bring the signature in line with other Schema/Storage methods. If you
\& really need to maintain backward compatibility, you can do the following
\& in any overriding methods:
\&
\&    ($dir, $version) = ($version, $dir) if ($DBIx::Class::VERSION < 0.08100);
.Ve
.SS "thaw"
.IX Subsection "thaw"
Provided as the recommended way of thawing schema objects. You can call
\&\f(CW\*(C`Storable::thaw\*(C'\fR directly if you wish, but the thawed objects will not have a
reference to any schema, so are rather useless.
.SS "freeze"
.IX Subsection "freeze"
This doesn't actually do anything more than call \*(L"nfreeze\*(R" in Storable, it is just
provided here for symmetry.
.SS "dclone"
.IX Subsection "dclone"
.ie n .IP "Arguments: $object" 4
.el .IP "Arguments: \f(CW$object\fR" 4
.IX Item "Arguments: $object"
.PD 0
.ie n .IP "Return Value: dcloned $object" 4
.el .IP "Return Value: dcloned \f(CW$object\fR" 4
.IX Item "Return Value: dcloned $object"
.PD
.PP
Recommended way of dcloning DBIx::Class::Row and DBIx::Class::ResultSet
objects so their references to the schema object
(which itself is \fBnot\fR cloned) are properly maintained.
.SS "schema_version"
.IX Subsection "schema_version"
Returns the current schema class' \f(CW$VERSION\fR in a normalised way.
.SS "register_class"
.IX Subsection "register_class"
.ie n .IP "Arguments: $source_name, $component_class" 4
.el .IP "Arguments: \f(CW$source_name\fR, \f(CW$component_class\fR" 4
.IX Item "Arguments: $source_name, $component_class"
.PP
This method is called by \*(L"load_namespaces\*(R" and \*(L"load_classes\*(R" to install the found classes into your Schema. You should be using those instead of this one.
.PP
You will only need this method if you have your Result classes in
files which are not named after the packages (or all in the same
file). You may also need it to register classes at runtime.
.PP
Registers a class which isa DBIx::Class::ResultSourceProxy. Equivalent to
calling:
.PP
.Vb 1
\&  $schema\->register_source($source_name, $component_class\->result_source_instance);
.Ve
.SS "register_source"
.IX Subsection "register_source"
.ie n .IP "Arguments: $source_name, $result_source" 4
.el .IP "Arguments: \f(CW$source_name\fR, \f(CW$result_source\fR" 4
.IX Item "Arguments: $source_name, $result_source"
.PP
This method is called by \*(L"register_class\*(R".
.PP
Registers the DBIx::Class::ResultSource in the schema with the given
source name.
.SS "unregister_source"
.IX Subsection "unregister_source"
.ie n .IP "Arguments: $source_name" 4
.el .IP "Arguments: \f(CW$source_name\fR" 4
.IX Item "Arguments: $source_name"
.PP
Removes the DBIx::Class::ResultSource from the schema for the given source name.
.SS "register_extra_source"
.IX Subsection "register_extra_source"
.ie n .IP "Arguments: $source_name, $result_source" 4
.el .IP "Arguments: \f(CW$source_name\fR, \f(CW$result_source\fR" 4
.IX Item "Arguments: $source_name, $result_source"
.PP
As \*(L"register_source\*(R" but should be used if the result class already
has a source and you want to register an extra one.
.SS "compose_connection (\s-1DEPRECATED\s0)"
.IX Subsection "compose_connection (DEPRECATED)"
.ie n .IP "Arguments: $target_namespace, @db_info" 4
.el .IP "Arguments: \f(CW$target_namespace\fR, \f(CW@db_info\fR" 4
.IX Item "Arguments: $target_namespace, @db_info"
.PD 0
.ie n .IP "Return Value: $new_schema" 4
.el .IP "Return Value: \f(CW$new_schema\fR" 4
.IX Item "Return Value: $new_schema"
.PD
.PP
\&\s-1DEPRECATED.\s0 You probably wanted compose_namespace.
.PP
Actually, you probably just wanted to call connect.
.SH "AUTHOR AND CONTRIBUTORS"
.IX Header "AUTHOR AND CONTRIBUTORS"
See \s-1AUTHOR\s0 and \s-1CONTRIBUTORS\s0 in DBIx::Class
.SH "LICENSE"
.IX Header "LICENSE"
You may distribute this code under the same terms as Perl itself.
