.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PERLTRAP 1"
.TH PERLTRAP 1 "2014-01-06" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
perltrap \- Perl traps for the unwary
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The biggest trap of all is forgetting to \f(CW\*(C`use warnings\*(C'\fR or use the \fB\-w\fR
switch; see perllexwarn and perlrun. The second biggest trap is not
making your entire program runnable under \f(CW\*(C`use strict\*(C'\fR.  The third biggest
trap is not reading the list of changes in this version of Perl; see
perldelta.
.SS "Awk Traps"
.IX Subsection "Awk Traps"
Accustomed \fBawk\fR users should take special note of the following:
.IP "\(bu" 4
A Perl program executes only once, not once for each input line.  You can
do an implicit loop with \f(CW\*(C`\-n\*(C'\fR or \f(CW\*(C`\-p\*(C'\fR.
.IP "\(bu" 4
The English module, loaded via
.Sp
.Vb 1
\&    use English;
.Ve
.Sp
allows you to refer to special variables (like \f(CW$/\fR) with names (like
\&\f(CW$RS\fR), as though they were in \fBawk\fR; see perlvar for details.
.IP "\(bu" 4
Semicolons are required after all simple statements in Perl (except
at the end of a block).  Newline is not a statement delimiter.
.IP "\(bu" 4
Curly brackets are required on \f(CW\*(C`if\*(C'\fRs and \f(CW\*(C`while\*(C'\fRs.
.IP "\(bu" 4
Variables begin with \*(L"$\*(R", \*(L"@\*(R" or \*(L"%\*(R" in Perl.
.IP "\(bu" 4
Arrays index from 0.  Likewise string positions in \fIsubstr()\fR and
\&\fIindex()\fR.
.IP "\(bu" 4
You have to decide whether your array has numeric or string indices.
.IP "\(bu" 4
Hash values do not spring into existence upon mere reference.
.IP "\(bu" 4
You have to decide whether you want to use string or numeric
comparisons.
.IP "\(bu" 4
Reading an input line does not split it for you.  You get to split it
to an array yourself.  And the \fIsplit()\fR operator has different
arguments than \fBawk\fR's.
.IP "\(bu" 4
The current input line is normally in \f(CW$_\fR, not \f(CW$0\fR.  It generally does
not have the newline stripped.  ($0 is the name of the program
executed.)  See perlvar.
.IP "\(bu" 4
$<\fIdigit\fR> does not refer to fields\*(--it refers to substrings matched
by the last match pattern.
.IP "\(bu" 4
The \fIprint()\fR statement does not add field and record separators unless
you set \f(CW$,\fR and \f(CW\*(C`$\e\*(C'\fR.  You can set \f(CW$OFS\fR and \f(CW$ORS\fR if you're using
the English module.
.IP "\(bu" 4
You must open your files before you print to them.
.IP "\(bu" 4
The range operator is \*(L"..\*(R", not comma.  The comma operator works as in
C.
.IP "\(bu" 4
The match operator is \*(L"=~\*(R", not \*(L"~\*(R".  (\*(L"~\*(R" is the one's complement
operator, as in C.)
.IP "\(bu" 4
The exponentiation operator is \*(L"**\*(R", not \*(L"^\*(R".  \*(L"^\*(R" is the \s-1XOR\s0
operator, as in C.  (You know, one could get the feeling that \fBawk\fR is
basically incompatible with C.)
.IP "\(bu" 4
The concatenation operator is \*(L".\*(R", not the null string.  (Using the
null string would render \f(CW\*(C`/pat/ /pat/\*(C'\fR unparsable, because the third slash
would be interpreted as a division operator\*(--the tokenizer is in fact
slightly context sensitive for operators like \*(L"/\*(R", \*(L"?\*(R", and \*(L">\*(R".
And in fact, \*(L".\*(R" itself can be the beginning of a number.)
.IP "\(bu" 4
The \f(CW\*(C`next\*(C'\fR, \f(CW\*(C`exit\*(C'\fR, and \f(CW\*(C`continue\*(C'\fR keywords work differently.
.IP "\(bu" 4
The following variables work differently:
.Sp
.Vb 10
\&      Awk       Perl
\&      ARGC      scalar @ARGV (compare with $#ARGV)
\&      ARGV[0]   $0
\&      FILENAME  $ARGV
\&      FNR       $. \- something
\&      FS        (whatever you like)
\&      NF        $#Fld, or some such
\&      NR        $.
\&      OFMT      $#
\&      OFS       $,
\&      ORS       $\e
\&      RLENGTH   length($&)
\&      RS        $/
\&      RSTART    length($\`)
\&      SUBSEP    $;
.Ve
.IP "\(bu" 4
You cannot set \f(CW$RS\fR to a pattern, only a string.
.IP "\(bu" 4
When in doubt, run the \fBawk\fR construct through \fBa2p\fR and see what it
gives you.
.SS "C/\*(C+ Traps"
.IX Subsection "C/ Traps"
Cerebral C and \*(C+ programmers should take note of the following:
.IP "\(bu" 4
Curly brackets are required on \f(CW\*(C`if\*(C'\fR's and \f(CW\*(C`while\*(C'\fR's.
.IP "\(bu" 4
You must use \f(CW\*(C`elsif\*(C'\fR rather than \f(CW\*(C`else if\*(C'\fR.
.IP "\(bu" 4
The \f(CW\*(C`break\*(C'\fR and \f(CW\*(C`continue\*(C'\fR keywords from C become in Perl \f(CW\*(C`last\*(C'\fR
and \f(CW\*(C`next\*(C'\fR, respectively.  Unlike in C, these do \fInot\fR work within a
\&\f(CW\*(C`do { } while\*(C'\fR construct.  See \*(L"Loop Control\*(R" in perlsyn.
.IP "\(bu" 4
The switch statement is called \f(CW\*(C`given/when\*(C'\fR and only available in
perl 5.10 or newer.  See \*(L"Switch Statements\*(R" in perlsyn.
.IP "\(bu" 4
Variables begin with \*(L"$\*(R", \*(L"@\*(R" or \*(L"%\*(R" in Perl.
.IP "\(bu" 4
Comments begin with \*(L"#\*(R", not \*(L"/*\*(R" or \*(L"//\*(R".  Perl may interpret C/\*(C+
comments as division operators, unterminated regular expressions or
the defined-or operator.
.IP "\(bu" 4
You can't take the address of anything, although a similar operator
in Perl is the backslash, which creates a reference.
.IP "\(bu" 4
\&\f(CW\*(C`ARGV\*(C'\fR must be capitalized.  \f(CW$ARGV[0]\fR is C's \f(CW\*(C`argv[1]\*(C'\fR, and \f(CW\*(C`argv[0]\*(C'\fR
ends up in \f(CW$0\fR.
.IP "\(bu" 4
System calls such as \fIlink()\fR, \fIunlink()\fR, \fIrename()\fR, etc. return nonzero for
success, not 0. (\fIsystem()\fR, however, returns zero for success.)
.IP "\(bu" 4
Signal handlers deal with signal names, not numbers.  Use \f(CW\*(C`kill \-l\*(C'\fR
to find their names on your system.
.SS "Sed Traps"
.IX Subsection "Sed Traps"
Seasoned \fBsed\fR programmers should take note of the following:
.IP "\(bu" 4
A Perl program executes only once, not once for each input line.  You can
do an implicit loop with \f(CW\*(C`\-n\*(C'\fR or \f(CW\*(C`\-p\*(C'\fR.
.IP "\(bu" 4
Backreferences in substitutions use \*(L"$\*(R" rather than \*(L"\e\*(R".
.IP "\(bu" 4
The pattern matching metacharacters \*(L"(\*(R", \*(L")\*(R", and \*(L"|\*(R" do not have backslashes
in front.
.IP "\(bu" 4
The range operator is \f(CW\*(C`...\*(C'\fR, rather than comma.
.SS "Shell Traps"
.IX Subsection "Shell Traps"
Sharp shell programmers should take note of the following:
.IP "\(bu" 4
The backtick operator does variable interpolation without regard to
the presence of single quotes in the command.
.IP "\(bu" 4
The backtick operator does no translation of the return value, unlike \fBcsh\fR.
.IP "\(bu" 4
Shells (especially \fBcsh\fR) do several levels of substitution on each
command line.  Perl does substitution in only certain constructs
such as double quotes, backticks, angle brackets, and search patterns.
.IP "\(bu" 4
Shells interpret scripts a little bit at a time.  Perl compiles the
entire program before executing it (except for \f(CW\*(C`BEGIN\*(C'\fR blocks, which
execute at compile time).
.IP "\(bu" 4
The arguments are available via \f(CW@ARGV\fR, not \f(CW$1\fR, \f(CW$2\fR, etc.
.IP "\(bu" 4
The environment is not automatically made available as separate scalar
variables.
.IP "\(bu" 4
The shell's \f(CW\*(C`test\*(C'\fR uses \*(L"=\*(R", \*(L"!=\*(R", \*(L"<\*(R" etc for string comparisons and \*(L"\-eq\*(R",
\&\*(L"\-ne\*(R", \*(L"\-lt\*(R" etc for numeric comparisons. This is the reverse of Perl, which
uses \f(CW\*(C`eq\*(C'\fR, \f(CW\*(C`ne\*(C'\fR, \f(CW\*(C`lt\*(C'\fR for string comparisons, and \f(CW\*(C`==\*(C'\fR, \f(CW\*(C`!=\*(C'\fR \f(CW\*(C`<\*(C'\fR etc
for numeric comparisons.
.SS "Perl Traps"
.IX Subsection "Perl Traps"
Practicing Perl Programmers should take note of the following:
.IP "\(bu" 4
Remember that many operations behave differently in a list
context than they do in a scalar one.  See perldata for details.
.IP "\(bu" 4
Avoid barewords if you can, especially all lowercase ones.
You can't tell by just looking at it whether a bareword is
a function or a string.  By using quotes on strings and
parentheses on function calls, you won't ever get them confused.
.IP "\(bu" 4
You cannot discern from mere inspection which builtins
are unary operators (like \fIchop()\fR and \fIchdir()\fR)
and which are list operators (like \fIprint()\fR and \fIunlink()\fR).
(Unless prototyped, user-defined subroutines can \fBonly\fR be list
operators, never unary ones.)  See perlop and perlsub.
.IP "\(bu" 4
People have a hard time remembering that some functions
default to \f(CW$_\fR, or \f(CW@ARGV\fR, or whatever, but that others which
you might expect to do not.
.IP "\(bu" 4
The <\s-1FH\s0> construct is not the name of the filehandle, it is a readline
operation on that handle.  The data read is assigned to \f(CW$_\fR only if the
file read is the sole condition in a while loop:
.Sp
.Vb 3
\&    while (<FH>)      { }
\&    while (defined($_ = <FH>)) { }..
\&    <FH>;  # data discarded!
.Ve
.IP "\(bu" 4
Remember not to use \f(CW\*(C`=\*(C'\fR when you need \f(CW\*(C`=~\*(C'\fR;
these two constructs are quite different:
.Sp
.Vb 2
\&    $x =  /foo/;
\&    $x =~ /foo/;
.Ve
.IP "\(bu" 4
The \f(CW\*(C`do {}\*(C'\fR construct isn't a real loop that you can use
loop control on.
.IP "\(bu" 4
Use \f(CW\*(C`my()\*(C'\fR for local variables whenever you can get away with
it (but see perlform for where you can't).
Using \f(CW\*(C`local()\*(C'\fR actually gives a local value to a global
variable, which leaves you open to unforeseen side-effects
of dynamic scoping.
.IP "\(bu" 4
If you localize an exported variable in a module, its exported value will
not change.  The local name becomes an alias to a new value but the
external name is still an alias for the original.
.PP
As always, if any of these are ever officially declared as bugs,
they'll be fixed and removed.
