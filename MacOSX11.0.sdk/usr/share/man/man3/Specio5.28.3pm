.\" Automatically generated by Pod::Man 4.10 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Specio 3"
.TH Specio 3 "2020-03-14" "perl v5.28.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Specio \- Type constraints and coercions for Perl
.SH "VERSION"
.IX Header "VERSION"
version 0.46
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    package MyApp::Type::Library;
\&
\&    use Specio::Declare;
\&    use Specio::Library::Builtins;
\&
\&    declare(
\&        \*(AqPositiveInt\*(Aq,
\&        parent => t(\*(AqInt\*(Aq),
\&        inline => sub {
\&            $_[0]\->parent\->inline_check( $_[1] )
\&                . \*(Aq && ( \*(Aq
\&                . $_[1]
\&                . \*(Aq > 0 )\*(Aq;
\&        },
\&    );
\&
\&    # or ...
\&
\&    declare(
\&        \*(AqPositiveInt\*(Aq,
\&        parent => t(\*(AqInt\*(Aq),
\&        where  => sub { $_[0] > 0 },
\&    );
\&
\&    declare(
\&        \*(AqArrayRefOfPositiveInt\*(Aq,
\&        parent => t(
\&            \*(AqArrayRef\*(Aq,
\&            of => t(\*(AqPositiveInt\*(Aq),
\&        ),
\&    );
\&
\&    coerce(
\&        \*(AqArrayRefOfPositiveInt\*(Aq,
\&        from  => t(\*(AqPositiveInt\*(Aq),
\&        using => sub { [ $_[0] ] },
\&    );
\&
\&    any_can_type(
\&        \*(AqDuck\*(Aq,
\&        methods => [ \*(Aqduck_walk\*(Aq, \*(Aqquack\*(Aq ],
\&    );
\&
\&    object_isa_type(\*(AqMyApp::Person\*(Aq);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The \f(CW\*(C`Specio\*(C'\fR distribution provides classes for representing type constraints
and coercion, along with syntax sugar for declaring them.
.PP
Note that this is not a proper type system for Perl. Nothing in this
distribution will magically make the Perl interpreter start checking a value's
type on assignment to a variable. In fact, there's no built-in way to apply a
type to a variable at all.
.PP
Instead, you can explicitly check a value against a type, and optionally
coerce values to that type.
.PP
My long-term goal is to replace Moose's built-in types and MooseX::Types
with this module.
.SH "WHAT IS A TYPE?"
.IX Header "WHAT IS A TYPE?"
At it's core, a type is simply a constraint. A constraint is code that checks
a value and returns true or false. Most constraints are represented by
Specio::Constraint::Simple objects. However, there are other type
constraint classes for specialized kinds of constraints.
.PP
Types can be named or anonymous, and each type can have a parent type. A
type's constraint is optional because sometimes you may want to create a named
subtype of some existing type without adding additional constraints.
.PP
Constraints can be expressed either in terms of a simple subroutine reference
or in terms of an inline generator subroutine reference. The former is easier
to write but the latter is preferred because it allow for better optimization.
.PP
A type can also have an optional message generator subroutine reference. You
can use this to provide a more intelligent error message when a value does not
pass the constraint, though the default message should suffice for most cases.
.PP
Finally, you can associate a set of coercions with a type. A coercion is a
subroutine reference (or inline generator, like constraints), that takes a
value of one type and turns it into a value that matches the type the coercion
belongs to.
.SH "BUILTIN TYPES"
.IX Header "BUILTIN TYPES"
This distribution ships with a set of builtin types representing the types
provided by the Perl interpreter itself. They are arranged in a hierarchy as
follows:
.PP
.Vb 10
\&  Item
\&      Bool
\&      Maybe (of \`a)
\&      Undef
\&      Defined
\&          Value
\&              Str
\&                  Num
\&                      Int
\&                  ClassName
\&          Ref
\&              ScalarRef (of \`a)
\&              ArrayRef (of \`a)
\&              HashRef (of \`a)
\&              CodeRef
\&              RegexpRef
\&              GlobRef
\&              FileHandle
\&              Object
.Ve
.PP
The \f(CW\*(C`Item\*(C'\fR type accepts anything and everything.
.PP
The \f(CW\*(C`Bool\*(C'\fR type only accepts \f(CW\*(C`undef\*(C'\fR, \f(CW0\fR, or \f(CW1\fR.
.PP
The \f(CW\*(C`Undef\*(C'\fR type only accepts \f(CW\*(C`undef\*(C'\fR.
.PP
The \f(CW\*(C`Defined\*(C'\fR type accepts anything \fIexcept\fR \f(CW\*(C`undef\*(C'\fR.
.PP
The \f(CW\*(C`Num\*(C'\fR and \f(CW\*(C`Int\*(C'\fR types are stricter about numbers than Perl
is. Specifically, they do not allow any sort of space in the number, nor do
they accept \*(L"Nan\*(R", \*(L"Inf\*(R", or \*(L"Infinity\*(R".
.PP
The \f(CW\*(C`ClassName\*(C'\fR type constraint checks that the name is valid \fIand\fR that the
class is loaded.
.PP
The \f(CW\*(C`FileHandle\*(C'\fR type accepts either a glob, a scalar filehandle, or anything
that isa IO::Handle.
.PP
All types accept overloaded objects that support the required operation. See
below for details.
.SS "Overloading"
.IX Subsection "Overloading"
Perl's overloading is horribly broken and doesn't make much sense at all.
.PP
However, unlike Moose, all type constraints allow overloaded objects where
they make sense.
.PP
For types where overloading makes sense, we explicitly check that the object
provides the type overloading we expect. We \fIdo not\fR simply try to use the
object as the type in question and hope it works. This means that these checks
effectively ignore the \f(CW\*(C`fallback\*(C'\fR setting for the overloaded object. In other
words, an object that overloads stringification will not pass the \f(CW\*(C`Bool\*(C'\fR type
check unless it \fIalso\fR overloads boolification.
.PP
Most types do not check that the overloaded method actually returns something
that matches the constraint. This may change in the future.
.PP
The \f(CW\*(C`Bool\*(C'\fR type accepts an object that implements \f(CW\*(C`bool\*(C'\fR overloading.
.PP
The \f(CW\*(C`Str\*(C'\fR type accepts an object that implements string (\f(CW\*(C`q{""}\*(C'\fR)
overloading.
.PP
The \f(CW\*(C`Num\*(C'\fR type accepts an object that implements numeric (\f(CW\*(C`\*(Aq0+\*(Aq}\*(C'\fR)
overloading. The \f(CW\*(C`Int\*(C'\fR type does as well, but it will check that the
overloading returns an actual integer.
.PP
The \f(CW\*(C`ClassName\*(C'\fR type will accept an object with string overloading that
returns a class name.
.PP
To make this all more confusing, the \f(CW\*(C`Value\*(C'\fR type will \fInever\fR accept an
object, even though some of its subtypes will.
.PP
The various reference types all accept objects which provide the appropriate
overloading. The \f(CW\*(C`FileHandle\*(C'\fR type accepts an object which overloads
globification as long as the returned glob is an open filehandle.
.SH "PARAMETERIZABLE TYPES"
.IX Header "PARAMETERIZABLE TYPES"
Any type followed by a type parameter \f(CW\*(C`of \`a\*(C'\fR in the hierarchy above can be
parameterized. The parameter is itself a type, so you can say you want an
\&\*(L"ArrayRef of Int\*(R", or even an \*(L"ArrayRef of HashRef of ScalarRef of ClassName\*(R".
.PP
When they are parameterized, the \f(CW\*(C`ScalarRef\*(C'\fR and \f(CW\*(C`ArrayRef\*(C'\fR types check that
the value(s) they refer to match the type parameter. For the \f(CW\*(C`HashRef\*(C'\fR type,
the parameter applies to the values (keys are never checked).
.SS "Maybe"
.IX Subsection "Maybe"
The \f(CW\*(C`Maybe\*(C'\fR type is a special parameterized type. It allows for either
\&\f(CW\*(C`undef\*(C'\fR or a value. All by itself, it is meaningless, since it is equivalent
to \*(L"Maybe of Item\*(R", which is equivalent to Item. When parameterized, it
accepts either an \f(CW\*(C`undef\*(C'\fR or the type of its parameter.
.PP
This is useful for optional attributes or parameters. However, you're probably
better off making your code simply not pass the parameter at all This usually
makes for a simpler \s-1API.\s0
.SH "REGISTRIES AND IMPORTING"
.IX Header "REGISTRIES AND IMPORTING"
Types are local to each package where they are used. When you \*(L"import\*(R" types
from some other library, you are actually making a copy of that type.
.PP
This means that a type named \*(L"Foo\*(R" in one package may not be the same as \*(L"Foo\*(R"
in another package. This has potential for confusion, but it also avoids the
magic action at a distance pollution that comes with a global type naming
system.
.PP
The registry is managed internally by the Specio distribution's modules, and is
not exposed to your code. To access a type, you always call \f(CW\*(C`t(\*(AqTypeName\*(Aq)\*(C'\fR.
.PP
This returns the named type or dies if no such type exists.
.PP
Because types are always copied on import, it's safe to create coercions on
any type. Your coercion from \f(CW\*(C`Str\*(C'\fR to \f(CW\*(C`Int\*(C'\fR will not be seen by any other
package, unless that package explicitly imports your \f(CW\*(C`Int\*(C'\fR type.
.PP
When you import types, you import every type defined in the package you import
from. However, you \fIcan\fR overwrite an imported type with your own type
definition. You \fIcannot\fR define the same type twice internally.
.SH "CREATING A TYPE LIBRARY"
.IX Header "CREATING A TYPE LIBRARY"
By default, all types created inside a package are invisible to other
packages. If you want to create a type library, you need to inherit from
Specio::Exporter package:
.PP
.Vb 1
\&  package MyApp::Type::Library;
\&
\&  use parent \*(AqSpecio::Exporter\*(Aq;
\&
\&  use Specio::Declare;
\&  use Specio::Library::Builtins;
\&
\&  declare(
\&      \*(AqFoo\*(Aq,
\&      parent => t(\*(AqStr\*(Aq),
\&      where  => sub { $_[0] =~ /foo/i },
\&  );
.Ve
.PP
Now the MyApp::Type::Library package will export a single type named
\&\f(CW\*(C`Foo\*(C'\fR. It \fIdoes not\fR re-export the types provided by
Specio::Library::Builtins.
.PP
If you want to make your library re-export some other libraries types, you can
ask for this explicitly:
.PP
.Vb 1
\&  package MyApp::Type::Library;
\&
\&  use parent \*(AqSpecio::Exporter\*(Aq;
\&
\&  use Specio::Declare;
\&  use Specio::Library::Builtins \-reexport;
\&
\&  declare( \*(AqFoo, ... );
.Ve
.PP
Now MyApp::Types::Library exports any types it defines, as well as all the
types defined in Specio::Library::Builtins.
.SH "DECLARING TYPES"
.IX Header "DECLARING TYPES"
Use the Specio::Declare module to declare types. It exports a set of helpers
for declaring types. See that module's documentation for more details on these
helpers.
.SH "USING SPECIO WITH Moose"
.IX Header "USING SPECIO WITH Moose"
This should just work. Use a Specio type anywhere you'd specify a type.
.SH "USING SPECIO WITH Moo"
.IX Header "USING SPECIO WITH Moo"
Using Specio with Moo is easy. You can pass Specio constraint objects as
\&\f(CW\*(C`isa\*(C'\fR parameters for attributes. For coercions, simply call \f(CW\*(C`$type\->coercion_sub\*(C'\fR.
.PP
.Vb 1
\&    package Foo;
\&
\&    use Specio::Declare;
\&    use Specio::Library::Builtins;
\&    use Moo;
\&
\&    my $str_type = t(\*(AqStr\*(Aq);
\&    has string => (
\&       is  => \*(Aqro\*(Aq,
\&       isa => $str_type,
\&    );
\&
\&    my $ucstr = declare(
\&        \*(AqUCStr\*(Aq,
\&        parent => t(\*(AqStr\*(Aq),
\&        where  => sub { $_[0] =~ /^[A\-Z]+$/ },
\&    );
\&
\&    coerce(
\&        $ucstr,
\&        from  => t(\*(AqStr\*(Aq),
\&        using => sub { return uc $_[0] },
\&    );
\&
\&    has ucstr => (
\&        is     => \*(Aqro\*(Aq,
\&        isa    => $ucstr,
\&        coerce => $ucstr\->coercion_sub,
\&    );
.Ve
.PP
The subs returned by Specio use Sub::Quote internally and are suitable for
inlining.
.SH "USING SPECIO WITH OTHER THINGS"
.IX Header "USING SPECIO WITH OTHER THINGS"
See Specio::Constraint::Simple for the \s-1API\s0 that all constraint objects
share.
.SH "Moose, MooseX::Types, and Specio"
.IX Header "Moose, MooseX::Types, and Specio"
This module aims to supplant both Moose's built-in type system (see
Moose::Util::TypeConstraints aka \s-1MUTC\s0) and MooseX::Types, which attempts
to patch some of the holes in the Moose built-in type design.
.PP
Here are some of the salient differences:
.IP "\(bu" 4
Types names are strings, but they're not global
.Sp
Unlike Moose and MooseX::Types, type names are always local to the current
package. There is no possibility of name collision between different modules,
so you can safely use short type names.
.Sp
Unlike MooseX::Types, types are strings, so there is no possibility of
colliding with existing class or subroutine names.
.IP "\(bu" 4
No type auto-creation
.Sp
Types are always retrieved using the \f(CW\*(C`t()\*(C'\fR subroutine. If you pass an unknown
name to this subroutine it dies. This is different from Moose and
MooseX::Types, which assume that unknown names are class names.
.IP "\(bu" 4
Anon types are explicit
.Sp
With Moose and MooseX::Types, you use the same subroutine, \f(CW\*(C`subtype()\*(C'\fR,
to declare both named and anonymous types. With Specio, you use \f(CW\*(C`declare()\*(C'\fR for
named types and \f(CW\*(C`anon()\*(C'\fR for anonymous types.
.IP "\(bu" 4
Class and object types are separate
.Sp
Moose and MooseX::Types have \f(CW\*(C`class_type\*(C'\fR and \f(CW\*(C`duck_type\*(C'\fR. The former type
requires an object, while the latter accepts a class name or object.
.Sp
With Specio, the distinction between accepting an object versus object or
class is explicit. There are six declaration helpers, \f(CW\*(C`object_can_type\*(C'\fR,
\&\f(CW\*(C`object_does_type\*(C'\fR, \f(CW\*(C`object_isa_type\*(C'\fR, \f(CW\*(C`any_can_type\*(C'\fR, \f(CW\*(C`any_does_type\*(C'\fR,
and \f(CW\*(C`any_isa_type\*(C'\fR.
.IP "\(bu" 4
Overloading support is baked in
.Sp
Perl's overloading is quite broken but ignoring it makes Moose's type system
frustrating to use in many cases.
.IP "\(bu" 4
Types can either have a constraint or inline generator, not both
.Sp
Moose and MooseX::Types types can be defined with a subroutine reference as
the constraint, an inline generator subroutine, or both. This is purely for
backwards compatibility, and it makes the internals more complicated than they
need to be.
.Sp
With Specio, a constraint can have \fIeither\fR a subroutine reference or an
inline generator, not both.
.IP "\(bu" 4
Coercions can be inlined
.Sp
I simply never got around to implementing this in Moose.
.IP "\(bu" 4
No crazy coercion features
.Sp
Moose has some bizarre (and mostly) undocumented features relating to
coercions and parameterizable types. This is a misfeature.
.SH "OPTIONAL PREREQS"
.IX Header "OPTIONAL PREREQS"
There are several optional prereqs that if installed will make this
distribution better in some way.
.IP "\(bu" 4
Ref::Util
.Sp
Installing this will speed up a number of type checks for built-in types.
.IP "\(bu" 4
XString
.Sp
If this is installed it will be loaded instead of the B module if you have
Perl 5.10 or greater. This module is much more memory efficient than loading
all of B.
.IP "\(bu" 4
Sub::Util or Sub::Name
.Sp
If one of these is installed then stack traces that end up in Specio code will
have much better subroutine names for any frames.
.SH "WHY THE NAME?"
.IX Header "WHY THE NAME?"
This distro was originally called \*(L"Type\*(R", but that's an awfully generic top
level namespace. Specio is Latin for for \*(L"look at\*(R" and \*(L"spec\*(R" is the root for
the word \*(L"species\*(R". It's short, relatively easy to type, and not used by any
other distro.
.SH "LONG-TERM PLANS"
.IX Header "LONG-TERM PLANS"
Eventually I'd like to see this distro replace Moose's internal type system,
which would also make MooseX::Types obsolete.
.SH "SUPPORT"
.IX Header "SUPPORT"
Bugs may be submitted at <https://github.com/houseabsolute/Specio/issues>.
.PP
I am also usually active on \s-1IRC\s0 as 'autarch' on \f(CW\*(C`irc://irc.perl.org\*(C'\fR.
.SH "SOURCE"
.IX Header "SOURCE"
The source code repository for Specio can be found at <https://github.com/houseabsolute/Specio>.
.SH "DONATIONS"
.IX Header "DONATIONS"
If you'd like to thank me for the work I've done on this module, please
consider making a \*(L"donation\*(R" to me via PayPal. I spend a lot of free time
creating free software, and would appreciate any support you'd care to offer.
.PP
Please note that \fBI am not suggesting that you must do this\fR in order for me
to continue working on this particular software. I will continue to do so,
inasmuch as I have in the past, for as long as it interests me.
.PP
Similarly, a donation made in this way will probably not make me work on this
software much more, unless I get so many donations that I can consider working
on free software full time (let's all have a chuckle at that together).
.PP
To donate, log into PayPal and send money to autarch@urth.org, or use the
button at <https://www.urth.org/fs\-donation.html>.
.SH "AUTHOR"
.IX Header "AUTHOR"
Dave Rolsky <autarch@urth.org>
.SH "CONTRIBUTORS"
.IX Header "CONTRIBUTORS"
.IP "\(bu" 4
Chris White <chrisw@leehayes.com>
.IP "\(bu" 4
cpansprout <cpansprout@gmail.com>
.IP "\(bu" 4
Graham Knop <haarg@haarg.org>
.IP "\(bu" 4
Karen Etheridge <ether@cpan.org>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is Copyright (c) 2012 \- 2020 by Dave Rolsky.
.PP
This is free software, licensed under:
.PP
.Vb 1
\&  The Artistic License 2.0 (GPL Compatible)
.Ve
.PP
The full text of the license can be found in the
\&\fI\s-1LICENSE\s0\fR file included with this distribution.
