.\" Automatically generated by Pod::Man 4.10 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Test::Script 3"
.TH Test::Script 3 "2019-10-26" "perl v5.28.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Test::Script \- Basic cross\-platform tests for scripts
.SH "VERSION"
.IX Header "VERSION"
version 1.26
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\& use Test2::V0;
\& use Test::Script;
\& 
\& script_compiles(\*(Aqscript/myscript.pl\*(Aq);
\& script_runs([\*(Aqscript/myscript.pl\*(Aq, \*(Aq\-\-my\-argument\*(Aq]);
\& 
\& program_runs([\*(Aqls\*(Aq, \*(Aq/dev\*(Aq]);
\& 
\& done_testing;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The intent of this module is to provide a series of basic tests for 80%
of the testing you will need to do for scripts in the \fIscript\fR (or \fIbin\fR
as is also commonly used) paths of your Perl distribution.
.PP
It also provides similar functions for testing programs that are not
Perl scripts.
.PP
Further, it aims to provide this functionality with perfect
platform-compatibility, and in a way that is as unobtrusive as possible.
.PP
That is, if the program works on a platform, then \fBTest::Script\fR
should always work on that platform as well. Anything less than 100% is
considered unacceptable.
.PP
In doing so, it is hoped that \fBTest::Script\fR can become a module that
you can safely make a dependency of all your modules, without risking that
your module won't on some platform because of the dependency.
.PP
Where a clash exists between wanting more functionality and maintaining
platform safety, this module will err on the side of platform safety.
.SH "FUNCTIONS"
.IX Header "FUNCTIONS"
.SS "script_compiles"
.IX Subsection "script_compiles"
.Vb 1
\& script_compiles( $script, $test_name );
.Ve
.PP
The \*(L"script_compiles\*(R" test calls the script with \*(L"perl \-c script.pl\*(R",
and checks that it returns without error.
.PP
The path it should be passed is a relative Unix-format script name. This
will be localised when running \f(CW\*(C`perl \-c\*(C'\fR and if the test fails the local
name used will be shown in the diagnostic output.
.PP
Note also that the test will be run with the same perl interpreter that
is running the test script (and not with the default system perl). This
will also be shown in the diagnostic output on failure.
.SS "script_runs"
.IX Subsection "script_runs"
.Vb 4
\& script_runs( $script, $test_name );
\& script_runs( \e@script_and_arguments, $test_name );
\& script_runs( $script, \e%options, $test_name );
\& script_runs( \e@script_and_arguments, \e%options, $test_name );
.Ve
.PP
The \*(L"script_runs\*(R" test executes the script with \*(L"perl script.pl\*(R" and checks
that it returns success.
.PP
The path it should be passed is a relative unix-format script name. This
will be localised when running \f(CW\*(C`perl \-c\*(C'\fR and if the test fails the local
name used will be shown in the diagnostic output.
.PP
The test will be run with the same perl interpreter that is running the
test script (and not with the default system perl). This will also be shown
in the diagnostic output on failure.
.PP
You may pass in options as a hash as the second argument.
.IP "exit" 4
.IX Item "exit"
The expected exit value.  The default is to use whatever indicates success
on your platform (usually 0).
.IP "interpreter_options" 4
.IX Item "interpreter_options"
Array reference of Perl options to be passed to the interpreter.  Things
like \f(CW\*(C`\-w\*(C'\fR or \f(CW\*(C`\-x\*(C'\fR can be passed this way.  This may be either a single
string or an array reference.
.IP "signal" 4
.IX Item "signal"
The expected signal.  The default is 0.  Use with care!  This may not be
portable, and is known not to work on Windows.
.IP "stdin" 4
.IX Item "stdin"
The input to be passed into the script via stdin.  The value may be one of
.RS 4
.IP "simple scalar" 4
.IX Item "simple scalar"
Is considered to be a filename.
.IP "scalar reference" 4
.IX Item "scalar reference"
In which case the input will be drawn from the data contained in the referenced
scalar.
.RE
.RS 4
.Sp
The behavior for any other types is undefined (the current implementation uses
Capture::Tiny).  Any already opened stdin will be closed.
.RE
.IP "stdout" 4
.IX Item "stdout"
Where to send the standard output to.  If you use this option, then the the
behavior of the \f(CW\*(C`script_stdout_\*(C'\fR functions below are undefined.  The value
may be one of
.RS 4
.IP "simple scalar" 4
.IX Item "simple scalar"
Is considered to be a filename.
.IP "scalar reference" 4
.IX Item "scalar reference"
.RE
.RS 4
.Sp
In which case the standard output will be places into the referenced scalar
.Sp
The behavior for any other types is undefined (the current implementation uses
Capture::Tiny).
.RE
.IP "stderr" 4
.IX Item "stderr"
Same as \f(CW\*(C`stdout\*(C'\fR above, except for stderr.
.SS "script_stdout_is"
.IX Subsection "script_stdout_is"
.Vb 1
\& script_stdout_is $expected_stdout, $test_name;
.Ve
.PP
Tests if the output to stdout from the previous \*(L"script_runs\*(R" matches the
expected value exactly.
.SS "script_stdout_isnt"
.IX Subsection "script_stdout_isnt"
.Vb 1
\& script_stdout_is $expected_stdout, $test_name;
.Ve
.PP
Tests if the output to stdout from the previous \*(L"script_runs\*(R" does \s-1NOT\s0 match the
expected value exactly.
.SS "script_stdout_like"
.IX Subsection "script_stdout_like"
.Vb 1
\& script_stdout_like $regex, $test_name;
.Ve
.PP
Tests if the output to stdout from the previous \*(L"script_runs\*(R" matches the regular
expression.
.SS "script_stdout_unlike"
.IX Subsection "script_stdout_unlike"
.Vb 1
\& script_stdout_unlike $regex, $test_name;
.Ve
.PP
Tests if the output to stdout from the previous \*(L"script_runs\*(R" does \s-1NOT\s0 match the regular
expression.
.SS "script_stderr_is"
.IX Subsection "script_stderr_is"
.Vb 1
\& script_stderr_is $expected_stderr, $test_name;
.Ve
.PP
Tests if the output to stderr from the previous \*(L"script_runs\*(R" matches the
expected value exactly.
.SS "script_stderr_isnt"
.IX Subsection "script_stderr_isnt"
.Vb 1
\& script_stderr_is $expected_stderr, $test_name;
.Ve
.PP
Tests if the output to stderr from the previous \*(L"script_runs\*(R" does \s-1NOT\s0 match the
expected value exactly.
.SS "script_stderr_like"
.IX Subsection "script_stderr_like"
.Vb 1
\& script_stderr_like $regex, $test_name;
.Ve
.PP
Tests if the output to stderr from the previous \*(L"script_runs\*(R" matches the regular
expression.
.SS "script_stderr_unlike"
.IX Subsection "script_stderr_unlike"
.Vb 1
\& script_stderr_unlike $regex, $test_name;
.Ve
.PP
Tests if the output to stderr from the previous \*(L"script_runs\*(R" does \s-1NOT\s0 match the regular
expression.
.SS "program_runs"
.IX Subsection "program_runs"
.Vb 4
\& program_runs( $program, $test_name );
\& program_runs( \e@program_and_arguments, $test_name );
\& program_runs( $program, \e%options, $test_name );
\& program_runs( \e@program_and_arguments, \e%options, $test_name );
.Ve
.PP
The \*(L"program_runs\*(R" test executes the given program and checks
that it returns success.  This function works like \*(L"script_runs\*(R" except:
.IP "\(bu" 4
The path \f(CW$program\fR or \f(CW@program_and_arguments\fR is passed as-is to
\&\fBsystem()\fR <https://perldoc.perl.org/functions/system.html>.  This means
\&\f(CW\*(C`program_runs\*(C'\fR can test any program, not just Perl scripts.
.IP "\(bu" 4
The \f(CW%options\fR do not support the \f(CW\*(C`interpreter_options\*(C'\fR key.
.PP
See File::Spec or Path::Class for routines useful in building pathnames
in a cross-platform way.
.SS "program_stdout_is"
.IX Subsection "program_stdout_is"
.Vb 1
\& program_stdout_is $expected_stdout, $test_name;
.Ve
.PP
Tests if the output to stdout from the previous \*(L"program_runs\*(R" matches the
expected value exactly.
.SS "program_stdout_isnt"
.IX Subsection "program_stdout_isnt"
.Vb 1
\& program_stdout_is $expected_stdout, $test_name;
.Ve
.PP
Tests if the output to stdout from the previous \*(L"program_runs\*(R" does \s-1NOT\s0 match the
expected value exactly.
.SS "program_stdout_like"
.IX Subsection "program_stdout_like"
.Vb 1
\& program_stdout_like $regex, $test_name;
.Ve
.PP
Tests if the output to stdout from the previous \*(L"program_runs\*(R" matches the regular
expression.
.SS "program_stdout_unlike"
.IX Subsection "program_stdout_unlike"
.Vb 1
\& program_stdout_unlike $regex, $test_name;
.Ve
.PP
Tests if the output to stdout from the previous \*(L"program_runs\*(R" does \s-1NOT\s0 match the regular
expression.
.SS "program_stderr_is"
.IX Subsection "program_stderr_is"
.Vb 1
\& program_stderr_is $expected_stderr, $test_name;
.Ve
.PP
Tests if the output to stderr from the previous \*(L"program_runs\*(R" matches the
expected value exactly.
.SS "program_stderr_isnt"
.IX Subsection "program_stderr_isnt"
.Vb 1
\& program_stderr_is $expected_stderr, $test_name;
.Ve
.PP
Tests if the output to stderr from the previous \*(L"program_runs\*(R" does \s-1NOT\s0 match the
expected value exactly.
.SS "program_stderr_like"
.IX Subsection "program_stderr_like"
.Vb 1
\& program_stderr_like $regex, $test_name;
.Ve
.PP
Tests if the output to stderr from the previous \*(L"program_runs\*(R" matches the regular
expression.
.SS "program_stderr_unlike"
.IX Subsection "program_stderr_unlike"
.Vb 1
\& program_stderr_unlike $regex, $test_name;
.Ve
.PP
Tests if the output to stderr from the previous \*(L"program_runs\*(R" does \s-1NOT\s0 match the regular
expression.
.SH "CAVEATS"
.IX Header "CAVEATS"
This module is fully supported back to Perl 5.8.1.
.PP
The \s-1STDIN\s0 handle will be closed when using script_runs with the stdin option.
An older version used IPC::Run3, which attempted to save \s-1STDIN,\s0 but
apparently this cannot be done consistently or portably.  We now use
Capture::Tiny instead and explicitly do not support saving \s-1STDIN\s0 handles.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Test::Script::Run, Test2::Suite
.SH "AUTHOR"
.IX Header "AUTHOR"
Original author: Adam Kennedy
.PP
Current maintainer: Graham Ollis <plicease@cpan.org>
.PP
Contributors:
.PP
Brendan Byrd
.PP
Chris White <cxw@cpan.org>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is copyright (c) 2019 by Adam Kennedy.
.PP
This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.
