.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PPI::Normal 3"
.TH PPI::Normal 3 "2011-02-25" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
PPI::Normal \- Normalize Perl Documents
.SS "\s-1DESCRIPTION\s0"
.IX Subsection "DESCRIPTION"
Perl Documents, as created by \s-1PPI,\s0 are typically filled with all sorts of
mess such as whitespace and comments and other things that don't effect
the actual meaning of the code.
.PP
In addition, because there is more than one way to do most things, and the
syntax of Perl itself is quite flexible, there are many ways in which the
\&\*(L"same\*(R" code can look quite different.
.PP
PPI::Normal attempts to resolve this by providing a variety of mechanisms
and algorithms to \*(L"normalize\*(R" Perl Documents, and determine a sort of base
form for them (although this base form will be a memory structure, and
not something that can be turned back into Perl source code).
.PP
The process itself is quite complex, and so for convenience and
extensibility it has been separated into a number of layers. At a later
point, it will be possible to write Plugin classes to insert additional
normalization steps into the various different layers.
.PP
In addition, you can choose to do the normalization only as deep as a
particular layer, depending on aggressively you want the normalization
process to be.
.SH "METHODS"
.IX Header "METHODS"
.ie n .SS "register $function => $layer, ..."
.el .SS "register \f(CW$function\fP => \f(CW$layer\fP, ..."
.IX Subsection "register $function => $layer, ..."
The \f(CW\*(C`register\*(C'\fR method is used by normalization method providers to
tell the normalization engines which functions need to be run, and
in which layer they apply.
.PP
Provide a set of key/value pairs, where the key is the full name of the
function (in string form), and the value is the layer (see description
of the layers above) in which it should be run.
.PP
Returns true if all functions are registered, or \f(CW\*(C`undef\*(C'\fR on error.
.SS "new"
.IX Subsection "new"
.Vb 2
\&  my $level_1 = PPI::Normal\->new;
\&  my $level_2 = PPI::Normal\->new(2);
.Ve
.PP
Creates a new normalization object, to which Document objects
can be passed to be normalized.
.PP
Of course, what you probably \s-1REALLY\s0 want is just to call
PPI::Document's \f(CW\*(C`normalize\*(C'\fR method.
.PP
Takes an optional single parameter of the normalisation layer
to use, which at this time can be either \*(L"1\*(R" or \*(L"2\*(R".
.PP
Returns a new \f(CW\*(C`PPI::Normal\*(C'\fR object, or \f(CW\*(C`undef\*(C'\fR on error.
.SH "layer"
.IX Header "layer"
The \f(CW\*(C`layer\*(C'\fR accessor returns the normalisation layer of the object.
.SS "process"
.IX Subsection "process"
The \f(CW\*(C`process\*(C'\fR method takes anything that can be converted to a
PPI::Document (object, \s-1SCALAR\s0 ref, filename), loads it and
applies the normalisation process to the document.
.PP
Returns a PPI::Document::Normalized object, or \f(CW\*(C`undef\*(C'\fR on error.
.SH "NOTES"
.IX Header "NOTES"
The following normalisation layers are implemented. When writing
plugins, you should register each transformation function with the
appropriate layer.
.SS "Layer 1 \- Insignificant Data Removal"
.IX Subsection "Layer 1 - Insignificant Data Removal"
The basic step common to all normalization, layer 1 scans through the
Document and removes all whitespace, comments, \s-1POD,\s0 and anything else
that returns false for its \f(CW\*(C`significant\*(C'\fR method.
.PP
It also checks each Element and removes known-useless sub-element
metadata such as the Element's physical position in the file.
.SS "Layer 2 \- Significant Element Removal"
.IX Subsection "Layer 2 - Significant Element Removal"
After the removal of the insignificant data, Layer 2 removed larger, more
complex, and superficially \*(L"significant\*(R" elements, that can be removed
for the purposes of normalisation.
.PP
Examples from this layer include pragmas, now-useless statement
separators (since the \s-1PDOM\s0 tree is holding statement elements), and
several other minor bits and pieces.
.SS "Layer 3 \- \s-1TO BE COMPLETED\s0"
.IX Subsection "Layer 3 - TO BE COMPLETED"
This version of the forward-port of the Perl::Compare functionality
to the 0.900+ \s-1API\s0 of \s-1PPI\s0 only implements Layer 1 and 2 at this time.
.SH "TO DO"
.IX Header "TO DO"
\&\- Write the other 4\-5 layers :)
.SH "SUPPORT"
.IX Header "SUPPORT"
See the support section in the main module.
.SH "AUTHOR"
.IX Header "AUTHOR"
Adam Kennedy <adamk@cpan.org>
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright 2005 \- 2011 Adam Kennedy.
.PP
This program is free software; you can redistribute
it and/or modify it under the same terms as Perl itself.
.PP
The full text of the license can be found in the
\&\s-1LICENSE\s0 file included with this module.
