.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "LWP 3"
.TH LWP 3 "2013-03-11" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
LWP \- The World\-Wide Web library for Perl
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&  use LWP;
\&  print "This is libwww\-perl\-$LWP::VERSION\en";
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The libwww-perl collection is a set of Perl modules which provides a
simple and consistent application programming interface (\s-1API\s0) to the
World-Wide Web.  The main focus of the library is to provide classes
and functions that allow you to write \s-1WWW\s0 clients. The library also
contain modules that are of more general use and even classes that
help you implement simple \s-1HTTP\s0 servers.
.PP
Most modules in this library provide an object oriented \s-1API. \s0 The user
agent, requests sent and responses received from the \s-1WWW\s0 server are
all represented by objects.  This makes a simple and powerful
interface to these services.  The interface is easy to extend
and customize for your own needs.
.PP
The main features of the library are:
.IP "\(bu" 3
Contains various reusable components (modules) that can be
used separately or together.
.IP "\(bu" 3
Provides an object oriented model of HTTP-style communication.  Within
this framework we currently support access to http, https, gopher, ftp, news,
file, and mailto resources.
.IP "\(bu" 3
Provides a full object oriented interface or
a very simple procedural interface.
.IP "\(bu" 3
Supports the basic and digest authorization schemes.
.IP "\(bu" 3
Supports transparent redirect handling.
.IP "\(bu" 3
Supports access through proxy servers.
.IP "\(bu" 3
Provides parser for \fIrobots.txt\fR files and a framework for constructing robots.
.IP "\(bu" 3
Supports parsing of \s-1HTML\s0 forms.
.IP "\(bu" 3
Implements \s-1HTTP\s0 content negotiation algorithm that can
be used both in protocol modules and in server scripts (like \s-1CGI\s0
scripts).
.IP "\(bu" 3
Supports \s-1HTTP\s0 cookies.
.IP "\(bu" 3
Some simple command line clients, for instance \f(CW\*(C`lwp\-request\*(C'\fR and \f(CW\*(C`lwp\-download\*(C'\fR.
.SH "HTTP STYLE COMMUNICATION"
.IX Header "HTTP STYLE COMMUNICATION"
The libwww-perl library is based on \s-1HTTP\s0 style communication. This
section tries to describe what that means.
.PP
Let us start with this quote from the \s-1HTTP\s0 specification document
<URL:http://www.w3.org/Protocols/>:
.IP "\(bu" 3
The \s-1HTTP\s0 protocol is based on a request/response paradigm. A client
establishes a connection with a server and sends a request to the
server in the form of a request method, \s-1URI,\s0 and protocol version,
followed by a MIME-like message containing request modifiers, client
information, and possible body content. The server responds with a
status line, including the message's protocol version and a success or
error code, followed by a MIME-like message containing server
information, entity meta-information, and possible body content.
.PP
What this means to libwww-perl is that communication always take place
through these steps: First a \fIrequest\fR object is created and
configured. This object is then passed to a server and we get a
\&\fIresponse\fR object in return that we can examine. A request is always
independent of any previous requests, i.e. the service is stateless.
The same simple model is used for any kind of service we want to
access.
.PP
For example, if we want to fetch a document from a remote file server,
then we send it a request that contains a name for that document and
the response will contain the document itself.  If we access a search
engine, then the content of the request will contain the query
parameters and the response will contain the query result.  If we want
to send a mail message to somebody then we send a request object which
contains our message to the mail server and the response object will
contain an acknowledgment that tells us that the message has been
accepted and will be forwarded to the recipient(s).
.PP
It is as simple as that!
.SS "The Request Object"
.IX Subsection "The Request Object"
The libwww-perl request object has the class name \f(CW\*(C`HTTP::Request\*(C'\fR.
The fact that the class name uses \f(CW\*(C`HTTP::\*(C'\fR as a
prefix only implies that we use the \s-1HTTP\s0 model of communication.  It
does not limit the kind of services we can try to pass this \fIrequest\fR
to.  For instance, we will send \f(CW\*(C`HTTP::Request\*(C'\fRs both to ftp and
gopher servers, as well as to the local file system.
.PP
The main attributes of the request objects are:
.IP "\(bu" 3
\&\fBmethod\fR is a short string that tells what kind of
request this is.  The most common methods are \fB\s-1GET\s0\fR, \fB\s-1PUT\s0\fR,
\&\fB\s-1POST\s0\fR and \fB\s-1HEAD\s0\fR.
.IP "\(bu" 3
\&\fBuri\fR is a string denoting the protocol, server and
the name of the \*(L"document\*(R" we want to access.  The \fBuri\fR might
also encode various other parameters.
.IP "\(bu" 3
\&\fBheaders\fR contains additional information about the
request and can also used to describe the content.  The headers
are a set of keyword/value pairs.
.IP "\(bu" 3
\&\fBcontent\fR is an arbitrary amount of data.
.SS "The Response Object"
.IX Subsection "The Response Object"
The libwww-perl response object has the class name \f(CW\*(C`HTTP::Response\*(C'\fR.
The main attributes of objects of this class are:
.IP "\(bu" 3
\&\fBcode\fR is a numerical value that indicates the overall
outcome of the request.
.IP "\(bu" 3
\&\fBmessage\fR is a short, human readable string that
corresponds to the \fIcode\fR.
.IP "\(bu" 3
\&\fBheaders\fR contains additional information about the
response and describe the content.
.IP "\(bu" 3
\&\fBcontent\fR is an arbitrary amount of data.
.PP
Since we don't want to handle all possible \fIcode\fR values directly in
our programs, a libwww-perl response object has methods that can be
used to query what kind of response this is.  The most commonly used
response classification methods are:
.IP "\fIis_success()\fR" 3
.IX Item "is_success()"
The request was successfully received, understood or accepted.
.IP "\fIis_error()\fR" 3
.IX Item "is_error()"
The request failed.  The server or the resource might not be
available, access to the resource might be denied or other things might
have failed for some reason.
.SS "The User Agent"
.IX Subsection "The User Agent"
Let us assume that we have created a \fIrequest\fR object. What do we
actually do with it in order to receive a \fIresponse\fR?
.PP
The answer is that you pass it to a \fIuser agent\fR object and this
object takes care of all the things that need to be done
(like low-level communication and error handling) and returns
a \fIresponse\fR object. The user agent represents your
application on the network and provides you with an interface that
can accept \fIrequests\fR and return \fIresponses\fR.
.PP
The user agent is an interface layer between
your application code and the network.  Through this interface you are
able to access the various servers on the network.
.PP
The class name for the user agent is \f(CW\*(C`LWP::UserAgent\*(C'\fR.  Every
libwww-perl application that wants to communicate should create at
least one object of this class. The main method provided by this
object is \fIrequest()\fR. This method takes an \f(CW\*(C`HTTP::Request\*(C'\fR object as
argument and (eventually) returns a \f(CW\*(C`HTTP::Response\*(C'\fR object.
.PP
The user agent has many other attributes that let you
configure how it will interact with the network and with your
application.
.IP "\(bu" 3
\&\fBtimeout\fR specifies how much time we give remote servers to
respond before the library disconnects and creates an
internal \fItimeout\fR response.
.IP "\(bu" 3
\&\fBagent\fR specifies the name that your application uses when it
presents itself on the network.
.IP "\(bu" 3
\&\fBfrom\fR can be set to the e\-mail address of the person
responsible for running the application.  If this is set, then the
address will be sent to the servers with every request.
.IP "\(bu" 3
\&\fBparse_head\fR specifies whether we should initialize response
headers from the <head> section of \s-1HTML\s0 documents.
.IP "\(bu" 3
\&\fBproxy\fR and \fBno_proxy\fR specify if and when to go through
a proxy server. <URL:http://www.w3.org/History/1994/WWW/Proxies/>
.IP "\(bu" 3
\&\fBcredentials\fR provides a way to set up user names and
passwords needed to access certain services.
.PP
Many applications want even more control over how they interact
with the network and they get this by sub-classing
\&\f(CW\*(C`LWP::UserAgent\*(C'\fR.  The library includes a
sub-class, \f(CW\*(C`LWP::RobotUA\*(C'\fR, for robot applications.
.SS "An Example"
.IX Subsection "An Example"
This example shows how the user agent, a request and a response are
represented in actual perl code:
.PP
.Vb 4
\&  # Create a user agent object
\&  use LWP::UserAgent;
\&  my $ua = LWP::UserAgent\->new;
\&  $ua\->agent("MyApp/0.1 ");
\&
\&  # Create a request
\&  my $req = HTTP::Request\->new(POST => \*(Aqhttp://search.cpan.org/search\*(Aq);
\&  $req\->content_type(\*(Aqapplication/x\-www\-form\-urlencoded\*(Aq);
\&  $req\->content(\*(Aqquery=libwww\-perl&mode=dist\*(Aq);
\&
\&  # Pass request to the user agent and get a response back
\&  my $res = $ua\->request($req);
\&
\&  # Check the outcome of the response
\&  if ($res\->is_success) {
\&      print $res\->content;
\&  }
\&  else {
\&      print $res\->status_line, "\en";
\&  }
.Ve
.PP
The \f(CW$ua\fR is created once when the application starts up.  New request
objects should normally created for each request sent.
.SH "NETWORK SUPPORT"
.IX Header "NETWORK SUPPORT"
This section discusses the various protocol schemes and
the \s-1HTTP\s0 style methods that headers may be used for each.
.PP
For all requests, a \*(L"User-Agent\*(R" header is added and initialized from
the \f(CW$ua\fR\->agent attribute before the request is handed to the network
layer.  In the same way, a \*(L"From\*(R" header is initialized from the
\&\f(CW$ua\fR\->from attribute.
.PP
For all responses, the library adds a header called \*(L"Client-Date\*(R".
This header holds the time when the response was received by
your application.  The format and semantics of the header are the
same as the server created \*(L"Date\*(R" header.  You may also encounter other
\&\*(L"Client-XXX\*(R" headers.  They are all generated by the library
internally and are not received from the servers.
.SS "\s-1HTTP\s0 Requests"
.IX Subsection "HTTP Requests"
\&\s-1HTTP\s0 requests are just handed off to an \s-1HTTP\s0 server and it
decides what happens.  Few servers implement methods beside the usual
\&\*(L"\s-1GET\*(R", \*(L"HEAD\*(R", \*(L"POST\*(R"\s0 and \*(L"\s-1PUT\*(R",\s0 but CGI-scripts may implement
any method they like.
.PP
If the server is not available then the library will generate an
internal error response.
.PP
The library automatically adds a \*(L"Host\*(R" and a \*(L"Content-Length\*(R" header
to the \s-1HTTP\s0 request before it is sent over the network.
.PP
For a \s-1GET\s0 request you might want to add a \*(L"If-Modified-Since\*(R" or
\&\*(L"If-None-Match\*(R" header to make the request conditional.
.PP
For a \s-1POST\s0 request you should add the \*(L"Content-Type\*(R" header.  When you
try to emulate \s-1HTML\s0 <\s-1FORM\s0> handling you should usually let the value
of the \*(L"Content-Type\*(R" header be \*(L"application/x\-www\-form\-urlencoded\*(R".
See lwpcook for examples of this.
.PP
The libwww-perl \s-1HTTP\s0 implementation currently support the \s-1HTTP/1.1\s0
and \s-1HTTP/1.0\s0 protocol.
.PP
The library allows you to access proxy server through \s-1HTTP. \s0 This
means that you can set up the library to forward all types of request
through the \s-1HTTP\s0 protocol module.  See LWP::UserAgent for
documentation of this.
.SS "\s-1HTTPS\s0 Requests"
.IX Subsection "HTTPS Requests"
\&\s-1HTTPS\s0 requests are \s-1HTTP\s0 requests over an encrypted network connection
using the \s-1SSL\s0 protocol developed by Netscape.  Everything about \s-1HTTP\s0
requests above also apply to \s-1HTTPS\s0 requests.  In addition the library
will add the headers \*(L"Client-SSL-Cipher\*(R", \*(L"Client-SSL-Cert-Subject\*(R" and
\&\*(L"Client-SSL-Cert-Issuer\*(R" to the response.  These headers denote the
encryption method used and the name of the server owner.
.PP
The request can contain the header \*(L"If-SSL-Cert-Subject\*(R" in order to
make the request conditional on the content of the server certificate.
If the certificate subject does not match, no request is sent to the
server and an internally generated error response is returned.  The
value of the \*(L"If-SSL-Cert-Subject\*(R" header is interpreted as a Perl
regular expression.
.SS "\s-1FTP\s0 Requests"
.IX Subsection "FTP Requests"
The library currently supports \s-1GET, HEAD\s0 and \s-1PUT\s0 requests.  \s-1GET\s0
retrieves a file or a directory listing from an \s-1FTP\s0 server.  \s-1PUT\s0
stores a file on a ftp server.
.PP
You can specify a ftp account for servers that want this in addition
to user name and password.  This is specified by including an \*(L"Account\*(R"
header in the request.
.PP
User name/password can be specified using basic authorization or be
encoded in the \s-1URL. \s0 Failed logins return an \s-1UNAUTHORIZED\s0 response with
\&\*(L"WWW-Authenticate: Basic\*(R" and can be treated like basic authorization
for \s-1HTTP.\s0
.PP
The library supports ftp \s-1ASCII\s0 transfer mode by specifying the \*(L"type=a\*(R"
parameter in the \s-1URL.\s0 It also supports transfer of ranges for \s-1FTP\s0 transfers
using the \*(L"Range\*(R" header.
.PP
Directory listings are by default returned unprocessed (as returned
from the ftp server) with the content media type reported to be
\&\*(L"text/ftp\-dir\-listing\*(R". The \f(CW\*(C`File::Listing\*(C'\fR module provides methods
for parsing of these directory listing.
.PP
The ftp module is also able to convert directory listings to \s-1HTML\s0 and
this can be requested via the standard \s-1HTTP\s0 content negotiation
mechanisms (add an \*(L"Accept: text/html\*(R" header in the request if you
want this).
.PP
For normal file retrievals, the \*(L"Content-Type\*(R" is guessed based on the
file name suffix. See LWP::MediaTypes.
.PP
The \*(L"If-Modified-Since\*(R" request header works for servers that implement
the \s-1MDTM\s0 command.  It will probably not work for directory listings though.
.PP
Example:
.PP
.Vb 2
\&  $req = HTTP::Request\->new(GET => \*(Aqftp://me:passwd@ftp.some.where.com/\*(Aq);
\&  $req\->header(Accept => "text/html, */*;q=0.1");
.Ve
.SS "News Requests"
.IX Subsection "News Requests"
Access to the \s-1USENET\s0 News system is implemented through the \s-1NNTP\s0
protocol.  The name of the news server is obtained from the
\&\s-1NNTP_SERVER\s0 environment variable and defaults to \*(L"news\*(R".  It is not
possible to specify the hostname of the \s-1NNTP\s0 server in news: URLs.
.PP
The library supports \s-1GET\s0 and \s-1HEAD\s0 to retrieve news articles through the
\&\s-1NNTP\s0 protocol.  You can also post articles to newsgroups by using
(surprise!) the \s-1POST\s0 method.
.PP
\&\s-1GET\s0 on newsgroups is not implemented yet.
.PP
Examples:
.PP
.Vb 1
\&  $req = HTTP::Request\->new(GET => \*(Aqnews:abc1234@a.sn.no\*(Aq);
\&
\&  $req = HTTP::Request\->new(POST => \*(Aqnews:comp.lang.perl.test\*(Aq);
\&  $req\->header(Subject => \*(AqThis is a test\*(Aq,
\&               From    => \*(Aqme@some.where.org\*(Aq);
\&  $req\->content(<<EOT);
\&  This is the content of the message that we are sending to
\&  the world.
\&  EOT
.Ve
.SS "Gopher Request"
.IX Subsection "Gopher Request"
The library supports the \s-1GET\s0 and \s-1HEAD\s0 methods for gopher requests.  All
request header values are ignored.  \s-1HEAD\s0 cheats and returns a
response without even talking to server.
.PP
Gopher menus are always converted to \s-1HTML.\s0
.PP
The response \*(L"Content-Type\*(R" is generated from the document type
encoded (as the first letter) in the request \s-1URL\s0 path itself.
.PP
Example:
.PP
.Vb 1
\&  $req = HTTP::Request\->new(GET => \*(Aqgopher://gopher.sn.no/\*(Aq);
.Ve
.SS "File Request"
.IX Subsection "File Request"
The library supports \s-1GET\s0 and \s-1HEAD\s0 methods for file requests.  The
\&\*(L"If-Modified-Since\*(R" header is supported.  All other headers are
ignored.  The \fIhost\fR component of the file \s-1URL\s0 must be empty or set
to \*(L"localhost\*(R".  Any other \fIhost\fR value will be treated as an error.
.PP
Directories are always converted to an \s-1HTML\s0 document.  For normal
files, the \*(L"Content-Type\*(R" and \*(L"Content-Encoding\*(R" in the response are
guessed based on the file suffix.
.PP
Example:
.PP
.Vb 1
\&  $req = HTTP::Request\->new(GET => \*(Aqfile:/etc/passwd\*(Aq);
.Ve
.SS "Mailto Request"
.IX Subsection "Mailto Request"
You can send (aka \*(L"\s-1POST\*(R"\s0) mail messages using the library.  All
headers specified for the request are passed on to the mail system.
The \*(L"To\*(R" header is initialized from the mail address in the \s-1URL.\s0
.PP
Example:
.PP
.Vb 3
\&  $req = HTTP::Request\->new(POST => \*(Aqmailto:libwww@perl.org\*(Aq);
\&  $req\->header(Subject => "subscribe");
\&  $req\->content("Please subscribe me to the libwww\-perl mailing list!\en");
.Ve
.SS "\s-1CPAN\s0 Requests"
.IX Subsection "CPAN Requests"
URLs with scheme \f(CW\*(C`cpan:\*(C'\fR are redirected to the a suitable \s-1CPAN\s0
mirror.  If you have your own local mirror of \s-1CPAN\s0 you might tell \s-1LWP\s0
to use it for \f(CW\*(C`cpan:\*(C'\fR URLs by an assignment like this:
.PP
.Vb 1
\&  $LWP::Protocol::cpan::CPAN = "file:/local/CPAN/";
.Ve
.PP
Suitable \s-1CPAN\s0 mirrors are also picked up from the configuration for
the \s-1CPAN\s0.pm, so if you have used that module a suitable mirror should
be picked automatically.  If neither of these apply, then a redirect
to the generic \s-1CPAN\s0 http location is issued.
.PP
Example request to download the newest perl:
.PP
.Vb 1
\&  $req = HTTP::Request\->new(GET => "cpan:src/latest.tar.gz");
.Ve
.SH "OVERVIEW OF CLASSES AND PACKAGES"
.IX Header "OVERVIEW OF CLASSES AND PACKAGES"
This table should give you a quick overview of the classes provided by the
library. Indentation shows class inheritance.
.PP
.Vb 8
\& LWP::MemberMixin   \-\- Access to member variables of Perl5 classes
\&   LWP::UserAgent   \-\- WWW user agent class
\&     LWP::RobotUA   \-\- When developing a robot applications
\&   LWP::Protocol          \-\- Interface to various protocol schemes
\&     LWP::Protocol::http  \-\- http:// access
\&     LWP::Protocol::file  \-\- file:// access
\&     LWP::Protocol::ftp   \-\- ftp:// access
\&     ...
\&
\& LWP::Authen::Basic \-\- Handle 401 and 407 responses
\& LWP::Authen::Digest
\&
\& HTTP::Headers      \-\- MIME/RFC822 style header (used by HTTP::Message)
\& HTTP::Message      \-\- HTTP style message
\&   HTTP::Request    \-\- HTTP request
\&   HTTP::Response   \-\- HTTP response
\& HTTP::Daemon       \-\- A HTTP server class
\&
\& WWW::RobotRules    \-\- Parse robots.txt files
\&   WWW::RobotRules::AnyDBM_File \-\- Persistent RobotRules
\&
\& Net::HTTP          \-\- Low level HTTP client
.Ve
.PP
The following modules provide various functions and definitions.
.PP
.Vb 8
\& LWP                \-\- This file.  Library version number and documentation.
\& LWP::MediaTypes    \-\- MIME types configuration (text/html etc.)
\& LWP::Simple        \-\- Simplified procedural interface for common functions
\& HTTP::Status       \-\- HTTP status code (200 OK etc)
\& HTTP::Date         \-\- Date parsing module for HTTP date formats
\& HTTP::Negotiate    \-\- HTTP content negotiation calculation
\& File::Listing      \-\- Parse directory listings
\& HTML::Form         \-\- Processing for <form>s in HTML documents
.Ve
.SH "MORE DOCUMENTATION"
.IX Header "MORE DOCUMENTATION"
All modules contain detailed information on the interfaces they
provide.  The lwpcook manpage is the libwww-perl cookbook that contain
examples of typical usage of the library.  You might want to take a
look at how the scripts lwp-request, lwp-download, lwp-dump
and lwp-mirror are implemented.
.SH "ENVIRONMENT"
.IX Header "ENVIRONMENT"
The following environment variables are used by \s-1LWP:\s0
.IP "\s-1HOME\s0" 4
.IX Item "HOME"
The \f(CW\*(C`LWP::MediaTypes\*(C'\fR functions will look for the \fI.media.types\fR and
\&\fI.mime.types\fR files relative to you home directory.
.IP "http_proxy" 4
.IX Item "http_proxy"
.PD 0
.IP "ftp_proxy" 4
.IX Item "ftp_proxy"
.IP "xxx_proxy" 4
.IX Item "xxx_proxy"
.IP "no_proxy" 4
.IX Item "no_proxy"
.PD
These environment variables can be set to enable communication through
a proxy server.  See the description of the \f(CW\*(C`env_proxy\*(C'\fR method in
LWP::UserAgent.
.IP "\s-1PERL_LWP_ENV_PROXY\s0" 4
.IX Item "PERL_LWP_ENV_PROXY"
If set to a \s-1TRUE\s0 value, then the \f(CW\*(C`LWP::UserAgent\*(C'\fR will by default call
\&\f(CW\*(C`env_proxy\*(C'\fR during initialization.  This makes \s-1LWP\s0 honor the proxy variables
described above.
.IP "\s-1PERL_LWP_SSL_VERIFY_HOSTNAME\s0" 4
.IX Item "PERL_LWP_SSL_VERIFY_HOSTNAME"
The default \f(CW\*(C`verify_hostname\*(C'\fR setting for \f(CW\*(C`LWP::UserAgent\*(C'\fR.  If
not set the default will be 1.  Set it as 0 to disable hostname
verification (the default prior to libwww-perl 5.840.
.IP "\s-1PERL_LWP_SSL_CA_FILE\s0" 4
.IX Item "PERL_LWP_SSL_CA_FILE"
.PD 0
.IP "\s-1PERL_LWP_SSL_CA_PATH\s0" 4
.IX Item "PERL_LWP_SSL_CA_PATH"
.PD
The file and/or directory
where the trusted Certificate Authority certificates
is located.  See LWP::UserAgent for details.
.IP "\s-1PERL_HTTP_URI_CLASS\s0" 4
.IX Item "PERL_HTTP_URI_CLASS"
Used to decide what \s-1URI\s0 objects to instantiate.  The default is \f(CW\*(C`URI\*(C'\fR.
You might want to set it to \f(CW\*(C`URI::URL\*(C'\fR for compatibility with old times.
.SH "AUTHORS"
.IX Header "AUTHORS"
\&\s-1LWP\s0 was made possible by contributions from Adam Newby, Albert
Dvornik, Alexandre Duret-Lutz, Andreas Gustafsson, Andreas Ko\*:nig,
Andrew Pimlott, Andy Lester, Ben Coleman, Benjamin Low, Ben Low, Ben
Tilly, Blair Zajac, Bob Dalgleish, BooK, Brad Hughes, Brian
J. Murrell, Brian McCauley, Charles C. Fu, Charles Lane, Chris Nandor,
Christian Gilmore, Chris W. Unger, Craig Macdonald, Dale Couch, Dan
Kubb, Dave Dunkin, Dave W. Smith, David Coppit, David Dick, David
D. Kilzer, Doug MacEachern, Edward Avis, erik, Gary Shea, Gisle Aas,
Graham Barr, Gurusamy Sarathy, Hans de Graaff, Harald Joerg, Harry
Bochner, Hugo, Ilya Zakharevich, \s-1INOUE\s0 Yoshinari, Ivan Panchenko, Jack
Shirazi, James Tillman, Jan Dubois, Jared Rhine, Jim Stern, Joao
Lopes, John Klar, Johnny Lee, Josh Kronengold, Josh Rai, Joshua
Chamas, Joshua Hoblitt, Kartik Subbarao, Keiichiro Nagano, Ken
Williams, \s-1KONISHI\s0 Katsuhiro, Lee T Lindley, Liam Quinn, Marc Hedlund,
Marc Langheinrich, Mark D. Anderson, Marko Asplund, Mark Stosberg,
Markus B Kru\*:ger, Markus Laker, Martijn Koster, Martin Thurn, Matthew
Eldridge, Matthew.van.Eerde, Matt Sergeant, Michael A. Chase, Michael
Quaranta, Michael Thompson, Mike Schilli, Moshe Kaminsky, Nathan
Torkington, Nicolai Langfeldt, Norton Allen, Olly Betts, Paul
J. Schinder, peterm, Philip GuentherDaniel Buenzli, Pon Hwa Lin,
Radoslaw Zielinski, Radu Greab, Randal L. Schwartz, Richard Chen,
Robin Barker, Roy Fielding, Sander van Zoest, Sean M. Burke,
shildreth, Slaven Rezic, Steve A Fink, Steve Hay, Steven Butler,
Steve_Kilbane, Takanori Ugai, Thomas Lotterer, Tim Bunce, Tom Hughes,
Tony Finch, Ville Skytta\*:, Ward Vandewege, William York, Yale Huang,
and Yitzchak Scott-Thoennes.
.PP
\&\s-1LWP\s0 owes a lot in motivation, design, and code, to the libwww-perl
library for Perl4 by Roy Fielding, which included work from Alberto
Accomazzi, James Casey, Brooks Cutter, Martijn Koster, Oscar
Nierstrasz, Mel Melchner, Gertjan van Oosten, Jared Rhine, Jack
Shirazi, Gene Spafford, Marc VanHeyningen, Steven E. Brenner, Marion
Hakanson, Waldemar Kebsch, Tony Sanders, and Larry Wall; see the
libwww\-perl\-0.40 library for details.
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
.Vb 2
\&  Copyright 1995\-2009, Gisle Aas
\&  Copyright 1995, Martijn Koster
.Ve
.PP
This library is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.
.SH "AVAILABILITY"
.IX Header "AVAILABILITY"
The latest version of this library is likely to be available from \s-1CPAN\s0
as well as:
.PP
.Vb 1
\&  http://github.com/libwww\-perl/libwww\-perl
.Ve
.PP
The best place to discuss this code is on the <libwww@perl.org>
mailing list.
