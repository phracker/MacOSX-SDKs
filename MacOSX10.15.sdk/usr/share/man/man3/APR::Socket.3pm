.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "install::TempContent::Objects::mod_perl-2.0.9::docs::api::APR::Socket 3"
.TH install::TempContent::Objects::mod_perl-2.0.9::docs::api::APR::Socket 3 "2015-06-18" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
APR::Socket \- Perl API for APR sockets
.SH "Synopsis"
.IX Header "Synopsis"
.Vb 1
\&  use APR::Socket ();
\&  
\&  ### set the socket to the blocking mode if it isn\*(Aqt already
\&  ### and read in the loop and echo it back
\&  use APR::Const \-compile => qw(SO_NONBLOCK);
\&  if ($sock\->opt_get(APR::Const::SO_NONBLOCK)) {
\&      $sock\->opt_set(APR::Const::SO_NONBLOCK => 0);
\&  }
\&  # read from/write to the socket (w/o handling possible failures)
\&  my $wanted = 1024;
\&  while ($sock\->recv(my $buff, $wanted)) {
\&      $sock\->send($buff);
\&  }
\&
\&  ### get/set IO timeout and try to read some data
\&  use APR::Const \-compile => qw(TIMEUP);
\&  # timeout is in usecs!
\&  my $timeout = $sock\->timeout_get();
\&  if ($timeout < 10_000_000) {
\&      $sock\->timeout_set(20_000_000); # 20 secs
\&  }
\&  # now read, while handling timeouts
\&  my $wanted = 1024;
\&  my $buff;
\&  my $rlen = eval { $sock\->recv($buff, $wanted) };
\&  if ($@ && ref $@ && $@ == APR::Const::TIMEUP) {
\&      # timeout, do something, e.g.
\&      warn "timed out, will try again later";
\&  }
\&  else {
\&      warn "asked for $wanted bytes, read $rlen bytes\en";
\&      # do something with the data
\&  }
\&
\&  # non\-blocking io poll
\&  $sock\->opt_set(APR::Const::SO_NONBLOCK => 1);
\&  my $rc = $sock\->poll($c\->pool, 1_000_000, APR::Const::POLLIN);
\&  if ($rc == APR::Const::SUCCESS) {
\&      # read the data
\&  }
\&  else {
\&      # handle the condition
\&  }
\&
\&  # fetch the operating level socket
\&  my $fd=$sock\->fileno;
.Ve
.SH "Description"
.IX Header "Description"
\&\f(CW\*(C`APR::Socket\*(C'\fR provides the Perl interface to \s-1APR\s0 sockets.
.SH "API"
.IX Header "API"
\&\f(CW\*(C`APR::Socket\*(C'\fR provides the following methods:
.ie n .SS """fileno"""
.el .SS "\f(CWfileno\fP"
.IX Subsection "fileno"
Get the operating system socket, the file descriptor on \s-1UNIX.\s0
.PP
.Vb 1
\&  $fd = $sock\->fileno;
.Ve
.ie n .IP "obj: $sock ( ""APR::Socket object"" )" 4
.el .IP "obj: \f(CW$sock\fR ( \f(CWAPR::Socket object\fR )" 4
.IX Item "obj: $sock ( APR::Socket object )"
The socket
.ie n .IP "ret: $fd ( integer )" 4
.el .IP "ret: \f(CW$fd\fR ( integer )" 4
.IX Item "ret: $fd ( integer )"
The OS-level file descriptor.
.IP "since: 2.0.5 (not implemented on Windows)" 4
.IX Item "since: 2.0.5 (not implemented on Windows)"
.ie n .SS """opt_get"""
.el .SS "\f(CWopt_get\fP"
.IX Subsection "opt_get"
Query socket options for the specified socket
.PP
.Vb 1
\&  $val = $sock\->opt_get($opt);
.Ve
.ie n .IP "obj: $sock ( ""APR::Socket object"" )" 4
.el .IP "obj: \f(CW$sock\fR ( \f(CWAPR::Socket object\fR )" 4
.IX Item "obj: $sock ( APR::Socket object )"
the socket object to query
.ie n .IP "arg1: $opt ( ""APR::Const constant"" )" 4
.el .IP "arg1: \f(CW$opt\fR ( \f(CWAPR::Const constant\fR )" 4
.IX Item "arg1: $opt ( APR::Const constant )"
the socket option we would like to configure.  Here are the
available socket options.
.ie n .IP "ret: $val ( integer )" 4
.el .IP "ret: \f(CW$val\fR ( integer )" 4
.IX Item "ret: $val ( integer )"
the currently set value for the socket
option you've queried for
.ie n .IP "excpt: ""APR::Error""" 4
.el .IP "excpt: \f(CWAPR::Error\fR" 4
.IX Item "excpt: APR::Error"
.PD 0
.IP "since: 2.0.00" 4
.IX Item "since: 2.0.00"
.PD
.PP
Examples can be found in the socket options constants
section. For example setting 
the \s-1IO\s0 to the blocking
mode.
.ie n .SS """opt_set"""
.el .SS "\f(CWopt_set\fP"
.IX Subsection "opt_set"
Setup socket options for the specified socket
.PP
.Vb 1
\&  $sock\->opt_set($opt, $val);
.Ve
.ie n .IP "obj: $sock ( ""APR::Socket object"" object )" 4
.el .IP "obj: \f(CW$sock\fR ( \f(CWAPR::Socket object\fR object )" 4
.IX Item "obj: $sock ( APR::Socket object object )"
the socket object to set up.
.ie n .IP "arg1: $opt ( ""APR::Const"" constant )" 4
.el .IP "arg1: \f(CW$opt\fR ( \f(CWAPR::Const\fR constant )" 4
.IX Item "arg1: $opt ( APR::Const constant )"
the socket option we would like to configure.  Here are the
available socket options.
.ie n .IP "arg2: $val ( integer )" 4
.el .IP "arg2: \f(CW$val\fR ( integer )" 4
.IX Item "arg2: $val ( integer )"
value for the option. Refer to the socket
options section to learn about
the expected values.
.IP "ret: no return value" 4
.IX Item "ret: no return value"
.PD 0
.ie n .IP "excpt: ""APR::Error""" 4
.el .IP "excpt: \f(CWAPR::Error\fR" 4
.IX Item "excpt: APR::Error"
.IP "since: 2.0.00" 4
.IX Item "since: 2.0.00"
.PD
.PP
Examples can be found in the socket options constants
section. For example setting 
the \s-1IO\s0 to the blocking
mode.
.ie n .SS """poll"""
.el .SS "\f(CWpoll\fP"
.IX Subsection "poll"
Poll the socket for events:
.PP
.Vb 1
\&    $rc = $sock\->poll($pool, $timeout, $events);
.Ve
.ie n .IP "obj: $sock ( ""APR::Socket object"" )" 4
.el .IP "obj: \f(CW$sock\fR ( \f(CWAPR::Socket object\fR )" 4
.IX Item "obj: $sock ( APR::Socket object )"
The socket to poll
.ie n .IP "arg1: $pool ( ""APR::Pool object"" )" 4
.el .IP "arg1: \f(CW$pool\fR ( \f(CWAPR::Pool object\fR )" 4
.IX Item "arg1: $pool ( APR::Pool object )"
usually \f(CW\*(C`$c\->pool\*(C'\fR.
.ie n .IP "arg2: $timeout ( integer )" 4
.el .IP "arg2: \f(CW$timeout\fR ( integer )" 4
.IX Item "arg2: $timeout ( integer )"
The amount of time to wait (in milliseconds) for the specified events
to occur.
.ie n .IP "arg3: $events ( ""APR::Const :poll constants"" )" 4
.el .IP "arg3: \f(CW$events\fR ( \f(CWAPR::Const :poll constants\fR )" 4
.IX Item "arg3: $events ( APR::Const :poll constants )"
The events for which to wait.
.Sp
For example use
\&\f(CW\*(C`APR::Const::POLLIN\*(C'\fR to wait
for incoming data to be available,
\&\f(CW\*(C`APR::Const::POLLOUT\*(C'\fR to wait
until it's possible to write data to the socket and
\&\f(CW\*(C`APR::Const::POLLPRI\*(C'\fR to wait
for priority data to become available.
.ie n .IP "ret: $rc ( ""APR::Const constant"" )" 4
.el .IP "ret: \f(CW$rc\fR ( \f(CWAPR::Const constant\fR )" 4
.IX Item "ret: $rc ( APR::Const constant )"
If \f(CW\*(C`APR::Const::SUCCESS\*(C'\fR is received than the polling was successful. If not
\&\*(-- the error code is returned, which can be converted to the error
string with help of
\&\f(CW\*(C`APR::Error::strerror\*(C'\fR.
.IP "since: 2.0.00" 4
.IX Item "since: 2.0.00"
.PP
For example poll a non-blocking socket up to 1 second when reading
data from the client:
.PP
.Vb 3
\&  use APR::Socket ();
\&  use APR::Connection ();
\&  use APR::Error ();
\&  
\&  use APR::Const \-compile => qw(SO_NONBLOCK POLLIN SUCCESS TIMEUP);
\&  
\&  $sock\->opt_set(APR::Const::SO_NONBLOCK => 1);
\&  
\&  my $rc = $sock\->poll($c\->pool, 1_000_000, APR::Const::POLLIN);
\&  if ($rc == APR::Const::SUCCESS) {
\&      # Data is waiting on the socket to be read.
\&      # $sock\->recv(my $buf, BUFF_LEN)
\&  }
\&  elsif ($rc == APR::Const::TIMEUP) {
\&      # One second elapsed and still there is no data waiting to be
\&      # read. for example could try again.
\&  }
\&  else {
\&      die "poll error: " . APR::Error::strerror($rc);
\&  }
.Ve
.ie n .SS """recv"""
.el .SS "\f(CWrecv\fP"
.IX Subsection "recv"
Read incoming data from the socket
.PP
.Vb 1
\&  $len = $sock\->recv($buffer, $wanted);
.Ve
.ie n .IP "obj: $sock ( ""APR::SockAddr object"" object )" 4
.el .IP "obj: \f(CW$sock\fR ( \f(CWAPR::SockAddr object\fR object )" 4
.IX Item "obj: $sock ( APR::SockAddr object object )"
The socket to read from
.ie n .IP "arg1: $buffer ( \s-1SCALAR \s0)" 4
.el .IP "arg1: \f(CW$buffer\fR ( \s-1SCALAR \s0)" 4
.IX Item "arg1: $buffer ( SCALAR )"
The buffer to fill. All previous data will be lost.
.ie n .IP "arg2: $wanted ( int )" 4
.el .IP "arg2: \f(CW$wanted\fR ( int )" 4
.IX Item "arg2: $wanted ( int )"
How many bytes to attempt to read.
.ie n .IP "ret: $len ( number )" 4
.el .IP "ret: \f(CW$len\fR ( number )" 4
.IX Item "ret: $len ( number )"
How many bytes were actually read.
.Sp
\&\f(CW$buffer\fR gets populated with the string that is read. It will
contain an empty string if there was nothing to read.
.ie n .IP "excpt: ""APR::Error""" 4
.el .IP "excpt: \f(CWAPR::Error\fR" 4
.IX Item "excpt: APR::Error"
If you get the \f(CW\*(Aq(11) Resource temporarily unavailable\*(Aq\fR error
(exception
\&\f(CW\*(C`APR::Const::EAGAIN\*(C'\fR)
(or another equivalent, which might be different on non-POSIX
systems), then you didn't ensure that the socket is in a blocking \s-1IO\s0
mode before using it. Note that you should use 
\&\f(CW\*(C`APR::Status::is_EAGAIN\*(C'\fR
to perform this check (since different error codes may be returned for
the same event on different OSes). For example if the socket is set to
the non-blocking mode and there is no data right away, you may get
this exception thrown. So here is how to check for it and retry a few
times after short delays:
.Sp
.Vb 10
\&  use APR::Status ();
\&  $sock\->opt_set(APR::Const::SO_NONBLOCK, 1);
\&  # ....
\&  my $tries = 0;
\&  my $buffer;
\&  RETRY: my $rlen = eval { $socket\->recv($buffer, SIZE) };
\&  if ($@)
\&      die $@ unless ref $@ && APR::Status::is_EAGAIN($@);
\&      if ($tries++ < 3) {
\&          # sleep 250msec
\&          select undef, undef, undef, 0.25;
\&          goto RETRY;
\&      }
\&      else {
\&          # do something else
\&      }
\&  }
\&  warn "read $rlen bytes\en"
.Ve
.Sp
If timeout was set via \f(CW\*(C`timeout_set|/C_timeout_set_\*(C'\fR, you may need to
catch the
\&\f(CW\*(C`APR::Const::TIMEUP\*(C'\fR
exception. For example:
.Sp
.Vb 7
\&  use APR::Const \-compile => qw(TIMEUP);
\&  $sock\->timeout_set(1_000_000); # 1 sec
\&  my $buffer;
\&  eval { $sock\->recv($buffer, $wanted) };
\&  if ($@ && $@ == APR::Const::TIMEUP) {
\&      # timeout, do something, e.g.
\&  }
.Ve
.Sp
If not handled \*(-- you may get the error \f(CW\*(Aq70007: The timeout
specified has expired\*(Aq\fR.
.Sp
Another error condition that may occur is the \f(CW\*(Aq(104) Connection
reset by peer\*(Aq\fR error, which is up to your application logic to decide
whether it's an error or not. This error usually happens when the
client aborts the connection.
.Sp
.Vb 6
\&  use APR::Const \-compile => qw(ECONNABORTED);
\&  my $buffer;
\&  eval { $sock\->recv($buffer, $wanted) };
\&  if ($@ == APR::Const::ECONNABORTED) {
\&      # ignore it or deal with it
\&  }
.Ve
.IP "since: 2.0.00" 4
.IX Item "since: 2.0.00"
.PP
Here is the quick prototype example, which doesn't handle any errors
(mod_perl will do that for you):
.PP
.Vb 1
\&  use APR::Socket ();
\&  
\&  # set the socket to the blocking mode if it isn\*(Aqt already
\&  use APR::Const \-compile => qw(SO_NONBLOCK);
\&  if ($sock\->opt_get(APR::Const::SO_NONBLOCK)) {
\&      $sock\->opt_set(APR::Const::SO_NONBLOCK => 0);
\&  }
\&  # read from/write to the socket (w/o handling possible failures)
\&  my $wanted = 1024;
\&  while ($sock\->recv(my $buffer, $wanted)) {
\&      $sock\->send($buffer);
\&  }
.Ve
.PP
If you want to handle errors by yourself, the loop may look like:
.PP
.Vb 10
\&  use APR::Const \-compile => qw(ECONNABORTED);
\&  # ...
\&  while (1) {
\&      my $buf;
\&      my $len = eval { $sock\->recv($buf, $wanted) };
\&      if ($@) {
\&          # handle the error, e.g. to ignore aborted connections but
\&          # rethrow any other errors:
\&          if ($@ == APR::Const::ECONNABORTED) {
\&              # ignore
\&              last;
\&          }
\&          else {
\&              die $@; # retrow
\&          }
\&      }
\&  
\&      if ($len) {
\&          $sock\->send($buffer);
\&      }
\&      else {
\&          last;
\&      }
\&  }
.Ve
.ie n .SS """send"""
.el .SS "\f(CWsend\fP"
.IX Subsection "send"
Write data to the socket
.PP
.Vb 1
\&  $wlen = $sock\->send($buf, $opt_len);
.Ve
.ie n .IP "obj: $sock ( ""APR::Socket object"" )" 4
.el .IP "obj: \f(CW$sock\fR ( \f(CWAPR::Socket object\fR )" 4
.IX Item "obj: $sock ( APR::Socket object )"
The socket to write to
.ie n .IP "arg1: $buf ( scalar )" 4
.el .IP "arg1: \f(CW$buf\fR ( scalar )" 4
.IX Item "arg1: $buf ( scalar )"
The data to send
.ie n .IP "opt arg2: $opt_len ( int )" 4
.el .IP "opt arg2: \f(CW$opt_len\fR ( int )" 4
.IX Item "opt arg2: $opt_len ( int )"
There is no need to pass this argument, unless you want to send less
data than contained in \f(CW$buf\fR.
.ie n .IP "ret: $wlen ( integer )" 4
.el .IP "ret: \f(CW$wlen\fR ( integer )" 4
.IX Item "ret: $wlen ( integer )"
How many bytes were sent
.IP "since: 2.0.00" 4
.IX Item "since: 2.0.00"
.PP
For examples see the \f(CW\*(C`recv\*(C'\fR item.
.ie n .SS """timeout_get"""
.el .SS "\f(CWtimeout_get\fP"
.IX Subsection "timeout_get"
Get socket timeout settings
.PP
.Vb 1
\&  $usecs = $sock\->timeout_get();
.Ve
.ie n .IP "obj: $sock ( ""APR::Socket object"" )" 4
.el .IP "obj: \f(CW$sock\fR ( \f(CWAPR::Socket object\fR )" 4
.IX Item "obj: $sock ( APR::Socket object )"
The socket to set up.
.ie n .IP "ret: $usecs ( number)" 4
.el .IP "ret: \f(CW$usecs\fR ( number)" 4
.IX Item "ret: $usecs ( number)"
Currently set timeout in microseconds (and also the blocking \s-1IO\s0
behavior). See (\f(CW\*(C`APR::timeout_set\*(C'\fR) for possible
values and their meaning.
.ie n .IP "excpt: ""APR::Error""" 4
.el .IP "excpt: \f(CWAPR::Error\fR" 4
.IX Item "excpt: APR::Error"
.PD 0
.IP "since: 2.0.00" 4
.IX Item "since: 2.0.00"
.PD
.ie n .SS """timeout_set"""
.el .SS "\f(CWtimeout_set\fP"
.IX Subsection "timeout_set"
Setup socket timeout.
.PP
.Vb 1
\&  $sock\->timeout_set($usecs);
.Ve
.ie n .IP "obj: $sock ( ""APR::Socket object"" )" 4
.el .IP "obj: \f(CW$sock\fR ( \f(CWAPR::Socket object\fR )" 4
.IX Item "obj: $sock ( APR::Socket object )"
The socket to set up.
.ie n .IP "arg1: $usecs ( number )" 4
.el .IP "arg1: \f(CW$usecs\fR ( number )" 4
.IX Item "arg1: $usecs ( number )"
Value for the timeout in microseconds and also the blocking \s-1IO\s0
behavior.
.Sp
The possible values are:
.RS 4
.IP "t > 0" 4
.IX Item "t > 0"
\&\f(CW\*(C`send()\*(C'\fR and \f(CW\*(C`recv()\*(C'\fR throw
(\f(CW\*(C`APR::Const::TIMEUP\*(C'\fR
exception) if specified time elapses with no data sent or received.
.Sp
Notice that the positive value is in micro seconds. So if you want to
set the timeout for 5 seconds, the value should be: 5_000_000.
.Sp
This mode sets the socket into a non-blocking \s-1IO\s0 mode.
.IP "t == 0" 4
.IX Item "t == 0"
\&\f(CW\*(C`send()\*(C'\fR and \f(CW\*(C`recv()\*(C'\fR calls never block.
.IP "t < 0" 4
.IX Item "t < 0"
\&\f(CW\*(C`send()\*(C'\fR and \f(CW\*(C`recv()\*(C'\fR calls block.
.Sp
Usually just \-1 is used for this case, but any negative value will do.
.Sp
This mode sets the socket into a blocking \s-1IO\s0 mode.
.IP "ret: no return value" 4
.IX Item "ret: no return value"
.RE
.RS 4
.RE
.PD 0
.ie n .IP "excpt: ""APR::Error""" 4
.el .IP "excpt: \f(CWAPR::Error\fR" 4
.IX Item "excpt: APR::Error"
.IP "since: 2.0.00" 4
.IX Item "since: 2.0.00"
.PD
.SH "Unsupported API"
.IX Header "Unsupported API"
\&\f(CW\*(C`APR::Socket\*(C'\fR also provides auto-generated Perl interface for a few
other methods which aren't tested at the moment and therefore their
\&\s-1API\s0 is a subject to change. These methods will be finalized later as a
need arises. If you want to rely on any of the following methods
please contact the the mod_perl development mailing
list so we can help each other take the steps necessary
to shift the method to an officially supported \s-1API.\s0
.ie n .SS """bind"""
.el .SS "\f(CWbind\fP"
.IX Subsection "bind"
\&\s-1META:\s0 Autogenerated \- needs to be reviewed/completed
.PP
Bind the socket to its associated port
.PP
.Vb 1
\&  $ret = $sock\->bind($sa);
.Ve
.ie n .IP "obj: $sock ( ""APR::Socket object"" )" 4
.el .IP "obj: \f(CW$sock\fR ( \f(CWAPR::Socket object\fR )" 4
.IX Item "obj: $sock ( APR::Socket object )"
The socket to bind
.ie n .IP "arg1: $sa ( ""APR::SockAddr object"" )" 4
.el .IP "arg1: \f(CW$sa\fR ( \f(CWAPR::SockAddr object\fR )" 4
.IX Item "arg1: $sa ( APR::SockAddr object )"
The socket address to bind to
.ie n .IP "ret: $ret ( integer )" 4
.el .IP "ret: \f(CW$ret\fR ( integer )" 4
.IX Item "ret: $ret ( integer )"
.PD 0
.IP "since: subject to change" 4
.IX Item "since: subject to change"
.PD
.PP
This may be where we will find out if there is any other process
using the selected port.
.ie n .SS """close"""
.el .SS "\f(CWclose\fP"
.IX Subsection "close"
\&\s-1META:\s0 Autogenerated \- needs to be reviewed/completed
.PP
Close a socket.
.PP
.Vb 1
\&  $ret = $sock\->close();
.Ve
.ie n .IP "obj: $sock ( ""APR::Socket object"" )" 4
.el .IP "obj: \f(CW$sock\fR ( \f(CWAPR::Socket object\fR )" 4
.IX Item "obj: $sock ( APR::Socket object )"
The socket to close
.ie n .IP "ret: $ret ( integer )" 4
.el .IP "ret: \f(CW$ret\fR ( integer )" 4
.IX Item "ret: $ret ( integer )"
.PD 0
.IP "since: subject to change" 4
.IX Item "since: subject to change"
.PD
.ie n .SS """connect"""
.el .SS "\f(CWconnect\fP"
.IX Subsection "connect"
\&\s-1META:\s0 Autogenerated \- needs to be reviewed/completed
.PP
Issue a connection request to a socket either on the same machine
or a different one.
.PP
.Vb 1
\&  $ret = $sock\->connect($sa);
.Ve
.ie n .IP "obj: $sock ( ""APR::Socket object"" )" 4
.el .IP "obj: \f(CW$sock\fR ( \f(CWAPR::Socket object\fR )" 4
.IX Item "obj: $sock ( APR::Socket object )"
The socket we wish to use for our side of the connection
.ie n .IP "arg1: $sa ( ""APR::SockAddr object"" )" 4
.el .IP "arg1: \f(CW$sa\fR ( \f(CWAPR::SockAddr object\fR )" 4
.IX Item "arg1: $sa ( APR::SockAddr object )"
The address of the machine we wish to connect to.  If \s-1NULL,
APR\s0 assumes that the sockaddr_in in the apr_socket is
completely filled out.
.ie n .IP "ret: $ret ( integer )" 4
.el .IP "ret: \f(CW$ret\fR ( integer )" 4
.IX Item "ret: $ret ( integer )"
.PD 0
.IP "since: subject to change" 4
.IX Item "since: subject to change"
.PD
.ie n .SS """listen"""
.el .SS "\f(CWlisten\fP"
.IX Subsection "listen"
\&\s-1META:\s0 Autogenerated \- needs to be reviewed/completed
.PP
Listen to a bound socket for connections.
.PP
.Vb 1
\&  $ret = $sock\->listen($backlog);
.Ve
.ie n .IP "obj: $sock ( ""APR::Socket object"" )" 4
.el .IP "obj: \f(CW$sock\fR ( \f(CWAPR::Socket object\fR )" 4
.IX Item "obj: $sock ( APR::Socket object )"
The socket to listen on
.ie n .IP "arg1: $backlog ( integer )" 4
.el .IP "arg1: \f(CW$backlog\fR ( integer )" 4
.IX Item "arg1: $backlog ( integer )"
The number of outstanding connections allowed in the sockets
listen queue.  If this value is less than zero, the listen
queue size is set to zero.
.ie n .IP "ret: $ret ( integer )" 4
.el .IP "ret: \f(CW$ret\fR ( integer )" 4
.IX Item "ret: $ret ( integer )"
.PD 0
.IP "since: subject to change" 4
.IX Item "since: subject to change"
.PD
.ie n .SS """recvfrom"""
.el .SS "\f(CWrecvfrom\fP"
.IX Subsection "recvfrom"
\&\s-1META:\s0 Autogenerated \- needs to be reviewed/completed
.PP
.Vb 1
\&  $ret = $from\->recvfrom($sock, $flags, $buf, $len);
.Ve
.ie n .IP "obj: $from ( ""APR::SockAddr object"" )" 4
.el .IP "obj: \f(CW$from\fR ( \f(CWAPR::SockAddr object\fR )" 4
.IX Item "obj: $from ( APR::SockAddr object )"
The apr_sockaddr_t to fill in the recipient info
.ie n .IP "arg1: $sock ( ""APR::SockAddr object"" )" 4
.el .IP "arg1: \f(CW$sock\fR ( \f(CWAPR::SockAddr object\fR )" 4
.IX Item "arg1: $sock ( APR::SockAddr object )"
The socket to use
.ie n .IP "arg2: $flags ( integer )" 4
.el .IP "arg2: \f(CW$flags\fR ( integer )" 4
.IX Item "arg2: $flags ( integer )"
The flags to use
.ie n .IP "arg3: $buf ( integer )" 4
.el .IP "arg3: \f(CW$buf\fR ( integer )" 4
.IX Item "arg3: $buf ( integer )"
The buffer to use
.ie n .IP "arg4: $len ( string )" 4
.el .IP "arg4: \f(CW$len\fR ( string )" 4
.IX Item "arg4: $len ( string )"
The length of the available buffer
.ie n .IP "ret: $ret ( integer )" 4
.el .IP "ret: \f(CW$ret\fR ( integer )" 4
.IX Item "ret: $ret ( integer )"
.PD 0
.IP "since: subject to change" 4
.IX Item "since: subject to change"
.PD
.ie n .SS """sendto"""
.el .SS "\f(CWsendto\fP"
.IX Subsection "sendto"
\&\s-1META:\s0 Autogenerated \- needs to be reviewed/completed
.PP
.Vb 1
\&  $ret = $sock\->sendto($where, $flags, $buf, $len);
.Ve
.ie n .IP "obj: $sock ( ""APR::Socket object"" )" 4
.el .IP "obj: \f(CW$sock\fR ( \f(CWAPR::Socket object\fR )" 4
.IX Item "obj: $sock ( APR::Socket object )"
The socket to send from
.ie n .IP "arg1: $where ( ""APR::Socket object"" )" 4
.el .IP "arg1: \f(CW$where\fR ( \f(CWAPR::Socket object\fR )" 4
.IX Item "arg1: $where ( APR::Socket object )"
The apr_sockaddr_t describing where to send the data
.ie n .IP "arg2: $flags ( integer )" 4
.el .IP "arg2: \f(CW$flags\fR ( integer )" 4
.IX Item "arg2: $flags ( integer )"
The flags to use
.ie n .IP "arg3: $buf ( scalar )" 4
.el .IP "arg3: \f(CW$buf\fR ( scalar )" 4
.IX Item "arg3: $buf ( scalar )"
The data to send
.ie n .IP "arg4: $len ( string )" 4
.el .IP "arg4: \f(CW$len\fR ( string )" 4
.IX Item "arg4: $len ( string )"
The length of the data to send
.ie n .IP "ret: $ret ( integer )" 4
.el .IP "ret: \f(CW$ret\fR ( integer )" 4
.IX Item "ret: $ret ( integer )"
.PD 0
.IP "since: subject to change" 4
.IX Item "since: subject to change"
.PD
.SH "See Also"
.IX Header "See Also"
mod_perl 2.0 documentation.
.SH "Copyright"
.IX Header "Copyright"
mod_perl 2.0 and its core modules are copyrighted under
The Apache Software License, Version 2.0.
.SH "Authors"
.IX Header "Authors"
The mod_perl development team and numerous
contributors.
