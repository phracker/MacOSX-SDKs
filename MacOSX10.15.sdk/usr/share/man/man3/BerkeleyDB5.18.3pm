.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "BerkeleyDB 3"
.TH BerkeleyDB 3 "2013-08-14" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
BerkeleyDB \- Perl extension for Berkeley DB version 2, 3, 4 or 5
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use BerkeleyDB;
\&
\&  $env = new BerkeleyDB::Env [OPTIONS] ;
\&
\&  $db  = tie %hash, \*(AqBerkeleyDB::Hash\*(Aq, [OPTIONS] ;
\&  $db  = new BerkeleyDB::Hash [OPTIONS] ;
\&
\&  $db  = tie %hash, \*(AqBerkeleyDB::Btree\*(Aq, [OPTIONS] ;
\&  $db  = new BerkeleyDB::Btree [OPTIONS] ;
\&
\&  $db  = tie @array, \*(AqBerkeleyDB::Recno\*(Aq, [OPTIONS] ;
\&  $db  = new BerkeleyDB::Recno [OPTIONS] ;
\&
\&  $db  = tie @array, \*(AqBerkeleyDB::Queue\*(Aq, [OPTIONS] ;
\&  $db  = new BerkeleyDB::Queue [OPTIONS] ;
\&
\&  $db  = new BerkeleyDB::Heap [OPTIONS] ;
\&
\&  $db  = new BerkeleyDB::Unknown [OPTIONS] ;
\&
\&  $status = BerkeleyDB::db_remove [OPTIONS]
\&  $status = BerkeleyDB::db_rename [OPTIONS]
\&  $status = BerkeleyDB::db_verify [OPTIONS]
\&
\&  $hash{$key} = $value ;
\&  $value = $hash{$key} ;
\&  each %hash ;
\&  keys %hash ;
\&  values %hash ;
\&
\&  $env = $db\->Env()
\&  $status = $db\->db_get()
\&  $status = $db\->db_exists() ;
\&  $status = $db\->db_put() ;
\&  $status = $db\->db_del() ;
\&  $status = $db\->db_sync() ;
\&  $status = $db\->db_close() ;
\&  $status = $db\->db_pget()
\&  $hash_ref = $db\->db_stat() ;
\&  $status = $db\->db_key_range();
\&  $type = $db\->type() ;
\&  $status = $db\->status() ;
\&  $boolean = $db\->byteswapped() ;
\&  $status = $db\->truncate($count) ;
\&  $status = $db\->compact($start, $stop, $c_data, $flags, $end);
\&  $status = $db\->get_blob_threshold($t1) ;
\&  $status = $db\->get_blob_dir($dir) ;
\&
\&  $bool = $env\->cds_enabled();
\&  $bool = $db\->cds_enabled();
\&  $lock = $db\->cds_lock();
\&  $lock\->cds_unlock();
\&  
\&  ($flag, $old_offset, $old_length) = $db\->partial_set($offset, $length) ;
\&  ($flag, $old_offset, $old_length) = $db\->partial_clear() ;
\&
\&  $cursor = $db\->db_cursor([$flags]) ;
\&  $newcursor = $cursor\->c_dup([$flags]);
\&  $status = $cursor\->c_get() ;
\&  $status = $cursor\->c_put() ;
\&  $status = $cursor\->c_del() ;
\&  $status = $cursor\->c_count() ;
\&  $status = $cursor\->c_pget() ;
\&  $status = $cursor\->status() ;
\&  $status = $cursor\->c_close() ;
\&  $stream = $cursor\->db_stream() ;
\&
\&  $cursor = $db\->db_join() ;
\&  $status = $cursor\->c_get() ;
\&  $status = $cursor\->c_close() ;
\&
\&  $status = $stream\->size($S);
\&  $status = $stream\->read($data, $offset, $size);
\&  $status = $stream\->write($data, $offset);
\&
\&  $status = $env\->txn_checkpoint()
\&  $hash_ref = $env\->txn_stat()
\&  $status = $env\->set_mutexlocks()
\&  $status = $env\->set_flags()
\&  $status = $env\->set_timeout()
\&  $status = $env\->lock_detect()
\&  $status = $env\->lsn_reset()
\&  $status = $env\->get_blob_threshold($t1) ;
\&  $status = $env\->get_blob_dir($dir) ;
\&
\&  $txn = $env\->txn_begin() ;
\&  $db\->Txn($txn);
\&  $txn\->Txn($db1, $db2,...);
\&  $status = $txn\->txn_prepare()
\&  $status = $txn\->txn_commit()
\&  $status = $txn\->txn_abort()
\&  $status = $txn\->txn_id()
\&  $status = $txn\->txn_discard()
\&  $status = $txn\->set_timeout()
\&
\&  $status = $env\->set_lg_dir();
\&  $status = $env\->set_lg_bsize();
\&  $status = $env\->set_lg_max();
\&
\&  $status = $env\->set_data_dir() ;
\&  $status = $env\->set_tmp_dir() ;
\&  $status = $env\->set_verbose() ;
\&  $db_env_ptr = $env\->DB_ENV() ;
\&
\&  $BerkeleyDB::Error
\&  $BerkeleyDB::db_version
\&
\&  # DBM Filters
\&  $old_filter = $db\->filter_store_key  ( sub { ... } ) ;
\&  $old_filter = $db\->filter_store_value( sub { ... } ) ;
\&  $old_filter = $db\->filter_fetch_key  ( sub { ... } ) ;
\&  $old_filter = $db\->filter_fetch_value( sub { ... } ) ;
\&
\&  # deprecated, but supported
\&  $txn_mgr = $env\->TxnMgr();
\&  $status = $txn_mgr\->txn_checkpoint()
\&  $hash_ref = $txn_mgr\->txn_stat()
\&  $txn = $txn_mgr\->txn_begin() ;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\fB\s-1NOTE:\s0 This document is still under construction. Expect it to be
incomplete in places.\fR
.PP
This Perl module provides an interface to most of the functionality
available in Berkeley \s-1DB\s0 versions 2, 3, 5 and 6. In general it is safe to assume
that the interface provided here to be identical to the Berkeley \s-1DB\s0
interface. The main changes have been to make the Berkeley \s-1DB API\s0 work
in a Perl way. Note that if you are using Berkeley \s-1DB 2\s0.x, the new
features available in Berkeley \s-1DB 3\s0.x or later are not available via
this module.
.PP
The reader is expected to be familiar with the Berkeley \s-1DB\s0
documentation. Where the interface provided here is identical to the
Berkeley \s-1DB\s0 library and the... \s-1TODO\s0
.PP
The \fBdb_appinit\fR, \fBdb_cursor\fR, \fBdb_open\fR and \fBdb_txn\fR man pages are
particularly relevant.
.PP
The interface to Berkeley \s-1DB\s0 is implemented with a number of Perl
classes.
.SH "The BerkeleyDB::Env Class"
.IX Header "The BerkeleyDB::Env Class"
The \fBBerkeleyDB::Env\fR class provides an interface to the Berkeley \s-1DB\s0
function \fBdb_appinit\fR in Berkeley \s-1DB 2\s0.x or \fBdb_env_create\fR and
\&\fB\s-1DBENV\-\s0>open\fR in Berkeley \s-1DB 3\s0.x (or later). Its purpose is to initialise a
number of sub-systems that can then be used in a consistent way in all
the databases you make use of in the environment.
.PP
If you don't intend using transactions, locking or logging, then you
shouldn't need to make use of \fBBerkeleyDB::Env\fR.
.PP
Note that an environment consists of a number of files that Berkeley \s-1DB\s0
manages behind the scenes for you. When you first use an environment, it
needs to be explicitly created. This is done by including \f(CW\*(C`DB_CREATE\*(C'\fR
with the \f(CW\*(C`Flags\*(C'\fR parameter, described below.
.SS "Synopsis"
.IX Subsection "Synopsis"
.Vb 10
\&    $env = new BerkeleyDB::Env
\&             [ \-Home         => $path, ]
\&             [ \-Server       => $name, ]
\&             [ \-CacheSize    => $number, ]
\&             [ \-Config       => { name => value, name => value }, ]
\&             [ \-ErrFile      => filename, ]
\&             [ \-MsgFile      => filename, ]
\&             [ \-ErrPrefix    => "string", ]
\&             [ \-Flags        => number, ]
\&             [ \-SetFlags     => bitmask, ]
\&             [ \-LockDetect   => number, ]
\&             [ \-TxMax        => number, ]
\&             [ \-LogConfig    => number, ]
\&             [ \-MaxLockers   => number, ]
\&             [ \-MaxLocks     => number, ]
\&             [ \-MaxObjects   => number, ]
\&             [ \-SharedMemKey => number, ]
\&             [ \-Verbose      => boolean, ]
\&             [ \-BlobThreshold=> $number, ]
\&             [ \-BlobDir      => directory, ]
\&             [ \-Encrypt      => { Password => "string",
\&                                  Flags    => number }, ]
.Ve
.PP
All the parameters to the BerkeleyDB::Env constructor are optional.
.IP "\-Home" 5
.IX Item "-Home"
If present, this parameter should point to an existing directory. Any
files that \fIaren't\fR specified with an absolute path in the sub-systems
that are initialised by the BerkeleyDB::Env class will be assumed to
live in the \fBHome\fR directory.
.Sp
For example, in the code fragment below the database \*(L"fred.db\*(R" will be
opened in the directory \*(L"/home/databases\*(R" because it was specified as a
relative path, but \*(L"joe.db\*(R" will be opened in \*(L"/other\*(R" because it was
part of an absolute path.
.Sp
.Vb 3
\&    $env = new BerkeleyDB::Env
\&             \-Home         => "/home/databases"
\&    ...
\&
\&    $db1 = new BerkeleyDB::Hash
\&             \-Filename => "fred.db",
\&             \-Env => $env
\&    ...
\&
\&    $db2 = new BerkeleyDB::Hash
\&             \-Filename => "/other/joe.db",
\&             \-Env => $env
\&    ...
.Ve
.IP "\-Server" 5
.IX Item "-Server"
If present, this parameter should be the hostname of a server that is running
the Berkeley \s-1DB RPC\s0 server. All databases will be accessed via the \s-1RPC\s0 server.
.IP "\-Encrypt" 5
.IX Item "-Encrypt"
If present, this parameter will enable encryption of  all data before
it is written to the database. This parameters must be given a hash
reference. The format is shown below.
.Sp
.Vb 1
\&    \-Encrypt => { \-Password => "abc", Flags => DB_ENCRYPT_AES }
.Ve
.Sp
Valid values for the Flags are 0 or \f(CW\*(C`DB_ENCRYPT_AES\*(C'\fR.
.Sp
This option requires Berkeley \s-1DB 4.1\s0 or better.
.IP "\-Cachesize" 5
.IX Item "-Cachesize"
If present, this parameter sets the size of the environments shared memory
buffer pool.
.IP "\-TxMax" 5
.IX Item "-TxMax"
If present, this parameter sets the number of simultaneous
transactions that are allowed.  Default 100.  This default is
definitely too low for programs using the \s-1MVCC\s0 capabilities.
.IP "\-LogConfig" 5
.IX Item "-LogConfig"
If present, this parameter is used to configure log options.
.IP "\-MaxLockers" 5
.IX Item "-MaxLockers"
If present, this parameter is used to configure the maximum number of
processes doing locking on the database.  Default 1000.
.IP "\-MaxLocks" 5
.IX Item "-MaxLocks"
If present, this parameter is used to configure the maximum number of
locks on the database.  Default 1000.  This is often lower than required.
.IP "\-MaxObjects" 5
.IX Item "-MaxObjects"
If present, this parameter is used to configure the maximum number of
locked objects.  Default 1000.  This is often lower than required.
.IP "\-SharedMemKey" 5
.IX Item "-SharedMemKey"
If present, this parameter sets the base segment \s-1ID\s0 for the shared memory
region used by Berkeley \s-1DB. \s0
.Sp
This option requires Berkeley \s-1DB 3.1\s0 or better.
.Sp
Use \f(CW\*(C`$env\->get_shm_key($id)\*(C'\fR to find out the base segment \s-1ID\s0 used
once the environment is open.
.IP "\-ThreadCount" 5
.IX Item "-ThreadCount"
If present, this parameter declares the approximate number of threads that
will be used in the database environment. This parameter is only necessary
when the \f(CW$env\fR\->failchk method will be used. It does not actually set the
maximum number of threads but rather is used to determine memory sizing.
.Sp
This option requires Berkeley \s-1DB 4.4\s0 or better. It is only supported on
Unix/Linux.
.IP "\-BlobThreshold" 5
.IX Item "-BlobThreshold"
Sets the size threshold that will be used to decide when data is stored as
a \s-1BLOB.\s0 This option must be set for a blobs to be used.
.Sp
This option requires Berkeley \s-1DB 6.0\s0 or better.
.IP "\-BlobDir" 5
.IX Item "-BlobDir"
The directory where the \s-1BLOB\s0 objects are stored.
.Sp
If not specified blob files are stores in the environment directoy.
.Sp
This option requires Berkeley \s-1DB 6.0\s0 or better.
.IP "\-Config" 5
.IX Item "-Config"
This is a variation on the \f(CW\*(C`\-Home\*(C'\fR parameter, but it allows finer
control of where specific types of files will be stored.
.Sp
The parameter expects a reference to a hash. Valid keys are:
\&\fB\s-1DB_DATA_DIR\s0\fR, \fB\s-1DB_LOG_DIR\s0\fR and \fB\s-1DB_TMP_DIR\s0\fR
.Sp
The code below shows an example of how it can be used.
.Sp
.Vb 6
\&    $env = new BerkeleyDB::Env
\&             \-Config => { DB_DATA_DIR => "/home/databases",
\&                          DB_LOG_DIR  => "/home/logs",
\&                          DB_TMP_DIR  => "/home/tmp"
\&                        }
\&    ...
.Ve
.IP "\-ErrFile" 5
.IX Item "-ErrFile"
Expects a filename or filehandle. Any errors generated internally by
Berkeley \s-1DB\s0 will be logged to this file. A useful debug setting is to
open environments with either
.Sp
.Vb 1
\&    \-ErrFile => *STDOUT
.Ve
.Sp
or
.Sp
.Vb 1
\&    \-ErrFile => *STDERR
.Ve
.IP "\-ErrPrefix" 5
.IX Item "-ErrPrefix"
Allows a prefix to be added to the error messages before they are sent
to \fB\-ErrFile\fR.
.IP "\-Flags" 5
.IX Item "-Flags"
The \fBFlags\fR parameter specifies both which sub-systems to initialise,
as well as a number of environment-wide options.
See the Berkeley \s-1DB\s0 documentation for more details of these options.
.Sp
Any of the following can be specified by \s-1OR\s0'ing them:
.Sp
\&\fB\s-1DB_CREATE\s0\fR
.Sp
If any of the files specified do not already exist, create them.
.Sp
\&\fB\s-1DB_INIT_CDB\s0\fR
.Sp
Initialise the Concurrent Access Methods
.Sp
\&\fB\s-1DB_INIT_LOCK\s0\fR
.Sp
Initialise the Locking sub-system.
.Sp
\&\fB\s-1DB_INIT_LOG\s0\fR
.Sp
Initialise the Logging sub-system.
.Sp
\&\fB\s-1DB_INIT_MPOOL\s0\fR
.Sp
Initialize the shared memory buffer pool subsystem. This subsystem should be used whenever an application is using any Berkeley \s-1DB\s0 access method.
.Sp
\&\fB\s-1DB_INIT_TXN\s0\fR
.Sp
Initialize the transaction subsystem. This subsystem should be used when recovery and atomicity of multiple operations are important. The \s-1DB_INIT_TXN\s0 flag implies the \s-1DB_INIT_LOG\s0 flag.
.Sp
\&\fB\s-1DB_MPOOL_PRIVATE\s0\fR
.Sp
Create a private memory pool; see memp_open. Ignored unless \s-1DB_INIT_MPOOL\s0 is also specified.
.Sp
\&\fB\s-1DB_INIT_MPOOL\s0\fR is also specified.
.Sp
\&\fB\s-1DB_NOMMAP\s0\fR
.Sp
Do not map this database into process memory.
.Sp
\&\fB\s-1DB_RECOVER\s0\fR
.Sp
Run normal recovery on this environment before opening it for normal use. If this flag is set, the \s-1DB_CREATE\s0 flag must also be set since the regions will be removed and recreated.
.Sp
The db_appinit function returns successfully if \s-1DB_RECOVER\s0 is specified and no log files exist, so it is necessary to ensure all necessary log files are present before running recovery.
.Sp
\&\fB\s-1DB_PRIVATE\s0\fR
.Sp
\&\fB\s-1DB_RECOVER_FATAL\s0\fR
.Sp
Run catastrophic recovery on this environment before opening it for normal use. If this flag is set, the \s-1DB_CREATE\s0 flag must also be set since the regions will be removed and recreated.
.Sp
The db_appinit function returns successfully if \s-1DB_RECOVER_FATAL\s0 is specified and no log files exist, so it is necessary to ensure all necessary log files are present before running recovery.
.Sp
\&\fB\s-1DB_THREAD\s0\fR
.Sp
Ensure that handles returned by the Berkeley \s-1DB\s0 subsystems are useable by multiple threads within a single process, i.e., that the system is free-threaded.
.Sp
\&\fB\s-1DB_TXN_NOSYNC\s0\fR
.Sp
On transaction commit, do not synchronously flush the log; see txn_open. Ignored unless \s-1DB_INIT_TXN\s0 is also specified.
.Sp
\&\fB\s-1DB_USE_ENVIRON\s0\fR
.Sp
The Berkeley \s-1DB\s0 process' environment may be permitted to specify information to be used when naming files; see Berkeley \s-1DB\s0 File Naming. As permitting users to specify which files are used can create security problems, environment information will be used in file naming for all users only if the \s-1DB_USE_ENVIRON\s0 flag is set.
.Sp
\&\fB\s-1DB_USE_ENVIRON_ROOT\s0\fR
.Sp
The Berkeley \s-1DB\s0 process' environment may be permitted to specify information to be used when naming files; see Berkeley \s-1DB\s0 File Naming. As permitting users to specify which files are used can create security problems, if the \s-1DB_USE_ENVIRON_ROOT\s0 flag is set, environment information will be used for file naming only for users with a user-ID matching that of the superuser (specifically, users for whom the \fIgetuid\fR\|(2) system call returns the user-ID 0).
.IP "\-SetFlags" 5
.IX Item "-SetFlags"
Calls \s-1ENV\-\s0>set_flags with the supplied bitmask. Use this when you need to make
use of \s-1DB_ENV\-\s0>set_flags before \s-1DB_ENV\-\s0>open is called.
.Sp
Only valid when Berkeley \s-1DB 3\s0.x or better is used.
.IP "\-LockDetect" 5
.IX Item "-LockDetect"
Specifies what to do when a lock conflict occurs. The value should be one of
.Sp
\&\fB\s-1DB_LOCK_DEFAULT\s0\fR
.Sp
Use the default policy as specified by db_deadlock.
.Sp
\&\fB\s-1DB_LOCK_OLDEST\s0\fR
.Sp
Abort the oldest transaction.
.Sp
\&\fB\s-1DB_LOCK_RANDOM\s0\fR
.Sp
Abort a random transaction involved in the deadlock.
.Sp
\&\fB\s-1DB_LOCK_YOUNGEST\s0\fR
.Sp
Abort the youngest transaction.
.IP "\-Verbose" 5
.IX Item "-Verbose"
Add extra debugging information to the messages sent to \fB\-ErrFile\fR.
.SS "Methods"
.IX Subsection "Methods"
The environment class has the following methods:
.ie n .IP "$env\->errPrefix(""string"") ;" 5
.el .IP "\f(CW$env\fR\->errPrefix(``string'') ;" 5
.IX Item "$env->errPrefix(string) ;"
This method is identical to the \fB\-ErrPrefix\fR flag. It allows the
error prefix string to be changed dynamically.
.ie n .IP "$env\->set_flags(bitmask, 1|0);" 5
.el .IP "\f(CW$env\fR\->set_flags(bitmask, 1|0);" 5
.IX Item "$env->set_flags(bitmask, 1|0);"
.PD 0
.ie n .IP "$txn = $env\->\fITxnMgr()\fR" 5
.el .IP "\f(CW$txn\fR = \f(CW$env\fR\->\fITxnMgr()\fR" 5
.IX Item "$txn = $env->TxnMgr()"
.PD
Constructor for creating a \fBTxnMgr\fR object.
See \*(L"\s-1TRANSACTIONS\*(R"\s0 for more details of using transactions.
.Sp
This method is deprecated. Access the transaction methods using the \fBtxn_\fR
methods below from the environment object directly.
.ie n .IP "$env\->\fItxn_begin()\fR" 5
.el .IP "\f(CW$env\fR\->\fItxn_begin()\fR" 5
.IX Item "$env->txn_begin()"
\&\s-1TODO\s0
.ie n .IP "$env\->\fItxn_stat()\fR" 5
.el .IP "\f(CW$env\fR\->\fItxn_stat()\fR" 5
.IX Item "$env->txn_stat()"
\&\s-1TODO\s0
.ie n .IP "$env\->\fItxn_checkpoint()\fR" 5
.el .IP "\f(CW$env\fR\->\fItxn_checkpoint()\fR" 5
.IX Item "$env->txn_checkpoint()"
\&\s-1TODO\s0
.ie n .IP "$env\->\fIstatus()\fR" 5
.el .IP "\f(CW$env\fR\->\fIstatus()\fR" 5
.IX Item "$env->status()"
Returns the status of the last BerkeleyDB::Env method.
.ie n .IP "$env\->\s-1\fIDB_ENV\s0()\fR" 5
.el .IP "\f(CW$env\fR\->\s-1\fIDB_ENV\s0()\fR" 5
.IX Item "$env->DB_ENV()"
Returns a pointer to the underlying \s-1DB_ENV\s0 data structure that Berkeley
\&\s-1DB\s0 uses.
.ie n .IP "$env\->get_shm_key($id)" 5
.el .IP "\f(CW$env\fR\->get_shm_key($id)" 5
.IX Item "$env->get_shm_key($id)"
Writes the base segment \s-1ID\s0 for the shared memory region used by the
Berkeley \s-1DB\s0 environment into \f(CW$id\fR. Returns 0 on success.
.Sp
This option requires Berkeley \s-1DB 4.2\s0 or better.
.Sp
Use the \f(CW\*(C`\-SharedMemKey\*(C'\fR option when opening the environmet to set the
base segment \s-1ID.\s0
.ie n .IP "$env\->\fIset_isalive()\fR" 5
.el .IP "\f(CW$env\fR\->\fIset_isalive()\fR" 5
.IX Item "$env->set_isalive()"
Set the callback that determines if the thread of control, identified by
the pid and tid arguments, is still running.  This method should only be
used in combination with \f(CW$env\fR\->failchk.
.Sp
This option requires Berkeley \s-1DB 4.4\s0 or better.
.ie n .IP "$env\->failchk($flags)" 5
.el .IP "\f(CW$env\fR\->failchk($flags)" 5
.IX Item "$env->failchk($flags)"
The \f(CW$env\fR\->failchk method checks for threads of control (either a true
thread or a process) that have exited while manipulating Berkeley \s-1DB\s0
library data structures, while holding a logical database lock, or with an
unresolved transaction (that is, a transaction that was never aborted or
committed).
.Sp
If \f(CW$env\fR\->failchk determines a thread of control exited while holding
database read locks, it will release those locks. If \f(CW$env\fR\->failchk
determines a thread of control exited with an unresolved transaction, the
transaction will be aborted.
.Sp
Applications calling the \f(CW$env\fR\->failchk method must have already called the
\&\f(CW$env\fR\->set_isalive method, on the same \s-1DB\s0 environment, and must have
configured their database environment using the \-ThreadCount flag. The
ThreadCount flag cannot be used on an environment that wasn't previously
initialized with it.
.Sp
This option requires Berkeley \s-1DB 4.4\s0 or better.
.ie n .IP "$env\->stat_print" 5
.el .IP "\f(CW$env\fR\->stat_print" 5
.IX Item "$env->stat_print"
Prints statistical information.
.Sp
If the \f(CW\*(C`MsgFile\*(C'\fR option is specified the output will be sent to the
file. Otherwise output is sent to standard output.
.Sp
This option requires Berkeley \s-1DB 4.3\s0 or better.
.ie n .IP "$env\->lock_stat_print" 5
.el .IP "\f(CW$env\fR\->lock_stat_print" 5
.IX Item "$env->lock_stat_print"
Prints locking subsystem statistics.
.Sp
If the \f(CW\*(C`MsgFile\*(C'\fR option is specified the output will be sent to the
file. Otherwise output is sent to standard output.
.Sp
This option requires Berkeley \s-1DB 4.3\s0 or better.
.ie n .IP "$env\->mutex_stat_print" 5
.el .IP "\f(CW$env\fR\->mutex_stat_print" 5
.IX Item "$env->mutex_stat_print"
Prints mutex subsystem statistics.
.Sp
If the \f(CW\*(C`MsgFile\*(C'\fR option is specified the output will be sent to the
file. Otherwise output is sent to standard output.
.Sp
This option requires Berkeley \s-1DB 4.4\s0 or better.
.ie n .IP "$status = $env\->get_blob_threshold($t1) ;" 5
.el .IP "\f(CW$status\fR = \f(CW$env\fR\->get_blob_threshold($t1) ;" 5
.IX Item "$status = $env->get_blob_threshold($t1) ;"
Sets the parameter \f(CW$t1\fR to the threshold value (in bytes) that is used to
determine when a data item is stored as a Blob.
.ie n .IP "$status = $env\->get_blob_dir($dir) ;" 5
.el .IP "\f(CW$status\fR = \f(CW$env\fR\->get_blob_dir($dir) ;" 5
.IX Item "$status = $env->get_blob_dir($dir) ;"
Sets the \f(CW$dir\fR parameter to the directory where blob files are stored.
.ie n .IP "$env\->set_timeout($timeout, $flags)" 5
.el .IP "\f(CW$env\fR\->set_timeout($timeout, \f(CW$flags\fR)" 5
.IX Item "$env->set_timeout($timeout, $flags)"
.PD 0
.ie n .IP "$env\->\fIstatus()\fR" 5
.el .IP "\f(CW$env\fR\->\fIstatus()\fR" 5
.IX Item "$env->status()"
.PD
Returns the status of the last BerkeleyDB::Env method.
.SS "Examples"
.IX Subsection "Examples"
\&\s-1TODO.\s0
.SH "Global Classes"
.IX Header "Global Classes"
.Vb 3
\&  $status = BerkeleyDB::db_remove [OPTIONS]
\&  $status = BerkeleyDB::db_rename [OPTIONS]
\&  $status = BerkeleyDB::db_verify [OPTIONS]
.Ve
.SH "THE DATABASE CLASSES"
.IX Header "THE DATABASE CLASSES"
\&\fBBerkeleyDB\fR supports the following database formats:
.IP "\fBBerkeleyDB::Hash\fR" 5
.IX Item "BerkeleyDB::Hash"
This database type allows arbitrary key/value pairs to be stored in data
files. This is equivalent to the functionality provided by other
hashing packages like \s-1DBM, NDBM, ODBM, GDBM,\s0 and \s-1SDBM.\s0 Remember though,
the files created using \fBBerkeleyDB::Hash\fR are not compatible with any
of the other packages mentioned.
.Sp
A default hashing algorithm, which will be adequate for most applications,
is built into BerkeleyDB. If you do need to use your own hashing algorithm
it is possible to write your own in Perl and have \fBBerkeleyDB\fR use
it instead.
.IP "\fBBerkeleyDB::Btree\fR" 5
.IX Item "BerkeleyDB::Btree"
The Btree format allows arbitrary key/value pairs to be stored in a
B+tree.
.Sp
As with the \fBBerkeleyDB::Hash\fR format, it is possible to provide a
user defined Perl routine to perform the comparison of keys. By default,
though, the keys are stored in lexical order.
.IP "\fBBerkeleyDB::Recno\fR" 5
.IX Item "BerkeleyDB::Recno"
\&\s-1TODO.\s0
.IP "\fBBerkeleyDB::Queue\fR" 5
.IX Item "BerkeleyDB::Queue"
\&\s-1TODO.\s0
.IP "\fBBerkeleyDB::Heap\fR" 5
.IX Item "BerkeleyDB::Heap"
\&\s-1TODO.\s0
.IP "\fBBerkeleyDB::Unknown\fR" 5
.IX Item "BerkeleyDB::Unknown"
This isn't a database format at all. It is used when you want to open an
existing Berkeley \s-1DB\s0 database without having to know what type is it.
.PP
Each of the database formats described above is accessed via a
corresponding \fBBerkeleyDB\fR class. These will be described in turn in
the next sections.
.SH "BerkeleyDB::Hash"
.IX Header "BerkeleyDB::Hash"
Equivalent to calling \fBdb_open\fR with type \fB\s-1DB_HASH\s0\fR in Berkeley \s-1DB 2\s0.x and
calling \fBdb_create\fR followed by \fB\s-1DB\-\s0>open\fR with type \fB\s-1DB_HASH\s0\fR in
Berkeley \s-1DB 3\s0.x or greater.
.PP
Two forms of constructor are supported:
.PP
.Vb 10
\&    $db = new BerkeleyDB::Hash
\&                [ \-Filename      => "filename", ]
\&                [ \-Subname       => "sub\-database name", ]
\&                [ \-Flags         => flags,]
\&                [ \-Property      => flags,]
\&                [ \-Mode          => number,]
\&                [ \-Cachesize     => number,]
\&                [ \-Lorder        => number,]
\&                [ \-Pagesize      => number,]
\&                [ \-Env           => $env,]
\&                [ \-Txn           => $txn,]
\&                [ \-Encrypt       => { Password => "string",
\&                                      Flags    => number }, ],
\&                [ \-BlobThreshold=> $number, ]
\&                [ \-BlobDir      => directory, ]
\&                # BerkeleyDB::Hash specific
\&                [ \-Ffactor       => number,]
\&                [ \-Nelem         => number,]
\&                [ \-Hash          => code reference,]
\&                [ \-DupCompare    => code reference,]
.Ve
.PP
and this
.PP
.Vb 10
\&    [$db =] tie %hash, \*(AqBerkeleyDB::Hash\*(Aq, 
\&                [ \-Filename      => "filename", ]
\&                [ \-Subname       => "sub\-database name", ]
\&                [ \-Flags         => flags,]
\&                [ \-Property      => flags,]
\&                [ \-Mode          => number,]
\&                [ \-Cachesize     => number,]
\&                [ \-Lorder        => number,]
\&                [ \-Pagesize      => number,]
\&                [ \-Env           => $env,]
\&                [ \-Txn           => $txn,]
\&                [ \-Encrypt       => { Password => "string",
\&                                      Flags    => number }, ],
\&                [ \-BlobThreshold=> $number, ]
\&                [ \-BlobDir      => directory, ]
\&                # BerkeleyDB::Hash specific
\&                [ \-Ffactor       => number,]
\&                [ \-Nelem         => number,]
\&                [ \-Hash          => code reference,]
\&                [ \-DupCompare    => code reference,]
.Ve
.PP
When the \*(L"tie\*(R" interface is used, reading from and writing to the database
is achieved via the tied hash. In this case the database operates like
a Perl associative array that happens to be stored on disk.
.PP
In addition to the high-level tied hash interface, it is possible to
make use of the underlying methods provided by Berkeley \s-1DB\s0
.SS "Options"
.IX Subsection "Options"
In addition to the standard set of options (see \*(L"\s-1COMMON OPTIONS\*(R"\s0)
\&\fBBerkeleyDB::Hash\fR supports these options:
.IP "\-Property" 5
.IX Item "-Property"
Used to specify extra flags when opening a database. The following
flags may be specified by bitwise \s-1OR\s0'ing together one or more of the
following values:
.Sp
\&\fB\s-1DB_DUP\s0\fR
.Sp
When creating a new database, this flag enables the storing of duplicate
keys in the database. If \fB\s-1DB_DUPSORT\s0\fR is not specified as well, the
duplicates are stored in the order they are created in the database.
.Sp
\&\fB\s-1DB_DUPSORT\s0\fR
.Sp
Enables the sorting of duplicate keys in the database. Ignored if
\&\fB\s-1DB_DUP\s0\fR isn't also specified.
.IP "\-Ffactor" 5
.IX Item "-Ffactor"
.PD 0
.IP "\-Nelem" 5
.IX Item "-Nelem"
.PD
See the Berkeley \s-1DB\s0 documentation for details of these options.
.IP "\-Hash" 5
.IX Item "-Hash"
Allows you to provide a user defined hash function. If not specified, 
a default hash function is used. Here is a template for a user-defined
hash function
.Sp
.Vb 7
\&    sub hash
\&    {
\&        my ($data) = shift ;
\&        ...
\&        # return the hash value for $data
\&        return $hash ;
\&    }
\&
\&    tie %h, "BerkeleyDB::Hash", 
\&        \-Filename => $filename, 
\&        \-Hash     => \e&hash,
\&        ...
.Ve
.Sp
See "" for an example.
.IP "\-DupCompare" 5
.IX Item "-DupCompare"
Used in conjunction with the \fB\s-1DB_DUPOSRT\s0\fR flag.
.Sp
.Vb 9
\&    sub compare
\&    {
\&        my ($key, $key2) = @_ ;
\&        ...
\&        # return  0 if $key1 eq $key2
\&        #        \-1 if $key1 lt $key2
\&        #         1 if $key1 gt $key2
\&        return (\-1 , 0 or 1) ;
\&    }
\&
\&    tie %h, "BerkeleyDB::Hash", 
\&        \-Filename   => $filename, 
\&        \-Property   => DB_DUP|DB_DUPSORT,
\&        \-DupCompare => \e&compare,
\&        ...
.Ve
.SS "Methods"
.IX Subsection "Methods"
\&\fBBerkeleyDB::Hash\fR only supports the standard database methods.
See \*(L"\s-1COMMON DATABASE METHODS\*(R"\s0.
.SS "A Simple Tied Hash Example"
.IX Subsection "A Simple Tied Hash Example"
.Vb 3
\&    use strict ;
\&    use BerkeleyDB ;
\&    use vars qw( %h $k $v ) ;
\&
\&    my $filename = "fruit" ;
\&    unlink $filename ;
\&    tie %h, "BerkeleyDB::Hash",
\&                \-Filename => $filename,
\&                \-Flags    => DB_CREATE
\&        or die "Cannot open file $filename: $! $BerkeleyDB::Error\en" ;
\&
\&    # Add a few key/value pairs to the file
\&    $h{"apple"} = "red" ;
\&    $h{"orange"} = "orange" ;
\&    $h{"banana"} = "yellow" ;
\&    $h{"tomato"} = "red" ;
\&
\&    # Check for existence of a key
\&    print "Banana Exists\en\en" if $h{"banana"} ;
\&
\&    # Delete a key/value pair.
\&    delete $h{"apple"} ;
\&
\&    # print the contents of the file
\&    while (($k, $v) = each %h)
\&      { print "$k \-> $v\en" }
\&
\&    untie %h ;
.Ve
.PP
here is the output:
.PP
.Vb 1
\&    Banana Exists
\&    
\&    orange \-> orange
\&    tomato \-> red
\&    banana \-> yellow
.Ve
.PP
Note that the like ordinary associative arrays, the order of the keys
retrieved from a Hash database are in an apparently random order.
.SS "Another Simple Hash Example"
.IX Subsection "Another Simple Hash Example"
Do the same as the previous example but not using tie.
.PP
.Vb 2
\&    use strict ;
\&    use BerkeleyDB ;
\&
\&    my $filename = "fruit" ;
\&    unlink $filename ;
\&    my $db = new BerkeleyDB::Hash
\&                \-Filename => $filename,
\&                \-Flags    => DB_CREATE
\&        or die "Cannot open file $filename: $! $BerkeleyDB::Error\en" ;
\&
\&    # Add a few key/value pairs to the file
\&    $db\->db_put("apple", "red") ;
\&    $db\->db_put("orange", "orange") ;
\&    $db\->db_put("banana", "yellow") ;
\&    $db\->db_put("tomato", "red") ;
\&
\&    # Check for existence of a key
\&    print "Banana Exists\en\en" if $db\->db_get("banana", $v) == 0;
\&
\&    # Delete a key/value pair.
\&    $db\->db_del("apple") ;
\&
\&    # print the contents of the file
\&    my ($k, $v) = ("", "") ;
\&    my $cursor = $db\->db_cursor() ;
\&    while ($cursor\->c_get($k, $v, DB_NEXT) == 0)
\&      { print "$k \-> $v\en" }
\&
\&    undef $cursor ;
\&    undef $db ;
.Ve
.SS "Duplicate keys"
.IX Subsection "Duplicate keys"
The code below is a variation on the examples above. This time the hash has
been inverted. The key this time is colour and the value is the fruit name.
The \fB\s-1DB_DUP\s0\fR flag has been specified to allow duplicates.
.PP
.Vb 2
\&    use strict ;
\&    use BerkeleyDB ;
\&
\&    my $filename = "fruit" ;
\&    unlink $filename ;
\&    my $db = new BerkeleyDB::Hash
\&                \-Filename => $filename,
\&                \-Flags    => DB_CREATE,
\&                \-Property  => DB_DUP
\&        or die "Cannot open file $filename: $! $BerkeleyDB::Error\en" ;
\&
\&    # Add a few key/value pairs to the file
\&    $db\->db_put("red", "apple") ;
\&    $db\->db_put("orange", "orange") ;
\&    $db\->db_put("green", "banana") ;
\&    $db\->db_put("yellow", "banana") ;
\&    $db\->db_put("red", "tomato") ;
\&    $db\->db_put("green", "apple") ;
\&
\&    # print the contents of the file
\&    my ($k, $v) = ("", "") ;
\&    my $cursor = $db\->db_cursor() ;
\&    while ($cursor\->c_get($k, $v, DB_NEXT) == 0)
\&      { print "$k \-> $v\en" }
\&
\&    undef $cursor ;
\&    undef $db ;
.Ve
.PP
here is the output:
.PP
.Vb 6
\&    orange \-> orange
\&    yellow \-> banana
\&    red \-> apple
\&    red \-> tomato
\&    green \-> banana
\&    green \-> apple
.Ve
.SS "Sorting Duplicate Keys"
.IX Subsection "Sorting Duplicate Keys"
In the previous example, when there were duplicate keys, the values are
sorted in the order they are stored in. The code below is
identical to the previous example except the \fB\s-1DB_DUPSORT\s0\fR flag is
specified.
.PP
.Vb 2
\&    use strict ;
\&    use BerkeleyDB ;
\&
\&    my $filename = "fruit" ;
\&    unlink $filename ;
\&    my $db = new BerkeleyDB::Hash
\&                \-Filename => $filename,
\&                \-Flags    => DB_CREATE,
\&                \-Property  => DB_DUP | DB_DUPSORT
\&        or die "Cannot open file $filename: $! $BerkeleyDB::Error\en" ;
\&
\&    # Add a few key/value pairs to the file
\&    $db\->db_put("red", "apple") ;
\&    $db\->db_put("orange", "orange") ;
\&    $db\->db_put("green", "banana") ;
\&    $db\->db_put("yellow", "banana") ;
\&    $db\->db_put("red", "tomato") ;
\&    $db\->db_put("green", "apple") ;
\&
\&    # print the contents of the file
\&    my ($k, $v) = ("", "") ;
\&    my $cursor = $db\->db_cursor() ;
\&    while ($cursor\->c_get($k, $v, DB_NEXT) == 0)
\&      { print "$k \-> $v\en" }
\&
\&    undef $cursor ;
\&    undef $db ;
.Ve
.PP
Notice that in the output below the duplicate values are sorted.
.PP
.Vb 6
\&    orange \-> orange
\&    yellow \-> banana
\&    red \-> apple
\&    red \-> tomato
\&    green \-> apple
\&    green \-> banana
.Ve
.SS "Custom Sorting Duplicate Keys"
.IX Subsection "Custom Sorting Duplicate Keys"
Another variation
.PP
\&\s-1TODO\s0
.SS "Changing the hash"
.IX Subsection "Changing the hash"
\&\s-1TODO\s0
.SS "Using db_stat"
.IX Subsection "Using db_stat"
\&\s-1TODO\s0
.SH "BerkeleyDB::Btree"
.IX Header "BerkeleyDB::Btree"
Equivalent to calling \fBdb_open\fR with type \fB\s-1DB_BTREE\s0\fR in Berkeley \s-1DB 2\s0.x and
calling \fBdb_create\fR followed by \fB\s-1DB\-\s0>open\fR with type \fB\s-1DB_BTREE\s0\fR in
Berkeley \s-1DB 3\s0.x or greater.
.PP
Two forms of constructor are supported:
.PP
.Vb 10
\&    $db = new BerkeleyDB::Btree
\&                [ \-Filename      => "filename", ]
\&                [ \-Subname       => "sub\-database name", ]
\&                [ \-Flags         => flags,]
\&                [ \-Property      => flags,]
\&                [ \-Mode          => number,]
\&                [ \-Cachesize     => number,]
\&                [ \-Lorder        => number,]
\&                [ \-Pagesize      => number,]
\&                [ \-Env           => $env,]
\&                [ \-Txn           => $txn,]
\&                [ \-Encrypt       => { Password => "string",
\&                                      Flags    => number }, ],
\&                [ \-BlobThreshold=> $number, ]
\&                [ \-BlobDir      => directory, ]
\&                # BerkeleyDB::Btree specific
\&                [ \-Minkey        => number,]
\&                [ \-Compare       => code reference,]
\&                [ \-DupCompare    => code reference,]
\&                [ \-Prefix        => code reference,]
.Ve
.PP
and this
.PP
.Vb 10
\&    [$db =] tie %hash, \*(AqBerkeleyDB::Btree\*(Aq, 
\&                [ \-Filename      => "filename", ]
\&                [ \-Subname       => "sub\-database name", ]
\&                [ \-Flags         => flags,]
\&                [ \-Property      => flags,]
\&                [ \-Mode          => number,]
\&                [ \-Cachesize     => number,]
\&                [ \-Lorder        => number,]
\&                [ \-Pagesize      => number,]
\&                [ \-Env           => $env,]
\&                [ \-Txn           => $txn,]
\&                [ \-Encrypt       => { Password => "string",
\&                                      Flags    => number }, ],
\&                [ \-BlobThreshold=> $number, ]
\&                [ \-BlobDir      => directory, ]
\&                # BerkeleyDB::Btree specific
\&                [ \-Minkey        => number,]
\&                [ \-Compare       => code reference,]
\&                [ \-DupCompare    => code reference,]
\&                [ \-Prefix        => code reference,]
.Ve
.SS "Options"
.IX Subsection "Options"
In addition to the standard set of options (see \*(L"\s-1COMMON OPTIONS\*(R"\s0)
\&\fBBerkeleyDB::Btree\fR supports these options:
.IP "\-Property" 5
.IX Item "-Property"
Used to specify extra flags when opening a database. The following
flags may be specified by bitwise \s-1OR\s0'ing together one or more of the
following values:
.Sp
\&\fB\s-1DB_DUP\s0\fR
.Sp
When creating a new database, this flag enables the storing of duplicate
keys in the database. If \fB\s-1DB_DUPSORT\s0\fR is not specified as well, the
duplicates are stored in the order they are created in the database.
.Sp
\&\fB\s-1DB_DUPSORT\s0\fR
.Sp
Enables the sorting of duplicate keys in the database. Ignored if
\&\fB\s-1DB_DUP\s0\fR isn't also specified.
.IP "Minkey" 5
.IX Item "Minkey"
\&\s-1TODO\s0
.IP "Compare" 5
.IX Item "Compare"
Allow you to override the default sort order used in the database. See
\&\*(L"Changing the sort order\*(R" for an example.
.Sp
.Vb 9
\&    sub compare
\&    {
\&        my ($key, $key2) = @_ ;
\&        ...
\&        # return  0 if $key1 eq $key2
\&        #        \-1 if $key1 lt $key2
\&        #         1 if $key1 gt $key2
\&        return (\-1 , 0 or 1) ;
\&    }
\&
\&    tie %h, "BerkeleyDB::Hash", 
\&        \-Filename   => $filename, 
\&        \-Compare    => \e&compare,
\&        ...
.Ve
.IP "Prefix" 5
.IX Item "Prefix"
.Vb 8
\&    sub prefix
\&    {
\&        my ($key, $key2) = @_ ;
\&        ...
\&        # return number of bytes of $key2 which are 
\&        # necessary to determine that it is greater than $key1
\&        return $bytes ;
\&    }
\&
\&    tie %h, "BerkeleyDB::Hash", 
\&        \-Filename   => $filename, 
\&        \-Prefix     => \e&prefix,
\&        ...
\&=item DupCompare
\&
\&    sub compare
\&    {
\&        my ($key, $key2) = @_ ;
\&        ...
\&        # return  0 if $key1 eq $key2
\&        #        \-1 if $key1 lt $key2
\&        #         1 if $key1 gt $key2
\&        return (\-1 , 0 or 1) ;
\&    }
\&
\&    tie %h, "BerkeleyDB::Hash", 
\&        \-Filename   => $filename, 
\&        \-DupCompare => \e&compare,
\&        ...
.Ve
.IP "set_bt_compress" 5
.IX Item "set_bt_compress"
Enabled compression of the btree data. The callback interface is not
supported at present. Need Berkeley \s-1DB 4.8\s0 or better.
.SS "Methods"
.IX Subsection "Methods"
\&\fBBerkeleyDB::Btree\fR supports the following database methods.
See also \*(L"\s-1COMMON DATABASE METHODS\*(R"\s0.
.PP
All the methods below return 0 to indicate success.
.ie n .IP "$status = $db\->db_key_range($key, $less, $equal, $greater [, $flags])" 5
.el .IP "\f(CW$status\fR = \f(CW$db\fR\->db_key_range($key, \f(CW$less\fR, \f(CW$equal\fR, \f(CW$greater\fR [, \f(CW$flags\fR])" 5
.IX Item "$status = $db->db_key_range($key, $less, $equal, $greater [, $flags])"
Given a key, \f(CW$key\fR, this method returns the proportion of keys less than 
\&\f(CW$key\fR in \f(CW$less\fR, the proportion equal to \f(CW$key\fR in \f(CW$equal\fR and the
proportion greater than \f(CW$key\fR in \f(CW$greater\fR.
.Sp
The proportion is returned as a double in the range 0.0 to 1.0.
.SS "A Simple Btree Example"
.IX Subsection "A Simple Btree Example"
The code below is a simple example of using a btree database.
.PP
.Vb 2
\&    use strict ;
\&    use BerkeleyDB ;
\&
\&    my $filename = "tree" ;
\&    unlink $filename ;
\&    my %h ;
\&    tie %h, \*(AqBerkeleyDB::Btree\*(Aq,
\&                \-Filename   => $filename,
\&                \-Flags      => DB_CREATE
\&      or die "Cannot open $filename: $! $BerkeleyDB::Error\en" ;
\&
\&    # Add a key/value pair to the file
\&    $h{\*(AqWall\*(Aq} = \*(AqLarry\*(Aq ;
\&    $h{\*(AqSmith\*(Aq} = \*(AqJohn\*(Aq ;
\&    $h{\*(Aqmouse\*(Aq} = \*(Aqmickey\*(Aq ;
\&    $h{\*(Aqduck\*(Aq}  = \*(Aqdonald\*(Aq ;
\&
\&    # Delete
\&    delete $h{"duck"} ;
\&
\&    # Cycle through the keys printing them in order.
\&    # Note it is not necessary to sort the keys as
\&    # the btree will have kept them in order automatically.
\&    foreach (keys %h)
\&      { print "$_\en" }
\&
\&    untie %h ;
.Ve
.PP
Here is the output from the code above. The keys have been sorted using
Berkeley \s-1DB\s0's default sorting algorithm.
.PP
.Vb 3
\&    Smith
\&    Wall
\&    mouse
.Ve
.SS "Changing the sort order"
.IX Subsection "Changing the sort order"
It is possible to supply your own sorting algorithm if the one that Berkeley
\&\s-1DB\s0 used isn't suitable. The code below is identical to the previous example
except for the case insensitive compare function.
.PP
.Vb 2
\&    use strict ;
\&    use BerkeleyDB ;
\&
\&    my $filename = "tree" ;
\&    unlink $filename ;
\&    my %h ;
\&    tie %h, \*(AqBerkeleyDB::Btree\*(Aq,
\&                \-Filename   => $filename,
\&                \-Flags      => DB_CREATE,
\&                \-Compare    => sub { lc $_[0] cmp lc $_[1] }
\&      or die "Cannot open $filename: $!\en" ;
\&
\&    # Add a key/value pair to the file
\&    $h{\*(AqWall\*(Aq} = \*(AqLarry\*(Aq ;
\&    $h{\*(AqSmith\*(Aq} = \*(AqJohn\*(Aq ;
\&    $h{\*(Aqmouse\*(Aq} = \*(Aqmickey\*(Aq ;
\&    $h{\*(Aqduck\*(Aq}  = \*(Aqdonald\*(Aq ;
\&
\&    # Delete
\&    delete $h{"duck"} ;
\&
\&    # Cycle through the keys printing them in order.
\&    # Note it is not necessary to sort the keys as
\&    # the btree will have kept them in order automatically.
\&    foreach (keys %h)
\&      { print "$_\en" }
\&
\&    untie %h ;
.Ve
.PP
Here is the output from the code above.
.PP
.Vb 3
\&    mouse
\&    Smith
\&    Wall
.Ve
.PP
There are a few point to bear in mind if you want to change the
ordering in a \s-1BTREE\s0 database:
.IP "1." 5
The new compare function must be specified when you create the database.
.IP "2." 5
You cannot change the ordering once the database has been created. Thus
you must use the same compare function every time you access the
database.
.SS "Using db_stat"
.IX Subsection "Using db_stat"
\&\s-1TODO\s0
.SH "BerkeleyDB::Recno"
.IX Header "BerkeleyDB::Recno"
Equivalent to calling \fBdb_open\fR with type \fB\s-1DB_RECNO\s0\fR in Berkeley \s-1DB 2\s0.x and
calling \fBdb_create\fR followed by \fB\s-1DB\-\s0>open\fR with type \fB\s-1DB_RECNO\s0\fR in
Berkeley \s-1DB 3\s0.x or greater.
.PP
Two forms of constructor are supported:
.PP
.Vb 10
\&    $db = new BerkeleyDB::Recno
\&                [ \-Filename      => "filename", ]
\&                [ \-Subname       => "sub\-database name", ]
\&                [ \-Flags         => flags,]
\&                [ \-Property      => flags,]
\&                [ \-Mode          => number,]
\&                [ \-Cachesize     => number,]
\&                [ \-Lorder        => number,]
\&                [ \-Pagesize      => number,]
\&                [ \-Env           => $env,]
\&                [ \-Txn           => $txn,]
\&                [ \-Encrypt       => { Password => "string",
\&                                      Flags    => number }, ],
\&                # BerkeleyDB::Recno specific
\&                [ \-Delim           => byte,]
\&                [ \-Len             => number,]
\&                [ \-Pad             => byte,]
\&                [ \-Source          => filename,]
.Ve
.PP
and this
.PP
.Vb 10
\&    [$db =] tie @arry, \*(AqBerkeleyDB::Recno\*(Aq, 
\&                [ \-Filename      => "filename", ]
\&                [ \-Subname       => "sub\-database name", ]
\&                [ \-Flags         => flags,]
\&                [ \-Property      => flags,]
\&                [ \-Mode          => number,]
\&                [ \-Cachesize     => number,]
\&                [ \-Lorder        => number,]
\&                [ \-Pagesize      => number,]
\&                [ \-Env           => $env,]
\&                [ \-Txn           => $txn,]
\&                [ \-Encrypt       => { Password => "string",
\&                                      Flags    => number }, ],
\&                # BerkeleyDB::Recno specific
\&                [ \-Delim           => byte,]
\&                [ \-Len             => number,]
\&                [ \-Pad             => byte,]
\&                [ \-Source          => filename,]
.Ve
.SS "A Recno Example"
.IX Subsection "A Recno Example"
Here is a simple example that uses \s-1RECNO \s0(if you are using a version 
of Perl earlier than 5.004_57 this example won't work \*(-- see 
\&\*(L"Extra \s-1RECNO\s0 Methods\*(R" for a workaround).
.PP
.Vb 2
\&    use strict ;
\&    use BerkeleyDB ;
\&
\&    my $filename = "text" ;
\&    unlink $filename ;
\&
\&    my @h ;
\&    tie @h, \*(AqBerkeleyDB::Recno\*(Aq,
\&                \-Filename   => $filename,
\&                \-Flags      => DB_CREATE,
\&                \-Property   => DB_RENUMBER
\&      or die "Cannot open $filename: $!\en" ;
\&
\&    # Add a few key/value pairs to the file
\&    $h[0] = "orange" ;
\&    $h[1] = "blue" ;
\&    $h[2] = "yellow" ;
\&
\&    push @h, "green", "black" ;
\&
\&    my $elements = scalar @h ;
\&    print "The array contains $elements entries\en" ;
\&
\&    my $last = pop @h ;
\&    print "popped $last\en" ;
\&
\&    unshift @h, "white" ;
\&    my $first = shift @h ;
\&    print "shifted $first\en" ;
\&
\&    # Check for existence of a key
\&    print "Element 1 Exists with value $h[1]\en" if $h[1] ;
\&
\&    untie @h ;
.Ve
.PP
Here is the output from the script:
.PP
.Vb 6
\&    The array contains 5 entries
\&    popped black
\&    shifted white
\&    Element 1 Exists with value blue
\&    The last element is green
\&    The 2nd last element is yellow
.Ve
.SH "BerkeleyDB::Queue"
.IX Header "BerkeleyDB::Queue"
Equivalent to calling \fBdb_create\fR followed by \fB\s-1DB\-\s0>open\fR with
type \fB\s-1DB_QUEUE\s0\fR in Berkeley \s-1DB 3\s0.x or greater. This database format
isn't available if you use Berkeley \s-1DB 2\s0.x.
.PP
Two forms of constructor are supported:
.PP
.Vb 10
\&    $db = new BerkeleyDB::Queue
\&                [ \-Filename      => "filename", ]
\&                [ \-Subname       => "sub\-database name", ]
\&                [ \-Flags         => flags,]
\&                [ \-Property      => flags,]
\&                [ \-Mode          => number,]
\&                [ \-Cachesize     => number,]
\&                [ \-Lorder        => number,]
\&                [ \-Pagesize      => number,]
\&                [ \-Env           => $env,]
\&                [ \-Txn           => $txn,]
\&                [ \-Encrypt       => { Password => "string",
\&                                      Flags    => number }, ],
\&                # BerkeleyDB::Queue specific
\&                [ \-Len             => number,]
\&                [ \-Pad             => byte,]
\&                [ \-ExtentSize    => number, ]
.Ve
.PP
and this
.PP
.Vb 10
\&    [$db =] tie @arry, \*(AqBerkeleyDB::Queue\*(Aq, 
\&                [ \-Filename      => "filename", ]
\&                [ \-Subname       => "sub\-database name", ]
\&                [ \-Flags         => flags,]
\&                [ \-Property      => flags,]
\&                [ \-Mode          => number,]
\&                [ \-Cachesize     => number,]
\&                [ \-Lorder        => number,]
\&                [ \-Pagesize      => number,]
\&                [ \-Env           => $env,]
\&                [ \-Txn           => $txn,]
\&                [ \-Encrypt       => { Password => "string",
\&                                      Flags    => number }, ],
\&                # BerkeleyDB::Queue specific
\&                [ \-Len             => number,]
\&                [ \-Pad             => byte,]
.Ve
.SH "BerkeleyDB::Heap"
.IX Header "BerkeleyDB::Heap"
Equivalent to calling \fBdb_create\fR followed by \fB\s-1DB\-\s0>open\fR with
type \fB\s-1DB_HEAP\s0\fR in Berkeley \s-1DB 5.2\s0.x or greater. This database format
isn't available if you use an older version of Berkeley \s-1DB.\s0
.PP
One form of constructor is supported:
.PP
.Vb 10
\&    $db = new BerkeleyDB::Heap
\&                [ \-Filename      => "filename", ]
\&                [ \-Subname       => "sub\-database name", ]
\&                [ \-Flags         => flags,]
\&                [ \-Property      => flags,]
\&                [ \-Mode          => number,]
\&                [ \-Cachesize     => number,]
\&                [ \-Lorder        => number,]
\&                [ \-Pagesize      => number,]
\&                [ \-Env           => $env,]
\&                [ \-Txn           => $txn,]
\&                [ \-Encrypt       => { Password => "string",
\&                                      Flags    => number }, ],
\&                [ \-BlobThreshold=> $number, ]
\&                [ \-BlobDir      => directory, ]
\&                # BerkeleyDB::Heap specific
\&                [ \-HeapSize      => number, ]
\&                [ \-HeapSizeGb    => number, ]
.Ve
.SH "BerkeleyDB::Unknown"
.IX Header "BerkeleyDB::Unknown"
This class is used to open an existing database.
.PP
Equivalent to calling \fBdb_open\fR with type \fB\s-1DB_UNKNOWN\s0\fR in Berkeley \s-1DB 2\s0.x and
calling \fBdb_create\fR followed by \fB\s-1DB\-\s0>open\fR with type \fB\s-1DB_UNKNOWN\s0\fR in
Berkeley \s-1DB 3\s0.x or greater.
.PP
The constructor looks like this:
.PP
.Vb 10
\&    $db = new BerkeleyDB::Unknown
\&                [ \-Filename      => "filename", ]
\&                [ \-Subname       => "sub\-database name", ]
\&                [ \-Flags         => flags,]
\&                [ \-Property      => flags,]
\&                [ \-Mode          => number,]
\&                [ \-Cachesize     => number,]
\&                [ \-Lorder        => number,]
\&                [ \-Pagesize      => number,]
\&                [ \-Env           => $env,]
\&                [ \-Txn           => $txn,]
\&                [ \-Encrypt       => { Password => "string",
\&                                      Flags    => number }, ],
.Ve
.SS "An example"
.IX Subsection "An example"
.SH "COMMON OPTIONS"
.IX Header "COMMON OPTIONS"
All database access class constructors support the common set of
options defined below. All are optional.
.IP "\-Filename" 5
.IX Item "-Filename"
The database filename. If no filename is specified, a temporary file will
be created and removed once the program terminates.
.IP "\-Subname" 5
.IX Item "-Subname"
Specifies the name of the sub-database to open.
This option is only valid if you are using Berkeley \s-1DB 3\s0.x or greater.
.IP "\-Flags" 5
.IX Item "-Flags"
Specify how the database will be opened/created. The valid flags are:
.Sp
\&\fB\s-1DB_CREATE\s0\fR
.Sp
Create any underlying files, as necessary. If the files do not already
exist and the \fB\s-1DB_CREATE\s0\fR flag is not specified, the call will fail.
.Sp
\&\fB\s-1DB_NOMMAP\s0\fR
.Sp
Not supported by BerkeleyDB.
.Sp
\&\fB\s-1DB_RDONLY\s0\fR
.Sp
Opens the database in read-only mode.
.Sp
\&\fB\s-1DB_THREAD\s0\fR
.Sp
Not supported by BerkeleyDB.
.Sp
\&\fB\s-1DB_TRUNCATE\s0\fR
.Sp
If the database file already exists, remove all the data before
opening it.
.IP "\-Mode" 5
.IX Item "-Mode"
Determines the file protection when the database is created. Defaults
to 0666.
.IP "\-Cachesize" 5
.IX Item "-Cachesize"
.PD 0
.IP "\-Lorder" 5
.IX Item "-Lorder"
.IP "\-Pagesize" 5
.IX Item "-Pagesize"
.IP "\-Env" 5
.IX Item "-Env"
.PD
When working under a Berkeley \s-1DB\s0 environment, this parameter
.Sp
Defaults to no environment.
.IP "\-Encrypt" 5
.IX Item "-Encrypt"
If present, this parameter will enable encryption of  all data before
it is written to the database. This parameters must be given a hash
reference. The format is shown below.
.Sp
.Vb 1
\&    \-Encrypt => { \-Password => "abc", Flags => DB_ENCRYPT_AES }
.Ve
.Sp
Valid values for the Flags are 0 or \f(CW\*(C`DB_ENCRYPT_AES\*(C'\fR.
.Sp
This option requires Berkeley \s-1DB 4.1\s0 or better.
.IP "\-Txn" 5
.IX Item "-Txn"
\&\s-1TODO.\s0
.SH "COMMON DATABASE METHODS"
.IX Header "COMMON DATABASE METHODS"
All the database interfaces support the common set of methods defined
below.
.PP
All the methods below return 0 to indicate success.
.ie n .SS "$env = $db\->\fIEnv()\fP;"
.el .SS "\f(CW$env\fP = \f(CW$db\fP\->\fIEnv()\fP;"
.IX Subsection "$env = $db->Env();"
Returns the environment object the database is associated with or \f(CW\*(C`undef\*(C'\fR
when no environment was used when opening the database.
.ie n .SS "$status = $db\->db_get($key, $value [, $flags])"
.el .SS "\f(CW$status\fP = \f(CW$db\fP\->db_get($key, \f(CW$value\fP [, \f(CW$flags\fP])"
.IX Subsection "$status = $db->db_get($key, $value [, $flags])"
Given a key (\f(CW$key\fR) this method reads the value associated with it
from the database. If it exists, the value read from the database is
returned in the \f(CW$value\fR parameter.
.PP
The \fB\f(CB$flags\fB\fR parameter is optional. If present, it must be set to \fBone\fR
of the following values:
.IP "\fB\s-1DB_GET_BOTH\s0\fR" 5
.IX Item "DB_GET_BOTH"
When the \fB\s-1DB_GET_BOTH\s0\fR flag is specified, \fBdb_get\fR checks for the
existence of \fBboth\fR the \f(CW$key\fR \fBand\fR \f(CW$value\fR in the database.
.IP "\fB\s-1DB_SET_RECNO\s0\fR" 5
.IX Item "DB_SET_RECNO"
\&\s-1TODO.\s0
.PP
In addition, the following value may be set by bitwise \s-1OR\s0'ing it into
the \fB\f(CB$flags\fB\fR parameter:
.IP "\fB\s-1DB_RMW\s0\fR" 5
.IX Item "DB_RMW"
\&\s-1TODO\s0
.PP
The variant \f(CW\*(C`db_pget\*(C'\fR allows you to query a secondary database:
.PP
.Vb 1
\&        $status = $sdb\->db_pget($skey, $pkey, $value);
.Ve
.PP
using the key \f(CW$skey\fR in the secondary db to lookup \f(CW$pkey\fR and \f(CW$value\fR
from the primary db.
.ie n .SS "$status = $db\->db_exists($key [, $flags])"
.el .SS "\f(CW$status\fP = \f(CW$db\fP\->db_exists($key [, \f(CW$flags\fP])"
.IX Subsection "$status = $db->db_exists($key [, $flags])"
This method checks for the existence of the given key (\f(CW$key\fR), but
does not read the value. If the key is not found, \fBdb_exists\fR will
return \fB\s-1DB_NOTFOUND\s0\fR. Requires \s-1BDB 4.6\s0 or better.
.ie n .SS "$status = $db\->db_put($key, $value [, $flags])"
.el .SS "\f(CW$status\fP = \f(CW$db\fP\->db_put($key, \f(CW$value\fP [, \f(CW$flags\fP])"
.IX Subsection "$status = $db->db_put($key, $value [, $flags])"
Stores a key/value pair in the database.
.PP
The \fB\f(CB$flags\fB\fR parameter is optional. If present it must be set to \fBone\fR
of the following values:
.IP "\fB\s-1DB_APPEND\s0\fR" 5
.IX Item "DB_APPEND"
This flag is only applicable when accessing a \fBBerkeleyDB::Recno\fR
database.
.Sp
\&\s-1TODO.\s0
.IP "\fB\s-1DB_NOOVERWRITE\s0\fR" 5
.IX Item "DB_NOOVERWRITE"
If this flag is specified and \f(CW$key\fR already exists in the database,
the call to \fBdb_put\fR will return \fB\s-1DB_KEYEXIST\s0\fR.
.ie n .SS "$status = $db\->db_del($key [, $flags])"
.el .SS "\f(CW$status\fP = \f(CW$db\fP\->db_del($key [, \f(CW$flags\fP])"
.IX Subsection "$status = $db->db_del($key [, $flags])"
Deletes a key/value pair in the database associated with \f(CW$key\fR.
If duplicate keys are enabled in the database, \fBdb_del\fR will delete
\&\fBall\fR key/value pairs with key \f(CW$key\fR.
.PP
The \fB\f(CB$flags\fB\fR parameter is optional and is currently unused.
.ie n .SS "$status = $env\->stat_print([$flags])"
.el .SS "\f(CW$status\fP = \f(CW$env\fP\->stat_print([$flags])"
.IX Subsection "$status = $env->stat_print([$flags])"
Prints statistical information.
.PP
If the \f(CW\*(C`MsgFile\*(C'\fR option is specified the output will be sent to the
file. Otherwise output is sent to standard output.
.PP
This option requires Berkeley \s-1DB 4.3\s0 or better.
.ie n .SS "$status = $db\->\fIdb_sync()\fP"
.el .SS "\f(CW$status\fP = \f(CW$db\fP\->\fIdb_sync()\fP"
.IX Subsection "$status = $db->db_sync()"
If any parts of the database are in memory, write them to the database.
.ie n .SS "$cursor = $db\->db_cursor([$flags])"
.el .SS "\f(CW$cursor\fP = \f(CW$db\fP\->db_cursor([$flags])"
.IX Subsection "$cursor = $db->db_cursor([$flags])"
Creates a cursor object. This is used to access the contents of the
database sequentially. See \s-1CURSORS\s0 for details of the methods
available when working with cursors.
.PP
The \fB\f(CB$flags\fB\fR parameter is optional. If present it must be set to \fBone\fR
of the following values:
.IP "\fB\s-1DB_RMW\s0\fR" 5
.IX Item "DB_RMW"
\&\s-1TODO.\s0
.ie n .SS "($flag, $old_offset, $old_length) = $db\->partial_set($offset, $length) ;"
.el .SS "($flag, \f(CW$old_offset\fP, \f(CW$old_length\fP) = \f(CW$db\fP\->partial_set($offset, \f(CW$length\fP) ;"
.IX Subsection "($flag, $old_offset, $old_length) = $db->partial_set($offset, $length) ;"
\&\s-1TODO\s0
.ie n .SS "($flag, $old_offset, $old_length) = $db\->\fIpartial_clear()\fP ;"
.el .SS "($flag, \f(CW$old_offset\fP, \f(CW$old_length\fP) = \f(CW$db\fP\->\fIpartial_clear()\fP ;"
.IX Subsection "($flag, $old_offset, $old_length) = $db->partial_clear() ;"
\&\s-1TODO\s0
.ie n .SS "$db\->\fIbyteswapped()\fP"
.el .SS "\f(CW$db\fP\->\fIbyteswapped()\fP"
.IX Subsection "$db->byteswapped()"
\&\s-1TODO\s0
.ie n .SS "$status = $db\->get_blob_threshold($t1) ;"
.el .SS "\f(CW$status\fP = \f(CW$db\fP\->get_blob_threshold($t1) ;"
.IX Subsection "$status = $db->get_blob_threshold($t1) ;"
Sets the parameter \f(CW$t1\fR to the threshold value (in bytes) that is used to
determine when a data item is stored as a Blob.
.ie n .SS "$status = $db\->get_blob_dir($dir) ;"
.el .SS "\f(CW$status\fP = \f(CW$db\fP\->get_blob_dir($dir) ;"
.IX Subsection "$status = $db->get_blob_dir($dir) ;"
Sets the \f(CW$dir\fR parameter to the directory where blob files are stored.
.ie n .SS "$db\->\fItype()\fP"
.el .SS "\f(CW$db\fP\->\fItype()\fP"
.IX Subsection "$db->type()"
Returns the type of the database. The possible return code are \fB\s-1DB_HASH\s0\fR
for a \fBBerkeleyDB::Hash\fR database, \fB\s-1DB_BTREE\s0\fR for a \fBBerkeleyDB::Btree\fR
database and \fB\s-1DB_RECNO\s0\fR for a \fBBerkeleyDB::Recno\fR database. This method
is typically used when a database has been opened with
\&\fBBerkeleyDB::Unknown\fR.
.ie n .SS "$bool = $env\->\fIcds_enabled()\fP;"
.el .SS "\f(CW$bool\fP = \f(CW$env\fP\->\fIcds_enabled()\fP;"
.IX Subsection "$bool = $env->cds_enabled();"
Returns true if the Berkeley \s-1DB\s0 environment \f(CW$env\fR has been opened on
\&\s-1CDS\s0 mode.
.ie n .SS "$bool = $db\->\fIcds_enabled()\fP;"
.el .SS "\f(CW$bool\fP = \f(CW$db\fP\->\fIcds_enabled()\fP;"
.IX Subsection "$bool = $db->cds_enabled();"
Returns true if the database \f(CW$db\fR has been opened on \s-1CDS\s0 mode.
.ie n .SS "$lock = $db\->\fIcds_lock()\fP;"
.el .SS "\f(CW$lock\fP = \f(CW$db\fP\->\fIcds_lock()\fP;"
.IX Subsection "$lock = $db->cds_lock();"
Creates a \s-1CDS\s0 write lock object \f(CW$lock\fR.
.PP
It is a fatal error to attempt to create a cds_lock if the Berkeley \s-1DB\s0
environment has not been opened in \s-1CDS\s0 mode.
.ie n .SS "$lock\->\fIcds_unlock()\fP;"
.el .SS "\f(CW$lock\fP\->\fIcds_unlock()\fP;"
.IX Subsection "$lock->cds_unlock();"
Removes a \s-1CDS\s0 lock. The destruction of the \s-1CDS\s0 lock object automatically
calls this method.
.PP
Note that if multiple \s-1CDS\s0 lock objects are created, the underlying write
lock will not be released until all \s-1CDS\s0 lock objects are either explicitly
unlocked with this method, or the \s-1CDS\s0 lock objects have been destroyed.
.ie n .SS "$ref = $db\->\fIdb_stat()\fP"
.el .SS "\f(CW$ref\fP = \f(CW$db\fP\->\fIdb_stat()\fP"
.IX Subsection "$ref = $db->db_stat()"
Returns a reference to an associative array containing information about
the database. The keys of the associative array correspond directly to the
names of the fields defined in the Berkeley \s-1DB\s0 documentation. For example,
in the \s-1DB\s0 documentation, the field \fBbt_version\fR stores the version of the
Btree database. Assuming you called \fBdb_stat\fR on a Btree database the
equivalent field would be accessed as follows:
.PP
.Vb 1
\&    $version = $ref\->{\*(Aqbt_version\*(Aq} ;
.Ve
.PP
If you are using Berkeley \s-1DB 3\s0.x or better, this method will work will
all database formats. When \s-1DB 2\s0.x is used, it only works with
\&\fBBerkeleyDB::Btree\fR.
.ie n .SS "$status = $db\->\fIstatus()\fP"
.el .SS "\f(CW$status\fP = \f(CW$db\fP\->\fIstatus()\fP"
.IX Subsection "$status = $db->status()"
Returns the status of the last \f(CW$db\fR method called.
.ie n .SS "$status = $db\->truncate($count)"
.el .SS "\f(CW$status\fP = \f(CW$db\fP\->truncate($count)"
.IX Subsection "$status = $db->truncate($count)"
Truncates the database and returns the number or records deleted
in \f(CW$count\fR.
.ie n .SS "$status = $db\->compact($start, $stop, $c_data, $flags, $end);"
.el .SS "\f(CW$status\fP = \f(CW$db\fP\->compact($start, \f(CW$stop\fP, \f(CW$c_data\fP, \f(CW$flags\fP, \f(CW$end\fP);"
.IX Subsection "$status = $db->compact($start, $stop, $c_data, $flags, $end);"
Compacts the database \f(CW$db\fR.
.PP
All the parameters are optional \- if only want to make use of some of them,
use \f(CW\*(C`undef\*(C'\fR for those you don't want.  Trailing unused parameters can be
omitted. For example, if you only want to use the \f(CW$c_data\fR parameter to
set the \f(CW\*(C`compact_fillpercent\*(C'\fR, write you code like this
.PP
.Vb 3
\&    my %hash;
\&    $hash{compact_fillpercent} = 50;
\&    $db\->compact(undef, undef, \e%hash);
.Ve
.PP
The parameters operate identically to the C equivalent of this method.
The \f(CW$c_data\fR needs a bit of explanation \- it must be a hash reference.
The values of the following keys can be set before calling \f(CW\*(C`compact\*(C'\fR and
will affect the operation of the compaction.
.IP "\(bu" 5
compact_fillpercent
.IP "\(bu" 5
compact_timeout
.PP
The following keys, along with associated values, will be created in the
hash reference if the \f(CW\*(C`compact\*(C'\fR operation was successful.
.IP "\(bu" 5
compact_deadlock
.IP "\(bu" 5
compact_levels
.IP "\(bu" 5
compact_pages_free
.IP "\(bu" 5
compact_pages_examine
.IP "\(bu" 5
compact_pages_truncated
.PP
You need to be running Berkeley \s-1DB 4.4\s0 or better if you want to make use of
\&\f(CW\*(C`compact\*(C'\fR.
.ie n .SS "$status = $db\->associate($secondary, \e&key_callback)"
.el .SS "\f(CW$status\fP = \f(CW$db\fP\->associate($secondary, \e&key_callback)"
.IX Subsection "$status = $db->associate($secondary, &key_callback)"
Associate \f(CW$db\fR with the secondary \s-1DB \s0\f(CW$secondary\fR
.PP
New key/value pairs inserted to the database will be passed to the callback
which must set its third argument to the secondary key to allow lookup. If
an array reference is set multiple keys secondary keys will be associated
with the primary database entry.
.PP
Data may be retrieved fro the secondary database using \f(CW\*(C`db_pget\*(C'\fR to also
obtain the primary key.
.PP
Secondary databased are maintained automatically.
.ie n .SS "$status = $db\->associate_foreign($secondary, callback, $flags)"
.el .SS "\f(CW$status\fP = \f(CW$db\fP\->associate_foreign($secondary, callback, \f(CW$flags\fP)"
.IX Subsection "$status = $db->associate_foreign($secondary, callback, $flags)"
Associate a foreign key database \f(CW$db\fR with the secondary \s-1DB
\&\s0\f(CW$secondary\fR.
.PP
The second parameter must be a reference to a sub or \f(CW\*(C`undef\*(C'\fR.
.PP
The \f(CW$flags\fR parameter must be either \f(CW\*(C`DB_FOREIGN_CASCADE\*(C'\fR, 
\&\f(CW\*(C`DB_FOREIGN_ABORT\*(C'\fR or \f(CW\*(C`DB_FOREIGN_NULLIFY\*(C'\fR.
.PP
When the flags parameter is \f(CW\*(C`DB_FOREIGN_NULLIFY\*(C'\fR the second parameter is a
reference to a sub of the form
.PP
.Vb 6
\&    sub foreign_cb
\&    {
\&        my $key = \e$_[0];
\&        my $value = \e$_[1];
\&        my $foreignkey = \e$_[2];
\&        my $changed = \e$_[3] ;
\&
\&        # for ... set $$value and set $$changed to 1
\&
\&        return 0;
\&    }
\&
\&    $foreign_db\->associate_foreign($secondary, \e&foreign_cb, DB_FOREIGN_NULLIFY);
.Ve
.SH "CURSORS"
.IX Header "CURSORS"
A cursor is used whenever you want to access the contents of a database
in sequential order.
A cursor object is created with the \f(CW\*(C`db_cursor\*(C'\fR
.PP
A cursor object has the following methods available:
.ie n .SS "$newcursor = $cursor\->c_dup($flags)"
.el .SS "\f(CW$newcursor\fP = \f(CW$cursor\fP\->c_dup($flags)"
.IX Subsection "$newcursor = $cursor->c_dup($flags)"
Creates a duplicate of \f(CW$cursor\fR. This method needs Berkeley \s-1DB 3.0\s0.x or better.
.PP
The \f(CW$flags\fR parameter is optional and can take the following value:
.IP "\s-1DB_POSITION\s0" 5
.IX Item "DB_POSITION"
When present this flag will position the new cursor at the same place as the
existing cursor.
.ie n .SS "$status = $cursor\->c_get($key, $value, $flags)"
.el .SS "\f(CW$status\fP = \f(CW$cursor\fP\->c_get($key, \f(CW$value\fP, \f(CW$flags\fP)"
.IX Subsection "$status = $cursor->c_get($key, $value, $flags)"
Reads a key/value pair from the database, returning the data in \f(CW$key\fR
and \f(CW$value\fR. The key/value pair actually read is controlled by the
\&\f(CW$flags\fR parameter, which can take \fBone\fR of the following values:
.IP "\fB\s-1DB_FIRST\s0\fR" 5
.IX Item "DB_FIRST"
Set the cursor to point to the first key/value pair in the
database. Return the key/value pair in \f(CW$key\fR and \f(CW$value\fR.
.IP "\fB\s-1DB_LAST\s0\fR" 5
.IX Item "DB_LAST"
Set the cursor to point to the last key/value pair in the database. Return
the key/value pair in \f(CW$key\fR and \f(CW$value\fR.
.IP "\fB\s-1DB_NEXT\s0\fR" 5
.IX Item "DB_NEXT"
If the cursor is already pointing to a key/value pair, it will be
incremented to point to the next key/value pair and return its contents.
.Sp
If the cursor isn't initialised, \fB\s-1DB_NEXT\s0\fR works just like \fB\s-1DB_FIRST\s0\fR.
.Sp
If the cursor is already positioned at the last key/value pair, \fBc_get\fR
will return \fB\s-1DB_NOTFOUND\s0\fR.
.IP "\fB\s-1DB_NEXT_DUP\s0\fR" 5
.IX Item "DB_NEXT_DUP"
This flag is only valid when duplicate keys have been enabled in
a database.
If the cursor is already pointing to a key/value pair and the key of
the next key/value pair is identical, the cursor will be incremented to
point to it and their contents returned.
.IP "\fB\s-1DB_PREV\s0\fR" 5
.IX Item "DB_PREV"
If the cursor is already pointing to a key/value pair, it will be
decremented to point to the previous key/value pair and return its
contents.
.Sp
If the cursor isn't initialised, \fB\s-1DB_PREV\s0\fR works just like \fB\s-1DB_LAST\s0\fR.
.Sp
If the cursor is already positioned at the first key/value pair, \fBc_get\fR
will return \fB\s-1DB_NOTFOUND\s0\fR.
.IP "\fB\s-1DB_CURRENT\s0\fR" 5
.IX Item "DB_CURRENT"
If the cursor has been set to point to a key/value pair, return their
contents.
If the key/value pair referenced by the cursor has been deleted, \fBc_get\fR
will return \fB\s-1DB_KEYEMPTY\s0\fR.
.IP "\fB\s-1DB_SET\s0\fR" 5
.IX Item "DB_SET"
Set the cursor to point to the key/value pair referenced by \fB\f(CB$key\fB\fR
and return the value in \fB\f(CB$value\fB\fR.
.IP "\fB\s-1DB_SET_RANGE\s0\fR" 5
.IX Item "DB_SET_RANGE"
This flag is a variation on the \fB\s-1DB_SET\s0\fR flag. As well as returning
the value, it also returns the key, via \fB\f(CB$key\fB\fR.
When used with a \fBBerkeleyDB::Btree\fR database the key matched by \fBc_get\fR
will be the shortest key (in length) which is greater than or equal to
the key supplied, via \fB\f(CB$key\fB\fR. This allows partial key searches.
See ??? for an example of how to use this flag.
.IP "\fB\s-1DB_GET_BOTH\s0\fR" 5
.IX Item "DB_GET_BOTH"
Another variation on \fB\s-1DB_SET\s0\fR. This one returns both the key and
the value.
.IP "\fB\s-1DB_SET_RECNO\s0\fR" 5
.IX Item "DB_SET_RECNO"
\&\s-1TODO.\s0
.IP "\fB\s-1DB_GET_RECNO\s0\fR" 5
.IX Item "DB_GET_RECNO"
\&\s-1TODO.\s0
.PP
In addition, the following value may be set by bitwise \s-1OR\s0'ing it into
the \fB\f(CB$flags\fB\fR parameter:
.IP "\fB\s-1DB_RMW\s0\fR" 5
.IX Item "DB_RMW"
\&\s-1TODO.\s0
.ie n .SS "$status = $cursor\->c_put($key, $value, $flags)"
.el .SS "\f(CW$status\fP = \f(CW$cursor\fP\->c_put($key, \f(CW$value\fP, \f(CW$flags\fP)"
.IX Subsection "$status = $cursor->c_put($key, $value, $flags)"
Stores the key/value pair in the database. The position that the data is
stored in the database is controlled by the \f(CW$flags\fR parameter, which
must take \fBone\fR of the following values:
.IP "\fB\s-1DB_AFTER\s0\fR" 5
.IX Item "DB_AFTER"
When used with a Btree or Hash database, a duplicate of the key referenced
by the current cursor position will be created and the contents of
\&\fB\f(CB$value\fB\fR will be associated with it \- \fB\f(CB$key\fB\fR is ignored.
The new key/value pair will be stored immediately after the current
cursor position.
Obviously the database has to have been opened with \fB\s-1DB_DUP\s0\fR.
.Sp
When used with a Recno ... \s-1TODO\s0
.IP "\fB\s-1DB_BEFORE\s0\fR" 5
.IX Item "DB_BEFORE"
When used with a Btree or Hash database, a duplicate of the key referenced
by the current cursor position will be created and the contents of
\&\fB\f(CB$value\fB\fR will be associated with it \- \fB\f(CB$key\fB\fR is ignored.
The new key/value pair will be stored immediately before the current
cursor position.
Obviously the database has to have been opened with \fB\s-1DB_DUP\s0\fR.
.Sp
When used with a Recno ... \s-1TODO\s0
.IP "\fB\s-1DB_CURRENT\s0\fR" 5
.IX Item "DB_CURRENT"
If the cursor has been initialised, replace the value of the key/value
pair stored in the database with the contents of \fB\f(CB$value\fB\fR.
.IP "\fB\s-1DB_KEYFIRST\s0\fR" 5
.IX Item "DB_KEYFIRST"
Only valid with a Btree or Hash database. This flag is only really
used when duplicates are enabled in the database and sorted duplicates
haven't been specified.
In this case the key/value pair will be inserted as the first entry in
the duplicates for the particular key.
.IP "\fB\s-1DB_KEYLAST\s0\fR" 5
.IX Item "DB_KEYLAST"
Only valid with a Btree or Hash database. This flag is only really
used when duplicates are enabled in the database and sorted duplicates
haven't been specified.
In this case the key/value pair will be inserted as the last entry in
the duplicates for the particular key.
.ie n .SS "$status = $cursor\->c_del([$flags])"
.el .SS "\f(CW$status\fP = \f(CW$cursor\fP\->c_del([$flags])"
.IX Subsection "$status = $cursor->c_del([$flags])"
This method deletes the key/value pair associated with the current cursor
position. The cursor position will not be changed by this operation, so
any subsequent cursor operation must first initialise the cursor to
point to a valid key/value pair.
.PP
If the key/value pair associated with the cursor have already been
deleted, \fBc_del\fR will return \fB\s-1DB_KEYEMPTY\s0\fR.
.PP
The \fB\f(CB$flags\fB\fR parameter is not used at present.
.ie n .SS "$status = $cursor\->c_count($cnt [, $flags])"
.el .SS "\f(CW$status\fP = \f(CW$cursor\fP\->c_count($cnt [, \f(CW$flags\fP])"
.IX Subsection "$status = $cursor->c_count($cnt [, $flags])"
Stores the number of duplicates at the current cursor position in \fB\f(CB$cnt\fB\fR.
.PP
The \fB\f(CB$flags\fB\fR parameter is not used at present. This method needs 
Berkeley \s-1DB 3.1\s0 or better.
.ie n .SS "$status = $cursor\->\fIstatus()\fP"
.el .SS "\f(CW$status\fP = \f(CW$cursor\fP\->\fIstatus()\fP"
.IX Subsection "$status = $cursor->status()"
Returns the status of the last cursor method as a dual type.
.ie n .SS "$status = $cursor\->\fIc_pget()\fP ;"
.el .SS "\f(CW$status\fP = \f(CW$cursor\fP\->\fIc_pget()\fP ;"
.IX Subsection "$status = $cursor->c_pget() ;"
See \f(CW\*(C`db_pget\*(C'\fR
.ie n .SS "$status = $cursor\->\fIc_close()\fP"
.el .SS "\f(CW$status\fP = \f(CW$cursor\fP\->\fIc_close()\fP"
.IX Subsection "$status = $cursor->c_close()"
Closes the cursor \fB\f(CB$cursor\fB\fR.
.ie n .SS "$stream = $cursor\->db_stream($flags);"
.el .SS "\f(CW$stream\fP = \f(CW$cursor\fP\->db_stream($flags);"
.IX Subsection "$stream = $cursor->db_stream($flags);"
Create a BerkeleyDB::DbStream object to read the blob at the current cursor location.
See Blob for details of the the BerkeleyDB::DbStream object.
.PP
\&\f(CW$flags\fR must be one or more of the following \s-1OR\s0'ed together
.PP
\&\s-1DB_STREAM_READ
DB_STREAM_WRITE
DB_STREAM_SYNC_WRITE\s0
.PP
For full information on the flags refer to the Berkeley \s-1DB\s0 Reference Guide.
.SS "Cursor Examples"
.IX Subsection "Cursor Examples"
\&\s-1TODO\s0
.PP
Iterating from first to last, then in reverse.
.PP
examples of each of the flags.
.SH "JOIN"
.IX Header "JOIN"
Join support for BerkeleyDB is in progress. Watch this space.
.PP
\&\s-1TODO\s0
.SH "TRANSACTIONS"
.IX Header "TRANSACTIONS"
Transactions are created using the \f(CW\*(C`txn_begin\*(C'\fR method on BerkeleyDB::Env:
.PP
.Vb 1
\&        my $txn = $env\->txn_begin;
.Ve
.PP
If this is a nested transaction, supply the parent transaction as an
argument:
.PP
.Vb 1
\&        my $child_txn = $env\->txn_begin($parent_txn);
.Ve
.PP
Then in order to work with the transaction, you must set it as the current
transaction on the database handles you want to work with:
.PP
.Vb 1
\&        $db\->Txn($txn);
.Ve
.PP
Or for multiple handles:
.PP
.Vb 1
\&        $txn\->Txn(@handles);
.Ve
.PP
The current transaction is given by BerkeleyDB each time to the various \s-1BDB\s0
operations. In the C api it is required explicitly as an argument to every
operation.
.PP
To commit a transaction call the \f(CW\*(C`commit\*(C'\fR method on it:
.PP
.Vb 1
\&        $txn\->txn_commit;
.Ve
.PP
and to roll back call abort:
.PP
.Vb 1
\&        $txn\->txn_abort
.Ve
.PP
After committing or aborting a child transaction you need to set the active
transaction again using \f(CW\*(C`Txn\*(C'\fR.
.SH "BerkeleyDBB::DbStream \*(-- support for BLOB"
.IX Header "BerkeleyDBB::DbStream support for BLOB"
Blob support is available in Berkeley \s-1DB\s0 starting with version 6.0. Refer
to the section \*(L"Blob Support\*(R" in the Berkeley \s-1DB\s0 Programmer Reference for
details of how Blob supports works.
.PP
A Blob is access via a BerkeleyDBB::DbStream object. This is created via a
cursor object.
.PP
.Vb 1
\&    # Note \- error handling not shown below.
\&
\&    # Set the key we want
\&    my $k = "some key";
\&
\&    # Don\*(Aqt want the value retrieved by the cursor,
\&    # so use partial_set to make sure no data is retrieved.
\&    my $v = \*(Aq\*(Aq;
\&    $cursor\->partial_set(0,0) ;
\&    $cursor\->c_get($k, $v, DB_SET) ;
\&    $cursor\->partial_clear() ;
\&
\&    # Now create a stream to the blob
\&    my $stream = $cursor\->db_stream(DB_STREAM_WRITE) ;
\&
\&    # get the size of the blob
\&    $stream\->size(my $s) ;
\&
\&    # Read the first 1k of data from the blob
\&    my $data ;
\&    $stream\->read($data, 0, 1024);
.Ve
.PP
A BerkeleyDB::DbStream object has the following methods available:
.ie n .SS "$status = $stream\->size($SIZE);"
.el .SS "\f(CW$status\fP = \f(CW$stream\fP\->size($SIZE);"
.IX Subsection "$status = $stream->size($SIZE);"
Outputs the length of the Blob in the \f(CW$SIZE\fR parameter.
.ie n .SS "$status = $stream\->read($data, $offset, $size);"
.el .SS "\f(CW$status\fP = \f(CW$stream\fP\->read($data, \f(CW$offset\fP, \f(CW$size\fP);"
.IX Subsection "$status = $stream->read($data, $offset, $size);"
Read from the blob. \f(CW$offset\fR is the number of bytes from the start of the
blob to read from. \f(CW$size\fR if the number of bytes to read.
.ie n .SS "$status = $stream\->write($data, $offset, $flags);"
.el .SS "\f(CW$status\fP = \f(CW$stream\fP\->write($data, \f(CW$offset\fP, \f(CW$flags\fP);"
.IX Subsection "$status = $stream->write($data, $offset, $flags);"
Write \f(CW$data\fR to the blob, starting at offset \f(CW$offset\fR.
.PP
Example
.PP
Below is an example of how to walk through a database when you don't know
beforehand which entries are blobs and which are not.
.PP
.Vb 7
\&    while (1)
\&    {
\&        my $k = \*(Aq\*(Aq;
\&        my $v = \*(Aq\*(Aq;
\&        $cursor\->partial_set(0,0) ;
\&        my $status = $cursor\->c_get($k, $v, DB_NEXT) ;
\&        $cursor\->partial_clear();
\&
\&        last if $status != 0 ;
\&
\&        my $stream = $cursor\->db_stream(DB_STREAM_WRITE);
\&
\&        if (defined $stream)
\&        {
\&            # It\*(Aqs a Blob
\&            $stream\->size(my $s) ;
\&        }
\&        else
\&        {
\&            # Not a Blob
\&            $cursor\->c_get($k, $v, DB_CURRENT) ;
\&        }
\&    }
.Ve
.SH "Berkeley DB Concurrent Data Store (CDS)"
.IX Header "Berkeley DB Concurrent Data Store (CDS)"
The Berkeley \s-1DB \s0\fIConcurrent Data Store\fR (\s-1CDS\s0) is a lightweight locking
mechanism that is useful in scenarios where transactions are overkill.
.SS "What is \s-1CDS\s0?"
.IX Subsection "What is CDS?"
The Berkeley \s-1DB CDS\s0 interface is a simple lightweight locking mechanism
that allows safe concurrent access to Berkeley \s-1DB\s0 databases. Your
application can have multiple reader and write processes, but Berkeley \s-1DB\s0
will arrange it so that only one process can have a write lock against the
database at a time, i.e. multiple processes can read from a database
concurrently, but all write processes will be serialised.
.SS "Should I use it?"
.IX Subsection "Should I use it?"
Whilst this simple locking model is perfectly adequate for some
applications, it will be too restrictive for others. Before deciding on
using \s-1CDS\s0 mode, you need to be sure that it is suitable for the expected
behaviour of your application.
.PP
The key features of this model are
.IP "\(bu" 5
All writes operations are serialised.
.IP "\(bu" 5
A write operation will block until all reads have finished.
.PP
There are a few of the attributes of your application that you need to be
aware of before choosing to use \s-1CDS.\s0
.PP
Firstly, if you application needs either recoverability or transaction
support, then \s-1CDS\s0 will not be suitable.
.PP
Next what is the ratio of read operation to write operations will your
application have?
.PP
If it is carrying out mostly read operations, and very few writes, then \s-1CDS\s0
may be appropriate.
.PP
What is the expected throughput of reads/writes in your application?
.PP
If you application does 90% writes and 10% reads, but on average you only
have a transaction every 5 seconds, then the fact that all writes are
serialised will not matter, because there will hardly ever be multiple
writes processes blocking.
.PP
In summary \s-1CDS\s0 mode may be appropriate for your application if it performs
mostly reads and very few writes or there is a low throughput.  Also, if
you do not need to be able to roll back a series of database operations if
an error occurs, then \s-1CDS\s0 is ok.
.PP
If any of these is not the case you will need to use Berkeley \s-1DB\s0
transactions. That is outside the scope of this document.
.SS "Locking Used"
.IX Subsection "Locking Used"
Berkeley \s-1DB\s0 implements \s-1CDS\s0 mode using two kinds of lock behind the scenes \-
namely read locks and write locks. A read lock allows multiple processes to
access the database for reading at the same time. A write lock will only
get access to the database when there are no read or write locks active.
The write lock will block until the process holding the lock releases it.
.PP
Multiple processes with read locks can all access the database at the same
time as long as no process has a write lock. A process with a write lock
can only access the database if there are no other active read or write
locks.
.PP
The majority of the time the Berkeley \s-1DB CDS\s0 mode will handle all locking
without your application having to do anything. There are a couple of
exceptions you need to be aware of though \- these will be discussed in
\&\*(L"Safely Updating Records\*(R" and \*(L"Implicit Cursors\*(R" below.
.PP
A Berkeley \s-1DB\s0 Cursor (created with \f(CW\*(C`$db\->db_cursor\*(C'\fR) will by hold a
lock on the database until it is either explicitly closed or destroyed.
This means the lock has the potential to be long lived.
.PP
By default Berkeley \s-1DB\s0 cursors create a read lock, but it is possible to
create a cursor that holds a write lock, thus
.PP
.Vb 1
\&    $cursor = $db\->db_cursor(DB_WRITECURSOR);
.Ve
.PP
Whilst either a read or write cursor is active, it will block any other
processes that wants to write to the database.
.PP
To avoid blocking problems, only keep cursors open as long as they are
needed. The same is true when you use the \f(CW\*(C`cursor\*(C'\fR method or the
\&\f(CW\*(C`cds_lock\*(C'\fR method.
.PP
For full information on \s-1CDS\s0 see the \*(L"Berkeley \s-1DB\s0 Concurrent Data Store
applications\*(R" section in the Berkeley \s-1DB\s0 Reference Guide.
.SS "Opening a database for \s-1CDS\s0"
.IX Subsection "Opening a database for CDS"
Here is the typical signature that is used when opening a database in \s-1CDS\s0
mode.
.PP
.Vb 1
\&    use BerkeleyDB ;
\&
\&    my $env = new BerkeleyDB::Env
\&                  \-Home   => "./home" ,
\&                  \-Flags  => DB_CREATE| DB_INIT_CDB | DB_INIT_MPOOL
\&        or die "cannot open environment: $BerkeleyDB::Error\en";
\&
\&    my $db  = new BerkeleyDB::Hash
\&                \-Filename       => \*(Aqtest1.db\*(Aq,
\&                \-Flags          => DB_CREATE,
\&                \-Env            => $env
\&        or die "cannot open database: $BerkeleyDB::Error\en";
.Ve
.PP
or this, if you use the tied interface
.PP
.Vb 5
\&    tie %hash, "BerkeleyDB::Hash",
\&                \-Filename       => \*(Aqtest2.db\*(Aq,
\&                \-Flags          => DB_CREATE,
\&                \-Env            => $env
\&        or die "cannot open database: $BerkeleyDB::Error\en";
.Ve
.PP
The first thing to note is that you \fB\s-1MUST\s0\fR always use a Berkeley \s-1DB\s0
environment if you want to use locking with Berkeley \s-1DB.\s0
.PP
Remember, that apart from the actual database files you explicitly create
yourself, Berkeley \s-1DB\s0 will create a few behind the scenes to handle locking
\&\- they usually have names like \*(L"_\|_db.001\*(R". It is therefore a good idea to
use the \f(CW\*(C`\-Home\*(C'\fR option, unless you are happy for all these files to be
written in the current directory.
.PP
Next, remember to include the \f(CW\*(C`DB_CREATE\*(C'\fR flag when opening the
environment for the first time. A common mistake is to forget to add this
option and then wonder why the application doesn't work.
.PP
Finally, it is vital that all processes that are going to access the
database files use the same Berkeley \s-1DB\s0 environment.
.SS "Safely Updating a Record"
.IX Subsection "Safely Updating a Record"
One of the main gotchas when using \s-1CDS\s0 is if you want to update a record in
a database, i.e. you want to retrieve a record from a database, modify it
in some way and put it back in the database.
.PP
For example, say you are writing a web application and you want to keep a
record of the number of times your site is accessed in a Berkeley \s-1DB\s0
database. So your code will have a line of code like this (assume, of
course, that \f(CW%hash\fR has been tied to a Berkeley \s-1DB\s0 database):
.PP
.Vb 1
\&    $hash{Counter} ++ ;
.Ve
.PP
That may look innocent enough, but there is a race condition lurking in
there. If I rewrite the line of code using the low-level Berkeley \s-1DB API,\s0
which is what will actually be executed, the race condition may be more
apparent:
.PP
.Vb 3
\&    $db\->db_get("Counter", $value);
\&    ++ $value ;
\&    $db\->db_put("Counter", $value);
.Ve
.PP
Consider what happens behind the scenes when you execute the commands
above.  Firstly, the existing value for the key \*(L"Counter\*(R" is fetched from
the database using \f(CW\*(C`db_get\*(C'\fR. A read lock will be used for this part of the
update.  The value is then incremented, and the new value is written back
to the database using \f(CW\*(C`db_put\*(C'\fR. This time a write lock will be used.
.PP
Here's the problem \- there is nothing to stop two (or more) processes
executing the read part at the same time. Remember multiple processes can
hold a read lock on the database at the same time. So both will fetch the
same value, let's say 7, from the database. Both increment the value to 8
and attempt to write it to the database. Berkeley \s-1DB\s0 will ensure that only
one of the processes gets a write lock, while the other will be blocked. So
the process that happened to get the write lock will store the value 8 to
the database and release the write lock. Now the other process will be
unblocked, and it too will write the value 8 to the database. The result,
in this example, is we have missed a hit in the counter.
.PP
To deal with this kind of scenario, you need to make the update atomic. A
convenience method, called \f(CW\*(C`cds_lock\*(C'\fR, is supplied with the BerkeleyDB
module for this purpose. Using \f(CW\*(C`cds_lock\*(C'\fR, the counter update code can now
be rewritten thus:
.PP
.Vb 3
\&    my $lk = $dbh\->cds_lock() ; 
\&    $hash{Counter} ++ ;
\&    $lk\->cds_unlock;
.Ve
.PP
or this, where scoping is used to limit the lifetime of the lock object
.PP
.Vb 4
\&    {
\&        my $lk = $dbh\->cds_lock() ;
\&        $hash{Counter} ++ ;
\&    }
.Ve
.PP
Similarly, \f(CW\*(C`cds_lock\*(C'\fR can be used with the native Berkeley \s-1DB API \s0
.PP
.Vb 5
\&    my $lk = $dbh\->cds_lock() ;
\&    $db\->db_get("Counter", $value);
\&    ++ $value ;
\&    $db\->db_put("Counter", $value);
\&    $lk\->unlock;
.Ve
.PP
The \f(CW\*(C`cds_lock\*(C'\fR method will ensure that the current process has exclusive
access to the database until the lock is either explicitly released, via
the \f(CW\*(C`$lk\->cds_unlock()\*(C'\fR or by the lock object being destroyed.
.PP
If you are interested, all that \f(CW\*(C`cds_lock\*(C'\fR does is open a \*(L"write\*(R" cursor.
This has the useful side-effect of holding a write-lock on the database
until the cursor is deleted. This is how you create a write-cursor
.PP
.Vb 1
\&    $cursor = $db\->db_cursor(DB_WRITECURSOR);
.Ve
.PP
If you have instantiated multiple \f(CW\*(C`cds_lock\*(C'\fR objects for one database
within a single process, that process will hold a write-lock on the
database until \fI\s-1ALL\s0\fR \f(CW\*(C`cds_lock\*(C'\fR objects have been destroyed.
.PP
As with all write-cursors, you should try to limit the scope of the
\&\f(CW\*(C`cds_lock\*(C'\fR to as short a time as possible. Remember the complete database
will be locked to other process whilst the write lock is in place.
.SS "Cannot write with a read cursor while a write cursor is active"
.IX Subsection "Cannot write with a read cursor while a write cursor is active"
This issue is easier to demonstrate with an example, so consider the code
below. The intention of the code is to increment the values of all the
elements in a database by one.
.PP
.Vb 1
\&    # Assume $db is a database opened in a CDS environment.
\&
\&    # Create a write\-lock
\&    my $lock = $db\->db_cursor(DB_WRITECURSOR);
\&    # or 
\&    # my $lock = $db\->cds_lock();
\&
\&    
\&    my $cursor = $db\->db_cursor();
\&
\&    # Now loop through the database, and increment
\&    # each value using c_put.
\&    while ($cursor\->c_get($key, $value, DB_NEXT) == 0) 
\&    {
\&         $cursor\->c_put($key, $value+1, DB_CURRENT) == 0
\&             or die "$BerkeleyDB::Error\en";
\&    }
.Ve
.PP
When this code is run, it will fail on the \f(CW\*(C`c_put\*(C'\fR line with this error
.PP
.Vb 1
\&    Write attempted on read\-only cursor
.Ve
.PP
The read cursor has automatically disallowed a write operation to prevent a
deadlock.
.PP
So the rule is \*(-- you \fB\s-1CANNOT\s0\fR carry out a write operation using a
read-only cursor (i.e. you cannot use \f(CW\*(C`c_put\*(C'\fR or \f(CW\*(C`c_del\*(C'\fR) whilst another
write-cursor is already active.
.PP
The workaround for this issue is to just use \f(CW\*(C`db_put\*(C'\fR instead of \f(CW\*(C`c_put\*(C'\fR,
like this
.PP
.Vb 1
\&    # Assume $db is a database opened in a CDS environment.
\&
\&    # Create a write\-lock
\&    my $lock = $db\->db_cursor(DB_WRITECURSOR);
\&    # or 
\&    # my $lock = $db\->cds_lock();
\&
\&    
\&    my $cursor = $db\->db_cursor();
\&
\&    # Now loop through the database, and increment
\&    # each value using c_put.
\&    while ($cursor\->c_get($key, $value, DB_NEXT) == 0) 
\&    {
\&         $db\->db_put($key, $value+1) == 0
\&             or die "$BerkeleyDB::Error\en";
\&    }
.Ve
.SS "Implicit Cursors"
.IX Subsection "Implicit Cursors"
All Berkeley \s-1DB\s0 cursors will hold either a read lock or a write lock on the
database for the existence of the cursor. In order to prevent blocking of
other processes you need to make sure that they are not long lived.
.PP
There are a number of instances where the Perl interface to Berkeley \s-1DB\s0
will create a cursor behind the scenes without you being aware of it. Most
of these are very short-lived and will not affect the running of your
script, but there are a few notable exceptions.
.PP
Consider this snippet of code
.PP
.Vb 4
\&    while (my ($k, $v) = each %hash)
\&    {
\&        # do something
\&    }
.Ve
.PP
To implement the \*(L"each\*(R" functionality, a read cursor will be created behind
the scenes to allow you to iterate through the tied hash, \f(CW%hash\fR. While
that cursor is still active, a read lock will obviously be held against the
database. If your application has any other writing processes, these will
be blocked until the read cursor is closed. That won't happen until the
loop terminates.
.PP
To avoid blocking problems, only keep cursors open as long as they are
needed. The same is true when you use the \f(CW\*(C`cursor\*(C'\fR method or the
\&\f(CW\*(C`cds_lock\*(C'\fR method.
.PP
The locking behaviour of the \f(CW\*(C`values\*(C'\fR or \f(CW\*(C`keys\*(C'\fR functions, shown below,
is subtly different.
.PP
.Vb 4
\&    foreach my $k (keys %hash)
\&    {
\&        # do something
\&    }
\&
\&    foreach my $v (values %hash)
\&    {
\&        # do something
\&    }
.Ve
.PP
Just as in the \f(CW\*(C`each\*(C'\fR function, a read cursor will be created to iterate
over the database in both of these cases. Where \f(CW\*(C`keys\*(C'\fR and \f(CW\*(C`values\*(C'\fR
differ is the place where the cursor carries out the iteration through the
database. Whilst \f(CW\*(C`each\*(C'\fR carried out a single iteration every time it was
invoked, the \f(CW\*(C`keys\*(C'\fR and \f(CW\*(C`values\*(C'\fR functions will iterate through the
entire database in one go \*(-- the complete database will be read into memory
before the first iteration of the loop.
.PP
Apart from the fact that a read lock will be held for the amount of time
required to iterate through the database, the use of \f(CW\*(C`keys\*(C'\fR and \f(CW\*(C`values\*(C'\fR
is \fBnot\fR recommended because it will result in the complete database being
read into memory.
.SS "Avoiding Deadlock with multiple databases"
.IX Subsection "Avoiding Deadlock with multiple databases"
If your \s-1CDS\s0 application uses multiple database files, and you need to write
to more than one of them, you need to be careful you don't create a
deadlock.
.PP
For example, say you have two databases, D1 and D2, and two processes, P1
and P2. Assume you want to write a record to each database. If P1 writes
the records to the databases in the order D1, D2 while process P2 writes
the records in the order D2, D1, there is the potential for a deadlock to
occur.
.PP
This scenario can be avoided by either always acquiring the write locks in
exactly the same order in your application code, or by using the
\&\f(CW\*(C`DB_CDB_ALLDB\*(C'\fR flag when opening the environment. This flag will make a
write-lock apply to all the databases in the environment.
.PP
Add example here
.SH "DBM Filters"
.IX Header "DBM Filters"
A \s-1DBM\s0 Filter is a piece of code that is be used when you \fIalways\fR
want to make the same transformation to all keys and/or values in a \s-1DBM\s0
database. All of the database classes (BerkeleyDB::Hash,
BerkeleyDB::Btree and BerkeleyDB::Recno) support \s-1DBM\s0 Filters.
.PP
There are four methods associated with \s-1DBM\s0 Filters. All work
identically, and each is used to install (or uninstall) a single \s-1DBM\s0
Filter. Each expects a single parameter, namely a reference to a sub.
The only difference between them is the place that the filter is
installed.
.PP
To summarise:
.IP "\fBfilter_store_key\fR" 5
.IX Item "filter_store_key"
If a filter has been installed with this method, it will be invoked
every time you write a key to a \s-1DBM\s0 database.
.IP "\fBfilter_store_value\fR" 5
.IX Item "filter_store_value"
If a filter has been installed with this method, it will be invoked
every time you write a value to a \s-1DBM\s0 database.
.IP "\fBfilter_fetch_key\fR" 5
.IX Item "filter_fetch_key"
If a filter has been installed with this method, it will be invoked
every time you read a key from a \s-1DBM\s0 database.
.IP "\fBfilter_fetch_value\fR" 5
.IX Item "filter_fetch_value"
If a filter has been installed with this method, it will be invoked
every time you read a value from a \s-1DBM\s0 database.
.PP
You can use any combination of the methods, from none, to all four.
.PP
All filter methods return the existing filter, if present, or \f(CW\*(C`undef\*(C'\fR
in not.
.PP
To delete a filter pass \f(CW\*(C`undef\*(C'\fR to it.
.SS "The Filter"
.IX Subsection "The Filter"
When each filter is called by Perl, a local copy of \f(CW$_\fR will contain
the key or value to be filtered. Filtering is achieved by modifying
the contents of \f(CW$_\fR. The return code from the filter is ignored.
.SS "An Example \*(-- the \s-1NULL\s0 termination problem."
.IX Subsection "An Example the NULL termination problem."
Consider the following scenario. You have a \s-1DBM\s0 database that you need
to share with a third-party C application. The C application assumes
that \fIall\fR keys and values are \s-1NULL\s0 terminated. Unfortunately when
Perl writes to \s-1DBM\s0 databases it doesn't use \s-1NULL\s0 termination, so your
Perl application will have to manage \s-1NULL\s0 termination itself. When you
write to the database you will have to use something like this:
.PP
.Vb 1
\&    $hash{"$key\e0"} = "$value\e0" ;
.Ve
.PP
Similarly the \s-1NULL\s0 needs to be taken into account when you are considering
the length of existing keys/values.
.PP
It would be much better if you could ignore the \s-1NULL\s0 terminations issue
in the main application code and have a mechanism that automatically
added the terminating \s-1NULL\s0 to all keys and values whenever you write to
the database and have them removed when you read from the database. As I'm
sure you have already guessed, this is a problem that \s-1DBM\s0 Filters can
fix very easily.
.PP
.Vb 2
\&    use strict ;
\&    use BerkeleyDB ;
\&
\&    my %hash ;
\&    my $filename = "filt.db" ;
\&    unlink $filename ;
\&
\&    my $db = tie %hash, \*(AqBerkeleyDB::Hash\*(Aq,
\&                \-Filename   => $filename,
\&                \-Flags      => DB_CREATE
\&      or die "Cannot open $filename: $!\en" ;
\&
\&    # Install DBM Filters
\&    $db\->filter_fetch_key  ( sub { s/\e0$//    } ) ;
\&    $db\->filter_store_key  ( sub { $_ .= "\e0" } ) ;
\&    $db\->filter_fetch_value( sub { s/\e0$//    } ) ;
\&    $db\->filter_store_value( sub { $_ .= "\e0" } ) ;
\&
\&    $hash{"abc"} = "def" ;
\&    my $a = $hash{"ABC"} ;
\&    # ...
\&    undef $db ;
\&    untie %hash ;
.Ve
.PP
Hopefully the contents of each of the filters should be
self-explanatory. Both \*(L"fetch\*(R" filters remove the terminating \s-1NULL,\s0
and both \*(L"store\*(R" filters add a terminating \s-1NULL.\s0
.SS "Another Example \*(-- Key is a C int."
.IX Subsection "Another Example Key is a C int."
Here is another real-life example. By default, whenever Perl writes to
a \s-1DBM\s0 database it always writes the key and value as strings. So when
you use this:
.PP
.Vb 1
\&    $hash{12345} = "something" ;
.Ve
.PP
the key 12345 will get stored in the \s-1DBM\s0 database as the 5 byte string
\&\*(L"12345\*(R". If you actually want the key to be stored in the \s-1DBM\s0 database
as a C int, you will have to use \f(CW\*(C`pack\*(C'\fR when writing, and \f(CW\*(C`unpack\*(C'\fR
when reading.
.PP
Here is a \s-1DBM\s0 Filter that does it:
.PP
.Vb 5
\&    use strict ;
\&    use BerkeleyDB ;
\&    my %hash ;
\&    my $filename = "filt.db" ;
\&    unlink $filename ;
\&
\&
\&    my $db = tie %hash, \*(AqBerkeleyDB::Btree\*(Aq,
\&                \-Filename   => $filename,
\&                \-Flags      => DB_CREATE
\&      or die "Cannot open $filename: $!\en" ;
\&
\&    $db\->filter_fetch_key  ( sub { $_ = unpack("i", $_) } ) ;
\&    $db\->filter_store_key  ( sub { $_ = pack ("i", $_) } ) ;
\&    $hash{123} = "def" ;
\&    # ...
\&    undef $db ;
\&    untie %hash ;
.Ve
.PP
This time only two filters have been used \*(-- we only need to manipulate
the contents of the key, so it wasn't necessary to install any value
filters.
.SH "Using BerkeleyDB with MLDBM"
.IX Header "Using BerkeleyDB with MLDBM"
Both BerkeleyDB::Hash and BerkeleyDB::Btree can be used with the \s-1MLDBM\s0
module. The code fragment below shows how to open associate \s-1MLDBM\s0 with
BerkeleyDB::Btree. To use BerkeleyDB::Hash just replace
BerkeleyDB::Btree with BerkeleyDB::Hash.
.PP
.Vb 4
\&    use strict ;
\&    use BerkeleyDB ;
\&    use MLDBM qw(BerkeleyDB::Btree) ;
\&    use Data::Dumper;
\& 
\&    my $filename = \*(Aqtestmldbm\*(Aq ;
\&    my %o ;
\&     
\&    unlink $filename ;
\&    tie %o, \*(AqMLDBM\*(Aq, \-Filename => $filename,
\&                     \-Flags    => DB_CREATE
\&                    or die "Cannot open database \*(Aq$filename: $!\en";
.Ve
.PP
See the \s-1MLDBM\s0 documentation for information on how to use the module
and for details of its limitations.
.SH "EXAMPLES"
.IX Header "EXAMPLES"
\&\s-1TODO.\s0
.SH "HINTS & TIPS"
.IX Header "HINTS & TIPS"
.SS "Sharing Databases With C Applications"
.IX Subsection "Sharing Databases With C Applications"
There is no technical reason why a Berkeley \s-1DB\s0 database cannot be
shared by both a Perl and a C application.
.PP
The vast majority of problems that are reported in this area boil down
to the fact that C strings are \s-1NULL\s0 terminated, whilst Perl strings
are not. See \*(L"An Example \*(-- the \s-1NULL\s0 termination problem.\*(R" in the \s-1DBM
FILTERS\s0 section for a generic way to work around this problem.
.SS "The untie Gotcha"
.IX Subsection "The untie Gotcha"
\&\s-1TODO\s0
.SH "COMMON QUESTIONS"
.IX Header "COMMON QUESTIONS"
This section attempts to answer some of the more common questions that
I get asked.
.SS "Relationship with DB_File"
.IX Subsection "Relationship with DB_File"
Before Berkeley \s-1DB 2\s0.x was written there was only one Perl module that
interfaced to Berkeley \s-1DB.\s0 That module is called \fBDB_File\fR. Although
\&\fBDB_File\fR can be build with Berkeley \s-1DB 1\s0.x, 2.x, 3.x or 4.x, it only
provides an interface to the functionality available in Berkeley \s-1DB
1\s0.x. That means that it doesn't support transactions, locking or any of
the other new features available in \s-1DB 2\s0.x or better.
.SS "How do I store Perl data structures with BerkeleyDB?"
.IX Subsection "How do I store Perl data structures with BerkeleyDB?"
See \*(L"Using BerkeleyDB with \s-1MLDBM\*(R"\s0.
.SH "HISTORY"
.IX Header "HISTORY"
See the Changes file.
.SH "AVAILABILITY"
.IX Header "AVAILABILITY"
The most recent version of \fBBerkeleyDB\fR can always be found
on \s-1CPAN \s0(see \*(L"\s-1CPAN\*(R"\s0 in perlmod for details), in the directory
\&\fImodules/by\-module/BerkeleyDB\fR.
.PP
The official web site for Berkeley \s-1DB\s0 is \fIhttp://www.oracle.com/technology/products/berkeley\-db/db/index.html\fR.
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (c) 1997\-2013 Paul Marquess. All rights reserved. This program
is free software; you can redistribute it and/or modify it under the
same terms as Perl itself.
.PP
Although \fBBerkeleyDB\fR is covered by the Perl license, the library it
makes use of, namely Berkeley \s-1DB,\s0 is not. Berkeley \s-1DB\s0 has its own
copyright and its own license. Please take the time to read it.
.PP
Here are few words taken from the Berkeley \s-1DB FAQ \s0(at
\&\fIhttp://www.oracle.com/technology/products/berkeley\-db/db/index.html\fR) regarding the license:
.PP
.Vb 1
\&    Do I have to license DB to use it in Perl scripts?
\&
\&    No. The Berkeley DB license requires that software that uses
\&    Berkeley DB be freely redistributable. In the case of Perl, that
\&    software is Perl, and not your scripts. Any Perl scripts that you
\&    write are your property, including scripts that make use of Berkeley
\&    DB. Neither the Perl license nor the Berkeley DB license
\&    place any restriction on what you may do with them.
.Ve
.PP
If you are in any doubt about the license situation, contact either the
Berkeley \s-1DB\s0 authors or the author of BerkeleyDB.
See \*(L"\s-1AUTHOR\*(R"\s0 for details.
.SH "AUTHOR"
.IX Header "AUTHOR"
Paul Marquess <pmqs@cpan.org>.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fIperl\fR\|(1), DB_File, Berkeley \s-1DB.\s0
