.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "MooseX::Storage 3pm"
.TH MooseX::Storage 3pm "2013-12-21" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
MooseX::Storage \- A serialization framework for Moose classes
.SH "VERSION"
.IX Header "VERSION"
version 0.45
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 3
\&  package Point;
\&  use Moose;
\&  use MooseX::Storage;
\&
\&  with Storage(\*(Aqformat\*(Aq => \*(AqJSON\*(Aq, \*(Aqio\*(Aq => \*(AqFile\*(Aq);
\&
\&  has \*(Aqx\*(Aq => (is => \*(Aqrw\*(Aq, isa => \*(AqInt\*(Aq);
\&  has \*(Aqy\*(Aq => (is => \*(Aqrw\*(Aq, isa => \*(AqInt\*(Aq);
\&
\&  1;
\&
\&  my $p = Point\->new(x => 10, y => 10);
\&
\&  ## methods to pack/unpack an
\&  ## object in perl data structures
\&
\&  # pack the class into a hash
\&  $p\->pack(); # { _\|_CLASS_\|_ => \*(AqPoint\-0.01\*(Aq, x => 10, y => 10 }
\&
\&  # unpack the hash into a class
\&  my $p2 = Point\->unpack({ _\|_CLASS_\|_ => \*(AqPoint\-0.01\*(Aq, x => 10, y => 10 });
\&
\&  ## methods to freeze/thaw into
\&  ## a specified serialization format
\&  ## (in this case JSON)
\&
\&  # pack the class into a JSON string
\&  $p\->freeze(); # { "_\|_CLASS_\|_" : "Point\-0.01", "x" : 10, "y" : 10 }
\&
\&  # unpack the JSON string into a class
\&  my $p2 = Point\->thaw(\*(Aq{ "_\|_CLASS_\|_" : "Point\-0.01", "x" : 10, "y" : 10 }\*(Aq);
\&
\&  ## methods to load/store a class
\&  ## on the file system
\&
\&  $p\->store(\*(Aqmy_point.json\*(Aq);
\&
\&  my $p2 = Point\->load(\*(Aqmy_point.json\*(Aq);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
MooseX::Storage is a serialization framework for Moose, it provides
a very flexible and highly pluggable way to serialize Moose classes
to a number of different formats and styles.
.SS "Important Note"
.IX Subsection "Important Note"
This is still an early release of this module, so use with caution.
It's outward facing serialization \s-1API\s0 should be considered stable,
but I still reserve the right to make tweaks if I need too. Anything
beyond the basic pack/unpack, freeze/thaw and load/store should not
be relied on.
.SS "Levels of Serialization"
.IX Subsection "Levels of Serialization"
There are 3 levels to the serialization, each of which builds upon
the other and each of which can be customized to the specific needs
of your class.
.IP "\fBbase\fR" 4
.IX Item "base"
The first (base) level is \f(CW\*(C`pack\*(C'\fR and \f(CW\*(C`unpack\*(C'\fR. In this level the
class is serialized into a Perl \s-1HASH\s0 reference, it is tagged with the
class name and each instance attribute is stored. Very simple.
.Sp
This level is not optional, it is the bare minimum that
MooseX::Storage provides and all other levels build on top of this.
.Sp
See MooseX::Storage::Basic for the fundamental implementation and
options to \f(CW\*(C`pack\*(C'\fR and \f(CW\*(C`unpack\*(C'\fR
.IP "\fBformat\fR" 4
.IX Item "format"
The second (format) level is \f(CW\*(C`freeze\*(C'\fR and \f(CW\*(C`thaw\*(C'\fR. In this level the
output of \f(CW\*(C`pack\*(C'\fR is sent to \f(CW\*(C`freeze\*(C'\fR or the output of \f(CW\*(C`thaw\*(C'\fR is sent
to \f(CW\*(C`unpack\*(C'\fR. This levels primary role is to convert to and from the
specific serialization format and Perl land.
.Sp
This level is optional, if you don't want/need it, you don't have to
have it. You can just use \f(CW\*(C`pack\*(C'\fR/\f(CW\*(C`unpack\*(C'\fR instead.
.IP "\fBio\fR" 4
.IX Item "io"
The third (io) level is \f(CW\*(C`load\*(C'\fR and \f(CW\*(C`store\*(C'\fR. In this level we are reading
and writing data to file/network/database/etc.
.Sp
This level is also optional, in most cases it does require a \f(CW\*(C`format\*(C'\fR role
to also be used, the exception being the \f(CW\*(C`StorableFile\*(C'\fR role.
.SS "Behaviour modifiers"
.IX Subsection "Behaviour modifiers"
The serialization behaviour can be changed by supplying \f(CW\*(C`traits\*(C'\fR.
This can be done as follows:
.PP
.Vb 2
\&  use MooseX::Storage;
\&  with Storage( traits => [Trait1, Trait2,...] );
.Ve
.PP
The following traits are currently bundled with \f(CW\*(C`MooseX::Storage\*(C'\fR:
.IP "OnlyWhenBuilt" 4
.IX Item "OnlyWhenBuilt"
Only attributes that have been built (i.e., where the predicate returns
\&'true') will be serialized. This avoids any potentially expensive computations.
.Sp
See MooseX::Storage::Traits::OnlyWhenBuilt for details.
.SS "How we serialize"
.IX Subsection "How we serialize"
There are always limits to any serialization framework, there are just
some things which are really difficult to serialize properly and some
things which cannot be serialized at all.
.SS "What can be serialized?"
.IX Subsection "What can be serialized?"
Currently only numbers, string, \s-1ARRAY\s0 refs, \s-1HASH\s0 refs and other
MooseX::Storage enabled objects are supported.
.PP
With Array and Hash references the first level down is inspected and
any objects found are serialized/deserialized for you. We do not do
this recursively by default, however this feature may become an
option eventually.
.PP
The specific serialize/deserialize routine is determined by the
Moose type constraint a specific attribute has. In most cases subtypes
of the supported types are handled correctly, and there is a facility
for adding handlers for custom types as well. This will get documented
eventually, but it is currently still in development.
.SS "What can not be serialized?"
.IX Subsection "What can not be serialized?"
We do not support \s-1CODE\s0 references yet, but this support might be added
in using B::Deparse or some other deep magic.
.PP
Scalar refs are not supported, mostly because there is no way to know
if the value being referenced will be there when the object is inflated.
I highly doubt will be ever support this in a general sense, but it
would be possible to add this yourself for a small specific case.
.PP
Circular references are specifically disallowed, however if you break
the cycles yourself then re-assemble them later you can get around this.
The reason we disallow circular refs is because they are not always supported
in all formats we use, and they tend to be very tricky to do for all
possible cases. It is almost always something you want to have tight control
over anyway.
.SH "CAVEAT"
.IX Header "CAVEAT"
This is \fBnot\fR a persistence framework; changes to your object after
you load or store it will not be reflected in the stored class.
.SH "EXPORTS"
.IX Header "EXPORTS"
.IP "\fBStorage (%options)\fR" 4
.IX Item "Storage (%options)"
This module will export the \f(CW\*(C`Storage\*(C'\fR method and can be used to
load a specific set of MooseX::Storage roles to implement a specific
combination of features. It is meant to make things easier, but it
is by no means the only way. You can still compose your roles by
hand if you like.
.Sp
By default, options are assumed to be short forms.  For example, this:
.Sp
.Vb 1
\&  Storage(format => \*(AqJSON\*(Aq);
.Ve
.Sp
\&...will result in looking for MooseX::Storage::Format::JSON.  To use a role
that is not under the default namespace prefix, start with an equal sign:
.Sp
.Vb 1
\&  Storage(format => \*(Aq=My::Private::JSONFormat\*(Aq);
.Ve
.Sp
To use a parameterized role (for which, see MooseX::Role::Parameterized) you
can pass an arrayref of the role name (in short or long form, as above) and its
parameters:
.Sp
.Vb 1
\&  Storage(format => [ JSONpm => { json_opts => { pretty => 1 } } ]);
.Ve
.SH "METHODS"
.IX Header "METHODS"
.IP "\fBimport\fR" 4
.IX Item "import"
.SS "Introspection"
.IX Subsection "Introspection"
.PD 0
.IP "\fBmeta\fR" 4
.IX Item "meta"
.PD
.SH "TODO"
.IX Header "TODO"
This module needs docs and probably a Cookbook of some kind as well.
This is an early release, so that is my excuse for now :)
.PP
For the time being, please read the tests and feel free to email me
if you have any questions. This module can also be discussed on \s-1IRC\s0
in the #moose channel on irc.perl.org.
.SH "BUGS"
.IX Header "BUGS"
All complex software has bugs lurking in it, and this module is no
exception. If you find a bug please either email me, or add the bug
to cpan-RT.
.SH "AUTHORS"
.IX Header "AUTHORS"
.IP "\(bu" 4
Chris Prather <chris.prather@iinteractive.com>
.IP "\(bu" 4
Stevan Little <stevan.little@iinteractive.com>
.IP "\(bu" 4
\&\s-1XXXX XXX\s0'\s-1XX \s0(Yuval Kogman) <nothingmuch@woobling.org>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is copyright (c) 2007 by Infinity Interactive, Inc..
.PP
This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.
.SH "CONTRIBUTORS"
.IX Header "CONTRIBUTORS"
.IP "\(bu" 4
Chris Prather <chris@prather.org>
.IP "\(bu" 4
Cory Watson <gphat@Crankwizzah.local>
.IP "\(bu" 4
Dagfinn Ilmari Mannsa\*oker <ilmari@ilmari.org>
.IP "\(bu" 4
David Golden <dagolden@cpan.org>
.IP "\(bu" 4
David Steinbrunner <dsteinbrunner@pobox.com>
.IP "\(bu" 4
Florian Ragwitz <rafl@debian.org>
.IP "\(bu" 4
Johannes Plunien <plu@pqpq.de>
.IP "\(bu" 4
Jonathan Rockway <jon@jrock.us>
.IP "\(bu" 4
Jonathan Yu <frequency@cpan.org>
.IP "\(bu" 4
Jos Boumans <jos@dwim.org>
.IP "\(bu" 4
Karen Etheridge <ether@cpan.org>
.IP "\(bu" 4
Ricardo Signes <rjbs@cpan.org>
.IP "\(bu" 4
Robert Boone <robo4288@gmail.com>
.IP "\(bu" 4
Shawn M Moore <sartak@gmail.com>
.IP "\(bu" 4
Tomas Doran <bobtfish@bobtfish.net>
.IP "\(bu" 4
Yuval Kogman <nothingmuch@woobling.org>
