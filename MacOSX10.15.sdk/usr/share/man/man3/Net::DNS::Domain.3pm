.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Net::DNS::Domain 3"
.TH Net::DNS::Domain 3 "2014-01-16" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Net::DNS::Domain \- Domain Name System domains
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use Net::DNS::Domain;
\&
\&    $domain = new Net::DNS::Domain(\*(Aqexample.com\*(Aq);
\&    $name   = $domain\->name;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The Net::DNS::Domain module implements a class of abstract \s-1DNS\s0
domain objects with associated class and instance methods.
.PP
Each domain object instance represents a single \s-1DNS\s0 domain which
has a fixed identity throughout its lifetime.
.PP
Internally, the primary representation is a (possibly empty) list
of \s-1ASCII\s0 domain name labels, and optional link to an arbitrary
origin domain object topologically closer to the \s-1DNS\s0 root.
.PP
The computational expense of Unicode character-set conversion is
partially mitigated by use of caches.
.SH "METHODS"
.IX Header "METHODS"
.SS "new"
.IX Subsection "new"
.Vb 1
\&    $object = new Net::DNS::Domain(\*(Aqexample.com\*(Aq);
.Ve
.PP
Creates a domain object which represents the \s-1DNS\s0 domain specified
by the character string argument. The argument consists of a
sequence of labels delimited by dots.
.PP
A character preceded by \e represents itself, without any special
interpretation.
.PP
Arbitrary 8\-bit codes can be represented by \e followed by exactly
three decimal digits.
Character code points are \s-1ASCII,\s0 irrespective of the character
coding scheme employed by the underlying platform.
.PP
Argument string literals should be delimited by single quotes to
avoid escape sequences being interpreted as octal character codes
by the Perl compiler.
.PP
The character string presentation format follows the conventions
for zone files described in \s-1RFC1035.\s0
.SS "name"
.IX Subsection "name"
.Vb 1
\&    $name = $domain\->name;
.Ve
.PP
Returns the domain name as a character string corresponding to the
\&\*(L"common interpretation\*(R" to which \s-1RFC1034, 3.1,\s0 paragraph 9 alludes.
.PP
Character escape sequences are used to represent a dot inside a
domain name label and the escape character itself.
.PP
Any non-printable code point is represented using the appropriate
numerical escape sequence.
.SS "fqdn"
.IX Subsection "fqdn"
.Vb 1
\&    @fqdn = $domain\->fqdn;
.Ve
.PP
Returns a character string containing the fully qualified domain
name, including the trailing dot.
.SS "xname"
.IX Subsection "xname"
.Vb 1
\&    $xname = $domain\->xname;
.Ve
.PP
Interprets an extended name containing Unicode domain name labels
encoded as Punycode A\-labels.
.PP
Domain names containing Unicode characters are supported if the
Net::LibIDN module is installed.
.SS "label"
.IX Subsection "label"
.Vb 1
\&    @label = $domain\->label;
.Ve
.PP
Identifies the domain by means of a list of domain labels.
.SS "string"
.IX Subsection "string"
.Vb 1
\&    $string = $object\->string;
.Ve
.PP
Returns a character string containing the fully qualified domain
name as it appears in a zone file.
.PP
Characters which are recognised by \s-1RFC1035\s0 zone file syntax are
represented by the appropriate escape sequence.
.SS "origin"
.IX Subsection "origin"
.Vb 3
\&    $create = origin Net::DNS::Domain( $ORIGIN );
\&    $result = &$create( sub{ new Net::DNS::RR( \*(Aqmx MX 10 a\*(Aq ); } );
\&    $expect = new Net::DNS::RR( "mx.$ORIGIN. MX 10 a.$ORIGIN." );
.Ve
.PP
Class method which returns a reference to a subroutine wrapper
which executes a given constructor in a dynamically scoped context
where relative names become descendents of the specified \f(CW$ORIGIN\fR.
.SH "BUGS"
.IX Header "BUGS"
Coding strategy is intended to avoid creating unnecessary argument
lists and stack frames. This improves efficiency at the expense of
code readability.
.PP
Platform specific character coding features are conditionally
compiled into the code.
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (c)2009\-2011 Dick Franks.
.PP
All rights reserved.
.PP
This program is free software; you may redistribute it and/or
modify it under the same terms as Perl itself.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
perl, Net::LibIDN, Net::DNS, \s-1RFC1034, RFC1035, RFC5891,\s0
Unicode Technical Report #16
