.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Data::Compare 3"
.TH Data::Compare 3 "2013-09-26" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Data::Compare \- compare perl data structures
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use Data::Compare;
\&
\&    my $h1 = { \*(Aqfoo\*(Aq => [ \*(Aqbar\*(Aq, \*(Aqbaz\*(Aq ],  \*(AqFOO\*(Aq => [ \*(Aqone\*(Aq, \*(Aqtwo\*(Aq ] };
\&    my $h2 = { \*(Aqfoo\*(Aq => [ \*(Aqbar\*(Aq, \*(Aqbarf\*(Aq ], \*(AqFOO\*(Aq => [ \*(Aqone\*(Aq, \*(Aqtwo\*(Aq ] };
\&    my @a1 = (\*(Aqone\*(Aq, \*(Aqtwo\*(Aq);
\&    my @a2 = (\*(Aqbar\*(Aq, \*(Aqbaz\*(Aq);
\&    my %v = ( \*(AqFOO\*(Aq, \e@a1, \*(Aqfoo\*(Aq, \e@a2 );
\&
\&    # simple procedural interface
\&    print \*(Aqstructures of $h1 and \e%v are \*(Aq,
\&      Compare($h1, \e%v) ? "" : "not ", "identical.\en";
\&
\&    print \*(Aqstructures of $h1 and $h2 are \*(Aq,
\&      Compare($h1, $h2, { ignore_hash_keys => [qw(foo)] }) ? \*(Aq\*(Aq : \*(Aqnot \*(Aq,
\&      "close enough to identical.\en";
\&
\&    # OO usage
\&    my $c = new Data::Compare($h1, \e%v);
\&    print \*(Aqstructures of $h1 and \e%v are \*(Aq,
\&      $c\->Cmp ? "" : "not ", "identical.\en";
\&    # or
\&    my $c = new Data::Compare;
\&    print \*(Aqstructures of $h and \e%v are \*(Aq,
\&      $c\->Cmp($h1, \e%v) ? "" : "not ", "identical.\en";
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Compare two perl data structures recursively. Returns 0 if the
structures differ, else returns 1.
.PP
A few data types are treated as special cases:
.IP "Scalar::Properties objects" 4
.IX Item "Scalar::Properties objects"
This has been moved into a plugin, although functionality remains the
same as with the previous version.  Full documentation is in
Data::Compare::Plugins::Scalar::Properties.
.IP "Compiled regular expressions, eg qr/foo/" 4
.IX Item "Compiled regular expressions, eg qr/foo/"
These are stringified before comparison, so the following will match:
.Sp
.Vb 3
\&    $r = qr/abc/i;
\&    $s = qr/abc/i;
\&    Compare($r, $s);
.Ve
.Sp
and the following won't, despite them matching *exactly* the same text:
.Sp
.Vb 3
\&    $r = qr/abc/i;
\&    $s = qr/[aA][bB][cC]/;
\&    Compare($r, $s);
.Ve
.Sp
Sorry, that's the best we can do.
.IP "\s-1CODE\s0 and \s-1GLOB\s0 references" 4
.IX Item "CODE and GLOB references"
These are assumed not to match unless the references are identical \- ie,
both are references to the same thing.
.PP
You may also customise how we compare structures by supplying options in
a hashref as a third parameter to the \f(CW\*(C`Compare()\*(C'\fR function.  This is not
yet available through the OO-ish interface.  These options will be in
force for the *whole* of your comparison, so will apply to structures
that are lurking deep down in your data as well as at the top level, so
beware!
.IP "ignore_hash_keys" 4
.IX Item "ignore_hash_keys"
an arrayref of strings. When comparing two hashes, any keys mentioned in
this list will be ignored.
.SH "CIRCULAR STRUCTURES"
.IX Header "CIRCULAR STRUCTURES"
Comparing a circular structure to itself returns true:
.PP
.Vb 3
\&    $x = \e$y;
\&    $y = \e$x;
\&    Compare([$x, $y], [$x, $y]);
.Ve
.PP
And on a sort-of-related note, if you try to compare insanely deeply nested
structures, the module will spit a warning.  For this to affect you, you need to go
around a hundred levels deep though, and if you do that you have bigger
problems which I can't help you with ;\-)
.SH "PLUGINS"
.IX Header "PLUGINS"
The module takes plug-ins so you can provide specialised routines for
comparing your own objects and data-types.  For details see
Data::Compare::Plugins.
.PP
Plugins are *not* available when running in \*(L"taint\*(R" mode.  You may
also make it not load plugins by providing an empty list as the
argument to \fIimport()\fR \- ie, by doing this:
.PP
.Vb 1
\&    use Data::Compare ();
.Ve
.PP
A couple of functions are provided to examine what goodies have been
made available through plugins:
.IP "plugins" 4
.IX Item "plugins"
Returns a structure (a hash ref) describing all the comparisons made
available through plugins.
This function is *not* exported, so should be called as \fIData::Compare::plugins()\fR.
It takes no parameters.
.IP "plugins_printable" 4
.IX Item "plugins_printable"
Returns formatted text
.SH "EXPORTS"
.IX Header "EXPORTS"
For historical reasons, the \fICompare()\fR function is exported.  If you
don't want this, then pass an empty list to \fIimport()\fR as explained
under \s-1PLUGINS. \s0 If you want no export but do want plugins, then pass
the empty list, and then call the register_plugins class method:
.PP
.Vb 2
\&    use Data::Compare ();
\&    Data::Compare\->register_plugins;
.Ve
.PP
or you could call it as a function if that floats your boat.
.SH "SOURCE CODE REPOSITORY"
.IX Header "SOURCE CODE REPOSITORY"
<git://github.com/DrHyde/perl\-modules\-Data\-Compare.git>
.SH "BUGS"
.IX Header "BUGS"
Plugin support is not quite finished (see the \s-1TODO\s0 file for details) but
is usable.  The missing bits are bells and whistles rather than core
functionality.
.PP
Please report any other bugs either by email to David Cantrell (see below
for address) or using rt.cpan.org:
.PP
<https://rt.cpan.org/Ticket/Create.html?Queue=Data\-Compare>
.SH "AUTHOR"
.IX Header "AUTHOR"
Fabien Tassin <fta@sofaraway.org>
.PP
Portions by David Cantrell <david@cantrell.org.uk>
.SH "COPYRIGHT and LICENCE"
.IX Header "COPYRIGHT and LICENCE"
Copyright (c) 1999\-2001 Fabien Tassin. All rights reserved.
This program is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.
.PP
Some parts copyright 2003 \- 2013 David Cantrell.
.PP
Seeing that Fabien seems to have disappeared, David Cantrell has become
a co-maintainer so he can apply needed patches.  The licence, of course,
remains the same.  As the \*(L"perl licence\*(R" is \*(L"Artistic or \s-1GPL,\s0 your choice\*(R",
you can find them as the files \s-1ARTISTIC\s0.txt and \s-1GPL2\s0.txt in the
distribution.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fIperl\fR\|(1), \fIperlref\fR\|(1)
