.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Parse::Eyapp::Driver 3"
.TH Parse::Eyapp::Driver 3 "2012-03-23" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Parse::Eyapp::Driver \- The LR parser
.SH "INTRODUCTION"
.IX Header "INTRODUCTION"
This class has the method \f(CW\*(C`YYParse\*(C'\fR implementing the \s-1LR\s0 generic
parsing algorithm plus the methods that give support to the generated
parser.
.ie n .SH "THE ""YYParse"" METHOD"
.el .SH "THE \f(CWYYParse\fP METHOD"
.IX Header "THE YYParse METHOD"
The \f(CW\*(C`YYParse\*(C'\fR methods implements the generic \s-1LR\s0 parsing algorithm.
It very much works \f(CW\*(C`Parse::Yapp::YYParse\*(C'\fR and as yacc/bison \f(CW\*(C`yyparse\*(C'\fR.
It accepts almost the same arguments as \f(CW\*(C`Class\->new\*(C'\fR (Being \f(CW\*(C`Class\*(C'\fR the name 
of the generated class).
.PP
The parser uses two tables and a stack. The two tables
are called the \fIaction\fR table and the \fIgoto\fR table.
The stack is used to keep track of the states visited.
.PP
At each step the generated parser consults the 
\&\f(CW\*(C`action\*(C'\fR table and takes one decision:
To shift to a new state consuming one token (and pushing 
the current state in the stack) or to reduce by some
production rule. In the last case the parser pops
from its stack as many states as symbols are on the right hand side
of the production rule. Here is a Perl/C like pseudocode
summarizing the activity of \f(CW\*(C`YYParse\*(C'\fR:
.PP
.Vb 10
\&     1   my $parser = shift; # The parser object
\&     2   push(@stack, $parser\->{startstate});
\&     3   $b = $parser\->YYLexer(); # Get the first token
\&     4   FOREVER: {
\&     5     $s = top(0);  # Get the state on top of the stack
\&     6     $a = $b;
\&     7     switch ($parser\->action[$s\->state][$a]) {
\&     8       case "shift t" : 
\&     9         my $t;
\&    10         $t\->{state} = t;
\&    11         $t\->{attr}  = $a\->{attr};
\&    12         push($t); 
\&    13         $b = $parser\->YYLexer(); # Call the lexical analyzer
\&    14         break;
\&    15       case "reduce A\->alpha" : 
\&    16         # Call the semantic action with the attributes of the rhs as args
\&    17         my $semantic  = $parser\->Semantic{A \->alpha}; # The semantic action
\&    18         my $r;
\&    19         $r\->{attr} = $semantic\->($parser, top(|alpha|\-1)\->attr, ... , top(0)\->attr); 
\&    20  
\&    21         # Pop as many states as symbols on the rhs of A\->alpha
\&    22         pop(|alpha|);  
\&    23  
\&    24         # Goto next state 
\&    25         $r\->{state} = $parser\->goto[top(0)][A]; 
\&    26         push($r); 
\&    27         break;
\&    28       case "accept" : return (1); 
\&    29       default : $parser\->YYError("syntax error"); 
\&    30     }
\&    31     redo FOREVER;
\&    32   }
.Ve
.PP
Here \f(CW\*(C`|alpha|\*(C'\fR stands for the length of \f(CW\*(C`alpha\*(C'\fR. Function \f(CWtop(k)\fR returns
the state in position \f(CW\*(C`k\*(C'\fR from the top of the stack, i.e. the state at depth \f(CW\*(C`k\*(C'\fR.
Function \f(CWpop(k)\fR extracts \f(CW\*(C`k\*(C'\fR states from the stack. The call \f(CW\*(C`$state\->attr\*(C'\fR
returns the attribute associated with \f(CW$state\fR. The call \f(CW\*(C`$parser\->Semantic{A \->alpha}\*(C'\fR
returns the semantic action associated with production \f(CW\*(C`A \->alpha\*(C'\fR.
.PP
Let us see a trace for the small grammar in \f(CW\*(C`examples/debuggingtut/aSb.yp\*(C'\fR:
.PP
.Vb 6
\&  pl@nereida:~/LEyapp/examples$ /usr/local/bin/paste.pl aSb.yp aSb.output | head \-5
\&  %%                                             | Rules:
\&  S:                 { print "S \-> epsilon\en" }  | \-\-\-\-\-\-
\&      |   \*(Aqa\*(Aq S \*(Aqb\*(Aq  { print "S \-> a S b\en" }    | 0:    $start \-> S $end
\&  ;                                              | 1:    S \-> /* empty */
\&  %%                                             | 2:    S \-> \*(Aqa\*(Aq S \*(Aqb\*(Aq
.Ve
.PP
The tables in file \f(CW\*(C`aSb.output\*(C'\fR describe the 
actions and transitions to take:
.PP
.Vb 10
\&  pl@nereida:~/LEyapp/examples$ cat \-n aSb.output
\&     .  .........................................
\&     7  States:
\&     8  \-\-\-\-\-\-\-
\&     9  State 0:
\&    10
\&    11          $start \-> . S $end      (Rule 0)
\&    12
\&    13          \*(Aqa\*(Aq     shift, and go to state 2
\&    14
\&    15          $default        reduce using rule 1 (S)
\&    16
\&    17          S       go to state 1
\&    18
\&    19  State 1:
\&    20
\&    21          $start \-> S . $end      (Rule 0)
\&    22
\&    23          $end    shift, and go to state 3
\&    24
\&    25  State 2:
\&    26
\&    27          S \-> \*(Aqa\*(Aq . S \*(Aqb\*(Aq        (Rule 2)
\&    28
\&    29          \*(Aqa\*(Aq     shift, and go to state 2
\&    30
\&    31          $default        reduce using rule 1 (S)
\&    32
\&    33          S       go to state 4
\&    34
\&    35  State 3:
\&    36
\&    37          $start \-> S $end .      (Rule 0)
\&    38
\&    39          $default        accept
\&    40
\&    41  State 4:
\&    42
\&    43          S \-> \*(Aqa\*(Aq S . \*(Aqb\*(Aq        (Rule 2)
\&    44
\&    45          \*(Aqb\*(Aq     shift, and go to state 5
\&    46
\&    47  State 5:
\&    48
\&    49          S \-> \*(Aqa\*(Aq S \*(Aqb\*(Aq .        (Rule 2)
\&    50
\&    51          $default        reduce using rule 2 (S)
\&    52
\&    53
\&    54  Summary:
\&    55  \-\-\-\-\-\-\-\-
\&    56  Number of rules         : 3
\&    57  Number of terminals     : 3
\&    58  Number of non\-terminals : 2
\&    59  Number of states        : 6
.Ve
.PP
When executed with \f(CW\*(C`yydebug\*(C'\fR set and input \f(CW\*(C`aabb\*(C'\fR  we obtain the following 
output:
.PP
.Vb 10
\&  pl@nereida:~/LEyapp/examples/debuggingtut$ eyapp \-b \*(Aq\*(Aq \-o use_aSb.pl aSb
\&  pl@nereida:~/LEyapp/examples/debuggingtut$ ./use_aSb.pl \-d
\&  Provide a statement like "a a b b" and press <CR><CTRL\-D>: aabb
\&  \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-                       
\&  In state 0:                                                    
\&  Stack:[0]                                                      
\&  Need token. Got >a<                                            
\&  Shift and go to state 2.                                       
\&  \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-                       
\&  In state 2:                                                    
\&  Stack:[0,2]                                                    
\&  Need token. Got >a<
\&  Shift and go to state 2.
\&  \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&  In state 2:
\&  Stack:[0,2,2]
\&  Need token. Got >b<
\&  Reduce using rule 1 (S \-\-> /* empty */): S \-> epsilon
\&  Back to state 2, then go to state 4.
\&  \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&  In state 4:
\&  Stack:[0,2,2,4]
\&  Shift and go to state 5.
\&  \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&  In state 5:
\&  Stack:[0,2,2,4,5]
\&  Don\*(Aqt need token.
\&  Reduce using rule 2 (S \-\-> a S b): S \-> a S b
\&  Back to state 2, then go to state 4.
\&  \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
.Ve
.PP
As a result of reducing by rule 2 
the three last
visited states are popped
from the stack, and the stack becomes \f(CW\*(C`[0,2]\*(C'\fR. But 
that means that we are now in state 2 seeing a \f(CW\*(C`S\*(C'\fR. 
If you look at the table above being in state 2 and seeing a \f(CW\*(C`S\*(C'\fR
we go to state 4.
.PP
.Vb 10
\&  In state 4:
\&  Stack:[0,2,4]
\&  Need token. Got >b<
\&  Shift and go to state 5.
\&  \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&  In state 5:
\&  Stack:[0,2,4,5]
\&  Don\*(Aqt need token.
\&  Reduce using rule 2 (S \-\-> a S b): S \-> a S b
\&  Back to state 0, then go to state 1.
\&  \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&  In state 1:
\&  Stack:[0,1]
\&  Need token. Got ><
\&  Shift and go to state 3.
\&  \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&  In state 3:
\&  Stack:[0,1,3]
\&  Don\*(Aqt need token.
\&  Accept.
.Ve
.ie n .SH "METHODS IN THE GENERATED CLASS: ""Parse::Eyapp::Driver"" METHODS"
.el .SH "METHODS IN THE GENERATED CLASS: \f(CWParse::Eyapp::Driver\fP METHODS"
.IX Header "METHODS IN THE GENERATED CLASS: Parse::Eyapp::Driver METHODS"
The class containing the parser generated by \f(CW\*(C`Parse::Eyapp\*(C'\fR inherits
from \f(CW\*(C`Parse::Eyapp::Driver\*(C'\fR. Therefore all the methods in
\&\f(CW\*(C`Parse::Eyapp::Driver\*(C'\fR  are available in the generated class.
.PP
This section describes the methods and objects belonging
to the class generated either using eyapp 
or \f(CW\*(C`Parse::Eyapp\->new_grammar\*(C'\fR. In the incoming paragraphs
we will assume that \f(CW\*(C`Class\*(C'\fR was the 
value selected for the \f(CW\*(C`classname\*(C'\fR argument
when \f(CW\*(C`Parse::Eyapp\->new_grammar\*(C'\fR was called.
Objects belonging to  \f(CW\*(C`Class\*(C'\fR are the actual parsers for the 
input grammar.
.SS "Class\->new"
.IX Subsection "Class->new"
The method \f(CW\*(C`Class\->new\*(C'\fR returns a new \s-1LALR\s0 parser object.
Here \f(CW\*(C`Class\*(C'\fR stands for the name of the class containing the parser.
See an example of call:
.PP
.Vb 5
\&  my $parser = main\->new(yyprefix => \*(AqParse::Eyapp::Node::\*(Aq,
\&                         yylex    => \e&main::_Lexer,
\&                         yyerror  => \e&main::_Error,
\&                         yydebug => 0x1F,
\&  );
.Ve
.PP
The meaning of the arguments used in the example are as follows:
.IP "\- yyprefix" 4
.IX Item "- yyprefix"
Used with \f(CW%tree\fR or \f(CW%metatree\fR. 
When used, the type names of the nodes of the syntax tree will
be build prefixing the value associated to \f(CW\*(C`yyprefix\*(C'\fR to the name of the production
rule. The name of the production rule is either explicitly given through a \f(CW%name\fR
directive or the concatenation of the left hand side of the rule with the
ordinal of the right hand side of the production. 
See section \*(L"Compiling with eyapp and treereg\*(R" in Parse::Eyapp for an example.
.IP "\- yylex" 4
.IX Item "- yylex"
Reference to the lexical analyzer subroutine
.IP "\- yyerror" 4
.IX Item "- yyerror"
Reference to the error subroutine. The error subroutine receives
as first argument the reference to the \f(CW\*(C`Class\*(C'\fR parser object.
This way it can take advantage of methods like \f(CW\*(C`YYCurval\*(C'\fR
and YYExpect (see below):
.Sp
.Vb 4
\&  sub _Error {
\&    my($token)=$_[0]\->YYCurval;
\&    my($what)= $token ? "input: \*(Aq$token\*(Aq" : "end of input";
\&    my @expected = $_[0]\->YYExpect();
\&
\&    local $" = \*(Aq, \*(Aq;
\&    die "Syntax error near $what. Expected one of these tokens: @expected\en";
\&  }
.Ve
.IP "\- yydebug" 4
.IX Item "- yydebug"
Controls the level of debugging. Must be a number.
.PP
The package produced from the grammar has several methods.
.PP
The parser object has the following methods that work at parsing time
exactly as in Parse::Yapp. These methods can be found
in the module Parse::Eyapp::Driver. 
Assume you have in \f(CW$parser\fR the reference
to your parser object:
.ie n .SS "$parser\->YYAction"
.el .SS "\f(CW$parser\fP\->YYAction"
.IX Subsection "$parser->YYAction"
Receives the name of a production and a subroutine reference implementing the new semantic action.
If no subroutine reference is set returns the reference to the current semantic action. See 
the tutorial Parse::Eyapp::defaultaction and the examples in the \f(CW\*(C`examples/recycle/\*(C'\fR directory
.ie n .SS " $parser\->YYAccept"
.el .SS " \f(CW$parser\fP\->YYAccept"
.IX Subsection " $parser->YYAccept"
Works as yacc/bison \f(CW\*(C`YYACCEPT\*(C'\fR.
The parser finishes returning 
the current semantic value to indicate success.
.ie n .SS " $parser\->YYAbort"
.el .SS " \f(CW$parser\fP\->YYAbort"
.IX Subsection " $parser->YYAbort"
Works as yacc/bison \f(CW\*(C`YYABORT\*(C'\fR. 
The parser finishes returning 
\&\f(CW\*(C`undef\*(C'\fR to indicate failure.
.SS "Parse::Eyapp::Driver::BeANode"
.IX Subsection "Parse::Eyapp::Driver::BeANode"
Is not a method.
Receives as input a \f(CW\*(C`Class\*(C'\fR name. 
Introduces \f(CW\*(C`Parse::Eyapp::Node\*(C'\fR as an ancestor class
of \f(CW\*(C`Class\*(C'\fR. To work correctly, objects belonging to 
\&\f(CW\*(C`Class\*(C'\fR must be hashes
with a \f(CW\*(C`children\*(C'\fR key whose value must be a reference
to the array of children. The children must be also
\&\f(CW\*(C`Parse::Eyapp::Node\*(C'\fR nodes.
Actually you can circumvent this call by directly introducing
\&\f(CW\*(C`Parse::Eyapp::Node\*(C'\fR in the ancestors of \f(CW\*(C`Class\*(C'\fR:
.PP
.Vb 1
\&         push @{$class."::ISA"}, "Parse::Eyapp::Node"
.Ve
.ie n .SS "$parser\->YYBuildAST"
.el .SS "\f(CW$parser\fP\->YYBuildAST"
.IX Subsection "$parser->YYBuildAST"
Sometimes the best time to decorate a node with some attributes is just
after being built. In such cases the programmer can take manual control
building the node with \f(CW\*(C`YYBuildAST\*(C'\fR to immediately proceed to decorate it.
.PP
The following example from the file \f(CW\*(C`lib/Simple/Types.eyp\*(C'\fR
in the tarball in \f(CW\*(C`examples/typechecking/Simple\-Types\-XXX.tar.gz\*(C'\fR
illustrates the idea:
.PP
.Vb 9
\& Variable:
\&     %name  VARARRAY
\&     $ID (\*(Aq[\*(Aq binary \*(Aq]\*(Aq) <%name INDEXSPEC +>
\&       {
\&         my $self = shift;
\&         my $node =  $self\->YYBuildAST(@_);
\&         $node\->{line} = $ID\->[1];
\&         return $node;
\&       }
.Ve
.PP
Actually, the \f(CW%tree\fR directive is semantically equivalent to:
.PP
.Vb 1
\&  %default action { goto &Parse::Eyapp::Driver::YYBuildAST }
.Ve
.ie n .SS " $parser\->YYBuildingTree"
.el .SS " \f(CW$parser\fP\->YYBuildingTree"
.IX Subsection " $parser->YYBuildingTree"
Influences the semantic of list operators. 
If true the action associated with \f(CW\*(C`X+\*(C'\fR
will be to build a \f(CW\*(C`Parse::Eyapp::Node\*(C'\fR node
with all the attributes of the elements in the list
as children. This is the appropriate semantic
when working under the \f(CW%tree\fR directive.
If set to false the semantic action will return
an anonymous list with the attributes 
associated with the \f(CW\*(C`X\*(C'\fR in the plus list.
Same thing with the operators \f(CW\*(C`*\*(C'\fR and \f(CW\*(C`?\*(C'\fR.
.ie n .SS "$parser\->YYBuildTS"
.el .SS "\f(CW$parser\fP\->YYBuildTS"
.IX Subsection "$parser->YYBuildTS"
Similar to \f(CW\*(C`$parser\->YYBuildAST\*(C'\fR but builds nodes for translation schemes.
.ie n .SS "$parser\->YYBypass"
.el .SS "\f(CW$parser\fP\->YYBypass"
.IX Subsection "$parser->YYBypass"
Returns \s-1TRUE\s0 if running under the \f(CW\*(C`%tree bypass\*(C'\fR clause
.ie n .SS "$parser\->YYBypassrule"
.el .SS "\f(CW$parser\fP\->YYBypassrule"
.IX Subsection "$parser->YYBypassrule"
Returns \s-1TRUE\s0 if the production being
used for reduction was marked to be bypassed.
.ie n .SS " $parser\->YYCurtok"
.el .SS " \f(CW$parser\fP\->YYCurtok"
.IX Subsection " $parser->YYCurtok"
Gives the current token
.ie n .SS " $parser\->YYCurval"
.el .SS " \f(CW$parser\fP\->YYCurval"
.IX Subsection " $parser->YYCurval"
Gives the attribute associated with the current token
.ie n .SS "$parser\->YYDelegateaction"
.el .SS "\f(CW$parser\fP\->YYDelegateaction"
.IX Subsection "$parser->YYDelegateaction"
Use it as \f(CW\*(C`defaultaction\*(C'\fR if you want to recycle your grammar.
It is equivalent to:
.PP
.Vb 2
\&  sub YYDelegateaction {
\&    my $self = shift;
\&
\&    my $action = $self\->YYName;
\&
\&    $self\->$action(@_);
\&  }
.Ve
.PP
For a full example illustrating how to use it, see files \f(CW\*(C`examples/recycle/NoacInh.eyp\*(C'\fR
and \f(CW\*(C`examples/recycle/icalcu_and_ipost.pl\*(C'\fR
in the Parse::Eyapp distribution
.ie n .SS " $parser\->YYEndOfInput"
.el .SS " \f(CW$parser\fP\->YYEndOfInput"
.IX Subsection " $parser->YYEndOfInput"
True if the \f(CW\*(C`pos()\*(C'\fR of the input being scanned in \f(CW\*(C`${$parser\->input}\*(C'\fR is at the end
.ie n .SS " $parser\->YYErrok"
.el .SS " \f(CW$parser\fP\->YYErrok"
.IX Subsection " $parser->YYErrok"
Works as yacc/bison \f(CW\*(C`yyerrok\*(C'\fR. 
Modifies the error status
so that subsequent 
error messages will be emitted.
.ie n .SS " $parser\->YYError"
.el .SS " \f(CW$parser\fP\->YYError"
.IX Subsection " $parser->YYError"
Works as yacc/bison \f(CW\*(C`YYERROR\*(C'\fR.
Pretends that a syntax error has been detected.
.ie n .SS " $parser\->YYExpect"
.el .SS " \f(CW$parser\fP\->YYExpect"
.IX Subsection " $parser->YYExpect"
Returns the list of tokens the parser 
expected when the failure occurred
.PP
.Vb 6
\& pl@nereida:~/src/perl/YappWithDefaultAction/examples$ \e
\&                            sed \-ne \*(Aq26,33p\*(Aq Postfix.eyp
\& sub _Error {
\&   my($token)=$_[0]\->YYCurval;
\&   my($what)= $token ? "input: \*(Aq$token\*(Aq" : "end of input";
\&   my @expected = $_[0]\->YYExpect();
\&
\&   local $" = \*(Aq, \*(Aq;
\&   die "Syntax error near $what. Expected one of these tokens: @expected\en";
\& }
.Ve
.PP
See the tutorial Parse::Eyapp::datagenerationtut and 
the section \fI\s-1TOKENS DEPENDING ON THE SYNTACTIC CONTEXT\s0\fR
in the tutorial Parse::Eyapp::debuggingtut for more detailed 
examples of use of \f(CW\*(C`YYExpect\*(C'\fR.
.ie n .SS "$parser\->YYFirstline"
.el .SS "\f(CW$parser\fP\->YYFirstline"
.IX Subsection "$parser->YYFirstline"
First line of the input string describing the grammar
.ie n .SS "$parser\->YYGrammar"
.el .SS "\f(CW$parser\fP\->YYGrammar"
.IX Subsection "$parser->YYGrammar"
Return the list of grammar items.
Each item is an anonymous list containing
.IP "\(bu" 2
The name of the production
.IP "\(bu" 2
The \s-1LHS\s0 of the production
.IP "\(bu" 2
An anonymous list containing the symbols in the \s-1RHS\s0
.PP
If it receives an index as argument returns the corresponding item
The following debugger session explain its use:
.PP
.Vb 10
\&  pl@europa:~/LEyapp/examples/recycle$ perl \-wd usepostfix.pl
\&  main::(usepostfix.pl:5):        my $parser = new Postfix();
\&    DB<1> n
\&  main::(usepostfix.pl:6):        $parser\->Run;
\&    DB<1> x $parser\->YYGrammar
\&  0  ARRAY(0xde5e20)
\&     0  \*(Aq_SUPERSTART\*(Aq
\&     1  \*(Aq$start\*(Aq
\&     2  ARRAY(0xc85e80)
\&        0  \*(Aqline\*(Aq
\&        1  \*(Aq$end\*(Aq
\&     3  0
\&  1  ARRAY(0xe2b6b0)
\&     0  \*(Aqline_1\*(Aq
\&     1  \*(Aqline\*(Aq
\&     2  ARRAY(0xe3abc0)
\&        0  \*(Aqexp\*(Aq
\&     3  0
\&  2  ARRAY(0xa05530)
\&     0  \*(Aqexp_2\*(Aq
\&     1  \*(Aqexp\*(Aq
\&     2  ARRAY(0x75bdc0)
\&        0  \*(AqNUM\*(Aq
\&     3  0
\&
\&     ...  etc, etc
.Ve
.PP
If an index is provided it returns the item for such number:
.PP
.Vb 8
\&    DB<2> x $parser\->YYGrammar(10)
\&  0  \*(Aqexp_10\*(Aq
\&  1  \*(Aqexp\*(Aq
\&  2  ARRAY(0xa05f80)
\&     0  \*(Aq(\*(Aq
\&     1  \*(Aqexp\*(Aq
\&     2  \*(Aq)\*(Aq
\&  3  0
.Ve
.PP
You can also use a production name as argument:
.PP
.Vb 8
\&    DB<3> x $parser\->YYGrammar(\*(Aqexp_7\*(Aq)
\&  0  \*(Aqexp_7\*(Aq
\&  1  \*(Aqexp\*(Aq
\&  2  ARRAY(0xa05890)
\&     0  \*(Aqexp\*(Aq
\&     1  \*(Aq*\*(Aq
\&     2  \*(Aqexp\*(Aq
\&  3  0
.Ve
.ie n .SS "$parser\->YYGetLRAction($state, $token)"
.el .SS "\f(CW$parser\fP\->YYGetLRAction($state, \f(CW$token\fP)"
.IX Subsection "$parser->YYGetLRAction($state, $token)"
Returns the shift-reduce action for state \f(CW$state\fR
and token \f(CW$token\fR. A positive number must be interpreted as a shift 
to the state with that number. A negative number \f(CW\*(C`\-m\*(C'\fR indicates a reduction
by production with index \f(CW\*(C`m\*(C'\fR.  Returns \f(CW\*(C`undef\*(C'\fR if no action is defined
for such combination \f(CW\*(C`($state, $token)\*(C'\fR.
.PP
See example \f(CW\*(C`DynamicallyChangingTheParser.eyp\*(C'\fR in the directory \f(CW\*(C`examples/debuggintut\*(C'\fR
for an example of use.
.ie n .SS "$parser\->YYIssemantic"
.el .SS "\f(CW$parser\fP\->YYIssemantic"
.IX Subsection "$parser->YYIssemantic"
Returns \s-1TRUE\s0 if the terminal is \fIsemantic\fR. \fISemantics token\fR can be declared
using the directive \f(CW\*(C`%semantic token\*(C'\fR. The opposite of a \fISemantic token\fR
is a \fISyntactic token\fR. \fISyntactic tokens\fR can be declared
using the directive  \f(CW\*(C`%syntactic token\*(C'\fR.
.PP
When using the \f(CW%tree\fR directive all the nodes corresponding to syntactic
tokens are pruned from the tree. Under this directive
tokens in the text delimited by simple quotes (like \f(CW\*(Aq+\*(Aq\fR)
are, by default, considered syntactic tokens.
.PP
When using the \f(CW%metatree\fR directive all the tokens 
are considered, by default, \fIsemantic tokens\fR.
Thus, no nodes will be \- by default\- pruned when construction
the code augmented tree. The exception are string tokens
used as separators in the definition of
lists,  like in \f(CW\*(C`S <* \*(Aq;\*(Aq>\*(C'\fR. If you want the separating string token
to appear include an explicit semantic declaration for it (example \f(CW\*(C`%semantic token \*(Aq;\*(Aq\*(C'\fR).
.ie n .SS "$parser\->YYIndex"
.el .SS "\f(CW$parser\fP\->YYIndex"
.IX Subsection "$parser->YYIndex"
Receives the name of production (right hand side).
Returns the index in the grammar of the production with such name.
When called in a list context and without a name return the hash
containing the relation
.PP
.Vb 1
\&           production name => production index
.Ve
.PP
The following debugger session illustrates its use:
.PP
.Vb 10
\&  pl@europa:~/LEyapp/examples/recycle$ perl \-wd usepostfix.pl
\&  main::(usepostfix.pl:5):        my $parser = new Postfix();
\&  main::(usepostfix.pl:6):        $parser\->Run;
\&  DB<1> x $parser\->YYIndex
\&  0  \*(Aqline_1\*(Aq
\&  1  1
\&  2  \*(Aqexp_3\*(Aq
\&  3  3
\&  4  \*(Aqexp_6\*(Aq
\&  5  6
\&  6  \*(Aqexp_4\*(Aq
\&  7  4
\&  8  \*(Aqexp_10\*(Aq
\&  9  10
\&  10  \*(Aqexp_8\*(Aq
\&  11  8
\&  12  \*(Aqexp_5\*(Aq
\&  13  5
\&  14  \*(Aqexp_7\*(Aq
\&  15  7
\&  16  \*(Aqexp_2\*(Aq
\&  17  2
\&  18  \*(Aq_SUPERSTART\*(Aq
\&  19  0
\&  20  \*(Aqexp_9\*(Aq
\&  21  9
.Ve
.PP
We can specify a list of names:
.PP
.Vb 5
\&  DB<2> x $parser\->YYIndex(qw{exp_4 exp_7})
\&  0  4
\&  1  7
\&  DB<3> x $parser\->YYIndex(qw{exp_4})
\&  0  4
.Ve
.ie n .SS "$parser\->YYInput"
.el .SS "\f(CW$parser\fP\->YYInput"
.IX Subsection "$parser->YYInput"
Alias \f(CW\*(C`input\*(C'\fR. If an argument is provided, sets the input for the parser object.
The argument is a string or a reference to a string.
It returns a reference to the input string or \f(CW\*(C`undef\*(C'\fR if not set.
.ie n .SS "$parser\->YYIsterm"
.el .SS "\f(CW$parser\fP\->YYIsterm"
.IX Subsection "$parser->YYIsterm"
Returns \s-1TRUE \s0 if the symbol given as argument is a terminal. Example:
.PP
.Vb 4
\&  DB<0> x $self\->YYIsterm(\*(Aqexp\*(Aq)
\& 0  \*(Aq\*(Aq
\&  DB<1> x $self\->YYIsterm(\*(Aq*\*(Aq)
\& 0  1
.Ve
.PP
An example of combined 
use of \f(CW\*(C`YYRightside\*(C'\fR, \f(CW\*(C`YYRuleindex\*(C'\fR, \f(CW\*(C`YYLhs\*(C'\fR and \f(CW\*(C`YYIsterm\*(C'\fR
can be found \f(CW\*(C`examples/Eyapp/Rule3.yp\*(C'\fR:
.PP
.Vb 10
\& nereida:~/src/perl/YappWithDefaultAction/examples> sed \-n \-e \*(Aq4,22p\*(Aq Rule3.yp | cat \-n
\&  1  sub build_node {
\&  2    my $self = shift;
\&  3    my @children = @_;
\&  4    my @right = $self\->YYRightside();
\&  5    my $var = $self\->YYLhs;
\&  6    my $rule = $self\->YYRuleindex();
\&  7
\&  8    for(my $i = 0; $i < @right; $i++) {
\&  9      $_ = $right[$i];
\& 10      if ($self\->YYIsterm($_)) {
\& 11        $children[$i] = bless { token => $_, attr => $children[$i] },
\& 12                                            _\|_PACKAGE_\|_.\*(Aq::TERMINAL\*(Aq;
\& 13      }
\& 14    }
\& 15    bless {
\& 16            children => \e@children,
\& 17            info => "$var \-> @right"
\& 18          }, _\|_PACKAGE_\|_."::${var}_$rule"
\& 19  }
.Ve
.PP
when executed an output similar to this is produced:
.PP
.Vb 10
\& nereida:~/src/perl/YappWithDefaultAction/examples> userule3.pl
\& 2*3
\& $VAR1 = bless( {
\&   \*(Aqinfo\*(Aq => \*(Aqexp \-> exp * exp\*(Aq,
\&   \*(Aqchildren\*(Aq => [
\&     bless( {
\&       \*(Aqinfo\*(Aq => \*(Aqexp \-> NUM\*(Aq,
\&       \*(Aqchildren\*(Aq => [ bless( { \*(Aqattr\*(Aq => \*(Aq2\*(Aq, \*(Aqtoken\*(Aq => \*(AqNUM\*(Aq }, \*(AqRule3::TERMINAL\*(Aq ) ]
\&     }, \*(AqRule3::exp_6\*(Aq ),
\&     bless( { \*(Aqattr\*(Aq => \*(Aq*\*(Aq, \*(Aqtoken\*(Aq => \*(Aq*\*(Aq }, \*(AqRule3::TERMINAL\*(Aq ),
\&     bless( {
\&       \*(Aqinfo\*(Aq => \*(Aqexp \-> NUM\*(Aq,
\&       \*(Aqchildren\*(Aq => [ bless( { \*(Aqattr\*(Aq => \*(Aq3\*(Aq, \*(Aqtoken\*(Aq => \*(AqNUM\*(Aq }, \*(AqRule3::TERMINAL\*(Aq )
\&       ]
\&     }, \*(AqRule3::exp_6\*(Aq )
\&   ]
\& }, \*(AqRule3::exp_11\*(Aq );
.Ve
.ie n .SS " $parser\->YYLexer"
.el .SS " \f(CW$parser\fP\->YYLexer"
.IX Subsection " $parser->YYLexer"
Returns a reference to the lexical analyzer
.ie n .SS " $parser\->YYLhs"
.el .SS " \f(CW$parser\fP\->YYLhs"
.IX Subsection " $parser->YYLhs"
Returns the identifier of the left hand side of the current production (the one
that is being used for reduction/reverse derivation. An example 
of use can be found in \f(CW\*(C`examples/Eyapp/Lhs1.yp\*(C'\fR:
.PP
.Vb 1
\&  %defaultaction { print $_[0]\->YYLhs,"\en" }
.Ve
.ie n .SS "$parser\->YYMain"
.el .SS "\f(CW$parser\fP\->YYMain"
.IX Subsection "$parser->YYMain"
Alias is also \f(CW\*(C`main\*(C'\fR.
.PP
Other than the package, it has as optional arguments the \f(CW\*(C`prompt\*(C'\fR 
(shown each time it ask for input), the name of the input file
(if it wasn't specified in the command line using \f(CW\*(C`\-\-file filename\*(C'\fR)
and also the input string.
.PP
This method provides a default \f(CW\*(C`main\*(C'\fR for testing the generated parser.
It parses the commandline searching for a number of options. See
an example of use:
.PP
.Vb 5
\&  pl@nereida:~/LEyapp/examples/eyapplanguageref$ cat use_list2.pl
\&  #!/usr/bin/env perl
\&  use warnings;
\&  use strict;
\&  use List2;
\&
\&  unshift @ARGV, \*(Aq\-\-noslurp\*(Aq;
\&  List2\->new\->main("Try input \*(Aqaacbb\*(Aq: ");
\&  pl@nereida:~/LEyapp/examples/eyapplanguageref$ ./use_list2.pl \-\-help
\&  Available options:
\&      \-\-debug                    sets yydebug on
\&      \-\-nodebug                  sets yydebug off
\&      \-\-file filepath            read input from filepath
\&      \-\-commandinput string      read input from string
\&      \-\-tree                     prints $tree\->str
\&      \-\-notree                   does not print $tree\->str
\&      \-\-info                     When printing $tree\->str shows the value of TERMINALs
\&      \-\-help                     shows this help
\&      \-\-slurp                    read until EOF reached
\&      \-\-noslurp                  read until CR is reached
\&      \-\-argfile                  main() will take the input string from its @_
\&      \-\-noargfile                main() will not take the input string from its @_
\&      \-\-yaml                     dumps YAML for $tree: YAML module must be installed
\&      \-\-margin=i                 controls the indentation of $tree\->str (i.e. $Parse::Eyapp::Node::INDENT)
.Ve
.ie n .SS "$parser\->YYName"
.el .SS "\f(CW$parser\fP\->YYName"
.IX Subsection "$parser->YYName"
Returns the name of the current rule (The production whose reduction
gave place to the execution of the current semantic action).
.PP
.Vb 2
\&  DB<12> x $self\->YYName
\& 0  \*(Aqexp_11\*(Aq
.Ve
.ie n .SS "$parser\->YYNames"
.el .SS "\f(CW$parser\fP\->YYNames"
.IX Subsection "$parser->YYNames"
Return the list of production names. In a scalar context returns
a reference to such list.
.PP
.Vb 10
\&  pl@europa:~/LEyapp/examples/recycle$ eyapp Postfix
\&  pl@europa:~/LEyapp/examples/recycle$ perl \-wd usepostfix.pl
\&  main::(usepostfix.pl:5):        my $parser = new Postfix();
\&  main::(usepostfix.pl:6):        $parser\->Run;
\&  DB<1> x $parser\->YYNames
\&  0  \*(Aq_SUPERSTART\*(Aq
\&  1  \*(Aqline_1\*(Aq
\&  2  \*(Aqexp_2\*(Aq
\&  3  \*(Aqexp_3\*(Aq
\&  4  \*(Aqexp_4\*(Aq
\&  5  \*(Aqexp_5\*(Aq
\&  6  \*(Aqexp_6\*(Aq
\&  7  \*(Aqexp_7\*(Aq
\&  8  \*(Aqexp_8\*(Aq
\&  9  \*(Aqexp_9\*(Aq
\&  10  \*(Aqexp_10\*(Aq
.Ve
.ie n .SS "$parser\->YYNberr"
.el .SS "\f(CW$parser\fP\->YYNberr"
.IX Subsection "$parser->YYNberr"
The current number of errors
.ie n .SS "$parser\->\fIYYNextState()\fP;"
.el .SS "\f(CW$parser\fP\->\fIYYNextState()\fP;"
.IX Subsection "$parser->YYNextState();"
If called inside a semantic
action, returns the state after the reduction
by the current production.
.PP
Provide a token if called from any other side:
.PP
.Vb 1
\&  $parser\->YYNextState($token);
.Ve
.PP
It will return the state given by the action table
for the state in the top of the stack and the given token.
.PP
For an example, see the program \f(CW\*(C`DynamicallyChangingTheParser.eyp\*(C'\fR 
in the directory \f(CW\*(C`examples/debuggintut/\*(C'\fR.
.ie n .SS "$parser\->YYPrefix"
.el .SS "\f(CW$parser\fP\->YYPrefix"
.IX Subsection "$parser->YYPrefix"
Return and/or sets the \f(CW\*(C`yyprefix\*(C'\fR attribute. This a string that will be concatenated
as a prefix to any \f(CW\*(C`Parse::Eyapp::Node\*(C'\fR nodes in the syntax tree.
.ie n .SS " $parser\->\fIYYParse()\fP"
.el .SS " \f(CW$parser\fP\->\fIYYParse()\fP"
.IX Subsection " $parser->YYParse()"
It very much works \f(CW\*(C`Parse::Yapp::YYParse\*(C'\fR and as yacc/bison \f(CW\*(C`yyparse\*(C'\fR.
It accepts almost the same arguments as \f(CW\*(C`Class\->new\*(C'\fR with the exception
of \f(CW\*(C`yyprefix\*(C'\fR which can be used only with \f(CW\*(C`new\*(C'\fR.
.ie n .SS " $parser\->YYRecovering"
.el .SS " \f(CW$parser\fP\->YYRecovering"
.IX Subsection " $parser->YYRecovering"
Works as yacc/bison \f(CW\*(C`YYRECOVERING\*(C'\fR.
Returns \f(CW\*(C`TRUE\*(C'\fR if the parser is recovering from a syntax error.
.ie n .SS "$parser\->YYRestoreLRAction('conflictname', $token)"
.el .SS "\f(CW$parser\fP\->YYRestoreLRAction('conflictname', \f(CW$token\fP)"
.IX Subsection "$parser->YYRestoreLRAction('conflictname', $token)"
This method has been designed to solve shift-reduce and reduce-reduce conflicts
at parsing-time using the \fIpostponed conflict\fR strategy. 
It has to be called inside the semantic
action associated with the postponed conflict rule. The \s-1LALR\s0 table is changed
so that the action in the presence of the token \f(CW$token\fR is restored
the one before the last call to
.PP
.Vb 1
\&  $parser\->YYSetReduce($token, $productionname )
.Ve
.PP
See the examples in \f(CW\*(C`examples/debuggingtut/\*(C'\fR in files 
\&\f(CW\*(C`DynamicallyChangingTheParser2.eyp\*(C'\fR
and \f(CW\*(C`Cplusplus.eyp\*(C'\fR.
.ie n .SS "$parser\->YYRHSLength($productionindex)"
.el .SS "\f(CW$parser\fP\->YYRHSLength($productionindex)"
.IX Subsection "$parser->YYRHSLength($productionindex)"
Also:
.PP
.Vb 1
\&  $parser\->YYRHSLength
.Ve
.PP
returns the length of the right hand side (the number of symbols) of 
\&\f(CW$productionindex\fR. The name of the production can be used instead of its index.
If no index or name is provided and the method is called inside a semantic
action, the length of the current production is returned.
.ie n .SS "$parser\->YYRightside"
.el .SS "\f(CW$parser\fP\->YYRightside"
.IX Subsection "$parser->YYRightside"
Also:
.PP
.Vb 1
\&  $parser\->YYRightside($index)
.Ve
.PP
Returns an array of strings describing the right hand side of the rule. 
The name of the production can be given instead of \f(CW$index\fR. If no 
\&\f(CW$index\fR is provided and the method is called inside a semantic action
the right hand side of the current production is returned.
.ie n .SS "$parser\->YYRuleindex"
.el .SS "\f(CW$parser\fP\->YYRuleindex"
.IX Subsection "$parser->YYRuleindex"
To be called inside a semantic action.
Returns the index of the current production rule, counting the super rule as rule 0.
.PP
To know the numbers have a look at  the \f(CW\*(C`.output\*(C'\fR file.
To get a \f(CW\*(C`.output\*(C'\fR file use the option \f(CW\*(C`\-v\*(C'\fR of \f(CW\*(C`eyapp\*(C'\fR or the \f(CW\*(C`outputfile\*(C'\fR
parameter when using method \f(CW\*(C`new_grammar\*(C'\fR (see the documentation for eyapp).
.ie n .SS "$parser\->YYRule"
.el .SS "\f(CW$parser\fP\->YYRule"
.IX Subsection "$parser->YYRule"
Return the list of rules. 
The following debugger session illustrates its use:
.PP
.Vb 10
\&  pl@europa:~/LEyapp/examples/recycle$ perl \-wd usepostfix.pl
\&  main::(usepostfix.pl:5):        my $parser = new Postfix();
\&  main::(usepostfix.pl:6):        $parser\->Run;
\&  0  ARRAY(0xa068e0)
\&     0  \*(Aq$start\*(Aq
\&     1  2
\&     2  undef
\&  1  ARRAY(0xa06940)
\&     0  \*(Aqline\*(Aq
\&     1  1
\&     2  CODE(0xc22360)
\&        \-> &Postfix::_\|_ANON_\|_[Postfix.eyp:10] in Postfix.eyp:227\-10
\&  ... etc, etc.
.Ve
.PP
Each item has three components: the \s-1LHS\s0 of the production, the number of symbols
in the \s-1RHS\s0 and the \s-1CODE\s0 reference to the semantic action.
.PP
If an index is specified as argument it returns the corresponding item:
.PP
.Vb 5
\&     DB<2> x $parser\->YYRule(7)
\&  0  \*(Aqexp\*(Aq
\&  1  3
\&  2  CODE(0xc1fce0)
\&     \-> &Postfix::_\|_ANON_\|_[Postfix.eyp:7] in Postfix.eyp:276\-7
.Ve
.PP
To know to what production an item is associated we can use the \f(CW\*(C`YYGrammar\*(C'\fR method:
.PP
.Vb 8
\&     DB<3> x $parser\->YYGrammar(\*(Aqexp_7\*(Aq)
\&  0  \*(Aqexp_7\*(Aq
\&  1  \*(Aqexp\*(Aq
\&  2  ARRAY(0xa05290)
\&     0  \*(Aqexp\*(Aq
\&     1  \*(Aq*\*(Aq
\&     2  \*(Aqexp\*(Aq
\&  3  0
.Ve
.PP
We can also use the name of the rule to get the item:
.PP
.Vb 5
\&   DB<4> x $parser\->YYRule(\*(Aqexp_7\*(Aq)
\&  0  \*(Aqexp\*(Aq
\&  1  3
\&  2  CODE(0xc1fce0)
\&     \-> &Postfix::_\|_ANON_\|_[Postfix.eyp:7] in Postfix.eyp:276\-7
.Ve
.ie n .SS "$parser\->YYSetaction"
.el .SS "\f(CW$parser\fP\->YYSetaction"
.IX Subsection "$parser->YYSetaction"
Receives a hash with keys the names of the production rules (right hand sides) and values
the new semantic actions. Used to reuse a grammar without overwriting all the semantic actions.
See section \fIReusing Grammars by Dynamic Substitution of Semantic Actions\fR
in Parse::Eyapp::defaultactionsintro.
.ie n .SS "$parser\->YYSetLRAction($conflictstate, $token, $shiftreduceaction )"
.el .SS "\f(CW$parser\fP\->YYSetLRAction($conflictstate, \f(CW$token\fP, \f(CW$shiftreduceaction\fP )"
.IX Subsection "$parser->YYSetLRAction($conflictstate, $token, $shiftreduceaction )"
It also accepts the syntax:
.PP
.Vb 1
\&  $parser\->YYSetLRAction($conflictstate, [$token1, ... ], $shiftreduceaction )
.Ve
.PP
This method has been designed to solve shift-reduce and reduce-reduce conflicts
at parsing-time (not at parser-generation time).
.PP
The \s-1LR\s0 table is changed so that the action in state \f(CW$conflictstate\fR
in the presence of the token \f(CW$token\fR will be given by \f(CW$shiftreduceaction\fR. 
The current shift-reduce action isn't saved.
.PP
See an example in
\&\f(CW\*(C`Cplusplus2.eyp\*(C'\fR in the directory \f(CW\*(C`examples/debuggintut\*(C'\fR.
.ie n .SS "$parser\->YYSetReduce($token, $productionname )"
.el .SS "\f(CW$parser\fP\->YYSetReduce($token, \f(CW$productionname\fP )"
.IX Subsection "$parser->YYSetReduce($token, $productionname )"
This method has been designed to solve shift-reduce and reduce-reduce conflicts
at parsing-time using the \fIpostponed conflict\fR strategy. See the corresponding 
section in Parse::Eyapp::debuggintut. It has to be called inside the semantic
action associated with the postponed conflict rule \f(CW\*(C`conflictname\*(C'\fR. 
The \s-1LALR\s0 table is changed
so that the action in the presence of the token \f(CW$token\fR will be to reduce
by \f(CW$productionname\fR. The current shift-reduce action is saved
to be restored using
.PP
.Vb 1
\&  $parser\->YYRestoreLRAction(\*(Aqconflictname\*(Aq, $token)
.Ve
.PP
See the examples in \f(CW\*(C`examples/debuggingtut/\*(C'\fR in files
.IP "\(bu" 2
\&\f(CW\*(C`DynamicallyChangingTheParser2.eyp\*(C'\fR
.IP "\(bu" 2
\&\f(CW\*(C`confusingsolveddynamic.eyp\*(C'\fR
.IP "\(bu" 2
\&\f(CW\*(C`DebugDynamicResolution.eyp\*(C'\fR
.IP "\(bu" 2
\&\f(CW\*(C`DynamicallyChangingTheParser2.eyp\*(C'\fR
.IP "\(bu" 2
\&\f(CW\*(C`DynamicallyChangingTheParser3.eyp\*(C'\fR
.IP "\(bu" 2
\&\f(CW\*(C`DynamicallyChangingTheParser.eyp\*(C'\fR
.IP "\(bu" 2
\&\f(CW\*(C`DynamicvsTieIns.eyp\*(C'\fR
.IP "\(bu" 2
\&\f(CW\*(C`nolr_k_grammarsolveddynamic.eyp\*(C'\fR
.IP "\(bu" 2
\&\f(CW\*(C`pascalenumeratedvsrangesolvedviadyn.eyp\*(C'\fR
.IP "\(bu" 2
\&\f(CW\*(C`Cplusplus.eyp\*(C'\fR.
.ie n .SS "$parser\->YYSetShift($token)"
.el .SS "\f(CW$parser\fP\->YYSetShift($token)"
.IX Subsection "$parser->YYSetShift($token)"
Also:
.PP
.Vb 1
\&      $parser\->YYSetShift([$token1, $token2, ... ])
.Ve
.PP
This method has been designed to solve shift-reduce 
at parsing-time using the \fIpostponed conflict\fR strategy. See the corresponding 
section in Parse::Eyapp::debuggintut. It has to be called inside the semantic
action associated with the postponed conflict rule \f(CW\*(C`conflictname\*(C'\fR. 
The \s-1LALR\s0 table is changed
so that the action in the presence of the token \f(CW$token\fR will be to shift.
.PP
See the examples in \f(CW\*(C`examples/debuggingtut/\*(C'\fR in files
.IP "\(bu" 2
\&\f(CW\*(C`DebugDynamicResolution.eyp\*(C'\fR
.IP "\(bu" 2
\&\f(CW\*(C`DynamicallyChangingTheParser.eyp\*(C'\fR
.ie n .SS "$parser\->YYSlurpFile"
.el .SS "\f(CW$parser\fP\->YYSlurpFile"
.IX Subsection "$parser->YYSlurpFile"
alias:
.PP
.Vb 1
\& $parser\->slurp_file($filename[,$prompt[,$mode]])
.Ve
.PP
Receives the name of the file, reads its contents
and stores it in \f(CW\*(C`$parser\->input\*(C'\fR.
.PP
If the file does not exists, it proceeds to read from \f(CW\*(C`STDIN\*(C'\fR.
If a prompt was set with \f(CW\*(C`$parser\->YYPrompt\*(C'\fR, it will be shown.
The additional optional parameter \f(CW$mode\fR is used in such case to set 
\&\f(CW$/\fR. It can also be used as a class method.
.ie n .SS "$parser\->YYState"
.el .SS "\f(CW$parser\fP\->YYState"
.IX Subsection "$parser->YYState"
\&\f(CW\*(C`YYState\*(C'\fR returns a reference to the list of states containing the \s-1\fILALR\s0\fR\|(1) tables: the 
action and \s-1GOTO\s0 tables.  Each state is an anonymous hash:
.PP
.Vb 5
\&  DB<4> x $parser\->YYState(2)
\&  0  HASH(0xfa7120)
\&     \*(AqACTIONS\*(Aq => HASH(0xfa70f0) # token => state
\&           \*(Aq:\*(Aq => \*(Aq\-7\*(Aq
\&     \*(AqDEFAULT\*(Aq => \*(Aq\-6\*(Aq
.Ve
.PP
A negative number means reduction using the corresponding production 
rule (opposite) number. The former example tells to reduce by rule 7
when in state 2 and seeing token \f(CW\*(Aq:\*(Aq\fR. By default, the action when
in state 2 is to reduce by rule number 6.
.PP
There are three keys: \s-1ACTIONS, GOTOS\s0 and  \s-1DEFAULT\s0
.PP
.Vb 6
\&  DB<7> x $parser\->YYState(13)
\& 0  HASH(0xfa8b50)
\&    \*(AqACTIONS\*(Aq => HASH(0xfa7530)
\&       \*(AqVAR\*(Aq => 17
\&    \*(AqGOTOS\*(Aq => HASH(0xfa8b20)
\&       \*(Aqtype\*(Aq => 19
.Ve
.PP
The \s-1GOTOS\s0 tables contains the \s-1DFA\s0 transition tables for
the syntactic variables. The former example tells
to move to state 19 when in state 13 after seeing
the syntactic variable \f(CW\*(C`type\*(C'\fR (i.e. if after reducing by a 
rule of \f(CW\*(C`type\*(C'\fR we are in state 13).
.ie n .SS "$parser\->YYTopState($length)"
.el .SS "\f(CW$parser\fP\->YYTopState($length)"
.IX Subsection "$parser->YYTopState($length)"
If \f(CW$length\fR is zero or not provided 
it returns the state on top of the stack.
Otherwise, returns the state \f(CW$length\fR units deep in the stack.
.SH "CONTRIBUTORS"
.IX Header "CONTRIBUTORS"
.IP "\(bu" 2
Hal Finkel <http://www.halssoftware.com/>
.IP "\(bu" 2
G. Williams <http://kasei.us/>
.IP "\(bu" 2
Thomas L. Shinnick <http://search.cpan.org/~tshinnic/>
.IP "\(bu" 2
Frank Leray
.SH "AUTHOR"
.IX Header "AUTHOR"
Casiano Rodriguez-Leon (casiano@ull.es)
.SH "ACKNOWLEDGMENTS"
.IX Header "ACKNOWLEDGMENTS"
This work has been supported by \s-1CEE \s0(\s-1FEDER\s0) and the Spanish Ministry of
\&\fIEducacion y Ciencia\fR through \fIPlan Nacional I+D+I\fR number \s-1TIN2005\-08818\-C04\-04
\&\s0(\s-1ULL::OPLINK\s0 project <http://www.oplink.ull.es/>). 
Support from Gobierno de Canarias was through \s-1GC02210601
\&\s0(\fIGrupos Consolidados\fR).
The University of La Laguna has also supported my work in many ways
and for many years.
.PP
A large percentage of  code is verbatim taken from Parse::Yapp 1.05.
The author of Parse::Yapp is Francois Desarmenien.
.PP
I wish to thank Francois Desarmenien for his Parse::Yapp module, 
to my students at La Laguna and to the Perl Community. Thanks to 
the people who have contributed to improve the module (see \*(L"\s-1CONTRIBUTORS\*(R"\s0 in Parse::Eyapp).
Thanks to Larry Wall for giving us Perl.
Special thanks to Juana.
.SH "LICENCE AND COPYRIGHT"
.IX Header "LICENCE AND COPYRIGHT"
Copyright (c) 2006\-2008 Casiano Rodriguez-Leon (casiano@ull.es). All rights reserved.
.PP
Parse::Yapp copyright is of Francois Desarmenien, all rights reserved. 1998\-2001
.PP
These modules are free software; you can redistribute it and/or
modify it under the same terms as Perl itself. See perlartistic.
.PP
This program is distributed in the hope that it will be useful,
but \s-1WITHOUT ANY WARRANTY\s0; without even the implied warranty of
\&\s-1MERCHANTABILITY\s0 or \s-1FITNESS FOR A PARTICULAR PURPOSE. \s0
