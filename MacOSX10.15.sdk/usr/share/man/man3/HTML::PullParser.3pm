.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "HTML::PullParser 3"
.TH HTML::PullParser 3 "2013-03-25" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
HTML::PullParser \- Alternative HTML::Parser interface
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& use HTML::PullParser;
\&
\& $p = HTML::PullParser\->new(file => "index.html",
\&                            start => \*(Aqevent, tagname, @attr\*(Aq,
\&                            end   => \*(Aqevent, tagname\*(Aq,
\&                            ignore_elements => [qw(script style)],
\&                           ) || die "Can\*(Aqt open: $!";
\& while (my $token = $p\->get_token) {
\&     #...do something with $token
\& }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The HTML::PullParser is an alternative interface to the HTML::Parser class.
It basically turns the HTML::Parser inside out.  You associate a file
(or any IO::Handle object or string) with the parser at construction time and
then repeatedly call \f(CW$parser\fR\->get_token to obtain the tags and text
found in the parsed document.
.PP
The following methods are provided:
.ie n .IP "$p = HTML::PullParser\->new( file => $file, %options )" 4
.el .IP "\f(CW$p\fR = HTML::PullParser\->new( file => \f(CW$file\fR, \f(CW%options\fR )" 4
.IX Item "$p = HTML::PullParser->new( file => $file, %options )"
.PD 0
.ie n .IP "$p = HTML::PullParser\->new( doc => \e$doc, %options )" 4
.el .IP "\f(CW$p\fR = HTML::PullParser\->new( doc => \e$doc, \f(CW%options\fR )" 4
.IX Item "$p = HTML::PullParser->new( doc => $doc, %options )"
.PD
A \f(CW\*(C`HTML::PullParser\*(C'\fR can be made to parse from either a file or a
literal document based on whether the \f(CW\*(C`file\*(C'\fR or \f(CW\*(C`doc\*(C'\fR option is
passed to the parser's constructor.
.Sp
The \f(CW\*(C`file\*(C'\fR passed in can either be a file name or a file handle
object.  If a file name is passed, and it can't be opened for reading,
then the constructor will return an undefined value and $!  will tell
you why it failed.  Otherwise the argument is taken to be some object
that the \f(CW\*(C`HTML::PullParser\*(C'\fR can \fIread()\fR from when it needs more data.
The stream will be \fIread()\fR until \s-1EOF,\s0 but not closed.
.Sp
A \f(CW\*(C`doc\*(C'\fR can be passed plain or as a reference
to a scalar.  If a reference is passed then the value of this scalar
should not be changed before all tokens have been extracted.
.Sp
Next the information to be returned for the different token types must
be set up.  This is done by simply associating an argspec (as defined
in HTML::Parser) with the events you have an interest in.  For
instance, if you want \f(CW\*(C`start\*(C'\fR tokens to be reported as the string
\&\f(CW\*(AqS\*(Aq\fR followed by the tagname and the attributes you might pass an
\&\f(CW\*(C`start\*(C'\fR\-option like this:
.Sp
.Vb 5
\&   $p = HTML::PullParser\->new(
\&          doc   => $document_to_parse,
\&          start => \*(Aq"S", tagname, @attr\*(Aq,
\&          end   => \*(Aq"E", tagname\*(Aq,
\&        );
.Ve
.Sp
At last other \f(CW\*(C`HTML::Parser\*(C'\fR options, like \f(CW\*(C`ignore_tags\*(C'\fR, and
\&\f(CW\*(C`unbroken_text\*(C'\fR, can be passed in.  Note that you should not use the
\&\fIevent\fR_h options to set up parser handlers.  That would confuse the
inner logic of \f(CW\*(C`HTML::PullParser\*(C'\fR.
.ie n .IP "$token = $p\->get_token" 4
.el .IP "\f(CW$token\fR = \f(CW$p\fR\->get_token" 4
.IX Item "$token = $p->get_token"
This method will return the next \fItoken\fR found in the \s-1HTML\s0 document,
or \f(CW\*(C`undef\*(C'\fR at the end of the document.  The token is returned as an
array reference.  The content of this array match the argspec set up
during \f(CW\*(C`HTML::PullParser\*(C'\fR construction.
.ie n .IP "$p\->unget_token( @tokens )" 4
.el .IP "\f(CW$p\fR\->unget_token( \f(CW@tokens\fR )" 4
.IX Item "$p->unget_token( @tokens )"
If you find out you have read too many tokens you can push them back,
so that they are returned again the next time \f(CW$p\fR\->get_token is called.
.SH "EXAMPLES"
.IX Header "EXAMPLES"
The 'eg/hform' script shows how we might parse the form section of
HTML::Documents using HTML::PullParser.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
HTML::Parser, HTML::TokeParser
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright 1998\-2001 Gisle Aas.
.PP
This library is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.
