.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "DBIx::Class::Manual::Example 3"
.TH DBIx::Class::Manual::Example 3 "2014-01-05" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
DBIx::Class::Manual::Example \- Simple CD database example
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This tutorial will guide you through the process of setting up and
testing a very basic \s-1CD\s0 database using SQLite, with DBIx::Class::Schema
as the database frontend.
.PP
The database consists of the following:
.PP
.Vb 3
\&  table \*(Aqartist\*(Aq with columns:  artistid, name
\&  table \*(Aqcd\*(Aq     with columns:  cdid, artist, title, year
\&  table \*(Aqtrack\*(Aq  with columns:  trackid, cd, title
.Ve
.PP
And these rules exists:
.PP
.Vb 4
\&  one artist can have many cds
\&  one cd belongs to one artist
\&  one cd can have many tracks
\&  one track belongs to one cd
.Ve
.SS "Installation"
.IX Subsection "Installation"
Install DBIx::Class via \s-1CPAN\s0 should be sufficient.
.PP
\fICreate the database/tables\fR
.IX Subsection "Create the database/tables"
.PP
First make and change the directory:
.PP
.Vb 4
\&  mkdir app
\&  cd app
\&  mkdir db
\&  cd db
.Ve
.PP
This example uses SQLite which is a dependency of DBIx::Class, so you
shouldn't have to install extra software.
.PP
Save the following into a example.sql in the directory db
.PP
.Vb 4
\&  CREATE TABLE artist (
\&    artistid INTEGER PRIMARY KEY,
\&    name TEXT NOT NULL
\&  );
\&
\&  CREATE TABLE cd (
\&    cdid INTEGER PRIMARY KEY,
\&    artist INTEGER NOT NULL REFERENCES artist(artistid),
\&    title TEXT NOT NULL
\&  );
\&
\&  CREATE TABLE track (
\&    trackid INTEGER PRIMARY KEY,
\&    cd INTEGER NOT NULL REFERENCES cd(cdid),
\&    title TEXT NOT NULL
\&  );
.Ve
.PP
and create the SQLite database file:
.PP
.Vb 1
\&  sqlite3 example.db < example.sql
.Ve
.PP
\fISet up DBIx::Class::Schema\fR
.IX Subsection "Set up DBIx::Class::Schema"
.PP
Change directory back from db to the directory app:
.PP
.Vb 1
\&  cd ../
.Ve
.PP
Now create some more directories:
.PP
.Vb 4
\&  mkdir MyApp
\&  mkdir MyApp/Schema
\&  mkdir MyApp/Schema/Result
\&  mkdir MyApp/Schema/ResultSet
.Ve
.PP
Then, create the following DBIx::Class::Schema classes:
.PP
MyApp/Schema.pm:
.PP
.Vb 3
\&  package MyApp::Schema;
\&  use base qw/DBIx::Class::Schema/;
\&  _\|_PACKAGE_\|_\->load_namespaces;
\&
\&  1;
.Ve
.PP
MyApp/Schema/Result/Artist.pm:
.PP
.Vb 6
\&  package MyApp::Schema::Result::Artist;
\&  use base qw/DBIx::Class::Core/;
\&  _\|_PACKAGE_\|_\->table(\*(Aqartist\*(Aq);
\&  _\|_PACKAGE_\|_\->add_columns(qw/ artistid name /);
\&  _\|_PACKAGE_\|_\->set_primary_key(\*(Aqartistid\*(Aq);
\&  _\|_PACKAGE_\|_\->has_many(\*(Aqcds\*(Aq => \*(AqMyApp::Schema::Result::Cd\*(Aq);
\&
\&  1;
.Ve
.PP
MyApp/Schema/Result/Cd.pm:
.PP
.Vb 8
\&  package MyApp::Schema::Result::Cd;
\&  use base qw/DBIx::Class::Core/;
\&  _\|_PACKAGE_\|_\->load_components(qw/InflateColumn::DateTime/);
\&  _\|_PACKAGE_\|_\->table(\*(Aqcd\*(Aq);
\&  _\|_PACKAGE_\|_\->add_columns(qw/ cdid artist title year/);
\&  _\|_PACKAGE_\|_\->set_primary_key(\*(Aqcdid\*(Aq);
\&  _\|_PACKAGE_\|_\->belongs_to(\*(Aqartist\*(Aq => \*(AqMyApp::Schema::Result::Artist\*(Aq);
\&  _\|_PACKAGE_\|_\->has_many(\*(Aqtracks\*(Aq => \*(AqMyApp::Schema::Result::Track\*(Aq);
\&
\&  1;
.Ve
.PP
MyApp/Schema/Result/Track.pm:
.PP
.Vb 6
\&  package MyApp::Schema::Result::Track;
\&  use base qw/DBIx::Class::Core/;
\&  _\|_PACKAGE_\|_\->table(\*(Aqtrack\*(Aq);
\&  _\|_PACKAGE_\|_\->add_columns(qw/ trackid cd title /);
\&  _\|_PACKAGE_\|_\->set_primary_key(\*(Aqtrackid\*(Aq);
\&  _\|_PACKAGE_\|_\->belongs_to(\*(Aqcd\*(Aq => \*(AqMyApp::Schema::Result::Cd\*(Aq);
\&
\&  1;
.Ve
.PP
\fIWrite a script to insert some records\fR
.IX Subsection "Write a script to insert some records"
.PP
insertdb.pl
.PP
.Vb 1
\&  #!/usr/bin/perl
\&
\&  use strict;
\&  use warnings;
\&
\&  use MyApp::Schema;
\&
\&  my $schema = MyApp::Schema\->connect(\*(Aqdbi:SQLite:db/example.db\*(Aq);
\&
\&  my @artists = ([\*(AqMichael Jackson\*(Aq], [\*(AqEminem\*(Aq]);
\&  $schema\->populate(\*(AqArtist\*(Aq, [
\&     [qw/name/],
\&     @artists,
\&  ]);
\&
\&  my %albums = (
\&    \*(AqThriller\*(Aq => \*(AqMichael Jackson\*(Aq,
\&    \*(AqBad\*(Aq => \*(AqMichael Jackson\*(Aq,
\&    \*(AqThe Marshall Mathers LP\*(Aq => \*(AqEminem\*(Aq,
\&  );
\&
\&  my @cds;
\&  foreach my $lp (keys %albums) {
\&    my $artist = $schema\->resultset(\*(AqArtist\*(Aq)\->find({
\&      name => $albums{$lp}
\&    });
\&    push @cds, [$lp, $artist\->id];
\&  }
\&
\&  $schema\->populate(\*(AqCd\*(Aq, [
\&    [qw/title artist/],
\&    @cds,
\&  ]);
\&
\&
\&  my %tracks = (
\&    \*(AqBeat It\*(Aq         => \*(AqThriller\*(Aq,
\&    \*(AqBillie Jean\*(Aq     => \*(AqThriller\*(Aq,
\&    \*(AqDirty Diana\*(Aq     => \*(AqBad\*(Aq,
\&    \*(AqSmooth Criminal\*(Aq => \*(AqBad\*(Aq,
\&    \*(AqLeave Me Alone\*(Aq  => \*(AqBad\*(Aq,
\&    \*(AqStan\*(Aq            => \*(AqThe Marshall Mathers LP\*(Aq,
\&    \*(AqThe Way I Am\*(Aq    => \*(AqThe Marshall Mathers LP\*(Aq,
\&  );
\&
\&  my @tracks;
\&  foreach my $track (keys %tracks) {
\&    my $cdname = $schema\->resultset(\*(AqCd\*(Aq)\->find({
\&      title => $tracks{$track},
\&    });
\&    push @tracks, [$cdname\->id, $track];
\&  }
\&
\&  $schema\->populate(\*(AqTrack\*(Aq,[
\&    [qw/cd title/],
\&    @tracks,
\&  ]);
.Ve
.PP
\fICreate and run the test scripts\fR
.IX Subsection "Create and run the test scripts"
.PP
testdb.pl:
.PP
.Vb 1
\&  #!/usr/bin/perl
\&
\&  use strict;
\&  use warnings;
\&
\&  use MyApp::Schema;
\&
\&  my $schema = MyApp::Schema\->connect(\*(Aqdbi:SQLite:db/example.db\*(Aq);
\&  # for other DSNs, e.g. MySQL, see the perldoc for the relevant dbd
\&  # driver, e.g perldoc L<DBD::mysql>.
\&
\&  get_tracks_by_cd(\*(AqBad\*(Aq);
\&  get_tracks_by_artist(\*(AqMichael Jackson\*(Aq);
\&
\&  get_cd_by_track(\*(AqStan\*(Aq);
\&  get_cds_by_artist(\*(AqMichael Jackson\*(Aq);
\&
\&  get_artist_by_track(\*(AqDirty Diana\*(Aq);
\&  get_artist_by_cd(\*(AqThe Marshall Mathers LP\*(Aq);
\&
\&
\&  sub get_tracks_by_cd {
\&    my $cdtitle = shift;
\&    print "get_tracks_by_cd($cdtitle):\en";
\&    my $rs = $schema\->resultset(\*(AqTrack\*(Aq)\->search(
\&      {
\&        \*(Aqcd.title\*(Aq => $cdtitle
\&      },
\&      {
\&        join     => [qw/ cd /],
\&      }
\&    );
\&    while (my $track = $rs\->next) {
\&      print $track\->title . "\en";
\&    }
\&    print "\en";
\&  }
\&
\&  sub get_tracks_by_artist {
\&    my $artistname = shift;
\&    print "get_tracks_by_artist($artistname):\en";
\&    my $rs = $schema\->resultset(\*(AqTrack\*(Aq)\->search(
\&      {
\&        \*(Aqartist.name\*(Aq => $artistname
\&      },
\&      {
\&        join => {
\&          \*(Aqcd\*(Aq => \*(Aqartist\*(Aq
\&        },
\&      }
\&    );
\&    while (my $track = $rs\->next) {
\&      print $track\->title . "\en";
\&    }
\&    print "\en";
\&  }
\&
\&
\&  sub get_cd_by_track {
\&    my $tracktitle = shift;
\&    print "get_cd_by_track($tracktitle):\en";
\&    my $rs = $schema\->resultset(\*(AqCd\*(Aq)\->search(
\&      {
\&        \*(Aqtracks.title\*(Aq => $tracktitle
\&      },
\&      {
\&        join     => [qw/ tracks /],
\&      }
\&    );
\&    my $cd = $rs\->first;
\&    print $cd\->title . "\en\en";
\&  }
\&
\&  sub get_cds_by_artist {
\&    my $artistname = shift;
\&    print "get_cds_by_artist($artistname):\en";
\&    my $rs = $schema\->resultset(\*(AqCd\*(Aq)\->search(
\&      {
\&        \*(Aqartist.name\*(Aq => $artistname
\&      },
\&      {
\&        join     => [qw/ artist /],
\&      }
\&    );
\&    while (my $cd = $rs\->next) {
\&      print $cd\->title . "\en";
\&    }
\&    print "\en";
\&  }
\&
\&
\&
\&  sub get_artist_by_track {
\&    my $tracktitle = shift;
\&    print "get_artist_by_track($tracktitle):\en";
\&    my $rs = $schema\->resultset(\*(AqArtist\*(Aq)\->search(
\&      {
\&        \*(Aqtracks.title\*(Aq => $tracktitle
\&      },
\&      {
\&        join => {
\&          \*(Aqcds\*(Aq => \*(Aqtracks\*(Aq
\&        }
\&      }
\&    );
\&    my $artist = $rs\->first;
\&    print $artist\->name . "\en\en";
\&  }
\&
\&  sub get_artist_by_cd {
\&    my $cdtitle = shift;
\&    print "get_artist_by_cd($cdtitle):\en";
\&    my $rs = $schema\->resultset(\*(AqArtist\*(Aq)\->search(
\&      {
\&        \*(Aqcds.title\*(Aq => $cdtitle
\&      },
\&      {
\&        join     => [qw/ cds /],
\&      }
\&    );
\&    my $artist = $rs\->first;
\&    print $artist\->name . "\en\en";
\&  }
.Ve
.PP
It should output:
.PP
.Vb 4
\&  get_tracks_by_cd(Bad):
\&  Dirty Diana
\&  Smooth Criminal
\&  Leave Me Alone
\&
\&  get_tracks_by_artist(Michael Jackson):
\&  Beat it
\&  Billie Jean
\&  Dirty Diana
\&  Smooth Criminal
\&  Leave Me Alone
\&
\&  get_cd_by_track(Stan):
\&  The Marshall Mathers LP
\&
\&  get_cds_by_artist(Michael Jackson):
\&  Thriller
\&  Bad
\&
\&  get_artist_by_track(Dirty Diana):
\&  Michael Jackson
\&
\&  get_artist_by_cd(The Marshall Mathers LP):
\&  Eminem
.Ve
.SH "Notes"
.IX Header "Notes"
A reference implementation of the database and scripts in this example
are available in the main distribution for DBIx::Class under the
directory \fIexamples/Schema\fR.
.PP
With these scripts we're relying on \f(CW@INC\fR looking in the current
working directory.  You may want to add the MyApp namespaces to
\&\f(CW@INC\fR in a different way when it comes to deployment.
.PP
The \fItestdb.pl\fR script is an excellent start for testing your database
model.
.PP
This example uses \*(L"load_namespaces\*(R" in DBIx::Class::Schema to load in the
appropriate Result classes from the
\&\f(CW\*(C`MyApp::Schema::Result\*(C'\fR namespace, and any required
ResultSet classes from the
\&\f(CW\*(C`MyApp::Schema::ResultSet\*(C'\fR namespace (although we created the directory
in the directions above we did not add, or need to add, any resultset
classes).
.SH "TODO"
.IX Header "TODO"
.SH "AUTHOR"
.IX Header "AUTHOR"
.Vb 3
\&  sc_ from irc.perl.org#dbix\-class
\&  Kieren Diment <kd@totaldatasolution.com>
\&  Nigel Metheringham <nigelm@cpan.org>
.Ve
