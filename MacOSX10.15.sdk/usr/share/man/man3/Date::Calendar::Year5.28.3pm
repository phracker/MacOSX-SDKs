.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Date::Calendar::Year 3"
.TH Date::Calendar::Year 3 "2009-10-30" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Date::Calendar::Year \- Implements embedded "year" objects for Date::Calendar
.SH "MOTTO"
.IX Header "MOTTO"
There is more than one way to do it \- this is just one of them!
.SH "PREFACE"
.IX Header "PREFACE"
Note that Date::Calendar::Year (and Date::Calendar) can only deal
with years lying within the range [1583..2299].
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&  use Date::Calendar::Year qw( check_year empty_period );
\&  use Date::Calendar::Year qw( :all ); # same as above
\&
\&  check_year(YEAR|DATE); # dies if year < 1583 or year > 2299
\&  empty_period();        # warns about empty interval if $^W is set
\&
\&  $index = $year\->date2index(YEAR,MONTH,DAY|DATE);
\&  $date  = $year\->index2date(INDEX);
\&
\&  use Date::Calendar::Profiles qw( $Profiles );
\&  $year_2000_US_FL = Date::Calendar::Year\->new( 2000, $Profiles\->{\*(AqUS\-FL\*(Aq} [,LANG[,WEEKEND]] );
\&  $year_2001_DE_NW = Date::Calendar::Year\->new( 2001, $Profiles\->{\*(AqDE\-NW\*(Aq} [,LANG[,WEEKEND]] );
\&
\&  $year = Date::Calendar::Year\->new( 2001, {} );
\&  $year\->init( 2002, $Profiles\->{\*(AqDE\-SN\*(Aq} [,LANG[,WEEKEND]] );
\&
\&  $vector = $year\->vec_full(); # vector of full holidays
\&  $vector = $year\->vec_half(); # vector of half holidays
\&  $vector = $year\->vec_work(); # NOT a vector of workdays but a workspace!
\&  $size   = $year\->val_days(); # number of days in that year, size of vectors
\&  $base   = $year\->val_base(); # number of days for [year,1,1] since [1,1,1]
\&  $number = $year\->val_year(); # the year\*(Aqs number itself
\&  $number = $year\->year();     # alias for val_year()
\&
\&  @names    = $year\->labels(YEAR,MONTH,DAY|DATE);
\&  @holidays = $year\->labels();
\&  $holidays = $year\->labels();
\&
\&  @dates    = $year\->search(PATTERN);
\&  $dates    = $year\->search(PATTERN);
\&
\&  $hashref  = $year\->tags(YEAR,MONTH,DAY|DATE);
\&  $hashref  = $year\->tags(INDEX);
\&
\&  $days     = $year\->delta_workdays(YEAR,MONTH1,DAY1|DATE1
\&                                   ,YEAR,MONTH2,DAY2|DATE2
\&                                   ,FLAG1,FLAG2);
\&
\&  ($date,$rest,$sign) = $year\->add_delta_workdays(YEAR,MONTH,DAY|DATE
\&                                                 ,DELTA,SIGN);
\&
\&  $flag     = $year\->is_full(YEAR,MONTH,DAY|DATE);
\&  $flag     = $year\->is_half(YEAR,MONTH,DAY|DATE);
\&  $flag     = $year\->is_work(YEAR,MONTH,DAY|DATE);
.Ve
.SH "INTERFACE"
.IX Header "INTERFACE"
Note that whenever a year number, a date, a time or a combined
date and time are expected as input parameters by one of the
methods of this class, you can always pass a Date::Calc[::Object]
date object or an array reference (of an array of appropriate
length) instead!
.PP
See \fIDate::Calc::Object\fR\|(3) for more details.
.PP
So instead of calling a given method like this:
.PP
.Vb 3
\&  $object\->method1( $year,$month,$day );
\&  $object\->method2( $year1,$month1,$day1, $year2,$month2,$day2 );
\&  $object\->method3( $year1, $year2, $year3 );
.Ve
.PP
You can also call it like so:
.PP
.Vb 2
\&  $object\->method1( $date );
\&  $object\->method1( [1964,1,3] );
\&
\&  $object\->method2( $year1,$month1,$day1, $date2 );
\&  $object\->method2( $date1, $year2,$month2,$day2 );
\&  $object\->method2( $date1, $date2 );
\&  $object\->method2( $year1,$month1,$day1, [2001,3,17] );
\&  $object\->method2( [1964,1,3], $year2,$month2,$day2 );
\&  $object\->method2( [1964,1,3], [2001,3,17] );
\&  $object\->method2( $date1, [2001,3,17] );
\&  $object\->method2( [1964,1,3], $date2 );
\&
\&  $object\->method3( $year1, $date2, [2001,3,17] );
.Ve
.PP
And similarly if a time or a combined date and time are expected.
.PP
If you substitute an expected year number by an anonymous array
(this is the recommended way of writing date constants, for
increased readability of your programs), it must contain three
values, nevertheless (otherwise the use of an anonymous array
would be pointless).
.PP
Don't confuse year numbers and their substitutes (a date object
or an array reference) with Date::Calendar::Year objects, which
are a totally different thing!
.PP
But incidentally \f(CW\*(C`:\-)\*(C'\fR, you may also pass a Date::Calendar::Year
object whenever a year number is expected. However, and perhaps
against your expectations at times, only the year number from
that object will be used, not the year object itself (the year
object in question might be using the wrong profile!).
.PP
Moreover, whenever a method of this class returns a date, it
does so by returning a Date::Calc[::Object] date object.
.SH "IMPLEMENTATION"
.IX Header "IMPLEMENTATION"
Each Date::Calendar::Year object consists mainly of three bit
vectors, plus some administrative attributes, all stored in a
(blessed) hash.
.PP
All three bit vectors contain as many bits as there are days
in the corresponding year, i.e., either 365 or 366.
.PP
The first bit vector, called \*(L"\s-1FULL\*(R",\s0 contains set bits for
Saturdays, Sundays and all \*(L"full\*(R" legal holidays (i.e.,
days off, on which you usually do not work).
.PP
The second bit vector, called \*(L"\s-1HALF\*(R",\s0 contains set bits for
all \*(L"half\*(R" holidays, i.e., holidays where you get only half
a day off from work.
.PP
The third and last bit vector, called \*(L"\s-1WORK\*(R",\s0 is used as a
workspace, in which various calculations are performed
throughout this module.
.PP
Its name does \fB\s-1NOT\s0\fR come from \*(L"working days\*(R" (as you might
think), but from \*(L"workspace\*(R".
.PP
It only so happens that it is used to calculate the working
days sometimes, at some places in this module.
.PP
But you are free to use it yourself, for whatever calculation
you would like to carry out yourself.
.PP
The two other bit vectors, \*(L"\s-1FULL\*(R"\s0 and \*(L"\s-1HALF\*(R",\s0 should never be
changed, unless you know \fB\s-1EXACTLY\s0\fR what you're doing!
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Functions
.IP "\(bu" 2
\&\f(CW\*(C`check_year(YEAR);\*(C'\fR
.Sp
This function checks that the given year lies in the permitted
range [1583..2299]. It returns nothing in case of success, and
throws an exception (\*(L"given year out of range [1583..2299]\*(R")
otherwise.
.IP "\(bu" 2
\&\f(CW\*(C`empty_period();\*(C'\fR
.Sp
This function issues a warning (from the perspective of the
caller of a Date::* module) that the given range of dates is
empty (\*(L"dates interval is empty\*(R"), provided that warnings are
enabled (i.e., "\f(CW$^W\fR" is true).
.Sp
This function is currently used by the method \*(L"\fIdelta_workdays()\fR\*(R"
in this class, and by its equivalent from the Date::Calendar
module.
.Sp
It is called whenever the range of dates of which the difference
in working days is to be calculated is empty. This can happen for
instance if you specify two adjacent dates both of which are not
to be included in the difference.
.PP
Methods
.IP "\(bu" 2
\&\f(CW\*(C`$index = $year\->date2index(YEAR,MONTH,DAY|DATE);\*(C'\fR
.Sp
This method converts a given date into the number of the day in
that year (this is sometimes also referred to as the \*(L"julian\*(R"
date), i.e., a number between 0 (for January 1st) and the number
of days in the given year minus one, i.e., 364 or 365 (for
December 31st).
.Sp
You may need this in order to access the bit vectors returned
by the methods \*(L"\fIvec_full()\fR\*(R", \*(L"\fIvec_half()\fR\*(R" and \*(L"\fIvec_work()\fR\*(R".
.Sp
Note that there are shorthand methods in this module called
\&\*(L"\fIis_full()\fR\*(R", \*(L"\fIis_half()\fR\*(R" and \*(L"\fIis_work()\fR\*(R", which serve to test
individual bits of the three bit vectors which are a part of
each Date::Calendar::Year object.
.Sp
An exception (\*(L"given year != object's year\*(R") is thrown if the
year associated with the year object itself and the year from
the given date do not match.
.Sp
An exception (\*(L"invalid date\*(R") is also thrown if the given
arguments do not constitute a valid date, or (\*(L"given year
out of range [1583..2299]\*(R") if the given year lies outside
of the permitted range.
.IP "\(bu" 2
\&\f(CW\*(C`$date = $year\->index2date(INDEX);\*(C'\fR
.Sp
This method converts an index (or \*(L"julian date\*(R") for the
given year back into a date.
.Sp
An exception (\*(L"invalid index\*(R") is thrown if the given index
is outside of the permitted range for the given year, i.e.,
\&\f(CW\*(C`[0..364]\*(C'\fR or \f(CW\*(C`[0..365]\*(C'\fR.
.Sp
Note that this method returns a Date::Calc \fB\s-1OBJECT\s0\fR!
.IP "\(bu" 2
\&\f(CW\*(C`$year_2000_US_FL = Date::Calendar::Year\->new( 2000, $Profiles\->{\*(AqUS\-FL\*(Aq} [,LANG[,WEEKEND]] );\*(C'\fR
.Sp
\&\f(CW\*(C`$year_2001_DE_NW = Date::Calendar::Year\->new( 2001, $Profiles\->{\*(AqDE\-NW\*(Aq} [,LANG[,WEEKEND]] );\*(C'\fR
.Sp
\&\f(CW\*(C`$year = Date::Calendar::Year\->new( 2001, {} );\*(C'\fR
.Sp
This is the constructor method. Call it to create a new
Date::Calendar::Year object.
.Sp
The first argument must be a year number in the range
[1583..2299].
.Sp
The second argument must be the reference of a hash,
which usually contains names of holidays and commemorative
days as keys and strings containing the date or formula
for each holiday as values.
.Sp
Reading this hash and initializing the object's internal
data is performed by an extra method, called \*(L"\fIinit()\fR\*(R",
which is called internally by the constructor method,
and which is described immediately below, after this
method.
.Sp
In case you want to call the \*(L"\fIinit()\fR\*(R" method yourself,
explicitly, after creating the object, you can pass an
empty profile (e.g., just an empty anonymous hash) to
the \*(L"\fInew()\fR\*(R" method, in order to create an empty object,
and also to improve performance.
.Sp
The third argument is optional, and must consist of
the valid name or number of a language as provided by
the \fIDate::Calc\fR\|(3) module, if given.
.Sp
This argument determines which language shall be used
when reading the profile, since the profile may contain
names of months and weekdays in its formulas in that
language.
.Sp
The default is English if no value or no valid value
is specified (and if the global default has not been
changed with \*(L"\fILanguage()\fR\*(R").
.Sp
After the third argument, a list of day numbers which
will constitute the \*(L"weekend\*(R" can optionally be specified,
where 1=Monday, 2=Tuesday, 3=Wednesday, 4=Thursday,
5=Friday, 6=Saturday and 7=Sunday.
.Sp
If no values are given, 6 and 7 (Saturday and Sunday)
are automatically taken as default.
.Sp
If values outside of the range \f(CW1..7\fR are given,
they will be ignored.
.Sp
This can be used to switch off this feature and to
have no regularly recurring holidays at all when
for instance a zero is given.
.IP "\(bu" 2
\&\f(CW\*(C`$year\->init( 2002, $Profiles\->{\*(AqDE\-SN\*(Aq} [,LANG[,WEEKEND]] );\*(C'\fR
.Sp
This method is called by the \*(L"\fInew()\fR\*(R" constructor method,
internally, and has the same arguments as the latter.
.Sp
See immediately above for a description of these arguments.
.Sp
Note that you can also call this method explicitly yourself,
if needed, and you can of course subclass the Date::Calendar::Year
class and override the \*(L"\fIinit()\fR\*(R" method with a method of your own.
.Sp
The holiday scheme or \*(L"profile\*(R" (i.e., the reference of
a hash passed as the second argument to this method) must
obey the following semantics and syntax:
.Sp
The keys are the names of the holiday or commemorative day
in question. Keys must be unique (but see further below).
.Sp
The difference between a holiday and a commemorative day is
that you (usually) get a day off on a holiday, whereas on a
purely commemorative day, you don't.
.Sp
A commemorative day is just a date with a name, nothing more.
.Sp
The values belonging to these keys can either be the code
reference of a callback function (see \fIDate::Calendar::Profiles\fR\|(3)
for more details and examples), or a string.
.Sp
All other values cause a fatal error with program abortion.
.Sp
The strings can specify three types of dates:
.Sp
.Vb 2
\&  \-  fixed dates
\&     (like New Year, or first of January),
\&
\&  \-  dates relative to Easter Sunday
\&     (like Ascension = Easter Sunday + 39 days), and
\&
\&  \-  the 1st, 2nd, 3rd, 4th or last
\&     of a given day of week in a given month
\&     (like "the 4th Thursday of November", or Thanksgiving).
.Ve
.Sp
All other types of dates must be specified via callback
functions.
.Sp
Note that the \*(L"last\*(R" of a given day of week is written as
the \*(L"5th\*(R", because the last is always either the 5th or the
4th of the given day of week. So the \*(L"\fIinit()\fR\*(R" module first
calculates the 5th of the requested day of week, and if that
doesn't exist, takes the 4th instead.
.Sp
There are also two modifier characters which may prefix the
string with the date formula, \*(L"#\*(R" and \*(L":\*(R".
.Sp
The character \*(L"#\*(R" (mnemonic: it's only a comment) signals
that the date in question is a purely commemorative day,
i.e., it will not enter into any date calculations, but
can be queried with the \*(L"\fIlabels()\fR\*(R" and \*(L"\fIsearch()\fR\*(R" methods,
and appears when printing a calendar, for instance.
.Sp
The character \*(L":\*(R" (mnemonic: divided into two halfs) specifies
that the date in question is only a \*(L"half\*(R" holiday, i.e., you
only get half a day off instead of a full day. Some companies
have this sort of thing. \f(CW\*(C`:\-)\*(C'\fR
.Sp
The exact syntax for the date formula strings is the following
(by example):
.Sp
.Vb 1
\& \-  Fixed dates:
\&
\&    "Christmas"  =>  "24.12",   # European format (day, month)
\&    "Christmas"  =>  "24.12.",
\&
\&    "Christmas"  =>  "24Dec",
\&    "Christmas"  =>  "24.Dec",
\&    "Christmas"  =>  "24Dec.",
\&    "Christmas"  =>  "24.Dec.",
\&
\&    "Christmas"  =>  "24\-12",
\&    "Christmas"  =>  "24\-12\-",
\&
\&    "Christmas"  =>  "24\-Dec",
\&    "Christmas"  =>  "24\-Dec\-",
\&
\&    "Christmas"  =>  "12/25",   # American format (month, day)
\&    "Christmas"  =>  "Dec25",
\&    "Christmas"  =>  "Dec/25",
\&
\& \-  Dates relative to Easter Sunday:
\&
\&    "Ladies\*(Aq Carnival"  =>  "\-52",
\&    "Carnival Monday"   =>  "\-48",
\&    "Mardi Gras"        =>  "\-47",
\&    "Ash Wednesday"     =>  "\-46",
\&    "Palm Sunday"       =>   "\-7",
\&    "Maundy Thursday"   =>   "\-3",
\&    "Good Friday"       =>   "\-2",
\&    "Easter Sunday"     =>   "+0",
\&    "Easter Monday"     =>   "+1",
\&    "Ascension"         =>  "+39",
\&    "Whitsunday"        =>  "+49",
\&    "Whitmonday"        =>  "+50",
\&    "Corpus Christi"    =>  "+60",
\&
\& \-  The 1st, 2nd, 3rd, 4th or last day of week:
\&
\&    "Thanksgiving"      =>  "4Thu11",
\&    "Thanksgiving"      =>  "4/Thu/Nov",
\&    "Columbus Day"      =>  "2/Mon/Oct",
\&    "Columbus Day"      =>  "2/Mon/10",
\&    "Columbus Day"      =>  "2/1/Oct",
\&    "Columbus Day"      =>  "2/1/10",
\&    "Memorial Day"      =>  "5/Mon/May", # LAST Monday of May
.Ve
.Sp
Remember that each of these date formula strings may
also be prefixed with either \*(L"#\*(R" or \*(L":\*(R":
.Sp
.Vb 2
\&    "Christmas"         =>  ":24.12.", # only half a day off
\&    "Valentine\*(Aqs Day"   =>  "#Feb/14", # not an official holiday
.Ve
.Sp
Note that the name of the month or day of week may have any
length you like, it just must specify the intended month or
day of week unambiguously. So \*(L"D\*(R", \*(L"De\*(R", \*(L"Dec\*(R", \*(L"Dece\*(R",
\&\*(L"Decem\*(R", \*(L"Decemb\*(R", \*(L"Decembe\*(R" and \*(L"December\*(R" would all
be valid, for example. Note also that case is ignored.
.Sp
When specifying day and month numbers, or offsets relative
to Easter Sunday, leading zeros are permitted (for nicely
indented formatting, for instance) but ignored.
.Sp
Leading zeros are not permitted in front of the ordinal
number [1..5] or the number of the day of week [1..7]
when specifying the nth day of week in a month.
.Sp
\&\fB\s-1BEWARE\s0\fR that if keys are not unique in the source code,
later entries will overwrite previous ones! I.e.,
.Sp
.Vb 4
\&    ...
\&    "My special holiday" => "01\-11",
\&    "My special holiday" => "02\-11",
\&    ...
.Ve
.Sp
will \fB\s-1NOT\s0\fR set two holidays of the same name, one on November
first, the other on November second, but only one, on November
second!
.Sp
Therefore, in order to use sets of defaults and to be able
to override some of them, you must \fB\s-1FIRST\s0\fR include any hash
containing the default definitions, and \fB\s-1THEN\s0\fR write down
your own definitions (see also the Date::Calendar::Profiles
module for examples of this!), like this:
.Sp
.Vb 6
\&    $defaults =
\&    {
\&        "Holiday #1" => "01\-01",
\&        "Holiday #2" => "02\-02",
\&        "Holiday #3" => "03\-03"
\&    };
\&
\&    $variant1 =
\&    {
\&        %$defaults,
\&        "Holiday #2" => "09\-02",
\&        "Holiday #4" => "04\-04"
\&    };
.Ve
.Sp
This is because of the way hashes work in Perl.
.Sp
The \*(L"\fIinit()\fR\*(R" method proceeds as follows:
.Sp
First it checks whether the given year number lies in
the range [1583..2299]. A fatal error occurs if not.
.Sp
Then it determines the number of days in the requested
year, and stores it in the given Date::Calendar::Year
object.
.Sp
It then calls the \fIBit::Vector\fR\|(3) module to allocate three
bit vectors with a number of bits equal to the number of
days in the requested year, and stores the three object
references (of the bit vectors) in the Date::Calendar::Year
object.
.Sp
(See also the description of the three methods \*(L"\fIvec_full()\fR\*(R",
\&\*(L"\fIvec_half()\fR\*(R" and \*(L"\fIvec_full()\fR\*(R" immediately below.)
.Sp
It then sets the bits which correspond to Saturdays and
Sundays (or optionally to the days whose numbers have been
specified as the \*(L"weekend\*(R") in the \*(L"full holidays\*(R" bit vector.
.Sp
At last, it iterates over the keys of the given holiday
scheme (of the hash referred to by the hash reference
passed to the \*(L"\fIinit()\fR\*(R" method as the second argument),
evaluates the formula (or calls the given callback
function), and sets the corresponding bit in the \*(L"full\*(R"
or \*(L"half\*(R" holidays bit vector if the calculated date
is valid.
.Sp
A fatal error occurs if the date formula cannot be parsed
or if the date returned by a formula or callback function
is invalid (e.g. 30\-Feb\-2001 or the like) or lies outside
the given year (e.g. Easter+365).
.Sp
Finally, the \*(L"\fIinit()\fR\*(R" method makes sure that days marked
as \*(L"full\*(R" holidays do not appear as \*(L"half\*(R" holidays as
well.
.Sp
Then the \*(L"\fIinit()\fR\*(R" method returns.
.Sp
Note that when deciphering the date formulas, the \*(L"\fIinit()\fR\*(R"
method uses the functions \*(L"\fIDecode_Day_of_Week()\fR\*(R" and
\&\*(L"\fIDecode_Month()\fR\*(R" from the \fIDate::Calc\fR\|(3) module, which
are language-dependent.
.Sp
Therefore the \*(L"\fIinit()\fR\*(R" method allows you to pass it an optional
third argument, which must consist of the valid name or number
of a language as provided by the \fIDate::Calc\fR\|(3) module.
.Sp
For the time of scanning the given holiday scheme, the \*(L"\fIinit()\fR\*(R"
method will use the language that has been specified, or the
global setting from \*(L"\fILanguage()\fR\*(R" if no or an invalid language
parameter is given.
.Sp
The default is English if none is specified and if the
global setting has not been modified.
.Sp
This means that you can provide the names of months and days of
week in your holiday profile in any of the languages supported
by the \fIDate::Calc\fR\|(3) module, provided you give the \*(L"\fIinit()\fR\*(R"
method a clue (the third parameter) which language to expect.
.IP "\(bu" 2
\&\f(CW\*(C`$vector = $year\->vec_full();\*(C'\fR
.Sp
This method returns a reference to the bit vector in the
given year object which contains all \*(L"full\*(R" holidays.
.Sp
\&\fB\s-1BEWARE\s0\fR that you should \fB\s-1NEVER\s0\fR change the contents of this
bit vector unless you know \fB\s-1EXACTLY\s0\fR what you're doing!
.Sp
You should usually only read from this bit vector, or use it
as an operand in bit vector operations \- but never as an
lvalue.
.IP "\(bu" 2
\&\f(CW\*(C`$vector = $year\->vec_half();\*(C'\fR
.Sp
This method returns a reference to the bit vector in the
given year object which contains all \*(L"half\*(R" holidays.
.Sp
\&\fB\s-1BEWARE\s0\fR that you should \fB\s-1NEVER\s0\fR change the contents of this
bit vector unless you know \fB\s-1EXACTLY\s0\fR what you're doing!
.Sp
You should usually only read from this bit vector, or use it
as an operand in bit vector operations \- but never as an
lvalue.
.IP "\(bu" 2
\&\f(CW\*(C`$vector = $year\->vec_work();\*(C'\fR
.Sp
This method returns a reference to the \*(L"workspace\*(R" bit vector
in the given year object.
.Sp
Note that you cannot rely on the contents of this bit vector.
.Sp
You have to set it up yourself before performing any calculations
with it.
.Sp
Currently the contents of this bit vector are modified by the
two methods \*(L"\fIdelta_workdays()\fR\*(R" and \*(L"\fIadd_delta_workdays()\fR\*(R", in
ways which are hard to predict (depending on the calculations
being performed).
.Sp
The size of this bit vector can be determined through either
"\f(CW\*(C`$days = $vector\->Size();\*(C'\fR\*(L" or
\&\*(R"\f(CW\*(C`$days = $year\->val_days();\*(C'\fR".
.IP "\(bu" 2
\&\f(CW\*(C`$size = $year\->val_days();\*(C'\fR
.Sp
This method returns the number of days in the given year object,
i.e., either 365 or 366. This is also the size (number of bits)
of the three bit vectors contained in the given year object.
.IP "\(bu" 2
\&\f(CW\*(C`$base = $year\->val_base();\*(C'\fR
.Sp
This method returns the value of the expression
"\f(CW\*(C`Date_to_Days($year\->val_year(),1,1)\*(C'\fR", or in other words,
the number of days between January 1st of the year 1 and January
1st of the given year, plus one.
.Sp
This value is used internally by the method \*(L"\fIdate2index()\fR\*(R" in order
to calculate the \*(L"julian\*(R" date or day of the year for a given date.
.Sp
The expression above is computed only once in method \*(L"\fIinit()\fR\*(R" and
then stored in one of the year object's attributes, of which this
method just returns the value.
.IP "\(bu" 2
\&\f(CW\*(C`$number = $year\->val_year();\*(C'\fR
.Sp
\&\f(CW\*(C`$number = $year\->year();\*(C'\fR
.Sp
These two methods are identical, the latter being a shortcut of
the former.
.Sp
They return the number of the year for which a calendar has been
stored in the given year object.
.Sp
The method name \*(L"\fIval_year()\fR\*(R" is used here in order to be consistent
with the other attribute accessor methods of this class, and the
method \*(L"\fIyear()\fR\*(R" is necessary in order to be able to pass
Date::Calendar::Year objects as parameters instead of a year number
in the methods of the Date::Calendar and Date::Calendar::Year
modules.
.IP "\(bu" 2
\&\f(CW\*(C`@names = $year\->labels(YEAR,MONTH,DAY|DATE);\*(C'\fR
.Sp
\&\f(CW\*(C`@holidays = $year\->labels();\*(C'\fR
.Sp
\&\f(CW\*(C`$holidays = $year\->labels();\*(C'\fR
.Sp
If any arguments are given, they are supposed to represent a
date. In that case, a list of all labels (= names of holidays)
associated with that date are returned. The first item returned
is always the name of the day of week for that date.
.Sp
If no arguments are given, the list of all available labels in
the given year is returned. This list does \fB\s-1NOT\s0\fR include any
names of the days of week (which would be pointless in this case).
.Sp
In list context, the resulting list itself is returned. In scalar
context, the number of items in the resulting list is returned.
.IP "\(bu" 2
\&\f(CW\*(C`@dates = $year\->search(PATTERN);\*(C'\fR
.Sp
\&\f(CW\*(C`$dates = $year\->search(PATTERN);\*(C'\fR
.Sp
This method searches through all the labels of the given year
and returns a list of date objects with all dates whose labels
match the given pattern.
.Sp
Note that this is a simple, case-insensitive substring search,
\&\fB\s-1NOT\s0\fR a full-fledged regular expression search!
.Sp
The result is guaranteed to be sorted chronologically.
.Sp
In scalar context, only the number of items in the resulting list
is returned, instead of the resulting list itself (as in list context).
.IP "\(bu" 2
\&\f(CW\*(C`$hashref  = $year\->tags(YEAR,MONTH,DAY|DATE);\*(C'\fR
.Sp
\&\f(CW\*(C`$hashref  = $year\->tags(INDEX);\*(C'\fR
.Sp
This method returns a hash reference for the given calendar and date
(or index). The hash it refers to is a copy of the calendar profile's
internal hash which contains the names for the given date as keys and
0, 1, 2, or 3 as their corresponding values meaning the following:
.Sp
.Vb 4
\&    0    =>    commemorative day
\&    1    =>    "half" holiday
\&    2    =>    "full" holiday
\&    3    =>    both a "half" and a "full" holiday
.Ve
.Sp
The value \*(L"3\*(R" should only occur if a date has been redefined by the
underlying profile using the same key (i.e., the same name) but with
a different type of holiday.
.Sp
The index must be a number such as returned by the method \*(L"\fIdate2index()\fR\*(R";
it can be used here instead of a date or a date object in order to speed
up processing (= no need to calculate it internally).
.IP "\(bu" 2
\&\f(CW\*(C`$days = $year\->delta_workdays(YEAR,MONTH1,DAY1, YEAR,MONTH2,DAY2, FLAG1,FLAG2);\*(C'\fR
.Sp
\&\f(CW\*(C`$days = $year\->delta_workdays(DATE1,DATE2,FLAG1,FLAG2);\*(C'\fR
.Sp
This method calculates the number of work days (i.e., the number
of days, but excluding all holidays) between two dates.
.Sp
In other words, this method is equivalent to the \*(L"\fIDelta_Days()\fR\*(R"
function of the Date::Calc module, except that it disregards
holidays in its counting.
.Sp
The two flags indicate whether the start and end dates should be
included in the counting (that is, of course, only in case they
aren't holidays), or not.
.Sp
It is common, for example, that you want to know how many work
days are left between the current date and a given deadline.
.Sp
Typically, you will want to count the current date but not the
deadline's date. So you would specify \*(L"true\*(R" (\*(L"1\*(R") for \s-1FLAG1\s0
and \*(L"false\*(R" (\*(L"0\*(R") for \s-1FLAG2\s0 in order to achieve that.
.Sp
In other words, a value of \*(L"true\*(R" means \*(L"including this date\*(R",
a value of \*(L"false\*(R" means \*(L"excluding this date\*(R".
.Sp
As with the \*(L"\fIDelta_Days()\fR\*(R" function from the Date::Calc module,
the dates have to be given in chronological order to yield a
positive result. If the dates are reversed, the result will
be negative.
.Sp
The parameter \s-1FLAG1\s0 is associated with the first given date,
the parameter \s-1FLAG2\s0 with the second given date (regardless
of whether the dates are in chronological order or not).
.Sp
An exception (\*(L"given year != object's year\*(R") is thrown if the
year number of either of the two given dates does not match the
year number associated with the given year object.
.Sp
An exception (\*(L"invalid date\*(R") is also raised if either of the
two date arguments does not constitute a valid date.
.IP "\(bu" 2
\&\f(CW\*(C`($date,$rest,$sign) = $year\->add_delta_workdays(YEAR,MONTH,DAY, DELTA, SIGN);\*(C'\fR
.Sp
\&\f(CW\*(C`($date,$rest,$sign) = $year\->add_delta_workdays(DATE,DELTA,SIGN);\*(C'\fR
.Sp
This method is the equivalent of the \*(L"\fIAdd_Delta_Days()\fR\*(R" function
from the Date::Calc module, except that it adds work days and
skips holidays.
.Sp
In other words, you can add or subtract a number of work days
\&\*(L"\s-1DELTA\*(R"\s0 to/from a given date and get a new date as the result
(as a Date::Calc object).
.Sp
You add days (i.e., you go forward in time) with a positive
offset \*(L"\s-1DELTA\*(R",\s0 and you subtract days (i.e., you go backwards
in time) with a negative offset.
.Sp
Note that an exception (\*(L"invalid date\*(R") is raised if the
given date argument (the \*(L"start\*(R" date) does not constitute
a valid date.
.Sp
Beware that this method is limited to date calculations within
a single year (in contrast to the method with the same name
from the Date::Calendar module).
.Sp
Therefore, the method does not only return a date (object),
but also a \*(L"rest\*(R" and a \*(L"sign\*(R".
.Sp
The \*(L"rest\*(R" indicates how many days are still left from your
original \s-1DELTA\s0 after going in the desired direction and
reaching a year boundary.
.Sp
The \*(L"sign\*(R" indicates in which direction (future or past) one
needs to go in order to \*(L"eat up\*(R" the \*(L"rest\*(R" (by subtracting
a day from the \*(L"rest\*(R" for each work day passed), or to adjust
the resulting date (in order to skip any holidays directly
after a year boundary), if at all.
.Sp
The \*(L"sign\*(R" is \-1 for going backwards in time, +1 for going
forward, and 0 if the result doesn't need any more fixing
(for instance because the result lies in the same year as
the starting date).
.Sp
The method \*(L"\fIadd_delta_workdays()\fR\*(R" from the Date::Calendar
module uses the \*(L"rest\*(R" and \*(L"sign\*(R" return values from this
method in order to perform calculations which may cross
year boundaries.
.Sp
Therefore, it is not recommended to use this method here
directly, as it is rather clumsy to use, but to use the
method with the same name from the Date::Calendar module
instead, which does the same but is much easier to use
and moreover allows calculations which cross an arbitrary
number of year boundaries.
.Sp
\&\fB\s-1BEWARE\s0\fR that this method may currently return unexpected
(i.e., contradicting the above documentation) or plain wrong
results when going back in time (this is a bug!).
.Sp
However, it works correctly and as documented above when
going forward in time.
.IP "\(bu" 2
\&\f(CW\*(C`$flag = $year\->is_full(YEAR,MONTH,DAY|DATE);\*(C'\fR
.Sp
This method returns \*(L"true\*(R" (\*(L"1\*(R") if the bit corresponding to
the given date is set in the bit vector representing \*(L"full\*(R"
holidays, and \*(L"false\*(R" (\*(L"0\*(R") otherwise.
.Sp
I.e., the method returns \*(L"true\*(R" if the given date is a (full)
holiday (according to the calendar profile associated with the
given year object).
.IP "\(bu" 2
\&\f(CW\*(C`$flag = $year\->is_half(YEAR,MONTH,DAY|DATE);\*(C'\fR
.Sp
This method returns \*(L"true\*(R" (\*(L"1\*(R") if the bit corresponding to
the given date is set in the bit vector representing \*(L"half\*(R"
holidays, and \*(L"false\*(R" (\*(L"0\*(R") otherwise.
.Sp
I.e., the method returns \*(L"true\*(R" if the given date is a half
holiday (according to the calendar profile associated with the
given year object).
.Sp
Note that if a date is a \*(L"full\*(R" holiday, the \*(L"half\*(R" bit is
never set, even if you try to do so in your calendar profile,
on purpose or by accident.
.IP "\(bu" 2
\&\f(CW\*(C`$flag = $year\->is_work(YEAR,MONTH,DAY|DATE);\*(C'\fR
.Sp
This method returns \*(L"true\*(R" (\*(L"1\*(R") if the bit corresponding to
the given date is set in the bit vector used to perform all
sorts of calculations, and \*(L"false\*(R" (\*(L"0\*(R") otherwise.
.Sp
\&\fB\s-1BEWARE\s0\fR that the \*(L"work\*(R" in this method's name does \fB\s-1NOT\s0\fR
come from \*(L"work days\*(R"!
.Sp
It comes from the fact that the corresponding bit vector can
be used for any \*(L"work\*(R" that you need to do. In other words,
it's a \*(L"work space\*(R".
.Sp
Therefore, this bit vector might contain about everything you
could imagine \- including a bit pattern which marks all \*(L"work
days\*(R" with set bits, if it so happens!
.Sp
But you better don't rely on it, unless you put the bit pattern
there yourself in the first place.
.Sp
Note that you can get a reference to this bit vector (in order
to fill it with any bit pattern you like) using the method
\&\*(L"\fIvec_work()\fR\*(R", described further above in this document.
.Sp
The number of bits in this bit vector is the same as the number
of days in the given year "\f(CW$year\fR\*(L", which you can retrieve
through either \*(R"\f(CW\*(C`$days = $year\->vec_work\->Size();\*(C'\fR\*(L"
or \*(R"\f(CW\*(C`$days = $year\->val_days();\*(C'\fR".
.Sp
See also \fIBit::Vector\fR\|(3) for more details.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fIBit::Vector\fR\|(3), \fIDate::Calendar\fR\|(3), \fIDate::Calendar::Profiles\fR\|(3),
\&\fIDate::Calc::Object\fR\|(3), \fIDate::Calc\fR\|(3), \fIDate::Calc::Util\fR\|(3).
.SH "KNOWN BUGS"
.IX Header "KNOWN BUGS"
The method \*(L"\fIadd_delta_workdays()\fR\*(R" is known to produce results
which are sometimes off by one working day when a negative
offset is used. As a workaround, try to add one working day
first and then subtract one working day more than initially
intended. See also the file \*(L"examples/bug.pl\*(R" for how to do
this.
.SH "VERSION"
.IX Header "VERSION"
This man page documents \*(L"Date::Calendar::Year\*(R" version 6.3.
.SH "AUTHOR"
.IX Header "AUTHOR"
.Vb 3
\&  Steffen Beyer
\&  mailto:STBEY@cpan.org
\&  http://www.engelschall.com/u/sb/download/
.Ve
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (c) 2000 \- 2009 by Steffen Beyer. All rights reserved.
.SH "LICENSE"
.IX Header "LICENSE"
This package is free software; you can use, modify and redistribute
it under the same terms as Perl itself, i.e., at your option, under
the terms either of the \*(L"Artistic License\*(R" or the \*(L"\s-1GNU\s0 General Public
License\*(R".
.PP
The C library at the core of the module \*(L"Date::Calc::XS\*(R" can, at your
discretion, also be used, modified and redistributed under the terms
of the \*(L"\s-1GNU\s0 Library General Public License\*(R".
.PP
Please refer to the files \*(L"Artistic.txt\*(R", \*(L"\s-1GNU_GPL\s0.txt\*(R" and
\&\*(L"\s-1GNU_LGPL\s0.txt\*(R" in the \*(L"license\*(R" subdirectory of this distribution
for any details!
.SH "DISCLAIMER"
.IX Header "DISCLAIMER"
This package is distributed in the hope that it will be useful,
but \s-1WITHOUT ANY WARRANTY\s0; without even the implied warranty of
\&\s-1MERCHANTABILITY\s0 or \s-1FITNESS FOR A PARTICULAR PURPOSE.\s0
.PP
See the \*(L"\s-1GNU\s0 General Public License\*(R" for more details.
