.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "DBIx::Class::Admin 3"
.TH DBIx::Class::Admin 3 "2014-01-08" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
DBIx::Class::Admin \- Administration object for schemas
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  $ dbicadmin \-\-help
\&
\&  $ dbicadmin \-\-schema=MyApp::Schema \e
\&    \-\-connect=\*(Aq["dbi:SQLite:my.db", "", ""]\*(Aq \e
\&    \-\-deploy
\&
\&  $ dbicadmin \-\-schema=MyApp::Schema \-\-class=Employee \e
\&    \-\-connect=\*(Aq["dbi:SQLite:my.db", "", ""]\*(Aq \e
\&    \-\-op=update \-\-set=\*(Aq{ "name": "New_Employee" }\*(Aq
\&
\&  use DBIx::Class::Admin;
\&
\&  # ddl manipulation
\&  my $admin = DBIx::Class::Admin\->new(
\&    schema_class=> \*(AqMY::Schema\*(Aq,
\&    sql_dir=> $sql_dir,
\&    connect_info => { dsn => $dsn, user => $user, password => $pass },
\&  );
\&
\&  # create SQLite sql
\&  $admin\->create(\*(AqSQLite\*(Aq);
\&
\&  # create SQL diff for an upgrade
\&  $admin\->create(\*(AqSQLite\*(Aq, {} , "1.0");
\&
\&  # upgrade a database
\&  $admin\->upgrade();
\&
\&  # install a version for an unversioned schema
\&  $admin\->install("3.0");
.Ve
.SH "REQUIREMENTS"
.IX Header "REQUIREMENTS"
The Admin interface has additional requirements not currently part of
DBIx::Class. See DBIx::Class::Optional::Dependencies for more details.
.SH "ATTRIBUTES"
.IX Header "ATTRIBUTES"
.SS "schema_class"
.IX Subsection "schema_class"
the class of the schema to load
.SS "schema"
.IX Subsection "schema"
A pre-connected schema object can be provided for manipulation
.SS "resultset"
.IX Subsection "resultset"
a resultset from the schema to operate on
.SS "where"
.IX Subsection "where"
a hash ref or json string to be used for identifying data to manipulate
.SS "set"
.IX Subsection "set"
a hash ref or json string to be used for inserting or updating data
.SS "attrs"
.IX Subsection "attrs"
a hash ref or json string to be used for passing additional info to the \->search call
.SS "connect_info"
.IX Subsection "connect_info"
connect_info the arguments to provide to the connect call of the schema_class
.SS "config_file"
.IX Subsection "config_file"
config_file provide a config_file to read connect_info from, if this is provided
config_stanze should also be provided to locate where the connect_info is in the config
The config file should be in a format readable by Config::Any.
.SS "config_stanza"
.IX Subsection "config_stanza"
config_stanza for use with config_file should be a '::' delimited 'path' to the connection information
designed for use with catalyst config files
.SS "config"
.IX Subsection "config"
Instead of loading from a file the configuration can be provided directly as a hash ref.  Please note
config_stanza will still be required.
.SS "sql_dir"
.IX Subsection "sql_dir"
The location where sql ddl files should be created or found for an upgrade.
.SS "sql_type"
.IX Subsection "sql_type"
The type of sql dialect to use for creating sql files from schema
.SS "version"
.IX Subsection "version"
Used for install, the version which will be 'installed' in the schema
.SS "preversion"
.IX Subsection "preversion"
Previous version of the schema to create an upgrade diff for, the full sql for that version of the sql must be in the sql_dir
.SS "force"
.IX Subsection "force"
Try and force certain operations.
.SS "quiet"
.IX Subsection "quiet"
Be less verbose about actions
.SS "trace"
.IX Subsection "trace"
Toggle DBIx::Class debug output
.SH "METHODS"
.IX Header "METHODS"
.SS "create"
.IX Subsection "create"
.ie n .IP "Arguments: $sqlt_type, \e%sqlt_args, $preversion" 4
.el .IP "Arguments: \f(CW$sqlt_type\fR, \e%sqlt_args, \f(CW$preversion\fR" 4
.IX Item "Arguments: $sqlt_type, %sqlt_args, $preversion"
.PP
\&\f(CW\*(C`create\*(C'\fR will generate sql for the supplied schema_class in sql_dir. The
flavour of sql to generate can be controlled by supplying a sqlt_type which
should be a SQL::Translator name.
.PP
Arguments for SQL::Translator can be supplied in the sqlt_args hashref.
.PP
Optional preversion can be supplied to generate a diff to be used by upgrade.
.SS "upgrade"
.IX Subsection "upgrade"
.IP "Arguments: <none>" 4
.IX Item "Arguments: <none>"
.PP
upgrade will attempt to upgrade the connected database to the same version as the schema_class.
\&\fB\s-1MAKE SURE YOU BACKUP YOUR DB FIRST\s0\fR
.SS "install"
.IX Subsection "install"
.ie n .IP "Arguments: $version" 4
.el .IP "Arguments: \f(CW$version\fR" 4
.IX Item "Arguments: $version"
.PP
install is here to help when you want to move to DBIx::Class::Schema::Versioned and have an existing
database.  install will take a version and add the version tracking tables and 'install' the version.  No
further ddl modification takes place.  Setting the force attribute to a true value will allow overriding of
already versioned databases.
.SS "deploy"
.IX Subsection "deploy"
.ie n .IP "Arguments: $args" 4
.el .IP "Arguments: \f(CW$args\fR" 4
.IX Item "Arguments: $args"
.PP
deploy will create the schema at the connected database.  \f(CW$args\fR are passed straight to
\&\*(L"deploy\*(R" in DBIx::Class::Schema.
.SS "insert"
.IX Subsection "insert"
.ie n .IP "Arguments: $rs, $set" 4
.el .IP "Arguments: \f(CW$rs\fR, \f(CW$set\fR" 4
.IX Item "Arguments: $rs, $set"
.PP
insert takes the name of a resultset from the schema_class and a hashref of data to insert
into that resultset
.SS "update"
.IX Subsection "update"
.ie n .IP "Arguments: $rs, $set, $where" 4
.el .IP "Arguments: \f(CW$rs\fR, \f(CW$set\fR, \f(CW$where\fR" 4
.IX Item "Arguments: $rs, $set, $where"
.PP
update takes the name of a resultset from the schema_class, a hashref of data to update and
a where hash used to form the search for the rows to update.
.SS "delete"
.IX Subsection "delete"
.ie n .IP "Arguments: $rs, $where, $attrs" 4
.el .IP "Arguments: \f(CW$rs\fR, \f(CW$where\fR, \f(CW$attrs\fR" 4
.IX Item "Arguments: $rs, $where, $attrs"
.PP
delete takes the name of a resultset from the schema_class, a where hashref and a attrs to pass to \->search.
The found data is deleted and cannot be recovered.
.SS "select"
.IX Subsection "select"
.ie n .IP "Arguments: $rs, $where, $attrs" 4
.el .IP "Arguments: \f(CW$rs\fR, \f(CW$where\fR, \f(CW$attrs\fR" 4
.IX Item "Arguments: $rs, $where, $attrs"
.PP
select takes the name of a resultset from the schema_class, a where hashref and a attrs to pass to \->search.
The found data is returned in a array ref where the first row will be the columns list.
.SH "AUTHOR"
.IX Header "AUTHOR"
See \*(L"\s-1CONTRIBUTORS\*(R"\s0 in DBIx::Class.
.SH "LICENSE"
.IX Header "LICENSE"
You may distribute this code under the same terms as Perl itself
