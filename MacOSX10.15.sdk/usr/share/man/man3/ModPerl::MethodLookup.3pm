.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "install::TempContent::Objects::mod_perl-2.0.9::docs::api::ModPerl::MethodLookup 3"
.TH install::TempContent::Objects::mod_perl-2.0.9::docs::api::ModPerl::MethodLookup 3 "2015-06-18" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
ModPerl::MethodLookup \-\- Lookup mod_perl modules, objects and methods
.SH "Synopsis"
.IX Header "Synopsis"
.Vb 1
\&  use ModPerl::MethodLookup;
\&  
\&  # return all module names containing XS method \*(Aqprint\*(Aq
\&  my ($hint, @modules) =
\&      ModPerl::MethodLookup::lookup_method(\*(Aqprint\*(Aq);
\&  
\&  # return only module names containing method \*(Aqprint\*(Aq which
\&  # expects the first argument to be of type \*(AqApache2::Filter\*(Aq
\&  # (here $filter is an Apache2::Filter object)
\&  my ($hint, @modules) =
\&      ModPerl::MethodLookup::lookup_method(\*(Aqprint\*(Aq, $filter);
\&  # or
\&  my ($hint, @modules) =
\&      ModPerl::MethodLookup::lookup_method(\*(Aqprint\*(Aq, \*(AqApache2::Filter\*(Aq);
\&  
\&  # what XS methods defined by module \*(AqApache2::Filter\*(Aq
\&  my ($hint, @methods) =
\&      ModPerl::MethodLookup::lookup_module(\*(AqApache2::Filter\*(Aq);
\&  
\&  # what XS methods can be invoked on the object $r (or a ref)
\&  my ($hint, @methods) =
\&      ModPerl::MethodLookup::lookup_object($r);
\&  # or
\&  my ($hint, @methods) =
\&      ModPerl::MethodLookup::lookup_object(\*(AqApache2::RequestRec\*(Aq);
\&  
\&  # preload all mp2 modules in startup.pl
\&  ModPerl::MethodLookup::preload_all_modules();
\&  
\&  # command line shortcuts
\&  % perl \-MModPerl::MethodLookup \-e print_module \e
\&    Apache2::RequestRec Apache2::Filter
\&  % perl \-MModPerl::MethodLookup \-e print_object Apache2
\&  % perl \-MModPerl::MethodLookup \-e print_method \e
\&    get_server_built request
\&  % perl \-MModPerl::MethodLookup \-e print_method read
\&  % perl \-MModPerl::MethodLookup \-e print_method read APR::Bucket
.Ve
.SH "Description"
.IX Header "Description"
mod_perl 2.0 provides many methods, which reside in various
modules. One has to load each of the modules before using the desired
methods. \f(CW\*(C`ModPerl::MethodLookup\*(C'\fR provides the Perl \s-1API\s0 for finding
module names which contain methods in question and other helper
functions, to find out out what methods defined by some module, what
methods can be called on a given object, etc.
.SH "API"
.IX Header "API"
.ie n .SS """lookup_method()"""
.el .SS "\f(CWlookup_method()\fP"
.IX Subsection "lookup_method()"
Find modules (packages) containing a certain method
.PP
.Vb 3
\&  ($hint, @modules) = lookup_method($method_name);
\&  ($hint, @modules) = lookup_method($method_name, $object);
\&  ($hint, @modules) = lookup_method($method_name, $class));
.Ve
.ie n .IP "arg1: $method_name ( string )" 4
.el .IP "arg1: \f(CW$method_name\fR ( string )" 4
.IX Item "arg1: $method_name ( string )"
the method name to look up
.ie n .IP "opt arg2: $object or $class" 4
.el .IP "opt arg2: \f(CW$object\fR or \f(CW$class\fR" 4
.IX Item "opt arg2: $object or $class"
a blessed object or the name of the class it's blessed into. If there
is more than one match, this extra information is used to return only
modules containing methods operating on the objects of the same kind.
.Sp
If a sub-classed object is passed it'll be handled correctly, by
checking its super\-class(es).  This usage is useful when the
\&\f(CW\*(C`AUTOLOAD\*(C'\fR is used to find a not yet loaded module
which include the called method.
.ie n .IP "ret1: $hint" 4
.el .IP "ret1: \f(CW$hint\fR" 4
.IX Item "ret1: $hint"
a string containing a human readable lookup result, suggesting which
modules should be loaded, ready for copy-n-paste or explaining the
failure if the lookup didn't succeed.
.ie n .IP "ret2: @modules" 4
.el .IP "ret2: \f(CW@modules\fR" 4
.IX Item "ret2: @modules"
an array of modules which have matched the query, i.e. the names of
the modules which contain the requested method.
.IP "since: 2.0.00" 4
.IX Item "since: 2.0.00"
.PP
Examples:
.PP
Return all module names containing \s-1XS\s0 method \fIprint\fR:
.PP
.Vb 2
\&  my ($hint, @modules) =
\&      ModPerl::MethodLookup::lookup_method(\*(Aqprint\*(Aq);
.Ve
.PP
Return only module names containing method \fIprint\fR which expects the
first argument to be of type \f(CW\*(C`Apache2::Filter\*(C'\fR:
.PP
.Vb 3
\&  my $filter = bless {}, \*(AqApache2::Filter\*(Aq;
\&  my ($hint, @modules) =
\&      ModPerl::MethodLookup::lookup_method(\*(Aqprint\*(Aq, $filter);
.Ve
.PP
or:
.PP
.Vb 2
\&  my ($hint, @modules) =
\&      ModPerl::MethodLookup::lookup_method(\*(Aqprint\*(Aq, \*(AqApache2::Filter\*(Aq);
.Ve
.ie n .SS """lookup_module()"""
.el .SS "\f(CWlookup_module()\fP"
.IX Subsection "lookup_module()"
Find methods contained in a certain module (package)
.PP
.Vb 1
\&  ($hint, @methods) = lookup_module($module_name);
.Ve
.ie n .IP "arg1: $module_name ( string )" 4
.el .IP "arg1: \f(CW$module_name\fR ( string )" 4
.IX Item "arg1: $module_name ( string )"
the module name
.ie n .IP "ret1: $hint" 4
.el .IP "ret1: \f(CW$hint\fR" 4
.IX Item "ret1: $hint"
a string containing a human readable lookup result, suggesting, which
methods the module \f(CW$module_name\fR implements, or explaining the
failure if the lookup failed.
.ie n .IP "ret2: @methods" 4
.el .IP "ret2: \f(CW@methods\fR" 4
.IX Item "ret2: @methods"
an array of methods which have matched the query, i.e. the names of
the methods defined in the requested module.
.IP "since: 2.0.00" 4
.IX Item "since: 2.0.00"
.PP
Example:
.PP
What \s-1XS\s0 methods defined by module \f(CW\*(C`Apache2::Filter\*(C'\fR:
.PP
.Vb 2
\&  my ($hint, @methods) =
\&      ModPerl::MethodLookup::lookup_module(\*(AqApache2::Filter\*(Aq);
.Ve
.ie n .SS """lookup_object()"""
.el .SS "\f(CWlookup_object()\fP"
.IX Subsection "lookup_object()"
.Vb 2
\&  ($hint, @methods) = lookup_object($object);
\&  ($hint, @methods) = lookup_object($class);
.Ve
.ie n .IP "arg1: $object or $class" 4
.el .IP "arg1: \f(CW$object\fR or \f(CW$class\fR" 4
.IX Item "arg1: $object or $class"
an object or a name of a class an object is blessed into
.Sp
If a sub-classed object is passed it'll be handled correctly, by
including methods provided by its super\-class(es).
.ie n .IP "ret1: $hint" 4
.el .IP "ret1: \f(CW$hint\fR" 4
.IX Item "ret1: $hint"
a string containing a human readable lookup result, suggesting, which
methods the given object can invoke (including module names that need
to be loaded to use those methods), or explaining the failure if the
lookup failed.
.ie n .IP "ret2: @methods" 4
.el .IP "ret2: \f(CW@methods\fR" 4
.IX Item "ret2: @methods"
an array of methods which have matched the query, i.e. the names of
the methods that can be invoked on the given object (or its class
name).
.IP "since: 2.0.00" 4
.IX Item "since: 2.0.00"
.PP
\&\s-1META:\s0 As of this writing this function may miss some of the
functions/methods that can be invoked on the given object. Currently
we can't programmatically deduct the objects they are invoked on,
because these methods are written in pure \s-1XS\s0 and manipulate the
arguments stack themselves. Currently these are mainly \s-1XS\s0 functions,
not methods, which of course aren't invoked on objects. There are also
logging function wrappers (\f(CW\*(C`Apache2::Log\*(C'\fR).
.PP
Examples:
.PP
What \s-1XS\s0 methods can be invoked on the object \f(CW$r\fR:
.PP
.Vb 2
\&  my ($hint, @methods) =
\&      ModPerl::MethodLookup::lookup_object($r);
.Ve
.PP
or \f(CW$r\fR's class \*(-- \f(CW\*(C`Apache2::RequestRec\*(C'\fR:
.PP
.Vb 2
\&  my ($hint, @methods) =
\&      ModPerl::MethodLookup::lookup_object(\*(AqApache2::RequestRec\*(Aq);
.Ve
.ie n .SS """preload_all_modules()"""
.el .SS "\f(CWpreload_all_modules()\fP"
.IX Subsection "preload_all_modules()"
The function \f(CW\*(C`preload_all_modules()\*(C'\fR preloads all mod_perl 2.0
modules, which implement their \s-1API\s0 in \s-1XS.\s0 This is similar to the
mod_perl 1.0 behavior which has most of its methods loaded at the
startup.
.PP
\&\s-1CPAN\s0 modules developers should make sure their distribution loads each
of the used mod_perl 2.0 modules explicitly, and not use this
function, as it takes the fine control away from the users. One should
avoid doing this the production server (unless all modules are used
indeed) in order to save memory.
.IP "since: 2.0.00" 4
.IX Item "since: 2.0.00"
.ie n .SS """print_method()"""
.el .SS "\f(CWprint_method()\fP"
.IX Subsection "print_method()"
\&\f(CW\*(C`print_method()\*(C'\fR is a convenience wrapper for
\&\f(CW\*(C`lookup_method()\*(C'\fR, mainly designed to be used
from the command line. For example to print all the modules which
define method \fIread\fR execute:
.PP
.Vb 1
\&  % perl \-MModPerl::MethodLookup \-e print_method read
.Ve
.PP
Since this will return more than one module, we can narrow the query
to only those methods which expect the first argument to be blessed
into class \f(CW\*(C`APR::Bucket\*(C'\fR:
.PP
.Vb 1
\&  % perl \-MModPerl::MethodLookup \-e print_method read APR::Bucket
.Ve
.PP
You can pass more than one method and it'll perform a lookup on each
of the methods. For example to lookup methods \f(CW\*(C`get_server_built\*(C'\fR and
\&\f(CW\*(C`request\*(C'\fR you can do:
.PP
.Vb 2
\&  % perl \-MModPerl::MethodLookup \-e print_method \e
\&    get_server_built request
.Ve
.PP
The function \f(CW\*(C`print_method()\*(C'\fR is exported by default.
.IP "since: 2.0.00" 4
.IX Item "since: 2.0.00"
.ie n .SS """print_module()"""
.el .SS "\f(CWprint_module()\fP"
.IX Subsection "print_module()"
\&\f(CW\*(C`print_module()\*(C'\fR is a convenience wrapper for
\&\f(CW\*(C`lookup_module()\*(C'\fR, mainly designed to be used
from the command line. For example to print all the methods defined in
the module \f(CW\*(C`Apache2::RequestRec\*(C'\fR, followed by methods defined in the
module \f(CW\*(C`Apache2::Filter\*(C'\fR you can run:
.PP
.Vb 2
\&  % perl \-MModPerl::MethodLookup \-e print_module \e
\&    Apache2::RequestRec Apache2::Filter
.Ve
.PP
The function \f(CW\*(C`print_module()\*(C'\fR is exported by default.
.IP "since: 2.0.00" 4
.IX Item "since: 2.0.00"
.ie n .SS """print_object()"""
.el .SS "\f(CWprint_object()\fP"
.IX Subsection "print_object()"
\&\f(CW\*(C`print_object()\*(C'\fR is a convenience wrapper for
\&\f(CW\*(C`lookup_object()\*(C'\fR, mainly designed to be used
from the command line. For example to print all the methods that can
be invoked on object blessed into a class \f(CW\*(C`Apache2::RequestRec\*(C'\fR run:
.PP
.Vb 2
\&  % perl \-MModPerl::MethodLookup \-e print_object \e
\&    Apache2::RequestRec
.Ve
.PP
Similar to \f(CW\*(C`print_object()\*(C'\fR, more than one
class can be passed to this function.
.PP
The function \f(CW\*(C`print_object()\*(C'\fR is exported by default.
.IP "since: 2.0.00" 4
.IX Item "since: 2.0.00"
.SH "Applications"
.IX Header "Applications"
.ie n .SS """AUTOLOAD"""
.el .SS "\f(CWAUTOLOAD\fP"
.IX Subsection "AUTOLOAD"
When Perl fails to locate a method it checks whether the package the
object belongs to has an \f(CW\*(C`AUTOLOAD\*(C'\fR function defined and if so, calls
it with the same arguments as the missing method while setting a
global variable \f(CW$AUTOLOAD\fR (in that package) to the name of the
originally called method. We can use this facility to lookup the
modules to be loaded when such a failure occurs. Though since we have
many packages to take care of we will use a special
\&\f(CW\*(C`UNIVERSAL::AUTOLOAD\*(C'\fR function which Perl calls if can't find the
\&\f(CW\*(C`AUTOLOAD\*(C'\fR function in the given package.
.PP
In that function you can query \f(CW\*(C`ModPerl::MethodLookup\*(C'\fR, \fIrequire()\fR the
module that includes the called method and call that method again
using the \fIgoto()\fR trick:
.PP
.Vb 12
\&  use ModPerl::MethodLookup;
\&  sub UNIVERSAL::AUTOLOAD {
\&      my ($hint, @modules) =
\&          ModPerl::MethodLookup::lookup_method($UNIVERSAL::AUTOLOAD, @_);
\&      if (@modules) {
\&          eval "require $_" for @modules;
\&          goto &$UNIVERSAL::AUTOLOAD;
\&      }
\&      else {
\&          die $hint;
\&      }
\&  }
.Ve
.PP
However we don't endorse this approach. It's a better approach to
always abort the execution which printing the \f(CW$hint\fRand use fix the
code to load the missing module. Moreover installing
\&\f(CW\*(C`UNIVERSAL::AUTOLOAD\*(C'\fR may cause a lot of problems, since once it's
installed Perl will call it every time some method is missing
(e.g. undefined \f(CW\*(C`DESTROY\*(C'\fR methods). The following approach seems to
somewhat work for me. It installs \f(CW\*(C`UNIVERSAL::AUTOLOAD\*(C'\fR only when the
the child process starts.
.PP
.Vb 3
\&  httpd.conf:
\&  \-\-\-\-\-\-\-\-\-\-\-
\&  PerlChildInitHandler ModPerl::MethodLookupAuto
\&
\&  startup.pl:
\&  \-\-\-\-\-\-\-\-\-\-\-
\&  {
\&      package ModPerl::MethodLookupAuto;
\&      use ModPerl::MethodLookup;
\&    
\&      use Carp;
\&      sub handler {
\&    
\&          *UNIVERSAL::AUTOLOAD = sub {
\&              my $method = $AUTOLOAD;
\&              return if $method =~ /DESTROY/; # exclude DESTROY resolving
\&    
\&              my ($hint, @modules) =
\&                  ModPerl::MethodLookup::lookup_method($method, @_);
\&              $hint ||= "Can\*(Aqt find method $AUTOLOAD";
\&              croak $hint;
\&          };
\&          return 0;
\&      }
\&  }
.Ve
.PP
This example doesn't load the modules for you. It'll print to \s-1STDERR\s0
what module should be loaded, when a method from the not-yet-loaded
module is called.
.PP
A similar technique is used by
\&\f(CW\*(C`Apache2::porting\*(C'\fR.
.PP
\&\s-1META:\s0 there is a better version of \s-1AUTOLOAD\s0 discussed on the dev
list. Replace the current one with it. (search the archive for
EazyLife)
.SS "Command Line Lookups"
.IX Subsection "Command Line Lookups"
When a method is used and mod_perl has reported a failure to find it,
it's often useful to use the command line query to figure out which
module needs to be loaded. For example if when executing:
.PP
.Vb 1
\&  $r\->construct_url();
.Ve
.PP
mod_perl complains:
.PP
.Vb 2
\&  Can\*(Aqt locate object method "construct_url" via package
\&  "Apache2::RequestRec" at ...
.Ve
.PP
you can ask \f(CW\*(C`ModPerl::MethodLookup\*(C'\fR for help:
.PP
.Vb 3
\&  % perl \-MModPerl::MethodLookup \-e print_method construct_url
\&  To use method \*(Aqconstruct_url\*(Aq add:
\&          use Apache2::URI ();
.Ve
.PP
and after copy-n-pasting the use statement in our code, the problem
goes away.
.PP
One can create a handy alias for this technique. For example, C\-style
shell users can do:
.PP
.Vb 1
\&   % alias lookup "perl \-MModPerl::MethodLookup \-e print_method"
.Ve
.PP
For Bash-style shell users:
.PP
.Vb 1
\&   % alias lookup="perl \-MModPerl::MethodLookup \-e print_method"
.Ve
.PP
Now the lookup is even easier:
.PP
.Vb 3
\&  % lookup construct_url
\&  to use method \*(Aqconstruct_url\*(Aq add:
\&          use Apache2::URI;
.Ve
.PP
Similar aliases can be provided for
\&\f(CW\*(C`print_object()\*(C'\fR and
\&\f(CW\*(C`print_module()\*(C'\fR.
.SH "Todo"
.IX Header "Todo"
These methods aren't yet picked by this module (the extract from the
map file):
.PP
.Vb 3
\& modperl_filter_attributes     | MODIFY_CODE_ATTRIBUTES
\& modperl_spawn_proc_prog       | spawn_proc_prog
\& apr_ipsubnet_create           | new
.Ve
.PP
Please report to the mod_perl development mailing
list if you find any other missing methods. But remember that
as of this moment the module reports only \s-1XS\s0 functions. In the future
we may add support for pure perl functions/methods as well.
.SH "See Also"
.IX Header "See Also"
.IP "\(bu" 4
the mod_perl 1.0 backward compatibility
document
.IP "\(bu" 4
porting Perl modules
.IP "\(bu" 4
porting \s-1XS\s0 modules
.IP "\(bu" 4
\&\f(CW\*(C`Apache2::porting\*(C'\fR
.SH "Copyright"
.IX Header "Copyright"
mod_perl 2.0 and its core modules are copyrighted under
The Apache Software License, Version 2.0.
.SH "Authors"
.IX Header "Authors"
The mod_perl development team and numerous
contributors.
