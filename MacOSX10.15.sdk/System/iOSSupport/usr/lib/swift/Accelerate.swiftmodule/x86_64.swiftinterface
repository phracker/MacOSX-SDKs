// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 5.1 (swiftlang-1100.8.259.70 clang-1100.0.32.1)
// swift-module-flags: -target x86_64-apple-ios13.0-macabi -enable-objc-interop -autolink-force-load -enable-library-evolution -module-link-name swiftAccelerate -swift-version 5 -O -enforce-exclusivity=unchecked -module-name Accelerate
@_exported import Accelerate
@_exported import Accelerate
@_exported import Accelerate.vecLib.BNNS
import Swift
@available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
public enum vImage {
}
@available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
public enum vDSP {
}
@available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
public enum vForce {
}
@available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension vDSP {
  @available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public struct VectorizableFloat {
    public typealias Scalar = Swift.Float
  }
  @available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public struct VectorizableDouble {
    public typealias Scalar = Swift.Double
  }
}
@available(OSX 10.12, iOS 10.0, tvOS 10.0, watchOS 3.0, *)
extension BNNSDataType {
  @available(OSX 10.12, iOS 10.0, tvOS 10.0, watchOS 3.0, *)
  public static var float16: Accelerate.BNNSDataType {
    get
  }
  @available(OSX 10.12, iOS 10.0, tvOS 10.0, watchOS 3.0, *)
  public static var float: Accelerate.BNNSDataType {
    get
  }
  @available(OSX 10.12, iOS 10.0, tvOS 10.0, watchOS 3.0, *)
  public static var int8: Accelerate.BNNSDataType {
    get
  }
  @available(OSX 10.12, iOS 10.0, tvOS 10.0, watchOS 3.0, *)
  public static var int16: Accelerate.BNNSDataType {
    get
  }
  @available(OSX 10.12, iOS 10.0, tvOS 10.0, watchOS 3.0, *)
  public static var int32: Accelerate.BNNSDataType {
    get
  }
  @available(OSX 10.13, iOS 11.0, tvOS 11.0, watchOS 4.0, *)
  public static var uint8: Accelerate.BNNSDataType {
    get
  }
  @available(OSX 10.13, iOS 11.0, tvOS 11.0, watchOS 4.0, *)
  public static var uint16: Accelerate.BNNSDataType {
    get
  }
  @available(OSX 10.13, iOS 11.0, tvOS 11.0, watchOS 4.0, *)
  public static var uint32: Accelerate.BNNSDataType {
    get
  }
  @available(OSX 10.12, iOS 10.0, tvOS 10.0, watchOS 3.0, *)
  public static var indexed8: Accelerate.BNNSDataType {
    get
  }
}
@available(OSX 10.12, iOS 10.0, tvOS 10.0, watchOS 3.0, *)
@available(*, deprecated, renamed: "BNNSDataType.float16")
public var BNNSDataTypeFloat16: Accelerate.BNNSDataType
@available(OSX 10.12, iOS 10.0, tvOS 10.0, watchOS 3.0, *)
@available(*, deprecated, renamed: "BNNSDataType.float")
public var BNNSDataTypeFloat32: Accelerate.BNNSDataType
@available(OSX 10.12, iOS 10.0, tvOS 10.0, watchOS 3.0, *)
@available(*, deprecated, renamed: "BNNSDataType.int8")
public var BNNSDataTypeInt8: Accelerate.BNNSDataType
@available(OSX 10.12, iOS 10.0, tvOS 10.0, watchOS 3.0, *)
@available(*, deprecated, renamed: "BNNSDataType.int16")
public var BNNSDataTypeInt16: Accelerate.BNNSDataType
@available(OSX 10.12, iOS 10.0, tvOS 10.0, watchOS 3.0, *)
@available(*, deprecated, renamed: "BNNSDataType.int32")
public var BNNSDataTypeInt32: Accelerate.BNNSDataType
@available(OSX 10.12, iOS 10.0, tvOS 10.0, watchOS 3.0, *)
@available(*, deprecated, renamed: "BNNSDataType.indexed8")
public var BNNSDataTypeIndexed8: Accelerate.BNNSDataType
@available(OSX 10.12, iOS 10.0, tvOS 10.0, watchOS 3.0, *)
extension BNNSPoolingFunction {
  @available(OSX 10.12, iOS 10.0, tvOS 10.0, watchOS 3.0, *)
  public static var max: Accelerate.BNNSPoolingFunction {
    get
  }
  @available(OSX 10.12, iOS 10.0, tvOS 10.0, watchOS 3.0, *)
  public static var average: Accelerate.BNNSPoolingFunction {
    get
  }
}
@available(OSX 10.12, iOS 10.0, tvOS 10.0, watchOS 3.0, *)
@available(*, deprecated, renamed: "BNNSPoolingFunction.max")
public var BNNSPoolingFunctionMax: Accelerate.BNNSPoolingFunction
@available(OSX 10.12, iOS 10.0, tvOS 10.0, watchOS 3.0, *)
@available(*, deprecated, renamed: "BNNSPoolingFunction.average")
public var BNNSPoolingFunctionAverage: Accelerate.BNNSPoolingFunction
@available(OSX 10.12, iOS 10.0, tvOS 10.0, watchOS 3.0, *)
extension BNNSActivationFunction {
  @available(OSX 10.12, iOS 10.0, tvOS 10.0, watchOS 3.0, *)
  public static var identity: Accelerate.BNNSActivationFunction {
    get
  }
  @available(OSX 10.12, iOS 10.0, tvOS 10.0, watchOS 3.0, *)
  public static var rectifiedLinear: Accelerate.BNNSActivationFunction {
    get
  }
  @available(OSX 10.12, iOS 10.0, tvOS 10.0, watchOS 3.0, *)
  public static var leakyRectifiedLinear: Accelerate.BNNSActivationFunction {
    get
  }
  @available(OSX 10.12, iOS 10.0, tvOS 10.0, watchOS 3.0, *)
  public static var sigmoid: Accelerate.BNNSActivationFunction {
    get
  }
  @available(OSX 10.12, iOS 10.0, tvOS 10.0, watchOS 3.0, *)
  public static var tanh: Accelerate.BNNSActivationFunction {
    get
  }
  @available(OSX 10.12, iOS 10.0, tvOS 10.0, watchOS 3.0, *)
  public static var scaledTanh: Accelerate.BNNSActivationFunction {
    get
  }
  @available(OSX 10.12, iOS 10.0, tvOS 10.0, watchOS 3.0, *)
  public static var abs: Accelerate.BNNSActivationFunction {
    get
  }
  @available(OSX 10.13, iOS 11.0, tvOS 11.0, watchOS 4.0, *)
  public static var linear: Accelerate.BNNSActivationFunction {
    get
  }
  @available(OSX 10.13, iOS 11.0, tvOS 11.0, watchOS 4.0, *)
  public static var clamp: Accelerate.BNNSActivationFunction {
    get
  }
  @available(OSX 10.13, iOS 11.0, tvOS 11.0, watchOS 4.0, *)
  public static var integerLinearSaturate: Accelerate.BNNSActivationFunction {
    get
  }
  @available(OSX 10.13, iOS 11.0, tvOS 11.0, watchOS 4.0, *)
  public static var integerLinearSaturatePerChannel: Accelerate.BNNSActivationFunction {
    get
  }
  @available(OSX 10.13, iOS 11.0, tvOS 11.0, watchOS 4.0, *)
  public static var softmax: Accelerate.BNNSActivationFunction {
    get
  }
}
@available(OSX 10.12, iOS 10.0, tvOS 10.0, watchOS 3.0, *)
@available(*, deprecated, renamed: "BNNSActivationFunction.identity")
public var BNNSActivationFunctionIdentity: Accelerate.BNNSActivationFunction
@available(OSX 10.12, iOS 10.0, tvOS 10.0, watchOS 3.0, *)
@available(*, deprecated, renamed: "BNNSActivationFunction.rectifiedLinear")
public var BNNSActivationFunctionRectifiedLinear: Accelerate.BNNSActivationFunction
@available(OSX 10.12, iOS 10.0, tvOS 10.0, watchOS 3.0, *)
@available(*, deprecated, renamed: "BNNSActivationFunction.leakyRectifiedLinear")
public var BNNSActivationFunctionLeakyRectifiedLinear: Accelerate.BNNSActivationFunction
@available(OSX 10.12, iOS 10.0, tvOS 10.0, watchOS 3.0, *)
@available(*, deprecated, renamed: "BNNSActivationFunction.sigmoid")
public var BNNSActivationFunctionSigmoid: Accelerate.BNNSActivationFunction
@available(OSX 10.12, iOS 10.0, tvOS 10.0, watchOS 3.0, *)
@available(*, deprecated, renamed: "BNNSActivationFunction.tanh")
public var BNNSActivationFunctionTanh: Accelerate.BNNSActivationFunction
@available(OSX 10.12, iOS 10.0, tvOS 10.0, watchOS 3.0, *)
@available(*, deprecated, renamed: "BNNSActivationFunction.scaledTanh")
public var BNNSActivationFunctionScaledTanh: Accelerate.BNNSActivationFunction
@available(OSX 10.12, iOS 10.0, tvOS 10.0, watchOS 3.0, *)
@available(*, deprecated, renamed: "BNNSActivationFunction.abs")
public var BNNSActivationFunctionAbs: Accelerate.BNNSActivationFunction
@available(OSX 10.12, iOS 10.0, tvOS 10.0, watchOS 3.0, *)
extension BNNSFlags {
  @available(OSX 10.12, iOS 10.0, tvOS 10.0, watchOS 3.0, *)
  public static var useClientPointer: Accelerate.BNNSFlags {
    get
  }
}
@available(OSX 10.12, iOS 10.0, tvOS 10.0, watchOS 3.0, *)
@available(*, deprecated, renamed: "BNNSFlags.useClientPointer")
public var BNNSFlagsUseClientPtr: Accelerate.BNNSFlags
@available(OSX 10.12, iOS 10.0, tvOS 10.0, watchOS 3.0, *)
extension BNNSImageStackDescriptor {
  @available(OSX 10.12, iOS 10.0, tvOS 10.0, watchOS 3.0, *)
  public init(width: Swift.Int, height: Swift.Int, channels: Swift.Int, row_stride: Swift.Int, image_stride: Swift.Int, data_type: Accelerate.BNNSDataType)
}
@available(OSX 10.12, iOS 10.0, tvOS 10.0, watchOS 3.0, *)
extension BNNSVectorDescriptor {
  @available(OSX 10.12, iOS 10.0, tvOS 10.0, watchOS 3.0, *)
  public init(size: Swift.Int, data_type: Accelerate.BNNSDataType)
}
@available(OSX 10.12, iOS 10.0, tvOS 10.0, watchOS 3.0, *)
extension BNNSLayerData {
  @available(OSX 10.12, iOS 10.0, tvOS 10.0, watchOS 3.0, *)
  public init(data: Swift.UnsafeRawPointer?, data_type: Accelerate.BNNSDataType, data_scale: Swift.Float = 1, data_bias: Swift.Float = 0)
  @available(OSX 10.12, iOS 10.0, tvOS 10.0, watchOS 3.0, *)
  public static var zero: Accelerate.BNNSLayerData {
    get
  }
  @available(OSX 10.12, iOS 10.0, tvOS 10.0, watchOS 3.0, *)
  public static func indexed8(data: Swift.UnsafePointer<Swift.Int8>?, data_table: Swift.UnsafePointer<Swift.Float>) -> Accelerate.BNNSLayerData
}
@available(OSX 10.12, iOS 10.0, tvOS 10.0, watchOS 3.0, *)
extension BNNSActivation {
  @available(OSX 10.12, iOS 10.0, tvOS 10.0, watchOS 3.0, *)
  public init(function: Accelerate.BNNSActivationFunction, alpha: Swift.Float = .nan, beta: Swift.Float = .nan)
  @available(OSX 10.12, iOS 10.0, tvOS 10.0, watchOS 3.0, *)
  public static var identity: Accelerate.BNNSActivation {
    get
  }
  @available(OSX 10.13, iOS 11.0, tvOS 11.0, watchOS 4.0, *)
  public static func integerLinearSaturate(scale: Swift.Int32 = 1, offset: Swift.Int32 = 0, shift: Swift.Int32 = 0) -> Accelerate.BNNSActivation
  @available(OSX 10.13, iOS 11.0, tvOS 11.0, watchOS 4.0, *)
  public static func integerLinearSaturatePerChannel(scale: Swift.UnsafePointer<Swift.Int32>, offset: Swift.UnsafePointer<Swift.Int32>, shift: Swift.UnsafePointer<Swift.Int32>) -> Accelerate.BNNSActivation
}
@available(OSX 10.12, iOS 10.0, tvOS 10.0, watchOS 3.0, *)
extension BNNSConvolutionLayerParameters {
  @available(OSX 10.12, iOS 10.0, tvOS 10.0, watchOS 3.0, *)
  public init(x_stride: Swift.Int, y_stride: Swift.Int, x_padding: Swift.Int, y_padding: Swift.Int, k_width: Swift.Int, k_height: Swift.Int, in_channels: Swift.Int, out_channels: Swift.Int, weights: Accelerate.BNNSLayerData)
}
@available(OSX 10.12, iOS 10.0, tvOS 10.0, watchOS 3.0, *)
extension BNNSPoolingLayerParameters {
  @available(OSX 10.12, iOS 10.0, tvOS 10.0, watchOS 3.0, *)
  public init(x_stride: Swift.Int, y_stride: Swift.Int, x_padding: Swift.Int, y_padding: Swift.Int, k_width: Swift.Int, k_height: Swift.Int, in_channels: Swift.Int, out_channels: Swift.Int, pooling_function: Accelerate.BNNSPoolingFunction)
}
@available(OSX 10.12, iOS 10.0, tvOS 10.0, watchOS 3.0, *)
extension BNNSFullyConnectedLayerParameters {
  @available(OSX 10.12, iOS 10.0, tvOS 10.0, watchOS 3.0, *)
  public init(in_size: Swift.Int, out_size: Swift.Int, weights: Accelerate.BNNSLayerData)
}
@available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension vImage {
  public enum Error : Swift.Int, Swift.Error {
    case noError
    case roiLargerThanInputBuffer
    case invalidKernelSize
    case invalidEdgeStyle
    case invalidOffset_X
    case invalidOffset_Y
    case memoryAllocationError
    case nullPointerArgument
    case invalidParameter
    case bufferSizeMismatch
    case unknownFlagsBit
    case internalError
    case invalidRowBytes
    case invalidImageFormat
    case colorSyncIsAbsent
    case outOfPlaceOperationRequired
    case invalidImageObject
    case invalidCVImageFormat
    case unsupportedConversion
    case coreVideoIsAbsent
    public init(vImageError: Accelerate.vImage_Error)
    public typealias RawValue = Swift.Int
    public init?(rawValue: Swift.Int)
    public var rawValue: Swift.Int {
      get
    }
  }
}
@available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension vImage {
  public struct Options : Swift.OptionSet {
    public init(rawValue: Accelerate.vImage_Flags)
    public let rawValue: Accelerate.vImage_Flags
    public static let noFlags: Accelerate.vImage.Options
    public static let leaveAlphaUnchanged: Accelerate.vImage.Options
    public static let copyInPlace: Accelerate.vImage.Options
    public static let backgroundColorFill: Accelerate.vImage.Options
    public static let imageExtend: Accelerate.vImage.Options
    public static let doNotTile: Accelerate.vImage.Options
    public static let highQualityResampling: Accelerate.vImage.Options
    public static let truncateKernel: Accelerate.vImage.Options
    public static let getTempBufferSize: Accelerate.vImage.Options
    public static let printDiagnosticsToConsole: Accelerate.vImage.Options
    public static let noAllocate: Accelerate.vImage.Options
    public static let hdrContent: Accelerate.vImage.Options
    public static let doNotClamp: Accelerate.vImage.Options
    public var flags: Accelerate.vImage_Flags {
      get
    }
    public typealias Element = Accelerate.vImage.Options
    public typealias ArrayLiteralElement = Accelerate.vImage.Options
    public typealias RawValue = Accelerate.vImage_Flags
  }
}
@available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension vImage_Buffer {
  public var size: CoreGraphics.CGSize {
    get
  }
  public static func preferredAlignmentAndRowBytes(width: Swift.Int, height: Swift.Int, bitsPerPixel: Swift.UInt32) throws -> (alignment: Swift.Int, rowBytes: Swift.Int)
  public init(width: Swift.Int, height: Swift.Int, bitsPerPixel: Swift.UInt32) throws
  public func free()
}
@available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension vImage_Buffer {
  public init(cgImage: CoreGraphics.CGImage, flags options: Accelerate.vImage.Options = .noFlags) throws
  public init(cgImage: CoreGraphics.CGImage, format: Accelerate.vImage_CGImageFormat, flags options: Accelerate.vImage.Options = .noFlags) throws
  public func createCGImage(format: Accelerate.vImage_CGImageFormat, flags options: Accelerate.vImage.Options = .noFlags) throws -> CoreGraphics.CGImage
  public func copy(destinationBuffer: inout Accelerate.vImage_Buffer, flags options: Accelerate.vImage.Options = .noFlags) throws
}
@available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension vImageCVImageFormat {
  public static func make(format: Accelerate.vImageCVImageFormat.Format, matrix: Accelerate.vImage_ARGBToYpCbCrMatrix, chromaSiting: Accelerate.vImageCVImageFormat.ChromaSiting, colorSpace: CoreGraphics.CGColorSpace, alphaIsOpaqueHint: Swift.Bool) -> Accelerate.vImageCVImageFormat?
  public static func make(buffer: CoreVideo.CVPixelBuffer) -> Accelerate.vImageCVImageFormat?
  public var alphaIsOpaqueHint: Swift.Bool {
    get
    set
  }
  public var channelCount: Swift.UInt32 {
    get
  }
  public var channels: [Accelerate.vImage.BufferType] {
    get
  }
  public func channelDescription(bufferType: Accelerate.vImage.BufferType) -> Accelerate.vImageChannelDescription?
  public var chromaSiting: Accelerate.vImageCVImageFormat.ChromaSiting? {
    get
    set
  }
  public var colorSpace: CoreGraphics.CGColorSpace? {
    get
    set
  }
  public var formatCode: Swift.UInt32 {
    get
  }
}
@available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension vImage {
  public enum BufferType : Swift.Int {
    case alpha
    case coreGraphics
    case cmykBlack
    case cmykCyan
    case cmykMagenta
    case cmykYellow
    case YCbCr
    case Cb
    case Cr
    case chroma
    case chunky
    case indexed
    case labA
    case labB
    case labL
    case luminance
    case monochrome
    case rgbRed
    case rgbGreen
    case rgbBlue
    case xyzX
    case xyzY
    case xyzZ
    public init?(rawValue: Swift.Int)
    public init?(bufferTypeCode: Swift.Int, model: CoreGraphics.CGColorSpaceModel?)
    public var bufferTypeCode: Accelerate.vImageBufferTypeCode {
      get
    }
    public typealias RawValue = Swift.Int
    public var rawValue: Swift.Int {
      get
    }
  }
}
@available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension vImageCVImageFormat {
  public enum Format {
    case format1Monochrome
    case format2Indexed
    case format4Indexed
    case format8Indexed
    case format1IndexedGray_WhiteIsZero
    case format2IndexedGray_WhiteIsZero
    case format4IndexedGray_WhiteIsZero
    case format8IndexedGray_WhiteIsZero
    case format16BE555
    case format16LE555
    case format16LE5551
    case format16BE565
    case format16LE565
    case format24RGB
    case format24BGR
    case format32ARGB
    case format32BGRA
    case format32ABGR
    case format32RGBA
    case format64ARGB
    case format48RGB
    case format32AlphaGray
    case format16Gray
    case format30RGB
    case format422YpCbCr8
    case format4444YpCbCrA8
    case format4444YpCbCrA8R
    case format4444AYpCbCr8
    case format4444AYpCbCr16
    case format444YpCbCr8
    case format422YpCbCr16
    case format422YpCbCr10
    case format444YpCbCr10
    case format420YpCbCr8Planar
    case format420YpCbCr8PlanarFullRange
    case format422YpCbCr_4A_8BiPlanar
    case format420YpCbCr8BiPlanarVideoRange
    case format420YpCbCr8BiPlanarFullRange
    case format422YpCbCr8_yuvs
    case format422YpCbCr8FullRange
    case formatOneComponent8
    case formatTwoComponent8
    case format30RGBLEPackedWideGamut
    case formatARGB2101010LEPacked
    case formatOneComponent16Half
    case formatOneComponent32Float
    case formatTwoComponent16Half
    case formatTwoComponent32Float
    case format64RGBAHalf
    case format128RGBAFloat
    case format14Bayer_GRBG
    case format14Bayer_RGGB
    case format14Bayer_BGGR
    case format14Bayer_GBRG
    case formatDisparityFloat16
    case formatDisparityFloat32
    case formatDepthFloat16
    case formatDepthFloat32
    case format420YpCbCr10BiPlanarVideoRange
    case format422YpCbCr10BiPlanarVideoRange
    case format444YpCbCr10BiPlanarVideoRange
    case format420YpCbCr10BiPlanarFullRange
    case format422YpCbCr10BiPlanarFullRange
    case format444YpCbCr10BiPlanarFullRange
    public static func == (a: Accelerate.vImageCVImageFormat.Format, b: Accelerate.vImageCVImageFormat.Format) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
  }
  public enum ChromaSiting {
    case left
    case center
    case topLeft
    case top
    case bottomLeft
    case bottom
    case dv420
    public static func == (a: Accelerate.vImageCVImageFormat.ChromaSiting, b: Accelerate.vImageCVImageFormat.ChromaSiting) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
  }
}
@available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension vImage_CGImageFormat {
  public init?(cgImage: CoreGraphics.CGImage)
  public init?(bitsPerComponent: Swift.Int, bitsPerPixel: Swift.Int, colorSpace: CoreGraphics.CGColorSpace, bitmapInfo: CoreGraphics.CGBitmapInfo, renderingIntent: CoreGraphics.CGColorRenderingIntent = .defaultIntent)
  public var componentCount: Swift.Int {
    get
  }
}
@available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension vImageConverter {
  public func sourceBuffers(colorSpace: CoreGraphics.CGColorSpace) -> [Accelerate.vImage.BufferType?]
  public func destinationBuffers(colorSpace: CoreGraphics.CGColorSpace) -> [Accelerate.vImage.BufferType?]
  public var sourceBufferCount: Swift.Int {
    get
  }
  public var destinationBufferCount: Swift.Int {
    get
  }
  public func mustOperateOutOfPlace(source: Accelerate.vImage_Buffer, destination: Accelerate.vImage_Buffer, flags options: Accelerate.vImage.Options = .noFlags) throws -> Swift.Bool
  public static func make(sourceFormat: Accelerate.vImage_CGImageFormat, destinationFormat: Accelerate.vImage_CGImageFormat, flags options: Accelerate.vImage.Options = .noFlags) throws -> Accelerate.vImageConverter
  public static func make(sourceFormat: Accelerate.vImage_CGImageFormat, destinationFormat: Accelerate.vImageCVImageFormat, flags options: Accelerate.vImage.Options = .noFlags) throws -> Accelerate.vImageConverter
  public static func make(sourceFormat: Accelerate.vImageCVImageFormat, destinationFormat: Accelerate.vImage_CGImageFormat, flags options: Accelerate.vImage.Options = .noFlags) throws -> Accelerate.vImageConverter
  public func convert(source: Accelerate.vImage_Buffer, destination: inout Accelerate.vImage_Buffer, flags options: Accelerate.vImage.Options = .noFlags) throws
}
@available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
public protocol AccelerateBuffer {
  associatedtype Element
  var count: Swift.Int { get }
  func withUnsafeBufferPointer<R>(_ body: (Swift.UnsafeBufferPointer<Self.Element>) throws -> R) rethrows -> R
}
@available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
public protocol AccelerateMutableBuffer : Accelerate.AccelerateBuffer {
  mutating func withUnsafeMutableBufferPointer<R>(_ body: (inout Swift.UnsafeMutableBufferPointer<Self.Element>) throws -> R) rethrows -> R
}
@available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension AccelerateBuffer where Self : Swift.Collection {
  @inlinable public func withUnsafeBufferPointer<R>(_ body: (Swift.UnsafeBufferPointer<Self.Element>) throws -> R) rethrows -> R {
        return try withContiguousStorageIfAvailable(body)!
    }
}
@available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension AccelerateMutableBuffer where Self : Swift.MutableCollection {
  @inlinable mutating public func withUnsafeMutableBufferPointer<R>(_ body: (inout Swift.UnsafeMutableBufferPointer<Self.Element>) throws -> R) rethrows -> R {
        return try withContiguousMutableStorageIfAvailable(body)!
    }
}
@available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Array : Accelerate.AccelerateMutableBuffer {
}
@available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension ContiguousArray : Accelerate.AccelerateMutableBuffer {
}
@available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension ArraySlice : Accelerate.AccelerateMutableBuffer {
}
@available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension UnsafeBufferPointer : Accelerate.AccelerateBuffer {
}
@available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension UnsafeMutableBufferPointer : Accelerate.AccelerateMutableBuffer {
}
@available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Slice : Accelerate.AccelerateBuffer where Base : Accelerate.AccelerateBuffer {
}
@available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Slice : Accelerate.AccelerateMutableBuffer where Base : Accelerate.AccelerateMutableBuffer, Base : Swift.MutableCollection {
}
@available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
public struct Quadrature {
  public init(integrator: Accelerate.Quadrature.Integrator, absoluteTolerance: Swift.Double = 1.0e-8, relativeTolerance: Swift.Double = 1.0e-2)
  public var absoluteTolerance: Swift.Double {
    get
    set
  }
  public var relativeTolerance: Swift.Double {
    get
    set
  }
  public func integrate(over interval: Swift.ClosedRange<Swift.Double>, integrand: (Swift.UnsafeBufferPointer<Swift.Double>, Swift.UnsafeMutableBufferPointer<Swift.Double>) -> ()) -> Swift.Result<(integralResult: Swift.Double, estimatedAbsoluteError: Swift.Double), Accelerate.Quadrature.Error>
  public func integrate(over interval: Swift.ClosedRange<Swift.Double>, integrand: (Swift.Double) -> Swift.Double) -> Swift.Result<(integralResult: Swift.Double, estimatedAbsoluteError: Swift.Double), Accelerate.Quadrature.Error>
  public enum Integrator {
    case qng
    public static let nonAdaptive: Accelerate.Quadrature.Integrator
    case qag(pointsPerInterval: Accelerate.Quadrature.QAGPointsPerInterval, maxIntervals: Swift.Int)
    public static func adaptive(pointsPerInterval: Accelerate.Quadrature.QAGPointsPerInterval, maxIntervals: Swift.Int) -> Accelerate.Quadrature.Integrator
    case qags(maxIntervals: Swift.Int)
    public static func adaptiveWithSingularities(maxIntervals: Swift.Int) -> Accelerate.Quadrature.Integrator
  }
  public struct QAGPointsPerInterval {
    public let points: Swift.Int
    public static let fifteen: Accelerate.Quadrature.QAGPointsPerInterval
    public static let twentyOne: Accelerate.Quadrature.QAGPointsPerInterval
    public static let thirtyOne: Accelerate.Quadrature.QAGPointsPerInterval
    public static let fortyOne: Accelerate.Quadrature.QAGPointsPerInterval
    public static let fiftyOne: Accelerate.Quadrature.QAGPointsPerInterval
    public static let sixtyOne: Accelerate.Quadrature.QAGPointsPerInterval
  }
  public enum Error : Swift.Error {
    case generic
    case invalidArgument
    case `internal`
    case integrateMaxEval
    case badIntegrandBehaviour
    public init(quadratureStatus: Accelerate.quadrature_status)
    public var errorDescription: Swift.String {
      get
    }
    public static func == (a: Accelerate.Quadrature.Error, b: Accelerate.Quadrature.Error) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
  }
}
@available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension vDSP {
  @inlinable public static func add<U>(_ scalar: Swift.Float, _ vector: U) -> [Swift.Float] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Float {
            
            let result = Array<Float>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                add(scalar,
                    vector,
                    result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func add<U, V>(_ scalar: Swift.Float, _ vector: U, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Float, V.Element == Swift.Float {
            
            let n = result.count
            precondition(vector.count == n)
            result.withUnsafeMutableBufferPointer { r in
                vector.withUnsafeBufferPointer { v in
                    withUnsafePointer(to: scalar) { s in
                        vDSP_vsadd(v.baseAddress!, 1,
                                   s,
                                   r.baseAddress!, 1,
                                   vDSP_Length(n))
                    }
                }
            }
    }
  @inlinable public static func add<U>(_ scalar: Swift.Double, _ vector: U) -> [Swift.Double] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Double {
            
            let result = Array<Double>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                add(scalar,
                    vector,
                    result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func add<U, V>(_ scalar: Swift.Double, _ vector: U, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Double, V.Element == Swift.Double {
            
            let n = result.count
            precondition(vector.count == n)
            result.withUnsafeMutableBufferPointer { r in
                vector.withUnsafeBufferPointer { v in
                    withUnsafePointer(to: scalar) { s in
                        vDSP_vsaddD(v.baseAddress!, 1,
                                    s,
                                    r.baseAddress!, 1,
                                    vDSP_Length(n))
                    }
                }
            }
    }
  @inlinable public static func add<T, U>(_ vectorA: T, _ vectorB: U) -> [Swift.Float] where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, T.Element == Swift.Float, U.Element == Swift.Float {
            
            let result = Array<Float>(unsafeUninitializedCapacity: vectorA.count) {
                buffer, initializedCount in
                
                add(vectorA,
                    vectorB,
                    result: &buffer)
                
                initializedCount = vectorA.count
            }
            
            return result
    }
  @inlinable public static func add<T, U, V>(_ vectorA: T, _ vectorB: U, result: inout V) where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, T.Element == Swift.Float, U.Element == Swift.Float, V.Element == Swift.Float {
            
            let n = result.count
            precondition(vectorA.count == n && vectorB.count == n)
            
            result.withUnsafeMutableBufferPointer { r in
                vectorA.withUnsafeBufferPointer { a in
                    vectorB.withUnsafeBufferPointer { b in
                        vDSP_vadd(a.baseAddress!, 1,
                                  b.baseAddress!, 1,
                                  r.baseAddress!, 1,
                                  vDSP_Length(n))
                    }
                }
            }
    }
  @inlinable public static func add<T, U>(_ vectorA: T, _ vectorB: U) -> [Swift.Double] where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, T.Element == Swift.Double, U.Element == Swift.Double {
            
            let result = Array<Double>(unsafeUninitializedCapacity: vectorA.count) {
                buffer, initializedCount in
                
                add(vectorA,
                    vectorB,
                    result: &buffer)
                
                initializedCount = vectorA.count
            }
            
            return result
    }
  @inlinable public static func add<T, U, V>(_ vectorA: T, _ vectorB: U, result: inout V) where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, T.Element == Swift.Double, U.Element == Swift.Double, V.Element == Swift.Double {
            
            let n = result.count
            precondition(vectorA.count == n && vectorB.count == n)
            
            result.withUnsafeMutableBufferPointer { r in
                vectorA.withUnsafeBufferPointer { a in
                    vectorB.withUnsafeBufferPointer { b in
                        vDSP_vaddD(a.baseAddress!, 1,
                                   b.baseAddress!, 1,
                                   r.baseAddress!, 1,
                                   vDSP_Length(n))
                    }
                }
            }
    }
  @inlinable public static func subtract<T, U>(_ vectorA: U, _ vectorB: T) -> [Swift.Float] where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, T.Element == Swift.Float, U.Element == Swift.Float {
            
            let result = Array<Float>(unsafeUninitializedCapacity: vectorA.count) {
                buffer, initializedCount in
                
                subtract(vectorA,
                         vectorB,
                         result: &buffer)
                
                initializedCount = vectorA.count
            }
            
            return result
    }
  @inlinable public static func subtract<T, U, V>(_ vectorA: U, _ vectorB: T, result: inout V) where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, T.Element == Swift.Float, U.Element == Swift.Float, V.Element == Swift.Float {
            
            let n = result.count
            precondition(vectorA.count == n && vectorB.count == n)
            
            result.withUnsafeMutableBufferPointer { r in
                vectorB.withUnsafeBufferPointer { b in
                    vectorA.withUnsafeBufferPointer { a in
                        vDSP_vsub(b.baseAddress!, 1,
                                  a.baseAddress!, 1,
                                  r.baseAddress!, 1,
                                  vDSP_Length(n))
                    }
                }
            }
    }
  @inlinable public static func subtract<T, U>(_ vectorA: U, _ vectorB: T) -> [Swift.Double] where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, T.Element == Swift.Double, U.Element == Swift.Double {
            
            let result = Array<Double>(unsafeUninitializedCapacity: vectorA.count) {
                buffer, initializedCount in
                
                subtract(vectorA,
                         vectorB,
                         result: &buffer)
                
                initializedCount = vectorA.count
            }
            
            return result
    }
  @inlinable public static func subtract<T, U, V>(_ vectorA: U, _ vectorB: T, result: inout V) where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, T.Element == Swift.Double, U.Element == Swift.Double, V.Element == Swift.Double {
            
            let n = result.count
            precondition(vectorA.count == n && vectorB.count == n)
            
            result.withUnsafeMutableBufferPointer { r in
                vectorB.withUnsafeBufferPointer { b in
                    vectorA.withUnsafeBufferPointer { a in
                        vDSP_vsubD(b.baseAddress!, 1,
                                   a.baseAddress!, 1,
                                   r.baseAddress!, 1,
                                   vDSP_Length(n))
                    }
                }
            }
    }
  @inlinable public static func multiply<U>(_ scalar: Swift.Float, _ vector: U) -> [Swift.Float] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Float {
            
            let result = Array<Float>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                multiply(scalar,
                         vector,
                         result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func multiply<U, V>(_ scalar: Swift.Float, _ vector: U, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Float, V.Element == Swift.Float {
            
            let n = result.count
            precondition(vector.count == n)
            result.withUnsafeMutableBufferPointer { r in
                vector.withUnsafeBufferPointer { v in
                    withUnsafePointer(to: scalar) { s in
                        vDSP_vsmul(v.baseAddress!, 1,
                                   s,
                                   r.baseAddress!, 1,
                                   vDSP_Length(n))
                    }
                }
            }
    }
  @inlinable public static func multiply<U>(_ scalar: Swift.Double, _ vector: U) -> [Swift.Double] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Double {
            
            let result = Array<Double>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                multiply(scalar,
                         vector,
                         result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func multiply<U, V>(_ scalar: Swift.Double, _ vector: U, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Double, V.Element == Swift.Double {
            
            let n = result.count
            precondition(vector.count == n)
            result.withUnsafeMutableBufferPointer { r in
                vector.withUnsafeBufferPointer { v in
                    withUnsafePointer(to: scalar) { s in
                        vDSP_vsmulD(v.baseAddress!, 1,
                                    s,
                                    r.baseAddress!, 1,
                                    vDSP_Length(n))
                    }
                }
            }
    }
  @inlinable public static func multiply<T, U>(_ vectorA: T, _ vectorB: U) -> [Swift.Float] where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, T.Element == Swift.Float, U.Element == Swift.Float {
            
            let result = Array<Float>(unsafeUninitializedCapacity: vectorA.count) {
                buffer, initializedCount in
                
                multiply(vectorA,
                         vectorB,
                         result: &buffer)
                
                initializedCount = vectorA.count
            }
            
            return result
    }
  @inlinable public static func multiply<T, U, V>(_ vectorA: T, _ vectorB: U, result: inout V) where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, T.Element == Swift.Float, U.Element == Swift.Float, V.Element == Swift.Float {
            
            let n = result.count
            precondition(vectorA.count == n && vectorB.count == n)
            result.withUnsafeMutableBufferPointer { r in
                vectorA.withUnsafeBufferPointer { a in
                    vectorB.withUnsafeBufferPointer { b in
                        vDSP_vmul(a.baseAddress!, 1,
                                  b.baseAddress!, 1,
                                  r.baseAddress!, 1,
                                  vDSP_Length(n))
                    }
                }
            }
    }
  @inlinable public static func multiply<T, U>(_ vectorA: T, _ vectorB: U) -> [Swift.Double] where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, T.Element == Swift.Double, U.Element == Swift.Double {
            
            let result = Array<Double>(unsafeUninitializedCapacity: vectorA.count) {
                buffer, initializedCount in
                
                multiply(vectorA,
                         vectorB,
                         result: &buffer)
                
                initializedCount = vectorA.count
            }
            
            return result
    }
  @inlinable public static func multiply<T, U, V>(_ vectorA: T, _ vectorB: U, result: inout V) where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, T.Element == Swift.Double, U.Element == Swift.Double, V.Element == Swift.Double {
            
            let n = result.count
            precondition(vectorA.count == n && vectorB.count == n)
            result.withUnsafeMutableBufferPointer { r in
                vectorA.withUnsafeBufferPointer { a in
                    vectorB.withUnsafeBufferPointer { b in
                        vDSP_vmulD(a.baseAddress!, 1,
                                   b.baseAddress!, 1,
                                   r.baseAddress!, 1,
                                   vDSP_Length(n))
                    }
                }
            }
    }
  @inlinable public static func divide<U>(_ vector: U, _ scalar: Swift.Float) -> [Swift.Float] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Float {
            
            let result = Array<Float>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                divide(vector,
                       scalar,
                       result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func divide<U, V>(_ vector: U, _ scalar: Swift.Float, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Float, V.Element == Swift.Float {
            
            let n = result.count
            precondition(vector.count == n)
            result.withUnsafeMutableBufferPointer { r in
                vector.withUnsafeBufferPointer { v in
                    withUnsafePointer(to: scalar) { s in
                        vDSP_vsdiv(v.baseAddress!, 1,
                                   [scalar],
                                   r.baseAddress!, 1,
                                   vDSP_Length(n))
                    }
                }
            }
    }
  @inlinable public static func divide<U>(_ vector: U, _ scalar: Swift.Double) -> [Swift.Double] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Double {
            
            let result = Array<Double>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                divide(vector,
                       scalar,
                       result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func divide<U, V>(_ vector: U, _ scalar: Swift.Double, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Double, V.Element == Swift.Double {
            
            let n = result.count
            precondition(vector.count == n)
            result.withUnsafeMutableBufferPointer { r in
                vector.withUnsafeBufferPointer { v in
                    withUnsafePointer(to: scalar) { s in
                        vDSP_vsdivD(v.baseAddress!, 1,
                                    s,
                                    r.baseAddress!, 1,
                                    vDSP_Length(n))
                    }
                }
            }
    }
  @inlinable public static func divide<U>(_ scalar: Swift.Float, _ vector: U) -> [Swift.Float] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Float {
            
            let result = Array<Float>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                divide(scalar,
                       vector,
                       result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func divide<U, V>(_ scalar: Swift.Float, _ vector: U, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Float, V.Element == Swift.Float {
            
            let n = result.count
            precondition(vector.count == n)
            result.withUnsafeMutableBufferPointer { r in
                vector.withUnsafeBufferPointer { v in
                    withUnsafePointer(to: scalar) { s in
                        vDSP_svdiv(s,
                                   v.baseAddress!, 1,
                                   r.baseAddress!, 1,
                                   vDSP_Length(n))
                    }
                }
            }
    }
  @inlinable public static func divide<U>(_ scalar: Swift.Double, _ vector: U) -> [Swift.Double] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Double {
            
            let result = Array<Double>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                divide(scalar,
                       vector,
                       result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func divide<U, V>(_ scalar: Swift.Double, _ vector: U, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Double, V.Element == Swift.Double {
            
            let n = result.count
            precondition(vector.count == n)
            result.withUnsafeMutableBufferPointer { r in
                vector.withUnsafeBufferPointer { v in
                    withUnsafePointer(to: scalar) { s in
                        vDSP_svdivD(s,
                                    v.baseAddress!, 1,
                                    r.baseAddress!, 1,
                                    vDSP_Length(n))
                    }
                }
            }
    }
  @inlinable public static func divide<T, U>(_ vectorA: T, _ vectorB: U) -> [Swift.Float] where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, T.Element == Swift.Float, U.Element == Swift.Float {
            
            let result = Array<Float>(unsafeUninitializedCapacity: vectorA.count) {
                buffer, initializedCount in
                
                divide(vectorA,
                       vectorB,
                       result: &buffer)
                
                initializedCount = vectorA.count
            }
            
            return result
    }
  @inlinable public static func divide<T, U, V>(_ vectorA: T, _ vectorB: U, result: inout V) where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, T.Element == Swift.Float, U.Element == Swift.Float, V.Element == Swift.Float {
            
            let n = result.count
            precondition(vectorA.count == n && vectorB.count == n)
            result.withUnsafeMutableBufferPointer { r in
                vectorA.withUnsafeBufferPointer { a in
                    vectorB.withUnsafeBufferPointer { b in
                        vDSP_vdiv(b.baseAddress!, 1,
                                  a.baseAddress!, 1,
                                  r.baseAddress!, 1,
                                  vDSP_Length(n))
                    }
                }
            }
    }
  @inlinable public static func divide<T, U>(_ vectorA: T, _ vectorB: U) -> [Swift.Double] where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, T.Element == Swift.Double, U.Element == Swift.Double {
            
            let result = Array<Double>(unsafeUninitializedCapacity: vectorA.count) {
                buffer, initializedCount in
                
                divide(vectorA,
                       vectorB,
                       result: &buffer)
                
                initializedCount = vectorA.count
            }
            
            return result
    }
  @inlinable public static func divide<T, U, V>(_ vectorA: T, _ vectorB: U, result: inout V) where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, T.Element == Swift.Double, U.Element == Swift.Double, V.Element == Swift.Double {
            
            let n = result.count
            precondition(vectorA.count == n && vectorB.count == n)
            result.withUnsafeMutableBufferPointer { r in
                vectorA.withUnsafeBufferPointer { a in
                    vectorB.withUnsafeBufferPointer { b in
                        vDSP_vdivD(b.baseAddress!, 1,
                                   a.baseAddress!, 1,
                                   r.baseAddress!, 1,
                                   vDSP_Length(n))
                    }
                }
            }
    }
  @inlinable public static func addSubtract<S, T, U, V>(_ vectorA: S, _ vectorB: T, addResult: inout U, subtractResult: inout V) where S : Accelerate.AccelerateBuffer, T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateMutableBuffer, V : Accelerate.AccelerateMutableBuffer, S.Element == Swift.Float, T.Element == Swift.Float, U.Element == Swift.Float, V.Element == Swift.Float {
            
            let n = addResult.count
            precondition(vectorA.count == n &&
                vectorB.count == n &&
                subtractResult.count == n)
            
            addResult.withUnsafeMutableBufferPointer { o0 in
                subtractResult.withUnsafeMutableBufferPointer { o1 in
                    vectorA.withUnsafeBufferPointer { i1 in
                        vectorB.withUnsafeBufferPointer { i0 in
                            vDSP_vaddsub(i0.baseAddress!, 1,
                                         i1.baseAddress!, 1,
                                         o0.baseAddress!, 1,
                                         o1.baseAddress!, 1,
                                         vDSP_Length(n))
                        }
                    }
                }
            }
    }
  @inlinable public static func addSubtract<S, T, U, V>(_ vectorA: S, _ vectorB: T, addResult: inout U, subtractResult: inout V) where S : Accelerate.AccelerateBuffer, T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateMutableBuffer, V : Accelerate.AccelerateMutableBuffer, S.Element == Swift.Double, T.Element == Swift.Double, U.Element == Swift.Double, V.Element == Swift.Double {
            
            let n = addResult.count
            precondition(vectorA.count == n &&
                vectorB.count == n &&
                subtractResult.count == n)
            
            addResult.withUnsafeMutableBufferPointer { o0 in
                subtractResult.withUnsafeMutableBufferPointer { o1 in
                    vectorA.withUnsafeBufferPointer { i1 in
                        vectorB.withUnsafeBufferPointer { i0 in
                            vDSP_vaddsubD(i0.baseAddress!, 1,
                                          i1.baseAddress!, 1,
                                          o0.baseAddress!, 1,
                                          o1.baseAddress!, 1,
                                          vDSP_Length(n))
                        }
                    }
                }
            }
    }
  @inlinable public static func multiply<T, U>(addition: (a: T, b: U), _ scalar: Swift.Float) -> [Swift.Float] where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, T.Element == Swift.Float, U.Element == Swift.Float {
            
            let result = Array<Float>(unsafeUninitializedCapacity: addition.a.count) {
                buffer, initializedCount in
                
                multiply(addition: addition,
                         scalar,
                         result: &buffer)
                
                initializedCount = addition.a.count
            }
            
            return result
    }
  @inlinable public static func multiply<T, U, V>(addition: (a: T, b: U), _ scalar: Swift.Float, result: inout V) where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, T.Element == Swift.Float, U.Element == Swift.Float, V.Element == Swift.Float {
            
            let n = result.count
            precondition(addition.a.count == n &&
                addition.b.count == n)
            
            result.withUnsafeMutableBufferPointer { r in
                addition.a.withUnsafeBufferPointer { a in
                    addition.b.withUnsafeBufferPointer { b in
                        withUnsafePointer(to: scalar) { s in
                            vDSP_vasm(a.baseAddress!, 1,
                                      b.baseAddress!, 1,
                                      s,
                                      r.baseAddress!, 1,
                                      vDSP_Length(n))
                        }
                    }
                }
            }
    }
  @inlinable public static func multiply<T, U>(addition: (a: T, b: U), _ scalar: Swift.Double) -> [Swift.Double] where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, T.Element == Swift.Double, U.Element == Swift.Double {
            
            let result = Array<Double>(unsafeUninitializedCapacity: addition.a.count) {
                buffer, initializedCount in
                
                multiply(addition: addition,
                         scalar,
                         result: &buffer)
                
                initializedCount = addition.a.count
            }
            
            return result
    }
  @inlinable public static func multiply<T, U, V>(addition: (a: T, b: U), _ scalar: Swift.Double, result: inout V) where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, T.Element == Swift.Double, U.Element == Swift.Double, V.Element == Swift.Double {
            
            let n = result.count
            precondition(addition.a.count == n &&
                addition.b.count == n)
            
            result.withUnsafeMutableBufferPointer { r in
                addition.a.withUnsafeBufferPointer { a in
                    addition.b.withUnsafeBufferPointer { b in
                        withUnsafePointer(to: scalar) { s in
                            vDSP_vasmD(a.baseAddress!, 1,
                                       b.baseAddress!, 1,
                                       s,
                                       r.baseAddress!, 1,
                                       vDSP_Length(n))
                        }
                    }
                }
            }
    }
  @inlinable public static func multiply<S, T, U>(addition: (a: S, b: T), _ vector: U) -> [Swift.Float] where S : Accelerate.AccelerateBuffer, T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, S.Element == Swift.Float, T.Element == Swift.Float, U.Element == Swift.Float {
            
            let result = Array<Float>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                multiply(addition: addition,
                         vector,
                         result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func multiply<S, T, U, V>(addition: (a: S, b: T), _ vector: U, result: inout V) where S : Accelerate.AccelerateBuffer, T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, S.Element == Swift.Float, T.Element == Swift.Float, U.Element == Swift.Float, V.Element == Swift.Float {
            
            let n = result.count
            precondition(addition.a.count == n &&
                addition.b.count == n)
            
            result.withUnsafeMutableBufferPointer { r in
                addition.a.withUnsafeBufferPointer { a in
                    addition.b.withUnsafeBufferPointer { b in
                        vector.withUnsafeBufferPointer { c in
                            vDSP_vam(a.baseAddress!, 1,
                                     b.baseAddress!, 1,
                                     c.baseAddress!, 1,
                                     r.baseAddress!, 1,
                                     vDSP_Length(n))
                        }
                    }
                }
            }
    }
  @inlinable public static func multiply<S, T, U>(addition: (a: S, b: T), _ vector: U) -> [Swift.Double] where S : Accelerate.AccelerateBuffer, T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, S.Element == Swift.Double, T.Element == Swift.Double, U.Element == Swift.Double {
            
            let result = Array<Double>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                multiply(addition: addition,
                         vector,
                         result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func multiply<S, T, U, V>(addition: (a: S, b: T), _ vector: U, result: inout V) where S : Accelerate.AccelerateBuffer, T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, S.Element == Swift.Double, T.Element == Swift.Double, U.Element == Swift.Double, V.Element == Swift.Double {
            
            let n = result.count
            precondition(addition.a.count == n &&
                addition.b.count == n)
            
            result.withUnsafeMutableBufferPointer { r in
                addition.a.withUnsafeBufferPointer { a in
                    addition.b.withUnsafeBufferPointer { b in
                        vector.withUnsafeBufferPointer { c in
                            vDSP_vamD(a.baseAddress!, 1,
                                      b.baseAddress!, 1,
                                      c.baseAddress!, 1,
                                      r.baseAddress!, 1,
                                      vDSP_Length(n))
                        }
                    }
                }
            }
    }
  @inlinable public static func multiply<T, U>(subtraction: (a: T, b: U), _ scalar: Swift.Float) -> [Swift.Float] where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, T.Element == Swift.Float, U.Element == Swift.Float {
            
            let result = Array<Float>(unsafeUninitializedCapacity: subtraction.a.count) {
                buffer, initializedCount in
                
                multiply(subtraction: subtraction,
                         scalar,
                         result: &buffer)
                
                initializedCount = subtraction.a.count
            }
            
            return result
    }
  @inlinable public static func multiply<T, U, V>(subtraction: (a: T, b: U), _ scalar: Swift.Float, result: inout V) where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, T.Element == Swift.Float, U.Element == Swift.Float, V.Element == Swift.Float {
            
            let n = result.count
            precondition(subtraction.a.count == n &&
                subtraction.b.count == n)
            
            result.withUnsafeMutableBufferPointer { r in
                subtraction.a.withUnsafeBufferPointer { a in
                    subtraction.b.withUnsafeBufferPointer { b in
                        withUnsafePointer(to: scalar) { s in
                            vDSP_vsbsm(a.baseAddress!, 1,
                                       b.baseAddress!, 1,
                                       s,
                                       r.baseAddress!, 1,
                                       vDSP_Length(n))
                        }
                    }
                }
            }
    }
  @inlinable public static func multiply<T, U>(subtraction: (a: T, b: U), _ scalar: Swift.Double) -> [Swift.Double] where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, T.Element == Swift.Double, U.Element == Swift.Double {
            
            let result = Array<Double>(unsafeUninitializedCapacity: subtraction.a.count) {
                buffer, initializedCount in
                
                multiply(subtraction: subtraction,
                         scalar,
                         result: &buffer)
                
                initializedCount = subtraction.a.count
            }
            
            return result
    }
  @inlinable public static func multiply<T, U, V>(subtraction: (a: T, b: U), _ scalar: Swift.Double, result: inout V) where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, T.Element == Swift.Double, U.Element == Swift.Double, V.Element == Swift.Double {
            
            let n = result.count
            precondition(subtraction.a.count == n &&
                subtraction.b.count == n)
            
            result.withUnsafeMutableBufferPointer { r in
                subtraction.a.withUnsafeBufferPointer { a in
                    subtraction.b.withUnsafeBufferPointer { b in
                        withUnsafePointer(to: scalar) { s in
                            vDSP_vsbsmD(a.baseAddress!, 1,
                                        b.baseAddress!, 1,
                                        s,
                                        r.baseAddress!, 1,
                                        vDSP_Length(n))
                        }
                    }
                }
            }
    }
  @inlinable public static func multiply<S, T, U>(subtraction: (a: S, b: T), _ vector: U) -> [Swift.Float] where S : Accelerate.AccelerateBuffer, T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, S.Element == Swift.Float, T.Element == Swift.Float, U.Element == Swift.Float {
            
            let result = Array<Float>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                multiply(subtraction: subtraction,
                         vector,
                         result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func multiply<S, T, U, V>(subtraction: (a: S, b: T), _ vector: U, result: inout V) where S : Accelerate.AccelerateBuffer, T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, S.Element == Swift.Float, T.Element == Swift.Float, U.Element == Swift.Float, V.Element == Swift.Float {
            
            let n = result.count
            precondition(subtraction.a.count == n &&
                subtraction.b.count == n)
            
            result.withUnsafeMutableBufferPointer { r in
                subtraction.a.withUnsafeBufferPointer { a in
                    subtraction.b.withUnsafeBufferPointer { b in
                        vector.withUnsafeBufferPointer { c in
                            vDSP_vsbm(a.baseAddress!, 1,
                                      b.baseAddress!, 1,
                                      c.baseAddress!, 1,
                                      r.baseAddress!, 1,
                                      vDSP_Length(n))
                        }
                    }
                }
            }
    }
  @inlinable public static func multiply<S, T, U>(subtraction: (a: S, b: T), _ vector: U) -> [Swift.Double] where S : Accelerate.AccelerateBuffer, T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, S.Element == Swift.Double, T.Element == Swift.Double, U.Element == Swift.Double {
            
            let result = Array<Double>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                multiply(subtraction: subtraction,
                         vector,
                         result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func multiply<S, T, U, V>(subtraction: (a: S, b: T), _ vector: U, result: inout V) where S : Accelerate.AccelerateBuffer, T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, S.Element == Swift.Double, T.Element == Swift.Double, U.Element == Swift.Double, V.Element == Swift.Double {
            
            let n = result.count
            precondition(subtraction.a.count == n &&
                subtraction.b.count == n)
            
            result.withUnsafeMutableBufferPointer { r in
                subtraction.a.withUnsafeBufferPointer { a in
                    subtraction.b.withUnsafeBufferPointer { b in
                        vector.withUnsafeBufferPointer { c in
                            vDSP_vsbmD(a.baseAddress!, 1,
                                       b.baseAddress!, 1,
                                       c.baseAddress!, 1,
                                       r.baseAddress!, 1,
                                       vDSP_Length(n))
                        }
                    }
                }
            }
    }
  @inlinable public static func add<T, U>(multiplication: (a: T, b: U), _ scalar: Swift.Float) -> [Swift.Float] where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, T.Element == Swift.Float, U.Element == Swift.Float {
            
            let result = Array<Float>(unsafeUninitializedCapacity: multiplication.a.count) {
                buffer, initializedCount in
                
                add(multiplication: multiplication,
                    scalar,
                    result: &buffer)
                
                initializedCount = multiplication.a.count
            }
            
            return result
    }
  @inlinable public static func add<T, U, V>(multiplication: (a: T, b: U), _ scalar: Swift.Float, result: inout V) where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, T.Element == Swift.Float, U.Element == Swift.Float, V.Element == Swift.Float {
            
            let n = result.count
            precondition(multiplication.a.count == n &&
                multiplication.b.count == n)
            
            result.withUnsafeMutableBufferPointer { r in
                multiplication.a.withUnsafeBufferPointer { a in
                    multiplication.b.withUnsafeBufferPointer { b in
                        withUnsafePointer(to: scalar) { s in
                            vDSP_vmsa(a.baseAddress!, 1,
                                      b.baseAddress!, 1,
                                      s,
                                      r.baseAddress!, 1,
                                      vDSP_Length(n))
                        }
                    }
                }
            }
    }
  @inlinable public static func add<T, U>(multiplication: (a: T, b: U), _ scalar: Swift.Double) -> [Swift.Double] where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, T.Element == Swift.Double, U.Element == Swift.Double {
            
            let result = Array<Double>(unsafeUninitializedCapacity: multiplication.a.count) {
                buffer, initializedCount in
                
                add(multiplication: multiplication,
                    scalar,
                    result: &buffer)
                
                initializedCount = multiplication.a.count
            }
            
            return result
    }
  @inlinable public static func add<T, U, V>(multiplication: (a: T, b: U), _ scalar: Swift.Double, result: inout V) where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, T.Element == Swift.Double, U.Element == Swift.Double, V.Element == Swift.Double {
            
            let n = result.count
            precondition(multiplication.a.count == n &&
                multiplication.b.count == n)
            
            result.withUnsafeMutableBufferPointer { r in
                multiplication.a.withUnsafeBufferPointer { a in
                    multiplication.b.withUnsafeBufferPointer { b in
                        withUnsafePointer(to: scalar) { s in
                            vDSP_vmsaD(a.baseAddress!, 1,
                                       b.baseAddress!, 1,
                                       s,
                                       r.baseAddress!, 1,
                                       vDSP_Length(n))
                        }
                    }
                }
            }
    }
  @inlinable public static func add<T, U>(multiplication: (a: T, b: Swift.Float), _ vector: U) -> [Swift.Float] where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, T.Element == Swift.Float, U.Element == Swift.Float {
            
            let result = Array<Float>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                add(multiplication: multiplication,
                    vector,
                    result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func add<T, U, V>(multiplication: (a: T, b: Swift.Float), _ vector: U, result: inout V) where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, T.Element == Swift.Float, U.Element == Swift.Float, V.Element == Swift.Float {
            
            let n = result.count
            precondition(multiplication.a.count == n)
            
            result.withUnsafeMutableBufferPointer { r in
                multiplication.a.withUnsafeBufferPointer { a in
                    vector.withUnsafeBufferPointer { c in
                        withUnsafePointer(to: multiplication.b) { b in
                            vDSP_vsma(a.baseAddress!, 1,
                                      b,
                                      c.baseAddress!, 1,
                                      r.baseAddress!, 1,
                                      vDSP_Length(n))
                        }
                    }
                }
            }
    }
  @inlinable public static func add<T, U>(multiplication: (a: T, b: Swift.Double), _ vector: U) -> [Swift.Double] where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, T.Element == Swift.Double, U.Element == Swift.Double {
            
            let result = Array<Double>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                add(multiplication: multiplication,
                    vector,
                    result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func add<T, U, V>(multiplication: (a: T, b: Swift.Double), _ vector: U, result: inout V) where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, T.Element == Swift.Double, U.Element == Swift.Double, V.Element == Swift.Double {
            
            let n = result.count
            precondition(multiplication.a.count == n)
            
            result.withUnsafeMutableBufferPointer { r in
                multiplication.a.withUnsafeBufferPointer { a in
                    vector.withUnsafeBufferPointer { c in
                        withUnsafePointer(to: multiplication.b) { b in
                            vDSP_vsmaD(a.baseAddress!, 1,
                                       b,
                                       c.baseAddress!, 1,
                                       r.baseAddress!, 1,
                                       vDSP_Length(n))
                        }
                    }
                }
            }
    }
  @inlinable public static func add<S, T, U>(multiplication: (a: S, b: T), _ vector: U) -> [Swift.Float] where S : Accelerate.AccelerateBuffer, T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, S.Element == Swift.Float, T.Element == Swift.Float, U.Element == Swift.Float {
            
            let result = Array<Float>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                add(multiplication: multiplication,
                    vector,
                    result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func add<S, T, U, V>(multiplication: (a: S, b: T), _ vector: U, result: inout V) where S : Accelerate.AccelerateBuffer, T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, S.Element == Swift.Float, T.Element == Swift.Float, U.Element == Swift.Float, V.Element == Swift.Float {
            
            let n = result.count
            precondition(multiplication.a.count == n &&
                multiplication.b.count == n)
            
            result.withUnsafeMutableBufferPointer { r in
                multiplication.a.withUnsafeBufferPointer { a in
                    multiplication.b.withUnsafeBufferPointer { b in
                        vector.withUnsafeBufferPointer { c in
                            vDSP_vma(a.baseAddress!, 1,
                                     b.baseAddress!, 1,
                                     c.baseAddress!, 1,
                                     r.baseAddress!, 1,
                                     vDSP_Length(n))
                        }
                    }
                }
            }
    }
  @inlinable public static func add<S, T, U>(multiplication: (a: S, b: T), _ vector: U) -> [Swift.Double] where S : Accelerate.AccelerateBuffer, T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, S.Element == Swift.Double, T.Element == Swift.Double, U.Element == Swift.Double {
            
            let result = Array<Double>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                add(multiplication: multiplication,
                    vector,
                    result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func add<S, T, U, V>(multiplication: (a: S, b: T), _ vector: U, result: inout V) where S : Accelerate.AccelerateBuffer, T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, S.Element == Swift.Double, T.Element == Swift.Double, U.Element == Swift.Double, V.Element == Swift.Double {
            
            let n = result.count
            precondition(multiplication.a.count == n &&
                multiplication.b.count == n)
            
            result.withUnsafeMutableBufferPointer { r in
                multiplication.a.withUnsafeBufferPointer { a in
                    multiplication.b.withUnsafeBufferPointer { b in
                        vector.withUnsafeBufferPointer { c in
                            vDSP_vmaD(a.baseAddress!, 1,
                                      b.baseAddress!, 1,
                                      c.baseAddress!, 1,
                                      r.baseAddress!, 1,
                                      vDSP_Length(n))
                        }
                    }
                }
            }
    }
  @inlinable public static func subtract<S, T, U>(multiplication: (a: T, b: U), _ vector: S) -> [Swift.Float] where S : Accelerate.AccelerateBuffer, T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, S.Element == Swift.Float, T.Element == Swift.Float, U.Element == Swift.Float {
            
            let result = Array<Float>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                subtract(multiplication: multiplication,
                         vector,
                         result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func subtract<S, T, U, V>(multiplication: (a: T, b: U), _ vector: S, result: inout V) where S : Accelerate.AccelerateBuffer, T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, S.Element == Swift.Float, T.Element == Swift.Float, U.Element == Swift.Float, V.Element == Swift.Float {
            
            let n = result.count
            precondition(multiplication.a.count == n &&
                multiplication.b.count == n)
            
            result.withUnsafeMutableBufferPointer { r in
                multiplication.a.withUnsafeBufferPointer { a in
                    multiplication.b.withUnsafeBufferPointer { b in
                        vector.withUnsafeBufferPointer { c in
                            vDSP_vmsb(a.baseAddress!, 1,
                                      b.baseAddress!, 1,
                                      c.baseAddress!, 1,
                                      r.baseAddress!, 1,
                                      vDSP_Length(n))
                        }
                    }
                }
            }
    }
  @inlinable public static func subtract<S, T, U>(multiplication: (a: T, b: U), _ vector: S) -> [Swift.Double] where S : Accelerate.AccelerateBuffer, T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, S.Element == Swift.Double, T.Element == Swift.Double, U.Element == Swift.Double {
            
            let result = Array<Double>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                subtract(multiplication: multiplication,
                         vector,
                         result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func subtract<S, T, U, V>(multiplication: (a: T, b: U), _ vector: S, result: inout V) where S : Accelerate.AccelerateBuffer, T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, S.Element == Swift.Double, T.Element == Swift.Double, U.Element == Swift.Double, V.Element == Swift.Double {
            
            let n = result.count
            precondition(multiplication.a.count == n &&
                multiplication.b.count == n)
            
            result.withUnsafeMutableBufferPointer { r in
                multiplication.a.withUnsafeBufferPointer { a in
                    multiplication.b.withUnsafeBufferPointer { b in
                        vector.withUnsafeBufferPointer { c in
                            vDSP_vmsbD(a.baseAddress!, 1,
                                       b.baseAddress!, 1,
                                       c.baseAddress!, 1,
                                       r.baseAddress!, 1,
                                       vDSP_Length(n))
                        }
                    }
                }
            }
    }
  @inlinable public static func add<T, U>(multiplication multiplicationAB: (a: T, b: Swift.Float), multiplication multiplicationCD: (c: U, d: Swift.Float)) -> [Swift.Float] where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, T.Element == Swift.Float, U.Element == Swift.Float {
            
            let result = Array<Float>(unsafeUninitializedCapacity: multiplicationAB.a.count) {
                buffer, initializedCount in
                
                add(multiplication: multiplicationAB,
                    multiplication: multiplicationCD,
                    result: &buffer)
                
                initializedCount = multiplicationAB.a.count
            }
            
            return result
    }
  @inlinable public static func add<T, U, V>(multiplication multiplicationAB: (a: T, b: Swift.Float), multiplication multiplicationCD: (c: U, d: Swift.Float), result: inout V) where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, T.Element == Swift.Float, U.Element == Swift.Float, V.Element == Swift.Float {
            
            let n = result.count
            precondition(multiplicationAB.a.count == n &&
                multiplicationCD.c.count == n)
            
            result.withUnsafeMutableBufferPointer { r in
                multiplicationAB.a.withUnsafeBufferPointer { a in
                    multiplicationCD.c.withUnsafeBufferPointer { c in
                        withUnsafePointer(to: multiplicationAB.b) { b in
                            withUnsafePointer(to: multiplicationCD.d) { d in
                                vDSP_vsmsma(a.baseAddress!, 1,
                                            b,
                                            c.baseAddress!, 1,
                                            d,
                                            r.baseAddress!, 1,
                                            vDSP_Length(n))
                            }
                        }
                    }
                }
            }
    }
  @inlinable public static func add<T, U>(multiplication multiplicationAB: (a: T, b: Swift.Double), multiplication multiplicationCD: (c: U, d: Swift.Double)) -> [Swift.Double] where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, T.Element == Swift.Double, U.Element == Swift.Double {
            
            let result = Array<Double>(unsafeUninitializedCapacity: multiplicationAB.a.count) {
                buffer, initializedCount in
                
                add(multiplication: multiplicationAB,
                    multiplication: multiplicationCD,
                    result: &buffer)
                
                initializedCount = multiplicationAB.a.count
            }
            
            return result
    }
  @inlinable public static func add<T, U, V>(multiplication multiplicationAB: (a: T, b: Swift.Double), multiplication multiplicationCD: (c: U, d: Swift.Double), result: inout V) where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, T.Element == Swift.Double, U.Element == Swift.Double, V.Element == Swift.Double {
            
            let n = result.count
            precondition(multiplicationAB.a.count == n &&
                multiplicationCD.c.count == n)
            
            result.withUnsafeMutableBufferPointer { r in
                multiplicationAB.a.withUnsafeBufferPointer { a in
                    multiplicationCD.c.withUnsafeBufferPointer { c in
                        withUnsafePointer(to: multiplicationAB.b) { b in
                            withUnsafePointer(to: multiplicationCD.d) { d in
                                vDSP_vsmsmaD(a.baseAddress!, 1,
                                             b,
                                             c.baseAddress!, 1,
                                             d,
                                             r.baseAddress!, 1,
                                             vDSP_Length(n))
                            }
                        }
                    }
                }
            }
    }
  @inlinable public static func add<R, S, T, U>(multiplication multiplicationAB: (a: R, b: S), multiplication multiplicationCD: (c: T, d: U)) -> [Swift.Float] where R : Accelerate.AccelerateBuffer, S : Accelerate.AccelerateBuffer, T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, R.Element == Swift.Float, S.Element == Swift.Float, T.Element == Swift.Float, U.Element == Swift.Float {
            
            let result = Array<Float>(unsafeUninitializedCapacity: multiplicationAB.a.count) {
                buffer, initializedCount in
                
                add(multiplication: multiplicationAB,
                    multiplication: multiplicationCD,
                    result: &buffer)
                
                initializedCount = multiplicationAB.a.count
            }
            
            return result
    }
  @inlinable public static func add<R, S, T, U, V>(multiplication multiplicationAB: (a: R, b: S), multiplication multiplicationCD: (c: T, d: U), result: inout V) where R : Accelerate.AccelerateBuffer, S : Accelerate.AccelerateBuffer, T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, R.Element == Swift.Float, S.Element == Swift.Float, T.Element == Swift.Float, U.Element == Swift.Float, V.Element == Swift.Float {
            
            let n = result.count
            precondition(multiplicationAB.a.count == n &&
                multiplicationAB.b.count == n &&
                multiplicationCD.c.count == n &&
                multiplicationCD.d.count == n)
            
            result.withUnsafeMutableBufferPointer { r in
                multiplicationAB.a.withUnsafeBufferPointer { a in
                    multiplicationAB.b.withUnsafeBufferPointer { b in
                        multiplicationCD.c.withUnsafeBufferPointer { c in
                            multiplicationCD.d.withUnsafeBufferPointer { d in
                                vDSP_vmma(a.baseAddress!, 1,
                                          b.baseAddress!, 1,
                                          c.baseAddress!, 1,
                                          d.baseAddress!, 1,
                                          r.baseAddress!, 1,
                                          vDSP_Length(n))
                            }
                        }
                    }
                }
            }
    }
  @inlinable public static func add<R, S, T, U>(multiplication multiplicationAB: (a: R, b: S), multiplication multiplicationCD: (c: T, d: U)) -> [Swift.Double] where R : Accelerate.AccelerateBuffer, S : Accelerate.AccelerateBuffer, T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, R.Element == Swift.Double, S.Element == Swift.Double, T.Element == Swift.Double, U.Element == Swift.Double {
            
            let result = Array<Double>(unsafeUninitializedCapacity: multiplicationAB.a.count) {
                buffer, initializedCount in
                
                add(multiplication: multiplicationAB,
                    multiplication: multiplicationCD,
                    result: &buffer)
                
                initializedCount = multiplicationAB.a.count
            }
            
            return result
    }
  @inlinable public static func add<R, S, T, U, V>(multiplication multiplicationAB: (a: R, b: S), multiplication multiplicationCD: (c: T, d: U), result: inout V) where R : Accelerate.AccelerateBuffer, S : Accelerate.AccelerateBuffer, T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, R.Element == Swift.Double, S.Element == Swift.Double, T.Element == Swift.Double, U.Element == Swift.Double, V.Element == Swift.Double {
            
            let n = result.count
            precondition(multiplicationAB.a.count == n &&
                multiplicationAB.b.count == n &&
                multiplicationCD.c.count == n &&
                multiplicationCD.d.count == n)
            
            result.withUnsafeMutableBufferPointer { r in
                multiplicationAB.a.withUnsafeBufferPointer { a in
                    multiplicationAB.b.withUnsafeBufferPointer { b in
                        multiplicationCD.c.withUnsafeBufferPointer { c in
                            multiplicationCD.d.withUnsafeBufferPointer { d in
                                vDSP_vmmaD(a.baseAddress!, 1,
                                           b.baseAddress!, 1,
                                           c.baseAddress!, 1,
                                           d.baseAddress!, 1,
                                           r.baseAddress!, 1,
                                           vDSP_Length(n))
                            }
                        }
                    }
                }
            }
    }
  @inlinable public static func multiply<S, T, U>(addition additionAB: (a: S, b: T), addition additionCD: (c: U, d: U)) -> [Swift.Float] where S : Accelerate.AccelerateBuffer, T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, S.Element == Swift.Float, T.Element == Swift.Float, U.Element == Swift.Float {
            
            let result = Array<Float>(unsafeUninitializedCapacity: additionAB.a.count) {
                buffer, initializedCount in
                
                multiply(addition: additionAB,
                         addition: additionCD,
                         result: &buffer)
                
                initializedCount = additionAB.a.count
            }
            
            return result
    }
  @inlinable public static func multiply<S, T, U, V>(addition additionAB: (a: S, b: T), addition additionCD: (c: U, d: U), result: inout V) where S : Accelerate.AccelerateBuffer, T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, S.Element == Swift.Float, T.Element == Swift.Float, U.Element == Swift.Float, V.Element == Swift.Float {
            
            let n = result.count
            precondition(additionAB.a.count == n &&
                additionAB.b.count == n &&
                additionCD.c.count == n &&
                additionCD.d.count == n)
            
            result.withUnsafeMutableBufferPointer { r in
                additionAB.a.withUnsafeBufferPointer { a in
                    additionAB.b.withUnsafeBufferPointer { b in
                        additionCD.c.withUnsafeBufferPointer { c in
                            additionCD.d.withUnsafeBufferPointer { d in
                                vDSP_vaam(a.baseAddress!, 1,
                                          b.baseAddress!, 1,
                                          c.baseAddress!, 1,
                                          d.baseAddress!, 1,
                                          r.baseAddress!, 1,
                                          vDSP_Length(n))
                            }
                        }
                    }
                }
            }
    }
  @inlinable public static func multiply<S, T, U>(addition additionAB: (a: S, b: T), addition additionCD: (c: U, d: U)) -> [Swift.Double] where S : Accelerate.AccelerateBuffer, T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, S.Element == Swift.Double, T.Element == Swift.Double, U.Element == Swift.Double {
            
            let result = Array<Double>(unsafeUninitializedCapacity: additionAB.a.count) {
                buffer, initializedCount in
                
                multiply(addition: additionAB,
                         addition: additionCD,
                         result: &buffer)
                
                initializedCount = additionAB.a.count
            }
            
            return result
    }
  @inlinable public static func multiply<S, T, U, V>(addition additionAB: (a: S, b: T), addition additionCD: (c: U, d: U), result: inout V) where S : Accelerate.AccelerateBuffer, T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, S.Element == Swift.Double, T.Element == Swift.Double, U.Element == Swift.Double, V.Element == Swift.Double {
            
            let n = result.count
            precondition(additionAB.a.count == n &&
                additionAB.b.count == n &&
                additionCD.c.count == n &&
                additionCD.d.count == n)
            
            result.withUnsafeMutableBufferPointer { r in
                additionAB.a.withUnsafeBufferPointer { a in
                    additionAB.b.withUnsafeBufferPointer { b in
                        additionCD.c.withUnsafeBufferPointer { c in
                            additionCD.d.withUnsafeBufferPointer { d in
                                vDSP_vaamD(a.baseAddress!, 1,
                                           b.baseAddress!, 1,
                                           c.baseAddress!, 1,
                                           d.baseAddress!, 1,
                                           r.baseAddress!, 1,
                                           vDSP_Length(n))
                            }
                        }
                    }
                }
            }
    }
  @inlinable public static func subtract<R, S, T, U>(multiplication multiplicationAB: (a: T, b: U), multiplication multiplicationCD: (c: R, d: S)) -> [Swift.Float] where R : Accelerate.AccelerateBuffer, S : Accelerate.AccelerateBuffer, T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, R.Element == Swift.Float, S.Element == Swift.Float, T.Element == Swift.Float, U.Element == Swift.Float {
            
            let result = Array<Float>(unsafeUninitializedCapacity: multiplicationAB.a.count) {
                buffer, initializedCount in
                
                subtract(multiplication: multiplicationAB,
                         multiplication: multiplicationCD,
                         result: &buffer)
                
                initializedCount = multiplicationAB.a.count
            }
            
            return result
    }
  @inlinable public static func subtract<R, S, T, U, V>(multiplication multiplicationAB: (a: T, b: U), multiplication multiplicationCD: (c: R, d: S), result: inout V) where R : Accelerate.AccelerateBuffer, S : Accelerate.AccelerateBuffer, T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, R.Element == Swift.Float, S.Element == Swift.Float, T.Element == Swift.Float, U.Element == Swift.Float, V.Element == Swift.Float {
            
            let n = result.count
            precondition(multiplicationAB.a.count == n &&
                multiplicationAB.b.count == n &&
                multiplicationCD.c.count == n &&
                multiplicationCD.d.count == n)
            
            result.withUnsafeMutableBufferPointer { r in
                multiplicationAB.a.withUnsafeBufferPointer { a in
                    multiplicationAB.b.withUnsafeBufferPointer { b in
                        multiplicationCD.c.withUnsafeBufferPointer { c in
                            multiplicationCD.d.withUnsafeBufferPointer { d in
                                vDSP_vmmsb(a.baseAddress!, 1,
                                           b.baseAddress!, 1,
                                           c.baseAddress!, 1,
                                           d.baseAddress!, 1,
                                           r.baseAddress!, 1,
                                           vDSP_Length(n))
                            }
                        }
                    }
                }
            }
    }
  @inlinable public static func subtract<R, S, T, U>(multiplication multiplicationAB: (a: T, b: U), multiplication multiplicationCD: (c: R, d: S)) -> [Swift.Double] where R : Accelerate.AccelerateBuffer, S : Accelerate.AccelerateBuffer, T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, R.Element == Swift.Double, S.Element == Swift.Double, T.Element == Swift.Double, U.Element == Swift.Double {
            
            let result = Array<Double>(unsafeUninitializedCapacity: multiplicationAB.a.count) {
                buffer, initializedCount in
                
                subtract(multiplication: multiplicationAB,
                         multiplication: multiplicationCD,
                         result: &buffer)
                
                initializedCount = multiplicationAB.a.count
            }
            
            return result
    }
  @inlinable public static func subtract<R, S, T, U, V>(multiplication multiplicationAB: (a: T, b: U), multiplication multiplicationCD: (c: R, d: S), result: inout V) where R : Accelerate.AccelerateBuffer, S : Accelerate.AccelerateBuffer, T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, R.Element == Swift.Double, S.Element == Swift.Double, T.Element == Swift.Double, U.Element == Swift.Double, V.Element == Swift.Double {
            
            let n = result.count
            precondition(multiplicationAB.a.count == n &&
                multiplicationAB.b.count == n &&
                multiplicationCD.c.count == n &&
                multiplicationCD.d.count == n)
            
            result.withUnsafeMutableBufferPointer { r in
                multiplicationAB.a.withUnsafeBufferPointer { a in
                    multiplicationAB.b.withUnsafeBufferPointer { b in
                        multiplicationCD.c.withUnsafeBufferPointer { c in
                            multiplicationCD.d.withUnsafeBufferPointer { d in
                                vDSP_vmmsbD(a.baseAddress!, 1,
                                            b.baseAddress!, 1,
                                            c.baseAddress!, 1,
                                            d.baseAddress!, 1,
                                            r.baseAddress!, 1,
                                            vDSP_Length(n))
                            }
                        }
                    }
                }
            }
    }
  @inlinable public static func multiply<R, S, T, U>(subtraction subtractionAB: (a: R, b: S), subtraction subtractionCD: (c: T, d: U)) -> [Swift.Float] where R : Accelerate.AccelerateBuffer, S : Accelerate.AccelerateBuffer, T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, R.Element == Swift.Float, S.Element == Swift.Float, T.Element == Swift.Float, U.Element == Swift.Float {
            
            let result = Array<Float>(unsafeUninitializedCapacity: subtractionAB.a.count) {
                buffer, initializedCount in
                
                multiply(subtraction: subtractionAB,
                         subtraction: subtractionCD,
                         result: &buffer)
                
                initializedCount = subtractionAB.a.count
            }
            
            return result
    }
  @inlinable public static func multiply<R, S, T, U, V>(subtraction subtractionAB: (a: R, b: S), subtraction subtractionCD: (c: T, d: U), result: inout V) where R : Accelerate.AccelerateBuffer, S : Accelerate.AccelerateBuffer, T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, R.Element == Swift.Float, S.Element == Swift.Float, T.Element == Swift.Float, U.Element == Swift.Float, V.Element == Swift.Float {
            
            let n = result.count
            precondition(subtractionAB.a.count == n &&
                subtractionAB.b.count == n &&
                subtractionCD.c.count == n &&
                subtractionCD.d.count == n)
            
            result.withUnsafeMutableBufferPointer { r in
                subtractionAB.a.withUnsafeBufferPointer { a in
                    subtractionAB.b.withUnsafeBufferPointer { b in
                        subtractionCD.c.withUnsafeBufferPointer { c in
                            subtractionCD.d.withUnsafeBufferPointer { d in
                                vDSP_vsbsbm(a.baseAddress!, 1,
                                            b.baseAddress!, 1,
                                            c.baseAddress!, 1,
                                            d.baseAddress!, 1,
                                            r.baseAddress!, 1,
                                            vDSP_Length(n))
                            }
                        }
                    }
                }
            }
    }
  @inlinable public static func multiply<R, S, T, U>(subtraction subtractionAB: (a: R, b: S), subtraction subtractionCD: (c: T, d: U)) -> [Swift.Double] where R : Accelerate.AccelerateBuffer, S : Accelerate.AccelerateBuffer, T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, R.Element == Swift.Double, S.Element == Swift.Double, T.Element == Swift.Double, U.Element == Swift.Double {
            
            let result = Array<Double>(unsafeUninitializedCapacity: subtractionAB.a.count) {
                buffer, initializedCount in
                
                multiply(subtraction: subtractionAB,
                         subtraction: subtractionCD,
                         result: &buffer)
                
                initializedCount = subtractionAB.a.count
            }
            
            return result
    }
  @inlinable public static func multiply<R, S, T, U, V>(subtraction subtractionAB: (a: R, b: S), subtraction subtractionCD: (c: T, d: U), result: inout V) where R : Accelerate.AccelerateBuffer, S : Accelerate.AccelerateBuffer, T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, R.Element == Swift.Double, S.Element == Swift.Double, T.Element == Swift.Double, U.Element == Swift.Double, V.Element == Swift.Double {
            
            let n = result.count
            precondition(subtractionAB.a.count == n &&
                subtractionAB.b.count == n &&
                subtractionCD.c.count == n &&
                subtractionCD.d.count == n)
            
            result.withUnsafeMutableBufferPointer { r in
                subtractionAB.a.withUnsafeBufferPointer { a in
                    subtractionAB.b.withUnsafeBufferPointer { b in
                        subtractionCD.c.withUnsafeBufferPointer { c in
                            subtractionCD.d.withUnsafeBufferPointer { d in
                                vDSP_vsbsbmD(a.baseAddress!, 1,
                                             b.baseAddress!, 1,
                                             c.baseAddress!, 1,
                                             d.baseAddress!, 1,
                                             r.baseAddress!, 1,
                                             vDSP_Length(n))
                            }
                        }
                    }
                }
            }
    }
  @inlinable public static func multiply<R, S, T, U>(addition: (a: R, b: S), subtraction: (c: T, d: U)) -> [Swift.Float] where R : Accelerate.AccelerateBuffer, S : Accelerate.AccelerateBuffer, T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, R.Element == Swift.Float, S.Element == Swift.Float, T.Element == Swift.Float, U.Element == Swift.Float {
            
            let result = Array<Float>(unsafeUninitializedCapacity: addition.a.count) {
                buffer, initializedCount in
                
                multiply(addition: addition,
                         subtraction: subtraction,
                         result: &buffer)
                
                initializedCount = addition.a.count
            }
            
            return result
    }
  @inlinable public static func multiply<R, S, T, U, V>(addition: (a: R, b: S), subtraction: (c: T, d: U), result: inout V) where R : Accelerate.AccelerateBuffer, S : Accelerate.AccelerateBuffer, T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, R.Element == Swift.Float, S.Element == Swift.Float, T.Element == Swift.Float, U.Element == Swift.Float, V.Element == Swift.Float {
            
            let n = result.count
            precondition(addition.a.count == n &&
                addition.b.count == n &&
                subtraction.c.count == n &&
                subtraction.d.count == n)
            
            result.withUnsafeMutableBufferPointer { r in
                addition.a.withUnsafeBufferPointer { a in
                    addition.b.withUnsafeBufferPointer { b in
                        subtraction.c.withUnsafeBufferPointer { c in
                            subtraction.d.withUnsafeBufferPointer { d in
                                vDSP_vasbm(a.baseAddress!, 1,
                                           b.baseAddress!, 1,
                                           c.baseAddress!, 1,
                                           d.baseAddress!, 1,
                                           r.baseAddress!, 1,
                                           vDSP_Length(n))
                            }
                        }
                    }
                }
            }
    }
  @inlinable public static func multiply<R, S, T, U>(addition: (a: R, b: S), subtraction: (c: T, d: U)) -> [Swift.Double] where R : Accelerate.AccelerateBuffer, S : Accelerate.AccelerateBuffer, T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, R.Element == Swift.Double, S.Element == Swift.Double, T.Element == Swift.Double, U.Element == Swift.Double {
            
            let result = Array<Double>(unsafeUninitializedCapacity: addition.a.count) {
                buffer, initializedCount in
                
                multiply(addition: addition,
                         subtraction: subtraction,
                         result: &buffer)
                
                initializedCount = addition.a.count
            }
            
            return result
    }
  @inlinable public static func multiply<R, S, T, U, V>(addition: (a: R, b: S), subtraction: (c: T, d: U), result: inout V) where R : Accelerate.AccelerateBuffer, S : Accelerate.AccelerateBuffer, T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, R.Element == Swift.Double, S.Element == Swift.Double, T.Element == Swift.Double, U.Element == Swift.Double, V.Element == Swift.Double {
            
            let n = result.count
            precondition(addition.a.count == n &&
                addition.b.count == n &&
                subtraction.c.count == n &&
                subtraction.d.count == n)
            
            result.withUnsafeMutableBufferPointer { r in
                addition.a.withUnsafeBufferPointer { a in
                    addition.b.withUnsafeBufferPointer { b in
                        subtraction.c.withUnsafeBufferPointer { c in
                            subtraction.d.withUnsafeBufferPointer { d in
                                vDSP_vasbmD(a.baseAddress!, 1,
                                            b.baseAddress!, 1,
                                            c.baseAddress!, 1,
                                            d.baseAddress!, 1,
                                            r.baseAddress!, 1,
                                            vDSP_Length(n))
                            }
                        }
                    }
                }
            }
    }
  @inlinable public static func add<U>(multiplication: (a: U, b: Swift.Float), _ scalar: Swift.Float) -> [Swift.Float] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Float {
            
            let result = Array<Float>(unsafeUninitializedCapacity: multiplication.a.count) {
                buffer, initializedCount in
                
                add(multiplication: multiplication,
                    scalar,
                    result: &buffer)
                
                initializedCount =  multiplication.a.count
            }
            
            return result
    }
  @inlinable public static func add<U, V>(multiplication: (a: U, b: Swift.Float), _ scalar: Swift.Float, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Float, V.Element == Swift.Float {
            let n = result.count
            precondition(multiplication.a.count == n)
            
            result.withUnsafeMutableBufferPointer { r in
                multiplication.a.withUnsafeBufferPointer { a in
                    withUnsafePointer(to: multiplication.b) { b in
                        withUnsafePointer(to: scalar) { c in
                            vDSP_vsmsa(a.baseAddress!, 1,
                                       b,
                                       c,
                                       r.baseAddress!, 1,
                                       vDSP_Length(n))
                        }
                    }
                }
            }
    }
  @inlinable public static func add<U>(multiplication: (a: U, b: Swift.Double), _ scalar: Swift.Double) -> [Swift.Double] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Double {
            
            let result = Array<Double>(unsafeUninitializedCapacity: multiplication.a.count) {
                buffer, initializedCount in
                
                add(multiplication: multiplication,
                    scalar,
                    result: &buffer)
                
                initializedCount =  multiplication.a.count
            }
            
            return result
    }
  @inlinable public static func add<U, V>(multiplication: (a: U, b: Swift.Double), _ scalar: Swift.Double, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Double, V.Element == Swift.Double {
            let n = result.count
            precondition(multiplication.a.count == n)
            
            result.withUnsafeMutableBufferPointer { r in
                multiplication.a.withUnsafeBufferPointer { a in
                    withUnsafePointer(to: multiplication.b) { b in
                        withUnsafePointer(to: scalar) { c in
                            vDSP_vsmsaD(a.baseAddress!, 1,
                                        b,
                                        c,
                                        r.baseAddress!, 1,
                                        vDSP_Length(n))
                        }
                    }
                }
            }
    }
  @inlinable public static func subtract<T, U>(multiplication: (a: U, b: Swift.Float), _ vector: T) -> [Swift.Float] where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, T.Element == Swift.Float, U.Element == Swift.Float {
            
            let result = Array<Float>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                subtract(multiplication: multiplication,
                         vector,
                         result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func subtract<T, U, V>(multiplication: (a: U, b: Swift.Float), _ vector: T, result: inout V) where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, T.Element == Swift.Float, U.Element == Swift.Float, V.Element == Swift.Float {
            
            let n = result.count
            precondition(multiplication.a.count == n)
            precondition(vector.count == n)
            
            result.withUnsafeMutableBufferPointer { r in
                multiplication.a.withUnsafeBufferPointer { a in
                    withUnsafePointer(to: multiplication.b) { b in
                        vector.withUnsafeBufferPointer { c in
                            vDSP_vsmsb(a.baseAddress!, 1,
                                       b,
                                       c.baseAddress!, 1,
                                       r.baseAddress!, 1,
                                       vDSP_Length(n))
                        }
                    }
                }
            }
    }
  @inlinable public static func subtract<T, U>(multiplication: (a: U, b: Swift.Double), _ vector: T) -> [Swift.Double] where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, T.Element == Swift.Double, U.Element == Swift.Double {
            
            let result = Array<Double>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                subtract(multiplication: multiplication,
                         vector,
                         result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func subtract<T, U, V>(multiplication: (a: U, b: Swift.Double), _ vector: T, result: inout V) where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, T.Element == Swift.Double, U.Element == Swift.Double, V.Element == Swift.Double {
            
            let n = result.count
            precondition(multiplication.a.count == n)
            precondition(vector.count == n)
            
            result.withUnsafeMutableBufferPointer { r in
                multiplication.a.withUnsafeBufferPointer { a in
                    withUnsafePointer(to: multiplication.b) { b in
                        vector.withUnsafeBufferPointer { c in
                            vDSP_vsmsbD(a.baseAddress!, 1,
                                        b,
                                        c.baseAddress!, 1,
                                        r.baseAddress!, 1,
                                        vDSP_Length(n))
                        }
                    }
                }
            }
    }
}
@available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension vDSP {
  public struct Biquad<T> where T : Accelerate.vDSP_FloatingPointBiquadFilterable {
    public init?(coefficients: [Swift.Double], channelCount: Accelerate.vDSP_Length, sectionCount: Accelerate.vDSP_Length, ofType: T.Type)
    mutating public func apply<U>(input: U) -> [T] where T == U.Element, U : Accelerate.AccelerateBuffer
    mutating public func apply<U, V>(input: U, output: inout V) where T == U.Element, U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == V.Element
  }
}
@available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
public protocol vDSP_FloatingPointBiquadFilterable : Swift.BinaryFloatingPoint {
  associatedtype BiquadFunctions : Accelerate.vDSP_BiquadFunctions where Self == Self.BiquadFunctions.Scalar
}
@available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Float : Accelerate.vDSP_FloatingPointBiquadFilterable {
  public typealias BiquadFunctions = Accelerate.vDSP.VectorizableFloat
}
@available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Double : Accelerate.vDSP_FloatingPointBiquadFilterable {
  public typealias BiquadFunctions = Accelerate.vDSP.VectorizableDouble
}
@available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
public protocol vDSP_BiquadFunctions {
  associatedtype Scalar
  static func makeBiquadSetup(channelCount: Accelerate.vDSP_Length, coefficients: [Swift.Double], sectionCount: Accelerate.vDSP_Length) -> Swift.OpaquePointer?
  static func applySingle<U, V>(source: U, destination: inout V, delays: Swift.UnsafeMutablePointer<Self.Scalar>, setup: Accelerate.vDSP_biquad_Setup, sectionCount: Accelerate.vDSP_Length, count: Accelerate.vDSP_Length) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, Self.Scalar == U.Element, U.Element == V.Element
  static func applyMulti(setup: Accelerate.vDSP_biquadm_SetupD, pInputs: Swift.UnsafeMutablePointer<Swift.UnsafePointer<Self.Scalar>>, pOutputs: Swift.UnsafeMutablePointer<Swift.UnsafeMutablePointer<Self.Scalar>>, count: Accelerate.vDSP_Length)
  static func destroySetup(channelCount: Swift.UInt, biquadSetup: Swift.OpaquePointer)
}
@available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension vDSP.VectorizableFloat : Accelerate.vDSP_BiquadFunctions {
  @inlinable public static func makeBiquadSetup(channelCount: Swift.UInt, coefficients: [Swift.Double], sectionCount: Swift.UInt) -> Swift.OpaquePointer? {
        if channelCount == 1 {
            return vDSP_biquad_CreateSetup(coefficients,
                                           sectionCount)
        } else {
            return vDSP_biquadm_CreateSetup(coefficients,
                                            sectionCount,
                                            channelCount)
        }
    }
  @inlinable public static func applySingle<U, V>(source: U, destination: inout V, delays: Swift.UnsafeMutablePointer<Accelerate.vDSP.VectorizableFloat.Scalar>, setup: Accelerate.vDSP_biquad_Setup, sectionCount: Accelerate.vDSP_Length, count: Accelerate.vDSP_Length) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Float, V.Element == Swift.Float {
            
            destination.withUnsafeMutableBufferPointer { dest in
                source.withUnsafeBufferPointer { src in
                    vDSP_biquad(setup,
                                delays,
                                src.baseAddress!, 1,
                                dest.baseAddress!, 1,
                                count)
                }
            }
    }
  @inlinable public static func applyMulti(setup: Accelerate.vDSP_biquadm_SetupD, pInputs: Swift.UnsafeMutablePointer<Swift.UnsafePointer<Accelerate.vDSP.VectorizableFloat.Scalar>>, pOutputs: Swift.UnsafeMutablePointer<Swift.UnsafeMutablePointer<Accelerate.vDSP.VectorizableFloat.Scalar>>, count: Accelerate.vDSP_Length) {
        vDSP_biquadm(setup,
                     pInputs, 1,
                     pOutputs, 1,
                     count)
    }
  @inlinable public static func destroySetup(channelCount: Swift.UInt, biquadSetup: Swift.OpaquePointer) {
        if channelCount == 1 {
            vDSP_biquad_DestroySetup(biquadSetup)
        } else {
            vDSP_biquadm_DestroySetup(biquadSetup)
        }
    }
}
@available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension vDSP.VectorizableDouble : Accelerate.vDSP_BiquadFunctions {
  @inlinable public static func makeBiquadSetup(channelCount: Accelerate.vDSP_Length, coefficients: [Swift.Double], sectionCount: Accelerate.vDSP_Length) -> Swift.OpaquePointer? {
        if channelCount == 1 {
            return vDSP_biquad_CreateSetupD(coefficients,
                                            sectionCount)
        } else {
            return vDSP_biquadm_CreateSetupD(coefficients,
                                             sectionCount,
                                             channelCount)
        }
    }
  @inlinable public static func applySingle<U, V>(source: U, destination: inout V, delays: Swift.UnsafeMutablePointer<Accelerate.vDSP.VectorizableDouble.Scalar>, setup: Accelerate.vDSP_biquad_Setup, sectionCount: Accelerate.vDSP_Length, count: Accelerate.vDSP_Length) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Double, V.Element == Swift.Double {
            
            destination.withUnsafeMutableBufferPointer { dest in
                source.withUnsafeBufferPointer { src in
                    vDSP_biquadD(setup,
                                 delays,
                                 src.baseAddress!, 1,
                                 dest.baseAddress!, 1,
                                 count)
                }
            }
    }
  @inlinable public static func applyMulti(setup: Accelerate.vDSP_biquadm_SetupD, pInputs: Swift.UnsafeMutablePointer<Swift.UnsafePointer<Accelerate.vDSP.VectorizableDouble.Scalar>>, pOutputs: Swift.UnsafeMutablePointer<Swift.UnsafeMutablePointer<Accelerate.vDSP.VectorizableDouble.Scalar>>, count: Accelerate.vDSP_Length) {
        vDSP_biquadmD(setup,
                      pInputs, 1,
                      pOutputs, 1,
                      count)
    }
  @inlinable public static func destroySetup(channelCount: Swift.UInt, biquadSetup: Swift.OpaquePointer) {
        if channelCount == 1 {
            vDSP_biquad_DestroySetupD(biquadSetup)
        } else {
            vDSP_biquadm_DestroySetupD(biquadSetup)
        }
    }
}
@available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension vDSP {
  @inlinable public static func clip<U>(_ vector: U, to bounds: Swift.ClosedRange<Swift.Float>) -> [Swift.Float] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Float {
            
            let result = Array<Float>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                clip(vector,
                     to: bounds,
                     result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func clip<U, V>(_ vector: U, to bounds: Swift.ClosedRange<Swift.Float>, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Float, V.Element == Swift.Float {
            
            let n = result.count
            precondition(vector.count == n)
            
            withUnsafePointer(to: bounds.lowerBound) { lowerBound in
                withUnsafePointer(to: bounds.upperBound) { upperBound in
                    result.withUnsafeMutableBufferPointer { r in
                        vector.withUnsafeBufferPointer { v in
                            vDSP_vclip(v.baseAddress!, 1,
                                       lowerBound,
                                       upperBound,
                                       r.baseAddress!, 1,
                                       vDSP_Length(n))
                        }
                    }
                }
            }
    }
  @inlinable public static func clip<U>(_ vector: U, to bounds: Swift.ClosedRange<Swift.Double>) -> [Swift.Double] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Double {
            
            let result = Array<Double>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                clip(vector,
                     to: bounds,
                     result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func clip<U, V>(_ vector: U, to bounds: Swift.ClosedRange<Swift.Double>, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Double, V.Element == Swift.Double {
            
            let n = result.count
            precondition(vector.count == n)
            
            withUnsafePointer(to: bounds.lowerBound) { lowerBound in
                withUnsafePointer(to: bounds.upperBound) { upperBound in
                    result.withUnsafeMutableBufferPointer { r in
                        vector.withUnsafeBufferPointer { v in
                            vDSP_vclipD(v.baseAddress!, 1,
                                        lowerBound,
                                        upperBound,
                                        r.baseAddress!, 1,
                                        vDSP_Length(n))
                        }
                    }
                }
            }
    }
  @inlinable public static func invertedClip<U>(_ vector: U, to bounds: Swift.ClosedRange<Swift.Float>) -> [Swift.Float] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Float {
            
            let result = Array<Float>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                invertedClip(vector,
                             to: bounds,
                             result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func invertedClip<U, V>(_ vector: U, to bounds: Swift.ClosedRange<Swift.Float>, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Float, V.Element == Swift.Float {
            
            let n = result.count
            precondition(vector.count == n)
            
            withUnsafePointer(to: bounds.lowerBound) { lowerBound in
                withUnsafePointer(to: bounds.upperBound) { upperBound in
                    result.withUnsafeMutableBufferPointer { r in
                        vector.withUnsafeBufferPointer { v in
                            vDSP_viclip(v.baseAddress!, 1,
                                        lowerBound,
                                        upperBound,
                                        r.baseAddress!, 1,
                                        vDSP_Length(n))
                        }
                    }
                }
            }
    }
  @inlinable public static func invertedClip<U>(_ vector: U, to bounds: Swift.ClosedRange<Swift.Double>) -> [Swift.Double] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Double {
            
            let result = Array<Double>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                invertedClip(vector,
                             to: bounds,
                             result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func invertedClip<U, V>(_ vector: U, to bounds: Swift.ClosedRange<Swift.Double>, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Double, V.Element == Swift.Double {
            
            let n = result.count
            precondition(vector.count == n)
            
            withUnsafePointer(to: bounds.lowerBound) { lowerBound in
                withUnsafePointer(to: bounds.upperBound) { upperBound in
                    result.withUnsafeMutableBufferPointer { r in
                        vector.withUnsafeBufferPointer { v in
                            vDSP_viclipD(v.baseAddress!, 1,
                                         lowerBound,
                                         upperBound,
                                         r.baseAddress!, 1,
                                         vDSP_Length(n))
                        }
                    }
                }
            }
    }
  public enum ThresholdRule<T> where T : Swift.BinaryFloatingPoint {
    case clampToThreshold
    case zeroFill
    case signedConstant(_: T)
  }
  @inlinable public static func threshold<U>(_ vector: U, to lowerBound: Swift.Float, with rule: Accelerate.vDSP.ThresholdRule<Swift.Float>) -> [Swift.Float] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Float {
            
            let result = Array<Float>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                threshold(vector,
                          to: lowerBound,
                          with: rule,
                          result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  public static func threshold<U, V>(_ vector: U, to lowerBound: Swift.Float, with rule: Accelerate.vDSP.ThresholdRule<Swift.Float>, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Float, V.Element == Swift.Float
  @inlinable public static func threshold<U>(_ vector: U, to lowerBound: Swift.Double, with rule: Accelerate.vDSP.ThresholdRule<Swift.Double>) -> [Swift.Double] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Double {
            
            let result = Array<Double>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                threshold(vector,
                          to: lowerBound,
                          with: rule,
                          result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  public static func threshold<U, V>(_ vector: U, to lowerBound: Swift.Double, with rule: Accelerate.vDSP.ThresholdRule<Swift.Double>, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Double, V.Element == Swift.Double
  @inlinable public static func limit<U>(_ vector: U, limit: Swift.Float, withOutputConstant outputConstant: Swift.Float) -> [Swift.Float] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Float {
            
            let result = Array<Float>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                vDSP.limit(vector,
                           limit: limit,
                           withOutputConstant: outputConstant,
                           result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func limit<U, V>(_ vector: U, limit: Swift.Float, withOutputConstant outputConstant: Swift.Float, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Float, V.Element == Swift.Float {
            
            let n = result.count
            precondition(vector.count == n)
            
            withUnsafePointer(to: limit) { limit in
                withUnsafePointer(to: outputConstant) { x in
                    result.withUnsafeMutableBufferPointer { r in
                        vector.withUnsafeBufferPointer { v in
                            vDSP_vlim(v.baseAddress!, 1,
                                      limit,
                                      x,
                                      r.baseAddress!, 1,
                                      vDSP_Length(n))
                        }
                    }
                }
            }
    }
  @inlinable public static func limit<U>(_ vector: U, limit: Swift.Double, withOutputConstant outputConstant: Swift.Double) -> [Swift.Double] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Double {
            
            let result = Array<Double>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                vDSP.limit(vector,
                           limit: limit,
                           withOutputConstant: outputConstant,
                           result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func limit<U, V>(_ vector: U, limit: Swift.Double, withOutputConstant outputConstant: Swift.Double, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Double, V.Element == Swift.Double {
            
            let n = result.count
            precondition(vector.count == n)
            
            withUnsafePointer(to: limit) { limit in
                withUnsafePointer(to: outputConstant) { x in
                    result.withUnsafeMutableBufferPointer { r in
                        vector.withUnsafeBufferPointer { v in
                            vDSP_vlimD(v.baseAddress!, 1,
                                       limit,
                                       x,
                                       r.baseAddress!, 1,
                                       vDSP_Length(n))
                        }
                    }
                }
            }
    }
}
@available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension vDSP {
  @inlinable public static func convert(splitComplexVector: Accelerate.DSPSplitComplex, toInterleavedComplexVector interleavedComplexVector: inout [Accelerate.DSPComplex]) {
        
        withUnsafePointer(to: splitComplexVector) {
            vDSP_ztoc($0, 1,
                      &interleavedComplexVector, 2,
                      vDSP_Length(interleavedComplexVector.count))
        }
    }
  @inlinable public static func convert(interleavedComplexVector: [Accelerate.DSPComplex], toSplitComplexVector splitComplexVector: inout Accelerate.DSPSplitComplex) {
        
        vDSP_ctoz(interleavedComplexVector, 2,
                  &splitComplexVector, 1,
                  vDSP_Length(interleavedComplexVector.count))
    }
  @inlinable public static func convert(splitComplexVector: Accelerate.DSPDoubleSplitComplex, toInterleavedComplexVector interleavedComplexVector: inout [Accelerate.DSPDoubleComplex]) {
        
        withUnsafePointer(to: splitComplexVector) {
            vDSP_ztocD($0, 1,
                       &interleavedComplexVector, 2,
                       vDSP_Length(interleavedComplexVector.count))
        }
    }
  @inlinable public static func convert(interleavedComplexVector: [Accelerate.DSPDoubleComplex], toSplitComplexVector splitComplexVector: inout Accelerate.DSPDoubleSplitComplex) {
        
        vDSP_ctozD(interleavedComplexVector, 2,
                   &splitComplexVector, 1,
                   vDSP_Length(interleavedComplexVector.count))
    }
}
@available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension vDSP {
  @inlinable public static func phase<V>(_ splitComplex: Accelerate.DSPSplitComplex, result: inout V) where V : Accelerate.AccelerateMutableBuffer, V.Element == Swift.Float {
            
            let n = vDSP_Length(result.count)
            
            result.withUnsafeMutableBufferPointer { dest in
                withUnsafePointer(to: splitComplex) { src in
                    vDSP_zvphas(src, 1,
                                dest.baseAddress!, 1,
                                n)
                }
            }
    }
  @inlinable public static func phase<V>(_ splitComplex: Accelerate.DSPDoubleSplitComplex, result: inout V) where V : Accelerate.AccelerateMutableBuffer, V.Element == Swift.Double {
            
            let n = vDSP_Length(result.count)
            
            result.withUnsafeMutableBufferPointer { dest in
                withUnsafePointer(to: splitComplex) { src in
                    vDSP_zvphasD(src, 1,
                                 dest.baseAddress!, 1,
                                 n)
                }
            }
    }
  @inlinable public static func copy(_ source: Accelerate.DSPSplitComplex, to destination: inout Accelerate.DSPSplitComplex, count: Swift.Int) {
        
        let n = vDSP_Length(count)
        
        withUnsafePointer(to: source) { src in
            vDSP_zvmov(src, 1,
                       &destination, 1,
                       n)
        }
    }
  @inlinable public static func copy(_ source: Accelerate.DSPDoubleSplitComplex, to destination: inout Accelerate.DSPDoubleSplitComplex, count: Swift.Int) {
        
        let n = vDSP_Length(count)
        
        withUnsafePointer(to: source) { src in
            vDSP_zvmovD(src, 1,
                        &destination, 1,
                        n)
        }
    }
  @inlinable public static func conjugate(_ splitComplex: Accelerate.DSPSplitComplex, count: Swift.Int, result: inout Accelerate.DSPSplitComplex) {
        
        withUnsafePointer(to: splitComplex) { a in
            vDSP_zvconj(a, 1,
                        &result, 1,
                        vDSP_Length(count))
        }
    }
  @inlinable public static func conjugate(_ splitComplex: Accelerate.DSPDoubleSplitComplex, count: Swift.Int, result: inout Accelerate.DSPDoubleSplitComplex) {
        
        withUnsafePointer(to: splitComplex) { a in
            vDSP_zvconjD(a, 1,
                         &result, 1,
                         vDSP_Length(count))
        }
    }
  @inlinable public static func divide<U>(_ splitComplex: Accelerate.DSPSplitComplex, by vector: U, result: inout Accelerate.DSPSplitComplex) where U : Accelerate.AccelerateBuffer, U.Element == Swift.Float {
            
            withUnsafePointer(to: splitComplex) { a in
                vector.withUnsafeBufferPointer { b in
                    vDSP_zrvdiv(a, 1,
                                b.baseAddress!, 1,
                                &result, 1,
                                vDSP_Length(vector.count))
                }
            }
    }
  @inlinable public static func divide<U>(_ splitComplex: Accelerate.DSPDoubleSplitComplex, by vector: U, result: inout Accelerate.DSPDoubleSplitComplex) where U : Accelerate.AccelerateBuffer, U.Element == Swift.Double {
            
            withUnsafePointer(to: splitComplex) { a in
                vector.withUnsafeBufferPointer { b in
                    vDSP_zrvdivD(a, 1,
                                 b.baseAddress!, 1,
                                 &result, 1,
                                 vDSP_Length(vector.count))
                }
            }
    }
  @inlinable public static func multiply<U>(_ splitComplex: Accelerate.DSPSplitComplex, by vector: U, result: inout Accelerate.DSPSplitComplex) where U : Accelerate.AccelerateBuffer, U.Element == Swift.Float {
            
            withUnsafePointer(to: splitComplex) { a in
                vector.withUnsafeBufferPointer { b in
                    vDSP_zrvmul(a, 1,
                                b.baseAddress!, 1,
                                &result, 1,
                                vDSP_Length(vector.count))
                }
            }
    }
  @inlinable public static func multiply<U>(_ splitComplex: Accelerate.DSPDoubleSplitComplex, by vector: U, result: inout Accelerate.DSPDoubleSplitComplex) where U : Accelerate.AccelerateBuffer, U.Element == Swift.Double {
            
            withUnsafePointer(to: splitComplex) { a in
                vector.withUnsafeBufferPointer { b in
                    vDSP_zrvmulD(a, 1,
                                 b.baseAddress!, 1,
                                 &result, 1,
                                 vDSP_Length(vector.count))
                }
            }
    }
  @inlinable public static func multiply(_ splitComplexA: Accelerate.DSPSplitComplex, by splitComplexB: Accelerate.DSPSplitComplex, count: Swift.Int, useConjugate: Swift.Bool, result: inout Accelerate.DSPSplitComplex) {
        
        let conjugate: Int32 = useConjugate ? -1 : 1
        
        withUnsafePointer(to: splitComplexA) { a in
            withUnsafePointer(to: splitComplexB) { b in
                vDSP_zvmul(a, 1,
                           b, 1,
                           &result, 1,
                           vDSP_Length(count),
                           conjugate)
            }
        }
    }
  @inlinable public static func multiply(_ splitComplexA: Accelerate.DSPDoubleSplitComplex, by splitComplexB: Accelerate.DSPDoubleSplitComplex, count: Swift.Int, useConjugate: Swift.Bool, result: inout Accelerate.DSPDoubleSplitComplex) {
        
        let conjugate: Int32 = useConjugate ? -1 : 1
        
        withUnsafePointer(to: splitComplexA) { a in
            withUnsafePointer(to: splitComplexB) { b in
                vDSP_zvmulD(a, 1,
                            b, 1,
                            &result, 1,
                            vDSP_Length(count),
                            conjugate)
            }
        }
    }
  @inlinable public static func add(_ splitComplexA: Accelerate.DSPSplitComplex, to splitComplexB: Accelerate.DSPSplitComplex, count: Swift.Int, result: inout Accelerate.DSPSplitComplex) {
        
        withUnsafePointer(to: splitComplexA) { a in
            withUnsafePointer(to: splitComplexB) { b in
                vDSP_zvadd(a, 1,
                           b, 1,
                           &result, 1,
                           vDSP_Length(count))
            }
        }
    }
  @inlinable public static func add(_ splitComplexA: Accelerate.DSPDoubleSplitComplex, to splitComplexB: Accelerate.DSPDoubleSplitComplex, count: Swift.Int, result: inout Accelerate.DSPDoubleSplitComplex) {
        
        withUnsafePointer(to: splitComplexA) { a in
            withUnsafePointer(to: splitComplexB) { b in
                vDSP_zvaddD(a, 1,
                            b, 1,
                            &result, 1,
                            vDSP_Length(count))
            }
        }
    }
  @inlinable public static func divide(_ splitComplexA: Accelerate.DSPSplitComplex, by splitComplexB: Accelerate.DSPSplitComplex, count: Swift.Int, result: inout Accelerate.DSPSplitComplex) {
        
        withUnsafePointer(to: splitComplexA) { a in
            withUnsafePointer(to: splitComplexB) { b in
                vDSP_zvdiv(b, 1,
                           a, 1,
                           &result, 1,
                           vDSP_Length(count))
            }
        }
    }
  @inlinable public static func divide(_ splitComplexA: Accelerate.DSPDoubleSplitComplex, by splitComplexB: Accelerate.DSPDoubleSplitComplex, count: Swift.Int, result: inout Accelerate.DSPDoubleSplitComplex) {
        
        withUnsafePointer(to: splitComplexA) { a in
            withUnsafePointer(to: splitComplexB) { b in
                vDSP_zvdivD(b, 1,
                            a, 1,
                            &result, 1,
                            vDSP_Length(count))
            }
        }
    }
  @inlinable public static func subtract(_ splitComplexB: Accelerate.DSPSplitComplex, from splitComplexA: Accelerate.DSPSplitComplex, count: Swift.Int, result: inout Accelerate.DSPSplitComplex) {
        
        withUnsafePointer(to: splitComplexA) { a in
            withUnsafePointer(to: splitComplexB) { b in
                vDSP_zvsub(b, 1,
                           a, 1,
                           &result, 1,
                           vDSP_Length(count))
            }
        }
    }
  @inlinable public static func subtract(_ splitComplexB: Accelerate.DSPDoubleSplitComplex, from splitComplexA: Accelerate.DSPDoubleSplitComplex, count: Swift.Int, result: inout Accelerate.DSPDoubleSplitComplex) {
        
        withUnsafePointer(to: splitComplexA) { a in
            withUnsafePointer(to: splitComplexB) { b in
                vDSP_zvsubD(b, 1,
                            a, 1,
                            &result, 1,
                            vDSP_Length(count))
            }
        }
    }
  @inlinable public static func absolute<V>(_ vector: Accelerate.DSPSplitComplex, result: inout V) where V : Accelerate.AccelerateMutableBuffer, V.Element == Swift.Float {
            
            let n = result.count
            
            result.withUnsafeMutableBufferPointer { r in
                withUnsafePointer(to: vector) { v in
                    vDSP_zvabs(v, 1,
                               r.baseAddress!, 1,
                               vDSP_Length(n))
                }
            }
    }
  @inlinable public static func absolute<V>(_ vector: Accelerate.DSPDoubleSplitComplex, result: inout V) where V : Accelerate.AccelerateMutableBuffer, V.Element == Swift.Double {
            
            let n = result.count
            
            result.withUnsafeMutableBufferPointer { r in
                withUnsafePointer(to: vector) { v in
                    vDSP_zvabsD(v, 1,
                                r.baseAddress!, 1,
                                vDSP_Length(n))
                }
            }
    }
  @inlinable public static func squareMagnitudes<V>(_ splitComplex: Accelerate.DSPSplitComplex, result: inout V) where V : Accelerate.AccelerateMutableBuffer, V.Element == Swift.Float {
            
            let n = vDSP_Length(result.count)
            
            result.withUnsafeMutableBufferPointer { dest in
                withUnsafePointer(to: splitComplex) { src in
                    vDSP_zvmags(src, 1,
                                dest.baseAddress!, 1,
                                n)
                }
            }
    }
  @inlinable public static func squareMagnitudes<V>(_ splitComplex: Accelerate.DSPDoubleSplitComplex, result: inout V) where V : Accelerate.AccelerateMutableBuffer, V.Element == Swift.Double {
            
            let n = vDSP_Length(result.count)
            
            result.withUnsafeMutableBufferPointer { dest in
                withUnsafePointer(to: splitComplex) { src in
                    vDSP_zvmagsD(src, 1,
                                 dest.baseAddress!, 1,
                                 n)
                }
            }
    }
}
@available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension vDSP {
  @inlinable public static func convertElements<U, V>(of source: U, to destination: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.UInt8, V.Element == Swift.Float {
            
            precondition(source.count == destination.count)
            
            let n = vDSP_Length(source.count)
            
            destination.withUnsafeMutableBufferPointer { dest in
                source.withUnsafeBufferPointer { src in
                    vDSP_vfltu8(src.baseAddress!, 1,
                                dest.baseAddress!, 1,
                                n)
                }
            }
    }
  @inlinable public static func convertElements<U, V>(of source: U, to destination: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.UInt8, V.Element == Swift.Double {
            
            precondition(source.count == destination.count)
            
            let n = vDSP_Length(source.count)
            
            destination.withUnsafeMutableBufferPointer { dest in
                source.withUnsafeBufferPointer { src in
                    vDSP_vfltu8D(src.baseAddress!, 1,
                                 dest.baseAddress!, 1,
                                 n)
                }
            }
    }
  @inlinable public static func convertElements<U, V>(of source: U, to destination: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.UInt16, V.Element == Swift.Float {
            
            precondition(source.count == destination.count)
            
            let n = vDSP_Length(source.count)
            
            destination.withUnsafeMutableBufferPointer { dest in
                source.withUnsafeBufferPointer { src in
                    vDSP_vfltu16(src.baseAddress!, 1,
                                 dest.baseAddress!, 1,
                                 n)
                }
            }
    }
  @inlinable public static func convertElements<U, V>(of source: U, to destination: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.UInt16, V.Element == Swift.Double {
            
            precondition(source.count == destination.count)
            
            let n = vDSP_Length(source.count)
            
            destination.withUnsafeMutableBufferPointer { dest in
                source.withUnsafeBufferPointer { src in
                    vDSP_vfltu16D(src.baseAddress!, 1,
                                  dest.baseAddress!, 1,
                                  n)
                }
            }
    }
  @inlinable public static func convertElements<U, V>(of source: U, to destination: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.UInt32, V.Element == Swift.Float {
            
            precondition(source.count == destination.count)
            
            let n = vDSP_Length(source.count)
            
            destination.withUnsafeMutableBufferPointer { dest in
                source.withUnsafeBufferPointer { src in
                    vDSP_vfltu32(src.baseAddress!, 1,
                                 dest.baseAddress!, 1,
                                 n)
                }
            }
    }
  @inlinable public static func convertElements<U, V>(of source: U, to destination: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.UInt32, V.Element == Swift.Double {
            
            precondition(source.count == destination.count)
            
            let n = vDSP_Length(source.count)
            
            destination.withUnsafeMutableBufferPointer { dest in
                source.withUnsafeBufferPointer { src in
                    vDSP_vfltu32D(src.baseAddress!, 1,
                                  dest.baseAddress!, 1,
                                  n)
                }
            }
    }
  @inlinable public static func convertElements<U, V>(of source: U, to destination: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Int8, V.Element == Swift.Float {
            
            precondition(source.count == destination.count)
            
            let n = vDSP_Length(source.count)
            
            destination.withUnsafeMutableBufferPointer { dest in
                source.withUnsafeBufferPointer { src in
                    vDSP_vflt8(src.baseAddress!, 1,
                               dest.baseAddress!, 1,
                               n)
                }
            }
    }
  @inlinable public static func convertElements<U, V>(of source: U, to destination: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Int8, V.Element == Swift.Double {
            
            precondition(source.count == destination.count)
            
            let n = vDSP_Length(source.count)
            
            destination.withUnsafeMutableBufferPointer { dest in
                source.withUnsafeBufferPointer { src in
                    vDSP_vflt8D(src.baseAddress!, 1,
                                dest.baseAddress!, 1,
                                n)
                }
            }
    }
  @inlinable public static func convertElements<U, V>(of source: U, to destination: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Int16, V.Element == Swift.Float {
            
            precondition(source.count == destination.count)
            
            let n = vDSP_Length(source.count)
            
            destination.withUnsafeMutableBufferPointer { dest in
                source.withUnsafeBufferPointer { src in
                    vDSP_vflt16(src.baseAddress!, 1,
                                dest.baseAddress!, 1,
                                n)
                }
            }
    }
  @inlinable public static func convertElements<U, V>(of source: U, to destination: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Int16, V.Element == Swift.Double {
            
            precondition(source.count == destination.count)
            
            let n = vDSP_Length(source.count)
            
            destination.withUnsafeMutableBufferPointer { dest in
                source.withUnsafeBufferPointer { src in
                    vDSP_vflt16D(src.baseAddress!, 1,
                                 dest.baseAddress!, 1,
                                 n)
                }
            }
    }
  @inlinable public static func convertElements<U, V>(of source: U, to destination: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Int32, V.Element == Swift.Float {
            
            precondition(source.count == destination.count)
            
            let n = vDSP_Length(source.count)
            
            destination.withUnsafeMutableBufferPointer { dest in
                source.withUnsafeBufferPointer { src in
                    vDSP_vflt32(src.baseAddress!, 1,
                                dest.baseAddress!, 1,
                                n)
                }
            }
    }
  @inlinable public static func convertElements<U, V>(of source: U, to destination: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Int32, V.Element == Swift.Double {
            
            precondition(source.count == destination.count)
            
            let n = vDSP_Length(source.count)
            
            destination.withUnsafeMutableBufferPointer { dest in
                source.withUnsafeBufferPointer { src in
                    vDSP_vflt32D(src.baseAddress!, 1,
                                 dest.baseAddress!, 1,
                                 n)
                }
            }
    }
  public enum RoundingMode {
    case towardZero
    case towardNearestInteger
    public static func == (a: Accelerate.vDSP.RoundingMode, b: Accelerate.vDSP.RoundingMode) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
  }
  public static func convertElements<U, V>(of source: U, to destination: inout V, rounding: Accelerate.vDSP.RoundingMode) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Float, V.Element == Swift.Int32
  public static func convertElements<U, V>(of source: U, to destination: inout V, rounding: Accelerate.vDSP.RoundingMode) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Double, V.Element == Swift.Int32
  public static func convertElements<U, V>(of source: U, to destination: inout V, rounding: Accelerate.vDSP.RoundingMode) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Float, V.Element == Swift.UInt16
  public static func convertElements<U, V>(of source: U, to destination: inout V, rounding: Accelerate.vDSP.RoundingMode) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Double, V.Element == Swift.UInt16
  public static func convertElements<U, V>(of source: U, to destination: inout V, rounding: Accelerate.vDSP.RoundingMode) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Float, V.Element == Swift.UInt32
  public static func convertElements<U, V>(of source: U, to destination: inout V, rounding: Accelerate.vDSP.RoundingMode) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Double, V.Element == Swift.UInt32
  public static func convertElements<U, V>(of source: U, to destination: inout V, rounding: Accelerate.vDSP.RoundingMode) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Float, V.Element == Swift.Int16
  public static func convertElements<U, V>(of source: U, to destination: inout V, rounding: Accelerate.vDSP.RoundingMode) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Double, V.Element == Swift.Int16
  public static func convertElements<U, V>(of source: U, to destination: inout V, rounding: Accelerate.vDSP.RoundingMode) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Float, V.Element == Swift.Int8
  public static func convertElements<U, V>(of source: U, to destination: inout V, rounding: Accelerate.vDSP.RoundingMode) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Double, V.Element == Swift.Int8
  public static func convertElements<U, V>(of source: U, to destination: inout V, rounding: Accelerate.vDSP.RoundingMode) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Float, V.Element == Swift.UInt8
  public static func convertElements<U, V>(of source: U, to destination: inout V, rounding: Accelerate.vDSP.RoundingMode) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Double, V.Element == Swift.UInt8
  @inlinable public static func convertElements<U, V>(of source: U, to destination: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Float, V.Element == Swift.Double {
            let n = vDSP_Length(min(source.count,
                                    destination.count))
            
            destination.withUnsafeMutableBufferPointer { dest in
                source.withUnsafeBufferPointer { src in
                    vDSP_vspdp(src.baseAddress!, 1,
                               dest.baseAddress!, 1,
                               n)
                }
            }
    }
  @inlinable public static func convertElements<U, V>(of source: U, to destination: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Double, V.Element == Swift.Float {
            let n = vDSP_Length(min(source.count,
                                    destination.count))
            
            destination.withUnsafeMutableBufferPointer { dest in
                source.withUnsafeBufferPointer { src in
                    vDSP_vdpsp(src.baseAddress!, 1,
                               dest.baseAddress!, 1,
                               n)
                }
            }
    }
}
@available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
public protocol vDSP_IntegerConvertable {
}
extension UInt8 : Accelerate.vDSP_IntegerConvertable {
}
extension UInt16 : Accelerate.vDSP_IntegerConvertable {
}
extension UInt32 : Accelerate.vDSP_IntegerConvertable {
}
extension Int8 : Accelerate.vDSP_IntegerConvertable {
}
extension Int16 : Accelerate.vDSP_IntegerConvertable {
}
extension Int32 : Accelerate.vDSP_IntegerConvertable {
}
@available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
public protocol vDSP_FloatingPointConvertable {
}
extension Float : Accelerate.vDSP_FloatingPointConvertable {
}
extension Double : Accelerate.vDSP_FloatingPointConvertable {
}
@available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension vDSP {
  @inlinable public static func integerToFloatingPoint<T, U>(_ vector: T, floatingPointType: U.Type) -> [U] where T : Accelerate.AccelerateBuffer, U : Accelerate.vDSP_FloatingPointConvertable, T.Element == Swift.UInt8 {
            
            switch floatingPointType {
            case is Float.Type:
                let result = Array<Float>(unsafeUninitializedCapacity: vector.count) {
                    buffer, initializedCount in
                    
                    convertElements(of: vector,
                                    to: &buffer)
                    
                    initializedCount = vector.count
                }
                
                return result as! [U]
            case is Double.Type:
                let result = Array<Double>(unsafeUninitializedCapacity: vector.count) {
                    buffer, initializedCount in
                    
                    convertElements(of: vector,
                                    to: &buffer)
                    
                    initializedCount = vector.count
                }
                
                return result as! [U]
                
            default:
                fatalError("\(floatingPointType) not supported as a destination type.")
            }
    }
  @inlinable public static func integerToFloatingPoint<T, U>(_ vector: T, floatingPointType: U.Type) -> [U] where T : Accelerate.AccelerateBuffer, U : Accelerate.vDSP_FloatingPointConvertable, T.Element == Swift.UInt16 {
            
            switch floatingPointType {
            case is Float.Type:
                let result = Array<Float>(unsafeUninitializedCapacity: vector.count) {
                    buffer, initializedCount in
                    
                    convertElements(of: vector,
                                    to: &buffer)
                    
                    initializedCount = vector.count
                }
                
                return result as! [U]
            case is Double.Type:
                let result = Array<Double>(unsafeUninitializedCapacity: vector.count) {
                    buffer, initializedCount in
                    
                    convertElements(of: vector,
                                    to: &buffer)
                    
                    initializedCount = vector.count
                }
                
                return result as! [U]
                
            default:
                fatalError("\(floatingPointType) not supported as a destination type.")
            }
    }
  @inlinable public static func integerToFloatingPoint<T, U>(_ vector: T, floatingPointType: U.Type) -> [U] where T : Accelerate.AccelerateBuffer, U : Accelerate.vDSP_FloatingPointConvertable, T.Element == Swift.UInt32 {
            
            switch floatingPointType {
            case is Float.Type:
                let result = Array<Float>(unsafeUninitializedCapacity: vector.count) {
                    buffer, initializedCount in
                    
                    convertElements(of: vector,
                                    to: &buffer)
                    
                    initializedCount = vector.count
                }
                
                return result as! [U]
            case is Double.Type:
                let result = Array<Double>(unsafeUninitializedCapacity: vector.count) {
                    buffer, initializedCount in
                    
                    convertElements(of: vector,
                                    to: &buffer)
                    
                    initializedCount = vector.count
                }
                
                return result as! [U]
                
            default:
                fatalError("\(floatingPointType) not supported as a destination type.")
            }
    }
  @inlinable public static func integerToFloatingPoint<T, U>(_ vector: T, floatingPointType: U.Type) -> [U] where T : Accelerate.AccelerateBuffer, U : Accelerate.vDSP_FloatingPointConvertable, T.Element == Swift.Int8 {
            
            switch floatingPointType {
            case is Float.Type:
                let result = Array<Float>(unsafeUninitializedCapacity: vector.count) {
                    buffer, initializedCount in
                    
                    convertElements(of: vector,
                                    to: &buffer)
                    
                    initializedCount = vector.count
                }
                
                return result as! [U]
            case is Double.Type:
                let result = Array<Double>(unsafeUninitializedCapacity: vector.count) {
                    buffer, initializedCount in
                    
                    convertElements(of: vector,
                                    to: &buffer)
                    
                    initializedCount = vector.count
                }
                
                return result as! [U]
                
            default:
                fatalError("\(floatingPointType) not supported as a destination type.")
            }
    }
  @inlinable public static func integerToFloatingPoint<T, U>(_ vector: T, floatingPointType: U.Type) -> [U] where T : Accelerate.AccelerateBuffer, U : Accelerate.vDSP_FloatingPointConvertable, T.Element == Swift.Int16 {
            
            switch floatingPointType {
            case is Float.Type:
                let result = Array<Float>(unsafeUninitializedCapacity: vector.count) {
                    buffer, initializedCount in
                    
                    convertElements(of: vector,
                                    to: &buffer)
                    
                    initializedCount = vector.count
                }
                
                return result as! [U]
            case is Double.Type:
                let result = Array<Double>(unsafeUninitializedCapacity: vector.count) {
                    buffer, initializedCount in
                    
                    convertElements(of: vector,
                                    to: &buffer)
                    
                    initializedCount = vector.count
                }
                
                return result as! [U]
                
            default:
                fatalError("\(floatingPointType) not supported as a destination type.")
            }
    }
  @inlinable public static func integerToFloatingPoint<T, U>(_ vector: T, floatingPointType: U.Type) -> [U] where T : Accelerate.AccelerateBuffer, U : Accelerate.vDSP_FloatingPointConvertable, T.Element == Swift.Int32 {
            
            switch floatingPointType {
            case is Float.Type:
                let result = Array<Float>(unsafeUninitializedCapacity: vector.count) {
                    buffer, initializedCount in
                    
                    convertElements(of: vector,
                                    to: &buffer)
                    
                    initializedCount = vector.count
                }
                
                return result as! [U]
            case is Double.Type:
                let result = Array<Double>(unsafeUninitializedCapacity: vector.count) {
                    buffer, initializedCount in
                    
                    convertElements(of: vector,
                                    to: &buffer)
                    
                    initializedCount = vector.count
                }
                
                return result as! [U]
                
            default:
                fatalError("\(floatingPointType) not supported as a destination type.")
            }
    }
  @inlinable public static func floatingPointToInteger<T, U>(_ vector: T, integerType: U.Type, rounding: Accelerate.vDSP.RoundingMode) -> [U] where T : Accelerate.AccelerateBuffer, U : Accelerate.vDSP_IntegerConvertable, T.Element == Swift.Float {
            
            switch integerType {
            case is UInt8.Type:
                let result = Array<UInt8>(unsafeUninitializedCapacity: vector.count) {
                    buffer, initializedCount in
                    
                    convertElements(of: vector,
                                    to: &buffer,
                                    rounding: rounding)
                    
                    initializedCount = vector.count
                }
                
                return result as! [U]
            case is UInt16.Type:
                let result = Array<UInt16>(unsafeUninitializedCapacity: vector.count) {
                    buffer, initializedCount in
                    
                    convertElements(of: vector,
                                    to: &buffer,
                                    rounding: rounding)
                    
                    initializedCount = vector.count
                }
                
                return result as! [U]
            case is UInt32.Type:
                let result = Array<UInt32>(unsafeUninitializedCapacity: vector.count) {
                    buffer, initializedCount in
                    
                    convertElements(of: vector,
                                    to: &buffer,
                                    rounding: rounding)
                    
                    initializedCount = vector.count
                }
                
                return result as! [U]
            case is Int8.Type:
                let result = Array<Int8>(unsafeUninitializedCapacity: vector.count) {
                    buffer, initializedCount in
                    
                    convertElements(of: vector,
                                    to: &buffer,
                                    rounding: rounding)
                    
                    initializedCount = vector.count
                }
                
                return result as! [U]
            case is Int16.Type:
                let result = Array<Int16>(unsafeUninitializedCapacity: vector.count) {
                    buffer, initializedCount in
                    
                    convertElements(of: vector,
                                    to: &buffer,
                                    rounding: rounding)
                    
                    initializedCount = vector.count
                }
                
                return result as! [U]
            case is Int32.Type:
                let result = Array<Int32>(unsafeUninitializedCapacity: vector.count) {
                    buffer, initializedCount in
                    
                    convertElements(of: vector,
                                    to: &buffer,
                                    rounding: rounding)
                    
                    initializedCount = vector.count
                }
                
                return result as! [U]
            default:
                fatalError("\(integerType) not supported as a destination type.")
            }
    }
  @inlinable public static func floatingPointToInteger<T, U>(_ vector: T, integerType: U.Type, rounding: Accelerate.vDSP.RoundingMode) -> [U] where T : Accelerate.AccelerateBuffer, U : Accelerate.vDSP_IntegerConvertable, T.Element == Swift.Double {
            
            switch integerType {
            case is UInt8.Type:
                let result = Array<UInt8>(unsafeUninitializedCapacity: vector.count) {
                    buffer, initializedCount in
                    
                    convertElements(of: vector,
                                    to: &buffer,
                                    rounding: rounding)
                    
                    initializedCount = vector.count
                }
                
                return result as! [U]
            case is UInt16.Type:
                let result = Array<UInt16>(unsafeUninitializedCapacity: vector.count) {
                    buffer, initializedCount in
                    
                    convertElements(of: vector,
                                    to: &buffer,
                                    rounding: rounding)
                    
                    initializedCount = vector.count
                }
                
                return result as! [U]
            case is UInt32.Type:
                let result = Array<UInt32>(unsafeUninitializedCapacity: vector.count) {
                    buffer, initializedCount in
                    
                    convertElements(of: vector,
                                    to: &buffer,
                                    rounding: rounding)
                    
                    initializedCount = vector.count
                }
                
                return result as! [U]
            case is Int8.Type:
                let result = Array<Int8>(unsafeUninitializedCapacity: vector.count) {
                    buffer, initializedCount in
                    
                    convertElements(of: vector,
                                    to: &buffer,
                                    rounding: rounding)
                    
                    initializedCount = vector.count
                }
                
                return result as! [U]
            case is Int16.Type:
                let result = Array<Int16>(unsafeUninitializedCapacity: vector.count) {
                    buffer, initializedCount in
                    
                    convertElements(of: vector,
                                    to: &buffer,
                                    rounding: rounding)
                    
                    initializedCount = vector.count
                }
                
                return result as! [U]
            case is Int32.Type:
                let result = Array<Int32>(unsafeUninitializedCapacity: vector.count) {
                    buffer, initializedCount in
                    
                    convertElements(of: vector,
                                    to: &buffer,
                                    rounding: rounding)
                    
                    initializedCount = vector.count
                }
                
                return result as! [U]
            default:
                fatalError("\(integerType) not supported as a destination type.")
            }
    }
  @inlinable public static func floatToDouble<U>(_ source: U) -> [Swift.Double] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Float {
            let result = Array<Double>(unsafeUninitializedCapacity: source.count) {
                buffer, initializedCount in
                
                convertElements(of: source,
                                to: &buffer)
                
                initializedCount = source.count
            }
            
            return result
    }
  @inlinable public static func doubleToFloat<U>(_ source: U) -> [Swift.Float] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Double {
            let result = Array<Float>(unsafeUninitializedCapacity: source.count) {
                buffer, initializedCount in
                
                convertElements(of: source,
                                to: &buffer)
                
                initializedCount = source.count
            }
            
            return result
    }
}
@available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension vDSP {
  @inlinable public static func convolve<T, U>(_ vector: T, withKernel kernel: U) -> [Swift.Float] where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, T.Element == Swift.Float, U.Element == Swift.Float {
            
            let n = vector.count - kernel.count
            
            let result = Array<Float>(unsafeUninitializedCapacity: n) {
                buffer, initializedCount in
                
                convolve(vector,
                         withKernel: kernel,
                         result: &buffer)
                
                initializedCount = n
            }
            
            return result
    }
  @inlinable public static func convolve<T, U, V>(_ vector: T, withKernel kernel: U, result: inout V) where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, T.Element == Swift.Float, U.Element == Swift.Float, V.Element == Swift.Float {
            
            let n = result.count
            precondition(vector.count >= n + kernel.count - 1,
                         "Source vector count must be at least the sum of the result and kernel counts, minus one.")
            
            result.withUnsafeMutableBufferPointer { dest in
                vector.withUnsafeBufferPointer { src in
                    kernel.withUnsafeBufferPointer { k in
                        vDSP_conv(src.baseAddress!, 1,
                                  k.baseAddress!.advanced(by: kernel.count - 1), -1,
                                  dest.baseAddress!, 1,
                                  vDSP_Length(n),
                                  vDSP_Length(kernel.count))
                    }
                }
            }
    }
  @inlinable public static func convolve<T, U>(_ vector: T, withKernel kernel: U) -> [Swift.Double] where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, T.Element == Swift.Double, U.Element == Swift.Double {
            
            let n = vector.count - kernel.count
            
            let result = Array<Double>(unsafeUninitializedCapacity: n) {
                buffer, initializedCount in
                
                convolve(vector,
                         withKernel: kernel,
                         result: &buffer)
                
                initializedCount = n
            }
            
            return result
    }
  @inlinable public static func convolve<T, U, V>(_ vector: T, withKernel kernel: U, result: inout V) where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, T.Element == Swift.Double, U.Element == Swift.Double, V.Element == Swift.Double {
            
            let n = result.count
            precondition(vector.count >= n + kernel.count - 1,
                         "Source vector count must be at least the sum of the result and kernel counts, minus one.")
            
            result.withUnsafeMutableBufferPointer { dest in
                vector.withUnsafeBufferPointer { src in
                    kernel.withUnsafeBufferPointer { k in
                        vDSP_convD(src.baseAddress!, 1,
                                   k.baseAddress!.advanced(by: kernel.count - 1), -1,
                                   dest.baseAddress!, 1,
                                   vDSP_Length(n),
                                   vDSP_Length(kernel.count))
                    }
                }
            }
    }
  @inlinable public static func correlate<T, U>(_ vector: T, withKernel kernel: U) -> [Swift.Float] where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, T.Element == Swift.Float, U.Element == Swift.Float {
            
            let n = vector.count - kernel.count
            
            let result = Array<Float>(unsafeUninitializedCapacity: n) {
                buffer, initializedCount in
                
                correlate(vector,
                          withKernel: kernel,
                          result: &buffer)
                
                initializedCount = n
            }
            
            return result
    }
  @inlinable public static func correlate<T, U, V>(_ vector: T, withKernel kernel: U, result: inout V) where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, T.Element == Swift.Float, U.Element == Swift.Float, V.Element == Swift.Float {
            
            let n = result.count
            precondition(vector.count >= n + kernel.count - 1,
                         "Source vector count must be at least the sum of the result and kernel counts, minus one.")
            
            result.withUnsafeMutableBufferPointer { dest in
                vector.withUnsafeBufferPointer { src in
                    kernel.withUnsafeBufferPointer { k in
                        vDSP_conv(src.baseAddress!, 1,
                                  k.baseAddress!, 1,
                                  dest.baseAddress!, 1,
                                  vDSP_Length(n),
                                  vDSP_Length(kernel.count))
                    }
                }
            }
    }
  @inlinable public static func correlate<T, U>(_ vector: T, withKernel kernel: U) -> [Swift.Double] where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, T.Element == Swift.Double, U.Element == Swift.Double {
            
            let n = vector.count - kernel.count
            
            let result = Array<Double>(unsafeUninitializedCapacity: n) {
                buffer, initializedCount in
                
                correlate(vector,
                          withKernel: kernel,
                          result: &buffer)
                
                initializedCount = n
            }
            
            return result
    }
  @inlinable public static func correlate<T, U, V>(_ vector: T, withKernel kernel: U, result: inout V) where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, T.Element == Swift.Double, U.Element == Swift.Double, V.Element == Swift.Double {
            
            let n = result.count
            precondition(vector.count >= n + kernel.count - 1,
                         "Source vector count must be at least the sum of the result and kernel counts, minus one.")
            
            result.withUnsafeMutableBufferPointer { dest in
                vector.withUnsafeBufferPointer { src in
                    kernel.withUnsafeBufferPointer { k in
                        vDSP_convD(src.baseAddress!, 1,
                                   k.baseAddress!, 1,
                                   dest.baseAddress!, 1,
                                   vDSP_Length(n),
                                   vDSP_Length(kernel.count))
                    }
                }
            }
    }
}
@available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension vDSP {
  @inlinable public static func convolve<T, U>(_ vector: T, rowCount: Swift.Int, columnCount: Swift.Int, with3x3Kernel kernel: U) -> [Swift.Float] where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, T.Element == Swift.Float, U.Element == Swift.Float {
            
            let result = Array<Float>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                convolve(vector,
                         rowCount: rowCount, columnCount: columnCount,
                         with3x3Kernel: kernel,
                         result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func convolve<T, U, V>(_ vector: T, rowCount: Swift.Int, columnCount: Swift.Int, with3x3Kernel kernel: U, result: inout V) where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, T.Element == Swift.Float, U.Element == Swift.Float, V.Element == Swift.Float {
            
            precondition(rowCount >= 3,
                         "Row count must be greater than or equal to 3.")
            
            precondition(columnCount >= 4,
                         "Column count must be even and greater than or equal to 4")
            
            precondition(rowCount * columnCount == vector.count,
                         "Row count `x` column count must equal source vector count.")
            
            precondition(kernel.count == 9,
                         "Kernel must contain 9 elements.")
            
            result.withUnsafeMutableBufferPointer { dest in
                vector.withUnsafeBufferPointer { src in
                    kernel.withUnsafeBufferPointer { k in
                        vDSP_f3x3(src.baseAddress!,
                                  vDSP_Length(rowCount), vDSP_Length(columnCount),
                                  k.baseAddress!,
                                  dest.baseAddress!)
                    }
                }
            }
    }
  @inlinable public static func convolve<T, U>(_ vector: T, rowCount: Swift.Int, columnCount: Swift.Int, with3x3Kernel kernel: U) -> [Swift.Double] where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, T.Element == Swift.Double, U.Element == Swift.Double {
            
            let result = Array<Double>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                convolve(vector,
                         rowCount: rowCount, columnCount: columnCount,
                         with3x3Kernel: kernel,
                         result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func convolve<T, U, V>(_ vector: T, rowCount: Swift.Int, columnCount: Swift.Int, with3x3Kernel kernel: U, result: inout V) where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, T.Element == Swift.Double, U.Element == Swift.Double, V.Element == Swift.Double {
            
            precondition(rowCount >= 3,
                         "Row count must be greater than or equal to 3.")
            
            precondition(columnCount >= 4,
                         "Column count must be even and greater than or equal to 4")
            
            precondition(rowCount * columnCount == vector.count,
                         "Row count `x` column count must equal source vector count.")
            
            precondition(kernel.count == 9,
                         "Kernel must contain 9 elements.")
            
            result.withUnsafeMutableBufferPointer { dest in
                vector.withUnsafeBufferPointer { src in
                    kernel.withUnsafeBufferPointer { k in
                        vDSP_f3x3D(src.baseAddress!,
                                   vDSP_Length(rowCount), vDSP_Length(columnCount),
                                   k.baseAddress!,
                                   dest.baseAddress!)
                    }
                }
            }
    }
  @inlinable public static func convolve<T, U>(_ vector: T, rowCount: Swift.Int, columnCount: Swift.Int, with5x5Kernel kernel: U) -> [Swift.Float] where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, T.Element == Swift.Float, U.Element == Swift.Float {
            
            let result = Array<Float>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                convolve(vector,
                         rowCount: rowCount, columnCount: columnCount,
                         with5x5Kernel: kernel,
                         result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func convolve<T, U, V>(_ vector: T, rowCount: Swift.Int, columnCount: Swift.Int, with5x5Kernel kernel: U, result: inout V) where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, T.Element == Swift.Float, U.Element == Swift.Float, V.Element == Swift.Float {
            
            precondition(rowCount >= 3,
                         "Row count must be greater than or equal to 3.")
            
            precondition(columnCount >= 4,
                         "Column count must be even and greater than or equal to 4")
            
            precondition(rowCount * columnCount == vector.count,
                         "Row count `x` column count must equal source vector count.")
            
            precondition(kernel.count == 25,
                         "Kernel must contain 25 elements.")
            
            result.withUnsafeMutableBufferPointer { dest in
                vector.withUnsafeBufferPointer { src in
                    kernel.withUnsafeBufferPointer { k in
                        vDSP_f5x5(src.baseAddress!,
                                  vDSP_Length(rowCount), vDSP_Length(columnCount),
                                  k.baseAddress!,
                                  dest.baseAddress!)
                    }
                }
            }
    }
  @inlinable public static func convolve<T, U>(_ vector: T, rowCount: Swift.Int, columnCount: Swift.Int, with5x5Kernel kernel: U) -> [Swift.Double] where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, T.Element == Swift.Double, U.Element == Swift.Double {
            
            let result = Array<Double>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                convolve(vector,
                         rowCount: rowCount, columnCount: columnCount,
                         with5x5Kernel: kernel,
                         result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func convolve<T, U, V>(_ vector: T, rowCount: Swift.Int, columnCount: Swift.Int, with5x5Kernel kernel: U, result: inout V) where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, T.Element == Swift.Double, U.Element == Swift.Double, V.Element == Swift.Double {
            
            precondition(rowCount >= 3,
                         "Row count must be greater than or equal to 3.")
            
            precondition(columnCount >= 4,
                         "Column count must be even and greater than or equal to 4")
            
            precondition(rowCount * columnCount == vector.count,
                         "Row count `x` column count must equal source vector count.")
            
            precondition(kernel.count == 25,
                         "Kernel must contain 25 elements.")
            
            result.withUnsafeMutableBufferPointer { dest in
                vector.withUnsafeBufferPointer { src in
                    kernel.withUnsafeBufferPointer { k in
                        vDSP_f5x5D(src.baseAddress!,
                                   vDSP_Length(rowCount), vDSP_Length(columnCount),
                                   k.baseAddress!,
                                   dest.baseAddress!)
                    }
                }
            }
    }
  @inlinable public static func convolve<T, U>(_ vector: T, rowCount: Swift.Int, columnCount: Swift.Int, withKernel kernel: U, kernelRowCount: Swift.Int, kernelColumnCount: Swift.Int) -> [Swift.Float] where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, T.Element == Swift.Float, U.Element == Swift.Float {
            
            let result = Array<Float>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                convolve(vector,
                         rowCount: rowCount, columnCount: columnCount,
                         withKernel: kernel,
                         kernelRowCount: kernelRowCount, kernelColumnCount: kernelColumnCount,
                         result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func convolve<T, U, V>(_ vector: T, rowCount: Swift.Int, columnCount: Swift.Int, withKernel kernel: U, kernelRowCount: Swift.Int, kernelColumnCount: Swift.Int, result: inout V) where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, T.Element == Swift.Float, U.Element == Swift.Float, V.Element == Swift.Float {
            
            precondition(rowCount >= 3,
                         "Row count must be greater than or equal to 3.")
            
            precondition(columnCount >= 4,
                         "Column count must be even and greater than or equal to 4")
            
            precondition(rowCount * columnCount == vector.count,
                         "Row count `x` column count must equal source vector count.")
            
            precondition(kernelRowCount % 2 == 1,
                         "Kernel row count must be odd.")
            
            precondition(kernelColumnCount % 2 == 1,
                         "Kernel column count must be odd.")
            
            result.withUnsafeMutableBufferPointer { dest in
                vector.withUnsafeBufferPointer { src in
                    kernel.withUnsafeBufferPointer { k in
                        vDSP_imgfir(src.baseAddress!,
                                    vDSP_Length(rowCount), vDSP_Length(columnCount),
                                    k.baseAddress!,
                                    dest.baseAddress!,
                                    vDSP_Length(kernelRowCount), vDSP_Length(kernelColumnCount))
                    }
                }
            }
    }
  @inlinable public static func convolve<T, U>(_ vector: T, rowCount: Swift.Int, columnCount: Swift.Int, withKernel kernel: U, kernelRowCount: Swift.Int, kernelColumnCount: Swift.Int) -> [Swift.Double] where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, T.Element == Swift.Double, U.Element == Swift.Double {
            
            let result = Array<Double>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                convolve(vector,
                         rowCount: rowCount, columnCount: columnCount,
                         withKernel: kernel,
                         kernelRowCount: kernelRowCount, kernelColumnCount: kernelColumnCount,
                         result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func convolve<T, U, V>(_ vector: T, rowCount: Swift.Int, columnCount: Swift.Int, withKernel kernel: U, kernelRowCount: Swift.Int, kernelColumnCount: Swift.Int, result: inout V) where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, T.Element == Swift.Double, U.Element == Swift.Double, V.Element == Swift.Double {
            
            precondition(rowCount >= 3,
                         "Row count must be greater than or equal to 3.")
            
            precondition(columnCount >= 4,
                         "Column count must be even and greater than or equal to 4")
            
            precondition(rowCount * columnCount == vector.count,
                         "Row count `x` column count must equal source vector count.")
            
            precondition(kernelRowCount % 2 == 1,
                         "Kernel row count must be odd.")
            
            precondition(kernelColumnCount % 2 == 1,
                         "Kernel column count must be odd.")
            
            result.withUnsafeMutableBufferPointer { dest in
                vector.withUnsafeBufferPointer { src in
                    kernel.withUnsafeBufferPointer { k in
                        vDSP_imgfirD(src.baseAddress!,
                                     vDSP_Length(rowCount), vDSP_Length(columnCount),
                                     k.baseAddress!,
                                     dest.baseAddress!,
                                     vDSP_Length(kernelRowCount), vDSP_Length(kernelColumnCount))
                    }
                }
            }
    }
}
@available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension vDSP {
  public enum DCTTransformType : Swift.CaseIterable {
    case II
    case III
    case IV
    public var dctType: Accelerate.vDSP_DCT_Type {
      get
    }
    public static func == (a: Accelerate.vDSP.DCTTransformType, b: Accelerate.vDSP.DCTTransformType) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
    public typealias AllCases = [Accelerate.vDSP.DCTTransformType]
    public static var allCases: [Accelerate.vDSP.DCTTransformType] {
      get
    }
  }
  public class DCT {
    public init?(previous: Accelerate.vDSP.DCT? = nil, count: Swift.Int, transformType: Accelerate.vDSP.DCTTransformType)
    public func transform<U>(_ vector: U) -> [Swift.Float] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Float
    public func transform<U, V>(_ vector: U, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Float, V.Element == Swift.Float
    @objc deinit
  }
}
@available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension vDSP {
  public enum DFTTransformType {
    case complexComplex
    case complexReal
    public static func == (a: Accelerate.vDSP.DFTTransformType, b: Accelerate.vDSP.DFTTransformType) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
  }
  public class DFT<T> where T : Accelerate.vDSP_FloatingPointDiscreteFourierTransformable {
    public init?(previous: Accelerate.vDSP.DFT<T>? = nil, count: Swift.Int, direction: Accelerate.vDSP.FourierTransformDirection, transformType: Accelerate.vDSP.DFTTransformType, ofType: T.Type)
    public func transform<U>(inputReal: U, inputImaginary: U) -> (real: [T], imaginary: [T]) where T == U.Element, U : Accelerate.AccelerateBuffer
    public func transform<U, V>(inputReal: U, inputImaginary: U, outputReal: inout V, outputImaginary: inout V) where T == U.Element, U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == V.Element
    @objc deinit
  }
}
@available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
public protocol vDSP_FloatingPointDiscreteFourierTransformable : Swift.BinaryFloatingPoint {
  associatedtype DFTFunctions : Accelerate.vDSP_DFTFunctions where Self == Self.DFTFunctions.Scalar
}
@available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Float : Accelerate.vDSP_FloatingPointDiscreteFourierTransformable {
  public typealias DFTFunctions = Accelerate.vDSP.VectorizableFloat
}
@available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Double : Accelerate.vDSP_FloatingPointDiscreteFourierTransformable {
  public typealias DFTFunctions = Accelerate.vDSP.VectorizableDouble
}
@available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
public protocol vDSP_DFTFunctions {
  associatedtype Scalar
  static func makeDFTSetup<T>(previous: Accelerate.vDSP.DFT<T>?, count: Swift.Int, direction: Accelerate.vDSP.FourierTransformDirection, transformType: Accelerate.vDSP.DFTTransformType) -> Swift.OpaquePointer? where T : Accelerate.vDSP_FloatingPointDiscreteFourierTransformable
  static func transform<U, V>(dftSetup: Swift.OpaquePointer, inputReal: U, inputImaginary: U, outputReal: inout V, outputImaginary: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, Self.Scalar == U.Element, U.Element == V.Element
  static func destroySetup(_ setup: Swift.OpaquePointer)
}
@available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension vDSP.VectorizableFloat : Accelerate.vDSP_DFTFunctions {
  public static func makeDFTSetup<T>(previous: Accelerate.vDSP.DFT<T>? = nil, count: Swift.Int, direction: Accelerate.vDSP.FourierTransformDirection, transformType: Accelerate.vDSP.DFTTransformType) -> Swift.OpaquePointer? where T : Accelerate.vDSP_FloatingPointDiscreteFourierTransformable
  public static func transform<U, V>(dftSetup: Swift.OpaquePointer, inputReal: U, inputImaginary: U, outputReal: inout V, outputImaginary: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Float, V.Element == Swift.Float
  public static func destroySetup(_ setup: Swift.OpaquePointer)
}
@available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension vDSP.VectorizableDouble : Accelerate.vDSP_DFTFunctions {
  public static func makeDFTSetup<T>(previous: Accelerate.vDSP.DFT<T>? = nil, count: Swift.Int, direction: Accelerate.vDSP.FourierTransformDirection, transformType: Accelerate.vDSP.DFTTransformType) -> Swift.OpaquePointer? where T : Accelerate.vDSP_FloatingPointDiscreteFourierTransformable
  public static func transform<U, V>(dftSetup: Swift.OpaquePointer, inputReal: U, inputImaginary: U, outputReal: inout V, outputImaginary: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Double, V.Element == Swift.Double
  public static func destroySetup(_ setup: Swift.OpaquePointer)
}
@available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension vDSP {
  @inlinable public static func powerToDecibels<U>(_ power: U, zeroReference: Swift.Float) -> [Swift.Float] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Float {
            
            let result = Array<Float>(unsafeUninitializedCapacity: power.count) {
                buffer, initializedCount in
                
                convert(power: power,
                        toDecibels: &buffer,
                        zeroReference: zeroReference)
                
                initializedCount = power.count
            }
            
            return result
    }
  @inlinable public static func convert<U, V>(power: U, toDecibels decibels: inout V, zeroReference: Swift.Float) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Float, V.Element == Swift.Float {
            
            let n = decibels.count
            precondition(power.count == n)
            
            decibels.withUnsafeMutableBufferPointer { db in
                power.withUnsafeBufferPointer { pwr in
                    withUnsafePointer(to: zeroReference) { zref in
                        vDSP_vdbcon(pwr.baseAddress!, 1,
                                    zref,
                                    db.baseAddress!, 1,
                                    vDSP_Length(n),
                                    0)
                    }
                }
            }
    }
  @inlinable public static func powerToDecibels<U>(_ power: U, zeroReference: Swift.Double) -> [Swift.Double] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Double {
            
            let result = Array<Double>(unsafeUninitializedCapacity: power.count) {
                buffer, initializedCount in
                
                convert(power: power,
                        toDecibels: &buffer,
                        zeroReference: zeroReference)
                
                initializedCount = power.count
            }
            
            return result
    }
  @inlinable public static func convert<U, V>(power: U, toDecibels decibels: inout V, zeroReference: Swift.Double) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Double, V.Element == Swift.Double {
            
            let n = decibels.count
            precondition(power.count == n)
            
            decibels.withUnsafeMutableBufferPointer { db in
                power.withUnsafeBufferPointer { pwr in
                    withUnsafePointer(to: zeroReference) { zref in
                        vDSP_vdbconD(pwr.baseAddress!, 1,
                                     zref,
                                     db.baseAddress!, 1,
                                     vDSP_Length(n),
                                     0)
                    }
                }
            }
    }
  @inlinable public static func amplitudeToDecibels<U>(_ amplitude: U, zeroReference: Swift.Float) -> [Swift.Float] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Float {
            
            let result = Array<Float>(unsafeUninitializedCapacity: amplitude.count) {
                buffer, initializedCount in
                
                convert(amplitude: amplitude,
                        toDecibels: &buffer,
                        zeroReference: zeroReference)
                
                initializedCount = amplitude.count
            }
            
            return result
    }
  @inlinable public static func convert<U, V>(amplitude: U, toDecibels decibels: inout V, zeroReference: Swift.Float) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Float, V.Element == Swift.Float {
            
            let n = decibels.count
            precondition(amplitude.count == n)
            
            decibels.withUnsafeMutableBufferPointer { db in
                amplitude.withUnsafeBufferPointer { amp in
                    withUnsafePointer(to: zeroReference) { zref in
                        vDSP_vdbcon(amp.baseAddress!, 1,
                                    zref,
                                    db.baseAddress!, 1,
                                    vDSP_Length(n),
                                    1)
                    }
                }
            }
    }
  @inlinable public static func amplitudeToDecibels<U>(_ amplitude: U, zeroReference: Swift.Double) -> [Swift.Double] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Double {
            
            let result = Array<Double>(unsafeUninitializedCapacity: amplitude.count) {
                buffer, initializedCount in
                
                convert(amplitude: amplitude,
                        toDecibels: &buffer,
                        zeroReference: zeroReference)
                
                initializedCount = amplitude.count
            }
            
            return result
    }
  @inlinable public static func convert<U, V>(amplitude: U, toDecibels decibels: inout V, zeroReference: Swift.Double) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Double, V.Element == Swift.Double {
            
            let n = decibels.count
            precondition(amplitude.count == n)
            
            decibels.withUnsafeMutableBufferPointer { db in
                amplitude.withUnsafeBufferPointer { amp in
                    withUnsafePointer(to: zeroReference) { zref in
                        vDSP_vdbconD(amp.baseAddress!, 1,
                                     zref,
                                     db.baseAddress!, 1,
                                     vDSP_Length(n),
                                     1)
                    }
                }
            }
    }
}
@available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension vDSP {
  public enum Radix {
    case radix2
    case radix3
    case radix5
    public var fftRadix: Accelerate.FFTRadix {
      get
    }
    public static func == (a: Accelerate.vDSP.Radix, b: Accelerate.vDSP.Radix) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
  }
  public class FFT<T> where T : Accelerate.vDSP_FourierTransformable {
    public init?(log2n: Accelerate.vDSP_Length, radix: Accelerate.vDSP.Radix, ofType: T.Type)
    public func transform<T>(input: T, output: inout T, direction: Accelerate.vDSP.FourierTransformDirection) where T : Accelerate.vDSP_FourierTransformable
    public func forward(input: Accelerate.DSPSplitComplex, output: inout Accelerate.DSPSplitComplex)
    public func inverse(input: Accelerate.DSPSplitComplex, output: inout Accelerate.DSPSplitComplex)
    @objc deinit
  }
  public class FFT2D<T> : Accelerate.vDSP.FFT<T> where T : Accelerate.vDSP_FourierTransformable {
    required public init?(width: Swift.Int, height: Swift.Int, ofType: T.Type)
    override public func transform<T>(input: T, output: inout T, direction: Accelerate.vDSP.FourierTransformDirection) where T : Accelerate.vDSP_FourierTransformable
    override public init?(log2n: Accelerate.vDSP_Length, radix: Accelerate.vDSP.Radix, ofType: T.Type)
    @objc deinit
  }
}
@available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
public protocol vDSP_FourierTransformFunctions {
  associatedtype SplitComplex
  static func makeFFTSetup(log2n: Accelerate.vDSP_Length, radix: Accelerate.vDSP.Radix) -> Swift.OpaquePointer?
  static func transform(fftSetup: Swift.OpaquePointer, log2n: Accelerate.vDSP_Length, source: Swift.UnsafePointer<Self.SplitComplex>, destination: Swift.UnsafeMutablePointer<Self.SplitComplex>, direction: Accelerate.vDSP.FourierTransformDirection)
  static func transform2D(fftSetup: Swift.OpaquePointer, width: Swift.Int, height: Swift.Int, source: Swift.UnsafePointer<Self.SplitComplex>, destination: Swift.UnsafeMutablePointer<Self.SplitComplex>, direction: Accelerate.vDSP.FourierTransformDirection)
  static func destroySetup(_ setup: Swift.OpaquePointer)
}
@available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
public struct vDSP_SplitComplexFloat : Accelerate.vDSP_FourierTransformFunctions {
  public typealias SplitComplex = Accelerate.DSPSplitComplex
  public static func makeFFTSetup(log2n: Accelerate.vDSP_Length, radix: Accelerate.vDSP.Radix) -> Swift.OpaquePointer?
  public static func transform(fftSetup: Swift.OpaquePointer, log2n: Accelerate.vDSP_Length, source: Swift.UnsafePointer<Accelerate.vDSP_SplitComplexFloat.SplitComplex>, destination: Swift.UnsafeMutablePointer<Accelerate.vDSP_SplitComplexFloat.SplitComplex>, direction: Accelerate.vDSP.FourierTransformDirection)
  public static func transform2D(fftSetup: Swift.OpaquePointer, width: Swift.Int, height: Swift.Int, source: Swift.UnsafePointer<Accelerate.vDSP_SplitComplexFloat.SplitComplex>, destination: Swift.UnsafeMutablePointer<Accelerate.vDSP_SplitComplexFloat.SplitComplex>, direction: Accelerate.vDSP.FourierTransformDirection)
  public static func destroySetup(_ setup: Swift.OpaquePointer)
}
@available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
public struct vDSP_SplitComplexDouble : Accelerate.vDSP_FourierTransformFunctions {
  public typealias SplitComplex = Accelerate.DSPDoubleSplitComplex
  public static func makeFFTSetup(log2n: Accelerate.vDSP_Length, radix: Accelerate.vDSP.Radix) -> Swift.OpaquePointer?
  public static func transform(fftSetup: Swift.OpaquePointer, log2n: Accelerate.vDSP_Length, source: Swift.UnsafePointer<Accelerate.vDSP_SplitComplexDouble.SplitComplex>, destination: Swift.UnsafeMutablePointer<Accelerate.vDSP_SplitComplexDouble.SplitComplex>, direction: Accelerate.vDSP.FourierTransformDirection)
  public static func transform2D(fftSetup: Swift.OpaquePointer, width: Swift.Int, height: Swift.Int, source: Swift.UnsafePointer<Accelerate.vDSP_SplitComplexDouble.SplitComplex>, destination: Swift.UnsafeMutablePointer<Accelerate.vDSP_SplitComplexDouble.SplitComplex>, direction: Accelerate.vDSP.FourierTransformDirection)
  public static func destroySetup(_ setup: Swift.OpaquePointer)
}
@available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
public protocol vDSP_FourierTransformable {
  associatedtype FFTFunctions : Accelerate.vDSP_FourierTransformFunctions where Self == Self.FFTFunctions.SplitComplex
}
@available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension DSPSplitComplex : Accelerate.vDSP_FourierTransformable {
  public typealias FFTFunctions = Accelerate.vDSP_SplitComplexFloat
}
@available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension DSPDoubleSplitComplex : Accelerate.vDSP_FourierTransformable {
  public typealias FFTFunctions = Accelerate.vDSP_SplitComplexDouble
}
@available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension DSPSplitComplex {
  public init(fromInputArray inputArray: [Swift.Float], realParts: inout [Swift.Float], imaginaryParts: inout [Swift.Float])
}
@available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension DSPDoubleSplitComplex {
  public init(fromInputArray inputArray: [Swift.Double], realParts: inout [Swift.Double], imaginaryParts: inout [Swift.Double])
}
extension Array where Element == Swift.Float {
  @available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public init(fromSplitComplex splitComplex: Accelerate.DSPSplitComplex, scale: Swift.Float, count: Swift.Int)
}
extension Array where Element == Swift.Double {
  @available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public init(fromSplitComplex splitComplex: Accelerate.DSPDoubleSplitComplex, scale: Swift.Double, count: Swift.Int)
}
@available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension vDSP {
  public enum FourierTransformDirection {
    case forward
    case inverse
    public var dftDirection: Accelerate.vDSP_DFT_Direction {
      get
    }
    public var fftDirection: Accelerate.FFTDirection {
      get
    }
    public static func == (a: Accelerate.vDSP.FourierTransformDirection, b: Accelerate.vDSP.FourierTransformDirection) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
  }
}
@available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension vDSP {
  @inlinable public static func downsample<T, U>(_ source: U, decimationFactor: Swift.Int, filter: T) -> [Swift.Float] where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, T.Element == Swift.Float, U.Element == Swift.Float {
            
            let n = (source.count - filter.count) / decimationFactor + 1
            
            let result = Array<Float>(unsafeUninitializedCapacity: n) {
                buffer, initializedCount in
                
                downsample(source,
                           decimationFactor: decimationFactor,
                           filter: filter,
                           result: &buffer)
                
                initializedCount = n
            }
            
            return result
    }
  @inlinable public static func downsample<T, U, V>(_ source: U, decimationFactor: Swift.Int, filter: T, result: inout V) where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, T.Element == Swift.Float, U.Element == Swift.Float, V.Element == Swift.Float {
            
            let p = filter.count
            let n = result.count
            
            precondition(source.count == decimationFactor * (n - 1) + p)
            
            result.withUnsafeMutableBufferPointer { dest in
                source.withUnsafeBufferPointer { src in
                    filter.withUnsafeBufferPointer { f in
                        
                        vDSP_desamp(src.baseAddress!,
                                    vDSP_Stride(decimationFactor),
                                    f.baseAddress!,
                                    dest.baseAddress!,
                                    vDSP_Length(n),
                                    vDSP_Length(p))
                    }
                }
            }
    }
  @inlinable public static func downsample<T, U>(_ source: U, decimationFactor: Swift.Int, filter: T) -> [Swift.Double] where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, T.Element == Swift.Double, U.Element == Swift.Double {
            let n = (source.count - filter.count) / decimationFactor + 1
            
            let result = Array<Double>(unsafeUninitializedCapacity: n) {
                buffer, initializedCount in
                
                downsample(source,
                           decimationFactor: decimationFactor,
                           filter: filter,
                           result: &buffer)
                
                initializedCount = n
            }
            
            return result
    }
  @inlinable public static func downsample<T, U, V>(_ source: U, decimationFactor: Swift.Int, filter: T, result: inout V) where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, T.Element == Swift.Double, U.Element == Swift.Double, V.Element == Swift.Double {
            
            let p = filter.count
            let n = result.count
            
            precondition(source.count == decimationFactor * (n - 1) + p)
            
            result.withUnsafeMutableBufferPointer { dest in
                source.withUnsafeBufferPointer { src in
                    filter.withUnsafeBufferPointer { f in
                        
                        vDSP_desampD(src.baseAddress!,
                                     vDSP_Stride(decimationFactor),
                                     f.baseAddress!,
                                     dest.baseAddress!,
                                     vDSP_Length(n),
                                     vDSP_Length(p))
                    }
                }
            }
    }
}
@available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
public protocol vDSP_FloatingPointGeneratable : Swift.BinaryFloatingPoint {
}
extension Float : Accelerate.vDSP_FloatingPointGeneratable {
}
extension Double : Accelerate.vDSP_FloatingPointGeneratable {
}
@available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension vDSP {
  @inlinable public static func fill<V>(_ vector: inout V, with value: Swift.Float) where V : Accelerate.AccelerateMutableBuffer, V.Element == Swift.Float {
            
            let n = vDSP_Length(vector.count)
            
            vector.withUnsafeMutableBufferPointer { v in
                withUnsafePointer(to: value) {
                    vDSP_vfill($0,
                               v.baseAddress!, 1,
                               n)
                }
            }
    }
  @inlinable public static func fill<V>(_ vector: inout V, with value: Swift.Double) where V : Accelerate.AccelerateMutableBuffer, V.Element == Swift.Double {
            
            let n = vDSP_Length(vector.count)
            
            vector.withUnsafeMutableBufferPointer { v in
                withUnsafePointer(to: value) {
                    vDSP_vfillD($0,
                                v.baseAddress!, 1,
                                n)
                }
            }
    }
  @inlinable public static func clear<V>(_ vector: inout V) where V : Accelerate.AccelerateMutableBuffer, V.Element == Swift.Float {
            
            let n = vDSP_Length(vector.count)
            
            vector.withUnsafeMutableBufferPointer { v in
                vDSP_vclr(v.baseAddress!, 1,
                          n)
            }
    }
  @inlinable public static func clear<V>(_ vector: inout V) where V : Accelerate.AccelerateMutableBuffer, V.Element == Swift.Double {
            
            let n = vDSP_Length(vector.count)
            
            vector.withUnsafeMutableBufferPointer { v in
                vDSP_vclrD(v.baseAddress!, 1,
                           n)
            }
    }
  public enum WindowSequence {
    case hanningNormalized
    case hanningDenormalized
    case hamming
    case blackman
    public static func == (a: Accelerate.vDSP.WindowSequence, b: Accelerate.vDSP.WindowSequence) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
  }
  @inlinable public static func window<T>(ofType: T.Type, usingSequence sequence: Accelerate.vDSP.WindowSequence, count: Swift.Int, isHalfWindow: Swift.Bool) -> [T] where T : Accelerate.vDSP_FloatingPointGeneratable {
        
        precondition(count > 0)
        
        if T.self == Float.self {
            
            let result = Array<Float>(unsafeUninitializedCapacity: count) {
                buffer, initializedCount in
                
                formWindow(usingSequence: sequence,
                           result: &buffer,
                           isHalfWindow: isHalfWindow)
                
                initializedCount = count
            }
            return result as! [T]
            
        } else if T.self == Double.self {
            
            let result = Array<Double>(unsafeUninitializedCapacity: count) {
                buffer, initializedCount in
                
                formWindow(usingSequence: sequence,
                           result: &buffer,
                           isHalfWindow: isHalfWindow)
                
                initializedCount = count
            }
            return result as! [T]
            
        } else {
            fatalError("This operation only supports `Float` and `Double` types.")
        }
    }
  public static func formWindow<V>(usingSequence sequence: Accelerate.vDSP.WindowSequence, result: inout V, isHalfWindow: Swift.Bool) where V : Accelerate.AccelerateMutableBuffer, V.Element == Swift.Float
  public static func formWindow<V>(usingSequence sequence: Accelerate.vDSP.WindowSequence, result: inout V, isHalfWindow: Swift.Bool) where V : Accelerate.AccelerateMutableBuffer, V.Element == Swift.Double
  @inlinable public static func ramp(withInitialValue initialValue: Swift.Float, increment: Swift.Float, count: Swift.Int) -> [Swift.Float] {
        
        precondition(count > 0)
        
        let result = Array<Float>(unsafeUninitializedCapacity: count) {
            buffer, initializedCount in
            
            formRamp(withInitialValue: initialValue,
                     increment: increment,
                     result: &buffer)
            
            initializedCount = count
        }
        
        return result
    }
  @inlinable public static func formRamp<V>(withInitialValue initialValue: Swift.Float, increment: Swift.Float, result: inout V) where V : Accelerate.AccelerateMutableBuffer, V.Element == Swift.Float {
            
            let n = vDSP_Length(result.count)
            
            withUnsafePointer(to: initialValue) { a in
                withUnsafePointer(to: increment) { b in
                    result.withUnsafeMutableBufferPointer { c in
                        vDSP_vramp(a,
                                   b,
                                   c.baseAddress!, 1,
                                   n)
                    }
                }
            }
    }
  @inlinable public static func ramp(withInitialValue initialValue: Swift.Double, increment: Swift.Double, count: Swift.Int) -> [Swift.Double] {
        
        precondition(count > 0)
        
        let result = Array<Double>(unsafeUninitializedCapacity: count) {
            buffer, initializedCount in
            
            formRamp(withInitialValue: initialValue,
                     increment: increment,
                     result: &buffer)
            
            initializedCount = count
        }
        
        return result
    }
  @inlinable public static func formRamp<V>(withInitialValue initialValue: Swift.Double, increment: Swift.Double, result: inout V) where V : Accelerate.AccelerateMutableBuffer, V.Element == Swift.Double {
            
            let n = vDSP_Length(result.count)
            
            withUnsafePointer(to: initialValue) { a in
                withUnsafePointer(to: increment) { b in
                    result.withUnsafeMutableBufferPointer { c in
                        vDSP_vrampD(a,
                                    b,
                                    c.baseAddress!, 1,
                                    n)
                    }
                }
            }
    }
  @inlinable public static func ramp(in range: Swift.ClosedRange<Swift.Float>, count: Swift.Int) -> [Swift.Float] {
        
        precondition(count > 0)
        
        let result = Array<Float>(unsafeUninitializedCapacity: count) {
            buffer, initializedCount in
            
            formRamp(in: range,
                     result: &buffer)
            
            initializedCount = count
        }
        
        return result
    }
  @inlinable public static func formRamp<V>(in range: Swift.ClosedRange<Swift.Float>, result: inout V) where V : Accelerate.AccelerateMutableBuffer, V.Element == Swift.Float {
            
            let n = vDSP_Length(result.count)
            
            withUnsafePointer(to: range.lowerBound) { a in
                withUnsafePointer(to: range.upperBound) { b in
                    result.withUnsafeMutableBufferPointer { c in
                        vDSP_vgen(a,
                                  b,
                                  c.baseAddress!, 1,
                                  n)
                    }
                }
            }
    }
  @inlinable public static func ramp(in range: Swift.ClosedRange<Swift.Double>, count: Swift.Int) -> [Swift.Double] {
        
        precondition(count > 0)
        
        let result = Array<Double>(unsafeUninitializedCapacity: count) {
            buffer, initializedCount in
            
            formRamp(in: range,
                     result: &buffer)
            
            initializedCount = count
        }
        
        return result
    }
  @inlinable public static func formRamp<V>(in range: Swift.ClosedRange<Swift.Double>, result: inout V) where V : Accelerate.AccelerateMutableBuffer, V.Element == Swift.Double {
            
            let n = vDSP_Length(result.count)
            
            withUnsafePointer(to: range.lowerBound) { a in
                withUnsafePointer(to: range.upperBound) { b in
                    result.withUnsafeMutableBufferPointer { c in
                        vDSP_vgenD(a,
                                   b,
                                   c.baseAddress!, 1,
                                   n)
                    }
                }
            }
    }
  @inlinable public static func ramp<U>(withInitialValue initialValue: inout Swift.Float, multiplyingBy vector: U, increment: Swift.Float) -> [Swift.Float] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Float {
            
            let result = Array<Float>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                formRamp(withInitialValue: &initialValue,
                         multiplyingBy: vector,
                         increment: increment,
                         result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func formRamp<U, V>(withInitialValue initialValue: inout Swift.Float, multiplyingBy vector: U, increment: Swift.Float, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Float, V.Element == Swift.Float {
            
            precondition(vector.count == result.count)
            let n = vDSP_Length(result.count)
            
            result.withUnsafeMutableBufferPointer { dest in
                vector.withUnsafeBufferPointer { src in
                    withUnsafePointer(to: increment) { step in
                        vDSP_vrampmul(src.baseAddress!, 1,
                                      &initialValue,
                                      step,
                                      dest.baseAddress!, 1,
                                      n)
                    }
                }
            }
    }
  @inlinable public static func ramp<U>(withInitialValue initialValue: inout Swift.Double, multiplyingBy vector: U, increment: Swift.Double) -> [Swift.Double] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Double {
            
            let result = Array<Double>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                formRamp(withInitialValue: &initialValue,
                         multiplyingBy: vector,
                         increment: increment,
                         result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func formRamp<U, V>(withInitialValue initialValue: inout Swift.Double, multiplyingBy vector: U, increment: Swift.Double, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Double, V.Element == Swift.Double {
            
            precondition(vector.count == result.count)
            let n = vDSP_Length(result.count)
            
            result.withUnsafeMutableBufferPointer { dest in
                vector.withUnsafeBufferPointer { src in
                    withUnsafePointer(to: increment) { step in
                        vDSP_vrampmulD(src.baseAddress!, 1,
                                       &initialValue,
                                       step,
                                       dest.baseAddress!, 1,
                                       n)
                    }
                }
            }
    }
  @inlinable public static func stereoRamp<U>(withInitialValue initialValue: inout Swift.Float, multiplyingBy multiplierOne: U, _ multiplierTwo: U, increment: Swift.Float) -> (firstOutput: [Swift.Float], secondOutput: [Swift.Float]) where U : Accelerate.AccelerateBuffer, U.Element == Swift.Float {
            
            let n = multiplierOne.count
            
            var firstOutput: Array<Float>!
            
            let secondOutput = Array<Float>(unsafeUninitializedCapacity: n) {
                secondBuffer, secondInitializedCount in
                
                firstOutput = Array<Float>(unsafeUninitializedCapacity: n) {
                    firstBuffer, firstInitializedCount in
                    
                    formStereoRamp(withInitialValue: &initialValue,
                                   multiplyingBy: multiplierOne, multiplierTwo,
                                   increment: increment,
                                   results: &firstBuffer, &secondBuffer)
                    
                    firstInitializedCount = n
                }
                
                secondInitializedCount = n
            }
            
            return (firstOutput: firstOutput,
                    secondOutput: secondOutput)
    }
  @inlinable public static func formStereoRamp<U, V>(withInitialValue initialValue: inout Swift.Float, multiplyingBy multiplierOne: U, _ multiplierTwo: U, increment: Swift.Float, results resultOne: inout V, _ resultTwo: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Float, V.Element == Swift.Float {
            
            precondition(multiplierOne.count == multiplierTwo.count)
            precondition(resultOne.count == resultTwo.count)
            precondition(multiplierOne.count == resultOne.count)
            let n = vDSP_Length(resultTwo.count)
            
            resultOne.withUnsafeMutableBufferPointer { o0 in
                resultTwo.withUnsafeMutableBufferPointer { o1 in
                    multiplierOne.withUnsafeBufferPointer { i0 in
                        multiplierTwo.withUnsafeBufferPointer { i1 in
                            withUnsafePointer(to: increment) { step in
                                vDSP_vrampmul2(i0.baseAddress!,
                                               i1.baseAddress!, 1,
                                               &initialValue,
                                               step,
                                               o0.baseAddress!,
                                               o1.baseAddress!, 1,
                                               n)
                            }
                        }
                    }
                }
            }
    }
  @inlinable public static func stereoRamp<U>(withInitialValue initialValue: inout Swift.Double, multiplyingBy multiplierOne: U, _ multiplierTwo: U, increment: Swift.Double) -> (firstOutput: [Swift.Double], secondOutput: [Swift.Double]) where U : Accelerate.AccelerateBuffer, U.Element == Swift.Double {
            
            let n = multiplierOne.count
            
            var firstOutput: Array<Double>!
            
            let secondOutput = Array<Double>(unsafeUninitializedCapacity: n) {
                secondBuffer, secondInitializedCount in
                
                firstOutput = Array<Double>(unsafeUninitializedCapacity: n) {
                    firstBuffer, firstInitializedCount in
                    
                    formStereoRamp(withInitialValue: &initialValue,
                                   multiplyingBy: multiplierOne, multiplierTwo,
                                   increment: increment,
                                   results: &firstBuffer, &secondBuffer)
                    
                    firstInitializedCount = n
                }
                
                secondInitializedCount = n
            }
            
            return (firstOutput: firstOutput,
                    secondOutput: secondOutput)
    }
  @inlinable public static func formStereoRamp<U, V>(withInitialValue initialValue: inout Swift.Double, multiplyingBy multiplierOne: U, _ multiplierTwo: U, increment: Swift.Double, results resultOne: inout V, _ resultTwo: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Double, V.Element == Swift.Double {
            
            precondition(multiplierOne.count == multiplierTwo.count)
            precondition(resultOne.count == resultTwo.count)
            precondition(multiplierOne.count == resultOne.count)
            let n = vDSP_Length(resultTwo.count)
            
            resultOne.withUnsafeMutableBufferPointer { o0 in
                resultTwo.withUnsafeMutableBufferPointer { o1 in
                    multiplierOne.withUnsafeBufferPointer { i0 in
                        multiplierTwo.withUnsafeBufferPointer { i1 in
                            withUnsafePointer(to: increment) { step in
                                vDSP_vrampmul2D(i0.baseAddress!,
                                                i1.baseAddress!, 1,
                                                &initialValue,
                                                step,
                                                o0.baseAddress!,
                                                o1.baseAddress!, 1,
                                                n)
                            }
                        }
                    }
                }
            }
    }
}
@available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension vDSP {
  @inlinable public static func dot<U>(_ vectorA: U, _ vectorB: U) -> Swift.Float where U : Accelerate.AccelerateBuffer, U.Element == Swift.Float {
            
            precondition(vectorA.count == vectorB.count)
            
            let n = vDSP_Length(vectorA.count)
            var result = Float.nan
            
            vectorA.withUnsafeBufferPointer { a in
                vectorB.withUnsafeBufferPointer { b in
                    
                    vDSP_dotpr(a.baseAddress!, 1,
                               b.baseAddress!, 1,
                               &result, n)
                    
                }
            }
            
            return result
    }
  @inlinable public static func dot<U>(_ vectorA: U, _ vectorB: U) -> Swift.Double where U : Accelerate.AccelerateBuffer, U.Element == Swift.Double {
            
            precondition(vectorA.count == vectorB.count)
            
            let n = vDSP_Length(vectorA.count)
            var result = Double.nan
            
            vectorA.withUnsafeBufferPointer { a in
                vectorB.withUnsafeBufferPointer { b in
                    
                    vDSP_dotprD(a.baseAddress!, 1,
                                b.baseAddress!, 1,
                                &result, n)
                    
                }
            }
            
            return result
    }
  @inlinable public static func hypot<U, V>(_ x: U, _ y: V) -> [Swift.Float] where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateBuffer, U.Element == Swift.Float, V.Element == Swift.Float {
            
            precondition(x.count == y.count)
            
            let result = Array<Float>(unsafeUninitializedCapacity: x.count) {
                buffer, initializedCount in
                
                hypot(x, y,
                     result: &buffer)
                
                initializedCount = x.count
            }
            
            return result
    }
  @inlinable public static func hypot<T, U, V>(_ x: T, _ y: U, result: inout V) where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, T.Element == Swift.Float, U.Element == Swift.Float, V.Element == Swift.Float {
            
            precondition(x.count == y.count && y.count == result.count)
            let n = vDSP_Length(result.count)
            
            x.withUnsafeBufferPointer { a in
                y.withUnsafeBufferPointer { b in
                    result.withUnsafeMutableBufferPointer { dest in
                        vDSP_vdist(a.baseAddress!, 1,
                                   b.baseAddress!, 1,
                                   dest.baseAddress!, 1,
                                   n)
                    }
                }
            }
    }
  @inlinable public static func hypot<U, V>(_ x: U, _ y: V) -> [Swift.Double] where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateBuffer, U.Element == Swift.Double, V.Element == Swift.Double {
            
            precondition(x.count == y.count)
            
            let result = Array<Double>(unsafeUninitializedCapacity: x.count) {
                buffer, initializedCount in
                
                hypot(x, y,
                      result: &buffer)
                
                initializedCount = x.count
            }
            
            return result
    }
  @inlinable public static func hypot<T, U, V>(_ x: T, _ y: U, result: inout V) where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, T.Element == Swift.Double, U.Element == Swift.Double, V.Element == Swift.Double {
            
            precondition(x.count == y.count && y.count == result.count)
            let n = vDSP_Length(result.count)
            
            x.withUnsafeBufferPointer { a in
                y.withUnsafeBufferPointer { b in
                    result.withUnsafeMutableBufferPointer { dest in
                        vDSP_vdistD(a.baseAddress!, 1,
                                    b.baseAddress!, 1,
                                    dest.baseAddress!, 1,
                                    n)
                    }
                }
            }
    }
  @inlinable public static func hypot<R, S, T, U>(x0: R, x1: S, y0: T, y1: U) -> [Swift.Float] where R : Accelerate.AccelerateBuffer, S : Accelerate.AccelerateBuffer, T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, R.Element == Swift.Float, S.Element == Swift.Float, T.Element == Swift.Float, U.Element == Swift.Float {
            
            precondition(x0.count == x1.count)
            precondition(y0.count == y1.count)
            precondition(x0.count == y0.count)
            
            let result = Array<Float>(unsafeUninitializedCapacity: x0.count) {
                buffer, initializedCount in
                
                hypot(x0: x0, x1: x1,
                      y0: y0, y1: y1,
                      result: &buffer)
                
                initializedCount = x0.count
            }
            
            return result
    }
  @inlinable public static func hypot<R, S, T, U, V>(x0: R, x1: S, y0: T, y1: U, result: inout V) where R : Accelerate.AccelerateBuffer, S : Accelerate.AccelerateBuffer, T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, R.Element == Swift.Float, S.Element == Swift.Float, T.Element == Swift.Float, U.Element == Swift.Float, V.Element == Swift.Float {
            
            precondition(x0.count == x1.count && x0.count == result.count)
            precondition(y0.count == y1.count && y0.count == result.count)
            
            let n = vDSP_Length(result.count)
            
            x0.withUnsafeBufferPointer { a in
                x1.withUnsafeBufferPointer { c in
                    y0.withUnsafeBufferPointer { b in
                        y1.withUnsafeBufferPointer { d in
                            result.withUnsafeMutableBufferPointer { dest in
                                vDSP_vpythg(a.baseAddress!, 1,
                                            b.baseAddress!, 1,
                                            c.baseAddress!, 1,
                                            d.baseAddress!, 1,
                                            dest.baseAddress!, 1,
                                            n)
                            }
                        }
                    }
                }
            }
    }
  @inlinable public static func hypot<R, S, T, U>(x0: R, x1: S, y0: T, y1: U) -> [Swift.Double] where R : Accelerate.AccelerateBuffer, S : Accelerate.AccelerateBuffer, T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, R.Element == Swift.Double, S.Element == Swift.Double, T.Element == Swift.Double, U.Element == Swift.Double {
            
            precondition(x0.count == x1.count)
            precondition(y0.count == y1.count)
            precondition(x0.count == y0.count)
            
            let result = Array<Double>(unsafeUninitializedCapacity: x0.count) {
                buffer, initializedCount in
                
                hypot(x0: x0, x1: x1,
                      y0: y0, y1: y1,
                      result: &buffer)
                
                initializedCount = x0.count
            }
            
            return result
    }
  @inlinable public static func hypot<R, S, T, U, V>(x0: R, x1: S, y0: T, y1: U, result: inout V) where R : Accelerate.AccelerateBuffer, S : Accelerate.AccelerateBuffer, T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, R.Element == Swift.Double, S.Element == Swift.Double, T.Element == Swift.Double, U.Element == Swift.Double, V.Element == Swift.Double {
            
            precondition(x0.count == x1.count && x0.count == result.count)
            precondition(y0.count == y1.count && y0.count == result.count)
            
            let n = vDSP_Length(result.count)
            
            x0.withUnsafeBufferPointer { a in
                x1.withUnsafeBufferPointer { c in
                    y0.withUnsafeBufferPointer { b in
                        y1.withUnsafeBufferPointer { d in
                            result.withUnsafeMutableBufferPointer { dest in
                                vDSP_vpythgD(a.baseAddress!, 1,
                                             b.baseAddress!, 1,
                                             c.baseAddress!, 1,
                                             d.baseAddress!, 1,
                                             dest.baseAddress!, 1,
                                             n)
                            }
                        }
                    }
                }
            }
    }
  @inlinable public static func distanceSquared<U, V>(_ pointA: U, _ pointB: V) -> Swift.Float where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Float, V.Element == Swift.Float {
            
            precondition(pointA.count == pointB.count)
            
            let n = vDSP_Length(pointA.count)
            var result = Float.nan
            
            pointA.withUnsafeBufferPointer { a in
                pointB.withUnsafeBufferPointer { b in
                    vDSP_distancesq(a.baseAddress!, 1,
                                    b.baseAddress!, 1,
                                    &result,
                                    n)
                }
            }
            
            return result
    }
  @inlinable public static func distanceSquared<U, V>(_ pointA: U, _ pointB: V) -> Swift.Double where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Double, V.Element == Swift.Double {
            
            precondition(pointA.count == pointB.count)
            
            let n = vDSP_Length(pointA.count)
            var result = Double.nan
            
            pointA.withUnsafeBufferPointer { a in
                pointB.withUnsafeBufferPointer { b in
                    vDSP_distancesqD(a.baseAddress!, 1,
                                     b.baseAddress!, 1,
                                     &result,
                                     n)
                }
            }
            
            return result
    }
}
@available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension vDSP {
  public enum IntegrationRule {
    case runningSum
    case simpson
    case trapezoidal
    public static func == (a: Accelerate.vDSP.IntegrationRule, b: Accelerate.vDSP.IntegrationRule) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
  }
  @inlinable public static func integrate<U>(_ vector: U, using rule: Accelerate.vDSP.IntegrationRule, stepSize: Swift.Float = 1) -> [Swift.Float] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Float {
            
            let result = Array<Float>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                integrate(vector,
                          using: rule,
                          result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  public static func integrate<U, V>(_ vector: U, using rule: Accelerate.vDSP.IntegrationRule, stepSize: Swift.Float = 1, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Float, V.Element == Swift.Float
  @inlinable public static func integrate<U>(_ vector: U, using rule: Accelerate.vDSP.IntegrationRule, stepSize: Swift.Double = 1) -> [Swift.Double] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Double {
            
            let result = Array<Double>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                integrate(vector,
                          using: rule,
                          result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  public static func integrate<U, V>(_ vector: U, using rule: Accelerate.vDSP.IntegrationRule, stepSize: Swift.Double = 1, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Double, V.Element == Swift.Double
}
@available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension vDSP {
  @inlinable public static func linearInterpolate<T, U>(_ vectorA: T, _ vectorB: U, using interpolationConstant: Swift.Float) -> [Swift.Float] where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, T.Element == Swift.Float, U.Element == Swift.Float {
            
            let result = Array<Float>(unsafeUninitializedCapacity: vectorA.count) {
                buffer, initializedCount in
                
                linearInterpolate(vectorA,
                                  vectorB,
                                  using: interpolationConstant,
                                  result: &buffer)
                
                initializedCount = vectorA.count
            }
            
            return result
    }
  @inlinable public static func linearInterpolate<T, U, V>(_ vectorA: T, _ vectorB: U, using interpolationConstant: Swift.Float, result: inout V) where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, T.Element == Swift.Float, U.Element == Swift.Float, V.Element == Swift.Float {
            
            precondition(vectorA.count == result.count)
            precondition(vectorB.count == result.count)
            let n = vDSP_Length(result.count)
            
            vectorA.withUnsafeBufferPointer { a in
                vectorB.withUnsafeBufferPointer { b in
                    result.withUnsafeMutableBufferPointer { dest in
                        
                        vDSP_vintb(a.baseAddress!, 1,
                                   b.baseAddress!, 1,
                                   [interpolationConstant],
                                   dest.baseAddress!, 1,
                                   n)
                    }
                }
            }
    }
  @inlinable public static func linearInterpolate<T, U>(_ vectorA: T, _ vectorB: U, using interpolationConstant: Swift.Double) -> [Swift.Double] where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, T.Element == Swift.Double, U.Element == Swift.Double {
            
            let result = Array<Double>(unsafeUninitializedCapacity: vectorA.count) {
                buffer, initializedCount in
                
                linearInterpolate(vectorA,
                                  vectorB,
                                  using: interpolationConstant,
                                  result: &buffer)
                
                initializedCount = vectorA.count
            }
            
            return result
    }
  @inlinable public static func linearInterpolate<T, U, V>(_ vectorA: T, _ vectorB: U, using interpolationConstant: Swift.Double, result: inout V) where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, T.Element == Swift.Double, U.Element == Swift.Double, V.Element == Swift.Double {
            
            precondition(vectorA.count == result.count)
            precondition(vectorB.count == result.count)
            let n = vDSP_Length(result.count)
            
            vectorA.withUnsafeBufferPointer { a in
                vectorB.withUnsafeBufferPointer { b in
                    result.withUnsafeMutableBufferPointer { dest in
                        
                        vDSP_vintbD(a.baseAddress!, 1,
                                    b.baseAddress!, 1,
                                    [interpolationConstant],
                                    dest.baseAddress!, 1,
                                    n)
                    }
                }
            }
    }
  @inlinable public static func linearInterpolate<T, U>(elementsOf vector: T, using controlVector: U) -> [Swift.Float] where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, T.Element == Swift.Float, U.Element == Swift.Float {
            
            let result = Array<Float>(unsafeUninitializedCapacity: controlVector.count) {
                buffer, initializedCount in
                
                linearInterpolate(elementsOf: vector,
                                  using: controlVector,
                                  result: &buffer)
                
                initializedCount = controlVector.count
            }
            
            return result
    }
  @inlinable public static func linearInterpolate<T, U, V>(elementsOf vector: T, using controlVector: U, result: inout V) where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, T.Element == Swift.Float, U.Element == Swift.Float, V.Element == Swift.Float {
            
            precondition(controlVector.count == result.count)
            
            let n = vDSP_Length(result.count)
            let m = vDSP_Length(vector.count)
            
            vector.withUnsafeBufferPointer { a in
                controlVector.withUnsafeBufferPointer { b in
                    result.withUnsafeMutableBufferPointer { dest in
                        vDSP_vlint(a.baseAddress!,
                                   b.baseAddress!, 1,
                                   dest.baseAddress!, 1,
                                   n, m)
                    }
                }
            }
    }
  @inlinable public static func linearInterpolate<T, U>(elementsOf vector: T, using controlVector: U) -> [Swift.Double] where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, T.Element == Swift.Double, U.Element == Swift.Double {
            
            let result = Array<Double>(unsafeUninitializedCapacity: controlVector.count) {
                buffer, initializedCount in
                
                linearInterpolate(elementsOf: vector,
                                  using: controlVector,
                                  result: &buffer)
                
                initializedCount = controlVector.count
            }
            
            return result
    }
  @inlinable public static func linearInterpolate<T, U, V>(elementsOf vector: T, using controlVector: U, result: inout V) where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, T.Element == Swift.Double, U.Element == Swift.Double, V.Element == Swift.Double {
            
            precondition(controlVector.count == result.count)
            
            let n = vDSP_Length(result.count)
            let m = vDSP_Length(vector.count)
            
            vector.withUnsafeBufferPointer { a in
                controlVector.withUnsafeBufferPointer { b in
                    result.withUnsafeMutableBufferPointer { dest in
                        vDSP_vlintD(a.baseAddress!,
                                    b.baseAddress!, 1,
                                    dest.baseAddress!, 1,
                                    n, m)
                    }
                }
            }
    }
}
@available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension vDSP {
  @inlinable public static func rectangularToPolar<U>(_ rectangularCoordinates: U) -> [Swift.Float] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Float {
            
            let result = Array<Float>(unsafeUninitializedCapacity: rectangularCoordinates.count) {
                buffer, initializedCount in
                
                convert(rectangularCoordinates: rectangularCoordinates,
                        toPolarCoordinates: &buffer)
                
                initializedCount = rectangularCoordinates.count
            }
            
            return result
    }
  @inlinable public static func convert<U, V>(rectangularCoordinates: U, toPolarCoordinates polarCoordinates: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Float, V.Element == Swift.Float {
            
            let n = rectangularCoordinates.count
            precondition(polarCoordinates.count == n)
            
            polarCoordinates.withUnsafeMutableBufferPointer { dest in
                rectangularCoordinates.withUnsafeBufferPointer { src in
                    vDSP_polar(src.baseAddress!, 2,
                               dest.baseAddress!, 2,
                               vDSP_Length(n / 2))
                }
            }
    }
  @inlinable public static func rectangularToPolar<U>(_ rectangularCoordinates: U) -> [Swift.Double] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Double {
            
            let result = Array<Double>(unsafeUninitializedCapacity: rectangularCoordinates.count) {
                buffer, initializedCount in
                
                convert(rectangularCoordinates: rectangularCoordinates,
                        toPolarCoordinates: &buffer)
                
                initializedCount = rectangularCoordinates.count
            }
            
            return result
    }
  @inlinable public static func convert<U, V>(rectangularCoordinates: U, toPolarCoordinates polarCoordinates: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Double, V.Element == Swift.Double {
            
            let n = rectangularCoordinates.count
            precondition(polarCoordinates.count == n)
            
            polarCoordinates.withUnsafeMutableBufferPointer { dest in
                rectangularCoordinates.withUnsafeBufferPointer { src in
                    vDSP_polarD(src.baseAddress!, 2,
                                dest.baseAddress!, 2,
                                vDSP_Length(n / 2))
                }
            }
    }
  @inlinable public static func polarToRectangular<U>(_ polarCoordinates: U) -> [Swift.Float] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Float {
            
            let result = Array<Float>(unsafeUninitializedCapacity: polarCoordinates.count) {
                buffer, initializedCount in
                
                convert(polarCoordinates: polarCoordinates,
                        toRectangularCoordinates: &buffer)
                
                initializedCount = polarCoordinates.count
            }
            
            return result
    }
  @inlinable public static func convert<U, V>(polarCoordinates: U, toRectangularCoordinates rectangularCoordinates: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Float, V.Element == Swift.Float {
            
            let n = rectangularCoordinates.count
            precondition(polarCoordinates.count == n)
            
            rectangularCoordinates.withUnsafeMutableBufferPointer { dest in
                polarCoordinates.withUnsafeBufferPointer { src in
                    vDSP_rect(src.baseAddress!, 2,
                              dest.baseAddress!, 2,
                              vDSP_Length(n / 2))
                }
            }
    }
  @inlinable public static func polarToRectangular<U>(_ polarCoordinates: U) -> [Swift.Double] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Double {
            
            let result = Array<Double>(unsafeUninitializedCapacity: polarCoordinates.count) {
                buffer, initializedCount in
                
                convert(polarCoordinates: polarCoordinates,
                        toRectangularCoordinates: &buffer)
                
                initializedCount = polarCoordinates.count
            }
            
            return result
    }
  @inlinable public static func convert<U, V>(polarCoordinates: U, toRectangularCoordinates rectangularCoordinates: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Double, V.Element == Swift.Double {
            
            let n = rectangularCoordinates.count
            precondition(polarCoordinates.count == n)
            
            rectangularCoordinates.withUnsafeMutableBufferPointer { dest in
                polarCoordinates.withUnsafeBufferPointer { src in
                    vDSP_rectD(src.baseAddress!, 2,
                               dest.baseAddress!, 2,
                               vDSP_Length(n / 2))
                }
            }
    }
}
@available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension vDSP {
  @inlinable public static func evaluatePolynomial<U>(usingCoefficients coefficients: [Swift.Float], withVariables variables: U) -> [Swift.Float] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Float {
            
            let result = Array<Float>(unsafeUninitializedCapacity: variables.count) {
                buffer, initializedCount in
                
                evaluatePolynomial(usingCoefficients: coefficients,
                                   withVariables: variables,
                                   result: &buffer)
                
                initializedCount = variables.count
            }
            
            return result
    }
  @inlinable public static func evaluatePolynomial<U, V>(usingCoefficients coefficients: [Swift.Float], withVariables variables: U, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Float, V.Element == Swift.Float {
            
            let n = vDSP_Length(min(variables.count,
                                    result.count))
            
            let degreeOfPolynomial = vDSP_Length(coefficients.count - 1)
            
            result.withUnsafeMutableBufferPointer { dest in
                variables.withUnsafeBufferPointer { src in
                    vDSP_vpoly(coefficients, 1,
                               src.baseAddress!, 1,
                               dest.baseAddress!, 1,
                               n,
                               degreeOfPolynomial)
                }
            }
    }
  @inlinable public static func evaluatePolynomial<U>(usingCoefficients coefficients: [Swift.Double], withVariables variables: U) -> [Swift.Double] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Double {
            
            let result = Array<Double>(unsafeUninitializedCapacity: variables.count) {
                buffer, initializedCount in
                
                evaluatePolynomial(usingCoefficients: coefficients,
                                   withVariables: variables,
                                   result: &buffer)
                
                initializedCount = variables.count
            }
            
            return result
    }
  @inlinable public static func evaluatePolynomial<U, V>(usingCoefficients coefficients: [Swift.Double], withVariables variables: U, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Double, V.Element == Swift.Double {
            
            let n = vDSP_Length(min(variables.count,
                                    result.count))
            
            let degreeOfPolynomial = vDSP_Length(coefficients.count - 1)
            
            result.withUnsafeMutableBufferPointer { dest in
                variables.withUnsafeBufferPointer { src in
                    vDSP_vpolyD(coefficients, 1,
                                src.baseAddress!, 1,
                                dest.baseAddress!, 1,
                                n,
                                degreeOfPolynomial)
                }
            }
    }
}
@available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension vDSP {
  @inlinable public static func twoPoleTwoZeroFilter<U>(_ source: U, coefficients: (Swift.Float, Swift.Float, Swift.Float, Swift.Float, Swift.Float)) -> [Swift.Float] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Float {
            
            let result = Array<Float>(unsafeUninitializedCapacity: source.count) {
                buffer, initializedCount in
                
                buffer[0] = 0
                buffer[1] = 0
                
                twoPoleTwoZeroFilter(source,
                                     coefficients: coefficients,
                                     result: &buffer)
                
                initializedCount = source.count
            }
            
            return result
    }
  @inlinable public static func twoPoleTwoZeroFilter<U, V>(_ source: U, coefficients: (Swift.Float, Swift.Float, Swift.Float, Swift.Float, Swift.Float), result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Float, V.Element == Swift.Float {
            
            precondition(source.count == result.count)
            
            let n = vDSP_Length(source.count - 2)
            
            result.withUnsafeMutableBufferPointer { dest in
                source.withUnsafeBufferPointer { src in
                    vDSP_deq22(src.baseAddress!, 1,
                               [coefficients.0, coefficients.1,
                                coefficients.2, coefficients.3,
                                coefficients.4],
                               dest.baseAddress!, 1,
                               n)
                }
            }
    }
  @inlinable public static func twoPoleTwoZeroFilter<U>(_ source: U, coefficients: (Swift.Double, Swift.Double, Swift.Double, Swift.Double, Swift.Double)) -> [Swift.Double] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Double {
            
            let result = Array<Double>(unsafeUninitializedCapacity: source.count) {
                buffer, initializedCount in
                
                buffer[0] = 0
                buffer[1] = 0
                
                twoPoleTwoZeroFilter(source,
                                     coefficients: coefficients,
                                     result: &buffer)
                
                initializedCount = source.count
            }
            
            return result
    }
  @inlinable public static func twoPoleTwoZeroFilter<U, V>(_ source: U, coefficients: (Swift.Double, Swift.Double, Swift.Double, Swift.Double, Swift.Double), result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Double, V.Element == Swift.Double {
            
            precondition(source.count == result.count)
            
            let n = vDSP_Length(source.count - 2)
            
            result.withUnsafeMutableBufferPointer { dest in
                source.withUnsafeBufferPointer { src in
                    vDSP_deq22D(src.baseAddress!, 1,
                                [coefficients.0, coefficients.1,
                                 coefficients.2, coefficients.3,
                                 coefficients.4],
                                dest.baseAddress!, 1,
                                n)
                }
            }
    }
}
@available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension vDSP {
  @inlinable public static func maximum<U>(_ vector: U) -> Swift.Float where U : Accelerate.AccelerateBuffer, U.Element == Swift.Float {
            
            let n = vDSP_Length(vector.count)
            var output = Float.nan
            
            vector.withUnsafeBufferPointer { v in
                vDSP_maxv(v.baseAddress!, 1,
                          &output,
                          n)
            }
            
            return output
    }
  @inlinable public static func maximum<U>(_ vector: U) -> Swift.Double where U : Accelerate.AccelerateBuffer, U.Element == Swift.Double {
            
            let n = vDSP_Length(vector.count)
            var output = Double.nan
            
            vector.withUnsafeBufferPointer { v in
                vDSP_maxvD(v.baseAddress!, 1,
                           &output,
                           n)
            }
            
            return output
    }
  @inlinable public static func maximumMagnitude<U>(_ vector: U) -> Swift.Float where U : Accelerate.AccelerateBuffer, U.Element == Swift.Float {
            
            let n = vDSP_Length(vector.count)
            var output = Float.nan
            
            vector.withUnsafeBufferPointer { v in
                vDSP_maxmgv(v.baseAddress!, 1,
                            &output,
                            n)
            }
            
            return output
    }
  @inlinable public static func maximumMagnitude<U>(_ vector: U) -> Swift.Double where U : Accelerate.AccelerateBuffer, U.Element == Swift.Double {
            
            let n = vDSP_Length(vector.count)
            var output = Double.nan
            
            vector.withUnsafeBufferPointer { v in
                vDSP_maxmgvD(v.baseAddress!, 1,
                             &output,
                             n)
            }
            
            return output
    }
  @inlinable public static func minimum<U>(_ vector: U) -> Swift.Float where U : Accelerate.AccelerateBuffer, U.Element == Swift.Float {
            
            let n = vDSP_Length(vector.count)
            var output = Float.nan
            
            vector.withUnsafeBufferPointer { v in
                vDSP_minv(v.baseAddress!, 1,
                          &output,
                          n)
            }
            
            return output
    }
  @inlinable public static func minimum<U>(_ vector: U) -> Swift.Double where U : Accelerate.AccelerateBuffer, U.Element == Swift.Double {
            
            let n = vDSP_Length(vector.count)
            var output = Double.nan
            
            vector.withUnsafeBufferPointer { v in
                vDSP_minvD(v.baseAddress!, 1,
                           &output,
                           n)
            }
            
            return output
    }
  @inlinable public static func sum<U>(_ vector: U) -> Swift.Float where U : Accelerate.AccelerateBuffer, U.Element == Swift.Float {
            
            let n = vDSP_Length(vector.count)
            var output = Float.nan
            
            vector.withUnsafeBufferPointer { v in
                vDSP_sve(v.baseAddress!, 1,
                         &output,
                         n)
            }
            
            return output
    }
  @inlinable public static func sum<U>(_ vector: U) -> Swift.Double where U : Accelerate.AccelerateBuffer, U.Element == Swift.Double {
            
            let n = vDSP_Length(vector.count)
            var output = Double.nan
            
            vector.withUnsafeBufferPointer { v in
                vDSP_sveD(v.baseAddress!, 1,
                          &output,
                          n)
            }
            
            return output
    }
  @inlinable public static func sumOfSquares<U>(_ vector: U) -> Swift.Float where U : Accelerate.AccelerateBuffer, U.Element == Swift.Float {
            
            let n = vDSP_Length(vector.count)
            var output = Float.nan
            
            vector.withUnsafeBufferPointer { v in
                vDSP_svesq(v.baseAddress!, 1,
                           &output,
                           n)
            }
            
            return output
    }
  @inlinable public static func sumOfSquares<U>(_ vector: U) -> Swift.Double where U : Accelerate.AccelerateBuffer, U.Element == Swift.Double {
            
            let n = vDSP_Length(vector.count)
            var output = Double.nan
            
            vector.withUnsafeBufferPointer { v in
                vDSP_svesqD(v.baseAddress!, 1,
                            &output,
                            n)
            }
            
            return output
    }
  @inlinable public static func sumAndSumOfSquares<U>(_ vector: U) -> (elementsSum: Swift.Float, squaresSum: Swift.Float) where U : Accelerate.AccelerateBuffer, U.Element == Swift.Float {
            
            let n = vDSP_Length(vector.count)
            var sum = Float.nan
            var sumOfSquares = Float.nan
            
            vector.withUnsafeBufferPointer { v in
                vDSP_sve_svesq(v.baseAddress!, 1,
                               &sum,
                               &sumOfSquares,
                               n)
            }
            
            return (elementsSum: sum, squaresSum: sumOfSquares)
    }
  @inlinable public static func sumAndSumOfSquares<U>(_ vector: U) -> (elementsSum: Swift.Double, squaresSum: Swift.Double) where U : Accelerate.AccelerateBuffer, U.Element == Swift.Double {
            
            let n = vDSP_Length(vector.count)
            var sum = Double.nan
            var sumOfSquares = Double.nan
            
            vector.withUnsafeBufferPointer { v in
                vDSP_sve_svesqD(v.baseAddress!, 1,
                                &sum,
                                &sumOfSquares,
                                n)
            }
            
            return (elementsSum: sum, squaresSum: sumOfSquares)
    }
  @inlinable public static func sumOfMagnitudes<U>(_ vector: U) -> Swift.Float where U : Accelerate.AccelerateBuffer, U.Element == Swift.Float {
            
            let n = vDSP_Length(vector.count)
            var output = Float.nan
            
            vector.withUnsafeBufferPointer { v in
                vDSP_svemg(v.baseAddress!, 1,
                           &output,
                           n)
            }
            
            return output
    }
  @inlinable public static func sumOfMagnitudes<U>(_ vector: U) -> Swift.Double where U : Accelerate.AccelerateBuffer, U.Element == Swift.Double {
            
            let n = vDSP_Length(vector.count)
            var output = Double.nan
            
            vector.withUnsafeBufferPointer { v in
                vDSP_svemgD(v.baseAddress!, 1,
                            &output,
                            n)
            }
            
            return output
    }
}
@available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension vDSP {
  @inlinable public static func indexOfMaximum<U>(_ vector: U) -> (Swift.UInt, Swift.Float) where U : Accelerate.AccelerateBuffer, U.Element == Swift.Float {
            
            let n = vDSP_Length(vector.count)
            var output = Float.nan
            var index: vDSP_Length = 0
            
            vector.withUnsafeBufferPointer { v in
                vDSP_maxvi(v.baseAddress!, 1,
                           &output,
                           &index,
                           n)
            }
            
            return (index, output)
    }
  @inlinable public static func indexOfMaximum<U>(_ vector: U) -> (Swift.UInt, Swift.Double) where U : Accelerate.AccelerateBuffer, U.Element == Swift.Double {
            
            let n = vDSP_Length(vector.count)
            var output = Double.nan
            var index: vDSP_Length = 0
            
            vector.withUnsafeBufferPointer { v in
                vDSP_maxviD(v.baseAddress!, 1,
                            &output,
                            &index,
                            n)
            }
            
            return (index, output)
    }
  @inlinable public static func indexOfMaximumMagnitude<U>(_ vector: U) -> (Swift.UInt, Swift.Float) where U : Accelerate.AccelerateBuffer, U.Element == Swift.Float {
            
            let n = vDSP_Length(vector.count)
            var output = Float.nan
            var index: vDSP_Length = 0
            
            vector.withUnsafeBufferPointer { v in
                vDSP_maxmgvi(v.baseAddress!, 1,
                             &output,
                             &index,
                             n)
            }
            
            return (index, output)
    }
  @inlinable public static func indexOfMaximumMagnitude<U>(_ vector: U) -> (Swift.UInt, Swift.Double) where U : Accelerate.AccelerateBuffer, U.Element == Swift.Double {
            
            let n = vDSP_Length(vector.count)
            var output = Double.nan
            var index: vDSP_Length = 0
            
            vector.withUnsafeBufferPointer { v in
                vDSP_maxmgviD(v.baseAddress!, 1,
                              &output,
                              &index,
                              n)
            }
            
            return (index, output)
    }
  @inlinable public static func indexOfMinimum<U>(_ vector: U) -> (Swift.UInt, Swift.Float) where U : Accelerate.AccelerateBuffer, U.Element == Swift.Float {
            
            let n = vDSP_Length(vector.count)
            var output = Float.nan
            var index: vDSP_Length = 0
            
            vector.withUnsafeBufferPointer { v in
                vDSP_minvi(v.baseAddress!, 1,
                           &output,
                           &index,
                           n)
            }
            
            return (index, output)
    }
  @inlinable public static func indexOfMinimum<U>(_ vector: U) -> (Swift.UInt, Swift.Double) where U : Accelerate.AccelerateBuffer, U.Element == Swift.Double {
            
            let n = vDSP_Length(vector.count)
            var output = Double.nan
            var index: vDSP_Length = 0
            
            vector.withUnsafeBufferPointer { v in
                vDSP_minviD(v.baseAddress!, 1,
                            &output,
                            &index,
                            n)
            }
            
            return (index, output)
    }
}
@available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension vDSP {
  @inlinable public static func meanSquare<U>(_ vector: U) -> Swift.Float where U : Accelerate.AccelerateBuffer, U.Element == Swift.Float {
            
            let n = vDSP_Length(vector.count)
            var output = Float.nan
            
            vector.withUnsafeBufferPointer { v in
                vDSP_measqv(v.baseAddress!, 1,
                            &output,
                            n)
            }
            
            return output
    }
  @inlinable public static func meanSquare<U>(_ vector: U) -> Swift.Double where U : Accelerate.AccelerateBuffer, U.Element == Swift.Double {
            
            let n = vDSP_Length(vector.count)
            var output = Double.nan
            
            vector.withUnsafeBufferPointer { v in
                vDSP_measqvD(v.baseAddress!, 1,
                             &output,
                             n)
            }
            
            return output
    }
  @inlinable public static func meanMagnitude<U>(_ vector: U) -> Swift.Float where U : Accelerate.AccelerateBuffer, U.Element == Swift.Float {
            
            let n = vDSP_Length(vector.count)
            var output = Float.nan
            
            vector.withUnsafeBufferPointer { v in
                vDSP_meamgv(v.baseAddress!, 1,
                            &output,
                            n)
            }
            
            return output
    }
  @inlinable public static func meanMagnitude<U>(_ vector: U) -> Swift.Double where U : Accelerate.AccelerateBuffer, U.Element == Swift.Double {
            
            let n = vDSP_Length(vector.count)
            var output = Double.nan
            
            vector.withUnsafeBufferPointer { v in
                vDSP_meamgvD(v.baseAddress!, 1,
                             &output,
                             n)
            }
            
            return output
    }
  @inlinable public static func mean<U>(_ vector: U) -> Swift.Float where U : Accelerate.AccelerateBuffer, U.Element == Swift.Float {
            
            let n = vDSP_Length(vector.count)
            var output = Float.nan
            
            vector.withUnsafeBufferPointer { v in
                vDSP_meanv(v.baseAddress!, 1,
                           &output,
                           n)
            }
            
            return output
    }
  @inlinable public static func mean<U>(_ vector: U) -> Swift.Double where U : Accelerate.AccelerateBuffer, U.Element == Swift.Double {
            
            let n = vDSP_Length(vector.count)
            var output = Double.nan
            
            vector.withUnsafeBufferPointer { v in
                vDSP_meanvD(v.baseAddress!, 1,
                            &output,
                            n)
            }
            
            return output
    }
  @inlinable public static func rootMeanSquare<U>(_ vector: U) -> Swift.Float where U : Accelerate.AccelerateBuffer, U.Element == Swift.Float {
            
            let n = vDSP_Length(vector.count)
            var output = Float.nan
            
            vector.withUnsafeBufferPointer { v in
                vDSP_rmsqv(v.baseAddress!, 1,
                           &output,
                           n)
            }
            
            return output
    }
  @inlinable public static func rootMeanSquare<U>(_ vector: U) -> Swift.Double where U : Accelerate.AccelerateBuffer, U.Element == Swift.Double {
            
            let n = vDSP_Length(vector.count)
            var output = Double.nan
            
            vector.withUnsafeBufferPointer { v in
                vDSP_rmsqvD(v.baseAddress!, 1,
                            &output,
                            n)
            }
            
            return output
    }
}
@available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension vDSP {
  @inlinable public static func minimum<U>(_ vectorA: U, _ vectorB: U) -> [Swift.Float] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Float {
            precondition(vectorA.count == vectorB.count)
            
            let result = Array<Float>(unsafeUninitializedCapacity: vectorA.count) {
                buffer, initializedCount in
                
                minimum(vectorA,
                        vectorB,
                        result: &buffer)
                
                initializedCount = vectorA.count
            }
            
            return result
    }
  @inlinable public static func minimum<U, V>(_ vectorA: U, _ vectorB: U, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Float, V.Element == Swift.Float {
            
            let n = vDSP_Length(min(vectorA.count,
                                    vectorB.count,
                                    result.count))
            
            result.withUnsafeMutableBufferPointer { r in
                vectorA.withUnsafeBufferPointer { a in
                    vectorB.withUnsafeBufferPointer { b in
                        vDSP_vmin(a.baseAddress!, 1,
                                  b.baseAddress!, 1,
                                  r.baseAddress!, 1,
                                  n)
                    }
                }
            }
    }
  @inlinable public static func minimum<U>(_ vectorA: U, _ vectorB: U) -> [Swift.Double] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Double {
            precondition(vectorA.count == vectorB.count)
            
            let result = Array<Double>(unsafeUninitializedCapacity: vectorA.count) {
                buffer, initializedCount in
                
                minimum(vectorA,
                        vectorB,
                        result: &buffer)
                
                initializedCount = vectorA.count
            }
            
            return result
    }
  @inlinable public static func minimum<U, V>(_ vectorA: U, _ vectorB: U, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Double, V.Element == Swift.Double {
            
            let n = vDSP_Length(min(vectorA.count,
                                    vectorB.count,
                                    result.count))
            
            result.withUnsafeMutableBufferPointer { r in
                vectorA.withUnsafeBufferPointer { a in
                    vectorB.withUnsafeBufferPointer { b in
                        vDSP_vminD(a.baseAddress!, 1,
                                   b.baseAddress!, 1,
                                   r.baseAddress!, 1,
                                   n)
                    }
                }
            }
    }
  @inlinable public static func maximum<U>(_ vectorA: U, _ vectorB: U) -> [Swift.Float] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Float {
            precondition(vectorA.count == vectorB.count)
            
            let result = Array<Float>(unsafeUninitializedCapacity: vectorA.count) {
                buffer, initializedCount in
                
                maximum(vectorA,
                        vectorB,
                        result: &buffer)
                
                initializedCount = vectorA.count
            }
            
            return result
    }
  @inlinable public static func maximum<U, V>(_ vectorA: U, _ vectorB: U, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Float, V.Element == Swift.Float {
            
            let n = vDSP_Length(min(vectorA.count,
                                    vectorB.count,
                                    result.count))
            
            result.withUnsafeMutableBufferPointer { r in
                vectorA.withUnsafeBufferPointer { a in
                    vectorB.withUnsafeBufferPointer { b in
                        vDSP_vmax(a.baseAddress!, 1,
                                  b.baseAddress!, 1,
                                  r.baseAddress!, 1,
                                  n)
                    }
                }
            }
    }
  @inlinable public static func maximum<U>(_ vectorA: U, _ vectorB: U) -> [Swift.Double] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Double {
            precondition(vectorA.count == vectorB.count)
            
            let result = Array<Double>(unsafeUninitializedCapacity: vectorA.count) {
                buffer, initializedCount in
                
                maximum(vectorA,
                        vectorB,
                        result: &buffer)
                
                initializedCount = vectorA.count
            }
            
            return result
    }
  @inlinable public static func maximum<U, V>(_ vectorA: U, _ vectorB: U, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Double, V.Element == Swift.Double {
            
            let n = vDSP_Length(min(vectorA.count,
                                    vectorB.count,
                                    result.count))
            
            result.withUnsafeMutableBufferPointer { r in
                vectorA.withUnsafeBufferPointer { a in
                    vectorB.withUnsafeBufferPointer { b in
                        vDSP_vmaxD(a.baseAddress!, 1,
                                   b.baseAddress!, 1,
                                   r.baseAddress!, 1,
                                   n)
                    }
                }
            }
    }
}
@available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension vDSP {
  @inlinable public static func absolute<U>(_ vector: U) -> [Swift.Float] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Float {
            
            let result = Array<Float>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                absolute(vector,
                         result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func absolute<U, V>(_ vector: U, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Float, V.Element == Swift.Float {
            
            let n = result.count
            precondition(vector.count == n)
            result.withUnsafeMutableBufferPointer { r in
                vector.withUnsafeBufferPointer { v in
                    vDSP_vabs(v.baseAddress!, 1,
                              r.baseAddress!, 1,
                              vDSP_Length(n))
                }
            }
            
    }
  @inlinable public static func absolute<U>(_ vector: U) -> [Swift.Double] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Double {
            
            let result = Array<Double>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                absolute(vector,
                         result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func absolute<U, V>(_ vector: U, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Double, V.Element == Swift.Double {
            
            let n = result.count
            precondition(vector.count == n)
            result.withUnsafeMutableBufferPointer { r in
                vector.withUnsafeBufferPointer { v in
                    vDSP_vabsD(v.baseAddress!, 1,
                               r.baseAddress!, 1,
                               vDSP_Length(n))
                }
            }
    }
  @inlinable public static func negativeAbsolute<U>(_ vector: U) -> [Swift.Float] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Float {
            
            let result = Array<Float>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                negativeAbsolute(vector,
                                 result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func negativeAbsolute<U, V>(_ vector: U, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Float, V.Element == Swift.Float {
            
            let n = result.count
            precondition(vector.count == n)
            result.withUnsafeMutableBufferPointer { r in
                vector.withUnsafeBufferPointer { v in
                    vDSP_vnabs(v.baseAddress!, 1,
                               r.baseAddress!, 1,
                               vDSP_Length(n))
                }
            }
    }
  @inlinable public static func negativeAbsolute<U>(_ vector: U) -> [Swift.Double] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Double {
            
            let result = Array<Double>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                negativeAbsolute(vector,
                                 result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func negativeAbsolute<U, V>(_ vector: U, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Double, V.Element == Swift.Double {
            
            let n = result.count
            precondition(vector.count == n)
            result.withUnsafeMutableBufferPointer { r in
                vector.withUnsafeBufferPointer { v in
                    vDSP_vnabsD(v.baseAddress!, 1,
                                r.baseAddress!, 1,
                                vDSP_Length(n))
                }
            }
    }
  @inlinable public static func negative<U>(_ vector: U) -> [Swift.Float] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Float {
            
            let result = Array<Float>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                negative(vector,
                         result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func negative<U, V>(_ vector: U, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Float, V.Element == Swift.Float {
            
            let n = result.count
            precondition(vector.count == n)
            result.withUnsafeMutableBufferPointer { r in
                vector.withUnsafeBufferPointer { v in
                    vDSP_vneg(v.baseAddress!, 1,
                              r.baseAddress!, 1,
                              vDSP_Length(n))
                }
            }
    }
  @inlinable public static func negative<U>(_ vector: U) -> [Swift.Double] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Double {
            
            let result = Array<Double>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                negative(vector,
                         result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func negative<U, V>(_ vector: U, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Double, V.Element == Swift.Double {
            
            let n = result.count
            precondition(vector.count == n)
            result.withUnsafeMutableBufferPointer { r in
                vector.withUnsafeBufferPointer { v in
                    vDSP_vnegD(v.baseAddress!, 1,
                               r.baseAddress!, 1,
                               vDSP_Length(n))
                }
            }
    }
}
@available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension vDSP {
  @inlinable public static func reverse<V>(_ vector: inout V) where V : Accelerate.AccelerateMutableBuffer, V.Element == Swift.Float {
            
            let n = vDSP_Length(vector.count)
            
            vector.withUnsafeMutableBufferPointer { v in
                vDSP_vrvrs(v.baseAddress!, 1,
                           n)
            }
    }
  @inlinable public static func reverse<V>(_ vector: inout V) where V : Accelerate.AccelerateMutableBuffer, V.Element == Swift.Double {
            
            let n = vDSP_Length(vector.count)
            
            vector.withUnsafeMutableBufferPointer { v in
                vDSP_vrvrsD(v.baseAddress!, 1,
                            n)
            }
    }
  public enum SortOrder : Swift.Int32 {
    case ascending
    case descending
    public typealias RawValue = Swift.Int32
    public init?(rawValue: Swift.Int32)
    public var rawValue: Swift.Int32 {
      get
    }
  }
  @inlinable public static func sort<V>(_ vector: inout V, sortOrder: Accelerate.vDSP.SortOrder) where V : Accelerate.AccelerateMutableBuffer, V.Element == Swift.Float {
            
            let n = vDSP_Length(vector.count)
            
            vector.withUnsafeMutableBufferPointer { v in
                vDSP_vsort(v.baseAddress!,
                           n,
                           sortOrder.rawValue)
            }
    }
  @inlinable public static func sort<V>(_ vector: inout V, sortOrder: Accelerate.vDSP.SortOrder) where V : Accelerate.AccelerateMutableBuffer, V.Element == Swift.Double {
            
            let n = vDSP_Length(vector.count)
            
            vector.withUnsafeMutableBufferPointer { v in
                vDSP_vsortD(v.baseAddress!,
                            n,
                            sortOrder.rawValue)
            }
    }
}
@available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension vDSP {
  @inlinable public static func square<U>(_ vector: U) -> [Swift.Float] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Float {
            
            let result = Array<Float>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                square(vector,
                       result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func square<U, V>(_ vector: U, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Float, V.Element == Swift.Float {
            
            precondition(vector.count == result.count)
            
            let n = vDSP_Length(vector.count)
            
            result.withUnsafeMutableBufferPointer { dest in
                vector.withUnsafeBufferPointer { src in
                    vDSP_vsq(src.baseAddress!, 1,
                             dest.baseAddress!, 1,
                             n)
                }
            }
    }
  @inlinable public static func square<U>(_ vector: U) -> [Swift.Double] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Double {
            
            let result = Array<Double>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                square(vector,
                       result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func square<U, V>(_ vector: U, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Double, V.Element == Swift.Double {
            
            precondition(vector.count == result.count)
            
            let n = vDSP_Length(vector.count)
            
            result.withUnsafeMutableBufferPointer { dest in
                vector.withUnsafeBufferPointer { src in
                    vDSP_vsqD(src.baseAddress!, 1,
                              dest.baseAddress!, 1,
                              n)
                }
            }
    }
  @inlinable public static func signedSquare<U>(_ vector: U) -> [Swift.Float] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Float {
            
            let result = Array<Float>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                signedSquare(vector,
                             result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func signedSquare<U, V>(_ vector: U, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Float, V.Element == Swift.Float {
            
            precondition(vector.count == result.count)
            
            let n = vDSP_Length(vector.count)
            
            result.withUnsafeMutableBufferPointer { dest in
                vector.withUnsafeBufferPointer { src in
                    vDSP_vssq(src.baseAddress!, 1,
                              dest.baseAddress!, 1,
                              n)
                }
            }
    }
  @inlinable public static func signedSquare<U>(_ vector: U) -> [Swift.Double] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Double {
            
            let result = Array<Double>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                signedSquare(vector,
                             result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func signedSquare<U, V>(_ vector: U, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Double, V.Element == Swift.Double {
            
            precondition(vector.count == result.count)
            
            let n = vDSP_Length(vector.count)
            
            result.withUnsafeMutableBufferPointer { dest in
                vector.withUnsafeBufferPointer { src in
                    vDSP_vssqD(src.baseAddress!, 1,
                               dest.baseAddress!, 1,
                               n)
                }
            }
    }
  @inlinable public static func trunc<U>(_ vector: U) -> [Swift.Float] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Float {
            
            let result = Array<Float>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                trunc(vector,
                      result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func trunc<U, V>(_ vector: U, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Float, V.Element == Swift.Float {
            
            precondition(vector.count == result.count)
            
            let n = vDSP_Length(vector.count)
            
            result.withUnsafeMutableBufferPointer { dest in
                vector.withUnsafeBufferPointer { src in
                    vDSP_vfrac(src.baseAddress!, 1,
                               dest.baseAddress!, 1,
                               n)
                }
            }
    }
  @inlinable public static func trunc<U>(_ vector: U) -> [Swift.Double] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Double {
            
            let result = Array<Double>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                trunc(vector,
                      result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func trunc<U, V>(_ vector: U, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Double, V.Element == Swift.Double {
            
            precondition(vector.count == result.count)
            
            let n = vDSP_Length(vector.count)
            
            result.withUnsafeMutableBufferPointer { dest in
                vector.withUnsafeBufferPointer { src in
                    vDSP_vfracD(src.baseAddress!, 1,
                                dest.baseAddress!, 1,
                                n)
                }
            }
    }
  @inlinable public static func countZeroCrossings<U>(_ vector: U) -> Swift.UInt where U : Accelerate.AccelerateBuffer, U.Element == Swift.Float {
            
            let n = vDSP_Length(vector.count)
            var crossingCount: vDSP_Length = 0
            var lastCrossingIndex: vDSP_Length = 0
            
            vector.withUnsafeBufferPointer { src in
                vDSP_nzcros(src.baseAddress!, 1,
                            n,
                            &lastCrossingIndex,
                            &crossingCount,
                            n)
            }
            
            return crossingCount
    }
  @inlinable public static func countZeroCrossings<U>(_ vector: U) -> Swift.UInt where U : Accelerate.AccelerateBuffer, U.Element == Swift.Double {
            
            let n = vDSP_Length(vector.count)
            var crossingCount: vDSP_Length = 0
            var lastCrossingIndex: vDSP_Length = 0
            
            vector.withUnsafeBufferPointer { src in
                vDSP_nzcrosD(src.baseAddress!, 1,
                             n,
                             &lastCrossingIndex,
                             &crossingCount,
                             n)
            }
            
            return crossingCount
    }
}
@available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension vDSP {
  @inlinable public static func slidingWindowSum<U>(_ vector: U, usingWindowLength windowLength: Swift.Int) -> [Swift.Float] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Float {
            
            let n = vector.count - windowLength + 1
            
            let result = Array<Float>(unsafeUninitializedCapacity: n) {
                buffer, initializedCount in
                
                slidingWindowSum(vector,
                                 usingWindowLength: windowLength,
                                 result: &buffer)
                
                initializedCount = n
            }
            
            return result
    }
  @inlinable public static func slidingWindowSum<U, V>(_ vector: U, usingWindowLength windowLength: Swift.Int, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Float, V.Element == Swift.Float {
            
            let n = result.count
            precondition(vector.count == n + windowLength - 1)
            
            result.withUnsafeMutableBufferPointer { dest in
                vector.withUnsafeBufferPointer { src in
                    vDSP_vswsum(src.baseAddress!, 1,
                                dest.baseAddress!, 1,
                                vDSP_Length(n),
                                vDSP_Length(windowLength))
                }
            }
            
    }
  @inlinable public static func slidingWindowSum<U>(_ vector: U, usingWindowLength windowLength: Swift.Int) -> [Swift.Double] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Double {
            
            let n = vector.count - windowLength + 1
            
            let result = Array<Double>(unsafeUninitializedCapacity: n) {
                buffer, initializedCount in
                
                slidingWindowSum(vector,
                                 usingWindowLength: windowLength,
                                 result: &buffer)
                
                initializedCount = n
            }
            
            return result
    }
  @inlinable public static func slidingWindowSum<U, V>(_ vector: U, usingWindowLength windowLength: Swift.Int, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Double, V.Element == Swift.Double {
            
            let n = result.count
            precondition(vector.count == n + windowLength - 1)
            
            result.withUnsafeMutableBufferPointer { dest in
                vector.withUnsafeBufferPointer { src in
                    vDSP_vswsumD(src.baseAddress!, 1,
                                 dest.baseAddress!, 1,
                                 vDSP_Length(n),
                                 vDSP_Length(windowLength))
                }
            }
            
    }
}
@available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension vForce {
  @inlinable public static func ceil<U>(_ vector: U) -> [Swift.Float] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Float {
            
            let result = Array<Float>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                ceil(vector,
                     result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func ceil<U, V>(_ vector: U, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Float, V.Element == Swift.Float {
            
            precondition(vector.count == result.count)
            
            var n = Int32(vector.count)
            
            result.withUnsafeMutableBufferPointer { dest in
                vector.withUnsafeBufferPointer { src in
                    vvceilf(dest.baseAddress!,
                            src.baseAddress!,
                            &n)
                }
            }
    }
  @inlinable public static func ceil<U>(_ vector: U) -> [Swift.Double] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Double {
            
            let result = Array<Double>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                ceil(vector,
                     result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func ceil<U, V>(_ vector: U, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Double, V.Element == Swift.Double {
            
            precondition(vector.count == result.count)
            
            var n = Int32(vector.count)
            
            result.withUnsafeMutableBufferPointer { dest in
                vector.withUnsafeBufferPointer { src in
                    vvceil(dest.baseAddress!,
                           src.baseAddress!,
                           &n)
                }
            }
    }
  @inlinable public static func floor<U>(_ vector: U) -> [Swift.Float] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Float {
            
            let result = Array<Float>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                floor(vector,
                      result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func floor<U, V>(_ vector: U, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Float, V.Element == Swift.Float {
            
            precondition(vector.count == result.count)
            
            var n = Int32(vector.count)
            
            result.withUnsafeMutableBufferPointer { dest in
                vector.withUnsafeBufferPointer { src in
                    vvfloorf(dest.baseAddress!,
                             src.baseAddress!,
                             &n)
                }
            }
    }
  @inlinable public static func floor<U>(_ vector: U) -> [Swift.Double] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Double {
            
            let result = Array<Double>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                floor(vector,
                      result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func floor<U, V>(_ vector: U, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Double, V.Element == Swift.Double {
            
            precondition(vector.count == result.count)
            
            var n = Int32(vector.count)
            
            result.withUnsafeMutableBufferPointer { dest in
                vector.withUnsafeBufferPointer { src in
                    vvfloor(dest.baseAddress!,
                            src.baseAddress!,
                            &n)
                }
            }
    }
  @inlinable public static func copysign<U, V>(magnitudes: U, signs: V) -> [Swift.Float] where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Float, V.Element == Swift.Float {
            
            precondition(magnitudes.count == signs.count)
            
            let result = Array<Float>(unsafeUninitializedCapacity: magnitudes.count) {
                buffer, initializedCount in
                
                copysign(magnitudes: magnitudes,
                         signs: signs,
                         result: &buffer)
                
                initializedCount = magnitudes.count
            }
            
            return result
    }
  @inlinable public static func copysign<T, U, V>(magnitudes: T, signs: U, result: inout V) where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, T.Element == Swift.Float, U.Element == Swift.Float, V.Element == Swift.Float {
            
            precondition(magnitudes.count == signs.count && signs.count == result.count)
            
            var n = Int32(magnitudes.count)
            
            result.withUnsafeMutableBufferPointer { dest in
                magnitudes.withUnsafeBufferPointer { mag in
                    signs.withUnsafeBufferPointer { sgn in
                        vvcopysignf(dest.baseAddress!,
                                    mag.baseAddress!,
                                    sgn.baseAddress!,
                                    &n)
                    }
                }
            }
    }
  @inlinable public static func copysign<U, V>(magnitudes: U, signs: V) -> [Swift.Double] where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Double, V.Element == Swift.Double {
            
            precondition(magnitudes.count == signs.count)
            
            let result = Array<Double>(unsafeUninitializedCapacity: magnitudes.count) {
                buffer, initializedCount in
                
                copysign(magnitudes: magnitudes,
                         signs: signs,
                         result: &buffer)
                
                initializedCount = magnitudes.count
            }
            
            return result
    }
  @inlinable public static func copysign<T, U, V>(magnitudes: T, signs: U, result: inout V) where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, T.Element == Swift.Double, U.Element == Swift.Double, V.Element == Swift.Double {
            
            precondition(magnitudes.count == signs.count && signs.count == result.count)
            
            var n = Int32(magnitudes.count)
            
            result.withUnsafeMutableBufferPointer { dest in
                magnitudes.withUnsafeBufferPointer { mag in
                    signs.withUnsafeBufferPointer { sgn in
                        vvcopysign(dest.baseAddress!,
                                   mag.baseAddress!,
                                   sgn.baseAddress!,
                                   &n)
                    }
                }
            }
    }
  @inlinable public static func truncatingRemainder<U, V>(dividends: U, divisors: V) -> [Swift.Float] where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Float, V.Element == Swift.Float {
            
            precondition(dividends.count == divisors.count)
            
            let result = Array<Float>(unsafeUninitializedCapacity: dividends.count) {
                buffer, initializedCount in
                
                truncatingRemainder(dividends: dividends,
                                    divisors: divisors,
                                    result: &buffer)
                
                initializedCount = dividends.count
            }
            
            return result
    }
  @inlinable public static func truncatingRemainder<T, U, V>(dividends: T, divisors: U, result: inout V) where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, T.Element == Swift.Float, U.Element == Swift.Float, V.Element == Swift.Float {
            
            precondition(dividends.count == divisors.count && divisors.count == result.count)
            
            var n = Int32(result.count)
            
            result.withUnsafeMutableBufferPointer { dest in
                dividends.withUnsafeBufferPointer { a in
                    divisors.withUnsafeBufferPointer { b in
                        vvfmodf(dest.baseAddress!,
                                a.baseAddress!,
                                b.baseAddress!,
                                &n)
                    }
                }
            }
    }
  @inlinable public static func truncatingRemainder<U, V>(dividends: U, divisors: V) -> [Swift.Double] where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Double, V.Element == Swift.Double {
            
            precondition(dividends.count == divisors.count)
            
            let result = Array<Double>(unsafeUninitializedCapacity: dividends.count) {
                buffer, initializedCount in
                
                truncatingRemainder(dividends: dividends,
                                    divisors: divisors,
                                    result: &buffer)
                
                initializedCount = dividends.count
            }
            
            return result
    }
  @inlinable public static func truncatingRemainder<T, U, V>(dividends: T, divisors: U, result: inout V) where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, T.Element == Swift.Double, U.Element == Swift.Double, V.Element == Swift.Double {
            
            precondition(dividends.count == divisors.count && divisors.count == result.count)
            
            var n = Int32(result.count)
            
            result.withUnsafeMutableBufferPointer { dest in
                dividends.withUnsafeBufferPointer { a in
                    divisors.withUnsafeBufferPointer { b in
                        vvfmod(dest.baseAddress!,
                               a.baseAddress!,
                               b.baseAddress!,
                               &n)
                    }
                }
            }
    }
  @inlinable public static func remainder<U, V>(dividends: U, divisors: V) -> [Swift.Float] where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Float, V.Element == Swift.Float {
            
            precondition(dividends.count == divisors.count)
            
            let result = Array<Float>(unsafeUninitializedCapacity: dividends.count) {
                buffer, initializedCount in
                
                remainder(dividends: dividends,
                          divisors: divisors,
                          result: &buffer)
                
                initializedCount = dividends.count
            }
            
            return result
    }
  @inlinable public static func remainder<T, U, V>(dividends: T, divisors: U, result: inout V) where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, T.Element == Swift.Float, U.Element == Swift.Float, V.Element == Swift.Float {
            
            precondition(dividends.count == divisors.count && divisors.count == result.count)
            
            var n = Int32(result.count)
            
            result.withUnsafeMutableBufferPointer { dest in
                dividends.withUnsafeBufferPointer { a in
                    divisors.withUnsafeBufferPointer { b in
                        vvremainderf(dest.baseAddress!,
                                     a.baseAddress!,
                                     b.baseAddress!,
                                     &n)
                    }
                }
            }
    }
  @inlinable public static func remainder<U, V>(dividends: U, divisors: V) -> [Swift.Double] where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Double, V.Element == Swift.Double {
            
            precondition(dividends.count == divisors.count)
            
            let result = Array<Double>(unsafeUninitializedCapacity: dividends.count) {
                buffer, initializedCount in
                
                remainder(dividends: dividends,
                          divisors: divisors,
                          result: &buffer)
                
                initializedCount = dividends.count
            }
            
            return result
    }
  @inlinable public static func remainder<T, U, V>(dividends: T, divisors: U, result: inout V) where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, T.Element == Swift.Double, U.Element == Swift.Double, V.Element == Swift.Double {
            
            precondition(dividends.count == divisors.count && divisors.count == result.count)
            
            var n = Int32(result.count)
            
            result.withUnsafeMutableBufferPointer { dest in
                dividends.withUnsafeBufferPointer { a in
                    divisors.withUnsafeBufferPointer { b in
                        vvremainder(dest.baseAddress!,
                                    a.baseAddress!,
                                    b.baseAddress!,
                                    &n)
                    }
                }
            }
    }
  @inlinable public static func trunc<U>(_ vector: U) -> [Swift.Float] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Float {
            
            let result = Array<Float>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                trunc(vector,
                      result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func trunc<U, V>(_ vector: U, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Float, V.Element == Swift.Float {
            
            precondition(vector.count == result.count)
            
            var n = Int32(vector.count)
            
            result.withUnsafeMutableBufferPointer { dest in
                vector.withUnsafeBufferPointer { src in
                    vvintf(dest.baseAddress!,
                           src.baseAddress!,
                           &n)
                }
            }
    }
  @inlinable public static func trunc<U>(_ vector: U) -> [Swift.Double] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Double {
            
            let result = Array<Double>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                trunc(vector,
                      result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func trunc<U, V>(_ vector: U, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Double, V.Element == Swift.Double {
            
            precondition(vector.count == result.count)
            
            var n = Int32(vector.count)
            
            result.withUnsafeMutableBufferPointer { dest in
                vector.withUnsafeBufferPointer { src in
                    vvint(dest.baseAddress!,
                          src.baseAddress!,
                          &n)
                }
            }
    }
  @inlinable public static func nearestInteger<U>(_ vector: U) -> [Swift.Float] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Float {
            
            let result = Array<Float>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                nearestInteger(vector,
                               result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func nearestInteger<U, V>(_ vector: U, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Float, V.Element == Swift.Float {
            
            precondition(vector.count == result.count)
            
            var n = Int32(vector.count)
            
            result.withUnsafeMutableBufferPointer { dest in
                vector.withUnsafeBufferPointer { src in
                    vvnintf(dest.baseAddress!,
                            src.baseAddress!,
                            &n)
                }
            }
    }
  @inlinable public static func nearestInteger<U>(_ vector: U) -> [Swift.Double] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Double {
            
            let result = Array<Double>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                nearestInteger(vector,
                               result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func nearestInteger<U, V>(_ vector: U, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Double, V.Element == Swift.Double {
            
            precondition(vector.count == result.count)
            
            var n = Int32(vector.count)
            
            result.withUnsafeMutableBufferPointer { dest in
                vector.withUnsafeBufferPointer { src in
                    vvnint(dest.baseAddress!,
                           src.baseAddress!,
                           &n)
                }
            }
    }
  @inlinable public static func rsqrt<U>(_ vector: U) -> [Swift.Float] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Float {
            
            let result = Array<Float>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                rsqrt(vector,
                      result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func rsqrt<U, V>(_ vector: U, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Float, V.Element == Swift.Float {
            
            precondition(vector.count == result.count)
            
            var n = Int32(vector.count)
            
            result.withUnsafeMutableBufferPointer { dest in
                vector.withUnsafeBufferPointer { src in
                    vvrsqrtf(dest.baseAddress!,
                             src.baseAddress!,
                             &n)
                }
            }
    }
  @inlinable public static func rsqrt<U>(_ vector: U) -> [Swift.Double] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Double {
            
            let result = Array<Double>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                rsqrt(vector,
                      result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func rsqrt<U, V>(_ vector: U, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Double, V.Element == Swift.Double {
            
            precondition(vector.count == result.count)
            
            var n = Int32(vector.count)
            
            result.withUnsafeMutableBufferPointer { dest in
                vector.withUnsafeBufferPointer { src in
                    vvrsqrt(dest.baseAddress!,
                            src.baseAddress!,
                            &n)
                }
            }
    }
  @inlinable public static func sqrt<U>(_ vector: U) -> [Swift.Float] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Float {
            
            let result = Array<Float>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                sqrt(vector,
                     result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func sqrt<U, V>(_ vector: U, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Float, V.Element == Swift.Float {
            
            precondition(vector.count == result.count)
            
            var n = Int32(vector.count)
            
            result.withUnsafeMutableBufferPointer { dest in
                vector.withUnsafeBufferPointer { src in
                    vvsqrtf(dest.baseAddress!,
                            src.baseAddress!,
                            &n)
                }
            }
    }
  @inlinable public static func sqrt<U>(_ vector: U) -> [Swift.Double] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Double {
            
            let result = Array<Double>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                sqrt(vector,
                     result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func sqrt<U, V>(_ vector: U, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Double, V.Element == Swift.Double {
            
            precondition(vector.count == result.count)
            
            var n = Int32(vector.count)
            
            result.withUnsafeMutableBufferPointer { dest in
                vector.withUnsafeBufferPointer { src in
                    vvsqrt(dest.baseAddress!,
                           src.baseAddress!,
                           &n)
                }
            }
    }
  @inlinable public static func reciprocal<U>(_ vector: U) -> [Swift.Float] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Float {
            
            let result = Array<Float>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                reciprocal(vector,
                           result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func reciprocal<U, V>(_ vector: U, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Float, V.Element == Swift.Float {
            
            precondition(vector.count == result.count)
            
            var n = Int32(vector.count)
            
            result.withUnsafeMutableBufferPointer { dest in
                vector.withUnsafeBufferPointer { src in
                    vvrecf(dest.baseAddress!,
                           src.baseAddress!,
                           &n)
                }
            }
    }
  @inlinable public static func reciprocal<U>(_ vector: U) -> [Swift.Double] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Double {
            
            let result = Array<Double>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                reciprocal(vector,
                           result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func reciprocal<U, V>(_ vector: U, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Double, V.Element == Swift.Double {
            
            precondition(vector.count == result.count)
            
            var n = Int32(vector.count)
            
            result.withUnsafeMutableBufferPointer { dest in
                vector.withUnsafeBufferPointer { src in
                    vvrec(dest.baseAddress!,
                          src.baseAddress!,
                          &n)
                }
            }
    }
}
@available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension vForce {
  @inlinable public static func exp<U>(_ vector: U) -> [Swift.Float] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Float {
            
            let result = Array<Float>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                exp(vector,
                    result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func exp<U, V>(_ vector: U, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Float, V.Element == Swift.Float {
            
            precondition(vector.count == result.count)
            
            var n = Int32(vector.count)
            
            result.withUnsafeMutableBufferPointer { dest in
                vector.withUnsafeBufferPointer { src in
                    vvexpf(dest.baseAddress!,
                           src.baseAddress!,
                           &n)
                }
            }
    }
  @inlinable public static func expm1<U>(_ vector: U) -> [Swift.Float] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Float {
            
            let result = Array<Float>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                expm1(vector,
                      result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func expm1<U, V>(_ vector: U, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Float, V.Element == Swift.Float {
            
            precondition(vector.count == result.count)
            
            var n = Int32(vector.count)
            
            result.withUnsafeMutableBufferPointer { dest in
                vector.withUnsafeBufferPointer { src in
                    vvexpm1f(dest.baseAddress!,
                             src.baseAddress!,
                             &n)
                }
            }
    }
  @inlinable public static func exp2<U>(_ vector: U) -> [Swift.Float] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Float {
            
            let result = Array<Float>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                exp2(vector,
                     result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func exp2<U, V>(_ vector: U, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Float, V.Element == Swift.Float {
            
            precondition(vector.count == result.count)
            
            var n = Int32(vector.count)
            
            result.withUnsafeMutableBufferPointer { dest in
                vector.withUnsafeBufferPointer { src in
                    vvexp2f(dest.baseAddress!,
                            src.baseAddress!,
                            &n)
                }
            }
    }
  @inlinable public static func exp<U>(_ vector: U) -> [Swift.Double] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Double {
            
            let result = Array<Double>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                exp(vector,
                    result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func exp<U, V>(_ vector: U, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Double, V.Element == Swift.Double {
            
            precondition(vector.count == result.count)
            
            var n = Int32(vector.count)
            
            result.withUnsafeMutableBufferPointer { dest in
                vector.withUnsafeBufferPointer { src in
                    vvexp(dest.baseAddress!,
                          src.baseAddress!,
                          &n)
                }
            }
    }
  @inlinable public static func expm1<U>(_ vector: U) -> [Swift.Double] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Double {
            
            let result = Array<Double>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                expm1(vector,
                      result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func expm1<U, V>(_ vector: U, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Double, V.Element == Swift.Double {
            
            precondition(vector.count == result.count)
            
            var n = Int32(vector.count)
            
            result.withUnsafeMutableBufferPointer { dest in
                vector.withUnsafeBufferPointer { src in
                    vvexpm1(dest.baseAddress!,
                            src.baseAddress!,
                            &n)
                }
            }
    }
  @inlinable public static func exp2<U>(_ vector: U) -> [Swift.Double] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Double {
            
            let result = Array<Double>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                exp2(vector,
                     result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func exp2<U, V>(_ vector: U, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Double, V.Element == Swift.Double {
            
            precondition(vector.count == result.count)
            
            var n = Int32(vector.count)
            
            result.withUnsafeMutableBufferPointer { dest in
                vector.withUnsafeBufferPointer { src in
                    vvexp2(dest.baseAddress!,
                           src.baseAddress!,
                           &n)
                }
            }
    }
  @inlinable public static func log2<U>(_ vector: U) -> [Swift.Float] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Float {
            
            let result = Array<Float>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                log2(vector,
                     result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func log2<U, V>(_ vector: U, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Float, V.Element == Swift.Float {
            
            precondition(vector.count == result.count)
            
            var n = Int32(vector.count)
            
            result.withUnsafeMutableBufferPointer { dest in
                vector.withUnsafeBufferPointer { src in
                    vvlog2f(dest.baseAddress!,
                            src.baseAddress!,
                            &n)
                }
            }
    }
  @inlinable public static func log10<U>(_ vector: U) -> [Swift.Float] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Float {
            
            let result = Array<Float>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                log10(vector,
                      result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func log10<U, V>(_ vector: U, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Float, V.Element == Swift.Float {
            
            precondition(vector.count == result.count)
            
            var n = Int32(vector.count)
            
            result.withUnsafeMutableBufferPointer { dest in
                vector.withUnsafeBufferPointer { src in
                    vvlog10f(dest.baseAddress!,
                             src.baseAddress!,
                             &n)
                }
            }
    }
  @inlinable public static func log2<U>(_ vector: U) -> [Swift.Double] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Double {
            
            let result = Array<Double>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                log2(vector,
                     result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func log2<U, V>(_ vector: U, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Double, V.Element == Swift.Double {
            
            precondition(vector.count == result.count)
            
            var n = Int32(vector.count)
            
            result.withUnsafeMutableBufferPointer { dest in
                vector.withUnsafeBufferPointer { src in
                    vvlog2(dest.baseAddress!,
                           src.baseAddress!,
                           &n)
                }
            }
    }
  @inlinable public static func log10<U>(_ vector: U) -> [Swift.Double] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Double {
            
            let result = Array<Double>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                log10(vector,
                      result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func log10<U, V>(_ vector: U, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Double, V.Element == Swift.Double {
            
            precondition(vector.count == result.count)
            
            var n = Int32(vector.count)
            
            result.withUnsafeMutableBufferPointer { dest in
                vector.withUnsafeBufferPointer { src in
                    vvlog10(dest.baseAddress!,
                            src.baseAddress!,
                            &n)
                }
            }
    }
  @inlinable public static func logb<U>(_ vector: U) -> [Swift.Float] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Float {
            
            let result = Array<Float>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                logb(vector,
                     result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func logb<U, V>(_ vector: U, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Float, V.Element == Swift.Float {
            
            precondition(vector.count == result.count)
            
            var n = Int32(vector.count)
            
            result.withUnsafeMutableBufferPointer { dest in
                vector.withUnsafeBufferPointer { src in
                    vvlogbf(dest.baseAddress!,
                            src.baseAddress!,
                            &n)
                }
            }
    }
  @inlinable public static func logb<U>(_ vector: U) -> [Swift.Double] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Double {
            
            let result = Array<Double>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                logb(vector,
                     result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func logb<U, V>(_ vector: U, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Double, V.Element == Swift.Double {
            
            precondition(vector.count == result.count)
            
            var n = Int32(vector.count)
            
            result.withUnsafeMutableBufferPointer { dest in
                vector.withUnsafeBufferPointer { src in
                    vvlogb(dest.baseAddress!,
                           src.baseAddress!,
                           &n)
                }
            }
    }
}
@available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension vForce {
  @inlinable public static func pow<U, V>(bases: U, exponents: V) -> [Swift.Float] where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Float, V.Element == Swift.Float {
            
            precondition(bases.count == exponents.count)
            
            let result = Array<Float>(unsafeUninitializedCapacity: exponents.count) {
                buffer, initializedCount in
                
                pow(bases: bases,
                    exponents: exponents,
                    result: &buffer)
                
                initializedCount = exponents.count
            }
            
            return result
    }
  @inlinable public static func pow<T, U, V>(bases: T, exponents: U, result: inout V) where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, T.Element == Swift.Float, U.Element == Swift.Float, V.Element == Swift.Float {
            
            precondition(bases.count == exponents.count && exponents.count == result.count)
            
            var n = Int32(bases.count)
            
            result.withUnsafeMutableBufferPointer { dest in
                bases.withUnsafeBufferPointer { bases in
                    exponents.withUnsafeBufferPointer { exponents in
                        vvpowf(dest.baseAddress!,
                               exponents.baseAddress!,
                               bases.baseAddress!,
                               &n)
                    }
                }
            }
    }
  @inlinable public static func pow<U, V>(bases: U, exponents: V) -> [Swift.Double] where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Double, V.Element == Swift.Double {
            
            precondition(bases.count == exponents.count)
            
            let result = Array<Double>(unsafeUninitializedCapacity: exponents.count) {
                buffer, initializedCount in
                
                pow(bases: bases,
                    exponents: exponents,
                    result: &buffer)
                
                initializedCount = exponents.count
            }
            
            return result
    }
  @inlinable public static func pow<T, U, V>(bases: T, exponents: U, result: inout V) where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, T.Element == Swift.Double, U.Element == Swift.Double, V.Element == Swift.Double {
            
            precondition(bases.count == exponents.count && exponents.count == result.count)
            
            var n = Int32(bases.count)
            
            result.withUnsafeMutableBufferPointer { dest in
                bases.withUnsafeBufferPointer { bases in
                    exponents.withUnsafeBufferPointer { exponents in
                        vvpow(dest.baseAddress!,
                              exponents.baseAddress!,
                              bases.baseAddress!,
                              &n)
                    }
                }
            }
    }
}
@available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension vForce {
  @inlinable public static func sin<U>(_ vector: U) -> [Swift.Float] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Float {
            
            let result = Array<Float>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                sin(vector,
                    result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func sin<U, V>(_ vector: U, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Float, V.Element == Swift.Float {
            
            precondition(vector.count == result.count)
            
            var n = Int32(vector.count)
            
            result.withUnsafeMutableBufferPointer { dest in
                vector.withUnsafeBufferPointer { src in
                    vvsinf(dest.baseAddress!,
                           src.baseAddress!,
                           &n)
                }
            }
    }
  @inlinable public static func sin<U>(_ vector: U) -> [Swift.Double] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Double {
            
            let result = Array<Double>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                sin(vector,
                    result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func sin<U, V>(_ vector: U, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Double, V.Element == Swift.Double {
            
            precondition(vector.count == result.count)
            
            var n = Int32(vector.count)
            
            result.withUnsafeMutableBufferPointer { dest in
                vector.withUnsafeBufferPointer { src in
                    vvsin(dest.baseAddress!,
                          src.baseAddress!,
                          &n)
                }
            }
    }
  @inlinable public static func sinPi<U>(_ vector: U) -> [Swift.Float] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Float {
            
            let result = Array<Float>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                sinPi(vector,
                      result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func sinPi<U, V>(_ vector: U, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Float, V.Element == Swift.Float {
            
            precondition(vector.count == result.count)
            
            var n = Int32(vector.count)
            
            result.withUnsafeMutableBufferPointer { dest in
                vector.withUnsafeBufferPointer { src in
                    vvsinpif(dest.baseAddress!,
                             src.baseAddress!,
                             &n)
                }
            }
    }
  @inlinable public static func sinPi<U>(_ vector: U) -> [Swift.Double] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Double {
            
            let result = Array<Double>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                sinPi(vector,
                      result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func sinPi<U, V>(_ vector: U, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Double, V.Element == Swift.Double {
            
            precondition(vector.count == result.count)
            
            var n = Int32(vector.count)
            
            result.withUnsafeMutableBufferPointer { dest in
                vector.withUnsafeBufferPointer { src in
                    vvsinpi(dest.baseAddress!,
                            src.baseAddress!,
                            &n)
                }
            }
    }
  @inlinable public static func cos<U>(_ vector: U) -> [Swift.Float] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Float {
            
            let result = Array<Float>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                cos(vector,
                    result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func cos<U, V>(_ vector: U, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Float, V.Element == Swift.Float {
            
            precondition(vector.count == result.count)
            
            var n = Int32(vector.count)
            
            result.withUnsafeMutableBufferPointer { dest in
                vector.withUnsafeBufferPointer { src in
                    vvcosf(dest.baseAddress!,
                           src.baseAddress!,
                           &n)
                }
            }
    }
  @inlinable public static func cos<U>(_ vector: U) -> [Swift.Double] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Double {
            
            let result = Array<Double>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                cos(vector,
                    result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func cos<U, V>(_ vector: U, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Double, V.Element == Swift.Double {
            
            precondition(vector.count == result.count)
            
            var n = Int32(vector.count)
            
            result.withUnsafeMutableBufferPointer { dest in
                vector.withUnsafeBufferPointer { src in
                    vvcos(dest.baseAddress!,
                          src.baseAddress!,
                          &n)
                }
            }
    }
  @inlinable public static func cosPi<U>(_ vector: U) -> [Swift.Float] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Float {
            
            let result = Array<Float>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                cosPi(vector,
                      result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func cosPi<U, V>(_ vector: U, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Float, V.Element == Swift.Float {
            
            precondition(vector.count == result.count)
            
            var n = Int32(vector.count)
            
            result.withUnsafeMutableBufferPointer { dest in
                vector.withUnsafeBufferPointer { src in
                    vvcospif(dest.baseAddress!,
                             src.baseAddress!,
                             &n)
                }
            }
    }
  @inlinable public static func cosPi<U>(_ vector: U) -> [Swift.Double] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Double {
            
            let result = Array<Double>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                cosPi(vector,
                      result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func cosPi<U, V>(_ vector: U, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Double, V.Element == Swift.Double {
            
            precondition(vector.count == result.count)
            
            var n = Int32(vector.count)
            
            result.withUnsafeMutableBufferPointer { dest in
                vector.withUnsafeBufferPointer { src in
                    vvcospi(dest.baseAddress!,
                            src.baseAddress!,
                            &n)
                }
            }
    }
  @inlinable public static func sincos<T, U, V>(_ vector: T, sinResult: inout U, cosResult: inout V) where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateMutableBuffer, V : Accelerate.AccelerateMutableBuffer, T.Element == Swift.Float, U.Element == Swift.Float, V.Element == Swift.Float {
            
            precondition(vector.count == sinResult.count && sinResult.count == cosResult.count)
            
            var n = Int32(vector.count)
            
            sinResult.withUnsafeMutableBufferPointer { sinDest in
                cosResult.withUnsafeMutableBufferPointer { cosDest in
                    vector.withUnsafeBufferPointer { src in
                        vvsincosf(sinDest.baseAddress!,
                                  cosDest.baseAddress!,
                                  src.baseAddress!,
                                  &n)
                    }
                }
            }
    }
  @inlinable public static func sincos<T, U, V>(_ vector: T, sinResult: inout U, cosResult: inout V) where T : Accelerate.AccelerateBuffer, U : Accelerate.AccelerateMutableBuffer, V : Accelerate.AccelerateMutableBuffer, T.Element == Swift.Double, U.Element == Swift.Double, V.Element == Swift.Double {
            
            precondition(vector.count == sinResult.count && sinResult.count == cosResult.count)
            
            var n = Int32(vector.count)
            
            sinResult.withUnsafeMutableBufferPointer { sinDest in
                cosResult.withUnsafeMutableBufferPointer { cosDest in
                    vector.withUnsafeBufferPointer { src in
                        vvsincos(sinDest.baseAddress!,
                                 cosDest.baseAddress!,
                                 src.baseAddress!,
                                 &n)
                    }
                }
            }
    }
  @inlinable public static func tan<U>(_ vector: U) -> [Swift.Float] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Float {
            
            let result = Array<Float>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                tan(vector,
                    result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func tan<U, V>(_ vector: U, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Float, V.Element == Swift.Float {
            
            precondition(vector.count == result.count)
            
            var n = Int32(vector.count)
            
            result.withUnsafeMutableBufferPointer { dest in
                vector.withUnsafeBufferPointer { src in
                    vvtanf(dest.baseAddress!,
                           src.baseAddress!,
                           &n)
                }
            }
    }
  @inlinable public static func tan<U>(_ vector: U) -> [Swift.Double] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Double {
            
            let result = Array<Double>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                tan(vector,
                    result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func tan<U, V>(_ vector: U, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Double, V.Element == Swift.Double {
            
            precondition(vector.count == result.count)
            
            var n = Int32(vector.count)
            
            result.withUnsafeMutableBufferPointer { dest in
                vector.withUnsafeBufferPointer { src in
                    vvtan(dest.baseAddress!,
                          src.baseAddress!,
                          &n)
                }
            }
    }
  @inlinable public static func tanPi<U>(_ vector: U) -> [Swift.Float] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Float {
            
            let result = Array<Float>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                tanPi(vector,
                      result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func tanPi<U, V>(_ vector: U, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Float, V.Element == Swift.Float {
            
            precondition(vector.count == result.count)
            
            var n = Int32(vector.count)
            
            result.withUnsafeMutableBufferPointer { dest in
                vector.withUnsafeBufferPointer { src in
                    vvtanpif(dest.baseAddress!,
                             src.baseAddress!,
                             &n)
                }
            }
    }
  @inlinable public static func tanPi<U>(_ vector: U) -> [Swift.Double] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Double {
            
            let result = Array<Double>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                tanPi(vector,
                      result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func tanPi<U, V>(_ vector: U, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Double, V.Element == Swift.Double {
            
            precondition(vector.count == result.count)
            
            var n = Int32(vector.count)
            
            result.withUnsafeMutableBufferPointer { dest in
                vector.withUnsafeBufferPointer { src in
                    vvtanpi(dest.baseAddress!,
                            src.baseAddress!,
                            &n)
                }
            }
    }
  @inlinable public static func asin<U>(_ vector: U) -> [Swift.Float] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Float {
            
            let result = Array<Float>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                asin(vector,
                     result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func asin<U, V>(_ vector: U, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Float, V.Element == Swift.Float {
            
            precondition(vector.count == result.count)
            
            var n = Int32(vector.count)
            
            result.withUnsafeMutableBufferPointer { dest in
                vector.withUnsafeBufferPointer { src in
                    vvasinf(dest.baseAddress!,
                            src.baseAddress!,
                            &n)
                }
            }
    }
  @inlinable public static func asin<U>(_ vector: U) -> [Swift.Double] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Double {
            
            let result = Array<Double>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                asin(vector,
                     result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func asin<U, V>(_ vector: U, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Double, V.Element == Swift.Double {
            
            precondition(vector.count == result.count)
            
            var n = Int32(vector.count)
            
            result.withUnsafeMutableBufferPointer { dest in
                vector.withUnsafeBufferPointer { src in
                    vvasin(dest.baseAddress!,
                           src.baseAddress!,
                           &n)
                }
            }
    }
  @inlinable public static func acos<U>(_ vector: U) -> [Swift.Float] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Float {
            
            let result = Array<Float>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                acos(vector,
                     result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func acos<U, V>(_ vector: U, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Float, V.Element == Swift.Float {
            
            precondition(vector.count == result.count)
            
            var n = Int32(vector.count)
            
            result.withUnsafeMutableBufferPointer { dest in
                vector.withUnsafeBufferPointer { src in
                    vvacosf(dest.baseAddress!,
                            src.baseAddress!,
                            &n)
                }
            }
    }
  @inlinable public static func acos<U>(_ vector: U) -> [Swift.Double] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Double {
            
            let result = Array<Double>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                acos(vector,
                     result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func acos<U, V>(_ vector: U, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Double, V.Element == Swift.Double {
            
            precondition(vector.count == result.count)
            
            var n = Int32(vector.count)
            
            result.withUnsafeMutableBufferPointer { dest in
                vector.withUnsafeBufferPointer { src in
                    vvacos(dest.baseAddress!,
                           src.baseAddress!,
                           &n)
                }
            }
    }
  @inlinable public static func atan<U>(_ vector: U) -> [Swift.Float] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Float {
            
            let result = Array<Float>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                atan(vector,
                     result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func atan<U, V>(_ vector: U, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Float, V.Element == Swift.Float {
            
            precondition(vector.count == result.count)
            
            var n = Int32(vector.count)
            
            result.withUnsafeMutableBufferPointer { dest in
                vector.withUnsafeBufferPointer { src in
                    vvatanf(dest.baseAddress!,
                            src.baseAddress!,
                            &n)
                }
            }
    }
  @inlinable public static func atan<U>(_ vector: U) -> [Swift.Double] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Double {
            
            let result = Array<Double>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                atan(vector,
                     result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func atan<U, V>(_ vector: U, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Double, V.Element == Swift.Double {
            
            precondition(vector.count == result.count)
            
            var n = Int32(vector.count)
            
            result.withUnsafeMutableBufferPointer { dest in
                vector.withUnsafeBufferPointer { src in
                    vvatan(dest.baseAddress!,
                           src.baseAddress!,
                           &n)
                }
            }
    }
}
@available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension vForce {
  @inlinable public static func sinh<U>(_ vector: U) -> [Swift.Float] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Float {
            
            let result = Array<Float>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                sinh(vector,
                     result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func sinh<U, V>(_ vector: U, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Float, V.Element == Swift.Float {
            
            precondition(vector.count == result.count)
            
            var n = Int32(vector.count)
            
            result.withUnsafeMutableBufferPointer { dest in
                vector.withUnsafeBufferPointer { src in
                    vvsinhf(dest.baseAddress!,
                            src.baseAddress!,
                            &n)
                }
            }
    }
  @inlinable public static func sinh<U>(_ vector: U) -> [Swift.Double] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Double {
            
            let result = Array<Double>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                sinh(vector,
                     result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func sinh<U, V>(_ vector: U, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Double, V.Element == Swift.Double {
            
            precondition(vector.count == result.count)
            
            var n = Int32(vector.count)
            
            result.withUnsafeMutableBufferPointer { dest in
                vector.withUnsafeBufferPointer { src in
                    vvsinh(dest.baseAddress!,
                           src.baseAddress!,
                           &n)
                }
            }
    }
  @inlinable public static func cosh<U>(_ vector: U) -> [Swift.Float] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Float {
            
            let result = Array<Float>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                cosh(vector,
                     result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func cosh<U, V>(_ vector: U, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Float, V.Element == Swift.Float {
            
            precondition(vector.count == result.count)
            
            var n = Int32(vector.count)
            
            result.withUnsafeMutableBufferPointer { dest in
                vector.withUnsafeBufferPointer { src in
                    vvcoshf(dest.baseAddress!,
                            src.baseAddress!,
                            &n)
                }
            }
    }
  @inlinable public static func cosh<U>(_ vector: U) -> [Swift.Double] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Double {
            
            let result = Array<Double>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                cosh(vector,
                     result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func cosh<U, V>(_ vector: U, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Double, V.Element == Swift.Double {
            
            precondition(vector.count == result.count)
            
            var n = Int32(vector.count)
            
            result.withUnsafeMutableBufferPointer { dest in
                vector.withUnsafeBufferPointer { src in
                    vvcosh(dest.baseAddress!,
                           src.baseAddress!,
                           &n)
                }
            }
    }
  @inlinable public static func tanh<U>(_ vector: U) -> [Swift.Float] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Float {
            
            let result = Array<Float>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                tanh(vector,
                     result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func tanh<U, V>(_ vector: U, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Float, V.Element == Swift.Float {
            
            precondition(vector.count == result.count)
            
            var n = Int32(vector.count)
            
            result.withUnsafeMutableBufferPointer { dest in
                vector.withUnsafeBufferPointer { src in
                    vvtanhf(dest.baseAddress!,
                            src.baseAddress!,
                            &n)
                }
            }
    }
  @inlinable public static func tanh<U>(_ vector: U) -> [Swift.Double] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Double {
            
            let result = Array<Double>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                tanh(vector,
                     result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func tanh<U, V>(_ vector: U, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Double, V.Element == Swift.Double {
            
            precondition(vector.count == result.count)
            
            var n = Int32(vector.count)
            
            result.withUnsafeMutableBufferPointer { dest in
                vector.withUnsafeBufferPointer { src in
                    vvtanh(dest.baseAddress!,
                           src.baseAddress!,
                           &n)
                }
            }
    }
  @inlinable public static func asinh<U>(_ vector: U) -> [Swift.Float] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Float {
            
            let result = Array<Float>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                asinh(vector,
                      result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func asinh<U, V>(_ vector: U, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Float, V.Element == Swift.Float {
            
            precondition(vector.count == result.count)
            
            var n = Int32(vector.count)
            
            result.withUnsafeMutableBufferPointer { dest in
                vector.withUnsafeBufferPointer { src in
                    vvasinhf(dest.baseAddress!,
                             src.baseAddress!,
                             &n)
                }
            }
    }
  @inlinable public static func asinh<U>(_ vector: U) -> [Swift.Double] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Double {
            
            let result = Array<Double>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                asinh(vector,
                      result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func asinh<U, V>(_ vector: U, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Double, V.Element == Swift.Double {
            
            precondition(vector.count == result.count)
            
            var n = Int32(vector.count)
            
            result.withUnsafeMutableBufferPointer { dest in
                vector.withUnsafeBufferPointer { src in
                    vvasinh(dest.baseAddress!,
                            src.baseAddress!,
                            &n)
                }
            }
    }
  @inlinable public static func acosh<U>(_ vector: U) -> [Swift.Float] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Float {
            
            let result = Array<Float>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                acosh(vector,
                      result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func acosh<U, V>(_ vector: U, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Float, V.Element == Swift.Float {
            
            precondition(vector.count == result.count)
            
            var n = Int32(vector.count)
            
            result.withUnsafeMutableBufferPointer { dest in
                vector.withUnsafeBufferPointer { src in
                    vvacoshf(dest.baseAddress!,
                             src.baseAddress!,
                             &n)
                }
            }
    }
  @inlinable public static func acosh<U>(_ vector: U) -> [Swift.Double] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Double {
            
            let result = Array<Double>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                acosh(vector,
                      result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func acosh<U, V>(_ vector: U, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Double, V.Element == Swift.Double {
            
            precondition(vector.count == result.count)
            
            var n = Int32(vector.count)
            
            result.withUnsafeMutableBufferPointer { dest in
                vector.withUnsafeBufferPointer { src in
                    vvacosh(dest.baseAddress!,
                            src.baseAddress!,
                            &n)
                }
            }
    }
  @inlinable public static func atanh<U>(_ vector: U) -> [Swift.Float] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Float {
            
            let result = Array<Float>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                atanh(vector,
                      result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func atanh<U, V>(_ vector: U, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Float, V.Element == Swift.Float {
            
            precondition(vector.count == result.count)
            
            var n = Int32(vector.count)
            
            result.withUnsafeMutableBufferPointer { dest in
                vector.withUnsafeBufferPointer { src in
                    vvatanhf(dest.baseAddress!,
                             src.baseAddress!,
                             &n)
                }
            }
    }
  @inlinable public static func atanh<U>(_ vector: U) -> [Swift.Double] where U : Accelerate.AccelerateBuffer, U.Element == Swift.Double {
            
            let result = Array<Double>(unsafeUninitializedCapacity: vector.count) {
                buffer, initializedCount in
                
                atanh(vector,
                      result: &buffer)
                
                initializedCount = vector.count
            }
            
            return result
    }
  @inlinable public static func atanh<U, V>(_ vector: U, result: inout V) where U : Accelerate.AccelerateBuffer, V : Accelerate.AccelerateMutableBuffer, U.Element == Swift.Double, V.Element == Swift.Double {
            
            precondition(vector.count == result.count)
            
            var n = Int32(vector.count)
            
            result.withUnsafeMutableBufferPointer { dest in
                vector.withUnsafeBufferPointer { src in
                    vvatanh(dest.baseAddress!,
                            src.baseAddress!,
                            &n)
                }
            }
    }
}
@available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Accelerate.vImage.Error : Swift.Equatable {}
@available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Accelerate.vImage.Error : Swift.Hashable {}
@available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Accelerate.vImage.Error : Swift.RawRepresentable {}
@available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Accelerate.vImage.BufferType : Swift.Equatable {}
@available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Accelerate.vImage.BufferType : Swift.Hashable {}
@available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Accelerate.vImage.BufferType : Swift.RawRepresentable {}
@available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Accelerate.vImageCVImageFormat.Format : Swift.Equatable {}
@available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Accelerate.vImageCVImageFormat.Format : Swift.Hashable {}
@available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Accelerate.vImageCVImageFormat.ChromaSiting : Swift.Equatable {}
@available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Accelerate.vImageCVImageFormat.ChromaSiting : Swift.Hashable {}
@available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Accelerate.Quadrature.Error : Swift.Equatable {}
@available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Accelerate.Quadrature.Error : Swift.Hashable {}
@available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Accelerate.vDSP.RoundingMode : Swift.Equatable {}
@available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Accelerate.vDSP.RoundingMode : Swift.Hashable {}
@available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Accelerate.vDSP.DCTTransformType : Swift.Equatable {}
@available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Accelerate.vDSP.DCTTransformType : Swift.Hashable {}
@available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Accelerate.vDSP.DFTTransformType : Swift.Equatable {}
@available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Accelerate.vDSP.DFTTransformType : Swift.Hashable {}
@available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Accelerate.vDSP.Radix : Swift.Equatable {}
@available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Accelerate.vDSP.Radix : Swift.Hashable {}
@available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Accelerate.vDSP.FourierTransformDirection : Swift.Equatable {}
@available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Accelerate.vDSP.FourierTransformDirection : Swift.Hashable {}
@available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Accelerate.vDSP.WindowSequence : Swift.Equatable {}
@available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Accelerate.vDSP.WindowSequence : Swift.Hashable {}
@available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Accelerate.vDSP.IntegrationRule : Swift.Equatable {}
@available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Accelerate.vDSP.IntegrationRule : Swift.Hashable {}
@available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Accelerate.vDSP.SortOrder : Swift.Equatable {}
@available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Accelerate.vDSP.SortOrder : Swift.Hashable {}
@available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Accelerate.vDSP.SortOrder : Swift.RawRepresentable {}
