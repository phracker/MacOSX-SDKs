.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "IO::Wrap 3"
.TH IO::Wrap 3 "2005-02-10" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
IO::Wrap \- wrap raw filehandles in IO::Handle interface
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&   use IO::Wrap;
\&       
\&   ### Do stuff with any kind of filehandle (including a bare globref), or 
\&   ### any kind of blessed object that responds to a print() message.
\&   ###
\&   sub do_stuff {
\&       my $fh = shift;         
\&       
\&       ### At this point, we have no idea what the user gave us... 
\&       ### a globref? a FileHandle? a scalar filehandle name?
\&       
\&       $fh = wraphandle($fh);  
\&        
\&       ### At this point, we know we have an IO::Handle\-like object!
\&       
\&       $fh\->print("Hey there!");
\&       ...
\&   }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Let's say you want to write some code which does I/O, but you don't 
want to force the caller to provide you with a FileHandle or IO::Handle
object.  You want them to be able to say:
.PP
.Vb 4
\&    do_stuff(\e*STDOUT);
\&    do_stuff(\*(AqSTDERR\*(Aq);
\&    do_stuff($some_FileHandle_object);
\&    do_stuff($some_IO_Handle_object);
.Ve
.PP
And even:
.PP
.Vb 1
\&    do_stuff($any_object_with_a_print_method);
.Ve
.PP
Sure, one way to do it is to force the caller to use \fItiehandle()\fR.  
But that puts the burden on them.  Another way to do it is to 
use \fBIO::Wrap\fR, which provides you with the following functions:
.IP "wraphandle \s-1SCALAR\s0" 4
.IX Item "wraphandle SCALAR"
This function will take a single argument, and \*(L"wrap\*(R" it based on
what it seems to be...
.RS 4
.IP "\(bu" 4
\&\fBA raw scalar filehandle name,\fR like \f(CW"STDOUT"\fR or \f(CW"Class::HANDLE"\fR.
In this case, the filehandle name is wrapped in an IO::Wrap object, 
which is returned.
.IP "\(bu" 4
\&\fBA raw filehandle glob,\fR like \f(CW\*(C`\e*STDOUT\*(C'\fR.
In this case, the filehandle glob is wrapped in an IO::Wrap object, 
which is returned.
.IP "\(bu" 4
\&\fBA blessed FileHandle object.\fR
In this case, the FileHandle is wrapped in an IO::Wrap object if and only
if your FileHandle class does not support the \f(CW\*(C`read()\*(C'\fR method.
.IP "\(bu" 4
\&\fBAny other kind of blessed object,\fR which is assumed to be already
conformant to the IO::Handle interface.
In this case, you just get back that object.
.RE
.RS 4
.RE
.PP
If you get back an IO::Wrap object, it will obey a basic subset of
the \s-1IO::\s0 interface.  That is, the following methods (note: I said
\&\fImethods\fR, not named operators) should work on the thing you get back:
.PP
.Vb 7
\&    close 
\&    getline 
\&    getlines 
\&    print ARGS...
\&    read BUFFER,NBYTES
\&    seek POS,WHENCE
\&    tell
.Ve
.SH "NOTES"
.IX Header "NOTES"
Clearly, when wrapping a raw external filehandle (like \e*STDOUT), 
I didn't want to close the file descriptor when the \*(L"wrapper\*(R" object is
destroyed... since the user might not appreciate that!  Hence,
there's no \s-1DESTROY\s0 method in this class.
.PP
When wrapping a FileHandle object, however, I believe that Perl will 
invoke the FileHandle::DESTROY when the last reference goes away,
so in that case, the filehandle is closed if the wrapped FileHandle
really was the last reference to it.
.SH "WARNINGS"
.IX Header "WARNINGS"
This module does not allow you to wrap filehandle names which are given
as strings that lack the package they were opened in. That is, if a user 
opens \s-1FOO\s0 in package Foo, they must pass it to you either as \f(CW\*(C`\e*FOO\*(C'\fR 
or as \f(CW"Foo::FOO"\fR.  However, \f(CW"STDIN"\fR and friends will work just fine.
.SH "VERSION"
.IX Header "VERSION"
\&\f(CW$Id:\fR Wrap.pm,v 1.2 2005/02/10 21:21:53 dfs Exp $
.SH "AUTHOR"
.IX Header "AUTHOR"
.IP "Primary Maintainer" 4
.IX Item "Primary Maintainer"
David F. Skoll (\fIdfs@roaringpenguin.com\fR).
.IP "Original Author" 4
.IX Item "Original Author"
Eryq (\fIeryq@zeegee.com\fR).
President, ZeeGee Software Inc (\fIhttp://www.zeegee.com\fR).
.SH "POD ERRORS"
.IX Header "POD ERRORS"
Hey! \fBThe above document had some coding errors, which are explained below:\fR
.IP "Around line 212:" 4
.IX Item "Around line 212:"
\&'=item' outside of any '=over'
.Sp
=over without closing =back
