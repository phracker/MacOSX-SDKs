.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Parse::Eyapp::YATW 3"
.TH Parse::Eyapp::YATW 3 "2012-03-23" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Parse::Eyapp::YATW \- Tree transformation objects
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 4
\&  #!/usr/bin/perl \-w
\&  use strict;
\&  use Rule6;
\&  use Parse::Eyapp::YATW;
\&
\&  my %BinaryOperation = (PLUS=>\*(Aq+\*(Aq, MINUS => \*(Aq\-\*(Aq, TIMES=>\*(Aq*\*(Aq, DIV => \*(Aq/\*(Aq);
\&
\&  sub set_terminfo {
\&    no warnings;
\&    *TERMINAL::info = sub { $_[0]{attr} };
\&  }
\&  sub is_foldable {
\&    my ($op, $left, $right);
\&    return 0 unless defined($op = $BinaryOperation{ref($_[0])});
\&    return 0 unless ($left = $_[0]\->child(0), $left\->isa(\*(AqNUM\*(Aq));
\&    return 0 unless ($right = $_[0]\->child(1), $right\->isa(\*(AqNUM\*(Aq));
\&
\&    my $leftnum = $left\->child(0)\->{attr};
\&    my $rightnum = $right\->child(0)\->{attr};
\&    $left\->child(0)\->{attr} = eval "$leftnum $op $rightnum";
\&    $_[0] = $left;
\&  }
\&
\&  my $parser = new Rule6();
\&  my $input = "2*3";
\&  my $t = $parser\->Run(\e$input);
\&  &set_terminfo;
\&  print "\en***** Before ******\en";
\&  print $t\->str;
\&  my $p = Parse::Eyapp::YATW\->new(PATTERN => \e&is_foldable);
\&  $p\->s($t);
\&  print "\en***** After ******\en";
\&  print $t\->str."\en";
.Ve
.SH "INTRODUCTION"
.IX Header "INTRODUCTION"
\&\f(CW\*(C`Parse::Eyapp:YATW\*(C'\fR objects implement tree transformations.
They have two attributes \f(CW\*(C`PATTERN\*(C'\fR and \f(CW\*(C`NAME\*(C'\fR.
\&\f(CW\*(C`PATTERN\*(C'\fR is a reference to the code implementing the transformation.
\&\f(CW\*(C`NAME\*(C'\fR is the name of the transformation.
.PP
Though usually you build a transformation by means of Treeregexp programs
you can directly invoke the method \f(CW\*(C`new\*(C'\fR to build a tree transformation.
A transformation object can be built from a function 
that conforms to the \s-1YATW\s0 tree transformation call protocol
.PP
For a subroutine  \f(CW\*(C`pattern_sub\*(C'\fR to work as a \s-1YATW\s0 tree transformation
\&\- as subroutine \f(CW\*(C`is_foldable\*(C'\fR in the \s-1SYNOPSIS\s0 section \- has to conform to the following
call description:
.PP
.Vb 6
\&  pattern_sub(
\&      $_[0],  # Node being visited
\&      $_[1],  # Father of this node
\&      $index, # Index of this node in @Father\->children
\&      $self,  # The YATW pattern object
\&  );
.Ve
.PP
The \f(CW\*(C`pattern_sub\*(C'\fR must return \s-1TRUE\s0 if matched 
and \s-1FALSE\s0 otherwise.
.PP
The function \f(CW\*(C`is_foldable\*(C'\fR in the \s-1SYNOPSIS\s0 section
(file \f(CW\*(C`examples/YATW/foldrule6.pl\*(C'\fR)
holds the properties to be a \s-1YATW\s0 tree transformation
.PP
.Vb 12
\&     1    sub is_foldable {
\&     2      my ($op, $left, $right);
\&     3  
\&     4      return 0 unless defined($op = $BinaryOperation{ref($_[0])});
\&     5      return 0 unless ($left = $_[0]\->child(0), $left\->isa(\*(AqNUM\*(Aq));
\&     6      return 0 unless ($right = $_[0]\->child(1), $right\->isa(\*(AqNUM\*(Aq));
\&     7  
\&     8      my $leftnum = $left\->child(0)\->{attr};
\&     9      my $rightnum = $right\->child(0)\->{attr};
\&    10      $left\->child(0)\->{attr} = eval "$leftnum $op $rightnum";
\&    11      $_[0] = $left;
\&    12    }
.Ve
.PP
First, checks that the current node is one of \f(CW\*(C`PLUS\*(C'\fR, \f(CW\*(C`MINUS\*(C'\fR, \f(CW\*(C`TIMES\*(C'\fR or
\&\f(CW\*(C`DIV\*(C'\fR (line 4). Then checks that both children are \f(CW\*(C`NUM\*(C'\fRbers (lines 5 and 6).
In such case proceeds to modify its left child with the result of operating
both children (line 10). The matching tree is finally substituted by its left child
(line 11).
.PP
This is the output of the program in the \s-1SYNOPSIS\s0 section:
.PP
.Vb 1
\&  pl@nereida:~/LEyapp/examples$ eyapp Rule6.yp; foldrule6.pl
\&
\&  ***** Before ******
\&  TIMES(NUM(TERMINAL[2]),NUM(TERMINAL[3]))
\&  ***** After ******
\&  NUM(TERMINAL[6])
.Ve
.PP
Follows the grammar description file in \f(CW\*(C`Rule6.yp\*(C'\fR:
.PP
.Vb 10
\&  pl@nereida:~/LEyapp/examples$ cat \-n Rule6.yp
\&     1  %{
\&     2  use Data::Dumper;
\&     3  %}
\&     4  %right  \*(Aq=\*(Aq
\&     5  %left   \*(Aq\-\*(Aq \*(Aq+\*(Aq
\&     6  %left   \*(Aq*\*(Aq \*(Aq/\*(Aq
\&     7  %left   NEG
\&     8  %tree
\&     9
\&    10  %%
\&    11  line: exp  { $_[1] }
\&    12  ;
\&    13
\&    14  exp:      %name NUM
\&    15              NUM
\&    16          | %name VAR
\&    17            VAR
\&    18          | %name ASSIGN
\&    19            VAR \*(Aq=\*(Aq exp
\&    20          | %name PLUS
\&    21            exp \*(Aq+\*(Aq exp
\&    22          | %name MINUS
\&    23            exp \*(Aq\-\*(Aq exp
\&    24          | %name TIMES
\&    25            exp \*(Aq*\*(Aq exp
\&    26          | %name DIV
\&    27            exp \*(Aq/\*(Aq exp
\&    28          | %name UMINUS
\&    29            \*(Aq\-\*(Aq exp %prec NEG
\&    30          |   \*(Aq(\*(Aq exp \*(Aq)\*(Aq  { $_[2] } /* Let us simplify a bit the tree */
\&    31  ;
\&    32
\&    33  %%
\&    34
\&    35  use Tail2;
.Ve
.PP
The module \f(CW\*(C`Tail2\*(C'\fR in file \f(CW\*(C`examples/Tail2.pm\*(C'\fR  implements the lexical 
analyzer plus the \f(CW\*(C`error\*(C'\fR and \f(CW\*(C`run\*(C'\fR methods.
.SH "Parse::Eyapp:YATW  Methods"
.IX Header "Parse::Eyapp:YATW Methods"
\&\f(CW\*(C`Parse::Eyapp:YATW\*(C'\fR objects represent tree transformations.
They carry the information of what nodes match and how to modify
them.
.SS "Parse::Eyapp::YATW\->new"
.IX Subsection "Parse::Eyapp::YATW->new"
Builds a treeregexp transformation object.
Though usually you build a transformation by means of Treeregexp programs
you can directly invoke the method to build a tree transformation.
A transformation object can be built from a function 
that conforms to the \s-1YATW\s0 tree transformation call protocol
(see the section \*(L"The \s-1YATW\s0 Tree Transformation Call Protocol\*(R").
Follows an example (file \f(CW\*(C`examples/12ts_simplify_with_s.pl\*(C'\fR):
.PP
.Vb 10
\& nereida:~/src/perl/YappWithDefaultAction/examples> \e
\&        sed \-ne \*(Aq68,$p\*(Aq 12ts_simplify_with_s.pl | cat \-n
\&  1  sub is_code {
\&  2    my $self = shift; # tree
\&  3
\&  4    # After the shift $_[0] is the father, $_[1] the index
\&  5    if ((ref($self) eq \*(AqCODE\*(Aq)) {
\&  6      splice(@{$_[0]\->{children}}, $_[1], 1);
\&  7      return 1;
\&  8    }
\&  9    return 0;
\& 10  }
\& 11
\& 12  Parse::Eyapp\->new_grammar(
\& 13    input=>$translationscheme,
\& 14    classname=>\*(AqCalc\*(Aq,
\& 15    firstline =>7,
\& 16  );
\& 17  my $parser = Calc\->new();                # Create the parser
\& 18
\& 19  $parser\->YYData\->{INPUT} = "2*\-3\en";  print "2*\-3\en"; # Set the input
\& 20  my $t = $parser\->Run;                    # Parse it
\& 21  print $t\->str."\en";
\& 22  my $p = Parse::Eyapp::YATW\->new(PATTERN => \e&is_code);
\& 23  $p\->s($t);
\& 24  { no warnings; # make attr info available only for this display
\& 25    local *TERMINAL::info = sub { $_[0]{attr} };
\& 26    print $t\->str."\en";
\& 27  }
.Ve
.PP
After the \f(CW\*(C`Parse::Eyapp::YATW\*(C'\fR object \f(CW$p\fR is built at line 22
the call to method \f(CW\*(C`$p\->s($t)\*(C'\fR applies  the 
transformation \f(CW\*(C`is_code\*(C'\fR using a bottom-up traversing of the tree \f(CW$t\fR.
The achieved effect is the elimination of \f(CW\*(C`CODE\*(C'\fR references
in the translation scheme tree.
When executed the former code produces:
.PP
.Vb 4
\& nereida:~/src/perl/YappWithDefaultAction/examples> 12ts_simplify_with_s.pl
\& 2*\-3
\& EXP(TIMES(NUM(TERMINAL,CODE),TERMINAL,UMINUS(TERMINAL,NUM(TERMINAL,CODE),CODE),CODE),CODE)
\& EXP(TIMES(NUM(TERMINAL[2]),TERMINAL[*],UMINUS(TERMINAL[\-],NUM(TERMINAL[3]))))
.Ve
.PP
The file \f(CW\*(C`foldrule6.pl\*(C'\fR in the \f(CW\*(C`examples/\*(C'\fR distribution directory
gives you another example:
.PP
.Vb 10
\& nereida:~/src/perl/YappWithDefaultAction/examples> cat \-n foldrule6.pl
\&   1  #!/usr/bin/perl \-w
\&   2  use strict;
\&   3  use Rule6;
\&   4  use Parse::Eyapp::YATW;
\&   5
\&   6  my %BinaryOperation = (PLUS=>\*(Aq+\*(Aq, MINUS => \*(Aq\-\*(Aq, TIMES=>\*(Aq*\*(Aq, DIV => \*(Aq/\*(Aq);
\&   7
\&   8  sub set_terminfo {
\&   9    no warnings;
\&  10    *TERMINAL::info = sub { $_[0]{attr} };
\&  11  }
\&  12  sub is_foldable {
\&  13    my ($op, $left, $right);
\&  14    return 0 unless defined($op = $BinaryOperation{ref($_[0])});
\&  15    return 0 unless ($left = $_[0]\->child(0), $left\->isa(\*(AqNUM\*(Aq));
\&  16    return 0 unless ($right = $_[0]\->child(1), $right\->isa(\*(AqNUM\*(Aq));
\&  17
\&  18    my $leftnum = $left\->child(0)\->{attr};
\&  19    my $rightnum = $right\->child(0)\->{attr};
\&  20    $left\->child(0)\->{attr} = eval "$leftnum $op $rightnum";
\&  21    $_[0] = $left;
\&  22  }
\&  23
\&  24  my $parser = new Rule6();
\&  25  $parser\->YYData\->{INPUT} = "2*3";
\&  26  my $t = $parser\->Run;
\&  27  &set_terminfo;
\&  28  print "\en***** Before ******\en";
\&  29  print $t\->str;
\&  30  my $p = Parse::Eyapp::YATW\->new(PATTERN => \e&is_foldable);
\&  31  $p\->s($t);
\&  32  print "\en***** After ******\en";
\&  33  print $t\->str."\en";
.Ve
.PP
when executed produces:
.PP
.Vb 1
\& nereida:~/src/perl/YappWithDefaultAction/examples> foldrule6.pl
\&
\& ***** Before ******
\& TIMES(NUM(TERMINAL[2]),NUM(TERMINAL[3]))
\& ***** After ******
\& NUM(TERMINAL[6])
.Ve
.SS "The \s-1YATW\s0 Tree Transformation Call Protocol"
.IX Subsection "The YATW Tree Transformation Call Protocol"
For a subroutine  \f(CW\*(C`pattern_sub\*(C'\fR to work as a \s-1YATW\s0 tree transformation
\&\- as subroutines \f(CW\*(C`is_foldable\*(C'\fR and  \f(CW\*(C`is_code\*(C'\fR above \- has to conform to the following
call description:
.PP
.Vb 6
\&  pattern_sub(
\&      $_[0],  # Node being visited
\&      $_[1],  # Father of this node
\&      $index, # Index of this node in @Father\->children
\&      $self,  # The YATW pattern object
\&  );
.Ve
.PP
The \f(CW\*(C`pattern_sub\*(C'\fR must return \s-1TRUE\s0 if matched 
and \s-1FALSE\s0 otherwise.
.PP
The protocol may change in the near future. 
Avoid using other information than the fact that 
the first argument 
is the node being visited.
.SS "Parse::Eyapp::YATW\->buildpatterns"
.IX Subsection "Parse::Eyapp::YATW->buildpatterns"
Works as \f(CW\*(C`Parse::Eyapp\->new\*(C'\fR but receives an array of subs 
conforming to the \s-1YATW\s0 Tree Transformation Call Protocol.
.PP
.Vb 1
\&  our @all = Parse::Eyapp::YATW\->buildpatt(\e&delete_code, \e&delete_tokens);
.Ve
.ie n .SS "$yatw\->delete"
.el .SS "\f(CW$yatw\fP\->delete"
.IX Subsection "$yatw->delete"
The root of the tree that is currently matched 
by the \s-1YATW\s0 transformation \f(CW$yatw\fR will be deleted from 
the tree as soon as is safe. That usually means 
when the processing of their siblings
is finished. The following
example (taken from file \f(CW\*(C`examples/13ts_simplify_with_delete.pl\*(C'\fR in 
the Parse::Eyapp distribution) 
illustrates how to eliminate \s-1CODE\s0 and syntactic terminals from the 
syntax tree:
.PP
.Vb 10
\& pl@nereida:~/src/perl/YappWithDefaultAction/examples$ \e
\&        sed \-ne \*(Aq62,$p\*(Aq 13ts_simplify_with_delete.pl | cat \-n
\&  1  sub not_useful {
\&  2    my $self = shift; # node
\&  3    my $pat = $_[2];  # get the YATW object
\&  4
\&  5    (ref($self) eq \*(AqCODE\*(Aq) or ((ref($self) eq \*(AqTERMINAL\*(Aq) and ($self\->{token} eq $self\->{attr}))
\&  6      or do { return 0 };
\&  7    $pat\->delete();
\&  8    return 1;
\&  9  }
\& 10
\& 11  Parse::Eyapp\->new_grammar(
\& 12    input=>$translationscheme,
\& 13    classname=>\*(AqCalc\*(Aq,
\& 14    firstline =>7,
\& 15  );
\& 16  my $parser = Calc\->new();                # Create the parser
\& 17
\& 18  $parser\->YYData\->{INPUT} = "2*3\en"; print $parser\->YYData\->{INPUT};
\& 19  my $t = $parser\->Run;                    # Parse it
\& 20  print $t\->str."\en";                      # Show the tree
\& 21  my $p = Parse::Eyapp::YATW\->new(PATTERN => \e&not_useful); 
\& 22  $p\->s($t);                               # Delete nodes
\& 23  print $t\->str."\en";                      # Show the tree
.Ve
.PP
when executed we get the following output:
.PP
.Vb 4
\& pl@nereida:~/src/perl/YappWithDefaultAction/examples$ 13ts_simplify_with_delete.pl
\& 2*3
\& EXP(TIMES(NUM(TERMINAL[2],CODE),TERMINAL[*],NUM(TERMINAL[3],CODE),CODE))
\& EXP(TIMES(NUM(TERMINAL[2]),NUM(TERMINAL[3])))
.Ve
.ie n .SS "$yatw\->unshift"
.el .SS "\f(CW$yatw\fP\->unshift"
.IX Subsection "$yatw->unshift"
The call \f(CW\*(C`$yatw\->unshift($b)\*(C'\fR 
safely unshifts (inserts at the beginning)
the node \f(CW$b\fR in the list of its 
siblings of the node that matched (i.e in the list of siblings of \f(CW$_[0]\fR). 
The following example
shows a \s-1YATW\s0 transformation
\&\f(CW\*(C`insert_child\*(C'\fR that illustrates the use of \f(CW\*(C`unshift\*(C'\fR (file \f(CW\*(C`examples/26delete_with_trreereg.pl\*(C'\fR):
.PP
.Vb 10
\& pl@nereida:~/src/perl/YappWithDefaultAction/examples$ \e
\&         sed \-ne \*(Aq70,$p\*(Aq 26delete_with_trreereg.pl | cat \-n
\&  1  my $transform = Parse::Eyapp::Treeregexp\->new( STRING => q{
\&  2
\&  3      delete_code : CODE => { $delete_code\->delete() }
\&  4
\&  5      {
\&  6        sub not_semantic {
\&  7          my $self = shift;
\&  8          return  1 if ((ref($self) eq \*(AqTERMINAL\*(Aq) and ($self\->{token} eq $self\->{attr}));
\&  9          return 0;
\& 10        }
\& 11      }
\& 12
\& 13      delete_tokens : TERMINAL and { not_semantic($TERMINAL) } => {
\& 14        $delete_tokens\->delete();
\& 15      }
\& 16
\& 17      insert_child : TIMES(NUM(TERMINAL), NUM(TERMINAL)) => {
\& 18        my $b = Parse::Eyapp::Node\->new( \*(AqUMINUS(TERMINAL)\*(Aq,
\& 19          sub { $_[1]\->{attr} = \*(Aq4.5\*(Aq }); # The new node will be a sibling of TIMES
\& 20
\& 21        $insert_child\->unshift($b); 
\& 22      }
\& 23    },
\& 24  )\->generate();
\& 25
\& 26  Parse::Eyapp\->new_grammar(
\& 27    input=>$translationscheme,
\& 28    classname=>\*(AqCalc\*(Aq,
\& 29    firstline =>7,
\& 30  );
\& 31  my $parser = Calc\->new();                # Create the parser
\& 32
\& 33  $parser\->YYData\->{INPUT} = "2*3\en"; print $parser\->YYData\->{INPUT}; # Set the input
\& 34  my $t = $parser\->Run;                # Parse it
\& 35  print $t\->str."\en";                        # Show the tree
\& 36  # Get the AST
\& 37  our ($delete_tokens, $delete_code);
\& 38  $t\->s($delete_tokens, $delete_code);
\& 39  print $t\->str."\en";                        # Show the tree
\& 40  our $insert_child;
\& 41  $insert_child\->s($t);
\& 42  print $t\->str."\en";                        # Show the tree
.Ve
.PP
When is executed the program produces the following output:
.PP
.Vb 5
\& pl@nereida:~/src/perl/YappWithDefaultAction/examples$ 26delete_with_trreereg.pl
\& 2*3
\& EXP(TIMES(NUM(TERMINAL[2],CODE),TERMINAL[*],NUM(TERMINAL[3],CODE),CODE))
\& EXP(TIMES(NUM(TERMINAL[2]),NUM(TERMINAL[3])))
\& EXP(UMINUS(TERMINAL[4.5]),TIMES(NUM(TERMINAL[2]),NUM(TERMINAL[3])))
.Ve
.PP
Don't try to take advantage that the transformation sub receives
in \f(CW$_[1]\fR a reference to the father 
(see the section \*(L"The \s-1YATW\s0 Tree Transformation Call Protocol\*(R") 
and do something like:
.PP
.Vb 1
\&  unshift $_[1]\->{children}, $b
.Ve
.PP
it is unsafe.
.ie n .SS "$yatw\->insert_before"
.el .SS "\f(CW$yatw\fP\->insert_before"
.IX Subsection "$yatw->insert_before"
A call to \f(CW\*(C`$yatw\->insert_before($node)\*(C'\fR safely inserts 
\&\f(CW$node\fR in the list of siblings of \f(CW$_[0]\fR
just before \f(CW$_[0]\fR (i.e. the node that matched with \f(CW$yatw\fR).
The following example (see
file \f(CW\*(C`examples/YATW/moveinvariantoutofloopcomplexformula.pl\*(C'\fR)
illustrates its use:
.PP
.Vb 9
\&  my $p = Parse::Eyapp::Treeregexp\->new( STRING => q{
\&    moveinvariant: WHILE(VAR($b), BLOCK(@a, ASSIGN($x, $e), @c)) 
\&         and { is_invariant($ASSIGN, $WHILE) } => {
\&           my $assign = $ASSIGN;
\&           $BLOCK\->delete($ASSIGN);
\&           $moveinvariant\->insert_before($assign);
\&         }
\&    },
\&  );
.Ve
.PP
Here the \f(CW\*(C`ASSIGN($x, $e)\*(C'\fR subtree \- if is loop invariant \- 
will be moved
to the list of siblings of \f(CW$WHILE\fR
just before the \f(CW$WHILE\fR.
Thus a program like
.PP
.Vb 1
\&  "a =1000; c = 1; while (a) { c = c*a; b = 5; a = a\-1 }\en"
.Ve
.PP
is transformed in s.t. like:
.PP
.Vb 1
\&  "a =1000; c = 1; b = 5; while (a) { c = c*a; a = a\-1 }\en"
.Ve
.SH "TREE MATCHING AND TREE SUBSTITUTION"
.IX Header "TREE MATCHING AND TREE SUBSTITUTION"
See the documentation in Parse::Eyapp::treematchingtut
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.IP "\(bu" 4
The project home is at <http://code.google.com/p/parse\-eyapp/>.
Use a subversion client to anonymously check out the latest project source code:
.Sp
.Vb 1
\&   svn checkout http://parse\-eyapp.googlecode.com/svn/trunk/ parse\-eyapp\-read\-only
.Ve
.IP "\(bu" 4
The tutorial \fIParsing Strings and Trees with\fR \f(CW\*(C`Parse::Eyapp\*(C'\fR
(An Introduction to Compiler Construction in seven pages) in
<http://nereida.deioc.ull.es/~pl/eyapsimple/>
.IP "\(bu" 4
Parse::Eyapp, 
Parse::Eyapp::eyapplanguageref, 
Parse::Eyapp::debuggingtut,
Parse::Eyapp::defaultactionsintro,
Parse::Eyapp::translationschemestut,
Parse::Eyapp::Driver,
Parse::Eyapp::Node,
Parse::Eyapp::YATW,
Parse::Eyapp::Treeregexp,
Parse::Eyapp::Scope,
Parse::Eyapp::Base,
Parse::Eyapp::datagenerationtut
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/languageintro.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/debuggingtut.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/eyapplanguageref.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/Treeregexp.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/Node.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/YATW.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/Eyapp.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/Base.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/translationschemestut.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/treematchingtut.pdf>
.IP "\(bu" 4
perldoc eyapp,
.IP "\(bu" 4
perldoc treereg,
.IP "\(bu" 4
perldoc vgg,
.IP "\(bu" 4
The Syntax Highlight file for vim at <http://www.vim.org/scripts/script.php?script_id=2453>
and <http://nereida.deioc.ull.es/~vim/>
.IP "\(bu" 4
\&\fIAnalisis Lexico y Sintactico\fR, (Notes for a course in compiler 
construction) by  Casiano Rodriguez-Leon. 
Available at  <http://nereida.deioc.ull.es/~pl/perlexamples/>
Is the more complete and reliable source for Parse::Eyapp. However is in Spanish.
.IP "\(bu" 4
Parse::Yapp,
.IP "\(bu" 4
Man pages of \fIyacc\fR\|(1) and
\&\fIbison\fR\|(1),
<http://www.delorie.com/gnu/docs/bison/bison.html>
.IP "\(bu" 4
Language::AttributeGrammar
.IP "\(bu" 4
Parse::RecDescent.
.IP "\(bu" 4
HOP::Parser
.IP "\(bu" 4
HOP::Lexer
.IP "\(bu" 4
ocamlyacc tutorial at 
<http://plus.kaist.ac.kr/~shoh/ocaml/ocamllex\-ocamlyacc/ocamlyacc\-tutorial/ocamlyacc\-tutorial.html>
.SH "REFERENCES"
.IX Header "REFERENCES"
.IP "\(bu" 4
The classic Dragon's book \fICompilers: Principles, Techniques, and Tools\fR 
by Alfred V. Aho, Ravi Sethi and
Jeffrey D. Ullman (Addison-Wesley 1986)
.IP "\(bu" 4
\&\fI\s-1CS2121:\s0 The Implementation and Power of Programming Languages\fR
(See <http://www.cs.man.ac.uk/~pjj>, <http://www.cs.man.ac.uk/~pjj/complang/g2lr.html> 
and <http://www.cs.man.ac.uk/~pjj/cs2121/ho/ho.html>) by 
Pete Jinks
.SH "CONTRIBUTORS"
.IX Header "CONTRIBUTORS"
.IP "\(bu" 2
Hal Finkel <http://www.halssoftware.com/>
.IP "\(bu" 2
G. Williams <http://kasei.us/>
.IP "\(bu" 2
Thomas L. Shinnick <http://search.cpan.org/~tshinnic/>
.IP "\(bu" 2
Frank Leray
.SH "AUTHOR"
.IX Header "AUTHOR"
Casiano Rodriguez-Leon (casiano@ull.es)
.SH "ACKNOWLEDGMENTS"
.IX Header "ACKNOWLEDGMENTS"
This work has been supported by \s-1CEE \s0(\s-1FEDER\s0) and the Spanish Ministry of
\&\fIEducacion y Ciencia\fR through \fIPlan Nacional I+D+I\fR number \s-1TIN2005\-08818\-C04\-04
\&\s0(\s-1ULL::OPLINK\s0 project <http://www.oplink.ull.es/>). 
Support from Gobierno de Canarias was through \s-1GC02210601
\&\s0(\fIGrupos Consolidados\fR).
The University of La Laguna has also supported my work in many ways
and for many years.
.PP
A large percentage of  code is verbatim taken from Parse::Yapp 1.05.
The author of Parse::Yapp is Francois Desarmenien.
.PP
I wish to thank Francois Desarmenien for his Parse::Yapp module, 
to my students at La Laguna and to the Perl Community. Thanks to 
the people who have contributed to improve the module (see \*(L"\s-1CONTRIBUTORS\*(R"\s0 in Parse::Eyapp).
Thanks to Larry Wall for giving us Perl.
Special thanks to Juana.
.SH "LICENCE AND COPYRIGHT"
.IX Header "LICENCE AND COPYRIGHT"
Copyright (c) 2006\-2008 Casiano Rodriguez-Leon (casiano@ull.es). All rights reserved.
.PP
Parse::Yapp copyright is of Francois Desarmenien, all rights reserved. 1998\-2001
.PP
These modules are free software; you can redistribute it and/or
modify it under the same terms as Perl itself. See perlartistic.
.PP
This program is distributed in the hope that it will be useful,
but \s-1WITHOUT ANY WARRANTY\s0; without even the implied warranty of
\&\s-1MERCHANTABILITY\s0 or \s-1FITNESS FOR A PARTICULAR PURPOSE. \s0
