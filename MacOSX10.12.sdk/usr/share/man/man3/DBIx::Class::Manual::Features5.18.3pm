.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "DBIx::Class::Manual::Features 3"
.TH DBIx::Class::Manual::Features 3 "2014-01-05" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
DBIx::Class::Manual::Features \- A boatload of DBIx::Class features with links to respective documentation
.SH "META"
.IX Header "META"
.SS "Large Community"
.IX Subsection "Large Community"
Currently there are 88 people listed as contributors to \s-1DBIC. \s0 That ranges
from documentation help, to test help, to added features, to entire database
support.
.SS "Active Community"
.IX Subsection "Active Community"
Currently (June 9, 2010) 6 active branches (committed to
in the last two weeks) in git.  Last release (0.08122)
had 14 new features, and 16 bug fixes.  Of course that
ebbs and flows <http://git.shadowcat.co.uk/gitweb/gitweb.cgi?p=dbsrgits/DBIx-Class.git;a=blob;f=Changes>.)
.SS "Responsive Community"
.IX Subsection "Responsive Community"
.IP "I needed \s-1MSSQL\s0 order-by support; the community helped me add support" 1
.IX Item "I needed MSSQL order-by support; the community helped me add support"
.PD 0
.IP "generally very welcoming of people willing to help" 1
.IX Item "generally very welcoming of people willing to help"
.PD
.SH "General ORM"
.IX Header "General ORM"
These are things that are in most other ORMs, but are still reasons to use
\&\s-1DBIC\s0 over raw \s-1SQL.\s0
.SS "Cross \s-1DB\s0"
.IX Subsection "Cross DB"
The vast majority of code should run on all databases without needing tweaking
.SS "Basic \s-1CRUD\s0"
.IX Subsection "Basic CRUD"
.IP "C \- Create" 1
.IX Item "C - Create"
.PD 0
.IP "R \- Retrieve" 1
.IX Item "R - Retrieve"
.IP "U \- Update" 1
.IX Item "U - Update"
.IP "D \- Delete" 1
.IX Item "D - Delete"
.PD
.SS "\s-1SQL:\s0 Create"
.IX Subsection "SQL: Create"
.Vb 5
\& my $sth = $dbh\->prepare(\*(Aq
\&    INSERT INTO books
\&    (title, author_id)
\&    values (?,?)
\& \*(Aq);
\&
\& $sth\->execute( \*(AqA book title\*(Aq, $author_id );
.Ve
.SS "\s-1DBIC:\s0 Create"
.IX Subsection "DBIC: Create"
.Vb 4
\& my $book = $book_rs\->create({
\&    title     => \*(AqA book title\*(Aq,
\&    author_id => $author_id,
\& });
.Ve
.PP
See \*(L"create\*(R" in DBIx::Class::ResultSet
.IP "No need to pair placeholders and values" 1
.IX Item "No need to pair placeholders and values"
.PD 0
.IP "Automatically gets autoincremented id for you" 1
.IX Item "Automatically gets autoincremented id for you"
.IP "Transparently uses \s-1INSERT ... RETURNING\s0 for databases that support it" 1
.IX Item "Transparently uses INSERT ... RETURNING for databases that support it"
.PD
.SS "\s-1SQL:\s0 Read"
.IX Subsection "SQL: Read"
.Vb 6
\& my $sth = $dbh\->prepare(\*(Aq
\&    SELECT title,
\&    authors.name as author_name
\&    FROM books, authors
\&    WHERE books.author = authors.id
\& \*(Aq);
\&
\& while ( my $book = $sth\->fetchrow_hashref ) {
\&   say "Author of $book\->{title} is $book\->{author_name}";
\& }
.Ve
.SS "\s-1DBIC:\s0 Read"
.IX Subsection "DBIC: Read"
.Vb 1
\& my $book = $book_rs\->find($book_id);
.Ve
.PP
or
.PP
.Vb 1
\& my $book = $book_rs\->search({ title => \*(AqA book title\*(Aq }, { rows => 1 })\->next;
.Ve
.PP
or
.PP
.Vb 1
\& my @books = $book_rs\->search({ author => $author_id })\->all;
.Ve
.PP
or
.PP
.Vb 3
\& while( my $book = $books_rs\->next ) {
\&   printf "Author of %s is %s\en", $book\->title, $book\->author\->name;
\& }
.Ve
.PP
See \*(L"find\*(R" in DBIx::Class::ResultSet, \*(L"search\*(R" in DBIx::Class::ResultSet, \*(L"next\*(R" in DBIx::Class::ResultSet, and \*(L"all\*(R" in DBIx::Class::ResultSet
.PP
\&\fB\s-1TMTOWTDI\s0!\fR
.SS "\s-1SQL:\s0 Update"
.IX Subsection "SQL: Update"
.Vb 5
\& my $update = $dbh\->prepare(\*(Aq
\&    UPDATE books
\&    SET title = ?
\&    WHERE id = ?
\& \*(Aq);
\&
\& $update\->execute( \*(AqNew title\*(Aq, $book_id );
.Ve
.SS "\s-1DBIC:\s0 Update"
.IX Subsection "DBIC: Update"
.Vb 1
\& $book\->update({ title => \*(AqNew title\*(Aq });
.Ve
.PP
See \*(L"update\*(R" in DBIx::Class::Row
.PP
Will not update unless value changes
.SS "\s-1SQL:\s0 Delete"
.IX Subsection "SQL: Delete"
.Vb 1
\& my $delete = $dbh\->prepare(\*(AqDELETE FROM books WHERE id = ?\*(Aq);
\&
\& $delete\->execute($book_id);
.Ve
.SS "\s-1DBIC:\s0 Delete"
.IX Subsection "DBIC: Delete"
.Vb 1
\& $book\->delete
.Ve
.PP
See \*(L"delete\*(R" in DBIx::Class::Row
.SS "\s-1SQL:\s0 Search"
.IX Subsection "SQL: Search"
.Vb 7
\& my $sth = $dbh\->prepare(\*(Aq
\&   SELECT title,
\&   authors.name as author_name
\&   FROM books
\&   WHERE books.name LIKE "%monte cristo%" AND
\&   books.topic = "jailbreak"
\& \*(Aq);
.Ve
.SS "\s-1DBIC:\s0 Search"
.IX Subsection "DBIC: Search"
.Vb 4
\& my $book = $book_rs\->search({
\&    \*(Aqme.name\*(Aq  => { \-like => \*(Aq%monte cristo%\*(Aq },
\&    \*(Aqme.topic\*(Aq => \*(Aqjailbreak\*(Aq,
\& })\->next;
.Ve
.ie n .IP "See SQL::Abstract, ""next"" in DBIx::Class::ResultSet, and ""search"" in DBIx::Class::ResultSet" 1
.el .IP "See SQL::Abstract, ``next'' in DBIx::Class::ResultSet, and ``search'' in DBIx::Class::ResultSet" 1
.IX Item "See SQL::Abstract, next in DBIx::Class::ResultSet, and search in DBIx::Class::ResultSet"
.PD 0
.IP "(kinda) introspectible" 1
.IX Item "(kinda) introspectible"
.IP "Prettier than \s-1SQL\s0" 1
.IX Item "Prettier than SQL"
.PD
.SS "\s-1OO\s0 Overridability"
.IX Subsection "OO Overridability"
.IP "Override new if you want to do validation" 1
.IX Item "Override new if you want to do validation"
.PD 0
.IP "Override delete if you want to disable deletion" 1
.IX Item "Override delete if you want to disable deletion"
.IP "and on and on" 1
.IX Item "and on and on"
.PD
.SS "Convenience Methods"
.IX Subsection "Convenience Methods"
.ie n .IP """find_or_create"" in DBIx::Class::ResultSet" 1
.el .IP "``find_or_create'' in DBIx::Class::ResultSet" 1
.IX Item "find_or_create in DBIx::Class::ResultSet"
.PD 0
.ie n .IP """update_or_create"" in DBIx::Class::ResultSet" 1
.el .IP "``update_or_create'' in DBIx::Class::ResultSet" 1
.IX Item "update_or_create in DBIx::Class::ResultSet"
.PD
.SS "Non-column methods"
.IX Subsection "Non-column methods"
Need a method to get a user's gravatar \s-1URL\s0?  Add a \f(CW\*(C`gravatar_url\*(C'\fR method to the
Result class
.SS "\s-1RELATIONSHIPS\s0"
.IX Subsection "RELATIONSHIPS"
.ie n .IP """belongs_to"" in DBIx::Class::Relationship" 1
.el .IP "``belongs_to'' in DBIx::Class::Relationship" 1
.IX Item "belongs_to in DBIx::Class::Relationship"
.PD 0
.ie n .IP """has_many"" in DBIx::Class::Relationship" 1
.el .IP "``has_many'' in DBIx::Class::Relationship" 1
.IX Item "has_many in DBIx::Class::Relationship"
.ie n .IP """might_have"" in DBIx::Class::Relationship" 1
.el .IP "``might_have'' in DBIx::Class::Relationship" 1
.IX Item "might_have in DBIx::Class::Relationship"
.ie n .IP """has_one"" in DBIx::Class::Relationship" 1
.el .IP "``has_one'' in DBIx::Class::Relationship" 1
.IX Item "has_one in DBIx::Class::Relationship"
.ie n .IP """many_to_many"" in DBIx::Class::Relationship" 1
.el .IP "``many_to_many'' in DBIx::Class::Relationship" 1
.IX Item "many_to_many in DBIx::Class::Relationship"
.IP "\s-1SET AND FORGET\s0" 1
.IX Item "SET AND FORGET"
.PD
.SH "DBIx::Class Specific Features"
.IX Header "DBIx::Class Specific Features"
These things may be in other \s-1ORM\s0's, but they are very specific, so doubtful
.SS "\->deploy"
.IX Subsection "->deploy"
Create a database from your DBIx::Class schema.
.PP
.Vb 1
\& my $schema = Frew::Schema\->connect( $dsn, $user, $pass );
\&
\& $schema\->deploy
.Ve
.PP
See \*(L"deploy\*(R" in DBIx::Class::Schema.
.PP
See also: DBIx::Class::DeploymentHandler
.SS "Schema::Loader"
.IX Subsection "Schema::Loader"
Create a DBIx::Class schema from your database.
.PP
.Vb 1
\& package Frew::Schema;
\&
\& use strict;
\& use warnings;
\&
\& use base \*(AqDBIx::Class::Schema::Loader\*(Aq;
\&
\& _\|_PACKAGE_\|_\->loader_options({
\&    naming => \*(Aqv7\*(Aq,
\&    debug  => $ENV{DBIC_TRACE},
\& });
\&
\& 1;
\&
\& # elsewhere...
\&
\& my $schema = Frew::Schema\->connect( $dsn, $user, $pass );
.Ve
.PP
See DBIx::Class::Schema::Loader and \*(L"\s-1CONSTRUCTOR OPTIONS\*(R"\s0 in DBIx::Class::Schema::Loader::Base.
.SS "Populate"
.IX Subsection "Populate"
Made for inserting lots of rows very quickly into database
.PP
.Vb 6
\& $schema\->populate([ Users =>
\&    [qw( username password )],
\&    [qw( frew     >=4char$ )],
\&    [qw(      ...          )],
\&    [qw(      ...          )],
\& );
.Ve
.PP
See \*(L"populate\*(R" in DBIx::Class::Schema
.PP
I use populate here <http://blog.afoolishmanifesto.com/archives/1255> to export our whole
(200M~) db to SQLite
.SS "Multicreate"
.IX Subsection "Multicreate"
Create an object and its related objects all at once
.PP
.Vb 9
\& $schema\->resultset(\*(AqAuthor\*(Aq)\->create({
\&    name => \*(AqStephen King\*(Aq,
\&    books => [{ title => \*(AqThe Dark Tower\*(Aq }],
\&    address => {
\&       street => \*(Aq123 Turtle Back Lane\*(Aq,
\&       state  => { abbreviation => \*(AqME\*(Aq },
\&       city   => { name => \*(AqLowell\*(Aq     },
\&    },
\& });
.Ve
.PP
See \*(L"create\*(R" in DBIx::Class::ResultSet
.IP "books is a has_many" 1
.IX Item "books is a has_many"
.PD 0
.IP "address is a belongs_to which in turn belongs to state and city each" 1
.IX Item "address is a belongs_to which in turn belongs to state and city each"
.IP "for this to work right state and city must mark abbreviation and name as unique" 1
.IX Item "for this to work right state and city must mark abbreviation and name as unique"
.PD
.SS "Extensible"
.IX Subsection "Extensible"
DBIx::Class helped pioneer fast \s-1MI\s0 in Perl 5 with Class::C3, so it is made to
allow extensions to nearly every part of it.
.SS "Extensibility example: DBIx::Class::Helpers"
.IX Subsection "Extensibility example: DBIx::Class::Helpers"
.IP "DBIx::Class::Helper::ResultSet::IgnoreWantarray" 1
.IX Item "DBIx::Class::Helper::ResultSet::IgnoreWantarray"
.PD 0
.IP "DBIx::Class::Helper::ResultSet::Random" 1
.IX Item "DBIx::Class::Helper::ResultSet::Random"
.IP "DBIx::Class::Helper::ResultSet::SetOperations" 1
.IX Item "DBIx::Class::Helper::ResultSet::SetOperations"
.IP "DBIx::Class::Helper::Row::JoinTable" 1
.IX Item "DBIx::Class::Helper::Row::JoinTable"
.IP "DBIx::Class::Helper::Row::NumifyGet" 1
.IX Item "DBIx::Class::Helper::Row::NumifyGet"
.IP "DBIx::Class::Helper::Row::SubClass" 1
.IX Item "DBIx::Class::Helper::Row::SubClass"
.IP "DBIx::Class::Helper::Row::ToJSON" 1
.IX Item "DBIx::Class::Helper::Row::ToJSON"
.IP "DBIx::Class::Helper::Row::StorageValues" 1
.IX Item "DBIx::Class::Helper::Row::StorageValues"
.IP "DBIx::Class::Helper::Row::OnColumnChange" 1
.IX Item "DBIx::Class::Helper::Row::OnColumnChange"
.PD
.SS "Extensibility example: DBIx::Class::TimeStamp"
.IX Subsection "Extensibility example: DBIx::Class::TimeStamp"
.IP "See DBIx::Class::TimeStamp" 1
.IX Item "See DBIx::Class::TimeStamp"
.PD 0
.IP "Cross \s-1DB\s0" 1
.IX Item "Cross DB"
.IP "set_on_create" 1
.IX Item "set_on_create"
.IP "set_on_update" 1
.IX Item "set_on_update"
.PD
.SS "Extensibility example: Kioku"
.IX Subsection "Extensibility example: Kioku"
.IP "See DBIx::Class::Schema::KiokuDB" 1
.IX Item "See DBIx::Class::Schema::KiokuDB"
.PD 0
.IP "Kioku is the new hotness" 1
.IX Item "Kioku is the new hotness"
.IP "Mix \s-1RDBMS\s0 with Object \s-1DB\s0" 1
.IX Item "Mix RDBMS with Object DB"
.PD
.SS "Result vs ResultSet"
.IX Subsection "Result vs ResultSet"
.IP "Result == Row" 1
.IX Item "Result == Row"
.PD 0
.IP "ResultSet == Query Plan" 1
.IX Item "ResultSet == Query Plan"
.RS 1
.IP "Internal Join Optimizer for all \s-1DB\s0's (!!!)" 1
.IX Item "Internal Join Optimizer for all DB's (!!!)"
.RE
.RS 1
.RE
.IP "(less important but...)" 1
.IX Item "(less important but...)"
.IP "ResultSource == Queryable collection of rows (Table, View, etc)" 1
.IX Item "ResultSource == Queryable collection of rows (Table, View, etc)"
.IP "Storage == Database" 1
.IX Item "Storage == Database"
.IP "Schema == associates a set of ResultSources with a Storage" 1
.IX Item "Schema == associates a set of ResultSources with a Storage"
.PD
.SS "ResultSet methods"
.IX Subsection "ResultSet methods"
.Vb 1
\& package MyApp::Schema::ResultSet::Book;
\&
\& use strict;
\& use warnings;
\&
\& use base \*(AqDBIx::Class::ResultSet\*(Aq;
\&
\& sub good {
\&    my $self = shift;
\&    $self\->search({
\&       $self\->current_source_alias . \*(Aq.rating\*(Aq => { \*(Aq>=\*(Aq => 4 }
\&    })
\& };
\&
\& sub cheap {
\&    my $self = shift;
\&    $self\->search({
\&       $self\->current_source_alias . \*(Aq.price\*(Aq => { \*(Aq<=\*(Aq => 5}
\&    })
\& };
\&
\& # ...
\&
\& 1;
.Ve
.PP
See \*(L"Predefined searches\*(R" in DBIx::Class::Manual::Cookbook
.IP "All searches should be ResultSet methods" 1
.IX Item "All searches should be ResultSet methods"
.PD 0
.IP "Name has obvious meaning" 1
.IX Item "Name has obvious meaning"
.ie n .IP """current_source_alias"" in DBIx::Class::ResultSet helps things to work no matter what" 1
.el .IP "``current_source_alias'' in DBIx::Class::ResultSet helps things to work no matter what" 1
.IX Item "current_source_alias in DBIx::Class::ResultSet helps things to work no matter what"
.PD
.SS "ResultSet method in Action"
.IX Subsection "ResultSet method in Action"
.Vb 1
\& $schema\->resultset(\*(AqBook\*(Aq)\->good
.Ve
.SS "ResultSet Chaining"
.IX Subsection "ResultSet Chaining"
.Vb 4
\& $schema\->resultset(\*(AqBook\*(Aq)
\&    \->good
\&    \->cheap
\&    \->recent
.Ve
.SS "search_related"
.IX Subsection "search_related"
.Vb 10
\& my $score = $schema\->resultset(\*(AqUser\*(Aq)
\&    \->search({\*(Aqme.userid\*(Aq => \*(Aqfrew\*(Aq})
\&    \->related_resultset(\*(Aqaccess\*(Aq)
\&    \->related_resultset(\*(Aqmgmt\*(Aq)
\&    \->related_resultset(\*(Aqorders\*(Aq)
\&    \->telephone
\&    \->search_related( shops => {
\&       \*(Aqshops.datecompleted\*(Aq => {
\&          \-between => [\*(Aq2009\-10\-01\*(Aq,\*(Aq2009\-10\-08\*(Aq]
\&       }
\&    })\->completed
\&    \->related_resultset(\*(Aqrpt_score\*(Aq)
\&    \->search(undef, { rows => 1})
\&    \->get_column(\*(Aqraw_scores\*(Aq)
\&    \->next;
.Ve
.PP
The \s-1SQL\s0 that this produces (with placeholders filled in for clarity's sake)
on our system (Microsoft \s-1SQL\s0) is:
.PP
.Vb 10
\& SELECT raw_scores
\&   FROM (
\&     SELECT raw_scores, ROW_NUMBER() OVER (
\&         ORDER BY (
\&             SELECT (1)
\&           )
\&       ) AS rno_\|_row_\|_index
\&       FROM (
\&         SELECT rpt_score.raw_scores
\&           FROM users me
\&           JOIN access access
\&             ON access.userid = me.userid
\&           JOIN mgmt mgmt
\&             ON mgmt.mgmtid = access.mgmtid
\&           JOIN [order] orders
\&             ON orders.mgmtid = mgmt.mgmtid
\&           JOIN shop shops
\&             ON shops.orderno = orders.orderno
\&           JOIN rpt_scores rpt_score
\&             ON rpt_score.shopno = shops.shopno
\&         WHERE (
\&           datecompleted IS NOT NULL AND
\&           (
\&             (shops.datecompleted BETWEEN \*(Aq2009\-10\-01\*(Aq AND \*(Aq2009\-10\-08\*(Aq)  AND
\&             (type = \*(Aq1\*(Aq AND me.userid = \*(Aqfrew\*(Aq)
\&           )
\&         )
\&       ) rpt_score
\&   ) rpt_score
\& WHERE rno_\|_row_\|_index BETWEEN 1 AND 1
.Ve
.PP
See: \*(L"related_resultset\*(R" in DBIx::Class::ResultSet, \*(L"search_related\*(R" in DBIx::ClassResultSet, and \*(L"get_column\*(R" in DBIx::Class::ResultSet.
.SS "bonus rel methods"
.IX Subsection "bonus rel methods"
.Vb 5
\& my $book = $author\->create_related(
\&    books => {
\&       title => \*(AqAnother Discworld book\*(Aq,
\&    }
\& );
\&
\& my $book2 = $pratchett\->add_to_books({
\&    title => \*(AqMOAR Discworld book\*(Aq,
\& });
.Ve
.PP
See \*(L"create_related\*(R" in DBIx::Class::Relationship::Base and \*(L"add_to_$rel\*(R" in DBIx::Class::Relationship::Base
.PP
Note that it automatically fills in foreign key for you
.SS "Excellent Transaction Support"
.IX Subsection "Excellent Transaction Support"
.Vb 3
\& $schema\->txn_do(sub {
\&    ...
\& });
\&
\& $schema\->txn_begin; # <\-\- low level
\& # ...
\& $schema\->txn_commit;
.Ve
.PP
See \*(L"txn_do\*(R" in DBIx::Class::Schema, \*(L"txn_begin\*(R" in DBIx::Class::Schema,
and \*(L"txn_commit\*(R" in DBIx::Class::Schema.
.SS "InflateColumn"
.IX Subsection "InflateColumn"
.Vb 1
\& package Frew::Schema::Result::Book;
\&
\& use strict;
\& use warnings;
\&
\& use base \*(AqDBIx::Class::Core\*(Aq;
\&
\& use DateTime::Format::MySQL;
\&
\& # Result code here
\&
\& _\|_PACKAGE_\|_\->load_components(\*(AqInflateColumn\*(Aq);
\&
\& _\|_PACKAGE_\|_\->inflate_column(
\&    date_published => {
\&       inflate => sub { DateTime::Format::MySQL\->parse_date( shift ) },
\&       deflate => sub { shift\->ymd },
\&    },
\& );
.Ve
.PP
See DBIx::Class::InflateColumn, \*(L"inflate_column\*(R" in DBIx::Class::InflateColumn, and
DBIx::Class::InflateColumn::DateTime.
.SS "InflateColumn: deflation"
.IX Subsection "InflateColumn: deflation"
.Vb 2
\& $book\->date_published(DateTime\->now);
\& $book\->update;
.Ve
.SS "InflateColumn: inflation"
.IX Subsection "InflateColumn: inflation"
.Vb 1
\& say $book\->date_published\->month_abbr; # Nov
.Ve
.SS "FilterColumn"
.IX Subsection "FilterColumn"
.Vb 1
\& package Frew::Schema::Result::Book;
\&
\& use strict;
\& use warnings;
\&
\& use base \*(AqDBIx::Class::Core\*(Aq;
\&
\& # Result code here
\&
\& _\|_PACKAGE_\|_\->load_components(\*(AqFilterColumn\*(Aq);
\&
\& _\|_PACKAGE_\|_\->filter_column(
\&    length => {
\&       to_storage   => \*(Aqto_metric\*(Aq,
\&       from_storage => \*(Aqto_imperial\*(Aq,
\&    },
\& );
\&
\& sub to_metric   { $_[1] * .305 }
\& sub to_imperial { $_[1] * 3.28 }
.Ve
.PP
See DBIx::Class::FilterColumn and \*(L"filter_column\*(R" in DBIx::Class::FilterColumn
.SS "ResultSetColumn"
.IX Subsection "ResultSetColumn"
.Vb 6
\& my $rsc = $schema\->resultset(\*(AqBook\*(Aq)\->get_column(\*(Aqprice\*(Aq);
\& $rsc\->first;
\& $rsc\->all;
\& $rsc\->min;
\& $rsc\->max;
\& $rsc\->sum;
.Ve
.PP
See DBIx::Class::ResultSetColumn
.SS "Aggregates"
.IX Subsection "Aggregates"
.Vb 10
\& my @res = $rs\->search(undef, {
\&    select   => [
\&       \*(Aqprice\*(Aq,
\&       \*(Aqgenre\*(Aq,
\&       { max => price },
\&       { avg => price },
\&    ],
\&    as       => [
\&       qw(price genre max_price avg_price)
\&    ],
\&    group_by => [qw(price genre)],
\& });
\& for (@res) {
\&    say $_\->price . \*(Aq \*(Aq . $_\->genre;
\&    say $_\->get_column(\*(Aqmax_price\*(Aq);
\&    say $_\->get_column(\*(Aqavg_price\*(Aq);
\& }
.Ve
.PP
See \*(L"select\*(R" in DBIx::Class::ResultSet, \*(L"as\*(R" in DBIx::Class::ResultSet, and
\&\*(L"group_by\*(R" in DBIx::Class::ResultSet
.IP "Careful, get_column can basically mean \fBthree\fR things" 1
.IX Item "Careful, get_column can basically mean three things"
.PD 0
.IP "private in which case you should use an accessor" 1
.IX Item "private in which case you should use an accessor"
.IP "public for what there is no accessor for" 1
.IX Item "public for what there is no accessor for"
.IP "public for get resultset column (prev example)" 1
.IX Item "public for get resultset column (prev example)"
.PD
.SS "\s-1HRI\s0"
.IX Subsection "HRI"
.Vb 3
\& $rs\->search(undef, {
\&   result_class => \*(AqDBIx::Class::ResultClass::HashRefInflator\*(Aq,
\& });
.Ve
.PP
See \*(L"result_class\*(R" in DBIx::Class::ResultSet and DBIx::Class::ResultClass::HashRefInflator.
.IP "Easy on memory" 1
.IX Item "Easy on memory"
.PD 0
.IP "Mega fast" 1
.IX Item "Mega fast"
.IP "Great for quick debugging" 1
.IX Item "Great for quick debugging"
.IP "Great for performance tuning (we went from 2m to < 3s)" 1
.IX Item "Great for performance tuning (we went from 2m to < 3s)"
.PD
.SS "Subquery Support"
.IX Subsection "Subquery Support"
.Vb 4
\& my $inner_query = $schema\->resultset(\*(AqArtist\*(Aq)
\&    \->search({
\&     name => [ \*(AqBilly Joel\*(Aq, \*(AqBrittany Spears\*(Aq ],
\& })\->get_column(\*(Aqid\*(Aq)\->as_query;
\&
\& my $rs = $schema\->resultset(\*(AqCD\*(Aq)\->search({
\&     artist_id => { \-in => $inner_query },
\& });
.Ve
.PP
See \*(L"Subqueries\*(R" in DBIx::Class::Manual::Cookbook
.SS "Bare \s-1SQL\s0 w/ Placeholders"
.IX Subsection "Bare SQL w/ Placeholders"
.Vb 4
\& $rs\->update({
\&    # !!! SQL INJECTION VECTOR
\&    price => \e"price + $inc", # DON\*(AqT DO THIS
\& });
.Ve
.PP
Better:
.PP
.Vb 3
\& $rs\->update({
\&    price => \e[\*(Aqprice + ?\*(Aq, [inc => $inc]],
\& });
.Ve
.PP
See \*(L"Literal_SQL_with_placeholders_and_bind_values_(subqueries)\*(R" in SQL::Abstract
