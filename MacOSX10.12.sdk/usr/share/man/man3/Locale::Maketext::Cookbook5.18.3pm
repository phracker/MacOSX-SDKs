.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Locale::Maketext::Cookbook 3pm"
.TH Locale::Maketext::Cookbook 3pm "2013-11-04" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Locale::Maketext::Cookbook \- recipes for using Locale::Maketext
.SH "INTRODUCTION"
.IX Header "INTRODUCTION"
This is a work in progress. Not much progress by now :\-)
.SH "ONESIDED LEXICONS"
.IX Header "ONESIDED LEXICONS"
\&\fIAdapted from a suggestion by Dan Muey\fR
.PP
It may be common (for example at your main lexicon) that
the hash keys and values coincide. Like that
.PP
.Vb 2
\&    q{Hello, tell me your name} 
\&      => q{Hello, tell me your name}
.Ve
.PP
It would be nice to just write:
.PP
.Vb 1
\&    q{Hello, tell me your name} => \*(Aq\*(Aq
.Ve
.PP
and have this magically inflated to the first form.
Among the advantages of such representation, that would
lead to  
smaller files, less prone to mistyping or mispasting, 
and handy to someone translating it which can simply 
copy the main lexicon and enter the translation 
instead of having to remove the value first.
.PP
That can be achieved by overriding \f(CW\*(C`init\*(C'\fR
in your class and working on the main lexicon
with code like that:
.PP
.Vb 2
\&    package My::I18N;
\&    ...
\&
\&    sub init {
\&        my $lh = shift; # a newborn handle
\&        $lh\->SUPER::init();
\&        inflate_lexicon(\e%My::I18N::en::Lexicon);
\&        return;
\&    }
\&
\&    sub inflate_lexicon {
\&        my $lex = shift;
\&        while (my ($k, $v) = each %$lex) {
\&            $v = $k if !defined $v || $v eq \*(Aq\*(Aq;
\&        }
\&    }
.Ve
.PP
Here we are assuming \f(CW\*(C`My::I18N::en\*(C'\fR to own the
main lexicon.
.PP
There are some downsides here: the size economy
will not stand at runtime after this \f(CW\*(C`init()\*(C'\fR
runs. But it should not be that critical, since
if you don't have space for that, you won't have
space for any other language besides the main one
as well. You could do that too with ties,
expanding the value at lookup time which
should be more time expensive as an option.
.SH "DECIMAL PLACES IN NUMBER FORMATTING"
.IX Header "DECIMAL PLACES IN NUMBER FORMATTING"
\&\fIAfter \s-1CPAN RT\s0 #36136 (https://rt.cpan.org/Ticket/Display.html?id=36136)\fR
.PP
The documentation of Locale::Maketext advises that 
the standard bracket method \f(CW\*(C`numf\*(C'\fR is limited and that
you must override that for better results. It even
suggests the use of Number::Format.
.PP
One such defect of standard \f(CW\*(C`numf\*(C'\fR is to not be
able to use a certain decimal precision.
For example,
.PP
.Vb 1
\&    $lh\->maketext(\*(Aqpi is [numf,_1]\*(Aq, 355/113);
.Ve
.PP
outputs
.PP
.Vb 1
\&    pi is 3.14159292035398
.Ve
.PP
Since pi X 355/116 is only accurate 
to 6 decimal places, you would want to say:
.PP
.Vb 1
\&    $lh\->maketext(\*(Aqpi is [numf,_1,6]\*(Aq, 355/113);
.Ve
.PP
and get \*(L"pi is 3.141592\*(R".
.PP
One solution for that could use \f(CW\*(C`Number::Format\*(C'\fR
like that:
.PP
.Vb 1
\&    package Wuu;
\&
\&    use base qw(Locale::Maketext);
\&
\&    use Number::Format;
\&
\&    # can be overridden according to language conventions
\&    sub _numf_params {
\&        return (
\&            \-thousands_sep  => \*(Aq.\*(Aq,
\&            \-decimal_point  => \*(Aq,\*(Aq,
\&            \-decimal_digits => 2,
\&        );
\&    }
\&
\&    # builds a Number::Format
\&    sub _numf_formatter {
\&        my ($lh, $scale) = @_;
\&        my @params = $lh\->_numf_params;
\&        if ($scale) { # use explicit scale rather than default
\&            push @params, (\-decimal_digits => $scale);
\&        }
\&        return Number::Format\->new(@params);
\&    }
\&
\&    sub numf {
\&        my ($lh, $n, $scale) = @_;
\&        # get the (cached) formatter
\&        my $nf = $lh\->{_\|_nf}{$scale} ||= $lh\->_numf_formatter($scale);
\&        # format the number itself
\&        return $nf\->format_number($n);
\&    }
\&
\&    package Wuu::pt;
\&
\&    use base qw(Wuu);
.Ve
.PP
and then
.PP
.Vb 2
\&    my $lh = Wuu\->get_handle(\*(Aqpt\*(Aq);
\&    $lh\->maketext(\*(AqA [numf,_1,3] km de dista\*^ncia\*(Aq, 1550.2222);
.Ve
.PP
would return \*(L"A 1.550,222 km de dista\*^ncia\*(R".
.PP
Notice that the standard utility methods of 
\&\f(CW\*(C`Locale::Maketext\*(C'\fR are irremediably limited
because they could not aim to do everything
that could be expected from them in different languages,
cultures and applications. So extending \f(CW\*(C`numf\*(C'\fR,
\&\f(CW\*(C`quant\*(C'\fR, and \f(CW\*(C`sprintf\*(C'\fR is natural as soon
as your needs exceed what the standard ones do.
