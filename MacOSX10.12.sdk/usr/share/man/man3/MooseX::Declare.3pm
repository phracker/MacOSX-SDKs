.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "MooseX::Declare 3pm"
.TH MooseX::Declare 3pm "2013-12-14" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
MooseX::Declare \- Declarative syntax for Moose
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use MooseX::Declare;
\&
\&    class BankAccount {
\&        has \*(Aqbalance\*(Aq => ( isa => \*(AqNum\*(Aq, is => \*(Aqrw\*(Aq, default => 0 );
\&
\&        method deposit (Num $amount) {
\&            $self\->balance( $self\->balance + $amount );
\&        }
\&
\&        method withdraw (Num $amount) {
\&            my $current_balance = $self\->balance();
\&            ( $current_balance >= $amount )
\&                || confess "Account overdrawn";
\&            $self\->balance( $current_balance \- $amount );
\&        }
\&    }
\&
\&    class CheckingAccount extends BankAccount {
\&        has \*(Aqoverdraft_account\*(Aq => ( isa => \*(AqBankAccount\*(Aq, is => \*(Aqrw\*(Aq );
\&
\&        before withdraw (Num $amount) {
\&            my $overdraft_amount = $amount \- $self\->balance();
\&            if ( $self\->overdraft_account && $overdraft_amount > 0 ) {
\&                $self\->overdraft_account\->withdraw($overdraft_amount);
\&                $self\->deposit($overdraft_amount);
\&            }
\&        }
\&    }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module provides syntactic sugar for Moose, the postmodern object system
for Perl 5. When used, it sets up the \f(CW\*(C`class\*(C'\fR and \f(CW\*(C`role\*(C'\fR keywords.
.PP
\&\fBNote:\fR Please see the \*(L"\s-1WARNING\*(R"\s0 section below!
.SH "KEYWORDS"
.IX Header "KEYWORDS"
.SS "class"
.IX Subsection "class"
.Vb 1
\&    class Foo { ... }
\&
\&    my $anon_class = class { ... };
.Ve
.PP
Declares a new class. The class can be either named or anonymous, depending on
whether or not a classname is given. Within the class definition Moose and
MooseX::Method::Signatures are set up automatically in addition to the other
keywords described in this document. At the end of the definition the class
will be made immutable. namespace::autoclean is injected to clean up Moose and
other imports for you.
.PP
Because of the way the options are parsed, you cannot have a class named \*(L"is\*(R",
\&\*(L"with\*(R" or \*(L"extends\*(R".
.PP
It's possible to specify options for classes:
.IP "extends" 4
.IX Item "extends"
.Vb 1
\&    class Foo extends Bar { ... }
.Ve
.Sp
Sets a superclass for the class being declared.
.IP "with" 4
.IX Item "with"
.Vb 3
\&    class Foo with Role             { ... }
\&    class Foo with Role1 with Role2 { ... }
\&    class Foo with (Role1, Role2)   { ... }
.Ve
.Sp
Applies a role or roles to the class being declared.
.IP "is mutable" 4
.IX Item "is mutable"
.Vb 1
\&    class Foo is mutable { ... }
.Ve
.Sp
Causes the class not to be made immutable after its definition.
.Sp
Options can also be provided for anonymous classes using the same syntax:
.Sp
.Vb 1
\&    my $meta_class = class with Role;
.Ve
.SS "role"
.IX Subsection "role"
.Vb 1
\&    role Foo { ... }
\&
\&    my $anon_role = role { ... };
.Ve
.PP
Declares a new role. The role can be either named or anonymous, depending on
whether or not a name is given. Within the role definition Moose::Role and
MooseX::Method::Signatures are set up automatically in addition to the other
keywords described in this document. Again, namespace::autoclean is injected to
clean up Moose::Role and other imports for you.
.PP
It's possible to specify options for roles:
.IP "with" 4
.IX Item "with"
.Vb 1
\&    role Foo with Bar { ... }
.Ve
.Sp
Applies a role to the role being declared.
.SS "before / after / around / override / augment"
.IX Subsection "before / after / around / override / augment"
.Vb 5
\&    before   foo ($x, $y, $z) { ... }
\&    after    bar ($x, $y, $z) { ... }
\&    around   baz ($x, $y, $z) { ... }
\&    override moo ($x, $y, $z) { ... }
\&    augment  kuh ($x, $y, $z) { ... }
.Ve
.PP
Add a method modifier. Those work like documented in Moose, except for
the slightly nicer syntax and the method signatures, which work like documented
in MooseX::Method::Signatures.
.PP
For the \f(CW\*(C`around\*(C'\fR modifier an additional argument called \f(CW$orig\fR is
automatically set up as the invocant for the method.
.SS "clean"
.IX Subsection "clean"
Sometimes you don't want the automatic cleaning the \f(CW\*(C`class\*(C'\fR and \f(CW\*(C`role\*(C'\fR
keywords provide using namespace::autoclean. In those cases you can specify the
\&\f(CW\*(C`dirty\*(C'\fR trait for your class or role:
.PP
.Vb 2
\&    use MooseX::Declare;
\&    class Foo is dirty { ... }
.Ve
.PP
This will prevent cleaning of your namespace, except for the keywords imported
from \f(CW\*(C`Moose\*(C'\fR or \f(CW\*(C`Moose::Role\*(C'\fR. Additionally, a \f(CW\*(C`clean\*(C'\fR keyword is provided,
which allows you to explicitly clean all functions that were defined prior to
calling \f(CW\*(C`clean\*(C'\fR. Here's an example:
.PP
.Vb 6
\&    use MooseX::Declare;
\&    class Foo is dirty {
\&        sub helper_function { ... }
\&        clean;
\&        method foo ($stuff) { ...; return helper_function($stuff); }
\&    }
.Ve
.PP
With that, the helper function won't be available as a method to a user of your
class, but you're still able to use it inside your class.
.SH "NOTE ON IMPORTS"
.IX Header "NOTE ON IMPORTS"
When creating a class with MooseX::Declare like:
.PP
.Vb 2
\&    use MooseX::Declare;
\&    class Foo { ... }
.Ve
.PP
What actually happens is something like this:
.PP
.Vb 7
\&    {
\&        package Foo;
\&        use Moose;
\&        use namespace::autoclean;
\&        ...
\&        _\|_PACKAGE_\|_\->meta\->make_immutable;
\&    }
.Ve
.PP
So if you declare imports outside the class, the symbols get imported into the
\&\f(CW\*(C`main::\*(C'\fR namespace, not the class' namespace. The symbols then cannot be called
from within the class:
.PP
.Vb 6
\&    use MooseX::Declare;
\&    use Data::Dump qw/dump/;
\&    class Foo {
\&        method dump($value) { return dump($value) } # Data::Dump::dump IS NOT in Foo::
\&        method pp($value)   { $self\->dump($value) } # an alias for our dump method
\&    }
.Ve
.PP
To solve this, only import MooseX::Declare outside the class definition
(because you have to). Make all other imports inside the class definition.
.PP
.Vb 6
\&    use MooseX::Declare;
\&    class Foo {
\&        use Data::Dump qw/dump/;
\&        method dump($value) { return dump($value) } # Data::Dump::dump IS in Foo::
\&        method pp($value)   { $self\->dump($value) } # an alias for our dump method
\&    }
\&
\&    Foo\->new\->dump($some_value);
\&    Foo\->new\->pp($some_value);
.Ve
.PP
\&\fB\s-1NOTE\s0\fR that the import \f(CW\*(C`Data::Dump::dump()\*(C'\fR and the method \f(CW\*(C`Foo::dump()\*(C'\fR,
although having the same name, do not conflict with each other, because the
imported \f(CW\*(C`dump\*(C'\fR function will be cleaned during compile time, so only the
method remains there at run time. If you want to do more esoteric things with
imports, have a look at the \f(CW\*(C`clean\*(C'\fR keyword and the \f(CW\*(C`dirty\*(C'\fR trait.
.SH "WARNING"
.IX Header "WARNING"
\&\fBWarning:\fR MooseX::Declare is based on Devel::Declare, a giant bag of crack
originally implemented by mst with the goal of upsetting the perl core
developers so much by its very existence that they implemented proper
keyword handling in the core.
.PP
As of perl5 version 14, this goal has been achieved, and modules such
as Devel::CallParser, Function::Parameters, and Keyword::Simple provide
mechanisms to mangle perl syntax that don't require hallucinogenic
drugs to interpret the error messages they produce.
.PP
If you want to use declarative syntax in new code, please for the love
of kittens get yourself a recent perl and look at Moops instead.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.IP "\(bu" 4
Moose
.IP "\(bu" 4
Moose::Role
.IP "\(bu" 4
MooseX::Method::Signatures
.IP "\(bu" 4
namespace::autoclean
.IP "\(bu" 4
vim syntax: <http://www.vim.org/scripts/script.php?script_id=2526>
.IP "\(bu" 4
emacs syntax: <http://github.com/jrockway/cperl\-mode>
.IP "\(bu" 4
Geany syntax + notes: <http://www.cattlegrid.info/blog/2009/09/moosex\-declare\-geany\-syntax.html>
.IP "\(bu" 4
Devel::CallParser
.IP "\(bu" 4
Function::Parameters
.IP "\(bu" 4
Keyword::Simple
.IP "\(bu" 4
Moops
.SH "AUTHOR"
.IX Header "AUTHOR"
Florian Ragwitz <rafl@debian.org>
.SH "CONTRIBUTORS"
.IX Header "CONTRIBUTORS"
.IP "\(bu" 4
Ash Berlin <ash_github@firemirror.com>
.IP "\(bu" 4
Chas. J. Owens \s-1IV\s0 <chas.owens@gmail.com>
.IP "\(bu" 4
Chris Prather <chris@prather.org>
.IP "\(bu" 4
Dave Rolsky <autarch@urth.org>
.IP "\(bu" 4
Devin Austin <dhoss@cpan.org>
.IP "\(bu" 4
Hans Dieter Pearcey <hdp@cpan.org>
.IP "\(bu" 4
Justin Hunter <justin.d.hunter@gmail.com>
.IP "\(bu" 4
Karen Etheridge <ether@cpan.org>
.IP "\(bu" 4
Matt Kraai <kraai@ftbfs.org>
.IP "\(bu" 4
Michele Beltrame <arthas@cpan.org>
.IP "\(bu" 4
Nelo Onyiah <nelo.onyiah@gmail.com>
.IP "\(bu" 4
Nick Perez <nperez@cpan.org>
.IP "\(bu" 4
Piers Cawley <pdcawley@bofh.org.uk>
.IP "\(bu" 4
Rafael Kitover <rkitover@io.com>
.IP "\(bu" 4
Robert 'phaylon' Sedlacek <rs@474.at>
.IP "\(bu" 4
Stevan Little <stevan.little@iinteractive.com>
.IP "\(bu" 4
Tomas Doran <bobtfish@bobtfish.net>
.IP "\(bu" 4
Yanick Champoux <yanick@babyl.dyndns.org>
.IP "\(bu" 4
leedo <lee@laylward.com>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is copyright (c) 2008 by Florian Ragwitz.
.PP
This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.
