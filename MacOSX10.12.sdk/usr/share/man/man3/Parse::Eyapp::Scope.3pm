.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Parse::Eyapp::Scope 3"
.TH Parse::Eyapp::Scope 3 "2012-03-23" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Parse::Eyapp::Scope \- Support for Scope Analysis
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 10
\&  # Fragment of the grammar lib/Simple/Types.eyp
\&  # in examples/typechecking/Simple\-Types\-XXX.tar.gz 
\&  funcDef:
\&      $ID 
\&         { 
\&           $ids\->begin_scope(); 
\&         }
\&      \*(Aq(\*(Aq  $params  \*(Aq)\*(Aq 
\&        $block
\&      {
\&         my $st = $block\->{symboltable}; 
\&         my @decs = $params\->children(); 
\&         $block\->{parameters} = [];
\&         while (my ($bt, $id, $arrspec) = splice(@decs, 0, 3)) {
\&             $bt = ref($bt); # The string \*(AqINT\*(Aq, \*(AqCHAR\*(Aq, etc.
\&             my $name = $id\->{attr}[0];
\&             my $type = build_type($bt, $arrspec);
\&             $type{$type} = Parse::Eyapp::Node\->hnew($type); 
\&
\&             # control duplicated declarations
\&               die "Duplicated declaration of $name at line $id\->{attr}[1]\en" 
\&             if exists($st\->{$name});
\&
\&             $st\->{$name}\->{type} = $type;
\&             $st\->{$name}\->{param} = 1;
\&             $st\->{$name}\->{line} = $id\->{attr}[1];
\&             push @{$block\->{parameters}}, $name;
\&         }
\&         $block\->{function_name} = $ID;
\&         $block\->type("FUNCTION");
\&
\&         my ($nodec, $dec) = $ids\->end_scope($st, $block, \*(Aqtype\*(Aq);
\&
\&         # Type checking: add a direct pointer to the data\-structure
\&         # describing the type
\&         $_\->{t} = $type{$_\->{type}} for @$dec;
\&
\&         return $block;
\&      }
\&  ;
\& 
\&  ...
\&
\&  Primary:
\&      %name INUM
\&      INUM 
\&    | %name CHARCONSTANT
\&      CHARCONSTANT
\&    | $Variable 
\&        { 
\&          $ids\->scope_instance($Variable); 
\&          return $Variable 
\&        }
\&    | \*(Aq(\*(Aq expression \*(Aq)\*(Aq { $_[2] }
\&    | $function_call 
\&        { 
\&          $ids\->scope_instance($function_call); 
\&          return $function_call  # bypass
\&        }
\&  ;
.Ve
.SH "INTRODUCTION"
.IX Header "INTRODUCTION"
The examples used in this document can be found in the
file \f(CW\*(C`examples/typechecking/Simple\-Types\-XXX.tar.gz\*(C'\fR.
This distribution contains the front-end of a compiler
(lexical analysis, syntax analysis, scope analysis and type checking) for
a small subset of the C language.
The language has characters, integers, arrays and functions.
Here is a small example:
.PP
.Vb 2
\&  pl@nereida:~/Lbook/code/Simple\-Types/script$ cat prueba03.c
\&  int a,b,e[10];
\&
\&  g() {}
\&
\&  int f(char c) {
\&  char d;
\&   c = \*(AqX\*(Aq;
\&   e[d] = \*(AqA\*(Aq+c;
\&   {
\&     int d;
\&     d = a + b;
\&   }
\&   a = b * 2;
\&   return c;
\&  }
.Ve
.PP
You can find more examples in the \f(CW\*(C`script/\*(C'\fR directory.
The front-end provided analyzes the input program
.PP
.Vb 1
\&  pl@nereida:~/Lbook/code/Simple\-Types/script$ usetypes.pl prueba03.c
.Ve
.PP
and produces the decorated abstract tree, i.e. s.t. like:
.PP
.Vb 10
\&  PROGRAM^{0}(
\&    FUNCTION[g]^{1},
\&    FUNCTION[f]^{2}(
\&      ASSIGNCHAR(
\&        VAR( TERMINAL[c:7]),
\&        CHARCONSTANT( TERMINAL[\*(AqX\*(Aq:7])
\&      ),
\&      ASSIGNINT(
\&        VARARRAY( TERMINAL[e:8], INDEXSPEC(CHAR2INT(VAR(TERMINAL[d:8])))),
\&        PLUS(
\&          CHAR2INT(CHARCONSTANT(TERMINAL[\*(AqA\*(Aq:8])),
\&          CHAR2INT(VAR(TERMINAL[c:8]))
\&        )
\&      ),
\&      BLOCK[9:3:f]^{3}(
\&        ASSIGNINT(
\&          VAR(TERMINAL[d:11]),
\&          PLUS(VAR(TERMINAL[a:11]),VAR( TERMINAL[b:11])))
\&      ),
\&      ASSIGNINT(
\&        VAR(TERMINAL[a:13]),
\&        TIMES(VAR(TERMINAL[b:13]),INUM(TERMINAL[2:13]))),
\&      RETURNINT(CHAR2INT(VAR(TERMINAL[c:14])))
\&    )
\&  )
\&  ...... # More descriptions
.Ve
.PP
A scope manager helps to compute the mapping function
that maps the uses (instances) of 
source objects to their definitions. 
For instance,
.IP "\(bu" 2
When dealing with \fIidentifier scope analysis\fR the problem is to associate
each occurrence of an identifier with the declaration
that applies to it.
.IP "\(bu" 2
Another example is \fIloop scope analysis\fR
where the problem is to associate each occurrence
of a \f(CW\*(C`CONTINUE\*(C'\fR or \f(CW\*(C`BREAK\*(C'\fR node with the 
shallowest \f(CW\*(C`LOOP\*(C'\fR that encloses it.
.IP "\(bu" 2
Or \fIlabel scope analysis\fR, the problem to associate a \f(CW\*(C`GOTO\*(C'\fR
node with the node to jump to, that is,
the one with the \f(CW\*(C`STATEMENT\*(C'\fR associated with the label.
.PP
The scope analysis start by creating the \f(CW\*(C`Parse::Eyapp::Scope\*(C'\fR objects:
.PP
.Vb 9
\&  program:
\&        {
\&          reset_file_scope_vars();
\&        }
\&      definition<%name PROGRAM +>.program
\&        {
\&          ..........  # Semantic actions 
\&        }
\&  ;
.Ve
.PP
Before the analysis of the whole program we call \f(CW\*(C`reset_file_scope_vars\*(C'\fR
which is in charge to create the scope analyzers for
\&\fIidentifier scope analysis\fR and \fIloop scope analysis\fR:
.PP
.Vb 10
\&  sub reset_file_scope_vars {
\&    %st = (); # reset symbol table
\&    ($tokenbegin, $tokenend) = (1, 1);
\&    %type = ( INT  => Parse::Eyapp::Node\->hnew(\*(AqINT\*(Aq),
\&              CHAR => Parse::Eyapp::Node\->hnew(\*(AqCHAR\*(Aq),
\&              VOID => Parse::Eyapp::Node\->hnew(\*(AqVOID\*(Aq),
\&            );
\&    $depth = 0;
\&    $ids = Parse::Eyapp::Scope\->new(
\&             SCOPE_NAME => \*(Aqblock\*(Aq,
\&             ENTRY_NAME => \*(Aqinfo\*(Aq,
\&             SCOPE_DEPTH => \*(Aqdepth\*(Aq,
\&    );
\&    $loops = Parse::Eyapp::Scope\->new(
\&             SCOPE_NAME => \*(Aqexits\*(Aq,
\&    );
\&    $ids\->begin_scope();
\&    $loops\->begin_scope(); # just for checking
\&  }
.Ve
.PP
To take advantage of \f(CW\*(C`Parse::Eyapp::Scope\*(C'\fR, 
the compiler writer must mark at the appropriate time 
(for example a new block or new subroutine for \fIidentifier scope analysis\fR,
a new loop for \fIloop scope analysis\fR, etc.) the \fIbeginning of a new scope\fR
calling the method \f(CW\*(C`begin_scope\*(C'\fR.
For example, the following code deals with the declaration of functions
.PP
.Vb 11
\&  funcDef:
\&      $ID 
\&         { 
\&           $ids\->begin_scope(); 
\&         }
\&      \*(Aq(\*(Aq  $params  \*(Aq)\*(Aq 
\&        $block
\&      {
\&         ........ # semantic action code
\&      }
\&  ;
.Ve
.PP
The call
.PP
.Vb 1
\&            $ids\->begin_scope
.Ve
.PP
marks the beginning of a new identifier scope.
.PP
From that point on, any \fIocurring instance\fR of an object 
(for example,
variables in expressions for \fIidentifier scope analysis\fR, breaks and continues
for \fIloop scope analysis\fR, etc.) must be declared 
calling the method \f(CW\*(C`scope_instance\*(C'\fR.
For example, the following rules deal with the use of 
of variables and functions inside expressions:
.PP
.Vb 10
\&  Primary:
\&      ........... # Other production rules
\&    | $Variable 
\&        { 
\&          $ids\->scope_instance($Variable); 
\&          return $Variable 
\&        }
\&    | $function_call 
\&        { 
\&          $ids\->scope_instance($function_call); 
\&          return $function_call  # bypass
\&        }
\&  ;
.Ve
.PP
The programmer must also mark the \fIend of the current scope\fR 
at the appropriate time. After the processing of the \f(CW\*(C`block\*(C'\fR 
following a function declaration an \fIidentifier scope\fR
has finished and we call \f(CW\*(C`end_scope\*(C'\fR:
.PP
.Vb 9
\&  funcDef:
\&      $ID 
\&         { 
\&           $ids\->begin_scope(); 
\&         }
\&      \*(Aq(\*(Aq  $params  \*(Aq)\*(Aq 
\&        $block
\&      {
\&         ............................... 
\&
\&         my ($nodec, $dec) = $ids\->end_scope($st, $block, \*(Aqtype\*(Aq);
\&
\&         # Type checking: add a direct pointer to the data\-structure
\&         # describing the type
\&         $_\->{t} = $type{$_\->{type}} for @$dec;
\&
\&         return $block;
\&      }
\&  ;
.Ve
.PP
This call is made after each end of scope, including the end of the program:
.PP
.Vb 11
\&  program:
\&        {
\&          reset_file_scope_vars();
\&        }
\&      definition<%name PROGRAM +>.program
\&        {
\&          $program\->{symboltable} = { %st };  # creates a copy of the s.t.
\&          $program\->{depth} = 0;
\&          $program\->{line}  = 1;
\&          $program\->{types} = { %type };
\&          $program\->{lines} = $tokenend;
\&
\&          my ($nondec, $declared) = $ids\->end_scope($program\->{symboltable}, $program, \*(Aqtype\*(Aq);
\&
\&          if (@$nondec) {
\&            warn "Identifier ".$_\->key." not declared at line ".$_\->line."\en" for @$nondec;
\&            die "\en";
\&          }
\&
\&          # Type checking: add a direct pointer to the data\-structure
\&          # describing the type
\&          $_\->{t} = $type{$_\->{type}} for @$declared;
\&
\&          my $out_of_loops = $loops\->end_scope($program);
\&          if (@$out_of_loops) {
\&            warn "Error: ".ref($_)." outside of loop at line $_\->{line}\en" for @$out_of_loops;
\&            die "\en";
\&          }
\&
\&          # Check that are not dangling breaks
\&          reset_file_scope_vars();
\&
\&          $program;
\&        }
\&  ;
.Ve
.SH "METHODS"
.IX Header "METHODS"
.ie n .SS "The ""end_scope"" method"
.el .SS "The \f(CWend_scope\fP method"
.IX Subsection "The end_scope method"
There are three ways of calling \f(CW\*(C`$scope\->end_scope\*(C'\fR.
The first one is for Scope Analysis Problems where
a symbol table is needed (for example in \fIidentifier scope analysis\fR
and \fIlabel scope analysis\fR and there is a \f(CW\*(C`Parse::Eyapp::Node\*(C'\fR node 
that owns the scope.
.PP
\fIThe \f(CI\*(C`end_scope\*(C'\fI with first Argument a Symbol Table and Second Argument a Node\fR
.IX Subsection "The end_scope with first Argument a Symbol Table and Second Argument a Node"
.PP
For each \fIocurring instance\fR of an object \f(CW$x\fR
that occurred since the last call to \f(CW\*(C`begin_scope\*(C'\fR
the call to
.PP
.Vb 1
\&  $scope\->end_scope(\e%symboltable, $definition_node, \*(Aqattr1\*(Aq, \*(Aqattr2\*(Aq, ... )
.Ve
.PP
decorates the \fIocurring instance\fR \f(CW$x\fR with several attributes:
.IP "\(bu" 4
An entry \f(CW\*(C`$x\->{SCOPE_NAME}\*(C'\fR is built that will reference \f(CW$definition_node\fR.
.IP "\(bu" 4
An entry \f(CW\*(C`$x\->{ENTRY_NAME}\*(C'\fR is built. That
entry references \f(CW$symboltable{$x\->key}\fR (to have a
faster access from the instance to the attributes of the object).
The instantiated nodes must have a \f(CW\*(C`$x\->key\*(C'\fR method which provides
the entry for the node in the symbol table:
.Sp
.Vb 3
\&  pl@nereida:~/src/perl/YappWithDefaultAction/examples$ sed \-ne \*(Aq651,657p\*(Aq Types.eyp
\&  sub VAR::key {
\&    my $self = shift;
\&
\&    return $self\->child(0)\->{attr}[0];
\&  }
\&
\&  *VARARRAY::key = *FUNCTIONCALL::key = \e&VAR::key;
.Ve
.IP "\(bu" 4
For each aditional arguments \f(CW\*(C`attr#k\*(C'\fR an
entry \f(CW\*(C`$x\->{attr#k\*(C'\fR} will be built.
That entry references \f(CW$symboltable{$x\->key}{attr#k}\fR. 
Therefore
the entry for \f(CW$x\fR in the symbol table must already 
have a field named \f(CW\*(C`attr#k\*(C'\fR.
If the hash referenced by \f(CW$symboltable{$x\->key}\fR does not
have a key \f(CW\*(C`attr#k\*(C'\fR no reference is built.
.PP
In a list context \f(CW\*(C`$scope>end_scope\*(C'\fR returns
two references. The first one
is a reference to a list of node instantiated
that weren't defined in the current scope.
The second is a reference to a list of nodes
that were defined in this scope. 
In a scalar context returns the first of these two.
An instance \f(CW$x\fR is \fIdefined\fR if, and only if, 
\&\f(CW\*(C`exists $symboltable{$_\->key}\*(C'\fR.
.PP
\fIThe \f(CI\*(C`end_scope\*(C'\fI Method with first Argument a Symbol Table and Remaining Arguments strings\fR
.IX Subsection "The end_scope Method with first Argument a Symbol Table and Remaining Arguments strings"
.PP
For each \fIocurring instance\fR of an object \f(CW$x\fR
that occurred since the last call to  \f(CW\*(C`begin_scope\*(C'\fR
the call to
.PP
.Vb 1
\&  $scope\->end_scope(\e%symboltable, \*(Aqattr1\*(Aq, \*(Aqattr2\*(Aq, ... )
.Ve
.PP
decorates the \fIocurring instance\fR \f(CW$x\fR with several attributes:
.IP "\(bu" 4
An entry \f(CW\*(C`$x\->{ENTRY_NAME}\*(C'\fR is built. That
entry references \f(CW$symboltable{$x\->key}\fR (to have a
faster access from the instance to the attributes of the object).
The instantiated nodes must have a \f(CW\*(C`$x\->key\*(C'\fR method which provides
the entry for the node in the symbol table.
.IP "\(bu" 4
For each aditional arguments \f(CW\*(C`attr#k\*(C'\fR an
entry \f(CW\*(C`$x\->{attr#k\*(C'\fR} will be built.
That entry references \f(CW$symboltable{$x\->key}{attr#k}\fR. 
Therefore
the entry for \f(CW$x\fR in the symbol table must already 
have a field named \f(CW\*(C`attr#k\*(C'\fR.
If the hash referenced by \f(CW$symboltable{$x\->key}\fR does not
have a key \f(CW\*(C`attr#k\*(C'\fR no reference is built.
.PP
\fIThe \f(CI\*(C`end_scope\*(C'\fI method for Simple Scope Analysis\fR
.IX Subsection "The end_scope method for Simple Scope Analysis"
.PP
Some scope analysis problems do not require the existence
of a symbol table (for instance, the problem of associating
a \f(CW\*(C`RETURN\*(C'\fR node with the \f(CW\*(C`FUNCTION\*(C'\fR that encloses it). 
For such kind of problems \f(CW\*(C`$scope>end_scope\*(C'\fR provides
a second form of call.
.PP
The second way to call \f(CW\*(C`$scope>end_scope\*(C'\fR is
.PP
.Vb 1
\&                 $declared = $scopemanager\->end_scope($definition_node);
.Ve
.PP
The only argument is the reference to the node that controls/defines
the scope. The method returns a reference to the declared
nodes. Any node instanced with \f(CW\*(C`scope_instance\*(C'\fR
since the last call to \f(CW\*(C`begin_scope\*(C'\fR is considered \fIdeclared\fR.
.PP
The scope node \f(CW$definition_node\fR is decorated with an attribute with
name the value of the attribute \f(CW\*(C`SCOPE_NAME\*(C'\fR of the scope manager
\&\f(CW$scopemanager\fR. The value of the attribute is the anonymous list of references to the instances
declared in the scope of \f(CW$definition_node\fR 
(i.e. the same list referenced by \f(CW$declared\fR).
.PP
The scope instances in \f(CW@$declared\fR are decorated with
an attribute with name the value of the attribute \f(CW\*(C`SCOPE_NAME\*(C'\fR of the scope manager.
The value is a reference to the scope node \f(CW$definition_node\fR.
.ie n .SS "The ""begin_scope"" method"
.el .SS "The \f(CWbegin_scope\fP method"
.IX Subsection "The begin_scope method"
Marks the beginning of an scope.
Example (file \f(CW\*(C`Types.eyp\*(C'\fR in \f(CW\*(C`examples/typechecking/Simple\-Types\-XXX.tar.gz\*(C'\fR):
.PP
.Vb 7
\&   loopPrefix:
\&       $WHILE \*(Aq(\*(Aq expression \*(Aq)\*(Aq
\&         {
\&           $loops\->begin_scope;
\&           $_[3]\->{line} = $WHILE\->[1]; # Save the line for error diagostic
\&           $_[3]
\&         }
.Ve
.ie n .SS "The ""scope_instance"" method"
.el .SS "The \f(CWscope_instance\fP method"
.IX Subsection "The scope_instance method"
Declares the node argument to be an occurring instance of the scope:
.PP
.Vb 8
\&   nereida:~/doc/casiano/PLBOOK/PLBOOK/code> \e
\&       sed \-ne \*(Aq375,380p\*(Aq Simple6.eyp | cat \-n
\&    1      $Variable \*(Aq=\*(Aq binary
\&    2        {
\&    3          my $parser = shift;
\&    4          $ids\->scope_instance($Variable);
\&    5          $parser\->YYBuildAST(@_); # "Manually" build the node
\&    6        }
.Ve
.ie n .SS "The constructor ""new"""
.el .SS "The constructor \f(CWnew\fP"
.IX Subsection "The constructor new"
\&\f(CW\*(C`Parse::Eyapp::Scope\->new\*(C'\fR returns a scope management object. 
The scope mapping function is implemented 
by \f(CW\*(C`Parse::Eyapp::Scope\*(C'\fR through a set of attributes
that are added to the nodes involved in the scope analysis.
The names of these attributes can be specified 
using the parameters of \f(CW\*(C`Parse::Eyapp::Scope\->new\*(C'\fR.
The arguments of \f(CW\*(C`new\*(C'\fR are:
.IP "\(bu" 4
\&\f(CW\*(C`SCOPE_NAME\*(C'\fR 
is the name chosen for the attribute of the 
\&\fInode instance\fR  which will held
the reference to the \fIdefinition node\fR.
If not specified it will take the value \f(CW"scope"\fR.
.IP "\(bu" 4
\&\f(CW\*(C`ENTRY_NAME\*(C'\fR is the name of the attribute of the
\&\fInode instance\fR  which will held
the reference to the symbol table entry.
By default takes the value \f(CW"entry"\fR.
.IP "\(bu" 4
\&\f(CW\*(C`SCOPE_DEPTH\*(C'\fR is the name for an attribute of the 
\&\fIdefinition node\fR. Optional. If not specified it will not be
defined.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.IP "\(bu" 4
The project home is at <http://code.google.com/p/parse\-eyapp/>.
Use a subversion client to anonymously check out the latest project source code:
.Sp
.Vb 1
\&   svn checkout http://parse\-eyapp.googlecode.com/svn/trunk/ parse\-eyapp\-read\-only
.Ve
.IP "\(bu" 4
The tutorial \fIParsing Strings and Trees with\fR \f(CW\*(C`Parse::Eyapp\*(C'\fR
(An Introduction to Compiler Construction in seven pages) in
<http://nereida.deioc.ull.es/~pl/eyapsimple/>
.IP "\(bu" 4
Parse::Eyapp, 
Parse::Eyapp::eyapplanguageref, 
Parse::Eyapp::debuggingtut,
Parse::Eyapp::defaultactionsintro,
Parse::Eyapp::translationschemestut,
Parse::Eyapp::Driver,
Parse::Eyapp::Node,
Parse::Eyapp::YATW,
Parse::Eyapp::Treeregexp,
Parse::Eyapp::Scope,
Parse::Eyapp::Base,
Parse::Eyapp::datagenerationtut
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/languageintro.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/debuggingtut.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/eyapplanguageref.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/Treeregexp.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/Node.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/YATW.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/Eyapp.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/Base.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/translationschemestut.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/treematchingtut.pdf>
.IP "\(bu" 4
perldoc eyapp,
.IP "\(bu" 4
perldoc treereg,
.IP "\(bu" 4
perldoc vgg,
.IP "\(bu" 4
The Syntax Highlight file for vim at <http://www.vim.org/scripts/script.php?script_id=2453>
and <http://nereida.deioc.ull.es/~vim/>
.IP "\(bu" 4
\&\fIAnalisis Lexico y Sintactico\fR, (Notes for a course in compiler 
construction) by  Casiano Rodriguez-Leon. 
Available at  <http://nereida.deioc.ull.es/~pl/perlexamples/>
Is the more complete and reliable source for Parse::Eyapp. However is in Spanish.
.IP "\(bu" 4
Parse::Yapp,
.IP "\(bu" 4
Man pages of \fIyacc\fR\|(1) and
\&\fIbison\fR\|(1),
<http://www.delorie.com/gnu/docs/bison/bison.html>
.IP "\(bu" 4
Language::AttributeGrammar
.IP "\(bu" 4
Parse::RecDescent.
.IP "\(bu" 4
HOP::Parser
.IP "\(bu" 4
HOP::Lexer
.IP "\(bu" 4
ocamlyacc tutorial at 
<http://plus.kaist.ac.kr/~shoh/ocaml/ocamllex\-ocamlyacc/ocamlyacc\-tutorial/ocamlyacc\-tutorial.html>
.SH "REFERENCES"
.IX Header "REFERENCES"
.IP "\(bu" 4
The classic Dragon's book \fICompilers: Principles, Techniques, and Tools\fR 
by Alfred V. Aho, Ravi Sethi and
Jeffrey D. Ullman (Addison-Wesley 1986)
.IP "\(bu" 4
\&\fI\s-1CS2121:\s0 The Implementation and Power of Programming Languages\fR
(See <http://www.cs.man.ac.uk/~pjj>, <http://www.cs.man.ac.uk/~pjj/complang/g2lr.html> 
and <http://www.cs.man.ac.uk/~pjj/cs2121/ho/ho.html>) by 
Pete Jinks
.SH "CONTRIBUTORS"
.IX Header "CONTRIBUTORS"
.IP "\(bu" 2
Hal Finkel <http://www.halssoftware.com/>
.IP "\(bu" 2
G. Williams <http://kasei.us/>
.IP "\(bu" 2
Thomas L. Shinnick <http://search.cpan.org/~tshinnic/>
.IP "\(bu" 2
Frank Leray
.SH "AUTHOR"
.IX Header "AUTHOR"
Casiano Rodriguez-Leon (casiano@ull.es)
.SH "ACKNOWLEDGMENTS"
.IX Header "ACKNOWLEDGMENTS"
This work has been supported by \s-1CEE \s0(\s-1FEDER\s0) and the Spanish Ministry of
\&\fIEducacion y Ciencia\fR through \fIPlan Nacional I+D+I\fR number \s-1TIN2005\-08818\-C04\-04
\&\s0(\s-1ULL::OPLINK\s0 project <http://www.oplink.ull.es/>). 
Support from Gobierno de Canarias was through \s-1GC02210601
\&\s0(\fIGrupos Consolidados\fR).
The University of La Laguna has also supported my work in many ways
and for many years.
.PP
A large percentage of  code is verbatim taken from Parse::Yapp 1.05.
The author of Parse::Yapp is Francois Desarmenien.
.PP
I wish to thank Francois Desarmenien for his Parse::Yapp module, 
to my students at La Laguna and to the Perl Community. Thanks to 
the people who have contributed to improve the module (see \*(L"\s-1CONTRIBUTORS\*(R"\s0 in Parse::Eyapp).
Thanks to Larry Wall for giving us Perl.
Special thanks to Juana.
.SH "LICENCE AND COPYRIGHT"
.IX Header "LICENCE AND COPYRIGHT"
Copyright (c) 2006\-2008 Casiano Rodriguez-Leon (casiano@ull.es). All rights reserved.
.PP
Parse::Yapp copyright is of Francois Desarmenien, all rights reserved. 1998\-2001
.PP
These modules are free software; you can redistribute it and/or
modify it under the same terms as Perl itself. See perlartistic.
.PP
This program is distributed in the hope that it will be useful,
but \s-1WITHOUT ANY WARRANTY\s0; without even the implied warranty of
\&\s-1MERCHANTABILITY\s0 or \s-1FITNESS FOR A PARTICULAR PURPOSE. \s0
