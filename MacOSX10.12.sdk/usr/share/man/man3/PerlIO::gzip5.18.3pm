.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "gzip 3"
.TH gzip 3 "2006-10-01" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
PerlIO::gzip \- Perl extension to provide a PerlIO layer to gzip/gunzip
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 3
\&  use PerlIO::gzip;
\&  open FOO, "<:gzip", "file.gz" or die $!;
\&  print while <FOO>; # And it will be uncompressed...
\&
\&  binmode FOO, ":gzip(none)" # Starts reading deflate stream from here on
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
PerlIO::gzip provides a PerlIO layer that manipulates files in the format used
by the \f(CW\*(C`gzip\*(C'\fR program.  Compression and Decompression are implemented, but
not together.  If you attempt to open a file for reading and writing the open
will fail.
.SH "EXPORT"
.IX Header "EXPORT"
PerlIO::gzip exports no subroutines or symbols, just a perl layer \f(CW\*(C`gzip\*(C'\fR
.SH "LAYER ARGUMENTS"
.IX Header "LAYER ARGUMENTS"
The \f(CW\*(C`gzip\*(C'\fR layer takes a comma separated list of arguments. 4 exclusive
options choose the header checking mode:
.IP "gzip" 4
.IX Item "gzip"
The default.  Expects a standard gzip file header for reading, writes a
standard gzip file header.
.IP "none" 4
.IX Item "none"
Expects or writes no file header; assumes the file handle is immediately a
deflate stream (eg as would be found inside a \f(CW\*(C`zip\*(C'\fR file)
.IP "auto" 4
.IX Item "auto"
Potentially dangerous. If the first two bytes match the \f(CW\*(C`gzip\*(C'\fR header
\&\*(L"\ex1f\ex8b\*(R" then a gzip header is assumed (and checked) else a deflate stream
is assumed.  No different from gzip on writing.
.IP "autopop" 4
.IX Item "autopop"
Potentially dangerous. If the first two bytes match the \f(CW\*(C`gzip\*(C'\fR header
\&\*(L"\ex1f\ex8b\*(R" then a gzip header is assumed (and checked) else the layer is
silently popped.  This results in gzip files being transparently
decompressed, other files being treated normally.  Of course, this has sides
effects such as File::Copy becoming gunzip, and File::Compare comparing
the uncompressed contents of files.
.Sp
In autopop mode Opening a handle for writing (or reading and writing) will
cause the gzip layer to automatically be popped.
.PP
Optionally you can add this flag:
.IP "lazy" 4
.IX Item "lazy"
For reading, defer header checking until the first read.  For writing, don't
write a header until the first buffer empty of compressed data to disk.
(and don't write anything at all if no data was written to the handle)
.Sp
By default, gzip header checking is done before the \f(CW\*(C`open\*(C'\fR (or \f(CW\*(C`binmode\*(C'\fR)
returns, so if an error is detected in the gzip header the \f(CW\*(C`open\*(C'\fR or
\&\f(CW\*(C`binmode\*(C'\fR will fail.  However, this will require reading some data, or writing
a header.  With lazy set on a file opened for reading the check is deferred
until the first read so the \f(CW\*(C`open\*(C'\fR should always succeed, but any problems
with the header will cause an error on read.
.Sp
.Vb 4
\&  open FOO, "<:gzip(lazy)", "file.gz" or die $!; # Dangerous.
\&  while (<FOO>) {
\&    print;
\&  } # Whoa. Bad. You\*(Aqre not distinguishing between errors and EOF.
.Ve
.Sp
If you're not careful you won't spot the errors \- like the example above
you'll think you got end of file.
.Sp
lazy is ignored if you are in autopop mode.
.SH "AUTHOR"
.IX Header "AUTHOR"
Nicholas Clark, <nwc10+perlio\-gzip@colon.colondot.net>
.SH "SEE ALSO"
.IX Header "SEE ALSO"
perl, gzip, rfc 1952 <http://www.ietf.org/rfc/rfc1952.txt> (the gzip
file format specification), rfc 1951 <http://www.ietf.org/rfc/rfc1951.txt>
(\s-1DEFLATE\s0 compressed data format specification)
