.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "NetAddr::IP::InetBase 3"
.TH NetAddr::IP::InetBase 3 "2012-10-02" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
NetAddr::IP::InetBase \-\- IPv4 and IPV6 utilities
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 10
\&  use NetAddr::IP::Base qw(
\&        :upper
\&        inet_aton
\&        inet_ntoa
\&        ipv6_aton
\&        ipv6_ntoa
\&        ipv6_n2x
\&        ipv6_n2d
\&        inet_any2n
\&        inet_n2dx
\&        inet_n2ad
\&        inet_pton
\&        inet_ntop
\&        packzeros
\&        isIPv4
\&        isNewIPv4
\&        isAnyIPv4
\&        AF_INET
\&        AF_INET6
\&        fake_AF_INET6
\&        fillIPv4
\&  );
\&
\&  use NetAddr::IP::Util qw(:all :inet :ipv4 :ipv6 :math)
\&
\&  :ipv4   =>    inet_aton, inet_ntoa, fillIPv4
\&
\&  :ipv6   =>    ipv6_aton, ipv6_ntoa,ipv6_n2x, ipv6_n2d,
\&                inet_any2n, inet_n2dx, inet_n2ad
\&                inet_pton, inet_ntop, packzeros
\&
\&  $dotquad = inet_ntoa($netaddr);
\&  $netaddr = inet_aton($dotquad);
\&  $ipv6naddr = ipv6_aton($ipv6_text);
\&  $ipv6_text = ipv6_ntoa($ipv6naddr);
\&  $hex_text = ipv6_n2x($ipv6naddr);
\&  $dec_text = ipv6_n2d($ipv6naddr);
\&  $ipv6naddr = inet_any2n($dotquad or $ipv6_text);
\&  $dotquad or $hex_text = inet_n2dx($ipv6naddr);
\&  $dotquad or $dec_text = inet_n2ad($ipv6naddr);
\&  $netaddr = inet_pton($AF_family,$text_addr);
\&  $text_addr = inet_ntop($AF_family,$netaddr);
\&  $hex_text = packzeros($hex_text);
\&  $rv = isIPv4($bits128);
\&  $rv = isNewIPv4($bits128);
\&  $rv = isAnyIPv4($bits128);
\&  $constant = AF_INET();
\&  $constant = AF_INET6();
\&  $trueif   = fake_AF_INET6();
\&  $ip_filled = fillIPv4($shortIP);
\&
\&  NetAddr::IP::InetBase::lower();
\&  NetAddr::IP::InetBase::upper();
.Ve
.SH "INSTALLATION"
.IX Header "INSTALLATION"
Un-tar the distribution in an appropriate directory and type:
.PP
.Vb 4
\&        perl Makefile.PL
\&        make
\&        make test
\&        make install
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\fBNetAddr::IP::InetBase\fR provides a suite network of conversion functions 
written in pure Perl for converting both IPv4 and IPv6 addresses to
and from network address format and text format.
.PP
The IPv6 functions support all rfc1884 formats.
.PP
.Vb 5
\&  i.e.  x:x:x:x:x:x:x:x:x
\&        x:x:x:x:x:x:x:d.d.d.d
\&        ::x:x:x
\&        ::x:d.d.d.d
\&  and so on...
.Ve
.IP "\(bu" 4
\&\f(CW$dotquad\fR = inet_ntoa($netaddr);
.Sp
Convert a packed IPv4 network address to a dot-quad \s-1IP\s0 address.
.Sp
.Vb 2
\&  input:        packed network address
\&  returns:      IP address i.e. 10.4.12.123
.Ve
.IP "\(bu" 4
\&\f(CW$netaddr\fR = inet_aton($dotquad);
.Sp
Convert a dot-quad \s-1IP\s0 address into an IPv4 packed network address.
.Sp
.Vb 2
\&  input:        IP address i.e. 192.5.16.32
\&  returns:      packed network address
.Ve
.IP "\(bu" 4
\&\f(CW$ipv6addr\fR = ipv6_aton($ipv6_text);
.Sp
Takes an IPv6 address of the form described in rfc1884
and returns a 128 bit binary \s-1RDATA\s0 string.
.Sp
.Vb 2
\&  input:        ipv6 text
\&  returns:      128 bit RDATA string
.Ve
.IP "\(bu" 4
\&\f(CW$ipv6text\fR = ipv6_ntoa($ipv6naddr);
.Sp
Convert a 128 bit binary IPv6 address to compressed rfc 1884
text representation.
.Sp
.Vb 2
\&  input:        128 bit RDATA string
\&  returns:      ipv6 text
.Ve
.IP "\(bu" 4
\&\f(CW$hex_text\fR = ipv6_n2x($ipv6addr);
.Sp
Takes an IPv6 \s-1RDATA\s0 string and returns an 8 segment IPv6 hex address
.Sp
.Vb 2
\&  input:        128 bit RDATA string
\&  returns:      x:x:x:x:x:x:x:x
\&
\&  Note: this function does NOT compress adjacent
\&  strings of 0:0:0:0 into the :: format
.Ve
.IP "\(bu" 4
\&\f(CW$dec_text\fR = ipv6_n2d($ipv6addr);
.Sp
Takes an IPv6 \s-1RDATA\s0 string and returns a mixed hex \- decimal IPv6 address
with the 6 uppermost chunks in hex and the lower 32 bits in dot-quad
representation.
.Sp
.Vb 2
\&  input:        128 bit RDATA string
\&  returns:      x:x:x:x:x:x:d.d.d.d
\&
\&  Note: this function does NOT compress adjacent
\&  strings of 0:0:0:0 into the :: format
.Ve
.IP "\(bu" 4
\&\f(CW$ipv6naddr\fR = inet_any2n($dotquad or \f(CW$ipv6_text\fR);
.Sp
This function converts a text IPv4 or IPv6 address in text format in any
standard notation into a 128 bit IPv6 string address. It prefixes any
dot-quad address (if found) with '::' and passes it to \fBipv6_aton\fR.
.Sp
.Vb 2
\&  input:        dot\-quad or rfc1844 address
\&  returns:      128 bit IPv6 string
.Ve
.IP "\(bu" 4
\&\f(CW$dotquad\fR or \f(CW$hex_text\fR = inet_n2dx($ipv6naddr);
.Sp
This function \fBdoes the right thing\fR and returns the text for either a
dot-quad IPv4 or a hex notation IPv6 address.
.Sp
.Vb 3
\&  input:        128 bit IPv6 string
\&  returns:      ddd.ddd.ddd.ddd
\&            or  x:x:x:x:x:x:x:x
\&
\&  Note: this function does NOT compress adjacent
\&  strings of 0:0:0:0 into the :: format
.Ve
.IP "\(bu" 4
\&\f(CW$dotquad\fR or \f(CW$dec_text\fR = inet_n2ad($ipv6naddr);
.Sp
This function \fBdoes the right thing\fR and returns the text for either a
dot-quad IPv4 or a hex::decimal notation IPv6 address.
.Sp
.Vb 3
\&  input:        128 bit IPv6 string
\&  returns:      ddd.ddd.ddd.ddd
\&            or  x:x:x:x:x:x:ddd.ddd.ddd.dd
\&
\&  Note: this function does NOT compress adjacent
\&  strings of 0:0:0:0 into the :: format
.Ve
.IP "\(bu" 4
\&\f(CW$netaddr\fR = inet_pton($AF_family,$text_addr);
.Sp
This function takes an \s-1IP\s0 address in IPv4 or IPv6 text format and converts it into
binary format. The type of \s-1IP\s0 address conversion is controlled by the \s-1FAMILY\s0
argument.
.Sp
\&\s-1NOTE:\s0 inet_pton, inet_ntop and \s-1AF_INET6\s0 come from the Socket6 library if it
is present on this host.
.IP "\(bu" 4
\&\f(CW$text_addr\fR = inet_ntop($AF_family,$netaddr);
.Sp
This function takes and \s-1IP\s0 address in binary format and converts it into
text format. The type of \s-1IP\s0 address conversion is controlled by the \s-1FAMILY \s0
argument.
.Sp
\&\s-1NOTE:\s0 inet_ntop \s-1ALWAYS\s0 returns lowercase characters.
.Sp
\&\s-1NOTE:\s0 inet_pton, inet_ntop and \s-1AF_INET6\s0 come from the Socket6 library if it
is present on this host.
.IP "\(bu" 4
\&\f(CW$hex_text\fR = packzeros($hex_text);
.Sp
This function optimizes and rfc 1884 IPv6 hex address to reduce the number of
long strings of zero bits as specified in rfc 1884, 2.2 (2) by substituting
\&\fB::\fR for the first occurence of the longest string of zeros in the address.
.IP "\(bu" 4
\&\f(CW$ipv6naddr\fR = ipv4to6($netaddr);
.Sp
Convert an ipv4 network address into an ipv6 network address.
.Sp
.Vb 2
\&  input:        32 bit network address
\&  returns:      128 bit network address
.Ve
.IP "\(bu" 4
\&\f(CW$rv\fR = isIPv4($bits128);
.Sp
This function returns true if there are no on bits present in the IPv6
portion of the 128 bit string and false otherwise.
.Sp
.Vb 1
\&  i.e.  the address must be of the form \- ::d.d.d.d
.Ve
.Sp
Note: this is an old and deprecated ipV4 compatible ipV6 address
.IP "\(bu" 4
\&\f(CW$rv\fR = isNewIPv4($bits128);
.Sp
This function return true if the IPv6 128 bit string is of the form
.Sp
.Vb 1
\&        ::ffff:d.d.d.d
.Ve
.IP "\(bu" 4
\&\f(CW$rv\fR = isAnyIPv4($bits128);
.Sp
This function return true if the IPv6 bit string is of the form
.Sp
.Vb 1
\&        ::d.d.d.d       or      ::ffff:d.d.d.d
.Ve
.IP "\(bu" 4
\&\fINetAddr::IP::InetBase::lower()\fR;
.Sp
Return IPv6 strings in lowercase. This is the default.
.IP "\(bu" 4
\&\fINetAddr::IP::InetBase::upper()\fR;
.Sp
Return IPv6 strings in uppercase.
.Sp
The default may be set to uppercase when the module is loaded by invoking
the \s-1TAG\s0 :upper. i.e.
.Sp
.Vb 1
\&        use NetAddr::IP::InetBase qw( :upper );
.Ve
.IP "\(bu" 4
\&\f(CW$constant\fR = \s-1AF_INET\s0;
.Sp
This function returns the system value for \s-1AF_INET. \s0
.IP "\(bu" 4
\&\f(CW$constant\fR = \s-1AF_INET6\s0;
.Sp
\&\s-1AF_INET6\s0 is sometimes present in the Socket library and always present in the Socket6 library. When the Socket 
library does not contain \s-1AF_INET6\s0 and when Socket6 is not present, a place holder value is \f(CW\*(C`guessed\*(C'\fR based on
the underlying host operating system. See \fBfake_AF_INET6\fR below.
.Sp
\&\s-1NOTE:\s0 inet_pton, inet_ntop and \s-1AF_INET6\s0 come from the Socket6 library if it
is present on this host.
.IP "\(bu" 4
\&\f(CW$trueif\fR = fake_AF_INET6;
.Sp
This function return \s-1FALSE\s0 if \s-1AF_INET6\s0 is provided by Socket or Socket6. Otherwise, it returns the best guess
value based on name of the host operating system.
.IP "\(bu" 4
\&\f(CW$ip_filled\fR = fillIPv4($shortIP);
.Sp
This function converts IPv4 addresses of the form 127.1 to the long form
127.0.0.1
.Sp
If the function is passed an argument that does not match the form of an \s-1IP\s0
address, the original argument is returned. i.e. pass it a hostname or a
short \s-1IP\s0 and it will return a hostname or a filled \s-1IP.\s0
.SH "EXPORT_OK"
.IX Header "EXPORT_OK"
.Vb 10
\&        :upper
\&        inet_aton
\&        inet_ntoa
\&        ipv6_aton
\&        ipv6_ntoa
\&        ipv6_n2x
\&        ipv6_n2d
\&        inet_any2n
\&        inet_n2dx
\&        inet_n2ad
\&        inet_pton
\&        inet_ntop
\&        packzeros
\&        isIPv4
\&        isNewIPv4
\&        isAnyIPv4
\&        AF_INET
\&        AF_INET6
\&        fake_AF_INET6
\&        fillIPv4
.Ve
.ie n .SH "%EXPORT_TAGS"
.el .SH "\f(CW%EXPORT_TAGS\fP"
.IX Header "%EXPORT_TAGS"
.Vb 4
\&        :all
\&        :ipv4
\&        :ipv6
\&        :upper
.Ve
.SH "AUTHOR"
.IX Header "AUTHOR"
Michael Robinton <michael@bizsystems.com>
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright 2003 \- 2012, Michael Robinton <michael@bizsystems.com>
.PP
All rights reserved.
.PP
This program is free software; you can redistribute it and/or modify
it under the terms of either:
.PP
.Vb 3
\&  a) the GNU General Public License as published by the Free
\&  Software Foundation; either version 2, or (at your option) any
\&  later version, or
\&
\&  b) the "Artistic License" which comes with this distribution.
.Ve
.PP
This program is distributed in the hope that it will be useful,
but \s-1WITHOUT ANY WARRANTY\s0; without even the implied warranty of
\&\s-1MERCHANTABILITY\s0 or \s-1FITNESS FOR A PARTICULAR PURPOSE. \s0 See either
the \s-1GNU\s0 General Public License or the Artistic License for more details.
.PP
You should have received a copy of the Artistic License with this
distribution, in the file named \*(L"Artistic\*(R".  If not, I'll be glad to provide
one.
.PP
You should also have received a copy of the \s-1GNU\s0 General Public License
along with this program in the file named \*(L"Copying\*(R". If not, write to the
.PP
.Vb 3
\&        Free Software Foundation, Inc.,
\&        51 Franklin Street, Fifth Floor
\&        Boston, MA 02110\-1301 USA
.Ve
.PP
or visit their web page on the internet at:
.PP
.Vb 1
\&        http://www.gnu.org/copyleft/gpl.html.
.Ve
.SH "AUTHOR"
.IX Header "AUTHOR"
Michael Robinton <michael@bizsystems.com>
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fINetAddr::IP\fR\|(3), \fINetAddr::IP::Lite\fR\|(3), \fINetAddr::IP::Util\fR\|(3)
