// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 5.4 (swiftlang-1205.0.24.14 clang-1205.0.19.54)
// swift-module-flags: -target x86_64-apple-ios14.5-macabi -enable-objc-interop -autolink-force-load -enable-library-evolution -module-link-name swiftUIKit -swift-version 5 -enforce-exclusivity=checked -O -module-name UIKit
import Foundation
import Swift
@_exported import UIKit
extension UIPasteboard {
  @available(iOS 14.0, *)
  open func detectPatterns(for patterns: Swift.Set<UIKit.UIPasteboard.DetectionPattern>, completionHandler: @escaping (Swift.Result<Swift.Set<UIKit.UIPasteboard.DetectionPattern>, Swift.Error>) -> ())
  @available(iOS 14.0, *)
  open func detectPatterns(for patterns: Swift.Set<UIKit.UIPasteboard.DetectionPattern>, inItemSet itemSet: Foundation.IndexSet?, completionHandler: @escaping (Swift.Result<[Swift.Set<UIKit.UIPasteboard.DetectionPattern>], Swift.Error>) -> ())
  @available(iOS 14.0, *)
  open func detectValues(for patterns: Swift.Set<UIKit.UIPasteboard.DetectionPattern>, completionHandler: @escaping (Swift.Result<[UIKit.UIPasteboard.DetectionPattern : Any], Swift.Error>) -> ())
  @available(iOS 14.0, *)
  open func detectValues(for patterns: Swift.Set<UIKit.UIPasteboard.DetectionPattern>, inItemSet itemSet: Foundation.IndexSet?, completionHandler: @escaping (Swift.Result<[[UIKit.UIPasteboard.DetectionPattern : Any]], Swift.Error>) -> ())
}
@available(iOS 14.0, tvOS 14.0, *)
public struct NSDiffableDataSourceSectionSnapshot<ItemIdentifierType> where ItemIdentifierType : Swift.Hashable {
  public init()
  public init(_ snapshot: UIKit.NSDiffableDataSourceSectionSnapshot<ItemIdentifierType>)
  public mutating func append(_ items: [ItemIdentifierType], to parent: ItemIdentifierType? = nil)
  public mutating func insert(_ items: [ItemIdentifierType], before item: ItemIdentifierType)
  public mutating func insert(_ items: [ItemIdentifierType], after item: ItemIdentifierType)
  public mutating func delete(_ items: [ItemIdentifierType])
  public mutating func deleteAll()
  public mutating func expand(_ items: [ItemIdentifierType])
  public mutating func collapse(_ items: [ItemIdentifierType])
  public mutating func replace(childrenOf parent: ItemIdentifierType, using snapshot: UIKit.NSDiffableDataSourceSectionSnapshot<ItemIdentifierType>)
  public mutating func insert(_ snapshot: UIKit.NSDiffableDataSourceSectionSnapshot<ItemIdentifierType>, before item: (ItemIdentifierType))
  public mutating func insert(_ snapshot: UIKit.NSDiffableDataSourceSectionSnapshot<ItemIdentifierType>, after item: (ItemIdentifierType))
  public func isExpanded(_ item: ItemIdentifierType) -> Swift.Bool
  public func isVisible(_ item: ItemIdentifierType) -> Swift.Bool
  public func contains(_ item: ItemIdentifierType) -> Swift.Bool
  public func level(of item: ItemIdentifierType) -> Swift.Int
  public func index(of item: ItemIdentifierType) -> Swift.Int?
  public func parent(of child: ItemIdentifierType) -> ItemIdentifierType?
  public func snapshot(of parent: ItemIdentifierType, includingParent: Swift.Bool = false) -> UIKit.NSDiffableDataSourceSectionSnapshot<ItemIdentifierType>
  public var items: [ItemIdentifierType] {
    get
  }
  public var rootItems: [ItemIdentifierType] {
    get
  }
  public var visibleItems: [ItemIdentifierType] {
    get
  }
  public func visualDescription() -> Swift.String
}
@available(iOS 14.0, tvOS 14.0, *)
extension UICollectionViewDiffableDataSource {
  public func apply(_ snapshot: UIKit.NSDiffableDataSourceSectionSnapshot<ItemIdentifierType>, to section: SectionIdentifierType, animatingDifferences: Swift.Bool = true, completion: (() -> Swift.Void)? = nil)
  public func snapshot(for section: SectionIdentifierType) -> UIKit.NSDiffableDataSourceSectionSnapshot<ItemIdentifierType>
}
@available(iOS 14.0, tvOS 14.0, *)
extension NSDiffableDataSourceSectionSnapshot : Swift._ObjectiveCBridgeable {
  @_semantics("convertToObjectiveC") public func _bridgeToObjectiveC() -> UIKit.NSDiffableDataSourceSectionSnapshotReference
  public static func _forceBridgeFromObjectiveC(_ input: UIKit.NSDiffableDataSourceSectionSnapshotReference, result: inout UIKit.NSDiffableDataSourceSectionSnapshot<ItemIdentifierType>?)
  public static func _conditionallyBridgeFromObjectiveC(_ input: UIKit.NSDiffableDataSourceSectionSnapshotReference, result: inout UIKit.NSDiffableDataSourceSectionSnapshot<ItemIdentifierType>?) -> Swift.Bool
  @_effects(readonly) public static func _unconditionallyBridgeFromObjectiveC(_ snapshot: UIKit.NSDiffableDataSourceSectionSnapshotReference?) -> UIKit.NSDiffableDataSourceSectionSnapshot<ItemIdentifierType>
  public typealias _ObjectiveCType = UIKit.NSDiffableDataSourceSectionSnapshotReference
}
@available(iOS 14.0, tvOS 14.0, *)
extension UICollectionViewCell {
  @available(iOS 14.0, tvOS 14.0, *)
  public var contentConfiguration: UIKit.UIContentConfiguration? {
    get
    set(config)
  }
}
@available(iOS 14.0, tvOS 14.0, *)
extension UICollectionViewListCell {
  @available(iOS 14.0, tvOS 14.0, *)
  public func defaultContentConfiguration() -> UIKit.UIListContentConfiguration
}
@available(iOS 14.0, tvOS 14.0, *)
extension UITableViewCell {
  @available(iOS 14.0, tvOS 14.0, *)
  public var contentConfiguration: UIKit.UIContentConfiguration? {
    get
    set(config)
  }
  @available(iOS 14.0, tvOS 14.0, *)
  public func defaultContentConfiguration() -> UIKit.UIListContentConfiguration
}
@available(iOS 14.0, tvOS 14.0, *)
extension UITableViewHeaderFooterView {
  @available(iOS 14.0, tvOS 14.0, *)
  public var contentConfiguration: UIKit.UIContentConfiguration? {
    get
    set(config)
  }
  @available(iOS 14.0, tvOS 14.0, *)
  public func defaultContentConfiguration() -> UIKit.UIListContentConfiguration
}
@available(iOS 14.0, tvOS 14.0, *)
extension UIListContentView : UIKit.UIContentView {
  @available(iOS 14.0, tvOS 14.0, *)
  public var configuration: UIKit.UIContentConfiguration {
    get
    set(config)
  }
  @available(iOS 14.0, tvOS 14.0, *)
  convenience public init(configuration: UIKit.UIListContentConfiguration)
}
@available(iOS 14.0, tvOS 14.0, *)
public protocol UIContentView : ObjectiveC.NSObjectProtocol {
  var configuration: UIKit.UIContentConfiguration { get set }
}
@available(iOS 14.0, tvOS 14.0, *)
public protocol UIContentConfiguration {
  func makeContentView() -> UIKit.UIView & UIKit.UIContentView
  func updated(for state: UIKit.UIConfigurationState) -> Self
}
@available(iOS 14.0, tvOS 14.0, *)
public struct UIListContentConfiguration : UIKit.UIContentConfiguration, Swift.Hashable {
  public struct ImageProperties : Swift.Hashable {
    public var preferredSymbolConfiguration: UIKit.UIImage.SymbolConfiguration? {
      get
      set(preferredSymbolConfiguration)
    }
    public var tintColor: UIKit.UIColor? {
      get
      set(tintColor)
    }
    public var tintColorTransformer: UIKit.UIConfigurationColorTransformer? {
      get
      set(tintColorTransformer)
    }
    public func resolvedTintColor(for tintColor: UIKit.UIColor) -> UIKit.UIColor
    public var cornerRadius: CoreGraphics.CGFloat {
      get
      set(cornerRadius)
    }
    public var maximumSize: CoreGraphics.CGSize {
      get
      set(maximumSize)
    }
    public var reservedLayoutSize: CoreGraphics.CGSize {
      get
      set(reservedLayoutSize)
    }
    public var accessibilityIgnoresInvertColors: Swift.Bool {
      get
      set(accessibilityIgnoresInvertColors)
    }
    public static let standardDimension: CoreGraphics.CGFloat
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: UIKit.UIListContentConfiguration.ImageProperties, b: UIKit.UIListContentConfiguration.ImageProperties) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
  }
  public struct TextProperties : Swift.Hashable {
    public enum TextAlignment : Swift.Hashable {
      case natural
      case center
      case justified
      public static func == (a: UIKit.UIListContentConfiguration.TextProperties.TextAlignment, b: UIKit.UIListContentConfiguration.TextProperties.TextAlignment) -> Swift.Bool
      public func hash(into hasher: inout Swift.Hasher)
      public var hashValue: Swift.Int {
        get
      }
    }
    public enum TextTransform : Swift.Hashable {
      case none
      case uppercase
      case lowercase
      case capitalized
      public static func == (a: UIKit.UIListContentConfiguration.TextProperties.TextTransform, b: UIKit.UIListContentConfiguration.TextProperties.TextTransform) -> Swift.Bool
      public func hash(into hasher: inout Swift.Hasher)
      public var hashValue: Swift.Int {
        get
      }
    }
    public var font: UIKit.UIFont {
      get
      set(font)
    }
    public var color: UIKit.UIColor {
      get
      set(color)
    }
    public var colorTransformer: UIKit.UIConfigurationColorTransformer? {
      get
      set(colorTransformer)
    }
    public func resolvedColor() -> UIKit.UIColor
    public var alignment: UIKit.UIListContentConfiguration.TextProperties.TextAlignment {
      get
      set(alignment)
    }
    public var lineBreakMode: UIKit.NSLineBreakMode {
      get
      set(lineBreakMode)
    }
    public var numberOfLines: Swift.Int {
      get
      set(numberOfLines)
    }
    public var adjustsFontSizeToFitWidth: Swift.Bool {
      get
      set(adjustsFontSizeToFitWidth)
    }
    public var minimumScaleFactor: CoreGraphics.CGFloat {
      get
      set(minimumScaleFactor)
    }
    public var allowsDefaultTighteningForTruncation: Swift.Bool {
      get
      set(allowsDefaultTighteningForTruncation)
    }
    public var adjustsFontForContentSizeCategory: Swift.Bool {
      get
      set(adjustsFontForContentSizeCategory)
    }
    public var transform: UIKit.UIListContentConfiguration.TextProperties.TextTransform {
      get
      set(transform)
    }
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: UIKit.UIListContentConfiguration.TextProperties, b: UIKit.UIListContentConfiguration.TextProperties) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
  }
  public static func cell() -> UIKit.UIListContentConfiguration
  public static func subtitleCell() -> UIKit.UIListContentConfiguration
  public static func valueCell() -> UIKit.UIListContentConfiguration
  public static func plainHeader() -> UIKit.UIListContentConfiguration
  public static func plainFooter() -> UIKit.UIListContentConfiguration
  public static func groupedHeader() -> UIKit.UIListContentConfiguration
  public static func groupedFooter() -> UIKit.UIListContentConfiguration
  public static func sidebarCell() -> UIKit.UIListContentConfiguration
  public static func sidebarSubtitleCell() -> UIKit.UIListContentConfiguration
  public static func accompaniedSidebarCell() -> UIKit.UIListContentConfiguration
  public static func accompaniedSidebarSubtitleCell() -> UIKit.UIListContentConfiguration
  public static func sidebarHeader() -> UIKit.UIListContentConfiguration
  public func makeContentView() -> UIKit.UIView & UIKit.UIContentView
  public func updated(for state: UIKit.UIConfigurationState) -> UIKit.UIListContentConfiguration
  public var image: UIKit.UIImage? {
    get
    set(image)
  }
  public var imageProperties: UIKit.UIListContentConfiguration.ImageProperties {
    get
    set(imageProperties)
  }
  public var text: Swift.String? {
    get
    set(text)
  }
  public var attributedText: Foundation.NSAttributedString? {
    get
    set(attributedText)
  }
  public var textProperties: UIKit.UIListContentConfiguration.TextProperties {
    get
    set(textProperties)
  }
  public var secondaryText: Swift.String? {
    get
    set(secondaryText)
  }
  public var secondaryAttributedText: Foundation.NSAttributedString? {
    get
    set(secondaryAttributedText)
  }
  public var secondaryTextProperties: UIKit.UIListContentConfiguration.TextProperties {
    get
    set(secondaryTextProperties)
  }
  public var axesPreservingSuperviewLayoutMargins: UIKit.UIAxis {
    get
    set(axesPreservingSuperviewLayoutMargins)
  }
  public var directionalLayoutMargins: UIKit.NSDirectionalEdgeInsets {
    get
    set(directionalLayoutMargins)
  }
  public var prefersSideBySideTextAndSecondaryText: Swift.Bool {
    get
    set(prefersSideBySideTextAndSecondaryText)
  }
  public var imageToTextPadding: CoreGraphics.CGFloat {
    get
    set(imageToTextPadding)
  }
  public var textToSecondaryTextHorizontalPadding: CoreGraphics.CGFloat {
    get
    set(textToSecondaryTextHorizontalPadding)
  }
  public var textToSecondaryTextVerticalPadding: CoreGraphics.CGFloat {
    get
    set(textToSecondaryTextVerticalPadding)
  }
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: UIKit.UIListContentConfiguration, b: UIKit.UIListContentConfiguration) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
@available(iOS 14.0, tvOS 14.0, *)
extension UIListContentConfiguration.ImageProperties : Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible, Swift.CustomReflectable {
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
  public var customMirror: Swift.Mirror {
    get
  }
}
@available(iOS 14.0, tvOS 14.0, *)
extension UIListContentConfiguration.TextProperties : Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible, Swift.CustomReflectable {
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
  public var customMirror: Swift.Mirror {
    get
  }
}
@available(iOS 14.0, tvOS 14.0, *)
extension UIListContentConfiguration : Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible, Swift.CustomReflectable {
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
  public var customMirror: Swift.Mirror {
    get
  }
}
extension UIBarButtonItem {
  @available(iOS 14.0, *)
  convenience public init(systemItem: UIKit.UIBarButtonItem.SystemItem, primaryAction: UIKit.UIAction? = nil, menu: UIKit.UIMenu? = nil)
  @available(iOS 14.0, *)
  convenience public init(title: Swift.String? = nil, image: UIKit.UIImage? = nil, primaryAction: UIKit.UIAction? = nil, menu: UIKit.UIMenu? = nil)
}
extension UIControl {
  @available(iOS 14.0, *)
  public func enumerateEventHandlers(_ iterator: (UIKit.UIAction?, (Any?, ObjectiveC.Selector)?, UIKit.UIControl.Event, inout Swift.Bool) -> Swift.Void)
}
extension UIButton {
  @available(iOS 14.0, *)
  convenience public init(type buttonType: UIKit.UIButton.ButtonType = .system, primaryAction: UIKit.UIAction?)
}
@available(iOS 14.0, tvOS 14.0, *)
extension UICollectionViewCell {
  @available(iOS 14.0, tvOS 14.0, *)
  public var backgroundConfiguration: UIKit.UIBackgroundConfiguration? {
    get
    set(backgroundConfiguration)
  }
}
@available(iOS 14.0, tvOS 14.0, *)
extension UITableViewCell {
  @available(iOS 14.0, tvOS 14.0, *)
  public var backgroundConfiguration: UIKit.UIBackgroundConfiguration? {
    get
    set(backgroundConfiguration)
  }
}
@available(iOS 14.0, tvOS 14.0, *)
extension UITableViewHeaderFooterView {
  @available(iOS 14.0, tvOS 14.0, *)
  public var backgroundConfiguration: UIKit.UIBackgroundConfiguration? {
    get
    set(backgroundConfiguration)
  }
}
@available(iOS 14.0, tvOS 14.0, *)
public struct UIConfigurationColorTransformer {
  public let transform: (UIKit.UIColor) -> UIKit.UIColor
  public init(_ transform: @escaping (UIKit.UIColor) -> UIKit.UIColor)
  public func callAsFunction(_ input: UIKit.UIColor) -> UIKit.UIColor
  public static let grayscale: UIKit.UIConfigurationColorTransformer
  public static let preferredTint: UIKit.UIConfigurationColorTransformer
  public static let monochromeTint: UIKit.UIConfigurationColorTransformer
}
@available(iOS 14.0, tvOS 14.0, *)
public struct UIBackgroundConfiguration : Swift.Hashable {
  public static func clear() -> UIKit.UIBackgroundConfiguration
  public static func listPlainCell() -> UIKit.UIBackgroundConfiguration
  public static func listPlainHeaderFooter() -> UIKit.UIBackgroundConfiguration
  public static func listGroupedCell() -> UIKit.UIBackgroundConfiguration
  public static func listGroupedHeaderFooter() -> UIKit.UIBackgroundConfiguration
  public static func listSidebarHeader() -> UIKit.UIBackgroundConfiguration
  public static func listSidebarCell() -> UIKit.UIBackgroundConfiguration
  public static func listAccompaniedSidebarCell() -> UIKit.UIBackgroundConfiguration
  public func updated(for state: UIKit.UIConfigurationState) -> UIKit.UIBackgroundConfiguration
  public var customView: UIKit.UIView? {
    get
    set(view)
  }
  public var cornerRadius: CoreGraphics.CGFloat {
    get
    set(cornerRadius)
  }
  public var backgroundInsets: UIKit.NSDirectionalEdgeInsets {
    get
    set(backgroundInsets)
  }
  public var edgesAddingLayoutMarginsToBackgroundInsets: UIKit.NSDirectionalRectEdge {
    get
    set(backgroundInsets)
  }
  public var backgroundColor: UIKit.UIColor? {
    get
    set(backgroundColor)
  }
  public var backgroundColorTransformer: UIKit.UIConfigurationColorTransformer? {
    get
    set(backgroundColorTransformer)
  }
  public func resolvedBackgroundColor(for tintColor: UIKit.UIColor) -> UIKit.UIColor
  public var visualEffect: UIKit.UIVisualEffect? {
    get
    set(visualEffect)
  }
  public var strokeColor: UIKit.UIColor? {
    get
    set(strokeColor)
  }
  public var strokeColorTransformer: UIKit.UIConfigurationColorTransformer? {
    get
    set(strokeColorTransformer)
  }
  public func resolvedStrokeColor(for tintColor: UIKit.UIColor) -> UIKit.UIColor
  public var strokeWidth: CoreGraphics.CGFloat {
    get
    set(strokeWidth)
  }
  public var strokeOutset: CoreGraphics.CGFloat {
    get
    set(strokeOutset)
  }
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: UIKit.UIBackgroundConfiguration, b: UIKit.UIBackgroundConfiguration) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
@available(iOS 14.0, tvOS 14.0, *)
extension UIBackgroundConfiguration : Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible, Swift.CustomReflectable {
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
  public var customMirror: Swift.Mirror {
    get
  }
}
@available(iOS 14.0, *)
open class UIIndirectScribbleInteraction<Delegate> : ObjectiveC.NSObject, UIKit.UIInteraction where Delegate : UIKit.UIIndirectScribbleInteractionDelegate {
  @objc weak public var view: UIKit.UIView? {
    get
  }
  weak public var delegate: Delegate? {
    get
  }
  @objc public func willMove(to view: UIKit.UIView?)
  @objc public func didMove(to view: UIKit.UIView?)
  public init(delegate: Delegate)
  public var isHandlingWriting: Swift.Bool {
    get
  }
  @objc override dynamic public init()
  @objc deinit
}
@available(iOS 14.0, *)
public protocol UIIndirectScribbleInteractionDelegate : ObjectiveC.NSObjectProtocol {
  associatedtype ElementIdentifier : Swift.Hashable = Swift.String
  func indirectScribbleInteraction(_ interaction: UIKit.UIInteraction, requestElementsIn rect: CoreGraphics.CGRect, completion: @escaping ([Self.ElementIdentifier]) -> Swift.Void)
  func indirectScribbleInteraction(_ interaction: UIKit.UIInteraction, isElementFocused elementIdentifier: Self.ElementIdentifier) -> Swift.Bool
  func indirectScribbleInteraction(_ interaction: UIKit.UIInteraction, frameForElement elementIdentifier: Self.ElementIdentifier) -> CoreGraphics.CGRect
  func indirectScribbleInteraction(_ interaction: UIKit.UIInteraction, focusElementIfNeeded elementIdentifier: Self.ElementIdentifier, referencePoint focusReferencePoint: CoreGraphics.CGPoint, completion: @escaping ((UIKit.UIResponder & UIKit.UITextInput)?) -> Swift.Void)
  func indirectScribbleInteraction(_ interaction: UIKit.UIInteraction, shouldDelayFocusForElement elementIdentifier: Self.ElementIdentifier) -> Swift.Bool
  func indirectScribbleInteraction(_ interaction: UIKit.UIInteraction, willBeginWritingInElement elementIdentifier: Self.ElementIdentifier)
  func indirectScribbleInteraction(_ interaction: UIKit.UIInteraction, didFinishWritingInElement elementIdentifier: Self.ElementIdentifier)
}
@available(iOS 14.0, *)
extension UIIndirectScribbleInteractionDelegate {
  public func indirectScribbleInteraction(_ interaction: UIKit.UIInteraction, willBeginWritingInElement elementIdentifier: Self.ElementIdentifier)
  public func indirectScribbleInteraction(_ interaction: UIKit.UIInteraction, didFinishWritingInElement elementIdentifier: Self.ElementIdentifier)
  public func indirectScribbleInteraction(_ interaction: UIKit.UIInteraction, shouldDelayFocusForElement elementIdentifier: Self.ElementIdentifier) -> Swift.Bool
}
extension UIEdgeInsets : Swift.Equatable {
  @_transparent public static func == (lhs: UIKit.UIEdgeInsets, rhs: UIKit.UIEdgeInsets) -> Swift.Bool {
    return lhs.top == rhs.top &&
           lhs.left == rhs.left &&
           lhs.bottom == rhs.bottom &&
           lhs.right == rhs.right
  }
}
@available(iOS 11.0, tvOS 11.0, watchOS 4.0, *)
extension NSDirectionalEdgeInsets : Swift.Equatable {
  @_transparent public static func == (lhs: UIKit.NSDirectionalEdgeInsets, rhs: UIKit.NSDirectionalEdgeInsets) -> Swift.Bool {
    return lhs.top == rhs.top &&
           lhs.leading == rhs.leading &&
           lhs.bottom == rhs.bottom &&
           lhs.trailing == rhs.trailing
  }
}
extension UIOffset : Swift.Equatable {
  @_transparent public static func == (lhs: UIKit.UIOffset, rhs: UIKit.UIOffset) -> Swift.Bool {
    return lhs.horizontal == rhs.horizontal &&
           lhs.vertical == rhs.vertical
  }
}
extension UIFloatRange : Swift.Equatable {
  @_transparent public static func == (lhs: UIKit.UIFloatRange, rhs: UIKit.UIFloatRange) -> Swift.Bool {
    return lhs.minimum == rhs.minimum &&
           lhs.maximum == rhs.maximum
  }
}
@available(swift, deprecated: 4.2, message: "Use == operator instead.")
public func UIEdgeInsetsEqualToEdgeInsets(_ insets1: UIKit.UIEdgeInsets, _ insets2: UIKit.UIEdgeInsets) -> Swift.Bool
@available(swift, deprecated: 4.2, message: "Use == operator instead.")
public func UIOffsetEqualToOffset(_ offset1: UIKit.UIOffset, _ offset2: UIKit.UIOffset) -> Swift.Bool
@available(swift, deprecated: 4.2, message: "Use == operator instead.")
public func UIFloatRangeIsEqualToRange(_ range: UIKit.UIFloatRange, _ otherRange: UIKit.UIFloatRange) -> Swift.Bool
extension UIEdgeInsets : Swift.Codable {
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
@available(iOS 11.0, tvOS 11.0, watchOS 4.0, *)
extension NSDirectionalEdgeInsets : Swift.Codable {
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
extension UIOffset : Swift.Codable {
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
extension UIFloatRange : Swift.Codable {
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
@available(swift 4)
public protocol _UIKitNumericRawRepresentable : Swift.Comparable, Swift.RawRepresentable where Self.RawValue : Swift.Comparable, Self.RawValue : Swift.Numeric {
}
extension _UIKitNumericRawRepresentable {
  public static func < (lhs: Self, rhs: Self) -> Swift.Bool
  public static func + (lhs: Self, rhs: Self.RawValue) -> Self
  public static func + (lhs: Self.RawValue, rhs: Self) -> Self
  public static func - (lhs: Self, rhs: Self.RawValue) -> Self
  public static func - (lhs: Self, rhs: Self) -> Self.RawValue
  public static func += (lhs: inout Self, rhs: Self.RawValue)
  public static func -= (lhs: inout Self, rhs: Self.RawValue)
}
extension UIFont.Weight : UIKit._UIKitNumericRawRepresentable {
}
extension UILayoutPriority : UIKit._UIKitNumericRawRepresentable {
}
extension UIWindow.Level : UIKit._UIKitNumericRawRepresentable {
}
@available(swift, obsoleted: 4.2, renamed: "getter:UIDeviceOrientation.isLandscape(self:)")
public func UIDeviceOrientationIsLandscape(_ orientation: UIKit.UIDeviceOrientation) -> Swift.Bool
@available(swift, obsoleted: 4.2, renamed: "getter:UIDeviceOrientation.isPortrait(self:)")
public func UIDeviceOrientationIsPortrait(_ orientation: UIKit.UIDeviceOrientation) -> Swift.Bool
@available(swift, obsoleted: 4.2, renamed: "getter:UIDeviceOrientation.isValidInterfaceOrientation(self:)")
public func UIDeviceOrientationIsValidInterfaceOrientation(_ orientation: UIKit.UIDeviceOrientation) -> Swift.Bool
@available(swift, obsoleted: 4.2, renamed: "getter:UIInterfaceOrientation.isPortrait(self:)")
public func UIInterfaceOrientationIsPortrait(_ orientation: UIKit.UIInterfaceOrientation) -> Swift.Bool
@available(swift, obsoleted: 4.2, renamed: "getter:UIInterfaceOrientation.isLandscape(self:)")
public func UIInterfaceOrientationIsLandscape(_ orientation: UIKit.UIInterfaceOrientation) -> Swift.Bool
extension UIActionSheet {
  convenience public init(title: Swift.String?, delegate: UIKit.UIActionSheetDelegate?, cancelButtonTitle: Swift.String?, destructiveButtonTitle: Swift.String?, otherButtonTitles firstButtonTitle: Swift.String, _ moreButtonTitles: Swift.String...)
}
extension UIAlertView {
  convenience public init(title: Swift.String, message: Swift.String, delegate: UIKit.UIAlertViewDelegate?, cancelButtonTitle: Swift.String?, otherButtonTitles firstButtonTitle: Swift.String, _ moreButtonTitles: Swift.String...)
}
extension UIView : Swift.__DefaultCustomPlaygroundQuickLookable {
  @available(*, deprecated, message: "UIView._defaultCustomPlaygroundQuickLook will be removed in a future Swift version")
  public var _defaultCustomPlaygroundQuickLook: Swift.PlaygroundQuickLook {
    get
  }
}
extension UIColor : Swift._ExpressibleByColorLiteral {
  @nonobjc required convenience public init(_colorLiteralRed red: Swift.Float, green: Swift.Float, blue: Swift.Float, alpha: Swift.Float)
}
public typealias _ColorLiteralType = UIKit.UIColor
extension UIImage : Swift._ExpressibleByImageLiteral {
  required convenience public init(imageLiteralResourceName name: Swift.String)
}
public typealias _ImageLiteralType = UIKit.UIImage
extension UIFont.TextStyle {
  @available(iOS 11.0, watchOS 4.0, tvOS 11.0, *)
  public var metrics: UIKit.UIFontMetrics {
    get
  }
}
extension UIContentSizeCategory {
  @available(iOS 11.0, tvOS 11.0, *)
  public var isAccessibilityCategory: Swift.Bool {
    get
  }
  @available(iOS 11.0, tvOS 11.0, *)
  public static func < (left: UIKit.UIContentSizeCategory, right: UIKit.UIContentSizeCategory) -> Swift.Bool
  @available(iOS 11.0, tvOS 11.0, *)
  public static func <= (left: UIKit.UIContentSizeCategory, right: UIKit.UIContentSizeCategory) -> Swift.Bool
  @available(iOS 11.0, tvOS 11.0, *)
  public static func > (left: UIKit.UIContentSizeCategory, right: UIKit.UIContentSizeCategory) -> Swift.Bool
  @available(iOS 11.0, tvOS 11.0, *)
  public static func >= (left: UIKit.UIContentSizeCategory, right: UIKit.UIContentSizeCategory) -> Swift.Bool
}
@available(iOS 11.0, tvOS 11.0, *)
extension UIFocusEnvironment {
  @available(iOS 11.0, tvOS 11.0, *)
  public func contains(_ environment: UIKit.UIFocusEnvironment) -> Swift.Bool
}
@available(iOS 11.0, tvOS 11.0, *)
extension UIFocusItem {
  @available(iOS 11.0, tvOS 11.0, *)
  public var isFocused: Swift.Bool {
    get
  }
}
@available(iOS 11.0, *)
extension UIDragDropSession {
  @available(iOS 11.0, *)
  public func canLoadObjects<T>(ofClass: T.Type) -> Swift.Bool where T : Swift._ObjectiveCBridgeable, T._ObjectiveCType : Foundation.NSItemProviderReading
}
@available(iOS 11.0, *)
extension UIDropSession {
  @available(iOS 11.0, *)
  public func loadObjects<T>(ofClass: T.Type, completion: @escaping ([T]) -> Swift.Void) -> Foundation.Progress where T : Swift._ObjectiveCBridgeable, T._ObjectiveCType : Foundation.NSItemProviderReading
}
@available(iOS 11.0, *)
extension UIPasteConfiguration {
  @available(iOS 11.0, *)
  convenience public init<T>(forAccepting _: T.Type) where T : Swift._ObjectiveCBridgeable, T._ObjectiveCType : Foundation.NSItemProviderReading
  @available(iOS 11.0, *)
  public func addTypeIdentifiers<T>(forAccepting aClass: T.Type) where T : Swift._ObjectiveCBridgeable, T._ObjectiveCType : Foundation.NSItemProviderReading
}
extension UIPasteboard {
  @available(iOS 11.0, *)
  public func setObjects<T>(_ objects: [T]) where T : Swift._ObjectiveCBridgeable, T._ObjectiveCType : Foundation.NSItemProviderWriting
  @available(iOS 11.0, *)
  public func setObjects<T>(_ objects: [T], localOnly: Swift.Bool, expirationDate: Foundation.Date?) where T : Swift._ObjectiveCBridgeable, T._ObjectiveCType : Foundation.NSItemProviderWriting
}
@available(swift, obsoleted: 4.2, renamed: "UIPrintError.Code.notAvailable.rawValue")
public let UIPrintingNotAvailableError: Swift.Int
@available(swift, obsoleted: 4.2, renamed: "UIPrintError.Code.noContent.rawValue")
public let UIPrintNoContentError: Swift.Int
@available(swift, obsoleted: 4.2, renamed: "UIPrintError.Code.unknownImageFormat.rawValue")
public let UIPrintUnknownImageFormatError: Swift.Int
@available(swift, obsoleted: 4.2, renamed: "UIPrintError.Code.jobFailed.rawValue")
public let UIPrintJobFailedError: Swift.Int
@available(swift, deprecated: 4.2, message: "Use the overload of UIApplicationMain where the type of the second parameter is UnsafeMutablePointer<UnsafeMutablePointer<Int8>?>, which is the same as the type of CommandLine.unsafeArgv.")
public func UIApplicationMain(_ argc: Swift.Int32, _ argv: Swift.UnsafeMutablePointer<Swift.UnsafeMutablePointer<Swift.Int8>>!, _ principalClassName: Swift.String?, _ delegateClassName: Swift.String?) -> Swift.Int32
extension UIApplicationDelegate {
  @_alwaysEmitIntoClient public static func main() {
    // Explicitly use the version of UIApplicationMain that was deprecated in Swift 4.2
    typealias _MainFunction =
      (Int32, UnsafeMutablePointer<UnsafeMutablePointer<Int8>>, String?, String?) -> Int32
    let _main = UIApplicationMain as _MainFunction
    
    // Convert the argument vector to `UnsafeMutablePointer<UnsafeMutablePointer<Int8>>`
    // This is a no-op for Swift versions < 4.2
    let argv = UnsafeMutableRawPointer(CommandLine.unsafeArgv)
      .bindMemory(to: UnsafeMutablePointer<Int8>.self, capacity: Int(CommandLine.argc))
    exit(_main(CommandLine.argc, argv, nil, NSStringFromClass(self)))
  }
}
extension UIStoryboard {
  @available(iOS 13.0, tvOS 13.0, *)
  public func instantiateInitialViewController<ViewController>(creator: ((Foundation.NSCoder) -> ViewController?)? = nil) -> ViewController? where ViewController : UIKit.UIViewController
  @available(iOS 13.0, tvOS 13.0, *)
  public func instantiateViewController<ViewController>(identifier: Swift.String, creator: ((Foundation.NSCoder) -> ViewController?)? = nil) -> ViewController where ViewController : UIKit.UIViewController
}
extension UIAccessibilityTraits : Swift.OptionSet {
  public typealias ArrayLiteralElement = UIKit.UIAccessibilityTraits
  public typealias Element = UIKit.UIAccessibilityTraits
}
extension UITextDirection {
  public static func storage(_ direction: UIKit.UITextStorageDirection) -> UIKit.UITextDirection
  public static func layout(_ direction: UIKit.UITextLayoutDirection) -> UIKit.UITextDirection
}
@available(iOS 13.0, tvOS 13.0, *)
public struct NSDiffableDataSourceSnapshot<SectionIdentifierType, ItemIdentifierType> where SectionIdentifierType : Swift.Hashable, ItemIdentifierType : Swift.Hashable {
  public init()
  public var numberOfItems: Swift.Int {
    get
  }
  public var numberOfSections: Swift.Int {
    get
  }
  public var sectionIdentifiers: [SectionIdentifierType] {
    get
  }
  public var itemIdentifiers: [ItemIdentifierType] {
    get
  }
  public func numberOfItems(inSection identifier: SectionIdentifierType) -> Swift.Int
  public func itemIdentifiers(inSection identifier: SectionIdentifierType) -> [ItemIdentifierType]
  public func sectionIdentifier(containingItem identifier: ItemIdentifierType) -> SectionIdentifierType?
  public func indexOfItem(_ identifier: ItemIdentifierType) -> Swift.Int?
  public func indexOfSection(_ identifier: SectionIdentifierType) -> Swift.Int?
  public mutating func appendItems(_ identifiers: [ItemIdentifierType], toSection sectionIdentifier: SectionIdentifierType? = nil)
  public mutating func insertItems(_ identifiers: [ItemIdentifierType], beforeItem beforeIdentifier: ItemIdentifierType)
  public mutating func insertItems(_ identifiers: [ItemIdentifierType], afterItem afterIdentifier: ItemIdentifierType)
  public mutating func deleteItems(_ identifiers: [ItemIdentifierType])
  public mutating func deleteAllItems()
  public mutating func moveItem(_ identifier: ItemIdentifierType, beforeItem toIdentifier: ItemIdentifierType)
  public mutating func moveItem(_ identifier: ItemIdentifierType, afterItem toIdentifier: ItemIdentifierType)
  public mutating func reloadItems(_ identifiers: [ItemIdentifierType])
  public mutating func appendSections(_ identifiers: [SectionIdentifierType])
  public mutating func insertSections(_ identifiers: [SectionIdentifierType], beforeSection toIdentifier: SectionIdentifierType)
  public mutating func insertSections(_ identifiers: [SectionIdentifierType], afterSection toIdentifier: SectionIdentifierType)
  public mutating func deleteSections(_ identifiers: [SectionIdentifierType])
  public mutating func moveSection(_ identifier: SectionIdentifierType, beforeSection toIdentifier: SectionIdentifierType)
  public mutating func moveSection(_ identifier: SectionIdentifierType, afterSection toIdentifier: SectionIdentifierType)
  public mutating func reloadSections(_ identifiers: [SectionIdentifierType])
}
@available(iOS 13.0, tvOS 13.0, *)
extension NSDiffableDataSourceSnapshot : Swift._ObjectiveCBridgeable {
  @_semantics("convertToObjectiveC") public func _bridgeToObjectiveC() -> UIKit.NSDiffableDataSourceSnapshotReference
  public static func _forceBridgeFromObjectiveC(_ input: UIKit.NSDiffableDataSourceSnapshotReference, result: inout UIKit.NSDiffableDataSourceSnapshot<SectionIdentifierType, ItemIdentifierType>?)
  public static func _conditionallyBridgeFromObjectiveC(_ input: UIKit.NSDiffableDataSourceSnapshotReference, result: inout UIKit.NSDiffableDataSourceSnapshot<SectionIdentifierType, ItemIdentifierType>?) -> Swift.Bool
  @_effects(readonly) public static func _unconditionallyBridgeFromObjectiveC(_ snapshot: UIKit.NSDiffableDataSourceSnapshotReference?) -> UIKit.NSDiffableDataSourceSnapshot<SectionIdentifierType, ItemIdentifierType>
  public typealias _ObjectiveCType = UIKit.NSDiffableDataSourceSnapshotReference
}
@available(iOS 13.0, tvOS 13.0, *)
open class UICollectionViewDiffableDataSource<SectionIdentifierType, ItemIdentifierType> : ObjectiveC.NSObject, UIKit.UICollectionViewDataSource where SectionIdentifierType : Swift.Hashable, ItemIdentifierType : Swift.Hashable {
  public typealias CellProvider = (UIKit.UICollectionView, Foundation.IndexPath, ItemIdentifierType) -> UIKit.UICollectionViewCell?
  public typealias SupplementaryViewProvider = (UIKit.UICollectionView, Swift.String, Foundation.IndexPath) -> UIKit.UICollectionReusableView?
  public var supplementaryViewProvider: UIKit.UICollectionViewDiffableDataSource<SectionIdentifierType, ItemIdentifierType>.SupplementaryViewProvider? {
    get
    set
  }
  public init(collectionView: UIKit.UICollectionView, cellProvider: @escaping UIKit.UICollectionViewDiffableDataSource<SectionIdentifierType, ItemIdentifierType>.CellProvider)
  open func apply(_ snapshot: UIKit.NSDiffableDataSourceSnapshot<SectionIdentifierType, ItemIdentifierType>, animatingDifferences: Swift.Bool = true, completion: (() -> Swift.Void)? = nil)
  open func snapshot() -> UIKit.NSDiffableDataSourceSnapshot<SectionIdentifierType, ItemIdentifierType>
  open func itemIdentifier(for indexPath: Foundation.IndexPath) -> ItemIdentifierType?
  open func indexPath(for itemIdentifier: ItemIdentifierType) -> Foundation.IndexPath?
  @objc open func numberOfSections(in collectionView: UIKit.UICollectionView) -> Swift.Int
  @objc open func collectionView(_ collectionView: UIKit.UICollectionView, numberOfItemsInSection section: Swift.Int) -> Swift.Int
  @objc open func collectionView(_ collectionView: UIKit.UICollectionView, cellForItemAt indexPath: Foundation.IndexPath) -> UIKit.UICollectionViewCell
  @objc open func collectionView(_ collectionView: UIKit.UICollectionView, viewForSupplementaryElementOfKind kind: Swift.String, at indexPath: Foundation.IndexPath) -> UIKit.UICollectionReusableView
  @objc open func collectionView(_ collectionView: UIKit.UICollectionView, canMoveItemAt indexPath: Foundation.IndexPath) -> Swift.Bool
  @objc open func collectionView(_ collectionView: UIKit.UICollectionView, moveItemAt sourceIndexPath: Foundation.IndexPath, to destinationIndexPath: Foundation.IndexPath)
  @objc open func indexTitles(for collectionView: UIKit.UICollectionView) -> [Swift.String]?
  @objc open func collectionView(_ collectionView: UIKit.UICollectionView, indexPathForIndexTitle title: Swift.String, at index: Swift.Int) -> Foundation.IndexPath
  public func description() -> Swift.String
  @objc override dynamic public init()
  @objc deinit
}
@available(iOS 13.0, tvOS 13.0, *)
open class UITableViewDiffableDataSource<SectionIdentifierType, ItemIdentifierType> : ObjectiveC.NSObject, UIKit.UITableViewDataSource where SectionIdentifierType : Swift.Hashable, ItemIdentifierType : Swift.Hashable {
  public typealias CellProvider = (UIKit.UITableView, Foundation.IndexPath, ItemIdentifierType) -> UIKit.UITableViewCell?
  public init(tableView: UIKit.UITableView, cellProvider: @escaping UIKit.UITableViewDiffableDataSource<SectionIdentifierType, ItemIdentifierType>.CellProvider)
  open func apply(_ snapshot: UIKit.NSDiffableDataSourceSnapshot<SectionIdentifierType, ItemIdentifierType>, animatingDifferences: Swift.Bool = true, completion: (() -> Swift.Void)? = nil)
  open func snapshot() -> UIKit.NSDiffableDataSourceSnapshot<SectionIdentifierType, ItemIdentifierType>
  open func itemIdentifier(for indexPath: Foundation.IndexPath) -> ItemIdentifierType?
  open func indexPath(for itemIdentifier: ItemIdentifierType) -> Foundation.IndexPath?
  public var defaultRowAnimation: UIKit.UITableView.RowAnimation {
    get
    set
  }
  @objc open func numberOfSections(in tableView: UIKit.UITableView) -> Swift.Int
  @objc open func tableView(_ tableView: UIKit.UITableView, numberOfRowsInSection section: Swift.Int) -> Swift.Int
  @objc open func tableView(_ tableView: UIKit.UITableView, cellForRowAt indexPath: Foundation.IndexPath) -> UIKit.UITableViewCell
  @objc open func tableView(_ tableView: UIKit.UITableView, titleForHeaderInSection section: Swift.Int) -> Swift.String?
  @objc open func tableView(_ tableView: UIKit.UITableView, titleForFooterInSection section: Swift.Int) -> Swift.String?
  @objc open func tableView(_ tableView: UIKit.UITableView, canEditRowAt indexPath: Foundation.IndexPath) -> Swift.Bool
  @objc open func tableView(_ tableView: UIKit.UITableView, commit editingStyle: UIKit.UITableViewCell.EditingStyle, forRowAt indexPath: Foundation.IndexPath)
  @objc open func tableView(_ tableView: UIKit.UITableView, canMoveRowAt indexPath: Foundation.IndexPath) -> Swift.Bool
  @objc open func tableView(_ tableView: UIKit.UITableView, moveRowAt sourceIndexPath: Foundation.IndexPath, to destinationIndexPath: Foundation.IndexPath)
  @objc open func sectionIndexTitles(for tableView: UIKit.UITableView) -> [Swift.String]?
  @objc open func tableView(_ tableView: UIKit.UITableView, sectionForSectionIndexTitle title: Swift.String, at index: Swift.Int) -> Swift.Int
  public func description() -> Swift.String
  @objc override dynamic public init()
  @objc deinit
}
@available(iOS 13.0, *)
extension UICommand {
  convenience public init(title: Swift.String = "", image: UIKit.UIImage? = nil, action: ObjectiveC.Selector, propertyList: Any? = nil, alternates: [UIKit.UICommandAlternate] = [], discoverabilityTitle: Swift.String? = nil, attributes: UIKit.UIMenuElement.Attributes = [], state: UIKit.UIMenuElement.State = .off)
}
@available(iOS 13.0, *)
extension UIKeyCommand {
  convenience public init(title: Swift.String = "", image: UIKit.UIImage? = nil, action: ObjectiveC.Selector, input: Swift.String, modifierFlags: UIKit.UIKeyModifierFlags = [], propertyList: Any? = nil, alternates: [UIKit.UICommandAlternate] = [], discoverabilityTitle: Swift.String? = nil, attributes: UIKit.UIMenuElement.Attributes = [], state: UIKit.UIMenuElement.State = .off)
}
@available(iOS 13.0, tvOS 14.0, *)
extension UIAction {
  convenience public init(title: Swift.String = "", image: UIKit.UIImage? = nil, identifier: UIKit.UIAction.Identifier? = nil, discoverabilityTitle: Swift.String? = nil, attributes: UIKit.UIMenuElement.Attributes = [], state: UIKit.UIMenuElement.State = .off, handler: @escaping UIKit.UIActionHandler)
}
@available(iOS 13.0, tvOS 14.0, *)
extension UIMenu {
  convenience public init(title: Swift.String = "", image: UIKit.UIImage? = nil, identifier: UIKit.UIMenu.Identifier? = nil, options: UIKit.UIMenu.Options = [], children: [UIKit.UIMenuElement] = [])
}
@available(iOS 13.0, tvOS 14.0, *)
extension UIMenuBuilder {
  public func command(for action: ObjectiveC.Selector, propertyList: Any? = nil) -> UIKit.UICommand?
}
@available(iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension UIImage {
  public var baselineOffsetFromBottom: CoreGraphics.CGFloat? {
    get
  }
}
@available(iOS 13.4, *)
public enum UIPointerShape {
  case path(_: UIKit.UIBezierPath)
  case roundedRect(_: CoreGraphics.CGRect, radius: CoreGraphics.CGFloat = UIPointerShape.defaultCornerRadius)
  case verticalBeam(length: CoreGraphics.CGFloat)
  case horizontalBeam(length: CoreGraphics.CGFloat)
  public static let defaultCornerRadius: CoreGraphics.CGFloat
}
@available(iOS 13.4, *)
public enum UIPointerEffect {
  public enum TintMode {
    case none, overlay, underlay
    public static func == (a: UIKit.UIPointerEffect.TintMode, b: UIKit.UIPointerEffect.TintMode) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  case automatic(_: UIKit.UITargetedPreview)
  case highlight(_: UIKit.UITargetedPreview)
  case lift(_: UIKit.UITargetedPreview)
  case hover(_: UIKit.UITargetedPreview, preferredTintMode: UIKit.UIPointerEffect.TintMode = .overlay, prefersShadow: Swift.Bool = false, prefersScaledContent: Swift.Bool = true)
  public var preview: UIKit.UITargetedPreview {
    get
  }
}
@available(iOS 13.4, *)
extension UIPointerStyle {
  convenience public init(effect: UIKit.UIPointerEffect, shape: UIKit.UIPointerShape? = nil)
  convenience public init(shape: UIKit.UIPointerShape, constrainedAxes: UIKit.UIAxis = [])
}
@available(iOS 13.4, *)
extension UIPointerRegion {
  convenience public init(rect: CoreGraphics.CGRect, identifier: Swift.AnyHashable? = nil)
  public var identifier: Swift.AnyHashable? {
    get
  }
}
@available(iOS 13.4, *)
extension UIButton {
  public typealias PointerStyleProvider = (UIKit.UIButton, UIKit.UIPointerEffect, UIKit.UIPointerShape) -> UIKit.UIPointerStyle?
  public var pointerStyleProvider: UIKit.UIButton.PointerStyleProvider? {
    get
    set
  }
}
@available(iOS 13.4, *)
extension UIPointerEffect : Swift._ObjectiveCBridgeable {
  @_semantics("convertToObjectiveC") public func _bridgeToObjectiveC() -> UIKit.__UIPointerEffect
  public static func _forceBridgeFromObjectiveC(_ input: UIKit.__UIPointerEffect, result: inout UIKit.UIPointerEffect?)
  public static func _conditionallyBridgeFromObjectiveC(_ input: UIKit.__UIPointerEffect, result: inout UIKit.UIPointerEffect?) -> Swift.Bool
  @_effects(readonly) public static func _unconditionallyBridgeFromObjectiveC(_ internalEffect: UIKit.__UIPointerEffect?) -> UIKit.UIPointerEffect
  public typealias _ObjectiveCType = UIKit.__UIPointerEffect
}
@available(iOS 13.4, *)
extension UIPointerShape : Swift._ObjectiveCBridgeable {
  @_semantics("convertToObjectiveC") public func _bridgeToObjectiveC() -> UIKit.__UIPointerShape
  public static func _forceBridgeFromObjectiveC(_ input: UIKit.__UIPointerShape, result: inout UIKit.UIPointerShape?)
  public static func _conditionallyBridgeFromObjectiveC(_ input: UIKit.__UIPointerShape, result: inout UIKit.UIPointerShape?) -> Swift.Bool
  @_effects(readonly) public static func _unconditionallyBridgeFromObjectiveC(_ _effect: UIKit.__UIPointerShape?) -> UIKit.UIPointerShape
  public typealias _ObjectiveCType = UIKit.__UIPointerShape
}
@available(iOS 14.5, *)
@available(tvOS, unavailable)
public struct UIListSeparatorConfiguration : Swift.Hashable {
  public enum Visibility : Swift.Hashable {
    case automatic
    case visible
    case hidden
    public static func == (a: UIKit.UIListSeparatorConfiguration.Visibility, b: UIKit.UIListSeparatorConfiguration.Visibility) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public var topSeparatorVisibility: UIKit.UIListSeparatorConfiguration.Visibility {
    get
    set
  }
  public var bottomSeparatorVisibility: UIKit.UIListSeparatorConfiguration.Visibility {
    get
    set
  }
  public static let automaticInsets: UIKit.NSDirectionalEdgeInsets
  public var topSeparatorInsets: UIKit.NSDirectionalEdgeInsets {
    get
    set
  }
  public var bottomSeparatorInsets: UIKit.NSDirectionalEdgeInsets {
    get
    set
  }
  public var color: UIKit.UIColor {
    get
    set
  }
  public var multipleSelectionColor: UIKit.UIColor {
    get
    set
  }
  public init(listAppearance: UIKit.UICollectionLayoutListConfiguration.Appearance)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: UIKit.UIListSeparatorConfiguration, b: UIKit.UIListSeparatorConfiguration) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
@available(iOS 14.5, *)
@available(tvOS, unavailable)
extension UIListSeparatorConfiguration : Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible, Swift.CustomReflectable {
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
  public var customMirror: Swift.Mirror {
    get
  }
}
@available(iOS 14.5, *)
@available(tvOS, unavailable)
extension UIListSeparatorConfiguration : Swift._ObjectiveCBridgeable {
  @_semantics("convertToObjectiveC") public func _bridgeToObjectiveC() -> UIKit.__UIListSeparatorConfiguration
  public static func _forceBridgeFromObjectiveC(_ source: UIKit.__UIListSeparatorConfiguration, result: inout UIKit.UIListSeparatorConfiguration?)
  public static func _conditionallyBridgeFromObjectiveC(_ input: UIKit.__UIListSeparatorConfiguration, result: inout UIKit.UIListSeparatorConfiguration?) -> Swift.Bool
  @_effects(readonly) public static func _unconditionallyBridgeFromObjectiveC(_ _configuration: UIKit.__UIListSeparatorConfiguration?) -> UIKit.UIListSeparatorConfiguration
  public typealias _ObjectiveCType = UIKit.__UIListSeparatorConfiguration
}
@available(iOS 14.0, tvOS 14.0, *)
extension UICollectionView {
  public struct CellRegistration<Cell, Item> where Cell : UIKit.UICollectionViewCell {
    public typealias Handler = (Cell, Foundation.IndexPath, Item) -> Swift.Void
    public init(handler: @escaping UIKit.UICollectionView.CellRegistration<Cell, Item>.Handler)
    public init(cellNib: UIKit.UINib, handler: @escaping UIKit.UICollectionView.CellRegistration<Cell, Item>.Handler)
  }
  public struct SupplementaryRegistration<Supplementary> where Supplementary : UIKit.UICollectionReusableView {
    public typealias Handler = (Supplementary, Swift.String, Foundation.IndexPath) -> Swift.Void
    public init(elementKind: Swift.String, handler: @escaping UIKit.UICollectionView.SupplementaryRegistration<Supplementary>.Handler)
    public init(supplementaryNib: UIKit.UINib, elementKind: Swift.String, handler: @escaping UIKit.UICollectionView.SupplementaryRegistration<Supplementary>.Handler)
  }
  public func dequeueConfiguredReusableCell<Cell, Item>(using registration: UIKit.UICollectionView.CellRegistration<Cell, Item>, for indexPath: Foundation.IndexPath, item: Item?) -> Cell where Cell : UIKit.UICollectionViewCell
  public func dequeueConfiguredReusableSupplementary<Supplementary>(using registration: UIKit.UICollectionView.SupplementaryRegistration<Supplementary>, for indexPath: Foundation.IndexPath) -> Supplementary where Supplementary : UIKit.UICollectionReusableView
}
@available(iOS 14.0, tvOS 14.0, *)
extension UICollectionViewListCell {
  @available(iOS 14.0, tvOS 14.0, *)
  public var accessories: [UIKit.UICellAccessory] {
    get
    set
  }
}
@available(iOS 14.0, tvOS 14.0, *)
public struct UICellAccessory {
  public typealias ActionHandler = () -> Swift.Void
  public enum DisplayedState {
    case always
    case whenEditing
    case whenNotEditing
    public static func == (a: UIKit.UICellAccessory.DisplayedState, b: UIKit.UICellAccessory.DisplayedState) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public enum LayoutDimension {
    case actual
    case standard
    case custom(CoreGraphics.CGFloat)
  }
  public struct DisclosureIndicatorOptions {
    public var isHidden: Swift.Bool
    public var reservedLayoutWidth: UIKit.UICellAccessory.LayoutDimension
    public var tintColor: UIKit.UIColor?
    public init(isHidden: Swift.Bool? = nil, reservedLayoutWidth: UIKit.UICellAccessory.LayoutDimension? = nil, tintColor: UIKit.UIColor? = nil)
  }
  public static func disclosureIndicator(displayed: UIKit.UICellAccessory.DisplayedState = .always, options: UIKit.UICellAccessory.DisclosureIndicatorOptions = DisclosureIndicatorOptions()) -> UIKit.UICellAccessory
  public struct CheckmarkOptions {
    public var isHidden: Swift.Bool
    public var reservedLayoutWidth: UIKit.UICellAccessory.LayoutDimension
    public var tintColor: UIKit.UIColor?
    public init(isHidden: Swift.Bool? = nil, reservedLayoutWidth: UIKit.UICellAccessory.LayoutDimension? = nil, tintColor: UIKit.UIColor? = nil)
  }
  public static func checkmark(displayed: UIKit.UICellAccessory.DisplayedState = .always, options: UIKit.UICellAccessory.CheckmarkOptions = CheckmarkOptions()) -> UIKit.UICellAccessory
  public struct DeleteOptions {
    public var isHidden: Swift.Bool
    public var reservedLayoutWidth: UIKit.UICellAccessory.LayoutDimension
    public var tintColor: UIKit.UIColor?
    public var backgroundColor: UIKit.UIColor?
    public init(isHidden: Swift.Bool? = nil, reservedLayoutWidth: UIKit.UICellAccessory.LayoutDimension? = nil, tintColor: UIKit.UIColor? = nil, backgroundColor: UIKit.UIColor? = nil)
  }
  public static func delete(displayed: UIKit.UICellAccessory.DisplayedState = .whenEditing, options: UIKit.UICellAccessory.DeleteOptions = DeleteOptions(), actionHandler: UIKit.UICellAccessory.ActionHandler? = nil) -> UIKit.UICellAccessory
  public struct InsertOptions {
    public var isHidden: Swift.Bool
    public var reservedLayoutWidth: UIKit.UICellAccessory.LayoutDimension
    public var tintColor: UIKit.UIColor?
    public var backgroundColor: UIKit.UIColor?
    public init(isHidden: Swift.Bool? = nil, reservedLayoutWidth: UIKit.UICellAccessory.LayoutDimension? = nil, tintColor: UIKit.UIColor? = nil, backgroundColor: UIKit.UIColor? = nil)
  }
  public static func insert(displayed: UIKit.UICellAccessory.DisplayedState = .whenEditing, options: UIKit.UICellAccessory.InsertOptions = InsertOptions(), actionHandler: UIKit.UICellAccessory.ActionHandler? = nil) -> UIKit.UICellAccessory
  public struct ReorderOptions {
    public var isHidden: Swift.Bool
    public var reservedLayoutWidth: UIKit.UICellAccessory.LayoutDimension
    public var tintColor: UIKit.UIColor?
    public var showsVerticalSeparator: Swift.Bool
    public init(isHidden: Swift.Bool? = nil, reservedLayoutWidth: UIKit.UICellAccessory.LayoutDimension? = nil, tintColor: UIKit.UIColor? = nil, showsVerticalSeparator: Swift.Bool? = nil)
  }
  public static func reorder(displayed: UIKit.UICellAccessory.DisplayedState = .whenEditing, options: UIKit.UICellAccessory.ReorderOptions = ReorderOptions()) -> UIKit.UICellAccessory
  public struct MultiselectOptions {
    public var isHidden: Swift.Bool
    public var reservedLayoutWidth: UIKit.UICellAccessory.LayoutDimension
    public var tintColor: UIKit.UIColor?
    public var backgroundColor: UIKit.UIColor?
    public init(isHidden: Swift.Bool? = nil, reservedLayoutWidth: UIKit.UICellAccessory.LayoutDimension? = nil, tintColor: UIKit.UIColor? = nil, backgroundColor: UIKit.UIColor? = nil)
  }
  public static func multiselect(displayed: UIKit.UICellAccessory.DisplayedState = .whenEditing, options: UIKit.UICellAccessory.MultiselectOptions = MultiselectOptions()) -> UIKit.UICellAccessory
  public struct OutlineDisclosureOptions {
    public enum Style {
      case automatic
      case header
      case cell
      public static func == (a: UIKit.UICellAccessory.OutlineDisclosureOptions.Style, b: UIKit.UICellAccessory.OutlineDisclosureOptions.Style) -> Swift.Bool
      public func hash(into hasher: inout Swift.Hasher)
      public var hashValue: Swift.Int {
        get
      }
    }
    public var style: UIKit.UICellAccessory.OutlineDisclosureOptions.Style
    public var isHidden: Swift.Bool
    public var reservedLayoutWidth: UIKit.UICellAccessory.LayoutDimension
    public var tintColor: UIKit.UIColor?
    public init(style: UIKit.UICellAccessory.OutlineDisclosureOptions.Style? = nil, isHidden: Swift.Bool? = nil, reservedLayoutWidth: UIKit.UICellAccessory.LayoutDimension? = nil, tintColor: UIKit.UIColor? = nil)
  }
  public static func outlineDisclosure(displayed: UIKit.UICellAccessory.DisplayedState = .always, options: UIKit.UICellAccessory.OutlineDisclosureOptions = OutlineDisclosureOptions(), actionHandler: UIKit.UICellAccessory.ActionHandler? = nil) -> UIKit.UICellAccessory
  public struct LabelOptions {
    public var isHidden: Swift.Bool
    public var reservedLayoutWidth: UIKit.UICellAccessory.LayoutDimension
    public var tintColor: UIKit.UIColor?
    public var font: UIKit.UIFont
    public var adjustsFontForContentSizeCategory: Swift.Bool
    public init(isHidden: Swift.Bool? = nil, reservedLayoutWidth: UIKit.UICellAccessory.LayoutDimension? = nil, tintColor: UIKit.UIColor? = nil, font: UIKit.UIFont? = nil, adjustsFontForContentSizeCategory: Swift.Bool? = nil)
  }
  public static func label(text: Swift.String, displayed: UIKit.UICellAccessory.DisplayedState = .always, options: UIKit.UICellAccessory.LabelOptions = LabelOptions()) -> UIKit.UICellAccessory
  public enum Placement {
    public typealias Position = ([UIKit.UICellAccessory]) -> Swift.Int
    public static func position(before accessory: UIKit.UICellAccessory) -> UIKit.UICellAccessory.Placement.Position
    public static func position(after accessory: UIKit.UICellAccessory) -> UIKit.UICellAccessory.Placement.Position
    case leading(displayed: UIKit.UICellAccessory.DisplayedState = .always, at: UIKit.UICellAccessory.Placement.Position = { $0.count })
    case trailing(displayed: UIKit.UICellAccessory.DisplayedState = .always, at: UIKit.UICellAccessory.Placement.Position = { _ in 0 })
  }
  public struct CustomViewConfiguration {
    public let customView: UIKit.UIView
    public let placement: UIKit.UICellAccessory.Placement
    public var isHidden: Swift.Bool
    public var reservedLayoutWidth: UIKit.UICellAccessory.LayoutDimension
    public var tintColor: UIKit.UIColor?
    public var maintainsFixedSize: Swift.Bool
    public init(customView: UIKit.UIView, placement: UIKit.UICellAccessory.Placement, isHidden: Swift.Bool? = nil, reservedLayoutWidth: UIKit.UICellAccessory.LayoutDimension? = nil, tintColor: UIKit.UIColor? = nil, maintainsFixedSize: Swift.Bool? = nil)
  }
  public static func customView(configuration: UIKit.UICellAccessory.CustomViewConfiguration) -> UIKit.UICellAccessory
  public enum AccessoryType : Swift.Hashable {
    case disclosureIndicator
    case outlineDisclosure
    case checkmark
    case delete
    case insert
    case reorder
    case multiselect
    case label
    case customView(UIKit.UIView)
    public static func == (lhs: UIKit.UICellAccessory.AccessoryType, rhs: UIKit.UICellAccessory.AccessoryType) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public let accessoryType: UIKit.UICellAccessory.AccessoryType
}
@available(iOS 14.0, tvOS 14.0, *)
public struct UICollectionLayoutListConfiguration {
  public enum Appearance {
    case plain
    case grouped
    @available(tvOS, unavailable)
    case insetGrouped
    @available(tvOS, unavailable)
    case sidebar
    @available(tvOS, unavailable)
    case sidebarPlain
    public static func == (a: UIKit.UICollectionLayoutListConfiguration.Appearance, b: UIKit.UICollectionLayoutListConfiguration.Appearance) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public enum HeaderMode {
    case none, supplementary, firstItemInSection
    public static func == (a: UIKit.UICollectionLayoutListConfiguration.HeaderMode, b: UIKit.UICollectionLayoutListConfiguration.HeaderMode) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public enum FooterMode {
    case none, supplementary
    public static func == (a: UIKit.UICollectionLayoutListConfiguration.FooterMode, b: UIKit.UICollectionLayoutListConfiguration.FooterMode) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  @available(tvOS, unavailable)
  public typealias SwipeActionsConfigurationProvider = (Foundation.IndexPath) -> UIKit.UISwipeActionsConfiguration?
  @available(iOS 14.5, *)
  @available(tvOS, unavailable)
  public typealias ItemSeparatorHandler = (Foundation.IndexPath, UIKit.UIListSeparatorConfiguration) -> UIKit.UIListSeparatorConfiguration
  public init(appearance: UIKit.UICollectionLayoutListConfiguration.Appearance)
  public var appearance: UIKit.UICollectionLayoutListConfiguration.Appearance {
    get
  }
  @available(tvOS, unavailable)
  public var showsSeparators: Swift.Bool {
    get
    set(showsSeparators)
  }
  @available(iOS 14.5, *)
  @available(tvOS, unavailable)
  public var separatorConfiguration: UIKit.UIListSeparatorConfiguration {
    get
    set(separatorConfiguration)
  }
  @available(iOS 14.5, *)
  @available(tvOS, unavailable)
  public var itemSeparatorHandler: UIKit.UICollectionLayoutListConfiguration.ItemSeparatorHandler? {
    get
    set
  }
  public var backgroundColor: UIKit.UIColor? {
    get
    set(color)
  }
  @available(tvOS, unavailable)
  public var leadingSwipeActionsConfigurationProvider: UIKit.UICollectionLayoutListConfiguration.SwipeActionsConfigurationProvider? {
    get
    set(provider)
  }
  @available(tvOS, unavailable)
  public var trailingSwipeActionsConfigurationProvider: UIKit.UICollectionLayoutListConfiguration.SwipeActionsConfigurationProvider? {
    get
    set(provider)
  }
  public var headerMode: UIKit.UICollectionLayoutListConfiguration.HeaderMode {
    get
    set(mode)
  }
  public var footerMode: UIKit.UICollectionLayoutListConfiguration.FooterMode {
    get
    set(mode)
  }
}
@available(iOS 14.0, tvOS 14.0, *)
extension UICollectionViewCompositionalLayout {
  public static func list(using configuration: UIKit.UICollectionLayoutListConfiguration) -> UIKit.UICollectionViewCompositionalLayout
}
@available(iOS 14.0, tvOS 14.0, *)
extension NSCollectionLayoutSection {
  public static func list(using configuration: UIKit.UICollectionLayoutListConfiguration, layoutEnvironment: UIKit.NSCollectionLayoutEnvironment) -> UIKit.NSCollectionLayoutSection
}
extension IndexPath {
  public init(row: Swift.Int, section: Swift.Int)
  public var section: Swift.Int {
    get
    set
  }
  public var row: Swift.Int {
    get
    set
  }
}
extension IndexPath {
  public init(item: Swift.Int, section: Swift.Int)
  public var item: Swift.Int {
    get
    set
  }
}
extension URLResourceValues {
  @available(iOS 8.0, *)
  public var thumbnailDictionary: [Foundation.URLThumbnailDictionaryItem : UIKit.UIImage]? {
    get
  }
}
extension UIEdgeInsets : Swift._ObjectiveCBridgeable {
  public func _bridgeToObjectiveC() -> Foundation.NSValue
  public static func _forceBridgeFromObjectiveC(_ source: Foundation.NSValue, result: inout UIKit.UIEdgeInsets?)
  public static func _conditionallyBridgeFromObjectiveC(_ source: Foundation.NSValue, result: inout UIKit.UIEdgeInsets?) -> Swift.Bool
  public static func _unconditionallyBridgeFromObjectiveC(_ source: Foundation.NSValue?) -> UIKit.UIEdgeInsets
  public typealias _ObjectiveCType = Foundation.NSValue
}
@available(iOS 11.0, tvOS 11.0, watchOS 4.0, *)
extension NSDirectionalEdgeInsets : Swift._ObjectiveCBridgeable {
  public func _bridgeToObjectiveC() -> Foundation.NSValue
  public static func _forceBridgeFromObjectiveC(_ source: Foundation.NSValue, result: inout UIKit.NSDirectionalEdgeInsets?)
  public static func _conditionallyBridgeFromObjectiveC(_ source: Foundation.NSValue, result: inout UIKit.NSDirectionalEdgeInsets?) -> Swift.Bool
  public static func _unconditionallyBridgeFromObjectiveC(_ source: Foundation.NSValue?) -> UIKit.NSDirectionalEdgeInsets
  public typealias _ObjectiveCType = Foundation.NSValue
}
extension UIOffset : Swift._ObjectiveCBridgeable {
  public func _bridgeToObjectiveC() -> Foundation.NSValue
  public static func _forceBridgeFromObjectiveC(_ source: Foundation.NSValue, result: inout UIKit.UIOffset?)
  public static func _conditionallyBridgeFromObjectiveC(_ source: Foundation.NSValue, result: inout UIKit.UIOffset?) -> Swift.Bool
  public static func _unconditionallyBridgeFromObjectiveC(_ source: Foundation.NSValue?) -> UIKit.UIOffset
  public typealias _ObjectiveCType = Foundation.NSValue
}
@available(iOS 14.0, tvOS 14.0, *)
extension UICollectionViewCell {
  @available(iOS 14.0, tvOS 14.0, *)
  @objc(_bridgedConfigurationState) dynamic open var configurationState: UIKit.UICellConfigurationState {
    @objc get
  }
  @available(iOS 14.0, tvOS 14.0, *)
  @objc(_bridgedUpdateConfigurationUsingState:) dynamic open func updateConfiguration(using state: UIKit.UICellConfigurationState)
}
@available(iOS 14.0, tvOS 14.0, *)
extension UITableViewCell {
  @available(iOS 14.0, tvOS 14.0, *)
  @objc(_bridgedConfigurationState) dynamic open var configurationState: UIKit.UICellConfigurationState {
    @objc get
  }
  @available(iOS 14.0, tvOS 14.0, *)
  @objc(_bridgedUpdateConfigurationUsingState:) dynamic open func updateConfiguration(using state: UIKit.UICellConfigurationState)
}
@available(iOS 14.0, tvOS 14.0, *)
extension UITableViewHeaderFooterView {
  @available(iOS 14.0, tvOS 14.0, *)
  @objc(_bridgedConfigurationState) dynamic open var configurationState: UIKit.UIViewConfigurationState {
    @objc get
  }
  @available(iOS 14.0, tvOS 14.0, *)
  @objc(_bridgedUpdateConfigurationUsingState:) dynamic open func updateConfiguration(using state: UIKit.UIViewConfigurationState)
}
@available(iOS 14.0, tvOS 14.0, *)
public protocol UIConfigurationState {
  init(traitCollection: UIKit.UITraitCollection)
  var traitCollection: UIKit.UITraitCollection { get set }
  subscript(key: UIKit.UIConfigurationStateCustomKey) -> Swift.AnyHashable? { get set }
}
@available(iOS 14.0, tvOS 14.0, *)
public struct UIViewConfigurationState : UIKit.UIConfigurationState, Swift.Hashable {
  public var traitCollection: UIKit.UITraitCollection {
    get
    set
  }
  public var isDisabled: Swift.Bool {
    get
    set
  }
  public var isHighlighted: Swift.Bool {
    get
    set
  }
  public var isSelected: Swift.Bool {
    get
    set
  }
  public var isFocused: Swift.Bool {
    get
    set
  }
  public subscript(key: UIKit.UIConfigurationStateCustomKey) -> Swift.AnyHashable? {
    get
    set
  }
  public init(traitCollection: UIKit.UITraitCollection)
  public static func == (lhs: UIKit.UIViewConfigurationState, rhs: UIKit.UIViewConfigurationState) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@available(iOS 14.0, tvOS 14.0, *)
public struct UICellConfigurationState : UIKit.UIConfigurationState, Swift.Hashable {
  @available(iOS 14.0, *)
  public enum DragState : Swift.Hashable {
    case none
    case lifting
    case dragging
    public static func == (a: UIKit.UICellConfigurationState.DragState, b: UIKit.UICellConfigurationState.DragState) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  @available(iOS 14.0, *)
  public enum DropState : Swift.Hashable {
    case none
    case notTargeted
    case targeted
    public static func == (a: UIKit.UICellConfigurationState.DropState, b: UIKit.UICellConfigurationState.DropState) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public var traitCollection: UIKit.UITraitCollection {
    get
    set
  }
  public var isDisabled: Swift.Bool {
    get
    set
  }
  public var isHighlighted: Swift.Bool {
    get
    set
  }
  public var isSelected: Swift.Bool {
    get
    set
  }
  public var isFocused: Swift.Bool {
    get
    set
  }
  public var isEditing: Swift.Bool {
    get
    set
  }
  public var isExpanded: Swift.Bool {
    get
    set
  }
  public var isSwiped: Swift.Bool {
    get
    set
  }
  public var isReordering: Swift.Bool {
    get
    set
  }
  public var cellDragState: UIKit.UICellConfigurationState.DragState {
    get
    set
  }
  public var cellDropState: UIKit.UICellConfigurationState.DropState {
    get
    set
  }
  public subscript(key: UIKit.UIConfigurationStateCustomKey) -> Swift.AnyHashable? {
    get
    set
  }
  public init(traitCollection: UIKit.UITraitCollection)
  public static func == (lhs: UIKit.UICellConfigurationState, rhs: UIKit.UICellConfigurationState) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@available(iOS 14.0, tvOS 14.0, *)
extension UIViewConfigurationState : Swift._ObjectiveCBridgeable {
  @_semantics("convertToObjectiveC") public func _bridgeToObjectiveC() -> UIKit.__UIViewConfigurationState
  public static func _forceBridgeFromObjectiveC(_ input: UIKit.__UIViewConfigurationState, result: inout UIKit.UIViewConfigurationState?)
  public static func _conditionallyBridgeFromObjectiveC(_ input: UIKit.__UIViewConfigurationState, result: inout UIKit.UIViewConfigurationState?) -> Swift.Bool
  @_effects(readonly) public static func _unconditionallyBridgeFromObjectiveC(_ _state: UIKit.__UIViewConfigurationState?) -> UIKit.UIViewConfigurationState
  public typealias _ObjectiveCType = UIKit.__UIViewConfigurationState
}
@available(iOS 14.0, tvOS 14.0, *)
extension UICellConfigurationState : Swift._ObjectiveCBridgeable {
  @_semantics("convertToObjectiveC") public func _bridgeToObjectiveC() -> UIKit.__UICellConfigurationState
  public static func _forceBridgeFromObjectiveC(_ input: UIKit.__UICellConfigurationState, result: inout UIKit.UICellConfigurationState?)
  public static func _conditionallyBridgeFromObjectiveC(_ input: UIKit.__UICellConfigurationState, result: inout UIKit.UICellConfigurationState?) -> Swift.Bool
  @_effects(readonly) public static func _unconditionallyBridgeFromObjectiveC(_ _state: UIKit.__UICellConfigurationState?) -> UIKit.UICellConfigurationState
  public typealias _ObjectiveCType = UIKit.__UICellConfigurationState
}
@available(iOS 14.0, tvOS 14.0, *)
extension UIViewConfigurationState : Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible, Swift.CustomReflectable {
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
  public var customMirror: Swift.Mirror {
    get
  }
}
@available(iOS 14.0, tvOS 14.0, *)
extension UICellConfigurationState : Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible, Swift.CustomReflectable {
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
  public var customMirror: Swift.Mirror {
    get
  }
}
@available(iOS 14.0, tvOS 14.0, *)
public struct NSDiffableDataSourceSectionTransaction<SectionIdentifierType, ItemIdentifierType> where SectionIdentifierType : Swift.Hashable, ItemIdentifierType : Swift.Hashable {
  public var sectionIdentifier: SectionIdentifierType {
    get
  }
  public var initialSnapshot: UIKit.NSDiffableDataSourceSectionSnapshot<ItemIdentifierType> {
    get
  }
  public var finalSnapshot: UIKit.NSDiffableDataSourceSectionSnapshot<ItemIdentifierType> {
    get
  }
  public var difference: Swift.CollectionDifference<ItemIdentifierType> {
    get
  }
}
@available(iOS 14.0, tvOS 14.0, *)
public struct NSDiffableDataSourceTransaction<SectionIdentifierType, ItemIdentifierType> where SectionIdentifierType : Swift.Hashable, ItemIdentifierType : Swift.Hashable {
  public var initialSnapshot: UIKit.NSDiffableDataSourceSnapshot<SectionIdentifierType, ItemIdentifierType> {
    get
  }
  public var finalSnapshot: UIKit.NSDiffableDataSourceSnapshot<SectionIdentifierType, ItemIdentifierType> {
    get
  }
  public var difference: Swift.CollectionDifference<ItemIdentifierType> {
    get
  }
  public var sectionTransactions: [UIKit.NSDiffableDataSourceSectionTransaction<SectionIdentifierType, ItemIdentifierType>] {
    get
  }
}
@available(iOS 14.0, tvOS 14.0, *)
extension UICollectionViewDiffableDataSource {
  public struct ReorderingHandlers {
    public var canReorderItem: ((ItemIdentifierType) -> Swift.Bool)? {
      get
      set(handler)
    }
    public var willReorder: ((UIKit.NSDiffableDataSourceTransaction<SectionIdentifierType, ItemIdentifierType>) -> Swift.Void)? {
      get
      set(handler)
    }
    public var didReorder: ((UIKit.NSDiffableDataSourceTransaction<SectionIdentifierType, ItemIdentifierType>) -> Swift.Void)? {
      get
      set(handler)
    }
    public init()
  }
  public var reorderingHandlers: UIKit.UICollectionViewDiffableDataSource<SectionIdentifierType, ItemIdentifierType>.ReorderingHandlers {
    get
    set(handlers)
  }
}
@available(iOS 14.0, tvOS 14.0, *)
extension UICollectionViewDiffableDataSource {
  public struct SectionSnapshotHandlers<ItemIdentifierType> where ItemIdentifierType : Swift.Hashable {
    public var shouldExpandItem: ((ItemIdentifierType) -> Swift.Bool)? {
      get
      set(handler)
    }
    public var willExpandItem: ((ItemIdentifierType) -> Swift.Void)? {
      get
      set(handler)
    }
    public var shouldCollapseItem: ((ItemIdentifierType) -> Swift.Bool)? {
      get
      set(handler)
    }
    public var willCollapseItem: ((ItemIdentifierType) -> Swift.Void)? {
      get
      set(handler)
    }
    public var snapshotForExpandingParent: ((ItemIdentifierType, UIKit.NSDiffableDataSourceSectionSnapshot<ItemIdentifierType>) -> UIKit.NSDiffableDataSourceSectionSnapshot<ItemIdentifierType>)? {
      get
      set(handler)
    }
    public init()
  }
  public var sectionSnapshotHandlers: UIKit.UICollectionViewDiffableDataSource<SectionIdentifierType, ItemIdentifierType>.SectionSnapshotHandlers<ItemIdentifierType> {
    get
    set(handlers)
  }
}
@available(iOS 13.4, *)
extension UIKit.UIPointerEffect.TintMode : Swift.Equatable {}
@available(iOS 13.4, *)
extension UIKit.UIPointerEffect.TintMode : Swift.Hashable {}
@available(iOS 14.0, tvOS 14.0, *)
extension UIKit.UICellAccessory.DisplayedState : Swift.Equatable {}
@available(iOS 14.0, tvOS 14.0, *)
extension UIKit.UICellAccessory.DisplayedState : Swift.Hashable {}
@available(iOS 14.0, tvOS 14.0, *)
extension UIKit.UICellAccessory.OutlineDisclosureOptions.Style : Swift.Equatable {}
@available(iOS 14.0, tvOS 14.0, *)
extension UIKit.UICellAccessory.OutlineDisclosureOptions.Style : Swift.Hashable {}
@available(iOS 14.0, tvOS 14.0, *)
extension UIKit.UICollectionLayoutListConfiguration.Appearance : Swift.Equatable {}
@available(iOS 14.0, tvOS 14.0, *)
extension UIKit.UICollectionLayoutListConfiguration.Appearance : Swift.Hashable {}
@available(iOS 14.0, tvOS 14.0, *)
extension UIKit.UICollectionLayoutListConfiguration.HeaderMode : Swift.Equatable {}
@available(iOS 14.0, tvOS 14.0, *)
extension UIKit.UICollectionLayoutListConfiguration.HeaderMode : Swift.Hashable {}
@available(iOS 14.0, tvOS 14.0, *)
extension UIKit.UICollectionLayoutListConfiguration.FooterMode : Swift.Equatable {}
@available(iOS 14.0, tvOS 14.0, *)
extension UIKit.UICollectionLayoutListConfiguration.FooterMode : Swift.Hashable {}
