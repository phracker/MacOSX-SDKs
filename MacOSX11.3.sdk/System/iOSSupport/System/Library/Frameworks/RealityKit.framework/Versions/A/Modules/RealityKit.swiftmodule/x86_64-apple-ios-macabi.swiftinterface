// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 5.4 (swiftlang-1205.0.24.14 clang-1205.0.19.54)
// swift-module-flags: -target x86_64-apple-ios14.5-macabi -enable-objc-interop -swift-version 5 -enforce-exclusivity=checked -O -enable-library-evolution -module-name RealityKit
import ARKit
import AVFoundation
import AudioToolbox
import Combine
import CoreGraphics
import CoreText
import Darwin
import Foundation
import Metal.MTLDevice
import Metal
import MultipeerConnectivity
import QuartzCore
import Swift
import UIKit
import os
@_exported import simd
public struct __RKEntityInteractionsComponent {
  @_hasMissingDesignatedInitializers public class Registration {
    final public let componentType: Swift.OpaquePointer
    @objc deinit
  }
  public static var registration: RealityKit.__RKEntityInteractionsComponent.Registration?
}
extension Entity {
  public var __interactions: [RealityKit.__RKEntityInteractionSpecification] {
    get
    set
  }
}
@available(macOS 10.15, iOS 13.0, *)
public struct DirectionalLightComponent : RealityKit.Component, Swift.Equatable {
  public typealias Color = UIKit.UIColor
  public struct Shadow : RealityKit.Component, Swift.Equatable {
    public var depthBias: Swift.Float
    public var maximumDistance: Swift.Float
    public init()
    public init(maximumDistance: Swift.Float = 5.0, depthBias: Swift.Float = 1.0)
    public static func __fromCore(_ coreComponent: RealityKit.__ComponentRef) -> RealityKit.DirectionalLightComponent.Shadow
    public func __toCore(_ coreComponent: RealityKit.__ComponentRef)
    public static var __coreComponentType: RealityKit.__ComponentTypeRef {
      get
    }
    public static func == (a: RealityKit.DirectionalLightComponent.Shadow, b: RealityKit.DirectionalLightComponent.Shadow) -> Swift.Bool
  }
  public var color: RealityKit.DirectionalLightComponent.Color
  public var intensity: Swift.Float
  public var isRealWorldProxy: Swift.Bool
  public init(color: RealityKit.DirectionalLightComponent.Color = .white, intensity: Swift.Float = 2145.7078, isRealWorldProxy: Swift.Bool = false)
  public static func __fromCore(_ coreComponent: RealityKit.__ComponentRef) -> RealityKit.DirectionalLightComponent
  public func __toCore(_ coreComponent: RealityKit.__ComponentRef)
  public static var __coreComponentType: RealityKit.__ComponentTypeRef {
    get
  }
  public static func == (a: RealityKit.DirectionalLightComponent, b: RealityKit.DirectionalLightComponent) -> Swift.Bool
}
public struct __REOSLog {
  public static var UpdateLoop: os.OSLog
  public static var ARQL: os.OSLog
  public static var RealityComposer: os.OSLog
}
public struct __RESignpostID {
  public static var UpdateLoop: os.OSSignpostID
  public static var ARQL: os.OSSignpostID
  public static var RealityComposer: os.OSSignpostID
}
public class __REOSSignpostScope {
  public init(osLog: os.OSLog, signpostID: os.OSSignpostID, name: Swift.StaticString)
  @objc deinit
}
public protocol __RKSimulationSceneCoordinatorDelegate : AnyObject {
  func coordinator(_ coordinator: RealityKit.__RKSimulationSceneCoordinator, didRequestToChangeToScene sceneIdentifier: Foundation.UUID) -> Swift.Bool
}
public enum __RKSimulationSceneCoordinatorState {
  case stopped
  case running
  public static func == (a: RealityKit.__RKSimulationSceneCoordinatorState, b: RealityKit.__RKSimulationSceneCoordinatorState) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public class __RKSimulationSceneCoordinator {
  @available(*, deprecated, message: "Please use the per-interaction-service scene coordinator.")
  public static var shared: RealityKit.__RKSimulationSceneCoordinator
  public init()
  weak public var delegate: RealityKit.__RKSimulationSceneCoordinatorDelegate?
  public var simulationState: RealityKit.__RKSimulationSceneCoordinatorState
  public func changeToScene(with identifier: Foundation.UUID) -> Swift.Bool
  @objc deinit
}
public struct __AmbientLightComponent : RealityKit.Component, Swift.Equatable {
  public typealias Color = UIKit.UIColor
  public var color: RealityKit.__AmbientLightComponent.Color
  public var intensity: Swift.Float
  public init()
  public init(color: RealityKit.__AmbientLightComponent.Color = .white, intensity: Swift.Float = 683.0)
  public static func __fromCore(_ coreComponent: RealityKit.__ComponentRef) -> RealityKit.__AmbientLightComponent
  public func __toCore(_ coreComponent: RealityKit.__ComponentRef)
  public static var __coreComponentType: RealityKit.__ComponentTypeRef {
    get
  }
  public static func == (a: RealityKit.__AmbientLightComponent, b: RealityKit.__AmbientLightComponent) -> Swift.Bool
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class __RKEmphasisPopAnimation : RealityKit.__RKEmphasisBaseAnimation {
  @objc deinit
}
public class __RKEntityLookAtCameraAction : RealityKit.__RKEntityAction {
  convenience public init(targetEntity: RealityKit.Entity?, duration: Swift.Float = 1.0, direction: Swift.SIMD3<Swift.Float> = SIMD3<Float>(0, 1, 0), upVector: Swift.SIMD3<Swift.Float> = SIMD3<Float>(0, 1, 0))
  public init(targetEntity: RealityKit.Entity?, duration: Swift.Float = 1.0, animationDuration: Swift.Float = 0.0, direction: Swift.SIMD3<Swift.Float> = SIMD3<Float>(0, 1, 0), rotation: Swift.Float = 0, upVector: Swift.SIMD3<Swift.Float> = SIMD3<Float>(0, 1, 0), loops: Swift.Bool = false)
  override public func perform(with context: RealityKit.__RKEntityActionContext) -> Swift.Bool
  override public func reversed() -> RealityKit.__RKEntityAction?
  @objc override public func copy(with zone: ObjectiveC.NSZone? = nil) -> Any
  override public init(targetEntity: RealityKit.Entity? = super)
  @objc deinit
}
@_hasMissingDesignatedInitializers public class __RealityFileURLResolver {
  @available(*, deprecated, message: "Don't use this variable")
  weak public static var weakShared: RealityKit.__RealityFileURLResolver? {
    get
    set
  }
  @available(*, deprecated, message: "use the \"instance(for assetService: __REAssetService)\" instead")
  public static var shared: RealityKit.__RealityFileURLResolver {
    get
  }
  public static func instance(for assetService: RealityKit.__REAssetService) -> RealityKit.__RealityFileURLResolver
  @available(*, deprecated, message: "use the \"init(_ assetService: __REAssetService)\" instead")
  public init()
  @objc deinit
  public static let assetPathPrefix: Swift.String
  public static let schemePrefix: Swift.String
  public func registerRealityFileResolver(assetService: RealityKit.__REAssetService)
  public func registerRealityFileResolver()
  public func unregisterRealityFileResolver()
  public func resolvedURL(for subpath: Swift.String) -> Foundation.URL?
  public func resolvedURL(group: Swift.String, name: Swift.String) -> Foundation.URL?
  public func setResolvedURLPath(_ resolvedURLPath: Swift.String, for key: Swift.String)
  public func createSchemePrefix(with realityFileName: Swift.String) -> Swift.String
  public func createSubAssetPath(with assetName: Swift.String) -> Swift.String
  @available(*, deprecated, message: "use the static version instead")
  public func createFullSchemePath(group: Swift.String, name: Swift.String) -> Swift.String
  public static func createFullSchemePath(group: Swift.String, name: Swift.String) -> Swift.String
}
extension SIMD3 where Scalar == Swift.Float {
  @inlinable internal static var one: Swift.SIMD3<Swift.Float> {
    get { return SIMD3<Float>(1, 1, 1) }
  }
  @inlinable internal static var positiveInfinity: Swift.SIMD3<Swift.Float> {
    get { return SIMD3<Float>(+.infinity, +.infinity, +.infinity) }
  }
  @inlinable internal static var negativeInfinity: Swift.SIMD3<Swift.Float> {
    get { return SIMD3<Float>(-.infinity, -.infinity, -.infinity) }
  }
}
extension simd_float4x4 {
  @inlinable internal var identity: simd.float4x4 {
    get {
        return matrix_identity_float4x4
    }
  }
}
extension simd_quatf {
  @usableFromInline
  internal static let identity: simd.simd_quatf
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class __RKEmphasisFlipAnimation : RealityKit.__RKEmphasisBaseAnimation {
  @objc deinit
}
public func __RERetain(_ ptr: Swift.OpaquePointer?)
public func __RERelease(_ ptr: Swift.OpaquePointer?)
@available(macOS 10.15.4, iOS 13.4, macCatalyst 14.0, *)
public protocol __ARReferenceProviding {
  func fetchReferenceObject(group: Swift.String, name: Swift.String) -> ARKit.ARReferenceObject?
  func fetchReferenceImage(group: Swift.String, name: Swift.String, physicalWidth: CoreGraphics.CGFloat) -> ARKit.ARReferenceImage?
}
public protocol __RKSpecificationHasTarget {
  var target: Foundation.UUID { get set }
}
public enum __RKEntityTriggerSpecification : Swift.Codable, Swift.Equatable {
  case drag
  case light
  case lookAt
  case placement
  case proximity(target: Foundation.UUID, distance: Swift.Float, type: RealityKit.__RKEntityProximityTrigger.ExitType)
  case removal
  case sound
  case start
  case tapTarget(target: Foundation.UUID)
  case timer
  case collision(target: Foundation.UUID, collidingEntities: [Foundation.UUID], tags: [Swift.String])
  case custom(tag: Swift.String)
  case customWithArguments(identifier: Swift.String, customArguments: [Swift.String : Swift.String]?)
  case group(triggers: [RealityKit.__RKEntityTriggerSpecification])
  public enum Name : Swift.String {
    case drag
    case light
    case lookAt
    case placement
    case proximity
    case removal
    case sound
    case start
    case tapTarget
    case timer
    case collision
    case custom
    case customWithArguments
    case group
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  public var name: RealityKit.__RKEntityTriggerSpecification.Name {
    get
  }
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
  public static func == (a: RealityKit.__RKEntityTriggerSpecification, b: RealityKit.__RKEntityTriggerSpecification) -> Swift.Bool
}
public enum __RKEntityActionSpecification : Swift.Codable, Swift.Equatable {
  case audio(RealityKit.__RKEntityAudioActionArguments)
  case changeScene(RealityKit.__RKChangeSceneActionArguments)
  case custom(RealityKit.__RKEntityCustomActionArguments)
  case emphasis(RealityKit.__RKEntityEmphasisActionArguments)
  case fadeEntity(RealityKit.__RKEntityFadeActionArguments)
  case fadeScene(RealityKit.__RKFadeSceneActionArguments)
  case group(RealityKit.__RKEntityActionGroupArguments)
  case hide(RealityKit.__RKEntityHideActionArguments)
  case force(RealityKit.__RKEntityForceActionArguments)
  case show(RealityKit.__RKEntityShowActionArguments)
  case startAnimate(RealityKit.__RKEntityStartAnimateActionArguments)
  case stopAnimate(RealityKit.__RKEntityStopAnimateActionArguments)
  case toggleAnimate(RealityKit.__RKEntityToggleAnimateActionArguments)
  case toggleVisibility(RealityKit.__RKEntityToggleVisibilityActionArguments)
  case transform(RealityKit.__RKEntityTransformActionArguments)
  case wait(RealityKit.__RKWaitActionArguments)
  case orbitEntity(RealityKit.__RKEntityOrbitEntityActionArguments)
  case lookAtCamera(RealityKit.__RKEntityLookAtCameraActionArguments)
  case swapEntity(RealityKit.__RKEntitySwapEntityActionArguments)
  case spin(RealityKit.__RKEntitySpinActionArguments)
  case setOpacity(RealityKit.__RKEntitySetOpacityActionArguments)
  public enum Name : Swift.String {
    case audio
    case changeScene
    case custom
    case emphasis
    case fadeEntity
    case fadeScene
    case force
    case group
    case hide
    case lookAtCamera
    case orbitEntity
    case setOpacity
    case show
    case spin
    case startAnimate
    case stopAnimate
    case swapEntity
    case toggleAnimate
    case toggleVisibility
    case transform
    case wait
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  public var name: RealityKit.__RKEntityActionSpecification.Name {
    get
  }
  public var target: Foundation.UUID? {
    get
  }
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
  public static func == (a: RealityKit.__RKEntityActionSpecification, b: RealityKit.__RKEntityActionSpecification) -> Swift.Bool
}
public enum __RKEntityGroupActionOrder : Swift.String, Swift.Codable, Swift.Equatable {
  case concurrent
  case sequenced
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public struct __RKEntityActionGroupArguments : Swift.Codable, Swift.Equatable {
  public var order: RealityKit.__RKEntityGroupActionOrder
  public var actions: [RealityKit.__RKEntityActionSpecification]
  public var exclusive: Swift.Bool?
  public var loopCount: Swift.Int?
  public var exclusiveBlocks: Swift.Bool?
  public init(order: RealityKit.__RKEntityGroupActionOrder, actions: [RealityKit.__RKEntityActionSpecification], exclusive: Swift.Bool = false, loopCount: Swift.Int = 1)
  @available(macOS 11.0, iOS 14.0, *)
  public init(order: RealityKit.__RKEntityGroupActionOrder, actions: [RealityKit.__RKEntityActionSpecification], exclusive: Swift.Bool = false, loopCount: Swift.Int = 1, exclusiveBlocks: Swift.Bool = false)
  public static func == (a: RealityKit.__RKEntityActionGroupArguments, b: RealityKit.__RKEntityActionGroupArguments) -> Swift.Bool
  public func encode(to encoder: Swift.Encoder) throws
  public init(from decoder: Swift.Decoder) throws
}
public struct __RKWaitActionArguments : Swift.Codable, Swift.Equatable {
  public var duration: Swift.Float
  public init(duration: Swift.Float)
  public static func == (a: RealityKit.__RKWaitActionArguments, b: RealityKit.__RKWaitActionArguments) -> Swift.Bool
  public func encode(to encoder: Swift.Encoder) throws
  public init(from decoder: Swift.Decoder) throws
}
public struct __RKEntityCustomActionArguments : Swift.Codable, Swift.Equatable, RealityKit.__RKSpecificationHasTarget {
  public var target: Foundation.UUID
  public var actionIdentifier: Swift.String
  public var customArguments: [Swift.String : Swift.String]
  public var optionalTarget: Foundation.UUID? {
    get
    set
  }
  public init(target: Foundation.UUID?, actionIdentifier: Swift.String, customArguments: [Swift.String : Swift.String]? = [:])
  public static func == (a: RealityKit.__RKEntityCustomActionArguments, b: RealityKit.__RKEntityCustomActionArguments) -> Swift.Bool
  public func encode(to encoder: Swift.Encoder) throws
  public init(from decoder: Swift.Decoder) throws
}
public struct __RKChangeSceneActionArguments : Swift.Codable, Swift.Equatable, RealityKit.__RKSpecificationHasTarget {
  public var target: Foundation.UUID {
    get
    set
  }
  public var sceneRoot: Foundation.UUID
  public var targetSceneIdentifier: Foundation.UUID
  public init(sceneRoot: Foundation.UUID, targetSceneIdentifier: Foundation.UUID)
  public static func == (a: RealityKit.__RKChangeSceneActionArguments, b: RealityKit.__RKChangeSceneActionArguments) -> Swift.Bool
  public func encode(to encoder: Swift.Encoder) throws
  public init(from decoder: Swift.Decoder) throws
}
public struct __RKFadeSceneActionArguments : Swift.Codable, Swift.Equatable {
  public var targetOpacity: Swift.Float
  public var duration: Swift.Float?
  public init(targetOpacity: Swift.Float, duration: Swift.Float = 0.0)
  public static func == (a: RealityKit.__RKFadeSceneActionArguments, b: RealityKit.__RKFadeSceneActionArguments) -> Swift.Bool
  public func encode(to encoder: Swift.Encoder) throws
  public init(from decoder: Swift.Decoder) throws
}
public struct __RKEntityFadeActionArguments : Swift.Codable, Swift.Equatable, RealityKit.__RKSpecificationHasTarget {
  public var target: Foundation.UUID
  public var targetOpacity: Swift.Float
  public var duration: Swift.Float?
  public init(target: Foundation.UUID, targetOpacity: Swift.Float, duration: Swift.Float = 1.0)
  public static func == (a: RealityKit.__RKEntityFadeActionArguments, b: RealityKit.__RKEntityFadeActionArguments) -> Swift.Bool
  public func encode(to encoder: Swift.Encoder) throws
  public init(from decoder: Swift.Decoder) throws
}
public struct __RKEntityToggleAnimateActionArguments : Swift.Codable, Swift.Equatable, RealityKit.__RKSpecificationHasTarget {
  public var target: Foundation.UUID
  public init(target: Foundation.UUID)
  public static func == (a: RealityKit.__RKEntityToggleAnimateActionArguments, b: RealityKit.__RKEntityToggleAnimateActionArguments) -> Swift.Bool
  public func encode(to encoder: Swift.Encoder) throws
  public init(from decoder: Swift.Decoder) throws
}
public struct __RKEntityStartAnimateActionArguments : Swift.Codable, Swift.Equatable, RealityKit.__RKSpecificationHasTarget {
  public var target: Foundation.UUID
  public let loopCount: Swift.Int
  public let multiplePerformBehavior: RealityKit.__RKEntityActionMultiplePerformBehavior
  public let clipStart: Swift.Double
  public let clipDuration: Swift.Double
  public let clipReverses: Swift.Bool
  public let clipReversed: Swift.Bool
  public let animationSpeed: Swift.Float
  public let muteAudio: Swift.Bool?
  public let audioGain: Swift.Double?
  public var targetAnimation: Foundation.UUID?
  public init(target: Foundation.UUID, loopCount: Swift.Int = 1, multiplePerformBehavior: RealityKit.__RKEntityActionMultiplePerformBehavior = .ignore, clipStart: Swift.Double = 0.0, clipDuration: Swift.Double = 0.0, clipReversed: Swift.Bool = false, animationSpeed: Swift.Float = 1.0, clipReverses: Swift.Bool = false)
  @available(macOS 10.15.4, iOS 13.4, *)
  public init(target: Foundation.UUID, loopCount: Swift.Int = 1, multiplePerformBehavior: RealityKit.__RKEntityActionMultiplePerformBehavior = .ignore, clipStart: Swift.Double = 0.0, clipDuration: Swift.Double = 0.0, clipReversed: Swift.Bool = false, animationSpeed: Swift.Float = 1.0, clipReverses: Swift.Bool = false, muteAudio: Swift.Bool = false, audioGain: Swift.Double = 1.0, targetAnimation: Foundation.UUID? = nil)
  public static func == (a: RealityKit.__RKEntityStartAnimateActionArguments, b: RealityKit.__RKEntityStartAnimateActionArguments) -> Swift.Bool
  public func encode(to encoder: Swift.Encoder) throws
  public init(from decoder: Swift.Decoder) throws
}
public struct __RKEntityStopAnimateActionArguments : Swift.Codable, Swift.Equatable, RealityKit.__RKSpecificationHasTarget {
  public var target: Foundation.UUID
  public init(target: Foundation.UUID)
  public static func == (a: RealityKit.__RKEntityStopAnimateActionArguments, b: RealityKit.__RKEntityStopAnimateActionArguments) -> Swift.Bool
  public func encode(to encoder: Swift.Encoder) throws
  public init(from decoder: Swift.Decoder) throws
}
public struct __RKEntityToggleVisibilityActionArguments : Swift.Codable, Swift.Equatable, RealityKit.__RKSpecificationHasTarget {
  public var target: Foundation.UUID
  public init(target: Foundation.UUID)
  public static func == (a: RealityKit.__RKEntityToggleVisibilityActionArguments, b: RealityKit.__RKEntityToggleVisibilityActionArguments) -> Swift.Bool
  public func encode(to encoder: Swift.Encoder) throws
  public init(from decoder: Swift.Decoder) throws
}
public struct __RKEntityShowActionArguments : Swift.Codable, Swift.Equatable, RealityKit.__RKSpecificationHasTarget {
  public var target: Foundation.UUID
  public var duration: Swift.Float?
  public var distance: Swift.Float?
  public var ease: RealityKit.__RKEntityMoveEase?
  public var easeType: RealityKit.__RKEntityMoveEaseType?
  public var fadeIn: Swift.Bool?
  public var finalOpacity: Swift.Float?
  public var respectPhysics: Swift.Bool?
  public var physicsLinearCoefficient: Swift.Float?
  public var physicsAngularCoefficient: Swift.Float?
  public var animationStyle: RealityKit.__RKEntityActionAnimationStyle?
  public var buildInAnimationType: RealityKit.__RKEntityShowActionBuildInAnimationType?
  public init(target: Foundation.UUID, duration: Swift.Float = 1.0, distance: Swift.Float = 10.0, ease: RealityKit.__RKEntityMoveEase = .none, easeType: RealityKit.__RKEntityMoveEaseType = .easeIn, fadeIn: Swift.Bool = false, finalOpacity: Swift.Float = 1.0, respectPhysics: Swift.Bool = false, physicsLinearCoefficient: Swift.Float = 0.0, physicsAngularCoefficient: Swift.Float = 0.0, animationStyle: RealityKit.__RKEntityActionAnimationStyle = .basic, buildInAnimationType: RealityKit.__RKEntityShowActionBuildInAnimationType = .none)
  public static func == (a: RealityKit.__RKEntityShowActionArguments, b: RealityKit.__RKEntityShowActionArguments) -> Swift.Bool
  public func encode(to encoder: Swift.Encoder) throws
  public init(from decoder: Swift.Decoder) throws
}
public struct __RKEntityHideActionArguments : Swift.Codable, Swift.Equatable, RealityKit.__RKSpecificationHasTarget {
  public var target: Foundation.UUID
  public var duration: Swift.Float?
  public var distance: Swift.Float?
  public var ease: RealityKit.__RKEntityMoveEase?
  public var easeType: RealityKit.__RKEntityMoveEaseType?
  public var fadeOut: Swift.Bool?
  public var finalOpacity: Swift.Float?
  public var respectPhysics: Swift.Bool?
  public var physicsLinearCoefficient: Swift.Float?
  public var physicsAngularCoefficient: Swift.Float?
  public var animationStyle: RealityKit.__RKEntityActionAnimationStyle?
  public var buildOutAnimationType: RealityKit.__RKEntityHideActionBuildOutAnimationType?
  public init(target: Foundation.UUID, duration: Swift.Float = 1.0, distance: Swift.Float = 10.0, ease: RealityKit.__RKEntityMoveEase = .none, easeType: RealityKit.__RKEntityMoveEaseType = .easeIn, fadeOut: Swift.Bool = false, finalOpacity: Swift.Float = 1.0, respectPhysics: Swift.Bool = false, physicsLinearCoefficient: Swift.Float = 0.0, physicsAngularCoefficient: Swift.Float = 0.0, animationStyle: RealityKit.__RKEntityActionAnimationStyle = .basic, buildOutAnimationType: RealityKit.__RKEntityHideActionBuildOutAnimationType = .none)
  public static func == (a: RealityKit.__RKEntityHideActionArguments, b: RealityKit.__RKEntityHideActionArguments) -> Swift.Bool
  public func encode(to encoder: Swift.Encoder) throws
  public init(from decoder: Swift.Decoder) throws
}
public struct __RKEntityEmphasisActionArguments : Swift.Codable, Swift.Equatable, RealityKit.__RKSpecificationHasTarget {
  public var target: Foundation.UUID
  public var duration: Swift.Float?
  public var iterations: Swift.Float?
  public var animationStyle: RealityKit.__RKEntityActionAnimationStyle?
  public var emphasisAnimationType: RealityKit.__RKEntityEmphasisAnimationType?
  public init(target: Foundation.UUID, duration: Swift.Float = 1.0, iterations: Swift.Float = 1.0, animationStyle: RealityKit.__RKEntityActionAnimationStyle = .basic, emphasisAnimationType: RealityKit.__RKEntityEmphasisAnimationType = .pop)
  public static func == (a: RealityKit.__RKEntityEmphasisActionArguments, b: RealityKit.__RKEntityEmphasisActionArguments) -> Swift.Bool
  public func encode(to encoder: Swift.Encoder) throws
  public init(from decoder: Swift.Decoder) throws
}
public struct __RKEntityAudioActionArguments : Swift.Codable, Swift.Equatable, RealityKit.__RKSpecificationHasTarget {
  public var target: Foundation.UUID
  public var path: Swift.String
  public var type: RealityKit.__RKEntityAudioActionType?
  public var volume: Swift.Double?
  public var loops: Swift.Bool?
  public var spatialMode: RealityKit.__RKAudioSpatialModeSelection?
  public let multiplePerformBehavior: RealityKit.__RKEntityActionMultiplePerformBehavior?
  public init(target: Foundation.UUID, path: Swift.String, type: RealityKit.__RKEntityAudioActionType, spatialMode: RealityKit.__RKAudioSpatialModeSelection, volume: Swift.Double = 0.5, loops: Swift.Bool = false, multiplePerformBehavior: RealityKit.__RKEntityActionMultiplePerformBehavior = .ignore)
  public static func == (a: RealityKit.__RKEntityAudioActionArguments, b: RealityKit.__RKEntityAudioActionArguments) -> Swift.Bool
  public func encode(to encoder: Swift.Encoder) throws
  public init(from decoder: Swift.Decoder) throws
}
public struct __RKEntityTransformActionArguments : Swift.Codable, Swift.Equatable, RealityKit.__RKSpecificationHasTarget {
  public var target: Foundation.UUID
  public var location: Swift.SIMD3<Swift.Float>?
  public var orientation: simd.simd_quatf? {
    get
    set
  }
  public var scale: Swift.Float?
  public var duration: Swift.Float?
  public var moveType: RealityKit.__RKEntityMoveSelection?
  public var ease: RealityKit.__RKEntityMoveEase?
  public var easeType: RealityKit.__RKEntityMoveEaseType?
  public var respectPhysics: Swift.Bool?
  public var physicsLinearCoefficient: Swift.Float?
  public var physicsAngularCoefficient: Swift.Float?
  public init(target: Foundation.UUID, location: Swift.SIMD3<Swift.Float>?, orientation: simd.simd_quatf?, scale: Swift.Float?, duration: Swift.Float = 1.0, moveType: RealityKit.__RKEntityMoveSelection = .local, ease: RealityKit.__RKEntityMoveEase = .none, easeType: RealityKit.__RKEntityMoveEaseType = .easeIn, respectPhysics: Swift.Bool = false, physicsLinearCoefficient: Swift.Float = 0.0, physicsAngularCoefficient: Swift.Float = 0.0)
  public static func == (a: RealityKit.__RKEntityTransformActionArguments, b: RealityKit.__RKEntityTransformActionArguments) -> Swift.Bool
  public func encode(to encoder: Swift.Encoder) throws
  public init(from decoder: Swift.Decoder) throws
}
public struct __RKEntityForceActionArguments : Swift.Codable, Swift.Equatable, RealityKit.__RKSpecificationHasTarget {
  public var target: Foundation.UUID
  public var force: Swift.SIMD3<Swift.Float>?
  public var velocity: Swift.SIMD3<Swift.Float>?
  public init(target: Foundation.UUID, force: Swift.SIMD3<Swift.Float>? = nil, velocity: Swift.SIMD3<Swift.Float>? = nil)
  public static func == (a: RealityKit.__RKEntityForceActionArguments, b: RealityKit.__RKEntityForceActionArguments) -> Swift.Bool
  public func encode(to encoder: Swift.Encoder) throws
  public init(from decoder: Swift.Decoder) throws
}
public struct __RKEntitySwapEntityActionArguments : Swift.Codable, Swift.Equatable, RealityKit.__RKSpecificationHasTarget {
  public var target: Foundation.UUID
  public var newTarget: Foundation.UUID
  public var buildOutAction: RealityKit.__RKEntityHideActionArguments
  public var buildInAction: RealityKit.__RKEntityShowActionArguments
  public init(target: Foundation.UUID, newTarget: Foundation.UUID, buildOutAction: RealityKit.__RKEntityHideActionArguments, buildInAction: RealityKit.__RKEntityShowActionArguments)
  public static func == (a: RealityKit.__RKEntitySwapEntityActionArguments, b: RealityKit.__RKEntitySwapEntityActionArguments) -> Swift.Bool
  public func encode(to encoder: Swift.Encoder) throws
  public init(from decoder: Swift.Decoder) throws
}
public struct __RKEntitySpinActionArguments : Swift.Codable, Swift.Equatable, RealityKit.__RKSpecificationHasTarget {
  public var target: Foundation.UUID
  public var duration: Swift.Float?
  public var iterations: Swift.Float?
  public var direction: RealityKit.__RKEntitySpinDirectionType?
  public var axis: Swift.SIMD3<Swift.Float>?
  public init(target: Foundation.UUID, duration: Swift.Float = 1.0, iterations: Swift.Float = 1, direction: RealityKit.__RKEntitySpinDirectionType = .clockwise, axis: Swift.SIMD3<Swift.Float> = SIMD3<Float>(0,1,0))
  public static func == (a: RealityKit.__RKEntitySpinActionArguments, b: RealityKit.__RKEntitySpinActionArguments) -> Swift.Bool
  public func encode(to encoder: Swift.Encoder) throws
  public init(from decoder: Swift.Decoder) throws
}
public struct __RKEntityOrbitEntityActionArguments : Swift.Codable, Swift.Equatable, RealityKit.__RKSpecificationHasTarget {
  public var target: Foundation.UUID
  public var pivotTarget: Foundation.UUID
  public var duration: Swift.Float?
  public var rotations: Swift.Float?
  public var orbitalAxis: Swift.SIMD3<Swift.Float>?
  public var orientToPath: Swift.Bool?
  public var spinDirection: RealityKit.__RKEntitySpinDirectionType?
  public var respectPhysics: Swift.Bool?
  public var physicsLinearCoefficient: Swift.Float?
  public var physicsAngularCoefficient: Swift.Float?
  public init(target: Foundation.UUID, pivotTarget: Foundation.UUID, duration: Swift.Float = 1.0, rotations: Swift.Float = 1.0, orbitalAxis: Swift.SIMD3<Swift.Float> = SIMD3<Float>(0, 1, 0), orientToPath: Swift.Bool = false, spinDirection: RealityKit.__RKEntitySpinDirectionType = .clockwise, respectPhysics: Swift.Bool = false, physicsLinearCoefficient: Swift.Float = 0.0, physicsAngularCoefficient: Swift.Float = 0.0)
  public static func == (a: RealityKit.__RKEntityOrbitEntityActionArguments, b: RealityKit.__RKEntityOrbitEntityActionArguments) -> Swift.Bool
  public func encode(to encoder: Swift.Encoder) throws
  public init(from decoder: Swift.Decoder) throws
}
public struct __RKEntityLookAtCameraActionArguments : Swift.Codable, Swift.Equatable, RealityKit.__RKSpecificationHasTarget {
  public var target: Foundation.UUID
  public var duration: Swift.Float?
  public var animationDuration: Swift.Float?
  public var direction: Swift.SIMD3<Swift.Float>?
  public var rotation: Swift.Float?
  public var upVector: Swift.SIMD3<Swift.Float>?
  public var loops: Swift.Bool?
  public init(target: Foundation.UUID, duration: Swift.Float = 1.0, animationDuration: Swift.Float = 0.0, direction: Swift.SIMD3<Swift.Float> = SIMD3<Float>(0, 1, 0), rotation: Swift.Float = 0.0, upVector: Swift.SIMD3<Swift.Float> = SIMD3<Float>(0, 1, 0), loops: Swift.Bool = false)
  public static func == (a: RealityKit.__RKEntityLookAtCameraActionArguments, b: RealityKit.__RKEntityLookAtCameraActionArguments) -> Swift.Bool
  public func encode(to encoder: Swift.Encoder) throws
  public init(from decoder: Swift.Decoder) throws
}
public struct __RKEntitySetOpacityActionArguments : Swift.Codable, Swift.Equatable, RealityKit.__RKSpecificationHasTarget {
  public var target: Foundation.UUID
  public var duration: Swift.Float
  public var opacity: Swift.Float
  public init(target: Foundation.UUID, duration: Swift.Float = 1.0, opacity: Swift.Float = 1.0)
  public static func == (a: RealityKit.__RKEntitySetOpacityActionArguments, b: RealityKit.__RKEntitySetOpacityActionArguments) -> Swift.Bool
  public func encode(to encoder: Swift.Encoder) throws
  public init(from decoder: Swift.Decoder) throws
}
public struct __RKEntityInteractionSpecification : Swift.Codable, Swift.Equatable, Swift.CustomStringConvertible {
  public var trigger: RealityKit.__RKEntityTriggerSpecification
  public var action: RealityKit.__RKEntityActionSpecification
  public var accessibilityDescription: Swift.String?
  public init(trigger: RealityKit.__RKEntityTriggerSpecification, action: RealityKit.__RKEntityActionSpecification)
  public init(_ trigger: RealityKit.__RKEntityTriggerSpecification, _ action: RealityKit.__RKEntityActionSpecification)
  public init(trigger: RealityKit.__RKEntityTriggerSpecification, action: RealityKit.__RKEntityActionSpecification, accessibilityDescription: Swift.String? = nil)
  public init(_ trigger: RealityKit.__RKEntityTriggerSpecification, _ action: RealityKit.__RKEntityActionSpecification, _ accessibilityDescription: Swift.String? = nil)
  public var description: Swift.String {
    get
  }
  public static func == (a: RealityKit.__RKEntityInteractionSpecification, b: RealityKit.__RKEntityInteractionSpecification) -> Swift.Bool
  public func encode(to encoder: Swift.Encoder) throws
  public init(from decoder: Swift.Decoder) throws
}
@available(macOS 10.15, iOS 13.0, *)
public protocol HasModel : RealityKit.HasTransform {
}
extension HasModel {
  public var model: RealityKit.ModelComponent? {
    get
    set
  }
  @available(macOS 11.0, iOS 14.0, *)
  public var modelDebugOptions: RealityKit.ModelDebugOptionsComponent? {
    get
    set
  }
  @available(*, unavailable, renamed: "modelDebugOptions")
  public var debugModel: RealityKit.ModelDebugOptionsComponent? {
    get
    set
  }
}
@available(macOS 10.15, iOS 13.0, macCatalyst 14.0, *)
public protocol EntityGestureRecognizer : UIKit.UIGestureRecognizer {
  var entity: RealityKit.HasCollision? { get set }
  func location(in entity: RealityKit.Entity?) -> Swift.SIMD3<Swift.Float>?
}
extension EntityGestureRecognizer {
  public func location(in entity: RealityKit.Entity?) -> Swift.SIMD3<Swift.Float>?
}
@available(iOS 13.4, macCatalyst 14.0, *)
public struct SceneUnderstandingComponent : RealityKit.Component {
}
@available(iOS 13.4, macCatalyst 14.0, *)
extension SceneUnderstandingComponent {
  public static func __fromCore(_ coreComponent: RealityKit.__ComponentRef) -> RealityKit.SceneUnderstandingComponent
  public func __toCore(_ coreComponent: RealityKit.__ComponentRef)
  public static var __coreComponentType: RealityKit.__ComponentTypeRef {
    get
  }
}
public enum __RKEntityFlipDirectionType : Swift.String, Swift.Codable, Swift.CaseIterable {
  case forward
  case backward
  public init?(rawValue: Swift.String)
  public typealias AllCases = [RealityKit.__RKEntityFlipDirectionType]
  public typealias RawValue = Swift.String
  public static var allCases: [RealityKit.__RKEntityFlipDirectionType] {
    get
  }
  public var rawValue: Swift.String {
    get
  }
}
public enum __RKEntityEmphasisAnimationType : Swift.String, Swift.Codable, Swift.CaseIterable {
  case pop
  case blink
  case bounce
  case flip
  case float
  case jiggle
  case pulse
  case spin
  public init?(rawValue: Swift.String)
  public typealias AllCases = [RealityKit.__RKEntityEmphasisAnimationType]
  public typealias RawValue = Swift.String
  public static var allCases: [RealityKit.__RKEntityEmphasisAnimationType] {
    get
  }
  public var rawValue: Swift.String {
    get
  }
}
public class __RKEntityEmphasisAction : RealityKit.__RKEntityAction {
  public init(targetEntity: RealityKit.Entity?, duration: Swift.Float, iterations: Swift.Float = 1.0, animationStyle: RealityKit.__RKEntityActionAnimationStyle = .basic, emphasisAnimationType: RealityKit.__RKEntityEmphasisAnimationType = .pop)
  override public func perform(with context: RealityKit.__RKEntityActionContext) -> Swift.Bool
  override public func reversed() -> RealityKit.__RKEntityAction?
  @objc override public func copy(with zone: ObjectiveC.NSZone? = nil) -> Any
  override public init(targetEntity: RealityKit.Entity? = super)
  @objc deinit
}
public struct __RKSceneUUIDComponent {
  @_hasMissingDesignatedInitializers public class Registration {
    final public let componentType: Swift.OpaquePointer
    @objc deinit
  }
  public static var registration: RealityKit.__RKSceneUUIDComponent.Registration?
}
extension Scene {
  public var __sceneIdentifier: Foundation.UUID? {
    get
    set
  }
}
@available(macOS 10.15, iOS 13.0, *)
public protocol SynchronizationPeerID {
}
extension MCPeerID : RealityKit.SynchronizationPeerID {
}
@available(macOS 10.15, iOS 13.0, *)
public protocol SynchronizationService : AnyObject {
  typealias Identifier = Swift.UInt64
  func entity(for identifier: Self.Identifier) -> RealityKit.Entity?
  func owner(of entity: RealityKit.Entity) -> RealityKit.SynchronizationPeerID?
  @discardableResult
  func giveOwnership(of entity: RealityKit.Entity, toPeer: RealityKit.SynchronizationPeerID) -> Swift.Bool
  func __fromCore(peerID: RealityKit.__PeerIDRef) -> RealityKit.SynchronizationPeerID?
  func __toCore(peerID: RealityKit.SynchronizationPeerID) -> RealityKit.__PeerIDRef
}
@available(macOS 10.15, iOS 13.0, *)
public class MultipeerConnectivityService : RealityKit.SynchronizationService {
  final public let session: MultipeerConnectivity.MCSession
  public init(session: MultipeerConnectivity.MCSession) throws
  public func entity(for identifier: RealityKit.MultipeerConnectivityService.Identifier) -> RealityKit.Entity?
  public func owner(of entity: RealityKit.Entity) -> RealityKit.SynchronizationPeerID?
  public func giveOwnership(of entity: RealityKit.Entity, toPeer peer: RealityKit.SynchronizationPeerID) -> Swift.Bool
  public func __fromCore(peerID: RealityKit.__PeerIDRef) -> RealityKit.SynchronizationPeerID?
  public func __toCore(peerID: RealityKit.SynchronizationPeerID) -> RealityKit.__PeerIDRef
  @objc deinit
}
@_hasMissingDesignatedInitializers @available(macOS 10.15.4, iOS 13.4, *)
final public class NetworkCompatibilityToken : Swift.Codable {
  public enum Compatibility {
    case compatible
    case sessionProtocolVersionMismatch
    public static func == (a: RealityKit.NetworkCompatibilityToken.Compatibility, b: RealityKit.NetworkCompatibilityToken.Compatibility) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public static let local: RealityKit.NetworkCompatibilityToken
  @objc deinit
  required public init(from decoder: Swift.Decoder) throws
  final public func encode(to encoder: Swift.Encoder) throws
  final public func compatibilityWith(_ otherToken: RealityKit.NetworkCompatibilityToken) -> RealityKit.NetworkCompatibilityToken.Compatibility
}
@objc @_inheritsConvenienceInitializers @available(macOS 10.15, iOS 13.0, macCatalyst 14.0, *)
open class EntityRotationGestureRecognizer : UIKit.UIRotationGestureRecognizer, RealityKit.EntityGestureRecognizer {
  public var entity: RealityKit.HasCollision? {
    get
    set
  }
  @objc override dynamic open func touchesBegan(_ touches: Swift.Set<UIKit.UITouch>, with event: UIKit.UIEvent)
  @objc override dynamic open func canPrevent(_ preventedGestureRecognizer: UIKit.UIGestureRecognizer) -> Swift.Bool
  @objc override dynamic public init(target: Any?, action: ObjectiveC.Selector?)
  @objc deinit
}
@_hasMissingDesignatedInitializers @available(macOS 10.15, iOS 13.0, *)
public class TextureResource : RealityKit.Resource {
  public var __coreAsset: RealityKit.__AssetRef {
    get
  }
  @objc deinit
  public static func load(named name: Swift.String, in bundle: Foundation.Bundle? = nil) throws -> RealityKit.TextureResource
  public static func loadAsync(named name: Swift.String, in bundle: Foundation.Bundle? = nil) -> RealityKit.LoadRequest<RealityKit.TextureResource>
  public static func load(contentsOf url: Foundation.URL, withName resourceName: Swift.String? = nil) throws -> RealityKit.TextureResource
  public static func loadAsync(contentsOf url: Foundation.URL, withName resourceName: Swift.String? = nil) -> RealityKit.LoadRequest<RealityKit.TextureResource>
  public static func __texture(from mtlTexture: Metal.MTLTexture) -> RealityKit.TextureResource
  public static func __texture(from cgImage: CoreGraphics.CGImage, label: Swift.String? = nil) -> RealityKit.TextureResource
}
public class __RKEntityActionGroup : RealityKit.__RKEntityAction {
  public enum Ordering {
    case concurrent
    case sequenced
    public static func == (a: RealityKit.__RKEntityActionGroup.Ordering, b: RealityKit.__RKEntityActionGroup.Ordering) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public static let infiniteLoopCount: Swift.Int
  public static let noLoopCount: Swift.Int
  public var actions: [RealityKit.__RKEntityAction] {
    get
  }
  public var ordering: RealityKit.__RKEntityActionGroup.Ordering {
    get
  }
  public var loopCount: Swift.Int {
    get
  }
  public init(actions: [RealityKit.__RKEntityAction], ordering: RealityKit.__RKEntityActionGroup.Ordering, loopCount: Swift.Int? = __RKEntityActionGroup.noLoopCount)
  override public func preloadAssets()
  override public func perform(with context: RealityKit.__RKEntityActionContext) -> Swift.Bool
  public func allActions() -> [RealityKit.__RKEntityAction]
  override public func isExclusiveWith(action: RealityKit.__RKEntityAction) -> Swift.Bool
  override public func reversed() -> RealityKit.__RKEntityAction?
  override public func stop() -> Swift.Bool
  override public var description: Swift.String {
    get
  }
  @objc override public func copy(with zone: ObjectiveC.NSZone? = nil) -> Any
  override public init(targetEntity: RealityKit.Entity? = super)
  @objc deinit
}
@available(macOS 10.15, iOS 13.0, *)
public struct PhysicsBodyComponent : RealityKit.Component, Swift.Equatable {
  public var mode: RealityKit.PhysicsBodyMode
  public var massProperties: RealityKit.PhysicsMassProperties
  public var material: RealityKit.PhysicsMaterialResource
  public var isTranslationLocked: (x: Swift.Bool, y: Swift.Bool, z: Swift.Bool)
  public var isRotationLocked: (x: Swift.Bool, y: Swift.Bool, z: Swift.Bool)
  public var isContinuousCollisionDetectionEnabled: Swift.Bool
  public init()
  public init(massProperties: RealityKit.PhysicsMassProperties = .default, material: RealityKit.PhysicsMaterialResource? = nil, mode: RealityKit.PhysicsBodyMode = .dynamic)
  public init(shapes: [RealityKit.ShapeResource], density: Swift.Float, material: RealityKit.PhysicsMaterialResource? = nil, mode: RealityKit.PhysicsBodyMode = .dynamic)
  public init(shapes: [RealityKit.ShapeResource], mass: Swift.Float, material: RealityKit.PhysicsMaterialResource? = nil, mode: RealityKit.PhysicsBodyMode = .dynamic)
  public static func __fromCore(_ coreComponent: RealityKit.__ComponentRef) -> RealityKit.PhysicsBodyComponent
  public func __toCore(_ coreComponent: RealityKit.__ComponentRef)
  public static var __coreComponentType: RealityKit.__ComponentTypeRef {
    get
  }
  public static func == (lhs: RealityKit.PhysicsBodyComponent, rhs: RealityKit.PhysicsBodyComponent) -> Swift.Bool
}
public protocol __RKRuntimeSceneCoordinatorObserver : AnyObject {
  func runtimeSceneCoordinator(_ coordinator: RealityKit.__RKRuntimeSceneCoordinator, willSwapFromEntity fromEntity: RealityKit.Entity, toEntity: RealityKit.Entity?, anchoringTarget: RealityKit.AnchoringComponent.Target?)
  func runtimeSceneCoordinator(_ coordinator: RealityKit.__RKRuntimeSceneCoordinator, didSwapFromEntity fromEntity: RealityKit.Entity, toEntity: RealityKit.Entity?, anchoringTarget: RealityKit.AnchoringComponent.Target?)
}
public class __RKRuntimeSceneCoordinator {
  public init()
  public func willSwap(fromEntity: RealityKit.Entity, toEntity: RealityKit.Entity?, anchoringTarget: RealityKit.AnchoringComponent.Target?)
  public func didSwap(fromEntity: RealityKit.Entity, toEntity: RealityKit.Entity?, anchoringTarget: RealityKit.AnchoringComponent.Target?)
  public func addObserver(observer: RealityKit.__RKRuntimeSceneCoordinatorObserver)
  public func removeObserver(observer: RealityKit.__RKRuntimeSceneCoordinatorObserver)
  @objc deinit
}
public struct __REAnchoring {
  public var type: RealityKit.__REAnchoringType? {
    get
    set
  }
  @_hasMissingDesignatedInitializers public class Registration {
    final public let componentType: Swift.OpaquePointer
    @objc deinit
  }
  public static var registration: RealityKit.__REAnchoring.Registration?
}
extension Scene {
  public var __anchoringType: RealityKit.__REAnchoringType? {
    get
    set
  }
}
extension Entity {
  public var __anchoringType: RealityKit.__REAnchoringType? {
    get
    set
  }
}
@_inheritsConvenienceInitializers public class __RKEntityDragTrigger : RealityKit.__RKEntityTrigger {
  override public init()
  @objc deinit
}
extension __REAnchoringType {
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class __RKVisibilityShowScaleAnimation : RealityKit.__RKVisibilityBaseAnimation {
  @objc deinit
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class __RKVisibilityShowScaleDownAnimation : RealityKit.__RKVisibilityBaseAnimation {
  @objc deinit
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class __RKEmphasisSpinAnimation : RealityKit.__RKEmphasisBaseAnimation {
  @objc deinit
}
public struct __RKEntityTagsComponent {
  public var tags: [Swift.String] {
    mutating get
    set(newTags)
  }
  @_hasMissingDesignatedInitializers public class Registration {
    @objc deinit
  }
  public static var registration: RealityKit.__RKEntityTagsComponent.Registration?
}
extension Entity {
  public var __tags: [Swift.String] {
    get
    set
  }
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class __RKVisibilityShowDropAnimation : RealityKit.__RKVisibilityBaseAnimation {
  @objc deinit
}
extension Entity {
  @discardableResult
  public func playAudio(_ resource: RealityKit.AudioResource) -> RealityKit.AudioPlaybackController
  public func prepareAudio(_ resource: RealityKit.AudioResource) -> RealityKit.AudioPlaybackController
  public func stopAllAudio()
}
@_hasMissingDesignatedInitializers @available(macOS 10.15, iOS 13.0, *)
public class AudioPlaybackController {
  public typealias Decibel = Swift.Double
  weak public var entity: RealityKit.Entity? {
    get
  }
  final public let resource: RealityKit.AudioResource
  @objc deinit
  public var completionHandler: (() -> Swift.Void)?
}
extension AudioPlaybackController {
  public var speed: Swift.Double {
    get
    set
  }
  public var gain: RealityKit.AudioPlaybackController.Decibel {
    get
    set
  }
  public func fade(to gain: RealityKit.AudioPlaybackController.Decibel, duration: Foundation.TimeInterval)
  public var reverbSendLevel: RealityKit.AudioPlaybackController.Decibel {
    get
    set
  }
}
extension AudioPlaybackController {
  public var isPlaying: Swift.Bool {
    get
  }
  public func play()
  public func pause()
  public func stop()
}
extension AudioPlaybackController {
  public var __playbackPosition: Foundation.TimeInterval {
    get
    set
  }
}
extension AudioPlaybackController : Swift.Identifiable {
  public var id: Swift.UInt64 {
    get
  }
  public typealias ID = Swift.UInt64
}
public struct __REAssetIdentifier : Swift.ExpressibleByStringLiteral, Swift.Codable {
  public typealias StringLiteralType = Swift.String
  public init(stringLiteral value: Swift.String)
  public init(_ value: Swift.String)
  public typealias ExtendedGraphemeClusterLiteralType = RealityKit.__REAssetIdentifier.StringLiteralType
  public typealias UnicodeScalarLiteralType = RealityKit.__REAssetIdentifier.StringLiteralType
  public func encode(to encoder: Swift.Encoder) throws
  public init(from decoder: Swift.Decoder) throws
}
@_hasMissingDesignatedInitializers public class __REAsset : Swift.CustomDebugStringConvertible {
  public static func __fromHandle(_ assetRef: RealityKit.__AssetRef) -> RealityKit.__REAsset
  public static func __fromHandleTransfer(_ assetRef: RealityKit.__AssetRef) -> RealityKit.__REAsset
  @objc deinit
  public var debugDescription: Swift.String {
    get
  }
  public var __hasSubsceneComponents: Swift.Bool {
    get
  }
  public var __handle: RealityKit.__AssetRef {
    get
  }
}
extension __REAsset : Swift.Hashable {
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (lhs: RealityKit.__REAsset, rhs: RealityKit.__REAsset) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public protocol __REAssetService {
  var mainBundle: RealityKit.__REAssetBundle { get }
  func loadBundle(at url: Foundation.URL) throws -> RealityKit.__REAssetBundle
  func makeBundle() -> RealityKit.__REAssetBundle
  var __handle: Swift.OpaquePointer { get }
  func __getDependencies(asset: RealityKit.__REAsset) -> [RealityKit.__REAsset]
}
public class __REAssetManager : RealityKit.__REAssetService {
  public init(handle: Swift.OpaquePointer)
  public var engineQueue: Dispatch.DispatchQueue {
    get
  }
  public var mainBundle: RealityKit.__REAssetBundle {
    get
  }
  public func loadBundle(at url: Foundation.URL) throws -> RealityKit.__REAssetBundle
  public func makeBundle() -> RealityKit.__REAssetBundle
  public func __getDependencies(asset: RealityKit.__REAsset) -> [RealityKit.__REAsset]
  public var __handle: Swift.OpaquePointer {
    get
  }
  @objc deinit
}
@available(*, deprecated)
extension __REAssetService {
  public func resource<T>(ofType type: T.Type, at path: RealityKit.__REAssetIdentifier) -> T?
}
@available(*, deprecated)
extension __REAssetBundle {
  public func resource<T>(ofType type: T.Type, at path: RealityKit.__REAssetIdentifier) -> T? where T : RealityKit.Resource
  public func __renderGraphEmitter(at path: RealityKit.__REAssetIdentifier) -> RealityKit.__RERenderGraphEmitter?
}
@_hasMissingDesignatedInitializers final public class __AssetLoadRequest {
  @objc deinit
  convenience public init(serviceLocator: RealityKit.__ServiceLocator)
  convenience public init(assetService: RealityKit.__REAssetService)
  final public func add(asset: RealityKit.__AssetRef)
  final public var progress: Swift.Float {
    get
  }
  public typealias CompletionHandler = @convention(block) (Swift.Bool) -> Swift.Void
  final public func setCompletionHandler(_ handler: @escaping RealityKit.__AssetLoadRequest.CompletionHandler)
}
@available(macOS 10.15, iOS 13.0, *)
public protocol HasSynchronization : RealityKit.Entity {
}
extension HasSynchronization {
  public var synchronization: RealityKit.SynchronizationComponent? {
    get
    set
  }
  public var isOwner: Swift.Bool {
    get
  }
  public func requestOwnership(timeout: Foundation.TimeInterval = 15, _ callback: @escaping (RealityKit.SynchronizationComponent.OwnershipTransferCompletionResult) -> Swift.Void)
  public func withUnsynchronized(_ changes: () -> Swift.Void)
}
@available(macOS 10.15, iOS 13.0, *)
public struct SynchronizationComponent : RealityKit.Component, Swift.Equatable {
  public enum OwnershipTransferMode {
    case autoAccept
    case manual
    public static func == (a: RealityKit.SynchronizationComponent.OwnershipTransferMode, b: RealityKit.SynchronizationComponent.OwnershipTransferMode) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public enum OwnershipTransferCompletionResult {
    case granted
    case timedOut
    public static func == (a: RealityKit.SynchronizationComponent.OwnershipTransferCompletionResult, b: RealityKit.SynchronizationComponent.OwnershipTransferCompletionResult) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public var identifier: Swift.UInt64 {
    get
  }
  public var isOwner: Swift.Bool {
    get
  }
  public var ownershipTransferMode: RealityKit.SynchronizationComponent.OwnershipTransferMode
  public init()
  public static func __fromCore(_ coreComponent: RealityKit.__ComponentRef) -> RealityKit.SynchronizationComponent
  public func __toCore(_ coreComponent: RealityKit.__ComponentRef)
  public static var __coreComponentType: RealityKit.__ComponentTypeRef {
    get
  }
  public static func == (lhs: RealityKit.SynchronizationComponent, rhs: RealityKit.SynchronizationComponent) -> Swift.Bool
}
extension HasModel {
  public var jointNames: [Swift.String] {
    get
  }
  public var jointTransforms: [RealityKit.Transform] {
    get
    set
  }
}
@_hasMissingDesignatedInitializers public class __RKSceneAssetLookupTable {
  public static var shared: RealityKit.__RKSceneAssetLookupTable
  public func reSceneAsset(for uuid: Foundation.UUID) -> RealityKit.__REAsset?
  public func registerRESceneAsset(_ reSceneAsset: RealityKit.__REAsset, for uuid: Foundation.UUID)
  public func removeAllRESceneAssets()
  @objc deinit
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class __RKVisibilityShowRiseAnimation : RealityKit.__RKVisibilityBaseAnimation {
  @objc deinit
}
extension SIMD3 where Scalar == Swift.Float {
  @usableFromInline
  internal var _xy: Swift.SIMD2<Swift.Float> {
    get
    set
  }
}
extension SIMD4 where Scalar == Swift.Float {
  @usableFromInline
  internal var _xyz: Swift.SIMD3<Swift.Float> {
    get
    set
  }
}
public enum __REAnchoringType : Swift.Codable, Swift.Equatable {
  case surface(alignment: RealityKit.__REAnchoringType.Alignment, classification: RealityKit.__REAnchoringType.Classification)
  case image(url: Foundation.URL, physicalWidth: Foundation.Measurement<Foundation.UnitLength>)
  case face(meshVertex: Swift.Int)
  case object(url: Foundation.URL)
  public enum Name : Swift.String, Swift.CaseIterable {
    case surface
    case image
    case face
    case object
    public init?(rawValue: Swift.String)
    public typealias AllCases = [RealityKit.__REAnchoringType.Name]
    public typealias RawValue = Swift.String
    public static var allCases: [RealityKit.__REAnchoringType.Name] {
      get
    }
    public var rawValue: Swift.String {
      get
    }
  }
  public var name: RealityKit.__REAnchoringType.Name {
    get
  }
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
  public struct Alignment : Swift.OptionSet, Swift.Codable {
    public init(rawValue: Swift.Int)
    public let rawValue: Swift.Int
    public static let horizontal: RealityKit.__REAnchoringType.Alignment
    public static let vertical: RealityKit.__REAnchoringType.Alignment
    public static let any: RealityKit.__REAnchoringType.Alignment
    public typealias ArrayLiteralElement = RealityKit.__REAnchoringType.Alignment
    public typealias Element = RealityKit.__REAnchoringType.Alignment
    public typealias RawValue = Swift.Int
  }
  public struct Classification : Swift.OptionSet, Swift.Codable {
    public init(rawValue: Swift.Int)
    public let rawValue: Swift.Int
    public static let wall: RealityKit.__REAnchoringType.Classification
    public static let floor: RealityKit.__REAnchoringType.Classification
    public static let ceiling: RealityKit.__REAnchoringType.Classification
    public static let table: RealityKit.__REAnchoringType.Classification
    public static let seat: RealityKit.__REAnchoringType.Classification
    public static let any: RealityKit.__REAnchoringType.Classification
    public typealias ArrayLiteralElement = RealityKit.__REAnchoringType.Classification
    public typealias Element = RealityKit.__REAnchoringType.Classification
    public typealias RawValue = Swift.Int
  }
  public static func == (a: RealityKit.__REAnchoringType, b: RealityKit.__REAnchoringType) -> Swift.Bool
}
@objc @_inheritsConvenienceInitializers @available(macOS 10.15, iOS 13.0, macCatalyst 14.0, *)
open class EntityTranslationGestureRecognizer : UIKit.UIGestureRecognizer, RealityKit.EntityGestureRecognizer {
  public var entity: RealityKit.HasCollision? {
    get
    set
  }
  @objc override dynamic open func touchesBegan(_ touches: Swift.Set<UIKit.UITouch>, with event: UIKit.UIEvent)
  @objc override dynamic open func touchesEnded(_ touches: Swift.Set<UIKit.UITouch>, with event: UIKit.UIEvent)
  @objc override dynamic open func touchesMoved(_ touches: Swift.Set<UIKit.UITouch>, with event: UIKit.UIEvent)
  @objc override dynamic open func touchesCancelled(_ touches: Swift.Set<UIKit.UITouch>, with event: UIKit.UIEvent)
  @objc override dynamic open func reset()
  @objc override dynamic open func canPrevent(_ preventedGestureRecognizer: UIKit.UIGestureRecognizer) -> Swift.Bool
  open func translation(in entity: RealityKit.Entity?) -> Swift.SIMD3<Swift.Float>?
  open func setTranslation(_ translation: Swift.SIMD3<Swift.Float>, in entity: RealityKit.Entity?)
  open func velocity(in entity: RealityKit.Entity?) -> Swift.SIMD3<Swift.Float>
  public func location(in entity: RealityKit.Entity?) -> Swift.SIMD3<Swift.Float>?
  @objc override dynamic public init(target: Any?, action: ObjectiveC.Selector?)
  @objc deinit
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class __RKEmphasisPulseAnimation : RealityKit.__RKEmphasisBaseAnimation {
  @objc deinit
}
public protocol __SceneService {
  var scenes: [RealityKit.Scene] { get }
  func append(scene: RealityKit.Scene)
  func remove(scene: RealityKit.Scene)
  var coreECSManager: RealityKit.__REECSManagerRef { get }
  func coreCustomComponentType(_ attributeType: RealityKit.Component.Type) -> Swift.OpaquePointer
}
public enum __RKEntityMoveSelection : Swift.String, Swift.Codable, Swift.CaseIterable {
  case local
  case absolute
  public init?(rawValue: Swift.String)
  public typealias AllCases = [RealityKit.__RKEntityMoveSelection]
  public typealias RawValue = Swift.String
  public static var allCases: [RealityKit.__RKEntityMoveSelection] {
    get
  }
  public var rawValue: Swift.String {
    get
  }
}
public enum __RKEntityMoveEase : Swift.String, Swift.Codable, Swift.CaseIterable {
  case none
  case back
  case bounce
  case circle
  case elastic
  case exponential
  case hermite
  case log
  case power
  case sine
  public init?(rawValue: Swift.String)
  public typealias AllCases = [RealityKit.__RKEntityMoveEase]
  public typealias RawValue = Swift.String
  public static var allCases: [RealityKit.__RKEntityMoveEase] {
    get
  }
  public var rawValue: Swift.String {
    get
  }
}
public enum __RKEntityMoveEaseType : Swift.String, Swift.Codable, Swift.CaseIterable {
  case easeIn
  case easeOut
  case easeInEaseOut
  public init?(rawValue: Swift.String)
  public typealias AllCases = [RealityKit.__RKEntityMoveEaseType]
  public typealias RawValue = Swift.String
  public static var allCases: [RealityKit.__RKEntityMoveEaseType] {
    get
  }
  public var rawValue: Swift.String {
    get
  }
}
public class __RKEntityTransformAction : RealityKit.__RKEntityAction {
  public init(targetEntity: RealityKit.Entity?, location: Swift.SIMD3<Swift.Float>?, orientation: simd.simd_quatf?, scale: Swift.Float?, duration: Swift.Float, moveType: RealityKit.__RKEntityMoveSelection, ease: RealityKit.__RKEntityMoveEase = .none, easeType: RealityKit.__RKEntityMoveEaseType = .easeIn, respectPhysics: Swift.Bool = false, physicsAngularCoefficient: Swift.Float = 0.0, physicsLinearCoefficient: Swift.Float = 0.0)
  override public func perform(with context: RealityKit.__RKEntityActionContext) -> Swift.Bool
  override public func reversed() -> RealityKit.__RKEntityAction?
  @objc override public func copy(with zone: ObjectiveC.NSZone? = nil) -> Any
  override public func prefersInitialOrdering() -> Swift.Bool
  override public init(targetEntity: RealityKit.Entity? = super)
  @objc deinit
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class __RKVisibilityHideMoveOutAnimation : RealityKit.__RKVisibilityBaseAnimation {
  @objc deinit
}
extension Entity {
  public func __remapUUIDs(entityIdentifierMapping: @escaping (Foundation.UUID) -> Foundation.UUID, interactionIdentifierMapping: @escaping (Foundation.UUID) -> Foundation.UUID)
}
@_hasMissingDesignatedInitializers public class __RERenderGraphEmitter : RealityKit.Resource {
  public static func __load(named name: Swift.String, in bundle: Foundation.Bundle? = nil) throws -> RealityKit.__RERenderGraphEmitter
  public var __handle: RealityKit.__AssetRef {
    get
  }
  @objc deinit
}
@available(macOS 10.15, iOS 13.0, *)
public protocol Material {
  typealias Color = UIKit.UIColor
  var __resource: RealityKit.__MaterialResource { get }
  var __parameterBlock: RealityKit.__RKMaterialParameterBlock { get set }
}
@_hasMissingDesignatedInitializers public class __MaterialResource {
  public var __coreAsset: RealityKit.__AssetRef {
    get
  }
  public static func __load(named name: Swift.String, in bundle: Foundation.Bundle? = nil) throws -> RealityKit.Material
  @objc deinit
}
@available(macOS 10.15, iOS 13.0, *)
public struct SimpleMaterial : RealityKit.Material {
  public let __resource: RealityKit.__MaterialResource
  public var __parameterBlock: RealityKit.__RKMaterialParameterBlock
  public var tintColor: UIKit.UIColor {
    get
    set
  }
  public var baseColor: RealityKit.MaterialColorParameter {
    get
    set
  }
  public var roughness: RealityKit.MaterialScalarParameter {
    get
    set
  }
  public var metallic: RealityKit.MaterialScalarParameter {
    get
    set
  }
  public var __emissive: RealityKit.MaterialColorParameter {
    get
    set
  }
  public var __usesTransparency: Swift.Bool {
    get
    set
  }
  public init(color: RealityKit.SimpleMaterial.Color, roughness: RealityKit.MaterialScalarParameter = 0.0, isMetallic: Swift.Bool)
  public init()
}
@available(macOS 10.15, iOS 13.0, *)
public struct OcclusionMaterial : RealityKit.Material {
  public let __resource: RealityKit.__MaterialResource
  public var __parameterBlock: RealityKit.__RKMaterialParameterBlock
  public let receivesDynamicLighting: Swift.Bool
  public init(receivesDynamicLighting: Swift.Bool = false)
}
@available(macOS 10.15, iOS 13.0, *)
public struct UnlitMaterial : RealityKit.Material {
  public let __resource: RealityKit.__MaterialResource
  public var __parameterBlock: RealityKit.__RKMaterialParameterBlock
  public var tintColor: UIKit.UIColor {
    get
    set
  }
  public var baseColor: RealityKit.MaterialColorParameter {
    get
    set
  }
  public var __usesTransparency: Swift.Bool {
    get
    set
  }
  public init(color: UIKit.UIColor)
  public init()
}
@available(macOS 11.0, iOS 14.0, *)
public struct VideoMaterial : RealityKit.Material {
  public var __resource: RealityKit.__MaterialResource
  public var __parameterBlock: RealityKit.__RKMaterialParameterBlock
  public var __videoResource: RealityKit.__VideoResource
  public init(avPlayer: AVFoundation.AVPlayer)
  public var avPlayer: AVFoundation.AVPlayer? {
    get
    set
  }
  public var controller: RealityKit.VideoPlaybackController {
    get
  }
  public static func __makeVideoMaterial(videoResource: RealityKit.__VideoResource) -> RealityKit.VideoMaterial
}
@available(macOS 10.15, iOS 13.0, *)
public enum MaterialScalarParameter : Swift.ExpressibleByFloatLiteral, Swift.ExpressibleByIntegerLiteral, Swift.Hashable {
  case float(Swift.Float)
  case texture(RealityKit.TextureResource)
  public init(floatLiteral value: Swift.Float)
  public init(integerLiteral value: Swift.Int)
  public static func == (lhs: RealityKit.MaterialScalarParameter, rhs: RealityKit.MaterialScalarParameter) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public typealias FloatLiteralType = Swift.Float
  public typealias IntegerLiteralType = Swift.Int
  public var hashValue: Swift.Int {
    get
  }
}
@available(macOS 10.15, iOS 13.0, *)
public enum MaterialColorParameter : Swift._ExpressibleByColorLiteral, Swift.Hashable {
  case color(UIKit.UIColor)
  case texture(RealityKit.TextureResource)
  public init(_colorLiteralRed red: Swift.Float, green: Swift.Float, blue: Swift.Float, alpha: Swift.Float)
  public static func == (lhs: RealityKit.MaterialColorParameter, rhs: RealityKit.MaterialColorParameter) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension Entity : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
extension Entity {
  public var __debugTree: [(Swift.String, Swift.Int)] {
    get
  }
}
public struct __RKEntityUUIDComponent {
  @_hasMissingDesignatedInitializers public class Registration {
    final public let componentType: Swift.OpaquePointer
    @objc deinit
  }
  public static var registration: RealityKit.__RKEntityUUIDComponent.Registration?
}
extension Entity {
  public var __interactionIdentifier: Foundation.UUID? {
    get
    set
  }
}
public protocol __RKEntityActionStateObserver : AnyObject {
  func action(_ action: RealityKit.__RKEntityAction, didChangeStateFrom fromState: RealityKit.__RKEntityAction.State, to toState: RealityKit.__RKEntityAction.State)
}
public enum __RKEntityActionMultiplePerformBehavior : Swift.String, Swift.Codable, Swift.CaseIterable {
  case allow
  case ignore
  case stopsAction
  public init?(rawValue: Swift.String)
  public typealias AllCases = [RealityKit.__RKEntityActionMultiplePerformBehavior]
  public typealias RawValue = Swift.String
  public static var allCases: [RealityKit.__RKEntityActionMultiplePerformBehavior] {
    get
  }
  public var rawValue: Swift.String {
    get
  }
}
public struct __RKEntityActionContext {
  public var trigger: RealityKit.__RKEntityTrigger
  public var scene: RealityKit.Scene
  public init(trigger: RealityKit.__RKEntityTrigger, scene: RealityKit.Scene)
}
open class __RKEntityAction : Swift.CustomStringConvertible, Foundation.NSCopying {
  public enum State : Swift.Equatable {
    case notStarted
    case running
    case progress(Swift.Double)
    case finished
    case stopped
    case failed
    public static func == (a: RealityKit.__RKEntityAction.State, b: RealityKit.__RKEntityAction.State) -> Swift.Bool
  }
  public init(targetEntity: RealityKit.Entity? = nil)
  @objc deinit
  public typealias CompletionHandler = ((Swift.Bool) -> Swift.Void)
  public var targetEntity: RealityKit.Entity?
  public var completionHandler: RealityKit.__RKEntityAction.CompletionHandler?
  public var isAlternate: Swift.Bool
  public var isExclusive: Swift.Bool
  public var exclusiveBlocksForCompletion: Swift.Bool
  public var state: RealityKit.__RKEntityAction.State {
    get
    set
  }
  public var multiplePerformBehaviour: RealityKit.__RKEntityActionMultiplePerformBehavior
  public func performAction(with context: RealityKit.__RKEntityActionContext)
  public func shouldContinueOnPerform() -> Swift.Bool
  public func preloadAssets()
  @discardableResult
  open func perform(with context: RealityKit.__RKEntityActionContext) -> Swift.Bool
  public func addStateObserver(_ observer: RealityKit.__RKEntityActionStateObserver)
  public func removeStateObserver(_ observer: RealityKit.__RKEntityActionStateObserver)
  public func reversed() -> RealityKit.__RKEntityAction?
  public var description: Swift.String {
    get
  }
  @discardableResult
  public func stop() -> Swift.Bool
  public func isExclusiveWith(action: RealityKit.__RKEntityAction) -> Swift.Bool
  @objc public func copy(with zone: ObjectiveC.NSZone? = nil) -> Any
  public func animationPostCleanup()
  public func prefersInitialOrdering() -> Swift.Bool
}
extension __RKEntityAction {
  public struct ActionStateObservation {
  }
}
@usableFromInline
internal struct RETransform {
  @usableFromInline
  internal var position: Swift.SIMD3<Swift.Float>
  @usableFromInline
  internal var orientation: simd.simd_quatf
  @usableFromInline
  internal var scale: Swift.SIMD3<Swift.Float>
}
extension RETransform {
  @inlinable internal var matrix: RealityKit.REMatrix4x4F {
    get {
            return REMatrix4x4F(translation: position, rotation: orientation, scale: scale)
        }
    set {
            (position, orientation, scale) = newValue.decompose()
        }
  }
}
@available(macOS 10.15, iOS 13.0, *)
public struct SpotLightComponent : RealityKit.Component, Swift.Equatable {
  public typealias Color = UIKit.UIColor
  public struct Shadow : RealityKit.Component, Swift.Equatable {
    public init()
    public static func __fromCore(_ coreComponent: RealityKit.__ComponentRef) -> RealityKit.SpotLightComponent.Shadow
    public func __toCore(_ coreComponent: RealityKit.__ComponentRef)
    public static var __coreComponentType: RealityKit.__ComponentTypeRef {
      get
    }
    public static func == (a: RealityKit.SpotLightComponent.Shadow, b: RealityKit.SpotLightComponent.Shadow) -> Swift.Bool
  }
  public var color: RealityKit.SpotLightComponent.Color
  public var intensity: Swift.Float
  public var innerAngleInDegrees: Swift.Float
  public var outerAngleInDegrees: Swift.Float
  public var attenuationRadius: Swift.Float
  public init(color: RealityKit.SpotLightComponent.Color = .white, intensity: Swift.Float = 6740.94, innerAngleInDegrees: Swift.Float = 45.0, outerAngleInDegrees: Swift.Float = 60.0, attenuationRadius: Swift.Float = 10.0)
  public static func __fromCore(_ coreComponent: RealityKit.__ComponentRef) -> RealityKit.SpotLightComponent
  public func __toCore(_ coreComponent: RealityKit.__ComponentRef)
  public static var __coreComponentType: RealityKit.__ComponentTypeRef {
    get
  }
  public static func == (a: RealityKit.SpotLightComponent, b: RealityKit.SpotLightComponent) -> Swift.Bool
}
open class __RKEntityTrigger : Swift.CustomStringConvertible {
  public init()
  public var reversible: Swift.Bool
  public var shouldReverse: Swift.Bool
  public var shouldFireAlternate: Swift.Bool
  open func matches(with trigger: RealityKit.__RKEntityTrigger) -> Swift.Bool
  public var description: Swift.String {
    get
  }
  @objc deinit
}
extension MeshResource {
  public static func __generateFace(from faceGeometry: ARKit.ARFaceGeometry, fillMesh: Swift.Bool = true) -> RealityKit.MeshResource
}
public struct __REEventSubscriber<CoreEvent> : Combine.Subscriber {
  public typealias Input = CoreEvent
  public typealias Failure = Swift.Never
  public var combineIdentifier: Combine.CombineIdentifier {
    get
  }
  public func receive(subscription: Combine.Subscription)
  public func receive(_ input: RealityKit.__REEventSubscriber<CoreEvent>.Input) -> Combine.Subscribers.Demand
  public func receive(completion: Combine.Subscribers.Completion<Swift.Never>)
}
public struct __RKCustomTriggerNotification {
}
public class __RKCustomTrigger : RealityKit.__RKEntityTrigger {
  public init(identifier: Swift.String, customArguments: [Swift.String : Swift.String]? = [:])
  override public func matches(with trigger: RealityKit.__RKEntityTrigger) -> Swift.Bool
  override public init()
  @objc deinit
}
public class __RKEntityCustomTrigger : RealityKit.__RKEntityTrigger {
  public var targetEntity: RealityKit.Entity?
  public init(targetEntity: RealityKit.Entity?, identifier: Swift.String, customArguments: [Swift.String : Swift.String]? = [:])
  override public func matches(with trigger: RealityKit.__RKEntityTrigger) -> Swift.Bool
  override public init()
  @objc deinit
}
@available(macCatalyst 14.0, *)
extension ARView {
  public struct RenderOptions : Swift.OptionSet {
    public static let disableCameraGrain: RealityKit.ARView.RenderOptions
    @available(*, deprecated, message: "Use .disableAREnvironmentLighting in ARView instead")
    public static let disableAutomaticLighting: RealityKit.ARView.RenderOptions
    public static let disableGroundingShadows: RealityKit.ARView.RenderOptions
    public static let disableMotionBlur: RealityKit.ARView.RenderOptions
    public static let disableDepthOfField: RealityKit.ARView.RenderOptions
    public static let disableHDR: RealityKit.ARView.RenderOptions
    public static let disableFaceOcclusions: RealityKit.ARView.RenderOptions
    public static let disablePersonOcclusion: RealityKit.ARView.RenderOptions
    public static let disableAREnvironmentLighting: RealityKit.ARView.RenderOptions
    public static let __disableLocalizedProbes: RealityKit.ARView.RenderOptions
    public let rawValue: Swift.UInt
    public init(rawValue: Swift.UInt)
    public typealias ArrayLiteralElement = RealityKit.ARView.RenderOptions
    public typealias Element = RealityKit.ARView.RenderOptions
    public typealias RawValue = Swift.UInt
  }
  public var renderOptions: RealityKit.ARView.RenderOptions {
    get
    set
  }
  @available(*, deprecated, message: "Use RenderOptions instead")
  public enum __RenderQuality {
    case tier1
    case tier2
    case tier3
    case tier4
    case fastest
    case standard
    case high
    case best
    public static func == (a: RealityKit.ARView.__RenderQuality, b: RealityKit.ARView.__RenderQuality) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public var __renderQuality: RealityKit.ARView.__RenderQuality {
    get
    set
  }
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class __RKVisibilityHideLaunchAnimation : RealityKit.__RKVisibilityBaseAnimation {
  @objc deinit
}
@_hasMissingDesignatedInitializers public class __Engine {
  public struct Configuration {
    public var clockMode: RealityKit.__EngineClockModeRef
    public var device: Metal.MTLDevice?
    public var queue: Dispatch.DispatchQueue?
    public var __createServices: RealityKit.__EngineServiceMaskRef
    public var __updateServices: RealityKit.__EngineServiceMaskRef
    public var __startupOptions: RealityKit.__StartupOptionsRef
    public var __renderFlags: RealityKit.__RenderFlagsRef
    public init()
  }
  final public let configuration: RealityKit.__Engine.Configuration
  public var __coreEngine: RealityKit.__EngineRef {
    get
  }
  final public let queue: Dispatch.DispatchQueue
  public var services: RealityKit.__ServiceLocator! {
    get
  }
  public init(configuration: RealityKit.__Engine.Configuration)
  public init(coreEngine: RealityKit.__EngineRef)
  @objc deinit
  public func __start()
  public func __stop()
  public static func __ensureBuiltInComponentsAreRegistered()
  public static func __registerREKitComponents() throws
  public static func __unregisterREKitComponents()
}
@available(macOS 10.15, iOS 13.0, *)
public struct AnimationTimingFunction : Swift.Hashable {
  @available(*, deprecated, message: "Will be hidden in RealityKit 2019.")
  public enum __Mode {
    case easeIn
    case easeOut
    case easeInOut
    public static func == (a: RealityKit.AnimationTimingFunction.__Mode, b: RealityKit.AnimationTimingFunction.__Mode) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  @available(*, deprecated, message: "Will be hidden in RealityKit 2019.")
  public static func __smooth(_ mode: RealityKit.AnimationTimingFunction.__Mode = .easeInOut) -> RealityKit.AnimationTimingFunction
  @available(*, deprecated, message: "Will be hidden in RealityKit 2019.")
  public static func __back(_ mode: RealityKit.AnimationTimingFunction.__Mode = .easeIn, amplitude: Swift.Float = 1) -> RealityKit.AnimationTimingFunction
  @available(*, deprecated, message: "Will be hidden in RealityKit 2019.")
  public static func __bounce(_ mode: RealityKit.AnimationTimingFunction.__Mode = .easeOut, bounces: Swift.Int = 3, bounciness: Swift.Float = 2) -> RealityKit.AnimationTimingFunction
  @available(*, deprecated, message: "Will be hidden in RealityKit 2019.")
  public static func __circle(_ mode: RealityKit.AnimationTimingFunction.__Mode = .easeIn) -> RealityKit.AnimationTimingFunction
  @available(*, deprecated, message: "Will be hidden in RealityKit 2019.")
  public static func __exponential(_ mode: RealityKit.AnimationTimingFunction.__Mode = .easeIn, exponent: Swift.Float = 2) -> RealityKit.AnimationTimingFunction
  @available(*, deprecated, message: "Will be hidden in RealityKit 2019.")
  public static func __logarithmic(_ mode: RealityKit.AnimationTimingFunction.__Mode = .easeIn, base: Swift.Float = 2) -> RealityKit.AnimationTimingFunction
  @available(*, deprecated, message: "Will be hidden in RealityKit 2019.")
  public static func __power(_ mode: RealityKit.AnimationTimingFunction.__Mode = .easeIn, power: Swift.Float = 2) -> RealityKit.AnimationTimingFunction
  @available(*, deprecated, message: "Will be hidden in RealityKit 2019.")
  public static func __sine(_ mode: RealityKit.AnimationTimingFunction.__Mode = .easeIn) -> RealityKit.AnimationTimingFunction
  @available(*, deprecated, message: "Renamed to `elastic`.")
  public static func __spring(_ mode: RealityKit.AnimationTimingFunction.__Mode = .easeOut, oscillations: Swift.Int = 2, springiness: Swift.Float = 2) -> RealityKit.AnimationTimingFunction
  @available(*, deprecated, message: "Will be hidden in RealityKit 2019.")
  public static func __elastic(_ mode: RealityKit.AnimationTimingFunction.__Mode = .easeOut, oscillations: Swift.Int = 2, springiness: Swift.Float = 2) -> RealityKit.AnimationTimingFunction
  public static var `default`: RealityKit.AnimationTimingFunction {
    get
  }
  public static var linear: RealityKit.AnimationTimingFunction {
    get
  }
  public static var easeIn: RealityKit.AnimationTimingFunction {
    get
  }
  public static var easeOut: RealityKit.AnimationTimingFunction {
    get
  }
  public static var easeInOut: RealityKit.AnimationTimingFunction {
    get
  }
  public static func cubicBezier(controlPoint1: Swift.SIMD2<Swift.Float>, controlPoint2: Swift.SIMD2<Swift.Float>) -> RealityKit.AnimationTimingFunction
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: RealityKit.AnimationTimingFunction, b: RealityKit.AnimationTimingFunction) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
@available(macOS 10.15, iOS 13.0, *)
public protocol Resource {
}
extension Resource {
  public static func __fromCore(_ coreAsset: RealityKit.__AssetRef) -> Self
}
public class __RKEntityTriggerGroup : RealityKit.__RKEntityTrigger {
  public var triggers: [RealityKit.__RKEntityTrigger] {
    get
  }
  public init(triggers: [RealityKit.__RKEntityTrigger])
  override public func matches(with trigger: RealityKit.__RKEntityTrigger) -> Swift.Bool
  override public init()
  @objc deinit
}
public class __RKEntitySwapEntityAction : RealityKit.__RKEntityAction {
  public init(targetEntity: RealityKit.Entity?, newEntity: RealityKit.Entity?, buildOutAction: RealityKit.__RKEntityHideAction, buildInAction: RealityKit.__RKEntityShowAction)
  override public func perform(with context: RealityKit.__RKEntityActionContext) -> Swift.Bool
  override public func reversed() -> RealityKit.__RKEntityAction?
  @objc override public func copy(with zone: ObjectiveC.NSZone? = nil) -> Any
  override public init(targetEntity: RealityKit.Entity? = super)
  @objc deinit
}
extension Entity {
  public var availableAnimations: [RealityKit.AnimationResource] {
    get
  }
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers @available(macOS 10.15, iOS 13.0, *)
public class AnchorEntity : RealityKit.Entity, RealityKit.HasAnchoring {
  required public init()
  public init(_ target: RealityKit.AnchoringComponent.Target)
  convenience public init(world position: Swift.SIMD3<Swift.Float>)
  convenience public init(world transform: simd.float4x4)
  convenience public init(plane alignment: RealityKit.AnchoringComponent.Target.Alignment, classification: RealityKit.AnchoringComponent.Target.Classification = .any, minimumBounds: Swift.SIMD2<Swift.Float> = [0, 0])
  convenience public init(anchor: ARKit.ARAnchor)
  convenience public init(raycastResult: ARKit.ARRaycastResult)
  @objc deinit
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers @available(macOS 10.15, iOS 13.0, *)
public class BodyTrackedEntity : RealityKit.Entity, RealityKit.HasBodyTracking, RealityKit.HasModel {
  @objc deinit
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers @available(macOS 10.15, iOS 13.0, *)
public class PerspectiveCamera : RealityKit.Entity, RealityKit.HasPerspectiveCamera {
  required public init()
  @objc deinit
}
@_inheritsConvenienceInitializers @available(macOS 10.15, iOS 13.0, *)
public class SpotLight : RealityKit.Entity, RealityKit.HasSpotLight {
  required public init()
  @usableFromInline
  override internal init(_coreEntity: RealityKit.__EntityRef)
  @objc deinit
}
@_inheritsConvenienceInitializers @available(macOS 10.15, iOS 13.0, *)
public class DirectionalLight : RealityKit.Entity, RealityKit.HasDirectionalLight {
  required public init()
  @usableFromInline
  override internal init(_coreEntity: RealityKit.__EntityRef)
  @objc deinit
}
@_inheritsConvenienceInitializers @available(macOS 10.15, iOS 13.0, *)
public class PointLight : RealityKit.Entity, RealityKit.HasPointLight {
  required public init()
  @usableFromInline
  override internal init(_coreEntity: RealityKit.__EntityRef)
  @objc deinit
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers @available(macOS 10.15, iOS 13.0, *)
public class ModelEntity : RealityKit.Entity, RealityKit.HasModel, RealityKit.HasPhysics {
  required public init()
  public init(mesh: RealityKit.MeshResource, materials: [RealityKit.Material] = [])
  public init(mesh: RealityKit.MeshResource, materials: [RealityKit.Material] = [], collisionShape: RealityKit.ShapeResource, mass: Swift.Float)
  public init(mesh: RealityKit.MeshResource, materials: [RealityKit.Material] = [], collisionShapes: [RealityKit.ShapeResource], mass: Swift.Float)
  @objc deinit
}
@available(macOS 10.15, iOS 13.0, *)
public class TriggerVolume : RealityKit.Entity, RealityKit.HasCollision {
  required public init()
  convenience public init(shape: RealityKit.ShapeResource, filter: RealityKit.CollisionFilter = .sensor)
  public init(shapes: [RealityKit.ShapeResource], filter: RealityKit.CollisionFilter = .sensor)
  @usableFromInline
  override internal init(_coreEntity: RealityKit.__EntityRef)
  @objc deinit
}
@available(macOS 10.15, iOS 13.0, *)
public struct PointLightComponent : RealityKit.Component, Swift.Equatable {
  public typealias Color = UIKit.UIColor
  public var color: RealityKit.PointLightComponent.Color
  public var intensity: Swift.Float
  public var attenuationRadius: Swift.Float
  public init(color: RealityKit.PointLightComponent.Color = .white, intensity: Swift.Float = 26963.76, attenuationRadius: Swift.Float = 10.0)
  public static func __fromCore(_ coreComponent: RealityKit.__ComponentRef) -> RealityKit.PointLightComponent
  public func __toCore(_ coreComponent: RealityKit.__ComponentRef)
  public static var __coreComponentType: RealityKit.__ComponentTypeRef {
    get
  }
  public static func == (a: RealityKit.PointLightComponent, b: RealityKit.PointLightComponent) -> Swift.Bool
}
public class __RKChangeSceneAction : RealityKit.__RKEntityAction {
  public static let noTargetSceneIdentifier: Foundation.UUID
  public var rootEntity: RealityKit.Entity?
  public init(rootEntity: RealityKit.Entity?, targetSceneIdentifier: Foundation.UUID)
  override public func perform(with context: RealityKit.__RKEntityActionContext) -> Swift.Bool
  override public func reversed() -> RealityKit.__RKEntityAction?
  @objc override public func copy(with zone: ObjectiveC.NSZone? = nil) -> Any
  override public init(targetEntity: RealityKit.Entity? = super)
  @objc deinit
}
public struct __REECSManagerRef {
  public func __as<T>(_ type: T.Type) -> T
}
public struct __EntityRef : Swift.Equatable {
  public func __as<T>(_ type: T.Type) -> T
  public static func __fromCore(_ core: Any) -> RealityKit.__EntityRef
  public static func == (a: RealityKit.__EntityRef, b: RealityKit.__EntityRef) -> Swift.Bool
}
public struct __SceneRef {
  public func __as<T>(_ type: T.Type) -> T
  public static func __fromCore(_ core: Any) -> RealityKit.__SceneRef
}
public struct __SceneImportOperationRef : Swift.Equatable {
  public func __as<T>(_ type: T.Type) -> T
  public static func __fromCore(_ core: Any) -> RealityKit.__SceneImportOperationRef
  public static func == (a: RealityKit.__SceneImportOperationRef, b: RealityKit.__SceneImportOperationRef) -> Swift.Bool
}
public struct __ComponentRef {
  public func __as<T>(_ type: T.Type) -> T
}
public struct __ComponentTypeRef {
  public static func __fromCore(_ core: Any) -> RealityKit.__ComponentTypeRef
  public func __as<T>(_ type: T.Type) -> T
}
public struct __AssetRef {
  public func __as<T>(_ type: T.Type) -> T
  public static func __fromCore(_ core: Any) -> RealityKit.__AssetRef
}
public struct __EngineRef {
  public func __as<T>(_ type: T.Type) -> T
  public static func __fromCore(_ core: Any) -> RealityKit.__EngineRef
}
public struct __EngineClockModeRef {
  public func __as<T>(_ type: T.Type) -> T
  public static func __fromCore(_ core: Any) -> RealityKit.__EngineClockModeRef
}
public struct __EngineServiceMaskRef {
  public func __as<T>(_ type: T.Type) -> T
  public static func __fromCore(_ core: Any) -> RealityKit.__EngineServiceMaskRef
}
public struct __RenderFlagsRef {
  public func __as<T>(_ type: T.Type) -> T
  public static func __fromCore(_ core: Any) -> RealityKit.__RenderFlagsRef
}
public struct __StartupOptionsRef {
  public func __as<T>(_ type: T.Type) -> T
  public static func __fromCore(_ core: Any) -> RealityKit.__StartupOptionsRef
}
public struct __PeerIDRef {
  public func __as<T>(_ type: T.Type) -> T
}
public struct __AABBRef {
  public func __as<T>(_ type: T.Type) -> T
}
public struct __SRTRef {
  public func __as<T>(_ type: T.Type) -> T
  public static func __fromCore(_ core: Any) -> RealityKit.__SRTRef
}
public struct __AnimationPlaybackTokenRef {
  public var core: Swift.UInt64
  public func __as<T>(_ type: T.Type) -> T
}
@inlinable internal func convertToDegrees(radians: Swift.Float) -> Swift.Float {
    return radians * Float(180.0) / Float.pi
}
@inlinable internal func convertToRadians(degrees: Swift.Float) -> Swift.Float {
    return degrees * Float.pi / Float(180.0)
}
@inlinable internal func log2RoundUp(_ v: Swift.Int32) -> Swift.Int32 {
    return Int32(ceil(log2(Double(v))))
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class __RKEmphasisLeanAnimation : RealityKit.__RKEmphasisBaseAnimation {
  @objc deinit
}
@available(macCatalyst 14.0, *)
extension ARView {
  public struct EntityGestures : Swift.OptionSet {
    public let rawValue: Swift.Int
    public init(rawValue: Swift.Int)
    public static let translation: RealityKit.ARView.EntityGestures
    public static let rotation: RealityKit.ARView.EntityGestures
    public static let scale: RealityKit.ARView.EntityGestures
    public static let all: RealityKit.ARView.EntityGestures
    public typealias ArrayLiteralElement = RealityKit.ARView.EntityGestures
    public typealias Element = RealityKit.ARView.EntityGestures
    public typealias RawValue = Swift.Int
  }
  @discardableResult
  public func installGestures(_ gestures: RealityKit.ARView.EntityGestures = .all, for entity: RealityKit.HasCollision) -> [RealityKit.EntityGestureRecognizer]
}
public protocol __RenderService {
  var device: Metal.MTLDevice { get }
  var __coreRenderManager: Swift.OpaquePointer { get }
}
@available(macOS 10.15, iOS 13.0, *)
public protocol HasTransform : RealityKit.Entity {
}
extension HasTransform {
  public var transform: RealityKit.Transform {
    get
    set
  }
  public var scale: Swift.SIMD3<Swift.Float> {
    get
    set
    _modify
  }
  public func scale(relativeTo referenceEntity: RealityKit.Entity?) -> Swift.SIMD3<Swift.Float>
  public func setScale(_ scale: Swift.SIMD3<Swift.Float>, relativeTo referenceEntity: RealityKit.Entity?)
  public var position: Swift.SIMD3<Swift.Float> {
    get
    set
    _modify
  }
  public func position(relativeTo referenceEntity: RealityKit.Entity?) -> Swift.SIMD3<Swift.Float>
  public func setPosition(_ position: Swift.SIMD3<Swift.Float>, relativeTo referenceEntity: RealityKit.Entity?)
  public var orientation: simd.simd_quatf {
    get
    set
    _modify
  }
  public func orientation(relativeTo referenceEntity: RealityKit.Entity?) -> simd.simd_quatf
  public func setOrientation(_ orientation: simd.simd_quatf, relativeTo referenceEntity: RealityKit.Entity?)
  public func transformMatrix(relativeTo referenceEntity: RealityKit.Entity?) -> simd.float4x4
  public func setTransformMatrix(_ transform: simd.float4x4, relativeTo referenceEntity: RealityKit.Entity?)
  public func convert(position: Swift.SIMD3<Swift.Float>, from referenceEntity: RealityKit.Entity?) -> Swift.SIMD3<Swift.Float>
  public func convert(direction: Swift.SIMD3<Swift.Float>, from referenceEntity: RealityKit.Entity?) -> Swift.SIMD3<Swift.Float>
  public func convert(normal: Swift.SIMD3<Swift.Float>, from referenceEntity: RealityKit.Entity?) -> Swift.SIMD3<Swift.Float>
  public func convert(transform: RealityKit.Transform, from referenceEntity: RealityKit.Entity?) -> RealityKit.Transform
  public func convert(position: Swift.SIMD3<Swift.Float>, to referenceEntity: RealityKit.Entity?) -> Swift.SIMD3<Swift.Float>
  public func convert(direction: Swift.SIMD3<Swift.Float>, to referenceEntity: RealityKit.Entity?) -> Swift.SIMD3<Swift.Float>
  public func convert(normal: Swift.SIMD3<Swift.Float>, to referenceEntity: RealityKit.Entity?) -> Swift.SIMD3<Swift.Float>
  public func convert(transform: RealityKit.Transform, to referenceEntity: RealityKit.Entity?) -> RealityKit.Transform
  public func look(at target: Swift.SIMD3<Swift.Float>, from position: Swift.SIMD3<Swift.Float>, upVector: Swift.SIMD3<Swift.Float> = SIMD3<Float>(0, 1, 0), relativeTo referenceEntity: RealityKit.Entity?)
  public func move(to transform: RealityKit.Transform, relativeTo referenceEntity: RealityKit.Entity?)
  public func move(to transform: simd.float4x4, relativeTo referenceEntity: RealityKit.Entity?)
  @discardableResult
  public func move(to target: RealityKit.Transform, relativeTo referenceEntity: RealityKit.Entity?, duration: Foundation.TimeInterval, timingFunction: RealityKit.AnimationTimingFunction = .default) -> RealityKit.AnimationPlaybackController
  @discardableResult
  public func move(to target: simd.float4x4, relativeTo referenceEntity: RealityKit.Entity?, duration: Foundation.TimeInterval, timingFunction: RealityKit.AnimationTimingFunction = .default) -> RealityKit.AnimationPlaybackController
  public func visualBounds(recursive: Swift.Bool = true, relativeTo referenceEntity: RealityKit.Entity?, excludeInactive: Swift.Bool = false) -> RealityKit.BoundingBox
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class __RKVisibilityHidePopAnimation : RealityKit.__RKVisibilityBaseAnimation {
  @objc deinit
}
public class __RKEntityTapTrigger : RealityKit.__RKEntityTrigger {
  public var targetEntity: RealityKit.Entity?
  public init(targetEntity: RealityKit.Entity?, reversible: Swift.Bool? = false)
  override public func matches(with trigger: RealityKit.__RKEntityTrigger) -> Swift.Bool
  override public init()
  @objc deinit
}
public class __RKEntityOrbitEntityAction : RealityKit.__RKEntityAction {
  public init(targetEntity: RealityKit.Entity?, pivotEntity: RealityKit.Entity?, duration: Swift.Float = 1.0, rotations: Swift.Float = 1.0, orbitalAxis: Swift.SIMD3<Swift.Float> = SIMD3<Float>(0, 1, 0), orientToPath: Swift.Bool = false, spinDirection: RealityKit.__RKEntitySpinDirectionType = .clockwise, respectPhysics: Swift.Bool = false, physicsAngularCoefficient: Swift.Float = 0, physicsLinearCoefficient: Swift.Float = 0)
  override public func perform(with context: RealityKit.__RKEntityActionContext) -> Swift.Bool
  override public func prefersInitialOrdering() -> Swift.Bool
  override public func animationPostCleanup()
  override public func reversed() -> RealityKit.__RKEntityAction?
  @objc override public func copy(with zone: ObjectiveC.NSZone? = nil) -> Any
  override public init(targetEntity: RealityKit.Entity? = super)
  @objc deinit
}
@available(macOS 10.15, iOS 13.0, *)
extension Entity {
  public func __setLoadContext(_ loadContext: RealityKit.__SceneResourceLoadResultLoadContext?)
  public func __fetchLoadContext() -> RealityKit.__SceneResourceLoadResultLoadContext?
  public func __setSceneResourceCacheEntry(_ sceneResourceCache: RealityKit.__SceneResourceCache.Entry?)
  public func __fetchSceneResourceCacheEntry() -> RealityKit.__SceneResourceCache.Entry?
}
public struct __SceneResourceLoadResultLoadContext {
}
@available(macOS 10.15.4, iOS 13.4, *)
public struct __SceneResourceLoadResult {
}
@_hasMissingDesignatedInitializers final public class __SceneResourceCache {
  @_hasMissingDesignatedInitializers final public class Entry {
    @objc deinit
  }
  @available(macOS 10.15.4, iOS 13.4, *)
  public static func __init() -> RealityKit.__SceneResourceCache
  @available(macOS 10.15.4, iOS 13.4, *)
  final public func __registerImportedScenes(url: Foundation.URL, importedScenes: [RealityKit.__SceneImportOperation.__ImportedScene]) throws -> RealityKit.__SceneResourceLoadResult
  @objc deinit
}
extension __REAnchoringType {
  public func isEqualToARAnchor(anchor: ARKit.ARAnchor) -> Swift.Bool
}
public struct __Downsampling {
  public struct Factor {
    public init(mipmapOffset: Swift.Int)
    public init(value: Swift.Int)
  }
  public enum Resolution {
    case noDownsampling
    case downsampling(factors: [RealityKit.__Downsampling.Factor])
  }
}
public protocol __DownsamplingStrategy {
  func resolve(_ descriptors: [Metal.MTLTextureDescriptor]) throws -> RealityKit.__Downsampling.Resolution
}
public struct __DownsamplingStrategyClosure : RealityKit.__DownsamplingStrategy {
  public func resolve(_ descriptors: [Metal.MTLTextureDescriptor]) throws -> RealityKit.__Downsampling.Resolution
}
extension __Downsampling {
  public struct Minimal : RealityKit.__DownsamplingStrategy {
    public init()
    public func resolve(_ descriptors: [Metal.MTLTextureDescriptor]) throws -> RealityKit.__Downsampling.Resolution
  }
  public typealias ByteSize = Swift.UInt64
  public enum Error : Swift.Error, Swift.CustomDebugStringConvertible {
    case noSufficientDownsamplingStrategy(budget: RealityKit.__Downsampling.ByteSize, minimalSize: RealityKit.__Downsampling.ByteSize)
    public var debugDescription: Swift.String {
      get
    }
  }
  public struct Budgeted : RealityKit.__DownsamplingStrategy {
    public init(availableBytes: RealityKit.__Downsampling.ByteSize, device: Metal.MTLDevice)
    public func resolve(_ descriptors: [Metal.MTLTextureDescriptor]) throws -> RealityKit.__Downsampling.Resolution
  }
}
extension __Downsampling {
  public static func getMipmapByteSizes(_ descriptor: Metal.MTLTextureDescriptor, device: Metal.MTLDevice) -> [RealityKit.__Downsampling.ByteSize]
}
@_hasMissingDesignatedInitializers @available(macOS 11.0, iOS 14.0, *)
public class VideoPlaybackController {
  public var audioInputMode: RealityKit.AudioResource.InputMode {
    get
    set
  }
  @objc deinit
}
public class __RKEntityProximityTrigger : RealityKit.__RKEntityTrigger {
  public enum ExitType : Swift.Int, Swift.Codable {
    case none
    case sequence
    case reverse
    public init?(rawValue: Swift.Int)
    public typealias RawValue = Swift.Int
    public var rawValue: Swift.Int {
      get
    }
  }
  public var __targetEntity: RealityKit.Entity? {
    get
  }
  public var distance: Swift.Float {
    get
  }
  public var type: RealityKit.__RKEntityProximityTrigger.ExitType {
    get
  }
  public var enterFired: Swift.Bool {
    get
  }
  public var exitFired: Swift.Bool {
    get
  }
  public init(targetEntity: RealityKit.Entity?, distance: Swift.Float, type: RealityKit.__RKEntityProximityTrigger.ExitType)
  override public func matches(with trigger: RealityKit.__RKEntityTrigger) -> Swift.Bool
  override public init()
  @objc deinit
}
public protocol __ARViewDelegatePrivate : AnyObject {
  func viewWillProcessTapInteraction(_ view: RealityKit.ARView)
  func view(_ view: RealityKit.ARView, performedTapInteraction: Swift.Bool, for entity: RealityKit.Entity?)
  @available(macOS 11.0, iOS 14.0, *)
  func view(_ view: RealityKit.ARView, performedProximityInteractionsForEntities: [RealityKit.Entity])
  func update(_ view: RealityKit.ARView, deltaTime: Swift.Float)
}
@available(macOS 11.0, iOS 14.0, *)
extension __ARViewDelegatePrivate {
  public func view(_ view: RealityKit.ARView, performedProximityInteractionsForEntities: [RealityKit.Entity])
}
@available(macOS 10.15, iOS 13.0, *)
public typealias ARViewBase = UIKit.UIView
@objc @_inheritsConvenienceInitializers @available(macOS 10.15, iOS 13.0, *)
open class ARView : RealityKit.ARViewBase {
  public var __services: RealityKit.__ServiceLocator {
    get
  }
  public var scene: RealityKit.Scene {
    get
  }
  weak public var __delegatePrivate: RealityKit.__ARViewDelegatePrivate?
  public var __automaticallyInvokesStartTrigger: Swift.Bool {
    get
    set
  }
  @available(macCatalyst 14.0, *)
  public var debugOptions: RealityKit.ARView.DebugOptions {
    get
    set
  }
  public var environment: RealityKit.ARView.Environment {
    get
    set
  }
  public var cameraTransform: RealityKit.Transform {
    get
  }
  public var audioListener: RealityKit.Entity? {
    get
    set
  }
  public var __environmentEntity: RealityKit.Entity!
  public var __enableAutomaticFrameRate: Swift.Bool
  public var __preferredFrameRate: Swift.Float
  @objc required dynamic public init?(coder decoder: Foundation.NSCoder)
  @objc required override dynamic public init(frame frameRect: CoreGraphics.CGRect)
  @available(*, deprecated, message: "Renamed to `init(frame:cameraMode:automaticallyConfigureSession:)`.")
  convenience public init(frame frameRect: CoreGraphics.CGRect, cameraMode: RealityKit.ARView.CameraMode)
  @available(macCatalyst 14.0, *)
  public init(frame frameRect: CoreGraphics.CGRect, cameraMode: RealityKit.ARView.CameraMode, automaticallyConfigureSession: Swift.Bool)
  open func __customizeMetalLayer()
  public var __renderGraphEmitter: RealityKit.__RERenderGraphEmitter! {
    get
    set
  }
  public func __setWireframeMode(displayWireframe: Swift.Bool)
  public var __forceLocalizedProbes: Swift.Bool
  public var __parallaxBackgroundProbe: Swift.Bool
  public var __targetIdentifier: Swift.UInt {
    get
  }
  open func __didInitializeEngine()
  public static func __queryModelIdentifier() -> Swift.String
  public static var __nonARKitModelIdentifiers: [Swift.String] {
    get
  }
  public var __disableCounterRotation: Swift.Bool
  public var __disableComposition: Swift.Bool
  public var __nonARKitDevices: Swift.Bool
  @objc deinit
  public func __handleTapAtPoint(point: CoreGraphics.CGPoint)
  public struct DebugOptions : Swift.OptionSet {
    public let rawValue: Swift.Int
    public static let none: RealityKit.ARView.DebugOptions
    public static let showPhysics: RealityKit.ARView.DebugOptions
    public static let showStatistics: RealityKit.ARView.DebugOptions
    public static let showWorldOrigin: RealityKit.ARView.DebugOptions
    public static let showAnchorOrigins: RealityKit.ARView.DebugOptions
    public static let showAnchorGeometry: RealityKit.ARView.DebugOptions
    public static let showFeaturePoints: RealityKit.ARView.DebugOptions
    @available(iOS 13.4, *)
    public static let showSceneUnderstanding: RealityKit.ARView.DebugOptions
    public init(rawValue: Swift.Int)
    public typealias ArrayLiteralElement = RealityKit.ARView.DebugOptions
    public typealias Element = RealityKit.ARView.DebugOptions
    public typealias RawValue = Swift.Int
  }
  public var __statisticsOptions: RealityKit.ARView.__StatisticsOptions {
    get
    set
  }
  public var __disableStatisticsRendering: Swift.Bool {
    get
    set
  }
  public func __getStatisticsStringForSingleOption(statisticOption: RealityKit.ARView.__StatisticsOptions) -> Swift.String
  public struct __StatisticsOptions : Swift.OptionSet {
    public let rawValue: Swift.UInt32
    public static let frameTimeStatistics: RealityKit.ARView.__StatisticsOptions
    public static let animationStatistics: RealityKit.ARView.__StatisticsOptions
    public static let assetPipelineStatistics: RealityKit.ARView.__StatisticsOptions
    public static let audioStatistics: RealityKit.ARView.__StatisticsOptions
    public static let ecsStatistics: RealityKit.ARView.__StatisticsOptions
    public static let meshStatistics: RealityKit.ARView.__StatisticsOptions
    public static let networkStatistics: RealityKit.ARView.__StatisticsOptions
    public static let physicsStatistics: RealityKit.ARView.__StatisticsOptions
    public static let renderingStatistics: RealityKit.ARView.__StatisticsOptions
    public static let memoryStatistics: RealityKit.ARView.__StatisticsOptions
    public static let thermalStatistics: RealityKit.ARView.__StatisticsOptions
    public static let sceneUnderstandingStatistics: RealityKit.ARView.__StatisticsOptions
    public init(rawValue: Swift.UInt32)
    public typealias ArrayLiteralElement = RealityKit.ARView.__StatisticsOptions
    public typealias Element = RealityKit.ARView.__StatisticsOptions
    public typealias RawValue = Swift.UInt32
  }
  public func __setProfilerUpdateInterval(newInterval: Swift.Float)
  public func __frameTime() -> Swift.Float
  public typealias Image = UIKit.UIImage
  public func snapshot(saveToHDR: Swift.Bool, completion: @escaping (RealityKit.ARView.Image?) -> Swift.Void)
  public func __startAudioEngine()
  public func __stopAudioEngine()
  public func __distanceInMetersFromEntity(_ entity: RealityKit.Entity) -> Swift.Float
}
@available(macOS 10.15, iOS 13.0, *)
public protocol Component {
  static var __size: Swift.Int { get }
  static func __load(from buffer: Swift.UnsafeRawPointer, offset: Swift.Int) -> RealityKit.Component
  @available(macOS 11.0, iOS 14.0, *)
  static func __store(attribute: RealityKit.Component, to buffer: Swift.UnsafeMutableRawPointer, offset: Swift.Int, deinitialize: Swift.Bool)
  @available(macOS, deprecated: 11.0, message: "Use __store(attribute:to:offset:deinitialize:) instead.")
  @available(iOS, deprecated: 14.0, message: "Use __store(attribute:to:offset:deinitialize:) instead.")
  static func __store(attribute: RealityKit.Component, to buffer: Swift.UnsafeMutableRawPointer, offset: Swift.Int)
  static func __free(to buffer: Swift.UnsafeMutableRawPointer, offset: Swift.Int)
  static func __fromCore(_ coreComponent: RealityKit.__ComponentRef) -> Self
  func __toCore(_ coreComponent: RealityKit.__ComponentRef)
  static var __coreComponentType: RealityKit.__ComponentTypeRef { get }
  static func __addIntrospectionData(_ builder: Swift.OpaquePointer?)
}
extension Component {
  public static var __size: Swift.Int {
    get
  }
  public static func __load(from buffer: Swift.UnsafeRawPointer, offset: Swift.Int) -> RealityKit.Component
  public static func __store(attribute: RealityKit.Component, to buffer: Swift.UnsafeMutableRawPointer, offset: Swift.Int, deinitialize: Swift.Bool)
  @available(macOS, deprecated: 11.0, message: "Use __store(attribute:to:offset:deinitialize:) instead.")
  @available(iOS, deprecated: 14.0, message: "Use __store(attribute:to:offset:deinitialize:) instead.")
  public static func __store(attribute: RealityKit.Component, to buffer: Swift.UnsafeMutableRawPointer, offset: Swift.Int)
  public static func __free(to buffer: Swift.UnsafeMutableRawPointer, offset: Swift.Int)
  public static func __fromCore(_ coreComponent: RealityKit.__ComponentRef) -> Self
  public func __toCore(_ coreComponent: RealityKit.__ComponentRef)
  public static var __coreComponentType: RealityKit.__ComponentTypeRef {
    get
  }
  public static func __addIntrospectionData(_ builder: Swift.OpaquePointer?)
  public static func registerComponent()
  public static func __registerComponent() -> Swift.OpaquePointer?
}
@_hasMissingDesignatedInitializers public class __RKVisibilityBaseAnimation {
  @objc deinit
}
public protocol __RKActiveSceneObserver : AnyObject {
  func manager(_ manager: RealityKit.__RKActiveSceneManager, activeSceneDidChange scene: RealityKit.Scene?)
}
@available(*, deprecated, message: "Please use the per-interaction-service runtime scene coordinator. __RKRuntimeSceneCoordinator")
public class __RKActiveSceneManager {
  public static var shared: RealityKit.__RKActiveSceneManager
  public init()
  public var activeScene: RealityKit.Scene? {
    get
    set
  }
  public func addObserver(observer: RealityKit.__RKActiveSceneObserver)
  public func removeObserver(observer: RealityKit.__RKActiveSceneObserver)
  @objc deinit
}
extension ARView {
  public struct Environment {
    public typealias Color = UIKit.UIColor
    public struct Background {
      @available(macCatalyst 14.0, *)
      public static func cameraFeed(exposureCompensation: Swift.Float = 0.0) -> RealityKit.ARView.Environment.Background
      public static func skybox(_ resource: RealityKit.EnvironmentResource) -> RealityKit.ARView.Environment.Background
      public static func color(_ color: RealityKit.ARView.Environment.Color) -> RealityKit.ARView.Environment.Background
    }
    public struct ImageBasedLight {
      public var resource: RealityKit.EnvironmentResource?
      public var intensityExponent: Swift.Float
    }
    public enum Reverb {
      public enum Preset {
        case smallRoom
        case mediumRoom
        case largeRoom
        case mediumHall
        case largeHall
        case cathedral
        public static func == (a: RealityKit.ARView.Environment.Reverb.Preset, b: RealityKit.ARView.Environment.Reverb.Preset) -> Swift.Bool
        public func hash(into hasher: inout Swift.Hasher)
        public var hashValue: Swift.Int {
          get
        }
      }
      case noReverb
      case preset(RealityKit.ARView.Environment.Reverb.Preset)
      public static var automatic: RealityKit.ARView.Environment.Reverb {
        get
      }
    }
    @available(iOS 13.4, macCatalyst 14.0, *)
    public struct SceneUnderstanding {
      public struct Options : Swift.OptionSet {
        public let rawValue: Swift.UInt32
        public static let occlusion: RealityKit.ARView.Environment.SceneUnderstanding.Options
        public static let receivesLighting: RealityKit.ARView.Environment.SceneUnderstanding.Options
        public static let collision: RealityKit.ARView.Environment.SceneUnderstanding.Options
        public static let physics: RealityKit.ARView.Environment.SceneUnderstanding.Options
        public static let __disableFeathering: RealityKit.ARView.Environment.SceneUnderstanding.Options
        public static let __disableGuidedFilterOcclusions: RealityKit.ARView.Environment.SceneUnderstanding.Options
        public static let `default`: RealityKit.ARView.Environment.SceneUnderstanding.Options
        public init(rawValue: Swift.UInt32)
        public typealias ArrayLiteralElement = RealityKit.ARView.Environment.SceneUnderstanding.Options
        public typealias Element = RealityKit.ARView.Environment.SceneUnderstanding.Options
        public typealias RawValue = Swift.UInt32
      }
      public struct __InternalSettings {
        public var guidedFilterOcclusionUseSingleMTLEvent: Swift.Bool
      }
      public var __internalSettings: RealityKit.ARView.Environment.SceneUnderstanding.__InternalSettings {
        get
        set
      }
      public var options: RealityKit.ARView.Environment.SceneUnderstanding.Options {
        get
        set
      }
    }
    @available(iOS 13.4, macCatalyst 14.0, *)
    public var sceneUnderstanding: RealityKit.ARView.Environment.SceneUnderstanding {
      mutating get
      set
    }
    public var background: RealityKit.ARView.Environment.Background
    public var lighting: RealityKit.ARView.Environment.ImageBasedLight
    public var reverb: RealityKit.ARView.Environment.Reverb
    public init(background: RealityKit.ARView.Environment.Background, lighting: RealityKit.ARView.Environment.ImageBasedLight, reverb: RealityKit.ARView.Environment.Reverb)
  }
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class __RKEmphasisBlinkAnimation : RealityKit.__RKEmphasisBaseAnimation {
  @objc deinit
}
@_inheritsConvenienceInitializers public class __RKLightTrigger : RealityKit.__RKEntityTrigger {
  override public init()
  @objc deinit
}
@available(macOS 10.15, iOS 13.0, *)
public protocol Event {
}
@available(macOS 10.15, iOS 13.0, *)
public protocol EventSource {
}
@available(macOS 10.15, iOS 13.0, *)
public enum SceneEvents {
  public struct Update : RealityKit.Event {
    public let scene: RealityKit.Scene
    public let deltaTime: Foundation.TimeInterval
  }
  public struct AnchoredStateChanged : RealityKit.Event {
    public let isAnchored: Swift.Bool
    public let anchor: RealityKit.HasAnchoring
  }
}
@available(macOS 10.15, iOS 13.0, *)
public enum AnimationEvents {
  public struct PlaybackCompleted : RealityKit.Event {
    public let playbackController: RealityKit.AnimationPlaybackController
  }
  public struct PlaybackLooped : RealityKit.Event {
    public let playbackController: RealityKit.AnimationPlaybackController
  }
  public struct PlaybackTerminated : RealityKit.Event {
    public let playbackController: RealityKit.AnimationPlaybackController
  }
}
@available(macOS 10.15, iOS 13.0, *)
public enum AudioEvents {
  public struct PlaybackCompleted : RealityKit.Event {
    public var playbackController: RealityKit.AudioPlaybackController
  }
}
@available(macOS 10.15, iOS 13.0, *)
public enum CollisionEvents {
  public struct Began : RealityKit.Event {
    public let entityA: RealityKit.Entity
    public let entityB: RealityKit.Entity
    public let position: Swift.SIMD3<Swift.Float>
    public let impulse: Swift.Float
  }
  public struct Updated : RealityKit.Event {
    public let entityA: RealityKit.Entity
    public let entityB: RealityKit.Entity
    public let position: Swift.SIMD3<Swift.Float>
    public let impulse: Swift.Float
  }
  public struct Ended : RealityKit.Event {
    public let entityA: RealityKit.Entity
    public let entityB: RealityKit.Entity
  }
}
@available(macOS 10.15, iOS 13.0, *)
public enum SynchronizationEvents {
  public struct OwnershipRequest : RealityKit.Event {
    public let entity: RealityKit.Entity
    public let requester: RealityKit.SynchronizationPeerID
    public let accept: () -> Swift.Void
  }
  public struct OwnershipChanged : RealityKit.Event {
    public let entity: RealityKit.Entity
    public let newOwner: RealityKit.SynchronizationPeerID?
  }
}
extension Scene {
  public func subscribe<E>(to event: E.Type, on sourceObject: RealityKit.EventSource? = nil, _ handler: @escaping (E) -> Swift.Void) -> Combine.Cancellable where E : RealityKit.Event
  public func publisher<E>(for event: E.Type, on sourceObject: RealityKit.EventSource? = nil) -> RealityKit.Scene.Publisher<E> where E : RealityKit.Event
}
extension Scene {
  public struct Publisher<E> : Combine.Publisher where E : RealityKit.Event {
    public typealias Output = E
    public typealias Failure = Swift.Never
    public func receive<S>(subscriber: S) where E == S.Input, S : Combine.Subscriber, S.Failure == RealityKit.Scene.Publisher<E>.Failure
  }
}
public struct __REAssetBundle {
  public static let __sdkBundleID: Swift.String
  public static let __sdkBundleVersionKey: Swift.String
  public static let __sdkBundleVersion: Swift.String
  public static let __sdkBundleVersionInvalid: Swift.String
  public static let __fileExtension: Swift.String
  public static var fileExtension: Swift.String {
    get
  }
  public struct Header : Swift.Codable {
    public struct VersionInfo : Swift.Codable {
      public func encode(to encoder: Swift.Encoder) throws
      public init(from decoder: Swift.Decoder) throws
    }
    public var versionInfo: RealityKit.__REAssetBundle.Header.VersionInfo
    public var minVersion: Swift.Int
    public var identifier: Foundation.UUID?
    public func encode(to encoder: Swift.Encoder) throws
    public init(from decoder: Swift.Decoder) throws
  }
  public var sceneAssets: [RealityKit.__REAsset] {
    get
  }
  public let __sceneAssets: [RealityKit.__REAsset]
  public var mainSceneAsset: RealityKit.__REAsset? {
    get
  }
  public var __mainSceneAsset: RealityKit.__REAsset? {
    get
  }
  public static func frameworkVersion(key: Swift.String) -> Swift.String
  public func mainSceneIdentifier() -> RealityKit.__REAssetIdentifier?
  public enum QueueOptions : Swift.Equatable {
    case fromEngineQueue
    case notFromEngineQueue(canUseEngineQueue: Swift.Bool)
    public static func == (a: RealityKit.__REAssetBundle.QueueOptions, b: RealityKit.__REAssetBundle.QueueOptions) -> Swift.Bool
  }
  public struct ExportOptions {
    public var queueOptions: RealityKit.__REAssetBundle.QueueOptions
    public var compressionLevel: Swift.Int?
    public var progress: Foundation.Progress?
    public var generateIdentifier: Swift.Bool
    public var deduplicateAssets: Swift.Bool
    public var __envelopeVersion: RealityKit.__AssetBundleEnvelopeVersion
    public init(queueOptions: RealityKit.__REAssetBundle.QueueOptions)
  }
  public struct LoadOptions {
    public var queueOptions: RealityKit.__REAssetBundle.QueueOptions
    @available(*, deprecated, message: "will be removed")
    public var materialDefinition: RealityKit.__REAssetBundle.__MaterialDefinitionOverride?
    public var downsamplingStrategy: RealityKit.__DownsamplingStrategy?
    public var performanceReport: RealityKit.__REArchivalStats?
    public init(queueOptions: RealityKit.__REAssetBundle.QueueOptions)
  }
  @available(*, deprecated, message: "will be removed")
  public struct __MaterialDefinitionOverride {
    public init(materialDefinition: Swift.String, serviceLocator: Swift.OpaquePointer)
  }
  public struct AssetMap : Swift.Codable {
    public struct SceneDescriptor : Swift.Codable, Swift.Equatable {
      public static func == (a: RealityKit.__REAssetBundle.AssetMap.SceneDescriptor, b: RealityKit.__REAssetBundle.AssetMap.SceneDescriptor) -> Swift.Bool
      public func encode(to encoder: Swift.Encoder) throws
      public init(from decoder: Swift.Decoder) throws
    }
    public var scenes: [RealityKit.__REAssetBundle.AssetMap.SceneDescriptor]
    public func encode(to encoder: Swift.Encoder) throws
    public init(from decoder: Swift.Decoder) throws
  }
  public var __temporaryUnarchivingURL: Foundation.URL?
  public static func __init(sceneAssets: [RealityKit.__REAsset], assetService: RealityKit.__REAssetService) throws -> RealityKit.__REAssetBundle
  public static func __init(sceneAssets: [RealityKit.__REAsset], assetService: RealityKit.__REAssetService, assetMapSceneDescriptorsByAsset: [RealityKit.__REAsset : RealityKit.__REAssetBundle.AssetMap.SceneDescriptor] = [:]) -> RealityKit.__REAssetBundle
  @available(*, deprecated, message: "Use __init(URL:__REAssetService:LoadOptions)")
  public init(url: Foundation.URL, assetService: RealityKit.__REAssetService, with queueOptions: RealityKit.__REAssetBundle.QueueOptions = .fromEngineQueue) throws
  public static func __init(url: Foundation.URL, assetService: RealityKit.__REAssetService, _ options: RealityKit.__REAssetBundle.LoadOptions) throws -> RealityKit.__REAssetBundle
  @available(*, deprecated, message: "Use __init(URL:__REAssetService:LoadOptions)")
  public static func __init(url: Foundation.URL, assetService: RealityKit.__REAssetService, materialDefinition: RealityKit.__REAssetBundle.__MaterialDefinitionOverride? = nil, with queueOptions: RealityKit.__REAssetBundle.QueueOptions = .fromEngineQueue) throws -> RealityKit.__REAssetBundle
  @available(*, deprecated, message: "will be moved to internal; use __init(URL:__REAssetService:LoadOptions)")
  public init(url: Foundation.URL, assetService: RealityKit.__REAssetService, downsamplingStrategy: RealityKit.__DownsamplingStrategy?, with options: RealityKit.__REAssetBundle.QueueOptions) throws
  @available(*, deprecated, message: "use load(url:assetService:completionHandler:) instead")
  public static func load(url: Foundation.URL, assetService: RealityKit.__REAssetService, materialDefinition: RealityKit.__REAssetBundle.__MaterialDefinitionOverride? = nil, completionHandler: @escaping (Swift.Result<RealityKit.__REAssetBundle, Swift.Error>) -> Swift.Void)
  public static func load(url: Foundation.URL, assetService: RealityKit.__REAssetService, completionHandler: @escaping (Swift.Result<RealityKit.__REAssetBundle, Swift.Error>) -> Swift.Void)
  public var sceneDescriptors: [RealityKit.__REAssetBundle.AssetMap.SceneDescriptor] {
    get
  }
  public func sceneAsset(for sceneDescriptor: RealityKit.__REAssetBundle.AssetMap.SceneDescriptor) -> RealityKit.__REAsset?
  public static var temporaryURL: Foundation.URL
  public func write(to url: Foundation.URL) throws
  public func __write(to url: Foundation.URL, fromEngineQueue: Swift.Bool = true) throws
  public func write(to url: Foundation.URL, with options: RealityKit.__REAssetBundle.ExportOptions) throws
  @available(*, deprecated, message: "use __write(to:with:) instead")
  public func __write(to url: Foundation.URL, with queueOptions: RealityKit.__REAssetBundle.QueueOptions, compressionLevel: Swift.Int? = 1, progress: Foundation.Progress? = nil) throws
  public func __write(to url: Foundation.URL, with options: RealityKit.__REAssetBundle.ExportOptions) throws
  public func __write(to url: Foundation.URL, completionHandler: @escaping (Swift.Error?) -> Swift.Void)
}
public enum __RealityFileError : Swift.Error, Swift.CustomDebugStringConvertible {
  case unsupportedVersion(Swift.Int)
  public var debugDescription: Swift.String {
    get
  }
}
public typealias __REArchivalStats = Swift.OpaquePointer
public typealias __REArchiveEnvelopeVersion = Swift.UInt8
public enum __AssetBundleEnvelopeVersion {
  case defaultVersion
  case specificVersion(versionNumber: RealityKit.__REArchiveEnvelopeVersion)
}
public struct __Archiving {
  public static func archivePackage(source: Foundation.URL, destination: Foundation.URL, envelopeVersion: RealityKit.__AssetBundleEnvelopeVersion, compressionLevel: Swift.Int? = nil, progress: Foundation.Progress? = nil) throws
  @available(*, deprecated, message: "will be removed")
  public static func unarchivePackage(source: Foundation.URL, destination: Foundation.URL) throws
  public static func unarchivePackage(source: Foundation.URL, destination: Foundation.URL, withReport report: RealityKit.__REArchivalStats? = nil) throws
  public enum ArchivingError : Swift.Error {
    case couldNotUnarchive
    case couldNotArchive
    public static func == (a: RealityKit.__Archiving.ArchivingError, b: RealityKit.__Archiving.ArchivingError) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
}
@available(macOS 10.15, iOS 13.0, *)
public struct ModelComponent : RealityKit.Component {
  public var mesh: RealityKit.MeshResource
  public var materials: [RealityKit.Material]
  public init(mesh: RealityKit.MeshResource, materials: [RealityKit.Material])
}
extension ModelComponent {
  public static func __fromCore(_ coreComponent: RealityKit.__ComponentRef) -> RealityKit.ModelComponent
  public func __toCore(_ coreComponent: RealityKit.__ComponentRef)
  public static var __coreComponentType: RealityKit.__ComponentTypeRef {
    get
  }
}
extension Entity {
  public struct ChildCollection : Swift.Collection {
    public typealias Element = RealityKit.Entity
    public typealias Index = Swift.Int
    public typealias Indices = Swift.DefaultIndices<RealityKit.Entity.ChildCollection>
    public typealias Iterator = RealityKit.Entity.ChildCollection.IndexingIterator<RealityKit.Entity.ChildCollection>
    public typealias SubSequence = Swift.Slice<RealityKit.Entity.ChildCollection>
    __consuming public func makeIterator() -> RealityKit.Entity.ChildCollection.Iterator
    public var startIndex: Swift.Int {
      get
    }
    public var endIndex: Swift.Int {
      get
    }
    public func index(after i: Swift.Int) -> Swift.Int
    public subscript(index: Swift.Int) -> RealityKit.Entity {
      get
      set
    }
    public func append(_ child: RealityKit.Entity, preservingWorldTransform: Swift.Bool = false)
    public func append(contentsOf array: [RealityKit.Entity], preservingWorldTransforms: Swift.Bool = false)
    public func append<S>(contentsOf sequence: S, preservingWorldTransforms: Swift.Bool = false) where S : Swift.Sequence, S.Element : RealityKit.Entity
    public func remove(_ child: RealityKit.Entity, preservingWorldTransform: Swift.Bool = false)
    public func remove(at index: Swift.Int, preservingWorldTransform: Swift.Bool = false)
    public func removeAll(keepCapacity: Swift.Bool = false, preservingWorldTransforms: Swift.Bool = false)
    public func removeAll(preservingWorldTransforms: Swift.Bool = false)
    public func replaceAll(_ children: [RealityKit.Entity], preservingWorldTransforms: Swift.Bool = false)
    public func replaceAll<S>(_ children: S, preservingWorldTransforms: Swift.Bool = false) where S : Swift.Sequence, S.Element : RealityKit.Entity
  }
}
extension Entity.ChildCollection : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
extension Entity.ChildCollection {
  public struct IndexingIterator<Elements> where Elements : Swift.Collection {
    public init(_elements: Elements)
    public init(_elements: Elements, _position: Elements.Index)
  }
}
extension Entity.ChildCollection.IndexingIterator : Swift.IteratorProtocol, Swift.Sequence {
  public typealias Element = Elements.Element
  public typealias Iterator = RealityKit.Entity.ChildCollection.IndexingIterator<Elements>
  public typealias SubSequence = Swift.AnySequence<RealityKit.Entity.ChildCollection.IndexingIterator<Elements>.Element>
  public mutating func next() -> Elements.Element?
}
@objc @_inheritsConvenienceInitializers @available(macOS 10.15, iOS 13.0, macCatalyst 14.0, *)
open class EntityScaleGestureRecognizer : UIKit.UIPinchGestureRecognizer, RealityKit.EntityGestureRecognizer {
  public var entity: RealityKit.HasCollision? {
    get
    set
  }
  @objc override dynamic open func touchesBegan(_ touches: Swift.Set<UIKit.UITouch>, with event: UIKit.UIEvent)
  @objc override dynamic open func canPrevent(_ preventedGestureRecognizer: UIKit.UIGestureRecognizer) -> Swift.Bool
  @objc override dynamic public init(target: Any?, action: ObjectiveC.Selector?)
  @objc deinit
}
@available(macOS 10.15, iOS 13.0, *)
public protocol HasDirectionalLight : RealityKit.HasTransform {
}
extension HasDirectionalLight {
  public var light: RealityKit.DirectionalLightComponent {
    get
    set
  }
  public var shadow: RealityKit.DirectionalLightComponent.Shadow? {
    get
    set
  }
}
@_inheritsConvenienceInitializers public class __RKEntityLookAtTrigger : RealityKit.__RKEntityTrigger {
  override public init()
  @objc deinit
}
extension Scene {
  public struct AnchorCollection : Swift.Collection {
    public typealias Element = RealityKit.HasAnchoring
    public typealias Index = Swift.Int
    public typealias Indices = Swift.DefaultIndices<RealityKit.Scene.AnchorCollection>
    public typealias Iterator = RealityKit.Entity.ChildCollection.IndexingIterator<RealityKit.Scene.AnchorCollection>
    public typealias SubSequence = Swift.Slice<RealityKit.Scene.AnchorCollection>
    __consuming public func makeIterator() -> RealityKit.Scene.AnchorCollection.Iterator
    public var startIndex: Swift.Int {
      get
    }
    public var endIndex: Swift.Int {
      get
    }
    public func index(after i: Swift.Int) -> Swift.Int
    public subscript(index: Swift.Int) -> RealityKit.Scene.AnchorCollection.Element {
      get
      set
    }
    public func append(_ entity: RealityKit.Scene.AnchorCollection.Element)
    public func append(contentsOf array: [RealityKit.Scene.AnchorCollection.Element])
    public func append<S>(contentsOf sequence: S) where S : Swift.Sequence, S.Element : RealityKit.HasAnchoring
    public func remove(_ entity: RealityKit.Scene.AnchorCollection.Element)
    public func remove(at index: Swift.Int)
    public func removeAll(keepCapacity: Swift.Bool = false)
    public func removeAll()
    public func replaceAll(_ entities: [RealityKit.Scene.AnchorCollection.Element])
    public func replaceAll<S>(_ entities: S) where S : Swift.Sequence, S.Element : RealityKit.HasAnchoring
  }
}
extension Scene.AnchorCollection : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
@_hasMissingDesignatedInitializers @available(macOS 10.15, iOS 13.0, *)
public class EnvironmentResource : RealityKit.Resource {
  public static let __compiledExtension: Swift.String
  @objc deinit
  public static func load(named name: Swift.String, in bundle: Foundation.Bundle? = nil) throws -> RealityKit.EnvironmentResource
  public static func loadAsync(named name: Swift.String, in bundle: Foundation.Bundle? = nil) -> RealityKit.LoadRequest<RealityKit.EnvironmentResource>
  public static func __load(contentsOf url: Foundation.URL, withName resourceName: Swift.String? = nil) throws -> RealityKit.EnvironmentResource
  public static func __fromAssets(_ coreIBLAsset: RealityKit.__AssetRef?, _ coreSkyboxAsset: RealityKit.__AssetRef?) -> RealityKit.EnvironmentResource
  public static func __exportCompiledResource(contentsOf inURL: Foundation.URL, to outURL: Foundation.URL) throws
}
extension Entity {
  public func generateCollisionShapes(recursive: Swift.Bool)
}
extension HasModel {
  public func __generateCollisionShape()
}
@_hasMissingDesignatedInitializers @available(macOS 10.15, iOS 13.0, *)
public class Scene {
  public var __coreScene: RealityKit.__SceneRef {
    get
  }
  public var name: Swift.String {
    get
  }
  public var __audioListener: RealityKit.Entity? {
    get
    set
  }
  public func __initAudioChannelCaptureUnit() -> AudioToolbox.AUAudioUnit
  public func __startAudioChannelCapture(auAudioUnit: AudioToolbox.AUAudioUnit, maxRecordingDurationInSeconds: Swift.Int)
  public func __stopAudioChannelCapture(auAudioUnit: AudioToolbox.AUAudioUnit) -> AVFAudio.AVAudioPCMBuffer
  @discardableResult
  public func __addPostProcessingAudioEffect(_ auDesc: AudioToolbox.AudioComponentDescription) -> AudioToolbox.AUAudioUnit?
  public var __defaultCamera: RealityKit.Entity! {
    get
  }
  public var __entities: [RealityKit.Entity] {
    get
  }
  public var anchors: RealityKit.Scene.AnchorCollection {
    get
    set
    _modify
  }
  public func addAnchor(_ anchor: RealityKit.HasAnchoring)
  public func removeAnchor(_ anchor: RealityKit.HasAnchoring)
  public static func __testInit(name: Swift.String) -> RealityKit.Scene
  @objc deinit
  public func findEntity(named name: Swift.String) -> RealityKit.Entity?
  public var __interactionService: RealityKit.__RKEntityInteractionService {
    get
  }
  public var synchronizationService: RealityKit.SynchronizationService? {
    get
    set
  }
}
extension Scene {
  public static func __fromCore(_ coreScene: RealityKit.__SceneRef) -> RealityKit.Scene
}
extension Scene : Swift.Hashable {
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (lhs: RealityKit.Scene, rhs: RealityKit.Scene) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
extension Scene : Swift.Identifiable {
  public var id: Swift.UInt64 {
    get
  }
  public typealias ID = Swift.UInt64
}
extension Scene : RealityKit.EventSource {
}
extension Scene {
  public var __corePointer: Swift.OpaquePointer {
    get
  }
}
extension ARView {
  public func project(_ point: Swift.SIMD3<Swift.Float>) -> CoreGraphics.CGPoint?
  public func unproject(_ point: CoreGraphics.CGPoint, viewport: CoreGraphics.CGRect) -> Swift.SIMD3<Swift.Float>?
  public func unproject(_ point: CoreGraphics.CGPoint, ontoPlane planeTransform: simd.float4x4) -> Swift.SIMD3<Swift.Float>?
  @available(macOS 11.0, iOS 14.0, *)
  public func unproject(_ point: CoreGraphics.CGPoint, ontoPlane planeTransform: simd.float4x4, relativeToCamera: Swift.Bool) -> Swift.SIMD3<Swift.Float>?
  public func ray(through screenPoint: CoreGraphics.CGPoint) -> (origin: Swift.SIMD3<Swift.Float>, direction: Swift.SIMD3<Swift.Float>)?
  public func hitTest(_ point: CoreGraphics.CGPoint, query: RealityKit.CollisionCastQueryType = .all, mask: RealityKit.CollisionGroup = .all) -> [RealityKit.CollisionCastHit]
  public func entity(at point: CoreGraphics.CGPoint) -> RealityKit.Entity?
  public func entities(at point: CoreGraphics.CGPoint) -> [RealityKit.Entity]
  public func hitTest(_ point: CoreGraphics.CGPoint, types: ARKit.ARHitTestResult.ResultType) -> [ARKit.ARHitTestResult]
  public func makeRaycastQuery(from point: CoreGraphics.CGPoint, allowing target: ARKit.ARRaycastQuery.Target, alignment: ARKit.ARRaycastQuery.TargetAlignment) -> ARKit.ARRaycastQuery?
  public func trackedRaycast(from point: CoreGraphics.CGPoint, allowing target: ARKit.ARRaycastQuery.Target, alignment: ARKit.ARRaycastQuery.TargetAlignment, updateHandler: @escaping ([ARKit.ARRaycastResult]) -> Swift.Void) -> ARKit.ARTrackedRaycast?
  public func raycast(from point: CoreGraphics.CGPoint, allowing target: ARKit.ARRaycastQuery.Target, alignment: ARKit.ARRaycastQuery.TargetAlignment) -> [ARKit.ARRaycastResult]
}
@_inheritsConvenienceInitializers public class __RKEntityAnimateAction : RealityKit.__RKEntityAction {
  override public func perform(with context: RealityKit.__RKEntityActionContext) -> Swift.Bool
  override public func stop() -> Swift.Bool
  override public func reversed() -> RealityKit.__RKEntityAction?
  @objc override public func copy(with zone: ObjectiveC.NSZone? = nil) -> Any
  override public init(targetEntity: RealityKit.Entity? = super)
  @objc deinit
}
public class __RKEntityStartAnimateAction : RealityKit.__RKEntityAnimateAction {
  public init(targetEntity: RealityKit.Entity?, loopCount: Swift.Int = 1, multiplePerformBehavior: RealityKit.__RKEntityActionMultiplePerformBehavior = .ignore, clipStart: Swift.Double = 0.0, clipDuration: Swift.Double = 0.0, clipReversed: Swift.Bool = false, animationSpeed: Swift.Float = 1.0, clipReverses: Swift.Bool = false, muteAudio: Swift.Bool = false, audioGain: Swift.Double = 1.0, targetAnimationEntity: RealityKit.Entity? = nil)
  override public func perform(with context: RealityKit.__RKEntityActionContext) -> Swift.Bool
  override public func reversed() -> RealityKit.__RKEntityAction?
  @objc override public func copy(with zone: ObjectiveC.NSZone? = nil) -> Any
  override public init(targetEntity: RealityKit.Entity? = super)
  @objc deinit
}
@_inheritsConvenienceInitializers public class __RKEntityStopAnimateAction : RealityKit.__RKEntityAnimateAction {
  override public func perform(with context: RealityKit.__RKEntityActionContext) -> Swift.Bool
  override public func reversed() -> RealityKit.__RKEntityAction?
  @objc override public func copy(with zone: ObjectiveC.NSZone? = nil) -> Any
  override public init(targetEntity: RealityKit.Entity? = super)
  @objc deinit
}
@_inheritsConvenienceInitializers public class __RKEntityToggleAnimateAction : RealityKit.__RKEntityAnimateAction {
  override public func perform(with context: RealityKit.__RKEntityActionContext) -> Swift.Bool
  override public func reversed() -> RealityKit.__RKEntityAction?
  @objc override public func copy(with zone: ObjectiveC.NSZone? = nil) -> Any
  override public init(targetEntity: RealityKit.Entity? = super)
  @objc deinit
}
@usableFromInline
internal typealias REMatrix2x2F = simd.simd_float2x2
@usableFromInline
internal typealias REMatrix3x3F = simd.simd_float3x3
@usableFromInline
internal typealias REMatrix4x4F = simd.simd_float4x4
extension simd_float3x3 {
  @inlinable internal init(_ matrix: RealityKit.REMatrix4x4F) {
        self = REMatrix3x3F(columns: (matrix[0]._xyz, matrix[1]._xyz, matrix[2]._xyz))
    }
}
extension simd_float4x4 {
  @inlinable internal static var identity: RealityKit.REMatrix4x4F {
    get { return REMatrix4x4F( diagonal: SIMD4<Float>(repeating: 1.0)) }
  }
  @inlinable internal init(rows: (Swift.SIMD4<Swift.Float>, Swift.SIMD4<Swift.Float>, Swift.SIMD4<Swift.Float>, Swift.SIMD4<Swift.Float>)) {
        self = simd_matrix_from_rows(rows.0, rows.1, rows.2, rows.3)
    }
  @inlinable internal init(rows r: ((Swift.Float, Swift.Float, Swift.Float, Swift.Float), (Swift.Float, Swift.Float, Swift.Float, Swift.Float), (Swift.Float, Swift.Float, Swift.Float, Swift.Float), (Swift.Float, Swift.Float, Swift.Float, Swift.Float))) {
        self = simd_matrix_from_rows(SIMD4<Float>(r.0.0, r.0.1, r.0.2, r.0.3),
                                     SIMD4<Float>(r.1.0, r.1.1, r.1.2, r.1.3),
                                     SIMD4<Float>(r.2.0, r.2.1, r.2.2, r.2.3),
                                     SIMD4<Float>(r.3.0, r.3.1, r.3.2, r.3.3))
    }
  @inlinable internal init(translation t: Swift.SIMD3<Swift.Float>) {
        self.init(columns: (SIMD4<Float>(1, 0, 0, 0),
                            SIMD4<Float>(0, 1, 0, 0),
                            SIMD4<Float>(0, 0, 1, 0),
                            SIMD4<Float>(t.x, t.y, t.z, 1)))
    }
  @inlinable internal init(scale s: Swift.SIMD3<Swift.Float>) {
        self.init(diagonal: SIMD4<Float>(s.x, s.y, s.z, 1))
    }
  @inlinable internal init(rotation: simd.simd_quatf) {
        self = simd_matrix4x4(rotation)
    }
  @inlinable internal init(translation: Swift.SIMD3<Swift.Float>, rotation: simd.simd_quatf, scale: Swift.SIMD3<Swift.Float>) {
        self = simd_matrix4x4(rotation)
        self.scale(scale)
        self.translate(translation)
    }
  @inlinable internal func scaled(_ scale: Swift.SIMD3<Swift.Float>) -> RealityKit.REMatrix4x4F {
        var m = self
        m.columns.0 *= scale.x
        m.columns.1 *= scale.y
        m.columns.2 *= scale.z
        return m
    }
  @inlinable internal func translated(_ trans: Swift.SIMD3<Swift.Float>) -> RealityKit.REMatrix4x4F {
        var m = self
        m.columns.3._xyz += trans
        return m
    }
  @inlinable internal mutating func scale(_ scale: Swift.SIMD3<Swift.Float>) {
        self.columns.0 *= scale.x
        self.columns.1 *= scale.y
        self.columns.2 *= scale.z
    }
  @inlinable internal mutating func translate(_ trans: Swift.SIMD3<Swift.Float>) {
        self.columns.3._xyz += trans
    }
  @inlinable internal var scale: Swift.SIMD3<Swift.Float> {
    get {
            let minor = matrix_float3x3(self)
            return SIMD3<Float>(simd.length(minor.columns.0),
                                simd.length(minor.columns.1),
                                simd.length(minor.columns.2))
        }
    set {
            self.columns.0._xyz = simd.normalize(self.columns.0._xyz)
            self.columns.1._xyz = simd.normalize(self.columns.1._xyz)
            self.columns.2._xyz = simd.normalize(self.columns.2._xyz)
            scale(newValue)
        }
  }
  @usableFromInline
  internal var rotation: simd.simd_quatf {
    get
    set
  }
  @inlinable internal var translation: Swift.SIMD3<Swift.Float> {
    get {
            return columns.3._xyz
        }
    set {
            columns.3._xyz = newValue
        }
  }
  @inlinable internal func decompose() -> (translation: Swift.SIMD3<Swift.Float>, rotation: simd.simd_quatf, scale: Swift.SIMD3<Swift.Float>) {
        return (translation, rotation, scale)
    }
}
public struct __RKScenePhysics {
  public var gravity: Swift.SIMD3<Swift.Float>
  public var adaptiveTimeStep: Swift.Bool
  @_hasMissingDesignatedInitializers public class Registration {
    final public let componentType: Swift.OpaquePointer
    @objc deinit
  }
  public static var registration: RealityKit.__RKScenePhysics.Registration?
}
extension Scene {
  public var __gravity: Swift.SIMD3<Swift.Float>? {
    get
    set
  }
  public var __adaptiveTimeStep: Swift.Bool? {
    get
    set
  }
}
@_inheritsConvenienceInitializers public class __RCEntity : RealityKit.Entity, RealityKit.HasAnchoring {
  public func invokeCustomTrigger(named name: Swift.String, overrides: [Swift.String : RealityKit.Entity]? = nil)
  public func registerCustomAction(named name: Swift.String, action: @escaping (RealityKit.Entity?) -> Swift.Void)
  required public init()
  @usableFromInline
  override internal init(_coreEntity: RealityKit.__EntityRef)
  @objc deinit
}
@available(macOS 10.15, iOS 13.0, *)
public struct PhysicsMotionComponent : RealityKit.Component, Swift.Equatable {
  public var linearVelocity: Swift.SIMD3<Swift.Float>
  public var angularVelocity: Swift.SIMD3<Swift.Float>
  public init()
  public init(linearVelocity: Swift.SIMD3<Swift.Float> = .zero, angularVelocity: Swift.SIMD3<Swift.Float> = .zero)
  public static func __fromCore(_ coreComponent: RealityKit.__ComponentRef) -> RealityKit.PhysicsMotionComponent
  public func __toCore(_ coreComponent: RealityKit.__ComponentRef)
  public static var __coreComponentType: RealityKit.__ComponentTypeRef {
    get
  }
  public static func == (a: RealityKit.PhysicsMotionComponent, b: RealityKit.PhysicsMotionComponent) -> Swift.Bool
}
@_inheritsConvenienceInitializers public class __RKTimerTrigger : RealityKit.__RKEntityTrigger {
  override public init()
  @objc deinit
}
public class __RKEntityFadeAction : RealityKit.__RKEntityAction {
  public init(targetEntity: RealityKit.Entity?, targetOpacity: Swift.Float, duration: Swift.Float)
  override public func perform(with context: RealityKit.__RKEntityActionContext) -> Swift.Bool
  override public func reversed() -> RealityKit.__RKEntityAction?
  @objc override public func copy(with zone: ObjectiveC.NSZone? = nil) -> Any
  override public init(targetEntity: RealityKit.Entity? = super)
  @objc deinit
}
public class __RKFadeSceneAction : RealityKit.__RKEntityAction {
  public init(targetOpacity: Swift.Float, duration: Swift.Float)
  override public func perform(with context: RealityKit.__RKEntityActionContext) -> Swift.Bool
  override public func reversed() -> RealityKit.__RKEntityAction?
  @objc override public func copy(with zone: ObjectiveC.NSZone? = nil) -> Any
  override public init(targetEntity: RealityKit.Entity? = super)
  @objc deinit
}
extension HasPhysicsBody {
  public func addForce(_ force: Swift.SIMD3<Swift.Float>, relativeTo referenceEntity: RealityKit.Entity?)
  public func addForce(_ force: Swift.SIMD3<Swift.Float>, at position: Swift.SIMD3<Swift.Float>, relativeTo referenceEntity: RealityKit.Entity?)
  public func addTorque(_ torque: Swift.SIMD3<Swift.Float>, relativeTo referenceEntity: RealityKit.Entity?)
  public func clearForcesAndTorques()
  public func applyLinearImpulse(_ impulse: Swift.SIMD3<Swift.Float>, relativeTo referenceEntity: RealityKit.Entity?)
  public func applyAngularImpulse(_ impulse: Swift.SIMD3<Swift.Float>, relativeTo referenceEntity: RealityKit.Entity?)
  public func applyImpulse(_ impulse: Swift.SIMD3<Swift.Float>, at position: Swift.SIMD3<Swift.Float>, relativeTo referenceEntity: RealityKit.Entity?)
}
@available(macOS 10.15, iOS 13.0, *)
public protocol HasCollision : RealityKit.HasTransform {
}
extension HasCollision {
  public var collision: RealityKit.CollisionComponent? {
    get
    set
  }
}
@available(macOS 10.15, iOS 13.0, macCatalyst 14.0, *)
public protocol HasAnchoring : RealityKit.Entity {
}
extension HasAnchoring {
  public var anchoring: RealityKit.AnchoringComponent {
    get
    set
  }
  public var anchorIdentifier: Foundation.UUID? {
    get
  }
  public func reanchor(_ target: RealityKit.AnchoringComponent.Target, preservingWorldTransform: Swift.Bool = true)
}
extension Entity {
  public var anchor: RealityKit.HasAnchoring? {
    get
  }
}
public enum __RKEntityAudioActionType : Swift.String, Swift.Codable {
  case play
  case pause
  case stop
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public enum __RKAudioSpatialModeSelection : Swift.String, Swift.Codable, Swift.CaseIterable {
  case pointSource
  case ambientBed
  case stereoBypass
  public init?(rawValue: Swift.String)
  public typealias AllCases = [RealityKit.__RKAudioSpatialModeSelection]
  public typealias RawValue = Swift.String
  public static var allCases: [RealityKit.__RKAudioSpatialModeSelection] {
    get
  }
  public var rawValue: Swift.String {
    get
  }
}
public class __RKEntityAudioAction : RealityKit.__RKEntityAction {
  final public let type: RealityKit.__RKEntityAudioActionType
  final public let path: Swift.String
  final public let volume: Swift.Double
  final public let loops: Swift.Bool
  final public let spatialMode: RealityKit.__RKAudioSpatialModeSelection
  public var __audioAssetRef: Swift.OpaquePointer? {
    get
  }
  public init(targetEntity: RealityKit.Entity?, type: RealityKit.__RKEntityAudioActionType, path: Swift.String, volume: Swift.Double, loops: Swift.Bool, spatialMode: RealityKit.__RKAudioSpatialModeSelection = .pointSource, multiplePerformBehavior: RealityKit.__RKEntityActionMultiplePerformBehavior = .ignore)
  @objc deinit
  override public func perform(with context: RealityKit.__RKEntityActionContext) -> Swift.Bool
  override public func reversed() -> RealityKit.__RKEntityAction?
  override public func stop() -> Swift.Bool
  override public func preloadAssets()
  @objc override public func copy(with zone: ObjectiveC.NSZone? = nil) -> Any
  override public init(targetEntity: RealityKit.Entity? = super)
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class __RKVisibilityShowMoveInAnimation : RealityKit.__RKVisibilityBaseAnimation {
  @objc deinit
}
extension __REAssetBundle {
  public func assetIdentifiers(forType: RealityKit.Resource.Type) -> [RealityKit.__REAssetIdentifier]
  public var sceneIdentifiers: [RealityKit.__REAssetIdentifier] {
    get
  }
  public func resource<T>(ofType: T.Type, identifier: RealityKit.__REAssetIdentifier) -> T? where T : RealityKit.Resource
  @discardableResult
  public func __add(resource: RealityKit.Resource) -> RealityKit.__REAssetIdentifier
  public func __renderGraphEmitter(identifier: RealityKit.__REAssetIdentifier) -> RealityKit.__RERenderGraphEmitter?
}
@_hasMissingDesignatedInitializers @available(macOS 10.15, iOS 13.0, *)
public class AnimationPlaybackController : Swift.Hashable {
  public var __identifier: RealityKit.__AnimationPlaybackTokenRef {
    get
  }
  weak public var entity: RealityKit.Entity? {
    get
  }
  public var isPaused: Swift.Bool {
    get
  }
  public var isComplete: Swift.Bool {
    get
  }
  public static func == (lhs: RealityKit.AnimationPlaybackController, rhs: RealityKit.AnimationPlaybackController) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public func pause()
  public func resume()
  public func stop()
  @objc deinit
  public var hashValue: Swift.Int {
    get
  }
}
extension Entity {
  public struct ComponentSet {
    public subscript<T>(componentType: T.Type) -> T? where T : RealityKit.Component {
      get
      set
    }
    public subscript(componentType: RealityKit.Component.Type) -> RealityKit.Component? {
      get
      set
    }
    public func set<T>(_ component: T) where T : RealityKit.Component
    public func set(_ components: [RealityKit.Component])
    public func has(_ componentType: RealityKit.Component.Type) -> Swift.Bool
    public func remove(_ componentType: RealityKit.Component.Type)
    public func removeAll()
    public var count: Swift.Int {
      get
    }
  }
}
public class __RKEntityLookupTable {
  public init()
  public func entity(for uuid: Foundation.UUID) -> RealityKit.Entity?
  public func uuid(for entity: RealityKit.Entity) -> Foundation.UUID?
  @discardableResult
  public func updateEntity(_ entity: RealityKit.Entity?, for uuid: Foundation.UUID) -> RealityKit.Entity?
  public func removeAllEntities()
  @objc deinit
}
@available(macOS 10.15, iOS 13.0, *)
open class Entity : RealityKit.HasHierarchy, RealityKit.HasSynchronization, RealityKit.HasTransform {
  public var __coreEntity: RealityKit.__EntityRef {
    get
  }
  public var components: RealityKit.Entity.ComponentSet {
    get
    set
  }
  public var scene: RealityKit.Scene? {
    get
  }
  public var name: Swift.String {
    get
    set
  }
  public var __boundingBox: RealityKit.__AABBRef {
    get
  }
  public var isActive: Swift.Bool {
    get
  }
  public var isAnchored: Swift.Bool {
    get
  }
  public var isEnabled: Swift.Bool {
    get
    set
  }
  public var isEnabledInHierarchy: Swift.Bool {
    get
  }
  public static var __disableUpdateInteractionEntities: [RealityKit.Entity]?
  required public init()
  @usableFromInline
  internal init(_coreEntity: RealityKit.__EntityRef)
  public static func __testInit() -> RealityKit.Entity
  @objc deinit
  open func didClone(from source: RealityKit.Entity)
  public func findEntity(named name: Swift.String) -> RealityKit.Entity?
}
extension Entity : Swift.Hashable {
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (lhs: RealityKit.Entity, rhs: RealityKit.Entity) -> Swift.Bool
  open var hashValue: Swift.Int {
    get
  }
}
extension Entity : Swift.Identifiable {
  public var id: Swift.UInt64 {
    get
  }
  public typealias ID = Swift.UInt64
}
extension Entity {
  public static func __fromCore(_ coreEntity: RealityKit.__EntityRef) -> RealityKit.Entity
}
extension Entity {
  public func clone(recursive: Swift.Bool) -> Self
  public func __clone(recursive: Swift.Bool, remapInteractionIdentifiers: Swift.Bool) -> Self
}
extension Entity : RealityKit.EventSource {
}
public class __RKEntityCollisionTrigger : RealityKit.__RKEntityTrigger {
  public init(targetEntity: RealityKit.Entity?, collidingEntities: [RealityKit.Entity] = [], tags: [Swift.String])
  override public func matches(with trigger: RealityKit.__RKEntityTrigger) -> Swift.Bool
  override public init()
  @objc deinit
}
public class __RKWaitAction : RealityKit.__RKEntityAction {
  public init(duration: Swift.Float, block: @escaping () -> Swift.Void = { })
  override public func perform(with context: RealityKit.__RKEntityActionContext) -> Swift.Bool
  override public func reversed() -> RealityKit.__RKEntityAction?
  @objc override public func copy(with zone: ObjectiveC.NSZone? = nil) -> Any
  override public init(targetEntity: RealityKit.Entity? = super)
  @objc deinit
}
extension MeshResource {
  public typealias Font = UIKit.UIFont
}
extension ARView : ARKit.ARSessionProviding {
  @objc dynamic public var session: ARKit.ARSession {
    @objc get
    @objc set
  }
  public enum CameraMode {
    case ar, nonAR
    public static func == (a: RealityKit.ARView.CameraMode, b: RealityKit.ARView.CameraMode) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public var cameraMode: RealityKit.ARView.CameraMode {
    get
    set
  }
  public var automaticallyConfigureSession: Swift.Bool {
    get
    set
  }
  public var __passthroughTextureY: Metal.MTLTexture? {
    get
  }
  public var __passthroughTextureCbCr: Metal.MTLTexture? {
    get
  }
  public var __passthroughCorrectionMatrix: simd.float4x4 {
    get
  }
  public var __passthroughIntensityExponent: Swift.Float {
    get
    set
  }
  public var __backgroundReplacementBuffer: CoreVideo.CVPixelBuffer? {
    get
    set
  }
  public var __enableUpdateCameraWorldMatrixFromARFrame: Swift.Bool {
    get
    set
  }
  public var __enableUpdateCameraProjectionMatrixFromARFrame: Swift.Bool {
    get
    set
  }
  public var __fallbackAmbientIntensity: Swift.Float {
    get
    set
  }
  public var __fallbackAmbientColor: RealityKit.PointLightComponent.Color {
    get
    set
  }
  public var __autoFireStartTriggerOnPlacement: Swift.Bool {
    get
    set
  }
  public func __enableRayTracedGroundingShadow()
  public func __disableRayTracedGroundingShadow()
  public static func __clusterSceneBoxes(sceneAABBs: inout [RealityKit.BoundingBox])
}
extension ARView {
  @discardableResult
  public func __occlusionEntity(for faceAnchor: ARKit.ARFaceAnchor) -> RealityKit.Entity?
  public func __removeOcclusionEntity(for faceAnchor: ARKit.ARFaceAnchor)
}
@_hasMissingDesignatedInitializers @available(macOS 10.15.4, iOS 13.4, macCatalyst 14.0, *)
public class __ARReferenceProvider : RealityKit.__ARReferenceProviding {
  @available(*, deprecated, message: "use the \"instance(for assetService: __REAssetService)\" instead")
  public static var shared: RealityKit.__ARReferenceProvider {
    get
  }
  public static func instance(for assetService: RealityKit.__REAssetService) -> RealityKit.__ARReferenceProvider
  public func supportsGroup(named group: Swift.String) -> Swift.Bool
  public func fetchReferenceObject(group: Swift.String, name: Swift.String) -> ARKit.ARReferenceObject?
  public func fetchReferenceImage(group: Swift.String, name: Swift.String, physicalWidth: CoreGraphics.CGFloat = 0.0) -> ARKit.ARReferenceImage?
  @objc deinit
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class __RKVisibilityShowPopAnimation : RealityKit.__RKVisibilityBaseAnimation {
  @objc deinit
}
@available(macOS 10.15, iOS 13.0, *)
public protocol HasPerspectiveCamera : RealityKit.HasTransform {
}
extension HasPerspectiveCamera {
  public var camera: RealityKit.PerspectiveCameraComponent {
    get
    set
  }
}
@_hasMissingDesignatedInitializers public class __RKEmphasisBaseAnimation {
  @objc deinit
}
@available(iOS 13.4, macCatalyst 14.0, *)
public protocol HasSceneUnderstanding : RealityKit.Entity {
}
@available(iOS 13.4, macCatalyst 14.0, *)
extension HasSceneUnderstanding {
  public var sceneUnderstanding: RealityKit.SceneUnderstandingComponent {
    get
  }
}
public class __RKEntityCustomAction : RealityKit.__RKEntityAction {
  public var handler: ((RealityKit.Entity?) -> Swift.Void)?
  final public let identifier: Swift.String
  final public let customArguments: [Swift.String : Swift.String]
  public var customArgumentsBlock: ((RealityKit.Entity?, [Swift.String : Swift.String]?) -> Swift.Void)?
  public init(targetEntity: RealityKit.Entity?, actionIdentifier: Swift.String, handler: ((RealityKit.Entity?) -> Swift.Void)? = nil, customArguments: [Swift.String : Swift.String]? = [:], customArgumentsBlock: ((RealityKit.Entity?, [Swift.String : Swift.String]?) -> Swift.Void)? = nil)
  override public func perform(with context: RealityKit.__RKEntityActionContext) -> Swift.Bool
  @objc override public func copy(with zone: ObjectiveC.NSZone? = nil) -> Any
  override public init(targetEntity: RealityKit.Entity? = super)
  @objc deinit
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class __RKEmphasisFloatAnimation : RealityKit.__RKEmphasisBaseAnimation {
  @objc deinit
}
@_hasMissingDesignatedInitializers @available(macOS 10.15, iOS 13.0, *)
public class PhysicsMaterialResource : RealityKit.Resource {
  public static var `default`: RealityKit.PhysicsMaterialResource
  @available(macOS 10.15.4, iOS 13.4, *)
  public var __staticFriction: Swift.Float {
    get
  }
  @available(macOS 10.15.4, iOS 13.4, *)
  public var __dynamicFriction: Swift.Float {
    get
  }
  @available(macOS 10.15.4, iOS 13.4, *)
  public var __restitution: Swift.Float {
    get
  }
  @objc deinit
  public static func generate(friction: Swift.Float = 0.8, restitution: Swift.Float = 0.8) -> RealityKit.PhysicsMaterialResource
  @available(macOS 10.15.4, iOS 13.4, *)
  public static func generate(staticFriction: Swift.Float, dynamicFriction: Swift.Float, restitution: Swift.Float) -> RealityKit.PhysicsMaterialResource
}
@available(macOS 10.15, iOS 13.0, *)
public protocol HasSpotLight : RealityKit.HasTransform {
}
extension HasSpotLight {
  public var light: RealityKit.SpotLightComponent {
    get
    set
  }
  public var shadow: RealityKit.SpotLightComponent.Shadow? {
    get
    set
  }
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class __RKEmphasisBounceAnimation : RealityKit.__RKEmphasisBaseAnimation {
  @objc deinit
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class __RKEmphasisJiggleAnimation : RealityKit.__RKEmphasisBaseAnimation {
  @objc deinit
}
@available(macOS 11.0, iOS 14.0, *)
extension Entity {
  public var isAccessibilityElement: Swift.Bool {
    get
    set
  }
  public var accessibilityLabel: Swift.String? {
    get
    set
  }
  public var accessibilityDescription: Swift.String? {
    get
    set
  }
}
@available(macOS 10.15.4, iOS 13.4, *)
extension Entity {
  public var __isAccessibilityRoot: Swift.Bool {
    get
    set
  }
  public var __isAccessibilityEnabled: Swift.Bool {
    get
    set
  }
  public var __accessibilityLabel: Swift.String? {
    get
    set
  }
  public var __accessibilityDescription: Swift.String? {
    get
    set
  }
  public func __accessibilityWrappers(rootEntityWrapper: RealityKit.__EntityAccessibilityWrapper? = nil) -> [RealityKit.__EntityAccessibilityWrapper]
  public func __calculateScreenBoundingRect(in arView: RealityKit.ARView) -> CoreGraphics.CGRect
}
@objc @_hasMissingDesignatedInitializers @available(macOS 10.15.4, iOS 13.4, *)
public class __EntityAccessibilityWrapper : ObjectiveC.NSObject {
  @objc override dynamic public init()
  @objc deinit
}
extension Entity {
  public static func load(named name: Swift.String, in bundle: Foundation.Bundle? = nil) throws -> RealityKit.Entity
  public static func loadAsync(named name: Swift.String, in bundle: Foundation.Bundle? = nil) -> RealityKit.LoadRequest<RealityKit.Entity>
  public static func __loadAsync(named name: Swift.String, in bundle: Foundation.Bundle?, generateDecimatedMesh: Swift.Bool) -> RealityKit.LoadRequest<RealityKit.Entity>
  public static func load(contentsOf url: Foundation.URL, withName resourceName: Swift.String? = nil) throws -> RealityKit.Entity
  public struct __LoadOptions {
    public var downsamplingStrategy: RealityKit.__DownsamplingStrategy?
    public var realityPerformanceReport: RealityKit.__REArchivalStats?
    public init(downsamplingStrategy: RealityKit.__DownsamplingStrategy? = nil, realityPerformanceReport: RealityKit.__REArchivalStats? = nil)
  }
  @available(*, deprecated, message: "deprecated; use __load(contentsOf:withName:loadOptions:) instead")
  public static func __load(contentsOf url: Foundation.URL, withName resourceName: Swift.String?, downsamplingStrategy: RealityKit.__DownsamplingStrategy?) throws -> RealityKit.Entity
  public static func __load(contentsOf url: Foundation.URL, withName resourceName: Swift.String?, loadOptions: RealityKit.Entity.__LoadOptions) throws -> RealityKit.Entity
  public static func loadAsync(contentsOf url: Foundation.URL, withName resourceName: Swift.String? = nil) -> RealityKit.LoadRequest<RealityKit.Entity>
  public static func __loadAsync(contentsOf url: Foundation.URL, withName resourceName: Swift.String? = nil, generateDecimatedMesh: Swift.Bool = false) -> RealityKit.LoadRequest<RealityKit.Entity>
  public static func loadAnchor(named name: Swift.String, in bundle: Foundation.Bundle? = nil) throws -> RealityKit.AnchorEntity
  public static func loadAnchorAsync(named name: Swift.String, in bundle: Foundation.Bundle? = nil) -> RealityKit.LoadRequest<RealityKit.AnchorEntity>
  public static func loadAnchor(contentsOf url: Foundation.URL, withName resourceName: Swift.String? = nil) throws -> RealityKit.AnchorEntity
  public static func __loadAnchor(contentsOf url: Foundation.URL, withName resourceName: Swift.String? = nil, downsamplingStrategy: RealityKit.__DownsamplingStrategy?) throws -> RealityKit.AnchorEntity
  public static func loadAnchorAsync(contentsOf url: Foundation.URL, withName resourceName: Swift.String? = nil) -> RealityKit.LoadRequest<RealityKit.AnchorEntity>
  public static func __loadAnchorAsync(contentsOf url: Foundation.URL, withName resourceName: Swift.String? = nil, downsamplingStrategy: RealityKit.__DownsamplingStrategy?) -> RealityKit.LoadRequest<RealityKit.AnchorEntity>
  public static func loadBodyTracked(named name: Swift.String, in bundle: Foundation.Bundle? = nil) throws -> RealityKit.BodyTrackedEntity
  public static func loadBodyTrackedAsync(named name: Swift.String, in bundle: Foundation.Bundle? = nil) -> RealityKit.LoadRequest<RealityKit.BodyTrackedEntity>
  public static func loadBodyTracked(contentsOf url: Foundation.URL, withName resourceName: Swift.String? = nil) throws -> RealityKit.BodyTrackedEntity
  public static func loadBodyTrackedAsync(contentsOf url: Foundation.URL, withName resourceName: Swift.String? = nil) -> RealityKit.LoadRequest<RealityKit.BodyTrackedEntity>
  public static func loadModel(named name: Swift.String, in bundle: Foundation.Bundle? = nil) throws -> RealityKit.ModelEntity
  public static func loadModelAsync(named name: Swift.String, in bundle: Foundation.Bundle? = nil) -> RealityKit.LoadRequest<RealityKit.ModelEntity>
  public static func __loadModelAsync(named name: Swift.String, in bundle: Foundation.Bundle? = nil, generateDecimatedMesh: Swift.Bool = false) -> RealityKit.LoadRequest<RealityKit.ModelEntity>
  public static func loadModel(contentsOf url: Foundation.URL, withName resourceName: Swift.String? = nil) throws -> RealityKit.ModelEntity
  public static func loadModelAsync(contentsOf url: Foundation.URL, withName resourceName: Swift.String? = nil) -> RealityKit.LoadRequest<RealityKit.ModelEntity>
  public static func __loadModelAsync(contentsOf url: Foundation.URL, withName resourceName: Swift.String?, generateDecimatedMesh: Swift.Bool) -> RealityKit.LoadRequest<RealityKit.ModelEntity>
  public static func __loadAllAsync(contentsOf url: Foundation.URL) -> RealityKit.LoadRequest<[RealityKit.Entity]>
  public static func __loadAllAsync(contentsOf url: Foundation.URL, downsamplingStrategy: RealityKit.__DownsamplingStrategy?) -> RealityKit.LoadRequest<[RealityKit.Entity]>
  public static func __remapIdentifiersAndInteractions(root: RealityKit.Entity)
}
@available(macOS 10.15.4, iOS 13.4, *)
extension __SceneResourceLoadResult {
  public func __makeEntity() throws -> RealityKit.Entity
  public func __makeAnchorEntity() throws -> RealityKit.Entity
}
extension __SceneImportOperation {
  final public func makeEntity() throws -> RealityKit.Entity
  final public func makeModelEntity() throws -> RealityKit.ModelEntity
  final public func makeBodyTrackedEntity() throws -> RealityKit.BodyTrackedEntity
}
@available(macOS 10.15, iOS 13.0, *)
@_fixed_layout public struct BoundingBox : Swift.Hashable {
  public static let empty: RealityKit.BoundingBox
  public var min: Swift.SIMD3<Swift.Float> = .positiveInfinity
  public var max: Swift.SIMD3<Swift.Float> = .negativeInfinity
  public init()
  public init(min: Swift.SIMD3<Swift.Float>, max: Swift.SIMD3<Swift.Float>)
  @inlinable public static func == (lhs: RealityKit.BoundingBox, rhs: RealityKit.BoundingBox) -> Swift.Bool {
        return lhs.min == rhs.min && lhs.max == rhs.max
    }
  @inlinable public func hash(into hasher: inout Swift.Hasher) {
        hasher.combine(min)
        hasher.combine(max)
    }
  public var hashValue: Swift.Int {
    get
  }
}
extension BoundingBox {
  public var center: Swift.SIMD3<Swift.Float> {
    get
  }
  public var extents: Swift.SIMD3<Swift.Float> {
    get
  }
  public var boundingRadius: Swift.Float {
    get
  }
  public var isEmpty: Swift.Bool {
    get
  }
  public func union(_ point: Swift.SIMD3<Swift.Float>) -> RealityKit.BoundingBox
  public mutating func formUnion(_ point: Swift.SIMD3<Swift.Float>)
  public func union(_ other: RealityKit.BoundingBox) -> RealityKit.BoundingBox
  public mutating func formUnion(_ other: RealityKit.BoundingBox)
  public func contains(_ point: Swift.SIMD3<Swift.Float>) -> Swift.Bool
  public func contains(_ boundingBox: RealityKit.BoundingBox) -> Swift.Bool
  public func intersects(_ boundingBox: RealityKit.BoundingBox) -> Swift.Bool
  public func transformed(by transform: simd.float4x4) -> RealityKit.BoundingBox
  public mutating func transform(by transform: simd.float4x4)
  public func distanceSquared(toPoint: Swift.SIMD3<Swift.Float>) -> Swift.Float
}
@_hasMissingDesignatedInitializers final public class __SceneResource {
  @objc deinit
  final public var coreHandle: RealityKit.__AssetRef {
    get
  }
  public static func fromCoreRetained(_ asset: RealityKit.__AssetRef) -> RealityKit.__SceneResource
  public static func fromCoreUnretained(_ asset: RealityKit.__AssetRef) -> RealityKit.__SceneResource
  final public func makeScene(named name: Swift.String) -> RealityKit.Scene?
}
@_hasMissingDesignatedInitializers @available(macOS 10.15, iOS 13.0, *)
public class ShapeResource : RealityKit.Resource, Swift.Hashable {
  @objc deinit
  public static func == (lhs: RealityKit.ShapeResource, rhs: RealityKit.ShapeResource) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension ShapeResource {
  public static func __makeShapeResource(_ shapes: [RealityKit.ShapeResource]) -> RealityKit.ShapeResource
  public func offsetBy(rotation: simd.simd_quatf) -> RealityKit.ShapeResource
  public func offsetBy(translation: Swift.SIMD3<Swift.Float>) -> RealityKit.ShapeResource
  public func offsetBy(rotation: simd.simd_quatf = simd_quatf(ix: 0, iy: 0, iz: 0, r: 1), translation: Swift.SIMD3<Swift.Float> = SIMD3<Float>()) -> RealityKit.ShapeResource
  public static func generateBox(size: Swift.SIMD3<Swift.Float>) -> RealityKit.ShapeResource
  public static func generateBox(width: Swift.Float, height: Swift.Float, depth: Swift.Float) -> RealityKit.ShapeResource
  public static func generateCapsule(height: Swift.Float, radius: Swift.Float) -> RealityKit.ShapeResource
  public static func generateConvex(from points: [Swift.SIMD3<Swift.Float>]) -> RealityKit.ShapeResource
  public static func generateConvex(from mesh: RealityKit.MeshResource) -> RealityKit.ShapeResource
  public static func generateSphere(radius: Swift.Float) -> RealityKit.ShapeResource
}
public protocol __RKEntityInteractionService : AnyObject {
  var areInteractionsEnabled: Swift.Bool { get set }
  var customTriggerIdentifiers: [Swift.String] { get }
  var customActionIdentifiers: [Swift.String] { get }
  @discardableResult
  func performInteractions(matchingCustomTriggerWithIdentifier customTriggerIdentifier: Swift.String, customArguments: [Swift.String : Swift.String]?, overrides: [Swift.String : RealityKit.Entity]?) -> Swift.Bool
  func setCustomActionHandler(for identifier: Swift.String, handler: ((RealityKit.Entity?) -> Swift.Void)?)
  @discardableResult
  func __performInteractions(matchingCustomTriggerWithIdentifier customTriggerIdentifier: Swift.String, with customArguments: [Swift.String : Swift.String], on elements: [RealityKit.Entity]?) -> Swift.Bool
  func __setCustomPackageActionHandler(withIdentifier identifier: Swift.String, actionHandler: ((RealityKit.Entity?, [Swift.String : Swift.String]?) -> Swift.Void)?)
  var automaticallyInvokesStartTrigger: Swift.Bool { get set }
}
@_hasMissingDesignatedInitializers public class __RKEntityInteractionManager : RealityKit.__RKEntityInteractionService {
  public var areInteractionsEnabled: Swift.Bool
  public var customTriggerIdentifiers: [Swift.String] {
    get
  }
  public var customActionIdentifiers: [Swift.String] {
    get
  }
  @discardableResult
  public func performInteractions(matchingCustomTriggerWithIdentifier customTriggerIdentifier: Swift.String, customArguments: [Swift.String : Swift.String]? = nil, overrides: [Swift.String : RealityKit.Entity]?) -> Swift.Bool
  public func setCustomActionHandler(for identifier: Swift.String, handler: ((RealityKit.Entity?) -> Swift.Void)?)
  @discardableResult
  public func __performInteractions(matchingCustomTriggerWithIdentifier customTriggerIdentifier: Swift.String, with customArguments: [Swift.String : Swift.String], on entities: [RealityKit.Entity]?) -> Swift.Bool
  public func __setCustomPackageActionHandler(withIdentifier identifier: Swift.String, actionHandler: ((RealityKit.Entity?, [Swift.String : Swift.String]?) -> Swift.Void)?)
  public var automaticallyInvokesStartTrigger: Swift.Bool
  public var __entityLookupTable: RealityKit.__RKEntityLookupTable
  public var __simulationSceneCoordinator: RealityKit.__RKSimulationSceneCoordinator
  public var __runtimeSceneCoordinator: RealityKit.__RKRuntimeSceneCoordinator
  public var __interactions: [RealityKit.__RKEntityInteraction] {
    get
  }
  public func __hasInteractionsForTrigger<T>(of objectType: T.Type) -> Swift.Bool where T : RealityKit.__RKEntityTrigger
  public var __actions: [RealityKit.__RKEntityAction] {
    get
  }
  public func __addInteraction(_ interaction: RealityKit.__RKEntityInteraction)
  public func __removeInteraction(_ interaction: RealityKit.__RKEntityInteraction)
  public func __removeAllInteractions()
  @discardableResult
  public func __performInteractions(matching trigger: RealityKit.__RKEntityTrigger, on entities: [RealityKit.Entity]? = nil) -> Swift.Bool
  public func action(for specification: RealityKit.__RKEntityActionSpecification) -> RealityKit.__RKEntityAction
  @objc deinit
}
extension __RKEntityInteraction {
  public static func interaction(for specification: RealityKit.__RKEntityInteractionSpecification, entityLookupTable: RealityKit.__RKEntityLookupTable) -> RealityKit.__RKEntityInteraction
}
extension __RKEntityTrigger {
  public static func trigger(for specification: RealityKit.__RKEntityTriggerSpecification, entityLookupTable: RealityKit.__RKEntityLookupTable) -> RealityKit.__RKEntityTrigger
}
extension __RKEntityAction {
  public static func action(for specification: RealityKit.__RKEntityActionSpecification, entityLookupTable: RealityKit.__RKEntityLookupTable) -> RealityKit.__RKEntityAction
}
@available(macOS 10.15, iOS 13.0, *)
public enum CollisionCastQueryType : Swift.Hashable {
  case nearest
  case all
  case any
  public static func == (a: RealityKit.CollisionCastQueryType, b: RealityKit.CollisionCastQueryType) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@available(macOS 10.15, iOS 13.0, *)
public struct CollisionGroup : Swift.OptionSet {
  public let rawValue: Swift.UInt32
  public static let `default`: RealityKit.CollisionGroup
  @available(iOS 13.4, *)
  public static let sceneUnderstanding: RealityKit.CollisionGroup
  public static let all: RealityKit.CollisionGroup
  public init(rawValue: Swift.UInt32)
  public typealias ArrayLiteralElement = RealityKit.CollisionGroup
  public typealias Element = RealityKit.CollisionGroup
  public typealias RawValue = Swift.UInt32
}
@available(macOS 10.15, iOS 13.0, *)
public struct CollisionFilter : Swift.Equatable {
  public static let `default`: RealityKit.CollisionFilter
  public static let sensor: RealityKit.CollisionFilter
  public var group: RealityKit.CollisionGroup
  public var mask: RealityKit.CollisionGroup
  public init(group: RealityKit.CollisionGroup, mask: RealityKit.CollisionGroup)
  public static func == (a: RealityKit.CollisionFilter, b: RealityKit.CollisionFilter) -> Swift.Bool
}
@available(macOS 10.15, iOS 13.0, *)
public struct CollisionCastHit : Swift.Equatable {
  public var entity: RealityKit.Entity {
    get
  }
  public var position: Swift.SIMD3<Swift.Float> {
    get
  }
  public var normal: Swift.SIMD3<Swift.Float> {
    get
  }
  public var distance: Swift.Float {
    get
  }
  public static func == (a: RealityKit.CollisionCastHit, b: RealityKit.CollisionCastHit) -> Swift.Bool
}
extension Scene {
  public func raycast(origin: Swift.SIMD3<Swift.Float>, direction: Swift.SIMD3<Swift.Float>, length: Swift.Float = 100, query: RealityKit.CollisionCastQueryType = .all, mask: RealityKit.CollisionGroup = .all, relativeTo referenceEntity: RealityKit.Entity? = nil) -> [RealityKit.CollisionCastHit]
  public func raycast(from startPosition: Swift.SIMD3<Swift.Float>, to endPosition: Swift.SIMD3<Swift.Float>, query: RealityKit.CollisionCastQueryType = .all, mask: RealityKit.CollisionGroup = .all, relativeTo referenceEntity: RealityKit.Entity? = nil) -> [RealityKit.CollisionCastHit]
  public func convexCast(convexShape: RealityKit.ShapeResource, fromPosition: Swift.SIMD3<Swift.Float>, fromOrientation: simd.simd_quatf, toPosition: Swift.SIMD3<Swift.Float>, toOrientation: simd.simd_quatf, query: RealityKit.CollisionCastQueryType = .all, mask: RealityKit.CollisionGroup = .all, relativeTo referenceEntity: RealityKit.Entity? = nil) -> [RealityKit.CollisionCastHit]
}
@available(macOS 10.15.4, iOS 13.4, *)
extension __RKEntityInteractionSpecification : RealityKit.__USDEncodablePublic {
  public func encode(to encoder: RealityKit.__USDEncoder, at pathName: RealityKit.__USKObjectPathWrapper) throws -> RealityKit.__USKNodeWrapper
  @available(*, deprecated)
  public func encode(to encoder: RealityKit.__USDEncoder, at pathName: RealityKit.__USKObjectPathWrapper, sceneSpecifier: RealityKit.__USKNodeSpecifierTypeWrapper) throws -> RealityKit.__USKNodeWrapper
}
@available(macOS 10.15.4, iOS 13.4, *)
extension __RKEntityTriggerSpecification : RealityKit.__USDEncodablePublic {
  public func encode(to encoder: RealityKit.__USDEncoder, at pathName: RealityKit.__USKObjectPathWrapper) throws -> RealityKit.__USKNodeWrapper
  @available(*, deprecated)
  public func encode(to encoder: RealityKit.__USDEncoder, at pathName: RealityKit.__USKObjectPathWrapper, sceneSpecifier: RealityKit.__USKNodeSpecifierTypeWrapper) throws -> RealityKit.__USKNodeWrapper
}
@available(macOS 10.15.4, iOS 13.4, *)
extension __RKEntityActionSpecification : RealityKit.__USDEncodablePublic {
  public func encode(to encoder: RealityKit.__USDEncoder, at pathName: RealityKit.__USKObjectPathWrapper) throws -> RealityKit.__USKNodeWrapper
  @available(*, deprecated)
  public func encode(to encoder: RealityKit.__USDEncoder, at pathName: RealityKit.__USKObjectPathWrapper, sceneSpecifier: RealityKit.__USKNodeSpecifierTypeWrapper) throws -> RealityKit.__USKNodeWrapper
}
extension ARView {
  @objc override dynamic open func didMoveToWindow()
}
public enum __RKEntitySpinDirectionType : Swift.String, Swift.Codable, Swift.CaseIterable {
  case clockwise
  case counterclockwise
  public init?(rawValue: Swift.String)
  public typealias AllCases = [RealityKit.__RKEntitySpinDirectionType]
  public typealias RawValue = Swift.String
  public static var allCases: [RealityKit.__RKEntitySpinDirectionType] {
    get
  }
  public var rawValue: Swift.String {
    get
  }
}
public class __RKEntitySpinAction : RealityKit.__RKEntityAction {
  public init(targetEntity: RealityKit.Entity?, duration: Swift.Float, iterations: Swift.Float = 1.0, direction: RealityKit.__RKEntitySpinDirectionType, axis: Swift.SIMD3<Swift.Float> = SIMD3<Float>(0,1,0))
  override public func perform(with context: RealityKit.__RKEntityActionContext) -> Swift.Bool
  override public func reversed() -> RealityKit.__RKEntityAction?
  @objc override public func copy(with zone: ObjectiveC.NSZone? = nil) -> Any
  override public init(targetEntity: RealityKit.Entity? = super)
  @objc deinit
}
@available(macOS 10.15, iOS 13.0, *)
public struct PerspectiveCameraComponent : RealityKit.Component, Swift.Equatable {
  public var near: Swift.Float
  public var far: Swift.Float
  public var fieldOfViewInDegrees: Swift.Float
  public init(near: Swift.Float = 0.01, far: Swift.Float = .infinity, fieldOfViewInDegrees: Swift.Float = 60.0)
  public static func == (a: RealityKit.PerspectiveCameraComponent, b: RealityKit.PerspectiveCameraComponent) -> Swift.Bool
}
extension PerspectiveCameraComponent {
  public static func __fromCore(_ coreComponent: RealityKit.__ComponentRef) -> RealityKit.PerspectiveCameraComponent
  public func __toCore(_ coreComponent: RealityKit.__ComponentRef)
  public static var __coreComponentType: RealityKit.__ComponentTypeRef {
    get
  }
}
public struct __EntityInfoComponent : RealityKit.Component, Swift.Codable {
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
  public static func __addIntrospectionData(_ builder: Swift.OpaquePointer?)
}
extension ARView {
  public var physicsOrigin: RealityKit.Entity? {
    get
    set
  }
}
@available(macOS 10.15, iOS 13.0, *)
public protocol HasPointLight : RealityKit.HasTransform {
}
extension HasPointLight {
  public var light: RealityKit.PointLightComponent {
    get
    set
  }
}
extension __REAssetBundle {
  public static func __init(element: RealityKit.Entity, assetService: RealityKit.__REAssetService) -> RealityKit.__REAssetBundle
  public static func __init(realityScenes: [RealityKit.Scene], assetService: RealityKit.__REAssetService) -> RealityKit.__REAssetBundle
  public static func loadSceneDescriptors(url: Foundation.URL) throws -> [RealityKit.__REAssetBundle.AssetMap.SceneDescriptor]
}
@_hasMissingDesignatedInitializers @available(macOS 10.15, iOS 13.0, *)
public class LoadRequest<Output> : Combine.Publisher {
  public typealias Failure = Swift.Error
  public var result: Swift.Result<Output, Swift.Error>? {
    get
  }
  public func subscribe<S>(_ subscriber: S) where Output == S.Input, S : Combine.Subscriber, S.Failure == Swift.Error
  @objc deinit
  public func receive<S>(subscriber: S) where Output == S.Input, S : Combine.Subscriber, S.Failure == RealityKit.LoadRequest<Output>.Failure
}
public struct __RKMaterialParameterBlock {
  public enum Parameter : Swift.ExpressibleByNilLiteral, Swift.ExpressibleByFloatLiteral, Swift.ExpressibleByIntegerLiteral {
    case texture(RealityKit.TextureResource)
    case float(Swift.Float)
    case float2(Swift.SIMD2<Swift.Float>)
    case float3(Swift.SIMD3<Swift.Float>)
    case float4(Swift.SIMD4<Swift.Float>)
    case float2x2(simd.float2x2)
    case float3x3(simd.float3x3)
    case float4x4(simd.float4x4)
    case `default`
    public init(nilLiteral: ())
    public init(floatLiteral value: Swift.Float)
    public init(integerLiteral value: Swift.Int)
    public typealias FloatLiteralType = Swift.Float
    public typealias IntegerLiteralType = Swift.Int
  }
  public enum TransparentPass : Swift.String, Swift.CaseIterable {
    case Transparent, TransparentAR, TransparentDynamicLighting, TransparentARDynamicLighting
    public init?(rawValue: Swift.String)
    public typealias AllCases = [RealityKit.__RKMaterialParameterBlock.TransparentPass]
    public typealias RawValue = Swift.String
    public static var allCases: [RealityKit.__RKMaterialParameterBlock.TransparentPass] {
      get
    }
    public var rawValue: Swift.String {
      get
    }
  }
  public enum OpaquePass : Swift.String, Swift.CaseIterable {
    case Opaque, OpaqueAR, OpaqueDynamicLighting, OpaqueARDynamicLighting, Shadow
    public init?(rawValue: Swift.String)
    public typealias AllCases = [RealityKit.__RKMaterialParameterBlock.OpaquePass]
    public typealias RawValue = Swift.String
    public static var allCases: [RealityKit.__RKMaterialParameterBlock.OpaquePass] {
      get
    }
    public var rawValue: Swift.String {
      get
    }
  }
  public let transparentPassTechniqueMapping: [(pass: RealityKit.__RKMaterialParameterBlock.TransparentPass, technique: Swift.String)]
  public var transparentPassTechniqueMappingEnabled: Swift.Bool {
    get
  }
  public mutating func setTransparentPassTechniqueMappingEnabled(_ enabled: Swift.Bool)
  public var parameters: [Swift.String : RealityKit.__RKMaterialParameterBlock.Parameter] {
    get
  }
  public mutating func set(parameter name: Swift.String, value: RealityKit.__RKMaterialParameterBlock.Parameter)
  public mutating func reset()
  public init()
  public init(transparentPassTechniqueMappping mapping: [(RealityKit.__RKMaterialParameterBlock.TransparentPass, Swift.String)])
  public static func __fromCore(_ coreComponent: RealityKit.__ComponentRef, index: Darwin.size_t) -> RealityKit.__RKMaterialParameterBlock
  public func __toCore(_ coreComponent: RealityKit.__ComponentRef, index: Darwin.size_t)
}
@available(macOS 10.15, iOS 13.0, *)
extension Entity {
  public enum __PackageTranslationError : Swift.Error {
    case noScenes(message: Swift.String)
    case noScenesMetadata(message: Swift.String)
    case failedToImportUSD(message: Swift.String, url: Foundation.URL)
    case invalidDictionary(message: Swift.String, invalidDictionary: [Swift.String : Any]?)
  }
  public static func __packageToRealityFile(packageURL: Foundation.URL, completion: @escaping (Swift.Result<Foundation.URL, Swift.Error>) -> Swift.Void)
}
@_hasMissingDesignatedInitializers final public class __SceneImportOperation {
  @available(macOS 10.15.4, iOS 13.4, *)
  public struct __ImportedScene {
    public let sceneIdentifier: Foundation.UUID
    public let sceneName: Swift.String
    public let sceneAsset: RealityKit.__REAsset
    public let sceneActive: Swift.Bool
  }
  @available(macOS 10.15.4, iOS 13.4, *)
  final public var __url: Foundation.URL? {
    get
  }
  @available(macOS 10.15.4, iOS 13.4, *)
  final public var __importedScenes: [RealityKit.__SceneImportOperation.__ImportedScene] {
    get
  }
  final public var __coreOperation: RealityKit.__SceneImportOperationRef {
    get
  }
  @objc deinit
  convenience public init(url: Foundation.URL, serviceLocator: RealityKit.__ServiceLocator)
  convenience public init?(bundle: Foundation.Bundle, resourceName: Swift.String, serviceLocator: RealityKit.__ServiceLocator)
  @discardableResult
  final public func setIsolateFromEngine(_ isolate: Swift.Bool) -> Self
  @discardableResult
  final public func setCompressTextures(_ compressTextures: Swift.Bool) -> Self
  @discardableResult
  final public func setMergeIntoSingleEntity(_ mergeEntities: Swift.Bool) -> Self
  @discardableResult
  final public func setPlayDefaultAnimationsImmediately(_ playImmediately: Swift.Bool) -> Self
  @discardableResult
  final public func setGenerateDecimatedMesh(_ decimateMesh: Swift.Bool) -> Self
  @discardableResult
  final public func setEnableAnimationInterpolation(_ enableInterpolation: Swift.Bool) -> Self
  @discardableResult
  final public func setRootSceneAssetPath(_ assetPath: Swift.String) -> Self
  @discardableResult
  final public func setMaterialDefinitionPath(_ materialDefinitionPath: Swift.String) -> Self
  @discardableResult
  final public func setApplyUnitConversionScale(_ applyScale: Swift.Bool) -> Self
  @discardableResult
  final public func setRetainSubdivisionSurfaceInfo(_ importSubdivisionSurfaces: Swift.Bool) -> Self
  final public func run() throws
  final public func publishToEngine() throws
  @available(macOS, deprecated: 10.15.4)
  @available(iOS, deprecated: 13.4)
  final public func getSceneResource() -> RealityKit.__SceneResource?
}
@available(iOS, introduced: 13.4, deprecated: 13.4, message: "Use the alternative that includes `actionAssets`")
@available(macOS, introduced: 10.15.4, deprecated: 10.15.4, message: "Use the alternative that includes `actionAssets`")
public func __SceneImportOperation_addCustomUSDDataToScene(uskNode: RealityKit.__USKNodeWrapper, uskScene: RealityKit.__USKSceneWrapper, scene: RealityKit.Scene, sceneIdentifier: Foundation.UUID, usdNodeToEntityMapping: [Swift.String : Swift.String], scenePathToUUIDMapping: [Swift.String : Foundation.UUID], fileName: Swift.String, error: Swift.UnsafeMutablePointer<Swift.Unmanaged<CoreFoundation.CFError>?>?) -> Swift.Bool
@available(macOS 10.15.4, iOS 13.4, *)
public func __SceneImportOperation_addCustomUSDDataToScene(uskNode: RealityKit.__USKNodeWrapper, uskScene: RealityKit.__USKSceneWrapper, scene: RealityKit.Scene, sceneIdentifier: Foundation.UUID, usdNodeToEntityMapping: [Swift.String : Swift.String], scenePathToUUIDMapping: [Swift.String : Foundation.UUID], actionAssets: [Swift.String : Swift.String], fileName: Swift.String) -> Swift.Error?
@available(macOS 10.15, iOS 13.0, *)
public enum PhysicsBodyMode : Swift.Hashable {
  case `static`
  case kinematic
  case dynamic
  public static func == (a: RealityKit.PhysicsBodyMode, b: RealityKit.PhysicsBodyMode) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@available(macOS 10.15, iOS 13.0, *)
public struct PhysicsMassProperties : Swift.Equatable {
  public static let `default`: RealityKit.PhysicsMassProperties
  public var mass: Swift.Float
  public var inertia: Swift.SIMD3<Swift.Float>
  public var centerOfMass: (position: Swift.SIMD3<Swift.Float>, orientation: simd.simd_quatf)
  public init()
  public init(mass: Swift.Float, inertia: Swift.SIMD3<Swift.Float> = SIMD3<Float>(x: 0.1, y: 0.1, z: 0.1), centerOfMass: (position: Swift.SIMD3<Swift.Float>, orientation: simd.simd_quatf) = (SIMD3<Float>(x: 0, y: 0, z: 0), simd_quatf(ix: 0, iy: 0, iz: 0, r: 1)))
  public init(shape: RealityKit.ShapeResource, density: Swift.Float)
  public init(shape: RealityKit.ShapeResource, mass: Swift.Float)
  public static func == (lhs: RealityKit.PhysicsMassProperties, rhs: RealityKit.PhysicsMassProperties) -> Swift.Bool
}
public class __RKEntityForceAction : RealityKit.__RKEntityAction {
  public var force: Swift.SIMD3<Swift.Float>? {
    get
  }
  public var velocity: Swift.SIMD3<Swift.Float>? {
    get
  }
  public init(targetEntity: RealityKit.Entity?, force: Swift.SIMD3<Swift.Float>? = nil, velocity: Swift.SIMD3<Swift.Float>? = nil)
  override public func perform(with context: RealityKit.__RKEntityActionContext) -> Swift.Bool
  @objc override public func copy(with zone: ObjectiveC.NSZone? = nil) -> Any
  override public init(targetEntity: RealityKit.Entity? = super)
  @objc deinit
}
extension Entity {
  @discardableResult
  public func playAnimation(named animationName: Swift.String, transitionDuration: Foundation.TimeInterval = 0, startsPaused: Swift.Bool = false, recursive: Swift.Bool = true) -> RealityKit.AnimationPlaybackController
  @discardableResult
  public func playAnimation(_ animation: RealityKit.AnimationResource, transitionDuration: Foundation.TimeInterval = 0, startsPaused: Swift.Bool = false) -> RealityKit.AnimationPlaybackController
  public func stopAllAnimations(recursive: Swift.Bool = true)
}
@usableFromInline
internal struct REAngleF {
  public init(radians: Swift.Float)
  public init(degrees: Swift.Float)
  public var radians: Swift.Float
  @inlinable public var degrees: Swift.Float {
    get {
            return radians * 180 / .pi
        }
    set {
            radians = newValue * .pi / 180
        }
  }
}
@usableFromInline
internal enum RotationOrder : Swift.UInt8 {
  public static let `default`: RealityKit.RotationOrder
  public static let sceneKit: RealityKit.RotationOrder
  case xyz
  case yzx
  case zxy
  case xzy
  case yxz
  case zyx
  @usableFromInline
  internal init?(rawValue: Swift.UInt8)
  @usableFromInline
  internal typealias RawValue = Swift.UInt8
  @usableFromInline
  internal var rawValue: Swift.UInt8 {
    @usableFromInline
    get
  }
}
extension simd_quatf {
  @usableFromInline
  internal init(eulerAngles: Swift.SIMD3<Swift.Float>, order: RealityKit.RotationOrder = .default)
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class __RKVisibilityHideScaleAnimation : RealityKit.__RKVisibilityBaseAnimation {
  @objc deinit
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class __RKVisibilityHideScaleUpAnimation : RealityKit.__RKVisibilityBaseAnimation {
  @objc deinit
}
@available(macOS 10.15.4, iOS 13.4, *)
public struct __USDExportContext {
  public typealias AssetResolverCallback = (Foundation.URL) throws -> Foundation.URL?
  @_hasMissingDesignatedInitializers public class InstanceMapper {
    public func addMapping(from: Foundation.UUID?, to: RealityKit.__USKObjectPathWrapper)
    public func getMapping(_ from: Foundation.UUID) -> RealityKit.__USKObjectPathWrapper?
    @objc deinit
  }
  public var instanceMapper: RealityKit.__USDExportContext.InstanceMapper
  @available(*, deprecated, message: "Use init(with:resolver:)")
  public init?(with scene: RealityKit.__USKSceneWrapper)
  public init?(with scene: RealityKit.__USKSceneWrapper, resolver: RealityKit.__USDExportContext.AssetResolverCallback?)
}
@available(macOS 10.15.4, iOS 13.4, *)
public struct __USKSceneWrapper {
  public let erasedValue: Any
  public init<T>(_ value: T)
}
@available(macOS 10.15.4, iOS 13.4, *)
public struct __USKNodeWrapper {
  public let erasedValue: Any
  public init<T>(_ value: T)
}
@available(macOS 10.15.4, iOS 13.4, *)
public struct __USKObjectPathWrapper {
  public let erasedValue: Any
  public init<T>(_ value: T)
}
@available(macOS 10.15.4, iOS 13.4, *)
public struct __USKNodeSpecifierTypeWrapper {
  public let erasedValue: Any
  public init<T>(_ value: T)
}
@available(macOS 10.15.4, iOS 13.4, *)
public protocol __USDEncodablePublic {
  func encode(to encoder: RealityKit.__USDEncoder, at parentPath: RealityKit.__USKObjectPathWrapper) throws -> RealityKit.__USKNodeWrapper
  @available(*, deprecated)
  func encode(to encoder: RealityKit.__USDEncoder, at parentPath: RealityKit.__USKObjectPathWrapper, sceneSpecifier: RealityKit.__USKNodeSpecifierTypeWrapper) throws -> RealityKit.__USKNodeWrapper
}
@available(macOS 10.15.4, iOS 13.4, *)
public struct __USDEncoder {
  public var exportContext: RealityKit.__USDExportContext
  public init(exportContext: RealityKit.__USDExportContext)
}
@_hasMissingDesignatedInitializers @available(macOS 10.15, iOS 13.0, *)
public class AnimationResource : RealityKit.Resource {
  public var __coreAsset: RealityKit.__AssetRef {
    get
  }
  final public let name: Swift.String?
  @objc deinit
}
extension AnimationResource {
  public func `repeat`(duration: Foundation.TimeInterval = .infinity) -> RealityKit.AnimationResource
  public func `repeat`(count: Swift.Int) -> RealityKit.AnimationResource
}
extension Scene {
}
@_inheritsConvenienceInitializers public class __RKStartTrigger : RealityKit.__RKEntityTrigger {
  override public init()
  override public func matches(with trigger: RealityKit.__RKEntityTrigger) -> Swift.Bool
  @objc deinit
}
@_hasMissingDesignatedInitializers @available(macOS 10.15, iOS 13.0, *)
public class MeshResource : RealityKit.Resource {
  public var expectedMaterialCount: Swift.Int {
    get
  }
  public var bounds: RealityKit.BoundingBox {
    get
  }
  @objc deinit
  public static func __load(named name: Swift.String, in bundle: Foundation.Bundle? = nil) throws -> RealityKit.MeshResource
  public static func generateBox(size: Swift.Float, cornerRadius: Swift.Float = 0) -> RealityKit.MeshResource
  public static func generateBox(size: Swift.SIMD3<Swift.Float>, cornerRadius: Swift.Float = 0) -> RealityKit.MeshResource
  public static func generateBox(width: Swift.Float, height: Swift.Float, depth: Swift.Float, cornerRadius: Swift.Float = 0, splitFaces: Swift.Bool = false) -> RealityKit.MeshResource
  public static func generatePlane(width: Swift.Float, height: Swift.Float, cornerRadius: Swift.Float = 0) -> RealityKit.MeshResource
  public static func generatePlane(width: Swift.Float, depth: Swift.Float, cornerRadius: Swift.Float = 0) -> RealityKit.MeshResource
  public static func __generatePlane(width: Swift.Float = 1, widthSegmentCount: Swift.UInt = 1, depth: Swift.Float = 1, depthSegmentCount: Swift.UInt = 1, cornerRadius: Swift.Float = 0, cornerSegmentCount: Swift.UInt = 0, addUVs: Swift.Bool = true, addNormals: Swift.Bool = true) -> RealityKit.MeshResource
  public static func __generateOccluderPlane(width: Swift.Float, depth: Swift.Float, cornerRadius: Swift.Float = 0) -> RealityKit.MeshResource
  public static func generateSphere(radius: Swift.Float) -> RealityKit.MeshResource
  public static func generateText(_ string: Swift.String, extrusionDepth: Swift.Float = 0.25, font: RealityKit.MeshResource.Font = .systemFont(ofSize: MeshResource.Font.systemFontSize), containerFrame: CoreGraphics.CGRect = CGRect.zero, alignment: CoreText.CTTextAlignment = .left, lineBreakMode: CoreText.CTLineBreakMode = .byTruncatingTail) -> RealityKit.MeshResource
  public static func __generateText(_ string: Swift.String, extrusionDepth: Swift.Float = 0.25, font: RealityKit.MeshResource.Font = .systemFont(ofSize: MeshResource.Font.systemFontSize), containerFrame: CoreGraphics.CGRect = CGRect.zero, alignment: CoreText.CTTextAlignment = .left, lineBreakMode: CoreText.CTLineBreakMode = .byTruncatingTail, segmentCount: Swift.UInt8 = 6) -> RealityKit.MeshResource
}
@_hasMissingDesignatedInitializers final public class __MeshCompileOptions {
  final public var coreOptions: Swift.OpaquePointer {
    get
  }
  public init()
  @objc deinit
  final public var generateVertexFaceAdjacencyAttributes: Swift.Bool {
    get
    set
  }
  final public var reorderVertexCaching: Swift.Bool {
    get
    set
  }
  final public var repairTangents: Swift.Bool {
    get
    set
  }
  final public var mergeVerticesIfPolygonSoup: Swift.Bool {
    get
    set
  }
  final public var preserveSharpFeatures: Swift.Bool {
    get
    set
  }
  final public var preserveSubdivisonSurfaceData: Swift.Bool {
    get
    set
  }
  final public var generateDecimatedMesh: Swift.Bool {
    get
    set
  }
}
@available(macOS 10.15, iOS 13.0, *)
public struct CollisionComponent : RealityKit.Component, Swift.Equatable {
  public enum Mode {
    case `default`
    case trigger
    public static func == (a: RealityKit.CollisionComponent.Mode, b: RealityKit.CollisionComponent.Mode) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public var shapes: [RealityKit.ShapeResource]
  public var mode: RealityKit.CollisionComponent.Mode
  public var filter: RealityKit.CollisionFilter
  public init(shapes: [RealityKit.ShapeResource], mode: RealityKit.CollisionComponent.Mode = .default, filter: RealityKit.CollisionFilter = .default)
  public static func __fromCore(_ coreComponent: RealityKit.__ComponentRef) -> RealityKit.CollisionComponent
  public func __toCore(_ coreComponent: RealityKit.__ComponentRef)
  public static var __coreComponentType: RealityKit.__ComponentTypeRef {
    get
  }
  public static func == (a: RealityKit.CollisionComponent, b: RealityKit.CollisionComponent) -> Swift.Bool
}
@available(macOS 10.15, iOS 13.0, macCatalyst 14.0, *)
public struct AnchoringComponent : RealityKit.Component, Swift.Equatable {
  public enum Target : Swift.Hashable {
    public struct Alignment : Swift.OptionSet {
      public static let horizontal: RealityKit.AnchoringComponent.Target.Alignment
      public static let vertical: RealityKit.AnchoringComponent.Target.Alignment
      public static let any: RealityKit.AnchoringComponent.Target.Alignment
      public let rawValue: Swift.UInt8
      public init(rawValue: Swift.UInt8)
      public typealias ArrayLiteralElement = RealityKit.AnchoringComponent.Target.Alignment
      public typealias Element = RealityKit.AnchoringComponent.Target.Alignment
      public typealias RawValue = Swift.UInt8
    }
    public struct Classification : Swift.OptionSet {
      public static let wall: RealityKit.AnchoringComponent.Target.Classification
      public static let floor: RealityKit.AnchoringComponent.Target.Classification
      public static let ceiling: RealityKit.AnchoringComponent.Target.Classification
      public static let table: RealityKit.AnchoringComponent.Target.Classification
      public static let seat: RealityKit.AnchoringComponent.Target.Classification
      public static let any: RealityKit.AnchoringComponent.Target.Classification
      public let rawValue: Swift.UInt64
      public init(rawValue: Swift.UInt64)
      public typealias ArrayLiteralElement = RealityKit.AnchoringComponent.Target.Classification
      public typealias Element = RealityKit.AnchoringComponent.Target.Classification
      public typealias RawValue = Swift.UInt64
    }
    case camera
    case world(transform: simd.float4x4)
    case anchor(identifier: Foundation.UUID)
    case plane(_: RealityKit.AnchoringComponent.Target.Alignment, classification: RealityKit.AnchoringComponent.Target.Classification, minimumBounds: Swift.SIMD2<Swift.Float>)
    case image(group: Swift.String, name: Swift.String)
    case object(group: Swift.String, name: Swift.String)
    case face
    case body
    public static func == (lhs: RealityKit.AnchoringComponent.Target, rhs: RealityKit.AnchoringComponent.Target) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public let target: RealityKit.AnchoringComponent.Target
  public init(_ target: RealityKit.AnchoringComponent.Target)
  public init(_ anchor: ARKit.ARAnchor)
  public func __toCore(_ component: RealityKit.__ComponentRef)
  public static func __fromCore(_ coreComponent: RealityKit.__ComponentRef) -> RealityKit.AnchoringComponent
  public static var __coreComponentType: RealityKit.__ComponentTypeRef {
    get
  }
  public static func == (a: RealityKit.AnchoringComponent, b: RealityKit.AnchoringComponent) -> Swift.Bool
}
@available(macOS 10.15, iOS 13.0, *)
public protocol HasPhysicsBody : RealityKit.HasCollision {
}
@available(macOS 10.15, iOS 13.0, *)
public protocol HasPhysicsMotion : RealityKit.Entity {
}
@available(macOS 10.15, iOS 13.0, *)
public protocol HasPhysics : RealityKit.HasPhysicsBody, RealityKit.HasPhysicsMotion {
}
extension HasPhysicsBody {
  public var physicsBody: RealityKit.PhysicsBodyComponent? {
    get
    set
  }
}
extension HasPhysicsMotion {
  public var physicsMotion: RealityKit.PhysicsMotionComponent? {
    get
    set
  }
}
extension HasPhysicsBody {
  @available(*, deprecated, message: "Will be hidden in RealityKit 2019.")
  public func resetPhysicsTransform(_ transform: RealityKit.Transform, recursive: Swift.Bool = true)
  public func resetPhysicsTransform(recursive: Swift.Bool = true)
}
@available(macOS 10.15, iOS 13.0, macCatalyst 14.0, *)
public protocol HasBodyTracking : RealityKit.HasTransform {
}
extension HasBodyTracking {
  public var bodyTracking: RealityKit.BodyTrackingComponent {
    get
    set
  }
}
@available(macOS 10.15, iOS 13.0, macCatalyst 14.0, *)
public struct BodyTrackingComponent : RealityKit.Component, Swift.Equatable {
  public enum Target : Swift.Hashable {
    case any
    case body(identifier: Foundation.UUID)
    public static func == (lhs: RealityKit.BodyTrackingComponent.Target, rhs: RealityKit.BodyTrackingComponent.Target) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public var target: RealityKit.BodyTrackingComponent.Target
  public var isPaused: Swift.Bool
  public init()
  public init(_ target: RealityKit.BodyTrackingComponent.Target)
  public static func __fromCore(_ coreComponent: RealityKit.__ComponentRef) -> RealityKit.BodyTrackingComponent
  public func __toCore(_ component: RealityKit.__ComponentRef)
  public static var __coreComponentType: RealityKit.__ComponentTypeRef {
    get
  }
  public static func == (a: RealityKit.BodyTrackingComponent, b: RealityKit.BodyTrackingComponent) -> Swift.Bool
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class __RKVisibilityHideDropAnimation : RealityKit.__RKVisibilityBaseAnimation {
  @objc deinit
}
@_hasMissingDesignatedInitializers public class __ServiceLocator {
  public static var __sharedEngine: RealityKit.__Engine! {
    get
    set
  }
  public static var hasSharedServiceLocator: Swift.Bool {
    get
  }
  public static var shared: RealityKit.__ServiceLocator {
    get
  }
  public static func __createSharedIfNeeded(with configuration: RealityKit.__Engine.Configuration)
  public var __engineRef: RealityKit.__EngineRef {
    get
  }
  unowned public var engine: RealityKit.__Engine
  public var __renderService: RealityKit.__RenderService {
    get
  }
  public var __sceneService: RealityKit.__SceneService {
    get
  }
  public var __assetService: RealityKit.__REAssetService {
    get
  }
  @objc deinit
}
@available(macOS 10.15, iOS 13.0, *)
@_fixed_layout public struct Transform : RealityKit.Component, Swift.Hashable {
  public static let identity: RealityKit.Transform
  public var scale: Swift.SIMD3<Swift.Float> = .one
  public var rotation: simd.simd_quatf = .identity
  public var translation: Swift.SIMD3<Swift.Float> = .zero
  public var __coreSRT: RealityKit.__SRTRef {
    get
  }
  @inlinable public var matrix: simd.float4x4 {
    get {
            let reMatrix = REMatrix4x4F(translation: translation, rotation: rotation, scale: scale)
            return reMatrix
        }
    set {
            let reMatrix = newValue as REMatrix4x4F
            scale = reMatrix.scale
            rotation = reMatrix.rotation
            translation = reMatrix.translation
        }
  }
  public init()
  @inlinable public init(scale: Swift.SIMD3<Swift.Float> = SIMD3<Float>(x: 1, y: 1, z: 1), rotation: simd.simd_quatf = simd_quaternion(0, 0, 0, 1), translation: Swift.SIMD3<Swift.Float> = SIMD3<Float>(x: 0, y: 0, z: 0)) {
        self.scale = scale
        self.rotation = rotation
        self.translation = translation
    }
  @inlinable public init(pitch x: Swift.Float = 0, yaw y: Swift.Float = 0, roll z: Swift.Float = 0) {
        let angles = SIMD3<Float>(x, y, z)
        self.init(scale: .one,
                  rotation: simd_quatf(eulerAngles: angles, order: .yxz),
                  translation: .zero)
    }
  public init(matrix: simd.float4x4)
  @inlinable public func hash(into hasher: inout Swift.Hasher) {
        hasher.combine(scale)
        hasher.combine(rotation.vector)
        hasher.combine(translation)
    }
  public static func == (a: RealityKit.Transform, b: RealityKit.Transform) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
extension Transform {
  public static func __fromCore(_ coreSRT: RealityKit.__SRTRef) -> RealityKit.Transform
  public static func __fromCore(_ coreComponent: RealityKit.__ComponentRef) -> RealityKit.Transform
  public func __toCore(_ coreComponent: RealityKit.__ComponentRef)
  public static var __coreComponentType: RealityKit.__ComponentTypeRef {
    get
  }
}
@_hasMissingDesignatedInitializers public class __VideoResource : RealityKit.Resource {
  public static func __fromCore(_ coreAsset: RealityKit.__AssetRef) -> Self
  @objc deinit
  public static func load(named name: Swift.String, in bundle: Foundation.Bundle? = nil) throws -> RealityKit.__VideoResource
}
@_hasMissingDesignatedInitializers @available(macOS 10.15, iOS 13.0, *)
public class AudioResource : RealityKit.Resource {
  @objc deinit
  public enum InputMode {
    case nonSpatial
    case spatial
    case ambient
    public static func == (a: RealityKit.AudioResource.InputMode, b: RealityKit.AudioResource.InputMode) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public var inputMode: RealityKit.AudioResource.InputMode {
    get
    set
  }
}
@_hasMissingDesignatedInitializers @available(macOS 10.15, iOS 13.0, *)
public class AudioFileResource : RealityKit.AudioResource {
  public enum LoadingStrategy {
    case stream
    case preload
    public static func == (a: RealityKit.AudioFileResource.LoadingStrategy, b: RealityKit.AudioFileResource.LoadingStrategy) -> Swift.Bool
  }
  public var loadingStrategy: RealityKit.AudioFileResource.LoadingStrategy {
    get
    set
  }
  public var shouldLoop: Swift.Bool {
    get
    set
  }
  public var __duration: Foundation.TimeInterval {
    get
  }
  @objc deinit
}
extension AudioFileResource {
  public static func load(named name: Swift.String, in bundle: Foundation.Bundle? = nil, inputMode: RealityKit.AudioResource.InputMode = .spatial, loadingStrategy: RealityKit.AudioFileResource.LoadingStrategy = .preload, shouldLoop: Swift.Bool = false) throws -> RealityKit.AudioFileResource
  public static func load(contentsOf url: Foundation.URL, withName resourceName: Swift.String? = nil, inputMode: RealityKit.AudioResource.InputMode = .spatial, loadingStrategy: RealityKit.AudioFileResource.LoadingStrategy = .preload, shouldLoop: Swift.Bool = false) throws -> RealityKit.AudioFileResource
}
extension AudioFileResource {
  public static func loadAsync(named name: Swift.String, in bundle: Foundation.Bundle? = nil, inputMode: RealityKit.AudioResource.InputMode = .spatial, loadingStrategy: RealityKit.AudioFileResource.LoadingStrategy = .preload, shouldLoop: Swift.Bool = false) -> RealityKit.LoadRequest<RealityKit.AudioFileResource>
  public static func loadAsync(contentsOf url: Foundation.URL, withName resourceName: Swift.String? = nil, inputMode: RealityKit.AudioResource.InputMode = .spatial, loadingStrategy: RealityKit.AudioFileResource.LoadingStrategy = .preload, shouldLoop: Swift.Bool = false) -> RealityKit.LoadRequest<RealityKit.AudioFileResource>
}
extension AudioFileResource.LoadingStrategy : Swift.Hashable {
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@available(macOS 11.0, iOS 14.0, *)
public struct ModelDebugOptionsComponent : RealityKit.Component {
  public var visualizationMode: RealityKit.ModelDebugOptionsComponent.VisualizationMode {
    get
  }
  public init(visualizationMode: RealityKit.ModelDebugOptionsComponent.VisualizationMode = .none)
  public static func __fromCore(_ coreComponent: RealityKit.__ComponentRef) -> RealityKit.ModelDebugOptionsComponent
  public func __toCore(_ coreComponent: RealityKit.__ComponentRef)
  public static var __coreComponentType: RealityKit.__ComponentTypeRef {
    get
  }
  public enum VisualizationMode : Swift.String {
    case none
    case normal
    case tangent
    case bitangent
    case baseColor
    case textureCoordinates
    case finalColor
    case finalAlpha
    case roughness
    case metallic
    case ambientOcclusion
    case specular
    case emissive
    case clearcoat
    case clearcoatRoughness
    case lightingDiffuse
    case lightingSpecular
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
}
public enum __RKEntityActionAnimationStyle : Swift.String, Swift.Codable, Swift.CaseIterable {
  case basic
  case playful
  case wild
  public init?(rawValue: Swift.String)
  public typealias AllCases = [RealityKit.__RKEntityActionAnimationStyle]
  public typealias RawValue = Swift.String
  public static var allCases: [RealityKit.__RKEntityActionAnimationStyle] {
    get
  }
  public var rawValue: Swift.String {
    get
  }
}
public enum __RKEntityShowActionBuildInAnimationType : Swift.String, Swift.Codable, Swift.CaseIterable {
  case none
  case moveFromLeft
  case moveFromRight
  case moveFromFront
  case moveFromRear
  case moveFromAbove
  case moveFromBelow
  case pop
  case scale
  case scaleBig
  public init?(rawValue: Swift.String)
  public typealias AllCases = [RealityKit.__RKEntityShowActionBuildInAnimationType]
  public typealias RawValue = Swift.String
  public static var allCases: [RealityKit.__RKEntityShowActionBuildInAnimationType] {
    get
  }
  public var rawValue: Swift.String {
    get
  }
}
public enum __RKEntityHideActionBuildOutAnimationType : Swift.String, Swift.Codable, Swift.CaseIterable {
  case none
  case moveToLeft
  case moveToRight
  case moveToFront
  case moveToRear
  case moveToAbove
  case moveToBelow
  case pop
  case scale
  case scaleUp
  public init?(rawValue: Swift.String)
  public typealias AllCases = [RealityKit.__RKEntityHideActionBuildOutAnimationType]
  public typealias RawValue = Swift.String
  public static var allCases: [RealityKit.__RKEntityHideActionBuildOutAnimationType] {
    get
  }
  public var rawValue: Swift.String {
    get
  }
}
@_inheritsConvenienceInitializers public class __RKEntityVisibilityAction : RealityKit.__RKEntityAction {
  @objc override public func copy(with zone: ObjectiveC.NSZone? = nil) -> Any
  override public init(targetEntity: RealityKit.Entity? = super)
  @objc deinit
}
@_inheritsConvenienceInitializers public class __RKEntityToggleVisibilityAction : RealityKit.__RKEntityVisibilityAction {
  override public func perform(with context: RealityKit.__RKEntityActionContext) -> Swift.Bool
  override public func reversed() -> RealityKit.__RKEntityAction?
  @objc override public func copy(with zone: ObjectiveC.NSZone? = nil) -> Any
  override public init(targetEntity: RealityKit.Entity? = super)
  @objc deinit
}
public class __RKEntitySetOpacityAction : RealityKit.__RKEntityVisibilityAction {
  public init(targetEntity: RealityKit.Entity?, duration: Swift.Float = 1.0, opacity: Swift.Float = 1.0)
  override public func perform(with context: RealityKit.__RKEntityActionContext) -> Swift.Bool
  override public func reversed() -> RealityKit.__RKEntityAction?
  @objc override public func copy(with zone: ObjectiveC.NSZone? = nil) -> Any
  override public init(targetEntity: RealityKit.Entity? = super)
  @objc deinit
}
public class __RKEntityShowAction : RealityKit.__RKEntityVisibilityAction {
  public init(targetEntity: RealityKit.Entity?, duration: Swift.Float = 1.0, distance: Swift.Float = 10.0, ease: RealityKit.__RKEntityMoveEase = .none, easeType: RealityKit.__RKEntityMoveEaseType = .easeIn, fadeIn: Swift.Bool = false, finalOpacity: Swift.Float = 1.0, respectPhysics: Swift.Bool = false, physicsAngularCoefficient: Swift.Float = 0.0, physicsLinearCoefficient: Swift.Float = 0.0, animationStyle: RealityKit.__RKEntityActionAnimationStyle = .basic, buildInAnimationType: RealityKit.__RKEntityShowActionBuildInAnimationType = .none)
  override public func perform(with context: RealityKit.__RKEntityActionContext) -> Swift.Bool
  override public func reversed() -> RealityKit.__RKEntityAction?
  override public var description: Swift.String {
    get
  }
  @objc override public func copy(with zone: ObjectiveC.NSZone? = nil) -> Any
  override public init(targetEntity: RealityKit.Entity? = super)
  @objc deinit
}
public class __RKEntityHideAction : RealityKit.__RKEntityVisibilityAction {
  public init(targetEntity: RealityKit.Entity?, duration: Swift.Float = 1.0, distance: Swift.Float = 10.0, ease: RealityKit.__RKEntityMoveEase = .none, easeType: RealityKit.__RKEntityMoveEaseType = .easeIn, fadeOut: Swift.Bool = false, finalOpacity: Swift.Float = 0.0, respectPhysics: Swift.Bool = false, physicsAngularCoefficient: Swift.Float = 0.0, physicsLinearCoefficient: Swift.Float = 0.0, animationStyle: RealityKit.__RKEntityActionAnimationStyle = .basic, buildOutAnimationType: RealityKit.__RKEntityHideActionBuildOutAnimationType = .none)
  @discardableResult
  override public func perform(with context: RealityKit.__RKEntityActionContext) -> Swift.Bool
  override public func reversed() -> RealityKit.__RKEntityAction?
  override public var description: Swift.String {
    get
  }
  @objc override public func copy(with zone: ObjectiveC.NSZone? = nil) -> Any
  override public init(targetEntity: RealityKit.Entity? = super)
  @objc deinit
}
@_inheritsConvenienceInitializers public class __RKSoundTrigger : RealityKit.__RKEntityTrigger {
  override public init()
  @objc deinit
}
@available(macOS 10.15, iOS 13.0, *)
public protocol HasHierarchy : RealityKit.Entity {
}
extension HasHierarchy {
  public var parent: RealityKit.Entity? {
    get
  }
  public func setParent(_ parent: RealityKit.Entity?, preservingWorldTransform: Swift.Bool = false)
  public var children: RealityKit.Entity.ChildCollection {
    get
    set
    _modify
  }
  public func addChild(_ entity: RealityKit.Entity, preservingWorldTransform: Swift.Bool = false)
  public func removeChild(_ entity: RealityKit.Entity, preservingWorldTransform: Swift.Bool = false)
  public func removeFromParent(preservingWorldTransform: Swift.Bool = false)
}
extension ARView : UIKit.UIGestureRecognizerDelegate {
  @objc override dynamic open class var layerClass: Swift.AnyClass {
    @objc get
  }
  @objc override dynamic open var contentScaleFactor: CoreGraphics.CGFloat {
    @objc get
    @objc set
  }
  public func __enablePauseEngineOnLeaveForeground()
  public func __disablePauseEngineOnLeaveForeground()
  @objc override dynamic open func didMoveToSuperview()
  @objc override dynamic open func layoutSubviews()
  @objc override dynamic open func touchesBegan(_ touches: Swift.Set<UIKit.UITouch>, with event: UIKit.UIEvent?)
  @objc override dynamic open func touchesMoved(_ touches: Swift.Set<UIKit.UITouch>, with event: UIKit.UIEvent?)
  @objc override dynamic open func touchesEnded(_ touches: Swift.Set<UIKit.UITouch>, with event: UIKit.UIEvent?)
  @objc override dynamic open func touchesCancelled(_ touches: Swift.Set<UIKit.UITouch>, with event: UIKit.UIEvent?)
  @objc dynamic public func gestureRecognizer(_ gestureRecognizer: UIKit.UIGestureRecognizer, shouldRecognizeSimultaneouslyWith otherGestureRecognizer: UIKit.UIGestureRecognizer) -> Swift.Bool
  @objc dynamic public func gestureRecognizer(_ gestureRecognizer: UIKit.UIGestureRecognizer, shouldReceive touch: UIKit.UITouch) -> Swift.Bool
}
@_inheritsConvenienceInitializers public class __RKEntityPlacementTrigger : RealityKit.__RKEntityTrigger {
  override public init()
  override public func matches(with trigger: RealityKit.__RKEntityTrigger) -> Swift.Bool
  @objc deinit
}
@_inheritsConvenienceInitializers public class __RKEntityRemovalTrigger : RealityKit.__RKEntityTrigger {
  override public init()
  override public func matches(with trigger: RealityKit.__RKEntityTrigger) -> Swift.Bool
  @objc deinit
}
public class __RKEntityInteraction : Swift.CustomStringConvertible {
  public var trigger: RealityKit.__RKEntityTrigger {
    get
  }
  public var action: RealityKit.__RKEntityAction {
    get
  }
  public var enabled: Swift.Bool
  public var accessibilityDescription: Swift.String?
  public init(trigger: RealityKit.__RKEntityTrigger, action: RealityKit.__RKEntityAction)
  @available(macOS 10.15.4, iOS 13.4, *)
  convenience public init(trigger: RealityKit.__RKEntityTrigger, action: RealityKit.__RKEntityAction, accessibilityDescription: Swift.String? = nil)
  public func fire(context: RealityKit.__RKEntityActionContext)
  public var description: Swift.String {
    get
  }
  @objc deinit
}
extension RealityKit.__RKSimulationSceneCoordinatorState : Swift.Equatable {}
extension RealityKit.__RKSimulationSceneCoordinatorState : Swift.Hashable {}
extension RealityKit.__RKEntityActionAnimationStyle : Swift.Equatable {}
extension RealityKit.__RKEntityActionAnimationStyle : Swift.Hashable {}
extension RealityKit.__RKEntityActionAnimationStyle : Swift.RawRepresentable {}
extension RealityKit.__RKEntityActionMultiplePerformBehavior : Swift.Equatable {}
extension RealityKit.__RKEntityActionMultiplePerformBehavior : Swift.Hashable {}
extension RealityKit.__RKEntityActionMultiplePerformBehavior : Swift.RawRepresentable {}
extension RealityKit.__RKEntityAudioActionType : Swift.Equatable {}
extension RealityKit.__RKEntityAudioActionType : Swift.Hashable {}
extension RealityKit.__RKEntityAudioActionType : Swift.RawRepresentable {}
extension RealityKit.__RKAudioSpatialModeSelection : Swift.Equatable {}
extension RealityKit.__RKAudioSpatialModeSelection : Swift.Hashable {}
extension RealityKit.__RKAudioSpatialModeSelection : Swift.RawRepresentable {}
extension RealityKit.__RKEntityEmphasisAnimationType : Swift.Equatable {}
extension RealityKit.__RKEntityEmphasisAnimationType : Swift.Hashable {}
extension RealityKit.__RKEntityEmphasisAnimationType : Swift.RawRepresentable {}
extension RealityKit.__RKEntityGroupActionOrder : Swift.Hashable {}
extension RealityKit.__RKEntityGroupActionOrder : Swift.RawRepresentable {}
extension RealityKit.__RKEntityHideActionBuildOutAnimationType : Swift.Equatable {}
extension RealityKit.__RKEntityHideActionBuildOutAnimationType : Swift.Hashable {}
extension RealityKit.__RKEntityHideActionBuildOutAnimationType : Swift.RawRepresentable {}
extension RealityKit.__RKEntityMoveEase : Swift.Equatable {}
extension RealityKit.__RKEntityMoveEase : Swift.Hashable {}
extension RealityKit.__RKEntityMoveEase : Swift.RawRepresentable {}
extension RealityKit.__RKEntityMoveEaseType : Swift.Equatable {}
extension RealityKit.__RKEntityMoveEaseType : Swift.Hashable {}
extension RealityKit.__RKEntityMoveEaseType : Swift.RawRepresentable {}
extension RealityKit.__RKEntityMoveSelection : Swift.Equatable {}
extension RealityKit.__RKEntityMoveSelection : Swift.Hashable {}
extension RealityKit.__RKEntityMoveSelection : Swift.RawRepresentable {}
extension RealityKit.__RKEntityShowActionBuildInAnimationType : Swift.Equatable {}
extension RealityKit.__RKEntityShowActionBuildInAnimationType : Swift.Hashable {}
extension RealityKit.__RKEntityShowActionBuildInAnimationType : Swift.RawRepresentable {}
extension RealityKit.__RKEntityTriggerSpecification.Name : Swift.Equatable {}
extension RealityKit.__RKEntityTriggerSpecification.Name : Swift.Hashable {}
extension RealityKit.__RKEntityTriggerSpecification.Name : Swift.RawRepresentable {}
extension RealityKit.__RKEntityActionSpecification.Name : Swift.Equatable {}
extension RealityKit.__RKEntityActionSpecification.Name : Swift.Hashable {}
extension RealityKit.__RKEntityActionSpecification.Name : Swift.RawRepresentable {}
extension RealityKit.__RKEntityFlipDirectionType : Swift.Equatable {}
extension RealityKit.__RKEntityFlipDirectionType : Swift.Hashable {}
extension RealityKit.__RKEntityFlipDirectionType : Swift.RawRepresentable {}
@available(macOS 10.15.4, iOS 13.4, *)
extension RealityKit.NetworkCompatibilityToken.Compatibility : Swift.Equatable {}
@available(macOS 10.15.4, iOS 13.4, *)
extension RealityKit.NetworkCompatibilityToken.Compatibility : Swift.Hashable {}
extension RealityKit.__RKEntityActionGroup.Ordering : Swift.Equatable {}
extension RealityKit.__RKEntityActionGroup.Ordering : Swift.Hashable {}
@available(macOS 10.15, iOS 13.0, *)
extension RealityKit.SynchronizationComponent.OwnershipTransferMode : Swift.Equatable {}
@available(macOS 10.15, iOS 13.0, *)
extension RealityKit.SynchronizationComponent.OwnershipTransferMode : Swift.Hashable {}
@available(macOS 10.15, iOS 13.0, *)
extension RealityKit.SynchronizationComponent.OwnershipTransferCompletionResult : Swift.Equatable {}
@available(macOS 10.15, iOS 13.0, *)
extension RealityKit.SynchronizationComponent.OwnershipTransferCompletionResult : Swift.Hashable {}
extension RealityKit.__REAnchoringType.Name : Swift.Equatable {}
extension RealityKit.__REAnchoringType.Name : Swift.Hashable {}
extension RealityKit.__REAnchoringType.Name : Swift.RawRepresentable {}
@available(macCatalyst 14.0, *)
@available(*, deprecated, message: "Use RenderOptions instead")
extension RealityKit.ARView.__RenderQuality : Swift.Equatable {}
@available(macCatalyst 14.0, *)
@available(*, deprecated, message: "Use RenderOptions instead")
extension RealityKit.ARView.__RenderQuality : Swift.Hashable {}
@available(macOS 10.15, iOS 13.0, *)
@available(*, deprecated, message: "Will be hidden in RealityKit 2019.")
extension RealityKit.AnimationTimingFunction.__Mode : Swift.Equatable {}
@available(macOS 10.15, iOS 13.0, *)
@available(*, deprecated, message: "Will be hidden in RealityKit 2019.")
extension RealityKit.AnimationTimingFunction.__Mode : Swift.Hashable {}
extension RealityKit.__RKEntityProximityTrigger.ExitType : Swift.Equatable {}
extension RealityKit.__RKEntityProximityTrigger.ExitType : Swift.Hashable {}
extension RealityKit.__RKEntityProximityTrigger.ExitType : Swift.RawRepresentable {}
extension RealityKit.ARView.Environment.Reverb.Preset : Swift.Equatable {}
extension RealityKit.ARView.Environment.Reverb.Preset : Swift.Hashable {}
extension RealityKit.__RKEntitySpinDirectionType : Swift.Equatable {}
extension RealityKit.__RKEntitySpinDirectionType : Swift.Hashable {}
extension RealityKit.__RKEntitySpinDirectionType : Swift.RawRepresentable {}
extension RealityKit.__Archiving.ArchivingError : Swift.Equatable {}
extension RealityKit.__Archiving.ArchivingError : Swift.Hashable {}
extension RealityKit.ARView.CameraMode : Swift.Equatable {}
extension RealityKit.ARView.CameraMode : Swift.Hashable {}
extension RealityKit.__RKMaterialParameterBlock.TransparentPass : Swift.Equatable {}
extension RealityKit.__RKMaterialParameterBlock.TransparentPass : Swift.Hashable {}
extension RealityKit.__RKMaterialParameterBlock.TransparentPass : Swift.RawRepresentable {}
extension RealityKit.__RKMaterialParameterBlock.OpaquePass : Swift.Equatable {}
extension RealityKit.__RKMaterialParameterBlock.OpaquePass : Swift.Hashable {}
extension RealityKit.__RKMaterialParameterBlock.OpaquePass : Swift.RawRepresentable {}
extension RealityKit.RotationOrder : Swift.Equatable {}
extension RealityKit.RotationOrder : Swift.Hashable {}
extension RealityKit.RotationOrder : Swift.RawRepresentable {}
@available(macOS 10.15, iOS 13.0, *)
extension RealityKit.CollisionComponent.Mode : Swift.Equatable {}
@available(macOS 10.15, iOS 13.0, *)
extension RealityKit.CollisionComponent.Mode : Swift.Hashable {}
@available(macOS 10.15, iOS 13.0, *)
extension RealityKit.AudioResource.InputMode : Swift.Equatable {}
@available(macOS 10.15, iOS 13.0, *)
extension RealityKit.AudioResource.InputMode : Swift.Hashable {}
@available(macOS 11.0, iOS 14.0, *)
extension RealityKit.ModelDebugOptionsComponent.VisualizationMode : Swift.Equatable {}
@available(macOS 11.0, iOS 14.0, *)
extension RealityKit.ModelDebugOptionsComponent.VisualizationMode : Swift.Hashable {}
@available(macOS 11.0, iOS 14.0, *)
extension RealityKit.ModelDebugOptionsComponent.VisualizationMode : Swift.RawRepresentable {}
