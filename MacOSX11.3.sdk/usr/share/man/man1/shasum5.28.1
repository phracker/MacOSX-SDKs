.\" Automatically generated by Pod::Man 4.10 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "SHASUM 1"
.TH SHASUM 1 "2021-02-28" "perl v5.28.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
shasum \- Print or Check SHA Checksums
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 3
\& Usage: shasum [OPTION]... [FILE]...
\& Print or check SHA checksums.
\& With no FILE, or when FILE is \-, read standard input.
\&
\&   \-a, \-\-algorithm   1 (default), 224, 256, 384, 512, 512224, 512256
\&   \-b, \-\-binary      read in binary mode
\&   \-c, \-\-check       read SHA sums from the FILEs and check them
\&       \-\-tag         create a BSD\-style checksum
\&   \-t, \-\-text        read in text mode (default)
\&   \-U, \-\-UNIVERSAL   read in Universal Newlines mode
\&                         produces same digest on Windows/Unix/Mac
\&   \-0, \-\-01          read in BITS mode
\&                         ASCII \*(Aq0\*(Aq interpreted as 0\-bit,
\&                         ASCII \*(Aq1\*(Aq interpreted as 1\-bit,
\&                         all other characters ignored
\&
\& The following five options are useful only when verifying checksums:
\&       \-\-ignore\-missing  don\*(Aqt fail or report status for missing files
\&   \-q, \-\-quiet           don\*(Aqt print OK for each successfully verified file
\&   \-s, \-\-status          don\*(Aqt output anything, status code shows success
\&       \-\-strict          exit non\-zero for improperly formatted checksum lines
\&   \-w, \-\-warn            warn about improperly formatted checksum lines
\&
\&   \-h, \-\-help        display this help and exit
\&   \-v, \-\-version     output version information and exit
\&
\& When verifying SHA\-512/224 or SHA\-512/256 checksums, indicate the
\& algorithm explicitly using the \-a option, e.g.
\&
\&   shasum \-a 512224 \-c checksumfile
\&
\& The sums are computed as described in FIPS PUB 180\-4.  When checking,
\& the input should be a former output of this program.  The default
\& mode is to print a line with checksum, a character indicating type
\& (\`*\*(Aq for binary, \` \*(Aq for text, \`U\*(Aq for UNIVERSAL, \`^\*(Aq for BITS),
\& and name for each FILE.  The line starts with a \`\e\*(Aq character if the
\& FILE name contains either newlines or backslashes, which are then
\& replaced by the two\-character sequences \`\en\*(Aq and \`\e\e\*(Aq respectively.
\&
\& Report shasum bugs to mshelor@cpan.org
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Running \fIshasum\fR is often the quickest way to compute \s-1SHA\s0 message
digests.  The user simply feeds data to the script through files or
standard input, and then collects the results from standard output.
.PP
The following command shows how to compute digests for typical inputs
such as the \s-1NIST\s0 test vector \*(L"abc\*(R":
.PP
.Vb 1
\&        perl \-e "print qq(abc)" | shasum
.Ve
.PP
Or, if you want to use \s-1SHA\-256\s0 instead of the default \s-1SHA\-1,\s0 simply say:
.PP
.Vb 1
\&        perl \-e "print qq(abc)" | shasum \-a 256
.Ve
.PP
Since \fIshasum\fR mimics the behavior of the combined \s-1GNU\s0 \fIsha1sum\fR,
\&\fIsha224sum\fR, \fIsha256sum\fR, \fIsha384sum\fR, and \fIsha512sum\fR programs,
you can install this script as a convenient drop-in replacement.
.PP
Unlike the \s-1GNU\s0 programs, \fIshasum\fR encompasses the full \s-1SHA\s0 standard by
allowing partial-byte inputs.  This is accomplished through the \s-1BITS\s0
option (\fI\-0\fR).  The following example computes the \s-1SHA\-224\s0 digest of
the 7\-bit message \fI0001100\fR:
.PP
.Vb 1
\&        perl \-e "print qq(0001100)" | shasum \-0 \-a 224
.Ve
.SH "AUTHOR"
.IX Header "AUTHOR"
Copyright (c) 2003\-2017 Mark Shelor <mshelor@cpan.org>.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fIshasum\fR is implemented using the Perl module Digest::SHA.
