.\" Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PERLDIAG 1"
.TH PERLDIAG 1 "2020-02-29" "perl v5.30.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
perldiag \- various Perl diagnostics
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
These messages are classified as follows (listed in increasing order of
desperation):
.PP
.Vb 7
\&    (W) A warning (optional).
\&    (D) A deprecation (enabled by default).
\&    (S) A severe warning (enabled by default).
\&    (F) A fatal error (trappable).
\&    (P) An internal error you should never see (trappable).
\&    (X) A very fatal error (nontrappable).
\&    (A) An alien error message (not generated by Perl).
.Ve
.PP
The majority of messages from the first three classifications above
(W, D & S) can be controlled using the \f(CW\*(C`warnings\*(C'\fR pragma.
.PP
If a message can be controlled by the \f(CW\*(C`warnings\*(C'\fR pragma, its warning
category is included with the classification letter in the description
below.  E.g. \f(CW\*(C`(W closed)\*(C'\fR means a warning in the \f(CW\*(C`closed\*(C'\fR category.
.PP
Optional warnings are enabled by using the \f(CW\*(C`warnings\*(C'\fR pragma or the \fB\-w\fR
and \fB\-W\fR switches.  Warnings may be captured by setting \f(CW$SIG{_\|_WARN_\|_}\fR
to a reference to a routine that will be called on each warning instead
of printing it.  See perlvar.
.PP
Severe warnings are always enabled, unless they are explicitly disabled
with the \f(CW\*(C`warnings\*(C'\fR pragma or the \fB\-X\fR switch.
.PP
Trappable errors may be trapped using the eval operator.  See
\&\*(L"eval\*(R" in perlfunc.  In almost all cases, warnings may be selectively
disabled or promoted to fatal errors using the \f(CW\*(C`warnings\*(C'\fR pragma.
See warnings.
.PP
The messages are in alphabetical order, without regard to upper or
lower-case.  Some of these messages are generic.  Spots that vary are
denoted with a \f(CW%s\fR or other printf-style escape.  These escapes are
ignored by the alphabetical order, as are all characters other than
letters.  To look up your message, just ignore anything that is not a
letter.
.ie n .IP "\fBaccept()\fR on closed socket %s" 4
.el .IP "\fBaccept()\fR on closed socket \f(CW%s\fR" 4
.IX Item "accept() on closed socket %s"
(W closed) You tried to do an accept on a closed socket.  Did you forget
to check the return value of your \fBsocket()\fR call?  See
\&\*(L"accept\*(R" in perlfunc.
.IP "Aliasing via reference is experimental" 4
.IX Item "Aliasing via reference is experimental"
(S experimental::refaliasing) This warning is emitted if you use
a reference constructor on the left-hand side of an assignment to
alias one variable to another.  Simply suppress the warning if you
want to use the feature, but know that in doing so you are taking
the risk of using an experimental feature which may change or be
removed in a future Perl version:
.Sp
.Vb 3
\&    no warnings "experimental::refaliasing";
\&    use feature "refaliasing";
\&    \e$x = \e$y;
.Ve
.ie n .IP "Allocation too large: %x" 4
.el .IP "Allocation too large: \f(CW%x\fR" 4
.IX Item "Allocation too large: %x"
(X) You can't allocate more than 64K on an MS-DOS machine.
.ie n .IP "'%c' allowed only after types %s in %s" 4
.el .IP "'%c' allowed only after types \f(CW%s\fR in \f(CW%s\fR" 4
.IX Item "'%c' allowed only after types %s in %s"
(F) The modifiers '!', '<' and '>' are allowed in \fBpack()\fR or \fBunpack()\fR only
after certain types.  See \*(L"pack\*(R" in perlfunc.
.IP "alpha\->\fBnumify()\fR is lossy" 4
.IX Item "alpha->numify() is lossy"
(W numeric) An alpha version can not be numified without losing
information.
.IP "Ambiguous call resolved as CORE::%s(), qualify as such or use &" 4
.IX Item "Ambiguous call resolved as CORE::%s(), qualify as such or use &"
(W ambiguous) A subroutine you have declared has the same name as a Perl
keyword, and you have used the name without qualification for calling
one or the other.  Perl decided to call the builtin because the
subroutine is not imported.
.Sp
To force interpretation as a subroutine call, either put an ampersand
before the subroutine name, or qualify the name with its package.
Alternatively, you can import the subroutine (or pretend that it's
imported with the \f(CW\*(C`use subs\*(C'\fR pragma).
.Sp
To silently interpret it as the Perl operator, use the \f(CW\*(C`CORE::\*(C'\fR prefix
on the operator (e.g. \f(CW\*(C`CORE::log($x)\*(C'\fR) or declare the subroutine
to be an object method (see \*(L"Subroutine Attributes\*(R" in perlsub or
attributes).
.IP "Ambiguous range in transliteration operator" 4
.IX Item "Ambiguous range in transliteration operator"
(F) You wrote something like \f(CW\*(C`tr/a\-z\-0//\*(C'\fR which doesn't mean anything at
all.  To include a \f(CW\*(C`\-\*(C'\fR character in a transliteration, put it either
first or last.  (In the past, \f(CW\*(C`tr/a\-z\-0//\*(C'\fR was synonymous with
\&\f(CW\*(C`tr/a\-y//\*(C'\fR, which was probably not what you would have expected.)
.ie n .IP "Ambiguous use of %s resolved as %s" 4
.el .IP "Ambiguous use of \f(CW%s\fR resolved as \f(CW%s\fR" 4
.IX Item "Ambiguous use of %s resolved as %s"
(S ambiguous) You said something that may not be interpreted the way
you thought.  Normally it's pretty easy to disambiguate it by supplying
a missing quote, operator, parenthesis pair or declaration.
.IP "Ambiguous use of \-%s resolved as \-&%s()" 4
.IX Item "Ambiguous use of -%s resolved as -&%s()"
(S ambiguous) You wrote something like \f(CW\*(C`\-foo\*(C'\fR, which might be the
string \f(CW"\-foo"\fR, or a call to the function \f(CW\*(C`foo\*(C'\fR, negated.  If you meant
the string, just write \f(CW"\-foo"\fR.  If you meant the function call,
write \f(CW\*(C`\-foo()\*(C'\fR.
.ie n .IP "Ambiguous use of %c resolved as operator %c" 4
.el .IP "Ambiguous use of \f(CW%c\fR resolved as operator \f(CW%c\fR" 4
.IX Item "Ambiguous use of %c resolved as operator %c"
(S ambiguous) \f(CW\*(C`%\*(C'\fR, \f(CW\*(C`&\*(C'\fR, and \f(CW\*(C`*\*(C'\fR are both infix operators (modulus,
bitwise and, and multiplication) \fIand\fR initial special characters
(denoting hashes, subroutines and typeglobs), and you said something
like \f(CW\*(C`*foo * foo\*(C'\fR that might be interpreted as either of them.  We
assumed you meant the infix operator, but please try to make it more
clear \*(-- in the example given, you might write \f(CW\*(C`*foo * foo()\*(C'\fR if you
really meant to multiply a glob by the result of calling a function.
.ie n .IP "Ambiguous use of %c{%s} resolved to %c%s" 4
.el .IP "Ambiguous use of \f(CW%c\fR{%s} resolved to \f(CW%c\fR%s" 4
.IX Item "Ambiguous use of %c{%s} resolved to %c%s"
(W ambiguous) You wrote something like \f(CW\*(C`@{foo}\*(C'\fR, which might be
asking for the variable \f(CW@foo\fR, or it might be calling a function
named foo, and dereferencing it as an array reference.  If you wanted
the variable, you can just write \f(CW@foo\fR.  If you wanted to call the
function, write \f(CW\*(C`@{foo()}\*(C'\fR ... or you could just not have a variable
and a function with the same name, and save yourself a lot of trouble.
.ie n .IP "Ambiguous use of %c{%s[...]} resolved to %c%s[...]" 4
.el .IP "Ambiguous use of \f(CW%c\fR{%s[...]} resolved to \f(CW%c\fR%s[...]" 4
.IX Item "Ambiguous use of %c{%s[...]} resolved to %c%s[...]"
.PD 0
.ie n .IP "Ambiguous use of %c{%s{...}} resolved to %c%s{...}" 4
.el .IP "Ambiguous use of \f(CW%c\fR{%s{...}} resolved to \f(CW%c\fR%s{...}" 4
.IX Item "Ambiguous use of %c{%s{...}} resolved to %c%s{...}"
.PD
(W ambiguous) You wrote something like \f(CW\*(C`${foo[2]}\*(C'\fR (where foo represents
the name of a Perl keyword), which might be looking for element number
2 of the array named \f(CW@foo\fR, in which case please write \f(CW$foo[2]\fR, or you
might have meant to pass an anonymous arrayref to the function named
foo, and then do a scalar deref on the value it returns.  If you meant
that, write \f(CW\*(C`${foo([2])}\*(C'\fR.
.Sp
In regular expressions, the \f(CW\*(C`${foo[2]}\*(C'\fR syntax is sometimes necessary
to disambiguate between array subscripts and character classes.
\&\f(CW\*(C`/$length[2345]/\*(C'\fR, for instance, will be interpreted as \f(CW$length\fR followed
by the character class \f(CW\*(C`[2345]\*(C'\fR.  If an array subscript is what you
want, you can avoid the warning by changing \f(CW\*(C`/${length[2345]}/\*(C'\fR to the
unsightly \f(CW\*(C`/${\e$length[2345]}/\*(C'\fR, by renaming your array to something
that does not coincide with a built-in keyword, or by simply turning
off warnings with \f(CW\*(C`no warnings \*(Aqambiguous\*(Aq;\*(C'\fR.
.IP "'|' and '<' may not both be specified on command line" 4
.IX Item "'|' and '<' may not both be specified on command line"
(F) An error peculiar to \s-1VMS.\s0  Perl does its own command line
redirection, and found that \s-1STDIN\s0 was a pipe, and that you also tried to
redirect \s-1STDIN\s0 using '<'.  Only one \s-1STDIN\s0 stream to a customer, please.
.IP "'|' and '>' may not both be specified on command line" 4
.IX Item "'|' and '>' may not both be specified on command line"
(F) An error peculiar to \s-1VMS.\s0  Perl does its own command line
redirection, and thinks you tried to redirect stdout both to a file and
into a pipe to another command.  You need to choose one or the other,
though nothing's stopping you from piping into a program or Perl script
which 'splits' output into two streams, such as
.Sp
.Vb 6
\&    open(OUT,">$ARGV[0]") or die "Can\*(Aqt write to $ARGV[0]: $!";
\&    while (<STDIN>) {
\&        print;
\&        print OUT;
\&    }
\&    close OUT;
.Ve
.ie n .IP "Applying %s to %s will act on scalar(%s)" 4
.el .IP "Applying \f(CW%s\fR to \f(CW%s\fR will act on scalar(%s)" 4
.IX Item "Applying %s to %s will act on scalar(%s)"
(W misc) The pattern match (\f(CW\*(C`//\*(C'\fR), substitution (\f(CW\*(C`s///\*(C'\fR), and
transliteration (\f(CW\*(C`tr///\*(C'\fR) operators work on scalar values.  If you apply
one of them to an array or a hash, it will convert the array or hash to
a scalar value (the length of an array, or the population info of a
hash) and then work on that scalar value.  This is probably not what
you meant to do.  See \*(L"grep\*(R" in perlfunc and \*(L"map\*(R" in perlfunc for
alternatives.
.IP "Arg too short for msgsnd" 4
.IX Item "Arg too short for msgsnd"
(F) \fBmsgsnd()\fR requires a string at least as long as sizeof(long).
.ie n .IP "Argument ""%s"" isn't numeric%s" 4
.el .IP "Argument ``%s'' isn't numeric%s" 4
.IX Item "Argument %s isn't numeric%s"
(W numeric) The indicated string was fed as an argument to an operator
that expected a numeric value instead.  If you're fortunate the message
will identify which operator was so unfortunate.
.Sp
Note that for the \f(CW\*(C`Inf\*(C'\fR and \f(CW\*(C`NaN\*(C'\fR (infinity and not-a-number) the
definition of \*(L"numeric\*(R" is somewhat unusual: the strings themselves
(like \*(L"Inf\*(R") are considered numeric, and anything following them is
considered non-numeric.
.ie n .IP "Argument list not closed for PerlIO layer ""%s""" 4
.el .IP "Argument list not closed for PerlIO layer ``%s''" 4
.IX Item "Argument list not closed for PerlIO layer %s"
(W layer) When pushing a layer with arguments onto the Perl I/O
system you forgot the ) that closes the argument list.  (Layers
take care of transforming data between external and internal
representations.)  Perl stopped parsing the layer list at this
point and did not attempt to push this layer.  If your program
didn't explicitly request the failing operation, it may be the
result of the value of the environment variable \s-1PERLIO.\s0
.ie n .IP "Argument ""%s"" treated as 0 in increment (++)" 4
.el .IP "Argument ``%s'' treated as 0 in increment (++)" 4
.IX Item "Argument %s treated as 0 in increment (++)"
(W numeric) The indicated string was fed as an argument to the \f(CW\*(C`++\*(C'\fR
operator which expects either a number or a string matching
\&\f(CW\*(C`/^[a\-zA\-Z]*[0\-9]*\ez/\*(C'\fR.  See \*(L"Auto-increment and
Auto-decrement\*(R" in perlop for details.
.IP "Array passed to stat will be coerced to a scalar%s" 4
.IX Item "Array passed to stat will be coerced to a scalar%s"
(W syntax) You called \fBstat()\fR on an array, but the array will be
coerced to a scalar \- the number of elements in the array.
.IP "A signature parameter must start with '$', '@' or '%'" 4
.IX Item "A signature parameter must start with '$', '@' or '%'"
(F) Each subroutine signature parameter declaration must start with a valid
sigil; for example:
.Sp
.Vb 1
\&    sub foo ($a, $, $b = 1, @c) {}
.Ve
.IP "A slurpy parameter may not have a default value" 4
.IX Item "A slurpy parameter may not have a default value"
(F) Only scalar subroutine signature parameters may have a default value;
for example:
.Sp
.Vb 3
\&    sub foo ($a = 1)        {} # legal
\&    sub foo (@a = (1))      {} # invalid
\&    sub foo (%a = (a => b)) {} # invalid
.Ve
.ie n .IP "assertion botched: %s" 4
.el .IP "assertion botched: \f(CW%s\fR" 4
.IX Item "assertion botched: %s"
(X) The malloc package that comes with Perl had an internal failure.
.ie n .IP "Assertion %s failed: file ""%s"", line %d" 4
.el .IP "Assertion \f(CW%s\fR failed: file ``%s'', line \f(CW%d\fR" 4
.IX Item "Assertion %s failed: file %s, line %d"
(X) A general assertion failed.  The file in question must be examined.
.IP "Assigned value is not a reference" 4
.IX Item "Assigned value is not a reference"
(F) You tried to assign something that was not a reference to an lvalue
reference (e.g., \f(CW\*(C`\e$x = $y\*(C'\fR).  If you meant to make \f(CW$x\fR an alias to \f(CW$y\fR, use
\&\f(CW\*(C`\e$x = \e$y\*(C'\fR.
.ie n .IP "Assigned value is not %s reference" 4
.el .IP "Assigned value is not \f(CW%s\fR reference" 4
.IX Item "Assigned value is not %s reference"
(F) You tried to assign a reference to a reference constructor, but the
two references were not of the same type.  You cannot alias a scalar to
an array, or an array to a hash; the two types must match.
.Sp
.Vb 4
\&    \e$x = \e@y;  # error
\&    \e@x = \e%y;  # error
\&     $y = [];
\&    \e$x = $y;   # error; did you mean \e$y?
.Ve
.IP "Assigning non-zero to $[ is no longer possible" 4
.IX Item "Assigning non-zero to $[ is no longer possible"
(F) When the \*(L"array_base\*(R" feature is disabled
(e.g., and under \f(CW\*(C`use v5.16;\*(C'\fR, and as of Perl 5.30)
the special variable \f(CW$[\fR, which is deprecated, is now a fixed zero value.
.IP "Assignment to both a list and a scalar" 4
.IX Item "Assignment to both a list and a scalar"
(F) If you assign to a conditional operator, the 2nd and 3rd arguments
must either both be scalars or both be lists.  Otherwise Perl won't
know which context to supply to the right side.
.ie n .IP "Assuming \s-1NOT\s0 a \s-1POSIX\s0 class since %s in regex; marked by <\-\-\ \s-1HERE\s0 in m/%s/" 4
.el .IP "Assuming \s-1NOT\s0 a \s-1POSIX\s0 class since \f(CW%s\fR in regex; marked by <\-\-\ \s-1HERE\s0 in m/%s/" 4
.IX Item "Assuming NOT a POSIX class since %s in regex; marked by <--HERE in m/%s/"
(W regexp) You had something like these:
.Sp
.Vb 2
\& [[:alnum]]
\& [[:digit:xyz]
.Ve
.Sp
They look like they might have been meant to be the \s-1POSIX\s0 classes
\&\f(CW\*(C`[:alnum:]\*(C'\fR or \f(CW\*(C`[:digit:]\*(C'\fR.  If so, they should be written:
.Sp
.Vb 2
\& [[:alnum:]]
\& [[:digit:]xyz]
.Ve
.Sp
Since these aren't legal \s-1POSIX\s0 class specifications, but are legal
bracketed character classes, Perl treats them as the latter.  In the
first example, it matches the characters \f(CW":"\fR, \f(CW"["\fR, \f(CW"a"\fR, \f(CW"l"\fR,
\&\f(CW"m"\fR, \f(CW"n"\fR, and \f(CW"u"\fR.
.Sp
If these weren't meant to be \s-1POSIX\s0 classes, this warning message is
spurious, and can be suppressed by reordering things, such as
.Sp
.Vb 1
\& [[al:num]]
.Ve
.Sp
or
.Sp
.Vb 1
\& [[:munla]]
.Ve
.IP "<> at require-statement should be quotes" 4
.IX Item "<> at require-statement should be quotes"
(F) You wrote \f(CW\*(C`require <file>\*(C'\fR when you should have written
\&\f(CW\*(C`require \*(Aqfile\*(Aq\*(C'\fR.
.IP "Attempt to access disallowed key '%s' in a restricted hash" 4
.IX Item "Attempt to access disallowed key '%s' in a restricted hash"
(F) The failing code has attempted to get or set a key which is not in
the current set of allowed keys of a restricted hash.
.IP "Attempt to bless into a freed package" 4
.IX Item "Attempt to bless into a freed package"
(F) You wrote \f(CW\*(C`bless $foo\*(C'\fR with one argument after somehow causing
the current package to be freed.  Perl cannot figure out what to
do, so it throws up its hands in despair.
.IP "Attempt to bless into a reference" 4
.IX Item "Attempt to bless into a reference"
(F) The \s-1CLASSNAME\s0 argument to the \fBbless()\fR operator is expected to be
the name of the package to bless the resulting object into.  You've
supplied instead a reference to something: perhaps you wrote
.Sp
.Vb 1
\&    bless $self, $proto;
.Ve
.Sp
when you intended
.Sp
.Vb 1
\&    bless $self, ref($proto) || $proto;
.Ve
.Sp
If you actually want to bless into the stringified version
of the reference supplied, you need to stringify it yourself, for
example by:
.Sp
.Vb 1
\&    bless $self, "$proto";
.Ve
.IP "Attempt to clear deleted array" 4
.IX Item "Attempt to clear deleted array"
(S debugging) An array was assigned to when it was being freed.
Freed values are not supposed to be visible to Perl code.  This
can also happen if \s-1XS\s0 code calls \f(CW\*(C`av_clear\*(C'\fR from a custom magic
callback on the array.
.IP "Attempt to delete disallowed key '%s' from a restricted hash" 4
.IX Item "Attempt to delete disallowed key '%s' from a restricted hash"
(F) The failing code attempted to delete from a restricted hash a key
which is not in its key set.
.IP "Attempt to delete readonly key '%s' from a restricted hash" 4
.IX Item "Attempt to delete readonly key '%s' from a restricted hash"
(F) The failing code attempted to delete a key whose value has been
declared readonly from a restricted hash.
.IP "Attempt to free non-arena \s-1SV:\s0 0x%x" 4
.IX Item "Attempt to free non-arena SV: 0x%x"
(S internal) All \s-1SV\s0 objects are supposed to be allocated from arenas
that will be garbage collected on exit.  An \s-1SV\s0 was discovered to be
outside any of those arenas.
.IP "Attempt to free nonexistent shared string '%s'%s" 4
.IX Item "Attempt to free nonexistent shared string '%s'%s"
(S internal) Perl maintains a reference-counted internal table of
strings to optimize the storage and access of hash keys and other
strings.  This indicates someone tried to decrement the reference count
of a string that can no longer be found in the table.
.IP "Attempt to free temp prematurely: \s-1SV\s0 0x%x" 4
.IX Item "Attempt to free temp prematurely: SV 0x%x"
(S debugging) Mortalized values are supposed to be freed by the
\&\fBfree_tmps()\fR routine.  This indicates that something else is freeing the
\&\s-1SV\s0 before the \fBfree_tmps()\fR routine gets a chance, which means that the
\&\fBfree_tmps()\fR routine will be freeing an unreferenced scalar when it does
try to free it.
.IP "Attempt to free unreferenced glob pointers" 4
.IX Item "Attempt to free unreferenced glob pointers"
(S internal) The reference counts got screwed up on symbol aliases.
.IP "Attempt to free unreferenced scalar: \s-1SV\s0 0x%x" 4
.IX Item "Attempt to free unreferenced scalar: SV 0x%x"
(S internal) Perl went to decrement the reference count of a scalar to
see if it would go to 0, and discovered that it had already gone to 0
earlier, and should have been freed, and in fact, probably was freed.
This could indicate that \fBSvREFCNT_dec()\fR was called too many times, or
that \fBSvREFCNT_inc()\fR was called too few times, or that the \s-1SV\s0 was
mortalized when it shouldn't have been, or that memory has been
corrupted.
.IP "Attempt to pack pointer to temporary value" 4
.IX Item "Attempt to pack pointer to temporary value"
(W pack) You tried to pass a temporary value (like the result of a
function, or a computed expression) to the \*(L"p\*(R" \fBpack()\fR template.  This
means the result contains a pointer to a location that could become
invalid anytime, even before the end of the current statement.  Use
literals or global values as arguments to the \*(L"p\*(R" \fBpack()\fR template to
avoid this warning.
.ie n .IP "Attempt to reload %s aborted." 4
.el .IP "Attempt to reload \f(CW%s\fR aborted." 4
.IX Item "Attempt to reload %s aborted."
(F) You tried to load a file with \f(CW\*(C`use\*(C'\fR or \f(CW\*(C`require\*(C'\fR that failed to
compile once already.  Perl will not try to compile this file again
unless you delete its entry from \f(CW%INC\fR.  See \*(L"require\*(R" in perlfunc and
\&\*(L"%INC\*(R" in perlvar.
.IP "Attempt to set length of freed array" 4
.IX Item "Attempt to set length of freed array"
(W misc) You tried to set the length of an array which has
been freed.  You can do this by storing a reference to the
scalar representing the last index of an array and later
assigning through that reference.  For example
.Sp
.Vb 2
\&    $r = do {my @a; \e$#a};
\&    $$r = 503
.Ve
.IP "Attempt to use reference as lvalue in substr" 4
.IX Item "Attempt to use reference as lvalue in substr"
(W substr) You supplied a reference as the first argument to \fBsubstr()\fR
used as an lvalue, which is pretty strange.  Perhaps you forgot to
dereference it first.  See \*(L"substr\*(R" in perlfunc.
.IP "Attribute prototype(%s) discards earlier prototype attribute in same sub" 4
.IX Item "Attribute prototype(%s) discards earlier prototype attribute in same sub"
(W misc) A sub was declared as sub foo : prototype(A) : prototype(B) {}, for
example.  Since each sub can only have one prototype, the earlier
declaration(s) are discarded while the last one is applied.
.IP "av_reify called on tied array" 4
.IX Item "av_reify called on tied array"
(S debugging) This indicates that something went wrong and Perl got \fIvery\fR
confused about \f(CW@_\fR or \f(CW@DB::args\fR being tied.
.ie n .IP "Bad arg length for %s, is %u, should be %d" 4
.el .IP "Bad arg length for \f(CW%s\fR, is \f(CW%u\fR, should be \f(CW%d\fR" 4
.IX Item "Bad arg length for %s, is %u, should be %d"
(F) You passed a buffer of the wrong size to one of \fBmsgctl()\fR, \fBsemctl()\fR
or \fBshmctl()\fR.  In C parlance, the correct sizes are, respectively,
sizeof(struct\ msqid_ds\ *), sizeof(struct\ semid_ds\ *), and
sizeof(struct\ shmid_ds\ *).
.IP "Bad evalled substitution pattern" 4
.IX Item "Bad evalled substitution pattern"
(F) You've used the \f(CW\*(C`/e\*(C'\fR switch to evaluate the replacement for a
substitution, but perl found a syntax error in the code to evaluate,
most likely an unexpected right brace '}'.
.ie n .IP "Bad filehandle: %s" 4
.el .IP "Bad filehandle: \f(CW%s\fR" 4
.IX Item "Bad filehandle: %s"
(F) A symbol was passed to something wanting a filehandle, but the
symbol has no filehandle associated with it.  Perhaps you didn't do an
\&\fBopen()\fR, or did it in another package.
.IP "Bad \fBfree()\fR ignored" 4
.IX Item "Bad free() ignored"
(S malloc) An internal routine called \fBfree()\fR on something that had never
been \fBmalloc()\fRed in the first place.  Mandatory, but can be disabled by
setting environment variable \f(CW\*(C`PERL_BADFREE\*(C'\fR to 0.
.Sp
This message can be seen quite often with DB_File on systems with \*(L"hard\*(R"
dynamic linking, like \f(CW\*(C`AIX\*(C'\fR and \f(CW\*(C`OS/2\*(C'\fR.  It is a bug of \f(CW\*(C`Berkeley DB\*(C'\fR
which is left unnoticed if \f(CW\*(C`DB\*(C'\fR uses \fIforgiving\fR system \fBmalloc()\fR.
.IP "Bad hash" 4
.IX Item "Bad hash"
(P) One of the internal hash routines was passed a null \s-1HV\s0 pointer.
.IP "Badly placed ()'s" 4
.IX Item "Badly placed ()'s"
(A) You've accidentally run your script through \fBcsh\fR instead
of Perl.  Check the #! line, or manually feed your script into
Perl yourself.
.ie n .IP "Bad name after %s" 4
.el .IP "Bad name after \f(CW%s\fR" 4
.IX Item "Bad name after %s"
(F) You started to name a symbol by using a package prefix, and then
didn't finish the symbol.  In particular, you can't interpolate outside
of quotes, so
.Sp
.Vb 2
\&    $var = \*(Aqmyvar\*(Aq;
\&    $sym = mypack::$var;
.Ve
.Sp
is not the same as
.Sp
.Vb 2
\&    $var = \*(Aqmyvar\*(Aq;
\&    $sym = "mypack::$var";
.Ve
.IP "Bad plugin affecting keyword '%s'" 4
.IX Item "Bad plugin affecting keyword '%s'"
(F) An extension using the keyword plugin mechanism violated the
plugin \s-1API.\s0
.IP "Bad \fBrealloc()\fR ignored" 4
.IX Item "Bad realloc() ignored"
(S malloc) An internal routine called \fBrealloc()\fR on something that
had never been \fBmalloc()\fRed in the first place.  Mandatory, but can
be disabled by setting the environment variable \f(CW\*(C`PERL_BADFREE\*(C'\fR to 1.
.IP "Bad symbol for array" 4
.IX Item "Bad symbol for array"
(P) An internal request asked to add an array entry to something that
wasn't a symbol table entry.
.IP "Bad symbol for dirhandle" 4
.IX Item "Bad symbol for dirhandle"
(P) An internal request asked to add a dirhandle entry to something
that wasn't a symbol table entry.
.IP "Bad symbol for filehandle" 4
.IX Item "Bad symbol for filehandle"
(P) An internal request asked to add a filehandle entry to something
that wasn't a symbol table entry.
.IP "Bad symbol for hash" 4
.IX Item "Bad symbol for hash"
(P) An internal request asked to add a hash entry to something that
wasn't a symbol table entry.
.IP "Bad symbol for scalar" 4
.IX Item "Bad symbol for scalar"
(P) An internal request asked to add a scalar entry to something that
wasn't a symbol table entry.
.IP "Bareword found in conditional" 4
.IX Item "Bareword found in conditional"
(W bareword) The compiler found a bareword where it expected a
conditional, which often indicates that an || or && was parsed as part
of the last argument of the previous construct, for example:
.Sp
.Vb 1
\&    open FOO || die;
.Ve
.Sp
It may also indicate a misspelled constant that has been interpreted as
a bareword:
.Sp
.Vb 2
\&    use constant TYPO => 1;
\&    if (TYOP) { print "foo" }
.Ve
.Sp
The \f(CW\*(C`strict\*(C'\fR pragma is useful in avoiding such errors.
.ie n .IP "Bareword in require contains ""%s""" 4
.el .IP "Bareword in require contains ``%s''" 4
.IX Item "Bareword in require contains %s"
.PD 0
.ie n .IP "Bareword in require maps to disallowed filename ""%s""" 4
.el .IP "Bareword in require maps to disallowed filename ``%s''" 4
.IX Item "Bareword in require maps to disallowed filename %s"
.IP "Bareword in require maps to empty filename" 4
.IX Item "Bareword in require maps to empty filename"
.PD
(F) The bareword form of require has been invoked with a filename which could
not have been generated by a valid bareword permitted by the parser.  You
shouldn't be able to get this error from Perl code, but \s-1XS\s0 code may throw it
if it passes an invalid module name to \f(CW\*(C`Perl_load_module\*(C'\fR.
.ie n .IP "Bareword in require must not start with a double-colon: ""%s""" 4
.el .IP "Bareword in require must not start with a double-colon: ``%s''" 4
.IX Item "Bareword in require must not start with a double-colon: %s"
(F) In \f(CW\*(C`require Bare::Word\*(C'\fR, the bareword is not allowed to start with a
double-colon.  Write \f(CW\*(C`require ::Foo::Bar\*(C'\fR as  \f(CW\*(C`require Foo::Bar\*(C'\fR instead.
.ie n .IP "Bareword ""%s"" not allowed while ""strict subs"" in use" 4
.el .IP "Bareword ``%s'' not allowed while ``strict subs'' in use" 4
.IX Item "Bareword %s not allowed while strict subs in use"
(F) With \*(L"strict subs\*(R" in use, a bareword is only allowed as a
subroutine identifier, in curly brackets or to the left of the \*(L"=>\*(R"
symbol.  Perhaps you need to predeclare a subroutine?
.ie n .IP "Bareword ""%s"" refers to nonexistent package" 4
.el .IP "Bareword ``%s'' refers to nonexistent package" 4
.IX Item "Bareword %s refers to nonexistent package"
(W bareword) You used a qualified bareword of the form \f(CW\*(C`Foo::\*(C'\fR, but the
compiler saw no other uses of that namespace before that point.  Perhaps
you need to predeclare a package?
.IP "\s-1BEGIN\s0 failed\*(--compilation aborted" 4
.IX Item "BEGIN failedcompilation aborted"
(F) An untrapped exception was raised while executing a \s-1BEGIN\s0
subroutine.  Compilation stops immediately and the interpreter is
exited.
.IP "\s-1BEGIN\s0 not safe after errors\*(--compilation aborted" 4
.IX Item "BEGIN not safe after errorscompilation aborted"
(F) Perl found a \f(CW\*(C`BEGIN {}\*(C'\fR subroutine (or a \f(CW\*(C`use\*(C'\fR directive, which
implies a \f(CW\*(C`BEGIN {}\*(C'\fR) after one or more compilation errors had already
occurred.  Since the intended environment for the \f(CW\*(C`BEGIN {}\*(C'\fR could not
be guaranteed (due to the errors), and since subsequent code likely
depends on its correct operation, Perl just gave up.
.IP "\e%d better written as $%d" 4
.IX Item "%d better written as $%d"
(W syntax) Outside of patterns, backreferences live on as variables.
The use of backslashes is grandfathered on the right-hand side of a
substitution, but stylistically it's better to use the variable form
because other Perl programmers will expect it, and it works better if
there are more than 9 backreferences.
.IP "Binary number > 0b11111111111111111111111111111111 non-portable" 4
.IX Item "Binary number > 0b11111111111111111111111111111111 non-portable"
(W portable) The binary number you specified is larger than 2**32\-1
(4294967295) and therefore non-portable between systems.  See
perlport for more on portability concerns.
.ie n .IP "\fBbind()\fR on closed socket %s" 4
.el .IP "\fBbind()\fR on closed socket \f(CW%s\fR" 4
.IX Item "bind() on closed socket %s"
(W closed) You tried to do a bind on a closed socket.  Did you forget to
check the return value of your \fBsocket()\fR call?  See \*(L"bind\*(R" in perlfunc.
.ie n .IP "\fBbinmode()\fR on closed filehandle %s" 4
.el .IP "\fBbinmode()\fR on closed filehandle \f(CW%s\fR" 4
.IX Item "binmode() on closed filehandle %s"
(W unopened) You tried \fBbinmode()\fR on a filehandle that was never opened.
Check your control flow and number of arguments.
.IP "Bit vector size > 32 non-portable" 4
.IX Item "Bit vector size > 32 non-portable"
(W portable) Using bit vector sizes larger than 32 is non-portable.
.ie n .IP "Bizarre copy of %s" 4
.el .IP "Bizarre copy of \f(CW%s\fR" 4
.IX Item "Bizarre copy of %s"
(P) Perl detected an attempt to copy an internal value that is not
copiable.
.IP "Bizarre SvTYPE [%d]" 4
.IX Item "Bizarre SvTYPE [%d]"
(P) When starting a new thread or returning values from a thread, Perl
encountered an invalid data type.
.IP "Both or neither range ends should be Unicode in regex; marked by <\-\-\ \s-1HERE\s0 in m/%s/" 4
.IX Item "Both or neither range ends should be Unicode in regex; marked by <--HERE in m/%s/"
(W regexp) (only under \f(CW\*(C`use\ re\ \*(Aqstrict\*(Aq\*(C'\fR or within \f(CW\*(C`(?[...])\*(C'\fR)
.Sp
In a bracketed character class in a regular expression pattern, you
had a range which has exactly one end of it specified using \f(CW\*(C`\eN{}\*(C'\fR, and
the other end is specified using a non-portable mechanism.  Perl treats
the range as a Unicode range, that is, all the characters in it are
considered to be the Unicode characters, and which may be different code
points on some platforms Perl runs on.  For example, \f(CW\*(C`[\eN{U+06}\-\ex08]\*(C'\fR
is treated as if you had instead said \f(CW\*(C`[\eN{U+06}\-\eN{U+08}]\*(C'\fR, that is it
matches the characters whose code points in Unicode are 6, 7, and 8.
But that \f(CW\*(C`\ex08\*(C'\fR might indicate that you meant something different, so
the warning gets raised.
.ie n .IP "Buffer overflow in prime_env_iter: %s" 4
.el .IP "Buffer overflow in prime_env_iter: \f(CW%s\fR" 4
.IX Item "Buffer overflow in prime_env_iter: %s"
(W internal) A warning peculiar to \s-1VMS.\s0  While Perl was preparing to
iterate over \f(CW%ENV\fR, it encountered a logical name or symbol definition
which was too long, so it was truncated to the string shown.
.IP "Callback called exit" 4
.IX Item "Callback called exit"
(F) A subroutine invoked from an external package via \fBcall_sv()\fR
exited by calling exit.
.IP "%s() called too early to check prototype" 4
.IX Item "%s() called too early to check prototype"
(W prototype) You've called a function that has a prototype before the
parser saw a definition or declaration for it, and Perl could not check
that the call conforms to the prototype.  You need to either add an
early prototype declaration for the subroutine in question, or move the
subroutine definition ahead of the call to get proper prototype
checking.  Alternatively, if you are certain that you're calling the
function correctly, you may put an ampersand before the name to avoid
the warning.  See perlsub.
.ie n .IP "Cannot chr %f" 4
.el .IP "Cannot chr \f(CW%f\fR" 4
.IX Item "Cannot chr %f"
(F) You passed an invalid number (like an infinity or not-a-number) to \f(CW\*(C`chr\*(C'\fR.
.ie n .IP "Cannot complete in-place edit of %s: %s" 4
.el .IP "Cannot complete in-place edit of \f(CW%s:\fR \f(CW%s\fR" 4
.IX Item "Cannot complete in-place edit of %s: %s"
(F) Your perl script appears to have changed directory while
performing an in-place edit of a file specified by a relative path,
and your system doesn't include the directory relative \s-1POSIX\s0 functions
needed to handle that.
.ie n .IP "Cannot compress %f in pack" 4
.el .IP "Cannot compress \f(CW%f\fR in pack" 4
.IX Item "Cannot compress %f in pack"
(F) You tried compressing an infinity or not-a-number as an unsigned
integer with \s-1BER,\s0 which makes no sense.
.IP "Cannot compress integer in pack" 4
.IX Item "Cannot compress integer in pack"
(F) An argument to pack(\*(L"w\*(R",...) was too large to compress.
The \s-1BER\s0 compressed integer format can only be used with positive
integers, and you attempted to compress a very large number (> 1e308).
See \*(L"pack\*(R" in perlfunc.
.IP "Cannot compress negative numbers in pack" 4
.IX Item "Cannot compress negative numbers in pack"
(F) An argument to pack(\*(L"w\*(R",...) was negative.  The \s-1BER\s0 compressed integer
format can only be used with positive integers.  See \*(L"pack\*(R" in perlfunc.
.ie n .IP "Cannot convert a reference to %s to typeglob" 4
.el .IP "Cannot convert a reference to \f(CW%s\fR to typeglob" 4
.IX Item "Cannot convert a reference to %s to typeglob"
(F) You manipulated Perl's symbol table directly, stored a reference
in it, then tried to access that symbol via conventional Perl syntax.
The access triggers Perl to autovivify that typeglob, but it there is
no legal conversion from that type of reference to a typeglob.
.ie n .IP "Cannot copy to %s" 4
.el .IP "Cannot copy to \f(CW%s\fR" 4
.IX Item "Cannot copy to %s"
(P) Perl detected an attempt to copy a value to an internal type that cannot
be directly assigned to.
.ie n .IP "Cannot find encoding ""%s""" 4
.el .IP "Cannot find encoding ``%s''" 4
.IX Item "Cannot find encoding %s"
(S io) You tried to apply an encoding that did not exist to a filehandle,
either with \fBopen()\fR or \fBbinmode()\fR.
.ie n .IP "Cannot open %s as a dirhandle: it is already open as a filehandle" 4
.el .IP "Cannot open \f(CW%s\fR as a dirhandle: it is already open as a filehandle" 4
.IX Item "Cannot open %s as a dirhandle: it is already open as a filehandle"
(F) You tried to use \fBopendir()\fR to associate a dirhandle to a symbol (glob
or scalar) that already holds a filehandle.  Since this idiom might render
your code confusing, it was deprecated in Perl 5.10.  As of Perl 5.28, it
is a fatal error.
.ie n .IP "Cannot open %s as a filehandle: it is already open as a dirhandle" 4
.el .IP "Cannot open \f(CW%s\fR as a filehandle: it is already open as a dirhandle" 4
.IX Item "Cannot open %s as a filehandle: it is already open as a dirhandle"
(F) You tried to use \fBopen()\fR to associate a filehandle to a symbol (glob
or scalar) that already holds a dirhandle.  Since this idiom might render
your code confusing, it was deprecated in Perl 5.10.  As of Perl 5.28, it
is a fatal error.
.ie n .IP "Cannot pack %f with '%c'" 4
.el .IP "Cannot pack \f(CW%f\fR with '%c'" 4
.IX Item "Cannot pack %f with '%c'"
(F) You tried converting an infinity or not-a-number to an integer,
which makes no sense.
.ie n .IP "Cannot printf %f with '%c'" 4
.el .IP "Cannot printf \f(CW%f\fR with '%c'" 4
.IX Item "Cannot printf %f with '%c'"
(F) You tried printing an infinity or not-a-number as a character (%c),
which makes no sense.  Maybe you meant '%s', or just stringifying it?
.ie n .IP "Cannot set tied @DB::args" 4
.el .IP "Cannot set tied \f(CW@DB::args\fR" 4
.IX Item "Cannot set tied @DB::args"
(F) \f(CW\*(C`caller\*(C'\fR tried to set \f(CW@DB::args\fR, but found it tied.  Tying \f(CW@DB::args\fR
is not supported.  (Before this error was added, it used to crash.)
.IP "Cannot tie unreifiable array" 4
.IX Item "Cannot tie unreifiable array"
(P) You somehow managed to call \f(CW\*(C`tie\*(C'\fR on an array that does not
keep a reference count on its arguments and cannot be made to
do so.  Such arrays are not even supposed to be accessible to
Perl code, but are only used internally.
.IP "Cannot yet reorder \fBsv_vcatpvfn()\fR arguments from va_list" 4
.IX Item "Cannot yet reorder sv_vcatpvfn() arguments from va_list"
(F) Some \s-1XS\s0 code tried to use \f(CW\*(C`sv_vcatpvfn()\*(C'\fR or a related function with a
format string that specifies explicit indexes for some of the elements, and
using a C\-style variable-argument list (a \f(CW\*(C`va_list\*(C'\fR).  This is not currently
supported.  \s-1XS\s0 authors wanting to do this must instead construct a C array
of \f(CW\*(C`SV*\*(C'\fR scalars containing the arguments.
.IP "Can only compress unsigned integers in pack" 4
.IX Item "Can only compress unsigned integers in pack"
(F) An argument to pack(\*(L"w\*(R",...) was not an integer.  The \s-1BER\s0 compressed
integer format can only be used with positive integers, and you attempted
to compress something else.  See \*(L"pack\*(R" in perlfunc.
.IP "Can't bless non-reference value" 4
.IX Item "Can't bless non-reference value"
(F) Only hard references may be blessed.  This is how Perl \*(L"enforces\*(R"
encapsulation of objects.  See perlobj.
.ie n .IP "Can't ""break"" in a loop topicalizer" 4
.el .IP "Can't ``break'' in a loop topicalizer" 4
.IX Item "Can't break in a loop topicalizer"
(F) You called \f(CW\*(C`break\*(C'\fR, but you're in a \f(CW\*(C`foreach\*(C'\fR block rather than
a \f(CW\*(C`given\*(C'\fR block.  You probably meant to use \f(CW\*(C`next\*(C'\fR or \f(CW\*(C`last\*(C'\fR.
.ie n .IP "Can't ""break"" outside a given block" 4
.el .IP "Can't ``break'' outside a given block" 4
.IX Item "Can't break outside a given block"
(F) You called \f(CW\*(C`break\*(C'\fR, but you're not inside a \f(CW\*(C`given\*(C'\fR block.
.ie n .IP "Can't call method ""%s"" on an undefined value" 4
.el .IP "Can't call method ``%s'' on an undefined value" 4
.IX Item "Can't call method %s on an undefined value"
(F) You used the syntax of a method call, but the slot filled by the
object reference or package name contains an undefined value.  Something
like this will reproduce the error:
.Sp
.Vb 3
\&    $BADREF = undef;
\&    process $BADREF 1,2,3;
\&    $BADREF\->process(1,2,3);
.Ve
.ie n .IP "Can't call method ""%s"" on unblessed reference" 4
.el .IP "Can't call method ``%s'' on unblessed reference" 4
.IX Item "Can't call method %s on unblessed reference"
(F) A method call must know in what package it's supposed to run.  It
ordinarily finds this out from the object reference you supply, but you
didn't supply an object reference in this case.  A reference isn't an
object reference until it has been blessed.  See perlobj.
.ie n .IP "Can't call method ""%s"" without a package or object reference" 4
.el .IP "Can't call method ``%s'' without a package or object reference" 4
.IX Item "Can't call method %s without a package or object reference"
(F) You used the syntax of a method call, but the slot filled by the
object reference or package name contains an expression that returns a
defined value which is neither an object reference nor a package name.
Something like this will reproduce the error:
.Sp
.Vb 3
\&    $BADREF = 42;
\&    process $BADREF 1,2,3;
\&    $BADREF\->process(1,2,3);
.Ve
.IP "Can't call \fBmro_isa_changed_in()\fR on anonymous symbol table" 4
.IX Item "Can't call mro_isa_changed_in() on anonymous symbol table"
(P) Perl got confused as to whether a hash was a plain hash or a
symbol table hash when trying to update \f(CW@ISA\fR caches.
.IP "Can't call \fBmro_method_changed_in()\fR on anonymous symbol table" 4
.IX Item "Can't call mro_method_changed_in() on anonymous symbol table"
(F) An \s-1XS\s0 module tried to call \f(CW\*(C`mro_method_changed_in\*(C'\fR on a hash that was
not attached to the symbol table.
.ie n .IP "Can't chdir to %s" 4
.el .IP "Can't chdir to \f(CW%s\fR" 4
.IX Item "Can't chdir to %s"
(F) You called \f(CW\*(C`perl \-x/foo/bar\*(C'\fR, but \fI/foo/bar\fR is not a directory
that you can chdir to, possibly because it doesn't exist.
.ie n .IP "Can't check filesystem of script ""%s"" for nosuid" 4
.el .IP "Can't check filesystem of script ``%s'' for nosuid" 4
.IX Item "Can't check filesystem of script %s for nosuid"
(P) For some reason you can't check the filesystem of the script for
nosuid.
.ie n .IP "Can't coerce %s to %s in %s" 4
.el .IP "Can't coerce \f(CW%s\fR to \f(CW%s\fR in \f(CW%s\fR" 4
.IX Item "Can't coerce %s to %s in %s"
(F) Certain types of SVs, in particular real symbol table entries
(typeglobs), can't be forced to stop being what they are.  So you can't
say things like:
.Sp
.Vb 1
\&    *foo += 1;
.Ve
.Sp
You \s-1CAN\s0 say
.Sp
.Vb 2
\&    $foo = *foo;
\&    $foo += 1;
.Ve
.Sp
but then \f(CW$foo\fR no longer contains a glob.
.ie n .IP "Can't ""continue"" outside a when block" 4
.el .IP "Can't ``continue'' outside a when block" 4
.IX Item "Can't continue outside a when block"
(F) You called \f(CW\*(C`continue\*(C'\fR, but you're not inside a \f(CW\*(C`when\*(C'\fR
or \f(CW\*(C`default\*(C'\fR block.
.IP "Can't create pipe mailbox" 4
.IX Item "Can't create pipe mailbox"
(P) An error peculiar to \s-1VMS.\s0  The process is suffering from exhausted
quotas or other plumbing problems.
.ie n .IP "Can't declare %s in ""%s""" 4
.el .IP "Can't declare \f(CW%s\fR in ``%s''" 4
.IX Item "Can't declare %s in %s"
(F) Only scalar, array, and hash variables may be declared as \*(L"my\*(R", \*(L"our\*(R" or
\&\*(L"state\*(R" variables.  They must have ordinary identifiers as names.
.ie n .IP "Can't ""default"" outside a topicalizer" 4
.el .IP "Can't ``default'' outside a topicalizer" 4
.IX Item "Can't default outside a topicalizer"
(F) You have used a \f(CW\*(C`default\*(C'\fR block that is neither inside a
\&\f(CW\*(C`foreach\*(C'\fR loop nor a \f(CW\*(C`given\*(C'\fR block.  (Note that this error is
issued on exit from the \f(CW\*(C`default\*(C'\fR block, so you won't get the
error if you use an explicit \f(CW\*(C`continue\*(C'\fR.)
.ie n .IP "Can't determine class of operator %s, assuming \s-1BASEOP\s0" 4
.el .IP "Can't determine class of operator \f(CW%s\fR, assuming \s-1BASEOP\s0" 4
.IX Item "Can't determine class of operator %s, assuming BASEOP"
(S) This warning indicates something wrong in the internals of perl.
Perl was trying to find the class (e.g. \s-1LISTOP\s0) of a particular \s-1OP,\s0
and was unable to do so. This is likely to be due to a bug in the perl
internals, or due to a bug in \s-1XS\s0 code which manipulates perl optrees.
.ie n .IP "Can't do inplace edit: %s is not a regular file" 4
.el .IP "Can't do inplace edit: \f(CW%s\fR is not a regular file" 4
.IX Item "Can't do inplace edit: %s is not a regular file"
(S inplace) You tried to use the \fB\-i\fR switch on a special file, such as
a file in /dev, a \s-1FIFO\s0 or an uneditable directory.  The file was ignored.
.ie n .IP "Can't do inplace edit on %s: %s" 4
.el .IP "Can't do inplace edit on \f(CW%s:\fR \f(CW%s\fR" 4
.IX Item "Can't do inplace edit on %s: %s"
(S inplace) The creation of the new file failed for the indicated
reason.
.ie n .IP "Can't do inplace edit: %s would not be unique" 4
.el .IP "Can't do inplace edit: \f(CW%s\fR would not be unique" 4
.IX Item "Can't do inplace edit: %s would not be unique"
(S inplace) Your filesystem does not support filenames longer than 14
characters and Perl was unable to create a unique filename during
inplace editing with the \fB\-i\fR switch.  The file was ignored.
.ie n .IP "Can't do %s(""%s"") on non\-UTF\-8 locale; resolved to ""%s""." 4
.el .IP "Can't do %s(``%s'') on non\-UTF\-8 locale; resolved to ``%s''." 4
.IX Item "Can't do %s(%s) on non-UTF-8 locale; resolved to %s."
(W locale) You are 1) running under "\f(CW\*(C`use locale\*(C'\fR"; 2) the current
locale is not a \s-1UTF\-8\s0 one; 3) you tried to do the designated case-change
operation on the specified Unicode character; and 4) the result of this
operation would mix Unicode and locale rules, which likely conflict.
Mixing of different rule types is forbidden, so the operation was not
done; instead the result is the indicated value, which is the best
available that uses entirely Unicode rules.  That turns out to almost
always be the original character, unchanged.
.Sp
It is generally a bad idea to mix non\-UTF\-8 locales and Unicode, and
this issue is one of the reasons why.  This warning is raised when
Unicode rules would normally cause the result of this operation to
contain a character that is in the range specified by the locale,
0..255, and hence is subject to the locale's rules, not Unicode's.
.Sp
If you are using locale purely for its characteristics related to things
like its numeric and time formatting (and not \f(CW\*(C`LC_CTYPE\*(C'\fR), consider
using a restricted form of the locale pragma (see \*(L"The \*(R"use
locale\*(L" pragma\*(R" in perllocale) like "\f(CW\*(C`use\ locale\ \*(Aq:not_characters\*(Aq\*(C'\fR".
.Sp
Note that failed case-changing operations done as a result of
case-insensitive \f(CW\*(C`/i\*(C'\fR regular expression matching will show up in this
warning as having the \f(CW\*(C`fc\*(C'\fR operation (as that is what the regular
expression engine calls behind the scenes.)
.IP "Can't do waitpid with flags" 4
.IX Item "Can't do waitpid with flags"
(F) This machine doesn't have either \fBwaitpid()\fR or \fBwait4()\fR, so only
\&\fBwaitpid()\fR without flags is emulated.
.IP "Can't emulate \-%s on #! line" 4
.IX Item "Can't emulate -%s on #! line"
(F) The #! line specifies a switch that doesn't make sense at this
point.  For example, it'd be kind of silly to put a \fB\-x\fR on the #!
line.
.ie n .IP "Can't %s %s\-endian %ss on this platform" 4
.el .IP "Can't \f(CW%s\fR \f(CW%s\fR\-endian \f(CW%ss\fR on this platform" 4
.IX Item "Can't %s %s-endian %ss on this platform"
(F) Your platform's byte-order is neither big-endian nor little-endian,
or it has a very strange pointer size.  Packing and unpacking big\- or
little-endian floating point values and pointers may not be possible.
See \*(L"pack\*(R" in perlfunc.
.ie n .IP "Can't exec ""%s"": %s" 4
.el .IP "Can't exec ``%s'': \f(CW%s\fR" 4
.IX Item "Can't exec %s: %s"
(W exec) A \fBsystem()\fR, \fBexec()\fR, or piped open call could not execute the
named program for the indicated reason.  Typical reasons include: the
permissions were wrong on the file, the file wasn't found in
\&\f(CW$ENV{PATH}\fR, the executable in question was compiled for another
architecture, or the #! line in a script points to an interpreter that
can't be run for similar reasons.  (Or maybe your system doesn't support
#! at all.)
.ie n .IP "Can't exec %s" 4
.el .IP "Can't exec \f(CW%s\fR" 4
.IX Item "Can't exec %s"
(F) Perl was trying to execute the indicated program for you because
that's what the #! line said.  If that's not what you wanted, you may
need to mention \*(L"perl\*(R" on the #! line somewhere.
.ie n .IP "Can't execute %s" 4
.el .IP "Can't execute \f(CW%s\fR" 4
.IX Item "Can't execute %s"
(F) You used the \fB\-S\fR switch, but the copies of the script to execute
found in the \s-1PATH\s0 did not have correct permissions.
.ie n .IP "Can't find an opnumber for ""%s""" 4
.el .IP "Can't find an opnumber for ``%s''" 4
.IX Item "Can't find an opnumber for %s"
(F) A string of a form \f(CW\*(C`CORE::word\*(C'\fR was given to \fBprototype()\fR, but there
is no builtin with the name \f(CW\*(C`word\*(C'\fR.
.ie n .IP "Can't find label %s" 4
.el .IP "Can't find label \f(CW%s\fR" 4
.IX Item "Can't find label %s"
(F) You said to goto a label that isn't mentioned anywhere that it's
possible for us to go to.  See \*(L"goto\*(R" in perlfunc.
.ie n .IP "Can't find %s on \s-1PATH\s0" 4
.el .IP "Can't find \f(CW%s\fR on \s-1PATH\s0" 4
.IX Item "Can't find %s on PATH"
(F) You used the \fB\-S\fR switch, but the script to execute could not be
found in the \s-1PATH.\s0
.ie n .IP "Can't find %s on \s-1PATH,\s0 '.' not in \s-1PATH\s0" 4
.el .IP "Can't find \f(CW%s\fR on \s-1PATH,\s0 '.' not in \s-1PATH\s0" 4
.IX Item "Can't find %s on PATH, '.' not in PATH"
(F) You used the \fB\-S\fR switch, but the script to execute could not be
found in the \s-1PATH,\s0 or at least not with the correct permissions.  The
script exists in the current directory, but \s-1PATH\s0 prohibits running it.
.ie n .IP "Can't find string terminator %s anywhere before \s-1EOF\s0" 4
.el .IP "Can't find string terminator \f(CW%s\fR anywhere before \s-1EOF\s0" 4
.IX Item "Can't find string terminator %s anywhere before EOF"
(F) Perl strings can stretch over multiple lines.  This message means
that the closing delimiter was omitted.  Because bracketed quotes count
nesting levels, the following is missing its final parenthesis:
.Sp
.Vb 1
\&    print q(The character \*(Aq(\*(Aq starts a side comment.);
.Ve
.Sp
If you're getting this error from a here-document, you may have
included unseen whitespace before or after your closing tag or there
may not be a linebreak after it.  A good programmer's editor will have
a way to help you find these characters (or lack of characters).  See
perlop for the full details on here-documents.
.ie n .IP "Can't find Unicode property definition ""%s""" 4
.el .IP "Can't find Unicode property definition ``%s''" 4
.IX Item "Can't find Unicode property definition %s"
.PD 0
.ie n .IP "Can't find Unicode property definition ""%s"" in regex; marked by <\-\- \s-1HERE\s0 in m/%s/" 4
.el .IP "Can't find Unicode property definition ``%s'' in regex; marked by <\-\- \s-1HERE\s0 in m/%s/" 4
.IX Item "Can't find Unicode property definition %s in regex; marked by <-- HERE in m/%s/"
.PD
(F) The named property which you specified via \f(CW\*(C`\ep\*(C'\fR or \f(CW\*(C`\eP\*(C'\fR is not one
known to Perl.  Perhaps you misspelled the name?  See
\&\*(L"Properties accessible through \ep{} and \eP{}\*(R" in perluniprops
for a complete list of available official
properties.  If it is a
user-defined property
it must have been defined by the time the regular expression is
matched.
.Sp
If you didn't mean to use a Unicode property, escape the \f(CW\*(C`\ep\*(C'\fR, either
by \f(CW\*(C`\e\ep\*(C'\fR (just the \f(CW\*(C`\ep\*(C'\fR) or by \f(CW\*(C`\eQ\ep\*(C'\fR (the rest of the string, or
until \f(CW\*(C`\eE\*(C'\fR).
.ie n .IP "Can't fork: %s" 4
.el .IP "Can't fork: \f(CW%s\fR" 4
.IX Item "Can't fork: %s"
(F) A fatal error occurred while trying to fork while opening a
pipeline.
.IP "Can't fork, trying again in 5 seconds" 4
.IX Item "Can't fork, trying again in 5 seconds"
(W pipe) A fork in a piped open failed with \s-1EAGAIN\s0 and will be retried
after five seconds.
.IP "Can't get filespec \- stale stat buffer?" 4
.IX Item "Can't get filespec - stale stat buffer?"
(S) A warning peculiar to \s-1VMS.\s0  This arises because of the difference
between access checks under \s-1VMS\s0 and under the Unix model Perl assumes.
Under \s-1VMS,\s0 access checks are done by filename, rather than by bits in
the stat buffer, so that ACLs and other protections can be taken into
account.  Unfortunately, Perl assumes that the stat buffer contains all
the necessary information, and passes it, instead of the filespec, to
the access-checking routine.  It will try to retrieve the filespec using
the device name and \s-1FID\s0 present in the stat buffer, but this works only
if you haven't made a subsequent call to the \s-1CRTL\s0 \fBstat()\fR routine,
because the device name is overwritten with each call.  If this warning
appears, the name lookup failed, and the access-checking routine gave up
and returned \s-1FALSE,\s0 just to be conservative.  (Note: The access-checking
routine knows about the Perl \f(CW\*(C`stat\*(C'\fR operator and file tests, so you
shouldn't ever see this warning in response to a Perl command; it arises
only if some internal code takes stat buffers lightly.)
.IP "Can't get pipe mailbox device name" 4
.IX Item "Can't get pipe mailbox device name"
(P) An error peculiar to \s-1VMS.\s0  After creating a mailbox to act as a
pipe, Perl can't retrieve its name for later use.
.IP "Can't get \s-1SYSGEN\s0 parameter value for \s-1MAXBUF\s0" 4
.IX Item "Can't get SYSGEN parameter value for MAXBUF"
(P) An error peculiar to \s-1VMS.\s0  Perl asked \f(CW$GETSYI\fR how big you want your
mailbox buffers to be, and didn't get an answer.
.ie n .IP "Can't ""goto"" into a binary or list expression" 4
.el .IP "Can't ``goto'' into a binary or list expression" 4
.IX Item "Can't goto into a binary or list expression"
(F) A \*(L"goto\*(R" statement was executed to jump into the middle of a binary
or list expression.  You can't get there from here.  The reason for this
restriction is that the interpreter would get confused as to how many
arguments there are, resulting in stack corruption or crashes.  This
error occurs in cases such as these:
.Sp
.Vb 2
\&    goto F;
\&    print do { F: }; # Can\*(Aqt jump into the arguments to print
\&
\&    goto G;
\&    $x + do { G: $y }; # How is + supposed to get its first operand?
.Ve
.ie n .IP "Can't ""goto"" into a ""given"" block" 4
.el .IP "Can't ``goto'' into a ``given'' block" 4
.IX Item "Can't goto into a given block"
(F) A \*(L"goto\*(R" statement was executed to jump into the middle of a \f(CW\*(C`given\*(C'\fR
block.  You can't get there from here.  See \*(L"goto\*(R" in perlfunc.
.ie n .IP "Can't ""goto"" into the middle of a foreach loop" 4
.el .IP "Can't ``goto'' into the middle of a foreach loop" 4
.IX Item "Can't goto into the middle of a foreach loop"
(F) A \*(L"goto\*(R" statement was executed to jump into the middle of a foreach
loop.  You can't get there from here.  See \*(L"goto\*(R" in perlfunc.
.ie n .IP "Can't ""goto"" out of a pseudo block" 4
.el .IP "Can't ``goto'' out of a pseudo block" 4
.IX Item "Can't goto out of a pseudo block"
(F) A \*(L"goto\*(R" statement was executed to jump out of what might look like
a block, except that it isn't a proper block.  This usually occurs if
you tried to jump out of a \fBsort()\fR block or subroutine, which is a no-no.
See \*(L"goto\*(R" in perlfunc.
.IP "Can't goto subroutine from an eval\-%s" 4
.IX Item "Can't goto subroutine from an eval-%s"
(F) The \*(L"goto subroutine\*(R" call can't be used to jump out of an eval
\&\*(L"string\*(R" or block.
.IP "Can't goto subroutine from a sort sub (or similar callback)" 4
.IX Item "Can't goto subroutine from a sort sub (or similar callback)"
(F) The \*(L"goto subroutine\*(R" call can't be used to jump out of the
comparison sub for a \fBsort()\fR, or from a similar callback (such
as the \fBreduce()\fR function in List::Util).
.IP "Can't goto subroutine outside a subroutine" 4
.IX Item "Can't goto subroutine outside a subroutine"
(F) The deeply magical \*(L"goto subroutine\*(R" call can only replace one
subroutine call for another.  It can't manufacture one out of whole
cloth.  In general you should be calling it out of only an \s-1AUTOLOAD\s0
routine anyway.  See \*(L"goto\*(R" in perlfunc.
.IP "Can't ignore signal \s-1CHLD,\s0 forcing to default" 4
.IX Item "Can't ignore signal CHLD, forcing to default"
(W signal) Perl has detected that it is being run with the \s-1SIGCHLD\s0
signal (sometimes known as \s-1SIGCLD\s0) disabled.  Since disabling this
signal will interfere with proper determination of exit status of child
processes, Perl has reset the signal to its default value.  This
situation typically indicates that the parent program under which Perl
may be running (e.g. cron) is being very careless.
.IP "Can't kill a non-numeric process \s-1ID\s0" 4
.IX Item "Can't kill a non-numeric process ID"
(F) Process identifiers must be (signed) integers.  It is a fatal error to
attempt to \fBkill()\fR an undefined, empty-string or otherwise non-numeric
process identifier.
.ie n .IP "Can't ""last"" outside a loop block" 4
.el .IP "Can't ``last'' outside a loop block" 4
.IX Item "Can't last outside a loop block"
(F) A \*(L"last\*(R" statement was executed to break out of the current block,
except that there's this itty bitty problem called there isn't a current
block.  Note that an \*(L"if\*(R" or \*(L"else\*(R" block doesn't count as a \*(L"loopish\*(R"
block, as doesn't a block given to \fBsort()\fR, \fBmap()\fR or \fBgrep()\fR.  You can
usually double the curlies to get the same effect though, because the
inner curlies will be considered a block that loops once.  See
\&\*(L"last\*(R" in perlfunc.
.IP "Can't linearize anonymous symbol table" 4
.IX Item "Can't linearize anonymous symbol table"
(F) Perl tried to calculate the method resolution order (\s-1MRO\s0) of a
package, but failed because the package stash has no name.
.ie n .IP "Can't load '%s' for module %s" 4
.el .IP "Can't load '%s' for module \f(CW%s\fR" 4
.IX Item "Can't load '%s' for module %s"
(F) The module you tried to load failed to load a dynamic extension.
This may either mean that you upgraded your version of perl to one
that is incompatible with your old dynamic extensions (which is known
to happen between major versions of perl), or (more likely) that your
dynamic extension was built against an older version of the library
that is installed on your system.  You may need to rebuild your old
dynamic extensions.
.ie n .IP "Can't localize lexical variable %s" 4
.el .IP "Can't localize lexical variable \f(CW%s\fR" 4
.IX Item "Can't localize lexical variable %s"
(F) You used local on a variable name that was previously declared as a
lexical variable using \*(L"my\*(R" or \*(L"state\*(R".  This is not allowed.  If you
want to localize a package variable of the same name, qualify it with
the package name.
.IP "Can't localize through a reference" 4
.IX Item "Can't localize through a reference"
(F) You said something like \f(CW\*(C`local $$ref\*(C'\fR, which Perl can't currently
handle, because when it goes to restore the old value of whatever \f(CW$ref\fR
pointed to after the scope of the \fBlocal()\fR is finished, it can't be sure
that \f(CW$ref\fR will still be a reference.
.ie n .IP "Can't locate %s" 4
.el .IP "Can't locate \f(CW%s\fR" 4
.IX Item "Can't locate %s"
(F) You said to \f(CW\*(C`do\*(C'\fR (or \f(CW\*(C`require\*(C'\fR, or \f(CW\*(C`use\*(C'\fR) a file that couldn't be found.
Perl looks for the file in all the locations mentioned in \f(CW@INC\fR, unless
the file name included the full path to the file.  Perhaps you need
to set the \s-1PERL5LIB\s0 or \s-1PERL5OPT\s0 environment variable to say where the
extra library is, or maybe the script needs to add the library name
to \f(CW@INC\fR.  Or maybe you just misspelled the name of the file.  See
\&\*(L"require\*(R" in perlfunc and lib.
.ie n .IP "Can't locate auto/%s.al in @INC" 4
.el .IP "Can't locate auto/%s.al in \f(CW@INC\fR" 4
.IX Item "Can't locate auto/%s.al in @INC"
(F) A function (or method) was called in a package which allows
autoload, but there is no function to autoload.  Most probable causes
are a misprint in a function/method name or a failure to \f(CW\*(C`AutoSplit\*(C'\fR
the file, say, by doing \f(CW\*(C`make install\*(C'\fR.
.ie n .IP "Can't locate loadable object for module %s in @INC" 4
.el .IP "Can't locate loadable object for module \f(CW%s\fR in \f(CW@INC\fR" 4
.IX Item "Can't locate loadable object for module %s in @INC"
(F) The module you loaded is trying to load an external library, like
for example, \fIfoo.so\fR or \fIbar.dll\fR, but the DynaLoader module was
unable to locate this library.  See DynaLoader.
.ie n .IP "Can't locate object method ""%s"" via package ""%s""" 4
.el .IP "Can't locate object method ``%s'' via package ``%s''" 4
.IX Item "Can't locate object method %s via package %s"
(F) You called a method correctly, and it correctly indicated a package
functioning as a class, but that package doesn't define that particular
method, nor does any of its base classes.  See perlobj.
.ie n .IP "Can't locate object method ""%s"" via package ""%s"" (perhaps you forgot to load ""%s""?)" 4
.el .IP "Can't locate object method ``%s'' via package ``%s'' (perhaps you forgot to load ``%s''?)" 4
.IX Item "Can't locate object method %s via package %s (perhaps you forgot to load %s?)"
(F) You called a method on a class that did not exist, and the method
could not be found in \s-1UNIVERSAL.\s0  This often means that a method
requires a package that has not been loaded.
.ie n .IP "Can't locate package %s for @%s::ISA" 4
.el .IP "Can't locate package \f(CW%s\fR for @%s::ISA" 4
.IX Item "Can't locate package %s for @%s::ISA"
(W syntax) The \f(CW@ISA\fR array contained the name of another package that
doesn't seem to exist.
.IP "Can't locate PerlIO%s" 4
.IX Item "Can't locate PerlIO%s"
(F) You tried to use in \fBopen()\fR a PerlIO layer that does not exist,
e.g. open(\s-1FH, \*(L"\s0>:nosuchlayer\*(R", \*(L"somefile\*(R").
.ie n .IP "Can't make list assignment to %ENV on this system" 4
.el .IP "Can't make list assignment to \f(CW%ENV\fR on this system" 4
.IX Item "Can't make list assignment to %ENV on this system"
(F) List assignment to \f(CW%ENV\fR is not supported on some systems, notably
\&\s-1VMS.\s0
.ie n .IP "Can't make loaded symbols global on this platform while loading %s" 4
.el .IP "Can't make loaded symbols global on this platform while loading \f(CW%s\fR" 4
.IX Item "Can't make loaded symbols global on this platform while loading %s"
(S) A module passed the flag 0x01 to \fBDynaLoader::dl_load_file()\fR to request
that symbols from the stated file are made available globally within the
process, but that functionality is not available on this platform.  Whilst
the module likely will still work, this may prevent the perl interpreter
from loading other XS-based extensions which need to link directly to
functions defined in the C or \s-1XS\s0 code in the stated file.
.ie n .IP "Can't modify %s in %s" 4
.el .IP "Can't modify \f(CW%s\fR in \f(CW%s\fR" 4
.IX Item "Can't modify %s in %s"
(F) You aren't allowed to assign to the item indicated, or otherwise try
to change it, such as with an auto-increment.
.IP "Can't modify nonexistent substring" 4
.IX Item "Can't modify nonexistent substring"
(P) The internal routine that does assignment to a \fBsubstr()\fR was handed
a \s-1NULL.\s0
.IP "Can't modify non-lvalue subroutine call of &%s" 4
.IX Item "Can't modify non-lvalue subroutine call of &%s"
.PD 0
.ie n .IP "Can't modify non-lvalue subroutine call of &%s in %s" 4
.el .IP "Can't modify non-lvalue subroutine call of &%s in \f(CW%s\fR" 4
.IX Item "Can't modify non-lvalue subroutine call of &%s in %s"
.PD
(F) Subroutines meant to be used in lvalue context should be declared as
such.  See \*(L"Lvalue subroutines\*(R" in perlsub.
.ie n .IP "Can't modify reference to %s in %s assignment" 4
.el .IP "Can't modify reference to \f(CW%s\fR in \f(CW%s\fR assignment" 4
.IX Item "Can't modify reference to %s in %s assignment"
(F) Only a limited number of constructs can be used as the argument to a
reference constructor on the left-hand side of an assignment, and what
you used was not one of them.  See \*(L"Assigning to References\*(R" in perlref.
.IP "Can't modify reference to localized parenthesized array in list assignment" 4
.IX Item "Can't modify reference to localized parenthesized array in list assignment"
(F) Assigning to \f(CW\*(C`\elocal(@array)\*(C'\fR or \f(CW\*(C`\e(local @array)\*(C'\fR is not supported, as
it is not clear exactly what it should do.  If you meant to make \f(CW@array\fR
refer to some other array, use \f(CW\*(C`\e@array = \e@other_array\*(C'\fR.  If you want to
make the elements of \f(CW@array\fR aliases of the scalars referenced on the
right-hand side, use \f(CW\*(C`\e(@array) = @scalar_refs\*(C'\fR.
.IP "Can't modify reference to parenthesized hash in list assignment" 4
.IX Item "Can't modify reference to parenthesized hash in list assignment"
(F) Assigning to \f(CW\*(C`\e(%hash)\*(C'\fR is not supported.  If you meant to make \f(CW%hash\fR
refer to some other hash, use \f(CW\*(C`\e%hash = \e%other_hash\*(C'\fR.  If you want to
make the elements of \f(CW%hash\fR into aliases of the scalars referenced on the
right-hand side, use a hash slice: \f(CW\*(C`\e@hash{@keys} = @those_scalar_refs\*(C'\fR.
.IP "Can't msgrcv to read-only var" 4
.IX Item "Can't msgrcv to read-only var"
(F) The target of a msgrcv must be modifiable to be used as a receive
buffer.
.ie n .IP "Can't ""next"" outside a loop block" 4
.el .IP "Can't ``next'' outside a loop block" 4
.IX Item "Can't next outside a loop block"
(F) A \*(L"next\*(R" statement was executed to reiterate the current block, but
there isn't a current block.  Note that an \*(L"if\*(R" or \*(L"else\*(R" block doesn't
count as a \*(L"loopish\*(R" block, as doesn't a block given to \fBsort()\fR, \fBmap()\fR or
\&\fBgrep()\fR.  You can usually double the curlies to get the same effect
though, because the inner curlies will be considered a block that loops
once.  See \*(L"next\*(R" in perlfunc.
.ie n .IP "Can't open %s: %s" 4
.el .IP "Can't open \f(CW%s:\fR \f(CW%s\fR" 4
.IX Item "Can't open %s: %s"
(S inplace) The implicit opening of a file through use of the \f(CW\*(C`<>\*(C'\fR
filehandle, either implicitly under the \f(CW\*(C`\-n\*(C'\fR or \f(CW\*(C`\-p\*(C'\fR command-line
switches, or explicitly, failed for the indicated reason.  Usually
this is because you don't have read permission for a file which
you named on the command line.
.Sp
(F) You tried to call perl with the \fB\-e\fR switch, but \fI/dev/null\fR (or
your operating system's equivalent) could not be opened.
.IP "Can't open a reference" 4
.IX Item "Can't open a reference"
(W io) You tried to open a scalar reference for reading or writing,
using the 3\-arg \fBopen()\fR syntax:
.Sp
.Vb 1
\&    open FH, \*(Aq>\*(Aq, $ref;
.Ve
.Sp
but your version of perl is compiled without perlio, and this form of
open is not supported.
.IP "Can't open bidirectional pipe" 4
.IX Item "Can't open bidirectional pipe"
(W pipe) You tried to say \f(CW\*(C`open(CMD, "|cmd|")\*(C'\fR, which is not supported.
You can try any of several modules in the Perl library to do this, such
as IPC::Open2.  Alternately, direct the pipe's output to a file using
\&\*(L">\*(R", and then read it in under a different file handle.
.ie n .IP "Can't open error file %s as stderr" 4
.el .IP "Can't open error file \f(CW%s\fR as stderr" 4
.IX Item "Can't open error file %s as stderr"
(F) An error peculiar to \s-1VMS.\s0  Perl does its own command line
redirection, and couldn't open the file specified after '2>' or '2>>' on
the command line for writing.
.ie n .IP "Can't open input file %s as stdin" 4
.el .IP "Can't open input file \f(CW%s\fR as stdin" 4
.IX Item "Can't open input file %s as stdin"
(F) An error peculiar to \s-1VMS.\s0  Perl does its own command line
redirection, and couldn't open the file specified after '<' on the
command line for reading.
.ie n .IP "Can't open output file %s as stdout" 4
.el .IP "Can't open output file \f(CW%s\fR as stdout" 4
.IX Item "Can't open output file %s as stdout"
(F) An error peculiar to \s-1VMS.\s0  Perl does its own command line
redirection, and couldn't open the file specified after '>' or '>>' on
the command line for writing.
.ie n .IP "Can't open output pipe (name: %s)" 4
.el .IP "Can't open output pipe (name: \f(CW%s\fR)" 4
.IX Item "Can't open output pipe (name: %s)"
(P) An error peculiar to \s-1VMS.\s0  Perl does its own command line
redirection, and couldn't open the pipe into which to send data destined
for stdout.
.ie n .IP "Can't open perl script ""%s"": %s" 4
.el .IP "Can't open perl script ``%s'': \f(CW%s\fR" 4
.IX Item "Can't open perl script %s: %s"
(F) The script you specified can't be opened for the indicated reason.
.Sp
If you're debugging a script that uses #!, and normally relies on the
shell's \f(CW$PATH\fR search, the \-S option causes perl to do that search, so
you don't have to type the path or \f(CW\*(C`\`which $scriptname\`\*(C'\fR.
.IP "Can't read \s-1CRTL\s0 environ" 4
.IX Item "Can't read CRTL environ"
(S) A warning peculiar to \s-1VMS.\s0  Perl tried to read an element of \f(CW%ENV\fR
from the \s-1CRTL\s0's internal environment array and discovered the array was
missing.  You need to figure out where your \s-1CRTL\s0 misplaced its environ
or define \fI\s-1PERL_ENV_TABLES\s0\fR (see perlvms) so that environ is not
searched.
.ie n .IP "Can't redeclare ""%s"" in ""%s""" 4
.el .IP "Can't redeclare ``%s'' in ``%s''" 4
.IX Item "Can't redeclare %s in %s"
(F) A \*(L"my\*(R", \*(L"our\*(R" or \*(L"state\*(R" declaration was found within another declaration,
such as \f(CW\*(C`my ($x, my($y), $z)\*(C'\fR or \f(CW\*(C`our (my $x)\*(C'\fR.
.ie n .IP "Can't ""redo"" outside a loop block" 4
.el .IP "Can't ``redo'' outside a loop block" 4
.IX Item "Can't redo outside a loop block"
(F) A \*(L"redo\*(R" statement was executed to restart the current block, but
there isn't a current block.  Note that an \*(L"if\*(R" or \*(L"else\*(R" block doesn't
count as a \*(L"loopish\*(R" block, as doesn't a block given to \fBsort()\fR, \fBmap()\fR
or \fBgrep()\fR.  You can usually double the curlies to get the same effect
though, because the inner curlies will be considered a block that
loops once.  See \*(L"redo\*(R" in perlfunc.
.ie n .IP "Can't remove %s: %s, skipping file" 4
.el .IP "Can't remove \f(CW%s:\fR \f(CW%s\fR, skipping file" 4
.IX Item "Can't remove %s: %s, skipping file"
(S inplace) You requested an inplace edit without creating a backup
file.  Perl was unable to remove the original file to replace it with
the modified file.  The file was left unmodified.
.ie n .IP "Can't rename in-place work file '%s' to '%s': %s" 4
.el .IP "Can't rename in-place work file '%s' to '%s': \f(CW%s\fR" 4
.IX Item "Can't rename in-place work file '%s' to '%s': %s"
(F) When closed implicitly, the temporary file for in-place editing
couldn't be renamed to the original filename.
.ie n .IP "Can't rename %s to %s: %s, skipping file" 4
.el .IP "Can't rename \f(CW%s\fR to \f(CW%s:\fR \f(CW%s\fR, skipping file" 4
.IX Item "Can't rename %s to %s: %s, skipping file"
(F) The rename done by the \fB\-i\fR switch failed for some reason,
probably because you don't have write permission to the directory.
.ie n .IP "Can't reopen input pipe (name: %s) in binary mode" 4
.el .IP "Can't reopen input pipe (name: \f(CW%s\fR) in binary mode" 4
.IX Item "Can't reopen input pipe (name: %s) in binary mode"
(P) An error peculiar to \s-1VMS.\s0  Perl thought stdin was a pipe, and tried
to reopen it to accept binary data.  Alas, it failed.
.IP "Can't represent character for Ox%X on this platform" 4
.IX Item "Can't represent character for Ox%X on this platform"
(F) There is a hard limit to how big a character code point can be due
to the fundamental properties of \s-1UTF\-8,\s0 especially on \s-1EBCDIC\s0
platforms.  The given code point exceeds that.  The only work-around is
to not use such a large code point.
.ie n .IP "Can't reset %ENV on this system" 4
.el .IP "Can't reset \f(CW%ENV\fR on this system" 4
.IX Item "Can't reset %ENV on this system"
(F) You called \f(CW\*(C`reset(\*(AqE\*(Aq)\*(C'\fR or similar, which tried to reset
all variables in the current package beginning with \*(L"E\*(R".  In
the main package, that includes \f(CW%ENV\fR.  Resetting \f(CW%ENV\fR is not
supported on some systems, notably \s-1VMS.\s0
.ie n .IP "Can't resolve method ""%s"" overloading ""%s"" in package ""%s""" 4
.el .IP "Can't resolve method ``%s'' overloading ``%s'' in package ``%s''" 4
.IX Item "Can't resolve method %s overloading %s in package %s"
(F)(P) Error resolving overloading specified by a method name (as
opposed to a subroutine reference): no such method callable via the
package.  If the method name is \f(CW\*(C`???\*(C'\fR, this is an internal error.
.ie n .IP "Can't return %s from lvalue subroutine" 4
.el .IP "Can't return \f(CW%s\fR from lvalue subroutine" 4
.IX Item "Can't return %s from lvalue subroutine"
(F) Perl detected an attempt to return illegal lvalues (such as
temporary or readonly values) from a subroutine used as an lvalue.  This
is not allowed.
.IP "Can't return outside a subroutine" 4
.IX Item "Can't return outside a subroutine"
(F) The return statement was executed in mainline code, that is, where
there was no subroutine call to return out of.  See perlsub.
.ie n .IP "Can't return %s to lvalue scalar context" 4
.el .IP "Can't return \f(CW%s\fR to lvalue scalar context" 4
.IX Item "Can't return %s to lvalue scalar context"
(F) You tried to return a complete array or hash from an lvalue
subroutine, but you called the subroutine in a way that made Perl
think you meant to return only one value.  You probably meant to
write parentheses around the call to the subroutine, which tell
Perl that the call should be in list context.
.ie n .IP "Can't stat script ""%s""" 4
.el .IP "Can't stat script ``%s''" 4
.IX Item "Can't stat script %s"
(P) For some reason you can't \fBfstat()\fR the script even though you have it
open already.  Bizarre.
.ie n .IP "Can't take log of %g" 4
.el .IP "Can't take log of \f(CW%g\fR" 4
.IX Item "Can't take log of %g"
(F) For ordinary real numbers, you can't take the logarithm of a
negative number or zero.  There's a Math::Complex package that comes
standard with Perl, though, if you really want to do that for the
negative numbers.
.ie n .IP "Can't take sqrt of %g" 4
.el .IP "Can't take sqrt of \f(CW%g\fR" 4
.IX Item "Can't take sqrt of %g"
(F) For ordinary real numbers, you can't take the square root of a
negative number.  There's a Math::Complex package that comes standard
with Perl, though, if you really want to do that.
.IP "Can't undef active subroutine" 4
.IX Item "Can't undef active subroutine"
(F) You can't undefine a routine that's currently running.  You can,
however, redefine it while it's running, and you can even undef the
redefined subroutine while the old routine is running.  Go figure.
.IP "Can't unweaken a nonreference" 4
.IX Item "Can't unweaken a nonreference"
(F) You attempted to unweaken something that was not a reference.  Only
references can be unweakened.
.ie n .IP "Can't upgrade %s (%d) to %d" 4
.el .IP "Can't upgrade \f(CW%s\fR (%d) to \f(CW%d\fR" 4
.IX Item "Can't upgrade %s (%d) to %d"
(P) The internal sv_upgrade routine adds \*(L"members\*(R" to an \s-1SV,\s0 making it
into a more specialized kind of \s-1SV.\s0  The top several \s-1SV\s0 types are so
specialized, however, that they cannot be interconverted.  This message
indicates that such a conversion was attempted.
.IP "Can't use '%c' after \-mname" 4
.IX Item "Can't use '%c' after -mname"
(F) You tried to call perl with the \fB\-m\fR switch, but you put something
other than \*(L"=\*(R" after the module name.
.IP "Can't use a hash as a reference" 4
.IX Item "Can't use a hash as a reference"
(F) You tried to use a hash as a reference, as in
\&\f(CW\*(C`%foo\->{"bar"}\*(C'\fR or \f(CW\*(C`%$ref\->{"hello"}\*(C'\fR.  Versions of perl
<= 5.22.0 used to allow this syntax, but shouldn't
have.  This was deprecated in perl 5.6.1.
.IP "Can't use an array as a reference" 4
.IX Item "Can't use an array as a reference"
(F) You tried to use an array as a reference, as in
\&\f(CW\*(C`@foo\->[23]\*(C'\fR or \f(CW\*(C`@$ref\->[99]\*(C'\fR.  Versions of perl <= 5.22.0
used to allow this syntax, but shouldn't have.  This
was deprecated in perl 5.6.1.
.IP "Can't use anonymous symbol table for method lookup" 4
.IX Item "Can't use anonymous symbol table for method lookup"
(F) The internal routine that does method lookup was handed a symbol
table that doesn't have a name.  Symbol tables can become anonymous
for example by undefining stashes: \f(CW\*(C`undef %Some::Package::\*(C'\fR.
.ie n .IP "Can't use an undefined value as %s reference" 4
.el .IP "Can't use an undefined value as \f(CW%s\fR reference" 4
.IX Item "Can't use an undefined value as %s reference"
(F) A value used as either a hard reference or a symbolic reference must
be a defined value.  This helps to delurk some insidious errors.
.ie n .IP "Can't use bareword (""%s"") as %s ref while ""strict refs"" in use" 4
.el .IP "Can't use bareword (``%s'') as \f(CW%s\fR ref while ``strict refs'' in use" 4
.IX Item "Can't use bareword (%s) as %s ref while strict refs in use"
(F) Only hard references are allowed by \*(L"strict refs\*(R".  Symbolic
references are disallowed.  See perlref.
.IP "Can't use %! because Errno.pm is not available" 4
.IX Item "Can't use %! because Errno.pm is not available"
(F) The first time the \f(CW\*(C`%!\*(C'\fR hash is used, perl automatically loads the
Errno.pm module.  The Errno module is expected to tie the %! hash to
provide symbolic names for \f(CW$!\fR errno values.
.ie n .IP "Can't use both '<' and '>' after type '%c' in %s" 4
.el .IP "Can't use both '<' and '>' after type '%c' in \f(CW%s\fR" 4
.IX Item "Can't use both '<' and '>' after type '%c' in %s"
(F) A type cannot be forced to have both big-endian and little-endian
byte-order at the same time, so this combination of modifiers is not
allowed.  See \*(L"pack\*(R" in perlfunc.
.IP "Can't use 'defined(@array)' (Maybe you should just omit the \fBdefined()\fR?)" 4
.IX Item "Can't use 'defined(@array)' (Maybe you should just omit the defined()?)"
(F) \fBdefined()\fR is not useful on arrays because it
checks for an undefined \fIscalar\fR value.  If you want to see if the
array is empty, just use \f(CW\*(C`if (@array) { # not empty }\*(C'\fR for example.
.IP "Can't use 'defined(%hash)' (Maybe you should just omit the \fBdefined()\fR?)" 4
.IX Item "Can't use 'defined(%hash)' (Maybe you should just omit the defined()?)"
(F) \f(CW\*(C`defined()\*(C'\fR is not usually right on hashes.
.Sp
Although \f(CW\*(C`defined %hash\*(C'\fR is false on a plain not-yet-used hash, it
becomes true in several non-obvious circumstances, including iterators,
weak references, stash names, even remaining true after \f(CW\*(C`undef %hash\*(C'\fR.
These things make \f(CW\*(C`defined %hash\*(C'\fR fairly useless in practice, so it now
generates a fatal error.
.Sp
If a check for non-empty is what you wanted then just put it in boolean
context (see \*(L"Scalar values\*(R" in perldata):
.Sp
.Vb 3
\&    if (%hash) {
\&       # not empty
\&    }
.Ve
.Sp
If you had \f(CW\*(C`defined %Foo::Bar::QUUX\*(C'\fR to check whether such a package
variable exists then that's never really been reliable, and isn't
a good way to enquire about the features of a package, or whether
it's loaded, etc.
.ie n .IP "Can't use %s for loop variable" 4
.el .IP "Can't use \f(CW%s\fR for loop variable" 4
.IX Item "Can't use %s for loop variable"
(P) The parser got confused when trying to parse a \f(CW\*(C`foreach\*(C'\fR loop.
.ie n .IP "Can't use global %s in ""%s""" 4
.el .IP "Can't use global \f(CW%s\fR in ``%s''" 4
.IX Item "Can't use global %s in %s"
(F) You tried to declare a magical variable as a lexical variable.  This
is not allowed, because the magic can be tied to only one location
(namely the global variable) and it would be incredibly confusing to
have variables in your program that looked like magical variables but
weren't.
.ie n .IP "Can't use '%c' in a group with different byte-order in %s" 4
.el .IP "Can't use '%c' in a group with different byte-order in \f(CW%s\fR" 4
.IX Item "Can't use '%c' in a group with different byte-order in %s"
(F) You attempted to force a different byte-order on a type
that is already inside a group with a byte-order modifier.
For example you cannot force little-endianness on a type that
is inside a big-endian group.
.ie n .IP "Can't use ""my %s"" in sort comparison" 4
.el .IP "Can't use ``my \f(CW%s\fR'' in sort comparison" 4
.IX Item "Can't use my %s in sort comparison"
(F) The global variables \f(CW$a\fR and \f(CW$b\fR are reserved for sort comparisons.
You mentioned \f(CW$a\fR or \f(CW$b\fR in the same line as the <=> or cmp operator,
and the variable had earlier been declared as a lexical variable.
Either qualify the sort variable with the package name, or rename the
lexical variable.
.ie n .IP "Can't use %s ref as %s ref" 4
.el .IP "Can't use \f(CW%s\fR ref as \f(CW%s\fR ref" 4
.IX Item "Can't use %s ref as %s ref"
(F) You've mixed up your reference types.  You have to dereference a
reference of the type needed.  You can use the \fBref()\fR function to
test the type of the reference, if need be.
.ie n .IP "Can't use string (""%s"") as %s ref while ""strict refs"" in use" 4
.el .IP "Can't use string (``%s'') as \f(CW%s\fR ref while ``strict refs'' in use" 4
.IX Item "Can't use string (%s) as %s ref while strict refs in use"
.PD 0
.ie n .IP "Can't use string (""%s""...) as %s ref while ""strict refs"" in use" 4
.el .IP "Can't use string (``%s''...) as \f(CW%s\fR ref while ``strict refs'' in use" 4
.IX Item "Can't use string (%s...) as %s ref while strict refs in use"
.PD
(F) You've told Perl to dereference a string, something which
\&\f(CW\*(C`use strict\*(C'\fR blocks to prevent it happening accidentally.  See
\&\*(L"Symbolic references\*(R" in perlref.  This can be triggered by an \f(CW\*(C`@\*(C'\fR or \f(CW\*(C`$\*(C'\fR
in a double-quoted string immediately before interpolating a variable,
for example in \f(CW"user @$twitter_id"\fR, which says to treat the contents
of \f(CW$twitter_id\fR as an array reference; use a \f(CW\*(C`\e\*(C'\fR to have a literal \f(CW\*(C`@\*(C'\fR
symbol followed by the contents of \f(CW$twitter_id\fR: \f(CW"user \e@$twitter_id"\fR.
.ie n .IP "Can't use subscript on %s" 4
.el .IP "Can't use subscript on \f(CW%s\fR" 4
.IX Item "Can't use subscript on %s"
(F) The compiler tried to interpret a bracketed expression as a
subscript.  But to the left of the brackets was an expression that
didn't look like a hash or array reference, or anything else subscriptable.
.IP "Can't use \e%c to mean $%c in expression" 4
.IX Item "Can't use %c to mean $%c in expression"
(W syntax) In an ordinary expression, backslash is a unary operator that
creates a reference to its argument.  The use of backslash to indicate a
backreference to a matched substring is valid only as part of a regular
expression pattern.  Trying to do this in ordinary Perl code produces a
value that prints out looking like \s-1\fBSCALAR\s0\fR\|(0xdecaf).  Use the \f(CW$1\fR form
instead.
.IP "Can't weaken a nonreference" 4
.IX Item "Can't weaken a nonreference"
(F) You attempted to weaken something that was not a reference.  Only
references can be weakened.
.ie n .IP "Can't ""when"" outside a topicalizer" 4
.el .IP "Can't ``when'' outside a topicalizer" 4
.IX Item "Can't when outside a topicalizer"
(F) You have used a \fBwhen()\fR block that is neither inside a \f(CW\*(C`foreach\*(C'\fR
loop nor a \f(CW\*(C`given\*(C'\fR block.  (Note that this error is issued on exit
from the \f(CW\*(C`when\*(C'\fR block, so you won't get the error if the match fails,
or if you use an explicit \f(CW\*(C`continue\*(C'\fR.)
.IP "Can't x= to read-only value" 4
.IX Item "Can't x= to read-only value"
(F) You tried to repeat a constant value (often the undefined value)
with an assignment operator, which implies modifying the value itself.
Perhaps you need to copy the value to a temporary, and repeat that.
.ie n .IP "Character following ""\ec"" must be printable \s-1ASCII\s0" 4
.el .IP "Character following ``\ec'' must be printable \s-1ASCII\s0" 4
.IX Item "Character following c must be printable ASCII"
(F) In \f(CW\*(C`\ec\f(CIX\f(CW\*(C'\fR, \fIX\fR must be a printable (non-control) \s-1ASCII\s0 character.
.Sp
Note that \s-1ASCII\s0 characters that don't map to control characters are
discouraged, and will generate the warning (when enabled)
"\*(L"\ec%c\*(R" is more clearly written simply as \*(L"%s\*(R"".
.IP "Character following \e%c must be '{' or a single-character Unicode property name in regex; marked by <\-\- \s-1HERE\s0 in m/%s/" 4
.IX Item "Character following %c must be '{' or a single-character Unicode property name in regex; marked by <-- HERE in m/%s/"
(F) (In the above the \f(CW%c\fR is replaced by either \f(CW\*(C`p\*(C'\fR or \f(CW\*(C`P\*(C'\fR.)  You
specified something that isn't a legal Unicode property name.  Most
Unicode properties are specified by \f(CW\*(C`\ep{...}\*(C'\fR.  But if the name is a
single character one, the braces may be omitted.
.IP "Character in 'C' format wrapped in pack" 4
.IX Item "Character in 'C' format wrapped in pack"
(W pack) You said
.Sp
.Vb 1
\&    pack("C", $x)
.Ve
.Sp
where \f(CW$x\fR is either less than 0 or more than 255; the \f(CW"C"\fR format is
only for encoding native operating system characters (\s-1ASCII, EBCDIC,\s0
and so on) and not for Unicode characters, so Perl behaved as if you meant
.Sp
.Vb 1
\&    pack("C", $x & 255)
.Ve
.Sp
If you actually want to pack Unicode codepoints, use the \f(CW"U"\fR format
instead.
.IP "Character in 'c' format wrapped in pack" 4
.IX Item "Character in 'c' format wrapped in pack"
(W pack) You said
.Sp
.Vb 1
\&    pack("c", $x)
.Ve
.Sp
where \f(CW$x\fR is either less than \-128 or more than 127; the \f(CW"c"\fR format
is only for encoding native operating system characters (\s-1ASCII, EBCDIC,\s0
and so on) and not for Unicode characters, so Perl behaved as if you meant
.Sp
.Vb 1
\&    pack("c", $x & 255);
.Ve
.Sp
If you actually want to pack Unicode codepoints, use the \f(CW"U"\fR format
instead.
.IP "Character in '%c' format wrapped in unpack" 4
.IX Item "Character in '%c' format wrapped in unpack"
(W unpack) You tried something like
.Sp
.Vb 1
\&   unpack("H", "\ex{2a1}")
.Ve
.Sp
where the format expects to process a byte (a character with a value
below 256), but a higher value was provided instead.  Perl uses the
value modulus 256 instead, as if you had provided:
.Sp
.Vb 1
\&   unpack("H", "\ex{a1}")
.Ve
.IP "Character in 'W' format wrapped in pack" 4
.IX Item "Character in 'W' format wrapped in pack"
(W pack) You said
.Sp
.Vb 1
\&    pack("U0W", $x)
.Ve
.Sp
where \f(CW$x\fR is either less than 0 or more than 255.  However, \f(CW\*(C`U0\*(C'\fR\-mode
expects all values to fall in the interval [0, 255], so Perl behaved
as if you meant:
.Sp
.Vb 1
\&    pack("U0W", $x & 255)
.Ve
.IP "Character(s) in '%c' format wrapped in pack" 4
.IX Item "Character(s) in '%c' format wrapped in pack"
(W pack) You tried something like
.Sp
.Vb 1
\&   pack("u", "\ex{1f3}b")
.Ve
.Sp
where the format expects to process a sequence of bytes (character with a
value below 256), but some of the characters had a higher value.  Perl
uses the character values modulus 256 instead, as if you had provided:
.Sp
.Vb 1
\&   pack("u", "\ex{f3}b")
.Ve
.IP "Character(s) in '%c' format wrapped in unpack" 4
.IX Item "Character(s) in '%c' format wrapped in unpack"
(W unpack) You tried something like
.Sp
.Vb 1
\&   unpack("s", "\ex{1f3}b")
.Ve
.Sp
where the format expects to process a sequence of bytes (character with a
value below 256), but some of the characters had a higher value.  Perl
uses the character values modulus 256 instead, as if you had provided:
.Sp
.Vb 1
\&   unpack("s", "\ex{f3}b")
.Ve
.ie n .IP "charnames alias definitions may not contain a sequence of multiple spaces; marked by <\-\-\ \s-1HERE\s0 in %s" 4
.el .IP "charnames alias definitions may not contain a sequence of multiple spaces; marked by <\-\-\ \s-1HERE\s0 in \f(CW%s\fR" 4
.IX Item "charnames alias definitions may not contain a sequence of multiple spaces; marked by <--HERE in %s"
(F) You defined a character name which had multiple space characters
in a row.  Change them to single spaces.  Usually these names are
defined in the \f(CW\*(C`:alias\*(C'\fR import argument to \f(CW\*(C`use charnames\*(C'\fR, but they
could be defined by a translator installed into \f(CW$^H{charnames}\fR.  See
\&\*(L"\s-1CUSTOM ALIASES\*(R"\s0 in charnames.
.ie n .IP "charnames alias definitions may not contain trailing white-space; marked by <\-\-\ \s-1HERE\s0 in %s" 4
.el .IP "charnames alias definitions may not contain trailing white-space; marked by <\-\-\ \s-1HERE\s0 in \f(CW%s\fR" 4
.IX Item "charnames alias definitions may not contain trailing white-space; marked by <--HERE in %s"
(F) You defined a character name which ended in a space
character.  Remove the trailing space(s).  Usually these names are
defined in the \f(CW\*(C`:alias\*(C'\fR import argument to \f(CW\*(C`use charnames\*(C'\fR, but they
could be defined by a translator installed into \f(CW$^H{charnames}\fR.
See \*(L"\s-1CUSTOM ALIASES\*(R"\s0 in charnames.
.ie n .IP "\fBchdir()\fR on unopened filehandle %s" 4
.el .IP "\fBchdir()\fR on unopened filehandle \f(CW%s\fR" 4
.IX Item "chdir() on unopened filehandle %s"
(W unopened) You tried \fBchdir()\fR on a filehandle that was never opened.
.ie n .IP """\ec%c"" is more clearly written simply as ""%s""" 4
.el .IP "``\ec%c'' is more clearly written simply as ``%s''" 4
.IX Item "c%c is more clearly written simply as %s"
(W syntax) The \f(CW\*(C`\ec\f(CIX\f(CW\*(C'\fR construct is intended to be a way to specify
non-printable characters.  You used it for a printable one, which
is better written as simply itself, perhaps preceded by a backslash
for non-word characters.  Doing it the way you did is not portable
between \s-1ASCII\s0 and \s-1EBCDIC\s0 platforms.
.IP "Cloning substitution context is unimplemented" 4
.IX Item "Cloning substitution context is unimplemented"
(F) Creating a new thread inside the \f(CW\*(C`s///\*(C'\fR operator is not supported.
.ie n .IP "\fBclosedir()\fR attempted on invalid dirhandle %s" 4
.el .IP "\fBclosedir()\fR attempted on invalid dirhandle \f(CW%s\fR" 4
.IX Item "closedir() attempted on invalid dirhandle %s"
(W io) The dirhandle you tried to close is either closed or not really
a dirhandle.  Check your control flow.
.ie n .IP "\fBclose()\fR on unopened filehandle %s" 4
.el .IP "\fBclose()\fR on unopened filehandle \f(CW%s\fR" 4
.IX Item "close() on unopened filehandle %s"
(W unopened) You tried to close a filehandle that was never opened.
.IP "Closure prototype called" 4
.IX Item "Closure prototype called"
(F) If a closure has attributes, the subroutine passed to an attribute
handler is the prototype that is cloned when a new closure is created.
This subroutine cannot be called.
.IP "\eC no longer supported in regex; marked by <\-\-\ \s-1HERE\s0 in m/%s/" 4
.IX Item "C no longer supported in regex; marked by <--HERE in m/%s/"
(F) The \eC character class used to allow a match of single byte
within a multi-byte utf\-8 character, but was removed in v5.24 as
it broke encapsulation and its implementation was extremely buggy.
If you really need to process the individual bytes, you probably
want to convert your string to one where each underlying byte is
stored as a character, with \fButf8::encode()\fR.
.IP "Code missing after '/'" 4
.IX Item "Code missing after '/'"
(F) You had a (sub\-)template that ends with a '/'.  There must be
another template code following the slash.  See \*(L"pack\*(R" in perlfunc.
.IP "Code point 0x%X is not Unicode, and not portable" 4
.IX Item "Code point 0x%X is not Unicode, and not portable"
(S non_unicode) You had a code point that has never been in any
standard, so it is likely that languages other than Perl will \s-1NOT\s0
understand it.  At one time, it was legal in some standards to have code
points up to 0x7FFF_FFFF, but not higher, and this code point is higher.
.Sp
Acceptance of these code points is a Perl extension, and you should
expect that nothing other than Perl can handle them; Perl itself on
\&\s-1EBCDIC\s0 platforms before v5.24 does not handle them.
.Sp
Code points above 0xFFFF_FFFF require larger than a 32 bit word.
.Sp
Perl also makes no guarantees that the representation of these code
points won't change at some point in the future, say when machines
become available that have larger than a 64\-bit word.  At that time,
files written by an older Perl would require conversion before being
readable by a newer Perl.
.IP "Code point 0x%X is not Unicode, may not be portable" 4
.IX Item "Code point 0x%X is not Unicode, may not be portable"
(S non_unicode) You had a code point above the Unicode maximum
of U+10FFFF.
.Sp
Perl allows strings to contain a superset of Unicode code points, but
these may not be accepted by other languages/systems.  Further, even if
these languages/systems accept these large code points, they may have
chosen a different representation for them than the UTF\-8\-like one that
Perl has, which would mean files are not exchangeable between them and
Perl.
.Sp
On \s-1EBCDIC\s0 platforms, code points above 0x3FFF_FFFF have a different
representation in Perl v5.24 than before, so any file containing these
that was written before that version will require conversion before
being readable by a later Perl.
.ie n .IP "%s: Command not found" 4
.el .IP "\f(CW%s:\fR Command not found" 4
.IX Item "%s: Command not found"
(A) You've accidentally run your script through \fBcsh\fR or another shell
instead of Perl.  Check the #! line, or manually feed your script into
Perl yourself.  The #! line at the top of your file could look like
.Sp
.Vb 1
\&  #!/usr/bin/perl
.Ve
.ie n .IP "%s: command not found" 4
.el .IP "\f(CW%s:\fR command not found" 4
.IX Item "%s: command not found"
(A) You've accidentally run your script through \fBbash\fR or another shell
instead of Perl.  Check the #! line, or manually feed your script into
Perl yourself.  The #! line at the top of your file could look like
.Sp
.Vb 1
\&  #!/usr/bin/perl
.Ve
.ie n .IP "%s: command not found: %s" 4
.el .IP "\f(CW%s:\fR command not found: \f(CW%s\fR" 4
.IX Item "%s: command not found: %s"
(A) You've accidentally run your script through \fBzsh\fR or another shell
instead of Perl.  Check the #! line, or manually feed your script into
Perl yourself.  The #! line at the top of your file could look like
.Sp
.Vb 1
\&  #!/usr/bin/perl
.Ve
.IP "Compilation failed in require" 4
.IX Item "Compilation failed in require"
(F) Perl could not compile a file specified in a \f(CW\*(C`require\*(C'\fR statement.
Perl uses this generic message when none of the errors that it
encountered were severe enough to halt compilation immediately.
.IP "Complex regular subexpression recursion limit (%d) exceeded" 4
.IX Item "Complex regular subexpression recursion limit (%d) exceeded"
(W regexp) The regular expression engine uses recursion in complex
situations where back-tracking is required.  Recursion depth is limited
to 32766, or perhaps less in architectures where the stack cannot grow
arbitrarily.  (\*(L"Simple\*(R" and \*(L"medium\*(R" situations are handled without
recursion and are not subject to a limit.)  Try shortening the string
under examination; looping in Perl code (e.g. with \f(CW\*(C`while\*(C'\fR) rather than
in the regular expression engine; or rewriting the regular expression so
that it is simpler or backtracks less.  (See perlfaq2 for information
on \fIMastering Regular Expressions\fR.)
.ie n .IP "\fBconnect()\fR on closed socket %s" 4
.el .IP "\fBconnect()\fR on closed socket \f(CW%s\fR" 4
.IX Item "connect() on closed socket %s"
(W closed) You tried to do a connect on a closed socket.  Did you forget
to check the return value of your \fBsocket()\fR call?  See
\&\*(L"connect\*(R" in perlfunc.
.IP "Constant(%s): Call to &{$^H{%s}} did not return a defined value" 4
.IX Item "Constant(%s): Call to &{$^H{%s}} did not return a defined value"
(F) The subroutine registered to handle constant overloading
(see overload) or a custom charnames handler (see
\&\*(L"\s-1CUSTOM TRANSLATORS\*(R"\s0 in charnames) returned an undefined value.
.IP "Constant(%s): $^H{%s} is not defined" 4
.IX Item "Constant(%s): $^H{%s} is not defined"
(F) The parser found inconsistencies while attempting to define an
overloaded constant.  Perhaps you forgot to load the corresponding
overload pragma?
.ie n .IP "Constant is not %s reference" 4
.el .IP "Constant is not \f(CW%s\fR reference" 4
.IX Item "Constant is not %s reference"
(F) A constant value (perhaps declared using the \f(CW\*(C`use constant\*(C'\fR pragma)
is being dereferenced, but it amounts to the wrong type of reference.
The message indicates the type of reference that was expected.  This
usually indicates a syntax error in dereferencing the constant value.
See \*(L"Constant Functions\*(R" in perlsub and constant.
.IP "Constants from lexical variables potentially modified elsewhere are deprecated. This will not be allowed in Perl 5.32" 4
.IX Item "Constants from lexical variables potentially modified elsewhere are deprecated. This will not be allowed in Perl 5.32"
(D deprecated) You wrote something like
.Sp
.Vb 2
\&    my $var;
\&    $sub = sub () { $var };
.Ve
.Sp
but \f(CW$var\fR is referenced elsewhere and could be modified after the \f(CW\*(C`sub\*(C'\fR
expression is evaluated.  Either it is explicitly modified elsewhere
(\f(CW\*(C`$var = 3\*(C'\fR) or it is passed to a subroutine or to an operator like
\&\f(CW\*(C`printf\*(C'\fR or \f(CW\*(C`map\*(C'\fR, which may or may not modify the variable.
.Sp
Traditionally, Perl has captured the value of the variable at that
point and turned the subroutine into a constant eligible for inlining.
In those cases where the variable can be modified elsewhere, this
breaks the behavior of closures, in which the subroutine captures
the variable itself, rather than its value, so future changes to the
variable are reflected in the subroutine's return value.
.Sp
This usage is deprecated, and will no longer be allowed in Perl 5.32,
making it possible to change the behavior in the future.
.Sp
If you intended for the subroutine to be eligible for inlining, then
make sure the variable is not referenced elsewhere, possibly by
copying it:
.Sp
.Vb 2
\&    my $var2 = $var;
\&    $sub = sub () { $var2 };
.Ve
.Sp
If you do want this subroutine to be a closure that reflects future
changes to the variable that it closes over, add an explicit \f(CW\*(C`return\*(C'\fR:
.Sp
.Vb 2
\&    my $var;
\&    $sub = sub () { return $var };
.Ve
.ie n .IP "Constant subroutine %s redefined" 4
.el .IP "Constant subroutine \f(CW%s\fR redefined" 4
.IX Item "Constant subroutine %s redefined"
(W redefine)(S) You redefined a subroutine which had previously
been eligible for inlining.  See \*(L"Constant Functions\*(R" in perlsub
for commentary and workarounds.
.ie n .IP "Constant subroutine %s undefined" 4
.el .IP "Constant subroutine \f(CW%s\fR undefined" 4
.IX Item "Constant subroutine %s undefined"
(W misc) You undefined a subroutine which had previously been eligible
for inlining.  See \*(L"Constant Functions\*(R" in perlsub for commentary and
workarounds.
.IP "Constant(%s) unknown" 4
.IX Item "Constant(%s) unknown"
(F) The parser found inconsistencies either while attempting
to define an overloaded constant, or when trying to find the
character name specified in the \f(CW\*(C`\eN{...}\*(C'\fR escape.  Perhaps you
forgot to load the corresponding overload pragma?
.IP ":const is experimental" 4
.IX Item ":const is experimental"
(S experimental::const_attr) The \*(L"const\*(R" attribute is experimental.
If you want to use the feature, disable the warning with \f(CW\*(C`no warnings
\&\*(Aqexperimental::const_attr\*(Aq\*(C'\fR, but know that in doing so you are taking
the risk that your code may break in a future Perl version.
.IP ":const is not permitted on named subroutines" 4
.IX Item ":const is not permitted on named subroutines"
(F) The \*(L"const\*(R" attribute causes an anonymous subroutine to be run and
its value captured at the time that it is cloned.  Named subroutines are
not cloned like this, so the attribute does not make sense on them.
.IP "Copy method did not return a reference" 4
.IX Item "Copy method did not return a reference"
(F) The method which overloads \*(L"=\*(R" is buggy.  See
\&\*(L"Copy Constructor\*(R" in overload.
.IP "&CORE::%s cannot be called directly" 4
.IX Item "&CORE::%s cannot be called directly"
(F) You tried to call a subroutine in the \f(CW\*(C`CORE::\*(C'\fR namespace
with \f(CW&foo\fR syntax or through a reference.  Some subroutines
in this package cannot yet be called that way, but must be
called as barewords.  Something like this will work:
.Sp
.Vb 2
\&    BEGIN { *shove = \e&CORE::push; }
\&    shove @array, 1,2,3; # pushes on to @array
.Ve
.IP "CORE::%s is not a keyword" 4
.IX Item "CORE::%s is not a keyword"
(F) The \s-1CORE::\s0 namespace is reserved for Perl keywords.
.ie n .IP "Corrupted regexp opcode %d > %d" 4
.el .IP "Corrupted regexp opcode \f(CW%d\fR > \f(CW%d\fR" 4
.IX Item "Corrupted regexp opcode %d > %d"
(P) This is either an error in Perl, or, if you're using
one, your custom regular expression engine.  If not the
latter, report the problem to <https://github.com/Perl/perl5/issues>.
.IP "corrupted regexp pointers" 4
.IX Item "corrupted regexp pointers"
(P) The regular expression engine got confused by what the regular
expression compiler gave it.
.IP "corrupted regexp program" 4
.IX Item "corrupted regexp program"
(P) The regular expression engine got passed a regexp program without a
valid magic number.
.IP "Corrupt malloc ptr 0x%x at 0x%x" 4
.IX Item "Corrupt malloc ptr 0x%x at 0x%x"
(P) The malloc package that comes with Perl had an internal failure.
.IP "Count after length/code in unpack" 4
.IX Item "Count after length/code in unpack"
(F) You had an unpack template indicating a counted-length string, but
you have also specified an explicit size for the string.  See
\&\*(L"pack\*(R" in perlfunc.
.IP "Declaring references is experimental" 4
.IX Item "Declaring references is experimental"
(S experimental::declared_refs) This warning is emitted if you use
a reference constructor on the right-hand side of \f(CW\*(C`my\*(C'\fR, \f(CW\*(C`state\*(C'\fR, \f(CW\*(C`our\*(C'\fR, or
\&\f(CW\*(C`local\*(C'\fR.  Simply suppress the warning if you want to use the feature, but
know that in doing so you are taking the risk of using an experimental
feature which may change or be removed in a future Perl version:
.Sp
.Vb 3
\&    no warnings "experimental::declared_refs";
\&    use feature "declared_refs";
\&    $fooref = my \e$foo;
.Ve
.IP "Deep recursion on anonymous subroutine" 4
.IX Item "Deep recursion on anonymous subroutine"
.PD 0
.ie n .IP "Deep recursion on subroutine ""%s""" 4
.el .IP "Deep recursion on subroutine ``%s''" 4
.IX Item "Deep recursion on subroutine %s"
.PD
(W recursion) This subroutine has called itself (directly or indirectly)
100 times more than it has returned.  This probably indicates an
infinite recursion, unless you're writing strange benchmark programs, in
which case it indicates something else.
.Sp
This threshold can be changed from 100, by recompiling the \fIperl\fR binary,
setting the C pre-processor macro \f(CW\*(C`PERL_SUB_DEPTH_WARN\*(C'\fR to the desired value.
.IP "(?(\s-1DEFINE\s0)....) does not allow branches in regex; marked by <\-\-\ \s-1HERE\s0 in m/%s/" 4
.IX Item "(?(DEFINE)....) does not allow branches in regex; marked by <--HERE in m/%s/"
(F) You used something like \f(CW\*(C`(?(DEFINE)...|..)\*(C'\fR which is illegal.  The
most likely cause of this error is that you left out a parenthesis inside
of the \f(CW\*(C`....\*(C'\fR part.
.Sp
The <\-\-\ \s-1HERE\s0 shows whereabouts in the regular expression the problem was
discovered.
.ie n .IP "%s defines neither package nor VERSION\*(--version check failed" 4
.el .IP "\f(CW%s\fR defines neither package nor VERSION\*(--version check failed" 4
.IX Item "%s defines neither package nor VERSIONversion check failed"
(F) You said something like \*(L"use Module 42\*(R" but in the Module file
there are neither package declarations nor a \f(CW$VERSION\fR.
.IP "delete argument is not a \s-1HASH\s0 or \s-1ARRAY\s0 element or slice" 4
.IX Item "delete argument is not a HASH or ARRAY element or slice"
(F) The argument to \f(CW\*(C`delete\*(C'\fR must be either a hash or array element,
such as:
.Sp
.Vb 2
\&    $foo{$bar}
\&    $ref\->{"susie"}[12]
.Ve
.Sp
or a hash or array slice, such as:
.Sp
.Vb 2
\&    @foo[$bar, $baz, $xyzzy]
\&    @{$ref\->[12]}{"susie", "queue"}
.Ve
.Sp
or a hash key/value or array index/value slice, such as:
.Sp
.Vb 2
\&    %foo[$bar, $baz, $xyzzy]
\&    %{$ref\->[12]}{"susie", "queue"}
.Ve
.IP "Delimiter for here document is too long" 4
.IX Item "Delimiter for here document is too long"
(F) In a here document construct like \f(CW\*(C`<<FOO\*(C'\fR, the label \f(CW\*(C`FOO\*(C'\fR is too
long for Perl to handle.  You have to be seriously twisted to write code
that triggers this error.
.IP "Deprecated use of \fBmy()\fR in false conditional. This will be a fatal error in Perl 5.30" 4
.IX Item "Deprecated use of my() in false conditional. This will be a fatal error in Perl 5.30"
(D deprecated) You used a declaration similar to \f(CW\*(C`my $x if 0\*(C'\fR.  There
has been a long-standing bug in Perl that causes a lexical variable
not to be cleared at scope exit when its declaration includes a false
conditional.  Some people have exploited this bug to achieve a kind of
static variable.  Since we intend to fix this bug, we don't want people
relying on this behavior.  You can achieve a similar static effect by
declaring the variable in a separate block outside the function, eg
.Sp
.Vb 1
\&    sub f { my $x if 0; return $x++ }
.Ve
.Sp
becomes
.Sp
.Vb 1
\&    { my $x; sub f { return $x++ } }
.Ve
.Sp
Beginning with perl 5.10.0, you can also use \f(CW\*(C`state\*(C'\fR variables to have
lexicals that are initialized only once (see feature):
.Sp
.Vb 1
\&    sub f { state $x; return $x++ }
.Ve
.Sp
This use of \f(CW\*(C`my()\*(C'\fR in a false conditional has been deprecated since
Perl 5.10, and it will become a fatal error in Perl 5.30.
.IP "\s-1DESTROY\s0 created new reference to dead object '%s'" 4
.IX Item "DESTROY created new reference to dead object '%s'"
(F) A \s-1\fBDESTROY\s0()\fR method created a new reference to the object which is
just being DESTROYed.  Perl is confused, and prefers to abort rather
than to create a dangling reference.
.IP "Did not produce a valid header" 4
.IX Item "Did not produce a valid header"
See \*(L"500 Server error\*(R".
.ie n .IP "%s did not return a true value" 4
.el .IP "\f(CW%s\fR did not return a true value" 4
.IX Item "%s did not return a true value"
(F) A required (or used) file must return a true value to indicate that
it compiled correctly and ran its initialization code correctly.  It's
traditional to end such a file with a \*(L"1;\*(R", though any true value would
do.  See \*(L"require\*(R" in perlfunc.
.IP "(Did you mean &%s instead?)" 4
.IX Item "(Did you mean &%s instead?)"
(W misc) You probably referred to an imported subroutine &FOO as \f(CW$FOO\fR or
some such.
.ie n .IP "(Did you mean ""local"" instead of ""our""?)" 4
.el .IP "(Did you mean ``local'' instead of ``our''?)" 4
.IX Item "(Did you mean local instead of our?)"
(W shadow) Remember that \*(L"our\*(R" does not localize the declared global
variable.  You have declared it again in the same lexical scope, which
seems superfluous.
.IP "(Did you mean $ or @ instead of %?)" 4
.IX Item "(Did you mean $ or @ instead of %?)"
(W) You probably said \f(CW%hash\fR{$key} when you meant \f(CW$hash\fR{$key} or
\&\f(CW@hash\fR{@keys}.  On the other hand, maybe you just meant \f(CW%hash\fR and got
carried away.
.IP "Died" 4
.IX Item "Died"
(F) You passed \fBdie()\fR an empty string (the equivalent of \f(CW\*(C`die ""\*(C'\fR) or
you called it with no args and \f(CW$@\fR was empty.
.IP "Document contains no data" 4
.IX Item "Document contains no data"
See \*(L"500 Server error\*(R".
.ie n .IP "%s does not define %s::VERSION\*(--version check failed" 4
.el .IP "\f(CW%s\fR does not define \f(CW%s::VERSION\fR\*(--version check failed" 4
.IX Item "%s does not define %s::VERSIONversion check failed"
(F) You said something like \*(L"use Module 42\*(R" but the Module did not
define a \f(CW$VERSION\fR.
.IP "'/' does not take a repeat count" 4
.IX Item "'/' does not take a repeat count"
(F) You cannot put a repeat count of any kind right after the '/' code.
See \*(L"pack\*(R" in perlfunc.
.ie n .IP "do ""%s"" failed, '.' is no longer in @INC; did you mean do ""./%s""?" 4
.el .IP "do ``%s'' failed, '.' is no longer in \f(CW@INC\fR; did you mean do ``./%s''?" 4
.IX Item "do %s failed, '.' is no longer in @INC; did you mean do ./%s?"
(D deprecated) Previously \f(CW\*(C` do "somefile"; \*(C'\fR would search the current
directory for the specified file.  Since perl v5.26.0, \fI.\fR has been
removed from \f(CW@INC\fR by default, so this is no longer true.  To search the
current directory (and only the current directory) you can write
\&\f(CW\*(C` do "./somefile"; \*(C'\fR.
.IP "Don't know how to get file name" 4
.IX Item "Don't know how to get file name"
(P) \f(CW\*(C`PerlIO_getname\*(C'\fR, a perl internal I/O function specific to \s-1VMS,\s0 was
somehow called on another platform.  This should not happen.
.IP "Don't know how to handle magic of type \e%o" 4
.IX Item "Don't know how to handle magic of type %o"
(P) The internal handling of magical variables has been cursed.
.IP "do_study: out of memory" 4
.IX Item "do_study: out of memory"
(P) This should have been caught by \fBsafemalloc()\fR instead.
.ie n .IP "(Do you need to predeclare %s?)" 4
.el .IP "(Do you need to predeclare \f(CW%s\fR?)" 4
.IX Item "(Do you need to predeclare %s?)"
(S syntax) This is an educated guess made in conjunction with the message
\&\*(L"%s found where operator expected\*(R".  It often means a subroutine or module
name is being referenced that hasn't been declared yet.  This may be
because of ordering problems in your file, or because of a missing
\&\*(L"sub\*(R", \*(L"package\*(R", \*(L"require\*(R", or \*(L"use\*(R" statement.  If you're referencing
something that isn't defined yet, you don't actually have to define the
subroutine or package before the current location.  You can use an empty
\&\*(L"sub foo;\*(R" or \*(L"package \s-1FOO\s0;\*(R" to enter a \*(L"forward\*(R" declaration.
.IP "\fBdump()\fR must be written as \fBCORE::dump()\fR as of Perl 5.30" 4
.IX Item "dump() must be written as CORE::dump() as of Perl 5.30"
(F) You used the obsolete \f(CW\*(C`dump()\*(C'\fR built-in function.  That was deprecated in
Perl 5.8.0.  As of Perl 5.30 it must be written in fully qualified format:
\&\f(CW\*(C`CORE::dump()\*(C'\fR.
.Sp
See \*(L"dump\*(R" in perlfunc.
.IP "dump is not supported" 4
.IX Item "dump is not supported"
(F) Your machine doesn't support dump/undump.
.IP "Duplicate \fBfree()\fR ignored" 4
.IX Item "Duplicate free() ignored"
(S malloc) An internal routine called \fBfree()\fR on something that had
already been freed.
.ie n .IP "Duplicate modifier '%c' after '%c' in %s" 4
.el .IP "Duplicate modifier '%c' after '%c' in \f(CW%s\fR" 4
.IX Item "Duplicate modifier '%c' after '%c' in %s"
(W unpack) You have applied the same modifier more than once after a
type in a pack template.  See \*(L"pack\*(R" in perlfunc.
.IP "elseif should be elsif" 4
.IX Item "elseif should be elsif"
(S syntax) There is no keyword \*(L"elseif\*(R" in Perl because Larry thinks
it's ugly.  Your code will be interpreted as an attempt to call a method
named \*(L"elseif\*(R" for the class returned by the following block.  This is
unlikely to be what you want.
.IP "Empty \e%c in regex; marked by <\-\-\ \s-1HERE\s0 in m/%s/" 4
.IX Item "Empty %c in regex; marked by <--HERE in m/%s/"
.PD 0
.IP "Empty \e%c{}" 4
.IX Item "Empty %c{}"
.IP "Empty \e%c{} in regex; marked by <\-\-\ \s-1HERE\s0 in m/%s/" 4
.IX Item "Empty %c{} in regex; marked by <--HERE in m/%s/"
.PD
(F) You used something like \f(CW\*(C`\eb{}\*(C'\fR, \f(CW\*(C`\eB{}\*(C'\fR, \f(CW\*(C`\eo{}\*(C'\fR, \f(CW\*(C`\ep\*(C'\fR, \f(CW\*(C`\eP\*(C'\fR, or
\&\f(CW\*(C`\ex\*(C'\fR without specifying anything for it to operate on.
.Sp
Unfortunately, for backwards compatibility reasons, an empty \f(CW\*(C`\ex\*(C'\fR is
legal outside \f(CW\*(C`use\ re\ \*(Aqstrict\*(Aq\*(C'\fR and expands to a \s-1NUL\s0 character.
.IP "Empty (?) without any modifiers in regex; marked by <\-\- \s-1HERE\s0 in m/%s/" 4
.IX Item "Empty (?) without any modifiers in regex; marked by <-- HERE in m/%s/"
(W regexp) (only under \f(CW\*(C`use\ re\ \*(Aqstrict\*(Aq\*(C'\fR)
\&\f(CW\*(C`(?)\*(C'\fR does nothing, so perhaps this is a typo.
.IP "${^ENCODING} is no longer supported" 4
.IX Item "${^ENCODING} is no longer supported"
(F) The special variable \f(CW\*(C`${^ENCODING}\*(C'\fR, formerly used to implement
the \f(CW\*(C`encoding\*(C'\fR pragma, is no longer supported as of Perl 5.26.0.
.Sp
Setting it to anything other than \f(CW\*(C`undef\*(C'\fR is a fatal error as of Perl
5.28.
.ie n .IP "entering effective %s failed" 4
.el .IP "entering effective \f(CW%s\fR failed" 4
.IX Item "entering effective %s failed"
(F) While under the \f(CW\*(C`use filetest\*(C'\fR pragma, switching the real and
effective uids or gids failed.
.ie n .IP "%ENV is aliased to %s" 4
.el .IP "\f(CW%ENV\fR is aliased to \f(CW%s\fR" 4
.IX Item "%ENV is aliased to %s"
(F) You're running under taint mode, and the \f(CW%ENV\fR variable has been
aliased to another hash, so it doesn't reflect anymore the state of the
program's environment.  This is potentially insecure.
.ie n .IP "Error converting file specification %s" 4
.el .IP "Error converting file specification \f(CW%s\fR" 4
.IX Item "Error converting file specification %s"
(F) An error peculiar to \s-1VMS.\s0  Because Perl may have to deal with file
specifications in either \s-1VMS\s0 or Unix syntax, it converts them to a
single form when it must operate on them directly.  Either you've passed
an invalid file specification to Perl, or you've found a case the
conversion routines don't handle.  Drat.
.IP "Eval-group in insecure regular expression" 4
.IX Item "Eval-group in insecure regular expression"
(F) Perl detected tainted data when trying to compile a regular
expression that contains the \f(CW\*(C`(?{ ... })\*(C'\fR zero-width assertion, which
is unsafe.  See \*(L"(?{ code })\*(R" in perlre, and perlsec.
.IP "Eval-group not allowed at runtime, use re 'eval' in regex m/%s/" 4
.IX Item "Eval-group not allowed at runtime, use re 'eval' in regex m/%s/"
(F) Perl tried to compile a regular expression containing the
\&\f(CW\*(C`(?{ ... })\*(C'\fR zero-width assertion at run time, as it would when the
pattern contains interpolated values.  Since that is a security risk,
it is not allowed.  If you insist, you may still do this by using the
\&\f(CW\*(C`re \*(Aqeval\*(Aq\*(C'\fR pragma or by explicitly building the pattern from an
interpolated string at run time and using that in an \fBeval()\fR.  See
\&\*(L"(?{ code })\*(R" in perlre.
.IP "Eval-group not allowed, use re 'eval' in regex m/%s/" 4
.IX Item "Eval-group not allowed, use re 'eval' in regex m/%s/"
(F) A regular expression contained the \f(CW\*(C`(?{ ... })\*(C'\fR zero-width
assertion, but that construct is only allowed when the \f(CW\*(C`use re \*(Aqeval\*(Aq\*(C'\fR
pragma is in effect.  See \*(L"(?{ code })\*(R" in perlre.
.IP "\s-1EVAL\s0 without pos change exceeded limit in regex; marked by <\-\-\ \s-1HERE\s0 in m/%s/" 4
.IX Item "EVAL without pos change exceeded limit in regex; marked by <--HERE in m/%s/"
(F) You used a pattern that nested too many \s-1EVAL\s0 calls without consuming
any text.  Restructure the pattern so that text is consumed.
.Sp
The <\-\-\ \s-1HERE\s0 shows whereabouts in the regular expression the problem was
discovered.
.IP "Excessively long <> operator" 4
.IX Item "Excessively long <> operator"
(F) The contents of a <> operator may not exceed the maximum size of a
Perl identifier.  If you're just trying to glob a long list of
filenames, try using the \fBglob()\fR operator, or put the filenames into a
variable and glob that.
.IP "exec? I'm not *that* kind of operating system" 4
.IX Item "exec? I'm not *that* kind of operating system"
(F) The \f(CW\*(C`exec\*(C'\fR function is not implemented on some systems, e.g., Symbian
\&\s-1OS.\s0  See perlport.
.ie n .IP "%sExecution of %s aborted due to compilation errors." 4
.el .IP "\f(CW%sExecution\fR of \f(CW%s\fR aborted due to compilation errors." 4
.IX Item "%sExecution of %s aborted due to compilation errors."
(F) The final summary message when a Perl compilation fails.
.IP "exists argument is not a \s-1HASH\s0 or \s-1ARRAY\s0 element or a subroutine" 4
.IX Item "exists argument is not a HASH or ARRAY element or a subroutine"
(F) The argument to \f(CW\*(C`exists\*(C'\fR must be a hash or array element or a
subroutine with an ampersand, such as:
.Sp
.Vb 3
\&    $foo{$bar}
\&    $ref\->{"susie"}[12]
\&    &do_something
.Ve
.IP "exists argument is not a subroutine name" 4
.IX Item "exists argument is not a subroutine name"
(F) The argument to \f(CW\*(C`exists\*(C'\fR for \f(CW\*(C`exists &sub\*(C'\fR must be a subroutine name,
and not a subroutine call.  \f(CW\*(C`exists &sub()\*(C'\fR will generate this error.
.ie n .IP "Exiting eval via %s" 4
.el .IP "Exiting eval via \f(CW%s\fR" 4
.IX Item "Exiting eval via %s"
(W exiting) You are exiting an eval by unconventional means, such as a
goto, or a loop control statement.
.ie n .IP "Exiting format via %s" 4
.el .IP "Exiting format via \f(CW%s\fR" 4
.IX Item "Exiting format via %s"
(W exiting) You are exiting a format by unconventional means, such as a
goto, or a loop control statement.
.ie n .IP "Exiting pseudo-block via %s" 4
.el .IP "Exiting pseudo-block via \f(CW%s\fR" 4
.IX Item "Exiting pseudo-block via %s"
(W exiting) You are exiting a rather special block construct (like a
sort block or subroutine) by unconventional means, such as a goto, or a
loop control statement.  See \*(L"sort\*(R" in perlfunc.
.ie n .IP "Exiting subroutine via %s" 4
.el .IP "Exiting subroutine via \f(CW%s\fR" 4
.IX Item "Exiting subroutine via %s"
(W exiting) You are exiting a subroutine by unconventional means, such
as a goto, or a loop control statement.
.ie n .IP "Exiting substitution via %s" 4
.el .IP "Exiting substitution via \f(CW%s\fR" 4
.IX Item "Exiting substitution via %s"
(W exiting) You are exiting a substitution by unconventional means, such
as a return, a goto, or a loop control statement.
.IP "Expecting close bracket in regex; marked by <\-\-\ \s-1HERE\s0 in m/%s/" 4
.IX Item "Expecting close bracket in regex; marked by <--HERE in m/%s/"
(F) You wrote something like
.Sp
.Vb 1
\& (?13
.Ve
.Sp
to denote a capturing group of the form
\&\f(CW\*(C`(?\f(CIPARNO\f(CW)\*(C'\fR,
but omitted the \f(CW")"\fR.
.IP "Expecting close paren for nested extended charclass in regex; marked by <\-\- \s-1HERE\s0 in m/%s/" 4
.IX Item "Expecting close paren for nested extended charclass in regex; marked by <-- HERE in m/%s/"
(F) While parsing a nested extended character class like:
.Sp
.Vb 2
\&    (?[ ... (?flags:(?[ ... ])) ... ])
\&                             ^
.Ve
.Sp
we expected to see a close paren ')' (marked by ^) but did not.
.IP "Expecting close paren for wrapper for nested extended charclass in regex; marked by <\-\- \s-1HERE\s0 in m/%s/" 4
.IX Item "Expecting close paren for wrapper for nested extended charclass in regex; marked by <-- HERE in m/%s/"
(F) While parsing a nested extended character class like:
.Sp
.Vb 2
\&    (?[ ... (?flags:(?[ ... ])) ... ])
\&                              ^
.Ve
.Sp
we expected to see a close paren ')' (marked by ^) but did not.
.IP "Expecting '(?flags:(?[...' in regex; marked by <\-\-\ \s-1HERE\s0 in m/%s/" 4
.IX Item "Expecting '(?flags:(?[...' in regex; marked by <--HERE in m/%s/"
(F) The \f(CW\*(C`(?[...])\*(C'\fR extended character class regular expression construct
only allows character classes (including character class escapes like
\&\f(CW\*(C`\ed\*(C'\fR), operators, and parentheses.  The one exception is \f(CW\*(C`(?flags:...)\*(C'\fR
containing at least one flag and exactly one \f(CW\*(C`(?[...])\*(C'\fR construct.
This allows a regular expression containing just \f(CW\*(C`(?[...])\*(C'\fR to be
interpolated.  If you see this error message, then you probably
have some other \f(CW\*(C`(?...)\*(C'\fR construct inside your character class.  See
\&\*(L"Extended Bracketed Character Classes\*(R" in perlrecharclass.
.IP "Experimental aliasing via reference not enabled" 4
.IX Item "Experimental aliasing via reference not enabled"
(F) To do aliasing via references, you must first enable the feature:
.Sp
.Vb 3
\&    no warnings "experimental::refaliasing";
\&    use feature "refaliasing";
\&    \e$x = \e$y;
.Ve
.ie n .IP "Experimental %s on scalar is now forbidden" 4
.el .IP "Experimental \f(CW%s\fR on scalar is now forbidden" 4
.IX Item "Experimental %s on scalar is now forbidden"
(F) An experimental feature added in Perl 5.14 allowed \f(CW\*(C`each\*(C'\fR, \f(CW\*(C`keys\*(C'\fR,
\&\f(CW\*(C`push\*(C'\fR, \f(CW\*(C`pop\*(C'\fR, \f(CW\*(C`shift\*(C'\fR, \f(CW\*(C`splice\*(C'\fR, \f(CW\*(C`unshift\*(C'\fR, and \f(CW\*(C`values\*(C'\fR to be called with a
scalar argument.  This experiment is considered unsuccessful, and
has been removed.  The \f(CW\*(C`postderef\*(C'\fR feature may meet your needs better.
.IP "Experimental subroutine signatures not enabled" 4
.IX Item "Experimental subroutine signatures not enabled"
(F) To use subroutine signatures, you must first enable them:
.Sp
.Vb 3
\&    no warnings "experimental::signatures";
\&    use feature "signatures";
\&    sub foo ($left, $right) { ... }
.Ve
.IP "Explicit blessing to '' (assuming package main)" 4
.IX Item "Explicit blessing to '' (assuming package main)"
(W misc) You are blessing a reference to a zero length string.  This has
the effect of blessing the reference into the package main.  This is
usually not what you want.  Consider providing a default target package,
e.g. bless($ref, \f(CW$p\fR || 'MyPackage');
.ie n .IP "%s: Expression syntax" 4
.el .IP "\f(CW%s:\fR Expression syntax" 4
.IX Item "%s: Expression syntax"
(A) You've accidentally run your script through \fBcsh\fR instead of Perl.
Check the #! line, or manually feed your script into Perl yourself.
.ie n .IP "%s failed\*(--call queue aborted" 4
.el .IP "\f(CW%s\fR failed\*(--call queue aborted" 4
.IX Item "%s failedcall queue aborted"
(F) An untrapped exception was raised while executing a \s-1UNITCHECK,
CHECK, INIT,\s0 or \s-1END\s0 subroutine.  Processing of the remainder of the
queue of such routines has been prematurely ended.
.ie n .IP "Failed to close in-place work file %s: %s" 4
.el .IP "Failed to close in-place work file \f(CW%s:\fR \f(CW%s\fR" 4
.IX Item "Failed to close in-place work file %s: %s"
(F) Closing an output file from in-place editing, as with the \f(CW\*(C`\-i\*(C'\fR
command-line switch, failed.
.ie n .IP "False [] range ""%s"" in regex; marked by <\-\-\ \s-1HERE\s0 in m/%s/" 4
.el .IP "False [] range ``%s'' in regex; marked by <\-\-\ \s-1HERE\s0 in m/%s/" 4
.IX Item "False [] range %s in regex; marked by <--HERE in m/%s/"
(W regexp)(F) A character class range must start and end at a literal
character, not another character class like \f(CW\*(C`\ed\*(C'\fR or \f(CW\*(C`[:alpha:]\*(C'\fR.  The \*(L"\-\*(R"
in your false range is interpreted as a literal \*(L"\-\*(R".  In a \f(CW\*(C`(?[...])\*(C'\fR
construct, this is an error, rather than a warning.  Consider quoting
the \*(L"\-\*(R", \*(L"\e\-\*(R".  The <\-\-\ \s-1HERE\s0 shows whereabouts in the regular expression
the problem was discovered.  See perlre.
.ie n .IP "Fatal \s-1VMS\s0 error (status=%d) at %s, line %d" 4
.el .IP "Fatal \s-1VMS\s0 error (status=%d) at \f(CW%s\fR, line \f(CW%d\fR" 4
.IX Item "Fatal VMS error (status=%d) at %s, line %d"
(P) An error peculiar to \s-1VMS.\s0  Something untoward happened in a \s-1VMS\s0
system service or \s-1RTL\s0 routine; Perl's exit status should provide more
details.  The filename in \*(L"at \f(CW%s\fR\*(R" and the line number in \*(L"line \f(CW%d\fR\*(R" tell
you which section of the Perl source code is distressed.
.IP "fcntl is not implemented" 4
.IX Item "fcntl is not implemented"
(F) Your machine apparently doesn't implement \fBfcntl()\fR.  What is this, a
\&\s-1PDP\-11\s0 or something?
.IP "\s-1FETCHSIZE\s0 returned a negative value" 4
.IX Item "FETCHSIZE returned a negative value"
(F) A tied array claimed to have a negative number of elements, which
is not possible.
.IP "Field too wide in 'u' format in pack" 4
.IX Item "Field too wide in 'u' format in pack"
(W pack) Each line in an uuencoded string starts with a length indicator
which can't encode values above 63.  So there is no point in asking for
a line length bigger than that.  Perl will behave as if you specified
\&\f(CW\*(C`u63\*(C'\fR as the format.
.IP "\fBFile::Glob::glob()\fR will disappear in perl 5.30. Use \fBFile::Glob::bsd_glob()\fR instead." 4
.IX Item "File::Glob::glob() will disappear in perl 5.30. Use File::Glob::bsd_glob() instead."
(D deprecated) \f(CW\*(C`File::Glob\*(C'\fR has a function called \f(CW\*(C`glob\*(C'\fR, which
just calls \f(CW\*(C`bsd_glob\*(C'\fR. However, its prototype is different from the
prototype of \f(CW\*(C`CORE::glob\*(C'\fR, and hence, \f(CW\*(C`File::Glob::glob\*(C'\fR should
not be used.
.Sp
\&\f(CW\*(C`File::Glob::glob()\*(C'\fR was deprecated in perl 5.8.0. A deprecation
message was issued from perl 5.26.0 onwards, and the function will
disappear in perl 5.30.0.
.Sp
Code using \f(CW\*(C`File::Glob::glob()\*(C'\fR should call
\&\f(CW\*(C`File::Glob::bsd_glob()\*(C'\fR instead.
.ie n .IP "Filehandle %s opened only for input" 4
.el .IP "Filehandle \f(CW%s\fR opened only for input" 4
.IX Item "Filehandle %s opened only for input"
(W io) You tried to write on a read-only filehandle.  If you intended
it to be a read-write filehandle, you needed to open it with \*(L"+<\*(R" or
\&\*(L"+>\*(R" or \*(L"+>>\*(R" instead of with \*(L"<\*(R" or nothing.  If you intended only to
write the file, use \*(L">\*(R" or \*(L">>\*(R".  See \*(L"open\*(R" in perlfunc.
.ie n .IP "Filehandle %s opened only for output" 4
.el .IP "Filehandle \f(CW%s\fR opened only for output" 4
.IX Item "Filehandle %s opened only for output"
(W io) You tried to read from a filehandle opened only for writing, If
you intended it to be a read/write filehandle, you needed to open it
with \*(L"+<\*(R" or \*(L"+>\*(R" or \*(L"+>>\*(R" instead of with \*(L">\*(R".  If you intended only to
read from the file, use \*(L"<\*(R".  See \*(L"open\*(R" in perlfunc.  Another possibility
is that you attempted to open filedescriptor 0 (also known as \s-1STDIN\s0) for
output (maybe you closed \s-1STDIN\s0 earlier?).
.ie n .IP "Filehandle %s reopened as %s only for input" 4
.el .IP "Filehandle \f(CW%s\fR reopened as \f(CW%s\fR only for input" 4
.IX Item "Filehandle %s reopened as %s only for input"
(W io) You opened for reading a filehandle that got the same filehandle id
as \s-1STDOUT\s0 or \s-1STDERR.\s0  This occurred because you closed \s-1STDOUT\s0 or \s-1STDERR\s0
previously.
.ie n .IP "Filehandle \s-1STDIN\s0 reopened as %s only for output" 4
.el .IP "Filehandle \s-1STDIN\s0 reopened as \f(CW%s\fR only for output" 4
.IX Item "Filehandle STDIN reopened as %s only for output"
(W io) You opened for writing a filehandle that got the same filehandle id
as \s-1STDIN.\s0  This occurred because you closed \s-1STDIN\s0 previously.
.ie n .IP "Final $ should be \e$ or $name" 4
.el .IP "Final $ should be \e$ or \f(CW$name\fR" 4
.IX Item "Final $ should be $ or $name"
(F) You must now decide whether the final $ in a string was meant to be
a literal dollar sign, or was meant to introduce a variable name that
happens to be missing.  So you have to put either the backslash or the
name.
.ie n .IP "\fBflock()\fR on closed filehandle %s" 4
.el .IP "\fBflock()\fR on closed filehandle \f(CW%s\fR" 4
.IX Item "flock() on closed filehandle %s"
(W closed) The filehandle you're attempting to \fBflock()\fR got itself closed
some time before now.  Check your control flow.  \fBflock()\fR operates on
filehandles.  Are you attempting to call \fBflock()\fR on a dirhandle by the
same name?
.IP "Format not terminated" 4
.IX Item "Format not terminated"
(F) A format must be terminated by a line with a solitary dot.  Perl got
to the end of your file without finding such a line.
.ie n .IP "Format %s redefined" 4
.el .IP "Format \f(CW%s\fR redefined" 4
.IX Item "Format %s redefined"
(W redefine) You redefined a format.  To suppress this warning, say
.Sp
.Vb 4
\&    {
\&        no warnings \*(Aqredefine\*(Aq;
\&        eval "format NAME =...";
\&    }
.Ve
.IP "Found = in conditional, should be ==" 4
.IX Item "Found = in conditional, should be =="
(W syntax) You said
.Sp
.Vb 1
\&    if ($foo = 123)
.Ve
.Sp
when you meant
.Sp
.Vb 1
\&    if ($foo == 123)
.Ve
.Sp
(or something like that).
.ie n .IP "%s found where operator expected" 4
.el .IP "\f(CW%s\fR found where operator expected" 4
.IX Item "%s found where operator expected"
(S syntax) The Perl lexer knows whether to expect a term or an operator.
If it sees what it knows to be a term when it was expecting to see an
operator, it gives you this warning.  Usually it indicates that an
operator or delimiter was omitted, such as a semicolon.
.ie n .IP "gdbm store returned %d, errno %d, key ""%s""" 4
.el .IP "gdbm store returned \f(CW%d\fR, errno \f(CW%d\fR, key ``%s''" 4
.IX Item "gdbm store returned %d, errno %d, key %s"
(S) A warning from the GDBM_File extension that a store failed.
.IP "gethostent not implemented" 4
.IX Item "gethostent not implemented"
(F) Your C library apparently doesn't implement \fBgethostent()\fR, probably
because if it did, it'd feel morally obligated to return every hostname
on the Internet.
.ie n .IP "get%\fBsname()\fR on closed socket %s" 4
.el .IP "get%\fBsname()\fR on closed socket \f(CW%s\fR" 4
.IX Item "get%sname() on closed socket %s"
(W closed) You tried to get a socket or peer socket name on a closed
socket.  Did you forget to check the return value of your \fBsocket()\fR call?
.ie n .IP "getpwnam returned invalid \s-1UIC\s0 %#o for user ""%s""" 4
.el .IP "getpwnam returned invalid \s-1UIC\s0 %#o for user ``%s''" 4
.IX Item "getpwnam returned invalid UIC %#o for user %s"
(S) A warning peculiar to \s-1VMS.\s0  The call to \f(CW\*(C`sys$getuai\*(C'\fR underlying the
\&\f(CW\*(C`getpwnam\*(C'\fR operator returned an invalid \s-1UIC.\s0
.ie n .IP "\fBgetsockopt()\fR on closed socket %s" 4
.el .IP "\fBgetsockopt()\fR on closed socket \f(CW%s\fR" 4
.IX Item "getsockopt() on closed socket %s"
(W closed) You tried to get a socket option on a closed socket.  Did you
forget to check the return value of your \fBsocket()\fR call?  See
\&\*(L"getsockopt\*(R" in perlfunc.
.IP "given is experimental" 4
.IX Item "given is experimental"
(S experimental::smartmatch) \f(CW\*(C`given\*(C'\fR depends on smartmatch, which
is experimental, so its behavior may change or even be removed
in any future release of perl.  See the explanation under
\&\*(L"Experimental Details on given and when\*(R" in perlsyn.
.ie n .IP "Global symbol ""%s"" requires explicit package name (did you forget to declare ""my %s""?)" 4
.el .IP "Global symbol ``%s'' requires explicit package name (did you forget to declare ``my \f(CW%s\fR''?)" 4
.IX Item "Global symbol %s requires explicit package name (did you forget to declare my %s?)"
(F) You've said \*(L"use strict\*(R" or \*(L"use strict vars\*(R", which indicates 
that all variables must either be lexically scoped (using \*(L"my\*(R" or \*(L"state\*(R"), 
declared beforehand using \*(L"our\*(R", or explicitly qualified to say 
which package the global variable is in (using \*(L"::\*(R").
.IP "glob failed (%s)" 4
.IX Item "glob failed (%s)"
(S glob) Something went wrong with the external program(s) used
for \f(CW\*(C`glob\*(C'\fR and \f(CW\*(C`<*.c>\*(C'\fR.  Usually, this means that you supplied a \f(CW\*(C`glob\*(C'\fR
pattern that caused the external program to fail and exit with a
nonzero status.  If the message indicates that the abnormal exit
resulted in a coredump, this may also mean that your csh (C shell)
is broken.  If so, you should change all of the csh-related variables
in config.sh:  If you have tcsh, make the variables refer to it as
if it were csh (e.g. \f(CW\*(C`full_csh=\*(Aq/usr/bin/tcsh\*(Aq\*(C'\fR); otherwise, make them
all empty (except that \f(CW\*(C`d_csh\*(C'\fR should be \f(CW\*(Aqundef\*(Aq\fR) so that Perl will
think csh is missing.  In either case, after editing config.sh, run
\&\f(CW\*(C`./Configure \-S\*(C'\fR and rebuild Perl.
.IP "Glob not terminated" 4
.IX Item "Glob not terminated"
(F) The lexer saw a left angle bracket in a place where it was expecting
a term, so it's looking for the corresponding right angle bracket, and
not finding it.  Chances are you left some needed parentheses out
earlier in the line, and you really meant a \*(L"less than\*(R".
.IP "gmtime(%f) failed" 4
.IX Item "gmtime(%f) failed"
(W overflow) You called \f(CW\*(C`gmtime\*(C'\fR with a number that it could not handle:
too large, too small, or NaN.  The returned value is \f(CW\*(C`undef\*(C'\fR.
.IP "gmtime(%f) too large" 4
.IX Item "gmtime(%f) too large"
(W overflow) You called \f(CW\*(C`gmtime\*(C'\fR with a number that was larger than
it can reliably handle and \f(CW\*(C`gmtime\*(C'\fR probably returned the wrong
date.  This warning is also triggered with NaN (the special
not-a-number value).
.IP "gmtime(%f) too small" 4
.IX Item "gmtime(%f) too small"
(W overflow) You called \f(CW\*(C`gmtime\*(C'\fR with a number that was smaller than
it can reliably handle and \f(CW\*(C`gmtime\*(C'\fR probably returned the wrong date.
.IP "Got an error from DosAllocMem" 4
.IX Item "Got an error from DosAllocMem"
(P) An error peculiar to \s-1OS/2.\s0  Most probably you're using an obsolete
version of Perl, and this should not happen anyway.
.IP "goto must have label" 4
.IX Item "goto must have label"
(F) Unlike with \*(L"next\*(R" or \*(L"last\*(R", you're not allowed to goto an
unspecified destination.  See \*(L"goto\*(R" in perlfunc.
.IP "Goto undefined subroutine%s" 4
.IX Item "Goto undefined subroutine%s"
(F) You tried to call a subroutine with \f(CW\*(C`goto &sub\*(C'\fR syntax, but
the indicated subroutine hasn't been defined, or if it was, it
has since been undefined.
.IP "Group name must start with a non-digit word character in regex; marked by <\-\-\ \s-1HERE\s0 in m/%s/" 4
.IX Item "Group name must start with a non-digit word character in regex; marked by <--HERE in m/%s/"
(F) Group names must follow the rules for perl identifiers, meaning
they must start with a non-digit word character.  A common cause of
this error is using (?&0) instead of (?0).  See perlre.
.IP "()\-group starts with a count" 4
.IX Item "()-group starts with a count"
(F) A ()\-group started with a count.  A count is supposed to follow
something: a template character or a ()\-group.  See \*(L"pack\*(R" in perlfunc.
.ie n .IP "%s had compilation errors." 4
.el .IP "\f(CW%s\fR had compilation errors." 4
.IX Item "%s had compilation errors."
(F) The final summary message when a \f(CW\*(C`perl \-c\*(C'\fR fails.
.ie n .IP "Had to create %s unexpectedly" 4
.el .IP "Had to create \f(CW%s\fR unexpectedly" 4
.IX Item "Had to create %s unexpectedly"
(S internal) A routine asked for a symbol from a symbol table that ought
to have existed already, but for some reason it didn't, and had to be
created on an emergency basis to prevent a core dump.
.ie n .IP "%s has too many errors" 4
.el .IP "\f(CW%s\fR has too many errors" 4
.IX Item "%s has too many errors"
(F) The parser has given up trying to parse the program after 10 errors.
Further error messages would likely be uninformative.
.IP "Hexadecimal float: exponent overflow" 4
.IX Item "Hexadecimal float: exponent overflow"
(W overflow) The hexadecimal floating point has a larger exponent
than the floating point supports.
.IP "Hexadecimal float: exponent underflow" 4
.IX Item "Hexadecimal float: exponent underflow"
(W overflow) The hexadecimal floating point has a smaller exponent
than the floating point supports.  With the \s-1IEEE 754\s0 floating point,
this may also mean that the subnormals (formerly known as denormals)
are being used, which may or may not be an error.
.IP "Hexadecimal float: internal error (%s)" 4
.IX Item "Hexadecimal float: internal error (%s)"
(F) Something went horribly bad in hexadecimal float handling.
.IP "Hexadecimal float: mantissa overflow" 4
.IX Item "Hexadecimal float: mantissa overflow"
(W overflow) The hexadecimal floating point literal had more bits in
the mantissa (the part between the 0x and the exponent, also known as
the fraction or the significand) than the floating point supports.
.IP "Hexadecimal float: precision loss" 4
.IX Item "Hexadecimal float: precision loss"
(W overflow) The hexadecimal floating point had internally more
digits than could be output.  This can be caused by unsupported
long double formats, or by 64\-bit integers not being available
(needed to retrieve the digits under some configurations).
.IP "Hexadecimal float: unsupported long double format" 4
.IX Item "Hexadecimal float: unsupported long double format"
(F) You have configured Perl to use long doubles but
the internals of the long double format are unknown;
therefore the hexadecimal float output is impossible.
.IP "Hexadecimal number > 0xffffffff non-portable" 4
.IX Item "Hexadecimal number > 0xffffffff non-portable"
(W portable) The hexadecimal number you specified is larger than 2**32\-1
(4294967295) and therefore non-portable between systems.  See
perlport for more on portability concerns.
.IP "Identifier too long" 4
.IX Item "Identifier too long"
(F) Perl limits identifiers (names for variables, functions, etc.) to
about 250 characters for simple names, and somewhat more for compound
names (like \f(CW$A::B\fR).  You've exceeded Perl's limits.  Future versions
of Perl are likely to eliminate these arbitrary limitations.
.IP "Ignoring zero length \eN{} in character class in regex; marked by <\-\-\ \s-1HERE\s0 in m/%s/" 4
.IX Item "Ignoring zero length N{} in character class in regex; marked by <--HERE in m/%s/"
(W regexp) Named Unicode character escapes (\f(CW\*(C`\eN{...}\*(C'\fR) may return a
zero-length sequence.  When such an escape is used in a character
class its behavior is not well defined.  Check that the correct
escape has been used, and the correct charname handler is in scope.
.IP "Illegal binary digit '%c'" 4
.IX Item "Illegal binary digit '%c'"
(F) You used a digit other than 0 or 1 in a binary number.
.ie n .IP "Illegal binary digit %s ignored" 4
.el .IP "Illegal binary digit \f(CW%s\fR ignored" 4
.IX Item "Illegal binary digit %s ignored"
(W digit) You may have tried to use a digit other than 0 or 1 in a
binary number.  Interpretation of the binary number stopped before the
offending digit.
.ie n .IP "Illegal character after '_' in prototype for %s : %s" 4
.el .IP "Illegal character after '_' in prototype for \f(CW%s\fR : \f(CW%s\fR" 4
.IX Item "Illegal character after '_' in prototype for %s : %s"
(W illegalproto) An illegal character was found in a prototype
declaration.  The '_' in a prototype must be followed by a ';',
indicating the rest of the parameters are optional, or one of '@'
or '%', since those two will accept 0 or more final parameters.
.IP "Illegal character \e%o (carriage return)" 4
.IX Item "Illegal character %o (carriage return)"
(F) Perl normally treats carriage returns in the program text as
it would any other whitespace, which means you should never see
this error when Perl was built using standard options.  For some
reason, your version of Perl appears to have been built without
this support.  Talk to your Perl administrator.
.IP "Illegal character following sigil in a subroutine signature" 4
.IX Item "Illegal character following sigil in a subroutine signature"
(F) A parameter in a subroutine signature contained an unexpected character
following the \f(CW\*(C`$\*(C'\fR, \f(CW\*(C`@\*(C'\fR or \f(CW\*(C`%\*(C'\fR sigil character.  Normally the sigil
should be followed by the variable name or \f(CW\*(C`=\*(C'\fR etc.  Perhaps you are
trying use a prototype while in the scope of \f(CW\*(C`use feature \*(Aqsignatures\*(Aq\*(C'\fR?
For example:
.Sp
.Vb 1
\&    sub foo ($$) {}            # legal \- a prototype
\&
\&    use feature \*(Aqsignatures;
\&    sub foo ($$) {}            # illegal \- was expecting a signature
\&    sub foo ($a, $b)
\&            :prototype($$) {}  # legal
.Ve
.ie n .IP "Illegal character in prototype for %s : %s" 4
.el .IP "Illegal character in prototype for \f(CW%s\fR : \f(CW%s\fR" 4
.IX Item "Illegal character in prototype for %s : %s"
(W illegalproto) An illegal character was found in a prototype declaration.
Legal characters in prototypes are $, @, %, *, ;, [, ], &, \e, and +.
Perhaps you were trying to write a subroutine signature but didn't enable
that feature first (\f(CW\*(C`use feature \*(Aqsignatures\*(Aq\*(C'\fR), so your signature was
instead interpreted as a bad prototype.
.IP "Illegal declaration of anonymous subroutine" 4
.IX Item "Illegal declaration of anonymous subroutine"
(F) When using the \f(CW\*(C`sub\*(C'\fR keyword to construct an anonymous subroutine,
you must always specify a block of code.  See perlsub.
.ie n .IP "Illegal declaration of subroutine %s" 4
.el .IP "Illegal declaration of subroutine \f(CW%s\fR" 4
.IX Item "Illegal declaration of subroutine %s"
(F) A subroutine was not declared correctly.  See perlsub.
.IP "Illegal division by zero" 4
.IX Item "Illegal division by zero"
(F) You tried to divide a number by 0.  Either something was wrong in
your logic, or you need to put a conditional in to guard against
meaningless input.
.ie n .IP "Illegal hexadecimal digit %s ignored" 4
.el .IP "Illegal hexadecimal digit \f(CW%s\fR ignored" 4
.IX Item "Illegal hexadecimal digit %s ignored"
(W digit) You may have tried to use a character other than 0 \- 9 or
A \- F, a \- f in a hexadecimal number.  Interpretation of the hexadecimal
number stopped before the illegal character.
.IP "Illegal modulus zero" 4
.IX Item "Illegal modulus zero"
(F) You tried to divide a number by 0 to get the remainder.  Most
numbers don't take to this kindly.
.IP "Illegal number of bits in vec" 4
.IX Item "Illegal number of bits in vec"
(F) The number of bits in \fBvec()\fR (the third argument) must be a power of
two from 1 to 32 (or 64, if your platform supports that).
.IP "Illegal octal digit '%c'" 4
.IX Item "Illegal octal digit '%c'"
(F) You used an 8 or 9 in an octal number.
.ie n .IP "Illegal octal digit %s ignored" 4
.el .IP "Illegal octal digit \f(CW%s\fR ignored" 4
.IX Item "Illegal octal digit %s ignored"
(W digit) You may have tried to use an 8 or 9 in an octal number.
Interpretation of the octal number stopped before the 8 or 9.
.IP "Illegal operator following parameter in a subroutine signature" 4
.IX Item "Illegal operator following parameter in a subroutine signature"
(F) A parameter in a subroutine signature, was followed by something
other than \f(CW\*(C`=\*(C'\fR introducing a default, \f(CW\*(C`,\*(C'\fR or \f(CW\*(C`)\*(C'\fR.
.Sp
.Vb 5
\&    use feature \*(Aqsignatures\*(Aq;
\&    sub foo ($=1) {}           # legal
\&    sub foo ($a = 1) {}        # legal
\&    sub foo ($a += 1) {}       # illegal
\&    sub foo ($a == 1) {}       # illegal
.Ve
.IP "Illegal pattern in regex; marked by <\-\-\ \s-1HERE\s0 in m/%s/" 4
.IX Item "Illegal pattern in regex; marked by <--HERE in m/%s/"
(F) You wrote something like
.Sp
.Vb 1
\& (?+foo)
.Ve
.Sp
The \f(CW"+"\fR is valid only when followed by digits, indicating a
capturing group.  See
\&\f(CW\*(C`(?\f(CIPARNO\f(CW)\*(C'\fR.
.IP "Illegal suidscript" 4
.IX Item "Illegal suidscript"
(F) The script run under suidperl was somehow illegal.
.IP "Illegal switch in \s-1PERL5OPT:\s0 \-%c" 4
.IX Item "Illegal switch in PERL5OPT: -%c"
(X) The \s-1PERL5OPT\s0 environment variable may only be used to set the
following switches: \fB\-[CDIMUdmtw]\fR.
.IP "Illegal user-defined property name" 4
.IX Item "Illegal user-defined property name"
(F) You specified a Unicode-like property name in a regular expression
pattern (using \f(CW\*(C`\ep{}\*(C'\fR or \f(CW\*(C`\eP{}\*(C'\fR) that Perl knows isn't an official
Unicode property, and was likely meant to be a user-defined property
name, but it can't be one of those, as they must begin with either \f(CW\*(C`In\*(C'\fR
or \f(CW\*(C`Is\*(C'\fR.  Check the spelling.  See also
\&\*(L"Can't find Unicode property definition \*(R"%s"".
.ie n .IP "Ill-formed \s-1CRTL\s0 environ value ""%s""" 4
.el .IP "Ill-formed \s-1CRTL\s0 environ value ``%s''" 4
.IX Item "Ill-formed CRTL environ value %s"
(W internal) A warning peculiar to \s-1VMS.\s0  Perl tried to read the \s-1CRTL\s0's
internal environ array, and encountered an element without the \f(CW\*(C`=\*(C'\fR
delimiter used to separate keys from values.  The element is ignored.
.IP "Ill-formed message in prime_env_iter: |%s|" 4
.IX Item "Ill-formed message in prime_env_iter: |%s|"
(W internal) A warning peculiar to \s-1VMS.\s0  Perl tried to read a logical
name or \s-1CLI\s0 symbol definition when preparing to iterate over \f(CW%ENV\fR, and
didn't see the expected delimiter between key and value, so the line was
ignored.
.ie n .IP "(in cleanup) %s" 4
.el .IP "(in cleanup) \f(CW%s\fR" 4
.IX Item "(in cleanup) %s"
(W misc) This prefix usually indicates that a \s-1\fBDESTROY\s0()\fR method raised
the indicated exception.  Since destructors are usually called by the
system at arbitrary points during execution, and often a vast number of
times, the warning is issued only once for any number of failures that
would otherwise result in the same message being repeated.
.Sp
Failure of user callbacks dispatched using the \f(CW\*(C`G_KEEPERR\*(C'\fR flag could
also result in this warning.  See \*(L"G_KEEPERR\*(R" in perlcall.
.IP "Incomplete expression within '(?[ ])' in regex; marked by <\-\-\ \s-1HERE\s0 in m/%s/" 4
.IX Item "Incomplete expression within '(?[ ])' in regex; marked by <--HERE in m/%s/"
(F) There was a syntax error within the \f(CW\*(C`(?[ ])\*(C'\fR.  This can happen if the
expression inside the construct was completely empty, or if there are
too many or few operands for the number of operators.  Perl is not smart
enough to give you a more precise indication as to what is wrong.
.IP "Inconsistent hierarchy during C3 merge of class '%s': merging failed on parent '%s'" 4
.IX Item "Inconsistent hierarchy during C3 merge of class '%s': merging failed on parent '%s'"
(F) The method resolution order (\s-1MRO\s0) of the given class is not
C3\-consistent, and you have enabled the C3 \s-1MRO\s0 for this class.  See the C3
documentation in mro for more information.
.ie n .IP "Indentation on line %d of here-doc doesn't match delimiter" 4
.el .IP "Indentation on line \f(CW%d\fR of here-doc doesn't match delimiter" 4
.IX Item "Indentation on line %d of here-doc doesn't match delimiter"
(F) You have an indented here-document where one or more of its lines
have whitespace at the beginning that does not match the closing
delimiter.
.Sp
For example, line 2 below is wrong because it does not have at least
2 spaces, but lines 1 and 3 are fine because they have at least 2:
.Sp
.Vb 7
\&    if ($something) {
\&      print <<~EOF;
\&        Line 1
\&       Line 2 not
\&          Line 3
\&        EOF
\&    }
.Ve
.Sp
Note that tabs and spaces are compared strictly, meaning 1 tab will
not match 8 spaces.
.IP "Infinite recursion in regex" 4
.IX Item "Infinite recursion in regex"
(F) You used a pattern that references itself without consuming any input
text.  You should check the pattern to ensure that recursive patterns
either consume text or fail.
.IP "Infinite recursion via empty pattern" 4
.IX Item "Infinite recursion via empty pattern"
(F) You tried to use the empty pattern inside of a regex code block,
for instance \f(CW\*(C`/(?{ s!!! })/\*(C'\fR, which resulted in re-executing
the same pattern, which is an infinite loop which is broken by
throwing an exception.
.IP "Initialization of state variables in list currently forbidden" 4
.IX Item "Initialization of state variables in list currently forbidden"
(F) \f(CW\*(C`state\*(C'\fR only permits initializing a single variable, specified
without parentheses.  So \f(CW\*(C`state $a = 42\*(C'\fR and \f(CW\*(C`state @a = qw(a b c)\*(C'\fR are
allowed, but not \f(CW\*(C`state ($a) = 42\*(C'\fR or \f(CW\*(C`(state $a) = 42\*(C'\fR.  To initialize
more than one \f(CW\*(C`state\*(C'\fR variable, initialize them one at a time.
.IP "%%s[%s] in scalar context better written as $%s[%s]" 4
.IX Item "%%s[%s] in scalar context better written as $%s[%s]"
(W syntax) In scalar context, you've used an array index/value slice
(indicated by %) to select a single element of an array.  Generally
it's better to ask for a scalar value (indicated by $).  The difference
is that \f(CW$foo[&bar]\fR always behaves like a scalar, both in the value it
returns and when evaluating its argument, while \f(CW%foo[&bar]\fR provides
a list context to its subscript, which can do weird things if you're
expecting only one subscript.  When called in list context, it also
returns the index (what \f(CW&bar\fR returns) in addition to the value.
.IP "%%s{%s} in scalar context better written as $%s{%s}" 4
.IX Item "%%s{%s} in scalar context better written as $%s{%s}"
(W syntax) In scalar context, you've used a hash key/value slice
(indicated by %) to select a single element of a hash.  Generally it's
better to ask for a scalar value (indicated by $).  The difference
is that \f(CW$foo{&bar}\fR always behaves like a scalar, both in the value
it returns and when evaluating its argument, while \f(CW@foo{&bar}\fR and
provides a list context to its subscript, which can do weird things
if you're expecting only one subscript.  When called in list context,
it also returns the key in addition to the value.
.ie n .IP "Insecure dependency in %s" 4
.el .IP "Insecure dependency in \f(CW%s\fR" 4
.IX Item "Insecure dependency in %s"
(F) You tried to do something that the tainting mechanism didn't like.
The tainting mechanism is turned on when you're running setuid or
setgid, or when you specify \fB\-T\fR to turn it on explicitly.  The
tainting mechanism labels all data that's derived directly or indirectly
from the user, who is considered to be unworthy of your trust.  If any
such data is used in a \*(L"dangerous\*(R" operation, you get this error.  See
perlsec for more information.
.ie n .IP "Insecure directory in %s" 4
.el .IP "Insecure directory in \f(CW%s\fR" 4
.IX Item "Insecure directory in %s"
(F) You can't use \fBsystem()\fR, \fBexec()\fR, or a piped open in a setuid or
setgid script if \f(CW$ENV{PATH}\fR contains a directory that is writable by
the world.  Also, the \s-1PATH\s0 must not contain any relative directory.
See perlsec.
.ie n .IP "Insecure $ENV{%s} while running %s" 4
.el .IP "Insecure \f(CW$ENV\fR{%s} while running \f(CW%s\fR" 4
.IX Item "Insecure $ENV{%s} while running %s"
(F) You can't use \fBsystem()\fR, \fBexec()\fR, or a piped open in a setuid or
setgid script if any of \f(CW$ENV{PATH}\fR, \f(CW$ENV{IFS}\fR, \f(CW$ENV{CDPATH}\fR,
\&\f(CW$ENV{ENV}\fR, \f(CW$ENV{BASH_ENV}\fR or \f(CW$ENV{TERM}\fR are derived from data
supplied (or potentially supplied) by the user.  The script must set
the path to a known value, using trustworthy data.  See perlsec.
.ie n .IP "Insecure user-defined property %s" 4
.el .IP "Insecure user-defined property \f(CW%s\fR" 4
.IX Item "Insecure user-defined property %s"
(F) Perl detected tainted data when trying to compile a regular
expression that contains a call to a user-defined character property
function, i.e. \f(CW\*(C`\ep{IsFoo}\*(C'\fR or \f(CW\*(C`\ep{InFoo}\*(C'\fR.
See \*(L"User-Defined Character Properties\*(R" in perlunicode and perlsec.
.ie n .IP "Integer overflow in format string for %s" 4
.el .IP "Integer overflow in format string for \f(CW%s\fR" 4
.IX Item "Integer overflow in format string for %s"
(F) The indexes and widths specified in the format string of \f(CW\*(C`printf()\*(C'\fR
or \f(CW\*(C`sprintf()\*(C'\fR are too large.  The numbers must not overflow the size of
integers for your architecture.
.ie n .IP "Integer overflow in %s number" 4
.el .IP "Integer overflow in \f(CW%s\fR number" 4
.IX Item "Integer overflow in %s number"
(S overflow) The hexadecimal, octal or binary number you have specified
either as a literal or as an argument to \fBhex()\fR or \fBoct()\fR is too big for
your architecture, and has been converted to a floating point number.
On a 32\-bit architecture the largest hexadecimal, octal or binary number
representable without overflow is 0xFFFFFFFF, 037777777777, or
0b11111111111111111111111111111111 respectively.  Note that Perl
transparently promotes all numbers to a floating point representation
internally\*(--subject to loss of precision errors in subsequent
operations.
.IP "Integer overflow in srand" 4
.IX Item "Integer overflow in srand"
(S overflow) The number you have passed to srand is too big to fit
in your architecture's integer representation.  The number has been
replaced with the largest integer supported (0xFFFFFFFF on 32\-bit
architectures).  This means you may be getting less randomness than
you expect, because different random seeds above the maximum will
return the same sequence of random numbers.
.IP "Integer overflow in version" 4
.IX Item "Integer overflow in version"
.PD 0
.ie n .IP "Integer overflow in version %d" 4
.el .IP "Integer overflow in version \f(CW%d\fR" 4
.IX Item "Integer overflow in version %d"
.PD
(W overflow) Some portion of a version initialization is too large for
the size of integers for your architecture.  This is not a warning
because there is no rational reason for a version to try and use an
element larger than typically 2**32.  This is usually caused by trying
to use some odd mathematical operation as a version, like 100/9.
.IP "Internal disaster in regex; marked by <\-\-\ \s-1HERE\s0 in m/%s/" 4
.IX Item "Internal disaster in regex; marked by <--HERE in m/%s/"
(P) Something went badly wrong in the regular expression parser.
The <\-\-\ \s-1HERE\s0 shows whereabouts in the regular expression the problem was
discovered.
.IP "Internal inconsistency in tracking vforks" 4
.IX Item "Internal inconsistency in tracking vforks"
(S) A warning peculiar to \s-1VMS.\s0  Perl keeps track of the number of times
you've called \f(CW\*(C`fork\*(C'\fR and \f(CW\*(C`exec\*(C'\fR, to determine whether the current call
to \f(CW\*(C`exec\*(C'\fR should affect the current script or a subprocess (see
\&\*(L"exec \s-1LIST\*(R"\s0 in perlvms).  Somehow, this count has become scrambled, so
Perl is making a guess and treating this \f(CW\*(C`exec\*(C'\fR as a request to
terminate the Perl script and execute the specified command.
.IP "internal %<num>p might conflict with future printf extensions" 4
.IX Item "internal %<num>p might conflict with future printf extensions"
(S internal) Perl's internal routine that handles \f(CW\*(C`printf\*(C'\fR and \f(CW\*(C`sprintf\*(C'\fR
formatting follows a slightly different set of rules when called from
C or \s-1XS\s0 code.  Specifically, formats consisting of digits followed
by \*(L"p\*(R" (e.g., \*(L"%7p\*(R") are reserved for future use.  If you see this
message, then an \s-1XS\s0 module tried to call that routine with one such
reserved format.
.IP "Internal urp in regex; marked by <\-\-\ \s-1HERE\s0 in m/%s/" 4
.IX Item "Internal urp in regex; marked by <--HERE in m/%s/"
(P) Something went badly awry in the regular expression parser.  The
<\-\-\ \s-1HERE\s0 shows whereabouts in the regular expression the problem was
discovered.
.ie n .IP "%s (...) interpreted as function" 4
.el .IP "\f(CW%s\fR (...) interpreted as function" 4
.IX Item "%s (...) interpreted as function"
(W syntax) You've run afoul of the rule that says that any list operator
followed by parentheses turns into a function, with all the list
operators arguments found inside the parentheses.  See
\&\*(L"Terms and List Operators (Leftward)\*(R" in perlop.
.IP "In '(?...)', the '(' and '?' must be adjacent in regex; marked by <\-\-\ \s-1HERE\s0 in m/%s/" 4
.IX Item "In '(?...)', the '(' and '?' must be adjacent in regex; marked by <--HERE in m/%s/"
(F) The two-character sequence \f(CW"(?"\fR in this context in a regular
expression pattern should be an indivisible token, with nothing
intervening between the \f(CW"("\fR and the \f(CW"?"\fR, but you separated them
with whitespace.
.IP "In '(*...)', the '(' and '*' must be adjacent in regex; marked by <\-\-\ \s-1HERE\s0 in m/%s/" 4
.IX Item "In '(*...)', the '(' and '*' must be adjacent in regex; marked by <--HERE in m/%s/"
(F) The two-character sequence \f(CW"(*"\fR in this context in a regular
expression pattern should be an indivisible token, with nothing
intervening between the \f(CW"("\fR and the \f(CW"*"\fR, but you separated them.
Fix the pattern and retry.
.ie n .IP "Invalid %s attribute: %s" 4
.el .IP "Invalid \f(CW%s\fR attribute: \f(CW%s\fR" 4
.IX Item "Invalid %s attribute: %s"
(F) The indicated attribute for a subroutine or variable was not recognized
by Perl or by a user-supplied handler.  See attributes.
.ie n .IP "Invalid %s attributes: %s" 4
.el .IP "Invalid \f(CW%s\fR attributes: \f(CW%s\fR" 4
.IX Item "Invalid %s attributes: %s"
(F) The indicated attributes for a subroutine or variable were not
recognized by Perl or by a user-supplied handler.  See attributes.
.IP "Invalid character in charnames alias definition; marked by <\-\-\ \s-1HERE\s0 in '%s" 4
.IX Item "Invalid character in charnames alias definition; marked by <--HERE in '%s"
(F) You tried to create a custom alias for a character name, with
the \f(CW\*(C`:alias\*(C'\fR option to \f(CW\*(C`use charnames\*(C'\fR and the specified character in
the indicated name isn't valid.  See \*(L"\s-1CUSTOM ALIASES\*(R"\s0 in charnames.
.ie n .IP "Invalid \e0 character in %s for %s: %s\e0%s" 4
.el .IP "Invalid \e0 character in \f(CW%s\fR for \f(CW%s:\fR \f(CW%s\fR\e0%s" 4
.IX Item "Invalid 0 character in %s for %s: %s0%s"
(W syscalls) Embedded \e0 characters in pathnames or other system call
arguments produce a warning as of 5.20.  The parts after the \e0 were
formerly ignored by system calls.
.IP "Invalid character in \eN{...}; marked by <\-\-\ \s-1HERE\s0 in \eN{%s}" 4
.IX Item "Invalid character in N{...}; marked by <--HERE in N{%s}"
(F) Only certain characters are valid for character names.  The
indicated one isn't.  See \*(L"\s-1CUSTOM ALIASES\*(R"\s0 in charnames.
.ie n .IP "Invalid conversion in %s: ""%s""" 4
.el .IP "Invalid conversion in \f(CW%s:\fR ``%s''" 4
.IX Item "Invalid conversion in %s: %s"
(W printf) Perl does not understand the given format conversion.  See
\&\*(L"sprintf\*(R" in perlfunc.
.IP "Invalid escape in the specified encoding in regex; marked by <\-\-\ \s-1HERE\s0 in m/%s/" 4
.IX Item "Invalid escape in the specified encoding in regex; marked by <--HERE in m/%s/"
(W regexp)(F) The numeric escape (for example \f(CW\*(C`\exHH\*(C'\fR) of value < 256
didn't correspond to a single character through the conversion
from the encoding specified by the encoding pragma.
The escape was replaced with \s-1REPLACEMENT CHARACTER\s0 (U+FFFD)
instead, except within \f(CW\*(C`(?[\ \ \ ])\*(C'\fR, where it is a fatal error.
The <\-\-\ \s-1HERE\s0 shows whereabouts in the regular expression the
escape was discovered.
.IP "Invalid hexadecimal number in \eN{U+...}" 4
.IX Item "Invalid hexadecimal number in N{U+...}"
.PD 0
.IP "Invalid hexadecimal number in \eN{U+...} in regex; marked by <\-\-\ \s-1HERE\s0 in m/%s/" 4
.IX Item "Invalid hexadecimal number in N{U+...} in regex; marked by <--HERE in m/%s/"
.PD
(F) The character constant represented by \f(CW\*(C`...\*(C'\fR is not a valid hexadecimal
number.  Either it is empty, or you tried to use a character other than
0 \- 9 or A \- F, a \- f in a hexadecimal number.
.ie n .IP "Invalid module name %s with \-%c option: contains single ':'" 4
.el .IP "Invalid module name \f(CW%s\fR with \-%c option: contains single ':'" 4
.IX Item "Invalid module name %s with -%c option: contains single ':'"
(F) The module argument to perl's \fB\-m\fR and \fB\-M\fR command-line options
cannot contain single colons in the module name, but only in the
arguments after \*(L"=\*(R".  In other words, \fB\-MFoo::Bar=:baz\fR is ok, but
\&\fB\-MFoo:Bar=baz\fR is not.
.IP "Invalid mro name: '%s'" 4
.IX Item "Invalid mro name: '%s'"
(F) You tried to \f(CW\*(C`mro::set_mro("classname", "foo")\*(C'\fR or \f(CW\*(C`use mro \*(Aqfoo\*(Aq\*(C'\fR,
where \f(CW\*(C`foo\*(C'\fR is not a valid method resolution order (\s-1MRO\s0).  Currently,
the only valid ones supported are \f(CW\*(C`dfs\*(C'\fR and \f(CW\*(C`c3\*(C'\fR, unless you have loaded
a module that is a \s-1MRO\s0 plugin.  See mro and perlmroapi.
.IP "Invalid negative number (%s) in chr" 4
.IX Item "Invalid negative number (%s) in chr"
(W utf8) You passed a negative number to \f(CW\*(C`chr\*(C'\fR.  Negative numbers are
not valid character numbers, so it returns the Unicode replacement
character (U+FFFD).
.IP "Invalid number '%s' for \-C option." 4
.IX Item "Invalid number '%s' for -C option."
(F) You supplied a number to the \-C option that either has extra leading
zeroes or overflows perl's unsigned integer representation.
.IP "invalid option \-D%c, use \-D'' to see choices" 4
.IX Item "invalid option -D%c, use -D'' to see choices"
(S debugging) Perl was called with invalid debugger flags.  Call perl
with the \fB\-D\fR option with no flags to see the list of acceptable values.
See also \*(L"\-Dletters\*(R" in perlrun.
.IP "Invalid quantifier in {,} in regex; marked by <\-\-\ \s-1HERE\s0 in m/%s/" 4
.IX Item "Invalid quantifier in {,} in regex; marked by <--HERE in m/%s/"
(F) The pattern looks like a {min,max} quantifier, but the min or max
could not be parsed as a valid number \- either it has leading zeroes,
or it represents too big a number to cope with.  The <\-\-\ \s-1HERE\s0 shows
where in the regular expression the problem was discovered.  See perlre.
.ie n .IP "Invalid [] range ""%s"" in regex; marked by <\-\-\ \s-1HERE\s0 in m/%s/" 4
.el .IP "Invalid [] range ``%s'' in regex; marked by <\-\-\ \s-1HERE\s0 in m/%s/" 4
.IX Item "Invalid [] range %s in regex; marked by <--HERE in m/%s/"
(F) The range specified in a character class had a minimum character
greater than the maximum character.  One possibility is that you forgot the
\&\f(CW\*(C`{}\*(C'\fR from your ending \f(CW\*(C`\ex{}\*(C'\fR \- \f(CW\*(C`\ex\*(C'\fR without the curly braces can go only
up to \f(CW\*(C`ff\*(C'\fR.  The <\-\-\ \s-1HERE\s0 shows whereabouts in the regular expression the
problem was discovered.  See perlre.
.ie n .IP "Invalid range ""%s"" in transliteration operator" 4
.el .IP "Invalid range ``%s'' in transliteration operator" 4
.IX Item "Invalid range %s in transliteration operator"
(F) The range specified in the tr/// or y/// operator had a minimum
character greater than the maximum character.  See perlop.
.ie n .IP "Invalid separator character %s in attribute list" 4
.el .IP "Invalid separator character \f(CW%s\fR in attribute list" 4
.IX Item "Invalid separator character %s in attribute list"
(F) Something other than a colon or whitespace was seen between the
elements of an attribute list.  If the previous attribute had a
parenthesised parameter list, perhaps that list was terminated too soon.
See attributes.
.ie n .IP "Invalid separator character %s in PerlIO layer specification %s" 4
.el .IP "Invalid separator character \f(CW%s\fR in PerlIO layer specification \f(CW%s\fR" 4
.IX Item "Invalid separator character %s in PerlIO layer specification %s"
(W layer) When pushing layers onto the Perl I/O system, something other
than a colon or whitespace was seen between the elements of a layer list.
If the previous attribute had a parenthesised parameter list, perhaps that
list was terminated too soon.
.IP "Invalid strict version format (%s)" 4
.IX Item "Invalid strict version format (%s)"
(F) A version number did not meet the \*(L"strict\*(R" criteria for versions.
A \*(L"strict\*(R" version number is a positive decimal number (integer or
decimal-fraction) without exponentiation or else a dotted-decimal
v\-string with a leading 'v' character and at least three components.
The parenthesized text indicates which criteria were not met.
See the version module for more details on allowed version formats.
.ie n .IP "Invalid type '%s' in %s" 4
.el .IP "Invalid type '%s' in \f(CW%s\fR" 4
.IX Item "Invalid type '%s' in %s"
(F) The given character is not a valid pack or unpack type.
See \*(L"pack\*(R" in perlfunc.
.Sp
(W) The given character is not a valid pack or unpack type but used to be
silently ignored.
.IP "Invalid version format (%s)" 4
.IX Item "Invalid version format (%s)"
(F) A version number did not meet the \*(L"lax\*(R" criteria for versions.
A \*(L"lax\*(R" version number is a positive decimal number (integer or
decimal-fraction) without exponentiation or else a dotted-decimal
v\-string.  If the v\-string has fewer than three components, it
must have a leading 'v' character.  Otherwise, the leading 'v' is
optional.  Both decimal and dotted-decimal versions may have a
trailing \*(L"alpha\*(R" component separated by an underscore character
after a fractional or dotted-decimal component.  The parenthesized
text indicates which criteria were not met.  See the version module
for more details on allowed version formats.
.IP "Invalid version object" 4
.IX Item "Invalid version object"
(F) The internal structure of the version object was invalid.
Perhaps the internals were modified directly in some way or
an arbitrary reference was blessed into the \*(L"version\*(R" class.
.IP "In '(*VERB...)', the '(' and '*' must be adjacent in regex; marked by <\-\-\ \s-1HERE\s0 in m/%s/" 4
.IX Item "In '(*VERB...)', the '(' and '*' must be adjacent in regex; marked by <--HERE in m/%s/"
(F) The two-character sequence \f(CW"(*"\fR in this context in a regular
expression pattern should be an indivisible token, with nothing
intervening between the \f(CW"("\fR and the \f(CW"*"\fR, but you separated them.
.IP "ioctl is not implemented" 4
.IX Item "ioctl is not implemented"
(F) Your machine apparently doesn't implement \fBioctl()\fR, which is pretty
strange for a machine that supports C.
.ie n .IP "\fBioctl()\fR on unopened %s" 4
.el .IP "\fBioctl()\fR on unopened \f(CW%s\fR" 4
.IX Item "ioctl() on unopened %s"
(W unopened) You tried \fBioctl()\fR on a filehandle that was never opened.
Check your control flow and number of arguments.
.IP "\s-1IO\s0 layers (like '%s') unavailable" 4
.IX Item "IO layers (like '%s') unavailable"
(F) Your Perl has not been configured to have PerlIO, and therefore
you cannot use \s-1IO\s0 layers.  To have PerlIO, Perl must be configured
with 'useperlio'.
.IP "IO::Socket::atmark not implemented on this architecture" 4
.IX Item "IO::Socket::atmark not implemented on this architecture"
(F) Your machine doesn't implement the \fBsockatmark()\fR functionality,
neither as a system call nor an ioctl call (\s-1SIOCATMARK\s0).
.IP "'%s' is an unknown bound type in regex; marked by <\-\-\ \s-1HERE\s0 in m/%s/" 4
.IX Item "'%s' is an unknown bound type in regex; marked by <--HERE in m/%s/"
(F) You used \f(CW\*(C`\eb{...}\*(C'\fR or \f(CW\*(C`\eB{...}\*(C'\fR and the \f(CW\*(C`...\*(C'\fR is not known to
Perl.  The current valid ones are given in
\&\*(L"\eb{}, \eb, \eB{}, \eB\*(R" in perlrebackslash.
.IP "%s() isn't allowed on :utf8 handles" 4
.IX Item "%s() isn't allowed on :utf8 handles"
(F) The \fBsysread()\fR, \fBrecv()\fR, \fBsyswrite()\fR and \fBsend()\fR operators are
not allowed on handles that have the \f(CW\*(C`:utf8\*(C'\fR layer, either explicitly, or
implicitly, eg., with the \f(CW\*(C`:encoding(UTF\-16LE)\*(C'\fR layer.
.Sp
Previously \fBsysread()\fR and \fBrecv()\fR currently use only the \f(CW\*(C`:utf8\*(C'\fR flag for the stream,
ignoring the actual layers.  Since \fBsysread()\fR and \fBrecv()\fR did no \s-1UTF\-8\s0
validation they can end up creating invalidly encoded scalars.
.Sp
Similarly, \fBsyswrite()\fR and \fBsend()\fR used only the \f(CW\*(C`:utf8\*(C'\fR flag, otherwise ignoring
any layers.  If the flag is set, both wrote the value \s-1UTF\-8\s0 encoded, even if
the layer is some different encoding, such as the example above.
.Sp
Ideally, all of these operators would completely ignore the \f(CW\*(C`:utf8\*(C'\fR state,
working only with bytes, but this would result in silently breaking existing
code.
.ie n .IP """%s"" is more clearly written simply as ""%s"" in regex; marked by <\-\-\ \s-1HERE\s0 in m/%s/" 4
.el .IP "``%s'' is more clearly written simply as ``%s'' in regex; marked by <\-\-\ \s-1HERE\s0 in m/%s/" 4
.IX Item "%s is more clearly written simply as %s in regex; marked by <--HERE in m/%s/"
(W regexp) (only under \f(CW\*(C`use\ re\ \*(Aqstrict\*(Aq\*(C'\fR or within \f(CW\*(C`(?[...])\*(C'\fR)
.Sp
You specified a character that has the given plainer way of writing it, and
which is also portable to platforms running with different character sets.
.IP "$* is no longer supported as of Perl 5.30" 4
.IX Item "$* is no longer supported as of Perl 5.30"
(F) The special variable \f(CW$*\fR, deprecated in older perls, was removed in
5.10.0, is no longer supported and is a fatal error as of Perl 5.30.  In
previous versions of perl the use of \f(CW$*\fR enabled or disabled multi-line
matching within a string.
.Sp
Instead of using \f(CW$*\fR you should use the \f(CW\*(C`/m\*(C'\fR (and maybe \f(CW\*(C`/s\*(C'\fR) regexp
modifiers.  You can enable \f(CW\*(C`/m\*(C'\fR for a lexical scope (even a whole file)
with \f(CW\*(C`use re \*(Aq/m\*(Aq\*(C'\fR.  (In older versions: when \f(CW$*\fR was set to a true value
then all regular expressions behaved as if they were written using \f(CW\*(C`/m\*(C'\fR.)
.Sp
Use of this variable will be a fatal error in Perl 5.30.
.IP "$# is no longer supported as of Perl 5.30" 4
.IX Item "$# is no longer supported as of Perl 5.30"
(F) The special variable \f(CW$#\fR, deprecated in older perls, was removed as of
5.10.0, is no longer supported and is a fatal error as of Perl 5.30.  You
should use the printf/sprintf functions instead.
.IP "'%s' is not a code reference" 4
.IX Item "'%s' is not a code reference"
(W overload) The second (fourth, sixth, ...) argument of
overload::constant needs to be a code reference.  Either
an anonymous subroutine, or a reference to a subroutine.
.IP "'%s' is not an overloadable type" 4
.IX Item "'%s' is not an overloadable type"
(W overload) You tried to overload a constant type the overload package is
unaware of.
.IP "\-i used with no filenames on the command line, reading from \s-1STDIN\s0" 4
.IX Item "-i used with no filenames on the command line, reading from STDIN"
(S inplace) The \f(CW\*(C`\-i\*(C'\fR option was passed on the command line, indicating
that the script is intended to edit files in place, but no files were
given.  This is usually a mistake, since editing \s-1STDIN\s0 in place doesn't
make sense, and can be confusing because it can make perl look like
it is hanging when it is really just trying to read from \s-1STDIN.\s0  You
should either pass a filename to edit, or remove \f(CW\*(C`\-i\*(C'\fR from the command
line.  See perlrun for more details.
.IP "Junk on end of regexp in regex m/%s/" 4
.IX Item "Junk on end of regexp in regex m/%s/"
(P) The regular expression parser is confused.
.ie n .IP "Label not found for ""last %s""" 4
.el .IP "Label not found for ``last \f(CW%s\fR''" 4
.IX Item "Label not found for last %s"
(F) You named a loop to break out of, but you're not currently in a loop
of that name, not even if you count where you were called from.  See
\&\*(L"last\*(R" in perlfunc.
.ie n .IP "Label not found for ""next %s""" 4
.el .IP "Label not found for ``next \f(CW%s\fR''" 4
.IX Item "Label not found for next %s"
(F) You named a loop to continue, but you're not currently in a loop of
that name, not even if you count where you were called from.  See
\&\*(L"last\*(R" in perlfunc.
.ie n .IP "Label not found for ""redo %s""" 4
.el .IP "Label not found for ``redo \f(CW%s\fR''" 4
.IX Item "Label not found for redo %s"
(F) You named a loop to restart, but you're not currently in a loop of
that name, not even if you count where you were called from.  See
\&\*(L"last\*(R" in perlfunc.
.ie n .IP "leaving effective %s failed" 4
.el .IP "leaving effective \f(CW%s\fR failed" 4
.IX Item "leaving effective %s failed"
(F) While under the \f(CW\*(C`use filetest\*(C'\fR pragma, switching the real and
effective uids or gids failed.
.IP "length/code after end of string in unpack" 4
.IX Item "length/code after end of string in unpack"
(F) While unpacking, the string buffer was already used up when an unpack
length/code combination tried to obtain more data.  This results in
an undefined value for the length.  See \*(L"pack\*(R" in perlfunc.
.ie n .IP "\fBlength()\fR used on %s (did you mean ""scalar(%s)""?)" 4
.el .IP "\fBlength()\fR used on \f(CW%s\fR (did you mean ``scalar(%s)''?)" 4
.IX Item "length() used on %s (did you mean scalar(%s)?)"
(W syntax) You used \fBlength()\fR on either an array or a hash when you
probably wanted a count of the items.
.Sp
Array size can be obtained by doing:
.Sp
.Vb 1
\&    scalar(@array);
.Ve
.Sp
The number of items in a hash can be obtained by doing:
.Sp
.Vb 1
\&    scalar(keys %hash);
.Ve
.IP "Lexing code attempted to stuff non\-Latin\-1 character into Latin\-1 input" 4
.IX Item "Lexing code attempted to stuff non-Latin-1 character into Latin-1 input"
(F) An extension is attempting to insert text into the current parse
(using lex_stuff_pvn or similar), but tried to insert a character that
couldn't be part of the current input.  This is an inherent pitfall
of the stuffing mechanism, and one of the reasons to avoid it.  Where
it is necessary to stuff, stuffing only plain \s-1ASCII\s0 is recommended.
.IP "Lexing code internal error (%s)" 4
.IX Item "Lexing code internal error (%s)"
(F) Lexing code supplied by an extension violated the lexer's \s-1API\s0 in a
detectable way.
.ie n .IP "\fBlisten()\fR on closed socket %s" 4
.el .IP "\fBlisten()\fR on closed socket \f(CW%s\fR" 4
.IX Item "listen() on closed socket %s"
(W closed) You tried to do a listen on a closed socket.  Did you forget
to check the return value of your \fBsocket()\fR call?  See
\&\*(L"listen\*(R" in perlfunc.
.IP "List form of piped open not implemented" 4
.IX Item "List form of piped open not implemented"
(F) On some platforms, notably Windows, the three-or-more-arguments
form of \f(CW\*(C`open\*(C'\fR does not support pipes, such as \f(CW\*(C`open($pipe, \*(Aq|\-\*(Aq, @args)\*(C'\fR.
Use the two-argument \f(CW\*(C`open($pipe, \*(Aq|prog arg1 arg2...\*(Aq)\*(C'\fR form instead.
.IP "Literal vertical space in [] is illegal except under /x in regex; marked by <\-\-\ \s-1HERE\s0 in m/%s/" 4
.IX Item "Literal vertical space in [] is illegal except under /x in regex; marked by <--HERE in m/%s/"
(F) (only under \f(CW\*(C`use\ re\ \*(Aqstrict\*(Aq\*(C'\fR or within \f(CW\*(C`(?[...])\*(C'\fR)
.Sp
Likely you forgot the \f(CW\*(C`/x\*(C'\fR modifier or there was a typo in the pattern.
For example, did you really mean to match a form-feed?  If so, all the
\&\s-1ASCII\s0 vertical space control characters are representable by escape
sequences which won't present such a jarring appearance as your pattern
does when displayed.
.Sp
.Vb 4
\&  \er    carriage return
\&  \ef    form feed
\&  \en    line feed
\&  \ecK   vertical tab
.Ve
.ie n .IP "%s: loadable library and perl binaries are mismatched (got handshake key %p, needed %p)" 4
.el .IP "\f(CW%s:\fR loadable library and perl binaries are mismatched (got handshake key \f(CW%p\fR, needed \f(CW%p\fR)" 4
.IX Item "%s: loadable library and perl binaries are mismatched (got handshake key %p, needed %p)"
(P) A dynamic loading library \f(CW\*(C`.so\*(C'\fR or \f(CW\*(C`.dll\*(C'\fR was being loaded into the
process that was built against a different build of perl than the
said library was compiled against.  Reinstalling the \s-1XS\s0 module will
likely fix this error.
.ie n .IP "Locale '%s' contains (at least) the following characters which have unexpected meanings: %s  The Perl program will use the expected meanings" 4
.el .IP "Locale '%s' contains (at least) the following characters which have unexpected meanings: \f(CW%s\fR  The Perl program will use the expected meanings" 4
.IX Item "Locale '%s' contains (at least) the following characters which have unexpected meanings: %s The Perl program will use the expected meanings"
(W locale) You are using the named \s-1UTF\-8\s0 locale.  \s-1UTF\-8\s0 locales are
expected to have very particular behavior, which most do.  This message
arises when perl found some departures from the expectations, and is
notifying you that the expected behavior overrides these differences.
In some cases the differences are caused by the locale definition being
defective, but the most common causes of this warning are when there are
ambiguities and conflicts in following the Standard, and the locale has
chosen an approach that differs from Perl's.
.Sp
One of these is because that, contrary to the claims, Unicode is not
completely locale insensitive.  Turkish and some related languages
have two types of \f(CW"I"\fR characters.  One is dotted in both upper\- and
lowercase, and the other is dotless in both cases.  Unicode allows a
locale to use either the Turkish rules, or the rules used in all other
instances, where there is only one type of \f(CW"I"\fR, which is dotless in
the uppercase, and dotted in the lower.  The perl core does not (yet)
handle the Turkish case, and this message warns you of that.  Instead,
the Unicode::Casing module allows you to mostly implement the Turkish
casing rules.
.Sp
The other common cause is for the characters
.Sp
.Vb 1
\& $ + < = > ^ \` | ~
.Ve
.Sp
These are probematic.  The C standard says that these should be
considered punctuation in the C locale (and the \s-1POSIX\s0 standard defers to
the C standard), and Unicode is generally considered a superset of
the C locale.  But Unicode has added an extra category, \*(L"Symbol\*(R", and
classifies these particular characters as being symbols.  Most \s-1UTF\-8\s0
locales have them treated as punctuation, so that \fBispunct\fR\|(2) returns
non-zero for them.  But a few locales have it return 0.   Perl takes
the first approach, not using \f(CW\*(C`ispunct()\*(C'\fR at all (see Note [5] in
perlrecharclass), and this message is raised to notify you that you
are getting Perl's approach, not the locale's.
.IP "Locale '%s' may not work well.%s" 4
.IX Item "Locale '%s' may not work well.%s"
(W locale) You are using the named locale, which is a non\-UTF\-8 one, and
which perl has determined is not fully compatible with what it can
handle.  The second \f(CW%s\fR gives a reason.
.Sp
By far the most common reason is that the locale has characters in it
that are represented by more than one byte.  The only such locales that
Perl can handle are the \s-1UTF\-8\s0 locales.  Most likely the specified locale
is a non\-UTF\-8 one for an East Asian language such as Chinese or
Japanese.  If the locale is a superset of \s-1ASCII,\s0 the \s-1ASCII\s0 portion of it
may work in Perl.
.Sp
Some essentially obsolete locales that aren't supersets of \s-1ASCII,\s0 mainly
those in \s-1ISO 646\s0 or other 7\-bit locales, such as \s-1ASMO 449,\s0 can also have
problems, depending on what portions of the \s-1ASCII\s0 character set get
changed by the locale and are also used by the program.
The warning message lists the determinable conflicting characters.
.Sp
Note that not all incompatibilities are found.
.Sp
If this happens to you, there's not much you can do except switch to use a
different locale or use Encode to translate from the locale into
\&\s-1UTF\-8\s0; if that's impracticable, you have been warned that some things
may break.
.Sp
This message is output once each time a bad locale is switched into
within the scope of \f(CW\*(C`use\ locale\*(C'\fR, or on the first possibly-affected
operation if the \f(CW\*(C`use\ locale\*(C'\fR inherits a bad one.  It is not raised
for any operations from the \s-1POSIX\s0 module.
.IP "localtime(%f) failed" 4
.IX Item "localtime(%f) failed"
(W overflow) You called \f(CW\*(C`localtime\*(C'\fR with a number that it could not handle:
too large, too small, or NaN.  The returned value is \f(CW\*(C`undef\*(C'\fR.
.IP "localtime(%f) too large" 4
.IX Item "localtime(%f) too large"
(W overflow) You called \f(CW\*(C`localtime\*(C'\fR with a number that was larger
than it can reliably handle and \f(CW\*(C`localtime\*(C'\fR probably returned the
wrong date.  This warning is also triggered with NaN (the special
not-a-number value).
.IP "localtime(%f) too small" 4
.IX Item "localtime(%f) too small"
(W overflow) You called \f(CW\*(C`localtime\*(C'\fR with a number that was smaller
than it can reliably handle and \f(CW\*(C`localtime\*(C'\fR probably returned the
wrong date.
.ie n .IP "Lookbehind longer than %d not implemented in regex m/%s/" 4
.el .IP "Lookbehind longer than \f(CW%d\fR not implemented in regex m/%s/" 4
.IX Item "Lookbehind longer than %d not implemented in regex m/%s/"
(F) There is currently a limit on the length of string which lookbehind can
handle.  This restriction may be eased in a future release.
.ie n .IP "Lost precision when %s %f by 1" 4
.el .IP "Lost precision when \f(CW%s\fR \f(CW%f\fR by 1" 4
.IX Item "Lost precision when %s %f by 1"
(W imprecision) The value you attempted to increment or decrement by one
is too large for the underlying floating point representation to store
accurately, hence the target of \f(CW\*(C`++\*(C'\fR or \f(CW\*(C`\-\-\*(C'\fR is unchanged.  Perl issues this
warning because it has already switched from integers to floating point
when values are too large for integers, and now even floating point is
insufficient.  You may wish to switch to using Math::BigInt explicitly.
.IP "\fBlstat()\fR on filehandle%s" 4
.IX Item "lstat() on filehandle%s"
(W io) You tried to do an lstat on a filehandle.  What did you mean
by that?  \fBlstat()\fR makes sense only on filenames.  (Perl did a \fBfstat()\fR
instead on the filehandle.)
.ie n .IP "lvalue attribute %s already-defined subroutine" 4
.el .IP "lvalue attribute \f(CW%s\fR already-defined subroutine" 4
.IX Item "lvalue attribute %s already-defined subroutine"
(W misc) Although attributes.pm allows this, turning the lvalue
attribute on or off on a Perl subroutine that is already defined
does not always work properly.  It may or may not do what you
want, depending on what code is inside the subroutine, with exact
details subject to change between Perl versions.  Only do this
if you really know what you are doing.
.IP "lvalue attribute ignored after the subroutine has been defined" 4
.IX Item "lvalue attribute ignored after the subroutine has been defined"
(W misc) Using the \f(CW\*(C`:lvalue\*(C'\fR declarative syntax to make a Perl
subroutine an lvalue subroutine after it has been defined is
not permitted.  To make the subroutine an lvalue subroutine,
add the lvalue attribute to the definition, or put the \f(CW\*(C`sub
foo :lvalue;\*(C'\fR declaration before the definition.
.Sp
See also attributes.pm.
.IP "Magical list constants are not supported" 4
.IX Item "Magical list constants are not supported"
(F) You assigned a magical array to a stash element, and then tried
to use the subroutine from the same slot.  You are asking Perl to do
something it cannot do, details subject to change between Perl versions.
.IP "Malformed integer in [] in pack" 4
.IX Item "Malformed integer in [] in pack"
(F) Between the brackets enclosing a numeric repeat count only digits
are permitted.  See \*(L"pack\*(R" in perlfunc.
.IP "Malformed integer in [] in unpack" 4
.IX Item "Malformed integer in [] in unpack"
(F) Between the brackets enclosing a numeric repeat count only digits
are permitted.  See \*(L"pack\*(R" in perlfunc.
.IP "Malformed \s-1PERLLIB_PREFIX\s0" 4
.IX Item "Malformed PERLLIB_PREFIX"
(F) An error peculiar to \s-1OS/2.\s0  \s-1PERLLIB_PREFIX\s0 should be of the form
.Sp
.Vb 1
\&    prefix1;prefix2
.Ve
.Sp
or
    prefix1 prefix2
.Sp
with nonempty prefix1 and prefix2.  If \f(CW\*(C`prefix1\*(C'\fR is indeed a prefix of
a builtin library search path, prefix2 is substituted.  The error may
appear if components are not found, or are too long.  See
\&\*(L"\s-1PERLLIB_PREFIX\*(R"\s0 in perlos2.
.ie n .IP "Malformed prototype for %s: %s" 4
.el .IP "Malformed prototype for \f(CW%s:\fR \f(CW%s\fR" 4
.IX Item "Malformed prototype for %s: %s"
(F) You tried to use a function with a malformed prototype.  The
syntax of function prototypes is given a brief compile-time check for
obvious errors like invalid characters.  A more rigorous check is run
when the function is called.
Perhaps the function's author was trying to write a subroutine signature
but didn't enable that feature first (\f(CW\*(C`use feature \*(Aqsignatures\*(Aq\*(C'\fR),
so the signature was instead interpreted as a bad prototype.
.IP "Malformed \s-1UTF\-8\s0 character%s" 4
.IX Item "Malformed UTF-8 character%s"
(S utf8)(F) Perl detected a string that should be \s-1UTF\-8,\s0 but didn't
comply with \s-1UTF\-8\s0 encoding rules, or represents a code point whose
ordinal integer value doesn't fit into the word size of the current
platform (overflows).  Details as to the exact malformation are given in
the variable, \f(CW%s\fR, part of the message.
.Sp
One possible cause is that you set the \s-1UTF8\s0 flag yourself for data that
you thought to be in \s-1UTF\-8\s0 but it wasn't (it was for example legacy 8\-bit
data).  To guard against this, you can use \f(CW\*(C`Encode::decode(\*(AqUTF\-8\*(Aq, ...)\*(C'\fR.
.Sp
If you use the \f(CW\*(C`:encoding(UTF\-8)\*(C'\fR PerlIO layer for input, invalid byte
sequences are handled gracefully, but if you use \f(CW\*(C`:utf8\*(C'\fR, the flag is set
without validating the data, possibly resulting in this error message.
.Sp
See also \*(L"Handling Malformed Data\*(R" in Encode.
.IP "Malformed \s-1UTF\-8\s0 returned by \eN{%s} immediately after '%s'" 4
.IX Item "Malformed UTF-8 returned by N{%s} immediately after '%s'"
(F) The charnames handler returned malformed \s-1UTF\-8.\s0
.ie n .IP "Malformed \s-1UTF\-8\s0 string in ""%s""" 4
.el .IP "Malformed \s-1UTF\-8\s0 string in ``%s''" 4
.IX Item "Malformed UTF-8 string in %s"
(F) This message indicates a bug either in the Perl core or in \s-1XS\s0
code. Such code was trying to find out if a character, allegedly
stored internally encoded as \s-1UTF\-8,\s0 was of a given type, such as
being punctuation or a digit.  But the character was not encoded
in legal \s-1UTF\-8.\s0  The \f(CW%s\fR is replaced by a string that can be used
by knowledgeable people to determine what the type being checked
against was.
.Sp
Passing malformed strings was deprecated in Perl 5.18, and
became fatal in Perl 5.26.
.IP "Malformed \s-1UTF\-8\s0 string in '%c' format in unpack" 4
.IX Item "Malformed UTF-8 string in '%c' format in unpack"
(F) You tried to unpack something that didn't comply with \s-1UTF\-8\s0 encoding
rules and perl was unable to guess how to make more progress.
.IP "Malformed \s-1UTF\-8\s0 string in pack" 4
.IX Item "Malformed UTF-8 string in pack"
(F) You tried to pack something that didn't comply with \s-1UTF\-8\s0 encoding
rules and perl was unable to guess how to make more progress.
.IP "Malformed \s-1UTF\-8\s0 string in unpack" 4
.IX Item "Malformed UTF-8 string in unpack"
(F) You tried to unpack something that didn't comply with \s-1UTF\-8\s0 encoding
rules and perl was unable to guess how to make more progress.
.IP "Malformed \s-1UTF\-16\s0 surrogate" 4
.IX Item "Malformed UTF-16 surrogate"
(F) Perl thought it was reading \s-1UTF\-16\s0 encoded character data but while
doing it Perl met a malformed Unicode surrogate.
.IP "Mandatory parameter follows optional parameter" 4
.IX Item "Mandatory parameter follows optional parameter"
(F) In a subroutine signature, you wrote something like \*(L"$a = undef,
\&\f(CW$b\fR\*(R", making an earlier parameter optional and a later one mandatory.
Parameters are filled from left to right, so it's impossible for the
caller to omit an earlier one and pass a later one.  If you want to act
as if the parameters are filled from right to left, declare the rightmost
optional and then shuffle the parameters around in the subroutine's body.
.IP "Matched non-Unicode code point 0x%X against Unicode property; may not be portable" 4
.IX Item "Matched non-Unicode code point 0x%X against Unicode property; may not be portable"
(S non_unicode) Perl allows strings to contain a superset of
Unicode code points; each code point may be as large as what is storable
in a signed integer on your system, but these may not be accepted by
other languages/systems.  This message occurs when you matched a string
containing such a code point against a regular expression pattern, and
the code point was matched against a Unicode property, \f(CW\*(C`\ep{...}\*(C'\fR or
\&\f(CW\*(C`\eP{...}\*(C'\fR.  Unicode properties are only defined on Unicode code points,
so the result of this match is undefined by Unicode, but Perl (starting
in v5.20) treats non-Unicode code points as if they were typical
unassigned Unicode ones, and matched this one accordingly.  Whether a
given property matches these code points or not is specified in
\&\*(L"Properties accessible through \ep{} and \eP{}\*(R" in perluniprops.
.Sp
This message is suppressed (unless it has been made fatal) if it is
immaterial to the results of the match if the code point is Unicode or
not.  For example, the property \f(CW\*(C`\ep{ASCII_Hex_Digit}\*(C'\fR only can match
the 22 characters \f(CW\*(C`[0\-9A\-Fa\-f]\*(C'\fR, so obviously all other code points,
Unicode or not, won't match it.  (And \f(CW\*(C`\eP{ASCII_Hex_Digit}\*(C'\fR will match
every code point except these 22.)
.Sp
Getting this message indicates that the outcome of the match arguably
should have been the opposite of what actually happened.  If you think
that is the case, you may wish to make the \f(CW\*(C`non_unicode\*(C'\fR warnings
category fatal; if you agree with Perl's decision, you may wish to turn
off this category.
.Sp
See \*(L"Beyond Unicode code points\*(R" in perlunicode for more information.
.ie n .IP "%s matches null string many times in regex; marked by <\-\-\ \s-1HERE\s0 in m/%s/" 4
.el .IP "\f(CW%s\fR matches null string many times in regex; marked by <\-\-\ \s-1HERE\s0 in m/%s/" 4
.IX Item "%s matches null string many times in regex; marked by <--HERE in m/%s/"
(W regexp) The pattern you've specified would be an infinite loop if the
regular expression engine didn't specifically check for that.  The <\-\-\ \s-1HERE\s0
shows whereabouts in the regular expression the problem was discovered.
See perlre.
.IP "Maximal count of pending signals (%u) exceeded" 4
.IX Item "Maximal count of pending signals (%u) exceeded"
(F) Perl aborted due to too high a number of signals pending.  This
usually indicates that your operating system tried to deliver signals
too fast (with a very high priority), starving the perl process from
resources it would need to reach a point where it can process signals
safely.  (See \*(L"Deferred Signals (Safe Signals)\*(R" in perlipc.)
.ie n .IP """%s"" may clash with future reserved word" 4
.el .IP "``%s'' may clash with future reserved word" 4
.IX Item "%s may clash with future reserved word"
(W) This warning may be due to running a perl5 script through a perl4
interpreter, especially if the word that is being warned about is
\&\*(L"use\*(R" or \*(L"my\*(R".
.IP "'%' may not be used in pack" 4
.IX Item "'%' may not be used in pack"
(F) You can't pack a string by supplying a checksum, because the
checksumming process loses information, and you can't go the other way.
See \*(L"unpack\*(R" in perlfunc.
.ie n .IP "Method for operation %s not found in package %s during blessing" 4
.el .IP "Method for operation \f(CW%s\fR not found in package \f(CW%s\fR during blessing" 4
.IX Item "Method for operation %s not found in package %s during blessing"
(F) An attempt was made to specify an entry in an overloading table that
doesn't resolve to a valid subroutine.  See overload.
.ie n .IP "Method %s not permitted" 4
.el .IP "Method \f(CW%s\fR not permitted" 4
.IX Item "Method %s not permitted"
See \*(L"500 Server error\*(R".
.ie n .IP "Might be a runaway multi-line %s string starting on line %d" 4
.el .IP "Might be a runaway multi-line \f(CW%s\fR string starting on line \f(CW%d\fR" 4
.IX Item "Might be a runaway multi-line %s string starting on line %d"
(S) An advisory indicating that the previous error may have been caused
by a missing delimiter on a string or pattern, because it eventually
ended earlier on the current line.
.IP "Misplaced _ in number" 4
.IX Item "Misplaced _ in number"
(W syntax) An underscore (underbar) in a numeric constant did not
separate two digits.
.ie n .IP "Missing argument for %n in %s" 4
.el .IP "Missing argument for \f(CW%n\fR in \f(CW%s\fR" 4
.IX Item "Missing argument for %n in %s"
(F) A \f(CW%n\fR was used in a format string with no corresponding argument for
perl to write the current string length to.
.ie n .IP "Missing argument in %s" 4
.el .IP "Missing argument in \f(CW%s\fR" 4
.IX Item "Missing argument in %s"
(W missing) You called a function with fewer arguments than other
arguments you supplied indicated would be needed.
.Sp
Currently only emitted when a printf-type format required more
arguments than were supplied, but might be used in the future for
other cases where we can statically determine that arguments to
functions are missing, e.g. for the \*(L"pack\*(R" in perlfunc function.
.IP "Missing argument to \-%c" 4
.IX Item "Missing argument to -%c"
(F) The argument to the indicated command line switch must follow
immediately after the switch, without intervening spaces.
.IP "Missing braces on \eN{}" 4
.IX Item "Missing braces on N{}"
.PD 0
.IP "Missing braces on \eN{} in regex; marked by <\-\-\ \s-1HERE\s0 in m/%s/" 4
.IX Item "Missing braces on N{} in regex; marked by <--HERE in m/%s/"
.PD
(F) Wrong syntax of character name literal \f(CW\*(C`\eN{charname}\*(C'\fR within
double-quotish context.  This can also happen when there is a space
(or comment) between the \f(CW\*(C`\eN\*(C'\fR and the \f(CW\*(C`{\*(C'\fR in a regex with the \f(CW\*(C`/x\*(C'\fR modifier.
This modifier does not change the requirement that the brace immediately
follow the \f(CW\*(C`\eN\*(C'\fR.
.IP "Missing braces on \eo{}" 4
.IX Item "Missing braces on o{}"
(F) A \f(CW\*(C`\eo\*(C'\fR must be followed immediately by a \f(CW\*(C`{\*(C'\fR in double-quotish context.
.ie n .IP "Missing comma after first argument to %s function" 4
.el .IP "Missing comma after first argument to \f(CW%s\fR function" 4
.IX Item "Missing comma after first argument to %s function"
(F) While certain functions allow you to specify a filehandle or an
\&\*(L"indirect object\*(R" before the argument list, this ain't one of them.
.IP "Missing command in piped open" 4
.IX Item "Missing command in piped open"
(W pipe) You used the \f(CW\*(C`open(FH, "| command")\*(C'\fR or
\&\f(CW\*(C`open(FH, "command |")\*(C'\fR construction, but the command was missing or
blank.
.IP "Missing control char name in \ec" 4
.IX Item "Missing control char name in c"
(F) A double-quoted string ended with \*(L"\ec\*(R", without the required control
character name.
.ie n .IP "Missing ']' in prototype for %s : %s" 4
.el .IP "Missing ']' in prototype for \f(CW%s\fR : \f(CW%s\fR" 4
.IX Item "Missing ']' in prototype for %s : %s"
(W illegalproto) A grouping was started with \f(CW\*(C`[\*(C'\fR but never closed with \f(CW\*(C`]\*(C'\fR.
.ie n .IP "Missing name in ""%s sub""" 4
.el .IP "Missing name in ``%s sub''" 4
.IX Item "Missing name in %s sub"
(F) The syntax for lexically scoped subroutines requires that
they have a name with which they can be found.
.IP "Missing $ on loop variable" 4
.IX Item "Missing $ on loop variable"
(F) Apparently you've been programming in \fBcsh\fR too much.  Variables
are always mentioned with the $ in Perl, unlike in the shells, where it
can vary from one line to the next.
.ie n .IP "(Missing operator before %s?)" 4
.el .IP "(Missing operator before \f(CW%s\fR?)" 4
.IX Item "(Missing operator before %s?)"
(S syntax) This is an educated guess made in conjunction with the message
\&\*(L"%s found where operator expected\*(R".  Often the missing operator is a comma.
.ie n .IP "Missing or undefined argument to %s" 4
.el .IP "Missing or undefined argument to \f(CW%s\fR" 4
.IX Item "Missing or undefined argument to %s"
(F) You tried to call require or do with no argument or with an undefined
value as an argument.  Require expects either a package name or a
file-specification as an argument; do expects a filename.  See
\&\*(L"require \s-1EXPR\*(R"\s0 in perlfunc and \*(L"do \s-1EXPR\*(R"\s0 in perlfunc.
.IP "Missing right brace on \e%c{} in regex; marked by <\-\-\ \s-1HERE\s0 in m/%s/" 4
.IX Item "Missing right brace on %c{} in regex; marked by <--HERE in m/%s/"
(F) Missing right brace in \f(CW\*(C`\ex{...}\*(C'\fR, \f(CW\*(C`\ep{...}\*(C'\fR, \f(CW\*(C`\eP{...}\*(C'\fR, or \f(CW\*(C`\eN{...}\*(C'\fR.
.IP "Missing right brace on \eN{}" 4
.IX Item "Missing right brace on N{}"
.PD 0
.IP "Missing right brace on \eN{} or unescaped left brace after \eN" 4
.IX Item "Missing right brace on N{} or unescaped left brace after N"
.PD
(F) \f(CW\*(C`\eN\*(C'\fR has two meanings.
.Sp
The traditional one has it followed by a name enclosed in braces,
meaning the character (or sequence of characters) given by that
name.  Thus \f(CW\*(C`\eN{ASTERISK}\*(C'\fR is another way of writing \f(CW\*(C`*\*(C'\fR, valid in both
double-quoted strings and regular expression patterns.  In patterns,
it doesn't have the meaning an unescaped \f(CW\*(C`*\*(C'\fR does.
.Sp
Starting in Perl 5.12.0, \f(CW\*(C`\eN\*(C'\fR also can have an additional meaning (only)
in patterns, namely to match a non-newline character.  (This is short
for \f(CW\*(C`[^\en]\*(C'\fR, and like \f(CW\*(C`.\*(C'\fR but is not affected by the \f(CW\*(C`/s\*(C'\fR regex modifier.)
.Sp
This can lead to some ambiguities.  When \f(CW\*(C`\eN\*(C'\fR is not followed immediately
by a left brace, Perl assumes the \f(CW\*(C`[^\en]\*(C'\fR meaning.  Also, if the braces
form a valid quantifier such as \f(CW\*(C`\eN{3}\*(C'\fR or \f(CW\*(C`\eN{5,}\*(C'\fR, Perl assumes that this
means to match the given quantity of non-newlines (in these examples,
3; and 5 or more, respectively).  In all other case, where there is a
\&\f(CW\*(C`\eN{\*(C'\fR and a matching \f(CW\*(C`}\*(C'\fR, Perl assumes that a character name is desired.
.Sp
However, if there is no matching \f(CW\*(C`}\*(C'\fR, Perl doesn't know if it was
mistakenly omitted, or if \f(CW\*(C`[^\en]{\*(C'\fR was desired, and raises this error.
If you meant the former, add the right brace; if you meant the latter,
escape the brace with a backslash, like so: \f(CW\*(C`\eN\e{\*(C'\fR
.IP "Missing right curly or square bracket" 4
.IX Item "Missing right curly or square bracket"
(F) The lexer counted more opening curly or square brackets than closing
ones.  As a general rule, you'll find it's missing near the place you
were last editing.
.IP "(Missing semicolon on previous line?)" 4
.IX Item "(Missing semicolon on previous line?)"
(S syntax) This is an educated guess made in conjunction with the message
\&\*(L"%s found where operator expected\*(R".  Don't automatically put a semicolon on
the previous line just because you saw this message.
.IP "Modification of a read-only value attempted" 4
.IX Item "Modification of a read-only value attempted"
(F) You tried, directly or indirectly, to change the value of a
constant.  You didn't, of course, try \*(L"2 = 1\*(R", because the compiler
catches that.  But an easy way to do the same thing is:
.Sp
.Vb 2
\&    sub mod { $_[0] = 1 }
\&    mod(2);
.Ve
.Sp
Another way is to assign to a \fBsubstr()\fR that's off the end of the string.
.Sp
Yet another way is to assign to a \f(CW\*(C`foreach\*(C'\fR loop \fI\s-1VAR\s0\fR when \fI\s-1VAR\s0\fR
is aliased to a constant in the look \fI\s-1LIST\s0\fR:
.Sp
.Vb 4
\&    $x = 1;
\&    foreach my $n ($x, 2) {
\&        $n *= 2; # modifies the $x, but fails on attempt to
\&    }            # modify the 2
.Ve
.ie n .IP "Modification of non-creatable array value attempted, %s" 4
.el .IP "Modification of non-creatable array value attempted, \f(CW%s\fR" 4
.IX Item "Modification of non-creatable array value attempted, %s"
(F) You tried to make an array value spring into existence, and the
subscript was probably negative, even counting from end of the array
backwards.
.ie n .IP "Modification of non-creatable hash value attempted, %s" 4
.el .IP "Modification of non-creatable hash value attempted, \f(CW%s\fR" 4
.IX Item "Modification of non-creatable hash value attempted, %s"
(P) You tried to make a hash value spring into existence, and it
couldn't be created for some peculiar reason.
.IP "Module name must be constant" 4
.IX Item "Module name must be constant"
(F) Only a bare module name is allowed as the first argument to a \*(L"use\*(R".
.IP "Module name required with \-%c option" 4
.IX Item "Module name required with -%c option"
(F) The \f(CW\*(C`\-M\*(C'\fR or \f(CW\*(C`\-m\*(C'\fR options say that Perl should load some module, but
you omitted the name of the module.  Consult perlrun for full details
about \f(CW\*(C`\-M\*(C'\fR and \f(CW\*(C`\-m\*(C'\fR.
.IP "More than one argument to '%s' open" 4
.IX Item "More than one argument to '%s' open"
(F) The \f(CW\*(C`open\*(C'\fR function has been asked to open multiple files.  This
can happen if you are trying to open a pipe to a command that takes a
list of arguments, but have forgotten to specify a piped open mode.
See \*(L"open\*(R" in perlfunc for details.
.ie n .IP "mprotect for \s-1COW\s0 string %p %u failed with %d" 4
.el .IP "mprotect for \s-1COW\s0 string \f(CW%p\fR \f(CW%u\fR failed with \f(CW%d\fR" 4
.IX Item "mprotect for COW string %p %u failed with %d"
(S) You compiled perl with \fB\-D\fR\s-1PERL_DEBUG_READONLY_COW\s0 (see
\&\*(L"Copy on Write\*(R" in perlguts), but a shared string buffer
could not be made read-only.
.ie n .IP "mprotect for %p %u failed with %d" 4
.el .IP "mprotect for \f(CW%p\fR \f(CW%u\fR failed with \f(CW%d\fR" 4
.IX Item "mprotect for %p %u failed with %d"
(S) You compiled perl with \fB\-D\fR\s-1PERL_DEBUG_READONLY_OPS\s0 (see perlhacktips),
but an op tree could not be made read-only.
.ie n .IP "mprotect \s-1RW\s0 for \s-1COW\s0 string %p %u failed with %d" 4
.el .IP "mprotect \s-1RW\s0 for \s-1COW\s0 string \f(CW%p\fR \f(CW%u\fR failed with \f(CW%d\fR" 4
.IX Item "mprotect RW for COW string %p %u failed with %d"
(S) You compiled perl with \fB\-D\fR\s-1PERL_DEBUG_READONLY_COW\s0 (see
\&\*(L"Copy on Write\*(R" in perlguts), but a read-only shared string
buffer could not be made mutable.
.ie n .IP "mprotect \s-1RW\s0 for %p %u failed with %d" 4
.el .IP "mprotect \s-1RW\s0 for \f(CW%p\fR \f(CW%u\fR failed with \f(CW%d\fR" 4
.IX Item "mprotect RW for %p %u failed with %d"
(S) You compiled perl with \fB\-D\fR\s-1PERL_DEBUG_READONLY_OPS\s0 (see
perlhacktips), but a read-only op tree could not be made
mutable before freeing the ops.
.IP "msg%s not implemented" 4
.IX Item "msg%s not implemented"
(F) You don't have System V message \s-1IPC\s0 on your system.
.ie n .IP "Multidimensional syntax %s not supported" 4
.el .IP "Multidimensional syntax \f(CW%s\fR not supported" 4
.IX Item "Multidimensional syntax %s not supported"
(W syntax) Multidimensional arrays aren't written like \f(CW$foo[1,2,3]\fR.
They're written like \f(CW$foo[1][2][3]\fR, as in C.
.IP "Multiple slurpy parameters not allowed" 4
.IX Item "Multiple slurpy parameters not allowed"
(F) In subroutine signatures, a slurpy parameter (\f(CW\*(C`@\*(C'\fR or \f(CW\*(C`%\*(C'\fR) must be
the last parameter, and there must not be more than one of them; for
example:
.Sp
.Vb 2
\&    sub foo ($a, @b)    {} # legal
\&    sub foo ($a, @b, %) {} # invalid
.Ve
.IP "'/' must follow a numeric type in unpack" 4
.IX Item "'/' must follow a numeric type in unpack"
(F) You had an unpack template that contained a '/', but this did not
follow some unpack specification producing a numeric value.
See \*(L"pack\*(R" in perlfunc.
.ie n .IP "%s must not be a named sequence in transliteration operator" 4
.el .IP "\f(CW%s\fR must not be a named sequence in transliteration operator" 4
.IX Item "%s must not be a named sequence in transliteration operator"
(F) Transliteration (\f(CW\*(C`tr///\*(C'\fR and \f(CW\*(C`y///\*(C'\fR) transliterates individual
characters.  But a named sequence by definition is more than an
individual character, and hence doing this operation on it doesn't make
sense.
.ie n .IP """my sub"" not yet implemented" 4
.el .IP "``my sub'' not yet implemented" 4
.IX Item "my sub not yet implemented"
(F) Lexically scoped subroutines are not yet implemented.  Don't try
that yet.
.ie n .IP """my"" subroutine %s can't be in a package" 4
.el .IP "``my'' subroutine \f(CW%s\fR can't be in a package" 4
.IX Item "my subroutine %s can't be in a package"
(F) Lexically scoped subroutines aren't in a package, so it doesn't make
sense to try to declare one with a package qualifier on the front.
.ie n .IP """my %s"" used in sort comparison" 4
.el .IP "``my \f(CW%s\fR'' used in sort comparison" 4
.IX Item "my %s used in sort comparison"
(W syntax) The package variables \f(CW$a\fR and \f(CW$b\fR are used for sort comparisons.
You used \f(CW$a\fR or \f(CW$b\fR in as an operand to the \f(CW\*(C`<=>\*(C'\fR or \f(CW\*(C`cmp\*(C'\fR operator inside a
sort comparison block, and the variable had earlier been declared as a
lexical variable.  Either qualify the sort variable with the package
name, or rename the lexical variable.
.ie n .IP """my"" variable %s can't be in a package" 4
.el .IP "``my'' variable \f(CW%s\fR can't be in a package" 4
.IX Item "my variable %s can't be in a package"
(F) Lexically scoped variables aren't in a package, so it doesn't make
sense to try to declare one with a package qualifier on the front.  Use
\&\fBlocal()\fR if you want to localize a package variable.
.ie n .IP "Name ""%s::%s"" used only once: possible typo" 4
.el .IP "Name ``%s::%s'' used only once: possible typo" 4
.IX Item "Name %s::%s used only once: possible typo"
(W once) Typographical errors often show up as unique variable
names.  If you had a good reason for having a unique name, then
just mention it again somehow to suppress the message.  The \f(CW\*(C`our\*(C'\fR
declaration is also provided for this purpose.
.Sp
\&\s-1NOTE:\s0 This warning detects package symbols that have been used
only once.  This means lexical variables will never trigger this
warning.  It also means that all of the package variables \f(CW$c\fR, \f(CW@c\fR,
\&\f(CW%c\fR, as well as *c, &c, sub c{}, c(), and c (the filehandle or
format) are considered the same; if a program uses \f(CW$c\fR only once
but also uses any of the others it will not trigger this warning.
Symbols beginning with an underscore and symbols using special
identifiers (q.v. perldata) are exempt from this warning.
.IP "Need exactly 3 octal digits in regex; marked by <\-\-\ \s-1HERE\s0 in m/%s/" 4
.IX Item "Need exactly 3 octal digits in regex; marked by <--HERE in m/%s/"
(F) Within \f(CW\*(C`(?[\ \ \ ])\*(C'\fR, all constants interpreted as octal need to be
exactly 3 digits long.  This helps catch some ambiguities.  If your
constant is too short, add leading zeros, like
.Sp
.Vb 3
\& (?[ [ \e078 ] ])     # Syntax error!
\& (?[ [ \e0078 ] ])    # Works
\& (?[ [ \e007 8 ] ])   # Clearer
.Ve
.Sp
The maximum number this construct can express is \f(CW\*(C`\e777\*(C'\fR.  If you
need a larger one, you need to use \eo{} instead.  If you meant
two separate things, you need to separate them:
.Sp
.Vb 4
\& (?[ [ \e7776 ] ])        # Syntax error!
\& (?[ [ \eo{7776} ] ])     # One meaning
\& (?[ [ \e777 6 ] ])       # Another meaning
\& (?[ [ \e777 \e006 ] ])    # Still another
.Ve
.IP "Negative '/' count in unpack" 4
.IX Item "Negative '/' count in unpack"
(F) The length count obtained from a length/code unpack operation was
negative.  See \*(L"pack\*(R" in perlfunc.
.IP "Negative length" 4
.IX Item "Negative length"
(F) You tried to do a read/write/send/recv operation with a buffer
length that is less than 0.  This is difficult to imagine.
.IP "Negative offset to vec in lvalue context" 4
.IX Item "Negative offset to vec in lvalue context"
(F) When \f(CW\*(C`vec\*(C'\fR is called in an lvalue context, the second argument must be
greater than or equal to zero.
.IP "Negative repeat count does nothing" 4
.IX Item "Negative repeat count does nothing"
(W numeric) You tried to execute the
\&\f(CW\*(C`x\*(C'\fR repetition operator fewer than 0
times, which doesn't make sense.
.IP "Nested quantifiers in regex; marked by <\-\-\ \s-1HERE\s0 in m/%s/" 4
.IX Item "Nested quantifiers in regex; marked by <--HERE in m/%s/"
(F) You can't quantify a quantifier without intervening parentheses.
So things like ** or +* or ?* are illegal.  The <\-\-\ \s-1HERE\s0 shows
whereabouts in the regular expression the problem was discovered.
.Sp
Note that the minimal matching quantifiers, \f(CW\*(C`*?\*(C'\fR, \f(CW\*(C`+?\*(C'\fR, and
\&\f(CW\*(C`??\*(C'\fR appear to be nested quantifiers, but aren't.  See perlre.
.ie n .IP "%s never introduced" 4
.el .IP "\f(CW%s\fR never introduced" 4
.IX Item "%s never introduced"
(S internal) The symbol in question was declared but somehow went out of
scope before it could possibly have been used.
.IP "next::method/next::can/maybe::next::method cannot find enclosing method" 4
.IX Item "next::method/next::can/maybe::next::method cannot find enclosing method"
(F) \f(CW\*(C`next::method\*(C'\fR needs to be called within the context of a
real method in a real package, and it could not find such a context.
See mro.
.IP "\eN in a character class must be a named character: \eN{...} in regex; marked by <\-\-\ \s-1HERE\s0 in m/%s/" 4
.IX Item "N in a character class must be a named character: N{...} in regex; marked by <--HERE in m/%s/"
(F) The new (as of Perl 5.12) meaning of \f(CW\*(C`\eN\*(C'\fR as \f(CW\*(C`[^\en]\*(C'\fR is not valid in a
bracketed character class, for the same reason that \f(CW\*(C`.\*(C'\fR in a character
class loses its specialness: it matches almost everything, which is
probably not what you want.
.IP "\eN{} in inverted character class or as a range end-point is restricted to one character in regex; marked by <\-\- \s-1HERE\s0 in m/%s/" 4
.IX Item "N{} in inverted character class or as a range end-point is restricted to one character in regex; marked by <-- HERE in m/%s/"
(F) Named Unicode character escapes (\f(CW\*(C`\eN{...}\*(C'\fR) may return a
multi-character sequence.  Even though a character class is
supposed to match just one character of input, perl will match the
whole thing correctly, except under certain conditions.  These currently
are
.RS 4
.ie n .IP "When the class is inverted (""[^...]"")" 4
.el .IP "When the class is inverted (\f(CW[^...]\fR)" 4
.IX Item "When the class is inverted ([^...])"
The mathematically logical behavior for what matches when inverting
is very different from what people expect, so we have decided to
forbid it.
.IP "The escape is the beginning or final end point of a range" 4
.IX Item "The escape is the beginning or final end point of a range"
Similarly unclear is what should be generated when the
\&\f(CW\*(C`\eN{...}\*(C'\fR is used as one of the end points of the range, such as in
.Sp
.Vb 1
\& [\ex{41}\-\eN{ARABIC SEQUENCE YEH WITH HAMZA ABOVE WITH AE}]
.Ve
.Sp
What is meant here is unclear, as the \f(CW\*(C`\eN{...}\*(C'\fR escape is a sequence
of code points, so this is made an error.
.IP "In a regex set" 4
.IX Item "In a regex set"
The syntax \f(CW\*(C`(?[\ \ \ ])\*(C'\fR in a regular expression yields a list of
single code points, none can be a sequence.
.RE
.RS 4
.RE
.ie n .IP "No %s allowed while running setuid" 4
.el .IP "No \f(CW%s\fR allowed while running setuid" 4
.IX Item "No %s allowed while running setuid"
(F) Certain operations are deemed to be too insecure for a setuid or
setgid script to even be allowed to attempt.  Generally speaking there
will be another way to do what you want that is, if not secure, at least
securable.  See perlsec.
.IP "No code specified for \-%c" 4
.IX Item "No code specified for -%c"
(F) Perl's \fB\-e\fR and \fB\-E\fR command-line options require an argument.  If
you want to run an empty program, pass the empty string as a separate
argument or run a program consisting of a single 0 or 1:
.Sp
.Vb 3
\&    perl \-e ""
\&    perl \-e0
\&    perl \-e1
.Ve
.ie n .IP "No comma allowed after %s" 4
.el .IP "No comma allowed after \f(CW%s\fR" 4
.IX Item "No comma allowed after %s"
(F) A list operator that has a filehandle or \*(L"indirect object\*(R" is
not allowed to have a comma between that and the following arguments.
Otherwise it'd be just another one of the arguments.
.Sp
One possible cause for this is that you expected to have imported
a constant to your name space with \fBuse\fR or \fBimport\fR while no such
importing took place, it may for example be that your operating
system does not support that particular constant.  Hopefully you did
use an explicit import list for the constants you expect to see;
please see \*(L"use\*(R" in perlfunc and \*(L"import\*(R" in perlfunc.  While an
explicit import list would probably have caught this error earlier
it naturally does not remedy the fact that your operating system
still does not support that constant.  Maybe you have a typo in
the constants of the symbol import list of \fBuse\fR or \fBimport\fR or in the
constant name at the line where this error was triggered?
.IP "No command into which to pipe on command line" 4
.IX Item "No command into which to pipe on command line"
(F) An error peculiar to \s-1VMS.\s0  Perl handles its own command line
redirection, and found a '|' at the end of the command line, so it
doesn't know where you want to pipe the output from this command.
.IP "No \s-1DB::DB\s0 routine defined" 4
.IX Item "No DB::DB routine defined"
(F) The currently executing code was compiled with the \fB\-d\fR switch, but
for some reason the current debugger (e.g. \fIperl5db.pl\fR or a \f(CW\*(C`Devel::\*(C'\fR
module) didn't define a routine to be called at the beginning of each
statement.
.IP "No dbm on this machine" 4
.IX Item "No dbm on this machine"
(P) This is counted as an internal error, because every machine should
supply dbm nowadays, because Perl comes with \s-1SDBM.\s0  See SDBM_File.
.IP "No DB::sub routine defined" 4
.IX Item "No DB::sub routine defined"
(F) The currently executing code was compiled with the \fB\-d\fR switch, but
for some reason the current debugger (e.g. \fIperl5db.pl\fR or a \f(CW\*(C`Devel::\*(C'\fR
module) didn't define a \f(CW\*(C`DB::sub\*(C'\fR routine to be called at the beginning
of each ordinary subroutine call.
.IP "No directory specified for \-I" 4
.IX Item "No directory specified for -I"
(F) The \fB\-I\fR command-line switch requires a directory name as part of the
\&\fIsame\fR argument.  Use \fB\-Ilib\fR, for instance.  \fB\-I lib\fR won't work.
.IP "No error file after 2> or 2>> on command line" 4
.IX Item "No error file after 2> or 2>> on command line"
(F) An error peculiar to \s-1VMS.\s0  Perl handles its own command line
redirection, and found a '2>' or a '2>>' on the command line, but can't
find the name of the file to which to write data destined for stderr.
.IP "No group ending character '%c' found in template" 4
.IX Item "No group ending character '%c' found in template"
(F) A pack or unpack template has an opening '(' or '[' without its
matching counterpart.  See \*(L"pack\*(R" in perlfunc.
.IP "No input file after < on command line" 4
.IX Item "No input file after < on command line"
(F) An error peculiar to \s-1VMS.\s0  Perl handles its own command line
redirection, and found a '<' on the command line, but can't find the
name of the file from which to read data for stdin.
.ie n .IP "No next::method '%s' found for %s" 4
.el .IP "No next::method '%s' found for \f(CW%s\fR" 4
.IX Item "No next::method '%s' found for %s"
(F) \f(CW\*(C`next::method\*(C'\fR found no further instances of this method name
in the remaining packages of the \s-1MRO\s0 of this class.  If you don't want
it throwing an exception, use \f(CW\*(C`maybe::next::method\*(C'\fR
or \f(CW\*(C`next::can\*(C'\fR.  See mro.
.IP "Non-finite repeat count does nothing" 4
.IX Item "Non-finite repeat count does nothing"
(W numeric) You tried to execute the
\&\f(CW\*(C`x\*(C'\fR repetition operator \f(CW\*(C`Inf\*(C'\fR (or
\&\f(CW\*(C`\-Inf\*(C'\fR) or \f(CW\*(C`NaN\*(C'\fR times, which doesn't make sense.
.IP "Non-hex character in regex; marked by <\-\-\ \s-1HERE\s0 in m/%s/" 4
.IX Item "Non-hex character in regex; marked by <--HERE in m/%s/"
(F) In a regular expression, there was a non-hexadecimal character where
a hex one was expected, like
.Sp
.Vb 2
\& (?[ [ \exDG ] ])
\& (?[ [ \ex{DEKA} ] ])
.Ve
.IP "Non-octal character in regex; marked by <\-\-\ \s-1HERE\s0 in m/%s/" 4
.IX Item "Non-octal character in regex; marked by <--HERE in m/%s/"
(F) In a regular expression, there was a non-octal character where
an octal one was expected, like
.Sp
.Vb 1
\& (?[ [ \eo{1278} ] ])
.Ve
.ie n .IP "Non-octal character '%c'.  Resolved as ""%s""" 4
.el .IP "Non-octal character '%c'.  Resolved as ``%s''" 4
.IX Item "Non-octal character '%c'. Resolved as %s"
(W digit) In parsing an octal numeric constant, a character was
unexpectedly encountered that isn't octal.  The resulting value
is as indicated.
.ie n .IP """no"" not allowed in expression" 4
.el .IP "``no'' not allowed in expression" 4
.IX Item "no not allowed in expression"
(F) The \*(L"no\*(R" keyword is recognized and executed at compile time, and
returns no useful value.  See perlmod.
.IP "Non-string passed as bitmask" 4
.IX Item "Non-string passed as bitmask"
(W misc) A number has been passed as a bitmask argument to \fBselect()\fR.
Use the \fBvec()\fR function to construct the file descriptor bitmasks for
select.  See \*(L"select\*(R" in perlfunc.
.IP "No output file after > on command line" 4
.IX Item "No output file after > on command line"
(F) An error peculiar to \s-1VMS.\s0  Perl handles its own command line
redirection, and found a lone '>' at the end of the command line, so it
doesn't know where you wanted to redirect stdout.
.IP "No output file after > or >> on command line" 4
.IX Item "No output file after > or >> on command line"
(F) An error peculiar to \s-1VMS.\s0  Perl handles its own command line
redirection, and found a '>' or a '>>' on the command line, but can't
find the name of the file to which to write data destined for stdout.
.ie n .IP "No package name allowed for subroutine %s in ""our""" 4
.el .IP "No package name allowed for subroutine \f(CW%s\fR in ``our''" 4
.IX Item "No package name allowed for subroutine %s in our"
.PD 0
.ie n .IP "No package name allowed for variable %s in ""our""" 4
.el .IP "No package name allowed for variable \f(CW%s\fR in ``our''" 4
.IX Item "No package name allowed for variable %s in our"
.PD
(F) Fully qualified subroutine and variable names are not allowed in \*(L"our\*(R"
declarations, because that doesn't make much sense under existing rules.
Such syntax is reserved for future extensions.
.IP "No Perl script found in input" 4
.IX Item "No Perl script found in input"
(F) You called \f(CW\*(C`perl \-x\*(C'\fR, but no line was found in the file beginning
with #! and containing the word \*(L"perl\*(R".
.IP "No setregid available" 4
.IX Item "No setregid available"
(F) Configure didn't find anything resembling the \fBsetregid()\fR call for
your system.
.IP "No setreuid available" 4
.IX Item "No setreuid available"
(F) Configure didn't find anything resembling the \fBsetreuid()\fR call for
your system.
.ie n .IP "No such class %s" 4
.el .IP "No such class \f(CW%s\fR" 4
.IX Item "No such class %s"
(F) You provided a class qualifier in a \*(L"my\*(R", \*(L"our\*(R" or \*(L"state\*(R"
declaration, but this class doesn't exist at this point in your program.
.ie n .IP "No such class field ""%s"" in variable %s of type %s" 4
.el .IP "No such class field ``%s'' in variable \f(CW%s\fR of type \f(CW%s\fR" 4
.IX Item "No such class field %s in variable %s of type %s"
(F) You tried to access a key from a hash through the indicated typed
variable but that key is not allowed by the package of the same type.
The indicated package has restricted the set of allowed keys using the
fields pragma.
.ie n .IP "No such hook: %s" 4
.el .IP "No such hook: \f(CW%s\fR" 4
.IX Item "No such hook: %s"
(F) You specified a signal hook that was not recognized by Perl.
Currently, Perl accepts \f(CW\*(C`_\|_DIE_\|_\*(C'\fR and \f(CW\*(C`_\|_WARN_\|_\*(C'\fR as valid signal hooks.
.IP "No such pipe open" 4
.IX Item "No such pipe open"
(P) An error peculiar to \s-1VMS.\s0  The internal routine \fBmy_pclose()\fR tried to
close a pipe which hadn't been opened.  This should have been caught
earlier as an attempt to close an unopened filehandle.
.IP "No such signal: SIG%s" 4
.IX Item "No such signal: SIG%s"
(W signal) You specified a signal name as a subscript to \f(CW%SIG\fR that was
not recognized.  Say \f(CW\*(C`kill \-l\*(C'\fR in your shell to see the valid signal
names on your system.
.IP "No Unicode property value wildcard matches:" 4
.IX Item "No Unicode property value wildcard matches:"
(W regexp) You specified a wildcard for a Unicode property value, but
there is no property value in the current Unicode release that matches
it.  Check your spelling.
.IP "Not a \s-1CODE\s0 reference" 4
.IX Item "Not a CODE reference"
(F) Perl was trying to evaluate a reference to a code value (that is, a
subroutine), but found a reference to something else instead.  You can
use the \fBref()\fR function to find out what kind of ref it really was.  See
also perlref.
.IP "Not a \s-1GLOB\s0 reference" 4
.IX Item "Not a GLOB reference"
(F) Perl was trying to evaluate a reference to a \*(L"typeglob\*(R" (that is, a
symbol table entry that looks like \f(CW*foo\fR), but found a reference to
something else instead.  You can use the \fBref()\fR function to find out what
kind of ref it really was.  See perlref.
.IP "Not a \s-1HASH\s0 reference" 4
.IX Item "Not a HASH reference"
(F) Perl was trying to evaluate a reference to a hash value, but found a
reference to something else instead.  You can use the \fBref()\fR function to
find out what kind of ref it really was.  See perlref.
.IP "'#' not allowed immediately following a sigil in a subroutine signature" 4
.IX Item "'#' not allowed immediately following a sigil in a subroutine signature"
(F) In a subroutine signature definition, a comment following a sigil
(\f(CW\*(C`$\*(C'\fR, \f(CW\*(C`@\*(C'\fR or \f(CW\*(C`%\*(C'\fR), needs to be separated by whitespace or a comma etc., in
particular to avoid confusion with the \f(CW$#\fR variable.  For example:
.Sp
.Vb 6
\&    # bad
\&    sub f ($# ignore first arg
\&           , $b) {}
\&    # good
\&    sub f ($, # ignore first arg
\&           $b) {}
.Ve
.IP "Not an \s-1ARRAY\s0 reference" 4
.IX Item "Not an ARRAY reference"
(F) Perl was trying to evaluate a reference to an array value, but found
a reference to something else instead.  You can use the \fBref()\fR function
to find out what kind of ref it really was.  See perlref.
.IP "Not a \s-1SCALAR\s0 reference" 4
.IX Item "Not a SCALAR reference"
(F) Perl was trying to evaluate a reference to a scalar value, but found
a reference to something else instead.  You can use the \fBref()\fR function
to find out what kind of ref it really was.  See perlref.
.IP "Not a subroutine reference" 4
.IX Item "Not a subroutine reference"
(F) Perl was trying to evaluate a reference to a code value (that is, a
subroutine), but found a reference to something else instead.  You can
use the \fBref()\fR function to find out what kind of ref it really was.  See
also perlref.
.IP "Not a subroutine reference in overload table" 4
.IX Item "Not a subroutine reference in overload table"
(F) An attempt was made to specify an entry in an overloading table that
doesn't somehow point to a valid subroutine.  See overload.
.ie n .IP "Not enough arguments for %s" 4
.el .IP "Not enough arguments for \f(CW%s\fR" 4
.IX Item "Not enough arguments for %s"
(F) The function requires more arguments than you specified.
.IP "Not enough format arguments" 4
.IX Item "Not enough format arguments"
(W syntax) A format specified more picture fields than the next line
supplied.  See perlform.
.ie n .IP "%s: not found" 4
.el .IP "\f(CW%s:\fR not found" 4
.IX Item "%s: not found"
(A) You've accidentally run your script through the Bourne shell instead
of Perl.  Check the #! line, or manually feed your script into Perl
yourself.
.IP "no \s-1UTC\s0 offset information; assuming local time is \s-1UTC\s0" 4
.IX Item "no UTC offset information; assuming local time is UTC"
(S) A warning peculiar to \s-1VMS.\s0  Perl was unable to find the local
timezone offset, so it's assuming that local system time is equivalent
to \s-1UTC.\s0  If it's not, define the logical name
\&\fI\s-1SYS$TIMEZONE_DIFFERENTIAL\s0\fR to translate to the number of seconds which
need to be added to \s-1UTC\s0 to get local time.
.IP "\s-1NULL OP IN RUN\s0" 4
.IX Item "NULL OP IN RUN"
(S debugging) Some internal routine called \fBrun()\fR with a null opcode
pointer.
.IP "Null picture in formline" 4
.IX Item "Null picture in formline"
(F) The first argument to formline must be a valid format picture
specification.  It was found to be empty, which probably means you
supplied it an uninitialized value.  See perlform.
.IP "Null realloc" 4
.IX Item "Null realloc"
(P) An attempt was made to realloc \s-1NULL.\s0
.IP "\s-1NULL\s0 regexp argument" 4
.IX Item "NULL regexp argument"
(P) The internal pattern matching routines blew it big time.
.IP "\s-1NULL\s0 regexp parameter" 4
.IX Item "NULL regexp parameter"
(P) The internal pattern matching routines are out of their gourd.
.IP "Number too long" 4
.IX Item "Number too long"
(F) Perl limits the representation of decimal numbers in programs to
about 250 characters.  You've exceeded that length.  Future
versions of Perl are likely to eliminate this arbitrary limitation.  In
the meantime, try using scientific notation (e.g. \*(L"1e6\*(R" instead of
\&\*(L"1_000_000\*(R").
.IP "Number with no digits" 4
.IX Item "Number with no digits"
(F) Perl was looking for a number but found nothing that looked like
a number.  This happens, for example with \f(CW\*(C`\eo{}\*(C'\fR, with no number between
the braces.
.IP "Octal number > 037777777777 non-portable" 4
.IX Item "Octal number > 037777777777 non-portable"
(W portable) The octal number you specified is larger than 2**32\-1
(4294967295) and therefore non-portable between systems.  See
perlport for more on portability concerns.
.IP "Odd name/value argument for subroutine '%s'" 4
.IX Item "Odd name/value argument for subroutine '%s'"
(F) A subroutine using a slurpy hash parameter in its signature
received an odd number of arguments to populate the hash.  It requires
the arguments to be paired, with the same number of keys as values.
The caller of the subroutine is presumably at fault.
.Sp
The message attempts to include the name of the called subroutine. If the
subroutine has been aliased, the subroutine's original name will be shown,
regardless of what name the caller used.
.IP "Odd number of arguments for overload::constant" 4
.IX Item "Odd number of arguments for overload::constant"
(W overload) The call to overload::constant contained an odd number of
arguments.  The arguments should come in pairs.
.IP "Odd number of elements in anonymous hash" 4
.IX Item "Odd number of elements in anonymous hash"
(W misc) You specified an odd number of elements to initialize a hash,
which is odd, because hashes come in key/value pairs.
.IP "Odd number of elements in hash assignment" 4
.IX Item "Odd number of elements in hash assignment"
(W misc) You specified an odd number of elements to initialize a hash,
which is odd, because hashes come in key/value pairs.
.IP "Offset outside string" 4
.IX Item "Offset outside string"
(F)(W layer) You tried to do a read/write/send/recv/seek operation
with an offset pointing outside the buffer.  This is difficult to
imagine.  The sole exceptions to this are that zero padding will
take place when going past the end of the string when either
\&\f(CW\*(C`sysread()\*(C'\fRing a file, or when seeking past the end of a scalar opened
for I/O (in anticipation of future reads and to imitate the behavior
with real files).
.IP "Old package separator used in string" 4
.IX Item "Old package separator used in string"
(W syntax) You used the old package separator, \*(L"'\*(R", in a variable
named inside a double-quoted string; e.g., \f(CW"In $name\*(Aqs house"\fR.  This
is equivalent to \f(CW"In $name::s house"\fR.  If you meant the former, put
a backslash before the apostrophe (\f(CW"In $name\e\*(Aqs house"\fR).
.ie n .IP "%s() on unopened %s" 4
.el .IP "%s() on unopened \f(CW%s\fR" 4
.IX Item "%s() on unopened %s"
(W unopened) An I/O operation was attempted on a filehandle that was
never initialized.  You need to do an \fBopen()\fR, a \fBsysopen()\fR, or a \fBsocket()\fR
call, or call a constructor from the FileHandle package.
.ie n .IP "\-%s on unopened filehandle %s" 4
.el .IP "\-%s on unopened filehandle \f(CW%s\fR" 4
.IX Item "-%s on unopened filehandle %s"
(W unopened) You tried to invoke a file test operator on a filehandle
that isn't open.  Check your control flow.  See also \*(L"\-X\*(R" in perlfunc.
.IP "oops: oopsAV" 4
.IX Item "oops: oopsAV"
(S internal) An internal warning that the grammar is screwed up.
.IP "oops: oopsHV" 4
.IX Item "oops: oopsHV"
(S internal) An internal warning that the grammar is screwed up.
.IP "Operand with no preceding operator in regex; marked by <\-\-\ \s-1HERE\s0 in m/%s/" 4
.IX Item "Operand with no preceding operator in regex; marked by <--HERE in m/%s/"
(F) You wrote something like
.Sp
.Vb 1
\& (?[ \ep{Digit} \ep{Thai} ])
.Ve
.Sp
There are two operands, but no operator giving how you want to combine
them.
.ie n .IP "Operation ""%s"": no method found, %s" 4
.el .IP "Operation ``%s'': no method found, \f(CW%s\fR" 4
.IX Item "Operation %s: no method found, %s"
(F) An attempt was made to perform an overloaded operation for which no
handler was defined.  While some handlers can be autogenerated in terms
of other handlers, there is no default handler for any operation, unless
the \f(CW\*(C`fallback\*(C'\fR overloading key is specified to be true.  See overload.
.ie n .IP "Operation ""%s"" returns its argument for non-Unicode code point 0x%X" 4
.el .IP "Operation ``%s'' returns its argument for non-Unicode code point 0x%X" 4
.IX Item "Operation %s returns its argument for non-Unicode code point 0x%X"
(S non_unicode) You performed an operation requiring Unicode rules
on a code point that is not in Unicode, so what it should do is not
defined.  Perl has chosen to have it do nothing, and warn you.
.Sp
If the operation shown is \*(L"ToFold\*(R", it means that case-insensitive
matching in a regular expression was done on the code point.
.Sp
If you know what you are doing you can turn off this warning by
\&\f(CW\*(C`no warnings \*(Aqnon_unicode\*(Aq;\*(C'\fR.
.ie n .IP "Operation ""%s"" returns its argument for \s-1UTF\-16\s0 surrogate U+%X" 4
.el .IP "Operation ``%s'' returns its argument for \s-1UTF\-16\s0 surrogate U+%X" 4
.IX Item "Operation %s returns its argument for UTF-16 surrogate U+%X"
(S surrogate) You performed an operation requiring Unicode
rules on a Unicode surrogate.  Unicode frowns upon the use
of surrogates for anything but storing strings in \s-1UTF\-16,\s0 but
rules are (reluctantly) defined for the surrogates, and
they are to do nothing for this operation.  Because the use of
surrogates can be dangerous, Perl warns.
.Sp
If the operation shown is \*(L"ToFold\*(R", it means that case-insensitive
matching in a regular expression was done on the code point.
.Sp
If you know what you are doing you can turn off this warning by
\&\f(CW\*(C`no warnings \*(Aqsurrogate\*(Aq;\*(C'\fR.
.ie n .IP "Operator or semicolon missing before %s" 4
.el .IP "Operator or semicolon missing before \f(CW%s\fR" 4
.IX Item "Operator or semicolon missing before %s"
(S ambiguous) You used a variable or subroutine call where the parser
was expecting an operator.  The parser has assumed you really meant to
use an operator, but this is highly likely to be incorrect.  For
example, if you say \*(L"*foo *foo\*(R" it will be interpreted as if you said
\&\*(L"*foo * 'foo'\*(R".
.IP "Optional parameter lacks default expression" 4
.IX Item "Optional parameter lacks default expression"
(F) In a subroutine signature, you wrote something like \*(L"$a =\*(R", making a
named optional parameter without a default value.  A nameless optional
parameter is permitted to have no default value, but a named one must
have a specific default.  You probably want \*(L"$a = undef\*(R".
.ie n .IP """our"" variable %s redeclared" 4
.el .IP "``our'' variable \f(CW%s\fR redeclared" 4
.IX Item "our variable %s redeclared"
(W shadow) You seem to have already declared the same global once before
in the current lexical scope.
.IP "Out of memory!" 4
.IX Item "Out of memory!"
(X) The \fBmalloc()\fR function returned 0, indicating there was insufficient
remaining memory (or virtual memory) to satisfy the request.  Perl has
no option but to exit immediately.
.Sp
At least in Unix you may be able to get past this by increasing your
process datasize limits: in csh/tcsh use \f(CW\*(C`limit\*(C'\fR and
\&\f(CW\*(C`limit datasize n\*(C'\fR (where \f(CW\*(C`n\*(C'\fR is the number of kilobytes) to check
the current limits and change them, and in ksh/bash/zsh use \f(CW\*(C`ulimit \-a\*(C'\fR
and \f(CW\*(C`ulimit \-d n\*(C'\fR, respectively.
.ie n .IP "Out of memory during %s extend" 4
.el .IP "Out of memory during \f(CW%s\fR extend" 4
.IX Item "Out of memory during %s extend"
(X) An attempt was made to extend an array, a list, or a string beyond
the largest possible memory allocation.
.ie n .IP "Out of memory during ""large"" request for %s" 4
.el .IP "Out of memory during ``large'' request for \f(CW%s\fR" 4
.IX Item "Out of memory during large request for %s"
(F) The \fBmalloc()\fR function returned 0, indicating there was insufficient
remaining memory (or virtual memory) to satisfy the request.  However,
the request was judged large enough (compile-time default is 64K), so a
possibility to shut down by trapping this error is granted.
.ie n .IP "Out of memory during request for %s" 4
.el .IP "Out of memory during request for \f(CW%s\fR" 4
.IX Item "Out of memory during request for %s"
(X)(F) The \fBmalloc()\fR function returned 0, indicating there was
insufficient remaining memory (or virtual memory) to satisfy the
request.
.Sp
The request was judged to be small, so the possibility to trap it
depends on the way perl was compiled.  By default it is not trappable.
However, if compiled for this, Perl may use the contents of \f(CW$^M\fR as an
emergency pool after \fBdie()\fRing with this message.  In this case the error
is trappable \fIonce\fR, and the error message will include the line and file
where the failed request happened.
.IP "Out of memory during ridiculously large request" 4
.IX Item "Out of memory during ridiculously large request"
(F) You can't allocate more than 2^31+\*(L"small amount\*(R" bytes.  This error
is most likely to be caused by a typo in the Perl program. e.g.,
\&\f(CW$arr[time]\fR instead of \f(CW$arr[$time]\fR.
.IP "Out of memory for yacc stack" 4
.IX Item "Out of memory for yacc stack"
(F) The yacc parser wanted to grow its stack so it could continue
parsing, but \fBrealloc()\fR wouldn't give it more memory, virtual or
otherwise.
.IP "'.' outside of string in pack" 4
.IX Item "'.' outside of string in pack"
(F) The argument to a '.' in your template tried to move the working
position to before the start of the packed string being built.
.IP "'@' outside of string in unpack" 4
.IX Item "'@' outside of string in unpack"
(F) You had a template that specified an absolute position outside
the string being unpacked.  See \*(L"pack\*(R" in perlfunc.
.IP "'@' outside of string with malformed \s-1UTF\-8\s0 in unpack" 4
.IX Item "'@' outside of string with malformed UTF-8 in unpack"
(F) You had a template that specified an absolute position outside
the string being unpacked.  The string being unpacked was also invalid
\&\s-1UTF\-8.\s0  See \*(L"pack\*(R" in perlfunc.
.IP "overload arg '%s' is invalid" 4
.IX Item "overload arg '%s' is invalid"
(W overload) The overload pragma was passed an argument it did not
recognize.  Did you mistype an operator?
.IP "Overloaded dereference did not return a reference" 4
.IX Item "Overloaded dereference did not return a reference"
(F) An object with an overloaded dereference operator was dereferenced,
but the overloaded operation did not return a reference.  See
overload.
.IP "Overloaded qr did not return a \s-1REGEXP\s0" 4
.IX Item "Overloaded qr did not return a REGEXP"
(F) An object with a \f(CW\*(C`qr\*(C'\fR overload was used as part of a match, but the
overloaded operation didn't return a compiled regexp.  See overload.
.ie n .IP "%s package attribute may clash with future reserved word: %s" 4
.el .IP "\f(CW%s\fR package attribute may clash with future reserved word: \f(CW%s\fR" 4
.IX Item "%s package attribute may clash with future reserved word: %s"
(W reserved) A lowercase attribute name was used that had a
package-specific handler.  That name might have a meaning to Perl itself
some day, even though it doesn't yet.  Perhaps you should use a
mixed-case attribute name, instead.  See attributes.
.IP "pack/unpack repeat count overflow" 4
.IX Item "pack/unpack repeat count overflow"
(F) You can't specify a repeat count so large that it overflows your
signed integers.  See \*(L"pack\*(R" in perlfunc.
.IP "page overflow" 4
.IX Item "page overflow"
(W io) A single call to \fBwrite()\fR produced more lines than can fit on a
page.  See perlform.
.ie n .IP "panic: %s" 4
.el .IP "panic: \f(CW%s\fR" 4
.IX Item "panic: %s"
(P) An internal error.
.ie n .IP "panic: attempt to call %s in %s" 4
.el .IP "panic: attempt to call \f(CW%s\fR in \f(CW%s\fR" 4
.IX Item "panic: attempt to call %s in %s"
(P) One of the file test operators entered a code branch that calls
an \s-1ACL\s0 related-function, but that function is not available on this
platform.  Earlier checks mean that it should not be possible to
enter this branch on this platform.
.IP "panic: child pseudo-process was never scheduled" 4
.IX Item "panic: child pseudo-process was never scheduled"
(P) A child pseudo-process in the ithreads implementation on Windows
was not scheduled within the time period allowed and therefore was not
able to initialize properly.
.IP "panic: ck_grep, type=%u" 4
.IX Item "panic: ck_grep, type=%u"
(P) Failed an internal consistency check trying to compile a grep.
.ie n .IP "panic: corrupt saved stack index %ld" 4
.el .IP "panic: corrupt saved stack index \f(CW%ld\fR" 4
.IX Item "panic: corrupt saved stack index %ld"
(P) The savestack was requested to restore more localized values than
there are in the savestack.
.IP "panic: del_backref" 4
.IX Item "panic: del_backref"
(P) Failed an internal consistency check while trying to reset a weak
reference.
.IP "panic: do_subst" 4
.IX Item "panic: do_subst"
(P) The internal \fBpp_subst()\fR routine was called with invalid operational
data.
.IP "panic: do_trans_%s" 4
.IX Item "panic: do_trans_%s"
(P) The internal do_trans routines were called with invalid operational
data.
.ie n .IP "panic: fold_constants \s-1JMPENV_PUSH\s0 returned %d" 4
.el .IP "panic: fold_constants \s-1JMPENV_PUSH\s0 returned \f(CW%d\fR" 4
.IX Item "panic: fold_constants JMPENV_PUSH returned %d"
(P) While attempting folding constants an exception other than an \f(CW\*(C`eval\*(C'\fR
failure was caught.
.ie n .IP "panic: frexp: %f" 4
.el .IP "panic: frexp: \f(CW%f\fR" 4
.IX Item "panic: frexp: %f"
(P) The library function \fBfrexp()\fR failed, making printf(\*(L"%f\*(R") impossible.
.IP "panic: goto, type=%u, ix=%ld" 4
.IX Item "panic: goto, type=%u, ix=%ld"
(P) We popped the context stack to a context with the specified label,
and then discovered it wasn't a context we know how to do a goto in.
.IP "panic: gp_free failed to free glob pointer" 4
.IX Item "panic: gp_free failed to free glob pointer"
(P) The internal routine used to clear a typeglob's entries tried
repeatedly, but each time something re-created entries in the glob.
Most likely the glob contains an object with a reference back to
the glob and a destructor that adds a new object to the glob.
.ie n .IP "panic: \s-1INTERPCASEMOD,\s0 %s" 4
.el .IP "panic: \s-1INTERPCASEMOD,\s0 \f(CW%s\fR" 4
.IX Item "panic: INTERPCASEMOD, %s"
(P) The lexer got into a bad state at a case modifier.
.ie n .IP "panic: \s-1INTERPCONCAT,\s0 %s" 4
.el .IP "panic: \s-1INTERPCONCAT,\s0 \f(CW%s\fR" 4
.IX Item "panic: INTERPCONCAT, %s"
(P) The lexer got into a bad state parsing a string with brackets.
.IP "panic: kid popen errno read" 4
.IX Item "panic: kid popen errno read"
(F) A forked child returned an incomprehensible message about its errno.
.IP "panic: last, type=%u" 4
.IX Item "panic: last, type=%u"
(P) We popped the context stack to a block context, and then discovered
it wasn't a block context.
.IP "panic: leave_scope clearsv" 4
.IX Item "panic: leave_scope clearsv"
(P) A writable lexical variable became read-only somehow within the
scope.
.ie n .IP "panic: leave_scope inconsistency %u" 4
.el .IP "panic: leave_scope inconsistency \f(CW%u\fR" 4
.IX Item "panic: leave_scope inconsistency %u"
(P) The savestack probably got out of sync.  At least, there was an
invalid enum on the top of it.
.IP "panic: magic_killbackrefs" 4
.IX Item "panic: magic_killbackrefs"
(P) Failed an internal consistency check while trying to reset all weak
references to an object.
.ie n .IP "panic: malloc, %s" 4
.el .IP "panic: malloc, \f(CW%s\fR" 4
.IX Item "panic: malloc, %s"
(P) Something requested a negative number of bytes of malloc.
.IP "panic: memory wrap" 4
.IX Item "panic: memory wrap"
(P) Something tried to allocate either more memory than possible or a
negative amount.
.ie n .IP "panic: pad_alloc, %p!=%p" 4
.el .IP "panic: pad_alloc, \f(CW%p\fR!=%p" 4
.IX Item "panic: pad_alloc, %p!=%p"
(P) The compiler got confused about which scratch pad it was allocating
and freeing temporaries and lexicals from.
.ie n .IP "panic: pad_free curpad, %p!=%p" 4
.el .IP "panic: pad_free curpad, \f(CW%p\fR!=%p" 4
.IX Item "panic: pad_free curpad, %p!=%p"
(P) The compiler got confused about which scratch pad it was allocating
and freeing temporaries and lexicals from.
.IP "panic: pad_free po" 4
.IX Item "panic: pad_free po"
(P) A zero scratch pad offset was detected internally.  An attempt was
made to free a target that had not been allocated to begin with.
.ie n .IP "panic: pad_reset curpad, %p!=%p" 4
.el .IP "panic: pad_reset curpad, \f(CW%p\fR!=%p" 4
.IX Item "panic: pad_reset curpad, %p!=%p"
(P) The compiler got confused about which scratch pad it was allocating
and freeing temporaries and lexicals from.
.IP "panic: pad_sv po" 4
.IX Item "panic: pad_sv po"
(P) A zero scratch pad offset was detected internally.  Most likely
an operator needed a target but that target had not been allocated
for whatever reason.
.ie n .IP "panic: pad_swipe curpad, %p!=%p" 4
.el .IP "panic: pad_swipe curpad, \f(CW%p\fR!=%p" 4
.IX Item "panic: pad_swipe curpad, %p!=%p"
(P) The compiler got confused about which scratch pad it was allocating
and freeing temporaries and lexicals from.
.IP "panic: pad_swipe po" 4
.IX Item "panic: pad_swipe po"
(P) An invalid scratch pad offset was detected internally.
.IP "panic: pp_iter, type=%u" 4
.IX Item "panic: pp_iter, type=%u"
(P) The foreach iterator got called in a non-loop context frame.
.IP "panic: pp_match%s" 4
.IX Item "panic: pp_match%s"
(P) The internal \fBpp_match()\fR routine was called with invalid operational
data.
.ie n .IP "panic: realloc, %s" 4
.el .IP "panic: realloc, \f(CW%s\fR" 4
.IX Item "panic: realloc, %s"
(P) Something requested a negative number of bytes of realloc.
.IP "panic: reference miscount on nsv in \fBsv_replace()\fR (%d != 1)" 4
.IX Item "panic: reference miscount on nsv in sv_replace() (%d != 1)"
(P) The internal \fBsv_replace()\fR function was handed a new \s-1SV\s0 with a
reference count other than 1.
.ie n .IP "panic: restartop in %s" 4
.el .IP "panic: restartop in \f(CW%s\fR" 4
.IX Item "panic: restartop in %s"
(P) Some internal routine requested a goto (or something like it), and
didn't supply the destination.
.IP "panic: return, type=%u" 4
.IX Item "panic: return, type=%u"
(P) We popped the context stack to a subroutine or eval context, and
then discovered it wasn't a subroutine or eval context.
.ie n .IP "panic: scan_num, %s" 4
.el .IP "panic: scan_num, \f(CW%s\fR" 4
.IX Item "panic: scan_num, %s"
(P) \fBscan_num()\fR got called on something that wasn't a number.
.IP "panic: Sequence (?{...}): no code block found in regex m/%s/" 4
.IX Item "panic: Sequence (?{...}): no code block found in regex m/%s/"
(P) While compiling a pattern that has embedded (?{}) or (??{}) code
blocks, perl couldn't locate the code block that should have already been
seen and compiled by perl before control passed to the regex compiler.
.ie n .IP "panic: \fBstrxfrm()\fR gets absurd \- a => %u, ab => %u" 4
.el .IP "panic: \fBstrxfrm()\fR gets absurd \- a => \f(CW%u\fR, ab => \f(CW%u\fR" 4
.IX Item "panic: strxfrm() gets absurd - a => %u, ab => %u"
(P) The interpreter's sanity check of the C function \fBstrxfrm()\fR failed.
In your current locale the returned transformation of the string \*(L"ab\*(R"
is shorter than that of the string \*(L"a\*(R", which makes no sense.
.ie n .IP "panic: sv_chop %s" 4
.el .IP "panic: sv_chop \f(CW%s\fR" 4
.IX Item "panic: sv_chop %s"
(P) The \fBsv_chop()\fR routine was passed a position that is not within the
scalar's string buffer.
.IP "panic: sv_insert, midend=%p, bigend=%p" 4
.IX Item "panic: sv_insert, midend=%p, bigend=%p"
(P) The \fBsv_insert()\fR routine was told to remove more string than there
was string.
.IP "panic: top_env" 4
.IX Item "panic: top_env"
(P) The compiler attempted to do a goto, or something weird like that.
.ie n .IP "panic: unimplemented op %s (#%d) called" 4
.el .IP "panic: unimplemented op \f(CW%s\fR (#%d) called" 4
.IX Item "panic: unimplemented op %s (#%d) called"
(P) The compiler is screwed up and attempted to use an op that isn't
permitted at run time.
.ie n .IP "panic: unknown OA_*: %x" 4
.el .IP "panic: unknown OA_*: \f(CW%x\fR" 4
.IX Item "panic: unknown OA_*: %x"
(P) The internal routine that handles arguments to \f(CW\*(C`&CORE::foo()\*(C'\fR
subroutine calls was unable to determine what type of arguments
were expected.
.IP "panic: utf16_to_utf8: odd bytelen" 4
.IX Item "panic: utf16_to_utf8: odd bytelen"
(P) Something tried to call utf16_to_utf8 with an odd (as opposed
to even) byte length.
.IP "panic: utf16_to_utf8_reversed: odd bytelen" 4
.IX Item "panic: utf16_to_utf8_reversed: odd bytelen"
(P) Something tried to call utf16_to_utf8_reversed with an odd (as opposed
to even) byte length.
.ie n .IP "panic: yylex, %s" 4
.el .IP "panic: yylex, \f(CW%s\fR" 4
.IX Item "panic: yylex, %s"
(P) The lexer got into a bad state while processing a case modifier.
.ie n .IP "Parentheses missing around ""%s"" list" 4
.el .IP "Parentheses missing around ``%s'' list" 4
.IX Item "Parentheses missing around %s list"
(W parenthesis) You said something like
.Sp
.Vb 1
\&    my $foo, $bar = @_;
.Ve
.Sp
when you meant
.Sp
.Vb 1
\&    my ($foo, $bar) = @_;
.Ve
.Sp
Remember that \*(L"my\*(R", \*(L"our\*(R", \*(L"local\*(R" and \*(L"state\*(R" bind tighter than comma.
.IP "Parsing code internal error (%s)" 4
.IX Item "Parsing code internal error (%s)"
(F) Parsing code supplied by an extension violated the parser's \s-1API\s0 in
a detectable way.
.IP "Pattern subroutine nesting without pos change exceeded limit in regex" 4
.IX Item "Pattern subroutine nesting without pos change exceeded limit in regex"
(F) You used a pattern that uses too many nested subpattern calls without
consuming any text.  Restructure the pattern so text is consumed before
the nesting limit is exceeded.
.ie n .IP """\-p"" destination: %s" 4
.el .IP "\f(CW\-p\fR destination: \f(CW%s\fR" 4
.IX Item "-p destination: %s"
(F) An error occurred during the implicit output invoked by the \f(CW\*(C`\-p\*(C'\fR
command-line switch.  (This output goes to \s-1STDOUT\s0 unless you've
redirected it with \fBselect()\fR.)
.ie n .IP "Perl \s-1API\s0 version %s of %s does not match %s" 4
.el .IP "Perl \s-1API\s0 version \f(CW%s\fR of \f(CW%s\fR does not match \f(CW%s\fR" 4
.IX Item "Perl API version %s of %s does not match %s"
(F) The \s-1XS\s0 module in question was compiled against a different incompatible
version of Perl than the one that has loaded the \s-1XS\s0 module.
.IP "Perl folding rules are not up-to-date for 0x%X; please use the perlbug utility to report; in regex; marked by <\-\-\ \s-1HERE\s0 in m/%s/" 4
.IX Item "Perl folding rules are not up-to-date for 0x%X; please use the perlbug utility to report; in regex; marked by <--HERE in m/%s/"
(S regexp) You used a regular expression with case-insensitive matching,
and there is a bug in Perl in which the built-in regular expression
folding rules are not accurate.  This may lead to incorrect results.
Please report this as a bug to <https://github.com/Perl/perl5/issues>.
.IP "PerlIO layer ':win32' is experimental" 4
.IX Item "PerlIO layer ':win32' is experimental"
(S experimental::win32_perlio) The \f(CW\*(C`:win32\*(C'\fR PerlIO layer is
experimental.  If you want to take the risk of using this layer,
simply disable this warning:
.Sp
.Vb 1
\&    no warnings "experimental::win32_perlio";
.Ve
.IP "Perl_my_%s() not available" 4
.IX Item "Perl_my_%s() not available"
(F) Your platform has very uncommon byte-order and integer size,
so it was not possible to set up some or all fixed-width byte-order
conversion functions.  This is only a problem when you're using the
\&'<' or '>' modifiers in (un)pack templates.  See \*(L"pack\*(R" in perlfunc.
.ie n .IP "Perl %s required (did you mean %s?)\-\-this is only %s, stopped" 4
.el .IP "Perl \f(CW%s\fR required (did you mean \f(CW%s\fR?)\-\-this is only \f(CW%s\fR, stopped" 4
.IX Item "Perl %s required (did you mean %s?)--this is only %s, stopped"
(F) The code you are trying to run has asked for a newer version of
Perl than you are running.  Perhaps \f(CW\*(C`use 5.10\*(C'\fR was written instead
of \f(CW\*(C`use 5.010\*(C'\fR or \f(CW\*(C`use v5.10\*(C'\fR.  Without the leading \f(CW\*(C`v\*(C'\fR, the number is
interpreted as a decimal, with every three digits after the
decimal point representing a part of the version number.  So 5.10
is equivalent to v5.100.
.ie n .IP "Perl %s required\*(--this is only %s, stopped" 4
.el .IP "Perl \f(CW%s\fR required\*(--this is only \f(CW%s\fR, stopped" 4
.IX Item "Perl %s requiredthis is only %s, stopped"
(F) The module in question uses features of a version of Perl more
recent than the currently running version.  How long has it been since
you upgraded, anyway?  See \*(L"require\*(R" in perlfunc.
.IP "\s-1PERL_SH_DIR\s0 too long" 4
.IX Item "PERL_SH_DIR too long"
(F) An error peculiar to \s-1OS/2.\s0  \s-1PERL_SH_DIR\s0 is the directory to find the
\&\f(CW\*(C`sh\*(C'\fR\-shell in.  See \*(L"\s-1PERL_SH_DIR\*(R"\s0 in perlos2.
.ie n .IP "\s-1PERL_SIGNALS\s0 illegal: ""%s""" 4
.el .IP "\s-1PERL_SIGNALS\s0 illegal: ``%s''" 4
.IX Item "PERL_SIGNALS illegal: %s"
(X) See \*(L"\s-1PERL_SIGNALS\*(R"\s0 in perlrun for legal values.
.ie n .IP "Perls since %s too modern\*(--this is %s, stopped" 4
.el .IP "Perls since \f(CW%s\fR too modern\*(--this is \f(CW%s\fR, stopped" 4
.IX Item "Perls since %s too modernthis is %s, stopped"
(F) The code you are trying to run claims it will not run
on the version of Perl you are using because it is too new.
Maybe the code needs to be updated, or maybe it is simply
wrong and the version check should just be removed.
.IP "perl: warning: Non hex character in '$ENV{\s-1PERL_HASH_SEED\s0}', seed only partially set" 4
.IX Item "perl: warning: Non hex character in '$ENV{PERL_HASH_SEED}', seed only partially set"
(S) \s-1PERL_HASH_SEED\s0 should match /^\es*(?:0x)?[0\-9a\-fA\-F]+\es*\ez/ but it
contained a non hex character.  This could mean you are not using the
hash seed you think you are.
.IP "perl: warning: Setting locale failed." 4
.IX Item "perl: warning: Setting locale failed."
(S) The whole warning message will look something like:
.Sp
.Vb 6
\&        perl: warning: Setting locale failed.
\&        perl: warning: Please check that your locale settings:
\&                LC_ALL = "En_US",
\&                LANG = (unset)
\&            are supported and installed on your system.
\&        perl: warning: Falling back to the standard locale ("C").
.Ve
.Sp
Exactly what were the failed locale settings varies.  In the above the
settings were that the \s-1LC_ALL\s0 was \*(L"En_US\*(R" and the \s-1LANG\s0 had no value.
This error means that Perl detected that you and/or your operating
system supplier and/or system administrator have set up the so-called
locale system but Perl could not use those settings.  This was not
dead serious, fortunately: there is a \*(L"default locale\*(R" called \*(L"C\*(R" that
Perl can and will use, and the script will be run.  Before you really
fix the problem, however, you will get the same error message each
time you run Perl.  How to really fix the problem can be found in
perllocale section \fB\s-1LOCALE PROBLEMS\s0\fR.
.IP "perl: warning: strange setting in '$ENV{\s-1PERL_PERTURB_KEYS\s0}': '%s'" 4
.IX Item "perl: warning: strange setting in '$ENV{PERL_PERTURB_KEYS}': '%s'"
(S) Perl was run with the environment variable \s-1PERL_PERTURB_KEYS\s0 defined
but containing an unexpected value.  The legal values of this setting
are as follows.
.Sp
.Vb 6
\&  Numeric | String        | Result
\&  \-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&  0       | NO            | Disables key traversal randomization
\&  1       | RANDOM        | Enables full key traversal randomization
\&  2       | DETERMINISTIC | Enables repeatable key traversal
\&          |               | randomization
.Ve
.Sp
Both numeric and string values are accepted, but note that string values are
case sensitive.  The default for this setting is \*(L"\s-1RANDOM\*(R"\s0 or 1.
.ie n .IP "pid %x not a child" 4
.el .IP "pid \f(CW%x\fR not a child" 4
.IX Item "pid %x not a child"
(W exec) A warning peculiar to \s-1VMS.\s0  \fBWaitpid()\fR was asked to wait for a
process which isn't a subprocess of the current process.  While this is
fine from \s-1VMS\s0' perspective, it's probably not what you intended.
.IP "'P' must have an explicit size in unpack" 4
.IX Item "'P' must have an explicit size in unpack"
(F) The unpack format P must have an explicit size, not \*(L"*\*(R".
.IP "\s-1POSIX\s0 class [:%s:] unknown in regex; marked by <\-\-\ \s-1HERE\s0 in m/%s/" 4
.IX Item "POSIX class [:%s:] unknown in regex; marked by <--HERE in m/%s/"
(F) The class in the character class [: :] syntax is unknown.  The <\-\-\ \s-1HERE\s0
shows whereabouts in the regular expression the problem was discovered.
Note that the \s-1POSIX\s0 character classes do \fBnot\fR have the \f(CW\*(C`is\*(C'\fR prefix
the corresponding C interfaces have: in other words, it's \f(CW\*(C`[[:print:]]\*(C'\fR,
not \f(CW\*(C`isprint\*(C'\fR.  See perlre.
.IP "\s-1POSIX\s0 getpgrp can't take an argument" 4
.IX Item "POSIX getpgrp can't take an argument"
(F) Your system has \s-1POSIX\s0 \fBgetpgrp()\fR, which takes no argument, unlike
the \s-1BSD\s0 version, which takes a pid.
.ie n .IP "\s-1POSIX\s0 syntax [%c %c] belongs inside character classes%s in regex; marked by <\-\-\ \s-1HERE\s0 in m/%s/" 4
.el .IP "\s-1POSIX\s0 syntax [%c \f(CW%c\fR] belongs inside character classes%s in regex; marked by <\-\-\ \s-1HERE\s0 in m/%s/" 4
.IX Item "POSIX syntax [%c %c] belongs inside character classes%s in regex; marked by <--HERE in m/%s/"
(W regexp) Perl thinks that you intended to write a \s-1POSIX\s0 character
class, but didn't use enough brackets.  These \s-1POSIX\s0 class constructs [:
:], [= =], and [. .]  go \fIinside\fR character classes, the [] are part of
the construct, for example: \f(CW\*(C`qr/[012[:alpha:]345]/\*(C'\fR.  What the regular
expression pattern compiled to is probably not what you were intending.
For example, \f(CW\*(C`qr/[:alpha:]/\*(C'\fR compiles to a regular bracketed character
class consisting of the four characters \f(CW":"\fR,  \f(CW"a"\fR,  \f(CW"l"\fR,
\&\f(CW"h"\fR, and \f(CW"p"\fR.  To specify the \s-1POSIX\s0 class, it should have been
written \f(CW\*(C`qr/[[:alpha:]]/\*(C'\fR.
.Sp
Note that [= =] and [. .] are not currently
implemented; they are simply placeholders for future extensions and
will cause fatal errors.  The <\-\-\ \s-1HERE\s0 shows whereabouts in the regular
expression the problem was discovered.  See perlre.
.Sp
If the specification of the class was not completely valid, the message
indicates that.
.IP "\s-1POSIX\s0 syntax [. .] is reserved for future extensions in regex; marked by <\-\-\ \s-1HERE\s0 in m/%s/" 4
.IX Item "POSIX syntax [. .] is reserved for future extensions in regex; marked by <--HERE in m/%s/"
(F) Within regular expression character classes ([]) the syntax beginning
with \*(L"[.\*(R" and ending with \*(L".]\*(R" is reserved for future extensions.  If you
need to represent those character sequences inside a regular expression
character class, just quote the square brackets with the backslash: \*(L"\e[.\*(R"
and \*(L".\e]\*(R".  The <\-\-\ \s-1HERE\s0 shows whereabouts in the regular expression the
problem was discovered.  See perlre.
.IP "\s-1POSIX\s0 syntax [= =] is reserved for future extensions in regex; marked by <\-\-\ \s-1HERE\s0 in m/%s/" 4
.IX Item "POSIX syntax [= =] is reserved for future extensions in regex; marked by <--HERE in m/%s/"
(F) Within regular expression character classes ([]) the syntax beginning
with \*(L"[=\*(R" and ending with \*(L"=]\*(R" is reserved for future extensions.  If you
need to represent those character sequences inside a regular expression
character class, just quote the square brackets with the backslash: \*(L"\e[=\*(R"
and \*(L"=\e]\*(R".  The <\-\-\ \s-1HERE\s0 shows whereabouts in the regular expression the
problem was discovered.  See perlre.
.IP "Possible attempt to put comments in \fBqw()\fR list" 4
.IX Item "Possible attempt to put comments in qw() list"
(W qw) \fBqw()\fR lists contain items separated by whitespace; as with literal
strings, comment characters are not ignored, but are instead treated as
literal data.  (You may have used different delimiters than the
parentheses shown here; braces are also frequently used.)
.Sp
You probably wrote something like this:
.Sp
.Vb 4
\&    @list = qw(
\&        a # a comment
\&        b # another comment
\&    );
.Ve
.Sp
when you should have written this:
.Sp
.Vb 4
\&    @list = qw(
\&        a
\&        b
\&    );
.Ve
.Sp
If you really want comments, build your list the
old-fashioned way, with quotes and commas:
.Sp
.Vb 4
\&    @list = (
\&        \*(Aqa\*(Aq,    # a comment
\&        \*(Aqb\*(Aq,    # another comment
\&    );
.Ve
.IP "Possible attempt to separate words with commas" 4
.IX Item "Possible attempt to separate words with commas"
(W qw) \fBqw()\fR lists contain items separated by whitespace; therefore
commas aren't needed to separate the items.  (You may have used
different delimiters than the parentheses shown here; braces are also
frequently used.)
.Sp
You probably wrote something like this:
.Sp
.Vb 1
\&    qw! a, b, c !;
.Ve
.Sp
which puts literal commas into some of the list items.  Write it without
commas if you don't want them to appear in your data:
.Sp
.Vb 1
\&    qw! a b c !;
.Ve
.ie n .IP "Possible memory corruption: %s overflowed 3rd argument" 4
.el .IP "Possible memory corruption: \f(CW%s\fR overflowed 3rd argument" 4
.IX Item "Possible memory corruption: %s overflowed 3rd argument"
(F) An \fBioctl()\fR or \fBfcntl()\fR returned more than Perl was bargaining for.
Perl guesses a reasonable buffer size, but puts a sentinel byte at the
end of the buffer just in case.  This sentinel byte got clobbered, and
Perl assumes that memory is now corrupted.  See \*(L"ioctl\*(R" in perlfunc.
.IP "Possible precedence issue with control flow operator" 4
.IX Item "Possible precedence issue with control flow operator"
(W syntax) There is a possible problem with the mixing of a control
flow operator (e.g. \f(CW\*(C`return\*(C'\fR) and a low-precedence operator like
\&\f(CW\*(C`or\*(C'\fR.  Consider:
.Sp
.Vb 1
\&    sub { return $a or $b; }
.Ve
.Sp
This is parsed as:
.Sp
.Vb 1
\&    sub { (return $a) or $b; }
.Ve
.Sp
Which is effectively just:
.Sp
.Vb 1
\&    sub { return $a; }
.Ve
.Sp
Either use parentheses or the high-precedence variant of the operator.
.Sp
Note this may be also triggered for constructs like:
.Sp
.Vb 1
\&    sub { 1 if die; }
.Ve
.ie n .IP "Possible precedence problem on bitwise %s operator" 4
.el .IP "Possible precedence problem on bitwise \f(CW%s\fR operator" 4
.IX Item "Possible precedence problem on bitwise %s operator"
(W precedence) Your program uses a bitwise logical operator in conjunction
with a numeric comparison operator, like this :
.Sp
.Vb 1
\&    if ($x & $y == 0) { ... }
.Ve
.Sp
This expression is actually equivalent to \f(CW\*(C`$x & ($y == 0)\*(C'\fR, due to the
higher precedence of \f(CW\*(C`==\*(C'\fR.  This is probably not what you want.  (If you
really meant to write this, disable the warning, or, better, put the
parentheses explicitly and write \f(CW\*(C`$x & ($y == 0)\*(C'\fR).
.IP "Possible unintended interpolation of $\e in regex" 4
.IX Item "Possible unintended interpolation of $ in regex"
(W ambiguous) You said something like \f(CW\*(C`m/$\e/\*(C'\fR in a regex.
The regex \f(CW\*(C`m/foo$\es+bar/m\*(C'\fR translates to: match the word 'foo', the output
record separator (see \*(L"$\e\*(R" in perlvar) and the letter 's' (one time or more)
followed by the word 'bar'.
.Sp
If this is what you intended then you can silence the warning by using 
\&\f(CW\*(C`m/${\e}/\*(C'\fR (for example: \f(CW\*(C`m/foo${\e}s+bar/\*(C'\fR).
.Sp
If instead you intended to match the word 'foo' at the end of the line
followed by whitespace and the word 'bar' on the next line then you can use
\&\f(CW\*(C`m/$(?)\e/\*(C'\fR (for example: \f(CW\*(C`m/foo$(?)\es+bar/\*(C'\fR).
.ie n .IP "Possible unintended interpolation of %s in string" 4
.el .IP "Possible unintended interpolation of \f(CW%s\fR in string" 4
.IX Item "Possible unintended interpolation of %s in string"
(W ambiguous) You said something like '@foo' in a double-quoted string
but there was no array \f(CW@foo\fR in scope at the time.  If you wanted a
literal \f(CW@foo\fR, then write it as \e@foo; otherwise find out what happened
to the array you apparently lost track of.
.ie n .IP "Precedence problem: open %s should be open(%s)" 4
.el .IP "Precedence problem: open \f(CW%s\fR should be open(%s)" 4
.IX Item "Precedence problem: open %s should be open(%s)"
(S precedence) The old irregular construct
.Sp
.Vb 1
\&    open FOO || die;
.Ve
.Sp
is now misinterpreted as
.Sp
.Vb 1
\&    open(FOO || die);
.Ve
.Sp
because of the strict regularization of Perl 5's grammar into unary and
list operators.  (The old open was a little of both.)  You must put
parentheses around the filehandle, or use the new \*(L"or\*(R" operator instead
of \*(L"||\*(R".
.IP "Premature end of script headers" 4
.IX Item "Premature end of script headers"
See \*(L"500 Server error\*(R".
.ie n .IP "\fBprintf()\fR on closed filehandle %s" 4
.el .IP "\fBprintf()\fR on closed filehandle \f(CW%s\fR" 4
.IX Item "printf() on closed filehandle %s"
(W closed) The filehandle you're writing to got itself closed sometime
before now.  Check your control flow.
.ie n .IP "\fBprint()\fR on closed filehandle %s" 4
.el .IP "\fBprint()\fR on closed filehandle \f(CW%s\fR" 4
.IX Item "print() on closed filehandle %s"
(W closed) The filehandle you're printing on got itself closed sometime
before now.  Check your control flow.
.IP "Process terminated by SIG%s" 4
.IX Item "Process terminated by SIG%s"
(W) This is a standard message issued by \s-1OS/2\s0 applications, while *nix
applications die in silence.  It is considered a feature of the \s-1OS/2\s0
port.  One can easily disable this by appropriate sighandlers, see
\&\*(L"Signals\*(R" in perlipc.  See also \*(L"Process terminated by \s-1SIGTERM/SIGINT\*(R"\s0
in perlos2.
.ie n .IP "Prototype after '%c' for %s : %s" 4
.el .IP "Prototype after '%c' for \f(CW%s\fR : \f(CW%s\fR" 4
.IX Item "Prototype after '%c' for %s : %s"
(W illegalproto) A character follows % or @ in a prototype.  This is
useless, since % and @ gobble the rest of the subroutine arguments.
.ie n .IP "Prototype mismatch: %s vs %s" 4
.el .IP "Prototype mismatch: \f(CW%s\fR vs \f(CW%s\fR" 4
.IX Item "Prototype mismatch: %s vs %s"
(S prototype) The subroutine being declared or defined had previously been
declared or defined with a different function prototype.
.IP "Prototype not terminated" 4
.IX Item "Prototype not terminated"
(F) You've omitted the closing parenthesis in a function prototype
definition.
.ie n .IP "Prototype '%s' overridden by attribute 'prototype(%s)' in %s" 4
.el .IP "Prototype '%s' overridden by attribute 'prototype(%s)' in \f(CW%s\fR" 4
.IX Item "Prototype '%s' overridden by attribute 'prototype(%s)' in %s"
(W prototype) A prototype was declared in both the parentheses after
the sub name and via the prototype attribute.  The prototype in
parentheses is useless, since it will be replaced by the prototype
from the attribute before it's ever used.
.IP "Quantifier follows nothing in regex; marked by <\-\-\ \s-1HERE\s0 in m/%s/" 4
.IX Item "Quantifier follows nothing in regex; marked by <--HERE in m/%s/"
(F) You started a regular expression with a quantifier.  Backslash it if
you meant it literally.  The <\-\-\ \s-1HERE\s0 shows whereabouts in the regular
expression the problem was discovered.  See perlre.
.ie n .IP "Quantifier in {,} bigger than %d in regex; marked by <\-\-\ \s-1HERE\s0 in m/%s/" 4
.el .IP "Quantifier in {,} bigger than \f(CW%d\fR in regex; marked by <\-\-\ \s-1HERE\s0 in m/%s/" 4
.IX Item "Quantifier in {,} bigger than %d in regex; marked by <--HERE in m/%s/"
(F) There is currently a limit to the size of the min and max values of
the {min,max} construct.  The <\-\-\ \s-1HERE\s0 shows whereabouts in the regular
expression the problem was discovered.  See perlre.
.IP "Quantifier {n,m} with n > m can't match in regex" 4
.IX Item "Quantifier {n,m} with n > m can't match in regex"
.PD 0
.IP "Quantifier {n,m} with n > m can't match in regex; marked by <\-\-\ \s-1HERE\s0 in m/%s/" 4
.IX Item "Quantifier {n,m} with n > m can't match in regex; marked by <--HERE in m/%s/"
.PD
(W regexp) Minima should be less than or equal to maxima.  If you really
want your regexp to match something 0 times, just put {0}.
.IP "Quantifier unexpected on zero-length expression in regex m/%s/" 4
.IX Item "Quantifier unexpected on zero-length expression in regex m/%s/"
(W regexp) You applied a regular expression quantifier in a place where
it makes no sense, such as on a zero-width assertion.  Try putting the
quantifier inside the assertion instead.  For example, the way to match
\&\*(L"abc\*(R" provided that it is followed by three repetitions of \*(L"xyz\*(R" is
\&\f(CW\*(C`/abc(?=(?:xyz){3})/\*(C'\fR, not \f(CW\*(C`/abc(?=xyz){3}/\*(C'\fR.
.IP "Range iterator outside integer range" 4
.IX Item "Range iterator outside integer range"
(F) One (or both) of the numeric arguments to the range operator \*(L"..\*(R"
are outside the range which can be represented by integers internally.
One possible workaround is to force Perl to use magical string increment
by prepending \*(L"0\*(R" to your numbers.
.ie n .IP "Ranges of \s-1ASCII\s0 printables should be some subset of ""0\-9"", ""A\-Z"", or ""a\-z"" in regex; marked by <\-\-\ \s-1HERE\s0 in m/%s/" 4
.el .IP "Ranges of \s-1ASCII\s0 printables should be some subset of ``0\-9'', ``A\-Z'', or ``a\-z'' in regex; marked by <\-\-\ \s-1HERE\s0 in m/%s/" 4
.IX Item "Ranges of ASCII printables should be some subset of 0-9, A-Z, or a-z in regex; marked by <--HERE in m/%s/"
(W regexp) (only under \f(CW\*(C`use\ re\ \*(Aqstrict\*(Aq\*(C'\fR or within \f(CW\*(C`(?[...])\*(C'\fR)
.Sp
Stricter rules help to find typos and other errors.  Perhaps you didn't
even intend a range here, if the \f(CW"\-"\fR was meant to be some other
character, or should have been escaped (like \f(CW"\e\-"\fR).  If you did
intend a range, the one that was used is not portable between \s-1ASCII\s0 and
\&\s-1EBCDIC\s0 platforms, and doesn't have an obvious meaning to a casual
reader.
.Sp
.Vb 7
\& [3\-7]    # OK; Obvious and portable
\& [d\-g]    # OK; Obvious and portable
\& [A\-Y]    # OK; Obvious and portable
\& [A\-z]    # WRONG; Not portable; not clear what is meant
\& [a\-Z]    # WRONG; Not portable; not clear what is meant
\& [%\-.]    # WRONG; Not portable; not clear what is meant
\& [\ex41\-Z] # WRONG; Not portable; not obvious to non\-geek
.Ve
.Sp
(You can force portability by specifying a Unicode range, which means that
the endpoints are specified by
\&\f(CW\*(C`\eN{...}\*(C'\fR, but the meaning may
still not be obvious.)
The stricter rules require that ranges that start or stop with an \s-1ASCII\s0
character that is not a control have all their endpoints be the literal
character, and not some escape sequence (like \f(CW"\ex41"\fR), and the ranges
must be all digits, or all uppercase letters, or all lowercase letters.
.IP "Ranges of digits should be from the same group in regex; marked by <\-\-\ \s-1HERE\s0 in m/%s/" 4
.IX Item "Ranges of digits should be from the same group in regex; marked by <--HERE in m/%s/"
(W regexp) (only under \f(CW\*(C`use\ re\ \*(Aqstrict\*(Aq\*(C'\fR or within \f(CW\*(C`(?[...])\*(C'\fR)
.Sp
Stricter rules help to find typos and other errors.  You included a
range, and at least one of the end points is a decimal digit.  Under the
stricter rules, when this happens, both end points should be digits in
the same group of 10 consecutive digits.
.ie n .IP "\fBreaddir()\fR attempted on invalid dirhandle %s" 4
.el .IP "\fBreaddir()\fR attempted on invalid dirhandle \f(CW%s\fR" 4
.IX Item "readdir() attempted on invalid dirhandle %s"
(W io) The dirhandle you're reading from is either closed or not really
a dirhandle.  Check your control flow.
.ie n .IP "\fBreadline()\fR on closed filehandle %s" 4
.el .IP "\fBreadline()\fR on closed filehandle \f(CW%s\fR" 4
.IX Item "readline() on closed filehandle %s"
(W closed) The filehandle you're reading from got itself closed sometime
before now.  Check your control flow.
.ie n .IP "\fBread()\fR on closed filehandle %s" 4
.el .IP "\fBread()\fR on closed filehandle \f(CW%s\fR" 4
.IX Item "read() on closed filehandle %s"
(W closed) You tried to read from a closed filehandle.
.ie n .IP "\fBread()\fR on unopened filehandle %s" 4
.el .IP "\fBread()\fR on unopened filehandle \f(CW%s\fR" 4
.IX Item "read() on unopened filehandle %s"
(W unopened) You tried to read from a filehandle that was never opened.
.ie n .IP "Reallocation too large: %x" 4
.el .IP "Reallocation too large: \f(CW%x\fR" 4
.IX Item "Reallocation too large: %x"
(F) You can't allocate more than 64K on an MS-DOS machine.
.IP "\fBrealloc()\fR of freed memory ignored" 4
.IX Item "realloc() of freed memory ignored"
(S malloc) An internal routine called \fBrealloc()\fR on something that had
already been freed.
.IP "Recompile perl with \fB\-D\fR\s-1DEBUGGING\s0 to use \fB\-D\fR switch" 4
.IX Item "Recompile perl with -DDEBUGGING to use -D switch"
(S debugging) You can't use the \fB\-D\fR option unless the code to produce
the desired output is compiled into Perl, which entails some overhead,
which is why it's currently left out of your copy.
.IP "Recursive call to Perl_load_module in PerlIO_find_layer" 4
.IX Item "Recursive call to Perl_load_module in PerlIO_find_layer"
(P) It is currently not permitted to load modules when creating
a filehandle inside an \f(CW%INC\fR hook.  This can happen with \f(CW\*(C`open my
$fh, \*(Aq<\*(Aq, \e$scalar\*(C'\fR, which implicitly loads PerlIO::scalar.  Try
loading PerlIO::scalar explicitly first.
.IP "Recursive inheritance detected in package '%s'" 4
.IX Item "Recursive inheritance detected in package '%s'"
(F) While calculating the method resolution order (\s-1MRO\s0) of a package, Perl
believes it found an infinite loop in the \f(CW@ISA\fR hierarchy.  This is a
crude check that bails out after 100 levels of \f(CW@ISA\fR depth.
.ie n .IP "Redundant argument in %s" 4
.el .IP "Redundant argument in \f(CW%s\fR" 4
.IX Item "Redundant argument in %s"
(W redundant) You called a function with more arguments than other
arguments you supplied indicated would be needed.  Currently only
emitted when a printf-type format required fewer arguments than were
supplied, but might be used in the future for e.g. \*(L"pack\*(R" in perlfunc.
.ie n .IP "refcnt_dec: fd %d%s" 4
.el .IP "refcnt_dec: fd \f(CW%d\fR%s" 4
.IX Item "refcnt_dec: fd %d%s"
.PD 0
.ie n .IP "refcnt: fd %d%s" 4
.el .IP "refcnt: fd \f(CW%d\fR%s" 4
.IX Item "refcnt: fd %d%s"
.ie n .IP "refcnt_inc: fd %d%s" 4
.el .IP "refcnt_inc: fd \f(CW%d\fR%s" 4
.IX Item "refcnt_inc: fd %d%s"
.PD
(P) Perl's I/O implementation failed an internal consistency check.  If
you see this message, something is very wrong.
.IP "Reference found where even-sized list expected" 4
.IX Item "Reference found where even-sized list expected"
(W misc) You gave a single reference where Perl was expecting a list
with an even number of elements (for assignment to a hash).  This
usually means that you used the anon hash constructor when you meant
to use parens.  In any case, a hash requires key/value \fBpairs\fR.
.Sp
.Vb 4
\&    %hash = { one => 1, two => 2, };    # WRONG
\&    %hash = [ qw/ an anon array / ];    # WRONG
\&    %hash = ( one => 1, two => 2, );    # right
\&    %hash = qw( one 1 two 2 );                  # also fine
.Ve
.IP "Reference is already weak" 4
.IX Item "Reference is already weak"
(W misc) You have attempted to weaken a reference that is already weak.
Doing so has no effect.
.IP "Reference is not weak" 4
.IX Item "Reference is not weak"
(W misc) You have attempted to unweaken a reference that is not weak.
Doing so has no effect.
.IP "Reference to invalid group 0 in regex; marked by <\-\-\ \s-1HERE\s0 in m/%s/" 4
.IX Item "Reference to invalid group 0 in regex; marked by <--HERE in m/%s/"
(F) You used \f(CW\*(C`\eg0\*(C'\fR or similar in a regular expression.  You may refer
to capturing parentheses only with strictly positive integers
(normal backreferences) or with strictly negative integers (relative
backreferences).  Using 0 does not make sense.
.IP "Reference to nonexistent group in regex; marked by <\-\-\ \s-1HERE\s0 in m/%s/" 4
.IX Item "Reference to nonexistent group in regex; marked by <--HERE in m/%s/"
(F) You used something like \f(CW\*(C`\e7\*(C'\fR in your regular expression, but there are
not at least seven sets of capturing parentheses in the expression.  If
you wanted to have the character with ordinal 7 inserted into the regular
expression, prepend zeroes to make it three digits long: \f(CW\*(C`\e007\*(C'\fR
.Sp
The <\-\-\ \s-1HERE\s0 shows whereabouts in the regular expression the problem was
discovered.
.IP "Reference to nonexistent named group in regex; marked by <\-\-\ \s-1HERE\s0 in m/%s/" 4
.IX Item "Reference to nonexistent named group in regex; marked by <--HERE in m/%s/"
(F) You used something like \f(CW\*(C`\ek\*(AqNAME\*(Aq\*(C'\fR or \f(CW\*(C`\ek<NAME>\*(C'\fR in your regular
expression, but there is no corresponding named capturing parentheses
such as \f(CW\*(C`(?\*(AqNAME\*(Aq...)\*(C'\fR or \f(CW\*(C`(?<NAME>...)\*(C'\fR.  Check if the name has been
spelled correctly both in the backreference and the declaration.
.Sp
The <\-\-\ \s-1HERE\s0 shows whereabouts in the regular expression the problem was
discovered.
.IP "Reference to nonexistent or unclosed group in regex; marked by <\-\-\ \s-1HERE\s0 in m/%s/" 4
.IX Item "Reference to nonexistent or unclosed group in regex; marked by <--HERE in m/%s/"
(F) You used something like \f(CW\*(C`\eg{\-7}\*(C'\fR in your regular expression, but there
are not at least seven sets of closed capturing parentheses in the
expression before where the \f(CW\*(C`\eg{\-7}\*(C'\fR was located.
.Sp
The <\-\-\ \s-1HERE\s0 shows whereabouts in the regular expression the problem was
discovered.
.IP "regexp memory corruption" 4
.IX Item "regexp memory corruption"
(P) The regular expression engine got confused by what the regular
expression compiler gave it.
.ie n .IP "Regexp modifier ""/%c"" may appear a maximum of twice" 4
.el .IP "Regexp modifier ``/%c'' may appear a maximum of twice" 4
.IX Item "Regexp modifier /%c may appear a maximum of twice"
.PD 0
.ie n .IP "Regexp modifier ""%c"" may appear a maximum of twice in regex; marked by <\-\-\ \s-1HERE\s0 in m/%s/" 4
.el .IP "Regexp modifier ``%c'' may appear a maximum of twice in regex; marked by <\-\-\ \s-1HERE\s0 in m/%s/" 4
.IX Item "Regexp modifier %c may appear a maximum of twice in regex; marked by <--HERE in m/%s/"
.PD
(F) The regular expression pattern had too many occurrences
of the specified modifier.  Remove the extraneous ones.
.ie n .IP "Regexp modifier ""%c"" may not appear after the ""\-"" in regex; marked by <\-\- \s-1HERE\s0 in m/%s/" 4
.el .IP "Regexp modifier ``%c'' may not appear after the ``\-'' in regex; marked by <\-\- \s-1HERE\s0 in m/%s/" 4
.IX Item "Regexp modifier %c may not appear after the - in regex; marked by <-- HERE in m/%s/"
(F) Turning off the given modifier has the side effect of turning on
another one.  Perl currently doesn't allow this.  Reword the regular
expression to use the modifier you want to turn on (and place it before
the minus), instead of the one you want to turn off.
.ie n .IP "Regexp modifier ""/%c"" may not appear twice" 4
.el .IP "Regexp modifier ``/%c'' may not appear twice" 4
.IX Item "Regexp modifier /%c may not appear twice"
.PD 0
.ie n .IP "Regexp modifier ""%c"" may not appear twice in regex; marked by <\-\- \s-1HERE\s0 in m/%s/" 4
.el .IP "Regexp modifier ``%c'' may not appear twice in regex; marked by <\-\- \s-1HERE\s0 in m/%s/" 4
.IX Item "Regexp modifier %c may not appear twice in regex; marked by <-- HERE in m/%s/"
.PD
(F) The regular expression pattern had too many occurrences
of the specified modifier.  Remove the extraneous ones.
.ie n .IP "Regexp modifiers ""/%c"" and ""/%c"" are mutually exclusive" 4
.el .IP "Regexp modifiers ``/%c'' and ``/%c'' are mutually exclusive" 4
.IX Item "Regexp modifiers /%c and /%c are mutually exclusive"
.PD 0
.ie n .IP "Regexp modifiers ""%c"" and ""%c"" are mutually exclusive in regex; marked by <\-\-\ \s-1HERE\s0 in m/%s/" 4
.el .IP "Regexp modifiers ``%c'' and ``%c'' are mutually exclusive in regex; marked by <\-\-\ \s-1HERE\s0 in m/%s/" 4
.IX Item "Regexp modifiers %c and %c are mutually exclusive in regex; marked by <--HERE in m/%s/"
.PD
(F) The regular expression pattern had more than one of these
mutually exclusive modifiers.  Retain only the modifier that is
supposed to be there.
.IP "Regexp out of space in regex m/%s/" 4
.IX Item "Regexp out of space in regex m/%s/"
(P) A \*(L"can't happen\*(R" error, because \fBsafemalloc()\fR should have caught it
earlier.
.IP "Repeated format line will never terminate (~~ and @#)" 4
.IX Item "Repeated format line will never terminate (~~ and @#)"
(F) Your format contains the ~~ repeat-until-blank sequence and a
numeric field that will never go blank so that the repetition never
terminates.  You might use ^# instead.  See perlform.
.IP "Replacement list is longer than search list" 4
.IX Item "Replacement list is longer than search list"
(W misc) You have used a replacement list that is longer than the
search list.  So the additional elements in the replacement list
are meaningless.
.IP "'(*%s' requires a terminating ':' in regex; marked by <\-\- \s-1HERE\s0 in m/%s/" 4
.IX Item "'(*%s' requires a terminating ':' in regex; marked by <-- HERE in m/%s/"
(F) You used a construct that needs a colon and pattern argument.
Supply these or check that you are using the right construct.
.IP "'%s' resolved to '\eo{%s}%d'" 4
.IX Item "'%s' resolved to 'o{%s}%d'"
(W misc, regexp)  You wrote something like \f(CW\*(C`\e08\*(C'\fR, or \f(CW\*(C`\e179\*(C'\fR in a
double-quotish string.  All but the last digit is treated as a single
character, specified in octal.  The last digit is the next character in
the string.  To tell Perl that this is indeed what you want, you can use
the \f(CW\*(C`\eo{ }\*(C'\fR syntax, or use exactly three digits to specify the octal
for the character.
.ie n .IP "Reversed %s= operator" 4
.el .IP "Reversed \f(CW%s\fR= operator" 4
.IX Item "Reversed %s= operator"
(W syntax) You wrote your assignment operator backwards.  The = must
always come last, to avoid ambiguity with subsequent unary operators.
.ie n .IP "\fBrewinddir()\fR attempted on invalid dirhandle %s" 4
.el .IP "\fBrewinddir()\fR attempted on invalid dirhandle \f(CW%s\fR" 4
.IX Item "rewinddir() attempted on invalid dirhandle %s"
(W io) The dirhandle you tried to do a \fBrewinddir()\fR on is either closed
or not really a dirhandle.  Check your control flow.
.ie n .IP "Scalars leaked: %d" 4
.el .IP "Scalars leaked: \f(CW%d\fR" 4
.IX Item "Scalars leaked: %d"
(S internal) Something went wrong in Perl's internal bookkeeping
of scalars: not all scalar variables were deallocated by the time
Perl exited.  What this usually indicates is a memory leak, which
is of course bad, especially if the Perl program is intended to be
long-running.
.IP "Scalar value @%s[%s] better written as $%s[%s]" 4
.IX Item "Scalar value @%s[%s] better written as $%s[%s]"
(W syntax) You've used an array slice (indicated by @) to select a
single element of an array.  Generally it's better to ask for a scalar
value (indicated by $).  The difference is that \f(CW$foo[&bar]\fR always
behaves like a scalar, both when assigning to it and when evaluating its
argument, while \f(CW@foo[&bar]\fR behaves like a list when you assign to it,
and provides a list context to its subscript, which can do weird things
if you're expecting only one subscript.
.Sp
On the other hand, if you were actually hoping to treat the array
element as a list, you need to look into how references work, because
Perl will not magically convert between scalars and lists for you.  See
perlref.
.IP "Scalar value @%s{%s} better written as $%s{%s}" 4
.IX Item "Scalar value @%s{%s} better written as $%s{%s}"
(W syntax) You've used a hash slice (indicated by @) to select a single
element of a hash.  Generally it's better to ask for a scalar value
(indicated by $).  The difference is that \f(CW$foo{&bar}\fR always behaves
like a scalar, both when assigning to it and when evaluating its
argument, while \f(CW@foo{&bar}\fR behaves like a list when you assign to it,
and provides a list context to its subscript, which can do weird things
if you're expecting only one subscript.
.Sp
On the other hand, if you were actually hoping to treat the hash element
as a list, you need to look into how references work, because Perl will
not magically convert between scalars and lists for you.  See
perlref.
.IP "Search pattern not terminated" 4
.IX Item "Search pattern not terminated"
(F) The lexer couldn't find the final delimiter of a // or m{}
construct.  Remember that bracketing delimiters count nesting level.
Missing the leading \f(CW\*(C`$\*(C'\fR from a variable \f(CW$m\fR may cause this error.
.Sp
Note that since Perl 5.10.0 a // can also be the \fIdefined-or\fR
construct, not just the empty search pattern.  Therefore code written
in Perl 5.10.0 or later that uses the // as the \fIdefined-or\fR can be
misparsed by pre\-5.10.0 Perls as a non-terminated search pattern.
.ie n .IP "\fBseekdir()\fR attempted on invalid dirhandle %s" 4
.el .IP "\fBseekdir()\fR attempted on invalid dirhandle \f(CW%s\fR" 4
.IX Item "seekdir() attempted on invalid dirhandle %s"
(W io) The dirhandle you are doing a \fBseekdir()\fR on is either closed or not
really a dirhandle.  Check your control flow.
.IP "%\fBsseek()\fR on unopened filehandle" 4
.IX Item "%sseek() on unopened filehandle"
(W unopened) You tried to use the \fBseek()\fR or \fBsysseek()\fR function on a
filehandle that was either never opened or has since been closed.
.IP "select not implemented" 4
.IX Item "select not implemented"
(F) This machine doesn't implement the \fBselect()\fR system call.
.IP "Self-ties of arrays and hashes are not supported" 4
.IX Item "Self-ties of arrays and hashes are not supported"
(F) Self-ties are of arrays and hashes are not supported in
the current implementation.
.IP "Semicolon seems to be missing" 4
.IX Item "Semicolon seems to be missing"
(W semicolon) A nearby syntax error was probably caused by a missing
semicolon, or possibly some other missing operator, such as a comma.
.IP "semi-panic: attempt to dup freed string" 4
.IX Item "semi-panic: attempt to dup freed string"
(S internal) The internal \fBnewSVsv()\fR routine was called to duplicate a
scalar that had previously been marked as free.
.IP "sem%s not implemented" 4
.IX Item "sem%s not implemented"
(F) You don't have System V semaphore \s-1IPC\s0 on your system.
.ie n .IP "\fBsend()\fR on closed socket %s" 4
.el .IP "\fBsend()\fR on closed socket \f(CW%s\fR" 4
.IX Item "send() on closed socket %s"
(W closed) The socket you're sending to got itself closed sometime
before now.  Check your control flow.
.ie n .IP "Sequence ""\ec{"" invalid" 4
.el .IP "Sequence ``\ec{'' invalid" 4
.IX Item "Sequence c{ invalid"
(F) These three characters may not appear in sequence in a
double-quotish context.  This message is raised only on non-ASCII
platforms (a different error message is output on \s-1ASCII\s0 ones).  If you
were intending to specify a control character with this sequence, you'll
have to use a different way to specify it.
.IP "Sequence (? incomplete in regex; marked by <\-\-\ \s-1HERE\s0 in m/%s/" 4
.IX Item "Sequence (? incomplete in regex; marked by <--HERE in m/%s/"
(F) A regular expression ended with an incomplete extension (?.  The
<\-\-\ \s-1HERE\s0 shows whereabouts in the regular expression the problem was
discovered.  See perlre.
.IP "Sequence (?%c...) not implemented in regex; marked by <\-\-\ \s-1HERE\s0 in m/%s/" 4
.IX Item "Sequence (?%c...) not implemented in regex; marked by <--HERE in m/%s/"
(F) A proposed regular expression extension has the character reserved
but has not yet been written.  The <\-\-\ \s-1HERE\s0 shows whereabouts in the
regular expression the problem was discovered.  See perlre.
.IP "Sequence (?%s...) not recognized in regex; marked by <\-\-\ \s-1HERE\s0 in m/%s/" 4
.IX Item "Sequence (?%s...) not recognized in regex; marked by <--HERE in m/%s/"
(F) You used a regular expression extension that doesn't make sense.
The <\-\-\ \s-1HERE\s0 shows whereabouts in the regular expression the problem was
discovered.  This may happen when using the \f(CW\*(C`(?^...)\*(C'\fR construct to tell
Perl to use the default regular expression modifiers, and you
redundantly specify a default modifier.  For other
causes, see perlre.
.IP "Sequence (?#... not terminated in regex m/%s/" 4
.IX Item "Sequence (?#... not terminated in regex m/%s/"
(F) A regular expression comment must be terminated by a closing
parenthesis.  Embedded parentheses aren't allowed.  See
perlre.
.IP "Sequence (?&... not terminated in regex; marked by <\-\-\ \s-1HERE\s0 in m/%s/" 4
.IX Item "Sequence (?&... not terminated in regex; marked by <--HERE in m/%s/"
(F) A named reference of the form \f(CW\*(C`(?&...)\*(C'\fR was missing the final
closing parenthesis after the name.  The <\-\-\ \s-1HERE\s0 shows whereabouts
in the regular expression the problem was discovered.
.IP "Sequence (?%c... not terminated in regex; marked by <\-\-\ \s-1HERE\s0 in m/%s/" 4
.IX Item "Sequence (?%c... not terminated in regex; marked by <--HERE in m/%s/"
(F) A named group of the form \f(CW\*(C`(?\*(Aq...\*(Aq)\*(C'\fR or \f(CW\*(C`(?<...>)\*(C'\fR was missing the final
closing quote or angle bracket.  The <\-\-\ \s-1HERE\s0 shows whereabouts in the
regular expression the problem was discovered.
.IP "Sequence (?(%c... not terminated in regex; marked by <\-\-\ \s-1HERE\s0 in m/%s/" 4
.IX Item "Sequence (?(%c... not terminated in regex; marked by <--HERE in m/%s/"
(F) A named reference of the form \f(CW\*(C`(?(\*(Aq...\*(Aq)...)\*(C'\fR or \f(CW\*(C`(?(<...>)...)\*(C'\fR was
missing the final closing quote or angle bracket after the name.  The
<\-\-\ \s-1HERE\s0 shows whereabouts in the regular expression the problem was
discovered.
.IP "Sequence (?... not terminated in regex; marked by <\-\-\ \s-1HERE\s0 in m/%s/" 4
.IX Item "Sequence (?... not terminated in regex; marked by <--HERE in m/%s/"
(F) There was no matching closing parenthesis for the '('.  The
<\-\-\ \s-1HERE\s0 shows whereabouts in the regular expression the problem was
discovered.
.IP "Sequence \e%s... not terminated in regex; marked by <\-\-\ \s-1HERE\s0 in m/%s/" 4
.IX Item "Sequence %s... not terminated in regex; marked by <--HERE in m/%s/"
(F) The regular expression expects a mandatory argument following the escape
sequence and this has been omitted or incorrectly written.
.IP "Sequence (?{...}) not terminated with ')'" 4
.IX Item "Sequence (?{...}) not terminated with ')'"
(F) The end of the perl code contained within the {...} must be
followed immediately by a ')'.
.IP "Sequence (?P>... not terminated in regex; marked by <\-\-\ \s-1HERE\s0 in m/%s/" 4
.IX Item "Sequence (?P>... not terminated in regex; marked by <--HERE in m/%s/"
(F) A named reference of the form \f(CW\*(C`(?P>...)\*(C'\fR was missing the final
closing parenthesis after the name.  The <\-\-\ \s-1HERE\s0 shows whereabouts
in the regular expression the problem was discovered.
.IP "Sequence (?P<... not terminated in regex; marked by <\-\-\ \s-1HERE\s0 in m/%s/" 4
.IX Item "Sequence (?P<... not terminated in regex; marked by <--HERE in m/%s/"
(F) A named group of the form \f(CW\*(C`(?P<...>\*(Aq)\*(C'\fR was missing the final
closing angle bracket.  The <\-\-\ \s-1HERE\s0 shows whereabouts in the
regular expression the problem was discovered.
.IP "Sequence ?P=... not terminated in regex; marked by <\-\-\ \s-1HERE\s0 in m/%s/" 4
.IX Item "Sequence ?P=... not terminated in regex; marked by <--HERE in m/%s/"
(F) A named reference of the form \f(CW\*(C`(?P=...)\*(C'\fR was missing the final
closing parenthesis after the name.  The <\-\-\ \s-1HERE\s0 shows whereabouts
in the regular expression the problem was discovered.
.IP "Sequence (?R) not terminated in regex m/%s/" 4
.IX Item "Sequence (?R) not terminated in regex m/%s/"
(F) An \f(CW\*(C`(?R)\*(C'\fR or \f(CW\*(C`(?0)\*(C'\fR sequence in a regular expression was missing the
final parenthesis.
.IP "500 Server error" 4
.IX Item "500 Server error"
(A) This is the error message generally seen in a browser window
when trying to run a \s-1CGI\s0 program (including \s-1SSI\s0) over the web.  The
actual error text varies widely from server to server.  The most
frequently-seen variants are \*(L"500 Server error\*(R", \*(L"Method (something)
not permitted\*(R", \*(L"Document contains no data\*(R", \*(L"Premature end of script
headers\*(R", and \*(L"Did not produce a valid header\*(R".
.Sp
\&\fBThis is a \s-1CGI\s0 error, not a Perl error\fR.
.Sp
You need to make sure your script is executable, is accessible by
the user \s-1CGI\s0 is running the script under (which is probably not the
user account you tested it under), does not rely on any environment
variables (like \s-1PATH\s0) from the user it isn't running under, and isn't
in a location where the \s-1CGI\s0 server can't find it, basically, more or
less.  Please see the following for more information:
.Sp
.Vb 3
\&        http://www.perl.org/CGI_MetaFAQ.html
\&        http://www.htmlhelp.org/faq/cgifaq.html
\&        http://www.w3.org/Security/Faq/
.Ve
.Sp
You should also look at perlfaq9.
.IP "\fBsetegid()\fR not implemented" 4
.IX Item "setegid() not implemented"
(F) You tried to assign to \f(CW$)\fR, and your operating system doesn't
support the \fBsetegid()\fR system call (or equivalent), or at least Configure
didn't think so.
.IP "\fBseteuid()\fR not implemented" 4
.IX Item "seteuid() not implemented"
(F) You tried to assign to \f(CW$>\fR, and your operating system doesn't
support the \fBseteuid()\fR system call (or equivalent), or at least Configure
didn't think so.
.IP "setpgrp can't take arguments" 4
.IX Item "setpgrp can't take arguments"
(F) Your system has the \fBsetpgrp()\fR from \s-1BSD 4.2,\s0 which takes no
arguments, unlike \s-1POSIX\s0 \fBsetpgid()\fR, which takes a process \s-1ID\s0 and process
group \s-1ID.\s0
.IP "\fBsetrgid()\fR not implemented" 4
.IX Item "setrgid() not implemented"
(F) You tried to assign to \f(CW$(\fR, and your operating system doesn't
support the \fBsetrgid()\fR system call (or equivalent), or at least Configure
didn't think so.
.IP "\fBsetruid()\fR not implemented" 4
.IX Item "setruid() not implemented"
(F) You tried to assign to \f(CW$<\fR, and your operating system doesn't
support the \fBsetruid()\fR system call (or equivalent), or at least Configure
didn't think so.
.ie n .IP "\fBsetsockopt()\fR on closed socket %s" 4
.el .IP "\fBsetsockopt()\fR on closed socket \f(CW%s\fR" 4
.IX Item "setsockopt() on closed socket %s"
(W closed) You tried to set a socket option on a closed socket.  Did you
forget to check the return value of your \fBsocket()\fR call?  See
\&\*(L"setsockopt\*(R" in perlfunc.
.ie n .IP "Setting $/ to a reference to %s is forbidden" 4
.el .IP "Setting $/ to a reference to \f(CW%s\fR is forbidden" 4
.IX Item "Setting $/ to a reference to %s is forbidden"
(F) You assigned a reference to a scalar to \f(CW$/\fR where the referenced item is
not a positive integer.  In older perls this \fBappeared\fR to work the same as
setting it to \f(CW\*(C`undef\*(C'\fR but was in fact internally different, less efficient
and with very bad luck could have resulted in your file being split by a
stringified form of the reference.
.Sp
In Perl 5.20.0 this was changed so that it would be \fBexactly\fR the same as
setting \f(CW$/\fR to undef, with the exception that this warning would be thrown.
.Sp
You are recommended to change your code to set \f(CW$/\fR to \f(CW\*(C`undef\*(C'\fR explicitly if
you wish to slurp the file.  As of Perl 5.28 assigning \f(CW$/\fR to a reference
to an integer which isn't positive is a fatal error.
.ie n .IP "Setting $/ to %s reference is forbidden" 4
.el .IP "Setting $/ to \f(CW%s\fR reference is forbidden" 4
.IX Item "Setting $/ to %s reference is forbidden"
(F) You tried to assign a reference to a non integer to \f(CW$/\fR.  In older
Perls this would have behaved similarly to setting it to a reference to
a positive integer, where the integer was the address of the reference.
As of Perl 5.20.0 this is a fatal error, to allow future versions of Perl
to use non-integer refs for more interesting purposes.
.IP "shm%s not implemented" 4
.IX Item "shm%s not implemented"
(F) You don't have System V shared memory \s-1IPC\s0 on your system.
.IP "!=~ should be !~" 4
.IX Item "!=~ should be !~"
(W syntax) The non-matching operator is !~, not !=~.  !=~ will be
interpreted as the != (numeric not equal) and ~ (1's complement)
operators: probably not what you intended.
.ie n .IP "/%s/ should probably be written as ""%s""" 4
.el .IP "/%s/ should probably be written as ``%s''" 4
.IX Item "/%s/ should probably be written as %s"
(W syntax) You have used a pattern where Perl expected to find a string,
as in the first argument to \f(CW\*(C`join\*(C'\fR.  Perl will treat the true or false
result of matching the pattern against \f(CW$_\fR as the string, which is
probably not what you had in mind.
.ie n .IP "\fBshutdown()\fR on closed socket %s" 4
.el .IP "\fBshutdown()\fR on closed socket \f(CW%s\fR" 4
.IX Item "shutdown() on closed socket %s"
(W closed) You tried to do a shutdown on a closed socket.  Seems a bit
superfluous.
.ie n .IP "SIG%s handler ""%s"" not defined" 4
.el .IP "SIG%s handler ``%s'' not defined" 4
.IX Item "SIG%s handler %s not defined"
(W signal) The signal handler named in \f(CW%SIG\fR doesn't, in fact, exist.
Perhaps you put it into the wrong package?
.ie n .IP "Slab leaked from cv %p" 4
.el .IP "Slab leaked from cv \f(CW%p\fR" 4
.IX Item "Slab leaked from cv %p"
(S) If you see this message, then something is seriously wrong with the
internal bookkeeping of op trees.  An op tree needed to be freed after
a compilation error, but could not be found, so it was leaked instead.
.IP "sleep(%u) too large" 4
.IX Item "sleep(%u) too large"
(W overflow) You called \f(CW\*(C`sleep\*(C'\fR with a number that was larger than
it can reliably handle and \f(CW\*(C`sleep\*(C'\fR probably slept for less time than
requested.
.IP "Slurpy parameter not last" 4
.IX Item "Slurpy parameter not last"
(F) In a subroutine signature, you put something after a slurpy (array or
hash) parameter.  The slurpy parameter takes all the available arguments,
so there can't be any left to fill later parameters.
.IP "Smart matching a non-overloaded object breaks encapsulation" 4
.IX Item "Smart matching a non-overloaded object breaks encapsulation"
(F) You should not use the \f(CW\*(C`~~\*(C'\fR operator on an object that does not
overload it: Perl refuses to use the object's underlying structure
for the smart match.
.IP "Smartmatch is experimental" 4
.IX Item "Smartmatch is experimental"
(S experimental::smartmatch) This warning is emitted if you
use the smartmatch (\f(CW\*(C`~~\*(C'\fR) operator.  This is currently an experimental
feature, and its details are subject to change in future releases of
Perl.  Particularly, its current behavior is noticed for being
unnecessarily complex and unintuitive, and is very likely to be
overhauled.
.IP "Sorry, hash keys must be smaller than 2**31 bytes" 4
.IX Item "Sorry, hash keys must be smaller than 2**31 bytes"
(F) You tried to create a hash containing a very large key, where \*(L"very
large\*(R" means that it needs at least 2 gigabytes to store. Unfortunately,
Perl doesn't yet handle such large hash keys. You should
reconsider your design to avoid hashing such a long string directly.
.IP "sort is now a reserved word" 4
.IX Item "sort is now a reserved word"
(F) An ancient error message that almost nobody ever runs into anymore.
But before sort was a keyword, people sometimes used it as a filehandle.
.IP "Source filters apply only to byte streams" 4
.IX Item "Source filters apply only to byte streams"
(F) You tried to activate a source filter (usually by loading a
source filter module) within a string passed to \f(CW\*(C`eval\*(C'\fR.  This is
not permitted under the \f(CW\*(C`unicode_eval\*(C'\fR feature.  Consider using
\&\f(CW\*(C`evalbytes\*(C'\fR instead.  See feature.
.IP "\fBsplice()\fR offset past end of array" 4
.IX Item "splice() offset past end of array"
(W misc) You attempted to specify an offset that was past the end of
the array passed to \fBsplice()\fR.  Splicing will instead commence at the
end of the array, rather than past it.  If this isn't what you want,
try explicitly pre-extending the array by assigning $#array = \f(CW$offset\fR.
See \*(L"splice\*(R" in perlfunc.
.IP "Split loop" 4
.IX Item "Split loop"
(P) The split was looping infinitely.  (Obviously, a split shouldn't
iterate more times than there are characters of input, which is what
happened.)  See \*(L"split\*(R" in perlfunc.
.IP "Statement unlikely to be reached" 4
.IX Item "Statement unlikely to be reached"
(W exec) You did an \fBexec()\fR with some statement after it other than a
\&\fBdie()\fR.  This is almost always an error, because \fBexec()\fR never returns
unless there was a failure.  You probably wanted to use \fBsystem()\fR
instead, which does return.  To suppress this warning, put the \fBexec()\fR in
a block by itself.
.ie n .IP """state"" subroutine %s can't be in a package" 4
.el .IP "``state'' subroutine \f(CW%s\fR can't be in a package" 4
.IX Item "state subroutine %s can't be in a package"
(F) Lexically scoped subroutines aren't in a package, so it doesn't make
sense to try to declare one with a package qualifier on the front.
.ie n .IP """state %s"" used in sort comparison" 4
.el .IP "``state \f(CW%s\fR'' used in sort comparison" 4
.IX Item "state %s used in sort comparison"
(W syntax) The package variables \f(CW$a\fR and \f(CW$b\fR are used for sort comparisons.
You used \f(CW$a\fR or \f(CW$b\fR in as an operand to the \f(CW\*(C`<=>\*(C'\fR or \f(CW\*(C`cmp\*(C'\fR operator inside a
sort comparison block, and the variable had earlier been declared as a
lexical variable.  Either qualify the sort variable with the package
name, or rename the lexical variable.
.ie n .IP """state"" variable %s can't be in a package" 4
.el .IP "``state'' variable \f(CW%s\fR can't be in a package" 4
.IX Item "state variable %s can't be in a package"
(F) Lexically scoped variables aren't in a package, so it doesn't make
sense to try to declare one with a package qualifier on the front.  Use
\&\fBlocal()\fR if you want to localize a package variable.
.ie n .IP "\fBstat()\fR on unopened filehandle %s" 4
.el .IP "\fBstat()\fR on unopened filehandle \f(CW%s\fR" 4
.IX Item "stat() on unopened filehandle %s"
(W unopened) You tried to use the \fBstat()\fR function on a filehandle that
was either never opened or has since been closed.
.IP "Strings with code points over 0xFF may not be mapped into in-memory file handles" 4
.IX Item "Strings with code points over 0xFF may not be mapped into in-memory file handles"
(W utf8) You tried to open a reference to a scalar for read or append
where the scalar contained code points over 0xFF.  In-memory files
model on-disk files and can only contain bytes.
.ie n .IP "Stub found while resolving method ""%s"" overloading ""%s"" in package ""%s""" 4
.el .IP "Stub found while resolving method ``%s'' overloading ``%s'' in package ``%s''" 4
.IX Item "Stub found while resolving method %s overloading %s in package %s"
(P) Overloading resolution over \f(CW@ISA\fR tree may be broken by importation
stubs.  Stubs should never be implicitly created, but explicit calls to
\&\f(CW\*(C`can\*(C'\fR may break this.
.IP "Subroutine attributes must come before the signature" 4
.IX Item "Subroutine attributes must come before the signature"
(F) When subroutine signatures are enabled, any subroutine attributes must
come before the signature. Note that this order was the opposite in
versions 5.22..5.26. So:
.Sp
.Vb 2
\&    sub foo :lvalue ($a, $b) { ... }  # 5.20 and 5.28 +
\&    sub foo ($a, $b) :lvalue { ... }  # 5.22 .. 5.26
.Ve
.ie n .IP "Subroutine ""&%s"" is not available" 4
.el .IP "Subroutine ``&%s'' is not available" 4
.IX Item "Subroutine &%s is not available"
(W closure) During compilation, an inner named subroutine or eval is
attempting to capture an outer lexical subroutine that is not currently
available.  This can happen for one of two reasons.  First, the lexical
subroutine may be declared in an outer anonymous subroutine that has
not yet been created.  (Remember that named subs are created at compile
time, while anonymous subs are created at run-time.)  For example,
.Sp
.Vb 1
\&    sub { my sub a {...} sub f { \e&a } }
.Ve
.Sp
At the time that f is created, it can't capture the current \*(L"a\*(R" sub,
since the anonymous subroutine hasn't been created yet.  Conversely, the
following won't give a warning since the anonymous subroutine has by now
been created and is live:
.Sp
.Vb 1
\&    sub { my sub a {...} eval \*(Aqsub f { \e&a }\*(Aq }\->();
.Ve
.Sp
The second situation is caused by an eval accessing a lexical subroutine
that has gone out of scope, for example,
.Sp
.Vb 5
\&    sub f {
\&        my sub a {...}
\&        sub { eval \*(Aq\e&a\*(Aq }
\&    }
\&    f()\->();
.Ve
.Sp
Here, when the '\e&a' in the eval is being compiled, f() is not currently
being executed, so its &a is not available for capture.
.ie n .IP """%s"" subroutine &%s masks earlier declaration in same %s" 4
.el .IP "``%s'' subroutine &%s masks earlier declaration in same \f(CW%s\fR" 4
.IX Item "%s subroutine &%s masks earlier declaration in same %s"
(W shadow) A \*(L"my\*(R" or \*(L"state\*(R" subroutine has been redeclared in the
current scope or statement, effectively eliminating all access to
the previous instance.  This is almost always a typographical error.
Note that the earlier subroutine will still exist until the end of
the scope or until all closure references to it are destroyed.
.ie n .IP "Subroutine %s redefined" 4
.el .IP "Subroutine \f(CW%s\fR redefined" 4
.IX Item "Subroutine %s redefined"
(W redefine) You redefined a subroutine.  To suppress this warning, say
.Sp
.Vb 4
\&    {
\&        no warnings \*(Aqredefine\*(Aq;
\&        eval "sub name { ... }";
\&    }
.Ve
.ie n .IP "Subroutine ""%s"" will not stay shared" 4
.el .IP "Subroutine ``%s'' will not stay shared" 4
.IX Item "Subroutine %s will not stay shared"
(W closure) An inner (nested) \fInamed\fR subroutine is referencing a \*(L"my\*(R"
subroutine defined in an outer named subroutine.
.Sp
When the inner subroutine is called, it will see the value of the outer
subroutine's lexical subroutine as it was before and during the *first*
call to the outer subroutine; in this case, after the first call to the
outer subroutine is complete, the inner and outer subroutines will no
longer share a common value for the lexical subroutine.  In other words,
it will no longer be shared.  This will especially make a difference
if the lexical subroutines accesses lexical variables declared in its
surrounding scope.
.Sp
This problem can usually be solved by making the inner subroutine
anonymous, using the \f(CW\*(C`sub {}\*(C'\fR syntax.  When inner anonymous subs that
reference lexical subroutines in outer subroutines are created, they
are automatically rebound to the current values of such lexical subs.
.IP "Substitution loop" 4
.IX Item "Substitution loop"
(P) The substitution was looping infinitely.  (Obviously, a substitution
shouldn't iterate more times than there are characters of input, which
is what happened.)  See the discussion of substitution in
\&\*(L"Regexp Quote-Like Operators\*(R" in perlop.
.IP "Substitution pattern not terminated" 4
.IX Item "Substitution pattern not terminated"
(F) The lexer couldn't find the interior delimiter of an s/// or s{}{}
construct.  Remember that bracketing delimiters count nesting level.
Missing the leading \f(CW\*(C`$\*(C'\fR from variable \f(CW$s\fR may cause this error.
.IP "Substitution replacement not terminated" 4
.IX Item "Substitution replacement not terminated"
(F) The lexer couldn't find the final delimiter of an s/// or s{}{}
construct.  Remember that bracketing delimiters count nesting level.
Missing the leading \f(CW\*(C`$\*(C'\fR from variable \f(CW$s\fR may cause this error.
.IP "substr outside of string" 4
.IX Item "substr outside of string"
(W substr)(F) You tried to reference a \fBsubstr()\fR that pointed outside of
a string.  That is, the absolute value of the offset was larger than the
length of the string.  See \*(L"substr\*(R" in perlfunc.  This warning is fatal if
substr is used in an lvalue context (as the left hand side of an
assignment or as a subroutine argument for example).
.ie n .IP "sv_upgrade from type %d down to type %d" 4
.el .IP "sv_upgrade from type \f(CW%d\fR down to type \f(CW%d\fR" 4
.IX Item "sv_upgrade from type %d down to type %d"
(P) Perl tried to force the upgrade of an \s-1SV\s0 to a type which was actually
inferior to its current type.
.IP "\s-1SWASHNEW\s0 didn't return an \s-1HV\s0 ref" 4
.IX Item "SWASHNEW didn't return an HV ref"
(P) Something went wrong internally when Perl was trying to look up
Unicode characters.
.IP "Switch (?(condition)... contains too many branches in regex; marked by <\-\-\ \s-1HERE\s0 in m/%s/" 4
.IX Item "Switch (?(condition)... contains too many branches in regex; marked by <--HERE in m/%s/"
(F) A (?(condition)if\-clause|else\-clause) construct can have at most
two branches (the if-clause and the else-clause).  If you want one or
both to contain alternation, such as using \f(CW\*(C`this|that|other\*(C'\fR, enclose
it in clustering parentheses:
.Sp
.Vb 1
\&    (?(condition)(?:this|that|other)|else\-clause)
.Ve
.Sp
The <\-\-\ \s-1HERE\s0 shows whereabouts in the regular expression the problem
was discovered.  See perlre.
.IP "Switch condition not recognized in regex; marked by <\-\-\ \s-1HERE\s0 in m/%s/" 4
.IX Item "Switch condition not recognized in regex; marked by <--HERE in m/%s/"
(F) The condition part of a (?(condition)if\-clause|else\-clause) construct
is not known.  The condition must be one of the following:
.Sp
.Vb 9
\& (1) (2) ...        true if 1st, 2nd, etc., capture matched
\& (<NAME>) (\*(AqNAME\*(Aq)  true if named capture matched
\& (?=...) (?<=...)   true if subpattern matches
\& (?!...) (?<!...)   true if subpattern fails to match
\& (?{ CODE })        true if code returns a true value
\& (R)                true if evaluating inside recursion
\& (R1) (R2) ...      true if directly inside capture group 1, 2, etc.
\& (R&NAME)           true if directly inside named capture
\& (DEFINE)           always false; for defining named subpatterns
.Ve
.Sp
The <\-\-\ \s-1HERE\s0 shows whereabouts in the regular expression the problem was
discovered.  See perlre.
.IP "Switch (?(condition)... not terminated in regex; marked by <\-\-\ \s-1HERE\s0 in m/%s/" 4
.IX Item "Switch (?(condition)... not terminated in regex; marked by <--HERE in m/%s/"
(F) You omitted to close a (?(condition)...) block somewhere
in the pattern.  Add a closing parenthesis in the appropriate
position.  See perlre.
.ie n .IP "switching effective %s is not implemented" 4
.el .IP "switching effective \f(CW%s\fR is not implemented" 4
.IX Item "switching effective %s is not implemented"
(F) While under the \f(CW\*(C`use filetest\*(C'\fR pragma, we cannot switch the real
and effective uids or gids.
.IP "syntax error" 4
.IX Item "syntax error"
(F) Probably means you had a syntax error.  Common reasons include:
.Sp
.Vb 6
\&    A keyword is misspelled.
\&    A semicolon is missing.
\&    A comma is missing.
\&    An opening or closing parenthesis is missing.
\&    An opening or closing brace is missing.
\&    A closing quote is missing.
.Ve
.Sp
Often there will be another error message associated with the syntax
error giving more information.  (Sometimes it helps to turn on \fB\-w\fR.)
The error message itself often tells you where it was in the line when
it decided to give up.  Sometimes the actual error is several tokens
before this, because Perl is good at understanding random input.
Occasionally the line number may be misleading, and once in a blue moon
the only way to figure out what's triggering the error is to call
\&\f(CW\*(C`perl \-c\*(C'\fR repeatedly, chopping away half the program each time to see
if the error went away.  Sort of the cybernetic version of 20\ questions.
.ie n .IP "syntax error at line %d: '%s' unexpected" 4
.el .IP "syntax error at line \f(CW%d:\fR '%s' unexpected" 4
.IX Item "syntax error at line %d: '%s' unexpected"
(A) You've accidentally run your script through the Bourne shell instead
of Perl.  Check the #! line, or manually feed your script into Perl
yourself.
.ie n .IP "syntax error in file %s at line %d, next 2 tokens ""%s""" 4
.el .IP "syntax error in file \f(CW%s\fR at line \f(CW%d\fR, next 2 tokens ``%s''" 4
.IX Item "syntax error in file %s at line %d, next 2 tokens %s"
(F) This error is likely to occur if you run a perl5 script through
a perl4 interpreter, especially if the next 2 tokens are \*(L"use strict\*(R"
or \*(L"my \f(CW$var\fR\*(R" or \*(L"our \f(CW$var\fR\*(R".
.IP "Syntax error in (?[...]) in regex; marked by <\-\- \s-1HERE\s0 in m/%s/" 4
.IX Item "Syntax error in (?[...]) in regex; marked by <-- HERE in m/%s/"
(F) Perl could not figure out what you meant inside this construct; this
notifies you that it is giving up trying.
.ie n .IP "%s syntax \s-1OK\s0" 4
.el .IP "\f(CW%s\fR syntax \s-1OK\s0" 4
.IX Item "%s syntax OK"
(F) The final summary message when a \f(CW\*(C`perl \-c\*(C'\fR succeeds.
.ie n .IP "\fBsysread()\fR on closed filehandle %s" 4
.el .IP "\fBsysread()\fR on closed filehandle \f(CW%s\fR" 4
.IX Item "sysread() on closed filehandle %s"
(W closed) You tried to read from a closed filehandle.
.ie n .IP "\fBsysread()\fR on unopened filehandle %s" 4
.el .IP "\fBsysread()\fR on unopened filehandle \f(CW%s\fR" 4
.IX Item "sysread() on unopened filehandle %s"
(W unopened) You tried to read from a filehandle that was never opened.
.ie n .IP "System V %s is not implemented on this machine" 4
.el .IP "System V \f(CW%s\fR is not implemented on this machine" 4
.IX Item "System V %s is not implemented on this machine"
(F) You tried to do something with a function beginning with \*(L"sem\*(R",
\&\*(L"shm\*(R", or \*(L"msg\*(R" but that System V \s-1IPC\s0 is not implemented in your
machine.  In some machines the functionality can exist but be
unconfigured.  Consult your system support.
.ie n .IP "\fBsyswrite()\fR on closed filehandle %s" 4
.el .IP "\fBsyswrite()\fR on closed filehandle \f(CW%s\fR" 4
.IX Item "syswrite() on closed filehandle %s"
(W closed) The filehandle you're writing to got itself closed sometime
before now.  Check your control flow.
.ie n .IP """\-T"" and ""\-B"" not implemented on filehandles" 4
.el .IP "\f(CW\-T\fR and \f(CW\-B\fR not implemented on filehandles" 4
.IX Item "-T and -B not implemented on filehandles"
(F) Perl can't peek at the stdio buffer of filehandles when it doesn't
know about your kind of stdio.  You'll have to use a filename instead.
.IP "Target of goto is too deeply nested" 4
.IX Item "Target of goto is too deeply nested"
(F) You tried to use \f(CW\*(C`goto\*(C'\fR to reach a label that was too deeply nested
for Perl to reach.  Perl is doing you a favor by refusing.
.ie n .IP "\fBtelldir()\fR attempted on invalid dirhandle %s" 4
.el .IP "\fBtelldir()\fR attempted on invalid dirhandle \f(CW%s\fR" 4
.IX Item "telldir() attempted on invalid dirhandle %s"
(W io) The dirhandle you tried to \fBtelldir()\fR is either closed or not really
a dirhandle.  Check your control flow.
.IP "\fBtell()\fR on unopened filehandle" 4
.IX Item "tell() on unopened filehandle"
(W unopened) You tried to use the \fBtell()\fR function on a filehandle that
was either never opened or has since been closed.
.IP "The alpha_assertions feature is experimental" 4
.IX Item "The alpha_assertions feature is experimental"
(S experimental::alpha_assertions) This feature is experimental
and its behavior may change in any future release of perl.  See
\&\*(L"Extended Patterns\*(R" in perlre.
.IP "The \fBcrypt()\fR function is unimplemented due to excessive paranoia." 4
.IX Item "The crypt() function is unimplemented due to excessive paranoia."
(F) Configure couldn't find the \fBcrypt()\fR function on your machine,
probably because your vendor didn't supply it, probably because they
think the U.S. Government thinks it's a secret, or at least that they
will continue to pretend that it is.  And if you quote me on that, I
will deny it.
.IP "The experimental declared_refs feature is not enabled" 4
.IX Item "The experimental declared_refs feature is not enabled"
(F) To declare references to variables, as in \f(CW\*(C`my \e%x\*(C'\fR, you must first enable
the feature:
.Sp
.Vb 2
\&    no warnings "experimental::declared_refs";
\&    use feature "declared_refs";
.Ve
.ie n .IP "The %s function is unimplemented" 4
.el .IP "The \f(CW%s\fR function is unimplemented" 4
.IX Item "The %s function is unimplemented"
(F) The function indicated isn't implemented on this architecture,
according to the probings of Configure.
.IP "The private_use feature is experimental" 4
.IX Item "The private_use feature is experimental"
(S experimental::private_use) This feature is actually a hook for future
use.
.IP "The regex_sets feature is experimental" 4
.IX Item "The regex_sets feature is experimental"
(S experimental::regex_sets) This warning is emitted if you
use the syntax \f(CW\*(C`(?[\ \ \ ])\*(C'\fR in a regular expression.
The details of this feature are subject to change.
If you want to use it, but know that in doing so you
are taking the risk of using an experimental feature which may
change in a future Perl version, you can do this to silence the
warning:
.Sp
.Vb 1
\&    no warnings "experimental::regex_sets";
.Ve
.IP "The script_run feature is experimental" 4
.IX Item "The script_run feature is experimental"
(S experimental::script_run) This feature is experimental
and its behavior may in any future release of perl.  See
\&\*(L"Script Runs\*(R" in perlre.
.IP "The signatures feature is experimental" 4
.IX Item "The signatures feature is experimental"
(S experimental::signatures) This warning is emitted if you unwrap a
subroutine's arguments using a signature.  Simply suppress the warning
if you want to use the feature, but know that in doing so you are taking
the risk of using an experimental feature which may change or be removed
in a future Perl version:
.Sp
.Vb 3
\&    no warnings "experimental::signatures";
\&    use feature "signatures";
\&    sub foo ($left, $right) { ... }
.Ve
.ie n .IP "The stat preceding %s wasn't an lstat" 4
.el .IP "The stat preceding \f(CW%s\fR wasn't an lstat" 4
.IX Item "The stat preceding %s wasn't an lstat"
(F) It makes no sense to test the current stat buffer for symbolic
linkhood if the last stat that wrote to the stat buffer already went
past the symlink to get to the real file.  Use an actual filename
instead.
.IP "The Unicode property wildcards feature is experimental" 4
.IX Item "The Unicode property wildcards feature is experimental"
(S experimental::uniprop_wildcards) This feature is experimental
and its behavior may in any future release of perl.  See
\&\*(L"Wildcards in Property Values\*(R" in perlunicode.
.IP "The 'unique' attribute may only be applied to 'our' variables" 4
.IX Item "The 'unique' attribute may only be applied to 'our' variables"
(F) This attribute was never supported on \f(CW\*(C`my\*(C'\fR or \f(CW\*(C`sub\*(C'\fR declarations.
.IP "This Perl can't reset \s-1CRTL\s0 environ elements (%s)" 4
.IX Item "This Perl can't reset CRTL environ elements (%s)"
.PD 0
.IP "This Perl can't set \s-1CRTL\s0 environ elements (%s=%s)" 4
.IX Item "This Perl can't set CRTL environ elements (%s=%s)"
.PD
(W internal) Warnings peculiar to \s-1VMS.\s0  You tried to change or delete an
element of the \s-1CRTL\s0's internal environ array, but your copy of Perl
wasn't built with a \s-1CRTL\s0 that contained the \fBsetenv()\fR function.  You'll
need to rebuild Perl with a \s-1CRTL\s0 that does, or redefine
\&\fI\s-1PERL_ENV_TABLES\s0\fR (see perlvms) so that the environ array isn't the
target of the change to
\&\f(CW%ENV\fR which produced the warning.
.IP "This Perl has not been built with support for randomized hash key traversal but something called \fBPerl_hv_rand_set()\fR." 4
.IX Item "This Perl has not been built with support for randomized hash key traversal but something called Perl_hv_rand_set()."
(F) Something has attempted to use an internal \s-1API\s0 call which
depends on Perl being compiled with the default support for randomized hash
key traversal, but this Perl has been compiled without it.  You should
report this warning to the relevant upstream party, or recompile perl
with default options.
.IP "This use of \fBmy()\fR in false conditional is no longer allowed" 4
.IX Item "This use of my() in false conditional is no longer allowed"
(F) You used a declaration similar to \f(CW\*(C`my $x if 0\*(C'\fR.  There
has been a long-standing bug in Perl that causes a lexical variable
not to be cleared at scope exit when its declaration includes a false
conditional.  Some people have exploited this bug to achieve a kind of
static variable.  Since we intend to fix this bug, we don't want people
relying on this behavior.  You can achieve a similar static effect by
declaring the variable in a separate block outside the function, eg
.Sp
.Vb 1
\&    sub f { my $x if 0; return $x++ }
.Ve
.Sp
becomes
.Sp
.Vb 1
\&    { my $x; sub f { return $x++ } }
.Ve
.Sp
Beginning with perl 5.10.0, you can also use \f(CW\*(C`state\*(C'\fR variables to have
lexicals that are initialized only once (see feature):
.Sp
.Vb 1
\&    sub f { state $x; return $x++ }
.Ve
.Sp
This use of \f(CW\*(C`my()\*(C'\fR in a false conditional was deprecated beginning in
Perl 5.10 and became a fatal error in Perl 5.30.
.IP "times not implemented" 4
.IX Item "times not implemented"
(F) Your version of the C library apparently doesn't do \fBtimes()\fR.  I
suspect you're not running on Unix.
.ie n .IP """\-T"" is on the #! line, it must also be used on the command line" 4
.el .IP "``\-T'' is on the #! line, it must also be used on the command line" 4
.IX Item "-T is on the #! line, it must also be used on the command line"
(X) The #! line (or local equivalent) in a Perl script contains
the \fB\-T\fR option (or the \fB\-t\fR option), but Perl was not invoked with
\&\fB\-T\fR in its command line.  This is an error because, by the time
Perl discovers a \fB\-T\fR in a script, it's too late to properly taint
everything from the environment.  So Perl gives up.
.Sp
If the Perl script is being executed as a command using the #!
mechanism (or its local equivalent), this error can usually be
fixed by editing the #! line so that the \fB\-%c\fR option is a part of
Perl's first argument: e.g. change \f(CW\*(C`perl \-n \-%c\*(C'\fR to \f(CW\*(C`perl \-%c \-n\*(C'\fR.
.Sp
If the Perl script is being executed as \f(CW\*(C`perl scriptname\*(C'\fR, then the
\&\fB\-%c\fR option must appear on the command line: \f(CW\*(C`perl \-%c scriptname\*(C'\fR.
.IP "To%s: illegal mapping '%s'" 4
.IX Item "To%s: illegal mapping '%s'"
(F) You tried to define a customized To-mapping for \fBlc()\fR, lcfirst,
\&\fBuc()\fR, or \fBucfirst()\fR (or their string-inlined versions), but you
specified an illegal mapping.
See \*(L"User-Defined Character Properties\*(R" in perlunicode.
.IP "Too deeply nested ()\-groups" 4
.IX Item "Too deeply nested ()-groups"
(F) Your template contains ()\-groups with a ridiculously deep nesting level.
.IP "Too few args to syscall" 4
.IX Item "Too few args to syscall"
(F) There has to be at least one argument to \fBsyscall()\fR to specify the
system call to call, silly dilly.
.IP "Too few arguments for subroutine '%s'" 4
.IX Item "Too few arguments for subroutine '%s'"
(F) A subroutine using a signature fewer arguments than required by the
signature.  The caller of the subroutine is presumably at fault.
.Sp
The message attempts to include the name of the called subroutine.  If
the subroutine has been aliased, the subroutine's original name will be
shown, regardless of what name the caller used.
.ie n .IP "Too late for ""\-%s"" option" 4
.el .IP "Too late for ``\-%s'' option" 4
.IX Item "Too late for -%s option"
(X) The #! line (or local equivalent) in a Perl script contains the
\&\fB\-M\fR, \fB\-m\fR or \fB\-C\fR option.
.Sp
In the case of \fB\-M\fR and \fB\-m\fR, this is an error because those options
are not intended for use inside scripts.  Use the \f(CW\*(C`use\*(C'\fR pragma instead.
.Sp
The \fB\-C\fR option only works if it is specified on the command line as
well (with the same sequence of letters or numbers following).  Either
specify this option on the command line, or, if your system supports
it, make your script executable and run it directly instead of passing
it to perl.
.ie n .IP "Too late to run %s block" 4
.el .IP "Too late to run \f(CW%s\fR block" 4
.IX Item "Too late to run %s block"
(W void) A \s-1CHECK\s0 or \s-1INIT\s0 block is being defined during run time proper,
when the opportunity to run them has already passed.  Perhaps you are
loading a file with \f(CW\*(C`require\*(C'\fR or \f(CW\*(C`do\*(C'\fR when you should be using \f(CW\*(C`use\*(C'\fR
instead.  Or perhaps you should put the \f(CW\*(C`require\*(C'\fR or \f(CW\*(C`do\*(C'\fR inside a
\&\s-1BEGIN\s0 block.
.IP "Too many args to syscall" 4
.IX Item "Too many args to syscall"
(F) Perl supports a maximum of only 14 args to \fBsyscall()\fR.
.ie n .IP "Too many arguments for %s" 4
.el .IP "Too many arguments for \f(CW%s\fR" 4
.IX Item "Too many arguments for %s"
(F) The function requires fewer arguments than you specified.
.IP "Too many arguments for subroutine '%s'" 4
.IX Item "Too many arguments for subroutine '%s'"
(F) A subroutine using a signature received more arguments than permitted
by the signature.  The caller of the subroutine is presumably at fault.
.Sp
The message attempts to include the name of the called subroutine. If the
subroutine has been aliased, the subroutine's original name will be shown,
regardless of what name the caller used.
.IP "Too many nested open parens in regex; marked by <\-\- \s-1HERE\s0 in m/%s/" 4
.IX Item "Too many nested open parens in regex; marked by <-- HERE in m/%s/"
(F) You have exceeded the number of open \f(CW"("\fR parentheses that haven't
been matched by corresponding closing ones.  This limit prevents eating
up too much memory.  It is initially set to 1000, but may be changed by
setting \f(CW\*(C`${^RE_COMPILE_RECURSION_LIMIT}\*(C'\fR to some other value.  This may
need to be done in a \s-1BEGIN\s0 block before the regular expression pattern
is compiled.
.IP "Too many )'s" 4
.IX Item "Too many )'s"
(A) You've accidentally run your script through \fBcsh\fR instead of Perl.
Check the #! line, or manually feed your script into Perl yourself.
.IP "Too many ('s" 4
.IX Item "Too many ('s"
(A) You've accidentally run your script through \fBcsh\fR instead of Perl.
Check the #! line, or manually feed your script into Perl yourself.
.IP "Trailing \e in regex m/%s/" 4
.IX Item "Trailing in regex m/%s/"
(F) The regular expression ends with an unbackslashed backslash.
Backslash it.   See perlre.
.IP "Transliteration pattern not terminated" 4
.IX Item "Transliteration pattern not terminated"
(F) The lexer couldn't find the interior delimiter of a tr/// or tr[][]
or y/// or y[][] construct.  Missing the leading \f(CW\*(C`$\*(C'\fR from variables
\&\f(CW$tr\fR or \f(CW$y\fR may cause this error.
.IP "Transliteration replacement not terminated" 4
.IX Item "Transliteration replacement not terminated"
(F) The lexer couldn't find the final delimiter of a tr///, tr[][],
y/// or y[][] construct.
.IP "'%s' trapped by operation mask" 4
.IX Item "'%s' trapped by operation mask"
(F) You tried to use an operator from a Safe compartment in which it's
disallowed.  See Safe.
.IP "truncate not implemented" 4
.IX Item "truncate not implemented"
(F) Your machine doesn't implement a file truncation mechanism that
Configure knows about.
.ie n .IP "Type of arg %d to &CORE::%s must be %s" 4
.el .IP "Type of arg \f(CW%d\fR to &CORE::%s must be \f(CW%s\fR" 4
.IX Item "Type of arg %d to &CORE::%s must be %s"
(F) The subroutine in question in the \s-1CORE\s0 package requires its argument
to be a hard reference to data of the specified type.  Overloading is
ignored, so a reference to an object that is not the specified type, but
nonetheless has overloading to handle it, will still not be accepted.
.ie n .IP "Type of arg %d to %s must be %s (not %s)" 4
.el .IP "Type of arg \f(CW%d\fR to \f(CW%s\fR must be \f(CW%s\fR (not \f(CW%s\fR)" 4
.IX Item "Type of arg %d to %s must be %s (not %s)"
(F) This function requires the argument in that position to be of a
certain type.  Arrays must be \f(CW@NAME\fR or \f(CW\*(C`@{EXPR}\*(C'\fR.  Hashes must be
\&\f(CW%NAME\fR or \f(CW\*(C`%{EXPR}\*(C'\fR.  No implicit dereferencing is allowed\*(--use the
{\s-1EXPR\s0} forms as an explicit dereference.  See perlref.
.IP "umask not implemented" 4
.IX Item "umask not implemented"
(F) Your machine doesn't implement the umask function and you tried to
use it to restrict permissions for yourself (\s-1EXPR & 0700\s0).
.ie n .IP "Unbalanced context: %d more PUSHes than POPs" 4
.el .IP "Unbalanced context: \f(CW%d\fR more PUSHes than POPs" 4
.IX Item "Unbalanced context: %d more PUSHes than POPs"
(S internal) The exit code detected an internal inconsistency in how
many execution contexts were entered and left.
.ie n .IP "Unbalanced saves: %d more saves than restores" 4
.el .IP "Unbalanced saves: \f(CW%d\fR more saves than restores" 4
.IX Item "Unbalanced saves: %d more saves than restores"
(S internal) The exit code detected an internal inconsistency in how
many values were temporarily localized.
.ie n .IP "Unbalanced scopes: %d more ENTERs than LEAVEs" 4
.el .IP "Unbalanced scopes: \f(CW%d\fR more ENTERs than LEAVEs" 4
.IX Item "Unbalanced scopes: %d more ENTERs than LEAVEs"
(S internal) The exit code detected an internal inconsistency in how
many blocks were entered and left.
.ie n .IP "Unbalanced string table refcount: (%d) for ""%s""" 4
.el .IP "Unbalanced string table refcount: (%d) for ``%s''" 4
.IX Item "Unbalanced string table refcount: (%d) for %s"
(S internal) On exit, Perl found some strings remaining in the shared
string table used for copy on write and for hash keys.  The entries
should have been freed, so this indicates a bug somewhere.
.ie n .IP "Unbalanced tmps: %d more allocs than frees" 4
.el .IP "Unbalanced tmps: \f(CW%d\fR more allocs than frees" 4
.IX Item "Unbalanced tmps: %d more allocs than frees"
(S internal) The exit code detected an internal inconsistency in how
many mortal scalars were allocated and freed.
.ie n .IP "Undefined format ""%s"" called" 4
.el .IP "Undefined format ``%s'' called" 4
.IX Item "Undefined format %s called"
(F) The format indicated doesn't seem to exist.  Perhaps it's really in
another package?  See perlform.
.ie n .IP "Undefined sort subroutine ""%s"" called" 4
.el .IP "Undefined sort subroutine ``%s'' called" 4
.IX Item "Undefined sort subroutine %s called"
(F) The sort comparison routine specified doesn't seem to exist.
Perhaps it's in a different package?  See \*(L"sort\*(R" in perlfunc.
.IP "Undefined subroutine &%s called" 4
.IX Item "Undefined subroutine &%s called"
(F) The subroutine indicated hasn't been defined, or if it was, it has
since been undefined.
.IP "Undefined subroutine called" 4
.IX Item "Undefined subroutine called"
(F) The anonymous subroutine you're trying to call hasn't been defined,
or if it was, it has since been undefined.
.IP "Undefined subroutine in sort" 4
.IX Item "Undefined subroutine in sort"
(F) The sort comparison routine specified is declared but doesn't seem
to have been defined yet.  See \*(L"sort\*(R" in perlfunc.
.ie n .IP "Undefined top format ""%s"" called" 4
.el .IP "Undefined top format ``%s'' called" 4
.IX Item "Undefined top format %s called"
(F) The format indicated doesn't seem to exist.  Perhaps it's really in
another package?  See perlform.
.IP "Undefined value assigned to typeglob" 4
.IX Item "Undefined value assigned to typeglob"
(W misc) An undefined value was assigned to a typeglob, a la
\&\f(CW\*(C`*foo = undef\*(C'\fR.  This does nothing.  It's possible that you really mean
\&\f(CW\*(C`undef *foo\*(C'\fR.
.ie n .IP "%s: Undefined variable" 4
.el .IP "\f(CW%s:\fR Undefined variable" 4
.IX Item "%s: Undefined variable"
(A) You've accidentally run your script through \fBcsh\fR instead of Perl.
Check the #! line, or manually feed your script into Perl yourself.
.IP "Unescaped left brace in regex is passed through in regex; marked by <\-\-\ \s-1HERE\s0 in m/%s/" 4
.IX Item "Unescaped left brace in regex is passed through in regex; marked by <--HERE in m/%s/"
(W regexp)  The simple rule to remember, if you want to
match a literal \f(CW"{"\fR character (U+007B \f(CW\*(C`LEFT CURLY BRACKET\*(C'\fR) in a
regular expression pattern, is to escape each literal instance of it in
some way.  Generally easiest is to precede it with a backslash, like
\&\f(CW"\e{"\fR or enclose it in square brackets (\f(CW"[{]"\fR).  If the pattern
delimiters are also braces, any matching right brace (\f(CW"}"\fR) should
also be escaped to avoid confusing the parser, for example,
.Sp
.Vb 1
\& qr{abc\e{def\e}ghi}
.Ve
.Sp
Forcing literal \f(CW"{"\fR characters to be escaped will enable the Perl
language to be extended in various ways in future releases.  To avoid
needlessly breaking existing code, the restriction is is not enforced in
contexts where there are unlikely to ever be extensions that could
conflict with the use there of \f(CW"{"\fR as a literal.  Those that are
not potentially ambiguous do not warn; those that are do raise a
non-deprecation warning.
.Sp
In this release of Perl, some literal uses of \f(CW"{"\fR are fatal, and some
still just deprecated.  This is because of an oversight:  some uses of a
literal \f(CW"{"\fR that should have raised a deprecation warning starting in
v5.20 did not warn until v5.26.  By making the already-warned uses fatal
now, some of the planned extensions can be made to the language sooner.
The cases which are still allowed will be fatal in Perl 5.32.
.Sp
The contexts where no warnings or errors are raised are:
.RS 4
.IP "\(bu" 4
as the first character in a pattern, or following \f(CW"^"\fR indicating to
anchor the match to the beginning of a line.
.IP "\(bu" 4
as the first character following a \f(CW"|"\fR indicating alternation.
.IP "\(bu" 4
as the first character in a parenthesized grouping like
.Sp
.Vb 2
\& /foo({bar)/
\& /foo(?:{bar)/
.Ve
.IP "\(bu" 4
as the first character following a quantifier
.Sp
.Vb 1
\& /\es*{/
.Ve
.RE
.RS 4
.RE
.IP "Unescaped left brace in regex is deprecated here (and will be fatal in Perl 5.32), passed through in regex; marked by <\-\-\ \s-1HERE\s0 in m/%s/" 4
.IX Item "Unescaped left brace in regex is deprecated here (and will be fatal in Perl 5.32), passed through in regex; marked by <--HERE in m/%s/"
(D deprecated, regexp)  The simple rule to remember, if you want to
match a literal \f(CW"{"\fR character (U+007B \f(CW\*(C`LEFT CURLY BRACKET\*(C'\fR) in a
regular expression pattern, is to escape each literal instance of it in
some way.  Generally easiest is to precede it with a backslash, like
\&\f(CW"\e{"\fR or enclose it in square brackets (\f(CW"[{]"\fR).  If the pattern
delimiters are also braces, any matching right brace (\f(CW"}"\fR) should
also be escaped to avoid confusing the parser, for example,
.Sp
.Vb 1
\& qr{abc\e{def\e}ghi}
.Ve
.Sp
Forcing literal \f(CW"{"\fR characters to be escaped will enable the Perl
language to be extended in various ways in future releases.  To avoid
needlessly breaking existing code, the restriction is is not enforced in
contexts where there are unlikely to ever be extensions that could
conflict with the use there of \f(CW"{"\fR as a literal.  Those that are
not potentially ambiguous do not warn; those that are do raise a
non-deprecation warning.
.Sp
In this release of Perl, some literal uses of \f(CW"{"\fR are fatal, and some
still just deprecated.  This is because of an oversight:  some uses of a
literal \f(CW"{"\fR that should have raised a deprecation warning starting in
v5.20 did not warn until v5.26.  By making the already-warned uses fatal
now, some of the planned extensions can be made to the language sooner.
The cases which are still allowed will be fatal in Perl 5.32.
.Sp
The contexts where no warnings or errors are raised are:
.RS 4
.IP "\(bu" 4
as the first character in a pattern, or following \f(CW"^"\fR indicating to
anchor the match to the beginning of a line.
.IP "\(bu" 4
as the first character following a \f(CW"|"\fR indicating alternation.
.IP "\(bu" 4
as the first character in a parenthesized grouping like
.Sp
.Vb 2
\& /foo({bar)/
\& /foo(?:{bar)/
.Ve
.IP "\(bu" 4
as the first character following a quantifier
.Sp
.Vb 1
\& /\es*{/
.Ve
.RE
.RS 4
.RE
.IP "Unescaped left brace in regex is illegal here in regex; marked by <\-\-\ \s-1HERE\s0 in m/%s/" 4
.IX Item "Unescaped left brace in regex is illegal here in regex; marked by <--HERE in m/%s/"
(F) The simple rule to remember, if you want to
match a literal \f(CW"{"\fR character (U+007B \f(CW\*(C`LEFT CURLY BRACKET\*(C'\fR) in a
regular expression pattern, is to escape each literal instance of it in
some way.  Generally easiest is to precede it with a backslash, like
\&\f(CW"\e{"\fR or enclose it in square brackets (\f(CW"[{]"\fR).  If the pattern
delimiters are also braces, any matching right brace (\f(CW"}"\fR) should
also be escaped to avoid confusing the parser, for example,
.Sp
.Vb 1
\& qr{abc\e{def\e}ghi}
.Ve
.Sp
Forcing literal \f(CW"{"\fR characters to be escaped will enable the Perl
language to be extended in various ways in future releases.  To avoid
needlessly breaking existing code, the restriction is is not enforced in
contexts where there are unlikely to ever be extensions that could
conflict with the use there of \f(CW"{"\fR as a literal.  Those that are
not potentially ambiguous do not warn; those that are do raise a
non-deprecation warning.
.Sp
In this release of Perl, some literal uses of \f(CW"{"\fR are fatal, and some
still just deprecated.  This is because of an oversight:  some uses of a
literal \f(CW"{"\fR that should have raised a deprecation warning starting in
v5.20 did not warn until v5.26.  By making the already-warned uses fatal
now, some of the planned extensions can be made to the language sooner.
The cases which are still allowed will be fatal in Perl 5.32.
.Sp
The contexts where no warnings or errors are raised are:
.RS 4
.IP "\(bu" 4
as the first character in a pattern, or following \f(CW"^"\fR indicating to
anchor the match to the beginning of a line.
.IP "\(bu" 4
as the first character following a \f(CW"|"\fR indicating alternation.
.IP "\(bu" 4
as the first character in a parenthesized grouping like
.Sp
.Vb 2
\& /foo({bar)/
\& /foo(?:{bar)/
.Ve
.IP "\(bu" 4
as the first character following a quantifier
.Sp
.Vb 1
\& /\es*{/
.Ve
.RE
.RS 4
.RE
.IP "Unescaped literal '%c' in regex; marked by <\-\- \s-1HERE\s0 in m/%s/" 4
.IX Item "Unescaped literal '%c' in regex; marked by <-- HERE in m/%s/"
(W regexp) (only under \f(CW\*(C`use\ re\ \*(Aqstrict\*(Aq\*(C'\fR)
.Sp
Within the scope of \f(CW\*(C`use\ re\ \*(Aqstrict\*(Aq\*(C'\fR in a regular expression
pattern, you included an unescaped \f(CW\*(C`}\*(C'\fR or \f(CW\*(C`]\*(C'\fR which was interpreted
literally.  These two characters are sometimes metacharacters, and
sometimes literals, depending on what precedes them in the
pattern.  This is unlike the similar \f(CW\*(C`)\*(C'\fR which is always a
metacharacter unless escaped.
.Sp
This action at a distance, perhaps a large distance, can lead to Perl
silently misinterpreting what you meant, so when you specify that you
want extra checking by \f(CW\*(C`use\ re\ \*(Aqstrict\*(Aq\*(C'\fR, this warning is generated.
If you meant the character as a literal, simply confirm that to Perl by
preceding the character with a backslash, or make it into a bracketed
character class (like \f(CW\*(C`[}]\*(C'\fR).  If you meant it as closing a
corresponding \f(CW\*(C`[\*(C'\fR or \f(CW\*(C`{\*(C'\fR, you'll need to look back through the pattern
to find out why that isn't happening.
.ie n .IP "unexec of %s into %s failed!" 4
.el .IP "unexec of \f(CW%s\fR into \f(CW%s\fR failed!" 4
.IX Item "unexec of %s into %s failed!"
(F) The \fBunexec()\fR routine failed for some reason.  See your local \s-1FSF\s0
representative, who probably put it there in the first place.
.IP "Unexpected binary operator '%c' with no preceding operand in regex; marked by <\-\-\ \s-1HERE\s0 in m/%s/" 4
.IX Item "Unexpected binary operator '%c' with no preceding operand in regex; marked by <--HERE in m/%s/"
(F) You had something like this:
.Sp
.Vb 1
\& (?[ | \ep{Digit} ])
.Ve
.Sp
where the \f(CW"|"\fR is a binary operator with an operand on the right, but
no operand on the left.
.IP "Unexpected character in regex; marked by <\-\-\ \s-1HERE\s0 in m/%s/" 4
.IX Item "Unexpected character in regex; marked by <--HERE in m/%s/"
(F) You had something like this:
.Sp
.Vb 1
\& (?[ z ])
.Ve
.Sp
Within \f(CW\*(C`(?[ ])\*(C'\fR, no literal characters are allowed unless they are
within an inner pair of square brackets, like
.Sp
.Vb 1
\& (?[ [ z ] ])
.Ve
.Sp
Another possibility is that you forgot a backslash.  Perl isn't smart
enough to figure out what you really meant.
.ie n .IP "Unexpected constant lvalue entersub entry via type/targ %d:%d" 4
.el .IP "Unexpected constant lvalue entersub entry via type/targ \f(CW%d:\fR%d" 4
.IX Item "Unexpected constant lvalue entersub entry via type/targ %d:%d"
(P) When compiling a subroutine call in lvalue context, Perl failed an
internal consistency check.  It encountered a malformed op tree.
.ie n .IP "Unexpected exit %u" 4
.el .IP "Unexpected exit \f(CW%u\fR" 4
.IX Item "Unexpected exit %u"
(S) \fBexit()\fR was called or the script otherwise finished gracefully when
\&\f(CW\*(C`PERL_EXIT_WARN\*(C'\fR was set in \f(CW\*(C`PL_exit_flags\*(C'\fR.
.ie n .IP "Unexpected exit failure %d" 4
.el .IP "Unexpected exit failure \f(CW%d\fR" 4
.IX Item "Unexpected exit failure %d"
(S) An uncaught \fBdie()\fR was called when \f(CW\*(C`PERL_EXIT_WARN\*(C'\fR was set in
\&\f(CW\*(C`PL_exit_flags\*(C'\fR.
.IP "Unexpected ')' in regex; marked by <\-\-\ \s-1HERE\s0 in m/%s/" 4
.IX Item "Unexpected ')' in regex; marked by <--HERE in m/%s/"
(F) You had something like this:
.Sp
.Vb 1
\& (?[ ( \ep{Digit} + ) ])
.Ve
.Sp
The \f(CW")"\fR is out-of-place.  Something apparently was supposed to
be combined with the digits, or the \f(CW"+"\fR shouldn't be there, or
something like that.  Perl can't figure out what was intended.
.IP "Unexpected ']' with no following ')' in (?[... in regex; marked by <\-\- \s-1HERE\s0 in m/%s/" 4
.IX Item "Unexpected ']' with no following ')' in (?[... in regex; marked by <-- HERE in m/%s/"
(F) While parsing an extended character class a ']' character was
encountered at a point in the definition where the only legal use of
\&']' is to close the character class definition as part of a '])', you
may have forgotten the close paren, or otherwise confused the parser.
.IP "Unexpected '(' with no preceding operator in regex; marked by <\-\-\ \s-1HERE\s0 in m/%s/" 4
.IX Item "Unexpected '(' with no preceding operator in regex; marked by <--HERE in m/%s/"
(F) You had something like this:
.Sp
.Vb 1
\& (?[ \ep{Digit} ( \ep{Lao} + \ep{Thai} ) ])
.Ve
.Sp
There should be an operator before the \f(CW"("\fR, as there's
no indication as to how the digits are to be combined
with the characters in the Lao and Thai scripts.
.IP "Unicode non-character U+%X is not recommended for open interchange" 4
.IX Item "Unicode non-character U+%X is not recommended for open interchange"
(S nonchar) Certain codepoints, such as U+FFFE and U+FFFF, are
defined by the Unicode standard to be non-characters.  Those
are legal codepoints, but are reserved for internal use; so,
applications shouldn't attempt to exchange them.  An application
may not be expecting any of these characters at all, and receiving
them may lead to bugs.  If you know what you are doing you can
turn off this warning by \f(CW\*(C`no warnings \*(Aqnonchar\*(Aq;\*(C'\fR.
.Sp
This is not really a \*(L"severe\*(R" error, but it is supposed to be
raised by default even if warnings are not enabled, and currently
the only way to do that in Perl is to mark it as serious.
.IP "Unicode property wildcard not terminated" 4
.IX Item "Unicode property wildcard not terminated"
(F) A Unicode property wildcard looks like a delimited regular
expression pattern (all within the braces of the enclosing \f(CW\*(C`\ep{...}\*(C'\fR.
The closing delimtter to match the opening one was not found.  If the
opening one is escaped by preceding it with a backslash, the closing one
must also be so escaped.
.IP "Unicode surrogate U+%X is illegal in \s-1UTF\-8\s0" 4
.IX Item "Unicode surrogate U+%X is illegal in UTF-8"
(S surrogate) You had a \s-1UTF\-16\s0 surrogate in a context where they are
not considered acceptable.  These code points, between U+D800 and
U+DFFF (inclusive), are used by Unicode only for \s-1UTF\-16.\s0  However, Perl
internally allows all unsigned integer code points (up to the size limit
available on your platform), including surrogates.  But these can cause
problems when being input or output, which is likely where this message
came from.  If you really really know what you are doing you can turn
off this warning by \f(CW\*(C`no warnings \*(Aqsurrogate\*(Aq;\*(C'\fR.
.IP "Unknown charname '%s'" 4
.IX Item "Unknown charname '%s'"
(F) The name you used inside \f(CW\*(C`\eN{}\*(C'\fR is unknown to Perl.  Check the
spelling.  You can say \f(CW\*(C`use charnames ":loose"\*(C'\fR to not have to be
so precise about spaces, hyphens, and capitalization on standard Unicode
names.  (Any custom aliases that have been created must be specified
exactly, regardless of whether \f(CW\*(C`:loose\*(C'\fR is used or not.)  This error may
also happen if the \f(CW\*(C`\eN{}\*(C'\fR is not in the scope of the corresponding
\&\f(CW\*(C`use\ charnames\*(C'\fR.
.IP "Unknown '(*...)' construct '%s' in regex; marked by <\-\- \s-1HERE\s0 in m/%s/" 4
.IX Item "Unknown '(*...)' construct '%s' in regex; marked by <-- HERE in m/%s/"
(F) The \f(CW\*(C`(*\*(C'\fR was followed by something that the regular expression
compiler does not recognize.  Check your spelling.
.IP "Unknown error" 4
.IX Item "Unknown error"
(P) Perl was about to print an error message in \f(CW$@\fR, but the \f(CW$@\fR variable
did not exist, even after an attempt to create it.
.ie n .IP "Unknown locale category %d; can't set it to %s" 4
.el .IP "Unknown locale category \f(CW%d\fR; can't set it to \f(CW%s\fR" 4
.IX Item "Unknown locale category %d; can't set it to %s"
(W locale) You used a locale category that perl doesn't recognize, so it
cannot carry out your request.  Check that you are using a valid
category.  If so, see \*(L"Multi-threaded\*(R" in perllocale for advice on
reporting this as a bug, and for modifying perl locally to accommodate
your needs.
.IP "Unknown \fBopen()\fR mode '%s'" 4
.IX Item "Unknown open() mode '%s'"
(F) The second argument of 3\-argument \fBopen()\fR is not among the list
of valid modes: \f(CW\*(C`<\*(C'\fR, \f(CW\*(C`>\*(C'\fR, \f(CW\*(C`>>\*(C'\fR, \f(CW\*(C`+<\*(C'\fR,
\&\f(CW\*(C`+>\*(C'\fR, \f(CW\*(C`+>>\*(C'\fR, \f(CW\*(C`\-|\*(C'\fR, \f(CW\*(C`|\-\*(C'\fR, \f(CW\*(C`<&\*(C'\fR, \f(CW\*(C`>&\*(C'\fR.
.ie n .IP "Unknown PerlIO layer ""%s""" 4
.el .IP "Unknown PerlIO layer ``%s''" 4
.IX Item "Unknown PerlIO layer %s"
(W layer) An attempt was made to push an unknown layer onto the Perl I/O
system.  (Layers take care of transforming data between external and
internal representations.)  Note that some layers, such as \f(CW\*(C`mmap\*(C'\fR,
are not supported in all environments.  If your program didn't
explicitly request the failing operation, it may be the result of the
value of the environment variable \s-1PERLIO.\s0
.ie n .IP "Unknown process %x sent message to prime_env_iter: %s" 4
.el .IP "Unknown process \f(CW%x\fR sent message to prime_env_iter: \f(CW%s\fR" 4
.IX Item "Unknown process %x sent message to prime_env_iter: %s"
(P) An error peculiar to \s-1VMS.\s0  Perl was reading values for \f(CW%ENV\fR before
iterating over it, and someone else stuck a message in the stream of
data Perl expected.  Someone's very confused, or perhaps trying to
subvert Perl's population of \f(CW%ENV\fR for nefarious purposes.
.ie n .IP "Unknown regexp modifier ""/%s""" 4
.el .IP "Unknown regexp modifier ``/%s''" 4
.IX Item "Unknown regexp modifier /%s"
(F) Alphanumerics immediately following the closing delimiter
of a regular expression pattern are interpreted by Perl as modifier
flags for the regex.  One of the ones you specified is invalid.  One way
this can happen is if you didn't put in white space between the end of
the regex and a following alphanumeric operator:
.Sp
.Vb 1
\& if ($a =~ /foo/and $bar == 3) { ... }
.Ve
.Sp
The \f(CW"a"\fR is a valid modifier flag, but the \f(CW"n"\fR is not, and raises
this error.  Likely what was meant instead was:
.Sp
.Vb 1
\& if ($a =~ /foo/ and $bar == 3) { ... }
.Ve
.ie n .IP "Unknown ""re"" subpragma '%s' (known ones are: %s)" 4
.el .IP "Unknown ``re'' subpragma '%s' (known ones are: \f(CW%s\fR)" 4
.IX Item "Unknown re subpragma '%s' (known ones are: %s)"
(W) You tried to use an unknown subpragma of the \*(L"re\*(R" pragma.
.IP "Unknown switch condition (?(...)) in regex; marked by <\-\-\ \s-1HERE\s0 in m/%s/" 4
.IX Item "Unknown switch condition (?(...)) in regex; marked by <--HERE in m/%s/"
(F) The condition part of a (?(condition)if\-clause|else\-clause) construct
is not known.  The condition must be one of the following:
.Sp
.Vb 10
\& (1) (2) ...            true if 1st, 2nd, etc., capture matched
\& (<NAME>) (\*(AqNAME\*(Aq)      true if named capture matched
\& (?=...) (?<=...)       true if subpattern matches
\& (*pla:...) (*plb:...)  true if subpattern matches; also
\&                             (*positive_lookahead:...)
\&                             (*positive_lookbehind:...)
\& (*nla:...) (*nlb:...)  true if subpattern fails to match; also
\&                             (*negative_lookahead:...)
\&                             (*negative_lookbehind:...)
\& (?{ CODE })            true if code returns a true value
\& (R)                    true if evaluating inside recursion
\& (R1) (R2) ...          true if directly inside capture group 1, 2,
\&                             etc.
\& (R&NAME)               true if directly inside named capture
\& (DEFINE)               always false; for defining named subpatterns
.Ve
.Sp
The <\-\-\ \s-1HERE\s0 shows whereabouts in the regular expression the problem was
discovered.  See perlre.
.IP "Unknown Unicode option letter '%c'" 4
.IX Item "Unknown Unicode option letter '%c'"
(F) You specified an unknown Unicode option.  See perlrun documentation
of the \f(CW\*(C`\-C\*(C'\fR switch for the list of known options.
.ie n .IP "Unknown Unicode option value %d" 4
.el .IP "Unknown Unicode option value \f(CW%d\fR" 4
.IX Item "Unknown Unicode option value %d"
(F) You specified an unknown Unicode option.  See perlrun documentation
of the \f(CW\*(C`\-C\*(C'\fR switch for the list of known options.
.IP "Unknown verb pattern '%s' in regex; marked by <\-\-\ \s-1HERE\s0 in m/%s/" 4
.IX Item "Unknown verb pattern '%s' in regex; marked by <--HERE in m/%s/"
(F) You either made a typo or have incorrectly put a \f(CW\*(C`*\*(C'\fR quantifier
after an open brace in your pattern.  Check the pattern and review
perlre for details on legal verb patterns.
.IP "Unknown warnings category '%s'" 4
.IX Item "Unknown warnings category '%s'"
(F) An error issued by the \f(CW\*(C`warnings\*(C'\fR pragma.  You specified a warnings
category that is unknown to perl at this point.
.Sp
Note that if you want to enable a warnings category registered by a
module (e.g. \f(CW\*(C`use warnings \*(AqFile::Find\*(Aq\*(C'\fR), you must have loaded this
module first.
.IP "Unmatched [ in regex; marked by <\-\-\ \s-1HERE\s0 in m/%s/" 4
.IX Item "Unmatched [ in regex; marked by <--HERE in m/%s/"
(F) The brackets around a character class must match.  If you wish to
include a closing bracket in a character class, backslash it or put it
first.  The <\-\-\ \s-1HERE\s0 shows whereabouts in the regular expression the
problem was discovered.  See perlre.
.IP "Unmatched ( in regex; marked by <\-\-\ \s-1HERE\s0 in m/%s/" 4
.IX Item "Unmatched ( in regex; marked by <--HERE in m/%s/"
.PD 0
.IP "Unmatched ) in regex; marked by <\-\-\ \s-1HERE\s0 in m/%s/" 4
.IX Item "Unmatched ) in regex; marked by <--HERE in m/%s/"
.PD
(F) Unbackslashed parentheses must always be balanced in regular
expressions.  If you're a vi user, the % key is valuable for finding
the matching parenthesis.  The <\-\-\ \s-1HERE\s0 shows whereabouts in the
regular expression the problem was discovered.  See perlre.
.ie n .IP "Unmatched right %s bracket" 4
.el .IP "Unmatched right \f(CW%s\fR bracket" 4
.IX Item "Unmatched right %s bracket"
(F) The lexer counted more closing curly or square brackets than opening
ones, so you're probably missing a matching opening bracket.  As a
general rule, you'll find the missing one (so to speak) near the place
you were last editing.
.ie n .IP "Unquoted string ""%s"" may clash with future reserved word" 4
.el .IP "Unquoted string ``%s'' may clash with future reserved word" 4
.IX Item "Unquoted string %s may clash with future reserved word"
(W reserved) You used a bareword that might someday be claimed as a
reserved word.  It's best to put such a word in quotes, or capitalize it
somehow, or insert an underbar into it.  You might also declare it as a
subroutine.
.ie n .IP "Unrecognized character %s; marked by <\-\-\ \s-1HERE\s0 after %s near column %d" 4
.el .IP "Unrecognized character \f(CW%s\fR; marked by <\-\-\ \s-1HERE\s0 after \f(CW%s\fR near column \f(CW%d\fR" 4
.IX Item "Unrecognized character %s; marked by <--HERE after %s near column %d"
(F) The Perl parser has no idea what to do with the specified character
in your Perl script (or eval) near the specified column.  Perhaps you
tried  to run a compressed script, a binary program, or a directory as
a Perl program.
.IP "Unrecognized escape \e%c in character class in regex; marked by <\-\-\ \s-1HERE\s0 in m/%s/" 4
.IX Item "Unrecognized escape %c in character class in regex; marked by <--HERE in m/%s/"
(F) You used a backslash-character combination which is not
recognized by Perl inside character classes.  This is a fatal
error when the character class is used within \f(CW\*(C`(?[ ])\*(C'\fR.
.IP "Unrecognized escape \e%c in character class passed through in regex; marked by <\-\-\ \s-1HERE\s0 in m/%s/" 4
.IX Item "Unrecognized escape %c in character class passed through in regex; marked by <--HERE in m/%s/"
(W regexp) You used a backslash-character combination which is not
recognized by Perl inside character classes.  The character was
understood literally, but this may change in a future version of Perl.
The <\-\-\ \s-1HERE\s0 shows whereabouts in the regular expression the
escape was discovered.
.IP "Unrecognized escape \e%c passed through" 4
.IX Item "Unrecognized escape %c passed through"
(W misc) You used a backslash-character combination which is not
recognized by Perl.  The character was understood literally, but this may
change in a future version of Perl.
.IP "Unrecognized escape \e%s passed through in regex; marked by <\-\-\ \s-1HERE\s0 in m/%s/" 4
.IX Item "Unrecognized escape %s passed through in regex; marked by <--HERE in m/%s/"
(W regexp) You used a backslash-character combination which is not
recognized by Perl.  The character(s) were understood literally, but
this may change in a future version of Perl.  The <\-\-\ \s-1HERE\s0 shows
whereabouts in the regular expression the escape was discovered.
.ie n .IP "Unrecognized signal name ""%s""" 4
.el .IP "Unrecognized signal name ``%s''" 4
.IX Item "Unrecognized signal name %s"
(F) You specified a signal name to the \fBkill()\fR function that was not
recognized.  Say \f(CW\*(C`kill \-l\*(C'\fR in your shell to see the valid signal names
on your system.
.IP "Unrecognized switch: \-%s  (\-h will show valid options)" 4
.IX Item "Unrecognized switch: -%s (-h will show valid options)"
(F) You specified an illegal option to Perl.  Don't do that.  (If you
think you didn't do that, check the #! line to see if it's supplying the
bad switch on your behalf.)
.ie n .IP "Unsuccessful %s on filename containing newline" 4
.el .IP "Unsuccessful \f(CW%s\fR on filename containing newline" 4
.IX Item "Unsuccessful %s on filename containing newline"
(W newline) A file operation was attempted on a filename, and that
operation failed, \s-1PROBABLY\s0 because the filename contained a newline,
\&\s-1PROBABLY\s0 because you forgot to \fBchomp()\fR it off.  See \*(L"chomp\*(R" in perlfunc.
.ie n .IP "Unsupported directory function ""%s"" called" 4
.el .IP "Unsupported directory function ``%s'' called" 4
.IX Item "Unsupported directory function %s called"
(F) Your machine doesn't support \fBopendir()\fR and \fBreaddir()\fR.
.ie n .IP "Unsupported function %s" 4
.el .IP "Unsupported function \f(CW%s\fR" 4
.IX Item "Unsupported function %s"
(F) This machine doesn't implement the indicated function, apparently.
At least, Configure doesn't think so.
.IP "Unsupported function fork" 4
.IX Item "Unsupported function fork"
(F) Your version of executable does not support forking.
.Sp
Note that under some systems, like \s-1OS/2,\s0 there may be different flavors
of Perl executables, some of which may support fork, some not.  Try
changing the name you call Perl by to \f(CW\*(C`perl_\*(C'\fR, \f(CW\*(C`perl_\|_\*(C'\fR, and so on.
.ie n .IP "Unsupported script encoding %s" 4
.el .IP "Unsupported script encoding \f(CW%s\fR" 4
.IX Item "Unsupported script encoding %s"
(F) Your program file begins with a Unicode Byte Order Mark (\s-1BOM\s0) which
declares it to be in a Unicode encoding that Perl cannot read.
.ie n .IP "Unsupported socket function ""%s"" called" 4
.el .IP "Unsupported socket function ``%s'' called" 4
.IX Item "Unsupported socket function %s called"
(F) Your machine doesn't support the Berkeley socket mechanism, or at
least that's what Configure thought.
.IP "Unterminated '(*...' argument in regex; marked by <\-\- \s-1HERE\s0 in m/%s/" 4
.IX Item "Unterminated '(*...' argument in regex; marked by <-- HERE in m/%s/"
(F) You used a pattern of the form \f(CW\*(C`(*...:...)\*(C'\fR but did not terminate
the pattern with a \f(CW\*(C`)\*(C'\fR.  Fix the pattern and retry.
.IP "Unterminated attribute list" 4
.IX Item "Unterminated attribute list"
(F) The lexer found something other than a simple identifier at the
start of an attribute, and it wasn't a semicolon or the start of a
block.  Perhaps you terminated the parameter list of the previous
attribute too soon.  See attributes.
.IP "Unterminated attribute parameter in attribute list" 4
.IX Item "Unterminated attribute parameter in attribute list"
(F) The lexer saw an opening (left) parenthesis character while parsing
an attribute list, but the matching closing (right) parenthesis
character was not found.  You may need to add (or remove) a backslash
character to get your parentheses to balance.  See attributes.
.IP "Unterminated compressed integer" 4
.IX Item "Unterminated compressed integer"
(F) An argument to unpack(\*(L"w\*(R",...) was incompatible with the \s-1BER\s0
compressed integer format and could not be converted to an integer.
See \*(L"pack\*(R" in perlfunc.
.IP "Unterminated '(*...' construct in regex; marked by <\-\- \s-1HERE\s0 in m/%s/" 4
.IX Item "Unterminated '(*...' construct in regex; marked by <-- HERE in m/%s/"
(F) You used a pattern of the form \f(CW\*(C`(*...)\*(C'\fR but did not terminate
the pattern with a \f(CW\*(C`)\*(C'\fR.  Fix the pattern and retry.
.IP "Unterminated delimiter for here document" 4
.IX Item "Unterminated delimiter for here document"
(F) This message occurs when a here document label has an initial
quotation mark but the final quotation mark is missing.  Perhaps
you wrote:
.Sp
.Vb 1
\&    <<"foo
.Ve
.Sp
instead of:
.Sp
.Vb 1
\&    <<"foo"
.Ve
.IP "Unterminated \eg... pattern in regex; marked by <\-\-\ \s-1HERE\s0 in m/%s/" 4
.IX Item "Unterminated g... pattern in regex; marked by <--HERE in m/%s/"
.PD 0
.IP "Unterminated \eg{...} pattern in regex; marked by <\-\-\ \s-1HERE\s0 in m/%s/" 4
.IX Item "Unterminated g{...} pattern in regex; marked by <--HERE in m/%s/"
.PD
(F) In a regular expression, you had a \f(CW\*(C`\eg\*(C'\fR that wasn't followed by a
proper group reference.  In the case of \f(CW\*(C`\eg{\*(C'\fR, the closing brace is
missing; otherwise the \f(CW\*(C`\eg\*(C'\fR must be followed by an integer.  Fix the
pattern and retry.
.IP "Unterminated <> operator" 4
.IX Item "Unterminated <> operator"
(F) The lexer saw a left angle bracket in a place where it was expecting
a term, so it's looking for the corresponding right angle bracket, and
not finding it.  Chances are you left some needed parentheses out
earlier in the line, and you really meant a \*(L"less than\*(R".
.IP "Unterminated verb pattern argument in regex; marked by <\-\-\ \s-1HERE\s0 in m/%s/" 4
.IX Item "Unterminated verb pattern argument in regex; marked by <--HERE in m/%s/"
(F) You used a pattern of the form \f(CW\*(C`(*VERB:ARG)\*(C'\fR but did not terminate
the pattern with a \f(CW\*(C`)\*(C'\fR.  Fix the pattern and retry.
.IP "Unterminated verb pattern in regex; marked by <\-\-\ \s-1HERE\s0 in m/%s/" 4
.IX Item "Unterminated verb pattern in regex; marked by <--HERE in m/%s/"
(F) You used a pattern of the form \f(CW\*(C`(*VERB)\*(C'\fR but did not terminate
the pattern with a \f(CW\*(C`)\*(C'\fR.  Fix the pattern and retry.
.ie n .IP "untie attempted while %d inner references still exist" 4
.el .IP "untie attempted while \f(CW%d\fR inner references still exist" 4
.IX Item "untie attempted while %d inner references still exist"
(W untie) A copy of the object returned from \f(CW\*(C`tie\*(C'\fR (or \f(CW\*(C`tied\*(C'\fR) was
still valid when \f(CW\*(C`untie\*(C'\fR was called.
.IP "Usage: POSIX::%s(%s)" 4
.IX Item "Usage: POSIX::%s(%s)"
(F) You called a \s-1POSIX\s0 function with incorrect arguments.
See \*(L"\s-1FUNCTIONS\*(R"\s0 in \s-1POSIX\s0 for more information.
.IP "Usage: Win32::%s(%s)" 4
.IX Item "Usage: Win32::%s(%s)"
(F) You called a Win32 function with incorrect arguments.
See Win32 for more information.
.ie n .IP "$[ used in %s (did you mean $] ?)" 4
.el .IP "$[ used in \f(CW%s\fR (did you mean $] ?)" 4
.IX Item "$[ used in %s (did you mean $] ?)"
(W syntax) You used \f(CW$[\fR in a comparison, such as:
.Sp
.Vb 3
\&    if ($[ > 5.006) {
\&        ...
\&    }
.Ve
.Sp
You probably meant to use \f(CW$]\fR instead.  \f(CW$[\fR is the base for indexing
arrays.  \f(CW$]\fR is the Perl version number in decimal.
.ie n .IP "Use ""%s"" instead of ""%s""" 4
.el .IP "Use ``%s'' instead of ``%s''" 4
.IX Item "Use %s instead of %s"
(F) The second listed construct is no longer legal.  Use the first one
instead.
.IP "Useless assignment to a temporary" 4
.IX Item "Useless assignment to a temporary"
(W misc) You assigned to an lvalue subroutine, but what
the subroutine returned was a temporary scalar about to
be discarded, so the assignment had no effect.
.IP "Useless (?\-%s) \- don't use /%s modifier in regex; marked by <\-\-\ \s-1HERE\s0 in m/%s/" 4
.IX Item "Useless (?-%s) - don't use /%s modifier in regex; marked by <--HERE in m/%s/"
(W regexp) You have used an internal modifier such as (?\-o) that has no
meaning unless removed from the entire regexp:
.Sp
.Vb 1
\&    if ($string =~ /(?\-o)$pattern/o) { ... }
.Ve
.Sp
must be written as
.Sp
.Vb 1
\&    if ($string =~ /$pattern/) { ... }
.Ve
.Sp
The <\-\-\ \s-1HERE\s0 shows whereabouts in the regular expression the problem was
discovered.  See perlre.
.ie n .IP "Useless localization of %s" 4
.el .IP "Useless localization of \f(CW%s\fR" 4
.IX Item "Useless localization of %s"
(W syntax) The localization of lvalues such as \f(CW\*(C`local($x=10)\*(C'\fR is legal,
but in fact the \fBlocal()\fR currently has no effect.  This may change at
some point in the future, but in the meantime such code is discouraged.
.IP "Useless (?%s) \- use /%s modifier in regex; marked by <\-\-\ \s-1HERE\s0 in m/%s/" 4
.IX Item "Useless (?%s) - use /%s modifier in regex; marked by <--HERE in m/%s/"
(W regexp) You have used an internal modifier such as (?o) that has no
meaning unless applied to the entire regexp:
.Sp
.Vb 1
\&    if ($string =~ /(?o)$pattern/) { ... }
.Ve
.Sp
must be written as
.Sp
.Vb 1
\&    if ($string =~ /$pattern/o) { ... }
.Ve
.Sp
The <\-\-\ \s-1HERE\s0 shows whereabouts in the regular expression the problem was
discovered.  See perlre.
.ie n .IP "Useless use of attribute ""const""" 4
.el .IP "Useless use of attribute ``const''" 4
.IX Item "Useless use of attribute const"
(W misc) The \f(CW\*(C`const\*(C'\fR attribute has no effect except
on anonymous closure prototypes.  You applied it to
a subroutine via attributes.pm.  This is only useful
inside an attribute handler for an anonymous subroutine.
.IP "Useless use of /d modifier in transliteration operator" 4
.IX Item "Useless use of /d modifier in transliteration operator"
(W misc) You have used the /d modifier where the searchlist has the
same length as the replacelist.  See perlop for more information
about the /d modifier.
.IP "Useless use of \eE" 4
.IX Item "Useless use of E"
(W misc) You have a \eE in a double-quotish string without a \f(CW\*(C`\eU\*(C'\fR,
\&\f(CW\*(C`\eL\*(C'\fR or \f(CW\*(C`\eQ\*(C'\fR preceding it.
.IP "Useless use of greediness modifier '%c' in regex; marked by <\-\-\ \s-1HERE\s0 in m/%s/" 4
.IX Item "Useless use of greediness modifier '%c' in regex; marked by <--HERE in m/%s/"
(W regexp) You specified something like these:
.Sp
.Vb 2
\& qr/a{3}?/
\& qr/b{1,1}+/
.Ve
.Sp
The \f(CW"?"\fR and \f(CW"+"\fR don't have any effect, as they modify whether to
match more or fewer when there is a choice, and by specifying to match
exactly a given numer, there is no room left for a choice.
.ie n .IP "Useless use of %s in void context" 4
.el .IP "Useless use of \f(CW%s\fR in void context" 4
.IX Item "Useless use of %s in void context"
(W void) You did something without a side effect in a context that does
nothing with the return value, such as a statement that doesn't return a
value from a block, or the left side of a scalar comma operator.  Very
often this points not to stupidity on your part, but a failure of Perl
to parse your program the way you thought it would.  For example, you'd
get this if you mixed up your C precedence with Python precedence and
said
.Sp
.Vb 1
\&    $one, $two = 1, 2;
.Ve
.Sp
when you meant to say
.Sp
.Vb 1
\&    ($one, $two) = (1, 2);
.Ve
.Sp
Another common error is to use ordinary parentheses to construct a list
reference when you should be using square or curly brackets, for
example, if you say
.Sp
.Vb 1
\&    $array = (1,2);
.Ve
.Sp
when you should have said
.Sp
.Vb 1
\&    $array = [1,2];
.Ve
.Sp
The square brackets explicitly turn a list value into a scalar value,
while parentheses do not.  So when a parenthesized list is evaluated in
a scalar context, the comma is treated like C's comma operator, which
throws away the left argument, which is not what you want.  See
perlref for more on this.
.Sp
This warning will not be issued for numerical constants equal to 0 or 1
since they are often used in statements like
.Sp
.Vb 1
\&    1 while sub_with_side_effects();
.Ve
.Sp
String constants that would normally evaluate to 0 or 1 are warned
about.
.IP "Useless use of (?\-p) in regex; marked by <\-\-\ \s-1HERE\s0 in m/%s/" 4
.IX Item "Useless use of (?-p) in regex; marked by <--HERE in m/%s/"
(W regexp) The \f(CW\*(C`p\*(C'\fR modifier cannot be turned off once set.  Trying to do
so is futile.
.ie n .IP "Useless use of ""re"" pragma" 4
.el .IP "Useless use of ``re'' pragma" 4
.IX Item "Useless use of re pragma"
(W) You did \f(CW\*(C`use re;\*(C'\fR without any arguments.  That isn't very useful.
.IP "Useless use of sort in scalar context" 4
.IX Item "Useless use of sort in scalar context"
(W void) You used sort in scalar context, as in :
.Sp
.Vb 1
\&    my $x = sort @y;
.Ve
.Sp
This is not very useful, and perl currently optimizes this away.
.ie n .IP "Useless use of %s with no values" 4
.el .IP "Useless use of \f(CW%s\fR with no values" 4
.IX Item "Useless use of %s with no values"
(W syntax) You used the \fBpush()\fR or \fBunshift()\fR function with no arguments
apart from the array, like \f(CW\*(C`push(@x)\*(C'\fR or \f(CW\*(C`unshift(@foo)\*(C'\fR.  That won't
usually have any effect on the array, so is completely useless.  It's
possible in principle that push(@tied_array) could have some effect
if the array is tied to a class which implements a \s-1PUSH\s0 method.  If so,
you can write it as \f(CW\*(C`push(@tied_array,())\*(C'\fR to avoid this warning.
.ie n .IP """use"" not allowed in expression" 4
.el .IP "``use'' not allowed in expression" 4
.IX Item "use not allowed in expression"
(F) The \*(L"use\*(R" keyword is recognized and executed at compile time, and
returns no useful value.  See perlmod.
.ie n .IP "Use of bare << to mean <<"""" is forbidden" 4
.el .IP "Use of bare << to mean <<``'' is forbidden" 4
.IX Item "Use of bare << to mean <<"""" is forbidden"
(F) You are now required to use the explicitly quoted form if you wish
to use an empty line as the terminator of the here-document.
.Sp
Use of a bare terminator was deprecated in Perl 5.000, and is a fatal
error as of Perl 5.28.
.IP "Use of /c modifier is meaningless in s///" 4
.IX Item "Use of /c modifier is meaningless in s///"
(W regexp) You used the /c modifier in a substitution.  The /c
modifier is not presently meaningful in substitutions.
.IP "Use of /c modifier is meaningless without /g" 4
.IX Item "Use of /c modifier is meaningless without /g"
(W regexp) You used the /c modifier with a regex operand, but didn't
use the /g modifier.  Currently, /c is meaningful only when /g is
used.  (This may change in the future.)
.IP "Use of code point 0x%s is not allowed; the permissible max is 0x%x" 4
.IX Item "Use of code point 0x%s is not allowed; the permissible max is 0x%x"
.PD 0
.IP "Use of code point 0x%s is not allowed; the permissible max is 0x%x in regex; marked by <\-\- \s-1HERE\s0 in m/%s/" 4
.IX Item "Use of code point 0x%s is not allowed; the permissible max is 0x%x in regex; marked by <-- HERE in m/%s/"
.PD
(F) You used a code point that is not allowed, because it is too large.
Unicode only allows code points up to 0x10FFFF, but Perl allows much
larger ones. Earlier versions of Perl allowed code points above \s-1IV_MAX\s0
(0x7FFFFFF on 32\-bit platforms, 0x7FFFFFFFFFFFFFFF on 64\-bit platforms),
however, this could possibly break the perl interpreter in some constructs,
including causing it to hang in a few cases.
.Sp
If your code is to run on various platforms, keep in mind that the upper
limit depends on the platform.  It is much larger on 64\-bit word sizes
than 32\-bit ones.
.Sp
The use of out of range code points was deprecated in Perl 5.24, and
became a fatal error in Perl 5.28.
.IP "Use of \fBeach()\fR on hash after insertion without resetting hash iterator results in undefined behavior" 4
.IX Item "Use of each() on hash after insertion without resetting hash iterator results in undefined behavior"
(S internal) The behavior of \f(CW\*(C`each()\*(C'\fR after insertion is undefined;
it may skip items, or visit items more than once.  Consider using
\&\f(CW\*(C`keys()\*(C'\fR instead of \f(CW\*(C`each()\*(C'\fR.
.IP "Use of := for an empty attribute list is not allowed" 4
.IX Item "Use of := for an empty attribute list is not allowed"
(F) The construction \f(CW\*(C`my $x := 42\*(C'\fR used to parse as equivalent to
\&\f(CW\*(C`my $x : = 42\*(C'\fR (applying an empty attribute list to \f(CW$x\fR).
This construct was deprecated in 5.12.0, and has now been made a syntax
error, so \f(CW\*(C`:=\*(C'\fR can be reclaimed as a new operator in the future.
.Sp
If you need an empty attribute list, for example in a code generator, add
a space before the \f(CW\*(C`=\*(C'\fR.
.ie n .IP "Use of %s for non\-UTF\-8 locale is wrong.  Assuming a \s-1UTF\-8\s0 locale" 4
.el .IP "Use of \f(CW%s\fR for non\-UTF\-8 locale is wrong.  Assuming a \s-1UTF\-8\s0 locale" 4
.IX Item "Use of %s for non-UTF-8 locale is wrong. Assuming a UTF-8 locale"
(W locale)  You are matching a regular expression using locale rules,
and the specified construct was encountered.  This construct is only
valid for \s-1UTF\-8\s0 locales, which the current locale isn't.  This doesn't
make sense.  Perl will continue, assuming a Unicode (\s-1UTF\-8\s0) locale, but
the results are likely to be wrong.
.IP "Use of freed value in iteration" 4
.IX Item "Use of freed value in iteration"
(F) Perhaps you modified the iterated array within the loop?
This error is typically caused by code like the following:
.Sp
.Vb 2
\&    @a = (3,4);
\&    @a = () for (1,2,@a);
.Ve
.Sp
You are not supposed to modify arrays while they are being iterated over.
For speed and efficiency reasons, Perl internally does not do full
reference-counting of iterated items, hence deleting such an item in the
middle of an iteration causes Perl to see a freed value.
.IP "Use of /g modifier is meaningless in split" 4
.IX Item "Use of /g modifier is meaningless in split"
(W regexp) You used the /g modifier on the pattern for a \f(CW\*(C`split\*(C'\fR
operator.  Since \f(CW\*(C`split\*(C'\fR always tries to match the pattern
repeatedly, the \f(CW\*(C`/g\*(C'\fR has no effect.
.ie n .IP "Use of ""goto"" to jump into a construct is deprecated" 4
.el .IP "Use of ``goto'' to jump into a construct is deprecated" 4
.IX Item "Use of goto to jump into a construct is deprecated"
(D deprecated) Using \f(CW\*(C`goto\*(C'\fR to jump from an outer scope into an inner
scope is deprecated and should be avoided.
.Sp
This was deprecated in Perl 5.12.
.ie n .IP "Use of '%s' in \ep{} or \eP{} is deprecated because: %s" 4
.el .IP "Use of '%s' in \ep{} or \eP{} is deprecated because: \f(CW%s\fR" 4
.IX Item "Use of '%s' in p{} or P{} is deprecated because: %s"
(D deprecated) Certain properties are deprecated by Unicode, and may
eventually be removed from the Standard, at which time Perl will follow
along.  In the meantime, this message is raised to notify you.
.ie n .IP "Use of inherited \s-1AUTOLOAD\s0 for non-method %s::%s() is no longer allowed" 4
.el .IP "Use of inherited \s-1AUTOLOAD\s0 for non-method \f(CW%s::\fR%s() is no longer allowed" 4
.IX Item "Use of inherited AUTOLOAD for non-method %s::%s() is no longer allowed"
(F) As an accidental feature, \f(CW\*(C`AUTOLOAD\*(C'\fR subroutines were looked up as
methods (using the \f(CW@ISA\fR hierarchy), even when the subroutines to be
autoloaded were called as plain functions (e.g. \f(CW\*(C`Foo::bar()\*(C'\fR), not as
methods (e.g. \f(CW\*(C`Foo\->bar()\*(C'\fR or \f(CW\*(C`$obj\->bar()\*(C'\fR).
.Sp
This was deprecated in Perl 5.004, and was made fatal in Perl 5.28.
.ie n .IP "Use of %s in printf format not supported" 4
.el .IP "Use of \f(CW%s\fR in printf format not supported" 4
.IX Item "Use of %s in printf format not supported"
(F) You attempted to use a feature of printf that is accessible from
only C.  This usually means there's a better way to do it in Perl.
.IP "Use of \-l on filehandle%s" 4
.IX Item "Use of -l on filehandle%s"
(W io) A filehandle represents an opened file, and when you opened the file
it already went past any symlink you are presumably trying to look for.
The operation returned \f(CW\*(C`undef\*(C'\fR.  Use a filename instead.
.ie n .IP "Use of reference ""%s"" as array index" 4
.el .IP "Use of reference ``%s'' as array index" 4
.IX Item "Use of reference %s as array index"
(W misc) You tried to use a reference as an array index; this probably
isn't what you mean, because references in numerical context tend
to be huge numbers, and so usually indicates programmer error.
.Sp
If you really do mean it, explicitly numify your reference, like so:
\&\f(CW$array[0+$ref]\fR.  This warning is not given for overloaded objects,
however, because you can overload the numification and stringification
operators and then you presumably know what you are doing.
.ie n .IP "Use of strings with code points over 0xFF as arguments to %s operator is not allowed" 4
.el .IP "Use of strings with code points over 0xFF as arguments to \f(CW%s\fR operator is not allowed" 4
.IX Item "Use of strings with code points over 0xFF as arguments to %s operator is not allowed"
(F) You tried to use one of the string bitwise operators (\f(CW\*(C`&\*(C'\fR or \f(CW\*(C`|\*(C'\fR or \f(CW\*(C`^\*(C'\fR or
\&\f(CW\*(C`~\*(C'\fR) on a string containing a code point over 0xFF.  The string bitwise
operators treat their operands as strings of bytes, and values beyond
0xFF are nonsensical in this context.
.Sp
This became fatal in Perl 5.28.
.ie n .IP "Use of strings with code points over 0xFF as arguments to ""vec"" is deprecated. This will be a fatal error in Perl 5.32" 4
.el .IP "Use of strings with code points over 0xFF as arguments to \f(CWvec\fR is deprecated. This will be a fatal error in Perl 5.32" 4
.IX Item "Use of strings with code points over 0xFF as arguments to vec is deprecated. This will be a fatal error in Perl 5.32"
(D deprecated) You tried to use \f(CW\*(C`vec\*(C'\fR
on a string containing a code point over 0xFF, which is nonsensical here.
.Sp
Such usage will be a fatal error in Perl 5.32.
.ie n .IP "Use of tainted arguments in %s is deprecated" 4
.el .IP "Use of tainted arguments in \f(CW%s\fR is deprecated" 4
.IX Item "Use of tainted arguments in %s is deprecated"
(W taint, deprecated) You have supplied \f(CW\*(C`system()\*(C'\fR or \f(CW\*(C`exec()\*(C'\fR with multiple
arguments and at least one of them is tainted.  This used to be allowed
but will become a fatal error in a future version of perl.  Untaint your
arguments.  See perlsec.
.IP "Use of unassigned code point or non-standalone grapheme for a delimiter is not allowed" 4
.IX Item "Use of unassigned code point or non-standalone grapheme for a delimiter is not allowed"
(F)
A grapheme is what appears to a native-speaker of a language to be a
character.  In Unicode (and hence Perl) a grapheme may actually be
several adjacent characters that together form a complete grapheme.  For
example, there can be a base character, like \*(L"R\*(R" and an accent, like a
circumflex \*(L"^\*(R", that appear when displayed to be a single character with
the circumflex hovering over the \*(L"R\*(R".  Perl currently allows things like
that circumflex to be delimiters of strings, patterns, \fIetc\fR.  When
displayed, the circumflex would look like it belongs to the character
just to the left of it.  In order to move the language to be able to
accept graphemes as delimiters, we cannot allow the use of
delimiters which aren't graphemes by themselves.  Also, a delimiter must
already be assigned (or known to be never going to be assigned) to try
to future-proof code, for otherwise code that works today would fail to
compile if the currently unassigned delimiter ends up being something
that isn't a stand-alone grapheme.  Because Unicode is never going to
assign
non-character code points, nor
code points that are above the legal Unicode maximum, those can be delimiters, and
their use is legal.
.IP "Use of uninitialized value%s" 4
.IX Item "Use of uninitialized value%s"
(W uninitialized) An undefined value was used as if it were already
defined.  It was interpreted as a "" or a 0, but maybe it was a mistake.
To suppress this warning assign a defined value to your variables.
.Sp
To help you figure out what was undefined, perl will try to tell you
the name of the variable (if any) that was undefined.  In some cases
it cannot do this, so it also tells you what operation you used the
undefined value in.  Note, however, that perl optimizes your program
and the operation displayed in the warning may not necessarily appear
literally in your program.  For example, \f(CW"that $foo"\fR is usually
optimized into \f(CW\*(C`"that " . $foo\*(C'\fR, and the warning will refer to the
\&\f(CW\*(C`concatenation (.)\*(C'\fR operator, even though there is no \f(CW\*(C`.\*(C'\fR in
your program.
.ie n .IP """use re 'strict'"" is experimental" 4
.el .IP "``use re 'strict''' is experimental" 4
.IX Item "use re 'strict' is experimental"
(S experimental::re_strict) The things that are different when a regular
expression pattern is compiled under \f(CW\*(Aqstrict\*(Aq\fR are subject to change
in future Perl releases in incompatible ways.  This means that a pattern
that compiles today may not in a future Perl release.  This warning is
to alert you to that risk.
.IP "Use \ex{...} for more than two hex characters in regex; marked by <\-\-\ \s-1HERE\s0 in m/%s/" 4
.IX Item "Use x{...} for more than two hex characters in regex; marked by <--HERE in m/%s/"
(F) In a regular expression, you said something like
.Sp
.Vb 1
\& (?[ [ \exBEEF ] ])
.Ve
.Sp
Perl isn't sure if you meant this
.Sp
.Vb 1
\& (?[ [ \ex{BEEF} ] ])
.Ve
.Sp
or if you meant this
.Sp
.Vb 1
\& (?[ [ \ex{BE} E F ] ])
.Ve
.Sp
You need to add either braces or blanks to disambiguate.
.IP "Using just the first character returned by \eN{} in character class in regex; marked by <\-\-\ \s-1HERE\s0 in m/%s/" 4
.IX Item "Using just the first character returned by N{} in character class in regex; marked by <--HERE in m/%s/"
(W regexp) Named Unicode character escapes \f(CW\*(C`(\eN{...})\*(C'\fR may return
a multi-character sequence.  Even though a character class is
supposed to match just one character of input, perl will match
the whole thing correctly, except when the class is inverted
(\f(CW\*(C`[^...]\*(C'\fR), or the escape is the beginning or final end point of
a range.  For these, what should happen isn't clear at all.  In
these circumstances, Perl discards all but the first character
of the returned sequence, which is not likely what you want.
.IP "Using /u for '%s' instead of /%s in regex; marked by <\-\-\ \s-1HERE\s0 in m/%s/" 4
.IX Item "Using /u for '%s' instead of /%s in regex; marked by <--HERE in m/%s/"
(W regexp) You used a Unicode boundary (\f(CW\*(C`\eb{...}\*(C'\fR or \f(CW\*(C`\eB{...}\*(C'\fR) in a
portion of a regular expression where the character set modifiers \f(CW\*(C`/a\*(C'\fR
or \f(CW\*(C`/aa\*(C'\fR are in effect.  These two modifiers indicate an \s-1ASCII\s0
interpretation, and this doesn't make sense for a Unicode definition.
The generated regular expression will compile so that the boundary uses
all of Unicode.  No other portion of the regular expression is affected.
.ie n .IP "Using !~ with %s doesn't make sense" 4
.el .IP "Using !~ with \f(CW%s\fR doesn't make sense" 4
.IX Item "Using !~ with %s doesn't make sense"
(F) Using the \f(CW\*(C`!~\*(C'\fR operator with \f(CW\*(C`s///r\*(C'\fR, \f(CW\*(C`tr///r\*(C'\fR or \f(CW\*(C`y///r\*(C'\fR is
currently reserved for future use, as the exact behavior has not
been decided.  (Simply returning the boolean opposite of the
modified string is usually not particularly useful.)
.IP "\s-1UTF\-16\s0 surrogate U+%X" 4
.IX Item "UTF-16 surrogate U+%X"
(S surrogate) You had a \s-1UTF\-16\s0 surrogate in a context where they are
not considered acceptable.  These code points, between U+D800 and
U+DFFF (inclusive), are used by Unicode only for \s-1UTF\-16.\s0  However, Perl
internally allows all unsigned integer code points (up to the size limit
available on your platform), including surrogates.  But these can cause
problems when being input or output, which is likely where this message
came from.  If you really really know what you are doing you can turn
off this warning by \f(CW\*(C`no warnings \*(Aqsurrogate\*(Aq;\*(C'\fR.
.ie n .IP "Value of %s can be ""0""; test with \fBdefined()\fR" 4
.el .IP "Value of \f(CW%s\fR can be ``0''; test with \fBdefined()\fR" 4
.IX Item "Value of %s can be 0; test with defined()"
(W misc) In a conditional expression, you used <\s-1HANDLE\s0>, <*> (glob),
\&\f(CW\*(C`each()\*(C'\fR, or \f(CW\*(C`readdir()\*(C'\fR as a boolean value.  Each of these constructs
can return a value of \*(L"0\*(R"; that would make the conditional expression
false, which is probably not what you intended.  When using these
constructs in conditional expressions, test their values with the
\&\f(CW\*(C`defined\*(C'\fR operator.
.ie n .IP "Value of \s-1CLI\s0 symbol ""%s"" too long" 4
.el .IP "Value of \s-1CLI\s0 symbol ``%s'' too long" 4
.IX Item "Value of CLI symbol %s too long"
(W misc) A warning peculiar to \s-1VMS.\s0  Perl tried to read the value of an
\&\f(CW%ENV\fR element from a \s-1CLI\s0 symbol table, and found a resultant string
longer than 1024 characters.  The return value has been truncated to
1024 characters.
.ie n .IP "Variable ""%s"" is not available" 4
.el .IP "Variable ``%s'' is not available" 4
.IX Item "Variable %s is not available"
(W closure) During compilation, an inner named subroutine or eval is
attempting to capture an outer lexical that is not currently available.
This can happen for one of two reasons.  First, the outer lexical may be
declared in an outer anonymous subroutine that has not yet been created.
(Remember that named subs are created at compile time, while anonymous
subs are created at run-time.)  For example,
.Sp
.Vb 1
\&    sub { my $a; sub f { $a } }
.Ve
.Sp
At the time that f is created, it can't capture the current value of \f(CW$a\fR,
since the anonymous subroutine hasn't been created yet.  Conversely,
the following won't give a warning since the anonymous subroutine has by
now been created and is live:
.Sp
.Vb 1
\&    sub { my $a; eval \*(Aqsub f { $a }\*(Aq }\->();
.Ve
.Sp
The second situation is caused by an eval accessing a variable that has
gone out of scope, for example,
.Sp
.Vb 5
\&    sub f {
\&        my $a;
\&        sub { eval \*(Aq$a\*(Aq }
\&    }
\&    f()\->();
.Ve
.Sp
Here, when the '$a' in the eval is being compiled, f() is not currently
being executed, so its \f(CW$a\fR is not available for capture.
.ie n .IP "Variable ""%s"" is not imported%s" 4
.el .IP "Variable ``%s'' is not imported%s" 4
.IX Item "Variable %s is not imported%s"
(S misc) With \*(L"use strict\*(R" in effect, you referred to a global variable
that you apparently thought was imported from another module, because
something else of the same name (usually a subroutine) is exported by
that module.  It usually means you put the wrong funny character on the
front of your variable.
.IP "Variable length lookbehind not implemented in regex m/%s/" 4
.IX Item "Variable length lookbehind not implemented in regex m/%s/"
(F) \fBThis message no longer should be raised as of Perl 5.30.\fR  It is
retained in this document as a convenience for people using an earlier
Perl version.
.Sp
In Perl 5.30 and earlier, lookbehind is allowed
only for subexpressions whose length is fixed and
known at compile time.  For positive lookbehind, you can use the \f(CW\*(C`\eK\*(C'\fR
regex construct as a way to get the equivalent functionality.  See
(?<=pattern) and \eK in perlre.
.Sp
Starting in Perl 5.18, there are non-obvious Unicode rules under \f(CW\*(C`/i\*(C'\fR
that can match variably, but which you might not think could.  For
example, the substring \f(CW"ss"\fR can match the single character \s-1LATIN
SMALL LETTER SHARP S.\s0  Here's a complete list of the current ones
affecting \s-1ASCII\s0 characters:
.Sp
.Vb 11
\&   ASCII
\&  sequence      Matches single letter under /i
\&    FF          U+FB00 LATIN SMALL LIGATURE FF
\&    FFI         U+FB03 LATIN SMALL LIGATURE FFI
\&    FFL         U+FB04 LATIN SMALL LIGATURE FFL
\&    FI          U+FB01 LATIN SMALL LIGATURE FI
\&    FL          U+FB02 LATIN SMALL LIGATURE FL
\&    SS          U+00DF LATIN SMALL LETTER SHARP S
\&                U+1E9E LATIN CAPITAL LETTER SHARP S
\&    ST          U+FB06 LATIN SMALL LIGATURE ST
\&                U+FB05 LATIN SMALL LIGATURE LONG S T
.Ve
.Sp
This list is subject to change, but is quite unlikely to.
Each \s-1ASCII\s0 sequence can be any combination of upper\- and lowercase.
.Sp
You can avoid this by using a bracketed character class in the
lookbehind assertion, like
.Sp
.Vb 2
\& (?<![sS]t)
\& (?<![fF]f[iI])
.Ve
.Sp
This fools Perl into not matching the ligatures.
.Sp
Another option for Perls starting with 5.16, if you only care about
\&\s-1ASCII\s0 matches, is to add the \f(CW\*(C`/aa\*(C'\fR modifier to the regex.  This will
exclude all these non-obvious matches, thus getting rid of this message.
You can also say
.Sp
.Vb 1
\& use if $] ge 5.016, re => \*(Aq/aa\*(Aq;
.Ve
.Sp
to apply \f(CW\*(C`/aa\*(C'\fR to all regular expressions compiled within its scope.
See re.
.ie n .IP """%s"" variable %s masks earlier declaration in same %s" 4
.el .IP "``%s'' variable \f(CW%s\fR masks earlier declaration in same \f(CW%s\fR" 4
.IX Item "%s variable %s masks earlier declaration in same %s"
(W shadow) A \*(L"my\*(R", \*(L"our\*(R" or \*(L"state\*(R" variable has been redeclared in the
current scope or statement, effectively eliminating all access to the
previous instance.  This is almost always a typographical error.  Note
that the earlier variable will still exist until the end of the scope
or until all closure references to it are destroyed.
.IP "Variable syntax" 4
.IX Item "Variable syntax"
(A) You've accidentally run your script through \fBcsh\fR instead
of Perl.  Check the #! line, or manually feed your script into
Perl yourself.
.ie n .IP "Variable ""%s"" will not stay shared" 4
.el .IP "Variable ``%s'' will not stay shared" 4
.IX Item "Variable %s will not stay shared"
(W closure) An inner (nested) \fInamed\fR subroutine is referencing a
lexical variable defined in an outer named subroutine.
.Sp
When the inner subroutine is called, it will see the value of
the outer subroutine's variable as it was before and during the *first*
call to the outer subroutine; in this case, after the first call to the
outer subroutine is complete, the inner and outer subroutines will no
longer share a common value for the variable.  In other words, the
variable will no longer be shared.
.Sp
This problem can usually be solved by making the inner subroutine
anonymous, using the \f(CW\*(C`sub {}\*(C'\fR syntax.  When inner anonymous subs that
reference variables in outer subroutines are created, they
are automatically rebound to the current values of such variables.
.IP "vector argument not supported with alpha versions" 4
.IX Item "vector argument not supported with alpha versions"
(S printf) The \f(CW%vd\fR (s)printf format does not support version objects
with alpha parts.
.IP "Verb pattern '%s' has a mandatory argument in regex; marked by <\-\-\ \s-1HERE\s0 in m/%s/" 4
.IX Item "Verb pattern '%s' has a mandatory argument in regex; marked by <--HERE in m/%s/"
(F) You used a verb pattern that requires an argument.  Supply an
argument or check that you are using the right verb.
.IP "Verb pattern '%s' may not have an argument in regex; marked by <\-\-\ \s-1HERE\s0 in m/%s/" 4
.IX Item "Verb pattern '%s' may not have an argument in regex; marked by <--HERE in m/%s/"
(F) You used a verb pattern that is not allowed an argument.  Remove the 
argument or check that you are using the right verb.
.IP "Version control conflict marker" 4
.IX Item "Version control conflict marker"
(F) The parser found a line starting with \f(CW\*(C`<<<<<<<\*(C'\fR,
\&\f(CW\*(C`>>>>>>>\*(C'\fR, or \f(CW\*(C`=======\*(C'\fR.  These may be left by a
version control system to mark conflicts after a failed merge operation.
.IP "Version number must be a constant number" 4
.IX Item "Version number must be a constant number"
(P) The attempt to translate a \f(CW\*(C`use Module n.n LIST\*(C'\fR statement into
its equivalent \f(CW\*(C`BEGIN\*(C'\fR block found an internal inconsistency with
the version number.
.IP "Version string '%s' contains invalid data; ignoring: '%s'" 4
.IX Item "Version string '%s' contains invalid data; ignoring: '%s'"
(W misc) The version string contains invalid characters at the end, which
are being ignored.
.IP "Warning: something's wrong" 4
.IX Item "Warning: something's wrong"
(W) You passed \fBwarn()\fR an empty string (the equivalent of \f(CW\*(C`warn ""\*(C'\fR) or
you called it with no args and \f(CW$@\fR was empty.
.ie n .IP "Warning: unable to close filehandle %s properly" 4
.el .IP "Warning: unable to close filehandle \f(CW%s\fR properly" 4
.IX Item "Warning: unable to close filehandle %s properly"
(S) The implicit \fBclose()\fR done by an \fBopen()\fR got an error indication on
the \fBclose()\fR.  This usually indicates your file system ran out of disk
space.
.ie n .IP "Warning: unable to close filehandle properly: %s" 4
.el .IP "Warning: unable to close filehandle properly: \f(CW%s\fR" 4
.IX Item "Warning: unable to close filehandle properly: %s"
.PD 0
.ie n .IP "Warning: unable to close filehandle %s properly: %s" 4
.el .IP "Warning: unable to close filehandle \f(CW%s\fR properly: \f(CW%s\fR" 4
.IX Item "Warning: unable to close filehandle %s properly: %s"
.PD
(S io) There were errors during the implicit \fBclose()\fR done on a filehandle
when its reference count reached zero while it was still open, e.g.:
.Sp
.Vb 4
\&    {
\&        open my $fh, \*(Aq>\*(Aq, $file  or die "open: \*(Aq$file\*(Aq: $!\en";
\&        print $fh $data or die "print: $!";
\&    } # implicit close here
.Ve
.Sp
Because various errors may only be detected by \fBclose()\fR (e.g. buffering could
allow the \f(CW\*(C`print\*(C'\fR in this example to return true even when the disk is full),
it is dangerous to ignore its result.  So when it happens implicitly, perl
will signal errors by warning.
.Sp
\&\fBPrior to version 5.22.0, perl ignored such errors\fR, so the common idiom shown
above was liable to cause \fBsilent data loss\fR.
.ie n .IP "Warning: Use of ""%s"" without parentheses is ambiguous" 4
.el .IP "Warning: Use of ``%s'' without parentheses is ambiguous" 4
.IX Item "Warning: Use of %s without parentheses is ambiguous"
(S ambiguous) You wrote a unary operator followed by something that
looks like a binary operator that could also have been interpreted as a
term or unary operator.  For instance, if you know that the rand
function has a default argument of 1.0, and you write
.Sp
.Vb 1
\&    rand + 5;
.Ve
.Sp
you may \s-1THINK\s0 you wrote the same thing as
.Sp
.Vb 1
\&    rand() + 5;
.Ve
.Sp
but in actual fact, you got
.Sp
.Vb 1
\&    rand(+5);
.Ve
.Sp
So put in parentheses to say what you really mean.
.IP "when is experimental" 4
.IX Item "when is experimental"
(S experimental::smartmatch) \f(CW\*(C`when\*(C'\fR depends on smartmatch, which is
experimental.  Additionally, it has several special cases that may
not be immediately obvious, and their behavior may change or
even be removed in any future release of perl.  See the explanation
under \*(L"Experimental Details on given and when\*(R" in perlsyn.
.ie n .IP "Wide character in %s" 4
.el .IP "Wide character in \f(CW%s\fR" 4
.IX Item "Wide character in %s"
(S utf8) Perl met a wide character (ordinal >255) when it wasn't
expecting one.  This warning is by default on for I/O (like print).
.Sp
If this warning does come from I/O, the easiest
way to quiet it is simply to add the \f(CW\*(C`:utf8\*(C'\fR layer, \fIe.g.\fR,
\&\f(CW\*(C`binmode\ STDOUT,\ \*(Aq:utf8\*(Aq\*(C'\fR.  Another way to turn off the warning is
to add \f(CW\*(C`no\ warnings\ \*(Aqutf8\*(Aq;\*(C'\fR but that is often closer to
cheating.  In general, you are supposed to explicitly mark the
filehandle with an encoding, see open and \*(L"binmode\*(R" in perlfunc.
.Sp
If the warning comes from other than I/O, this diagnostic probably
indicates that incorrect results are being obtained.  You should examine
your code to determine how a wide character is getting to an operation
that doesn't handle them.
.ie n .IP "Wide character (U+%X) in %s" 4
.el .IP "Wide character (U+%X) in \f(CW%s\fR" 4
.IX Item "Wide character (U+%X) in %s"
(W locale) While in a single-byte locale (\fIi.e.\fR, a non\-UTF\-8
one), a multi-byte character was encountered.   Perl considers this
character to be the specified Unicode code point.  Combining non\-UTF\-8
locales and Unicode is dangerous.  Almost certainly some characters
will have two different representations.  For example, in the \s-1ISO 8859\-7\s0
(Greek) locale, the code point 0xC3 represents a Capital Gamma.  But so
also does 0x393.  This will make string comparisons unreliable.
.Sp
You likely need to figure out how this multi-byte character got mixed up
with your single-byte locale (or perhaps you thought you had a \s-1UTF\-8\s0
locale, but Perl disagrees).
.IP "Within []\-length '%c' not allowed" 4
.IX Item "Within []-length '%c' not allowed"
(F) The count in the (un)pack template may be replaced by \f(CW\*(C`[TEMPLATE]\*(C'\fR
only if \f(CW\*(C`TEMPLATE\*(C'\fR always matches the same amount of packed bytes that
can be determined from the template alone.  This is not possible if
it contains any of the codes @, /, U, u, w or a *\-length.  Redesign
the template.
.IP "%s() with negative argument" 4
.IX Item "%s() with negative argument"
(S misc) Certain operations make no sense with negative arguments.
Warning is given and the operation is not done.
.ie n .IP "\fBwrite()\fR on closed filehandle %s" 4
.el .IP "\fBwrite()\fR on closed filehandle \f(CW%s\fR" 4
.IX Item "write() on closed filehandle %s"
(W closed) The filehandle you're writing to got itself closed sometime
before now.  Check your control flow.
.ie n .IP "%s ""\ex%X"" does not map to Unicode" 4
.el .IP "\f(CW%s\fR ``\ex%X'' does not map to Unicode" 4
.IX Item "%s x%X does not map to Unicode"
(S utf8) When reading in different encodings, Perl tries to
map everything into Unicode characters.  The bytes you read
in are not legal in this encoding.  For example
.Sp
.Vb 1
\&    utf8 "\exE4" does not map to Unicode
.Ve
.Sp
if you try to read in the a\-diaereses Latin\-1 as \s-1UTF\-8.\s0
.IP "'X' outside of string" 4
.IX Item "'X' outside of string"
(F) You had a (un)pack template that specified a relative position before
the beginning of the string being (un)packed.  See \*(L"pack\*(R" in perlfunc.
.IP "'x' outside of string in unpack" 4
.IX Item "'x' outside of string in unpack"
(F) You had a pack template that specified a relative position after
the end of the string being unpacked.  See \*(L"pack\*(R" in perlfunc.
.IP "\s-1YOU HAVEN\s0'T \s-1DISABLED\s0 SET-ID \s-1SCRIPTS IN THE KERNEL YET\s0!" 4
.IX Item "YOU HAVEN'T DISABLED SET-ID SCRIPTS IN THE KERNEL YET!"
(F) And you probably never will, because you probably don't have the
sources to your kernel, and your vendor probably doesn't give a rip
about what you want.  There is a vulnerability anywhere that you have a
set-id script, and to close it you need to remove the set-id bit from
the script that you're attempting to run.  To actually run the script
set-id, your best bet is to put a set-id C wrapper around your script.
.ie n .IP "You need to quote ""%s""" 4
.el .IP "You need to quote ``%s''" 4
.IX Item "You need to quote %s"
(W syntax) You assigned a bareword as a signal handler name.
Unfortunately, you already have a subroutine of that name declared,
which means that Perl 5 will try to call the subroutine when the
assignment is executed, which is probably not what you want.  (If it \s-1IS\s0
what you want, put an & in front.)
.IP "Your random numbers are not that random" 4
.IX Item "Your random numbers are not that random"
(F) When trying to initialize the random seed for hashes, Perl could
not get any randomness out of your system.  This usually indicates
Something Very Wrong.
.IP "Zero length \eN{} in regex; marked by <\-\-\ \s-1HERE\s0 in m/%s/" 4
.IX Item "Zero length N{} in regex; marked by <--HERE in m/%s/"
(F) Named Unicode character escapes (\f(CW\*(C`\eN{...}\*(C'\fR) may return a zero-length
sequence.  Such an escape was used in an extended character class, i.e.
\&\f(CW\*(C`(?[...])\*(C'\fR, or under \f(CW\*(C`use re \*(Aqstrict\*(Aq\*(C'\fR, which is not permitted.  Check
that the correct escape has been used, and the correct charnames handler
is in scope.  The <\-\-\ \s-1HERE\s0 shows whereabouts in the regular
expression the problem was discovered.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
warnings, diagnostics.
