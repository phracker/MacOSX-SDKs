.\" Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Inline 3"
.TH Inline 3 "2020-01-09" "perl v5.30.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Inline \- Write Perl Subroutines in Other Programming Languages
.SH "VERSION"
.IX Header "VERSION"
This document describes Inline version \fB0.86\fR.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use Inline C;
\&
\&    print "9 + 16 = ", add(9, 16), "\en";
\&    print "9 \- 16 = ", subtract(9, 16), "\en";
\&
\&    _\|_END_\|_
\&    _\|_C_\|_
\&    int add(int x, int y) {
\&      return x + y;
\&    }
\&
\&    int subtract(int x, int y) {
\&      return x \- y;
\&    }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The Inline module allows you to put source code from other programming
languages directly \*(L"inline\*(R" in a Perl script or module. The code is
automatically compiled as needed, and then loaded for immediate access
from Perl.
.PP
Inline saves you from the hassle of having to write and compile your own glue
code using facilities like \s-1XS\s0 or \s-1SWIG.\s0 Simply type the code where you want it
and run your Perl as normal. All the hairy details are handled for you. The
compilation and installation of your code chunks all happen transparently; all
you will notice is the delay of compilation on the first run.
.PP
The Inline code only gets compiled the first time you run it (or whenever it
is modified) so you only take the performance hit once. Code that is Inlined
into distributed modules (like on the \s-1CPAN\s0) will get compiled when the module
is installed, so the end user will never notice the compilation time.
.PP
Best of all, it works the same on both Unix and Microsoft Windows. See Inline\-
Support for support information.
.SS "Why Inline?"
.IX Subsection "Why Inline?"
Do you want to know \*(L"Why would I use other languages in Perl?\*(R" or \*(L"Why should
I use Inline to do it?\*(R"? I'll try to answer both.
.IP "Why would I use other languages in Perl?" 4
.IX Item "Why would I use other languages in Perl?"
The most obvious reason is performance. For an interpreted language, Perl is
very fast. Many people will say \*(L"Anything Perl can do, C can do faster\*(R". (They
never mention the development time :\-) Anyway, you may be able to remove a
bottleneck in your Perl code by using another language, without having to
write the entire program in that language. This keeps your overall development
time down, because you're using Perl for all of the non-critical code.
.Sp
Another reason is to access functionality from existing API-s that use the
language. Some of this code may only be available in binary form. But by
creating small subroutines in the native language, you can \*(L"glue\*(R" existing
libraries to your Perl. As a user of the \s-1CPAN,\s0 you know that code reuse is a
good thing. So why throw away those Fortran libraries just yet?
.Sp
If you are using Inline with the C language, then you can access the full
internals of Perl itself. This opens up the floodgates to both extreme power
and peril.
.Sp
Maybe the best reason is \*(L"Because you want to!\*(R". Diversity keeps the world
interesting. \s-1TMTOWTDI\s0!
.IP "Why should I use Inline to do it?" 4
.IX Item "Why should I use Inline to do it?"
There are already two major facilities for extending Perl with C. They are \s-1XS\s0
and \s-1SWIG.\s0 Both are similar in their capabilities, at least as far as Perl is
concerned. And both of them are quite difficult to learn compared to Inline.
.Sp
There is a big fat learning curve involved with setting up and using the \s-1XS\s0
environment. You need to get quite intimate with the following docs:
.RS 4
.IP "\(bu" 4
perlxs
.IP "\(bu" 4
perlxstut
.IP "\(bu" 4
perlapi
.IP "\(bu" 4
perlguts
.IP "\(bu" 4
perlmod
.IP "\(bu" 4
h2xs
.IP "\(bu" 4
xsubpp
.IP "\(bu" 4
ExtUtils::MakeMaker
.RE
.RS 4
.Sp
With Inline you can be up and running in minutes. There is a C Cookbook with
lots of short but complete programs that you can extend to your real-life
problems. No need to learn about the complicated build process going on in the
background. You don't even need to compile the code yourself. Inline takes
care of every last detail except writing the C code.
.Sp
Perl programmers cannot be bothered with silly things like compiling. \*(L"Tweak,
Run, Tweak, Run\*(R" is our way of life. Inline does all the dirty work for you.
.Sp
Another advantage of Inline is that you can use it directly in a script. You
can even use it in a Perl one-liner. With \s-1XS\s0 and \s-1SWIG,\s0 you always set up an
entirely separate module. Even if you only have one or two functions. Inline
makes easy things easy, and hard things possible. Just like Perl.
.Sp
Finally, Inline supports several programming languages (not just C and
\&\*(C+). As of this writing, Inline has support for C, \*(C+, Java, Python,
Ruby, Tcl, Assembler, Basic, Guile, Befunge, Octave, Awk, \s-1BC, TT\s0 (Template
Toolkit), WebChat and even \s-1PERL.\s0 New Inline Language Support Modules
(ILSMs) are regularly being added. See Inline-API for details on how to
create your own \s-1ILSM.\s0
.RE
.SH "USING THE INLINE.PM MODULE"
.IX Header "USING THE INLINE.PM MODULE"
Inline is a little bit different than most of the Perl modules that you are
used to. It doesn't import any functions into your namespace and it doesn't
have any object oriented methods. Its entire interface (with two minor
exceptions) is specified through the \f(CW\*(Aquse Inline ...\*(Aq\fR command.
.PP
This section will explain all of the different ways to \f(CW\*(C`use Inline\*(C'\fR. If you
want to begin using C with Inline immediately, see Inline::C\-Cookbook.
.SS "The Basics"
.IX Subsection "The Basics"
The most basic form for using Inline is:
.PP
.Vb 1
\&    use Inline X => "X source code";
.Ve
.PP
where 'X' is one of the supported Inline programming languages. The second
parameter identifies the source code that you want to bind to Perl. The source
code can be specified using any of the following syntaxes:
.IP "The \s-1DATA\s0 Keyword." 4
.IX Item "The DATA Keyword."
.Vb 1
\&    use Inline Java => \*(AqDATA\*(Aq;
\&
\&    # Perl code goes here ...
\&
\&    _\|_DATA_\|_
\&    _\|_Java_\|_
\&    /* Java code goes here ... */
.Ve
.Sp
The easiest and most visually clean way to specify your source code in an
Inline Perl program is to use the special \f(CW\*(C`DATA\*(C'\fR keyword. This tells Inline
to look for a special marker in your \f(CW\*(C`DATA\*(C'\fR filehandle's input stream. In
this example the special marker is \f(CW\*(C`_\|_Java_\|_\*(C'\fR, which is the programming
language surrounded by double underscores.
.Sp
In case you've forgotten, the \f(CW\*(C`DATA\*(C'\fR pseudo file is comprised of all the text
after the \f(CW\*(C`_\|_END_\|_\*(C'\fR or \f(CW\*(C`_\|_DATA_\|_\*(C'\fR section of your program. If you're working
outside the \f(CW\*(C`main\*(C'\fR package, you'd best use the \f(CW\*(C`_\|_DATA_\|_\*(C'\fR marker or else
Inline will not find your code.
.Sp
Using this scheme keeps your Perl code at the top, and all the ugly Java stuff
down below where it belongs. This is visually clean and makes for more
maintainable code. An excellent side benefit is that you don't have to escape
any characters like you might in a Perl string. The source code is verbatim.
For these reasons, I prefer this method the most.
.Sp
The only problem with this style is that since Perl can't read the \f(CW\*(C`DATA\*(C'\fR
filehandle until runtime, it obviously can't bind your functions until
runtime. The net effect of this is that you can't use your Inline functions as
barewords (without predeclaring them) because Perl has no idea they exist
during compile time.
.IP "The \s-1FILE\s0 and \s-1BELOW\s0 keywords." 4
.IX Item "The FILE and BELOW keywords."
.Vb 2
\&    use Inline::Files;
\&    use Inline Java => \*(Aqfile\*(Aq;
\&
\&    # Perl code goes here ...
\&
\&    _\|_JAVA_\|_
\&    /* Java code goes here ... */
.Ve
.Sp
This is the newest method of specifying your source code. It makes use of the
Perl module \f(CW\*(C`Inline::Files\*(C'\fR written by Damian Conway. The basic style and
meaning are the same as for the \f(CW\*(C`DATA\*(C'\fR keyword, but there are a few syntactic
and semantic twists.
.Sp
First, you must say 'use Inline::Files' before you 'use Inline' code that
needs those files. The special '\f(CW\*(C`DATA\*(C'\fR' keyword is replaced by either
\&'\f(CW\*(C`file\*(C'\fR' or '\f(CW\*(C`below\*(C'\fR'. This allows for the bad pun idiom of:
.Sp
.Vb 1
\&    use Inline C => \*(Aqbelow\*(Aq;
.Ve
.Sp
You can omit the \f(CW\*(C`_\|_DATA_\|_\*(C'\fR tag now. Inline::Files is a source filter that
will remove these sections from your program before Perl compiles it. They are
then available for Inline to make use of. And since this can all be done at
compile time, you don't have to worry about the caveats of the '\s-1DATA\s0' keyword.
.Sp
This module has a couple small gotchas. Since Inline::Files only recognizes
file markers with capital letters, you must specify the capital form of
your language name. Also, there is a startup time penalty for using a
source code filter.
.Sp
At this point Inline::Files is alpha software and use of it is experimental.
Inline's integration of this module is also fledgling at the time being. One
of things I plan to do with Inline::Files is to get line number info so when
an extension doesn't compile, the error messages will point to the correct
source file and line number.
.Sp
My best advice is to use Inline::Files for testing (especially as support for
it improves), but use \s-1DATA\s0 for production and distributed/CPAN code.
.IP "Strings" 4
.IX Item "Strings"
.Vb 1
\&    use Inline Java => <<\*(AqEND\*(Aq;
\&
\&    /* Java code goes here ... */
\&    END
\&
\&    # Perl code goes here ...
.Ve
.Sp
You also just specify the source code as a single string. A handy way to write
the string is to use Perl's \*(L"here document\*(R" style of quoting. This is ok for
small functions but can get unwieldy in the large. On the other hand, the
string variant probably has the least startup penalty and all functions are
bound at compile time.
.Sp
If you wish to put the string into a scalar variable, please be aware that the
\&\f(CW\*(C`use\*(C'\fR statement is a compile time directive. As such, all the variables it
uses must also be set at compile time, \f(CW\*(C`before\*(C'\fR the 'use Inline' statement.
Here is one way to do it:
.Sp
.Vb 3
\&    my $code;
\&    BEGIN {
\&        $code = <<END;
\&
\&    /* Java code goes here ... */
\&    END
\&    }
\&    use Inline Java => $code;
\&
\&    # Perl code goes here ...
.Ve
.IP "The \fBbind()\fR Function" 4
.IX Item "The bind() Function"
An alternative to using the \s-1BEGIN\s0 block method is to specify the source code
at run time using the 'Inline\->\fBbind()\fR' method. (This is one of the interface
exceptions mentioned above) The \f(CW\*(C`bind()\*(C'\fR method takes the same arguments as
\&\f(CW\*(Aquse Inline ...\*(Aq\fR.
.Sp
.Vb 1
\&    my $code = <<END;
\&
\&    /* Java code goes here ... */
\&    END
\&
\&    Inline\->bind(Java => $code);
.Ve
.Sp
You can think of \f(CW\*(C`bind()\*(C'\fR as a way to \f(CW\*(C`eval()\*(C'\fR code in other programming
languages.
.Sp
Although \fBbind()\fR is a powerful feature, it is not recommended for use in Inline
based modules. In fact, it won't work at all for installable modules. See
instructions below for creating modules with Inline.
.IP "Other Methods" 4
.IX Item "Other Methods"
The source code for Inline can also be specified as an external filename, a
reference to a subroutine that returns source code, or a reference to an array
that contains lines of source code. (Note that if the external source file is
in the current directory it must be specified with a leading '.\fI' \- ie
\&'.\fRfile.ext' instead of simply 'file.ext'.) These methods are less frequently
used but may be useful in some situations.
.Sp
For instance, to load your \*(C+ code from a file named the same as your perl
module with a swapped file extension, you can use:
.Sp
.Vb 1
\&    use Inline CPP => (_\|_FILE_\|_ =~ s/\e.pm$/.cpp/r);
.Ve
.IP "Shorthand" 4
.IX Item "Shorthand"
If you are using the '\s-1DATA\s0' or 'file' methods described above \fBand\fR there are
no extra parameters, you can omit the keyword altogether. For example:
.Sp
.Vb 1
\&    use Inline \*(AqJava\*(Aq;
\&
\&    # Perl code goes here ...
\&
\&    _\|_DATA_\|_
\&    _\|_Java_\|_
\&    /* Java code goes here ... */
.Ve
.Sp
or
.Sp
.Vb 2
\&    use Inline::Files;
\&    use Inline \*(AqJava\*(Aq;
\&
\&    # Perl code goes here ...
\&
\&    _\|_JAVA_\|_
\&    /* Java code goes here ... */
.Ve
.SS "More about the \s-1DATA\s0 Section"
.IX Subsection "More about the DATA Section"
If you are writing a module, you can also use the \s-1DATA\s0 section for \s-1POD\s0 and
AutoLoader subroutines. Just be sure to put them before the first Inline
marker. If you install the helper module \f(CW\*(C`Inline::Filters\*(C'\fR, you can even
use \s-1POD\s0 inside your Inline code. You just have to specify a filter to
strip it out.
.PP
You can also specify multiple Inline sections, possibly in different
programming languages. Here is another example:
.PP
.Vb 3
\&    # The module Foo.pm
\&    package Foo;
\&    use AutoLoader;
\&
\&    use Inline C;
\&    use Inline C => DATA => filters => \*(AqStrip_POD\*(Aq;
\&    use Inline Python;
\&
\&    1;
\&
\&    _\|_DATA_\|_
\&
\&    sub marine {
\&        # This is an autoloaded subroutine
\&    }
\&
\&    =head1 External subroutines
\&
\&    =cut
\&
\&    _\|_C_\|_
\&    /* First C section */
\&
\&    _\|_C_\|_
\&    /* Second C section */
\&    =head1 My C Function
\&
\&    Some POD doc.
\&
\&    =cut
\&
\&    _\|_Python_\|_
\&    """A Python Section"""
.Ve
.PP
An important thing to remember is that you need to have one \f(CW\*(C`use Inline Foo
=> \*(AqDATA\*(Aq\*(C'\fR for each \f(CW\*(C`_\|_Foo_\|_\*(C'\fR marker, and they must be in the same order.
This allows you to apply different configuration options to each section.
.SS "Configuration Options"
.IX Subsection "Configuration Options"
Inline tries to do the right thing as often as possible. But sometimes you may
need to override the default actions. This is easy to do. Simply list the
Inline configuration options after the regular Inline parameters. All
configuration options are specified as (key, value) pairs.
.PP
.Vb 7
\&    use Inline (C => \*(AqDATA\*(Aq,
\&                directory => \*(Aq./inline_dir\*(Aq,
\&                libs => \*(Aq\-lfoo\*(Aq,
\&                inc => \*(Aq\-I/foo/include\*(Aq,
\&                prefix => \*(AqXXX_\*(Aq,
\&                warnings => 0,
\&               );
.Ve
.PP
You can also specify the configuration options on a separate Inline call
like this:
.PP
.Vb 8
\&    use Inline (C => Config =>
\&                directory => \*(Aq./inline_dir\*(Aq,
\&                libs => \*(Aq\-lfoo\*(Aq,
\&                inc => \*(Aq\-I/foo/include\*(Aq,
\&                prefix => \*(AqXXX_\*(Aq,
\&                warnings => 0,
\&               );
\&    use Inline C => <<\*(AqEND_OF_C_CODE\*(Aq;
.Ve
.PP
The special keyword \f(CW\*(AqConfig\*(Aq\fR tells Inline that this is a configuration-only
call. No source code will be compiled or bound to Perl.
.PP
If you want to specify global configuration options that don't apply to a
particular language, just leave the language out of the call. Like this:
.PP
.Vb 1
\&    use Inline Config => warnings => 0;
.Ve
.PP
The Config options are inherited and additive. You can use as many Config
calls as you want. And you can apply different options to different code
sections. When a source code section is passed in, Inline will apply
whichever options have been specified up to that point. Here is a complex
configuration example:
.PP
.Vb 10
\&    use Inline (Config =>
\&                directory => \*(Aq./inline_dir\*(Aq,
\&               );
\&    use Inline (C => Config =>
\&                libs => \*(Aq\-lglobal\*(Aq,
\&               );
\&    use Inline (C => \*(AqDATA\*(Aq,         # First C Section
\&                libs => [\*(Aq\-llocal1\*(Aq, \*(Aq\-llocal2\*(Aq],
\&               );
\&    use Inline (Config =>
\&                warnings => 0,
\&               );
\&    use Inline (Python => \*(AqDATA\*(Aq,    # First Python Section
\&                libs => \*(Aq\-lmypython1\*(Aq,
\&               );
\&    use Inline (C => \*(AqDATA\*(Aq,         # Second C Section
\&                libs => [undef, \*(Aq\-llocal3\*(Aq],
\&               );
.Ve
.PP
The first \f(CW\*(C`Config\*(C'\fR applies to all subsequent calls. The second \f(CW\*(C`Config\*(C'\fR
applies to all subsequent \f(CW\*(C`C\*(C'\fR sections (but not \f(CW\*(C`Python\*(C'\fR sections). In the
first \f(CW\*(C`C\*(C'\fR section, the external libraries \f(CW\*(C`global\*(C'\fR, \f(CW\*(C`local1\*(C'\fR and \f(CW\*(C`local2\*(C'\fR
are used. (Most options allow either string or array ref forms, and do the
right thing.) The \f(CW\*(C`Python\*(C'\fR section does not use the \f(CW\*(C`global\*(C'\fR library, but
does use the same \f(CW\*(C`DIRECTORY\*(C'\fR, and has warnings turned off. The second \f(CW\*(C`C\*(C'\fR
section only uses the \f(CW\*(C`local3\*(C'\fR library. That's because a value of \f(CW\*(C`undef\*(C'\fR
resets the additive behavior.
.PP
The \f(CW\*(C`directory\*(C'\fR and \f(CW\*(C`warnings\*(C'\fR options are generic Inline options. All other
options are language specific. To find out what the \f(CW\*(C`C\*(C'\fR options do, see
\&\f(CW\*(C`Inline::C\*(C'\fR.
.SS "On and Off"
.IX Subsection "On and Off"
If a particular config option has value options of 1 and 0, you can use the
\&'enable' and 'disable' modifiers. In other words, this:
.PP
.Vb 3
\&    use Inline Config =>
\&               force_build => 1,
\&               clean_after_build => 0;
.Ve
.PP
could be reworded as:
.PP
.Vb 3
\&    use Inline Config =>
\&               enable => force_build =>
\&               disable => clean_after_build;
.Ve
.SS "Playing 'with' Others"
.IX Subsection "Playing 'with' Others"
Inline has a special configuration syntax that tells it to get more
configuration options from other Perl modules. Here is an example:
.PP
.Vb 1
\&    use Inline with => \*(AqEvent\*(Aq;
.Ve
.PP
This tells Inline to load the module \f(CW\*(C`Event.pm\*(C'\fR and ask it for configuration
information. Since \f(CW\*(C`Event\*(C'\fR has a C \s-1API\s0 of its own, it can pass Inline all of
the information it needs to be able to use \f(CW\*(C`Event\*(C'\fR C callbacks seamlessly.
.PP
That means that you don't need to specify the typemaps, shared libraries,
include files and other information required to get this to work.
.PP
You can specify a single module or a list of them. Like:
.PP
.Vb 1
\&    use Inline with => qw(Event Foo Bar);
.Ve
.PP
Currently, modules that works \fIwith\fR Inline include \f(CW\*(C`Event\*(C'\fR, \f(CW\*(C`PDL\*(C'\fR, and
those that use \f(CW\*(C`Alien::Build\*(C'\fR.
.PP
In order to make \fByour\fR module work \fIwith\fR Inline in this way, your module
needs to provide a class method called \f(CW\*(C`Inline\*(C'\fR that takes an Inline language
as a parameter (e.g. \*(L"C\*(R"), and returns a reference to a hash with
configuration information that is acceptable to the relevant \s-1ILSM.\s0 For C, see
C Configuration Options. E.g.:
.PP
.Vb 2
\&    my $confighashref = Event\->Inline(\*(AqC\*(Aq); # only supports C in 1.21
\&    # hashref contains keys INC, TYPEMAPS, MYEXTLIB, AUTO_INCLUDE, BOOT
.Ve
.PP
If your module uses ExtUtils::Depends version 0.400 or higher, your module
only needs this:
.PP
.Vb 2
\&    package Module;
\&    use autouse Module::Install::Files => qw(Inline);
.Ve
.SS "Inline Shortcuts"
.IX Subsection "Inline Shortcuts"
Inline lets you set many configuration options from the command line. These
options are called 'shortcuts'. They can be very handy, especially when you
only want to set the options temporarily, for say, debugging.
.PP
For instance, to get some general information about your Inline code in the
script \f(CW\*(C`Foo.pl\*(C'\fR, use the command:
.PP
.Vb 1
\&    perl \-MInline=info Foo.pl
.Ve
.PP
If you want to force your code to compile, even if its already done, use:
.PP
.Vb 1
\&    perl \-MInline=force Foo.pl
.Ve
.PP
If you want to do both, use:
.PP
.Vb 1
\&    perl \-MInline=info \-MInline=force Foo.pl
.Ve
.PP
or better yet:
.PP
.Vb 1
\&    perl \-MInline=info,force Foo.pl
.Ve
.SS "The Inline 'directory'"
.IX Subsection "The Inline 'directory'"
Inline needs a place to build your code and to install the results of the
build. It uses a single directory named \f(CW\*(Aq.Inline/\*(Aq\fR under normal
circumstances. If you create this directory in your home directory, the
current directory or in the directory where your program resides, Inline will
find and use it. You can also specify it in the environment variable
\&\f(CW\*(C`PERL_INLINE_DIRECTORY\*(C'\fR or directly in your program, by using the
\&\f(CW\*(C`directory\*(C'\fR keyword option. If Inline cannot find the directory in any of
these places it will create a \f(CW\*(Aq_Inline/\*(Aq\fR directory in either your current
directory or the directory where your script resides.
.PP
One of the key factors to using Inline successfully, is understanding this
directory. When developing code it is usually best to create this directory
(or let Inline do it) in your current directory. Remember that there is
nothing sacred about this directory except that it holds your compiled code.
Feel free to delete it at any time. Inline will simply start from scratch and
recompile your code on the next run. If you have several programs that you
want to force to recompile, just delete your \f(CW\*(Aq.Inline/\*(Aq\fR directory.
.PP
It is probably best to have a separate \f(CW\*(Aq.Inline/\*(Aq\fR directory for each
project that you are working on. You may want to keep stable code in the
<.Inline/> in your home directory. On multi-user systems, each user should
have their own \f(CW\*(Aq.Inline/\*(Aq\fR directories. It could be a security risk to put
the directory in a shared place like \f(CW\*(C`/tmp/\*(C'\fR.
.SS "Debugging Inline Errors"
.IX Subsection "Debugging Inline Errors"
All programmers make mistakes. When you make a mistake with Inline, like
writing bad C code, you'll get a big error report on your screen. This report
tells you where to look to do the debugging. Some languages may also dump out
the error messages generated from the build.
.PP
When Inline needs to build something it creates a subdirectory under your
\&\f(CW\*(C`DIRECTORY/build/\*(C'\fR directory. This is where it writes all the components it
needs to build your extension. Things like \s-1XS\s0 files, Makefiles and output
log files.
.PP
If everything goes \s-1OK,\s0 Inline will delete this subdirectory. If there is
an error, Inline will leave the directory intact and print its location.
The idea is that you are supposed to go into that directory and figure out
what happened.
.PP
Read the doc for your particular Inline Language Support Module for more
information.
.SS "The 'config' Registry File"
.IX Subsection "The 'config' Registry File"
Inline keeps a cached file of all of the Inline Language Support Module's meta
data in a file called \f(CW\*(C`config\*(C'\fR. This file can be found in your \f(CW\*(C`directory\*(C'\fR
directory. If the file does not exist, Inline creates a new one. It will
search your system for any module beginning with \f(CW\*(C`Inline::\*(C'\fR. It will then
call that module's \f(CW\*(C`register()\*(C'\fR method to get useful information for future
invocations.
.PP
Whenever you add a new \s-1ILSM,\s0 you should delete this file so that Inline will
auto-discover your newly installed language module. (This should no longer be
necessary as of Inline\-0.49.)
.SH "CONFIGURATION OPTIONS"
.IX Header "CONFIGURATION OPTIONS"
This section lists all of the generic Inline configuration options. For
language specific configuration, see the doc for that language.
.ie n .IP """directory""" 4
.el .IP "\f(CWdirectory\fR" 4
.IX Item "directory"
The \f(CW\*(C`directory\*(C'\fR config option is the directory that Inline uses to both build
and install an extension.
.Sp
Normally Inline will search in a bunch of known places for a directory called
\&\f(CW\*(Aq.Inline/\*(Aq\fR. Failing that, it will create a directory called \f(CW\*(Aq_Inline/\*(Aq\fR
.Sp
If you want to specify your own directory, use this configuration option.
.Sp
Note that you must create the \f(CW\*(C`directory\*(C'\fR directory yourself. Inline will not
do it for you.
.ie n .IP """name""" 4
.el .IP "\f(CWname\fR" 4
.IX Item "name"
You can use this option to set the name of your Inline extension object
module. For example:
.Sp
.Vb 2
\&    use Inline C => \*(AqDATA\*(Aq,
\&               name => \*(AqFoo::Bar\*(Aq;
.Ve
.Sp
would cause your C code to be compiled in to the object:
.Sp
.Vb 2
\&    lib/auto/Foo/Bar/Bar.so
\&    lib/auto/Foo/Bar/Bar.inl
.Ve
.Sp
(The .inl component contains dependency information to make sure the source
code is in sync with the executable)
.Sp
If you don't use \f(CW\*(C`name\*(C'\fR, Inline will pick a name for you based on your
program name or package name. In this case, Inline will also enable the
\&\f(CW\*(C`autoname\*(C'\fR option which mangles in a small piece of the \s-1MD5\s0 fingerprint into
your object name, to make it unique.
.ie n .IP """autoname""" 4
.el .IP "\f(CWautoname\fR" 4
.IX Item "autoname"
This option is enabled whenever the \f(CW\*(C`name\*(C'\fR parameter is not specified. To
disable it say:
.Sp
.Vb 2
\&    use Inline C => \*(AqDATA\*(Aq,
\&               disable => \*(Aqautoname\*(Aq;
.Ve
.Sp
\&\f(CW\*(C`autoname\*(C'\fR mangles in enough of the \s-1MD5\s0 fingerprint to make your module name
unique. Objects created with \f(CW\*(C`autoname\*(C'\fR will never get replaced. That also
means they will never get cleaned up automatically.
.Sp
\&\f(CW\*(C`autoname\*(C'\fR is very useful for small throw away scripts. For more serious
things, always use the \f(CW\*(C`name\*(C'\fR option.
.ie n .IP """version""" 4
.el .IP "\f(CWversion\fR" 4
.IX Item "version"
Specifies the version number of the Inline extension object. It is used
\&\fBonly\fR for modules, and it must match the global variable \f(CW$VERSION\fR.
Additionally, this option should used if (and only if) a module is being set
up to be installed permanently into the Perl sitelib tree using
Inline::MakeMaker (\s-1NOT\s0 used by Inline::Module). Inline will croak if you use
it otherwise.
.Sp
The presence of the \f(CW\*(C`version\*(C'\fR parameter is the official way to let Inline
know that your code is an installable/installed module. Inline will never
generate an object in the temporary cache (\f(CW\*(C`_Inline/\*(C'\fR directory) if
\&\f(CW\*(C`version\*(C'\fR is set. It will also never try to recompile a module that was
installed into someone's Perl site tree.
.Sp
So the basic rule is develop without \f(CW\*(C`version\*(C'\fR, and deliver with \f(CW\*(C`version\*(C'\fR.
.ie n .IP """with""" 4
.el .IP "\f(CWwith\fR" 4
.IX Item "with"
\&\f(CW\*(C`with\*(C'\fR can also be used as a configuration option instead of using the
special 'with' syntax. Do this if you want to use different sections of Inline
code \fIwith\fR different modules. (Probably a very rare usage)
.Sp
.Vb 2
\&    use Event;
\&    use Inline C => DATA => with => \*(AqEvent\*(Aq;
.Ve
.Sp
Modules specified using the config form of \f(CW\*(C`with\*(C'\fR will \fBnot\fR be
automatically required. You must \f(CW\*(C`use\*(C'\fR them yourself.
.ie n .IP """using""" 4
.el .IP "\f(CWusing\fR" 4
.IX Item "using"
You can override modules that get used by ILSMs with the \f(CW\*(C`using\*(C'\fR option. This
is typically used to override the default parser for Inline::C, but might
be used by any \s-1ILSM\s0 for any purpose.
.Sp
.Vb 2
\&    use Inline config => using => \*(Aq::Parser::RecDescent\*(Aq;
\&    use Inline C => \*(Aq...\*(Aq;
.Ve
.Sp
This would tell Inline::C to use Inline::C::Parser::RecDescent.
.ie n .IP """global_load""" 4
.el .IP "\f(CWglobal_load\fR" 4
.IX Item "global_load"
This option is for compiled languages only. It tells Inline to tell DynaLoader
to load an object file in such a way that its symbols can be dynamically
resolved by other object files. May not work on all platforms. See the
\&\f(CW\*(C`global\*(C'\fR shortcut below.
.ie n .IP """untaint""" 4
.el .IP "\f(CWuntaint\fR" 4
.IX Item "untaint"
You can use this option whenever you use Perl's \f(CW\*(C`\-T\*(C'\fR switch, for taint
checking. This option tells Inline to blindly untaint all tainted variables.
(This is generally considered to be an appallingly insecure thing to do, and
not to be recommended \- but the option is there for you to use if you want.
Please consider using something other than Inline for scripts that need taint
checking.) It also turns on \f(CW\*(C`safemode\*(C'\fR by default. See the \f(CW\*(C`untaint\*(C'\fR
shortcut below. You will see warnings about blindly untainting fields in both
\&\f(CW%ENV\fR and Inline objects. If you want to silence these warnings, set the Config
option \f(CW\*(C`no_untaint_warn\*(C'\fR => 1. There can be some problems untainting Inline
scripts where older versions of Cwd, such as those that shipped with early
versions of perl\-5.8 (and earlier), are installed. Updating Cwd will probably
solve these problems.
.IP "safemode" 4
.IX Item "safemode"
Perform extra safety checking, in an attempt to thwart malicious code. This
option cannot guarantee security, but it does turn on all the currently
implemented checks. (Currently, the only \*(L"currently implemented check\*(R" is to
ensure that the \f(CW\*(C`directory\*(C'\fR option has also been used.)
.Sp
There is a slight startup penalty by using \f(CW\*(C`safemode\*(C'\fR. Also, using \f(CW\*(C`untaint\*(C'\fR
automatically turns this option on. If you need your code to start faster
under \f(CW\*(C`\-T\*(C'\fR (taint) checking, you'll need to turn this option off manually.
Only do this if you are not worried about security risks. See the \f(CW\*(C`unsafe\*(C'\fR
shortcut below.
.ie n .IP """force_build""" 4
.el .IP "\f(CWforce_build\fR" 4
.IX Item "force_build"
Makes Inline build (compile) the source code every time the program is run.
The default is 0. See the \f(CW\*(C`force\*(C'\fR shortcut below.
.ie n .IP """build_noisy""" 4
.el .IP "\f(CWbuild_noisy\fR" 4
.IX Item "build_noisy"
Tells ILSMs that they should dump build messages to the terminal rather than
be silent about all the build details.
.ie n .IP """build_timers""" 4
.el .IP "\f(CWbuild_timers\fR" 4
.IX Item "build_timers"
Tells ILSMs to print timing information about how long each build phase took.
Usually requires \f(CW\*(C`Time::HiRes\*(C'\fR.
.ie n .IP """clean_after_build""" 4
.el .IP "\f(CWclean_after_build\fR" 4
.IX Item "clean_after_build"
Tells Inline to clean up the current build area if the build was successful.
Sometimes you want to \f(CW\*(C`disable\*(C'\fR this for debugging. Default is 1. See the
\&\f(CW\*(C`noclean\*(C'\fR shortcut below.
.ie n .IP """clean_build_area""" 4
.el .IP "\f(CWclean_build_area\fR" 4
.IX Item "clean_build_area"
Tells Inline to clean up the old build areas within the entire Inline
\&\f(CW\*(C`directory\*(C'\fR. Default is 0. See the \f(CW\*(C`clean\*(C'\fR shortcut below.
.ie n .IP """print_info""" 4
.el .IP "\f(CWprint_info\fR" 4
.IX Item "print_info"
Tells Inline to print various information about the source code. Default is 0.
See the \f(CW\*(C`info\*(C'\fR shortcut below.
.ie n .IP """print_version""" 4
.el .IP "\f(CWprint_version\fR" 4
.IX Item "print_version"
Tells Inline to print version info about itself. Default is 0. See the
\&\f(CW\*(C`version\*(C'\fR shortcut below.
.ie n .IP """reportbug""" 4
.el .IP "\f(CWreportbug\fR" 4
.IX Item "reportbug"
Puts Inline into 'reportbug' mode, which is what you want if you desire to
report a bug.
.ie n .IP """rewrite_config_file""" 4
.el .IP "\f(CWrewrite_config_file\fR" 4
.IX Item "rewrite_config_file"
Default is 0, but setting \f(CW\*(C`rewrite_config_file => 1\*(C'\fR will mean that the
existing configuration file in the Inline \f(CW\*(C`directory\*(C'\fR will be overwritten.
(This is useful if the existing config file is not up to date as regards
supported languages.)
.ie n .IP """warnings""" 4
.el .IP "\f(CWwarnings\fR" 4
.IX Item "warnings"
This option tells Inline whether to print certain warnings. Default is 1.
.SH "INLINE CONFIGURATION SHORTCUTS"
.IX Header "INLINE CONFIGURATION SHORTCUTS"
This is a list of all the shortcut configuration options currently available
for Inline. Specify them from the command line when running Inline scripts.
.PP
.Vb 1
\&    perl \-MInline=noclean inline_script.pl
.Ve
.PP
or
.PP
.Vb 1
\&    perl \-MInline=info,force,noclean inline_script.pl
.Ve
.PP
You can specify multiple shortcuts separated by commas. They are not case
sensitive. You can also specify shortcuts inside the Inline program like this:
.PP
.Vb 1
\&    use Inline \*(Aqinfo\*(Aq, \*(Aqforce\*(Aq, \*(Aqnoclean\*(Aq;
.Ve
.PP
\&\s-1NOTE:\s0 If a \f(CW\*(Aquse Inline\*(Aq\fR statement is used to set shortcuts, it can not be
      used for additional purposes.
.ie n .IP """clean""" 4
.el .IP "\f(CWclean\fR" 4
.IX Item "clean"
Tells Inline to remove any build directories that may be lying around in your
build area. Normally these directories get removed immediately after a
successful build. Exceptions are when the build fails, or when you use the
\&\f(CW\*(C`noclean\*(C'\fR or \f(CW\*(C`reportbug\*(C'\fR options.
.ie n .IP """force""" 4
.el .IP "\f(CWforce\fR" 4
.IX Item "force"
Forces the code to be recompiled, even if everything is up to date.
.ie n .IP """global""" 4
.el .IP "\f(CWglobal\fR" 4
.IX Item "global"
Turns on the \f(CW\*(C`global_load\*(C'\fR option.
.ie n .IP """info""" 4
.el .IP "\f(CWinfo\fR" 4
.IX Item "info"
This is a very useful option when you want to know what's going on under the
hood. It tells Inline to print helpful information to \f(CW\*(C`STDERR\*(C'\fR. Among the
things that get printed is a list of which Inline functions were successfully
bound to Perl.
.ie n .IP """noclean""" 4
.el .IP "\f(CWnoclean\fR" 4
.IX Item "noclean"
Tells Inline to leave the build files after compiling.
.ie n .IP """noisy""" 4
.el .IP "\f(CWnoisy\fR" 4
.IX Item "noisy"
Use the \f(CW\*(C`build_noisy\*(C'\fR option to print messages during a build.
.ie n .IP """reportbug""" 4
.el .IP "\f(CWreportbug\fR" 4
.IX Item "reportbug"
Puts Inline into \f(CW\*(C`reportbug\*(C'\fR mode, which does special processing when you
want to report a bug. \f(CW\*(C`reportbug\*(C'\fR also automatically forces a build, and
doesn't clean up afterwards. This is so that you can tar and mail the build
directory to me. \f(CW\*(C`reportbug\*(C'\fR will print exact instructions on what to do.
Please read and follow them carefully.
.Sp
\&\s-1NOTE:\s0 \f(CW\*(C`reportbug\*(C'\fR informs you to use the tar command. If your system does not
      have tar, please use the equivalent \f(CW\*(C`zip\*(C'\fR command.
.ie n .IP """safe""" 4
.el .IP "\f(CWsafe\fR" 4
.IX Item "safe"
Turns \f(CW\*(C`safemode\*(C'\fR on. \f(CW\*(C`untaint\*(C'\fR will turn this on automatically. While this
mode performs extra security checking, it does not guarantee safety.
.ie n .IP """site_install""" 4
.el .IP "\f(CWsite_install\fR" 4
.IX Item "site_install"
This parameter used to be used for creating installable Inline modules. It has
been removed from Inline altogether and replaced with a much simpler and more
powerful mechanism, \f(CW\*(C`Inline::MakeMaker\*(C'\fR. See the section below on how to
create modules with Inline.
.ie n .IP """_testing""" 4
.el .IP "\f(CW_testing\fR" 4
.IX Item "_testing"
Used internally by C\fIt\fR09parser.t and C\fIt\fR10callback.t(in the Inline::C test
suite). Setting this option with Inline::C will mean that files named
\&\f(CW\*(C`parser_id\*(C'\fR and \f(CW\*(C`void_test\*(C'\fR are created in the \f(CW\*(C`./Inline_test\*(C'\fR directory,
creating that directory if it doesn't already exist. The files (but not the
\&\f(CW\*(C`./Inline_test directory\*(C'\fR) are cleaned up by calling
\&\f(CW\*(C`Inline::C::_testing_cleanup()\*(C'\fR. Also used by \f(CW\*(C`t/06rewrite_config.t\*(C'\fR to
trigger a warning.
.ie n .IP """timers""" 4
.el .IP "\f(CWtimers\fR" 4
.IX Item "timers"
Turn on \f(CW\*(C`build_timers\*(C'\fR to get extra diagnostic info about builds.
.ie n .IP """unsafe""" 4
.el .IP "\f(CWunsafe\fR" 4
.IX Item "unsafe"
Turns \f(CW\*(C`safemode\*(C'\fR off. Use this in combination with \f(CW\*(C`untaint\*(C'\fR for slightly
faster startup time under \f(CW\*(C`\-T\*(C'\fR. Only use this if you are sure the
environment is safe.
.ie n .IP """untaint""" 4
.el .IP "\f(CWuntaint\fR" 4
.IX Item "untaint"
Turn the \f(CW\*(C`untaint\*(C'\fR option on. Used with \f(CW\*(C`\-T\*(C'\fR switch. In terms of secure
practices, this is definitely \fBnot\fR a recommended way of dealing with taint
checking, but it's the \fBonly\fR option currently available with Inline. Use it
at your own risk.
.ie n .IP """version""" 4
.el .IP "\f(CWversion\fR" 4
.IX Item "version"
Tells Inline to report its release version.
.SH "WRITING MODULES WITH INLINE"
.IX Header "WRITING MODULES WITH INLINE"
The current preferred way to author \s-1CPAN\s0 modules with Inline is to use
Inline::Module (distributed separately). Inline ships with Inline::MakeMaker,
which helps you set up a Makefile.PL that invokes Inline at install time to
compile all the code before it gets installed, but the resulting module still
depends on Inline and the language support module like Inline::C. In order to
avoid this dependency, what you really want to do is convert your distribution
to plain \s-1XS\s0 before uploading it to \s-1CPAN.\s0 Inline::Module fills that role, and
also integrates well with more modern authoring tools.
.PP
See Inline::Module for details on that approach, or continue reading below for
the older Inline::MakeMaker technique.
.PP
Let's say that you wanted to write a module called \f(CW\*(C`Math::Simple\*(C'\fR. Start by
using the following command:
.PP
.Vb 1
\&    h2xs \-PAXn Math::Simple
.Ve
.PP
This will generate a bunch of files that form a skeleton of what you need for
a distributable module. (Read the h2xs manpage to find out what the options
do) Next, modify the \f(CW\*(C`Simple.pm\*(C'\fR file to look like this:
.PP
.Vb 2
\&    package Math::Simple;
\&    $VERSION = \*(Aq1.23\*(Aq;
\&
\&    use base \*(AqExporter\*(Aq;
\&    @EXPORT_OK = qw(add subtract);
\&    use strict;
\&
\&    use Inline C => \*(AqDATA\*(Aq,
\&               version => \*(Aq1.23\*(Aq,
\&               name => \*(AqMath::Simple\*(Aq;
\&
\&    # The following Inline\->init() call is optional \- see below for more info.
\&    #Inline\->init();
\&
\&    1;
\&
\&    _\|_DATA_\|_
\&
\&    =pod
\&
\&    =cut
\&
\&    _\|_C_\|_
\&    int add(int x, int y) {
\&      return x + y;
\&    }
\&
\&    int subtract(int x, int y) {
\&      return x \- y;
\&    }
.Ve
.PP
The important things to note here are that you \fBmust\fR specify a \f(CW\*(C`name\*(C'\fR and
\&\f(CW\*(C`version\*(C'\fR parameter. The \f(CW\*(C`name\*(C'\fR must match your module's package name. The
\&\f(CW\*(C`version\*(C'\fR parameter must match your module's \f(CW$VERSION\fR variable and they
must be considered valid by \f(CW\*(C`version::parse\*(C'\fR.
.PP
\&\s-1NOTE:\s0 These are Inline's sanity checks to make sure you know what you're doing
      before uploading your code to \s-1CPAN.\s0 They insure that once the module has
      been installed on someone's system, the module would not get
      automatically recompiled for any reason. This makes Inline based modules
      work in exactly the same manner as \s-1XS\s0 based ones.
.PP
Finally, you need to modify the Makefile.PL. Simply change:
.PP
.Vb 1
\&    use ExtUtils::MakeMaker;
.Ve
.PP
to
.PP
.Vb 1
\&    use Inline::MakeMaker;
.Ve
.PP
And, in order that the module build work correctly in the cpan shell, add the
following directive to the Makefile.PL's \fBWriteMakefile()\fR:
.PP
.Vb 4
\&    CONFIGURE_REQUIRES  =>  {
\&        \*(AqInline::MakeMaker\*(Aq     => 0.45,
\&        \*(AqExtUtils::MakeMaker\*(Aq   => 6.52,
\&    },
.Ve
.PP
This \f(CW\*(C`CONFIGURE_REQUIRES\*(C'\fR directive ensures that the cpan shell will install
Inline on the user's machine (if it's not already present) before building
your Inline-based module. Specifying of \*(L"ExtUtils::MakeMaker => 6.52,\*(R" is
optional, and can be omitted if you like. It ensures only that some harmless
warnings relating to the \f(CW\*(C`CONFIGURE_REQUIRES\*(C'\fR directive won't be emitted
during the building of the module. It also means, of course, that
ExtUtils::Makemaker will first be updated on the user's machine unless the
user already has version 6.52 or later.
.PP
If the \*(L"Inline\->\fBinit()\fR;\*(R" is not done then, having installed Math::Simple, a
warning that \*(L"One or more \s-1DATA\s0 sections were not processed by Inline\*(R" will
appear when (and only when) Math::Simple is loaded by a \*(L"require call. It's a
harmless warning \- and if you're prepared to live with it, then there's no
need to make the \*(R"Inline\->\fBinit()\fR;" call.
.PP
When the person installing \f(CW\*(C`Math::Simple\*(C'\fR does a "\f(CW\*(C`make\*(C'\fR", the generated
Makefile will invoke Inline in such a way that the C code will be compiled and
the executable code will be placed into the \f(CW\*(C`./blib\*(C'\fR directory. Then when a
"\f(CW\*(C`make install\*(C'\fR" is done, the module will be copied into the appropriate Perl
sitelib directory (which is where an installed module should go).
.PP
Now all you need to do is:
.PP
.Vb 2
\&    perl Makefile.PL
\&    make dist
.Ve
.PP
That will generate the file \f(CW\*(C`Math\-Simple\-0.20.tar.gz\*(C'\fR which is a
distributable package. (It will also generate some harmless warnings in
relation to \f(CW\*(C`CONFIGURE_REQUIRES\*(C'\fR unless the version of your
ExtUtils::MakeMaker is 6.52 or later.) That's all there is to it.
.PP
\&\fB\s-1IMPORTANT NOTE\s0\fR: Although the above steps will produce a workable module,
you still have a few more responsibilities as a budding new \s-1CPAN\s0 author. You
need to write lots of documentation and write lots of tests. Take a look at
some of the better \s-1CPAN\s0 modules for ideas on creating a killer test harness.
Actually, don't listen to me, go read these:
.IP "\(bu" 4
perldoc perlnewmod
.IP "\(bu" 4
<http://www.cpan.org/modules/04pause.html>
.IP "\(bu" 4
<http://www.cpan.org/modules/00modlist.long.html>
.SH "HOW INLINE WORKS"
.IX Header "HOW INLINE WORKS"
In reality, Inline just automates everything you would need to do if you were
going to do it by hand (using \s-1XS,\s0 etc).
.PP
Inline performs the following steps:
.IP "\(bu" 4
Receive the Source Code
.Sp
Inline gets the source code from your script or module with a statements like
the following:
.Sp
.Vb 1
\&    use Inline C => "Source\-Code";
.Ve
.Sp
or
.Sp
.Vb 2
\&    use Inline;
\&    bind Inline C => "Source\-Code";
.Ve
.Sp
where \f(CW\*(C`C\*(C'\fR is the programming language of the source code, and \f(CW\*(C`Source\-
Code\*(C'\fR is a string, a file name, an array reference, or the special
\&\f(CW\*(AqDATA\*(Aq\fR keyword.
.Sp
Since Inline is coded in a "\f(CW\*(C`use\*(C'\fR" statement, everything is done during
Perl's compile time. If anything needs to be done that will affect the \f(CW\*(C`Source\-
Code\*(C'\fR, it needs to be done in a \f(CW\*(C`BEGIN\*(C'\fR block that is \fIbefore\fR the "\f(CW\*(C`use
Inline ...\*(C'\fR" statement. If you really need to specify code to Inline at
runtime, you can use the \f(CW\*(C`bind()\*(C'\fR method.
.Sp
Source code that is stowed in the \f(CW\*(AqDATA\*(Aq\fR section of your code, is read in
by an \f(CW\*(C`INIT\*(C'\fR subroutine in Inline. That's because the \f(CW\*(C`DATA\*(C'\fR filehandle is
not available at compile time.
.IP "\(bu" 4
Check if the Source Code has been Built
.Sp
Inline only needs to build the source code if it has not yet been built. It
accomplishes this seemingly magical task in an extremely simple and
straightforward manner. It runs the source text through the \f(CW\*(C`Digest::MD5\*(C'\fR
module to produce a 128\-bit \*(L"fingerprint\*(R" which is virtually unique. The
fingerprint along with a bunch of other contingency information is stored in a
\&\f(CW\*(C`.inl\*(C'\fR file that sits next to your executable object. For instance, the \f(CW\*(C`C\*(C'\fR
code from a script called \f(CW\*(C`example.pl\*(C'\fR might create these files:
.Sp
.Vb 2
\&    example_pl_3a9a.so
\&    example_pl_3a9a.inl
.Ve
.Sp
If all the contingency information matches the values stored in the \f(CW\*(C`.inl\*(C'\fR
file, then proceed to step 8. (No compilation is necessary)
.IP "\(bu" 4
Find a Place to Build and Install
.Sp
At this point Inline knows it needs to build the source code. The first thing
to figure out is where to create the great big mess associated with
compilation, and where to put the object when it's done.
.Sp
By default Inline will try to build and install under the first place that
meets one of the following conditions:
.RS 4
.IP "1." 4
The DIRECTORY= config option; if specified
.IP "2." 4
The \f(CW\*(C`PERL_INLINE_DIRECTORY\*(C'\fR environment variable; if set
.IP "3." 4
\&\f(CW\*(C`.Inline/\*(C'\fR (in current directory); if exists and \f(CW\*(C`$PWD != $HOME\*(C'\fR
.IP "4." 4
bin\fI.Inline\fR (in directory of your script); if exists
.IP "5." 4
\&\f(CW\*(C`~/.Inline/\*(C'\fR \- if exists
.IP "6." 4
\&\f(CW\*(C`./_Inline/\*(C'\fR \- if exists
.IP "7." 4
\&\f(CW\*(C`bin/_Inline\*(C'\fR \- if exists
.IP "8." 4
Create \f(CW\*(C`./_Inline/\*(C'\fR \- if possible
.IP "9." 4
Create \f(CW\*(C`bin/_Inline/\*(C'\fR \- if possible
.RE
.RS 4
.Sp
Failing that, Inline will croak. This is rare and easily remedied by just
making a directory that Inline will use.
.Sp
If the \f(CW\*(C`PERL_INSTALL_ROOT\*(C'\fR Environment Variable has been set, you will need
to make special provision for that if the 'make install' phase of your Inline
scripts are to succeed.
.Sp
If the module option is being compiled for permanent installation, then Inline
will only use \f(CW\*(C`./_Inline/\*(C'\fR to build in, and the \f(CW$Config{installsitearch}\fR
directory to install the executable in. This action is caused by
Inline::MakeMaker, and is intended to be used in modules that are to be
distributed on the \s-1CPAN,\s0 so that they get installed in the proper place.
.RE
.IP "\(bu" 4
Parse the Source for Semantic Cues
.Sp
Inline::C uses the module \f(CW\*(C`Parse::RecDescent\*(C'\fR to parse through your chunks of
C source code and look for things that it can create run-time bindings to. In
\&\f(CW\*(C`C\*(C'\fR it looks for all of the function definitions and breaks them down into
names and data types. These elements are used to correctly bind the \f(CW\*(C`C\*(C'\fR
function to a \f(CW\*(C`Perl\*(C'\fR subroutine. Other Inline languages like Python and Java
actually use the \f(CW\*(C`python\*(C'\fR and \f(CW\*(C`javac\*(C'\fR modules to parse the Inline code.
.IP "\(bu" 4
Create the Build Environment
.Sp
Now Inline can take all of the gathered information and create an environment
to build your source code into an executable. Without going into all the
details, it just creates the appropriate directories, creates the appropriate
source files including an \s-1XS\s0 file (for C) and a \f(CW\*(C`Makefile.PL\*(C'\fR.
.IP "\(bu" 4
Build the Code and Install the Executable
.Sp
The planets are in alignment. Now for the easy part. Inline just does what you
would do to install a module. \*(L"`perl Makefile.PL && make && make test && make
install>\*(R". If something goes awry, Inline will croak with a message indicating
where to look for more info.
.IP "\(bu" 4
Tidy Up
.Sp
By default, Inline will remove all of the mess created by the build process,
assuming that everything worked. If the build fails, Inline will leave
everything intact, so that you can debug your errors. Setting the \f(CW\*(C`noclean\*(C'\fR
shortcut option will also stop Inline from cleaning up.
.IP "\(bu" 4
DynaLoad the Executable
.Sp
For C (and \*(C+), Inline uses the \f(CW\*(C`DynaLoader::bootstrap\*(C'\fR method to pull your
external module into \f(CW\*(C`Perl\*(C'\fR space. Now you can call all of your external
functions like Perl subroutines.
.Sp
Other languages like Python and Java, provide their own loaders.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
For information about using Inline with C see Inline::C.
.PP
For sample programs using Inline with C see Inline::C\-Cookbook.
.PP
For \*(L"Formerly Answered Questions\*(R" about Inline, see Inline-FAQ.
.PP
For information on supported languages and platforms see Inline-Support.
.PP
For information on writing your own Inline Language Support Module, see
Inline-API.
.PP
Inline's mailing list is inline@perl.org
.PP
To subscribe, send email to inline\-subscribe@perl.org
.SH "BUGS AND DEFICIENCIES"
.IX Header "BUGS AND DEFICIENCIES"
When reporting a bug, please do the following:
.IP "\(bu" 4
Put \*(L"use Inline 'reportbug';\*(R" at the top of your code, or use the command line option \*(L"perl \-MInline=reportbug ...\*(R".
.IP "\(bu" 4
Run your code.
.IP "\(bu" 4
Follow the printed directions.
.SH "AUTHOR"
.IX Header "AUTHOR"
Ingy dt Net <ingy@cpan.org>
.PP
Sisyphus <sisyphus@cpan.org> fixed some bugs and is current co-maintainer.
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
.IP "\(bu" 4
Copyright 2000\-2019. Ingy dt Net.
.IP "\(bu" 4
Copyright 2008, 2010\-2014. Sisyphus.
.PP
This program is free software; you can redistribute it and/or modify it under
the same terms as Perl itself.
.PP
See <http://www.perl.com/perl/misc/Artistic.html>
