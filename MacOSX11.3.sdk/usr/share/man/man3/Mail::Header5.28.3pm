.\" Automatically generated by Pod::Man 4.10 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Mail::Header 3"
.TH Mail::Header 3 "2019-05-21" "perl v5.28.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Mail::Header \- manipulate MIME headers
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& use Mail::Header;
\&    
\& my $head = Mail::Header\->new;
\& my $head = Mail::Header\->new( \e*STDIN );
\& my $head = Mail::Header\->new( [<>], Modify => 0);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Read, write, create, and manipulate \s-1MIME\s0 headers, the leading part
of each modern e\-mail message, but also used in other protocols
like \s-1HTTP.\s0  The fields are kept in Mail::Field objects.
.PP
Be aware that the header fields each have a name part, which shall
be treated case-insensitive, and a content part, which may be folded
over multiple lines.
.PP
Mail::Header does not always follow the RFCs strict enough, does not
help you with character encodings.  It does not use weak references
where it could (because those did not exist when the module was written)
which costs some performance and make the implementation a little more
complicated.  The Mail::Message::Head implementation is much newer
and therefore better.
.SH "METHODS"
.IX Header "METHODS"
.SS "Constructors"
.IX Subsection "Constructors"
.ie n .IP "$obj\->\fBdup\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBdup\fR()" 4
.IX Item "$obj->dup()"
Create a duplicate of the current object.
.ie n .IP "$obj\->\fBnew\fR( [$source], [%options] )" 4
.el .IP "\f(CW$obj\fR\->\fBnew\fR( [$source], [%options] )" 4
.IX Item "$obj->new( [$source], [%options] )"
.PD 0
.IP "Mail::Header\->\fBnew\fR( [$source], [%options] )" 4
.IX Item "Mail::Header->new( [$source], [%options] )"
.PD
The \f(CW$source\fR may be either a file descriptor (reference to a \s-1GLOB\s0)
or a reference to an array. If given the new object will be
initialized with headers either from the array of read from 
the file descriptor.
.Sp
\&\f(CW%options\fR is a list of options given in the form of key-value
pairs, just like a hash table. Valid options are
.Sp
.Vb 4
\& \-Option    \-\-Default
\&  FoldLength  79
\&  MailFrom    \*(AqKEEP\*(Aq
\&  Modify      false
.Ve
.RS 4
.IP "FoldLength => \s-1INTEGER\s0" 2
.IX Item "FoldLength => INTEGER"
The default length of line to be used when folding header lines.
See \fBfold_length()\fR.
.IP "MailFrom => '\s-1IGNORE\s0'|'\s-1COERCE\s0'|'\s-1KEEP\s0'|'\s-1ERROR\s0'" 2
.IX Item "MailFrom => 'IGNORE'|'COERCE'|'KEEP'|'ERROR'"
See method \fBmail_from()\fR.
.IP "Modify => \s-1BOOLEAN\s0" 2
.IX Item "Modify => BOOLEAN"
If this value is \fItrue\fR then the headers will be re-formatted,
otherwise the format of the header lines will remain unchanged.
.RE
.RS 4
.RE
.ie n .SS """Fake"" constructors"
.el .SS "``Fake'' constructors"
.IX Subsection "Fake constructors"
Be warned that the next constructors all require an already created
header object, of which the original content will be destroyed.
.ie n .IP "$obj\->\fBempty\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBempty\fR()" 4
.IX Item "$obj->empty()"
Empty an existing \f(CW\*(C`Mail::Header\*(C'\fR object of all lines.
.ie n .IP "$obj\->\fBextract\fR(\s-1ARRAY\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBextract\fR(\s-1ARRAY\s0)" 4
.IX Item "$obj->extract(ARRAY)"
Extract a header from the given array into an existing Mail::Header
object. \f(CW\*(C`extract\*(C'\fR \fBwill modify\fR this array.
Returns the object that the method was called on.
.ie n .IP "$obj\->\fBheader\fR( [\s-1ARRAY\s0] )" 4
.el .IP "\f(CW$obj\fR\->\fBheader\fR( [\s-1ARRAY\s0] )" 4
.IX Item "$obj->header( [ARRAY] )"
\&\f(CW\*(C`header\*(C'\fR does multiple operations. First it will extract a header from
the \s-1ARRAY,\s0 if given. It will then reformat the header (if reformatting
is permitted), and finally return a reference to an array which
contains the header in a printable form.
.ie n .IP "$obj\->\fBheader_hashref\fR( [\s-1HASH\s0] )" 4
.el .IP "\f(CW$obj\fR\->\fBheader_hashref\fR( [\s-1HASH\s0] )" 4
.IX Item "$obj->header_hashref( [HASH] )"
As \fBheader()\fR, but it will eventually set headers from a hash
reference, and it will return the headers as a hash reference.
.Sp
example:
.Sp
.Vb 3
\& $fields\->{From} = \*(AqTobias Brox <tobix@cpan.org>\*(Aq;
\& $fields\->{To}   = [\*(Aqyou@somewhere\*(Aq, \*(Aqme@localhost\*(Aq];
\& $head\->header_hashref($fields);
.Ve
.ie n .IP "$obj\->\fBread\fR($fh)" 4
.el .IP "\f(CW$obj\fR\->\fBread\fR($fh)" 4
.IX Item "$obj->read($fh)"
Read a header from the given file descriptor into an existing Mail::Header
object.
.SS "Accessors"
.IX Subsection "Accessors"
.ie n .IP "$obj\->\fBfold_length\fR( [$tag], [$length] )" 4
.el .IP "\f(CW$obj\fR\->\fBfold_length\fR( [$tag], [$length] )" 4
.IX Item "$obj->fold_length( [$tag], [$length] )"
Set the default fold length for all tags or just one. With no arguments
the default fold length is returned. With two arguments it sets the fold
length for the given tag and returns the previous value. If only \f(CW$length\fR
is given it sets the default fold length for the current object.
.Sp
In the two argument form \f(CW\*(C`fold_length\*(C'\fR may be called as a static method,
setting default fold lengths for tags that will be used by \fBall\fR
\&\f(CW\*(C`Mail::Header\*(C'\fR objects. See the \f(CW\*(C`fold\*(C'\fR method for
a description on how \f(CW\*(C`Mail::Header\*(C'\fR uses these values.
.ie n .IP "$obj\->\fBmail_from\fR('\s-1IGNORE\s0'|'\s-1COERCE\s0'|'\s-1KEEP\s0'|'\s-1ERROR\s0')" 4
.el .IP "\f(CW$obj\fR\->\fBmail_from\fR('\s-1IGNORE\s0'|'\s-1COERCE\s0'|'\s-1KEEP\s0'|'\s-1ERROR\s0')" 4
.IX Item "$obj->mail_from('IGNORE'|'COERCE'|'KEEP'|'ERROR')"
This specifies what to do when a \f(CW\`From \*(Aq\fR line is encountered.
Valid values are \f(CW\*(C`IGNORE\*(C'\fR \- ignore and discard the header,
\&\f(CW\*(C`ERROR\*(C'\fR \- invoke an error (call die), \f(CW\*(C`COERCE\*(C'\fR \- rename them as Mail-From
and \f(CW\*(C`KEEP\*(C'\fR \- keep them.
.ie n .IP "$obj\->\fBmodify\fR( [$value] )" 4
.el .IP "\f(CW$obj\fR\->\fBmodify\fR( [$value] )" 4
.IX Item "$obj->modify( [$value] )"
If \f(CW$value\fR is \fIfalse\fR then \f(CW\*(C`Mail::Header\*(C'\fR will not do any automatic
reformatting of the headers, other than to ensure that the line
starts with the tags given.
.SS "Processing"
.IX Subsection "Processing"
.ie n .IP "$obj\->\fBadd\fR( $tag, $line [, $index] )" 4
.el .IP "\f(CW$obj\fR\->\fBadd\fR( \f(CW$tag\fR, \f(CW$line\fR [, \f(CW$index\fR] )" 4
.IX Item "$obj->add( $tag, $line [, $index] )"
Add a new line to the header. If \f(CW$tag\fR is \f(CW\*(C`undef\*(C'\fR the tag will be
extracted from the beginning of the given line. If \f(CW$index\fR is given,
the new line will be inserted into the header at the given point, otherwise
the new line will be appended to the end of the header.
.ie n .IP "$obj\->\fBas_string\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBas_string\fR()" 4
.IX Item "$obj->as_string()"
Returns the header as a single string.
.ie n .IP "$obj\->\fBcleanup\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBcleanup\fR()" 4
.IX Item "$obj->cleanup()"
Remove any header line that, other than the tag, only contains whitespace
.ie n .IP "$obj\->\fBcombine\fR( $tag [, $with] )" 4
.el .IP "\f(CW$obj\fR\->\fBcombine\fR( \f(CW$tag\fR [, \f(CW$with\fR] )" 4
.IX Item "$obj->combine( $tag [, $with] )"
Combine all instances of \f(CW$tag\fR into one. The lines will be
joined together \f(CW$with\fR, or a single space if not given. The new
item will be positioned in the header where the first instance was, all
other instances of \f(CW$tag\fR will be removed.
.ie n .IP "$obj\->\fBcount\fR($tag)" 4
.el .IP "\f(CW$obj\fR\->\fBcount\fR($tag)" 4
.IX Item "$obj->count($tag)"
Returns the number of times the given atg appears in the header
.ie n .IP "$obj\->\fBdelete\fR( $tag [, $index ] )" 4
.el .IP "\f(CW$obj\fR\->\fBdelete\fR( \f(CW$tag\fR [, \f(CW$index\fR ] )" 4
.IX Item "$obj->delete( $tag [, $index ] )"
Delete a tag from the header. If an \f(CW$index\fR id is given, then the Nth instance
of the tag will be removed. If no \f(CW$index\fR is given, then all instances
of tag will be removed.
.ie n .IP "$obj\->\fBfold\fR( [$length] )" 4
.el .IP "\f(CW$obj\fR\->\fBfold\fR( [$length] )" 4
.IX Item "$obj->fold( [$length] )"
Fold the header. If \f(CW$length\fR is not given, then \f(CW\*(C`Mail::Header\*(C'\fR uses the
following rules to determine what length to fold a line.
.ie n .IP "$obj\->\fBget\fR( $tag [, $index] )" 4
.el .IP "\f(CW$obj\fR\->\fBget\fR( \f(CW$tag\fR [, \f(CW$index\fR] )" 4
.IX Item "$obj->get( $tag [, $index] )"
Get the text from a line. If an \f(CW$index\fR is given, then the text of the Nth
instance will be returned. If it is not given the return value depends on the
context in which \f(CW\*(C`get\*(C'\fR was called. In an array context a list of all the
text from all the instances of the \f(CW$tag\fR will be returned. In a scalar context
the text for the first instance will be returned.
.Sp
The lines are unfolded, but still terminated with a new-line (see \f(CW\*(C`chomp\*(C'\fR)
.ie n .IP "$obj\->\fBprint\fR( [$fh] )" 4
.el .IP "\f(CW$obj\fR\->\fBprint\fR( [$fh] )" 4
.IX Item "$obj->print( [$fh] )"
Print the header to the given file descriptor, or \f(CW\*(C`STDOUT\*(C'\fR if no
file descriptor is given.
.ie n .IP "$obj\->\fBreplace\fR( $tag, $line [, $index ] )" 4
.el .IP "\f(CW$obj\fR\->\fBreplace\fR( \f(CW$tag\fR, \f(CW$line\fR [, \f(CW$index\fR ] )" 4
.IX Item "$obj->replace( $tag, $line [, $index ] )"
Replace a line in the header.  If \f(CW$tag\fR is \f(CW\*(C`undef\*(C'\fR the tag will be
extracted from the beginning of the given line. If \f(CW$index\fR is given
the new line will replace the Nth instance of that tag, otherwise the
first instance of the tag is replaced. If the tag does not appear in the
header then a new line will be appended to the header.
.ie n .IP "$obj\->\fBtags\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBtags\fR()" 4
.IX Item "$obj->tags()"
Returns an array of all the tags that exist in the header. Each tag will
only appear in the list once. The order of the tags is not specified.
.ie n .IP "$obj\->\fBunfold\fR( [$tag] )" 4
.el .IP "\f(CW$obj\fR\->\fBunfold\fR( [$tag] )" 4
.IX Item "$obj->unfold( [$tag] )"
Unfold all instances of the given tag so that they do not spread across
multiple lines. If \f(CW$tag\fR is not given then all lines are unfolded.
.Sp
The unfolding process is wrong but (for compatibility reasons) will
not be repaired: only one blank at the start of the line should be
removed, not all of them.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
This module is part of the MailTools distribution,
\&\fIhttp://perl.overmeer.net/mailtools/\fR.
.SH "AUTHORS"
.IX Header "AUTHORS"
The MailTools bundle was developed by Graham Barr.  Later, Mark
Overmeer took over maintenance without commitment to further development.
.PP
Mail::Cap by Gisle Aas <aas@oslonett.no>.
Mail::Field::AddrList by Peter Orbaek <poe@cit.dk>.
Mail::Mailer and Mail::Send by Tim Bunce <Tim.Bunce@ig.co.uk>.
For other contributors see ChangeLog.
.SH "LICENSE"
.IX Header "LICENSE"
Copyrights 1995\-2000 Graham Barr <gbarr@pobox.com> and
2001\-2017 Mark Overmeer <perl@overmeer.net>.
.PP
This program is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.
See \fIhttp://www.perl.com/perl/misc/Artistic.html\fR
