.\" Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "HTML::Tree::Scanning 3"
.TH HTML::Tree::Scanning 3 "2021-02-28" "perl v5.30.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
HTML::Tree::Scanning \-\- article: "Scanning HTML"
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  # This an article, not a module.
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The following article by Sean M. Burke first appeared in \fIThe Perl
Journal\fR #19 and is copyright 2000 The Perl Journal. It appears
courtesy of Jon Orwant and The Perl Journal.  This document may be
distributed under the same terms as Perl itself.
.PP
(Note that this is discussed in chapters 6 through 10 of the
book \fIPerl and \s-1LWP\s0\fR <http://lwp.interglacial.com/> which
was written after the following documentation, and which is
available free online.)
.SH "Scanning HTML"
.IX Header "Scanning HTML"
\&\-\- Sean M. Burke
.PP
In \fIThe Perl Journal\fR issue 17, Ken MacFarlane's article \*(L"Parsing
\&\s-1HTML\s0 with HTML::Parser\*(R" describes how the HTML::Parser module scans
\&\s-1HTML\s0 source as a stream of start-tags, end-tags, text, comments, etc.
In \s-1TPJ\s0 #18, my \*(L"Trees\*(R" article kicked around the idea of tree-shaped
data structures.  Now I'll try to tie it together, in a discussion of
\&\s-1HTML\s0 trees.
.PP
The \s-1CPAN\s0 module HTML::TreeBuilder takes the
tags that HTML::Parser picks out, and builds a parse tree \*(-- a
tree-shaped network of objects...
.Sp
.RS 4
Footnote:
And if you need a quick explanation of objects, see my \s-1TPJ17\s0 article \*(L"A
User's View of Object-Oriented Modules\*(R"; or go whole hog and get Damian
Conway's excellent book \fIObject-Oriented Perl\fR, from Manning
Publications.
.RE
.PP
\&...representing the structured content of the \s-1HTML\s0 document.  And once
the document is parsed as a tree, you'll find the common tasks
of extracting data from that \s-1HTML\s0 document/tree to be quite
straightforward.
.SS "HTML::Parser, HTML::TreeBuilder, and HTML::Element"
.IX Subsection "HTML::Parser, HTML::TreeBuilder, and HTML::Element"
You use HTML::TreeBuilder to make a parse tree out of an \s-1HTML\s0 source
file, by simply saying:
.PP
.Vb 3
\&  use HTML::TreeBuilder;
\&  my $tree = HTML::TreeBuilder\->new();
\&  $tree\->parse_file(\*(Aqfoo.html\*(Aq);
.Ve
.PP
and then \f(CW$tree\fR contains a parse tree built from the \s-1HTML\s0 source from
the file \*(L"foo.html\*(R".  The way this parse tree is represented is with a
network of objects \*(-- \f(CW$tree\fR is the root, an element with tag-name
\&\*(L"html\*(R", and its children typically include a \*(L"head\*(R" and \*(L"body\*(R" element,
and so on.  Elements in the tree are objects of the class
HTML::Element.
.PP
So, if you take this source:
.PP
.Vb 4
\&  <html><head><title>Doc 1</title></head>
\&  <body>
\&  Stuff <hr> 2000\-08\-17
\&  </body></html>
.Ve
.PP
and feed it to HTML::TreeBuilder, it'll return a tree of objects that
looks like this:
.PP
.Vb 7
\&               html
\&             /      \e
\&         head        body
\&        /          /   |  \e
\&     title    "Stuff"  hr  "2000\-08\-17"
\&       |
\&    "Doc 1"
.Ve
.PP
This is a pretty simple document, but if it were any more complex,
it'd be a bit hard to draw in that style, since it's sprawl left and
right.  The same tree can be represented a bit more easily sideways,
with indenting:
.PP
.Vb 8
\&  . html
\&     . head
\&        . title
\&           . "Doc 1"
\&     . body
\&        . "Stuff"
\&        . hr
\&        . "2000\-08\-17"
.Ve
.PP
Either way expresses the same structure.  In that structure, the root
node is an object of the class HTML::Element
.Sp
.RS 4
Footnote:
Well actually, the root is of the class HTML::TreeBuilder, but that's
just a subclass of HTML::Element, plus the few extra methods like
\&\f(CW\*(C`parse_file\*(C'\fR that elaborate the tree
.RE
.PP
, with the tag name \*(L"html\*(R", and with two children: an HTML::Element
object whose tag names are \*(L"head\*(R" and \*(L"body\*(R".  And each of those
elements have children, and so on down.  Not all elements (as we'll
call the objects of class HTML::Element) have children \*(-- the \*(L"hr\*(R"
element doesn't.  And note all nodes in the tree are elements \*(-- the
text nodes (\*(L"Doc 1\*(R", \*(L"Stuff\*(R", and \*(L"2000\-08\-17\*(R") are just strings.
.PP
Objects of the class HTML::Element each have three noteworthy attributes:
.ie n .IP """_tag"" \*(-- (best accessed as ""$e\->tag"") this element's tag-name, lowercased (e.g., ""em"" for an ""em"" element)." 4
.el .IP "\f(CW_tag\fR \*(-- (best accessed as \f(CW$e\->tag\fR) this element's tag-name, lowercased (e.g., ``em'' for an ``em'' element)." 4
.IX Item "_tag (best accessed as $e->tag) this element's tag-name, lowercased (e.g., em for an em element)."
.RS 4
.RS 4
Footnote: Yes, this is misnamed.  In proper \s-1SGML\s0 terminology, this is
instead called a \*(L"\s-1GI\*(R",\s0 short for \*(L"generic identifier\*(R"; and the term
\&\*(L"tag\*(R" is used for a token of \s-1SGML\s0 source that represents either
the start of an element (a start-tag like \*(L"<em lang='fr'>\*(R") or the end
of an element (an end-tag like \*(L"</em>\*(R".  However, since more people
claim to have been abducted by aliens than to have ever seen the
\&\s-1SGML\s0 standard, and since both encounters typically involve a feeling of
\&\*(L"missing time\*(R", it's not surprising that the terminology of the \s-1SGML\s0
standard is not closely followed.
.RE
.RE
.RS 4
.RE
.ie n .IP """_parent"" \*(-- (best accessed as ""$e\->parent"") the element that is $obj's parent, or undef if this element is the root of its tree." 4
.el .IP "\f(CW_parent\fR \*(-- (best accessed as \f(CW$e\->parent\fR) the element that is \f(CW$obj\fR's parent, or undef if this element is the root of its tree." 4
.IX Item "_parent (best accessed as $e->parent) the element that is $obj's parent, or undef if this element is the root of its tree."
.PD 0
.ie n .IP """_content"" \*(-- (best accessed as ""$e\->content_list"") the list of nodes (i.e., elements or text segments) that are $e's children." 4
.el .IP "\f(CW_content\fR \*(-- (best accessed as \f(CW$e\->content_list\fR) the list of nodes (i.e., elements or text segments) that are \f(CW$e\fR's children." 4
.IX Item "_content (best accessed as $e->content_list) the list of nodes (i.e., elements or text segments) that are $e's children."
.PD
.PP
Moreover, if an element object has any attributes in the \s-1SGML\s0 sense of
the word, then those are readable as \f(CW\*(C`$e\->attr(\*(Aqname\*(Aq)\*(C'\fR \*(-- for
example, with the object built from having parsed "<a
\&\fBid='foo'\fR>bar</a>", \f(CW\*(C`$e\->attr(\*(Aqid\*(Aq)\*(C'\fR will return
the string \*(L"foo\*(R".  Moreover, \f(CW\*(C`$e\->tag\*(C'\fR on that object returns the
string \*(L"a\*(R", \f(CW\*(C`$e\->content_list\*(C'\fR returns a list consisting of just
the single scalar \*(L"bar\*(R", and \f(CW\*(C`$e\->parent\*(C'\fR returns the object
that's this node's parent \*(-- which may be, for example, a \*(L"p\*(R" element.
.PP
And that's all that there is to it \*(-- you throw \s-1HTML\s0
source at TreeBuilder, and it returns a tree built of HTML::Element
objects and some text strings.
.PP
However, what do you \fIdo\fR with a tree of objects?  People code
information into \s-1HTML\s0 trees not for the fun of arranging elements, but
to represent the structure of specific text and images \*(-- some text is
in this \*(L"li\*(R" element, some other text is in that heading, some
images are in that other table cell that has those attributes, and so on.
.PP
Now, it may happen that you're rendering that whole \s-1HTML\s0 tree into some
layout format.  Or you could be trying to make some systematic change to
the \s-1HTML\s0 tree before dumping it out as \s-1HTML\s0 source again.  But, in my
experience, by far the most common programming task that Perl
programmers face with \s-1HTML\s0 is in trying to extract some piece
of information from a larger document.  Since that's so common (and
also since it involves concepts that are basic to more complex tasks),
that is what the rest of this article will be about.
.SS "Scanning \s-1HTML\s0 trees"
.IX Subsection "Scanning HTML trees"
Suppose you have a thousand \s-1HTML\s0 documents, each of them a press
release.  They all start out:
.PP
.Vb 7
\&  [...lots of leading images and junk...]
\&  <h1>ConGlomCo to Open New Corporate Office in Ougadougou</h1>
\&  BAKERSFIELD, CA, 2000\-04\-24 \-\- ConGlomCo\*(Aqs vice president in charge
\&  of world conquest, Rock Feldspar, announced today the opening of a
\&  new office in Ougadougou, the capital city of Burkino Faso, gateway
\&  to the bustling "Silicon Sahara" of Africa...
\&  [...etc...]
.Ve
.PP
\&...and what you've got to do is, for each document, copy whatever text
is in the \*(L"h1\*(R" element, so that you can, for example, make a table of
contents of it.  Now, there are three ways to do this:
.IP "\(bu" 4
You can just use a regexp to scan the file for a text pattern.
.Sp
For many very simple tasks, this will do fine.  Many \s-1HTML\s0 documents are,
in practice, very consistently formatted as far as placement of
linebreaks and whitespace, so you could just get away with scanning the
file like so:
.Sp
.Vb 10
\&  sub get_heading {
\&    my $filename = $_[0];
\&    local *HTML;
\&    open(HTML, $filename)
\&      or die "Couldn\*(Aqt open $filename);
\&    my $heading;
\&   Line:
\&    while(<HTML>) {
\&      if( m{<h1>(.*?)</h1>}i ) {  # match it!
\&        $heading = $1;
\&        last Line;
\&      }
\&    }
\&    close(HTML);
\&    warn "No heading in $filename?"
\&     unless defined $heading;
\&    return $heading;
\&  }
.Ve
.Sp
This is quick and fast, but awfully fragile \*(-- if there's a newline in
the middle of a heading's text, it won't match the above regexp, and
you'll get an error.  The regexp will also fail if the \*(L"h1\*(R" element's
start-tag has any attributes.  If you have to adapt your code to fit
more kinds of start-tags, you'll end up basically reinventing part of
HTML::Parser, at which point you should probably just stop, and use
HTML::Parser itself:
.IP "\(bu" 4
You can use HTML::Parser to scan the file for an \*(L"h1\*(R" start-tag
token, then capture all the text tokens until the \*(L"h1\*(R" close-tag.  This
approach is extensively covered in the Ken MacFarlane's \s-1TPJ17\s0 article
\&\*(L"Parsing \s-1HTML\s0 with HTML::Parser\*(R".  (A variant of this approach is to use
HTML::TokeParser, which presents a different and rather handier
interface to the tokens that HTML::Parser picks out.)
.Sp
Using HTML::Parser is less fragile than our first approach, since it's
not sensitive to the exact internal formatting of the start-tag (much
less whether it's split across two lines).  However, when you need more
information about the context of the \*(L"h1\*(R" element, or if you're having
to deal with any of the tricky bits of \s-1HTML,\s0 such as parsing of tables,
you'll find out the flat list of tokens that HTML::Parser returns
isn't immediately useful.  To get something useful out of those tokens,
you'll need to write code that knows some things about what elements
take no content (as with \*(L"hr\*(R" elements), and that a \*(L"</p>\*(R" end-tags
are omissible, so a \*(L"<p>\*(R" will end any currently
open paragraph \*(-- and you're well on your way to pointlessly
reinventing much of the code in HTML::TreeBuilder
.RS 4
.Sp
.RS 4
Footnote:
And, as the person who last rewrote that module, I can attest that it
wasn't terribly easy to get right!  Never underestimate the perversity
of people coding \s-1HTML.\s0
.RE
.RE
.RS 4
.Sp
, at which point you should probably just stop, and use
HTML::TreeBuilder itself:
.RE
.IP "\(bu" 4
You can use HTML::Treebuilder, and scan the tree of element
objects that you get back.
.PP
The last approach, using HTML::TreeBuilder, is the diametric opposite of
first approach:  The first approach involves just elementary Perl and one
regexp, whereas the TreeBuilder approach involves being at home with
the concept of tree-shaped data structures and modules with
object-oriented interfaces, as well as with the particular interfaces
that HTML::TreeBuilder and HTML::Element provide.
.PP
However, what the TreeBuilder approach has going for it is that it's
the most robust, because it involves dealing with \s-1HTML\s0 in its \*(L"native\*(R"
format \*(-- it deals with the tree structure that \s-1HTML\s0 code represents,
without any consideration of how the source is coded and with what
tags omitted.
.PP
So, to extract the text from the \*(L"h1\*(R" elements of an \s-1HTML\s0 document:
.PP
.Vb 10
\&  sub get_heading {
\&    my $tree = HTML::TreeBuilder\->new;
\&    $tree\->parse_file($_[0]);   # !
\&    my $heading;
\&    my $h1 = $tree\->look_down(\*(Aq_tag\*(Aq, \*(Aqh1\*(Aq);  # !
\&    if($h1) {
\&      $heading = $h1\->as_text;   # !
\&    } else {
\&      warn "No heading in $_[0]?";
\&    }
\&    $tree\->delete; # clear memory!
\&    return $heading;
\&  }
.Ve
.PP
This uses some unfamiliar methods that need explaining.  The
\&\f(CW\*(C`parse_file\*(C'\fR method that we've seen before, builds a tree based on
source from the file given.  The \f(CW\*(C`delete\*(C'\fR method is for marking a
tree's contents as available for garbage collection, when you're done
with the tree.  The \f(CW\*(C`as_text\*(C'\fR method returns a string that contains
all the text bits that are children (or otherwise descendants) of the
given node \*(-- to get the text content of the \f(CW$h1\fR object, we could
just say:
.PP
.Vb 1
\&  $heading = join \*(Aq\*(Aq, $h1\->content_list;
.Ve
.PP
but that will work only if we're sure that the \*(L"h1\*(R" element's children
will be only text bits \*(-- if the document contained:
.PP
.Vb 1
\&  <h1>Local Man Sees <cite>Blade</cite> Again</h1>
.Ve
.PP
then the sub-tree would be:
.PP
.Vb 5
\&  . h1
\&    . "Local Man Sees "
\&    . cite
\&      . "Blade"
\&    . " Again\*(Aq
.Ve
.PP
so \f(CW\*(C`join \*(Aq\*(Aq, $h1\->content_list\*(C'\fR will be something like:
.PP
.Vb 1
\&  Local Man Sees HTML::Element=HASH(0x15424040) Again
.Ve
.PP
whereas \f(CW\*(C`$h1\->as_text\*(C'\fR would yield:
.PP
.Vb 1
\&  Local Man Sees Blade Again
.Ve
.PP
and depending on what you're doing with the heading text, you might
want the \f(CW\*(C`as_HTML\*(C'\fR method instead.  It returns the (sub)tree
represented as \s-1HTML\s0 source.  \f(CW\*(C`$h1\->as_HTML\*(C'\fR would yield:
.PP
.Vb 1
\&  <h1>Local Man Sees <cite>Blade</cite> Again</h1>
.Ve
.PP
However, if you wanted the contents of \f(CW$h1\fR as \s-1HTML,\s0 but not the
\&\f(CW$h1\fR itself, you could say:
.PP
.Vb 5
\&  join \*(Aq\*(Aq,
\&    map(
\&      ref($_) ? $_\->as_HTML : $_,
\&      $h1\->content_list
\&    )
.Ve
.PP
This \f(CW\*(C`map\*(C'\fR iterates over the nodes in \f(CW$h1\fR's list of children; and
for each node that's just a text bit (as \*(L"Local Man Sees \*(R" is), it just
passes through that string value, and for each node that's an actual
object (causing \f(CW\*(C`ref\*(C'\fR to be true), \f(CW\*(C`as_HTML\*(C'\fR will used instead of the
string value of the object itself (which would be something quite
useless, as most object values are).  So that \f(CW\*(C`as_HTML\*(C'\fR for the \*(L"cite\*(R"
element will be the string \*(L"<cite>Blade</cite>\*(R".  And then,
finally, \f(CW\*(C`join\*(C'\fR just puts into one string all the strings that the
\&\f(CW\*(C`map\*(C'\fR returns.
.PP
Last but not least, the most important method in our \f(CW\*(C`get_heading\*(C'\fR sub
is the \f(CW\*(C`look_down\*(C'\fR method.  This method looks down at the subtree
starting at the given object (\f(CW$h1\fR), looking for elements that meet
criteria you provide.
.PP
The criteria are specified in the method's argument list.  Each
criterion can consist of two scalars, a key and a value, which express
that you want elements that have that attribute (like \*(L"_tag\*(R", or
\&\*(L"src\*(R") with the given value (\*(L"h1\*(R"); or the criterion can be a
reference to a subroutine that, when called on the given element,
returns true if that is a node you're looking for.  If you specify
several criteria, then that's taken to mean that you want all the
elements that each satisfy \fIall\fR the criteria.  (In other words,
there's an \*(L"implicit \s-1AND\*(R".\s0)
.PP
And finally, there's a bit of an optimization \*(-- if you call the
\&\f(CW\*(C`look_down\*(C'\fR method in a scalar context, you get just the \fIfirst\fR node
(or undef if none) \*(-- and, in fact, once \f(CW\*(C`look_down\*(C'\fR finds that first
matching element, it doesn't bother looking any further.
.PP
So the example:
.PP
.Vb 1
\&  $h1 = $tree\->look_down(\*(Aq_tag\*(Aq, \*(Aqh1\*(Aq);
.Ve
.PP
returns the first element at-or-under \f(CW$tree\fR whose \f(CW"_tag"\fR
attribute has the value \f(CW"h1"\fR.
.SS "Complex Criteria in Tree Scanning"
.IX Subsection "Complex Criteria in Tree Scanning"
Now, the above \f(CW\*(C`look_down\*(C'\fR code looks like a lot of bother, with
barely more benefit than just grepping the file!  But consider if your
criteria were more complicated \*(-- suppose you found that some of the
press releases that you were scanning had several \*(L"h1\*(R" elements,
possibly before or after the one you actually want.  For example:
.PP
.Vb 8
\&  <h1><center>Visit Our Corporate Partner
\&   <br><a href="/dyna/clickthru"
\&     ><img src="/dyna/vend_ad"></a>
\&  </center></h1>
\&  <h1><center>ConGlomCo President Schreck to Visit Regional HQ
\&   <br><a href="/photos/Schreck_visit_large.jpg"
\&     ><img src="/photos/Schreck_visit.jpg"></a>
\&  </center></h1>
.Ve
.PP
Here, you want to ignore the first \*(L"h1\*(R" element because it contains an
ad, and you want the text from the second \*(L"h1\*(R".  The problem is in
formalizing the way you know that it's an ad.  Since ad banners are
always entreating you to \*(L"visit\*(R" the sponsoring site, you could exclude
\&\*(L"h1\*(R" elements that contain the word \*(L"visit\*(R" under them:
.PP
.Vb 6
\&  my $real_h1 = $tree\->look_down(
\&    \*(Aq_tag\*(Aq, \*(Aqh1\*(Aq,
\&    sub {
\&      $_[0]\->as_text !~ m/\ebvisit/i
\&    }
\&  );
.Ve
.PP
The first criterion looks for \*(L"h1\*(R" elements, and the second criterion
limits those to only the ones whose text content doesn't match
\&\f(CW\*(C`m/\ebvisit/\*(C'\fR.  But unfortunately, that won't work for our example,
since the second \*(L"h1\*(R" mentions "ConGlomCo President Schreck to
\&\fIVisit\fR Regional \s-1HQ".\s0
.PP
Instead you could try looking for the first \*(L"h1\*(R" element that
doesn't contain an image:
.PP
.Vb 6
\&  my $real_h1 = $tree\->look_down(
\&    \*(Aq_tag\*(Aq, \*(Aqh1\*(Aq,
\&    sub {
\&      not $_[0]\->look_down(\*(Aq_tag\*(Aq, \*(Aqimg\*(Aq)
\&    }
\&  );
.Ve
.PP
This criterion sub might seem a bit odd, since it calls \f(CW\*(C`look_down\*(C'\fR
as part of a larger \f(CW\*(C`look_down\*(C'\fR operation, but that's fine.  Note that
when considered as a boolean value, a \f(CW\*(C`look_down\*(C'\fR in a scalar context
value returns false (specifically, undef) if there's no matching element
at or under the given element; and it returns the first matching
element (which, being a reference and object, is always a true value),
if any matches.  So, here,
.PP
.Vb 3
\&  sub {
\&    not $_[0]\->look_down(\*(Aq_tag\*(Aq, \*(Aqimg\*(Aq)
\&  }
.Ve
.PP
means \*(L"return true only if this element has no 'img' element as
descendants (and isn't an 'img' element itself).\*(R"
.PP
This correctly filters out the first \*(L"h1\*(R" that contains the ad, but it
also incorrectly filters out the second \*(L"h1\*(R" that contains a
non-advertisement photo besides the headline text you want.
.PP
There clearly are detectable differences between the first and second
\&\*(L"h1\*(R" elements \*(-- the only second one contains the string \*(L"Schreck\*(R", and
we could just test for that:
.PP
.Vb 6
\&  my $real_h1 = $tree\->look_down(
\&    \*(Aq_tag\*(Aq, \*(Aqh1\*(Aq,
\&    sub {
\&      $_[0]\->as_text =~ m{Schreck}
\&    }
\&  );
.Ve
.PP
And that works fine for this one example, but unless all thousand of
your press releases have \*(L"Schreck\*(R" in the headline, that's just not a
general solution.  However, if all the ads\-in\-\*(L"h1\*(R"s that you want to
exclude involve a link whose \s-1URL\s0 involves \*(L"/dyna/\*(R", then you can use
that:
.PP
.Vb 11
\&  my $real_h1 = $tree\->look_down(
\&    \*(Aq_tag\*(Aq, \*(Aqh1\*(Aq,
\&    sub {
\&      my $link = $_[0]\->look_down(\*(Aq_tag\*(Aq,\*(Aqa\*(Aq);
\&      return 1 unless $link;
\&        # no link means it\*(Aqs fine
\&      return 0 if $link\->attr(\*(Aqhref\*(Aq) =~ m{/dyna/};
\&        # a link to there is bad
\&      return 1; # otherwise okay
\&    }
\&  );
.Ve
.PP
Or you can look at it another way and say that you want the first \*(L"h1\*(R"
element that either contains no images, or else whose image has a \*(L"src\*(R"
attribute whose value contains \*(L"/photos/\*(R":
.PP
.Vb 11
\&  my $real_h1 = $tree\->look_down(
\&    \*(Aq_tag\*(Aq, \*(Aqh1\*(Aq,
\&    sub {
\&      my $img = $_[0]\->look_down(\*(Aq_tag\*(Aq,\*(Aqimg\*(Aq);
\&      return 1 unless $img;
\&        # no image means it\*(Aqs fine
\&      return 1 if $img\->attr(\*(Aqsrc\*(Aq) =~ m{/photos/};
\&        # good if a photo
\&      return 0; # otherwise bad
\&    }
\&  );
.Ve
.PP
Recall that this use of \f(CW\*(C`look_down\*(C'\fR in a scalar context means to return
the first element at or under \f(CW$tree\fR that matches all the criteria.
But if you notice that you can formulate criteria that'll match several
possible \*(L"h1\*(R" elements, some of which may be bogus but the \fIlast\fR one
of which is always the one you want, then you can use \f(CW\*(C`look_down\*(C'\fR in a
list context, and just use the last element of that list:
.PP
.Vb 6
\&  my @h1s = $tree\->look_down(
\&    \*(Aq_tag\*(Aq, \*(Aqh1\*(Aq,
\&    ...maybe more criteria...
\&  );
\&  die "What, no h1s here?" unless @h1s;
\&  my $real_h1 = $h1s[\-1]; # last or only
.Ve
.SS "A Case Study: Scanning Yahoo News's \s-1HTML\s0"
.IX Subsection "A Case Study: Scanning Yahoo News's HTML"
The above (somewhat contrived) case involves extracting data from a
bunch of pre-existing \s-1HTML\s0 files.  In that sort of situation, if your
code works for all the files, then you know that the code \fIworks\fR \*(--
since the data it's meant to handle won't go changing or growing; and,
typically, once you've used the program, you'll never need to use it
again.
.PP
The other kind of situation faced in many data extraction tasks is
where the program is used recurringly to handle new data \*(-- such as
from ever-changing Web pages.  As a real-world example of this,
consider a program that you could use (suppose it's crontabbed) to
extract headline-links from subsections of Yahoo News
(\f(CW\*(C`http://dailynews.yahoo.com/\*(C'\fR).
.PP
Yahoo News has several subsections:
.IP "http://dailynews.yahoo.com/h/tc/ for technology news" 4
.IX Item "http://dailynews.yahoo.com/h/tc/ for technology news"
.PD 0
.IP "http://dailynews.yahoo.com/h/sc/ for science news" 4
.IX Item "http://dailynews.yahoo.com/h/sc/ for science news"
.IP "http://dailynews.yahoo.com/h/hl/ for health news" 4
.IX Item "http://dailynews.yahoo.com/h/hl/ for health news"
.IP "http://dailynews.yahoo.com/h/wl/ for world news" 4
.IX Item "http://dailynews.yahoo.com/h/wl/ for world news"
.IP "http://dailynews.yahoo.com/h/en/ for entertainment news" 4
.IX Item "http://dailynews.yahoo.com/h/en/ for entertainment news"
.PD
.PP
and others.  All of them are built on the same basic \s-1HTML\s0 template \*(--
and a scarily complicated template it is, especially when you look at
it with an eye toward making up rules that will select where the real
headline-links are, while screening out all the links to other parts of
Yahoo, other news services, etc.  You will need to puzzle
over the \s-1HTML\s0 source, and scrutinize the output of
\&\f(CW\*(C`$tree\->dump\*(C'\fR on the parse tree of that \s-1HTML.\s0
.PP
Sometimes the only way to pin down what you're after is by position in
the tree. For example, headlines of interest may be in the third
column of the second row of the second table element in a page:
.PP
.Vb 4
\&  my $table = ( $tree\->look_down(\*(Aq_tag\*(Aq,\*(Aqtable\*(Aq) )[1];
\&  my $row2  = ( $table\->look_down(\*(Aq_tag\*(Aq, \*(Aqtr\*(Aq ) )[1];
\&  my $col3  = ( $row2\->look\-down(\*(Aq_tag\*(Aq, \*(Aqtd\*(Aq)   )[2];
\&  ...then do things with $col3...
.Ve
.PP
Or they may be all the links in a \*(L"p\*(R" element that has at least three
\&\*(L"br\*(R" elements as children:
.PP
.Vb 8
\&  my $p = $tree\->look_down(
\&    \*(Aq_tag\*(Aq, \*(Aqp\*(Aq,
\&    sub {
\&      2 < grep { ref($_) and $_\->tag eq \*(Aqbr\*(Aq }
\&               $_[0]\->content_list
\&    }
\&  );
\&  @links = $p\->look_down(\*(Aq_tag\*(Aq, \*(Aqa\*(Aq);
.Ve
.PP
But almost always, you can get away with looking for properties of the
of the thing itself, rather than just looking for contexts.  Now, if
you're lucky, the document you're looking through has clear semantic
tagging, such is as useful in \s-1CSS\s0 \*(-- note the
class=\*(L"headlinelink\*(R" bit here:
.PP
.Vb 2
\&  <a href="...long_news_url..." class="headlinelink">Elvis
\&  seen in tortilla</a>
.Ve
.PP
If you find anything like that, you could leap right in and select
links with:
.PP
.Vb 1
\&  @links = $tree\->look_down(\*(Aqclass\*(Aq,\*(Aqheadlinelink\*(Aq);
.Ve
.PP
Regrettably, your chances of seeing any sort of semantic markup
principles really being followed with actual \s-1HTML\s0 are pretty thin.
.Sp
.RS 4
Footnote:
In fact, your chances of finding a page that is simply free of \s-1HTML\s0
errors are even thinner.  And surprisingly, sites like Amazon or Yahoo
are typically worse as far as quality of code than personal sites
whose entire production cycle involves simply being saved and uploaded
from Netscape Composer.
.RE
.PP
The code may be sort of \*(L"accidentally semantic\*(R", however \*(-- for example,
in a set of pages I was scanning recently, I found that looking for
\&\*(L"td\*(R" elements with a \*(L"width\*(R" attribute value of \*(L"375\*(R" got me exactly
what I wanted.  No-one designing that page ever conceived of
\&\*(L"width=375\*(R" as \fImeaning\fR \*(L"this is a headline\*(R", but if you impute it
to mean that, it works.
.PP
An approach like this happens to work for the Yahoo News code, because
the headline-links are distinguished by the fact that they (and they
alone) contain a \*(L"b\*(R" element:
.PP
.Vb 1
\&  <a href="...long_news_url..."><b>Elvis seen in tortilla</b></a>
.Ve
.PP
or, diagrammed as a part of the parse tree:
.PP
.Vb 3
\&  . a  [href="...long_news_url..."]
\&    . b
\&      . "Elvis seen in tortilla"
.Ve
.PP
A rule that matches these can be formalized as \*(L"look for any 'a'
element that has only one daughter node, which must be a 'b' element\*(R".
And this is what it looks like when cooked up as a \f(CW\*(C`look_down\*(C'\fR
expression and prefaced with a bit of code that retrieves the text of
the given Yahoo News page and feeds it to TreeBuilder:
.PP
.Vb 5
\&  use strict;
\&  use HTML::TreeBuilder 2.97;
\&  use LWP::UserAgent;
\&  sub get_headlines {
\&    my $url = $_[0] || die "What URL?";
\&    
\&    my $response = LWP::UserAgent\->new\->request(
\&      HTTP::Request\->new( GET => $url )
\&    );
\&    unless($response\->is_success) {
\&      warn "Couldn\*(Aqt get $url: ", $response\->status_line, "\en";
\&      return;
\&    }
\&    
\&    my $tree = HTML::TreeBuilder\->new();
\&    $tree\->parse($response\->content);
\&    $tree\->eof;
\&    
\&    my @out;
\&    foreach my $link (
\&      $tree\->look_down(   # !
\&        \*(Aq_tag\*(Aq, \*(Aqa\*(Aq,
\&        sub {
\&          return unless $_[0]\->attr(\*(Aqhref\*(Aq);
\&          my @c = $_[0]\->content_list;
\&          @c == 1 and ref $c[0] and $c[0]\->tag eq \*(Aqb\*(Aq;
\&        }
\&      )
\&    ) {
\&      push @out, [ $link\->attr(\*(Aqhref\*(Aq), $link\->as_text ];
\&    }
\&    
\&    warn "Odd, fewer than 6 stories in $url!" if @out < 6;
\&    $tree\->delete;
\&    return @out;
\&  }
.Ve
.PP
\&...and add a bit of code to actually call that routine and display the
results...
.PP
.Vb 9
\&  foreach my $section (qw[tc sc hl wl en]) {
\&    my @links = get_headlines(
\&      "http://dailynews.yahoo.com/h/$section/"
\&    );
\&    print
\&      $section, ": ", scalar(@links), " stories\en",
\&      map(("  ", $_\->[0], " : ", $_\->[1], "\en"), @links),
\&      "\en";
\&  }
.Ve
.PP
And we've got our own headline-extractor service!  This in and of
itself isn't no amazingly useful (since if you want to see the
headlines, you \fIcan\fR just look at the Yahoo News pages), but it could
easily be the basis for quite useful features like filtering the
headlines for matching certain keywords of interest to you.
.PP
Now, one of these days, Yahoo News will decide to change its \s-1HTML\s0
template.  When this happens, this will appear to the above program as
there being no links that meet the given criteria; or, less likely,
dozens of erroneous links will meet the criteria.  In either case, the
criteria will have to be changed for the new template; they may just
need adjustment, or you may need to scrap them and start over.
.SS "\fIRegardez, duvet!\fP"
.IX Subsection "Regardez, duvet!"
It's often quite a challenge to write criteria to match the desired
parts of an \s-1HTML\s0 parse tree.  Very often you \fIcan\fR pull it off with a
simple \f(CW\*(C`$tree\->look_down(\*(Aq_tag\*(Aq, \*(Aqh1\*(Aq)\*(C'\fR, but sometimes you do
have to keep adding and refining criteria, until you might end up with
complex filters like what I've shown in this article.  The
benefit to learning how to deal with \s-1HTML\s0 parse trees is that one main
search tool, the \f(CW\*(C`look_down\*(C'\fR method, can do most of the work, making
simple things easy, while still making hard things possible.
.PP
\&\fB[end body of article]\fR
.SS "[Author Credit]"
.IX Subsection "[Author Credit]"
Sean M. Burke (\f(CW\*(C`sburke@cpan.org\*(C'\fR) is the current maintainer of
\&\f(CW\*(C`HTML::TreeBuilder\*(C'\fR and \f(CW\*(C`HTML::Element\*(C'\fR, both originally by
Gisle Aas.
.PP
Sean adds: \*(L"I'd like to thank the folks who listened to me ramble
incessantly about HTML::TreeBuilder and HTML::Element at this year's Yet
Another Perl Conference and O'Reilly Open Source Software Convention.\*(R"
.SH "BACK"
.IX Header "BACK"
Return to the HTML::Tree docs.
