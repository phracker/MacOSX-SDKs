// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 5.4 (swiftlang-1205.0.24.14 clang-1205.0.19.54)
// swift-module-flags: -disable-objc-attr-requires-foundation-module -target x86_64-apple-macosx10.15 -enable-objc-interop -enable-library-evolution -module-link-name swiftCore -parse-stdlib -swift-version 5 -O -enforce-exclusivity=unchecked -enable-experimental-concise-pound-file -module-name Swift
import SwiftShims
@inlinable public func min<T>(_ x: T, _ y: T) -> T where T : Swift.Comparable {
  // In case `x == y` we pick `x`.
  // This preserves any pre-existing order in case `T` has identity,
  // which is important for e.g. the stability of sorting algorithms.
  // `(min(x, y), max(x, y))` should return `(x, y)` in case `x == y`.
  return y < x ? y : x
}
@inlinable public func min<T>(_ x: T, _ y: T, _ z: T, _ rest: T...) -> T where T : Swift.Comparable {
  var minValue = min(min(x, y), z)
  // In case `value == minValue`, we pick `minValue`. See min(_:_:).
  for value in rest where value < minValue {
    minValue = value
  }
  return minValue
}
@inlinable public func max<T>(_ x: T, _ y: T) -> T where T : Swift.Comparable {
  // In case `x == y`, we pick `y`. See min(_:_:).
  return y >= x ? y : x
}
@inlinable public func max<T>(_ x: T, _ y: T, _ z: T, _ rest: T...) -> T where T : Swift.Comparable {
  var maxValue = max(max(x, y), z)
  // In case `value == maxValue`, we pick `value`. See min(_:_:).
  for value in rest where value >= maxValue {
    maxValue = value
  }
  return maxValue
}
@frozen public struct EnumeratedSequence<Base> where Base : Swift.Sequence {
  @usableFromInline
  internal var _base: Base
  @inlinable internal init(_base: Base) {
    self._base = _base
  }
}
extension EnumeratedSequence {
  @frozen public struct Iterator {
    @usableFromInline
    internal var _base: Base.Iterator
    @usableFromInline
    internal var _count: Swift.Int
    @inlinable internal init(_base: Base.Iterator) {
      self._base = _base
      self._count = 0
    }
  }
}
extension EnumeratedSequence.Iterator : Swift.IteratorProtocol, Swift.Sequence {
  public typealias Element = (offset: Swift.Int, element: Base.Element)
  @inlinable public mutating func next() -> Swift.EnumeratedSequence<Base>.Iterator.Element? {
    guard let b = _base.next() else { return nil }
    let result = (offset: _count, element: b)
    _count += 1 
    return result
  }
  public typealias Iterator = Swift.EnumeratedSequence<Base>.Iterator
}
extension EnumeratedSequence : Swift.Sequence {
  @inlinable __consuming public func makeIterator() -> Swift.EnumeratedSequence<Base>.Iterator {
    return Iterator(_base: _base.makeIterator())
  }
  public typealias Element = Swift.EnumeratedSequence<Base>.Iterator.Element
}
@usableFromInline
@frozen internal struct _ArrayBody {
  @usableFromInline
  internal var _storage: SwiftShims._SwiftArrayBodyStorage
  @inlinable internal init(count: Swift.Int, capacity: Swift.Int, elementTypeIsBridgedVerbatim: Swift.Bool = false) {
    _internalInvariant(count >= 0)
    _internalInvariant(capacity >= 0)
    
    _storage = _SwiftArrayBodyStorage(
      count: count,
      _capacityAndFlags:
        (UInt(truncatingIfNeeded: capacity) &<< 1) |
        (elementTypeIsBridgedVerbatim ? 1 : 0))
  }
  @inlinable internal init() {
    _storage = _SwiftArrayBodyStorage(count: 0, _capacityAndFlags: 0)
  }
  @inlinable internal var count: Swift.Int {
    get {
      return _assumeNonNegative(_storage.count)
    }
    set(newCount) {
      _storage.count = newCount
    }
  }
  @inlinable internal var capacity: Swift.Int {
    get {
    return Int(_capacityAndFlags &>> 1)
  }
  }
  @inlinable internal var elementTypeIsBridgedVerbatim: Swift.Bool {
    get {
      return (_capacityAndFlags & 0x1) != 0
    }
    set {
      _capacityAndFlags
        = newValue ? _capacityAndFlags | 1 : _capacityAndFlags & ~1
    }
  }
  @inlinable internal var _capacityAndFlags: Swift.UInt {
    get {
      return _storage._capacityAndFlags
    }
    set {
      _storage._capacityAndFlags = newValue
    }
  }
}
@usableFromInline
internal typealias _ArrayBridgeStorage = Swift._BridgeStorage<Swift.__ContiguousArrayStorageBase>
@usableFromInline
@frozen internal struct _ArrayBuffer<Element> : Swift._ArrayBufferProtocol {
  @inlinable internal init() {
    _storage = _ArrayBridgeStorage(native: _emptyArrayStorage)
  }
  @inlinable internal init(nsArray: Swift.AnyObject) {
    _internalInvariant(_isClassOrObjCExistential(Element.self))
    _storage = _ArrayBridgeStorage(objC: nsArray)
  }
  @inlinable __consuming internal func cast<U>(toBufferOf _: U.Type) -> Swift._ArrayBuffer<U> {
    _internalInvariant(_isClassOrObjCExistential(Element.self))
    _internalInvariant(_isClassOrObjCExistential(U.self))
    return _ArrayBuffer<U>(storage: _storage)
  }
  @inlinable __consuming internal func downcast<U>(toBufferWithDeferredTypeCheckOf _: U.Type) -> Swift._ArrayBuffer<U> {
    _internalInvariant(_isClassOrObjCExistential(Element.self))
    _internalInvariant(_isClassOrObjCExistential(U.self))
    
    // FIXME: can't check that U is derived from Element pending
    // <rdar://problem/20028320> generic metatype casting doesn't work
    // _internalInvariant(U.self is Element.Type)

    return _ArrayBuffer<U>(
      storage: _ArrayBridgeStorage(native: _native._storage, isFlagged: true))
  }
  @inlinable internal var needsElementTypeCheck: Swift.Bool {
    get {
    // NSArray's need an element typecheck when the element type isn't AnyObject
    return !_isNativeTypeChecked && !(AnyObject.self is Element.Type)
  }
  }
  @inlinable internal init(storage: Swift._ArrayBridgeStorage) {
    _storage = storage
  }
  @usableFromInline
  internal var _storage: Swift._ArrayBridgeStorage
  @usableFromInline
  internal typealias Index = Swift.Int
  @usableFromInline
  internal typealias Iterator = Swift.IndexingIterator<Swift._ArrayBuffer<Element>>
  @usableFromInline
  internal typealias SubSequence = Swift._SliceBuffer<Element>
}
extension _ArrayBuffer {
  @inlinable internal init(_buffer source: Swift._ArrayBuffer<Element>.NativeBuffer, shiftedToStartIndex: Swift.Int) {
    _internalInvariant(shiftedToStartIndex == 0, "shiftedToStartIndex must be 0")
    _storage = _ArrayBridgeStorage(native: source._storage)
  }
  @inlinable internal var arrayPropertyIsNativeTypeChecked: Swift.Bool {
    get {
    return _isNativeTypeChecked
  }
  }
  @inlinable internal mutating func isUniquelyReferenced() -> Swift.Bool {
    if !_isClassOrObjCExistential(Element.self) {
      return _storage.isUniquelyReferencedUnflaggedNative()
    }
    return _storage.isUniquelyReferencedNative() && _isNative
   }
  @_alwaysEmitIntoClient internal mutating func beginCOWMutation() -> Swift.Bool {
    let isUnique: Bool
    if !_isClassOrObjCExistential(Element.self) {
      isUnique = _storage.beginCOWMutationUnflaggedNative()
    } else if !_storage.beginCOWMutationNative() {
      return false
    } else {
      isUnique = _isNative
    }
    return isUnique
  }
  @_alwaysEmitIntoClient @inline(__always) internal mutating func endCOWMutation() {
    _storage.endCOWMutation()
  }
  @inlinable internal func _asCocoaArray() -> Swift.AnyObject {
    return _fastPath(_isNative) ? _native._asCocoaArray() : _nonNative.buffer
  }
  @_alwaysEmitIntoClient @inline(never) @_semantics("optimize.sil.specialize.owned2guarantee.never") __consuming internal func _consumeAndCreateNew() -> Swift._ArrayBuffer<Element> {
    return _consumeAndCreateNew(bufferIsUnique: false,
                                minimumCapacity: count,
                                growForAppend: false)
  }
  @_alwaysEmitIntoClient @inline(never) @_semantics("optimize.sil.specialize.owned2guarantee.never") __consuming internal func _consumeAndCreateNew(bufferIsUnique: Swift.Bool, minimumCapacity: Swift.Int, growForAppend: Swift.Bool) -> Swift._ArrayBuffer<Element> {
    let newCapacity = _growArrayCapacity(oldCapacity: capacity,
                                         minimumCapacity: minimumCapacity,
                                         growForAppend: growForAppend)
    let c = count
    _internalInvariant(newCapacity >= c)
    
    let newBuffer = _ContiguousArrayBuffer<Element>(
      _uninitializedCount: c, minimumCapacity: newCapacity)

    if bufferIsUnique {
      // As an optimization, if the original buffer is unique, we can just move
      // the elements instead of copying.
      let dest = newBuffer.firstElementAddress
      dest.moveInitialize(from: mutableFirstElementAddress,
                          count: c)
      _native.mutableCount = 0
    } else {
      _copyContents(
        subRange: 0..<c,
        initializing: newBuffer.mutableFirstElementAddress)
    }
    return _ArrayBuffer(_buffer: newBuffer, shiftedToStartIndex: 0)
  }
  @inlinable internal mutating func requestUniqueMutableBackingBuffer(minimumCapacity: Swift.Int) -> Swift._ArrayBuffer<Element>.NativeBuffer? {
    if _fastPath(isUniquelyReferenced()) {
      let b = _native
      if _fastPath(b.mutableCapacity >= minimumCapacity) {
        return b
      }
    }
    return nil
  }
  @inlinable internal mutating func isMutableAndUniquelyReferenced() -> Swift.Bool {
    return isUniquelyReferenced()
  }
  @inlinable internal func requestNativeBuffer() -> Swift._ArrayBuffer<Element>.NativeBuffer? {
    if !_isClassOrObjCExistential(Element.self) {
      return _native
    }
    return _fastPath(_storage.isNative) ? _native : nil
  }
  @usableFromInline
  @inline(never) internal func _typeCheckSlowPath(_ index: Swift.Int)
  @inlinable internal func _typeCheck(_ subRange: Swift.Range<Swift.Int>) {
    if !_isClassOrObjCExistential(Element.self) {
      return
    }

    if _slowPath(needsElementTypeCheck) {
      // Could be sped up, e.g. by using
      // enumerateObjectsAtIndexes:options:usingBlock: in the
      // non-native case.
      for i in subRange.lowerBound ..< subRange.upperBound {
        _typeCheckSlowPath(i)
      }
    }
  }
  @discardableResult
  @inlinable __consuming internal func _copyContents(subRange bounds: Swift.Range<Swift.Int>, initializing target: Swift.UnsafeMutablePointer<Element>) -> Swift.UnsafeMutablePointer<Element> {
    _typeCheck(bounds)
    if _fastPath(_isNative) {
      return _native._copyContents(subRange: bounds, initializing: target)
    }
    let buffer = UnsafeMutableRawPointer(target)
      .assumingMemoryBound(to: AnyObject.self)
    let result = _nonNative._copyContents(
      subRange: bounds,
      initializing: buffer)
    return UnsafeMutableRawPointer(result).assumingMemoryBound(to: Element.self)
  }
  __consuming public func _copyContents(initializing buffer: Swift.UnsafeMutableBufferPointer<Element>) -> (Swift.IndexingIterator<Swift._ArrayBuffer<Element>>, Swift.UnsafeMutableBufferPointer<Element>.Index)
  @inlinable internal subscript(bounds: Swift.Range<Swift.Int>) -> Swift._SliceBuffer<Element> {
    get {
      _typeCheck(bounds)
      if _fastPath(_isNative) {
        return _native[bounds]
      }
      return _nonNative[bounds].unsafeCastElements(to: Element.self)
    }
    set {
      fatalError("not implemented")
    }
  }
  @inlinable internal var firstElementAddress: Swift.UnsafeMutablePointer<Element> {
    get {
    _internalInvariant(_isNative, "must be a native buffer")
    return _native.firstElementAddress
  }
  }
  @_alwaysEmitIntoClient internal var mutableFirstElementAddress: Swift.UnsafeMutablePointer<Element> {
    get {
    _internalInvariant(_isNative, "must be a native buffer")
    return _native.mutableFirstElementAddress
  }
  }
  @inlinable internal var firstElementAddressIfContiguous: Swift.UnsafeMutablePointer<Element>? {
    get {
    return _fastPath(_isNative) ? firstElementAddress : nil
  }
  }
  @inlinable internal var count: Swift.Int {
    @inline(__always) get {
      return _fastPath(_isNative) ? _native.count : _nonNative.endIndex
    }
    set {
      _internalInvariant(_isNative, "attempting to update count of Cocoa array")
      _native.count = newValue
    }
  }
  @_alwaysEmitIntoClient internal var immutableCount: Swift.Int {
    get {
    return _fastPath(_isNative) ? _native.immutableCount : _nonNative.endIndex
  }
  }
  @_alwaysEmitIntoClient internal var mutableCount: Swift.Int {
    @inline(__always) get {
      _internalInvariant(
        _isNative,
        "attempting to get mutating-count of non-native buffer")
      return _native.mutableCount
    }
    @inline(__always) set {
      _internalInvariant(_isNative, "attempting to update count of Cocoa array")
      _native.mutableCount = newValue
    }
  }
  @inlinable internal func _checkInoutAndNativeBounds(_ index: Swift.Int, wasNative: Swift.Bool) {
    _precondition(
      _isNative == wasNative,
      "inout rules were violated: the array was overwritten")

    if _fastPath(wasNative) {
      _native._checkValidSubscript(index)
    }
  }
  @inlinable internal func _checkInoutAndNativeTypeCheckedBounds(_ index: Swift.Int, wasNativeTypeChecked: Swift.Bool) {
    _precondition(
      _isNativeTypeChecked == wasNativeTypeChecked,
      "inout rules were violated: the array was overwritten")

    if _fastPath(wasNativeTypeChecked) {
      _native._checkValidSubscript(index)
    }
  }
  @_alwaysEmitIntoClient internal func _checkValidSubscriptMutating(_ index: Swift.Int) {
    _native._checkValidSubscriptMutating(index)
  }
  @inlinable internal var capacity: Swift.Int {
    get {
    return _fastPath(_isNative) ? _native.capacity : _nonNative.endIndex
  }
  }
  @_alwaysEmitIntoClient internal var immutableCapacity: Swift.Int {
    get {
    return _fastPath(_isNative) ? _native.immutableCapacity : _nonNative.count
  }
  }
  @_alwaysEmitIntoClient internal var mutableCapacity: Swift.Int {
    get {
    _internalInvariant(_isNative, "attempting to get mutating-capacity of non-native buffer")
    return _native.mutableCapacity
  }
  }
  @inlinable @inline(__always) internal func getElement(_ i: Swift.Int, wasNativeTypeChecked: Swift.Bool) -> Element {
    if _fastPath(wasNativeTypeChecked) {
      return _nativeTypeChecked[i]
    }
    return unsafeBitCast(_getElementSlowPath(i), to: Element.self)
  }
  @inline(never) @inlinable internal func _getElementSlowPath(_ i: Swift.Int) -> Swift.AnyObject {
    _internalInvariant(
      _isClassOrObjCExistential(Element.self),
      "Only single reference elements can be indexed here.")
    let element: AnyObject
    if _isNative {
      // _checkInoutAndNativeTypeCheckedBounds does no subscript
      // checking for the native un-typechecked case.  Therefore we
      // have to do it here.
      _native._checkValidSubscript(i)
      
      element = cast(toBufferOf: AnyObject.self)._native[i]
      precondition(
        element is Element,
        """
        Down-casted Array element failed to match the target type
        Expected \(Element.self) but found \(type(of: element))
        """
      )
    } else {
      // ObjC arrays do their own subscript checking.
      element = _nonNative[i]
      precondition(
        element is Element,
        """
        NSArray element failed to match the Swift Array Element type
        Expected \(Element.self) but found \(type(of: element))
        """
      )
    }
    return element
  }
  @inlinable internal subscript(i: Swift.Int) -> Element {
    get {
      return getElement(i, wasNativeTypeChecked: _isNativeTypeChecked)
    }
    nonmutating set {
      if _fastPath(_isNative) {
        _native[i] = newValue
      }
      else {
        var refCopy = self
        refCopy.replaceSubrange(
          i..<(i + 1),
          with: 1,
          elementsOf: CollectionOfOne(newValue))
      }
    }
  }
  @inlinable internal func withUnsafeBufferPointer<R>(_ body: (Swift.UnsafeBufferPointer<Element>) throws -> R) rethrows -> R {
    if _fastPath(_isNative) {
      defer { _fixLifetime(self) }
      return try body(
        UnsafeBufferPointer(start: firstElementAddress, count: count))
    }
    return try ContiguousArray(self).withUnsafeBufferPointer(body)
  }
  @inlinable internal mutating func withUnsafeMutableBufferPointer<R>(_ body: (Swift.UnsafeMutableBufferPointer<Element>) throws -> R) rethrows -> R {
    _internalInvariant(
      _isNative || count == 0,
      "Array is bridging an opaque NSArray; can't get a pointer to the elements"
    )
    defer { _fixLifetime(self) }
    return try body(UnsafeMutableBufferPointer(
      start: firstElementAddressIfContiguous, count: count))
  }
  @inlinable internal var owner: Swift.AnyObject {
    get {
    return _fastPath(_isNative) ? _native._storage : _nonNative.buffer
  }
  }
  @inlinable internal var nativeOwner: Swift.AnyObject {
    get {
    _internalInvariant(_isNative, "Expect a native array")
    return _native._storage
  }
  }
  @inlinable internal var identity: Swift.UnsafeRawPointer {
    get {
    if _isNative {
      return _native.identity
    }
    else {
      return UnsafeRawPointer(
        Unmanaged.passUnretained(_nonNative.buffer).toOpaque())
    }
  }
  }
  @inlinable internal var startIndex: Swift.Int {
    get {
    return 0
  }
  }
  @inlinable internal var endIndex: Swift.Int {
    get {
    return count
  }
  }
  @usableFromInline
  internal typealias Indices = Swift.Range<Swift.Int>
  @usableFromInline
  internal typealias NativeBuffer = Swift._ContiguousArrayBuffer<Element>
  @inlinable internal var _isNative: Swift.Bool {
    get {
    if !_isClassOrObjCExistential(Element.self) {
      return true
    } else {
      return _storage.isNative
    }
  }
  }
  @inlinable internal var _isNativeTypeChecked: Swift.Bool {
    get {
    if !_isClassOrObjCExistential(Element.self) {
      return true
    } else {
      return _storage.isUnflaggedNative
    }
  }
  }
  @inlinable internal var _native: Swift._ArrayBuffer<Element>.NativeBuffer {
    get {
    return NativeBuffer(
      _isClassOrObjCExistential(Element.self)
      ? _storage.nativeInstance : _storage.unflaggedNativeInstance)
  }
  }
  @inlinable internal var _nativeTypeChecked: Swift._ArrayBuffer<Element>.NativeBuffer {
    get {
    return NativeBuffer(_storage.unflaggedNativeInstance)
  }
  }
  @inlinable internal var _nonNative: Swift._CocoaArrayWrapper {
    get {
      _internalInvariant(_isClassOrObjCExistential(Element.self))
      return _CocoaArrayWrapper(_storage.objCInstance)
    }
  }
}
@usableFromInline
internal protocol _ArrayBufferProtocol : Swift.MutableCollection, Swift.RandomAccessCollection where Self.Indices == Swift.Range<Swift.Int> {
  init()
  init(_buffer: Swift._ContiguousArrayBuffer<Self.Element>, shiftedToStartIndex: Swift.Int)
  init(copying buffer: Self)
  @discardableResult
  __consuming func _copyContents(subRange bounds: Swift.Range<Swift.Int>, initializing target: Swift.UnsafeMutablePointer<Self.Element>) -> Swift.UnsafeMutablePointer<Self.Element>
  mutating func requestUniqueMutableBackingBuffer(minimumCapacity: Swift.Int) -> Swift._ContiguousArrayBuffer<Self.Element>?
  mutating func isMutableAndUniquelyReferenced() -> Swift.Bool
  func requestNativeBuffer() -> Swift._ContiguousArrayBuffer<Self.Element>?
  mutating func replaceSubrange<C>(_ subrange: Swift.Range<Swift.Int>, with newCount: Swift.Int, elementsOf newValues: __owned C) where C : Swift.Collection, Self.Element == C.Element
  subscript(bounds: Swift.Range<Swift.Int>) -> Swift._SliceBuffer<Self.Element> { get }
  func withUnsafeBufferPointer<R>(_ body: (Swift.UnsafeBufferPointer<Self.Element>) throws -> R) rethrows -> R
  mutating func withUnsafeMutableBufferPointer<R>(_ body: (Swift.UnsafeMutableBufferPointer<Self.Element>) throws -> R) rethrows -> R
  override var count: Swift.Int { get set }
  var capacity: Swift.Int { get }
  var owner: Swift.AnyObject { get }
  var firstElementAddress: Swift.UnsafeMutablePointer<Self.Element> { get }
  var firstElementAddressIfContiguous: Swift.UnsafeMutablePointer<Self.Element>? { get }
  var subscriptBaseAddress: Swift.UnsafeMutablePointer<Self.Element> { get }
  var identity: Swift.UnsafeRawPointer { get }
}
extension _ArrayBufferProtocol {
  @inlinable internal var subscriptBaseAddress: Swift.UnsafeMutablePointer<Self.Element> {
    get {
    return firstElementAddress
  }
  }
  @inline(never) @inlinable internal init(copying buffer: Self) {
    let newBuffer = _ContiguousArrayBuffer<Element>(
      _uninitializedCount: buffer.count, minimumCapacity: buffer.count)
    buffer._copyContents(
      subRange: buffer.indices,
      initializing: newBuffer.firstElementAddress)
    self = Self( _buffer: newBuffer, shiftedToStartIndex: buffer.startIndex)
  }
  @inlinable internal mutating func replaceSubrange<C>(_ subrange: Swift.Range<Swift.Int>, with newCount: Swift.Int, elementsOf newValues: __owned C) where C : Swift.Collection, Self.Element == C.Element {
    _internalInvariant(startIndex == 0, "_SliceBuffer should override this function.")
    let oldCount = self.count
    let eraseCount = subrange.count

    let growth = newCount - eraseCount
    // This check will prevent storing a 0 count to the empty array singleton.
    if growth != 0 {
      self.count = oldCount + growth
    }

    let elements = self.subscriptBaseAddress
    let oldTailIndex = subrange.upperBound
    let oldTailStart = elements + oldTailIndex
    let newTailIndex = oldTailIndex + growth
    let newTailStart = oldTailStart + growth
    let tailCount = oldCount - subrange.upperBound

    if growth > 0 {
      // Slide the tail part of the buffer forwards, in reverse order
      // so as not to self-clobber.
      newTailStart.moveInitialize(from: oldTailStart, count: tailCount)

      // Assign over the original subrange
      var i = newValues.startIndex
      for j in subrange {
        elements[j] = newValues[i]
        newValues.formIndex(after: &i)
      }
      // Initialize the hole left by sliding the tail forward
      for j in oldTailIndex..<newTailIndex {
        (elements + j).initialize(to: newValues[i])
        newValues.formIndex(after: &i)
      }
      _expectEnd(of: newValues, is: i)
    }
    else { // We're not growing the buffer
      // Assign all the new elements into the start of the subrange
      var i = subrange.lowerBound
      var j = newValues.startIndex
      for _ in 0..<newCount {
        elements[i] = newValues[j]
        i += 1
        newValues.formIndex(after: &j)
      }
      _expectEnd(of: newValues, is: j)

      // If the size didn't change, we're done.
      if growth == 0 {
        return
      }

      // Move the tail backward to cover the shrinkage.
      let shrinkage = -growth
      if tailCount > shrinkage {   // If the tail length exceeds the shrinkage

        // Assign over the rest of the replaced range with the first
        // part of the tail.
        newTailStart.moveAssign(from: oldTailStart, count: shrinkage)

        // Slide the rest of the tail back
        oldTailStart.moveInitialize(
          from: oldTailStart + shrinkage, count: tailCount - shrinkage)
      }
      else {                      // Tail fits within erased elements
        // Assign over the start of the replaced range with the tail
        newTailStart.moveAssign(from: oldTailStart, count: tailCount)

        // Destroy elements remaining after the tail in subrange
        (newTailStart + tailCount).deinitialize(
          count: shrinkage - tailCount)
      }
    }
  }
}
@inlinable public func _arrayForceCast<SourceElement, TargetElement>(_ source: Swift.Array<SourceElement>) -> Swift.Array<TargetElement> {
  if _isClassOrObjCExistential(SourceElement.self)
  && _isClassOrObjCExistential(TargetElement.self) {
    let src = source._buffer
    if let native = src.requestNativeBuffer() {
      if native.storesOnlyElementsOfType(TargetElement.self) {
        // A native buffer that is known to store only elements of the
        // TargetElement can be used directly
        return Array(_buffer: src.cast(toBufferOf: TargetElement.self))
      }
      // Other native buffers must use deferred element type checking
      return Array(_buffer:
        src.downcast(toBufferWithDeferredTypeCheckOf: TargetElement.self))
    }
    return Array(_immutableCocoaArray: source._buffer._asCocoaArray())
  }
  return source.map { $0 as! TargetElement }
}
@inlinable public func _arrayConditionalCast<SourceElement, TargetElement>(_ source: [SourceElement]) -> [TargetElement]? {
  var successfulCasts = ContiguousArray<TargetElement>()
  successfulCasts.reserveCapacity(source.count)
  for element in source {
    if let casted = element as? TargetElement {
      successfulCasts.append(casted)
    } else {
      return nil
    }
  }
  return Array(successfulCasts)
}
@frozen public struct Array<Element> : Swift._DestructorSafeContainer {
  @usableFromInline
  internal typealias _Buffer = Swift._ArrayBuffer<Element>
  @usableFromInline
  internal var _buffer: Swift.Array<Element>._Buffer
  @inlinable internal init(_buffer: Swift.Array<Element>._Buffer) {
    self._buffer = _buffer
  }
}
extension Array {
  @inlinable @_semantics("array.props.isNativeTypeChecked") public func _hoistableIsNativeTypeChecked() -> Swift.Bool {
   return _buffer.arrayPropertyIsNativeTypeChecked
  }
  @inlinable @_semantics("array.get_count") internal func _getCount() -> Swift.Int {
    return _buffer.immutableCount
  }
  @inlinable @_semantics("array.get_capacity") internal func _getCapacity() -> Swift.Int {
    return _buffer.immutableCapacity
  }
  @inlinable @_semantics("array.make_mutable") internal mutating func _makeMutableAndUnique() {
    if _slowPath(!_buffer.beginCOWMutation()) {
      _buffer = _buffer._consumeAndCreateNew()
    }
  }
  @_alwaysEmitIntoClient @_semantics("array.end_mutation") internal mutating func _endMutation() {
    _buffer.endCOWMutation()
  }
  @inlinable @inline(__always) internal func _checkSubscript_native(_ index: Swift.Int) {
    _ = _checkSubscript(index, wasNativeTypeChecked: true)
  }
  @inlinable @_semantics("array.check_subscript") public func _checkSubscript(_ index: Swift.Int, wasNativeTypeChecked: Swift.Bool) -> Swift._DependenceToken {
    _buffer._checkInoutAndNativeTypeCheckedBounds(
      index, wasNativeTypeChecked: wasNativeTypeChecked)
    return _DependenceToken()
  }
  @_alwaysEmitIntoClient @_semantics("array.check_subscript") internal func _checkSubscript_mutating(_ index: Swift.Int) {
    _buffer._checkValidSubscriptMutating(index)
  }
  @inlinable @_semantics("array.check_index") internal func _checkIndex(_ index: Swift.Int) {
    _precondition(index <= endIndex, "Array index is out of range")
    _precondition(index >= startIndex, "Negative Array index is out of range")
  }
  @_semantics("array.get_element") @inlinable @inline(__always) public func _getElement(_ index: Swift.Int, wasNativeTypeChecked: Swift.Bool, matchingSubscriptCheck: Swift._DependenceToken) -> Element {
    return _buffer.getElement(index, wasNativeTypeChecked: wasNativeTypeChecked)
  }
  @inlinable @_semantics("array.get_element_address") internal func _getElementAddress(_ index: Swift.Int) -> Swift.UnsafeMutablePointer<Element> {
    return _buffer.firstElementAddress + index
  }
}
extension Array : Swift._ArrayProtocol {
  @inlinable public var capacity: Swift.Int {
    get {
    return _getCapacity()
  }
  }
  @inlinable public var _owner: Swift.AnyObject? {
    @inlinable @inline(__always) get {
      return _buffer.owner      
    }
  }
  @inlinable public var _baseAddressIfContiguous: Swift.UnsafeMutablePointer<Element>? {
    @inline(__always) get { return _buffer.firstElementAddressIfContiguous }
  }
}
extension Array : Swift.RandomAccessCollection, Swift.MutableCollection {
  public typealias Index = Swift.Int
  public typealias Indices = Swift.Range<Swift.Int>
  public typealias Iterator = Swift.IndexingIterator<Swift.Array<Element>>
  @inlinable public var startIndex: Swift.Int {
    get {
    return 0
  }
  }
  @inlinable public var endIndex: Swift.Int {
    @inlinable get {
      return _getCount()
    }
  }
  @inlinable public func index(after i: Swift.Int) -> Swift.Int {
    // NOTE: this is a manual specialization of index movement for a Strideable
    // index that is required for Array performance.  The optimizer is not
    // capable of creating partial specializations yet.
    // NOTE: Range checks are not performed here, because it is done later by
    // the subscript function.
    return i + 1
  }
  @inlinable public func formIndex(after i: inout Swift.Int) {
    // NOTE: this is a manual specialization of index movement for a Strideable
    // index that is required for Array performance.  The optimizer is not
    // capable of creating partial specializations yet.
    // NOTE: Range checks are not performed here, because it is done later by
    // the subscript function.
    i += 1
  }
  @inlinable public func index(before i: Swift.Int) -> Swift.Int {
    // NOTE: this is a manual specialization of index movement for a Strideable
    // index that is required for Array performance.  The optimizer is not
    // capable of creating partial specializations yet.
    // NOTE: Range checks are not performed here, because it is done later by
    // the subscript function.
    return i - 1
  }
  @inlinable public func formIndex(before i: inout Swift.Int) {
    // NOTE: this is a manual specialization of index movement for a Strideable
    // index that is required for Array performance.  The optimizer is not
    // capable of creating partial specializations yet.
    // NOTE: Range checks are not performed here, because it is done later by
    // the subscript function.
    i -= 1
  }
  @inlinable public func index(_ i: Swift.Int, offsetBy distance: Swift.Int) -> Swift.Int {
    // NOTE: this is a manual specialization of index movement for a Strideable
    // index that is required for Array performance.  The optimizer is not
    // capable of creating partial specializations yet.
    // NOTE: Range checks are not performed here, because it is done later by
    // the subscript function.
    return i + distance
  }
  @inlinable public func index(_ i: Swift.Int, offsetBy distance: Swift.Int, limitedBy limit: Swift.Int) -> Swift.Int? {
    // NOTE: this is a manual specialization of index movement for a Strideable
    // index that is required for Array performance.  The optimizer is not
    // capable of creating partial specializations yet.
    // NOTE: Range checks are not performed here, because it is done later by
    // the subscript function.
    let l = limit - i
    if distance > 0 ? l >= 0 && l < distance : l <= 0 && distance < l {
      return nil
    }
    return i + distance
  }
  @inlinable public func distance(from start: Swift.Int, to end: Swift.Int) -> Swift.Int {
    // NOTE: this is a manual specialization of index movement for a Strideable
    // index that is required for Array performance.  The optimizer is not
    // capable of creating partial specializations yet.
    // NOTE: Range checks are not performed here, because it is done later by
    // the subscript function.
    return end - start
  }
  @inlinable public func _failEarlyRangeCheck(_ index: Swift.Int, bounds: Swift.Range<Swift.Int>) {
    // NOTE: This method is a no-op for performance reasons.
  }
  @inlinable public func _failEarlyRangeCheck(_ range: Swift.Range<Swift.Int>, bounds: Swift.Range<Swift.Int>) {
    // NOTE: This method is a no-op for performance reasons.
  }
  @inlinable public subscript(index: Swift.Int) -> Element {
    get {
      // This call may be hoisted or eliminated by the optimizer.  If
      // there is an inout violation, this value may be stale so needs to be
      // checked again below.
      let wasNativeTypeChecked = _hoistableIsNativeTypeChecked()

      // Make sure the index is in range and wasNativeTypeChecked is
      // still valid.
      let token = _checkSubscript(
        index, wasNativeTypeChecked: wasNativeTypeChecked)

      return _getElement(
        index, wasNativeTypeChecked: wasNativeTypeChecked,
        matchingSubscriptCheck: token)
    }
    _modify {
      _makeMutableAndUnique() // makes the array native, too
      _checkSubscript_mutating(index)
      let address = _buffer.mutableFirstElementAddress + index
      yield &address.pointee
      _endMutation();
    }
  }
  @inlinable public subscript(bounds: Swift.Range<Swift.Int>) -> Swift.ArraySlice<Element> {
    get {
      _checkIndex(bounds.lowerBound)
      _checkIndex(bounds.upperBound)
      return ArraySlice(_buffer: _buffer[bounds])
    }
    set(rhs) {
      _checkIndex(bounds.lowerBound)
      _checkIndex(bounds.upperBound)
      // If the replacement buffer has same identity, and the ranges match,
      // then this was a pinned in-place modification, nothing further needed.
      if self[bounds]._buffer.identity != rhs._buffer.identity
      || bounds != rhs.startIndex..<rhs.endIndex {
        self.replaceSubrange(bounds, with: rhs)
      }
    }
  }
  @inlinable public var count: Swift.Int {
    get {
    return _getCount()
  }
  }
  public typealias SubSequence = Swift.ArraySlice<Element>
}
extension Array : Swift.ExpressibleByArrayLiteral {
  @inlinable public init(arrayLiteral elements: Element...) {
    self = elements
  }
  public typealias ArrayLiteralElement = Element
}
extension Array : Swift.RangeReplaceableCollection {
  @inlinable @_semantics("array.init.empty") public init() {
    _buffer = _Buffer()
  }
  @inlinable public init<S>(_ s: S) where Element == S.Element, S : Swift.Sequence {
    self = Array(
      _buffer: _Buffer(
        _buffer: s._copyToContiguousArray()._buffer,
        shiftedToStartIndex: 0))
  }
  @inlinable @_semantics("array.init") public init(repeating repeatedValue: Element, count: Swift.Int) {
    var p: UnsafeMutablePointer<Element>
    (self, p) = Array._allocateUninitialized(count)
    for _ in 0..<count {
      p.initialize(to: repeatedValue)
      p += 1
    }
    _endMutation()
  }
  @usableFromInline
  @inline(never) internal static func _allocateBufferUninitialized(minimumCapacity: Swift.Int) -> Swift.Array<Element>._Buffer
  @inlinable internal init(_uninitializedCount count: Swift.Int) {
    _precondition(count >= 0, "Can't construct Array with count < 0")
    // Note: Sinking this constructor into an else branch below causes an extra
    // Retain/Release.
    _buffer = _Buffer()
    if count > 0 {
      // Creating a buffer instead of calling reserveCapacity saves doing an
      // unnecessary uniqueness check. We disable inlining here to curb code
      // growth.
      _buffer = Array._allocateBufferUninitialized(minimumCapacity: count)
      _buffer.mutableCount = count
    }
    // Can't store count here because the buffer might be pointing to the
    // shared empty array.
  }
  @inlinable @_semantics("array.uninitialized") internal static func _allocateUninitialized(_ count: Swift.Int) -> (Swift.Array<Element>, Swift.UnsafeMutablePointer<Element>) {
    let result = Array(_uninitializedCount: count)
    return (result, result._buffer.firstElementAddress)
  }
  @inlinable @_semantics("array.uninitialized") internal static func _adoptStorage(_ storage: __owned Swift._ContiguousArrayStorage<Element>, count: Swift.Int) -> (Swift.Array<Element>, Swift.UnsafeMutablePointer<Element>) {

    let innerBuffer = _ContiguousArrayBuffer<Element>(
      count: count,
      storage: storage)

    return (
      Array(
        _buffer: _Buffer(_buffer: innerBuffer, shiftedToStartIndex: 0)),
        innerBuffer.firstElementAddress)
  }
  @inlinable internal mutating func _deallocateUninitialized() {
    // Set the count to zero and just release as normal.
    // Somewhat of a hack.
    _buffer.mutableCount = 0
  }
  @inlinable @_semantics("array.mutate_unknown") public mutating func reserveCapacity(_ minimumCapacity: Swift.Int) {
    _reserveCapacityImpl(minimumCapacity: minimumCapacity,
                         growForAppend: false)
    _endMutation()
  }
  @_alwaysEmitIntoClient internal mutating func _reserveCapacityImpl(minimumCapacity: Swift.Int, growForAppend: Swift.Bool) {
    let isUnique = _buffer.beginCOWMutation()
    if _slowPath(!isUnique || _buffer.mutableCapacity < minimumCapacity) {
      _createNewBuffer(bufferIsUnique: isUnique,
                       minimumCapacity: Swift.max(minimumCapacity, _buffer.count),
                       growForAppend: growForAppend)
    }
    _internalInvariant(_buffer.mutableCapacity >= minimumCapacity)
    _internalInvariant(_buffer.mutableCapacity == 0 ||
                       _buffer.isUniquelyReferenced())
  }
  @_alwaysEmitIntoClient internal mutating func _createNewBuffer(bufferIsUnique: Swift.Bool, minimumCapacity: Swift.Int, growForAppend: Swift.Bool) {
    _internalInvariant(!bufferIsUnique || _buffer.isUniquelyReferenced())
    _buffer = _buffer._consumeAndCreateNew(bufferIsUnique: bufferIsUnique,
                                           minimumCapacity: minimumCapacity,
                                           growForAppend: growForAppend)
  }
  @inline(never) @inlinable internal mutating func _copyToNewBuffer(oldCount: Swift.Int) {
    let newCount = oldCount + 1
    var newBuffer = _buffer._forceCreateUniqueMutableBuffer(
      countForNewBuffer: oldCount, minNewCapacity: newCount)
    _buffer._arrayOutOfPlaceUpdate(&newBuffer, oldCount, 0)
  }
  @inlinable @_semantics("array.make_mutable") internal mutating func _makeUniqueAndReserveCapacityIfNotUnique() {
    if _slowPath(!_buffer.beginCOWMutation()) {
      _createNewBuffer(bufferIsUnique: false,
                       minimumCapacity: count + 1,
                       growForAppend: true)
    }
  }
  @inlinable @_semantics("array.mutate_unknown") internal mutating func _reserveCapacityAssumingUniqueBuffer(oldCount: Swift.Int) {
    // Due to make_mutable hoisting the situation can arise where we hoist
    // _makeMutableAndUnique out of loop and use it to replace
    // _makeUniqueAndReserveCapacityIfNotUnique that preceeds this call. If the
    // array was empty _makeMutableAndUnique does not replace the empty array
    // buffer by a unique buffer (it just replaces it by the empty array
    // singleton).
    // This specific case is okay because we will make the buffer unique in this
    // function because we request a capacity > 0 and therefore _copyToNewBuffer
    // will be called creating a new buffer.
    let capacity = _buffer.mutableCapacity
    _internalInvariant(capacity == 0 || _buffer.isMutableAndUniquelyReferenced())

    if _slowPath(oldCount + 1 > capacity) {
      _createNewBuffer(bufferIsUnique: capacity > 0,
                       minimumCapacity: oldCount + 1,
                       growForAppend: true)
    }
  }
  @inlinable @_semantics("array.mutate_unknown") internal mutating func _appendElementAssumeUniqueAndCapacity(_ oldCount: Swift.Int, newElement: __owned Element) {
    _internalInvariant(_buffer.isMutableAndUniquelyReferenced())
    _internalInvariant(_buffer.mutableCapacity >= _buffer.mutableCount + 1)

    _buffer.mutableCount = oldCount + 1
    (_buffer.mutableFirstElementAddress + oldCount).initialize(to: newElement)
  }
  @inlinable @_semantics("array.append_element") public mutating func append(_ newElement: __owned Element) {
    // Separating uniqueness check and capacity check allows hoisting the
    // uniqueness check out of a loop.
    _makeUniqueAndReserveCapacityIfNotUnique()
    let oldCount = _buffer.mutableCount
    _reserveCapacityAssumingUniqueBuffer(oldCount: oldCount)
    _appendElementAssumeUniqueAndCapacity(oldCount, newElement: newElement)
    _endMutation()
  }
  @inlinable @_semantics("array.append_contentsOf") public mutating func append<S>(contentsOf newElements: __owned S) where Element == S.Element, S : Swift.Sequence {

    defer {
      _endMutation()
    }

    let newElementsCount = newElements.underestimatedCount
    _reserveCapacityImpl(minimumCapacity: self.count + newElementsCount,
                         growForAppend: true)

    let oldCount = _buffer.mutableCount
    let startNewElements = _buffer.mutableFirstElementAddress + oldCount
    let buf = UnsafeMutableBufferPointer(
                start: startNewElements, 
                count: _buffer.mutableCapacity - oldCount)

    var (remainder,writtenUpTo) = buf.initialize(from: newElements)
    
    // trap on underflow from the sequence's underestimate:
    let writtenCount = buf.distance(from: buf.startIndex, to: writtenUpTo)
    _precondition(newElementsCount <= writtenCount, 
      "newElements.underestimatedCount was an overestimate")
    // can't check for overflow as sequences can underestimate

    // This check prevents a data race writing to _swiftEmptyArrayStorage
    if writtenCount > 0 {
      _buffer.mutableCount = _buffer.mutableCount + writtenCount
    }

    if _slowPath(writtenUpTo == buf.endIndex) {

      // A shortcut for appending an Array: If newElements is an Array then it's
      // guaranteed that buf.initialize(from: newElements) already appended all
      // elements. It reduces code size, because the following code
      // can be removed by the optimizer by constant folding this check in a
      // generic specialization.
      if S.self == [Element].self {
        _internalInvariant(remainder.next() == nil)
        return
      }

      // there may be elements that didn't fit in the existing buffer,
      // append them in slow sequence-only mode
      var newCount = _buffer.mutableCount
      var nextItem = remainder.next()
      while nextItem != nil {
        _reserveCapacityAssumingUniqueBuffer(oldCount: newCount)

        let currentCapacity = _buffer.mutableCapacity
        let base = _buffer.mutableFirstElementAddress

        // fill while there is another item and spare capacity
        while let next = nextItem, newCount < currentCapacity {
          (base + newCount).initialize(to: next)
          newCount += 1
          nextItem = remainder.next()
        }
        _buffer.mutableCount = newCount
      }
    }
  }
  @inlinable @_semantics("array.reserve_capacity_for_append") internal mutating func reserveCapacityForAppend(newElementsCount: Swift.Int) {
    // Ensure uniqueness, mutability, and sufficient storage.  Note that
    // for consistency, we need unique self even if newElements is empty.
    _reserveCapacityImpl(minimumCapacity: self.count + newElementsCount,
                         growForAppend: true)
    _endMutation()
  }
  @inlinable @_semantics("array.mutate_unknown") public mutating func _customRemoveLast() -> Element? {
    _makeMutableAndUnique()
    let newCount = _buffer.mutableCount - 1
    _precondition(newCount >= 0, "Can't removeLast from an empty Array")
    let pointer = (_buffer.mutableFirstElementAddress + newCount)
    let element = pointer.move()
    _buffer.mutableCount = newCount
    _endMutation()
    return element
  }
  @discardableResult
  @inlinable @_semantics("array.mutate_unknown") public mutating func remove(at index: Swift.Int) -> Element {
    _makeMutableAndUnique()
    let currentCount = _buffer.mutableCount
    _precondition(index < currentCount, "Index out of range")
    _precondition(index >= 0, "Index out of range")
    let newCount = currentCount - 1
    let pointer = (_buffer.mutableFirstElementAddress + index)
    let result = pointer.move()
    pointer.moveInitialize(from: pointer + 1, count: newCount - index)
    _buffer.mutableCount = newCount
    _endMutation()
    return result
  }
  @inlinable public mutating func insert(_ newElement: __owned Element, at i: Swift.Int) {
    _checkIndex(i)
    self.replaceSubrange(i..<i, with: CollectionOfOne(newElement))
  }
  @inlinable public mutating func removeAll(keepingCapacity keepCapacity: Swift.Bool = false) {
    if !keepCapacity {
      _buffer = _Buffer()
    }
    else {
      self.replaceSubrange(indices, with: EmptyCollection())
    }
  }
  @inlinable public mutating func _withUnsafeMutableBufferPointerIfSupported<R>(_ body: (inout Swift.UnsafeMutableBufferPointer<Element>) throws -> R) rethrows -> R? {
    return try withUnsafeMutableBufferPointer {
      (bufferPointer) -> R in
      return try body(&bufferPointer)
    }
  }
  @inlinable public mutating func withContiguousMutableStorageIfAvailable<R>(_ body: (inout Swift.UnsafeMutableBufferPointer<Element>) throws -> R) rethrows -> R? {
    return try withUnsafeMutableBufferPointer {
      (bufferPointer) -> R in
      return try body(&bufferPointer)
    }
  }
  @inlinable public func withContiguousStorageIfAvailable<R>(_ body: (Swift.UnsafeBufferPointer<Element>) throws -> R) rethrows -> R? {
    return try withUnsafeBufferPointer {
      (bufferPointer) -> R in
      return try body(bufferPointer)
    }
  }
  @inlinable __consuming public func _copyToContiguousArray() -> Swift.ContiguousArray<Element> {
    if let n = _buffer.requestNativeBuffer() {
      return ContiguousArray(_buffer: n)
    }
    return _copyCollectionToContiguousArray(self)
  }
}
extension Array {
  @inlinable public static func + (lhs: Swift.Array<Element>, rhs: Swift.Array<Element>) -> Swift.Array<Element> {
    var lhs = lhs
    lhs.append(contentsOf: rhs)
    return lhs
  }
  @inlinable public static func += (lhs: inout Swift.Array<Element>, rhs: Swift.Array<Element>) {
    lhs.append(contentsOf: rhs)
  }
}
extension Array : Swift.CustomReflectable {
  public var customMirror: Swift.Mirror {
    get
  }
}
extension Array : Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible {
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
}
extension Array {
  @usableFromInline
  @_transparent internal func _cPointerArgs() -> (Swift.AnyObject?, Swift.UnsafeRawPointer?) {
    let p = _baseAddressIfContiguous
    if _fastPath(p != nil || isEmpty) {
      return (_owner, UnsafeRawPointer(p))
    }
    let n = ContiguousArray(self._buffer)._buffer
    return (n.owner, UnsafeRawPointer(n.firstElementAddress))
  }
}
extension Array {
  @inlinable internal init(_unsafeUninitializedCapacity: Swift.Int, initializingWith initializer: (inout Swift.UnsafeMutableBufferPointer<Element>, inout Swift.Int) throws -> Swift.Void) rethrows {
    var firstElementAddress: UnsafeMutablePointer<Element>
    (self, firstElementAddress) =
      Array._allocateUninitialized(_unsafeUninitializedCapacity)

    var initializedCount = 0
    var buffer = UnsafeMutableBufferPointer<Element>(
      start: firstElementAddress, count: _unsafeUninitializedCapacity)
    defer {
      // Update self.count even if initializer throws an error.
      _precondition(
        initializedCount <= _unsafeUninitializedCapacity,
        "Initialized count set to greater than specified capacity."
      )
      _precondition(
        buffer.baseAddress == firstElementAddress,
        "Can't reassign buffer in Array(unsafeUninitializedCapacity:initializingWith:)"
      )
      self._buffer.mutableCount = initializedCount
      _endMutation()
    }
    try initializer(&buffer, &initializedCount)
  }
  @_alwaysEmitIntoClient @inlinable public init(unsafeUninitializedCapacity: Swift.Int, initializingWith initializer: (inout Swift.UnsafeMutableBufferPointer<Element>, inout Swift.Int) throws -> Swift.Void) rethrows {
    self = try Array(
      _unsafeUninitializedCapacity: unsafeUninitializedCapacity,
      initializingWith: initializer)
  }
  @inlinable public func withUnsafeBufferPointer<R>(_ body: (Swift.UnsafeBufferPointer<Element>) throws -> R) rethrows -> R {
    return try _buffer.withUnsafeBufferPointer(body)
  }
  @_semantics("array.withUnsafeMutableBufferPointer") @inlinable @inline(__always) public mutating func withUnsafeMutableBufferPointer<R>(_ body: (inout Swift.UnsafeMutableBufferPointer<Element>) throws -> R) rethrows -> R {
    _makeMutableAndUnique()
    let count = _buffer.mutableCount

    // Ensure that body can't invalidate the storage or its bounds by
    // moving self into a temporary working array.
    // NOTE: The stack promotion optimization that keys of the
    // "array.withUnsafeMutableBufferPointer" semantics annotation relies on the
    // array buffer not being able to escape in the closure. It can do this
    // because we swap the array buffer in self with an empty buffer here. Any
    // escape via the address of self in the closure will therefore escape the
    // empty array.

    var work = Array()
    (work, self) = (self, work)

    // Create an UnsafeBufferPointer over work that we can pass to body
    let pointer = work._buffer.mutableFirstElementAddress
    var inoutBufferPointer = UnsafeMutableBufferPointer(
      start: pointer, count: count)

    // Put the working array back before returning.
    defer {
      _precondition(
        inoutBufferPointer.baseAddress == pointer &&
        inoutBufferPointer.count == count,
        "Array withUnsafeMutableBufferPointer: replacing the buffer is not allowed")

      (work, self) = (self, work)
      _endMutation()
    }

    // Invoke the body.
    return try body(&inoutBufferPointer)
  }
  @inlinable __consuming public func _copyContents(initializing buffer: Swift.UnsafeMutableBufferPointer<Element>) -> (Swift.Array<Element>.Iterator, Swift.UnsafeMutableBufferPointer<Element>.Index) {

    guard !self.isEmpty else { return (makeIterator(),buffer.startIndex) }

    // It is not OK for there to be no pointer/not enough space, as this is
    // a precondition and Array never lies about its count.
    guard var p = buffer.baseAddress
      else { _preconditionFailure("Attempt to copy contents into nil buffer pointer") }
    _precondition(self.count <= buffer.count, 
      "Insufficient space allocated to copy array contents")

    if let s = _baseAddressIfContiguous {
      p.initialize(from: s, count: self.count)
      // Need a _fixLifetime bracketing the _baseAddressIfContiguous getter
      // and all uses of the pointer it returns:
      _fixLifetime(self._owner)
    } else {
      for x in self {
        p.initialize(to: x)
        p += 1
      }
    }

    var it = IndexingIterator(_elements: self)
    it._position = endIndex
    return (it,buffer.index(buffer.startIndex, offsetBy: self.count))
  }
}
extension Array {
  @inlinable @_semantics("array.mutate_unknown") public mutating func replaceSubrange<C>(_ subrange: Swift.Range<Swift.Int>, with newElements: __owned C) where Element == C.Element, C : Swift.Collection {
    _precondition(subrange.lowerBound >= self._buffer.startIndex,
      "Array replace: subrange start is negative")

    _precondition(subrange.upperBound <= _buffer.endIndex,
      "Array replace: subrange extends past the end")

    let eraseCount = subrange.count
    let insertCount = newElements.count
    let growth = insertCount - eraseCount

    _reserveCapacityImpl(minimumCapacity: self.count + growth,
                         growForAppend: true)
    _buffer.replaceSubrange(subrange, with: insertCount, elementsOf: newElements)
    _endMutation()
  }
}
extension Array : Swift.Equatable where Element : Swift.Equatable {
  @inlinable public static func == (lhs: Swift.Array<Element>, rhs: Swift.Array<Element>) -> Swift.Bool {
    let lhsCount = lhs.count
    if lhsCount != rhs.count {
      return false
    }

    // Test referential equality.
    if lhsCount == 0 || lhs._buffer.identity == rhs._buffer.identity {
      return true
    }


    _internalInvariant(lhs.startIndex == 0 && rhs.startIndex == 0)
    _internalInvariant(lhs.endIndex == lhsCount && rhs.endIndex == lhsCount)

    // We know that lhs.count == rhs.count, compare element wise.
    for idx in 0..<lhsCount {
      if lhs[idx] != rhs[idx] {
        return false
      }
    }

    return true
  }
}
extension Array : Swift.Hashable where Element : Swift.Hashable {
  @inlinable public func hash(into hasher: inout Swift.Hasher) {
    hasher.combine(count) // discriminator
    for element in self {
      hasher.combine(element)
    }
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension Array {
  @inlinable public mutating func withUnsafeMutableBytes<R>(_ body: (Swift.UnsafeMutableRawBufferPointer) throws -> R) rethrows -> R {
    return try self.withUnsafeMutableBufferPointer {
      return try body(UnsafeMutableRawBufferPointer($0))
    }
  }
  @inlinable public func withUnsafeBytes<R>(_ body: (Swift.UnsafeRawBufferPointer) throws -> R) rethrows -> R {
    return try self.withUnsafeBufferPointer {
      try body(UnsafeRawBufferPointer($0))
    }
  }
}
@usableFromInline
internal func _bridgeCocoaArray<T>(_ _immutableCocoaArray: Swift.AnyObject) -> Swift.Array<T>
extension Array {
  @inlinable public func _bridgeToObjectiveCImpl() -> Swift.AnyObject {
    return _buffer._asCocoaArray()
  }
  @inlinable public static func _bridgeFromObjectiveCAdoptingNativeStorageOf(_ source: Swift.AnyObject) -> Swift.Array<Element>? {
    // If source is deferred, we indirect to get its native storage
    let maybeNative = (source as? __SwiftDeferredNSArray)?._nativeStorage ?? source

    return (maybeNative as? _ContiguousArrayStorage<Element>).map {
      Array(_ContiguousArrayBuffer($0))
    }
  }
  @inlinable public init(_immutableCocoaArray: Swift.AnyObject) {
    self = _bridgeCocoaArray(_immutableCocoaArray)
  }
}
extension Array : Swift._HasCustomAnyHashableRepresentation where Element : Swift.Hashable {
  __consuming public func _toCustomAnyHashable() -> Swift.AnyHashable?
}
@frozen public struct _DependenceToken {
  @inlinable public init() {
  }
}
@inlinable @inline(__always) @_semantics("array.uninitialized_intrinsic") public func _allocateUninitializedArray<Element>(_ builtinCount: Builtin.Word) -> (Swift.Array<Element>, Builtin.RawPointer) {
  let count = Int(builtinCount)
  if count > 0 {
    // Doing the actual buffer allocation outside of the array.uninitialized
    // semantics function enables stack propagation of the buffer.
    let bufferObject = Builtin.allocWithTailElems_1(
      _ContiguousArrayStorage<Element>.self, builtinCount, Element.self)

    let (array, ptr) = Array<Element>._adoptStorage(bufferObject, count: count)
    return (array, ptr._rawValue)
  }
  // For an empty array no buffer allocation is needed.
  let (array, ptr) = Array<Element>._allocateUninitialized(count)
  return (array, ptr._rawValue)
}
@inlinable @_semantics("array.dealloc_uninitialized") public func _deallocateUninitializedArray<Element>(_ array: __owned Swift.Array<Element>) {
  var array = array
  array._deallocateUninitialized()
}
@_alwaysEmitIntoClient @_semantics("array.finalize_intrinsic") @_effects(readnone) public func _finalizeUninitializedArray<Element>(_ array: __owned Swift.Array<Element>) -> Swift.Array<Element> {
  var mutableArray = array
  mutableArray._endMutation()
  return mutableArray
}
extension _ArrayBufferProtocol {
  @inlinable @inline(never) internal mutating func _arrayOutOfPlaceReplace<C>(_ bounds: Swift.Range<Swift.Int>, with newValues: __owned C, count insertCount: Swift.Int) where C : Swift.Collection, Self.Element == C.Element {

    let growth = insertCount - bounds.count
    let newCount = self.count + growth
    var newBuffer = _forceCreateUniqueMutableBuffer(
      newCount: newCount, requiredCapacity: newCount)

    _arrayOutOfPlaceUpdate(
      &newBuffer, bounds.lowerBound - startIndex, insertCount,
      { rawMemory, count in
        var p = rawMemory
        var q = newValues.startIndex
        for _ in 0..<count {
          p.initialize(to: newValues[q])
          newValues.formIndex(after: &q)
          p += 1
        }
        _expectEnd(of: newValues, is: q)
      }
    )
  }
}
@inlinable internal func _expectEnd<C>(of s: C, is i: C.Index) where C : Swift.Collection {
  _debugPrecondition(
    i == s.endIndex,
    "invalid Collection: count differed in successive traversals")
}
@inlinable internal func _growArrayCapacity(_ capacity: Swift.Int) -> Swift.Int {
  return capacity * 2
}
@_alwaysEmitIntoClient internal func _growArrayCapacity(oldCapacity: Swift.Int, minimumCapacity: Swift.Int, growForAppend: Swift.Bool) -> Swift.Int {
  if growForAppend {
    if oldCapacity < minimumCapacity {
      // When appending to an array, grow exponentially.
      return Swift.max(minimumCapacity, _growArrayCapacity(oldCapacity))
    }
    return oldCapacity
  }
  // If not for append, just use the specified capacity, ignoring oldCapacity.
  // This means that we "shrink" the buffer in case minimumCapacity is less
  // than oldCapacity.
  return minimumCapacity
}
extension _ArrayBufferProtocol {
  @inline(never) @inlinable internal func _forceCreateUniqueMutableBuffer(newCount: Swift.Int, requiredCapacity: Swift.Int) -> Swift._ContiguousArrayBuffer<Self.Element> {
    return _forceCreateUniqueMutableBufferImpl(
      countForBuffer: newCount, minNewCapacity: newCount,
      requiredCapacity: requiredCapacity)
  }
  @inline(never) @inlinable internal func _forceCreateUniqueMutableBuffer(countForNewBuffer: Swift.Int, minNewCapacity: Swift.Int) -> Swift._ContiguousArrayBuffer<Self.Element> {
    return _forceCreateUniqueMutableBufferImpl(
      countForBuffer: countForNewBuffer, minNewCapacity: minNewCapacity,
      requiredCapacity: minNewCapacity)
  }
  @inlinable internal func _forceCreateUniqueMutableBufferImpl(countForBuffer: Swift.Int, minNewCapacity: Swift.Int, requiredCapacity: Swift.Int) -> Swift._ContiguousArrayBuffer<Self.Element> {
    _internalInvariant(countForBuffer >= 0)
    _internalInvariant(requiredCapacity >= countForBuffer)
    _internalInvariant(minNewCapacity >= countForBuffer)

    let minimumCapacity = Swift.max(requiredCapacity,
      minNewCapacity > capacity
         ? _growArrayCapacity(capacity) : capacity)

    return _ContiguousArrayBuffer(
      _uninitializedCount: countForBuffer, minimumCapacity: minimumCapacity)
  }
}
extension _ArrayBufferProtocol {
  @inline(never) @inlinable internal mutating func _arrayOutOfPlaceUpdate(_ dest: inout Swift._ContiguousArrayBuffer<Self.Element>, _ headCount: Swift.Int, _ newCount: Swift.Int, _ initializeNewElements: ((Swift.UnsafeMutablePointer<Self.Element>, Swift.Int) -> ()) = { ptr, count in
      _internalInvariant(count == 0)
    }) {

    _internalInvariant(headCount >= 0)
    _internalInvariant(newCount >= 0)

    // Count of trailing source elements to copy/move
    let sourceCount = self.count
    let tailCount = dest.count - headCount - newCount
    _internalInvariant(headCount + tailCount <= sourceCount)

    let oldCount = sourceCount - headCount - tailCount
    let destStart = dest.firstElementAddress
    let newStart = destStart + headCount
    let newEnd = newStart + newCount

    // Check to see if we have storage we can move from
    if let backing = requestUniqueMutableBackingBuffer(
      minimumCapacity: sourceCount) {

      let sourceStart = firstElementAddress
      let oldStart = sourceStart + headCount

      // Destroy any items that may be lurking in a _SliceBuffer before
      // its real first element
      let backingStart = backing.firstElementAddress
      let sourceOffset = sourceStart - backingStart
      backingStart.deinitialize(count: sourceOffset)

      // Move the head items
      destStart.moveInitialize(from: sourceStart, count: headCount)

      // Destroy unused source items
      oldStart.deinitialize(count: oldCount)

      initializeNewElements(newStart, newCount)

      // Move the tail items
      newEnd.moveInitialize(from: oldStart + oldCount, count: tailCount)

      // Destroy any items that may be lurking in a _SliceBuffer after
      // its real last element
      let backingEnd = backingStart + backing.count
      let sourceEnd = sourceStart + sourceCount
      sourceEnd.deinitialize(count: backingEnd - sourceEnd)
      backing.count = 0
    }
    else {
      let headStart = startIndex
      let headEnd = headStart + headCount
      let newStart = _copyContents(
        subRange: headStart..<headEnd,
        initializing: destStart)
      initializeNewElements(newStart, newCount)
      let tailStart = headEnd + oldCount
      let tailEnd = endIndex
      _copyContents(subRange: tailStart..<tailEnd, initializing: newEnd)
    }
    self = Self(_buffer: dest, shiftedToStartIndex: startIndex)
  }
}
extension _ArrayBufferProtocol {
  @usableFromInline
  @inline(never) internal mutating func _outlinedMakeUniqueBuffer(bufferCount: Swift.Int)
  @inlinable internal mutating func _arrayAppendSequence<S>(_ newItems: __owned S) where S : Swift.Sequence, Self.Element == S.Element {
    
    // this function is only ever called from append(contentsOf:)
    // which should always have exhausted its capacity before calling
    _internalInvariant(count == capacity)
    var newCount = self.count

    // there might not be any elements to append remaining,
    // so check for nil element first, then increase capacity,
    // then inner-loop to fill that capacity with elements
    var stream = newItems.makeIterator()
    var nextItem = stream.next()
    while nextItem != nil {

      // grow capacity, first time around and when filled
      var newBuffer = _forceCreateUniqueMutableBuffer(
        countForNewBuffer: newCount, 
        // minNewCapacity handles the exponential growth, just
        // need to request 1 more than current count/capacity
        minNewCapacity: newCount + 1)

      _arrayOutOfPlaceUpdate(&newBuffer, newCount, 0)

      let currentCapacity = self.capacity
      let base = self.firstElementAddress

      // fill while there is another item and spare capacity
      while let next = nextItem, newCount < currentCapacity {
        (base + newCount).initialize(to: next)
        newCount += 1
        nextItem = stream.next()
      }
      self.count = newCount
    }
  }
}
@frozen public struct ArraySlice<Element> : Swift._DestructorSafeContainer {
  @usableFromInline
  internal typealias _Buffer = Swift._SliceBuffer<Element>
  @usableFromInline
  internal var _buffer: Swift.ArraySlice<Element>._Buffer
  @inlinable internal init(_buffer: Swift.ArraySlice<Element>._Buffer) {
    self._buffer = _buffer
  }
  @inlinable internal init(_buffer buffer: Swift._ContiguousArrayBuffer<Element>) {
    self.init(_buffer: _Buffer(_buffer: buffer, shiftedToStartIndex: 0))
  }
}
extension ArraySlice {
  @inlinable @_semantics("array.props.isNativeTypeChecked") public func _hoistableIsNativeTypeChecked() -> Swift.Bool {
   return _buffer.arrayPropertyIsNativeTypeChecked
  }
  @inlinable @_semantics("array.get_count") internal func _getCount() -> Swift.Int {
    return _buffer.count
  }
  @inlinable @_semantics("array.get_capacity") internal func _getCapacity() -> Swift.Int {
    return _buffer.capacity
  }
  @inlinable @_semantics("array.make_mutable") internal mutating func _makeMutableAndUnique() {
    if _slowPath(!_buffer.beginCOWMutation()) {
      _buffer = _Buffer(copying: _buffer)
    }
  }
  @_alwaysEmitIntoClient @_semantics("array.end_mutation") internal mutating func _endMutation() {
    _buffer.endCOWMutation()
  }
  @inlinable @inline(__always) internal func _checkSubscript_native(_ index: Swift.Int) {
    _buffer._checkValidSubscript(index)
  }
  @inlinable @_semantics("array.check_subscript") public func _checkSubscript(_ index: Swift.Int, wasNativeTypeChecked: Swift.Bool) -> Swift._DependenceToken {
    _buffer._checkValidSubscript(index)
    return _DependenceToken()
  }
  @inlinable @_semantics("array.check_index") internal func _checkIndex(_ index: Swift.Int) {
    _precondition(index <= endIndex, "ArraySlice index is out of range")
    _precondition(index >= startIndex, "ArraySlice index is out of range (before startIndex)")
  }
  @_semantics("array.get_element") @inlinable @inline(__always) public func _getElement(_ index: Swift.Int, wasNativeTypeChecked: Swift.Bool, matchingSubscriptCheck: Swift._DependenceToken) -> Element {
    return _buffer.getElement(index)
  }
  @inlinable @_semantics("array.get_element_address") internal func _getElementAddress(_ index: Swift.Int) -> Swift.UnsafeMutablePointer<Element> {
    return _buffer.subscriptBaseAddress + index
  }
}
extension ArraySlice : Swift._ArrayProtocol {
  @inlinable public var capacity: Swift.Int {
    get {
    return _getCapacity()
  }
  }
  @inlinable public var _owner: Swift.AnyObject? {
    get {
    return _buffer.owner
  }
  }
  @inlinable public var _baseAddressIfContiguous: Swift.UnsafeMutablePointer<Element>? {
    @inline(__always) get { return _buffer.firstElementAddressIfContiguous }
  }
  @inlinable internal var _baseAddress: Swift.UnsafeMutablePointer<Element> {
    get {
    return _buffer.firstElementAddress
  }
  }
}
extension ArraySlice : Swift.RandomAccessCollection, Swift.MutableCollection {
  public typealias Index = Swift.Int
  public typealias Indices = Swift.Range<Swift.Int>
  public typealias Iterator = Swift.IndexingIterator<Swift.ArraySlice<Element>>
  @inlinable public var startIndex: Swift.Int {
    get {
    return _buffer.startIndex
  }
  }
  @inlinable public var endIndex: Swift.Int {
    get {
    return _buffer.endIndex
  }
  }
  @inlinable public func index(after i: Swift.Int) -> Swift.Int {
    // NOTE: this is a manual specialization of index movement for a Strideable
    // index that is required for Array performance.  The optimizer is not
    // capable of creating partial specializations yet.
    // NOTE: Range checks are not performed here, because it is done later by
    // the subscript function.
    return i + 1
  }
  @inlinable public func formIndex(after i: inout Swift.Int) {
    // NOTE: this is a manual specialization of index movement for a Strideable
    // index that is required for Array performance.  The optimizer is not
    // capable of creating partial specializations yet.
    // NOTE: Range checks are not performed here, because it is done later by
    // the subscript function.
    i += 1
  }
  @inlinable public func index(before i: Swift.Int) -> Swift.Int {
    // NOTE: this is a manual specialization of index movement for a Strideable
    // index that is required for Array performance.  The optimizer is not
    // capable of creating partial specializations yet.
    // NOTE: Range checks are not performed here, because it is done later by
    // the subscript function.
    return i - 1
  }
  @inlinable public func formIndex(before i: inout Swift.Int) {
    // NOTE: this is a manual specialization of index movement for a Strideable
    // index that is required for Array performance.  The optimizer is not
    // capable of creating partial specializations yet.
    // NOTE: Range checks are not performed here, because it is done later by
    // the subscript function.
    i -= 1
  }
  @inlinable public func index(_ i: Swift.Int, offsetBy distance: Swift.Int) -> Swift.Int {
    // NOTE: this is a manual specialization of index movement for a Strideable
    // index that is required for Array performance.  The optimizer is not
    // capable of creating partial specializations yet.
    // NOTE: Range checks are not performed here, because it is done later by
    // the subscript function.
    return i + distance
  }
  @inlinable public func index(_ i: Swift.Int, offsetBy distance: Swift.Int, limitedBy limit: Swift.Int) -> Swift.Int? {
    // NOTE: this is a manual specialization of index movement for a Strideable
    // index that is required for Array performance.  The optimizer is not
    // capable of creating partial specializations yet.
    // NOTE: Range checks are not performed here, because it is done later by
    // the subscript function.
    let l = limit - i
    if distance > 0 ? l >= 0 && l < distance : l <= 0 && distance < l {
      return nil
    }
    return i + distance
  }
  @inlinable public func distance(from start: Swift.Int, to end: Swift.Int) -> Swift.Int {
    // NOTE: this is a manual specialization of index movement for a Strideable
    // index that is required for Array performance.  The optimizer is not
    // capable of creating partial specializations yet.
    // NOTE: Range checks are not performed here, because it is done later by
    // the subscript function.
    return end - start
  }
  @inlinable public func _failEarlyRangeCheck(_ index: Swift.Int, bounds: Swift.Range<Swift.Int>) {
    // NOTE: This method is a no-op for performance reasons.
  }
  @inlinable public func _failEarlyRangeCheck(_ range: Swift.Range<Swift.Int>, bounds: Swift.Range<Swift.Int>) {
    // NOTE: This method is a no-op for performance reasons.
  }
  @inlinable public subscript(index: Swift.Int) -> Element {
    get {
      // This call may be hoisted or eliminated by the optimizer.  If
      // there is an inout violation, this value may be stale so needs to be
      // checked again below.
      let wasNativeTypeChecked = _hoistableIsNativeTypeChecked()

      // Make sure the index is in range and wasNativeTypeChecked is
      // still valid.
      let token = _checkSubscript(
        index, wasNativeTypeChecked: wasNativeTypeChecked)

      return _getElement(
        index, wasNativeTypeChecked: wasNativeTypeChecked,
        matchingSubscriptCheck: token)
    }
    _modify {
      _makeMutableAndUnique() // makes the array native, too
      _checkSubscript_native(index)
      let address = _buffer.subscriptBaseAddress + index
      yield &address.pointee
      _endMutation();
    }
  }
  @inlinable public subscript(bounds: Swift.Range<Swift.Int>) -> Swift.ArraySlice<Element> {
    get {
      _checkIndex(bounds.lowerBound)
      _checkIndex(bounds.upperBound)
      return ArraySlice(_buffer: _buffer[bounds])
    }
    set(rhs) {
      _checkIndex(bounds.lowerBound)
      _checkIndex(bounds.upperBound)
      // If the replacement buffer has same identity, and the ranges match,
      // then this was a pinned in-place modification, nothing further needed.
      if self[bounds]._buffer.identity != rhs._buffer.identity
      || bounds != rhs.startIndex..<rhs.endIndex {
        self.replaceSubrange(bounds, with: rhs)
      }
    }
  }
  @inlinable public var count: Swift.Int {
    get {
    return _getCount()
  }
  }
  public typealias SubSequence = Swift.ArraySlice<Element>
}
extension ArraySlice : Swift.ExpressibleByArrayLiteral {
  @inlinable public init(arrayLiteral elements: Element...) {
    self.init(_buffer: ContiguousArray(elements)._buffer)
  }
  public typealias ArrayLiteralElement = Element
}
extension ArraySlice : Swift.RangeReplaceableCollection {
  @inlinable @_semantics("array.init.empty") public init() {
    _buffer = _Buffer()
  }
  @inlinable public init<S>(_ s: S) where Element == S.Element, S : Swift.Sequence {

    self.init(_buffer: s._copyToContiguousArray()._buffer)
  }
  @inlinable @_semantics("array.init") public init(repeating repeatedValue: Element, count: Swift.Int) {
    _precondition(count >= 0, "Can't construct ArraySlice with count < 0")
    if count > 0 {
      _buffer = ArraySlice._allocateBufferUninitialized(minimumCapacity: count)
      _buffer.count = count
      var p = _buffer.firstElementAddress
      for _ in 0..<count {
        p.initialize(to: repeatedValue)
        p += 1
      }
    } else {
      _buffer = _Buffer()
    }
    _endMutation()
  }
  @usableFromInline
  @inline(never) internal static func _allocateBufferUninitialized(minimumCapacity: Swift.Int) -> Swift.ArraySlice<Element>._Buffer
  @inlinable @_semantics("array.init") internal init(_uninitializedCount count: Swift.Int) {
    _precondition(count >= 0, "Can't construct ArraySlice with count < 0")
    // Note: Sinking this constructor into an else branch below causes an extra
    // Retain/Release.
    _buffer = _Buffer()
    if count > 0 {
      // Creating a buffer instead of calling reserveCapacity saves doing an
      // unnecessary uniqueness check. We disable inlining here to curb code
      // growth.
      _buffer = ArraySlice._allocateBufferUninitialized(minimumCapacity: count)
      _buffer.count = count
    }
    // Can't store count here because the buffer might be pointing to the
    // shared empty array.
    _endMutation()
  }
  @inlinable @_semantics("array.uninitialized") internal static func _allocateUninitialized(_ count: Swift.Int) -> (Swift.ArraySlice<Element>, Swift.UnsafeMutablePointer<Element>) {
    let result = ArraySlice(_uninitializedCount: count)
    return (result, result._buffer.firstElementAddress)
  }
  @inlinable @_semantics("array.mutate_unknown") public mutating func reserveCapacity(_ minimumCapacity: Swift.Int) {
    if !_buffer.beginCOWMutation() || _buffer.capacity < minimumCapacity {
      let newBuffer = _ContiguousArrayBuffer<Element>(
        _uninitializedCount: count, minimumCapacity: minimumCapacity)

      _buffer._copyContents(
        subRange: _buffer.indices,
        initializing: newBuffer.firstElementAddress)
      _buffer = _Buffer(
        _buffer: newBuffer, shiftedToStartIndex: _buffer.startIndex)
    }
    _internalInvariant(capacity >= minimumCapacity)
    _endMutation()
  }
  @inline(never) @inlinable internal mutating func _copyToNewBuffer(oldCount: Swift.Int) {
    let newCount = oldCount + 1
    var newBuffer = _buffer._forceCreateUniqueMutableBuffer(
      countForNewBuffer: oldCount, minNewCapacity: newCount)
    _buffer._arrayOutOfPlaceUpdate(
      &newBuffer, oldCount, 0)
  }
  @inlinable @_semantics("array.make_mutable") internal mutating func _makeUniqueAndReserveCapacityIfNotUnique() {
    if _slowPath(!_buffer.beginCOWMutation()) {
      _copyToNewBuffer(oldCount: _buffer.count)
    }
  }
  @inlinable @_semantics("array.mutate_unknown") internal mutating func _reserveCapacityAssumingUniqueBuffer(oldCount: Swift.Int) {
    // Due to make_mutable hoisting the situation can arise where we hoist
    // _makeMutableAndUnique out of loop and use it to replace
    // _makeUniqueAndReserveCapacityIfNotUnique that preceeds this call. If the
    // array was empty _makeMutableAndUnique does not replace the empty array
    // buffer by a unique buffer (it just replaces it by the empty array
    // singleton).
    // This specific case is okay because we will make the buffer unique in this
    // function because we request a capacity > 0 and therefore _copyToNewBuffer
    // will be called creating a new buffer.
    let capacity = _buffer.capacity
    _internalInvariant(capacity == 0 || _buffer.isMutableAndUniquelyReferenced())

    if _slowPath(oldCount + 1 > capacity) {
      _copyToNewBuffer(oldCount: oldCount)
    }
  }
  @inlinable @_semantics("array.mutate_unknown") internal mutating func _appendElementAssumeUniqueAndCapacity(_ oldCount: Swift.Int, newElement: __owned Element) {
    _internalInvariant(_buffer.isMutableAndUniquelyReferenced())
    _internalInvariant(_buffer.capacity >= _buffer.count + 1)

    _buffer.count = oldCount + 1
    (_buffer.firstElementAddress + oldCount).initialize(to: newElement)
  }
  @inlinable @_semantics("array.append_element") public mutating func append(_ newElement: __owned Element) {
    _makeUniqueAndReserveCapacityIfNotUnique()
    let oldCount = _getCount()
    _reserveCapacityAssumingUniqueBuffer(oldCount: oldCount)
    _appendElementAssumeUniqueAndCapacity(oldCount, newElement: newElement)
    _endMutation()
  }
  @inlinable @_semantics("array.append_contentsOf") public mutating func append<S>(contentsOf newElements: __owned S) where Element == S.Element, S : Swift.Sequence {

    let newElementsCount = newElements.underestimatedCount
    reserveCapacityForAppend(newElementsCount: newElementsCount)
    _ = _buffer.beginCOWMutation()

    let oldCount = self.count
    let startNewElements = _buffer.firstElementAddress + oldCount
    let buf = UnsafeMutableBufferPointer(
                start: startNewElements, 
                count: self.capacity - oldCount)

    let (remainder,writtenUpTo) = buf.initialize(from: newElements)
    
    // trap on underflow from the sequence's underestimate:
    let writtenCount = buf.distance(from: buf.startIndex, to: writtenUpTo)
    _precondition(newElementsCount <= writtenCount,
      "newElements.underestimatedCount was an overestimate")
    // can't check for overflow as sequences can underestimate

    // This check prevents a data race writing to _swiftEmptyArrayStorage
    if writtenCount > 0 {
      _buffer.count += writtenCount
    }

    if writtenUpTo == buf.endIndex {
      // there may be elements that didn't fit in the existing buffer,
      // append them in slow sequence-only mode
      _buffer._arrayAppendSequence(IteratorSequence(remainder))
    }
    _endMutation()
  }
  @inlinable @_semantics("array.reserve_capacity_for_append") internal mutating func reserveCapacityForAppend(newElementsCount: Swift.Int) {
    let oldCount = self.count
    let oldCapacity = self.capacity
    let newCount = oldCount + newElementsCount

    // Ensure uniqueness, mutability, and sufficient storage.  Note that
    // for consistency, we need unique self even if newElements is empty.
    self.reserveCapacity(
      newCount > oldCapacity ?
      Swift.max(newCount, _growArrayCapacity(oldCapacity))
      : newCount)
  }
  @inlinable public mutating func _customRemoveLast() -> Element? {
    _precondition(count > 0, "Can't removeLast from an empty ArraySlice")
    // FIXME(performance): if `self` is uniquely referenced, we should remove
    // the element as shown below (this will deallocate the element and
    // decrease memory use).  If `self` is not uniquely referenced, the code
    // below will make a copy of the storage, which is wasteful.  Instead, we
    // should just shrink the view without allocating new storage.
    let i = endIndex
    // We don't check for overflow in `i - 1` because `i` is known to be
    // positive.
    let result = self[i &- 1]
    self.replaceSubrange((i &- 1)..<i, with: EmptyCollection())
    return result
  }
  @discardableResult
  @inlinable public mutating func remove(at index: Swift.Int) -> Element {
    let result = self[index]
    self.replaceSubrange(index..<(index + 1), with: EmptyCollection())
    return result
  }
  @inlinable public mutating func insert(_ newElement: __owned Element, at i: Swift.Int) {
    _checkIndex(i)
    self.replaceSubrange(i..<i, with: CollectionOfOne(newElement))
  }
  @inlinable public mutating func removeAll(keepingCapacity keepCapacity: Swift.Bool = false) {
    if !keepCapacity {
      _buffer = _Buffer()
    }
    else {
      self.replaceSubrange(indices, with: EmptyCollection())
    }
  }
  @inlinable public mutating func _withUnsafeMutableBufferPointerIfSupported<R>(_ body: (inout Swift.UnsafeMutableBufferPointer<Element>) throws -> R) rethrows -> R? {
    return try withUnsafeMutableBufferPointer {
      (bufferPointer) -> R in
      return try body(&bufferPointer)
    }
  }
  @inlinable public mutating func withContiguousMutableStorageIfAvailable<R>(_ body: (inout Swift.UnsafeMutableBufferPointer<Element>) throws -> R) rethrows -> R? {
    return try withUnsafeMutableBufferPointer {
      (bufferPointer) -> R in
      return try body(&bufferPointer)
    }
  }
  @inlinable public func withContiguousStorageIfAvailable<R>(_ body: (Swift.UnsafeBufferPointer<Element>) throws -> R) rethrows -> R? {
    return try withUnsafeBufferPointer {
      (bufferPointer) -> R in
      return try body(bufferPointer)
    }
  }
  @inlinable __consuming public func _copyToContiguousArray() -> Swift.ContiguousArray<Element> {
    if let n = _buffer.requestNativeBuffer() {
      return ContiguousArray(_buffer: n)
    }
    return _copyCollectionToContiguousArray(self)
  }
}
extension ArraySlice : Swift.CustomReflectable {
  public var customMirror: Swift.Mirror {
    get
  }
}
extension ArraySlice : Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible {
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
}
extension ArraySlice {
  @usableFromInline
  @_transparent internal func _cPointerArgs() -> (Swift.AnyObject?, Swift.UnsafeRawPointer?) {
    let p = _baseAddressIfContiguous
    if _fastPath(p != nil || isEmpty) {
      return (_owner, UnsafeRawPointer(p))
    }
    let n = ContiguousArray(self._buffer)._buffer
    return (n.owner, UnsafeRawPointer(n.firstElementAddress))
  }
}
extension ArraySlice {
  @inlinable public func withUnsafeBufferPointer<R>(_ body: (Swift.UnsafeBufferPointer<Element>) throws -> R) rethrows -> R {
    return try _buffer.withUnsafeBufferPointer(body)
  }
  @_semantics("array.withUnsafeMutableBufferPointer") @inlinable @inline(__always) public mutating func withUnsafeMutableBufferPointer<R>(_ body: (inout Swift.UnsafeMutableBufferPointer<Element>) throws -> R) rethrows -> R {
    let count = self.count
    // Ensure unique storage
    _makeMutableAndUnique()

    // Ensure that body can't invalidate the storage or its bounds by
    // moving self into a temporary working array.
    // NOTE: The stack promotion optimization that keys of the
    // "array.withUnsafeMutableBufferPointer" semantics annotation relies on the
    // array buffer not being able to escape in the closure. It can do this
    // because we swap the array buffer in self with an empty buffer here. Any
    // escape via the address of self in the closure will therefore escape the
    // empty array.

    var work = ArraySlice()
    (work, self) = (self, work)

    // Create an UnsafeBufferPointer over work that we can pass to body
    let pointer = work._buffer.firstElementAddress
    var inoutBufferPointer = UnsafeMutableBufferPointer(
      start: pointer, count: count)

    // Put the working array back before returning.
    defer {
      _precondition(
        inoutBufferPointer.baseAddress == pointer &&
        inoutBufferPointer.count == count,
        "ArraySlice withUnsafeMutableBufferPointer: replacing the buffer is not allowed")

      (work, self) = (self, work)
      _endMutation()
    }

    // Invoke the body.
    return try body(&inoutBufferPointer)
  }
  @inlinable __consuming public func _copyContents(initializing buffer: Swift.UnsafeMutableBufferPointer<Element>) -> (Swift.ArraySlice<Element>.Iterator, Swift.UnsafeMutableBufferPointer<Element>.Index) {

    guard !self.isEmpty else { return (makeIterator(),buffer.startIndex) }

    // It is not OK for there to be no pointer/not enough space, as this is
    // a precondition and Array never lies about its count.
    guard var p = buffer.baseAddress
      else { _preconditionFailure("Attempt to copy contents into nil buffer pointer") }
    _precondition(self.count <= buffer.count, 
      "Insufficient space allocated to copy array contents")

    if let s = _baseAddressIfContiguous {
      p.initialize(from: s, count: self.count)
      // Need a _fixLifetime bracketing the _baseAddressIfContiguous getter
      // and all uses of the pointer it returns:
      _fixLifetime(self._owner)
    } else {
      for x in self {
        p.initialize(to: x)
        p += 1
      }
    }

    var it = IndexingIterator(_elements: self)
    it._position = endIndex
    return (it,buffer.index(buffer.startIndex, offsetBy: self.count))
  }
}
extension ArraySlice {
  @inlinable @_semantics("array.mutate_unknown") public mutating func replaceSubrange<C>(_ subrange: Swift.Range<Swift.Int>, with newElements: __owned C) where Element == C.Element, C : Swift.Collection {
    _precondition(subrange.lowerBound >= _buffer.startIndex,
      "ArraySlice replace: subrange start is before the startIndex")

    _precondition(subrange.upperBound <= _buffer.endIndex,
      "ArraySlice replace: subrange extends past the end")

    let oldCount = _buffer.count
    let eraseCount = subrange.count
    let insertCount = newElements.count
    let growth = insertCount - eraseCount

    if _buffer.beginCOWMutation() && _buffer.capacity >= oldCount + growth {
      _buffer.replaceSubrange(
        subrange, with: insertCount, elementsOf: newElements)
    } else {
      _buffer._arrayOutOfPlaceReplace(subrange, with: newElements, count: insertCount)
    }
    _endMutation()
  }
}
extension ArraySlice : Swift.Equatable where Element : Swift.Equatable {
  @inlinable public static func == (lhs: Swift.ArraySlice<Element>, rhs: Swift.ArraySlice<Element>) -> Swift.Bool {
    let lhsCount = lhs.count
    if lhsCount != rhs.count {
      return false
    }

    // Test referential equality.
    if lhsCount == 0 || lhs._buffer.identity == rhs._buffer.identity {
      return true
    }


    var streamLHS = lhs.makeIterator()
    var streamRHS = rhs.makeIterator()

    var nextLHS = streamLHS.next()
    while nextLHS != nil {
      let nextRHS = streamRHS.next()
      if nextLHS != nextRHS {
        return false
      }
      nextLHS = streamLHS.next()
    }


    return true
  }
}
extension ArraySlice : Swift.Hashable where Element : Swift.Hashable {
  @inlinable public func hash(into hasher: inout Swift.Hasher) {
    hasher.combine(count) // discriminator
    for element in self {
      hasher.combine(element)
    }
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension ArraySlice {
  @inlinable public mutating func withUnsafeMutableBytes<R>(_ body: (Swift.UnsafeMutableRawBufferPointer) throws -> R) rethrows -> R {
    return try self.withUnsafeMutableBufferPointer {
      return try body(UnsafeMutableRawBufferPointer($0))
    }
  }
  @inlinable public func withUnsafeBytes<R>(_ body: (Swift.UnsafeRawBufferPointer) throws -> R) rethrows -> R {
    return try self.withUnsafeBufferPointer {
      try body(UnsafeRawBufferPointer($0))
    }
  }
}
extension ArraySlice {
  @inlinable public init(_startIndex: Swift.Int) {
    self.init(
      _buffer: _Buffer(
        _buffer: ContiguousArray()._buffer,
        shiftedToStartIndex: _startIndex))
  }
}
@usableFromInline
internal protocol _ArrayProtocol : Swift.ExpressibleByArrayLiteral, Swift.RangeReplaceableCollection where Self.Indices == Swift.Range<Swift.Int> {
  var capacity: Swift.Int { get }
  var _owner: Swift.AnyObject? { get }
  var _baseAddressIfContiguous: Swift.UnsafeMutablePointer<Self.Element>? { get }
  override mutating func reserveCapacity(_ minimumCapacity: Swift.Int)
  override mutating func insert(_ newElement: __owned Self.Element, at i: Swift.Int)
  @discardableResult
  override mutating func remove(at index: Swift.Int) -> Self.Element
  associatedtype _Buffer : Swift._ArrayBufferProtocol where Self.Element == Self._Buffer.Element
  init(_ buffer: Self._Buffer)
  var _buffer: Self._Buffer { get }
}
extension _ArrayProtocol {
  @inlinable __consuming public func filter(_ isIncluded: (Self.Element) throws -> Swift.Bool) rethrows -> [Self.Element] {
    return try _filter(isIncluded)
  }
}
extension Unicode {
  @frozen public enum ASCII {
  }
}
extension Unicode.ASCII : Swift.Unicode.Encoding {
  public typealias CodeUnit = Swift.UInt8
  public typealias EncodedScalar = Swift.CollectionOfOne<Swift.Unicode.ASCII.CodeUnit>
  @inlinable public static var encodedReplacementCharacter: Swift.Unicode.ASCII.EncodedScalar {
    get {
    return EncodedScalar(0x1a) // U+001A SUBSTITUTE; best we can do for ASCII
  }
  }
  @_alwaysEmitIntoClient public static func isASCII(_ x: Swift.Unicode.ASCII.CodeUnit) -> Swift.Bool { return UTF8.isASCII(x) }
  @inline(__always) @inlinable public static func _isScalar(_ x: Swift.Unicode.ASCII.CodeUnit) -> Swift.Bool {
    return true
  }
  @inline(__always) @inlinable public static func decode(_ source: Swift.Unicode.ASCII.EncodedScalar) -> Swift.Unicode.Scalar {
    return Unicode.Scalar(_unchecked: UInt32(
        source.first._unsafelyUnwrappedUnchecked))
  }
  @inline(__always) @inlinable public static func encode(_ source: Swift.Unicode.Scalar) -> Swift.Unicode.ASCII.EncodedScalar? {
    guard source.value < (1&<<7) else { return nil }
    return EncodedScalar(UInt8(truncatingIfNeeded: source.value))
  }
  @inline(__always) @inlinable public static func transcode<FromEncoding>(_ content: FromEncoding.EncodedScalar, from _: FromEncoding.Type) -> Swift.Unicode.ASCII.EncodedScalar? where FromEncoding : Swift._UnicodeEncoding {
    if _fastPath(FromEncoding.self == UTF16.self) {
      let c = _identityCast(content, to: UTF16.EncodedScalar.self)
      guard (c._storage & 0xFF80 == 0) else { return nil }
      return EncodedScalar(CodeUnit(c._storage & 0x7f))
    }
    else if _fastPath(FromEncoding.self == UTF8.self) {
      let c = _identityCast(content, to: UTF8.EncodedScalar.self)
      let first = c.first.unsafelyUnwrapped
      guard (first < 0x80) else { return nil }
      return EncodedScalar(CodeUnit(first))
    }
    return encode(FromEncoding.decode(content))
  }
  @frozen public struct Parser {
    @inlinable public init() { }
  }
  public typealias ForwardParser = Swift.Unicode.ASCII.Parser
  public typealias ReverseParser = Swift.Unicode.ASCII.Parser
}
extension Unicode.ASCII.Parser : Swift.Unicode.Parser {
  public typealias Encoding = Swift.Unicode.ASCII
  @inlinable public mutating func parseScalar<I>(from input: inout I) -> Swift.Unicode.ParseResult<Swift.Unicode.ASCII.Parser.Encoding.EncodedScalar> where I : Swift.IteratorProtocol, I.Element == Swift.Unicode.ASCII.Parser.Encoding.CodeUnit {
    let n = input.next()
    if _fastPath(n != nil), let x = n {
      guard _fastPath(Int8(truncatingIfNeeded: x) >= 0)
      else { return .error(length: 1) }
      return .valid(Unicode.ASCII.EncodedScalar(x))
    }
    return .emptyInput
  }
}
@_transparent public func assert(_ condition: @autoclosure () -> Swift.Bool, _ message: @autoclosure () -> Swift.String = String(), file: Swift.StaticString = #file, line: Swift.UInt = #line) {
  // Only assert in debug mode.
  if _isDebugAssertConfiguration() {
    if !_fastPath(condition()) {
      _assertionFailure("Assertion failed", message(), file: file, line: line,
        flags: _fatalErrorFlags())
    }
  }
}
@_transparent public func precondition(_ condition: @autoclosure () -> Swift.Bool, _ message: @autoclosure () -> Swift.String = String(), file: Swift.StaticString = #file, line: Swift.UInt = #line) {
  // Only check in debug and release mode. In release mode just trap.
  if _isDebugAssertConfiguration() {
    if !_fastPath(condition()) {
      _assertionFailure("Precondition failed", message(), file: file, line: line,
        flags: _fatalErrorFlags())
    }
  } else if _isReleaseAssertConfiguration() {
    let error = !condition()
    Builtin.condfail_message(error._value,
      StaticString("precondition failure").unsafeRawPointer)
  }
}
@inlinable @inline(__always) public func assertionFailure(_ message: @autoclosure () -> Swift.String = String(), file: Swift.StaticString = #file, line: Swift.UInt = #line) {
  if _isDebugAssertConfiguration() {
    _assertionFailure("Fatal error", message(), file: file, line: line,
      flags: _fatalErrorFlags())
  }
  else if _isFastAssertConfiguration() {
    _conditionallyUnreachable()
  }
}
@_transparent public func preconditionFailure(_ message: @autoclosure () -> Swift.String = String(), file: Swift.StaticString = #file, line: Swift.UInt = #line) -> Swift.Never {
  // Only check in debug and release mode.  In release mode just trap.
  if _isDebugAssertConfiguration() {
    _assertionFailure("Fatal error", message(), file: file, line: line,
      flags: _fatalErrorFlags())
  } else if _isReleaseAssertConfiguration() {
    Builtin.condfail_message(true._value,
      StaticString("precondition failure").unsafeRawPointer)
  }
  _conditionallyUnreachable()
}
@_transparent public func fatalError(_ message: @autoclosure () -> Swift.String = String(), file: Swift.StaticString = #file, line: Swift.UInt = #line) -> Swift.Never {
  _assertionFailure("Fatal error", message(), file: file, line: line,
    flags: _fatalErrorFlags())
}
@usableFromInline
@_transparent internal func _precondition(_ condition: @autoclosure () -> Swift.Bool, _ message: Swift.StaticString = StaticString(), file: Swift.StaticString = #file, line: Swift.UInt = #line) {
  // Only check in debug and release mode. In release mode just trap.
  if _isDebugAssertConfiguration() {
    if !_fastPath(condition()) {
      _assertionFailure("Fatal error", message, file: file, line: line,
        flags: _fatalErrorFlags())
    }
  } else if _isReleaseAssertConfiguration() {
    let error = !condition()
    Builtin.condfail_message(error._value, message.unsafeRawPointer)
  }
}
@usableFromInline
@_transparent internal func _preconditionFailure(_ message: Swift.StaticString = StaticString(), file: Swift.StaticString = #file, line: Swift.UInt = #line) -> Swift.Never {
  _precondition(false, message, file: file, line: line)
  _conditionallyUnreachable()
}
@_transparent public func _overflowChecked<T>(_ args: (T, Swift.Bool), file: Swift.StaticString = #file, line: Swift.UInt = #line) -> T {
  let (result, error) = args
  if _isDebugAssertConfiguration() {
    if _slowPath(error) {
      _fatalErrorMessage("Fatal error", "Overflow/underflow",
        file: file, line: line, flags: _fatalErrorFlags())
    }
  } else {
    Builtin.condfail_message(error._value,
      StaticString("_overflowChecked failure").unsafeRawPointer)
  }
  return result
}
@usableFromInline
@_transparent internal func _debugPrecondition(_ condition: @autoclosure () -> Swift.Bool, _ message: Swift.StaticString = StaticString(), file: Swift.StaticString = #file, line: Swift.UInt = #line) {
  // Only check in debug mode.
  if _slowPath(_isDebugAssertConfiguration()) {
    if !_fastPath(condition()) {
      _fatalErrorMessage("Fatal error", message, file: file, line: line,
        flags: _fatalErrorFlags())
    }
  }
}
@usableFromInline
@_transparent internal func _debugPreconditionFailure(_ message: Swift.StaticString = StaticString(), file: Swift.StaticString = #file, line: Swift.UInt = #line) -> Swift.Never {
  if _slowPath(_isDebugAssertConfiguration()) {
    _precondition(false, message, file: file, line: line)
  }
  _conditionallyUnreachable()
}
@usableFromInline
@_transparent internal func _internalInvariant(_ condition: @autoclosure () -> Swift.Bool, _ message: Swift.StaticString = StaticString(), file: Swift.StaticString = #file, line: Swift.UInt = #line) {
}
@_alwaysEmitIntoClient @_transparent internal func _internalInvariant_5_1(_ condition: @autoclosure () -> Swift.Bool, _ message: Swift.StaticString = StaticString(), file: Swift.StaticString = #file, line: Swift.UInt = #line) {
}
@usableFromInline
@_transparent internal func _internalInvariantFailure(_ message: Swift.StaticString = StaticString(), file: Swift.StaticString = #file, line: Swift.UInt = #line) -> Swift.Never {
  _internalInvariant(false, message, file: file, line: line)
  _conditionallyUnreachable()
}
@_transparent public func _isDebugAssertConfiguration() -> Swift.Bool {
  // The values for the assert_configuration call are:
  // 0: Debug
  // 1: Release
  // 2: Fast
  return Int32(Builtin.assert_configuration()) == 0
}
@usableFromInline
@_transparent internal func _isReleaseAssertConfiguration() -> Swift.Bool {
  // The values for the assert_configuration call are:
  // 0: Debug
  // 1: Release
  // 2: Fast
  return Int32(Builtin.assert_configuration()) == 1
}
@_transparent public func _isFastAssertConfiguration() -> Swift.Bool {
  // The values for the assert_configuration call are:
  // 0: Debug
  // 1: Release
  // 2: Fast
  return Int32(Builtin.assert_configuration()) == 2
}
@_transparent public func _isStdlibInternalChecksEnabled() -> Swift.Bool {
  return false
}
@usableFromInline
@_transparent internal func _fatalErrorFlags() -> Swift.UInt32 {
  // The current flags are:
  // (1 << 0): Report backtrace on fatal error
  return _isDebugAssertConfiguration() ? 1 : 0
}
@usableFromInline
@inline(never) @_semantics("programtermination_point") internal func _assertionFailure(_ prefix: Swift.StaticString, _ message: Swift.StaticString, file: Swift.StaticString, line: Swift.UInt, flags: Swift.UInt32) -> Swift.Never
@usableFromInline
@inline(never) @_semantics("programtermination_point") internal func _assertionFailure(_ prefix: Swift.StaticString, _ message: Swift.String, file: Swift.StaticString, line: Swift.UInt, flags: Swift.UInt32) -> Swift.Never
@usableFromInline
@inline(never) @_semantics("programtermination_point") internal func _assertionFailure(_ prefix: Swift.StaticString, _ message: Swift.String, flags: Swift.UInt32) -> Swift.Never
@usableFromInline
@inline(never) @_semantics("programtermination_point") internal func _fatalErrorMessage(_ prefix: Swift.StaticString, _ message: Swift.StaticString, file: Swift.StaticString, line: Swift.UInt, flags: Swift.UInt32) -> Swift.Never
@_transparent public func _unimplementedInitializer(className: Swift.StaticString, initName: Swift.StaticString = #function, file: Swift.StaticString = #file, line: Swift.UInt = #line, column: Swift.UInt = #column) -> Swift.Never {
  // This function is marked @_transparent so that it is inlined into the caller
  // (the initializer stub), and, depending on the build configuration,
  // redundant parameter values (#file etc.) are eliminated, and don't leak
  // information about the user's source.

  if _isDebugAssertConfiguration() {
    className.withUTF8Buffer {
      (className) in
      initName.withUTF8Buffer {
        (initName) in
        file.withUTF8Buffer {
          (file) in
          _swift_stdlib_reportUnimplementedInitializerInFile(
            className.baseAddress!, CInt(className.count),
            initName.baseAddress!, CInt(initName.count),
            file.baseAddress!, CInt(file.count),
            UInt32(line), UInt32(column),
            /*flags:*/ 0)
        }
      }
    }
  } else {
    className.withUTF8Buffer {
      (className) in
      initName.withUTF8Buffer {
        (initName) in
        _swift_stdlib_reportUnimplementedInitializer(
          className.baseAddress!, CInt(className.count),
          initName.baseAddress!, CInt(initName.count),
          /*flags:*/ 0)
      }
    }
  }

  Builtin.int_trap()
}
public func _undefined<T>(_ message: @autoclosure () -> Swift.String = String(), file: Swift.StaticString = #file, line: Swift.UInt = #line) -> T
@usableFromInline
@inline(never) internal func _diagnoseUnexpectedEnumCaseValue<SwitchedValue, RawValue>(type: SwitchedValue.Type, rawValue: RawValue) -> Swift.Never
@usableFromInline
@inline(never) internal func _diagnoseUnexpectedEnumCase<SwitchedValue>(type: SwitchedValue.Type) -> Swift.Never
public protocol BidirectionalCollection : Swift.Collection where Self.Indices : Swift.BidirectionalCollection, Self.SubSequence : Swift.BidirectionalCollection {
  override associatedtype Element
  override associatedtype Index
  override associatedtype SubSequence
  override associatedtype Indices
  func index(before i: Self.Index) -> Self.Index
  func formIndex(before i: inout Self.Index)
  override func index(after i: Self.Index) -> Self.Index
  override func formIndex(after i: inout Self.Index)
  @_nonoverride func index(_ i: Self.Index, offsetBy distance: Swift.Int) -> Self.Index
  @_nonoverride func index(_ i: Self.Index, offsetBy distance: Swift.Int, limitedBy limit: Self.Index) -> Self.Index?
  @_nonoverride func distance(from start: Self.Index, to end: Self.Index) -> Swift.Int
  override var indices: Self.Indices { get }
  override subscript(bounds: Swift.Range<Self.Index>) -> Self.SubSequence { get }
  @_borrowed override subscript(position: Self.Index) -> Self.Element { get }
  override var startIndex: Self.Index { get }
  override var endIndex: Self.Index { get }
}
extension BidirectionalCollection {
  @inlinable @inline(__always) public func formIndex(before i: inout Self.Index) {
    i = index(before: i)
  }
  @inlinable public func index(_ i: Self.Index, offsetBy distance: Swift.Int) -> Self.Index {
    return _index(i, offsetBy: distance)
  }
  @inlinable internal func _index(_ i: Self.Index, offsetBy distance: Swift.Int) -> Self.Index {
    if distance >= 0 {
      return _advanceForward(i, by: distance)
    }
    var i = i
    for _ in stride(from: 0, to: distance, by: -1) {
      formIndex(before: &i)
    }
    return i
  }
  @inlinable public func index(_ i: Self.Index, offsetBy distance: Swift.Int, limitedBy limit: Self.Index) -> Self.Index? {
    return _index(i, offsetBy: distance, limitedBy: limit)
  }
  @inlinable internal func _index(_ i: Self.Index, offsetBy distance: Swift.Int, limitedBy limit: Self.Index) -> Self.Index? {
    if distance >= 0 {
      return _advanceForward(i, by: distance, limitedBy: limit)
    }
    var i = i
    for _ in stride(from: 0, to: distance, by: -1) {
      if i == limit {
        return nil
      }
      formIndex(before: &i)
    }
    return i
  }
  @inlinable public func distance(from start: Self.Index, to end: Self.Index) -> Swift.Int {
    return _distance(from: start, to: end)
  }
  @inlinable internal func _distance(from start: Self.Index, to end: Self.Index) -> Swift.Int {
    var start = start
    var count = 0

    if start < end {
      while start != end {
        count += 1
        formIndex(after: &start)
      }
    }
    else if start > end {
      while start != end {
        count -= 1
        formIndex(before: &start)
      }
    }

    return count
  }
}
extension BidirectionalCollection where Self == Self.SubSequence {
  @inlinable public mutating func popLast() -> Self.Element? {
    guard !isEmpty else { return nil }
    let element = last!
    self = self[startIndex..<index(before: endIndex)]
    return element
  }
  @discardableResult
  @inlinable public mutating func removeLast() -> Self.Element {
    let element = last!
    self = self[startIndex..<index(before: endIndex)]
    return element
  }
  @inlinable public mutating func removeLast(_ k: Swift.Int) {
    if k == 0 { return }
    _precondition(k >= 0, "Number of elements to remove should be non-negative")
    guard let end = index(endIndex, offsetBy: -k, limitedBy: startIndex)
    else {
      _preconditionFailure(
        "Can't remove more items from a collection than it contains")
    }
    self = self[startIndex..<end]
  }
}
extension BidirectionalCollection {
  @inlinable __consuming public func dropLast(_ k: Swift.Int) -> Self.SubSequence {
    _precondition(
      k >= 0, "Can't drop a negative number of elements from a collection")
    let end = index(
      endIndex,
      offsetBy: -k,
      limitedBy: startIndex) ?? startIndex
    return self[startIndex..<end]
  }
  @inlinable __consuming public func suffix(_ maxLength: Swift.Int) -> Self.SubSequence {
    _precondition(
      maxLength >= 0,
      "Can't take a suffix of negative length from a collection")
    let start = index(
      endIndex,
      offsetBy: -maxLength,
      limitedBy: startIndex) ?? startIndex
    return self[start..<endIndex]
  }
}
@usableFromInline
@frozen internal struct _UnsafeBitset {
  @usableFromInline
  internal let words: Swift.UnsafeMutablePointer<Swift._UnsafeBitset.Word>
  @usableFromInline
  internal let wordCount: Swift.Int
  @inlinable @inline(__always) internal init(words: Swift.UnsafeMutablePointer<Swift._UnsafeBitset.Word>, wordCount: Swift.Int) {
    self.words = words
    self.wordCount = wordCount
  }
}
extension _UnsafeBitset {
  @inlinable @inline(__always) internal static func word(for element: Swift.Int) -> Swift.Int {
    _internalInvariant(element >= 0)
    // Note: We perform on UInts to get faster unsigned math (shifts).
    let element = UInt(bitPattern: element)
    let capacity = UInt(bitPattern: Word.capacity)
    return Int(bitPattern: element / capacity)
  }
  @inlinable @inline(__always) internal static func bit(for element: Swift.Int) -> Swift.Int {
    _internalInvariant(element >= 0)
    // Note: We perform on UInts to get faster unsigned math (masking).
    let element = UInt(bitPattern: element)
    let capacity = UInt(bitPattern: Word.capacity)
    return Int(bitPattern: element % capacity)
  }
  @inlinable @inline(__always) internal static func split(_ element: Swift.Int) -> (word: Swift.Int, bit: Swift.Int) {
    return (word(for: element), bit(for: element))
  }
  @inlinable @inline(__always) internal static func join(word: Swift.Int, bit: Swift.Int) -> Swift.Int {
    _internalInvariant(bit >= 0 && bit < Word.capacity)
    return word &* Word.capacity &+ bit
  }
}
extension _UnsafeBitset {
  @inlinable @inline(__always) internal static func wordCount(forCapacity capacity: Swift.Int) -> Swift.Int {
    return word(for: capacity &+ Word.capacity &- 1)
  }
  @inlinable internal var capacity: Swift.Int {
    @inline(__always) get {
      return wordCount &* Word.capacity
    }
  }
  @inlinable @inline(__always) internal func isValid(_ element: Swift.Int) -> Swift.Bool {
    return element >= 0 && element <= capacity
  }
  @inlinable @inline(__always) internal func uncheckedContains(_ element: Swift.Int) -> Swift.Bool {
    _internalInvariant(isValid(element))
    let (word, bit) = _UnsafeBitset.split(element)
    return words[word].uncheckedContains(bit)
  }
  @discardableResult
  @inlinable @inline(__always) internal func uncheckedInsert(_ element: Swift.Int) -> Swift.Bool {
    _internalInvariant(isValid(element))
    let (word, bit) = _UnsafeBitset.split(element)
    return words[word].uncheckedInsert(bit)
  }
  @discardableResult
  @inlinable @inline(__always) internal func uncheckedRemove(_ element: Swift.Int) -> Swift.Bool {
    _internalInvariant(isValid(element))
    let (word, bit) = _UnsafeBitset.split(element)
    return words[word].uncheckedRemove(bit)
  }
  @inlinable @inline(__always) internal func clear() {
    words.assign(repeating: .empty, count: wordCount)
  }
}
extension _UnsafeBitset : Swift.Sequence {
  @usableFromInline
  internal typealias Element = Swift.Int
  @inlinable internal var count: Swift.Int {
    get {
    var count = 0
    for w in 0 ..< wordCount {
      count += words[w].count
    }
    return count
  }
  }
  @inlinable internal var underestimatedCount: Swift.Int {
    get {
    return count
  }
  }
  @inlinable internal func makeIterator() -> Swift._UnsafeBitset.Iterator {
    return Iterator(self)
  }
  @usableFromInline
  @frozen internal struct Iterator : Swift.IteratorProtocol {
    @usableFromInline
    internal let bitset: Swift._UnsafeBitset
    @usableFromInline
    internal var index: Swift.Int
    @usableFromInline
    internal var word: Swift._UnsafeBitset.Word
    @inlinable internal init(_ bitset: Swift._UnsafeBitset) {
      self.bitset = bitset
      self.index = 0
      self.word = bitset.wordCount > 0 ? bitset.words[0] : .empty
    }
    @inlinable internal mutating func next() -> Swift.Int? {
      if let bit = word.next() {
        return _UnsafeBitset.join(word: index, bit: bit)
      }
      while (index + 1) < bitset.wordCount {
        index += 1
        word = bitset.words[index]
        if let bit = word.next() {
          return _UnsafeBitset.join(word: index, bit: bit)
        }
      }
      return nil
    }
    @usableFromInline
    internal typealias Element = Swift.Int
  }
}
extension _UnsafeBitset {
  @usableFromInline
  @frozen internal struct Word {
    @usableFromInline
    internal var value: Swift.UInt
    @inlinable internal init(_ value: Swift.UInt) {
      self.value = value
    }
  }
}
extension _UnsafeBitset.Word {
  @inlinable internal static var capacity: Swift.Int {
    @inline(__always) get {
      return UInt.bitWidth
    }
  }
  @inlinable @inline(__always) internal func uncheckedContains(_ bit: Swift.Int) -> Swift.Bool {
    _internalInvariant(bit >= 0 && bit < UInt.bitWidth)
    return value & (1 &<< bit) != 0
  }
  @discardableResult
  @inlinable @inline(__always) internal mutating func uncheckedInsert(_ bit: Swift.Int) -> Swift.Bool {
    _internalInvariant(bit >= 0 && bit < UInt.bitWidth)
    let mask: UInt = 1 &<< bit
    let inserted = value & mask == 0
    value |= mask
    return inserted
  }
  @discardableResult
  @inlinable @inline(__always) internal mutating func uncheckedRemove(_ bit: Swift.Int) -> Swift.Bool {
    _internalInvariant(bit >= 0 && bit < UInt.bitWidth)
    let mask: UInt = 1 &<< bit
    let removed = value & mask != 0
    value &= ~mask
    return removed
  }
}
extension _UnsafeBitset.Word {
  @inlinable internal var minimum: Swift.Int? {
    @inline(__always) get {
      guard value != 0 else { return nil }
      return value.trailingZeroBitCount
    }
  }
  @inlinable internal var maximum: Swift.Int? {
    @inline(__always) get {
      guard value != 0 else { return nil }
      return _UnsafeBitset.Word.capacity &- 1 &- value.leadingZeroBitCount
    }
  }
  @inlinable internal var complement: Swift._UnsafeBitset.Word {
    @inline(__always) get {
      return _UnsafeBitset.Word(~value)
    }
  }
  @inlinable @inline(__always) internal func subtracting(elementsBelow bit: Swift.Int) -> Swift._UnsafeBitset.Word {
    _internalInvariant(bit >= 0 && bit < _UnsafeBitset.Word.capacity)
    let mask = UInt.max &<< bit
    return _UnsafeBitset.Word(value & mask)
  }
  @inlinable @inline(__always) internal func intersecting(elementsBelow bit: Swift.Int) -> Swift._UnsafeBitset.Word {
    _internalInvariant(bit >= 0 && bit < _UnsafeBitset.Word.capacity)
    let mask: UInt = (1 as UInt &<< bit) &- 1
    return _UnsafeBitset.Word(value & mask)
  }
  @inlinable @inline(__always) internal func intersecting(elementsAbove bit: Swift.Int) -> Swift._UnsafeBitset.Word {
    _internalInvariant(bit >= 0 && bit < _UnsafeBitset.Word.capacity)
    let mask = (UInt.max &<< bit) &<< 1
    return _UnsafeBitset.Word(value & mask)
  }
}
extension _UnsafeBitset.Word {
  @inlinable internal static var empty: Swift._UnsafeBitset.Word {
    @inline(__always) get {
      return _UnsafeBitset.Word(0)
    }
  }
  @inlinable internal static var allBits: Swift._UnsafeBitset.Word {
    @inline(__always) get {
      return _UnsafeBitset.Word(UInt.max)
    }
  }
}
extension _UnsafeBitset.Word : Swift.Sequence, Swift.IteratorProtocol {
  @inlinable internal var count: Swift.Int {
    get {
    return value.nonzeroBitCount
  }
  }
  @inlinable internal var underestimatedCount: Swift.Int {
    get {
    return count
  }
  }
  @inlinable internal var isEmpty: Swift.Bool {
    @inline(__always) get {
      return value == 0
    }
  }
  @inlinable internal mutating func next() -> Swift.Int? {
    guard value != 0 else { return nil }
    let bit = value.trailingZeroBitCount
    value &= value &- 1       // Clear lowest nonzero bit.
    return bit
  }
  @usableFromInline
  internal typealias Element = Swift.Int
  @usableFromInline
  internal typealias Iterator = Swift._UnsafeBitset.Word
}
@frozen public struct Bool {
  @usableFromInline
  internal var _value: Builtin.Int1
  @_transparent public init() {
    let zero: Int8 = 0
    self._value = Builtin.trunc_Int8_Int1(zero._value)
  }
  @usableFromInline
  @_transparent internal init(_ v: Builtin.Int1) { self._value = v }
  @inlinable public init(_ value: Swift.Bool) {
    self = value
  }
  @inlinable public static func random<T>(using generator: inout T) -> Swift.Bool where T : Swift.RandomNumberGenerator {
    return (generator.next() >> 17) & 1 == 0
  }
  @inlinable public static func random() -> Swift.Bool {
    var g = SystemRandomNumberGenerator()
    return Bool.random(using: &g)
  }
}
extension Bool : Swift._ExpressibleByBuiltinBooleanLiteral, Swift.ExpressibleByBooleanLiteral {
  @_transparent public init(_builtinBooleanLiteral value: Builtin.Int1) {
    self._value = value
  }
  @_transparent public init(booleanLiteral value: Swift.Bool) {
    self = value
  }
  public typealias BooleanLiteralType = Swift.Bool
}
extension Bool : Swift.CustomStringConvertible {
  @inlinable public var description: Swift.String {
    get {
    return self ? "true" : "false"
  }
  }
}
extension Bool : Swift.Equatable {
  @_transparent public static func == (lhs: Swift.Bool, rhs: Swift.Bool) -> Swift.Bool {
    return Bool(Builtin.cmp_eq_Int1(lhs._value, rhs._value))
  }
}
extension Bool : Swift.Hashable {
  @inlinable public func hash(into hasher: inout Swift.Hasher) {
    hasher.combine((self ? 1 : 0) as UInt8)
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension Bool : Swift.LosslessStringConvertible {
  @inlinable public init?(_ description: Swift.String) {
    if description == "true" {
      self = true
    } else if description == "false" {
      self = false
    } else {
      return nil
    }
  }
}
extension Bool {
  @_transparent prefix public static func ! (a: Swift.Bool) -> Swift.Bool {
    return Bool(Builtin.xor_Int1(a._value, true._value))
  }
}
extension Bool {
  @_transparent @inline(__always) public static func && (lhs: Swift.Bool, rhs: @autoclosure () throws -> Swift.Bool) rethrows -> Swift.Bool {
    return lhs ? try rhs() : false
  }
  @_transparent @inline(__always) public static func || (lhs: Swift.Bool, rhs: @autoclosure () throws -> Swift.Bool) rethrows -> Swift.Bool {
    return lhs ? true : try rhs()
  }
}
extension Bool {
  @inlinable public mutating func toggle() {
    self = !self
  }
}
public protocol _ObjectiveCBridgeable {
  associatedtype _ObjectiveCType : AnyObject
  func _bridgeToObjectiveC() -> Self._ObjectiveCType
  static func _forceBridgeFromObjectiveC(_ source: Self._ObjectiveCType, result: inout Self?)
  @discardableResult
  static func _conditionallyBridgeFromObjectiveC(_ source: Self._ObjectiveCType, result: inout Self?) -> Swift.Bool
  @_effects(readonly) static func _unconditionallyBridgeFromObjectiveC(_ source: Self._ObjectiveCType?) -> Self
}
@available(macOS 10.15.4, iOS 13.4, watchOS 6.2, tvOS 13.4, *)
@_cdecl("_SwiftCreateBridgedArray")
@usableFromInline
internal func _SwiftCreateBridgedArray_DoNotCall(values: Swift.UnsafePointer<Swift.AnyObject>, numValues: Swift.Int) -> Swift.Unmanaged<Swift.AnyObject>
@available(macOS 10.15.4, iOS 13.4, watchOS 6.2, tvOS 13.4, *)
@_cdecl("_SwiftCreateBridgedMutableArray")
@usableFromInline
internal func _SwiftCreateBridgedMutableArray_DoNotCall(values: Swift.UnsafePointer<Swift.AnyObject>, numValues: Swift.Int) -> Swift.Unmanaged<Swift.AnyObject>
public struct _BridgeableMetatype : Swift._ObjectiveCBridgeable {
  public typealias _ObjectiveCType = Swift.AnyObject
  public func _bridgeToObjectiveC() -> Swift.AnyObject
  public static func _forceBridgeFromObjectiveC(_ source: Swift.AnyObject, result: inout Swift._BridgeableMetatype?)
  public static func _conditionallyBridgeFromObjectiveC(_ source: Swift.AnyObject, result: inout Swift._BridgeableMetatype?) -> Swift.Bool
  @_effects(readonly) public static func _unconditionallyBridgeFromObjectiveC(_ source: Swift.AnyObject?) -> Swift._BridgeableMetatype
}
@inlinable public func _bridgeAnythingToObjectiveC<T>(_ x: T) -> Swift.AnyObject {
  if _fastPath(_isClassOrObjCExistential(T.self)) {
    return unsafeBitCast(x, to: AnyObject.self)
  }
  return _bridgeAnythingNonVerbatimToObjectiveC(x)
}
@_silgen_name("")
public func _bridgeAnythingNonVerbatimToObjectiveC<T>(_ x: __owned T) -> Swift.AnyObject
public func _bridgeAnyObjectToAny(_ possiblyNullObject: Swift.AnyObject?) -> Any
@inlinable public func _forceBridgeFromObjectiveC<T>(_ x: Swift.AnyObject, _: T.Type) -> T {
  if _fastPath(_isClassOrObjCExistential(T.self)) {
    return x as! T
  }

  var result: T?
  _bridgeNonVerbatimFromObjectiveC(x, T.self, &result)
  return result!
}
@inlinable public func _forceBridgeFromObjectiveC_bridgeable<T>(_ x: T._ObjectiveCType, _: T.Type) -> T where T : Swift._ObjectiveCBridgeable {
  var result: T?
  T._forceBridgeFromObjectiveC(x, result: &result)
  return result!
}
@inlinable public func _conditionallyBridgeFromObjectiveC<T>(_ x: Swift.AnyObject, _: T.Type) -> T? {
  if _fastPath(_isClassOrObjCExistential(T.self)) {
    return x as? T
  }

  var result: T?
  _ = _bridgeNonVerbatimFromObjectiveCConditional(x, T.self, &result)
  return result
}
@inlinable public func _conditionallyBridgeFromObjectiveC_bridgeable<T>(_ x: T._ObjectiveCType, _: T.Type) -> T? where T : Swift._ObjectiveCBridgeable {
  var result: T?
  T._conditionallyBridgeFromObjectiveC (x, result: &result)
  return result
}
@_silgen_name("")
@usableFromInline
internal func _bridgeNonVerbatimFromObjectiveC<T>(_ x: Swift.AnyObject, _ nativeType: T.Type, _ result: inout T?)
@_silgen_name("")
public func _bridgeNonVerbatimFromObjectiveCConditional<T>(_ x: Swift.AnyObject, _ nativeType: T.Type, _ result: inout T?) -> Swift.Bool
public func _isBridgedToObjectiveC<T>(_: T.Type) -> Swift.Bool
@_silgen_name("")
public func _isBridgedNonVerbatimToObjectiveC<T>(_: T.Type) -> Swift.Bool
@inlinable public func _isBridgedVerbatimToObjectiveC<T>(_: T.Type) -> Swift.Bool {
  return _isClassOrObjCExistential(T.self)
}
@inlinable public func _getBridgedObjectiveCType<T>(_: T.Type) -> Any.Type? {
  if _fastPath(_isClassOrObjCExistential(T.self)) {
    return T.self
  }
  return _getBridgedNonVerbatimObjectiveCType(T.self)
}
@_silgen_name("")
public func _getBridgedNonVerbatimObjectiveCType<T>(_: T.Type) -> Any.Type?
@frozen public struct AutoreleasingUnsafeMutablePointer<Pointee> : Swift._Pointer {
  public let _rawValue: Builtin.RawPointer
  @_transparent public init(_ _rawValue: Builtin.RawPointer) {
    self._rawValue = _rawValue
  }
  @inlinable public var pointee: Pointee {
    @_transparent get {
      // The memory addressed by this pointer contains a non-owning reference,
      // therefore we *must not* point an `UnsafePointer<AnyObject>` to
      // it---otherwise we would allow the compiler to assume it has a +1
      // refcount, enabling some optimizations that wouldn't be valid.
      //
      // Instead, we need to load the pointee as a +0 unmanaged reference. For
      // an extra twist, `Pointee` is allowed (but not required) to be an
      // optional type, so we actually need to load it as an optional, and
      // explicitly handle the nil case.
      let unmanaged =
        UnsafePointer<Optional<Unmanaged<AnyObject>>>(_rawValue).pointee
      return _unsafeReferenceCast(
        unmanaged?.takeUnretainedValue(),
        to: Pointee.self)
    }
    @_transparent nonmutating set {
      // Autorelease the object reference.
      let object = _unsafeReferenceCast(newValue, to: Optional<AnyObject>.self)
      Builtin.retain(object)
      Builtin.autorelease(object)

      // Convert it to an unmanaged reference and trivially assign it to the
      // memory addressed by this pointer.
      let unmanaged: Optional<Unmanaged<AnyObject>>
      if let object = object {
        unmanaged = Unmanaged.passUnretained(object)
      } else {
        unmanaged = nil
      }
      UnsafeMutablePointer<Optional<Unmanaged<AnyObject>>>(_rawValue).pointee =
        unmanaged
    }
  }
  @inlinable public subscript(i: Swift.Int) -> Pointee {
    @_transparent get {
      return self.advanced(by: i).pointee
    }
  }
  @_transparent public init<U>(@_nonEphemeral _ from: Swift.UnsafeMutablePointer<U>) {		
   self._rawValue = from._rawValue		
  }
  @_transparent public init?<U>(@_nonEphemeral _ from: Swift.UnsafeMutablePointer<U>?) {
   guard let unwrapped = from else { return nil }		
   self.init(unwrapped)		
  }
  @usableFromInline
  @_transparent internal init<U>(@_nonEphemeral _ from: Swift.UnsafePointer<U>) {
    self._rawValue = from._rawValue
  }
  @usableFromInline
  @_transparent internal init?<U>(@_nonEphemeral _ from: Swift.UnsafePointer<U>?) {
    guard let unwrapped = from else { return nil }
    self.init(unwrapped)
  }
  public typealias Stride = Swift.Int
  public var hashValue: Swift.Int {
    get
  }
}
extension UnsafeMutableRawPointer {
  @_transparent public init<T>(@_nonEphemeral _ other: Swift.AutoreleasingUnsafeMutablePointer<T>) {
    _rawValue = other._rawValue
  }
  @_transparent public init?<T>(@_nonEphemeral _ other: Swift.AutoreleasingUnsafeMutablePointer<T>?) {
    guard let unwrapped = other else { return nil }
    self.init(unwrapped)
  }
}
extension UnsafeRawPointer {
  @_transparent public init<T>(@_nonEphemeral _ other: Swift.AutoreleasingUnsafeMutablePointer<T>) {
    _rawValue = other._rawValue
  }
  @_transparent public init?<T>(@_nonEphemeral _ other: Swift.AutoreleasingUnsafeMutablePointer<T>?) {
    guard let unwrapped = other else { return nil }
    self.init(unwrapped)
  }
}
@_transparent public func _getObjCTypeEncoding<T>(_ type: T.Type) -> Swift.UnsafePointer<Swift.Int8> {
  // This must be `@_transparent` because `Builtin.getObjCTypeEncoding` is
  // only supported by the compiler for concrete types that are representable
  // in ObjC.
  return UnsafePointer(Builtin.getObjCTypeEncoding(type))
}
@usableFromInline
@frozen internal struct _BridgeStorage<NativeClass> where NativeClass : AnyObject {
  @usableFromInline
  internal typealias Native = NativeClass
  @usableFromInline
  internal typealias ObjC = Swift.AnyObject
  @usableFromInline
  internal var rawValue: Builtin.BridgeObject
  @inlinable @inline(__always) internal init(native: Swift._BridgeStorage<NativeClass>.Native, isFlagged flag: Swift.Bool) {
    // Note: Some platforms provide more than one spare bit, but the minimum is
    // a single bit.

    _internalInvariant(_usesNativeSwiftReferenceCounting(NativeClass.self))

    rawValue = _makeNativeBridgeObject(
      native,
      flag ? (1 as UInt) << _objectPointerLowSpareBitShift : 0)
  }
  @inlinable @inline(__always) internal init(objC: Swift._BridgeStorage<NativeClass>.ObjC) {
    _internalInvariant(_usesNativeSwiftReferenceCounting(NativeClass.self))
    rawValue = _makeObjCBridgeObject(objC)
  }
  @inlinable @inline(__always) internal init(native: Swift._BridgeStorage<NativeClass>.Native) {
    _internalInvariant(_usesNativeSwiftReferenceCounting(NativeClass.self))
    rawValue = Builtin.reinterpretCast(native)
  }
  @inlinable @inline(__always) internal init(taggedPayload: Swift.UInt) {
    rawValue = _bridgeObject(taggingPayload: taggedPayload)
  }
  @inlinable @inline(__always) internal mutating func isUniquelyReferencedNative() -> Swift.Bool {
    return _isUnique(&rawValue)
  }
  @_alwaysEmitIntoClient @inline(__always) internal mutating func beginCOWMutationNative() -> Swift.Bool {
    return Bool(Builtin.beginCOWMutation(&rawValue))
  }
  @inlinable internal var isNative: Swift.Bool {
    @inline(__always) get {
      let result = Builtin.classifyBridgeObject(rawValue)
      return !Bool(Builtin.or_Int1(result.isObjCObject,
                                   result.isObjCTaggedPointer))
    }
  }
  @inlinable internal static var flagMask: Swift.UInt {
    @inline(__always) get {
      return (1 as UInt) << _objectPointerLowSpareBitShift
    }
  }
  @inlinable internal var isUnflaggedNative: Swift.Bool {
    @inline(__always) get {
      return (_bitPattern(rawValue) &
        (_bridgeObjectTaggedPointerBits | _objCTaggedPointerBits |
          _objectPointerIsObjCBit | _BridgeStorage.flagMask)) == 0
    }
  }
  @inlinable internal var isObjC: Swift.Bool {
    @inline(__always) get {
      return !isNative
    }
  }
  @inlinable internal var nativeInstance: Swift._BridgeStorage<NativeClass>.Native {
    @inline(__always) get {
      _internalInvariant(isNative)
      return Builtin.castReferenceFromBridgeObject(rawValue)
    }
  }
  @inlinable internal var unflaggedNativeInstance: Swift._BridgeStorage<NativeClass>.Native {
    @inline(__always) get {
      _internalInvariant(isNative)
      _internalInvariant(_nonPointerBits(rawValue) == 0)
      return Builtin.reinterpretCast(rawValue)
    }
  }
  @inlinable @inline(__always) internal mutating func isUniquelyReferencedUnflaggedNative() -> Swift.Bool {
    _internalInvariant(isNative)
    return _isUnique_native(&rawValue)
  }
  @_alwaysEmitIntoClient @inline(__always) internal mutating func beginCOWMutationUnflaggedNative() -> Swift.Bool {
    _internalInvariant(isNative)
    return Bool(Builtin.beginCOWMutation_native(&rawValue))
  }
  @_alwaysEmitIntoClient @inline(__always) internal mutating func endCOWMutation() {
    _internalInvariant(isNative)
    Builtin.endCOWMutation(&rawValue)
  }
  @inlinable internal var objCInstance: Swift._BridgeStorage<NativeClass>.ObjC {
    @inline(__always) get {
      _internalInvariant(isObjC)
      return Builtin.castReferenceFromBridgeObject(rawValue)
    }
  }
}
@inlinable @inline(__always) internal func _roundUpImpl(_ offset: Swift.UInt, toAlignment alignment: Swift.Int) -> Swift.UInt {
  _internalInvariant(alignment > 0)
  _internalInvariant(_isPowerOf2(alignment))
  // Note, given that offset is >= 0, and alignment > 0, we don't
  // need to underflow check the -1, as it can never underflow.
  let x = offset + UInt(bitPattern: alignment) &- 1
  // Note, as alignment is a power of 2, we'll use masking to efficiently
  // get the aligned value
  return x & ~(UInt(bitPattern: alignment) &- 1)
}
@inlinable internal func _roundUp(_ offset: Swift.UInt, toAlignment alignment: Swift.Int) -> Swift.UInt {
  return _roundUpImpl(offset, toAlignment: alignment)
}
@inlinable internal func _roundUp(_ offset: Swift.Int, toAlignment alignment: Swift.Int) -> Swift.Int {
  _internalInvariant(offset >= 0)
  return Int(_roundUpImpl(UInt(bitPattern: offset), toAlignment: alignment))
}
@_transparent public func _canBeClass<T>(_: T.Type) -> Swift.Int8 {
  return Int8(Builtin.canBeClass(T.self))
}
@inlinable @_transparent public func unsafeBitCast<T, U>(_ x: T, to type: U.Type) -> U {
  _precondition(MemoryLayout<T>.size == MemoryLayout<U>.size,
    "Can't unsafeBitCast between types of different sizes")
  return Builtin.reinterpretCast(x)
}
@_transparent public func _identityCast<T, U>(_ x: T, to expectedType: U.Type) -> U {
  _precondition(T.self == expectedType, "_identityCast to wrong type")
  return Builtin.reinterpretCast(x)
}
@usableFromInline
@_transparent internal func _reinterpretCastToAnyObject<T>(_ x: T) -> Swift.AnyObject {
  return unsafeBitCast(x, to: AnyObject.self)
}
@usableFromInline
@_transparent internal func == (lhs: Builtin.NativeObject, rhs: Builtin.NativeObject) -> Swift.Bool {
  return unsafeBitCast(lhs, to: Int.self) == unsafeBitCast(rhs, to: Int.self)
}
@usableFromInline
@_transparent internal func != (lhs: Builtin.NativeObject, rhs: Builtin.NativeObject) -> Swift.Bool {
  return !(lhs == rhs)
}
@usableFromInline
@_transparent internal func == (lhs: Builtin.RawPointer, rhs: Builtin.RawPointer) -> Swift.Bool {
  return unsafeBitCast(lhs, to: Int.self) == unsafeBitCast(rhs, to: Int.self)
}
@usableFromInline
@_transparent internal func != (lhs: Builtin.RawPointer, rhs: Builtin.RawPointer) -> Swift.Bool {
  return !(lhs == rhs)
}
@inlinable public func == (t0: Any.Type?, t1: Any.Type?) -> Swift.Bool {
  switch (t0, t1) {
  case (.none, .none): return true
  case let (.some(ty0), .some(ty1)):
    return Bool(Builtin.is_same_metatype(ty0, ty1))
  default: return false
  }
}
@inlinable public func != (t0: Any.Type?, t1: Any.Type?) -> Swift.Bool {
  return !(t0 == t1)
}
@usableFromInline
@_transparent internal func _unreachable(_ condition: Swift.Bool = true) {
  if condition {
    // FIXME: use a parameterized version of Builtin.unreachable when
    // <rdar://problem/16806232> is closed.
    Builtin.unreachable()
  }
}
@usableFromInline
@_transparent internal func _conditionallyUnreachable() -> Swift.Never {
  Builtin.conditionallyUnreachable()
}
@usableFromInline
@_silgen_name("_swift_isClassOrObjCExistentialType")
internal func _swift_isClassOrObjCExistentialType<T>(_ x: T.Type) -> Swift.Bool
@inlinable @inline(__always) internal func _isClassOrObjCExistential<T>(_ x: T.Type) -> Swift.Bool {

  switch _canBeClass(x) {
  // Is not a class.
  case 0:
    return false
  // Is a class.
  case 1:
    return true
  // Maybe a class.
  default:
    return _swift_isClassOrObjCExistentialType(x)
  }
}
@_transparent public func _unsafeReferenceCast<T, U>(_ x: T, to: U.Type) -> U {
  return Builtin.castReference(x)
}
@_transparent public func unsafeDowncast<T>(_ x: Swift.AnyObject, to type: T.Type) -> T where T : AnyObject {
  _debugPrecondition(x is T, "invalid unsafeDowncast")
  return Builtin.castReference(x)
}
@_transparent public func _unsafeUncheckedDowncast<T>(_ x: Swift.AnyObject, to type: T.Type) -> T where T : AnyObject {
  _internalInvariant(x is T, "invalid unsafeDowncast")
  return Builtin.castReference(x)
}
@inlinable @inline(__always) public func _getUnsafePointerToStoredProperties(_ x: Swift.AnyObject) -> Swift.UnsafeMutableRawPointer {
  let storedPropertyOffset = _roundUp(
    MemoryLayout<SwiftShims.HeapObject>.size,
    toAlignment: MemoryLayout<Optional<AnyObject>>.alignment)
  return UnsafeMutableRawPointer(Builtin.bridgeToRawPointer(x)) +
    storedPropertyOffset
}
@inlinable @inline(__always) internal func _minAllocationAlignment() -> Swift.Int {
  return _swift_MinAllocationAlignment
}
@_transparent @_semantics("fastpath") public func _fastPath(_ x: Swift.Bool) -> Swift.Bool {
  return Bool(Builtin.int_expect_Int1(x._value, true._value))
}
@_transparent @_semantics("slowpath") public func _slowPath(_ x: Swift.Bool) -> Swift.Bool {
  return Bool(Builtin.int_expect_Int1(x._value, false._value))
}
@_transparent public func _onFastPath() {
  Builtin.onFastPath()
}
@usableFromInline
@_transparent internal func _uncheckedUnsafeAssume(_ condition: Swift.Bool) {
  _ = Builtin.assume_Int1(condition._value)
}
@usableFromInline
@_silgen_name("_swift_objcClassUsesNativeSwiftReferenceCounting")
internal func _usesNativeSwiftReferenceCounting(_ theClass: Swift.AnyClass) -> Swift.Bool
@usableFromInline
@_silgen_name("_swift_getSwiftClassInstanceExtents")
internal func getSwiftClassInstanceExtents(_ theClass: Swift.AnyClass) -> (negative: Swift.UInt, positive: Swift.UInt)
@usableFromInline
@_silgen_name("_swift_getObjCClassInstanceExtents")
internal func getObjCClassInstanceExtents(_ theClass: Swift.AnyClass) -> (negative: Swift.UInt, positive: Swift.UInt)
@inlinable @inline(__always) internal func _class_getInstancePositiveExtentSize(_ theClass: Swift.AnyClass) -> Swift.Int {
  return Int(getObjCClassInstanceExtents(theClass).positive)
}
@inlinable internal func _isValidAddress(_ address: Swift.UInt) -> Swift.Bool {
  // TODO: define (and use) ABI max valid pointer value
  return address >= _swift_abi_LeastValidPointerValue
}
@inlinable internal var _bridgeObjectTaggedPointerBits: Swift.UInt {
  @inline(__always) get { return UInt(_swift_BridgeObject_TaggedPointerBits) }
}
@inlinable internal var _objCTaggedPointerBits: Swift.UInt {
  @inline(__always) get { return UInt(_swift_abi_ObjCReservedBitsMask) }
}
@inlinable internal var _objectPointerSpareBits: Swift.UInt {
  @inline(__always) get {
      return UInt(_swift_abi_SwiftSpareBitsMask) & ~_bridgeObjectTaggedPointerBits
    }
}
@inlinable internal var _objectPointerLowSpareBitShift: Swift.UInt {
  @inline(__always) get {
      _internalInvariant(_swift_abi_ObjCReservedLowBits < 2,
        "num bits now differs from num-shift-amount, new platform?")
      return UInt(_swift_abi_ObjCReservedLowBits)
    }
}
@inlinable internal var _objectPointerIsObjCBit: Swift.UInt {
  @inline(__always) get { return 0x4000_0000_0000_0000 }
}
@inlinable @inline(__always) internal func _bitPattern(_ x: Builtin.BridgeObject) -> Swift.UInt {
  return UInt(Builtin.castBitPatternFromBridgeObject(x))
}
@inlinable @inline(__always) internal func _nonPointerBits(_ x: Builtin.BridgeObject) -> Swift.UInt {
  return _bitPattern(x) & _objectPointerSpareBits
}
@inlinable @inline(__always) internal func _isObjCTaggedPointer(_ x: Swift.AnyObject) -> Swift.Bool {
  return (Builtin.reinterpretCast(x) & _objCTaggedPointerBits) != 0
}
@inlinable @inline(__always) internal func _isObjCTaggedPointer(_ x: Swift.UInt) -> Swift.Bool {
  return (x & _objCTaggedPointerBits) != 0
}
@inlinable @inline(__always) public func _isTaggedObject(_ x: Builtin.BridgeObject) -> Swift.Bool {
  return _bitPattern(x) & _bridgeObjectTaggedPointerBits != 0
}
@inlinable @inline(__always) public func _isNativePointer(_ x: Builtin.BridgeObject) -> Swift.Bool {
  return (
    _bitPattern(x) & (_bridgeObjectTaggedPointerBits | _objectPointerIsObjCBit)
  ) == 0
}
@inlinable @inline(__always) public func _isNonTaggedObjCPointer(_ x: Builtin.BridgeObject) -> Swift.Bool {
  return !_isTaggedObject(x) && !_isNativePointer(x)
}
@inlinable @inline(__always) internal func _getNonTagBits(_ x: Builtin.BridgeObject) -> Swift.UInt {
  // Zero out the tag bits, and leave them all at the top.
  _internalInvariant(_isTaggedObject(x), "not tagged!")
  return (_bitPattern(x) & ~_bridgeObjectTaggedPointerBits)
    >> _objectPointerLowSpareBitShift
}
@inline(__always) @inlinable public func _bridgeObject(fromNative x: Swift.AnyObject) -> Builtin.BridgeObject {
  _internalInvariant(!_isObjCTaggedPointer(x))
  let object = Builtin.castToBridgeObject(x, 0._builtinWordValue)
  _internalInvariant(_isNativePointer(object))
  return object
}
@inline(__always) @inlinable public func _bridgeObject(fromNonTaggedObjC x: Swift.AnyObject) -> Builtin.BridgeObject {
  _internalInvariant(!_isObjCTaggedPointer(x))
  let object = _makeObjCBridgeObject(x)
  _internalInvariant(_isNonTaggedObjCPointer(object))
  return object
}
@inline(__always) @inlinable public func _bridgeObject(fromTagged x: Swift.UInt) -> Builtin.BridgeObject {
  _internalInvariant(x & _bridgeObjectTaggedPointerBits != 0)
  let object: Builtin.BridgeObject = Builtin.valueToBridgeObject(x._value)
  _internalInvariant(_isTaggedObject(object))
  return object
}
@inline(__always) @inlinable public func _bridgeObject(taggingPayload x: Swift.UInt) -> Builtin.BridgeObject {
  let shifted = x &<< _objectPointerLowSpareBitShift
  _internalInvariant(x == (shifted &>> _objectPointerLowSpareBitShift),
    "out-of-range: limited bit range requires some zero top bits")
  _internalInvariant(shifted & _bridgeObjectTaggedPointerBits == 0,
    "out-of-range: post-shift use of tag bits")
  return _bridgeObject(fromTagged: shifted | _bridgeObjectTaggedPointerBits)
}
@inline(__always) @inlinable public func _bridgeObject(toNative x: Builtin.BridgeObject) -> Swift.AnyObject {
  _internalInvariant(_isNativePointer(x))
  return Builtin.castReferenceFromBridgeObject(x)
}
@inline(__always) @inlinable public func _bridgeObject(toNonTaggedObjC x: Builtin.BridgeObject) -> Swift.AnyObject {
  _internalInvariant(_isNonTaggedObjCPointer(x))
  return Builtin.castReferenceFromBridgeObject(x)
}
@inline(__always) @inlinable public func _bridgeObject(toTagged x: Builtin.BridgeObject) -> Swift.UInt {
  _internalInvariant(_isTaggedObject(x))
  let bits = _bitPattern(x)
  _internalInvariant(bits & _bridgeObjectTaggedPointerBits != 0)
  return bits
}
@inline(__always) @inlinable public func _bridgeObject(toTagPayload x: Builtin.BridgeObject) -> Swift.UInt {
  return _getNonTagBits(x)
}
@inline(__always) @inlinable public func _bridgeObject(fromNativeObject x: Builtin.NativeObject) -> Builtin.BridgeObject {
  return _bridgeObject(fromNative: _nativeObject(toNative: x))
}
@inlinable @inline(__always) public func _nativeObject(fromNative x: Swift.AnyObject) -> Builtin.NativeObject {
  _internalInvariant(!_isObjCTaggedPointer(x))
  let native = Builtin.unsafeCastToNativeObject(x)
  // _internalInvariant(native == Builtin.castToNativeObject(x))
  return native
}
@inlinable @inline(__always) public func _nativeObject(fromBridge x: Builtin.BridgeObject) -> Builtin.NativeObject {
  return _nativeObject(fromNative: _bridgeObject(toNative: x))
}
@inlinable @inline(__always) public func _nativeObject(toNative x: Builtin.NativeObject) -> Swift.AnyObject {
  return Builtin.castFromNativeObject(x)
}
extension ManagedBufferPointer {
  @inline(__always) @inlinable public init(_nativeObject buffer: Builtin.NativeObject) {
    self._nativeBuffer = buffer
  }
}
@inlinable @inline(__always) internal func _makeNativeBridgeObject(_ nativeObject: Swift.AnyObject, _ bits: Swift.UInt) -> Builtin.BridgeObject {
  _internalInvariant(
    (bits & _objectPointerIsObjCBit) == 0,
    "BridgeObject is treated as non-native when ObjC bit is set"
  )
  return _makeBridgeObject(nativeObject, bits)
}
@inlinable @inline(__always) public func _makeObjCBridgeObject(_ objCObject: Swift.AnyObject) -> Builtin.BridgeObject {
  return _makeBridgeObject(
    objCObject,
    _isObjCTaggedPointer(objCObject) ? 0 : _objectPointerIsObjCBit)
}
@inlinable @inline(__always) internal func _makeBridgeObject(_ object: Swift.AnyObject, _ bits: Swift.UInt) -> Builtin.BridgeObject {
  _internalInvariant(!_isObjCTaggedPointer(object) || bits == 0,
    "Tagged pointers cannot be combined with bits")

  _internalInvariant(
    _isObjCTaggedPointer(object)
    || _usesNativeSwiftReferenceCounting(type(of: object))
    || bits == _objectPointerIsObjCBit,
    "All spare bits must be set in non-native, non-tagged bridge objects"
  )

  _internalInvariant(
    bits & _objectPointerSpareBits == bits,
    "Can't store non-spare bits into Builtin.BridgeObject")

  return Builtin.castToBridgeObject(
    object, bits._builtinWordValue
  )
}
public func _getSuperclass(_ t: Swift.AnyClass) -> Swift.AnyClass?
@inlinable @inline(__always) public func _getSuperclass(_ t: Any.Type) -> Swift.AnyClass? {
  return (t as? AnyClass).flatMap { _getSuperclass($0) }
}
@usableFromInline
@_transparent internal func _isUnique<T>(_ object: inout T) -> Swift.Bool {
  return Bool(Builtin.isUnique(&object))
}
@_transparent public func _isUnique_native<T>(_ object: inout T) -> Swift.Bool {
  // This could be a bridge object, single payload enum, or plain old
  // reference. Any case it's non pointer bits must be zero, so
  // force cast it to BridgeObject and check the spare bits.
  _internalInvariant(
    (_bitPattern(Builtin.reinterpretCast(object)) & _objectPointerSpareBits)
    == 0)
  _internalInvariant(_usesNativeSwiftReferenceCounting(
      type(of: Builtin.reinterpretCast(object) as AnyObject)))
  return Bool(Builtin.isUnique_native(&object))
}
@_alwaysEmitIntoClient @_transparent public func _COWBufferForReading<T>(_ object: T) -> T where T : AnyObject {
  return Builtin.COWBufferForReading(object)
}
@_transparent public func _isPOD<T>(_ type: T.Type) -> Swift.Bool {
  return Bool(Builtin.ispod(type))
}
@_alwaysEmitIntoClient @_transparent public func _isConcrete<T>(_ type: T.Type) -> Swift.Bool {
  return Bool(Builtin.isConcrete(type))
}
@_transparent public func _isBitwiseTakable<T>(_ type: T.Type) -> Swift.Bool {
  return Bool(Builtin.isbitwisetakable(type))
}
@_transparent public func _isOptional<T>(_ type: T.Type) -> Swift.Bool {
  return Bool(Builtin.isOptional(type))
}
@inlinable internal func _unsafeDowncastToAnyObject(fromAny any: Any) -> Swift.AnyObject {
  _internalInvariant(type(of: any) is AnyObject.Type
               || type(of: any) is AnyObject.Protocol,
               "Any expected to contain object reference")
  // Ideally we would do something like this:
  //
  // func open<T>(object: T) -> AnyObject {
  //   return unsafeBitCast(object, to: AnyObject.self)
  // }
  // return _openExistential(any, do: open)
  //
  // Unfortunately, class constrained protocol existentials conform to AnyObject
  // but are not word-sized.  As a result, we cannot currently perform the
  // `unsafeBitCast` on them just yet.  When they are word-sized, it would be
  // possible to efficiently grab the object reference out of the inline
  // storage.
  return any as AnyObject
}
@inlinable @inline(__always) public func _trueAfterDiagnostics() -> Builtin.Int1 {
  return true._value
}
@_transparent @_semantics("typechecker.type(of:)") public func type<T, Metatype>(of value: T) -> Metatype {
  // This implementation is never used, since calls to `Swift.type(of:)` are
  // resolved as a special case by the type checker.
  Builtin.staticReport(_trueAfterDiagnostics(), true._value,
    ("internal consistency error: 'type(of:)' operation failed to resolve"
     as StaticString).utf8Start._rawValue)
  Builtin.unreachable()
}
@_transparent @_semantics("typechecker.withoutActuallyEscaping(_:do:)") public func withoutActuallyEscaping<ClosureType, ResultType>(_ closure: ClosureType, do body: (ClosureType) throws -> ResultType) rethrows -> ResultType {
  // This implementation is never used, since calls to
  // `Swift.withoutActuallyEscaping(_:do:)` are resolved as a special case by
  // the type checker.
  Builtin.staticReport(_trueAfterDiagnostics(), true._value,
    ("internal consistency error: 'withoutActuallyEscaping(_:do:)' operation failed to resolve"
     as StaticString).utf8Start._rawValue)
  Builtin.unreachable()
}
@_transparent @_semantics("typechecker._openExistential(_:do:)") public func _openExistential<ExistentialType, ContainedType, ResultType>(_ existential: ExistentialType, do body: (ContainedType) throws -> ResultType) rethrows -> ResultType {
  // This implementation is never used, since calls to
  // `Swift._openExistential(_:do:)` are resolved as a special case by
  // the type checker.
  Builtin.staticReport(_trueAfterDiagnostics(), true._value,
    ("internal consistency error: '_openExistential(_:do:)' operation failed to resolve"
     as StaticString).utf8Start._rawValue)
  Builtin.unreachable()
}
@_transparent @_alwaysEmitIntoClient public func _getGlobalStringTablePointer(_ constant: Swift.String) -> Swift.UnsafePointer<Swift.CChar> {
  return UnsafePointer<CChar>(Builtin.globalStringTablePointer(constant));
}
@_transparent public func _cos(_ x: Swift.Float) -> Swift.Float {
  return Float(Builtin.int_cos_FPIEEE32(x._value))
}
@_transparent public func _sin(_ x: Swift.Float) -> Swift.Float {
  return Float(Builtin.int_sin_FPIEEE32(x._value))
}
@_transparent public func _exp(_ x: Swift.Float) -> Swift.Float {
  return Float(Builtin.int_exp_FPIEEE32(x._value))
}
@_transparent public func _exp2(_ x: Swift.Float) -> Swift.Float {
  return Float(Builtin.int_exp2_FPIEEE32(x._value))
}
@_transparent public func _log(_ x: Swift.Float) -> Swift.Float {
  return Float(Builtin.int_log_FPIEEE32(x._value))
}
@_transparent public func _log10(_ x: Swift.Float) -> Swift.Float {
  return Float(Builtin.int_log10_FPIEEE32(x._value))
}
@_transparent public func _log2(_ x: Swift.Float) -> Swift.Float {
  return Float(Builtin.int_log2_FPIEEE32(x._value))
}
@_transparent public func _nearbyint(_ x: Swift.Float) -> Swift.Float {
  return Float(Builtin.int_nearbyint_FPIEEE32(x._value))
}
@_transparent public func _rint(_ x: Swift.Float) -> Swift.Float {
  return Float(Builtin.int_rint_FPIEEE32(x._value))
}
@_transparent public func _cos(_ x: Swift.Double) -> Swift.Double {
  return Double(Builtin.int_cos_FPIEEE64(x._value))
}
@_transparent public func _sin(_ x: Swift.Double) -> Swift.Double {
  return Double(Builtin.int_sin_FPIEEE64(x._value))
}
@_transparent public func _exp(_ x: Swift.Double) -> Swift.Double {
  return Double(Builtin.int_exp_FPIEEE64(x._value))
}
@_transparent public func _exp2(_ x: Swift.Double) -> Swift.Double {
  return Double(Builtin.int_exp2_FPIEEE64(x._value))
}
@_transparent public func _log(_ x: Swift.Double) -> Swift.Double {
  return Double(Builtin.int_log_FPIEEE64(x._value))
}
@_transparent public func _log10(_ x: Swift.Double) -> Swift.Double {
  return Double(Builtin.int_log10_FPIEEE64(x._value))
}
@_transparent public func _log2(_ x: Swift.Double) -> Swift.Double {
  return Double(Builtin.int_log2_FPIEEE64(x._value))
}
@_transparent public func _nearbyint(_ x: Swift.Double) -> Swift.Double {
  return Double(Builtin.int_nearbyint_FPIEEE64(x._value))
}
@_transparent public func _rint(_ x: Swift.Double) -> Swift.Double {
  return Double(Builtin.int_rint_FPIEEE64(x._value))
}
@_transparent public func _cos(_ x: Swift.Float80) -> Swift.Float80 {
  return Float80(Builtin.int_cos_FPIEEE80(x._value))
}
@_transparent public func _sin(_ x: Swift.Float80) -> Swift.Float80 {
  return Float80(Builtin.int_sin_FPIEEE80(x._value))
}
@_transparent public func _exp(_ x: Swift.Float80) -> Swift.Float80 {
  return Float80(Builtin.int_exp_FPIEEE80(x._value))
}
@_transparent public func _exp2(_ x: Swift.Float80) -> Swift.Float80 {
  return Float80(Builtin.int_exp2_FPIEEE80(x._value))
}
@_transparent public func _log(_ x: Swift.Float80) -> Swift.Float80 {
  return Float80(Builtin.int_log_FPIEEE80(x._value))
}
@_transparent public func _log10(_ x: Swift.Float80) -> Swift.Float80 {
  return Float80(Builtin.int_log10_FPIEEE80(x._value))
}
@_transparent public func _log2(_ x: Swift.Float80) -> Swift.Float80 {
  return Float80(Builtin.int_log2_FPIEEE80(x._value))
}
@_transparent public func _nearbyint(_ x: Swift.Float80) -> Swift.Float80 {
  return Float80(Builtin.int_nearbyint_FPIEEE80(x._value))
}
@_transparent public func _rint(_ x: Swift.Float80) -> Swift.Float80 {
  return Float80(Builtin.int_rint_FPIEEE80(x._value))
}
@frozen public struct Character {
  @usableFromInline
  internal var _str: Swift.String
  @inlinable @inline(__always) internal init(unchecked str: Swift.String) {
    self._str = str
    _invariantCheck()
  }
}
extension Character {
  @inlinable @inline(__always) internal func _invariantCheck() {}
}
extension Character {
  public typealias UTF8View = Swift.String.UTF8View
  @inlinable public var utf8: Swift.Character.UTF8View {
    get { return _str.utf8 }
  }
  public typealias UTF16View = Swift.String.UTF16View
  @inlinable public var utf16: Swift.Character.UTF16View {
    get { return _str.utf16 }
  }
  public typealias UnicodeScalarView = Swift.String.UnicodeScalarView
  @inlinable public var unicodeScalars: Swift.Character.UnicodeScalarView {
    get { return _str.unicodeScalars }
  }
}
extension Character : Swift._ExpressibleByBuiltinExtendedGraphemeClusterLiteral, Swift.ExpressibleByExtendedGraphemeClusterLiteral {
  @inlinable @inline(__always) public init(_ content: Swift.Unicode.Scalar) {
    self.init(unchecked: String(content))
  }
  @inlinable @inline(__always) @_effects(readonly) public init(_builtinUnicodeScalarLiteral value: Builtin.Int32) {
    self.init(Unicode.Scalar(_builtinUnicodeScalarLiteral: value))
  }
  @inlinable @inline(__always) @_effects(readonly) public init(_builtinExtendedGraphemeClusterLiteral start: Builtin.RawPointer, utf8CodeUnitCount: Builtin.Word, isASCII: Builtin.Int1) {
    self.init(unchecked: String(
      _builtinExtendedGraphemeClusterLiteral: start,
      utf8CodeUnitCount: utf8CodeUnitCount,
      isASCII: isASCII))
  }
  @inlinable @inline(__always) public init(extendedGraphemeClusterLiteral value: Swift.Character) {
    self.init(unchecked: value._str)
  }
  @inlinable @inline(__always) public init(_ s: Swift.String) {
    _precondition(!s.isEmpty,
      "Can't form a Character from an empty String")
    _debugPrecondition(s.index(after: s.startIndex) == s.endIndex,
      "Can't form a Character from a String containing more than one extended grapheme cluster")

    if _fastPath(s._guts._object.isPreferredRepresentation) {
      self.init(unchecked: s)
      return
    }
    self.init(unchecked: String._copying(s))
  }
  public typealias ExtendedGraphemeClusterLiteralType = Swift.Character
  public typealias UnicodeScalarLiteralType = Swift.Character
}
extension Character : Swift.CustomStringConvertible {
  @inlinable public var description: Swift.String {
    get {
   return _str
 }
  }
}
extension Character : Swift.LosslessStringConvertible {
}
extension Character : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
extension String {
  @inlinable @inline(__always) public init(_ c: Swift.Character) {
    self.init(c._str._guts)
  }
}
extension Character : Swift.Equatable {
  @inlinable @inline(__always) @_effects(readonly) public static func == (lhs: Swift.Character, rhs: Swift.Character) -> Swift.Bool {
    return lhs._str == rhs._str
  }
}
extension Character : Swift.Comparable {
  @inlinable @inline(__always) @_effects(readonly) public static func < (lhs: Swift.Character, rhs: Swift.Character) -> Swift.Bool {
    return lhs._str < rhs._str
  }
}
extension Character : Swift.Hashable {
  @_effects(releasenone) public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension Character {
  @usableFromInline
  internal var _isSmall: Swift.Bool {
    get
  }
}
@usableFromInline
@frozen internal struct _CocoaArrayWrapper : Swift.RandomAccessCollection {
  @usableFromInline
  internal typealias Indices = Swift.Range<Swift.Int>
  @usableFromInline
  internal var buffer: Swift.AnyObject
  @usableFromInline
  @_transparent internal init(_ buffer: Swift.AnyObject) {
    self.buffer = buffer
  }
  @inlinable internal var startIndex: Swift.Int {
    get {
    return 0
  }
  }
  @usableFromInline
  internal var endIndex: Swift.Int {
    get
  }
  @usableFromInline
  internal subscript(i: Swift.Int) -> Swift.AnyObject {
    get
  }
  @usableFromInline
  internal subscript(bounds: Swift.Range<Swift.Int>) -> Swift._SliceBuffer<Swift.AnyObject> {
    get
  }
  @usableFromInline
  __consuming internal func _copyContents(subRange bounds: Swift.Range<Swift.Int>, initializing target: Swift.UnsafeMutablePointer<Swift.AnyObject>) -> Swift.UnsafeMutablePointer<Swift.AnyObject>
  @usableFromInline
  internal typealias Element = Swift.AnyObject
  @usableFromInline
  internal typealias Index = Swift.Int
  @usableFromInline
  internal typealias Iterator = Swift.IndexingIterator<Swift._CocoaArrayWrapper>
  @usableFromInline
  internal typealias SubSequence = Swift._SliceBuffer<Swift.AnyObject>
}
public protocol Encodable {
  func encode(to encoder: Swift.Encoder) throws
}
public protocol Decodable {
  init(from decoder: Swift.Decoder) throws
}
public typealias Codable = Swift.Decodable & Swift.Encodable
public protocol CodingKey : Swift.CustomDebugStringConvertible, Swift.CustomStringConvertible {
  var stringValue: Swift.String { get }
  init?(stringValue: Swift.String)
  var intValue: Swift.Int? { get }
  init?(intValue: Swift.Int)
}
extension CodingKey {
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
}
public protocol Encoder {
  var codingPath: [Swift.CodingKey] { get }
  var userInfo: [Swift.CodingUserInfoKey : Any] { get }
  func container<Key>(keyedBy type: Key.Type) -> Swift.KeyedEncodingContainer<Key> where Key : Swift.CodingKey
  func unkeyedContainer() -> Swift.UnkeyedEncodingContainer
  func singleValueContainer() -> Swift.SingleValueEncodingContainer
}
public protocol Decoder {
  var codingPath: [Swift.CodingKey] { get }
  var userInfo: [Swift.CodingUserInfoKey : Any] { get }
  func container<Key>(keyedBy type: Key.Type) throws -> Swift.KeyedDecodingContainer<Key> where Key : Swift.CodingKey
  func unkeyedContainer() throws -> Swift.UnkeyedDecodingContainer
  func singleValueContainer() throws -> Swift.SingleValueDecodingContainer
}
public protocol KeyedEncodingContainerProtocol {
  associatedtype Key : Swift.CodingKey
  var codingPath: [Swift.CodingKey] { get }
  mutating func encodeNil(forKey key: Self.Key) throws
  mutating func encode(_ value: Swift.Bool, forKey key: Self.Key) throws
  mutating func encode(_ value: Swift.String, forKey key: Self.Key) throws
  mutating func encode(_ value: Swift.Double, forKey key: Self.Key) throws
  mutating func encode(_ value: Swift.Float, forKey key: Self.Key) throws
  mutating func encode(_ value: Swift.Int, forKey key: Self.Key) throws
  mutating func encode(_ value: Swift.Int8, forKey key: Self.Key) throws
  mutating func encode(_ value: Swift.Int16, forKey key: Self.Key) throws
  mutating func encode(_ value: Swift.Int32, forKey key: Self.Key) throws
  mutating func encode(_ value: Swift.Int64, forKey key: Self.Key) throws
  mutating func encode(_ value: Swift.UInt, forKey key: Self.Key) throws
  mutating func encode(_ value: Swift.UInt8, forKey key: Self.Key) throws
  mutating func encode(_ value: Swift.UInt16, forKey key: Self.Key) throws
  mutating func encode(_ value: Swift.UInt32, forKey key: Self.Key) throws
  mutating func encode(_ value: Swift.UInt64, forKey key: Self.Key) throws
  mutating func encode<T>(_ value: T, forKey key: Self.Key) throws where T : Swift.Encodable
  mutating func encodeConditional<T>(_ object: T, forKey key: Self.Key) throws where T : AnyObject, T : Swift.Encodable
  mutating func encodeIfPresent(_ value: Swift.Bool?, forKey key: Self.Key) throws
  mutating func encodeIfPresent(_ value: Swift.String?, forKey key: Self.Key) throws
  mutating func encodeIfPresent(_ value: Swift.Double?, forKey key: Self.Key) throws
  mutating func encodeIfPresent(_ value: Swift.Float?, forKey key: Self.Key) throws
  mutating func encodeIfPresent(_ value: Swift.Int?, forKey key: Self.Key) throws
  mutating func encodeIfPresent(_ value: Swift.Int8?, forKey key: Self.Key) throws
  mutating func encodeIfPresent(_ value: Swift.Int16?, forKey key: Self.Key) throws
  mutating func encodeIfPresent(_ value: Swift.Int32?, forKey key: Self.Key) throws
  mutating func encodeIfPresent(_ value: Swift.Int64?, forKey key: Self.Key) throws
  mutating func encodeIfPresent(_ value: Swift.UInt?, forKey key: Self.Key) throws
  mutating func encodeIfPresent(_ value: Swift.UInt8?, forKey key: Self.Key) throws
  mutating func encodeIfPresent(_ value: Swift.UInt16?, forKey key: Self.Key) throws
  mutating func encodeIfPresent(_ value: Swift.UInt32?, forKey key: Self.Key) throws
  mutating func encodeIfPresent(_ value: Swift.UInt64?, forKey key: Self.Key) throws
  mutating func encodeIfPresent<T>(_ value: T?, forKey key: Self.Key) throws where T : Swift.Encodable
  mutating func nestedContainer<NestedKey>(keyedBy keyType: NestedKey.Type, forKey key: Self.Key) -> Swift.KeyedEncodingContainer<NestedKey> where NestedKey : Swift.CodingKey
  mutating func nestedUnkeyedContainer(forKey key: Self.Key) -> Swift.UnkeyedEncodingContainer
  mutating func superEncoder() -> Swift.Encoder
  mutating func superEncoder(forKey key: Self.Key) -> Swift.Encoder
}
public struct KeyedEncodingContainer<K> : Swift.KeyedEncodingContainerProtocol where K : Swift.CodingKey {
  public typealias Key = K
  public init<Container>(_ container: Container) where K == Container.Key, Container : Swift.KeyedEncodingContainerProtocol
  public var codingPath: [Swift.CodingKey] {
    get
  }
  public mutating func encodeNil(forKey key: Swift.KeyedEncodingContainer<K>.Key) throws
  public mutating func encode(_ value: Swift.Bool, forKey key: Swift.KeyedEncodingContainer<K>.Key) throws
  public mutating func encode(_ value: Swift.String, forKey key: Swift.KeyedEncodingContainer<K>.Key) throws
  public mutating func encode(_ value: Swift.Double, forKey key: Swift.KeyedEncodingContainer<K>.Key) throws
  public mutating func encode(_ value: Swift.Float, forKey key: Swift.KeyedEncodingContainer<K>.Key) throws
  public mutating func encode(_ value: Swift.Int, forKey key: Swift.KeyedEncodingContainer<K>.Key) throws
  public mutating func encode(_ value: Swift.Int8, forKey key: Swift.KeyedEncodingContainer<K>.Key) throws
  public mutating func encode(_ value: Swift.Int16, forKey key: Swift.KeyedEncodingContainer<K>.Key) throws
  public mutating func encode(_ value: Swift.Int32, forKey key: Swift.KeyedEncodingContainer<K>.Key) throws
  public mutating func encode(_ value: Swift.Int64, forKey key: Swift.KeyedEncodingContainer<K>.Key) throws
  public mutating func encode(_ value: Swift.UInt, forKey key: Swift.KeyedEncodingContainer<K>.Key) throws
  public mutating func encode(_ value: Swift.UInt8, forKey key: Swift.KeyedEncodingContainer<K>.Key) throws
  public mutating func encode(_ value: Swift.UInt16, forKey key: Swift.KeyedEncodingContainer<K>.Key) throws
  public mutating func encode(_ value: Swift.UInt32, forKey key: Swift.KeyedEncodingContainer<K>.Key) throws
  public mutating func encode(_ value: Swift.UInt64, forKey key: Swift.KeyedEncodingContainer<K>.Key) throws
  public mutating func encode<T>(_ value: T, forKey key: Swift.KeyedEncodingContainer<K>.Key) throws where T : Swift.Encodable
  public mutating func encodeConditional<T>(_ object: T, forKey key: Swift.KeyedEncodingContainer<K>.Key) throws where T : AnyObject, T : Swift.Encodable
  public mutating func encodeIfPresent(_ value: Swift.Bool?, forKey key: Swift.KeyedEncodingContainer<K>.Key) throws
  public mutating func encodeIfPresent(_ value: Swift.String?, forKey key: Swift.KeyedEncodingContainer<K>.Key) throws
  public mutating func encodeIfPresent(_ value: Swift.Double?, forKey key: Swift.KeyedEncodingContainer<K>.Key) throws
  public mutating func encodeIfPresent(_ value: Swift.Float?, forKey key: Swift.KeyedEncodingContainer<K>.Key) throws
  public mutating func encodeIfPresent(_ value: Swift.Int?, forKey key: Swift.KeyedEncodingContainer<K>.Key) throws
  public mutating func encodeIfPresent(_ value: Swift.Int8?, forKey key: Swift.KeyedEncodingContainer<K>.Key) throws
  public mutating func encodeIfPresent(_ value: Swift.Int16?, forKey key: Swift.KeyedEncodingContainer<K>.Key) throws
  public mutating func encodeIfPresent(_ value: Swift.Int32?, forKey key: Swift.KeyedEncodingContainer<K>.Key) throws
  public mutating func encodeIfPresent(_ value: Swift.Int64?, forKey key: Swift.KeyedEncodingContainer<K>.Key) throws
  public mutating func encodeIfPresent(_ value: Swift.UInt?, forKey key: Swift.KeyedEncodingContainer<K>.Key) throws
  public mutating func encodeIfPresent(_ value: Swift.UInt8?, forKey key: Swift.KeyedEncodingContainer<K>.Key) throws
  public mutating func encodeIfPresent(_ value: Swift.UInt16?, forKey key: Swift.KeyedEncodingContainer<K>.Key) throws
  public mutating func encodeIfPresent(_ value: Swift.UInt32?, forKey key: Swift.KeyedEncodingContainer<K>.Key) throws
  public mutating func encodeIfPresent(_ value: Swift.UInt64?, forKey key: Swift.KeyedEncodingContainer<K>.Key) throws
  public mutating func encodeIfPresent<T>(_ value: T?, forKey key: Swift.KeyedEncodingContainer<K>.Key) throws where T : Swift.Encodable
  public mutating func nestedContainer<NestedKey>(keyedBy keyType: NestedKey.Type, forKey key: Swift.KeyedEncodingContainer<K>.Key) -> Swift.KeyedEncodingContainer<NestedKey> where NestedKey : Swift.CodingKey
  public mutating func nestedUnkeyedContainer(forKey key: Swift.KeyedEncodingContainer<K>.Key) -> Swift.UnkeyedEncodingContainer
  public mutating func superEncoder() -> Swift.Encoder
  public mutating func superEncoder(forKey key: Swift.KeyedEncodingContainer<K>.Key) -> Swift.Encoder
}
public protocol KeyedDecodingContainerProtocol {
  associatedtype Key : Swift.CodingKey
  var codingPath: [Swift.CodingKey] { get }
  var allKeys: [Self.Key] { get }
  func contains(_ key: Self.Key) -> Swift.Bool
  func decodeNil(forKey key: Self.Key) throws -> Swift.Bool
  func decode(_ type: Swift.Bool.Type, forKey key: Self.Key) throws -> Swift.Bool
  func decode(_ type: Swift.String.Type, forKey key: Self.Key) throws -> Swift.String
  func decode(_ type: Swift.Double.Type, forKey key: Self.Key) throws -> Swift.Double
  func decode(_ type: Swift.Float.Type, forKey key: Self.Key) throws -> Swift.Float
  func decode(_ type: Swift.Int.Type, forKey key: Self.Key) throws -> Swift.Int
  func decode(_ type: Swift.Int8.Type, forKey key: Self.Key) throws -> Swift.Int8
  func decode(_ type: Swift.Int16.Type, forKey key: Self.Key) throws -> Swift.Int16
  func decode(_ type: Swift.Int32.Type, forKey key: Self.Key) throws -> Swift.Int32
  func decode(_ type: Swift.Int64.Type, forKey key: Self.Key) throws -> Swift.Int64
  func decode(_ type: Swift.UInt.Type, forKey key: Self.Key) throws -> Swift.UInt
  func decode(_ type: Swift.UInt8.Type, forKey key: Self.Key) throws -> Swift.UInt8
  func decode(_ type: Swift.UInt16.Type, forKey key: Self.Key) throws -> Swift.UInt16
  func decode(_ type: Swift.UInt32.Type, forKey key: Self.Key) throws -> Swift.UInt32
  func decode(_ type: Swift.UInt64.Type, forKey key: Self.Key) throws -> Swift.UInt64
  func decode<T>(_ type: T.Type, forKey key: Self.Key) throws -> T where T : Swift.Decodable
  func decodeIfPresent(_ type: Swift.Bool.Type, forKey key: Self.Key) throws -> Swift.Bool?
  func decodeIfPresent(_ type: Swift.String.Type, forKey key: Self.Key) throws -> Swift.String?
  func decodeIfPresent(_ type: Swift.Double.Type, forKey key: Self.Key) throws -> Swift.Double?
  func decodeIfPresent(_ type: Swift.Float.Type, forKey key: Self.Key) throws -> Swift.Float?
  func decodeIfPresent(_ type: Swift.Int.Type, forKey key: Self.Key) throws -> Swift.Int?
  func decodeIfPresent(_ type: Swift.Int8.Type, forKey key: Self.Key) throws -> Swift.Int8?
  func decodeIfPresent(_ type: Swift.Int16.Type, forKey key: Self.Key) throws -> Swift.Int16?
  func decodeIfPresent(_ type: Swift.Int32.Type, forKey key: Self.Key) throws -> Swift.Int32?
  func decodeIfPresent(_ type: Swift.Int64.Type, forKey key: Self.Key) throws -> Swift.Int64?
  func decodeIfPresent(_ type: Swift.UInt.Type, forKey key: Self.Key) throws -> Swift.UInt?
  func decodeIfPresent(_ type: Swift.UInt8.Type, forKey key: Self.Key) throws -> Swift.UInt8?
  func decodeIfPresent(_ type: Swift.UInt16.Type, forKey key: Self.Key) throws -> Swift.UInt16?
  func decodeIfPresent(_ type: Swift.UInt32.Type, forKey key: Self.Key) throws -> Swift.UInt32?
  func decodeIfPresent(_ type: Swift.UInt64.Type, forKey key: Self.Key) throws -> Swift.UInt64?
  func decodeIfPresent<T>(_ type: T.Type, forKey key: Self.Key) throws -> T? where T : Swift.Decodable
  func nestedContainer<NestedKey>(keyedBy type: NestedKey.Type, forKey key: Self.Key) throws -> Swift.KeyedDecodingContainer<NestedKey> where NestedKey : Swift.CodingKey
  func nestedUnkeyedContainer(forKey key: Self.Key) throws -> Swift.UnkeyedDecodingContainer
  func superDecoder() throws -> Swift.Decoder
  func superDecoder(forKey key: Self.Key) throws -> Swift.Decoder
}
public struct KeyedDecodingContainer<K> : Swift.KeyedDecodingContainerProtocol where K : Swift.CodingKey {
  public typealias Key = K
  public init<Container>(_ container: Container) where K == Container.Key, Container : Swift.KeyedDecodingContainerProtocol
  public var codingPath: [Swift.CodingKey] {
    get
  }
  public var allKeys: [Swift.KeyedDecodingContainer<K>.Key] {
    get
  }
  public func contains(_ key: Swift.KeyedDecodingContainer<K>.Key) -> Swift.Bool
  public func decodeNil(forKey key: Swift.KeyedDecodingContainer<K>.Key) throws -> Swift.Bool
  public func decode(_ type: Swift.Bool.Type, forKey key: Swift.KeyedDecodingContainer<K>.Key) throws -> Swift.Bool
  public func decode(_ type: Swift.String.Type, forKey key: Swift.KeyedDecodingContainer<K>.Key) throws -> Swift.String
  public func decode(_ type: Swift.Double.Type, forKey key: Swift.KeyedDecodingContainer<K>.Key) throws -> Swift.Double
  public func decode(_ type: Swift.Float.Type, forKey key: Swift.KeyedDecodingContainer<K>.Key) throws -> Swift.Float
  public func decode(_ type: Swift.Int.Type, forKey key: Swift.KeyedDecodingContainer<K>.Key) throws -> Swift.Int
  public func decode(_ type: Swift.Int8.Type, forKey key: Swift.KeyedDecodingContainer<K>.Key) throws -> Swift.Int8
  public func decode(_ type: Swift.Int16.Type, forKey key: Swift.KeyedDecodingContainer<K>.Key) throws -> Swift.Int16
  public func decode(_ type: Swift.Int32.Type, forKey key: Swift.KeyedDecodingContainer<K>.Key) throws -> Swift.Int32
  public func decode(_ type: Swift.Int64.Type, forKey key: Swift.KeyedDecodingContainer<K>.Key) throws -> Swift.Int64
  public func decode(_ type: Swift.UInt.Type, forKey key: Swift.KeyedDecodingContainer<K>.Key) throws -> Swift.UInt
  public func decode(_ type: Swift.UInt8.Type, forKey key: Swift.KeyedDecodingContainer<K>.Key) throws -> Swift.UInt8
  public func decode(_ type: Swift.UInt16.Type, forKey key: Swift.KeyedDecodingContainer<K>.Key) throws -> Swift.UInt16
  public func decode(_ type: Swift.UInt32.Type, forKey key: Swift.KeyedDecodingContainer<K>.Key) throws -> Swift.UInt32
  public func decode(_ type: Swift.UInt64.Type, forKey key: Swift.KeyedDecodingContainer<K>.Key) throws -> Swift.UInt64
  public func decode<T>(_ type: T.Type, forKey key: Swift.KeyedDecodingContainer<K>.Key) throws -> T where T : Swift.Decodable
  public func decodeIfPresent(_ type: Swift.Bool.Type, forKey key: Swift.KeyedDecodingContainer<K>.Key) throws -> Swift.Bool?
  public func decodeIfPresent(_ type: Swift.String.Type, forKey key: Swift.KeyedDecodingContainer<K>.Key) throws -> Swift.String?
  public func decodeIfPresent(_ type: Swift.Double.Type, forKey key: Swift.KeyedDecodingContainer<K>.Key) throws -> Swift.Double?
  public func decodeIfPresent(_ type: Swift.Float.Type, forKey key: Swift.KeyedDecodingContainer<K>.Key) throws -> Swift.Float?
  public func decodeIfPresent(_ type: Swift.Int.Type, forKey key: Swift.KeyedDecodingContainer<K>.Key) throws -> Swift.Int?
  public func decodeIfPresent(_ type: Swift.Int8.Type, forKey key: Swift.KeyedDecodingContainer<K>.Key) throws -> Swift.Int8?
  public func decodeIfPresent(_ type: Swift.Int16.Type, forKey key: Swift.KeyedDecodingContainer<K>.Key) throws -> Swift.Int16?
  public func decodeIfPresent(_ type: Swift.Int32.Type, forKey key: Swift.KeyedDecodingContainer<K>.Key) throws -> Swift.Int32?
  public func decodeIfPresent(_ type: Swift.Int64.Type, forKey key: Swift.KeyedDecodingContainer<K>.Key) throws -> Swift.Int64?
  public func decodeIfPresent(_ type: Swift.UInt.Type, forKey key: Swift.KeyedDecodingContainer<K>.Key) throws -> Swift.UInt?
  public func decodeIfPresent(_ type: Swift.UInt8.Type, forKey key: Swift.KeyedDecodingContainer<K>.Key) throws -> Swift.UInt8?
  public func decodeIfPresent(_ type: Swift.UInt16.Type, forKey key: Swift.KeyedDecodingContainer<K>.Key) throws -> Swift.UInt16?
  public func decodeIfPresent(_ type: Swift.UInt32.Type, forKey key: Swift.KeyedDecodingContainer<K>.Key) throws -> Swift.UInt32?
  public func decodeIfPresent(_ type: Swift.UInt64.Type, forKey key: Swift.KeyedDecodingContainer<K>.Key) throws -> Swift.UInt64?
  public func decodeIfPresent<T>(_ type: T.Type, forKey key: Swift.KeyedDecodingContainer<K>.Key) throws -> T? where T : Swift.Decodable
  public func nestedContainer<NestedKey>(keyedBy type: NestedKey.Type, forKey key: Swift.KeyedDecodingContainer<K>.Key) throws -> Swift.KeyedDecodingContainer<NestedKey> where NestedKey : Swift.CodingKey
  public func nestedUnkeyedContainer(forKey key: Swift.KeyedDecodingContainer<K>.Key) throws -> Swift.UnkeyedDecodingContainer
  public func superDecoder() throws -> Swift.Decoder
  public func superDecoder(forKey key: Swift.KeyedDecodingContainer<K>.Key) throws -> Swift.Decoder
}
public protocol UnkeyedEncodingContainer {
  var codingPath: [Swift.CodingKey] { get }
  var count: Swift.Int { get }
  mutating func encodeNil() throws
  mutating func encode(_ value: Swift.Bool) throws
  mutating func encode(_ value: Swift.String) throws
  mutating func encode(_ value: Swift.Double) throws
  mutating func encode(_ value: Swift.Float) throws
  mutating func encode(_ value: Swift.Int) throws
  mutating func encode(_ value: Swift.Int8) throws
  mutating func encode(_ value: Swift.Int16) throws
  mutating func encode(_ value: Swift.Int32) throws
  mutating func encode(_ value: Swift.Int64) throws
  mutating func encode(_ value: Swift.UInt) throws
  mutating func encode(_ value: Swift.UInt8) throws
  mutating func encode(_ value: Swift.UInt16) throws
  mutating func encode(_ value: Swift.UInt32) throws
  mutating func encode(_ value: Swift.UInt64) throws
  mutating func encode<T>(_ value: T) throws where T : Swift.Encodable
  mutating func encodeConditional<T>(_ object: T) throws where T : AnyObject, T : Swift.Encodable
  mutating func encode<T>(contentsOf sequence: T) throws where T : Swift.Sequence, T.Element == Swift.Bool
  mutating func encode<T>(contentsOf sequence: T) throws where T : Swift.Sequence, T.Element == Swift.String
  mutating func encode<T>(contentsOf sequence: T) throws where T : Swift.Sequence, T.Element == Swift.Double
  mutating func encode<T>(contentsOf sequence: T) throws where T : Swift.Sequence, T.Element == Swift.Float
  mutating func encode<T>(contentsOf sequence: T) throws where T : Swift.Sequence, T.Element == Swift.Int
  mutating func encode<T>(contentsOf sequence: T) throws where T : Swift.Sequence, T.Element == Swift.Int8
  mutating func encode<T>(contentsOf sequence: T) throws where T : Swift.Sequence, T.Element == Swift.Int16
  mutating func encode<T>(contentsOf sequence: T) throws where T : Swift.Sequence, T.Element == Swift.Int32
  mutating func encode<T>(contentsOf sequence: T) throws where T : Swift.Sequence, T.Element == Swift.Int64
  mutating func encode<T>(contentsOf sequence: T) throws where T : Swift.Sequence, T.Element == Swift.UInt
  mutating func encode<T>(contentsOf sequence: T) throws where T : Swift.Sequence, T.Element == Swift.UInt8
  mutating func encode<T>(contentsOf sequence: T) throws where T : Swift.Sequence, T.Element == Swift.UInt16
  mutating func encode<T>(contentsOf sequence: T) throws where T : Swift.Sequence, T.Element == Swift.UInt32
  mutating func encode<T>(contentsOf sequence: T) throws where T : Swift.Sequence, T.Element == Swift.UInt64
  mutating func encode<T>(contentsOf sequence: T) throws where T : Swift.Sequence, T.Element : Swift.Encodable
  mutating func nestedContainer<NestedKey>(keyedBy keyType: NestedKey.Type) -> Swift.KeyedEncodingContainer<NestedKey> where NestedKey : Swift.CodingKey
  mutating func nestedUnkeyedContainer() -> Swift.UnkeyedEncodingContainer
  mutating func superEncoder() -> Swift.Encoder
}
public protocol UnkeyedDecodingContainer {
  var codingPath: [Swift.CodingKey] { get }
  var count: Swift.Int? { get }
  var isAtEnd: Swift.Bool { get }
  var currentIndex: Swift.Int { get }
  mutating func decodeNil() throws -> Swift.Bool
  mutating func decode(_ type: Swift.Bool.Type) throws -> Swift.Bool
  mutating func decode(_ type: Swift.String.Type) throws -> Swift.String
  mutating func decode(_ type: Swift.Double.Type) throws -> Swift.Double
  mutating func decode(_ type: Swift.Float.Type) throws -> Swift.Float
  mutating func decode(_ type: Swift.Int.Type) throws -> Swift.Int
  mutating func decode(_ type: Swift.Int8.Type) throws -> Swift.Int8
  mutating func decode(_ type: Swift.Int16.Type) throws -> Swift.Int16
  mutating func decode(_ type: Swift.Int32.Type) throws -> Swift.Int32
  mutating func decode(_ type: Swift.Int64.Type) throws -> Swift.Int64
  mutating func decode(_ type: Swift.UInt.Type) throws -> Swift.UInt
  mutating func decode(_ type: Swift.UInt8.Type) throws -> Swift.UInt8
  mutating func decode(_ type: Swift.UInt16.Type) throws -> Swift.UInt16
  mutating func decode(_ type: Swift.UInt32.Type) throws -> Swift.UInt32
  mutating func decode(_ type: Swift.UInt64.Type) throws -> Swift.UInt64
  mutating func decode<T>(_ type: T.Type) throws -> T where T : Swift.Decodable
  mutating func decodeIfPresent(_ type: Swift.Bool.Type) throws -> Swift.Bool?
  mutating func decodeIfPresent(_ type: Swift.String.Type) throws -> Swift.String?
  mutating func decodeIfPresent(_ type: Swift.Double.Type) throws -> Swift.Double?
  mutating func decodeIfPresent(_ type: Swift.Float.Type) throws -> Swift.Float?
  mutating func decodeIfPresent(_ type: Swift.Int.Type) throws -> Swift.Int?
  mutating func decodeIfPresent(_ type: Swift.Int8.Type) throws -> Swift.Int8?
  mutating func decodeIfPresent(_ type: Swift.Int16.Type) throws -> Swift.Int16?
  mutating func decodeIfPresent(_ type: Swift.Int32.Type) throws -> Swift.Int32?
  mutating func decodeIfPresent(_ type: Swift.Int64.Type) throws -> Swift.Int64?
  mutating func decodeIfPresent(_ type: Swift.UInt.Type) throws -> Swift.UInt?
  mutating func decodeIfPresent(_ type: Swift.UInt8.Type) throws -> Swift.UInt8?
  mutating func decodeIfPresent(_ type: Swift.UInt16.Type) throws -> Swift.UInt16?
  mutating func decodeIfPresent(_ type: Swift.UInt32.Type) throws -> Swift.UInt32?
  mutating func decodeIfPresent(_ type: Swift.UInt64.Type) throws -> Swift.UInt64?
  mutating func decodeIfPresent<T>(_ type: T.Type) throws -> T? where T : Swift.Decodable
  mutating func nestedContainer<NestedKey>(keyedBy type: NestedKey.Type) throws -> Swift.KeyedDecodingContainer<NestedKey> where NestedKey : Swift.CodingKey
  mutating func nestedUnkeyedContainer() throws -> Swift.UnkeyedDecodingContainer
  mutating func superDecoder() throws -> Swift.Decoder
}
public protocol SingleValueEncodingContainer {
  var codingPath: [Swift.CodingKey] { get }
  mutating func encodeNil() throws
  mutating func encode(_ value: Swift.Bool) throws
  mutating func encode(_ value: Swift.String) throws
  mutating func encode(_ value: Swift.Double) throws
  mutating func encode(_ value: Swift.Float) throws
  mutating func encode(_ value: Swift.Int) throws
  mutating func encode(_ value: Swift.Int8) throws
  mutating func encode(_ value: Swift.Int16) throws
  mutating func encode(_ value: Swift.Int32) throws
  mutating func encode(_ value: Swift.Int64) throws
  mutating func encode(_ value: Swift.UInt) throws
  mutating func encode(_ value: Swift.UInt8) throws
  mutating func encode(_ value: Swift.UInt16) throws
  mutating func encode(_ value: Swift.UInt32) throws
  mutating func encode(_ value: Swift.UInt64) throws
  mutating func encode<T>(_ value: T) throws where T : Swift.Encodable
}
public protocol SingleValueDecodingContainer {
  var codingPath: [Swift.CodingKey] { get }
  func decodeNil() -> Swift.Bool
  func decode(_ type: Swift.Bool.Type) throws -> Swift.Bool
  func decode(_ type: Swift.String.Type) throws -> Swift.String
  func decode(_ type: Swift.Double.Type) throws -> Swift.Double
  func decode(_ type: Swift.Float.Type) throws -> Swift.Float
  func decode(_ type: Swift.Int.Type) throws -> Swift.Int
  func decode(_ type: Swift.Int8.Type) throws -> Swift.Int8
  func decode(_ type: Swift.Int16.Type) throws -> Swift.Int16
  func decode(_ type: Swift.Int32.Type) throws -> Swift.Int32
  func decode(_ type: Swift.Int64.Type) throws -> Swift.Int64
  func decode(_ type: Swift.UInt.Type) throws -> Swift.UInt
  func decode(_ type: Swift.UInt8.Type) throws -> Swift.UInt8
  func decode(_ type: Swift.UInt16.Type) throws -> Swift.UInt16
  func decode(_ type: Swift.UInt32.Type) throws -> Swift.UInt32
  func decode(_ type: Swift.UInt64.Type) throws -> Swift.UInt64
  func decode<T>(_ type: T.Type) throws -> T where T : Swift.Decodable
}
public struct CodingUserInfoKey : Swift.RawRepresentable, Swift.Equatable, Swift.Hashable {
  public typealias RawValue = Swift.String
  public let rawValue: Swift.String
  public init?(rawValue: Swift.String)
  public static func == (lhs: Swift.CodingUserInfoKey, rhs: Swift.CodingUserInfoKey) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
}
public enum EncodingError : Swift.Error {
  public struct Context {
    public let codingPath: [Swift.CodingKey]
    public let debugDescription: Swift.String
    public let underlyingError: Swift.Error?
    public init(codingPath: [Swift.CodingKey], debugDescription: Swift.String, underlyingError: Swift.Error? = nil)
  }
  case invalidValue(Any, Swift.EncodingError.Context)
  public var _domain: Swift.String {
    get
  }
  public var _code: Swift.Int {
    get
  }
  public var _userInfo: Swift.AnyObject? {
    get
  }
}
public enum DecodingError : Swift.Error {
  public struct Context {
    public let codingPath: [Swift.CodingKey]
    public let debugDescription: Swift.String
    public let underlyingError: Swift.Error?
    public init(codingPath: [Swift.CodingKey], debugDescription: Swift.String, underlyingError: Swift.Error? = nil)
  }
  case typeMismatch(Any.Type, Swift.DecodingError.Context)
  case valueNotFound(Any.Type, Swift.DecodingError.Context)
  case keyNotFound(Swift.CodingKey, Swift.DecodingError.Context)
  case dataCorrupted(Swift.DecodingError.Context)
  public var _domain: Swift.String {
    get
  }
  public var _code: Swift.Int {
    get
  }
  public var _userInfo: Swift.AnyObject? {
    get
  }
}
extension DecodingError {
  public static func dataCorruptedError<C>(forKey key: C.Key, in container: C, debugDescription: Swift.String) -> Swift.DecodingError where C : Swift.KeyedDecodingContainerProtocol
  public static func dataCorruptedError(in container: Swift.UnkeyedDecodingContainer, debugDescription: Swift.String) -> Swift.DecodingError
  public static func dataCorruptedError(in container: Swift.SingleValueDecodingContainer, debugDescription: Swift.String) -> Swift.DecodingError
}
extension Bool : Swift.Codable {
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
extension RawRepresentable where Self : Swift.Encodable, Self.RawValue == Swift.Bool {
  public func encode(to encoder: Swift.Encoder) throws
}
extension RawRepresentable where Self : Swift.Decodable, Self.RawValue == Swift.Bool {
  public init(from decoder: Swift.Decoder) throws
}
extension String : Swift.Codable {
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
extension RawRepresentable where Self : Swift.Encodable, Self.RawValue == Swift.String {
  public func encode(to encoder: Swift.Encoder) throws
}
extension RawRepresentable where Self : Swift.Decodable, Self.RawValue == Swift.String {
  public init(from decoder: Swift.Decoder) throws
}
extension Double : Swift.Codable {
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
extension RawRepresentable where Self : Swift.Encodable, Self.RawValue == Swift.Double {
  public func encode(to encoder: Swift.Encoder) throws
}
extension RawRepresentable where Self : Swift.Decodable, Self.RawValue == Swift.Double {
  public init(from decoder: Swift.Decoder) throws
}
extension Float : Swift.Codable {
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
extension RawRepresentable where Self : Swift.Encodable, Self.RawValue == Swift.Float {
  public func encode(to encoder: Swift.Encoder) throws
}
extension RawRepresentable where Self : Swift.Decodable, Self.RawValue == Swift.Float {
  public init(from decoder: Swift.Decoder) throws
}
extension Int : Swift.Codable {
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
extension RawRepresentable where Self : Swift.Encodable, Self.RawValue == Swift.Int {
  public func encode(to encoder: Swift.Encoder) throws
}
extension RawRepresentable where Self : Swift.Decodable, Self.RawValue == Swift.Int {
  public init(from decoder: Swift.Decoder) throws
}
extension Int8 : Swift.Codable {
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
extension RawRepresentable where Self : Swift.Encodable, Self.RawValue == Swift.Int8 {
  public func encode(to encoder: Swift.Encoder) throws
}
extension RawRepresentable where Self : Swift.Decodable, Self.RawValue == Swift.Int8 {
  public init(from decoder: Swift.Decoder) throws
}
extension Int16 : Swift.Codable {
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
extension RawRepresentable where Self : Swift.Encodable, Self.RawValue == Swift.Int16 {
  public func encode(to encoder: Swift.Encoder) throws
}
extension RawRepresentable where Self : Swift.Decodable, Self.RawValue == Swift.Int16 {
  public init(from decoder: Swift.Decoder) throws
}
extension Int32 : Swift.Codable {
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
extension RawRepresentable where Self : Swift.Encodable, Self.RawValue == Swift.Int32 {
  public func encode(to encoder: Swift.Encoder) throws
}
extension RawRepresentable where Self : Swift.Decodable, Self.RawValue == Swift.Int32 {
  public init(from decoder: Swift.Decoder) throws
}
extension Int64 : Swift.Codable {
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
extension RawRepresentable where Self : Swift.Encodable, Self.RawValue == Swift.Int64 {
  public func encode(to encoder: Swift.Encoder) throws
}
extension RawRepresentable where Self : Swift.Decodable, Self.RawValue == Swift.Int64 {
  public init(from decoder: Swift.Decoder) throws
}
extension UInt : Swift.Codable {
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
extension RawRepresentable where Self : Swift.Encodable, Self.RawValue == Swift.UInt {
  public func encode(to encoder: Swift.Encoder) throws
}
extension RawRepresentable where Self : Swift.Decodable, Self.RawValue == Swift.UInt {
  public init(from decoder: Swift.Decoder) throws
}
extension UInt8 : Swift.Codable {
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
extension RawRepresentable where Self : Swift.Encodable, Self.RawValue == Swift.UInt8 {
  public func encode(to encoder: Swift.Encoder) throws
}
extension RawRepresentable where Self : Swift.Decodable, Self.RawValue == Swift.UInt8 {
  public init(from decoder: Swift.Decoder) throws
}
extension UInt16 : Swift.Codable {
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
extension RawRepresentable where Self : Swift.Encodable, Self.RawValue == Swift.UInt16 {
  public func encode(to encoder: Swift.Encoder) throws
}
extension RawRepresentable where Self : Swift.Decodable, Self.RawValue == Swift.UInt16 {
  public init(from decoder: Swift.Decoder) throws
}
extension UInt32 : Swift.Codable {
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
extension RawRepresentable where Self : Swift.Encodable, Self.RawValue == Swift.UInt32 {
  public func encode(to encoder: Swift.Encoder) throws
}
extension RawRepresentable where Self : Swift.Decodable, Self.RawValue == Swift.UInt32 {
  public init(from decoder: Swift.Decoder) throws
}
extension UInt64 : Swift.Codable {
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
extension RawRepresentable where Self : Swift.Encodable, Self.RawValue == Swift.UInt64 {
  public func encode(to encoder: Swift.Encoder) throws
}
extension RawRepresentable where Self : Swift.Decodable, Self.RawValue == Swift.UInt64 {
  public init(from decoder: Swift.Decoder) throws
}
extension Optional : Swift.Encodable where Wrapped : Swift.Encodable {
  public func encode(to encoder: Swift.Encoder) throws
}
extension Optional : Swift.Decodable where Wrapped : Swift.Decodable {
  public init(from decoder: Swift.Decoder) throws
}
extension Array : Swift.Encodable where Element : Swift.Encodable {
  public func encode(to encoder: Swift.Encoder) throws
}
extension Array : Swift.Decodable where Element : Swift.Decodable {
  public init(from decoder: Swift.Decoder) throws
}
extension ContiguousArray : Swift.Encodable where Element : Swift.Encodable {
  public func encode(to encoder: Swift.Encoder) throws
}
extension ContiguousArray : Swift.Decodable where Element : Swift.Decodable {
  public init(from decoder: Swift.Decoder) throws
}
extension Set : Swift.Encodable where Element : Swift.Encodable {
  public func encode(to encoder: Swift.Encoder) throws
}
extension Set : Swift.Decodable where Element : Swift.Decodable {
  public init(from decoder: Swift.Decoder) throws
}
extension Dictionary : Swift.Encodable where Key : Swift.Encodable, Value : Swift.Encodable {
  public func encode(to encoder: Swift.Encoder) throws
}
extension Dictionary : Swift.Decodable where Key : Swift.Decodable, Value : Swift.Decodable {
  public init(from decoder: Swift.Decoder) throws
}
extension KeyedEncodingContainerProtocol {
  public mutating func encodeConditional<T>(_ object: T, forKey key: Self.Key) throws where T : AnyObject, T : Swift.Encodable
}
extension KeyedEncodingContainerProtocol {
  public mutating func encodeIfPresent(_ value: Swift.Bool?, forKey key: Self.Key) throws
  public mutating func encodeIfPresent(_ value: Swift.String?, forKey key: Self.Key) throws
  public mutating func encodeIfPresent(_ value: Swift.Double?, forKey key: Self.Key) throws
  public mutating func encodeIfPresent(_ value: Swift.Float?, forKey key: Self.Key) throws
  public mutating func encodeIfPresent(_ value: Swift.Int?, forKey key: Self.Key) throws
  public mutating func encodeIfPresent(_ value: Swift.Int8?, forKey key: Self.Key) throws
  public mutating func encodeIfPresent(_ value: Swift.Int16?, forKey key: Self.Key) throws
  public mutating func encodeIfPresent(_ value: Swift.Int32?, forKey key: Self.Key) throws
  public mutating func encodeIfPresent(_ value: Swift.Int64?, forKey key: Self.Key) throws
  public mutating func encodeIfPresent(_ value: Swift.UInt?, forKey key: Self.Key) throws
  public mutating func encodeIfPresent(_ value: Swift.UInt8?, forKey key: Self.Key) throws
  public mutating func encodeIfPresent(_ value: Swift.UInt16?, forKey key: Self.Key) throws
  public mutating func encodeIfPresent(_ value: Swift.UInt32?, forKey key: Self.Key) throws
  public mutating func encodeIfPresent(_ value: Swift.UInt64?, forKey key: Self.Key) throws
  public mutating func encodeIfPresent<T>(_ value: T?, forKey key: Self.Key) throws where T : Swift.Encodable
}
extension KeyedDecodingContainerProtocol {
  public func decodeIfPresent(_ type: Swift.Bool.Type, forKey key: Self.Key) throws -> Swift.Bool?
  public func decodeIfPresent(_ type: Swift.String.Type, forKey key: Self.Key) throws -> Swift.String?
  public func decodeIfPresent(_ type: Swift.Double.Type, forKey key: Self.Key) throws -> Swift.Double?
  public func decodeIfPresent(_ type: Swift.Float.Type, forKey key: Self.Key) throws -> Swift.Float?
  public func decodeIfPresent(_ type: Swift.Int.Type, forKey key: Self.Key) throws -> Swift.Int?
  public func decodeIfPresent(_ type: Swift.Int8.Type, forKey key: Self.Key) throws -> Swift.Int8?
  public func decodeIfPresent(_ type: Swift.Int16.Type, forKey key: Self.Key) throws -> Swift.Int16?
  public func decodeIfPresent(_ type: Swift.Int32.Type, forKey key: Self.Key) throws -> Swift.Int32?
  public func decodeIfPresent(_ type: Swift.Int64.Type, forKey key: Self.Key) throws -> Swift.Int64?
  public func decodeIfPresent(_ type: Swift.UInt.Type, forKey key: Self.Key) throws -> Swift.UInt?
  public func decodeIfPresent(_ type: Swift.UInt8.Type, forKey key: Self.Key) throws -> Swift.UInt8?
  public func decodeIfPresent(_ type: Swift.UInt16.Type, forKey key: Self.Key) throws -> Swift.UInt16?
  public func decodeIfPresent(_ type: Swift.UInt32.Type, forKey key: Self.Key) throws -> Swift.UInt32?
  public func decodeIfPresent(_ type: Swift.UInt64.Type, forKey key: Self.Key) throws -> Swift.UInt64?
  public func decodeIfPresent<T>(_ type: T.Type, forKey key: Self.Key) throws -> T? where T : Swift.Decodable
}
extension UnkeyedEncodingContainer {
  public mutating func encodeConditional<T>(_ object: T) throws where T : AnyObject, T : Swift.Encodable
  public mutating func encode<T>(contentsOf sequence: T) throws where T : Swift.Sequence, T.Element == Swift.Bool
  public mutating func encode<T>(contentsOf sequence: T) throws where T : Swift.Sequence, T.Element == Swift.String
  public mutating func encode<T>(contentsOf sequence: T) throws where T : Swift.Sequence, T.Element == Swift.Double
  public mutating func encode<T>(contentsOf sequence: T) throws where T : Swift.Sequence, T.Element == Swift.Float
  public mutating func encode<T>(contentsOf sequence: T) throws where T : Swift.Sequence, T.Element == Swift.Int
  public mutating func encode<T>(contentsOf sequence: T) throws where T : Swift.Sequence, T.Element == Swift.Int8
  public mutating func encode<T>(contentsOf sequence: T) throws where T : Swift.Sequence, T.Element == Swift.Int16
  public mutating func encode<T>(contentsOf sequence: T) throws where T : Swift.Sequence, T.Element == Swift.Int32
  public mutating func encode<T>(contentsOf sequence: T) throws where T : Swift.Sequence, T.Element == Swift.Int64
  public mutating func encode<T>(contentsOf sequence: T) throws where T : Swift.Sequence, T.Element == Swift.UInt
  public mutating func encode<T>(contentsOf sequence: T) throws where T : Swift.Sequence, T.Element == Swift.UInt8
  public mutating func encode<T>(contentsOf sequence: T) throws where T : Swift.Sequence, T.Element == Swift.UInt16
  public mutating func encode<T>(contentsOf sequence: T) throws where T : Swift.Sequence, T.Element == Swift.UInt32
  public mutating func encode<T>(contentsOf sequence: T) throws where T : Swift.Sequence, T.Element == Swift.UInt64
  public mutating func encode<T>(contentsOf sequence: T) throws where T : Swift.Sequence, T.Element : Swift.Encodable
}
extension UnkeyedDecodingContainer {
  public mutating func decodeIfPresent(_ type: Swift.Bool.Type) throws -> Swift.Bool?
  public mutating func decodeIfPresent(_ type: Swift.String.Type) throws -> Swift.String?
  public mutating func decodeIfPresent(_ type: Swift.Double.Type) throws -> Swift.Double?
  public mutating func decodeIfPresent(_ type: Swift.Float.Type) throws -> Swift.Float?
  public mutating func decodeIfPresent(_ type: Swift.Int.Type) throws -> Swift.Int?
  public mutating func decodeIfPresent(_ type: Swift.Int8.Type) throws -> Swift.Int8?
  public mutating func decodeIfPresent(_ type: Swift.Int16.Type) throws -> Swift.Int16?
  public mutating func decodeIfPresent(_ type: Swift.Int32.Type) throws -> Swift.Int32?
  public mutating func decodeIfPresent(_ type: Swift.Int64.Type) throws -> Swift.Int64?
  public mutating func decodeIfPresent(_ type: Swift.UInt.Type) throws -> Swift.UInt?
  public mutating func decodeIfPresent(_ type: Swift.UInt8.Type) throws -> Swift.UInt8?
  public mutating func decodeIfPresent(_ type: Swift.UInt16.Type) throws -> Swift.UInt16?
  public mutating func decodeIfPresent(_ type: Swift.UInt32.Type) throws -> Swift.UInt32?
  public mutating func decodeIfPresent(_ type: Swift.UInt64.Type) throws -> Swift.UInt64?
  public mutating func decodeIfPresent<T>(_ type: T.Type) throws -> T? where T : Swift.Decodable
}
@frozen public struct IndexingIterator<Elements> where Elements : Swift.Collection {
  @usableFromInline
  internal let _elements: Elements
  @usableFromInline
  internal var _position: Elements.Index
  @inlinable @inline(__always) public init(_elements: Elements) {
    self._elements = _elements
    self._position = _elements.startIndex
  }
  @inlinable @inline(__always) public init(_elements: Elements, _position: Elements.Index) {
    self._elements = _elements
    self._position = _position
  }
}
extension IndexingIterator : Swift.IteratorProtocol, Swift.Sequence {
  public typealias Element = Elements.Element
  public typealias Iterator = Swift.IndexingIterator<Elements>
  public typealias SubSequence = Swift.AnySequence<Swift.IndexingIterator<Elements>.Element>
  @inlinable @inline(__always) public mutating func next() -> Elements.Element? {
    if _position == _elements.endIndex { return nil }
    let element = _elements[_position]
    _elements.formIndex(after: &_position)
    return element
  }
}
public protocol Collection : Swift.Sequence {
  @available(*, deprecated, message: "all index distances are now of type Int")
  typealias IndexDistance = Swift.Int
  override associatedtype Element
  associatedtype Index : Swift.Comparable where Self.Index == Self.Indices.Element, Self.Indices.Element == Self.Indices.Index, Self.Indices.Index == Self.SubSequence.Index, Self.SubSequence.Index == Self.Indices.Indices.Element, Self.Indices.Indices.Element == Self.Indices.Indices.Index, Self.Indices.Indices.Index == Self.SubSequence.Indices.Element, Self.SubSequence.Indices.Element == Self.SubSequence.Indices.Index, Self.SubSequence.Indices.Index == Self.SubSequence.Indices.Indices.Element, Self.SubSequence.Indices.Indices.Element == Self.SubSequence.Indices.Indices.Index
  var startIndex: Self.Index { get }
  var endIndex: Self.Index { get }
  associatedtype Iterator = Swift.IndexingIterator<Self>
  override __consuming func makeIterator() -> Self.Iterator
  associatedtype SubSequence : Swift.Collection = Swift.Slice<Self> where Self.Element == Self.SubSequence.Element, Self.SubSequence == Self.SubSequence.SubSequence
  @_borrowed subscript(position: Self.Index) -> Self.Element { get }
  subscript(bounds: Swift.Range<Self.Index>) -> Self.SubSequence { get }
  associatedtype Indices : Swift.Collection = Swift.DefaultIndices<Self> where Self.Indices == Self.Indices.SubSequence
  var indices: Self.Indices { get }
  var isEmpty: Swift.Bool { get }
  var count: Swift.Int { get }
  func _customIndexOfEquatableElement(_ element: Self.Element) -> Self.Index??
  func _customLastIndexOfEquatableElement(_ element: Self.Element) -> Self.Index??
  func index(_ i: Self.Index, offsetBy distance: Swift.Int) -> Self.Index
  func index(_ i: Self.Index, offsetBy distance: Swift.Int, limitedBy limit: Self.Index) -> Self.Index?
  func distance(from start: Self.Index, to end: Self.Index) -> Swift.Int
  func _failEarlyRangeCheck(_ index: Self.Index, bounds: Swift.Range<Self.Index>)
  func _failEarlyRangeCheck(_ index: Self.Index, bounds: Swift.ClosedRange<Self.Index>)
  func _failEarlyRangeCheck(_ range: Swift.Range<Self.Index>, bounds: Swift.Range<Self.Index>)
  func index(after i: Self.Index) -> Self.Index
  func formIndex(after i: inout Self.Index)
}
extension Collection {
  @inlinable @inline(__always) public func formIndex(after i: inout Self.Index) {
    i = index(after: i)
  }
  @inlinable public func _failEarlyRangeCheck(_ index: Self.Index, bounds: Swift.Range<Self.Index>) {
    // FIXME: swift-3-indexing-model: tests.
    _precondition(
      bounds.lowerBound <= index,
      "Out of bounds: index < startIndex")
    _precondition(
      index < bounds.upperBound,
      "Out of bounds: index >= endIndex")
  }
  @inlinable public func _failEarlyRangeCheck(_ index: Self.Index, bounds: Swift.ClosedRange<Self.Index>) {
    // FIXME: swift-3-indexing-model: tests.
    _precondition(
      bounds.lowerBound <= index,
      "Out of bounds: index < startIndex")
    _precondition(
      index <= bounds.upperBound,
      "Out of bounds: index > endIndex")
  }
  @inlinable public func _failEarlyRangeCheck(_ range: Swift.Range<Self.Index>, bounds: Swift.Range<Self.Index>) {
    // FIXME: swift-3-indexing-model: tests.
    _precondition(
      bounds.lowerBound <= range.lowerBound,
      "Out of bounds: range begins before startIndex")
    _precondition(
      range.lowerBound <= bounds.upperBound,
      "Out of bounds: range ends after endIndex")
    _precondition(
      bounds.lowerBound <= range.upperBound,
      "Out of bounds: range ends before bounds.lowerBound")
    _precondition(
      range.upperBound <= bounds.upperBound,
      "Out of bounds: range begins after bounds.upperBound")
  }
  @inlinable public func index(_ i: Self.Index, offsetBy distance: Swift.Int) -> Self.Index {
    return self._advanceForward(i, by: distance)
  }
  @inlinable public func index(_ i: Self.Index, offsetBy distance: Swift.Int, limitedBy limit: Self.Index) -> Self.Index? {
    return self._advanceForward(i, by: distance, limitedBy: limit)
  }
  @inlinable public func formIndex(_ i: inout Self.Index, offsetBy distance: Swift.Int) {
    i = index(i, offsetBy: distance)
  }
  @inlinable public func formIndex(_ i: inout Self.Index, offsetBy distance: Swift.Int, limitedBy limit: Self.Index) -> Swift.Bool {
    if let advancedIndex = index(i, offsetBy: distance, limitedBy: limit) {
      i = advancedIndex
      return true
    }
    i = limit
    return false
  }
  @inlinable public func distance(from start: Self.Index, to end: Self.Index) -> Swift.Int {
    _precondition(start <= end,
      "Only BidirectionalCollections can have end come before start")

    var start = start
    var count = 0
    while start != end {
      count = count + 1
      formIndex(after: &start)
    }
    return count
  }
  @inlinable public func randomElement<T>(using generator: inout T) -> Self.Element? where T : Swift.RandomNumberGenerator {
    guard !isEmpty else { return nil }
    let random = Int.random(in: 0 ..< count, using: &generator)
    let idx = index(startIndex, offsetBy: random)
    return self[idx]
  }
  @inlinable public func randomElement() -> Self.Element? {
    var g = SystemRandomNumberGenerator()
    return randomElement(using: &g)
  }
  @inlinable @inline(__always) internal func _advanceForward(_ i: Self.Index, by n: Swift.Int) -> Self.Index {
    _precondition(n >= 0,
      "Only BidirectionalCollections can be advanced by a negative amount")

    var i = i
    for _ in stride(from: 0, to: n, by: 1) {
      formIndex(after: &i)
    }
    return i
  }
  @inlinable @inline(__always) internal func _advanceForward(_ i: Self.Index, by n: Swift.Int, limitedBy limit: Self.Index) -> Self.Index? {
    _precondition(n >= 0,
      "Only BidirectionalCollections can be advanced by a negative amount")

    var i = i
    for _ in stride(from: 0, to: n, by: 1) {
      if i == limit {
        return nil
      }
      formIndex(after: &i)
    }
    return i
  }
}
extension Collection where Self.Iterator == Swift.IndexingIterator<Self> {
  @inlinable @inline(__always) __consuming public func makeIterator() -> Swift.IndexingIterator<Self> {
    return IndexingIterator(_elements: self)
  }
}
extension Collection where Self.SubSequence == Swift.Slice<Self> {
  @inlinable public subscript(bounds: Swift.Range<Self.Index>) -> Swift.Slice<Self> {
    get {
    _failEarlyRangeCheck(bounds, bounds: startIndex..<endIndex)
    return Slice(base: self, bounds: bounds)
  }
  }
}
extension Collection where Self == Self.SubSequence {
  @inlinable public mutating func popFirst() -> Self.Element? {
    // TODO: swift-3-indexing-model - review the following
    guard !isEmpty else { return nil }
    let element = first!
    self = self[index(after: startIndex)..<endIndex]
    return element
  }
}
extension Collection {
  @inlinable public var isEmpty: Swift.Bool {
    get {
    return startIndex == endIndex
  }
  }
  @inlinable public var first: Self.Element? {
    get {
    let start = startIndex
    if start != endIndex { return self[start] }
    else { return nil }
  }
  }
  @inlinable public var underestimatedCount: Swift.Int {
    get {
    // TODO: swift-3-indexing-model - review the following
    return count
  }
  }
  @inlinable public var count: Swift.Int {
    get {
    return distance(from: startIndex, to: endIndex)
  }
  }
  @inlinable @inline(__always) public func _customIndexOfEquatableElement(_: Self.Element) -> Self.Index?? {
    return nil
  }
  @inlinable @inline(__always) public func _customLastIndexOfEquatableElement(_ element: Self.Element) -> Self.Index?? {
    return nil
  }
}
extension Collection {
  @inlinable public func map<T>(_ transform: (Self.Element) throws -> T) rethrows -> [T] {
    // TODO: swift-3-indexing-model - review the following
    let n = self.count
    if n == 0 {
      return []
    }

    var result = ContiguousArray<T>()
    result.reserveCapacity(n)

    var i = self.startIndex

    for _ in 0..<n {
      result.append(try transform(self[i]))
      formIndex(after: &i)
    }

    _expectEnd(of: self, is: i)
    return Array(result)
  }
  @inlinable __consuming public func dropFirst(_ k: Swift.Int = 1) -> Self.SubSequence {
    _precondition(k >= 0, "Can't drop a negative number of elements from a collection")
    let start = index(startIndex, offsetBy: k, limitedBy: endIndex) ?? endIndex
    return self[start..<endIndex]
  }
  @inlinable __consuming public func dropLast(_ k: Swift.Int = 1) -> Self.SubSequence {
    _precondition(
      k >= 0, "Can't drop a negative number of elements from a collection")
    let amount = Swift.max(0, count - k)
    let end = index(startIndex,
      offsetBy: amount, limitedBy: endIndex) ?? endIndex
    return self[startIndex..<end]
  }
  @inlinable __consuming public func drop(while predicate: (Self.Element) throws -> Swift.Bool) rethrows -> Self.SubSequence {
    var start = startIndex
    while try start != endIndex && predicate(self[start]) {
      formIndex(after: &start)
    } 
    return self[start..<endIndex]
  }
  @inlinable __consuming public func prefix(_ maxLength: Swift.Int) -> Self.SubSequence {
    _precondition(
      maxLength >= 0,
      "Can't take a prefix of negative length from a collection")
    let end = index(startIndex,
      offsetBy: maxLength, limitedBy: endIndex) ?? endIndex
    return self[startIndex..<end]
  }
  @inlinable __consuming public func prefix(while predicate: (Self.Element) throws -> Swift.Bool) rethrows -> Self.SubSequence {
    var end = startIndex
    while try end != endIndex && predicate(self[end]) {
      formIndex(after: &end)
    }
    return self[startIndex..<end]
  }
  @inlinable __consuming public func suffix(_ maxLength: Swift.Int) -> Self.SubSequence {
    _precondition(
      maxLength >= 0,
      "Can't take a suffix of negative length from a collection")
    let amount = Swift.max(0, count - maxLength)
    let start = index(startIndex,
      offsetBy: amount, limitedBy: endIndex) ?? endIndex
    return self[start..<endIndex]
  }
  @inlinable __consuming public func prefix(upTo end: Self.Index) -> Self.SubSequence {
    return self[startIndex..<end]
  }
  @inlinable __consuming public func suffix(from start: Self.Index) -> Self.SubSequence {
    return self[start..<endIndex]
  }
  @inlinable __consuming public func prefix(through position: Self.Index) -> Self.SubSequence {
    return prefix(upTo: index(after: position))
  }
  @inlinable __consuming public func split(maxSplits: Swift.Int = Int.max, omittingEmptySubsequences: Swift.Bool = true, whereSeparator isSeparator: (Self.Element) throws -> Swift.Bool) rethrows -> [Self.SubSequence] {
    // TODO: swift-3-indexing-model - review the following
    _precondition(maxSplits >= 0, "Must take zero or more splits")

    var result: [SubSequence] = []
    var subSequenceStart: Index = startIndex

    func appendSubsequence(end: Index) -> Bool {
      if subSequenceStart == end && omittingEmptySubsequences {
        return false
      }
      result.append(self[subSequenceStart..<end])
      return true
    }

    if maxSplits == 0 || isEmpty {
      _ = appendSubsequence(end: endIndex)
      return result
    }

    var subSequenceEnd = subSequenceStart
    let cachedEndIndex = endIndex
    while subSequenceEnd != cachedEndIndex {
      if try isSeparator(self[subSequenceEnd]) {
        let didAppend = appendSubsequence(end: subSequenceEnd)
        formIndex(after: &subSequenceEnd)
        subSequenceStart = subSequenceEnd
        if didAppend && result.count == maxSplits {
          break
        }
        continue
      }
      formIndex(after: &subSequenceEnd)
    }

    if subSequenceStart != cachedEndIndex || !omittingEmptySubsequences {
      result.append(self[subSequenceStart..<cachedEndIndex])
    }

    return result
  }
}
extension Collection where Self.Element : Swift.Equatable {
  @inlinable __consuming public func split(separator: Self.Element, maxSplits: Swift.Int = Int.max, omittingEmptySubsequences: Swift.Bool = true) -> [Self.SubSequence] {
    // TODO: swift-3-indexing-model - review the following
    return split(
      maxSplits: maxSplits,
      omittingEmptySubsequences: omittingEmptySubsequences,
      whereSeparator: { $0 == separator })
  }
}
extension Collection where Self == Self.SubSequence {
  @discardableResult
  @inlinable public mutating func removeFirst() -> Self.Element {
    // TODO: swift-3-indexing-model - review the following
    _precondition(!isEmpty, "Can't remove items from an empty collection")
    let element = first!
    self = self[index(after: startIndex)..<endIndex]
    return element
  }
  @inlinable public mutating func removeFirst(_ k: Swift.Int) {
    if k == 0 { return }
    _precondition(k >= 0, "Number of elements to remove should be non-negative")
    guard let idx = index(startIndex, offsetBy: k, limitedBy: endIndex) else {
      _preconditionFailure(
        "Can't remove more items from a collection than it contains")
    }
    self = self[idx..<endIndex]
  }
}
extension BidirectionalCollection {
  @inlinable public var last: Self.Element? {
    get {
    return isEmpty ? nil : self[index(before: endIndex)]
  }
  }
}
extension Collection where Self.Element : Swift.Equatable {
  @inlinable public func firstIndex(of element: Self.Element) -> Self.Index? {
    if let result = _customIndexOfEquatableElement(element) {
      return result
    }

    var i = self.startIndex
    while i != self.endIndex {
      if self[i] == element {
        return i
      }
      self.formIndex(after: &i)
    }
    return nil
  }
}
extension Collection {
  @inlinable public func firstIndex(where predicate: (Self.Element) throws -> Swift.Bool) rethrows -> Self.Index? {
    var i = self.startIndex
    while i != self.endIndex {
      if try predicate(self[i]) {
        return i
      }
      self.formIndex(after: &i)
    }
    return nil
  }
}
extension BidirectionalCollection {
  @inlinable public func last(where predicate: (Self.Element) throws -> Swift.Bool) rethrows -> Self.Element? {
    return try lastIndex(where: predicate).map { self[$0] }
  }
  @inlinable public func lastIndex(where predicate: (Self.Element) throws -> Swift.Bool) rethrows -> Self.Index? {
    var i = endIndex
    while i != startIndex {
      formIndex(before: &i)
      if try predicate(self[i]) {
        return i
      }
    }
    return nil
  }
}
extension BidirectionalCollection where Self.Element : Swift.Equatable {
  @inlinable public func lastIndex(of element: Self.Element) -> Self.Index? {
    if let result = _customLastIndexOfEquatableElement(element) {
      return result
    }
    return lastIndex(where: { $0 == element })
  }
}
extension MutableCollection {
  @inlinable public mutating func partition(by belongsInSecondPartition: (Self.Element) throws -> Swift.Bool) rethrows -> Self.Index {
    return try _halfStablePartition(isSuffixElement: belongsInSecondPartition)
  }
  @inlinable internal mutating func _halfStablePartition(isSuffixElement: (Self.Element) throws -> Swift.Bool) rethrows -> Self.Index {
    guard var i = try firstIndex(where: isSuffixElement)
    else { return endIndex }
    
    var j = index(after: i)
    while j != endIndex {
      if try !isSuffixElement(self[j]) { swapAt(i, j); formIndex(after: &i) }
      formIndex(after: &j)
    }
    return i
  }
}
extension MutableCollection where Self : Swift.BidirectionalCollection {
  @inlinable public mutating func partition(by belongsInSecondPartition: (Self.Element) throws -> Swift.Bool) rethrows -> Self.Index {
    let maybeOffset = try _withUnsafeMutableBufferPointerIfSupported {
      (bufferPointer) -> Int in
      let unsafeBufferPivot = try bufferPointer._partitionImpl(
        by: belongsInSecondPartition)
      return unsafeBufferPivot - bufferPointer.startIndex
    }
    if let offset = maybeOffset {
      return index(startIndex, offsetBy: offset)
    } else {
      return try _partitionImpl(by: belongsInSecondPartition)
    }
  }
  @usableFromInline
  internal mutating func _partitionImpl(by belongsInSecondPartition: (Self.Element) throws -> Swift.Bool) rethrows -> Self.Index
}
extension Sequence {
  @inlinable public func shuffled<T>(using generator: inout T) -> [Self.Element] where T : Swift.RandomNumberGenerator {
    var result = ContiguousArray(self)
    result.shuffle(using: &generator)
    return Array(result)
  }
  @inlinable public func shuffled() -> [Self.Element] {
    var g = SystemRandomNumberGenerator()
    return shuffled(using: &g)
  }
}
extension MutableCollection where Self : Swift.RandomAccessCollection {
  @inlinable public mutating func shuffle<T>(using generator: inout T) where T : Swift.RandomNumberGenerator {
    guard count > 1 else { return }
    var amount = count
    var currentIndex = startIndex
    while amount > 1 {
      let random = Int.random(in: 0 ..< amount, using: &generator)
      amount -= 1
      swapAt(
        currentIndex,
        index(currentIndex, offsetBy: random)
      )
      formIndex(after: &currentIndex)
    }
  }
  @inlinable public mutating func shuffle() {
    var g = SystemRandomNumberGenerator()
    shuffle(using: &g)
  }
}
public protocol Comparable : Swift.Equatable {
  static func < (lhs: Self, rhs: Self) -> Swift.Bool
  static func <= (lhs: Self, rhs: Self) -> Swift.Bool
  static func >= (lhs: Self, rhs: Self) -> Swift.Bool
  static func > (lhs: Self, rhs: Self) -> Swift.Bool
}
extension Comparable {
  @inlinable public static func > (lhs: Self, rhs: Self) -> Swift.Bool {
    return rhs < lhs
  }
  @inlinable public static func <= (lhs: Self, rhs: Self) -> Swift.Bool {
    return !(rhs < lhs)
  }
  @inlinable public static func >= (lhs: Self, rhs: Self) -> Swift.Bool {
    return !(lhs < rhs)
  }
}
public protocol RawRepresentable {
  associatedtype RawValue
  init?(rawValue: Self.RawValue)
  var rawValue: Self.RawValue { get }
}
@inlinable public func == <T>(lhs: T, rhs: T) -> Swift.Bool where T : Swift.RawRepresentable, T.RawValue : Swift.Equatable {
  return lhs.rawValue == rhs.rawValue
}
@inlinable public func != <T>(lhs: T, rhs: T) -> Swift.Bool where T : Swift.RawRepresentable, T.RawValue : Swift.Equatable {
  return lhs.rawValue != rhs.rawValue
}
@inlinable public func != <T>(lhs: T, rhs: T) -> Swift.Bool where T : Swift.Equatable, T : Swift.RawRepresentable, T.RawValue : Swift.Equatable {
  return lhs.rawValue != rhs.rawValue
}
extension RawRepresentable where Self : Swift.Hashable, Self.RawValue : Swift.Hashable {
  @inlinable public var hashValue: Swift.Int {
    get {
    return rawValue.hashValue
  }
  }
  @inlinable public func hash(into hasher: inout Swift.Hasher) {
    hasher.combine(rawValue)
  }
  @inlinable public func _rawHashValue(seed: Swift.Int) -> Swift.Int {
    // In 5.0, this used to return rawValue._rawHashValue(seed: seed).  This was
    // slightly faster, but it interfered with conforming types' ability to
    // customize their hashing. The current definition is equivalent to the
    // default implementation; however, we need to keep the definition to remain
    // ABI compatible with code compiled on 5.0.
    //
    // Note that unless a type provides a custom hash(into:) implementation,
    // this new version returns the same values as the original 5.0 definition,
    // so code that used to work in 5.0 remains working whether or not the
    // original definition was inlined.
    //
    // See https://bugs.swift.org/browse/SR-10734
    var hasher = Hasher(_seed: seed)
    self.hash(into: &hasher)
    return hasher._finalize()
  }
}
public protocol CaseIterable {
  associatedtype AllCases : Swift.Collection = [Self] where Self == Self.AllCases.Element
  static var allCases: Self.AllCases { get }
}
public protocol ExpressibleByNilLiteral {
  init(nilLiteral: ())
}
public protocol _ExpressibleByBuiltinIntegerLiteral {
  init(_builtinIntegerLiteral value: Builtin.IntLiteral)
}
public protocol ExpressibleByIntegerLiteral {
  associatedtype IntegerLiteralType : Swift._ExpressibleByBuiltinIntegerLiteral
  init(integerLiteral value: Self.IntegerLiteralType)
}
public protocol _ExpressibleByBuiltinFloatLiteral {
  init(_builtinFloatLiteral value: Swift._MaxBuiltinFloatType)
}
public protocol ExpressibleByFloatLiteral {
  associatedtype FloatLiteralType : Swift._ExpressibleByBuiltinFloatLiteral
  init(floatLiteral value: Self.FloatLiteralType)
}
public protocol _ExpressibleByBuiltinBooleanLiteral {
  init(_builtinBooleanLiteral value: Builtin.Int1)
}
public protocol ExpressibleByBooleanLiteral {
  associatedtype BooleanLiteralType : Swift._ExpressibleByBuiltinBooleanLiteral
  init(booleanLiteral value: Self.BooleanLiteralType)
}
public protocol _ExpressibleByBuiltinUnicodeScalarLiteral {
  init(_builtinUnicodeScalarLiteral value: Builtin.Int32)
}
public protocol ExpressibleByUnicodeScalarLiteral {
  associatedtype UnicodeScalarLiteralType : Swift._ExpressibleByBuiltinUnicodeScalarLiteral
  init(unicodeScalarLiteral value: Self.UnicodeScalarLiteralType)
}
public protocol _ExpressibleByBuiltinExtendedGraphemeClusterLiteral : Swift._ExpressibleByBuiltinUnicodeScalarLiteral {
  init(_builtinExtendedGraphemeClusterLiteral start: Builtin.RawPointer, utf8CodeUnitCount: Builtin.Word, isASCII: Builtin.Int1)
}
public protocol ExpressibleByExtendedGraphemeClusterLiteral : Swift.ExpressibleByUnicodeScalarLiteral {
  associatedtype ExtendedGraphemeClusterLiteralType : Swift._ExpressibleByBuiltinExtendedGraphemeClusterLiteral
  init(extendedGraphemeClusterLiteral value: Self.ExtendedGraphemeClusterLiteralType)
}
extension ExpressibleByExtendedGraphemeClusterLiteral where Self.ExtendedGraphemeClusterLiteralType == Self.UnicodeScalarLiteralType {
  @_transparent public init(unicodeScalarLiteral value: Self.ExtendedGraphemeClusterLiteralType) {
    self.init(extendedGraphemeClusterLiteral: value)
  }
}
public protocol _ExpressibleByBuiltinStringLiteral : Swift._ExpressibleByBuiltinExtendedGraphemeClusterLiteral {
  init(_builtinStringLiteral start: Builtin.RawPointer, utf8CodeUnitCount: Builtin.Word, isASCII: Builtin.Int1)
}
public protocol ExpressibleByStringLiteral : Swift.ExpressibleByExtendedGraphemeClusterLiteral {
  associatedtype StringLiteralType : Swift._ExpressibleByBuiltinStringLiteral
  init(stringLiteral value: Self.StringLiteralType)
}
extension ExpressibleByStringLiteral where Self.ExtendedGraphemeClusterLiteralType == Self.StringLiteralType {
  @_transparent public init(extendedGraphemeClusterLiteral value: Self.StringLiteralType) {
    self.init(stringLiteral: value)
  }
}
public protocol ExpressibleByArrayLiteral {
  associatedtype ArrayLiteralElement
  init(arrayLiteral elements: Self.ArrayLiteralElement...)
}
public protocol ExpressibleByDictionaryLiteral {
  associatedtype Key
  associatedtype Value
  init(dictionaryLiteral elements: (Self.Key, Self.Value)...)
}
public protocol ExpressibleByStringInterpolation : Swift.ExpressibleByStringLiteral {
  associatedtype StringInterpolation : Swift.StringInterpolationProtocol = Swift.DefaultStringInterpolation where Self.StringLiteralType == Self.StringInterpolation.StringLiteralType
  init(stringInterpolation: Self.StringInterpolation)
}
extension ExpressibleByStringInterpolation where Self.StringInterpolation == Swift.DefaultStringInterpolation {
  public init(stringInterpolation: Swift.DefaultStringInterpolation)
}
public protocol StringInterpolationProtocol {
  associatedtype StringLiteralType : Swift._ExpressibleByBuiltinStringLiteral
  init(literalCapacity: Swift.Int, interpolationCount: Swift.Int)
  mutating func appendLiteral(_ literal: Self.StringLiteralType)
}
public protocol _ExpressibleByColorLiteral {
  init(_colorLiteralRed red: Swift.Float, green: Swift.Float, blue: Swift.Float, alpha: Swift.Float)
}
public protocol _ExpressibleByImageLiteral {
  init(imageLiteralResourceName path: Swift.String)
}
public protocol _ExpressibleByFileReferenceLiteral {
  init(fileReferenceLiteralResourceName path: Swift.String)
}
public protocol _DestructorSafeContainer {
}
@frozen public struct ContiguousArray<Element> : Swift._DestructorSafeContainer {
  @usableFromInline
  internal typealias _Buffer = Swift._ContiguousArrayBuffer<Element>
  @usableFromInline
  internal var _buffer: Swift.ContiguousArray<Element>._Buffer
  @inlinable internal init(_buffer: Swift.ContiguousArray<Element>._Buffer) {
    self._buffer = _buffer
  }
}
extension ContiguousArray {
  @inlinable @_semantics("array.get_count") internal func _getCount() -> Swift.Int {
    return _buffer.immutableCount
  }
  @inlinable @_semantics("array.get_capacity") internal func _getCapacity() -> Swift.Int {
    return _buffer.immutableCapacity
  }
  @inlinable @_semantics("array.make_mutable") internal mutating func _makeMutableAndUnique() {
    if _slowPath(!_buffer.beginCOWMutation()) {
      _buffer = _buffer._consumeAndCreateNew()
    }
  }
  @_alwaysEmitIntoClient @_semantics("array.end_mutation") internal mutating func _endMutation() {
    _buffer.endCOWMutation()
  }
  @inlinable @inline(__always) internal func _checkSubscript_native(_ index: Swift.Int) {
    _buffer._checkValidSubscript(index)
  }
  @_alwaysEmitIntoClient @_semantics("array.check_subscript") internal func _checkSubscript_mutating(_ index: Swift.Int) {
    _buffer._checkValidSubscriptMutating(index)
  }
  @inlinable @_semantics("array.check_index") internal func _checkIndex(_ index: Swift.Int) {
    _precondition(index <= endIndex, "ContiguousArray index is out of range")
    _precondition(index >= startIndex, "Negative ContiguousArray index is out of range")
  }
  @inlinable @_semantics("array.get_element_address") internal func _getElementAddress(_ index: Swift.Int) -> Swift.UnsafeMutablePointer<Element> {
    return _buffer.firstElementAddress + index
  }
}
extension ContiguousArray : Swift._ArrayProtocol {
  @inlinable public var capacity: Swift.Int {
    get {
    return _getCapacity()
  }
  }
  @inlinable public var _owner: Swift.AnyObject? {
    get {
    return _buffer.owner
  }
  }
  @inlinable public var _baseAddressIfContiguous: Swift.UnsafeMutablePointer<Element>? {
    @inline(__always) get { return _buffer.firstElementAddressIfContiguous }
  }
  @inlinable internal var _baseAddress: Swift.UnsafeMutablePointer<Element> {
    get {
    return _buffer.firstElementAddress
  }
  }
}
extension ContiguousArray : Swift.RandomAccessCollection, Swift.MutableCollection {
  public typealias Index = Swift.Int
  public typealias Indices = Swift.Range<Swift.Int>
  public typealias Iterator = Swift.IndexingIterator<Swift.ContiguousArray<Element>>
  @inlinable public var startIndex: Swift.Int {
    get {
    return 0
  }
  }
  public var endIndex: Swift.Int {
    @inlinable get {
      return _getCount()
    }
  }
  @inlinable public func index(after i: Swift.Int) -> Swift.Int {
    // NOTE: this is a manual specialization of index movement for a Strideable
    // index that is required for Array performance.  The optimizer is not
    // capable of creating partial specializations yet.
    // NOTE: Range checks are not performed here, because it is done later by
    // the subscript function.
    return i + 1
  }
  @inlinable public func formIndex(after i: inout Swift.Int) {
    // NOTE: this is a manual specialization of index movement for a Strideable
    // index that is required for Array performance.  The optimizer is not
    // capable of creating partial specializations yet.
    // NOTE: Range checks are not performed here, because it is done later by
    // the subscript function.
    i += 1
  }
  @inlinable public func index(before i: Swift.Int) -> Swift.Int {
    // NOTE: this is a manual specialization of index movement for a Strideable
    // index that is required for Array performance.  The optimizer is not
    // capable of creating partial specializations yet.
    // NOTE: Range checks are not performed here, because it is done later by
    // the subscript function.
    return i - 1
  }
  @inlinable public func formIndex(before i: inout Swift.Int) {
    // NOTE: this is a manual specialization of index movement for a Strideable
    // index that is required for Array performance.  The optimizer is not
    // capable of creating partial specializations yet.
    // NOTE: Range checks are not performed here, because it is done later by
    // the subscript function.
    i -= 1
  }
  @inlinable public func index(_ i: Swift.Int, offsetBy distance: Swift.Int) -> Swift.Int {
    // NOTE: this is a manual specialization of index movement for a Strideable
    // index that is required for Array performance.  The optimizer is not
    // capable of creating partial specializations yet.
    // NOTE: Range checks are not performed here, because it is done later by
    // the subscript function.
    return i + distance
  }
  @inlinable public func index(_ i: Swift.Int, offsetBy distance: Swift.Int, limitedBy limit: Swift.Int) -> Swift.Int? {
    // NOTE: this is a manual specialization of index movement for a Strideable
    // index that is required for Array performance.  The optimizer is not
    // capable of creating partial specializations yet.
    // NOTE: Range checks are not performed here, because it is done later by
    // the subscript function.
    let l = limit - i
    if distance > 0 ? l >= 0 && l < distance : l <= 0 && distance < l {
      return nil
    }
    return i + distance
  }
  @inlinable public func distance(from start: Swift.Int, to end: Swift.Int) -> Swift.Int {
    // NOTE: this is a manual specialization of index movement for a Strideable
    // index that is required for Array performance.  The optimizer is not
    // capable of creating partial specializations yet.
    // NOTE: Range checks are not performed here, because it is done later by
    // the subscript function.
    return end - start
  }
  @inlinable public func _failEarlyRangeCheck(_ index: Swift.Int, bounds: Swift.Range<Swift.Int>) {
    // NOTE: This method is a no-op for performance reasons.
  }
  @inlinable public func _failEarlyRangeCheck(_ range: Swift.Range<Swift.Int>, bounds: Swift.Range<Swift.Int>) {
    // NOTE: This method is a no-op for performance reasons.
  }
  @inlinable public subscript(index: Swift.Int) -> Element {
    get {
      _checkSubscript_native(index)
      return _buffer.getElement(index)
    }
    _modify {
      _makeMutableAndUnique()
      _checkSubscript_mutating(index)
      let address = _buffer.mutableFirstElementAddress + index
      yield &address.pointee
      _endMutation();
    }
  }
  @inlinable public subscript(bounds: Swift.Range<Swift.Int>) -> Swift.ArraySlice<Element> {
    get {
      _checkIndex(bounds.lowerBound)
      _checkIndex(bounds.upperBound)
      return ArraySlice(_buffer: _buffer[bounds])
    }
    set(rhs) {
      _checkIndex(bounds.lowerBound)
      _checkIndex(bounds.upperBound)
      // If the replacement buffer has same identity, and the ranges match,
      // then this was a pinned in-place modification, nothing further needed.
      if self[bounds]._buffer.identity != rhs._buffer.identity
      || bounds != rhs.startIndex..<rhs.endIndex {
        self.replaceSubrange(bounds, with: rhs)
      }
    }
  }
  @inlinable public var count: Swift.Int {
    get {
    return _getCount()
  }
  }
}
extension ContiguousArray : Swift.ExpressibleByArrayLiteral {
  @inlinable public init(arrayLiteral elements: Element...) {
    self.init(_buffer: ContiguousArray(elements)._buffer)
  }
  public typealias ArrayLiteralElement = Element
}
extension ContiguousArray : Swift.RangeReplaceableCollection {
  @inlinable @_semantics("array.init.empty") public init() {
    _buffer = _Buffer()
  }
  @inlinable public init<S>(_ s: S) where Element == S.Element, S : Swift.Sequence {
    self.init(_buffer: s._copyToContiguousArray()._buffer)
  }
  @inlinable @_semantics("array.init") public init(repeating repeatedValue: Element, count: Swift.Int) {
    var p: UnsafeMutablePointer<Element>
    (self, p) = ContiguousArray._allocateUninitialized(count)
    for _ in 0..<count {
      p.initialize(to: repeatedValue)
      p += 1
    }
    _endMutation()
  }
  @usableFromInline
  @inline(never) internal static func _allocateBufferUninitialized(minimumCapacity: Swift.Int) -> Swift.ContiguousArray<Element>._Buffer
  @inlinable internal init(_uninitializedCount count: Swift.Int) {
    _precondition(count >= 0, "Can't construct ContiguousArray with count < 0")
    // Note: Sinking this constructor into an else branch below causes an extra
    // Retain/Release.
    _buffer = _Buffer()
    if count > 0 {
      // Creating a buffer instead of calling reserveCapacity saves doing an
      // unnecessary uniqueness check. We disable inlining here to curb code
      // growth.
      _buffer = ContiguousArray._allocateBufferUninitialized(minimumCapacity: count)
      _buffer.mutableCount = count
    }
    // Can't store count here because the buffer might be pointing to the
    // shared empty array.
  }
  @inlinable @_semantics("array.uninitialized") internal static func _allocateUninitialized(_ count: Swift.Int) -> (Swift.ContiguousArray<Element>, Swift.UnsafeMutablePointer<Element>) {
    let result = ContiguousArray(_uninitializedCount: count)
    return (result, result._buffer.firstElementAddress)
  }
  @inlinable @_semantics("array.mutate_unknown") public mutating func reserveCapacity(_ minimumCapacity: Swift.Int) {
    _reserveCapacityImpl(minimumCapacity: minimumCapacity,
                         growForAppend: false)
    _endMutation()
  }
  @_alwaysEmitIntoClient internal mutating func _reserveCapacityImpl(minimumCapacity: Swift.Int, growForAppend: Swift.Bool) {
    let isUnique = _buffer.beginCOWMutation()
    if _slowPath(!isUnique || _buffer.mutableCapacity < minimumCapacity) {
      _createNewBuffer(bufferIsUnique: isUnique,
                       minimumCapacity: Swift.max(minimumCapacity, _buffer.count),
                       growForAppend: growForAppend)
    }
    _internalInvariant(_buffer.mutableCapacity >= minimumCapacity)
    _internalInvariant(_buffer.mutableCapacity == 0 || _buffer.isUniquelyReferenced())
  }
  @_alwaysEmitIntoClient @inline(never) internal mutating func _createNewBuffer(bufferIsUnique: Swift.Bool, minimumCapacity: Swift.Int, growForAppend: Swift.Bool) {
    _internalInvariant(!bufferIsUnique || _buffer.isUniquelyReferenced())
    _buffer = _buffer._consumeAndCreateNew(bufferIsUnique: bufferIsUnique,
                                           minimumCapacity: minimumCapacity,
                                           growForAppend: growForAppend)
  }
  @inline(never) @inlinable internal mutating func _copyToNewBuffer(oldCount: Swift.Int) {
    let newCount = oldCount + 1
    var newBuffer = _buffer._forceCreateUniqueMutableBuffer(
      countForNewBuffer: oldCount, minNewCapacity: newCount)
    _buffer._arrayOutOfPlaceUpdate(
      &newBuffer, oldCount, 0)
  }
  @inlinable @_semantics("array.make_mutable") internal mutating func _makeUniqueAndReserveCapacityIfNotUnique() {
    if _slowPath(!_buffer.beginCOWMutation()) {
      _createNewBuffer(bufferIsUnique: false,
                       minimumCapacity: count + 1,
                       growForAppend: true)
    }
  }
  @inlinable @_semantics("array.mutate_unknown") internal mutating func _reserveCapacityAssumingUniqueBuffer(oldCount: Swift.Int) {
    // Due to make_mutable hoisting the situation can arise where we hoist
    // _makeMutableAndUnique out of loop and use it to replace
    // _makeUniqueAndReserveCapacityIfNotUnique that preceeds this call. If the
    // array was empty _makeMutableAndUnique does not replace the empty array
    // buffer by a unique buffer (it just replaces it by the empty array
    // singleton).
    // This specific case is okay because we will make the buffer unique in this
    // function because we request a capacity > 0 and therefore _copyToNewBuffer
    // will be called creating a new buffer.
    let capacity = _buffer.mutableCapacity
    _internalInvariant(capacity == 0 || _buffer.isMutableAndUniquelyReferenced())

    if _slowPath(oldCount + 1 > capacity) {
      _createNewBuffer(bufferIsUnique: capacity > 0,
                       minimumCapacity: oldCount + 1,
                       growForAppend: true)
    }
  }
  @inlinable @_semantics("array.mutate_unknown") internal mutating func _appendElementAssumeUniqueAndCapacity(_ oldCount: Swift.Int, newElement: __owned Element) {
    _internalInvariant(_buffer.isMutableAndUniquelyReferenced())
    _internalInvariant(_buffer.mutableCapacity >= _buffer.mutableCount + 1)

    _buffer.mutableCount = oldCount + 1
    (_buffer.mutableFirstElementAddress + oldCount).initialize(to: newElement)
  }
  @inlinable @_semantics("array.append_element") public mutating func append(_ newElement: __owned Element) {
    // Separating uniqueness check and capacity check allows hoisting the
    // uniqueness check out of a loop.
    _makeUniqueAndReserveCapacityIfNotUnique()
    let oldCount = _buffer.mutableCount
    _reserveCapacityAssumingUniqueBuffer(oldCount: oldCount)
    _appendElementAssumeUniqueAndCapacity(oldCount, newElement: newElement)
    _endMutation()
  }
  @inlinable @_semantics("array.append_contentsOf") public mutating func append<S>(contentsOf newElements: __owned S) where Element == S.Element, S : Swift.Sequence {

    defer {
      _endMutation()
    }

    let newElementsCount = newElements.underestimatedCount
    _reserveCapacityImpl(minimumCapacity: self.count + newElementsCount,
                         growForAppend: true)

    let oldCount = _buffer.mutableCount
    let startNewElements = _buffer.mutableFirstElementAddress + oldCount
    let buf = UnsafeMutableBufferPointer(
                start: startNewElements, 
                count: _buffer.mutableCapacity - oldCount)

    var (remainder,writtenUpTo) = buf.initialize(from: newElements)
    
    // trap on underflow from the sequence's underestimate:
    let writtenCount = buf.distance(from: buf.startIndex, to: writtenUpTo)
    _precondition(newElementsCount <= writtenCount, 
      "newElements.underestimatedCount was an overestimate")
    // can't check for overflow as sequences can underestimate

    // This check prevents a data race writing to _swiftEmptyArrayStorage
    if writtenCount > 0 {
      _buffer.mutableCount = _buffer.mutableCount + writtenCount
    }

    if writtenUpTo == buf.endIndex {
      // there may be elements that didn't fit in the existing buffer,
      // append them in slow sequence-only mode
      var newCount = _buffer.mutableCount
      var nextItem = remainder.next()
      while nextItem != nil {
        _reserveCapacityAssumingUniqueBuffer(oldCount: newCount)

        let currentCapacity = _buffer.mutableCapacity
        let base = _buffer.mutableFirstElementAddress

        // fill while there is another item and spare capacity
        while let next = nextItem, newCount < currentCapacity {
          (base + newCount).initialize(to: next)
          newCount += 1
          nextItem = remainder.next()
        }
        _buffer.mutableCount = newCount
      }
    }
  }
  @inlinable @_semantics("array.reserve_capacity_for_append") internal mutating func reserveCapacityForAppend(newElementsCount: Swift.Int) {
    // Ensure uniqueness, mutability, and sufficient storage.  Note that
    // for consistency, we need unique self even if newElements is empty.
    _reserveCapacityImpl(minimumCapacity: self.count + newElementsCount,
                         growForAppend: true)
    _endMutation()
  }
  @inlinable @_semantics("array.mutate_unknown") public mutating func _customRemoveLast() -> Element? {
    _makeMutableAndUnique()
    let newCount = _buffer.mutableCount - 1
    _precondition(newCount >= 0, "Can't removeLast from an empty ContiguousArray")
    let pointer = (_buffer.mutableFirstElementAddress + newCount)
    let element = pointer.move()
    _buffer.mutableCount = newCount
    _endMutation()
    return element
  }
  @discardableResult
  @inlinable @_semantics("array.mutate_unknown") public mutating func remove(at index: Swift.Int) -> Element {
    _makeMutableAndUnique()
    let currentCount = _buffer.mutableCount
    _precondition(index < currentCount, "Index out of range")
    _precondition(index >= 0, "Index out of range")
    let newCount = currentCount - 1
    let pointer = (_buffer.mutableFirstElementAddress + index)
    let result = pointer.move()
    pointer.moveInitialize(from: pointer + 1, count: newCount - index)
    _buffer.mutableCount = newCount
    _endMutation()
    return result
  }
  @inlinable public mutating func insert(_ newElement: __owned Element, at i: Swift.Int) {
    _checkIndex(i)
    self.replaceSubrange(i..<i, with: CollectionOfOne(newElement))
  }
  @inlinable public mutating func removeAll(keepingCapacity keepCapacity: Swift.Bool = false) {
    if !keepCapacity {
      _buffer = _Buffer()
    }
    else {
      self.replaceSubrange(indices, with: EmptyCollection())
    }
  }
  @inlinable public mutating func _withUnsafeMutableBufferPointerIfSupported<R>(_ body: (inout Swift.UnsafeMutableBufferPointer<Element>) throws -> R) rethrows -> R? {
    return try withUnsafeMutableBufferPointer {
      (bufferPointer) -> R in
      return try body(&bufferPointer)
    }
  }
  @inlinable public mutating func withContiguousMutableStorageIfAvailable<R>(_ body: (inout Swift.UnsafeMutableBufferPointer<Element>) throws -> R) rethrows -> R? {
    return try withUnsafeMutableBufferPointer {
      (bufferPointer) -> R in
      return try body(&bufferPointer)
    }
  }
  @inlinable public func withContiguousStorageIfAvailable<R>(_ body: (Swift.UnsafeBufferPointer<Element>) throws -> R) rethrows -> R? {
    return try withUnsafeBufferPointer {
      (bufferPointer) -> R in
      return try body(bufferPointer)
    }
  }
  @inlinable __consuming public func _copyToContiguousArray() -> Swift.ContiguousArray<Element> {
    if let n = _buffer.requestNativeBuffer() {
      return ContiguousArray(_buffer: n)
    }
    return _copyCollectionToContiguousArray(self)
  }
  public typealias SubSequence = Swift.ArraySlice<Element>
}
extension ContiguousArray : Swift.CustomReflectable {
  public var customMirror: Swift.Mirror {
    get
  }
}
extension ContiguousArray : Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible {
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
}
extension ContiguousArray {
  @usableFromInline
  @_transparent internal func _cPointerArgs() -> (Swift.AnyObject?, Swift.UnsafeRawPointer?) {
    let p = _baseAddressIfContiguous
    if _fastPath(p != nil || isEmpty) {
      return (_owner, UnsafeRawPointer(p))
    }
    let n = ContiguousArray(self._buffer)._buffer
    return (n.owner, UnsafeRawPointer(n.firstElementAddress))
  }
}
extension ContiguousArray {
  @_alwaysEmitIntoClient @inlinable public init(unsafeUninitializedCapacity: Swift.Int, initializingWith initializer: (inout Swift.UnsafeMutableBufferPointer<Element>, inout Swift.Int) throws -> Swift.Void) rethrows {
    self = try ContiguousArray(Array(
      _unsafeUninitializedCapacity: unsafeUninitializedCapacity,
      initializingWith: initializer))
  }
  @inlinable public func withUnsafeBufferPointer<R>(_ body: (Swift.UnsafeBufferPointer<Element>) throws -> R) rethrows -> R {
    return try _buffer.withUnsafeBufferPointer(body)
  }
  @_semantics("array.withUnsafeMutableBufferPointer") @inlinable @inline(__always) public mutating func withUnsafeMutableBufferPointer<R>(_ body: (inout Swift.UnsafeMutableBufferPointer<Element>) throws -> R) rethrows -> R {
    _makeMutableAndUnique()
    let count = _buffer.mutableCount

    // Ensure that body can't invalidate the storage or its bounds by
    // moving self into a temporary working array.
    // NOTE: The stack promotion optimization that keys of the
    // "array.withUnsafeMutableBufferPointer" semantics annotation relies on the
    // array buffer not being able to escape in the closure. It can do this
    // because we swap the array buffer in self with an empty buffer here. Any
    // escape via the address of self in the closure will therefore escape the
    // empty array.

    var work = ContiguousArray()
    (work, self) = (self, work)

    // Create an UnsafeBufferPointer over work that we can pass to body
    let pointer = work._buffer.mutableFirstElementAddress
    var inoutBufferPointer = UnsafeMutableBufferPointer(
      start: pointer, count: count)

    // Put the working array back before returning.
    defer {
      _precondition(
        inoutBufferPointer.baseAddress == pointer &&
        inoutBufferPointer.count == count,
        "ContiguousArray withUnsafeMutableBufferPointer: replacing the buffer is not allowed")

      (work, self) = (self, work)
      _endMutation()
    }

    // Invoke the body.
    return try body(&inoutBufferPointer)
  }
  @inlinable __consuming public func _copyContents(initializing buffer: Swift.UnsafeMutableBufferPointer<Element>) -> (Swift.ContiguousArray<Element>.Iterator, Swift.UnsafeMutableBufferPointer<Element>.Index) {

    guard !self.isEmpty else { return (makeIterator(),buffer.startIndex) }

    // It is not OK for there to be no pointer/not enough space, as this is
    // a precondition and Array never lies about its count.
    guard var p = buffer.baseAddress
      else { _preconditionFailure("Attempt to copy contents into nil buffer pointer") }
    _precondition(self.count <= buffer.count, 
      "Insufficient space allocated to copy array contents")

    if let s = _baseAddressIfContiguous {
      p.initialize(from: s, count: self.count)
      // Need a _fixLifetime bracketing the _baseAddressIfContiguous getter
      // and all uses of the pointer it returns:
      _fixLifetime(self._owner)
    } else {
      for x in self {
        p.initialize(to: x)
        p += 1
      }
    }

    var it = IndexingIterator(_elements: self)
    it._position = endIndex
    return (it,buffer.index(buffer.startIndex, offsetBy: self.count))
  }
}
extension ContiguousArray {
  @inlinable @_semantics("array.mutate_unknown") public mutating func replaceSubrange<C>(_ subrange: Swift.Range<Swift.Int>, with newElements: __owned C) where Element == C.Element, C : Swift.Collection {
    _precondition(subrange.lowerBound >= self._buffer.startIndex,
      "ContiguousArray replace: subrange start is negative")

    _precondition(subrange.upperBound <= _buffer.endIndex,
      "ContiguousArray replace: subrange extends past the end")

    let eraseCount = subrange.count
    let insertCount = newElements.count
    let growth = insertCount - eraseCount

    _reserveCapacityImpl(minimumCapacity: self.count + growth,
                         growForAppend: true)
    _buffer.replaceSubrange(subrange, with: insertCount, elementsOf: newElements)
    _endMutation()
  }
}
extension ContiguousArray : Swift.Equatable where Element : Swift.Equatable {
  @inlinable public static func == (lhs: Swift.ContiguousArray<Element>, rhs: Swift.ContiguousArray<Element>) -> Swift.Bool {
    let lhsCount = lhs.count
    if lhsCount != rhs.count {
      return false
    }

    // Test referential equality.
    if lhsCount == 0 || lhs._buffer.identity == rhs._buffer.identity {
      return true
    }


    _internalInvariant(lhs.startIndex == 0 && rhs.startIndex == 0)
    _internalInvariant(lhs.endIndex == lhsCount && rhs.endIndex == lhsCount)

    // We know that lhs.count == rhs.count, compare element wise.
    for idx in 0..<lhsCount {
      if lhs[idx] != rhs[idx] {
        return false
      }
    }

    return true
  }
}
extension ContiguousArray : Swift.Hashable where Element : Swift.Hashable {
  @inlinable public func hash(into hasher: inout Swift.Hasher) {
    hasher.combine(count) // discriminator
    for element in self {
      hasher.combine(element)
    }
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension ContiguousArray {
  @inlinable public mutating func withUnsafeMutableBytes<R>(_ body: (Swift.UnsafeMutableRawBufferPointer) throws -> R) rethrows -> R {
    return try self.withUnsafeMutableBufferPointer {
      return try body(UnsafeMutableRawBufferPointer($0))
    }
  }
  @inlinable public func withUnsafeBytes<R>(_ body: (Swift.UnsafeRawBufferPointer) throws -> R) rethrows -> R {
    return try self.withUnsafeBufferPointer {
      try body(UnsafeRawBufferPointer($0))
    }
  }
}
@usableFromInline
internal protocol _HasContiguousBytes {
  func withUnsafeBytes<R>(_ body: (Swift.UnsafeRawBufferPointer) throws -> R) rethrows -> R
  var _providesContiguousBytesNoCopy: Swift.Bool { get }
}
extension _HasContiguousBytes {
  @inlinable internal var _providesContiguousBytesNoCopy: Swift.Bool {
    @inline(__always) get { return true }
  }
}
extension Array : Swift._HasContiguousBytes {
  @inlinable internal var _providesContiguousBytesNoCopy: Swift.Bool {
    @inline(__always) get {
      return _buffer._isNative
    }
  }
}
extension ContiguousArray : Swift._HasContiguousBytes {
}
extension UnsafeBufferPointer : Swift._HasContiguousBytes {
  @inlinable @inline(__always) internal func withUnsafeBytes<R>(_ body: (Swift.UnsafeRawBufferPointer) throws -> R) rethrows -> R {
    let ptr = UnsafeRawPointer(self.baseAddress)
    let len = self.count &* MemoryLayout<Element>.stride
    return try body(UnsafeRawBufferPointer(start: ptr, count: len))
  }
}
extension UnsafeMutableBufferPointer : Swift._HasContiguousBytes {
  @inlinable @inline(__always) internal func withUnsafeBytes<R>(_ body: (Swift.UnsafeRawBufferPointer) throws -> R) rethrows -> R {
    let ptr = UnsafeRawPointer(self.baseAddress)
    let len = self.count &* MemoryLayout<Element>.stride
    return try body(UnsafeRawBufferPointer(start: ptr, count: len))
  }
}
extension UnsafeRawBufferPointer : Swift._HasContiguousBytes {
  @inlinable @inline(__always) internal func withUnsafeBytes<R>(_ body: (Swift.UnsafeRawBufferPointer) throws -> R) rethrows -> R {
    return try body(self)
  }
}
extension UnsafeMutableRawBufferPointer : Swift._HasContiguousBytes {
  @inlinable @inline(__always) internal func withUnsafeBytes<R>(_ body: (Swift.UnsafeRawBufferPointer) throws -> R) rethrows -> R {
    return try body(UnsafeRawBufferPointer(self))
  }
}
extension String : Swift._HasContiguousBytes {
  @inlinable internal var _providesContiguousBytesNoCopy: Swift.Bool {
    @inline(__always) get { return self._guts.isFastUTF8 }
  }
  @inlinable @inline(__always) internal func withUnsafeBytes<R>(_ body: (Swift.UnsafeRawBufferPointer) throws -> R) rethrows -> R {
    var copy = self
    return try copy.withUTF8 { return try body(UnsafeRawBufferPointer($0)) }
  }
}
extension Substring : Swift._HasContiguousBytes {
  @inlinable internal var _providesContiguousBytesNoCopy: Swift.Bool {
    @inline(__always) get { return self._wholeGuts.isFastUTF8 }
  }
  @inlinable @inline(__always) internal func withUnsafeBytes<R>(_ body: (Swift.UnsafeRawBufferPointer) throws -> R) rethrows -> R {
    var copy = self
    return try copy.withUTF8 { return try body(UnsafeRawBufferPointer($0)) }
  }
}
@frozen public struct ClosedRange<Bound> where Bound : Swift.Comparable {
  public let lowerBound: Bound
  public let upperBound: Bound
  @_alwaysEmitIntoClient @inline(__always) internal init(_uncheckedBounds bounds: (lower: Bound, upper: Bound)) {
    self.lowerBound = bounds.lower
    self.upperBound = bounds.upper
  }
  @inlinable public init(uncheckedBounds bounds: (lower: Bound, upper: Bound)) {
    _debugPrecondition(bounds.lower <= bounds.upper,
      "ClosedRange requires lowerBound <= upperBound")
    self.init(_uncheckedBounds: (lower: bounds.lower, upper: bounds.upper))
  }
}
extension ClosedRange {
  @inlinable public var isEmpty: Swift.Bool {
    get {
    return false
  }
  }
}
extension ClosedRange : Swift.RangeExpression {
  @inlinable public func relative<C>(to collection: C) -> Swift.Range<Bound> where Bound == C.Index, C : Swift.Collection {
    return Range(
      _uncheckedBounds: (
        lower: lowerBound,
        upper: collection.index(after: self.upperBound)))
  }
  @inlinable public func contains(_ element: Bound) -> Swift.Bool {
    return element >= self.lowerBound && element <= self.upperBound
  }
}
extension ClosedRange : Swift.Sequence where Bound : Swift.Strideable, Bound.Stride : Swift.SignedInteger {
  public typealias Element = Bound
  public typealias Iterator = Swift.IndexingIterator<Swift.ClosedRange<Bound>>
}
extension ClosedRange where Bound : Swift.Strideable, Bound.Stride : Swift.SignedInteger {
  @frozen public enum Index {
    case pastEnd
    case inRange(Bound)
  }
}
extension ClosedRange.Index : Swift.Comparable {
  @inlinable public static func == (lhs: Swift.ClosedRange<Bound>.Index, rhs: Swift.ClosedRange<Bound>.Index) -> Swift.Bool {
    switch (lhs, rhs) {
    case (.inRange(let l), .inRange(let r)):
      return l == r
    case (.pastEnd, .pastEnd):
      return true
    default:
      return false
    }
  }
  @inlinable public static func < (lhs: Swift.ClosedRange<Bound>.Index, rhs: Swift.ClosedRange<Bound>.Index) -> Swift.Bool {
    switch (lhs, rhs) {
    case (.inRange(let l), .inRange(let r)):
      return l < r
    case (.inRange, .pastEnd):
      return true
    default:
      return false
    }
  }
}
extension ClosedRange.Index : Swift.Hashable where Bound : Swift.Hashable {
  @inlinable public func hash(into hasher: inout Swift.Hasher) {
    switch self {
    case .inRange(let value):
      hasher.combine(0 as Int8)
      hasher.combine(value)
    case .pastEnd:
      hasher.combine(1 as Int8)
    }
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension ClosedRange : Swift.Collection, Swift.BidirectionalCollection, Swift.RandomAccessCollection where Bound : Swift.Strideable, Bound.Stride : Swift.SignedInteger {
  public typealias SubSequence = Swift.Slice<Swift.ClosedRange<Bound>>
  @inlinable public var startIndex: Swift.ClosedRange<Bound>.Index {
    get {
    return .inRange(lowerBound)
  }
  }
  @inlinable public var endIndex: Swift.ClosedRange<Bound>.Index {
    get {
    return .pastEnd
  }
  }
  @inlinable public func index(after i: Swift.ClosedRange<Bound>.Index) -> Swift.ClosedRange<Bound>.Index {
    switch i {
    case .inRange(let x):
      return x == upperBound
        ? .pastEnd
        : .inRange(x.advanced(by: 1))
    case .pastEnd: 
      _preconditionFailure("Incrementing past end index")
    }
  }
  @inlinable public func index(before i: Swift.ClosedRange<Bound>.Index) -> Swift.ClosedRange<Bound>.Index {
    switch i {
    case .inRange(let x):
      _precondition(x > lowerBound, "Incrementing past start index")
      return .inRange(x.advanced(by: -1))
    case .pastEnd: 
      _precondition(upperBound >= lowerBound, "Incrementing past start index")
      return .inRange(upperBound)
    }
  }
  @inlinable public func index(_ i: Swift.ClosedRange<Bound>.Index, offsetBy distance: Swift.Int) -> Swift.ClosedRange<Bound>.Index {
    switch i {
    case .inRange(let x):
      let d = x.distance(to: upperBound)
      if distance <= d {
        let newPosition = x.advanced(by: numericCast(distance))
        _precondition(newPosition >= lowerBound,
          "Advancing past start index")
        return .inRange(newPosition)
      }
      if d - -1 == distance { return .pastEnd }
      _preconditionFailure("Advancing past end index")
    case .pastEnd:
      if distance == 0 {
        return i
      } 
      if distance < 0 {
        return index(.inRange(upperBound), offsetBy: numericCast(distance + 1))
      }
      _preconditionFailure("Advancing past end index")
    }
  }
  @inlinable public func distance(from start: Swift.ClosedRange<Bound>.Index, to end: Swift.ClosedRange<Bound>.Index) -> Swift.Int {
    switch (start, end) {
    case let (.inRange(left), .inRange(right)):
      // in range <--> in range
      return numericCast(left.distance(to: right))
    case let (.inRange(left), .pastEnd):
      // in range --> end
      return numericCast(1 + left.distance(to: upperBound))
    case let (.pastEnd, .inRange(right)):
      // in range <-- end
      return numericCast(upperBound.distance(to: right) - 1)
    case (.pastEnd, .pastEnd):
      // end <--> end
      return 0
    }
  }
  @inlinable public subscript(position: Swift.ClosedRange<Bound>.Index) -> Bound {
    get {
    // FIXME: swift-3-indexing-model: range checks and tests.
    switch position {
    case .inRange(let x): return x
    case .pastEnd: _preconditionFailure("Index out of range")
    }
  }
  }
  @inlinable public subscript(bounds: Swift.Range<Swift.ClosedRange<Bound>.Index>) -> Swift.Slice<Swift.ClosedRange<Bound>> {
    get {
    return Slice(base: self, bounds: bounds)
  }
  }
  @inlinable public func _customContainsEquatableElement(_ element: Bound) -> Swift.Bool? {
    return lowerBound <= element && element <= upperBound
  }
  @inlinable public func _customIndexOfEquatableElement(_ element: Bound) -> Swift.ClosedRange<Bound>.Index?? {
    return lowerBound <= element && element <= upperBound
              ? .inRange(element) : nil
  }
  @inlinable public func _customLastIndexOfEquatableElement(_ element: Bound) -> Swift.ClosedRange<Bound>.Index?? {
    // The first and last elements are the same because each element is unique.
    return _customIndexOfEquatableElement(element)
  }
  public typealias Indices = Swift.DefaultIndices<Swift.ClosedRange<Bound>>
}
extension Comparable {
  @_transparent public static func ... (minimum: Self, maximum: Self) -> Swift.ClosedRange<Self> {
    _precondition(
      minimum <= maximum, "Range requires lowerBound <= upperBound")
    return ClosedRange(_uncheckedBounds: (lower: minimum, upper: maximum))
  }
}
extension ClosedRange : Swift.Equatable {
  @inlinable public static func == (lhs: Swift.ClosedRange<Bound>, rhs: Swift.ClosedRange<Bound>) -> Swift.Bool {
    return lhs.lowerBound == rhs.lowerBound && lhs.upperBound == rhs.upperBound
  }
}
extension ClosedRange : Swift.Hashable where Bound : Swift.Hashable {
  @inlinable public func hash(into hasher: inout Swift.Hasher) {
    hasher.combine(lowerBound)
    hasher.combine(upperBound)
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension ClosedRange : Swift.CustomStringConvertible {
  @inlinable public var description: Swift.String {
    get {
    return "\(lowerBound)...\(upperBound)"
  }
  }
}
extension ClosedRange : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
extension ClosedRange : Swift.CustomReflectable {
  public var customMirror: Swift.Mirror {
    get
  }
}
extension ClosedRange {
  @inlinable @inline(__always) public func clamped(to limits: Swift.ClosedRange<Bound>) -> Swift.ClosedRange<Bound> {
    let lower =         
      limits.lowerBound > self.lowerBound ? limits.lowerBound
          : limits.upperBound < self.lowerBound ? limits.upperBound
          : self.lowerBound
    let upper =
      limits.upperBound < self.upperBound ? limits.upperBound
          : limits.lowerBound > self.upperBound ? limits.lowerBound
          : self.upperBound
    return ClosedRange(_uncheckedBounds: (lower: lower, upper: upper))
  }
}
extension ClosedRange where Bound : Swift.Strideable, Bound.Stride : Swift.SignedInteger {
  @inlinable public init(_ other: Swift.Range<Bound>) {
    _precondition(!other.isEmpty, "Can't form an empty closed range")
    let upperBound = other.upperBound.advanced(by: -1)
    self.init(_uncheckedBounds: (lower: other.lowerBound, upper: upperBound))
  }
}
extension ClosedRange {
  @inlinable public func overlaps(_ other: Swift.ClosedRange<Bound>) -> Swift.Bool {
    // Disjoint iff the other range is completely before or after our range.
    // Unlike a `Range`, a `ClosedRange` can *not* be empty, so no check for
    // that case is needed here.
    let isDisjoint = other.upperBound < self.lowerBound
      || self.upperBound < other.lowerBound
    return !isDisjoint
  }
  @inlinable public func overlaps(_ other: Swift.Range<Bound>) -> Swift.Bool {
    return other.overlaps(self)
  }
}
public typealias CountableClosedRange<Bound> = Swift.ClosedRange<Bound> where Bound : Swift.Strideable, Bound.Stride : Swift.SignedInteger
extension ClosedRange : Swift.Decodable where Bound : Swift.Decodable {
  public init(from decoder: Swift.Decoder) throws
}
extension ClosedRange : Swift.Encodable where Bound : Swift.Encodable {
  public func encode(to encoder: Swift.Encoder) throws
}
@objc @usableFromInline
@_fixed_layout @_objc_non_lazy_realization final internal class __EmptyArrayStorage : Swift.__ContiguousArrayStorageBase {
  @inlinable @nonobjc internal init(_doNotCallMe: ()) {
    _internalInvariantFailure("creating instance of __EmptyArrayStorage")
  }
  @inlinable override final internal func canStoreElements(ofDynamicType _: Any.Type) -> Swift.Bool {
    return false
  }
  @inlinable override final internal var staticElementType: Any.Type {
    get {
    return Void.self
  }
  }
  @inlinable override internal init(_doNotCallMeBase: ())
  @objc @usableFromInline
  deinit
}
@inlinable internal var _emptyArrayStorage: Swift.__EmptyArrayStorage {
  get {
  return Builtin.bridgeFromRawPointer(
    Builtin.addressof(&_swiftEmptyArrayStorage))
}
}
@_inheritsConvenienceInitializers @usableFromInline
@_fixed_layout final internal class _ContiguousArrayStorage<Element> : Swift.__ContiguousArrayStorageBase {
  @objc @inlinable deinit {
    _elementPointer.deinitialize(count: countAndCapacity.count)
    _fixLifetime(self)
  }
  @inlinable override final internal func canStoreElements(ofDynamicType proposedElementType: Any.Type) -> Swift.Bool {
    return proposedElementType is Element.Type
  }
  @inlinable override final internal var staticElementType: Any.Type {
    get {
    return Element.self
  }
  }
  @inlinable final internal var _elementPointer: Swift.UnsafeMutablePointer<Element> {
    get {
    return UnsafeMutablePointer(Builtin.projectTailElems(self, Element.self))
  }
  }
  @inlinable override internal init(_doNotCallMeBase: ())
}
@usableFromInline
@frozen internal struct _ContiguousArrayBuffer<Element> : Swift._ArrayBufferProtocol {
  @inlinable internal init(_uninitializedCount uninitializedCount: Swift.Int, minimumCapacity: Swift.Int) {
    let realMinimumCapacity = Swift.max(uninitializedCount, minimumCapacity)
    if realMinimumCapacity == 0 {
      self = _ContiguousArrayBuffer<Element>()
    }
    else {
      _storage = Builtin.allocWithTailElems_1(
         _ContiguousArrayStorage<Element>.self,
         realMinimumCapacity._builtinWordValue, Element.self)

      let storageAddr = UnsafeMutableRawPointer(Builtin.bridgeToRawPointer(_storage))
      if let allocSize = _mallocSize(ofAllocation: storageAddr) {
        let endAddr = storageAddr + allocSize
        let realCapacity = endAddr.assumingMemoryBound(to: Element.self) - firstElementAddress
        _initStorageHeader(
          count: uninitializedCount, capacity: realCapacity)
      } else {
        _initStorageHeader(
          count: uninitializedCount, capacity: realMinimumCapacity)
      }
    }
  }
  @inlinable internal init(count: Swift.Int, storage: Swift._ContiguousArrayStorage<Element>) {
    _storage = storage

    _initStorageHeader(count: count, capacity: count)
  }
  @inlinable internal init(_ storage: Swift.__ContiguousArrayStorageBase) {
    _storage = storage
  }
  @inlinable internal func _initStorageHeader(count: Swift.Int, capacity: Swift.Int) {
    let verbatim = _isBridgedVerbatimToObjectiveC(Element.self)

    // We can initialize by assignment because _ArrayBody is a trivial type,
    // i.e. contains no references.
    _storage.countAndCapacity = _ArrayBody(
      count: count,
      capacity: capacity,
      elementTypeIsBridgedVerbatim: verbatim)
  }
  @inlinable internal var arrayPropertyIsNativeTypeChecked: Swift.Bool {
    get {
    return true
  }
  }
  @inlinable internal var firstElementAddress: Swift.UnsafeMutablePointer<Element> {
    get {
    return UnsafeMutablePointer(Builtin.projectTailElems(_storage,
                                                         Element.self))
  }
  }
  @_alwaysEmitIntoClient internal var mutableFirstElementAddress: Swift.UnsafeMutablePointer<Element> {
    get {
    return UnsafeMutablePointer(Builtin.projectTailElems(mutableOrEmptyStorage,
                                                         Element.self))
  }
  }
  @inlinable internal var firstElementAddressIfContiguous: Swift.UnsafeMutablePointer<Element>? {
    get {
    return firstElementAddress
  }
  }
  @inlinable internal func withUnsafeBufferPointer<R>(_ body: (Swift.UnsafeBufferPointer<Element>) throws -> R) rethrows -> R {
    defer { _fixLifetime(self) }
    return try body(UnsafeBufferPointer(start: firstElementAddress,
      count: count))
  }
  @inlinable internal mutating func withUnsafeMutableBufferPointer<R>(_ body: (Swift.UnsafeMutableBufferPointer<Element>) throws -> R) rethrows -> R {
    defer { _fixLifetime(self) }
    return try body(
      UnsafeMutableBufferPointer(start: firstElementAddress, count: count))
  }
  @inlinable internal init() {
    _storage = _emptyArrayStorage
  }
  @inlinable internal init(_buffer buffer: Swift._ContiguousArrayBuffer<Element>, shiftedToStartIndex: Swift.Int) {
    _internalInvariant(shiftedToStartIndex == 0, "shiftedToStartIndex must be 0")
    self = buffer
  }
  @inlinable internal mutating func requestUniqueMutableBackingBuffer(minimumCapacity: Swift.Int) -> Swift._ContiguousArrayBuffer<Element>? {
    if _fastPath(isUniquelyReferenced() && capacity >= minimumCapacity) {
      return self
    }
    return nil
  }
  @inlinable internal mutating func isMutableAndUniquelyReferenced() -> Swift.Bool {
    return isUniquelyReferenced()
  }
  @inlinable internal func requestNativeBuffer() -> Swift._ContiguousArrayBuffer<Element>? {
    return self
  }
  @inlinable @inline(__always) internal func getElement(_ i: Swift.Int) -> Element {
    _internalInvariant(i >= 0 && i < count, "Array index out of range")
    let addr = UnsafePointer<Element>(
      Builtin.projectTailElems(immutableStorage, Element.self))
    return addr[i]
  }
  @_alwaysEmitIntoClient @inline(__always) internal var immutableStorage: Swift.__ContiguousArrayStorageBase {
    get {
    return Builtin.COWBufferForReading(_storage)
  }
  }
  @_alwaysEmitIntoClient @inline(__always) internal var mutableStorage: Swift.__ContiguousArrayStorageBase {
    get {
    return _storage
  }
  }
  @_alwaysEmitIntoClient @inline(__always) internal var mutableOrEmptyStorage: Swift.__ContiguousArrayStorageBase {
    get {
    return _storage
  }
  }
  @inlinable internal subscript(i: Swift.Int) -> Element {
    @inline(__always) get {
      return getElement(i)
    }
    @inline(__always) nonmutating set {
      _internalInvariant(i >= 0 && i < count, "Array index out of range")

      // FIXME: Manually swap because it makes the ARC optimizer happy.  See
      // <rdar://problem/16831852> check retain/release order
      // firstElementAddress[i] = newValue
      var nv = newValue
      let tmp = nv
      nv = firstElementAddress[i]
      firstElementAddress[i] = tmp
    }
  }
  @inlinable internal var count: Swift.Int {
    get {
      return _storage.countAndCapacity.count
    }
    nonmutating set {
      _internalInvariant(newValue >= 0)

      _internalInvariant(
        newValue <= mutableCapacity,
        "Can't grow an array buffer past its capacity")

      mutableStorage.countAndCapacity.count = newValue
    }
  }
  @_alwaysEmitIntoClient @inline(__always) internal var immutableCount: Swift.Int {
    get {
    return immutableStorage.countAndCapacity.count
  }
  }
  @_alwaysEmitIntoClient internal var mutableCount: Swift.Int {
    @inline(__always) get {
      return mutableOrEmptyStorage.countAndCapacity.count
    }
    @inline(__always) nonmutating set {
      _internalInvariant(newValue >= 0)

      _internalInvariant(
        newValue <= mutableCapacity,
        "Can't grow an array buffer past its capacity")

      mutableStorage.countAndCapacity.count = newValue
    }
  }
  @inlinable @inline(__always) internal func _checkValidSubscript(_ index: Swift.Int) {
    _precondition(
      (index >= 0) && (index < immutableCount),
      "Index out of range"
    )
  }
  @_alwaysEmitIntoClient @inline(__always) internal func _checkValidSubscriptMutating(_ index: Swift.Int) {
    _precondition(
      (index >= 0) && (index < mutableCount),
      "Index out of range"
    )
  }
  @inlinable internal var capacity: Swift.Int {
    get {
    return _storage.countAndCapacity.capacity
  }
  }
  @_alwaysEmitIntoClient @inline(__always) internal var immutableCapacity: Swift.Int {
    get {
    return immutableStorage.countAndCapacity.capacity
  }
  }
  @_alwaysEmitIntoClient @inline(__always) internal var mutableCapacity: Swift.Int {
    get {
    return mutableOrEmptyStorage.countAndCapacity.capacity
  }
  }
  @discardableResult
  @inlinable __consuming internal func _copyContents(subRange bounds: Swift.Range<Swift.Int>, initializing target: Swift.UnsafeMutablePointer<Element>) -> Swift.UnsafeMutablePointer<Element> {
    _internalInvariant(bounds.lowerBound >= 0)
    _internalInvariant(bounds.upperBound >= bounds.lowerBound)
    _internalInvariant(bounds.upperBound <= count)

    let initializedCount = bounds.upperBound - bounds.lowerBound
    target.initialize(
      from: firstElementAddress + bounds.lowerBound, count: initializedCount)
    _fixLifetime(owner)
    return target + initializedCount
  }
  __consuming public func _copyContents(initializing buffer: Swift.UnsafeMutableBufferPointer<Element>) -> (Swift.IndexingIterator<Swift._ContiguousArrayBuffer<Element>>, Swift.UnsafeMutableBufferPointer<Element>.Index)
  @inlinable internal subscript(bounds: Swift.Range<Swift.Int>) -> Swift._SliceBuffer<Element> {
    get {
      return _SliceBuffer(
        owner: _storage,
        subscriptBaseAddress: firstElementAddress,
        indices: bounds,
        hasNativeBuffer: true)
    }
    set {
      fatalError("not implemented")
    }
  }
  @inlinable internal mutating func isUniquelyReferenced() -> Swift.Bool {
    return _isUnique(&_storage)
  }
  @_alwaysEmitIntoClient internal mutating func beginCOWMutation() -> Swift.Bool {
    if Bool(Builtin.beginCOWMutation(&_storage)) {
      return true
    }
    return false;
  }
  @_alwaysEmitIntoClient @inline(__always) internal mutating func endCOWMutation() {
    Builtin.endCOWMutation(&_storage)
  }
  @_alwaysEmitIntoClient @inline(never) @_semantics("optimize.sil.specialize.owned2guarantee.never") __consuming internal func _consumeAndCreateNew() -> Swift._ContiguousArrayBuffer<Element> {
    return _consumeAndCreateNew(bufferIsUnique: false,
                                minimumCapacity: count,
                                growForAppend: false)
  }
  @_alwaysEmitIntoClient @inline(never) @_semantics("optimize.sil.specialize.owned2guarantee.never") __consuming internal func _consumeAndCreateNew(bufferIsUnique: Swift.Bool, minimumCapacity: Swift.Int, growForAppend: Swift.Bool) -> Swift._ContiguousArrayBuffer<Element> {
    let newCapacity = _growArrayCapacity(oldCapacity: capacity,
                                         minimumCapacity: minimumCapacity,
                                         growForAppend: growForAppend)
    let c = count
    _internalInvariant(newCapacity >= c)
    
    let newBuffer = _ContiguousArrayBuffer<Element>(
      _uninitializedCount: c, minimumCapacity: newCapacity)

    if bufferIsUnique {
      // As an optimization, if the original buffer is unique, we can just move
      // the elements instead of copying.
      let dest = newBuffer.mutableFirstElementAddress
      dest.moveInitialize(from: firstElementAddress,
                          count: c)
      mutableCount = 0
    } else {
      _copyContents(
        subRange: 0..<c,
        initializing: newBuffer.mutableFirstElementAddress)
    }
    return newBuffer
  }
  @usableFromInline
  __consuming internal func _asCocoaArray() -> Swift.AnyObject
  @inlinable internal var owner: Swift.AnyObject {
    get {
    return _storage
  }
  }
  @inlinable internal var nativeOwner: Swift.AnyObject {
    get {
    return _storage
  }
  }
  @inlinable internal var identity: Swift.UnsafeRawPointer {
    get {
    return UnsafeRawPointer(firstElementAddress)
  }
  }
  @inlinable internal func canStoreElements(ofDynamicType proposedElementType: Any.Type) -> Swift.Bool {
    return _storage.canStoreElements(ofDynamicType: proposedElementType)
  }
  @inlinable internal func storesOnlyElementsOfType<U>(_: U.Type) -> Swift.Bool {
    _internalInvariant(_isClassOrObjCExistential(U.self))

    if _fastPath(_storage.staticElementType is U.Type) {
      // Done in O(1)
      return true
    }

    // Check the elements
    for x in self {
      if !(x is U) {
        return false
      }
    }
    return true
  }
  @usableFromInline
  internal var _storage: Swift.__ContiguousArrayStorageBase
}
@inlinable internal func += <Element, C>(lhs: inout Swift._ContiguousArrayBuffer<Element>, rhs: __owned C) where Element == C.Element, C : Swift.Collection {

  let oldCount = lhs.count
  let newCount = oldCount + rhs.count

  let buf: UnsafeMutableBufferPointer<Element>
  
  if _fastPath(newCount <= lhs.capacity) {
    buf = UnsafeMutableBufferPointer(
      start: lhs.firstElementAddress + oldCount,
      count: rhs.count)
    lhs.mutableCount = newCount
  }
  else {
    var newLHS = _ContiguousArrayBuffer<Element>(
      _uninitializedCount: newCount,
      minimumCapacity: _growArrayCapacity(lhs.capacity))

    newLHS.firstElementAddress.moveInitialize(
      from: lhs.firstElementAddress, count: oldCount)
    lhs.mutableCount = 0
    (lhs, newLHS) = (newLHS, lhs)
    buf = UnsafeMutableBufferPointer(
      start: lhs.firstElementAddress + oldCount,
      count: rhs.count)
  }

  var (remainders,writtenUpTo) = buf.initialize(from: rhs)

  // ensure that exactly rhs.count elements were written
  _precondition(remainders.next() == nil, "rhs underreported its count")
  _precondition(writtenUpTo == buf.endIndex, "rhs overreported its count")    
}
extension _ContiguousArrayBuffer : Swift.RandomAccessCollection {
  @inlinable internal var startIndex: Swift.Int {
    get {
    return 0
  }
  }
  @inlinable internal var endIndex: Swift.Int {
    get {
    return count
  }
  }
  @usableFromInline
  internal typealias Indices = Swift.Range<Swift.Int>
  @usableFromInline
  internal typealias Index = Swift.Int
  @usableFromInline
  internal typealias Iterator = Swift.IndexingIterator<Swift._ContiguousArrayBuffer<Element>>
  @usableFromInline
  internal typealias SubSequence = Swift._SliceBuffer<Element>
}
extension Sequence {
  @inlinable __consuming public func _copyToContiguousArray() -> Swift.ContiguousArray<Self.Element> {
    return _copySequenceToContiguousArray(self)
  }
}
@inlinable internal func _copySequenceToContiguousArray<S>(_ source: S) -> Swift.ContiguousArray<S.Element> where S : Swift.Sequence {
  let initialCapacity = source.underestimatedCount
  var builder =
    _UnsafePartiallyInitializedContiguousArrayBuffer<S.Element>(
      initialCapacity: initialCapacity)

  var iterator = source.makeIterator()

  // FIXME(performance): use _copyContents(initializing:).

  // Add elements up to the initial capacity without checking for regrowth.
  for _ in 0..<initialCapacity {
    builder.addWithExistingCapacity(iterator.next()!)
  }

  // Add remaining elements, if any.
  while let element = iterator.next() {
    builder.add(element)
  }

  return builder.finish()
}
extension Collection {
  @inlinable __consuming public func _copyToContiguousArray() -> Swift.ContiguousArray<Self.Element> {
    return _copyCollectionToContiguousArray(self)
  }
}
extension _ContiguousArrayBuffer {
  @inlinable __consuming internal func _copyToContiguousArray() -> Swift.ContiguousArray<Element> {
    return ContiguousArray(_buffer: self)
  }
}
@inlinable internal func _copyCollectionToContiguousArray<C>(_ source: C) -> Swift.ContiguousArray<C.Element> where C : Swift.Collection {
  let count = source.count
  if count == 0 {
    return ContiguousArray()
  }

  var result = _ContiguousArrayBuffer<C.Element>(
    _uninitializedCount: count,
    minimumCapacity: 0)

  let p = UnsafeMutableBufferPointer(
    start: result.firstElementAddress,
    count: count)
  var (itr, end) = source._copyContents(initializing: p)

  _debugPrecondition(itr.next() == nil,
    "invalid Collection: more than 'count' elements in collection")
  // We also have to check the evil shrink case in release builds, because
  // it can result in uninitialized array elements and therefore undefined
  // behavior.
  _precondition(end == p.endIndex,
    "invalid Collection: less than 'count' elements in collection")

  result.endCOWMutation()
  return ContiguousArray(_buffer: result)
}
@usableFromInline
@frozen internal struct _UnsafePartiallyInitializedContiguousArrayBuffer<Element> {
  @usableFromInline
  internal var result: Swift._ContiguousArrayBuffer<Element>
  @usableFromInline
  internal var p: Swift.UnsafeMutablePointer<Element>
  @usableFromInline
  internal var remainingCapacity: Swift.Int
  @inlinable @inline(__always) internal init(initialCapacity: Swift.Int) {
    if initialCapacity == 0 {
      result = _ContiguousArrayBuffer()
    } else {
      result = _ContiguousArrayBuffer(
        _uninitializedCount: initialCapacity,
        minimumCapacity: 0)
    }

    p = result.firstElementAddress
    remainingCapacity = result.capacity
  }
  @inlinable @inline(__always) internal mutating func add(_ element: Element) {
    if remainingCapacity == 0 {
      // Reallocate.
      let newCapacity = max(_growArrayCapacity(result.capacity), 1)
      var newResult = _ContiguousArrayBuffer<Element>(
        _uninitializedCount: newCapacity, minimumCapacity: 0)
      p = newResult.firstElementAddress + result.capacity
      remainingCapacity = newResult.capacity - result.capacity
      if !result.isEmpty {
        // This check prevents a data race writing to _swiftEmptyArrayStorage
        // Since count is always 0 there, this code does nothing anyway
        newResult.firstElementAddress.moveInitialize(
          from: result.firstElementAddress, count: result.capacity)
        result.mutableCount = 0
      }
      (result, newResult) = (newResult, result)
    }
    addWithExistingCapacity(element)
  }
  @inlinable @inline(__always) internal mutating func addWithExistingCapacity(_ element: Element) {
    _internalInvariant(remainingCapacity > 0,
      "_UnsafePartiallyInitializedContiguousArrayBuffer has no more capacity")
    remainingCapacity -= 1

    p.initialize(to: element)
    p += 1
  }
  @inlinable @inline(__always) internal mutating func finish() -> Swift.ContiguousArray<Element> {
    // Adjust the initialized count of the buffer.
    if (result.capacity != 0) {
      result.mutableCount = result.capacity - remainingCapacity
    } else {
      _internalInvariant(remainingCapacity == 0)
      _internalInvariant(result.count == 0)      
    }

    return finishWithOriginalCount()
  }
  @inlinable @inline(__always) internal mutating func finishWithOriginalCount() -> Swift.ContiguousArray<Element> {
    _internalInvariant(remainingCapacity == result.capacity - result.count,
      "_UnsafePartiallyInitializedContiguousArrayBuffer has incorrect count")
    var finalResult = _ContiguousArrayBuffer<Element>()
    (finalResult, result) = (result, finalResult)
    remainingCapacity = 0
    finalResult.endCOWMutation()
    return ContiguousArray(_buffer: finalResult)
  }
}
extension String {
  public init(cString: Swift.UnsafePointer<Swift.CChar>)
  public init(cString: Swift.UnsafePointer<Swift.UInt8>)
  public init?(validatingUTF8 cString: Swift.UnsafePointer<Swift.CChar>)
  @_specialize(exported: false, kind: full, where Encoding == Swift.Unicode.UTF8)
  @_specialize(exported: false, kind: full, where Encoding == Swift.Unicode.UTF16)
  @inlinable public static func decodeCString<Encoding>(_ cString: Swift.UnsafePointer<Encoding.CodeUnit>?, as encoding: Encoding.Type, repairingInvalidCodeUnits isRepairing: Swift.Bool = true) -> (result: Swift.String, repairsMade: Swift.Bool)? where Encoding : Swift._UnicodeEncoding {
    guard let cPtr = cString else { return nil }

    if _fastPath(encoding == Unicode.UTF8.self) {
      let ptr = UnsafeRawPointer(cPtr).assumingMemoryBound(to: UInt8.self)
      let len = UTF8._nullCodeUnitOffset(in: ptr)
      let codeUnits = UnsafeBufferPointer(start: ptr, count: len)
      if isRepairing {
        return String._fromUTF8Repairing(codeUnits)
      } else {
        guard let str = String._tryFromUTF8(codeUnits) else { return nil }
        return (str, false)
      }
    }

    var end = cPtr
    while end.pointee != 0 { end += 1 }
    let len = end - cPtr
    let codeUnits = UnsafeBufferPointer(start: cPtr, count: len)
    return String._fromCodeUnits(
      codeUnits, encoding: encoding, repair: isRepairing)
  }
  @_specialize(exported: false, kind: full, where Encoding == Swift.Unicode.UTF8)
  @_specialize(exported: false, kind: full, where Encoding == Swift.Unicode.UTF16)
  @inlinable public init<Encoding>(decodingCString ptr: Swift.UnsafePointer<Encoding.CodeUnit>, as sourceEncoding: Encoding.Type) where Encoding : Swift._UnicodeEncoding {
    self = String.decodeCString(ptr, as: sourceEncoding)!.0
  }
}
extension UnsafePointer where Pointee == Swift.UInt8 {
  @inlinable internal var _asCChar: Swift.UnsafePointer<Swift.CChar> {
    @inline(__always) get {
      return UnsafeRawPointer(self).assumingMemoryBound(to: CChar.self)
    }
  }
}
extension UnsafePointer where Pointee == Swift.CChar {
  @inlinable internal var _asUInt8: Swift.UnsafePointer<Swift.UInt8> {
    @inline(__always) get {
      return UnsafeRawPointer(self).assumingMemoryBound(to: UInt8.self)
    }
  }
}
public typealias CChar = Swift.Int8
public typealias CUnsignedChar = Swift.UInt8
public typealias CUnsignedShort = Swift.UInt16
public typealias CUnsignedInt = Swift.UInt32
public typealias CUnsignedLong = Swift.UInt
public typealias CUnsignedLongLong = Swift.UInt64
public typealias CSignedChar = Swift.Int8
public typealias CShort = Swift.Int16
public typealias CInt = Swift.Int32
public typealias CLong = Swift.Int
public typealias CLongLong = Swift.Int64
public typealias CFloat = Swift.Float
public typealias CDouble = Swift.Double
public typealias CLongDouble = Swift.Float80
public typealias CWideChar = Swift.Unicode.Scalar
public typealias CChar16 = Swift.UInt16
public typealias CChar32 = Swift.Unicode.Scalar
public typealias CBool = Swift.Bool
@frozen public struct OpaquePointer {
  @usableFromInline
  internal var _rawValue: Builtin.RawPointer
  @usableFromInline
  @_transparent internal init(_ v: Builtin.RawPointer) {
    self._rawValue = v
  }
  @_transparent public init?(bitPattern: Swift.Int) {
    if bitPattern == 0 { return nil }
    self._rawValue = Builtin.inttoptr_Word(bitPattern._builtinWordValue)
  }
  @_transparent public init?(bitPattern: Swift.UInt) {
    if bitPattern == 0 { return nil }
    self._rawValue = Builtin.inttoptr_Word(bitPattern._builtinWordValue)
  }
  @_transparent public init<T>(@_nonEphemeral _ from: Swift.UnsafePointer<T>) {
    self._rawValue = from._rawValue
  }
  @_transparent public init?<T>(@_nonEphemeral _ from: Swift.UnsafePointer<T>?) {
    guard let unwrapped = from else { return nil }
    self.init(unwrapped)
  }
  @_transparent public init<T>(@_nonEphemeral _ from: Swift.UnsafeMutablePointer<T>) {
    self._rawValue = from._rawValue
  }
  @_transparent public init?<T>(@_nonEphemeral _ from: Swift.UnsafeMutablePointer<T>?) {
    guard let unwrapped = from else { return nil }
    self.init(unwrapped)
  }
}
extension OpaquePointer : Swift.Equatable {
  @inlinable public static func == (lhs: Swift.OpaquePointer, rhs: Swift.OpaquePointer) -> Swift.Bool {
    return Bool(Builtin.cmp_eq_RawPointer(lhs._rawValue, rhs._rawValue))
  }
}
extension OpaquePointer : Swift.Hashable {
  @inlinable public func hash(into hasher: inout Swift.Hasher) {
    hasher.combine(Int(Builtin.ptrtoint_Word(_rawValue)))
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension OpaquePointer : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
extension Int {
  @inlinable public init(bitPattern pointer: Swift.OpaquePointer?) {
    self.init(bitPattern: UnsafeRawPointer(pointer))
  }
}
extension UInt {
  @inlinable public init(bitPattern pointer: Swift.OpaquePointer?) {
    self.init(bitPattern: UnsafeRawPointer(pointer))
  }
}
@frozen public struct CVaListPointer {
  @usableFromInline
  internal var _value: Swift.UnsafeMutableRawPointer
  @inlinable public init(_fromUnsafeMutablePointer from: Swift.UnsafeMutableRawPointer) {
    _value = from
  }
}
extension CVaListPointer : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
@inlinable internal func _memcpy(dest destination: Swift.UnsafeMutableRawPointer, src: Swift.UnsafeRawPointer, size: Swift.UInt) {
  let dest = destination._rawValue
  let src = src._rawValue
  let size = UInt64(size)._value
  Builtin.int_memcpy_RawPointer_RawPointer_Int64(
    dest, src, size,
    /*volatile:*/ false._value)
}
@inlinable internal func _memmove(dest destination: Swift.UnsafeMutableRawPointer, src: Swift.UnsafeRawPointer, size: Swift.UInt) {
  let dest = destination._rawValue
  let src = src._rawValue
  let size = UInt64(size)._value
  Builtin.int_memmove_RawPointer_RawPointer_Int64(
    dest, src, size,
    /*volatile:*/ false._value)
}
@frozen public enum _DebuggerSupport {
  public static func stringForPrintObject(_ value: Any) -> Swift.String
}
public func _stringForPrintObject(_ value: Any) -> Swift.String
public func _debuggerTestingCheckExpect(_: Swift.String, _: Swift.String)
@_silgen_name("swift_retainCount")
public func _getRetainCount(_ Value: Swift.AnyObject) -> Swift.UInt
@_silgen_name("swift_unownedRetainCount")
public func _getUnownedRetainCount(_ Value: Swift.AnyObject) -> Swift.UInt
@_silgen_name("swift_weakRetainCount")
public func _getWeakRetainCount(_ Value: Swift.AnyObject) -> Swift.UInt
@frozen public struct Dictionary<Key, Value> where Key : Swift.Hashable {
  public typealias Element = (key: Key, value: Value)
  @usableFromInline
  internal var _variant: Swift.Dictionary<Key, Value>._Variant
  @inlinable internal init(_native: __owned Swift._NativeDictionary<Key, Value>) {
    _variant = _Variant(native: _native)
  }
  @inlinable internal init(_cocoa: __owned Swift.__CocoaDictionary) {
    _variant = _Variant(cocoa: _cocoa)
  }
  @inlinable public init(_immutableCocoaDictionary: __owned Swift.AnyObject) {
    _internalInvariant(
      _isBridgedVerbatimToObjectiveC(Key.self) &&
      _isBridgedVerbatimToObjectiveC(Value.self),
      """
      Dictionary can be backed by NSDictionary buffer only when both Key \
      and Value are bridged verbatim to Objective-C
      """)
    self.init(_cocoa: __CocoaDictionary(_immutableCocoaDictionary))
  }
  @inlinable public init() {
    self.init(_native: _NativeDictionary())
  }
  public init(minimumCapacity: Swift.Int)
  @inlinable public init<S>(uniqueKeysWithValues keysAndValues: __owned S) where S : Swift.Sequence, S.Element == (Key, Value) {
    if let d = keysAndValues as? Dictionary<Key, Value> {
      self = d
      return
    }
    var native = _NativeDictionary<Key, Value>(
      capacity: keysAndValues.underestimatedCount)
    // '_MergeError.keyCollision' is caught and handled with an appropriate
    // error message one level down, inside native.merge(_:...). We throw an
    // error instead of calling fatalError() directly because we want the
    // message to include the duplicate key, and the closure only has access to
    // the conflicting values.
    try! native.merge(
      keysAndValues,
      isUnique: true,
      uniquingKeysWith: { _, _ in throw _MergeError.keyCollision })
    self.init(_native: native)
  }
  @inlinable public init<S>(_ keysAndValues: __owned S, uniquingKeysWith combine: (Value, Value) throws -> Value) rethrows where S : Swift.Sequence, S.Element == (Key, Value) {
    var native = _NativeDictionary<Key, Value>(
      capacity: keysAndValues.underestimatedCount)
    try native.merge(keysAndValues, isUnique: true, uniquingKeysWith: combine)
    self.init(_native: native)
  }
  @inlinable public init<S>(grouping values: __owned S, by keyForValue: (S.Element) throws -> Key) rethrows where Value == [S.Element], S : Swift.Sequence {
    try self.init(_native: _NativeDictionary(grouping: values, by: keyForValue))
  }
}
extension Dictionary : Swift.Sequence {
  @inlinable @inline(__always) __consuming public func makeIterator() -> Swift.Dictionary<Key, Value>.Iterator {
    return _variant.makeIterator()
  }
}
extension Dictionary {
  @available(swift 4.0)
  @inlinable __consuming public func filter(_ isIncluded: (Swift.Dictionary<Key, Value>.Element) throws -> Swift.Bool) rethrows -> [Key : Value] {
    // FIXME(performance): Try building a bitset of elements to keep, so that we
    // eliminate rehashings during insertion.
    var result = _NativeDictionary<Key, Value>()
    for element in self {
      if try isIncluded(element) {
        result.insertNew(key: element.key, value: element.value)
      }
    }
    return Dictionary(_native: result)
  }
}
extension Dictionary : Swift.Collection {
  public typealias SubSequence = Swift.Slice<Swift.Dictionary<Key, Value>>
  @inlinable public var startIndex: Swift.Dictionary<Key, Value>.Index {
    get {
    return _variant.startIndex
  }
  }
  @inlinable public var endIndex: Swift.Dictionary<Key, Value>.Index {
    get {
    return _variant.endIndex
  }
  }
  @inlinable public func index(after i: Swift.Dictionary<Key, Value>.Index) -> Swift.Dictionary<Key, Value>.Index {
    return _variant.index(after: i)
  }
  @inlinable public func formIndex(after i: inout Swift.Dictionary<Key, Value>.Index) {
    _variant.formIndex(after: &i)
  }
  @inlinable @inline(__always) public func index(forKey key: Key) -> Swift.Dictionary<Key, Value>.Index? {
    // Complexity: amortized O(1) for native dictionary, O(*n*) when wrapping an
    // NSDictionary.
    return _variant.index(forKey: key)
  }
  @inlinable public subscript(position: Swift.Dictionary<Key, Value>.Index) -> Swift.Dictionary<Key, Value>.Element {
    get {
    return _variant.lookup(position)
  }
  }
  @inlinable public var count: Swift.Int {
    get {
    return _variant.count
  }
  }
  @inlinable public var isEmpty: Swift.Bool {
    get {
    return count == 0
  }
  }
  public typealias Indices = Swift.DefaultIndices<Swift.Dictionary<Key, Value>>
}
extension Dictionary {
  @inlinable public subscript(key: Key) -> Value? {
    get {
      return _variant.lookup(key)
    }
    set(newValue) {
      if let x = newValue {
        _variant.setValue(x, forKey: key)
      } else {
        removeValue(forKey: key)
      }
    }
    _modify {
      defer { _fixLifetime(self) }
      yield &_variant[key]
    }
  }
}
extension Dictionary : Swift.ExpressibleByDictionaryLiteral {
  @inlinable @_effects(readonly) @_semantics("optimize.sil.specialize.generic.size.never") public init(dictionaryLiteral elements: (Key, Value)...) {
    let native = _NativeDictionary<Key, Value>(capacity: elements.count)
    for (key, value) in elements {
      let (bucket, found) = native.find(key)
      _precondition(!found, "Dictionary literal contains duplicate keys")
      native._insert(at: bucket, key: key, value: value)
    }
    self.init(_native: native)
  }
}
extension Dictionary {
  @inlinable public subscript(key: Key, default defaultValue: @autoclosure () -> Value) -> Value {
    @inline(__always) get {
      return _variant.lookup(key) ?? defaultValue()
    }
    @inline(__always) _modify {
      let (bucket, found) = _variant.mutatingFind(key)
      let native = _variant.asNative
      if !found {
        let value = defaultValue()
        native._insert(at: bucket, key: key, value: value)
      }
      let address = native._values + bucket.offset
      defer { _fixLifetime(self) }
      yield &address.pointee
    }
  }
  @inlinable public func mapValues<T>(_ transform: (Value) throws -> T) rethrows -> Swift.Dictionary<Key, T> {
    return try Dictionary<Key, T>(_native: _variant.mapValues(transform))
  }
  @inlinable public func compactMapValues<T>(_ transform: (Value) throws -> T?) rethrows -> Swift.Dictionary<Key, T> {
    let result: _NativeDictionary<Key, T> =
      try self.reduce(into: _NativeDictionary<Key, T>()) { (result, element) in
      if let value = try transform(element.value) {
        result.insertNew(key: element.key, value: value)
      }
    }
    return Dictionary<Key, T>(_native: result)
  }
  @discardableResult
  @inlinable public mutating func updateValue(_ value: __owned Value, forKey key: Key) -> Value? {
    return _variant.updateValue(value, forKey: key)
  }
  @inlinable public mutating func merge<S>(_ other: __owned S, uniquingKeysWith combine: (Value, Value) throws -> Value) rethrows where S : Swift.Sequence, S.Element == (Key, Value) {
    try _variant.merge(other, uniquingKeysWith: combine)
  }
  @inlinable public mutating func merge(_ other: __owned [Key : Value], uniquingKeysWith combine: (Value, Value) throws -> Value) rethrows {
    try _variant.merge(
      other.lazy.map { ($0, $1) }, uniquingKeysWith: combine)
  }
  @inlinable __consuming public func merging<S>(_ other: __owned S, uniquingKeysWith combine: (Value, Value) throws -> Value) rethrows -> [Key : Value] where S : Swift.Sequence, S.Element == (Key, Value) {
    var result = self
    try result._variant.merge(other, uniquingKeysWith: combine)
    return result
  }
  @inlinable __consuming public func merging(_ other: __owned [Key : Value], uniquingKeysWith combine: (Value, Value) throws -> Value) rethrows -> [Key : Value] {
    var result = self
    try result.merge(other, uniquingKeysWith: combine)
    return result
  }
  @discardableResult
  @inlinable public mutating func remove(at index: Swift.Dictionary<Key, Value>.Index) -> Swift.Dictionary<Key, Value>.Element {
    return _variant.remove(at: index)
  }
  @discardableResult
  @inlinable public mutating func removeValue(forKey key: Key) -> Value? {
    return _variant.removeValue(forKey: key)
  }
  @inlinable public mutating func removeAll(keepingCapacity keepCapacity: Swift.Bool = false) {
    // The 'will not decrease' part in the documentation comment is worded very
    // carefully.  The capacity can increase if we replace Cocoa dictionary with
    // native dictionary.
    _variant.removeAll(keepingCapacity: keepCapacity)
  }
}
extension Dictionary {
  @available(swift 4.0)
  @inlinable public var keys: Swift.Dictionary<Key, Value>.Keys {
    get {
      return Keys(_dictionary: self)
    }
  }
  @available(swift 4.0)
  @inlinable public var values: Swift.Dictionary<Key, Value>.Values {
    get {
      return Values(_dictionary: self)
    }
    _modify {
      var values = Values(_variant: _Variant(dummy: ()))
      swap(&values._variant, &_variant)
      defer { self._variant = values._variant }
      yield &values
    }
  }
  @frozen public struct Keys : Swift.Collection, Swift.Equatable, Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible {
    public typealias Element = Key
    public typealias SubSequence = Swift.Slice<Swift.Dictionary<Key, Value>.Keys>
    @usableFromInline
    internal var _variant: Swift.Dictionary<Key, Value>._Variant
    @inlinable internal init(_dictionary: __owned Swift.Dictionary<Key, Value>) {
      self._variant = _dictionary._variant
    }
    @inlinable public var startIndex: Swift.Dictionary<Key, Value>.Index {
      get {
      return _variant.startIndex
    }
    }
    @inlinable public var endIndex: Swift.Dictionary<Key, Value>.Index {
      get {
      return _variant.endIndex
    }
    }
    @inlinable public func index(after i: Swift.Dictionary<Key, Value>.Index) -> Swift.Dictionary<Key, Value>.Index {
      return _variant.index(after: i)
    }
    @inlinable public func formIndex(after i: inout Swift.Dictionary<Key, Value>.Index) {
      _variant.formIndex(after: &i)
    }
    @inlinable public subscript(position: Swift.Dictionary<Key, Value>.Index) -> Swift.Dictionary<Key, Value>.Keys.Element {
      get {
      return _variant.key(at: position)
    }
    }
    @inlinable public var count: Swift.Int {
      get {
      return _variant.count
    }
    }
    @inlinable public var isEmpty: Swift.Bool {
      get {
      return count == 0
    }
    }
    @inlinable @inline(__always) public func _customContainsEquatableElement(_ element: Swift.Dictionary<Key, Value>.Keys.Element) -> Swift.Bool? {
      return _variant.contains(element)
    }
    @inlinable @inline(__always) public func _customIndexOfEquatableElement(_ element: Swift.Dictionary<Key, Value>.Keys.Element) -> Swift.Dictionary<Key, Value>.Index?? {
      return Optional(_variant.index(forKey: element))
    }
    @inlinable @inline(__always) public func _customLastIndexOfEquatableElement(_ element: Swift.Dictionary<Key, Value>.Keys.Element) -> Swift.Dictionary<Key, Value>.Index?? {
      // The first and last elements are the same because each element is unique.
      return _customIndexOfEquatableElement(element)
    }
    @inlinable public static func == (lhs: Swift.Dictionary<Key, Value>.Keys, rhs: Swift.Dictionary<Key, Value>.Keys) -> Swift.Bool {
      // Equal if the two dictionaries share storage.
      if
        lhs._variant.isNative,
        rhs._variant.isNative,
        lhs._variant.asNative._storage === rhs._variant.asNative._storage
      {
        return true
      }
      if
        !lhs._variant.isNative,
        !rhs._variant.isNative,
        lhs._variant.asCocoa.object === rhs._variant.asCocoa.object
      {
        return true
      }

      // Not equal if the dictionaries are different sizes.
      if lhs.count != rhs.count {
        return false
      }

      // Perform unordered comparison of keys.
      for key in lhs {
        if !rhs.contains(key) {
          return false
        }
      }

      return true
    }
    public var description: Swift.String {
      get
    }
    public var debugDescription: Swift.String {
      get
    }
    public typealias Index = Swift.Dictionary<Key, Value>.Index
    public typealias Indices = Swift.DefaultIndices<Swift.Dictionary<Key, Value>.Keys>
  }
  @frozen public struct Values : Swift.MutableCollection, Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible {
    public typealias Element = Value
    @usableFromInline
    internal var _variant: Swift.Dictionary<Key, Value>._Variant
    @inlinable internal init(_variant: __owned Swift.Dictionary<Key, Value>._Variant) {
      self._variant = _variant
    }
    @inlinable internal init(_dictionary: __owned Swift.Dictionary<Key, Value>) {
      self._variant = _dictionary._variant
    }
    @inlinable public var startIndex: Swift.Dictionary<Key, Value>.Index {
      get {
      return _variant.startIndex
    }
    }
    @inlinable public var endIndex: Swift.Dictionary<Key, Value>.Index {
      get {
      return _variant.endIndex
    }
    }
    @inlinable public func index(after i: Swift.Dictionary<Key, Value>.Index) -> Swift.Dictionary<Key, Value>.Index {
      return _variant.index(after: i)
    }
    @inlinable public func formIndex(after i: inout Swift.Dictionary<Key, Value>.Index) {
      _variant.formIndex(after: &i)
    }
    @inlinable public subscript(position: Swift.Dictionary<Key, Value>.Index) -> Swift.Dictionary<Key, Value>.Values.Element {
      get {
        return _variant.value(at: position)
      }
      _modify {
        let native = _variant.ensureUniqueNative()
        let bucket = native.validatedBucket(for: position)
        let address = native._values + bucket.offset
        defer { _fixLifetime(self) }
        yield &address.pointee
      }
    }
    @inlinable public var count: Swift.Int {
      get {
      return _variant.count
    }
    }
    @inlinable public var isEmpty: Swift.Bool {
      get {
      return count == 0
    }
    }
    public var description: Swift.String {
      get
    }
    public var debugDescription: Swift.String {
      get
    }
    @inlinable public mutating func swapAt(_ i: Swift.Dictionary<Key, Value>.Index, _ j: Swift.Dictionary<Key, Value>.Index) {
      guard i != j else { return }
      if !_variant.isNative {
        _variant = .init(native: _NativeDictionary(_variant.asCocoa))
      }
      let isUnique = _variant.isUniquelyReferenced()
      let native = _variant.asNative
      let a = native.validatedBucket(for: i)
      let b = native.validatedBucket(for: j)
      _variant.asNative.swapValuesAt(a, b, isUnique: isUnique)
    }
    public typealias Index = Swift.Dictionary<Key, Value>.Index
    public typealias Indices = Swift.DefaultIndices<Swift.Dictionary<Key, Value>.Values>
    public typealias SubSequence = Swift.Slice<Swift.Dictionary<Key, Value>.Values>
  }
}
extension Dictionary.Keys {
  @frozen public struct Iterator : Swift.IteratorProtocol {
    @usableFromInline
    internal var _base: Swift.Dictionary<Key, Value>.Iterator
    @inlinable @inline(__always) internal init(_ base: Swift.Dictionary<Key, Value>.Iterator) {
      self._base = base
    }
    @inlinable @inline(__always) public mutating func next() -> Key? {
      if case .cocoa(let cocoa) = _base._variant {
        _base._cocoaPath()
        guard let cocoaKey = cocoa.nextKey() else { return nil }
        return _forceBridgeFromObjectiveC(cocoaKey, Key.self)
      }
      return _base._asNative.nextKey()
    }
    public typealias Element = Key
  }
  @inlinable @inline(__always) __consuming public func makeIterator() -> Swift.Dictionary<Key, Value>.Keys.Iterator {
    return Iterator(_variant.makeIterator())
  }
}
extension Dictionary.Values {
  @frozen public struct Iterator : Swift.IteratorProtocol {
    @usableFromInline
    internal var _base: Swift.Dictionary<Key, Value>.Iterator
    @inlinable @inline(__always) internal init(_ base: Swift.Dictionary<Key, Value>.Iterator) {
      self._base = base
    }
    @inlinable @inline(__always) public mutating func next() -> Value? {
      if case .cocoa(let cocoa) = _base._variant {
        _base._cocoaPath()
        guard let (_, cocoaValue) = cocoa.next() else { return nil }
        return _forceBridgeFromObjectiveC(cocoaValue, Value.self)
      }
      return _base._asNative.nextValue()
    }
    public typealias Element = Value
  }
  @inlinable @inline(__always) __consuming public func makeIterator() -> Swift.Dictionary<Key, Value>.Values.Iterator {
    return Iterator(_variant.makeIterator())
  }
}
extension Dictionary : Swift.Equatable where Value : Swift.Equatable {
  @inlinable public static func == (lhs: [Key : Value], rhs: [Key : Value]) -> Swift.Bool {
    switch (lhs._variant.isNative, rhs._variant.isNative) {
    case (true, true):
      return lhs._variant.asNative.isEqual(to: rhs._variant.asNative)
    case (false, false):
      return lhs._variant.asCocoa.isEqual(to: rhs._variant.asCocoa)
    case (true, false):
      return lhs._variant.asNative.isEqual(to: rhs._variant.asCocoa)
    case (false, true):
      return rhs._variant.asNative.isEqual(to: lhs._variant.asCocoa)
    }
  }
}
extension Dictionary : Swift.Hashable where Value : Swift.Hashable {
  @inlinable public func hash(into hasher: inout Swift.Hasher) {
    var commutativeHash = 0
    for (k, v) in self {
      // Note that we use a copy of our own hasher here. This makes hash values
      // dependent on its state, eliminating static collision patterns.
      var elementHasher = hasher
      elementHasher.combine(k)
      elementHasher.combine(v)
      commutativeHash ^= elementHasher._finalize()
    }
    hasher.combine(commutativeHash)
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension Dictionary : Swift._HasCustomAnyHashableRepresentation where Value : Swift.Hashable {
  __consuming public func _toCustomAnyHashable() -> Swift.AnyHashable?
}
extension Dictionary : Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible {
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
}
@usableFromInline
@frozen internal enum _MergeError : Swift.Error {
  case keyCollision
  @usableFromInline
  internal static func == (a: Swift._MergeError, b: Swift._MergeError) -> Swift.Bool
  @usableFromInline
  internal func hash(into hasher: inout Swift.Hasher)
  @usableFromInline
  internal var hashValue: Swift.Int {
    @usableFromInline
    get
  }
}
extension Dictionary {
  @frozen public struct Index {
    @usableFromInline
    @frozen internal enum _Variant {
      case native(Swift._HashTable.Index)
      case cocoa(Swift.__CocoaDictionary.Index)
    }
    @usableFromInline
    internal var _variant: Swift.Dictionary<Key, Value>.Index._Variant
    @inlinable @inline(__always) internal init(_variant: __owned Swift.Dictionary<Key, Value>.Index._Variant) {
      self._variant = _variant
    }
    @inlinable @inline(__always) internal init(_native index: Swift._HashTable.Index) {
      self.init(_variant: .native(index))
    }
    @inlinable @inline(__always) internal init(_cocoa index: __owned Swift.__CocoaDictionary.Index) {
      self.init(_variant: .cocoa(index))
    }
  }
}
extension Dictionary.Index {
  @usableFromInline
  @_transparent internal var _guaranteedNative: Swift.Bool {
    @_transparent get {
    return _canBeClass(Key.self) == 0 || _canBeClass(Value.self) == 0
  }
  }
  @usableFromInline
  @_transparent internal func _cocoaPath() {
    if _guaranteedNative {
      _conditionallyUnreachable()
    }
  }
  @inlinable @inline(__always) internal mutating func _isUniquelyReferenced() -> Swift.Bool {
    defer { _fixLifetime(self) }
    var handle = _asCocoa.handleBitPattern
    return handle == 0 || _isUnique_native(&handle)
  }
  @usableFromInline
  @_transparent internal var _isNative: Swift.Bool {
    @_transparent get {
    switch _variant {
    case .native:
      return true
    case .cocoa:
      _cocoaPath()
      return false
    }
  }
  }
  @usableFromInline
  @_transparent internal var _asNative: Swift._HashTable.Index {
    @_transparent get {
    switch _variant {
    case .native(let nativeIndex):
      return nativeIndex
    case .cocoa:
      _preconditionFailure(
        "Attempting to access Dictionary elements using an invalid index")
    }
  }
  }
  @usableFromInline
  internal var _asCocoa: Swift.__CocoaDictionary.Index {
    @_transparent get {
      switch _variant {
      case .native:
        _preconditionFailure(
          "Attempting to access Dictionary elements using an invalid index")
      case .cocoa(let cocoaIndex):
        return cocoaIndex
      }
    }
    _modify
  }
}
extension Dictionary.Index : Swift.Equatable {
  @inlinable public static func == (lhs: Swift.Dictionary<Key, Value>.Index, rhs: Swift.Dictionary<Key, Value>.Index) -> Swift.Bool {
    switch (lhs._variant, rhs._variant) {
    case (.native(let lhsNative), .native(let rhsNative)):
      return lhsNative == rhsNative
    case (.cocoa(let lhsCocoa), .cocoa(let rhsCocoa)):
      lhs._cocoaPath()
      return lhsCocoa == rhsCocoa
    default:
      _preconditionFailure("Comparing indexes from different dictionaries")
    }
  }
}
extension Dictionary.Index : Swift.Comparable {
  @inlinable public static func < (lhs: Swift.Dictionary<Key, Value>.Index, rhs: Swift.Dictionary<Key, Value>.Index) -> Swift.Bool {
    switch (lhs._variant, rhs._variant) {
    case (.native(let lhsNative), .native(let rhsNative)):
      return lhsNative < rhsNative
    case (.cocoa(let lhsCocoa), .cocoa(let rhsCocoa)):
      lhs._cocoaPath()
      return lhsCocoa < rhsCocoa
    default:
      _preconditionFailure("Comparing indexes from different dictionaries")
    }
  }
}
extension Dictionary.Index : Swift.Hashable {
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension Dictionary {
  @frozen public struct Iterator {
    @usableFromInline
    @frozen internal enum _Variant {
      case native(Swift._NativeDictionary<Key, Value>.Iterator)
      case cocoa(Swift.__CocoaDictionary.Iterator)
    }
    @usableFromInline
    internal var _variant: Swift.Dictionary<Key, Value>.Iterator._Variant
    @inlinable internal init(_variant: __owned Swift.Dictionary<Key, Value>.Iterator._Variant) {
      self._variant = _variant
    }
    @inlinable internal init(_native: __owned Swift._NativeDictionary<Key, Value>.Iterator) {
      self.init(_variant: .native(_native))
    }
    @inlinable internal init(_cocoa: __owned Swift.__CocoaDictionary.Iterator) {
      self.init(_variant: .cocoa(_cocoa))
    }
  }
}
extension Dictionary.Iterator {
  @usableFromInline
  @_transparent internal var _guaranteedNative: Swift.Bool {
    @_transparent get {
    return _canBeClass(Key.self) == 0 || _canBeClass(Value.self) == 0
  }
  }
  @usableFromInline
  @_transparent internal func _cocoaPath() {
    if _guaranteedNative {
      _conditionallyUnreachable()
    }
  }
  @usableFromInline
  @_transparent internal var _isNative: Swift.Bool {
    @_transparent get {
    switch _variant {
    case .native:
      return true
    case .cocoa:
      _cocoaPath()
      return false
    }
  }
  }
  @usableFromInline
  @_transparent internal var _asNative: Swift._NativeDictionary<Key, Value>.Iterator {
    @_transparent get {
      switch _variant {
      case .native(let nativeIterator):
        return nativeIterator
      case .cocoa:
        _internalInvariantFailure("internal error: does not contain a native index")
      }
    }
    @_transparent set {
      self._variant = .native(newValue)
    }
  }
  @usableFromInline
  @_transparent internal var _asCocoa: Swift.__CocoaDictionary.Iterator {
    @_transparent get {
      switch _variant {
      case .native:
        _internalInvariantFailure("internal error: does not contain a Cocoa index")
      case .cocoa(let cocoa):
        return cocoa
      }
    }
  }
}
extension Dictionary.Iterator : Swift.IteratorProtocol {
  @inlinable @inline(__always) public mutating func next() -> (key: Key, value: Value)? {
    guard _isNative else {
      if let (cocoaKey, cocoaValue) = _asCocoa.next() {
        let nativeKey = _forceBridgeFromObjectiveC(cocoaKey, Key.self)
        let nativeValue = _forceBridgeFromObjectiveC(cocoaValue, Value.self)
        return (nativeKey, nativeValue)
      }
      return nil
    }
    return _asNative.next()
  }
  public typealias Element = (key: Key, value: Value)
}
extension Dictionary.Iterator : Swift.CustomReflectable {
  public var customMirror: Swift.Mirror {
    get
  }
}
extension Dictionary : Swift.CustomReflectable {
  public var customMirror: Swift.Mirror {
    get
  }
}
extension Dictionary {
  @inlinable public mutating func popFirst() -> Swift.Dictionary<Key, Value>.Element? {
    guard !isEmpty else { return nil }
    return remove(at: startIndex)
  }
  @inlinable public var capacity: Swift.Int {
    get {
    return _variant.capacity
  }
  }
  public mutating func reserveCapacity(_ minimumCapacity: Swift.Int)
}
public typealias DictionaryIndex<Key, Value> = Swift.Dictionary<Key, Value>.Index where Key : Swift.Hashable
public typealias DictionaryIterator<Key, Value> = Swift.Dictionary<Key, Value>.Iterator where Key : Swift.Hashable
extension _NativeDictionary {
  @usableFromInline
  __consuming internal func bridged() -> Swift.AnyObject
}
@usableFromInline
@frozen internal struct __CocoaDictionary {
  @usableFromInline
  internal let object: Swift.AnyObject
  @inlinable internal init(_ object: __owned Swift.AnyObject) {
    self.object = object
  }
}
extension __CocoaDictionary {
  @usableFromInline
  internal func isEqual(to other: Swift.__CocoaDictionary) -> Swift.Bool
}
extension __CocoaDictionary {
  @usableFromInline
  internal typealias Key = Swift.AnyObject
  @usableFromInline
  internal typealias Value = Swift.AnyObject
  @usableFromInline
  internal var startIndex: Swift.__CocoaDictionary.Index {
    @_effects(releasenone) get
  }
  @usableFromInline
  internal var endIndex: Swift.__CocoaDictionary.Index {
    @_effects(releasenone) get
  }
  @usableFromInline
  @_effects(releasenone) internal func index(after index: Swift.__CocoaDictionary.Index) -> Swift.__CocoaDictionary.Index
  @usableFromInline
  internal func formIndex(after index: inout Swift.__CocoaDictionary.Index, isUnique: Swift.Bool)
  @usableFromInline
  @_effects(releasenone) internal func index(forKey key: Swift.__CocoaDictionary.Key) -> Swift.__CocoaDictionary.Index?
  @usableFromInline
  internal var count: Swift.Int {
    get
  }
  @usableFromInline
  internal func contains(_ key: Swift.__CocoaDictionary.Key) -> Swift.Bool
  @usableFromInline
  internal func lookup(_ key: Swift.__CocoaDictionary.Key) -> Swift.__CocoaDictionary.Value?
  @usableFromInline
  @_effects(releasenone) internal func lookup(_ index: Swift.__CocoaDictionary.Index) -> (key: Swift.__CocoaDictionary.Key, value: Swift.__CocoaDictionary.Value)
  @usableFromInline
  @_effects(releasenone) internal func key(at index: Swift.__CocoaDictionary.Index) -> Swift.__CocoaDictionary.Key
  @usableFromInline
  @_effects(releasenone) internal func value(at index: Swift.__CocoaDictionary.Index) -> Swift.__CocoaDictionary.Value
}
extension __CocoaDictionary {
  @inlinable internal func mapValues<Key, Value, T>(_ transform: (Value) throws -> T) rethrows -> Swift._NativeDictionary<Key, T> where Key : Swift.Hashable {
    var result = _NativeDictionary<Key, T>(capacity: self.count)
    for (cocoaKey, cocoaValue) in self {
      let key = _forceBridgeFromObjectiveC(cocoaKey, Key.self)
      let value = _forceBridgeFromObjectiveC(cocoaValue, Value.self)
      try result.insertNew(key: key, value: transform(value))
    }
    return result
  }
}
extension __CocoaDictionary {
  @usableFromInline
  @frozen internal struct Index {
    internal var _storage: Builtin.BridgeObject
    internal var _offset: Swift.Int
  }
}
extension __CocoaDictionary.Index {
  @usableFromInline
  internal var handleBitPattern: Swift.UInt {
    @_effects(readonly) get
  }
  @usableFromInline
  internal var dictionary: Swift.__CocoaDictionary {
    @_effects(releasenone) get
  }
}
extension __CocoaDictionary.Index {
  @usableFromInline
  @nonobjc internal var key: Swift.AnyObject {
    @_effects(readonly) get
  }
  @usableFromInline
  @nonobjc internal var age: Swift.Int32 {
    @_effects(readonly) get
  }
}
extension __CocoaDictionary.Index : Swift.Equatable {
  @usableFromInline
  @_effects(readonly) internal static func == (lhs: Swift.__CocoaDictionary.Index, rhs: Swift.__CocoaDictionary.Index) -> Swift.Bool
}
extension __CocoaDictionary.Index : Swift.Comparable {
  @usableFromInline
  @_effects(readonly) internal static func < (lhs: Swift.__CocoaDictionary.Index, rhs: Swift.__CocoaDictionary.Index) -> Swift.Bool
}
extension __CocoaDictionary : Swift.Sequence {
  @_hasMissingDesignatedInitializers @usableFromInline
  final internal class Iterator {
    @objc @usableFromInline
    deinit
  }
  @usableFromInline
  @_effects(releasenone) __consuming internal func makeIterator() -> Swift.__CocoaDictionary.Iterator
  @usableFromInline
  internal typealias Element = Swift.__CocoaDictionary.Iterator.Element
}
extension __CocoaDictionary.Iterator : Swift.IteratorProtocol {
  @usableFromInline
  internal typealias Element = (key: Swift.AnyObject, value: Swift.AnyObject)
  @usableFromInline
  final internal func nextKey() -> Swift.AnyObject?
  @usableFromInline
  final internal func next() -> Swift.__CocoaDictionary.Iterator.Element?
}
extension Dictionary {
  @inlinable __consuming public func _bridgeToObjectiveCImpl() -> Swift.AnyObject {
    guard _variant.isNative else {
      return _variant.asCocoa.object
    }
    return _variant.asNative.bridged()
  }
  public static func _bridgeFromObjectiveCAdoptingNativeStorageOf(_ s: __owned Swift.AnyObject) -> Swift.Dictionary<Key, Value>?
}
@frozen public struct _DictionaryBuilder<Key, Value> where Key : Swift.Hashable {
  @usableFromInline
  internal var _target: Swift._NativeDictionary<Key, Value>
  @usableFromInline
  internal let _requestedCount: Swift.Int
  @inlinable public init(count: Swift.Int) {
    _target = _NativeDictionary(capacity: count)
    _requestedCount = count
  }
  @inlinable public mutating func add(key newKey: Key, value: Value) {
    _precondition(_target.count < _requestedCount,
      "Can't add more members than promised")
    _target._unsafeInsertNew(key: newKey, value: value)
  }
  @inlinable __consuming public func take() -> Swift.Dictionary<Key, Value> {
    _precondition(_target.count == _requestedCount,
      "The number of members added does not match the promised count")
    return Dictionary(_native: _target)
  }
}
extension Dictionary {
  @_alwaysEmitIntoClient public init(_unsafeUninitializedCapacity capacity: Swift.Int, allowingDuplicates: Swift.Bool, initializingWith initializer: (Swift.UnsafeMutableBufferPointer<Key>, Swift.UnsafeMutableBufferPointer<Value>) -> Swift.Int) {
    self.init(_native: _NativeDictionary(
        _unsafeUninitializedCapacity: capacity,
        allowingDuplicates: allowingDuplicates,
        initializingWith: initializer))
  }
}
extension _NativeDictionary {
  @_alwaysEmitIntoClient internal init(_unsafeUninitializedCapacity capacity: Swift.Int, allowingDuplicates: Swift.Bool, initializingWith initializer: (Swift.UnsafeMutableBufferPointer<Key>, Swift.UnsafeMutableBufferPointer<Value>) -> Swift.Int) {
    self.init(capacity: capacity)
    let initializedCount = initializer(
      UnsafeMutableBufferPointer(start: _keys, count: capacity),
      UnsafeMutableBufferPointer(start: _values, count: capacity))
    _precondition(initializedCount >= 0 && initializedCount <= capacity)
    _storage._count = initializedCount

    // Hash initialized elements and move each of them into their correct
    // buckets.
    //
    // - We have some number of unprocessed elements at the start of the
    //   key/value buffers -- buckets up to and including `bucket`. Everything
    //   in this region is either unprocessed or in use. There are no
    //   uninitialized entries in it.
    //
    // - Everything after `bucket` is either uninitialized or in use. This
    //   region works exactly like regular dictionary storage.
    //
    // - "in use" is tracked by the bitmap in `hashTable`, the same way it would
    //   be for a working Dictionary.
    //
    // Each iteration of the loop below processes an unprocessed element, and/or
    // reduces the size of the unprocessed region, while ensuring the above
    // invariants.
    var bucket = _HashTable.Bucket(offset: initializedCount - 1)
    while bucket.offset >= 0 {
      if hashTable._isOccupied(bucket) {
        // We've moved an element here in a previous iteration.
        bucket.offset -= 1
        continue
      }
      // Find the target bucket for this entry and mark it as in use.
      let target: Bucket
      if _isDebugAssertConfiguration() || allowingDuplicates {
        let (b, found) = find(_keys[bucket.offset])
        if found {
          _internalInvariant(b != bucket)
          _precondition(allowingDuplicates, "Duplicate keys found")
          // Discard duplicate entry.
          uncheckedDestroy(at: bucket)
          _storage._count -= 1
          bucket.offset -= 1
          continue
        }
        hashTable.insert(b)
        target = b
      } else {
        let hashValue = self.hashValue(for: _keys[bucket.offset])
        target = hashTable.insertNew(hashValue: hashValue)
      }

      if target > bucket {
        // The target is outside the unprocessed region.  We can simply move the
        // entry, leaving behind an uninitialized bucket.
        moveEntry(from: bucket, to: target)
        // Restore invariants by lowering the region boundary.
        bucket.offset -= 1
      } else if target == bucket {
        // Already in place.
        bucket.offset -= 1
      } else {
        // The target bucket is also in the unprocessed region. Swap the current
        // item into place, then try again with the swapped-in value, so that we
        // don't lose it.
        swapEntry(target, with: bucket)
      }
    }
    // When there are no more unprocessed entries, we're left with a valid
    // Dictionary.
  }
}
extension Dictionary {
  @_alwaysEmitIntoClient @inlinable @inline(__always) internal init?<C>(_mapping source: C, allowingDuplicates: Swift.Bool, transform: (C.Element) -> (key: Key, value: Value)?) where C : Swift.Collection {
    var target = _NativeDictionary<Key, Value>(capacity: source.count)
    if allowingDuplicates {
      for member in source {
        guard let (key, value) = transform(member) else { return nil }
        target._unsafeUpdate(key: key, value: value)
      }
    } else {
      for member in source {
        guard let (key, value) = transform(member) else { return nil }
        target._unsafeInsertNew(key: key, value: value)
      }
    }
    self.init(_native: target)
  }
}
@inlinable public func _dictionaryUpCast<DerivedKey, DerivedValue, BaseKey, BaseValue>(_ source: Swift.Dictionary<DerivedKey, DerivedValue>) -> Swift.Dictionary<BaseKey, BaseValue> where DerivedKey : Swift.Hashable, BaseKey : Swift.Hashable {
  return Dictionary(
    _mapping: source,
    // String and NSString have different concepts of equality, so
    // NSString-keyed Dictionaries may generate key collisions when "upcasted"
    // to String. See rdar://problem/35995647
    allowingDuplicates: (BaseKey.self == String.self)
  ) { k, v in
    (k as! BaseKey, v as! BaseValue)
  }!
}
@inlinable public func _dictionaryDownCast<BaseKey, BaseValue, DerivedKey, DerivedValue>(_ source: Swift.Dictionary<BaseKey, BaseValue>) -> Swift.Dictionary<DerivedKey, DerivedValue> where BaseKey : Swift.Hashable, DerivedKey : Swift.Hashable {

  if _isClassOrObjCExistential(BaseKey.self)
  && _isClassOrObjCExistential(BaseValue.self)
  && _isClassOrObjCExistential(DerivedKey.self)
  && _isClassOrObjCExistential(DerivedValue.self) {

    guard source._variant.isNative else {
      return Dictionary(
        _immutableCocoaDictionary: source._variant.asCocoa.object)
    }
    // Note: it is safe to treat the buffer as immutable here because
    // Dictionary will not mutate buffer with reference count greater than 1.
    return Dictionary(
      _immutableCocoaDictionary: source._variant.asNative.bridged())
  }

  // Note: We can't delegate this call to _dictionaryDownCastConditional,
  // because we rely on as! to generate nice runtime errors when the downcast
  // fails.

  return Dictionary(
    _mapping: source,
    // String and NSString have different concepts of equality, so
    // NSString-keyed Dictionaries may generate key collisions when downcasted
    // to String. See rdar://problem/35995647
    allowingDuplicates: (DerivedKey.self == String.self)
  ) { k, v in
    (k as! DerivedKey, v as! DerivedValue)
  }!
}
@inlinable public func _dictionaryDownCastConditional<BaseKey, BaseValue, DerivedKey, DerivedValue>(_ source: Swift.Dictionary<BaseKey, BaseValue>) -> Swift.Dictionary<DerivedKey, DerivedValue>? where BaseKey : Swift.Hashable, DerivedKey : Swift.Hashable {
  return Dictionary(
    _mapping: source,
    // String and NSString have different concepts of equality, so
    // NSString-keyed Dictionaries may generate key collisions when downcasted
    // to String. See rdar://problem/35995647
    allowingDuplicates: (DerivedKey.self == String.self)
  ) { k, v in
    guard
      let key = k as? DerivedKey,
      let value = v as? DerivedValue
    else {
      return nil
    }
    return (key, value)
  }
}
@objc @_hasMissingDesignatedInitializers @usableFromInline
@_fixed_layout @_objc_non_lazy_realization internal class __RawDictionaryStorage : Swift.__SwiftNativeNSDictionary {
  @usableFromInline
  @nonobjc final internal var _count: Swift.Int
  @usableFromInline
  @nonobjc final internal var _capacity: Swift.Int
  @usableFromInline
  @nonobjc final internal var _scale: Swift.Int8
  @usableFromInline
  @nonobjc final internal var _reservedScale: Swift.Int8
  @nonobjc final internal var _extra: Swift.Int16
  @usableFromInline
  @nonobjc final internal var _age: Swift.Int32
  @usableFromInline
  final internal var _seed: Swift.Int
  @usableFromInline
  @nonobjc final internal var _rawKeys: Swift.UnsafeMutableRawPointer
  @usableFromInline
  @nonobjc final internal var _rawValues: Swift.UnsafeMutableRawPointer
  @inlinable @nonobjc final internal var _bucketCount: Swift.Int {
    @inline(__always) get { return 1 &<< _scale }
  }
  @inlinable @nonobjc final internal var _metadata: Swift.UnsafeMutablePointer<Swift._HashTable.Word> {
    @inline(__always) get {
      let address = Builtin.projectTailElems(self, _HashTable.Word.self)
      return UnsafeMutablePointer(address)
    }
  }
  @inlinable @nonobjc final internal var _hashTable: Swift._HashTable {
    @inline(__always) get {
      return _HashTable(words: _metadata, bucketCount: _bucketCount)
    }
  }
  @usableFromInline
  @objc override internal init(coder: Swift.AnyObject)
  @objc @usableFromInline
  deinit
}
@objc @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers @usableFromInline
@_fixed_layout @_objc_non_lazy_realization internal class __EmptyDictionarySingleton : Swift.__RawDictionaryStorage {
  @objc @usableFromInline
  deinit
}
extension __RawDictionaryStorage {
  @inlinable @nonobjc internal static var empty: Swift.__EmptyDictionarySingleton {
    get {
    return Builtin.bridgeFromRawPointer(
      Builtin.addressof(&_swiftEmptyDictionarySingleton))
  }
  }
  @_alwaysEmitIntoClient @inline(__always) final internal func uncheckedKey<Key>(at bucket: Swift._HashTable.Bucket) -> Key where Key : Swift.Hashable {
    defer { _fixLifetime(self) }
    _internalInvariant(_hashTable.isOccupied(bucket))
    let keys = _rawKeys.assumingMemoryBound(to: Key.self)
    return keys[bucket.offset]
  }
  @_alwaysEmitIntoClient @inline(never) final internal func find<Key>(_ key: Key) -> (bucket: Swift._HashTable.Bucket, found: Swift.Bool) where Key : Swift.Hashable {
    return find(key, hashValue: key._rawHashValue(seed: _seed))
  }
  @_alwaysEmitIntoClient @inline(never) final internal func find<Key>(_ key: Key, hashValue: Swift.Int) -> (bucket: Swift._HashTable.Bucket, found: Swift.Bool) where Key : Swift.Hashable {
      let hashTable = _hashTable
      var bucket = hashTable.idealBucket(forHashValue: hashValue)
      while hashTable._isOccupied(bucket) {
        if uncheckedKey(at: bucket) == key {
          return (bucket, true)
        }
        bucket = hashTable.bucket(wrappedAfter: bucket)
      }
      return (bucket, false)
  }
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers @usableFromInline
final internal class _DictionaryStorage<Key, Value> : Swift.__RawDictionaryStorage where Key : Swift.Hashable {
  @objc deinit
  @inlinable final internal var _keys: Swift.UnsafeMutablePointer<Key> {
    @inline(__always) get {
      return self._rawKeys.assumingMemoryBound(to: Key.self)
    }
  }
  @inlinable final internal var _values: Swift.UnsafeMutablePointer<Value> {
    @inline(__always) get {
      return self._rawValues.assumingMemoryBound(to: Value.self)
    }
  }
}
extension _DictionaryStorage {
  @usableFromInline
  @_effects(releasenone) internal static func copy(original: Swift.__RawDictionaryStorage) -> Swift._DictionaryStorage<Key, Value>
  @usableFromInline
  @_effects(releasenone) internal static func resize(original: Swift.__RawDictionaryStorage, capacity: Swift.Int, move: Swift.Bool) -> Swift._DictionaryStorage<Key, Value>
  @usableFromInline
  @_effects(releasenone) internal static func allocate(capacity: Swift.Int) -> Swift._DictionaryStorage<Key, Value>
  @usableFromInline
  @_effects(releasenone) internal static func convert(_ cocoa: Swift.__CocoaDictionary, capacity: Swift.Int) -> Swift._DictionaryStorage<Key, Value>
}
extension Dictionary {
  @usableFromInline
  @frozen internal struct _Variant {
    @usableFromInline
    internal var object: Swift._BridgeStorage<Swift.__RawDictionaryStorage>
    @inlinable @inline(__always) internal init(native: __owned Swift._NativeDictionary<Key, Value>) {
      self.object = _BridgeStorage(native: native._storage)
    }
    @inlinable @inline(__always) internal init(dummy: Swift.Void) {
      self.object = _BridgeStorage(taggedPayload: 0)
    }
    @inlinable @inline(__always) internal init(cocoa: __owned Swift.__CocoaDictionary) {
      self.object = _BridgeStorage(objC: cocoa.object)
    }
  }
}
extension Dictionary._Variant {
  @usableFromInline
  @_transparent internal var guaranteedNative: Swift.Bool {
    @_transparent get {
    return _canBeClass(Key.self) == 0 || _canBeClass(Value.self) == 0
  }
  }
  @inlinable internal mutating func isUniquelyReferenced() -> Swift.Bool {
    return object.isUniquelyReferencedUnflaggedNative()
  }
  @usableFromInline
  @_transparent internal var isNative: Swift.Bool {
    @_transparent get {
    if guaranteedNative { return true }
    return object.isUnflaggedNative
  }
  }
  @usableFromInline
  @_transparent internal var asNative: Swift._NativeDictionary<Key, Value> {
    @_transparent get {
      return _NativeDictionary<Key, Value>(object.unflaggedNativeInstance)
    }
    @_transparent set {
      self = .init(native: newValue)
    }
    @_transparent _modify {
      var native = _NativeDictionary<Key, Value>(object.unflaggedNativeInstance)
      self = .init(dummy: ())
      defer { object = .init(native: native._storage) }
      yield &native
    }
  }
  @inlinable internal var asCocoa: Swift.__CocoaDictionary {
    get {
    return __CocoaDictionary(object.objCInstance)
  }
  }
  @inlinable internal var capacity: Swift.Int {
    get {
    guard isNative else {
      return asCocoa.count
    }
    return asNative.capacity
  }
  }
}
extension Dictionary._Variant {
  @usableFromInline
  internal typealias Element = (key: Key, value: Value)
  @usableFromInline
  internal typealias Index = Swift.Dictionary<Key, Value>.Index
  @inlinable internal var startIndex: Swift.Dictionary<Key, Value>._Variant.Index {
    get {
    guard isNative else {
      return Index(_cocoa: asCocoa.startIndex)
    }
    return asNative.startIndex
  }
  }
  @inlinable internal var endIndex: Swift.Dictionary<Key, Value>._Variant.Index {
    get {
    guard isNative else {
      return Index(_cocoa: asCocoa.endIndex)
    }
    return asNative.endIndex
  }
  }
  @inlinable internal func index(after index: Swift.Dictionary<Key, Value>._Variant.Index) -> Swift.Dictionary<Key, Value>._Variant.Index {
    guard isNative else {
      return Index(_cocoa: asCocoa.index(after: index._asCocoa))
    }
    return asNative.index(after: index)
  }
  @inlinable internal func formIndex(after index: inout Swift.Dictionary<Key, Value>._Variant.Index) {
    guard isNative else {
      let isUnique = index._isUniquelyReferenced()
      asCocoa.formIndex(after: &index._asCocoa, isUnique: isUnique)
      return
    }
    index = asNative.index(after: index)
  }
  @inlinable @inline(__always) internal func index(forKey key: Key) -> Swift.Dictionary<Key, Value>._Variant.Index? {
    guard isNative else {
      let cocoaKey = _bridgeAnythingToObjectiveC(key)
      guard let index = asCocoa.index(forKey: cocoaKey) else { return nil }
      return Index(_cocoa: index)
    }
    return asNative.index(forKey: key)
  }
  @inlinable internal var count: Swift.Int {
    @inline(__always) get {
      guard isNative else {
        return asCocoa.count
      }
      return asNative.count
    }
  }
  @inlinable @inline(__always) internal func contains(_ key: Key) -> Swift.Bool {
    guard isNative else {
      let cocoaKey = _bridgeAnythingToObjectiveC(key)
      return asCocoa.contains(cocoaKey)
    }
    return asNative.contains(key)
  }
  @inlinable @inline(__always) internal func lookup(_ key: Key) -> Value? {
    guard isNative else {
      let cocoaKey = _bridgeAnythingToObjectiveC(key)
      guard let cocoaValue = asCocoa.lookup(cocoaKey) else { return nil }
      return _forceBridgeFromObjectiveC(cocoaValue, Value.self)
    }
    return asNative.lookup(key)
  }
  @inlinable @inline(__always) internal func lookup(_ index: Swift.Dictionary<Key, Value>._Variant.Index) -> (key: Key, value: Value) {
    guard isNative else {
      let (cocoaKey, cocoaValue) = asCocoa.lookup(index._asCocoa)
      let nativeKey = _forceBridgeFromObjectiveC(cocoaKey, Key.self)
      let nativeValue = _forceBridgeFromObjectiveC(cocoaValue, Value.self)
      return (nativeKey, nativeValue)
    }
    return asNative.lookup(index)
  }
  @inlinable @inline(__always) internal func key(at index: Swift.Dictionary<Key, Value>._Variant.Index) -> Key {
    guard isNative else {
      let cocoaKey = asCocoa.key(at: index._asCocoa)
      return _forceBridgeFromObjectiveC(cocoaKey, Key.self)
    }
    return asNative.key(at: index)
  }
  @inlinable @inline(__always) internal func value(at index: Swift.Dictionary<Key, Value>._Variant.Index) -> Value {
    guard isNative else {
      let cocoaValue = asCocoa.value(at: index._asCocoa)
      return _forceBridgeFromObjectiveC(cocoaValue, Value.self)
    }
    return asNative.value(at: index)
  }
}
extension Dictionary._Variant {
  @inlinable internal subscript(key: Key) -> Value? {
    @inline(__always) get {
      return lookup(key)
    }
    @inline(__always) _modify {
      guard isNative else {
        let cocoa = asCocoa
        var native = _NativeDictionary<Key, Value>(
          cocoa, capacity: cocoa.count + 1)
        self = .init(native: native)
        yield &native[key, isUnique: true]
        return
      }
      let isUnique = isUniquelyReferenced()
      yield &asNative[key, isUnique: isUnique]
    }
  }
}
extension Dictionary._Variant {
  @inlinable @inline(__always) internal mutating func mutatingFind(_ key: Key) -> (bucket: Swift._NativeDictionary<Key, Value>.Bucket, found: Swift.Bool) {
    guard isNative else {
      let cocoa = asCocoa
      var native = _NativeDictionary<Key, Value>(
        cocoa, capacity: cocoa.count + 1)
      let result = native.mutatingFind(key, isUnique: true)
      self = .init(native: native)
      return result
    }
    let isUnique = isUniquelyReferenced()
    return asNative.mutatingFind(key, isUnique: isUnique)
  }
  @inlinable @inline(__always) internal mutating func ensureUniqueNative() -> Swift._NativeDictionary<Key, Value> {
    guard isNative else {
      let native = _NativeDictionary<Key, Value>(asCocoa)
      self = .init(native: native)
      return native
    }
    let isUnique = isUniquelyReferenced()
    if !isUnique {
      asNative.copy()
    }
    return asNative
  }
  @inlinable internal mutating func updateValue(_ value: __owned Value, forKey key: Key) -> Value? {
    guard isNative else {
      // Make sure we have space for an extra element.
      let cocoa = asCocoa
      var native = _NativeDictionary<Key, Value>(
        cocoa,
        capacity: cocoa.count + 1)
      let result = native.updateValue(value, forKey: key, isUnique: true)
      self = .init(native: native)
      return result
    }
    let isUnique = self.isUniquelyReferenced()
    return asNative.updateValue(value, forKey: key, isUnique: isUnique)
  }
  @inlinable internal mutating func setValue(_ value: __owned Value, forKey key: Key) {
    if !isNative {
      // Make sure we have space for an extra element.
      let cocoa = asCocoa
      self = .init(native: _NativeDictionary<Key, Value>(
        cocoa,
        capacity: cocoa.count + 1))
    }
    let isUnique = self.isUniquelyReferenced()
    asNative.setValue(value, forKey: key, isUnique: isUnique)
  }
  @inlinable @_semantics("optimize.sil.specialize.generic.size.never") internal mutating func remove(at index: Swift.Dictionary<Key, Value>._Variant.Index) -> Swift.Dictionary<Key, Value>._Variant.Element {
    // FIXME(performance): fuse data migration and element deletion into one
    // operation.
    let native = ensureUniqueNative()
    let bucket = native.validatedBucket(for: index)
    return asNative.uncheckedRemove(at: bucket, isUnique: true)
  }
  @inlinable internal mutating func removeValue(forKey key: Key) -> Value? {
    guard isNative else {
      let cocoaKey = _bridgeAnythingToObjectiveC(key)
      let cocoa = asCocoa
      guard cocoa.lookup(cocoaKey) != nil else { return nil }
      var native = _NativeDictionary<Key, Value>(cocoa)
      let (bucket, found) = native.find(key)
      _precondition(found, "Bridging did not preserve equality")
      let old = native.uncheckedRemove(at: bucket, isUnique: true).value
      self = .init(native: native)
      return old
    }
    let (bucket, found) = asNative.find(key)
    guard found else { return nil }
    let isUnique = isUniquelyReferenced()
    return asNative.uncheckedRemove(at: bucket, isUnique: isUnique).value
  }
  @inlinable @_semantics("optimize.sil.specialize.generic.size.never") internal mutating func removeAll(keepingCapacity keepCapacity: Swift.Bool) {
    if !keepCapacity {
      self = .init(native: _NativeDictionary())
      return
    }
    guard count > 0 else { return }

    guard isNative else {
      self = .init(native: _NativeDictionary(capacity: asCocoa.count))
      return
    }
    let isUnique = isUniquelyReferenced()
    asNative.removeAll(isUnique: isUnique)
  }
}
extension Dictionary._Variant {
  @inlinable @inline(__always) __consuming internal func makeIterator() -> Swift.Dictionary<Key, Value>.Iterator {
    guard isNative else {
      return Dictionary.Iterator(_cocoa: asCocoa.makeIterator())
    }
    return Dictionary.Iterator(_native: asNative.makeIterator())
  }
}
extension Dictionary._Variant {
  @inlinable internal func mapValues<T>(_ transform: (Value) throws -> T) rethrows -> Swift._NativeDictionary<Key, T> {
    guard isNative else {
      return try asCocoa.mapValues(transform)
    }
    return try asNative.mapValues(transform)
  }
  @inlinable internal mutating func merge<S>(_ keysAndValues: __owned S, uniquingKeysWith combine: (Value, Value) throws -> Value) rethrows where S : Swift.Sequence, S.Element == (Key, Value) {
    guard isNative else {
      var native = _NativeDictionary<Key, Value>(asCocoa)
      try native.merge(
        keysAndValues,
        isUnique: true,
        uniquingKeysWith: combine)
      self = .init(native: native)
      return
    }
    let isUnique = isUniquelyReferenced()
    try asNative.merge(
      keysAndValues,
      isUnique: isUnique,
      uniquingKeysWith: combine)
  }
}
@frozen public struct LazyDropWhileSequence<Base> where Base : Swift.Sequence {
  public typealias Element = Base.Element
  @inlinable internal init(_base: Base, predicate: @escaping (Swift.LazyDropWhileSequence<Base>.Element) -> Swift.Bool) {
    self._base = _base
    self._predicate = predicate
  }
  @usableFromInline
  internal var _base: Base
  @usableFromInline
  internal let _predicate: (Swift.LazyDropWhileSequence<Base>.Element) -> Swift.Bool
}
extension LazyDropWhileSequence {
  @frozen public struct Iterator {
    public typealias Element = Base.Element
    @inlinable internal init(_base: Base.Iterator, predicate: @escaping (Swift.LazyDropWhileSequence<Base>.Iterator.Element) -> Swift.Bool) {
      self._base = _base
      self._predicate = predicate
    }
    @usableFromInline
    internal var _predicateHasFailed: Swift.Bool = false
    @usableFromInline
    internal var _base: Base.Iterator
    @usableFromInline
    internal let _predicate: (Swift.LazyDropWhileSequence<Base>.Iterator.Element) -> Swift.Bool
  }
}
extension LazyDropWhileSequence.Iterator : Swift.IteratorProtocol {
  @inlinable public mutating func next() -> Swift.LazyDropWhileSequence<Base>.Iterator.Element? {
    // Once the predicate has failed for the first time, the base iterator
    // can be used for the rest of the elements.
    if _predicateHasFailed {
      return _base.next()
    }

    // Retrieve and discard elements from the base iterator until one fails
    // the predicate.
    while let nextElement = _base.next() {
      if !_predicate(nextElement) {
        _predicateHasFailed = true
        return nextElement
      }
    }
    return nil
  }
}
extension LazyDropWhileSequence : Swift.Sequence {
  @inlinable __consuming public func makeIterator() -> Swift.LazyDropWhileSequence<Base>.Iterator {
    return Iterator(_base: _base.makeIterator(), predicate: _predicate)
  }
}
extension LazyDropWhileSequence : Swift.LazySequenceProtocol {
  public typealias Elements = Swift.LazyDropWhileSequence<Base>
}
extension LazySequenceProtocol {
  @inlinable __consuming public func drop(while predicate: @escaping (Self.Elements.Element) -> Swift.Bool) -> Swift.LazyDropWhileSequence<Self.Elements> {
    return LazyDropWhileSequence(_base: self.elements, predicate: predicate)
  }
}
public typealias LazyDropWhileCollection<T> = Swift.LazyDropWhileSequence<T> where T : Swift.Collection
extension Swift.LazyDropWhileCollection : Swift.Collection where Base : Swift.Collection {
  public typealias SubSequence = Swift.Slice<Swift.LazyDropWhileCollection<Base>>
  public typealias Index = Base.Index
  @inlinable public var startIndex: Swift.LazyDropWhileSequence<Base>.Index {
    get {
    var index = _base.startIndex
    while index != _base.endIndex && _predicate(_base[index]) {
      _base.formIndex(after: &index)
    }
    return index
  }
  }
  @inlinable public var endIndex: Swift.LazyDropWhileSequence<Base>.Index {
    get {
    return _base.endIndex
  }
  }
  @inlinable public func index(after i: Swift.LazyDropWhileSequence<Base>.Index) -> Swift.LazyDropWhileSequence<Base>.Index {
    _precondition(i < _base.endIndex, "Can't advance past endIndex")
    return _base.index(after: i)
  }
  @inlinable public subscript(position: Swift.LazyDropWhileSequence<Base>.Index) -> Swift.LazyDropWhileSequence<Base>.Element {
    get {
    return _base[position]
  }
  }
  public typealias Indices = Swift.DefaultIndices<Swift.LazyDropWhileSequence<Base>>
}
extension Swift.LazyDropWhileCollection : Swift.BidirectionalCollection where Base : Swift.BidirectionalCollection {
  @inlinable public func index(before i: Swift.LazyDropWhileSequence<Base>.Index) -> Swift.LazyDropWhileSequence<Base>.Index {
    _precondition(i > startIndex, "Can't move before startIndex")
    return _base.index(before: i)
  }
}
extension Swift.LazyDropWhileCollection : Swift.LazyCollectionProtocol where Base : Swift.Collection {
}
@discardableResult
@_semantics("optimize.sil.specialize.generic.never") public func dump<T, TargetStream>(_ value: T, to target: inout TargetStream, name: Swift.String? = nil, indent: Swift.Int = 0, maxDepth: Swift.Int = .max, maxItems: Swift.Int = .max) -> T where TargetStream : Swift.TextOutputStream
@discardableResult
@_semantics("optimize.sil.specialize.generic.never") public func dump<T>(_ value: T, name: Swift.String? = nil, indent: Swift.Int = 0, maxDepth: Swift.Int = .max, maxItems: Swift.Int = .max) -> T
@frozen public struct EmptyCollection<Element> {
  @inlinable public init() {}
}
extension EmptyCollection {
  @frozen public struct Iterator {
    @inlinable public init() {}
  }
}
extension EmptyCollection.Iterator : Swift.IteratorProtocol, Swift.Sequence {
  @inlinable public mutating func next() -> Element? {
    return nil
  }
  public typealias Iterator = Swift.EmptyCollection<Element>.Iterator
}
extension EmptyCollection : Swift.Sequence {
  @inlinable public func makeIterator() -> Swift.EmptyCollection<Element>.Iterator {
    return Iterator()
  }
}
extension EmptyCollection : Swift.RandomAccessCollection, Swift.MutableCollection {
  public typealias Index = Swift.Int
  public typealias Indices = Swift.Range<Swift.Int>
  public typealias SubSequence = Swift.EmptyCollection<Element>
  @inlinable public var startIndex: Swift.EmptyCollection<Element>.Index {
    get {
    return 0
  }
  }
  @inlinable public var endIndex: Swift.EmptyCollection<Element>.Index {
    get {
    return 0
  }
  }
  @inlinable public func index(after i: Swift.EmptyCollection<Element>.Index) -> Swift.EmptyCollection<Element>.Index {
    _preconditionFailure("EmptyCollection can't advance indices")
  }
  @inlinable public func index(before i: Swift.EmptyCollection<Element>.Index) -> Swift.EmptyCollection<Element>.Index {
    _preconditionFailure("EmptyCollection can't advance indices")
  }
  @inlinable public subscript(position: Swift.EmptyCollection<Element>.Index) -> Element {
    get {
      _preconditionFailure("Index out of range")
    }
    set {
      _preconditionFailure("Index out of range")
    }
  }
  @inlinable public subscript(bounds: Swift.Range<Swift.EmptyCollection<Element>.Index>) -> Swift.EmptyCollection<Element>.SubSequence {
    get {
      _debugPrecondition(bounds.lowerBound == 0 && bounds.upperBound == 0,
        "Index out of range")
      return self
    }
    set {
      _debugPrecondition(bounds.lowerBound == 0 && bounds.upperBound == 0,
        "Index out of range")
    }
  }
  @inlinable public var count: Swift.Int {
    get {
    return 0
  }
  }
  @inlinable public func index(_ i: Swift.EmptyCollection<Element>.Index, offsetBy n: Swift.Int) -> Swift.EmptyCollection<Element>.Index {
    _debugPrecondition(i == startIndex && n == 0, "Index out of range")
    return i
  }
  @inlinable public func index(_ i: Swift.EmptyCollection<Element>.Index, offsetBy n: Swift.Int, limitedBy limit: Swift.EmptyCollection<Element>.Index) -> Swift.EmptyCollection<Element>.Index? {
    _debugPrecondition(i == startIndex && limit == startIndex,
      "Index out of range")
    return n == 0 ? i : nil
  }
  @inlinable public func distance(from start: Swift.EmptyCollection<Element>.Index, to end: Swift.EmptyCollection<Element>.Index) -> Swift.Int {
    _debugPrecondition(start == 0, "From must be startIndex (or endIndex)")
    _debugPrecondition(end == 0, "To must be endIndex (or startIndex)")
    return 0
  }
  @inlinable public func _failEarlyRangeCheck(_ index: Swift.EmptyCollection<Element>.Index, bounds: Swift.Range<Swift.EmptyCollection<Element>.Index>) {
    _debugPrecondition(index == 0, "out of bounds")
    _debugPrecondition(bounds == indices, "invalid bounds for an empty collection")
  }
  @inlinable public func _failEarlyRangeCheck(_ range: Swift.Range<Swift.EmptyCollection<Element>.Index>, bounds: Swift.Range<Swift.EmptyCollection<Element>.Index>) {
    _debugPrecondition(range == indices, "invalid range for an empty collection")
    _debugPrecondition(bounds == indices, "invalid bounds for an empty collection")
  }
}
extension EmptyCollection : Swift.Equatable {
  @inlinable public static func == (lhs: Swift.EmptyCollection<Element>, rhs: Swift.EmptyCollection<Element>) -> Swift.Bool {
    return true
  }
}
public protocol Equatable {
  static func == (lhs: Self, rhs: Self) -> Swift.Bool
}
extension Equatable {
  @_transparent public static func != (lhs: Self, rhs: Self) -> Swift.Bool {
    return !(lhs == rhs)
  }
}
@inlinable public func === (lhs: Swift.AnyObject?, rhs: Swift.AnyObject?) -> Swift.Bool {
  switch (lhs, rhs) {
  case let (l?, r?):
    return ObjectIdentifier(l) == ObjectIdentifier(r)
  case (nil, nil):
    return true
  default:
    return false
  }
}
@inlinable public func !== (lhs: Swift.AnyObject?, rhs: Swift.AnyObject?) -> Swift.Bool {
  return !(lhs === rhs)
}
public protocol Error {
  var _domain: Swift.String { get }
  var _code: Swift.Int { get }
  var _userInfo: Swift.AnyObject? { get }
  func _getEmbeddedNSError() -> Swift.AnyObject?
}
extension Error {
  public func _getEmbeddedNSError() -> Swift.AnyObject?
}
public func _getErrorEmbeddedNSError<T>(_ x: T) -> Swift.AnyObject? where T : Swift.Error
@_silgen_name("_swift_stdlib_bridgeErrorToNSError")
public func _bridgeErrorToNSError(_ error: __owned Swift.Error) -> Swift.AnyObject
@_silgen_name("swift_unexpectedError")
public func _unexpectedError(_ error: __owned Swift.Error, filenameStart: Builtin.RawPointer, filenameLength: Builtin.Word, filenameIsASCII: Builtin.Int1, line: Builtin.Word)
@_silgen_name("swift_errorInMain")
public func _errorInMain(_ error: Swift.Error)
@_silgen_name("_swift_stdlib_getDefaultErrorCode")
public func _getDefaultErrorCode<T>(_ error: T) -> Swift.Int where T : Swift.Error
extension Error {
  public var _code: Swift.Int {
    get
  }
  public var _domain: Swift.String {
    get
  }
  public var _userInfo: Swift.AnyObject? {
    get
  }
}
extension Error where Self : Swift.RawRepresentable, Self.RawValue : Swift.FixedWidthInteger {
  public var _code: Swift.Int {
    get
  }
}
@usableFromInline
@inline(never) internal func _abstract(file: Swift.StaticString = #file, line: Swift.UInt = #line) -> Swift.Never
@frozen public struct AnyIterator<Element> {
  @usableFromInline
  internal let _box: Swift._AnyIteratorBoxBase<Element>
  @inlinable public init<I>(_ base: I) where Element == I.Element, I : Swift.IteratorProtocol {
    self._box = _IteratorBox(base)
  }
  @inlinable public init(_ body: @escaping () -> Element?) {
    self._box = _IteratorBox(_ClosureBasedIterator(body))
  }
  @inlinable internal init(_box: Swift._AnyIteratorBoxBase<Element>) {
    self._box = _box
  }
}
extension AnyIterator : Swift.IteratorProtocol {
  @inlinable public func next() -> Element? {
    return _box.next()
  }
}
extension AnyIterator : Swift.Sequence {
  public typealias Iterator = Swift.AnyIterator<Element>
}
@usableFromInline
@frozen internal struct _ClosureBasedIterator<Element> : Swift.IteratorProtocol {
  @inlinable internal init(_ body: @escaping () -> Element?) {
    self._body = body
  }
  @inlinable internal func next() -> Element? { return _body() }
  @usableFromInline
  internal let _body: () -> Element?
}
@usableFromInline
@_fixed_layout internal class _AnyIteratorBoxBase<Element> : Swift.IteratorProtocol {
  @inlinable internal init() {}
  @objc @inlinable deinit {}
  @inlinable internal func next() -> Element? { _abstract() }
}
@usableFromInline
@_fixed_layout final internal class _IteratorBox<Base> : Swift._AnyIteratorBoxBase<Base.Element> where Base : Swift.IteratorProtocol {
  @inlinable internal init(_ base: Base) { self._base = base }
  @objc @inlinable deinit {}
  @inlinable override final internal func next() -> Base.Element? { return _base.next() }
  @usableFromInline
  final internal var _base: Base
  @inlinable override internal init()
}
@usableFromInline
@_fixed_layout internal class _AnySequenceBox<Element> {
  @inlinable internal init() { }
  @inlinable internal func _makeIterator() -> Swift.AnyIterator<Element> { _abstract() }
  @inlinable internal var _underestimatedCount: Swift.Int {
    get { _abstract() }
  }
  @inlinable internal func _map<T>(_ transform: (Element) throws -> T) rethrows -> [T] {
    _abstract()
  }
  @inlinable internal func _filter(_ isIncluded: (Element) throws -> Swift.Bool) rethrows -> [Element] {
    _abstract()
  }
  @inlinable internal func _forEach(_ body: (Element) throws -> Swift.Void) rethrows {
    _abstract()
  }
  @inlinable internal func __customContainsEquatableElement(_ element: Element) -> Swift.Bool? {
    _abstract()
  }
  @inlinable internal func __copyToContiguousArray() -> Swift.ContiguousArray<Element> {
    _abstract()
  }
  @inlinable internal func __copyContents(initializing buf: Swift.UnsafeMutableBufferPointer<Element>) -> (Swift.AnyIterator<Element>, Swift.UnsafeMutableBufferPointer<Element>.Index) {
    _abstract()
  }
  @objc @inlinable deinit {}
  @inlinable internal func _drop(while predicate: (Element) throws -> Swift.Bool) rethrows -> Swift._AnySequenceBox<Element> {
    _abstract()
  }
  @inlinable internal func _dropFirst(_ n: Swift.Int) -> Swift._AnySequenceBox<Element> {
    _abstract()
  }
  @inlinable internal func _dropLast(_ n: Swift.Int) -> [Element] {
    _abstract()
  }
  @inlinable internal func _prefix(_ maxLength: Swift.Int) -> Swift._AnySequenceBox<Element> {
    _abstract()
  }
  @inlinable internal func _prefix(while predicate: (Element) throws -> Swift.Bool) rethrows -> [Element] {
    _abstract()
  }
  @inlinable internal func _suffix(_ maxLength: Swift.Int) -> [Element] {
    _abstract()
  }
}
@usableFromInline
@_fixed_layout internal class _AnyCollectionBox<Element> : Swift._AnySequenceBox<Element> {
  @objc @inlinable deinit {}
  @inlinable override internal func _drop(while predicate: (Element) throws -> Swift.Bool) rethrows -> Swift._AnyCollectionBox<Element> {
    _abstract()
  }
  @inlinable override internal func _dropFirst(_ n: Swift.Int) -> Swift._AnyCollectionBox<Element> {
    _abstract()
  }
  @inlinable internal func _dropLast(_ n: Swift.Int) -> Swift._AnyCollectionBox<Element> {
    _abstract()
  }
  @inlinable override internal func _prefix(_ maxLength: Swift.Int) -> Swift._AnyCollectionBox<Element> {
    _abstract()
  }
  @inlinable internal func _prefix(while predicate: (Element) throws -> Swift.Bool) rethrows -> Swift._AnyCollectionBox<Element> {
    _abstract()
  }
  @inlinable internal func _suffix(_ maxLength: Swift.Int) -> Swift._AnyCollectionBox<Element> {
    _abstract()
  }
  @inlinable internal subscript(i: Swift._AnyIndexBox) -> Element {
    get { _abstract() }
  }
  @inlinable internal func _index(after i: Swift._AnyIndexBox) -> Swift._AnyIndexBox { _abstract() }
  @inlinable internal func _formIndex(after i: Swift._AnyIndexBox) { _abstract() }
  @inlinable internal func _index(_ i: Swift._AnyIndexBox, offsetBy n: Swift.Int) -> Swift._AnyIndexBox {
    _abstract()
  }
  @inlinable internal func _index(_ i: Swift._AnyIndexBox, offsetBy n: Swift.Int, limitedBy limit: Swift._AnyIndexBox) -> Swift._AnyIndexBox? {
    _abstract()
  }
  @inlinable internal func _formIndex(_ i: inout Swift._AnyIndexBox, offsetBy n: Swift.Int) {
    _abstract()
  }
  @inlinable internal func _formIndex(_ i: inout Swift._AnyIndexBox, offsetBy n: Swift.Int, limitedBy limit: Swift._AnyIndexBox) -> Swift.Bool {
    _abstract()
  }
  @inlinable internal func _distance(from start: Swift._AnyIndexBox, to end: Swift._AnyIndexBox) -> Swift.Int {
    _abstract()
  }
  @inlinable internal var _count: Swift.Int {
    get { _abstract() }
  }
  @inlinable internal init(_startIndex: Swift._AnyIndexBox, endIndex: Swift._AnyIndexBox) {
    self._startIndex = _startIndex
    self._endIndex = endIndex
  }
  @usableFromInline
  final internal let _startIndex: Swift._AnyIndexBox
  @usableFromInline
  final internal let _endIndex: Swift._AnyIndexBox
  @inlinable internal subscript(start start: Swift._AnyIndexBox, end end: Swift._AnyIndexBox) -> Swift._AnyCollectionBox<Element> {
    get { _abstract() }
  }
  @inlinable override internal init()
}
@_inheritsConvenienceInitializers @usableFromInline
@_fixed_layout internal class _AnyBidirectionalCollectionBox<Element> : Swift._AnyCollectionBox<Element> {
  @objc @inlinable deinit {}
  @inlinable override internal func _drop(while predicate: (Element) throws -> Swift.Bool) rethrows -> Swift._AnyBidirectionalCollectionBox<Element> {
    _abstract()
  }
  @inlinable override internal func _dropFirst(_ n: Swift.Int) -> Swift._AnyBidirectionalCollectionBox<Element> {
    _abstract()
  }
  @inlinable override internal func _dropLast(_ n: Swift.Int) -> Swift._AnyBidirectionalCollectionBox<Element> {
    _abstract()
  }
  @inlinable override internal func _prefix(_ maxLength: Swift.Int) -> Swift._AnyBidirectionalCollectionBox<Element> {
    _abstract()
  }
  @inlinable override internal func _prefix(while predicate: (Element) throws -> Swift.Bool) rethrows -> Swift._AnyBidirectionalCollectionBox<Element> {
    _abstract()
  }
  @inlinable override internal func _suffix(_ maxLength: Swift.Int) -> Swift._AnyBidirectionalCollectionBox<Element> {
    _abstract()
  }
  @inlinable override internal subscript(start start: Swift._AnyIndexBox, end end: Swift._AnyIndexBox) -> Swift._AnyBidirectionalCollectionBox<Element> {
    get { _abstract() }
  }
  @inlinable internal func _index(before i: Swift._AnyIndexBox) -> Swift._AnyIndexBox { _abstract() }
  @inlinable internal func _formIndex(before i: Swift._AnyIndexBox) { _abstract() }
  @inlinable override internal init(_startIndex: Swift._AnyIndexBox, endIndex: Swift._AnyIndexBox)
}
@_inheritsConvenienceInitializers @usableFromInline
@_fixed_layout internal class _AnyRandomAccessCollectionBox<Element> : Swift._AnyBidirectionalCollectionBox<Element> {
  @objc @inlinable deinit {}
  @inlinable override internal func _drop(while predicate: (Element) throws -> Swift.Bool) rethrows -> Swift._AnyRandomAccessCollectionBox<Element> {
    _abstract()
  }
  @inlinable override internal func _dropFirst(_ n: Swift.Int) -> Swift._AnyRandomAccessCollectionBox<Element> {
    _abstract()
  }
  @inlinable override internal func _dropLast(_ n: Swift.Int) -> Swift._AnyRandomAccessCollectionBox<Element> {
    _abstract()
  }
  @inlinable override internal func _prefix(_ maxLength: Swift.Int) -> Swift._AnyRandomAccessCollectionBox<Element> {
    _abstract()
  }
  @inlinable override internal func _prefix(while predicate: (Element) throws -> Swift.Bool) rethrows -> Swift._AnyRandomAccessCollectionBox<Element> {
    _abstract()
  }
  @inlinable override internal func _suffix(_ maxLength: Swift.Int) -> Swift._AnyRandomAccessCollectionBox<Element> {
    _abstract()
  }
  @inlinable override internal subscript(start start: Swift._AnyIndexBox, end end: Swift._AnyIndexBox) -> Swift._AnyRandomAccessCollectionBox<Element> {
    get { _abstract() }
  }
  @inlinable override internal init(_startIndex: Swift._AnyIndexBox, endIndex: Swift._AnyIndexBox)
}
@usableFromInline
@_fixed_layout final internal class _SequenceBox<S> : Swift._AnySequenceBox<S.Element> where S : Swift.Sequence {
  @usableFromInline
  internal typealias Element = S.Element
  @inline(__always) @inlinable override final internal func _makeIterator() -> Swift.AnyIterator<Swift._SequenceBox<S>.Element> {
    return AnyIterator(_base.makeIterator())
  }
  @inlinable override final internal var _underestimatedCount: Swift.Int {
    get {
    return _base.underestimatedCount
  }
  }
  @inlinable override final internal func _map<T>(_ transform: (Swift._SequenceBox<S>.Element) throws -> T) rethrows -> [T] {
    return try _base.map(transform)
  }
  @inlinable override final internal func _filter(_ isIncluded: (Swift._SequenceBox<S>.Element) throws -> Swift.Bool) rethrows -> [Swift._SequenceBox<S>.Element] {
    return try _base.filter(isIncluded)
  }
  @inlinable override final internal func _forEach(_ body: (Swift._SequenceBox<S>.Element) throws -> Swift.Void) rethrows {
    return try _base.forEach(body)
  }
  @inlinable override final internal func __customContainsEquatableElement(_ element: Swift._SequenceBox<S>.Element) -> Swift.Bool? {
    return _base._customContainsEquatableElement(element)
  }
  @inlinable override final internal func __copyToContiguousArray() -> Swift.ContiguousArray<Swift._SequenceBox<S>.Element> {
    return _base._copyToContiguousArray()
  }
  @inlinable override final internal func __copyContents(initializing buf: Swift.UnsafeMutableBufferPointer<Swift._SequenceBox<S>.Element>) -> (Swift.AnyIterator<Swift._SequenceBox<S>.Element>, Swift.UnsafeMutableBufferPointer<Swift._SequenceBox<S>.Element>.Index) {
    let (it,idx) = _base._copyContents(initializing: buf)
    return (AnyIterator(it),idx)
  }
  @inlinable override final internal func _dropFirst(_ n: Swift.Int) -> Swift._AnySequenceBox<Swift._SequenceBox<S>.Element> {
    return _SequenceBox<DropFirstSequence<S>>(_base: _base.dropFirst(n))
  }
  @inlinable override final internal func _drop(while predicate: (Swift._SequenceBox<S>.Element) throws -> Swift.Bool) rethrows -> Swift._AnySequenceBox<Swift._SequenceBox<S>.Element> {
    return try _SequenceBox<DropWhileSequence<S>>(_base: _base.drop(while: predicate))
  }
  @inlinable override final internal func _dropLast(_ n: Swift.Int) -> [Swift._SequenceBox<S>.Element] {
    return _base.dropLast(n)
  }
  @inlinable override final internal func _prefix(_ n: Swift.Int) -> Swift._AnySequenceBox<Swift._SequenceBox<S>.Element> {
    return _SequenceBox<PrefixSequence<S>>(_base: _base.prefix(n))
  }
  @inlinable override final internal func _prefix(while predicate: (Swift._SequenceBox<S>.Element) throws -> Swift.Bool) rethrows -> [Swift._SequenceBox<S>.Element] {
    return try _base.prefix(while: predicate)
  }
  @inlinable override final internal func _suffix(_ maxLength: Swift.Int) -> [Swift._SequenceBox<S>.Element] {
    return _base.suffix(maxLength)
  }
  @objc @inlinable deinit {}
  @inlinable internal init(_base: S) {
    self._base = _base
  }
  @usableFromInline
  final internal var _base: S
  @inlinable override internal init()
}
@usableFromInline
@_fixed_layout final internal class _CollectionBox<S> : Swift._AnyCollectionBox<S.Element> where S : Swift.Collection {
  @usableFromInline
  internal typealias Element = S.Element
  @inline(__always) @inlinable override final internal func _makeIterator() -> Swift.AnyIterator<Swift._CollectionBox<S>.Element> {
    return AnyIterator(_base.makeIterator())
  }
  @inlinable override final internal var _underestimatedCount: Swift.Int {
    get {
    return _base.underestimatedCount
  }
  }
  @inlinable override final internal func _map<T>(_ transform: (Swift._CollectionBox<S>.Element) throws -> T) rethrows -> [T] {
    return try _base.map(transform)
  }
  @inlinable override final internal func _filter(_ isIncluded: (Swift._CollectionBox<S>.Element) throws -> Swift.Bool) rethrows -> [Swift._CollectionBox<S>.Element] {
    return try _base.filter(isIncluded)
  }
  @inlinable override final internal func _forEach(_ body: (Swift._CollectionBox<S>.Element) throws -> Swift.Void) rethrows {
    return try _base.forEach(body)
  }
  @inlinable override final internal func __customContainsEquatableElement(_ element: Swift._CollectionBox<S>.Element) -> Swift.Bool? {
    return _base._customContainsEquatableElement(element)
  }
  @inlinable override final internal func __copyToContiguousArray() -> Swift.ContiguousArray<Swift._CollectionBox<S>.Element> {
    return _base._copyToContiguousArray()
  }
  @inlinable override final internal func __copyContents(initializing buf: Swift.UnsafeMutableBufferPointer<Swift._CollectionBox<S>.Element>) -> (Swift.AnyIterator<Swift._CollectionBox<S>.Element>, Swift.UnsafeMutableBufferPointer<Swift._CollectionBox<S>.Element>.Index) {
    let (it,idx) = _base._copyContents(initializing: buf)
    return (AnyIterator(it),idx)
  }
  @inline(__always) @inlinable override final internal func _drop(while predicate: (Swift._CollectionBox<S>.Element) throws -> Swift.Bool) rethrows -> Swift._AnyCollectionBox<Swift._CollectionBox<S>.Element> {
    return try _CollectionBox<S.SubSequence>(_base: _base.drop(while: predicate))
  }
  @inline(__always) @inlinable override final internal func _dropFirst(_ n: Swift.Int) -> Swift._AnyCollectionBox<Swift._CollectionBox<S>.Element> {
    return _CollectionBox<S.SubSequence>(_base: _base.dropFirst(n))
  }
  @inline(__always) @inlinable override final internal func _dropLast(_ n: Swift.Int) -> Swift._AnyCollectionBox<Swift._CollectionBox<S>.Element> {
    return _CollectionBox<S.SubSequence>(_base: _base.dropLast(n))
  }
  @inline(__always) @inlinable override final internal func _prefix(while predicate: (Swift._CollectionBox<S>.Element) throws -> Swift.Bool) rethrows -> Swift._AnyCollectionBox<Swift._CollectionBox<S>.Element> {
    return try _CollectionBox<S.SubSequence>(_base: _base.prefix(while: predicate))
  }
  @inline(__always) @inlinable override final internal func _prefix(_ maxLength: Swift.Int) -> Swift._AnyCollectionBox<Swift._CollectionBox<S>.Element> {
    return _CollectionBox<S.SubSequence>(_base: _base.prefix(maxLength))
  }
  @inline(__always) @inlinable override final internal func _suffix(_ maxLength: Swift.Int) -> Swift._AnyCollectionBox<Swift._CollectionBox<S>.Element> {
    return _CollectionBox<S.SubSequence>(_base: _base.suffix(maxLength))
  }
  @objc @inlinable deinit {}
  @inlinable internal init(_base: S) {
    self._base = _base
    super.init(
      _startIndex: _IndexBox(_base: _base.startIndex),
      endIndex: _IndexBox(_base: _base.endIndex)
    )
  }
  @inlinable final internal func _unbox(_ position: Swift._AnyIndexBox, file: Swift.StaticString = #file, line: Swift.UInt = #line) -> S.Index {
    if let i = position._unbox() as S.Index? {
      return i
    }
    fatalError("Index type mismatch!", file: file, line: line)
  }
  @inlinable override final internal subscript(position: Swift._AnyIndexBox) -> Swift._CollectionBox<S>.Element {
    get {
    return _base[_unbox(position)]
  }
  }
  @inlinable override final internal subscript(start start: Swift._AnyIndexBox, end end: Swift._AnyIndexBox) -> Swift._AnyCollectionBox<Swift._CollectionBox<S>.Element> {
    get {
    return _CollectionBox<S.SubSequence>(_base:
      _base[_unbox(start)..<_unbox(end)]
    )
  }
  }
  @inlinable override final internal func _index(after position: Swift._AnyIndexBox) -> Swift._AnyIndexBox {
    return _IndexBox(_base: _base.index(after: _unbox(position)))
  }
  @inlinable override final internal func _formIndex(after position: Swift._AnyIndexBox) {
    if let p = position as? _IndexBox<S.Index> {
      return _base.formIndex(after: &p._base)
    }
    fatalError("Index type mismatch!")
  }
  @inlinable override final internal func _index(_ i: Swift._AnyIndexBox, offsetBy n: Swift.Int) -> Swift._AnyIndexBox {
    return _IndexBox(_base: _base.index(_unbox(i), offsetBy: n))
  }
  @inlinable override final internal func _index(_ i: Swift._AnyIndexBox, offsetBy n: Swift.Int, limitedBy limit: Swift._AnyIndexBox) -> Swift._AnyIndexBox? {
    return _base.index(_unbox(i), offsetBy: n, limitedBy: _unbox(limit))
      .map { _IndexBox(_base: $0) }
  }
  @inlinable override final internal func _formIndex(_ i: inout Swift._AnyIndexBox, offsetBy n: Swift.Int) {
    if let box = i as? _IndexBox<S.Index> {
      return _base.formIndex(&box._base, offsetBy: n)
    }
    fatalError("Index type mismatch!")
  }
  @inlinable override final internal func _formIndex(_ i: inout Swift._AnyIndexBox, offsetBy n: Swift.Int, limitedBy limit: Swift._AnyIndexBox) -> Swift.Bool {
    if let box = i as? _IndexBox<S.Index> {
      return _base.formIndex(&box._base, offsetBy: n, limitedBy: _unbox(limit))
    }
    fatalError("Index type mismatch!")
  }
  @inlinable override final internal func _distance(from start: Swift._AnyIndexBox, to end: Swift._AnyIndexBox) -> Swift.Int {
    return _base.distance(from: _unbox(start), to: _unbox(end))
  }
  @inlinable override final internal var _count: Swift.Int {
    get {
    return _base.count
  }
  }
  @usableFromInline
  final internal var _base: S
  @inlinable override internal init(_startIndex: Swift._AnyIndexBox, endIndex: Swift._AnyIndexBox)
}
@usableFromInline
@_fixed_layout final internal class _BidirectionalCollectionBox<S> : Swift._AnyBidirectionalCollectionBox<S.Element> where S : Swift.BidirectionalCollection {
  @usableFromInline
  internal typealias Element = S.Element
  @inline(__always) @inlinable override final internal func _makeIterator() -> Swift.AnyIterator<Swift._BidirectionalCollectionBox<S>.Element> {
    return AnyIterator(_base.makeIterator())
  }
  @inlinable override final internal var _underestimatedCount: Swift.Int {
    get {
    return _base.underestimatedCount
  }
  }
  @inlinable override final internal func _map<T>(_ transform: (Swift._BidirectionalCollectionBox<S>.Element) throws -> T) rethrows -> [T] {
    return try _base.map(transform)
  }
  @inlinable override final internal func _filter(_ isIncluded: (Swift._BidirectionalCollectionBox<S>.Element) throws -> Swift.Bool) rethrows -> [Swift._BidirectionalCollectionBox<S>.Element] {
    return try _base.filter(isIncluded)
  }
  @inlinable override final internal func _forEach(_ body: (Swift._BidirectionalCollectionBox<S>.Element) throws -> Swift.Void) rethrows {
    return try _base.forEach(body)
  }
  @inlinable override final internal func __customContainsEquatableElement(_ element: Swift._BidirectionalCollectionBox<S>.Element) -> Swift.Bool? {
    return _base._customContainsEquatableElement(element)
  }
  @inlinable override final internal func __copyToContiguousArray() -> Swift.ContiguousArray<Swift._BidirectionalCollectionBox<S>.Element> {
    return _base._copyToContiguousArray()
  }
  @inlinable override final internal func __copyContents(initializing buf: Swift.UnsafeMutableBufferPointer<Swift._BidirectionalCollectionBox<S>.Element>) -> (Swift.AnyIterator<Swift._BidirectionalCollectionBox<S>.Element>, Swift.UnsafeMutableBufferPointer<Swift._BidirectionalCollectionBox<S>.Element>.Index) {
    let (it,idx) = _base._copyContents(initializing: buf)
    return (AnyIterator(it),idx)
  }
  @inline(__always) @inlinable override final internal func _drop(while predicate: (Swift._BidirectionalCollectionBox<S>.Element) throws -> Swift.Bool) rethrows -> Swift._AnyBidirectionalCollectionBox<Swift._BidirectionalCollectionBox<S>.Element> {
    return try _BidirectionalCollectionBox<S.SubSequence>(_base: _base.drop(while: predicate))
  }
  @inline(__always) @inlinable override final internal func _dropFirst(_ n: Swift.Int) -> Swift._AnyBidirectionalCollectionBox<Swift._BidirectionalCollectionBox<S>.Element> {
    return _BidirectionalCollectionBox<S.SubSequence>(_base: _base.dropFirst(n))
  }
  @inline(__always) @inlinable override final internal func _dropLast(_ n: Swift.Int) -> Swift._AnyBidirectionalCollectionBox<Swift._BidirectionalCollectionBox<S>.Element> {
    return _BidirectionalCollectionBox<S.SubSequence>(_base: _base.dropLast(n))
  }
  @inline(__always) @inlinable override final internal func _prefix(while predicate: (Swift._BidirectionalCollectionBox<S>.Element) throws -> Swift.Bool) rethrows -> Swift._AnyBidirectionalCollectionBox<Swift._BidirectionalCollectionBox<S>.Element> {
    return try _BidirectionalCollectionBox<S.SubSequence>(_base: _base.prefix(while: predicate))
  }
  @inline(__always) @inlinable override final internal func _prefix(_ maxLength: Swift.Int) -> Swift._AnyBidirectionalCollectionBox<Swift._BidirectionalCollectionBox<S>.Element> {
    return _BidirectionalCollectionBox<S.SubSequence>(_base: _base.prefix(maxLength))
  }
  @inline(__always) @inlinable override final internal func _suffix(_ maxLength: Swift.Int) -> Swift._AnyBidirectionalCollectionBox<Swift._BidirectionalCollectionBox<S>.Element> {
    return _BidirectionalCollectionBox<S.SubSequence>(_base: _base.suffix(maxLength))
  }
  @objc @inlinable deinit {}
  @inlinable internal init(_base: S) {
    self._base = _base
    super.init(
      _startIndex: _IndexBox(_base: _base.startIndex),
      endIndex: _IndexBox(_base: _base.endIndex)
    )
  }
  @inlinable final internal func _unbox(_ position: Swift._AnyIndexBox, file: Swift.StaticString = #file, line: Swift.UInt = #line) -> S.Index {
    if let i = position._unbox() as S.Index? {
      return i
    }
    fatalError("Index type mismatch!", file: file, line: line)
  }
  @inlinable override final internal subscript(position: Swift._AnyIndexBox) -> Swift._BidirectionalCollectionBox<S>.Element {
    get {
    return _base[_unbox(position)]
  }
  }
  @inlinable override final internal subscript(start start: Swift._AnyIndexBox, end end: Swift._AnyIndexBox) -> Swift._AnyBidirectionalCollectionBox<Swift._BidirectionalCollectionBox<S>.Element> {
    get {
    return _BidirectionalCollectionBox<S.SubSequence>(_base:
      _base[_unbox(start)..<_unbox(end)]
    )
  }
  }
  @inlinable override final internal func _index(after position: Swift._AnyIndexBox) -> Swift._AnyIndexBox {
    return _IndexBox(_base: _base.index(after: _unbox(position)))
  }
  @inlinable override final internal func _formIndex(after position: Swift._AnyIndexBox) {
    if let p = position as? _IndexBox<S.Index> {
      return _base.formIndex(after: &p._base)
    }
    fatalError("Index type mismatch!")
  }
  @inlinable override final internal func _index(_ i: Swift._AnyIndexBox, offsetBy n: Swift.Int) -> Swift._AnyIndexBox {
    return _IndexBox(_base: _base.index(_unbox(i), offsetBy: n))
  }
  @inlinable override final internal func _index(_ i: Swift._AnyIndexBox, offsetBy n: Swift.Int, limitedBy limit: Swift._AnyIndexBox) -> Swift._AnyIndexBox? {
    return _base.index(_unbox(i), offsetBy: n, limitedBy: _unbox(limit))
      .map { _IndexBox(_base: $0) }
  }
  @inlinable override final internal func _formIndex(_ i: inout Swift._AnyIndexBox, offsetBy n: Swift.Int) {
    if let box = i as? _IndexBox<S.Index> {
      return _base.formIndex(&box._base, offsetBy: n)
    }
    fatalError("Index type mismatch!")
  }
  @inlinable override final internal func _formIndex(_ i: inout Swift._AnyIndexBox, offsetBy n: Swift.Int, limitedBy limit: Swift._AnyIndexBox) -> Swift.Bool {
    if let box = i as? _IndexBox<S.Index> {
      return _base.formIndex(&box._base, offsetBy: n, limitedBy: _unbox(limit))
    }
    fatalError("Index type mismatch!")
  }
  @inlinable override final internal func _distance(from start: Swift._AnyIndexBox, to end: Swift._AnyIndexBox) -> Swift.Int {
    return _base.distance(from: _unbox(start), to: _unbox(end))
  }
  @inlinable override final internal var _count: Swift.Int {
    get {
    return _base.count
  }
  }
  @inlinable override final internal func _index(before position: Swift._AnyIndexBox) -> Swift._AnyIndexBox {
    return _IndexBox(_base: _base.index(before: _unbox(position)))
  }
  @inlinable override final internal func _formIndex(before position: Swift._AnyIndexBox) {
    if let p = position as? _IndexBox<S.Index> {
      return _base.formIndex(before: &p._base)
    }
    fatalError("Index type mismatch!")
  }
  @usableFromInline
  final internal var _base: S
  @inlinable override internal init(_startIndex: Swift._AnyIndexBox, endIndex: Swift._AnyIndexBox)
}
@usableFromInline
@_fixed_layout final internal class _RandomAccessCollectionBox<S> : Swift._AnyRandomAccessCollectionBox<S.Element> where S : Swift.RandomAccessCollection {
  @usableFromInline
  internal typealias Element = S.Element
  @inline(__always) @inlinable override final internal func _makeIterator() -> Swift.AnyIterator<Swift._RandomAccessCollectionBox<S>.Element> {
    return AnyIterator(_base.makeIterator())
  }
  @inlinable override final internal var _underestimatedCount: Swift.Int {
    get {
    return _base.underestimatedCount
  }
  }
  @inlinable override final internal func _map<T>(_ transform: (Swift._RandomAccessCollectionBox<S>.Element) throws -> T) rethrows -> [T] {
    return try _base.map(transform)
  }
  @inlinable override final internal func _filter(_ isIncluded: (Swift._RandomAccessCollectionBox<S>.Element) throws -> Swift.Bool) rethrows -> [Swift._RandomAccessCollectionBox<S>.Element] {
    return try _base.filter(isIncluded)
  }
  @inlinable override final internal func _forEach(_ body: (Swift._RandomAccessCollectionBox<S>.Element) throws -> Swift.Void) rethrows {
    return try _base.forEach(body)
  }
  @inlinable override final internal func __customContainsEquatableElement(_ element: Swift._RandomAccessCollectionBox<S>.Element) -> Swift.Bool? {
    return _base._customContainsEquatableElement(element)
  }
  @inlinable override final internal func __copyToContiguousArray() -> Swift.ContiguousArray<Swift._RandomAccessCollectionBox<S>.Element> {
    return _base._copyToContiguousArray()
  }
  @inlinable override final internal func __copyContents(initializing buf: Swift.UnsafeMutableBufferPointer<Swift._RandomAccessCollectionBox<S>.Element>) -> (Swift.AnyIterator<Swift._RandomAccessCollectionBox<S>.Element>, Swift.UnsafeMutableBufferPointer<Swift._RandomAccessCollectionBox<S>.Element>.Index) {
    let (it,idx) = _base._copyContents(initializing: buf)
    return (AnyIterator(it),idx)
  }
  @inline(__always) @inlinable override final internal func _drop(while predicate: (Swift._RandomAccessCollectionBox<S>.Element) throws -> Swift.Bool) rethrows -> Swift._AnyRandomAccessCollectionBox<Swift._RandomAccessCollectionBox<S>.Element> {
    return try _RandomAccessCollectionBox<S.SubSequence>(_base: _base.drop(while: predicate))
  }
  @inline(__always) @inlinable override final internal func _dropFirst(_ n: Swift.Int) -> Swift._AnyRandomAccessCollectionBox<Swift._RandomAccessCollectionBox<S>.Element> {
    return _RandomAccessCollectionBox<S.SubSequence>(_base: _base.dropFirst(n))
  }
  @inline(__always) @inlinable override final internal func _dropLast(_ n: Swift.Int) -> Swift._AnyRandomAccessCollectionBox<Swift._RandomAccessCollectionBox<S>.Element> {
    return _RandomAccessCollectionBox<S.SubSequence>(_base: _base.dropLast(n))
  }
  @inline(__always) @inlinable override final internal func _prefix(while predicate: (Swift._RandomAccessCollectionBox<S>.Element) throws -> Swift.Bool) rethrows -> Swift._AnyRandomAccessCollectionBox<Swift._RandomAccessCollectionBox<S>.Element> {
    return try _RandomAccessCollectionBox<S.SubSequence>(_base: _base.prefix(while: predicate))
  }
  @inline(__always) @inlinable override final internal func _prefix(_ maxLength: Swift.Int) -> Swift._AnyRandomAccessCollectionBox<Swift._RandomAccessCollectionBox<S>.Element> {
    return _RandomAccessCollectionBox<S.SubSequence>(_base: _base.prefix(maxLength))
  }
  @inline(__always) @inlinable override final internal func _suffix(_ maxLength: Swift.Int) -> Swift._AnyRandomAccessCollectionBox<Swift._RandomAccessCollectionBox<S>.Element> {
    return _RandomAccessCollectionBox<S.SubSequence>(_base: _base.suffix(maxLength))
  }
  @objc @inlinable deinit {}
  @inlinable internal init(_base: S) {
    self._base = _base
    super.init(
      _startIndex: _IndexBox(_base: _base.startIndex),
      endIndex: _IndexBox(_base: _base.endIndex)
    )
  }
  @inlinable final internal func _unbox(_ position: Swift._AnyIndexBox, file: Swift.StaticString = #file, line: Swift.UInt = #line) -> S.Index {
    if let i = position._unbox() as S.Index? {
      return i
    }
    fatalError("Index type mismatch!", file: file, line: line)
  }
  @inlinable override final internal subscript(position: Swift._AnyIndexBox) -> Swift._RandomAccessCollectionBox<S>.Element {
    get {
    return _base[_unbox(position)]
  }
  }
  @inlinable override final internal subscript(start start: Swift._AnyIndexBox, end end: Swift._AnyIndexBox) -> Swift._AnyRandomAccessCollectionBox<Swift._RandomAccessCollectionBox<S>.Element> {
    get {
    return _RandomAccessCollectionBox<S.SubSequence>(_base:
      _base[_unbox(start)..<_unbox(end)]
    )
  }
  }
  @inlinable override final internal func _index(after position: Swift._AnyIndexBox) -> Swift._AnyIndexBox {
    return _IndexBox(_base: _base.index(after: _unbox(position)))
  }
  @inlinable override final internal func _formIndex(after position: Swift._AnyIndexBox) {
    if let p = position as? _IndexBox<S.Index> {
      return _base.formIndex(after: &p._base)
    }
    fatalError("Index type mismatch!")
  }
  @inlinable override final internal func _index(_ i: Swift._AnyIndexBox, offsetBy n: Swift.Int) -> Swift._AnyIndexBox {
    return _IndexBox(_base: _base.index(_unbox(i), offsetBy: n))
  }
  @inlinable override final internal func _index(_ i: Swift._AnyIndexBox, offsetBy n: Swift.Int, limitedBy limit: Swift._AnyIndexBox) -> Swift._AnyIndexBox? {
    return _base.index(_unbox(i), offsetBy: n, limitedBy: _unbox(limit))
      .map { _IndexBox(_base: $0) }
  }
  @inlinable override final internal func _formIndex(_ i: inout Swift._AnyIndexBox, offsetBy n: Swift.Int) {
    if let box = i as? _IndexBox<S.Index> {
      return _base.formIndex(&box._base, offsetBy: n)
    }
    fatalError("Index type mismatch!")
  }
  @inlinable override final internal func _formIndex(_ i: inout Swift._AnyIndexBox, offsetBy n: Swift.Int, limitedBy limit: Swift._AnyIndexBox) -> Swift.Bool {
    if let box = i as? _IndexBox<S.Index> {
      return _base.formIndex(&box._base, offsetBy: n, limitedBy: _unbox(limit))
    }
    fatalError("Index type mismatch!")
  }
  @inlinable override final internal func _distance(from start: Swift._AnyIndexBox, to end: Swift._AnyIndexBox) -> Swift.Int {
    return _base.distance(from: _unbox(start), to: _unbox(end))
  }
  @inlinable override final internal var _count: Swift.Int {
    get {
    return _base.count
  }
  }
  @inlinable override final internal func _index(before position: Swift._AnyIndexBox) -> Swift._AnyIndexBox {
    return _IndexBox(_base: _base.index(before: _unbox(position)))
  }
  @inlinable override final internal func _formIndex(before position: Swift._AnyIndexBox) {
    if let p = position as? _IndexBox<S.Index> {
      return _base.formIndex(before: &p._base)
    }
    fatalError("Index type mismatch!")
  }
  @usableFromInline
  final internal var _base: S
  @inlinable override internal init(_startIndex: Swift._AnyIndexBox, endIndex: Swift._AnyIndexBox)
}
@usableFromInline
@frozen internal struct _ClosureBasedSequence<Iterator> where Iterator : Swift.IteratorProtocol {
  @usableFromInline
  internal var _makeUnderlyingIterator: () -> Iterator
  @inlinable internal init(_ makeUnderlyingIterator: @escaping () -> Iterator) {
    self._makeUnderlyingIterator = makeUnderlyingIterator
  }
}
extension _ClosureBasedSequence : Swift.Sequence {
  @inlinable internal func makeIterator() -> Iterator {
    return _makeUnderlyingIterator()
  }
  @usableFromInline
  internal typealias Element = Iterator.Element
}
@frozen public struct AnySequence<Element> {
  @usableFromInline
  internal let _box: Swift._AnySequenceBox<Element>
  @inlinable public init<I>(_ makeUnderlyingIterator: @escaping () -> I) where Element == I.Element, I : Swift.IteratorProtocol {
    self.init(_ClosureBasedSequence(makeUnderlyingIterator))
  }
  @inlinable internal init(_box: Swift._AnySequenceBox<Element>) {
    self._box = _box
  }
}
extension AnySequence : Swift.Sequence {
  public typealias Iterator = Swift.AnyIterator<Element>
  @inlinable public init<S>(_ base: S) where Element == S.Element, S : Swift.Sequence {
    self._box = _SequenceBox(_base: base)
  }
}
extension AnySequence {
  @inline(__always) @inlinable __consuming public func makeIterator() -> Swift.AnySequence<Element>.Iterator {
    return _box._makeIterator()
  }
  @inlinable __consuming public func dropLast(_ n: Swift.Int = 1) -> [Element] {
    return _box._dropLast(n)
  }
  @inlinable __consuming public func prefix(while predicate: (Element) throws -> Swift.Bool) rethrows -> [Element] {
    return try _box._prefix(while: predicate)
  }
  @inlinable __consuming public func suffix(_ maxLength: Swift.Int) -> [Element] {
    return _box._suffix(maxLength)
  }
  @inlinable public var underestimatedCount: Swift.Int {
    get {
    return _box._underestimatedCount
  }
  }
  @inlinable public func map<T>(_ transform: (Element) throws -> T) rethrows -> [T] {
    return try _box._map(transform)
  }
  @inlinable __consuming public func filter(_ isIncluded: (Element) throws -> Swift.Bool) rethrows -> [Element] {
    return try _box._filter(isIncluded)
  }
  @inlinable __consuming public func forEach(_ body: (Element) throws -> Swift.Void) rethrows {
    return try _box._forEach(body)
  }
  @inlinable __consuming public func drop(while predicate: (Element) throws -> Swift.Bool) rethrows -> Swift.AnySequence<Element> {
    return try AnySequence(_box: _box._drop(while: predicate))
  }
  @inlinable __consuming public func dropFirst(_ n: Swift.Int = 1) -> Swift.AnySequence<Element> {
    return AnySequence(_box: _box._dropFirst(n))
  }
  @inlinable __consuming public func prefix(_ maxLength: Swift.Int = 1) -> Swift.AnySequence<Element> {
    return AnySequence(_box: _box._prefix(maxLength))
  }
  @inlinable public func _customContainsEquatableElement(_ element: Element) -> Swift.Bool? {
    return _box.__customContainsEquatableElement(element)
  }
  @inlinable __consuming public func _copyToContiguousArray() -> Swift.ContiguousArray<Element> {
    return self._box.__copyToContiguousArray()
  }
  @inlinable __consuming public func _copyContents(initializing buf: Swift.UnsafeMutableBufferPointer<Element>) -> (Swift.AnyIterator<Element>, Swift.UnsafeMutableBufferPointer<Element>.Index) {
    let (it,idx) = _box.__copyContents(initializing: buf)
    return (AnyIterator(it),idx)
  }
}
extension AnyCollection {
  @inline(__always) @inlinable __consuming public func makeIterator() -> Swift.AnyCollection<Element>.Iterator {
    return _box._makeIterator()
  }
  @inlinable __consuming public func dropLast(_ n: Swift.Int = 1) -> Swift.AnyCollection<Element> {
    return AnyCollection(_box: _box._dropLast(n))
  }
  @inlinable __consuming public func prefix(while predicate: (Element) throws -> Swift.Bool) rethrows -> Swift.AnyCollection<Element> {
    return try AnyCollection(_box: _box._prefix(while: predicate))
  }
  @inlinable __consuming public func suffix(_ maxLength: Swift.Int) -> Swift.AnyCollection<Element> {
    return AnyCollection(_box: _box._suffix(maxLength))
  }
  @inlinable public var underestimatedCount: Swift.Int {
    get {
    return _box._underestimatedCount
  }
  }
  @inlinable public func map<T>(_ transform: (Element) throws -> T) rethrows -> [T] {
    return try _box._map(transform)
  }
  @inlinable __consuming public func filter(_ isIncluded: (Element) throws -> Swift.Bool) rethrows -> [Element] {
    return try _box._filter(isIncluded)
  }
  @inlinable __consuming public func forEach(_ body: (Element) throws -> Swift.Void) rethrows {
    return try _box._forEach(body)
  }
  @inlinable __consuming public func drop(while predicate: (Element) throws -> Swift.Bool) rethrows -> Swift.AnyCollection<Element> {
    return try AnyCollection(_box: _box._drop(while: predicate))
  }
  @inlinable __consuming public func dropFirst(_ n: Swift.Int = 1) -> Swift.AnyCollection<Element> {
    return AnyCollection(_box: _box._dropFirst(n))
  }
  @inlinable __consuming public func prefix(_ maxLength: Swift.Int = 1) -> Swift.AnyCollection<Element> {
    return AnyCollection(_box: _box._prefix(maxLength))
  }
  @inlinable public func _customContainsEquatableElement(_ element: Element) -> Swift.Bool? {
    return _box.__customContainsEquatableElement(element)
  }
  @inlinable __consuming public func _copyToContiguousArray() -> Swift.ContiguousArray<Element> {
    return self._box.__copyToContiguousArray()
  }
  @inlinable __consuming public func _copyContents(initializing buf: Swift.UnsafeMutableBufferPointer<Element>) -> (Swift.AnyIterator<Element>, Swift.UnsafeMutableBufferPointer<Element>.Index) {
    let (it,idx) = _box.__copyContents(initializing: buf)
    return (AnyIterator(it),idx)
  }
}
extension AnyBidirectionalCollection {
  @inline(__always) @inlinable __consuming public func makeIterator() -> Swift.AnyBidirectionalCollection<Element>.Iterator {
    return _box._makeIterator()
  }
  @inlinable __consuming public func dropLast(_ n: Swift.Int = 1) -> Swift.AnyBidirectionalCollection<Element> {
    return AnyBidirectionalCollection(_box: _box._dropLast(n))
  }
  @inlinable __consuming public func prefix(while predicate: (Element) throws -> Swift.Bool) rethrows -> Swift.AnyBidirectionalCollection<Element> {
    return try AnyBidirectionalCollection(_box: _box._prefix(while: predicate))
  }
  @inlinable __consuming public func suffix(_ maxLength: Swift.Int) -> Swift.AnyBidirectionalCollection<Element> {
    return AnyBidirectionalCollection(_box: _box._suffix(maxLength))
  }
  @inlinable public var underestimatedCount: Swift.Int {
    get {
    return _box._underestimatedCount
  }
  }
  @inlinable public func map<T>(_ transform: (Element) throws -> T) rethrows -> [T] {
    return try _box._map(transform)
  }
  @inlinable __consuming public func filter(_ isIncluded: (Element) throws -> Swift.Bool) rethrows -> [Element] {
    return try _box._filter(isIncluded)
  }
  @inlinable __consuming public func forEach(_ body: (Element) throws -> Swift.Void) rethrows {
    return try _box._forEach(body)
  }
  @inlinable __consuming public func drop(while predicate: (Element) throws -> Swift.Bool) rethrows -> Swift.AnyBidirectionalCollection<Element> {
    return try AnyBidirectionalCollection(_box: _box._drop(while: predicate))
  }
  @inlinable __consuming public func dropFirst(_ n: Swift.Int = 1) -> Swift.AnyBidirectionalCollection<Element> {
    return AnyBidirectionalCollection(_box: _box._dropFirst(n))
  }
  @inlinable __consuming public func prefix(_ maxLength: Swift.Int = 1) -> Swift.AnyBidirectionalCollection<Element> {
    return AnyBidirectionalCollection(_box: _box._prefix(maxLength))
  }
  @inlinable public func _customContainsEquatableElement(_ element: Element) -> Swift.Bool? {
    return _box.__customContainsEquatableElement(element)
  }
  @inlinable __consuming public func _copyToContiguousArray() -> Swift.ContiguousArray<Element> {
    return self._box.__copyToContiguousArray()
  }
  @inlinable __consuming public func _copyContents(initializing buf: Swift.UnsafeMutableBufferPointer<Element>) -> (Swift.AnyIterator<Element>, Swift.UnsafeMutableBufferPointer<Element>.Index) {
    let (it,idx) = _box.__copyContents(initializing: buf)
    return (AnyIterator(it),idx)
  }
}
extension AnyRandomAccessCollection {
  @inline(__always) @inlinable __consuming public func makeIterator() -> Swift.AnyRandomAccessCollection<Element>.Iterator {
    return _box._makeIterator()
  }
  @inlinable __consuming public func dropLast(_ n: Swift.Int = 1) -> Swift.AnyRandomAccessCollection<Element> {
    return AnyRandomAccessCollection(_box: _box._dropLast(n))
  }
  @inlinable __consuming public func prefix(while predicate: (Element) throws -> Swift.Bool) rethrows -> Swift.AnyRandomAccessCollection<Element> {
    return try AnyRandomAccessCollection(_box: _box._prefix(while: predicate))
  }
  @inlinable __consuming public func suffix(_ maxLength: Swift.Int) -> Swift.AnyRandomAccessCollection<Element> {
    return AnyRandomAccessCollection(_box: _box._suffix(maxLength))
  }
  @inlinable public var underestimatedCount: Swift.Int {
    get {
    return _box._underestimatedCount
  }
  }
  @inlinable public func map<T>(_ transform: (Element) throws -> T) rethrows -> [T] {
    return try _box._map(transform)
  }
  @inlinable __consuming public func filter(_ isIncluded: (Element) throws -> Swift.Bool) rethrows -> [Element] {
    return try _box._filter(isIncluded)
  }
  @inlinable __consuming public func forEach(_ body: (Element) throws -> Swift.Void) rethrows {
    return try _box._forEach(body)
  }
  @inlinable __consuming public func drop(while predicate: (Element) throws -> Swift.Bool) rethrows -> Swift.AnyRandomAccessCollection<Element> {
    return try AnyRandomAccessCollection(_box: _box._drop(while: predicate))
  }
  @inlinable __consuming public func dropFirst(_ n: Swift.Int = 1) -> Swift.AnyRandomAccessCollection<Element> {
    return AnyRandomAccessCollection(_box: _box._dropFirst(n))
  }
  @inlinable __consuming public func prefix(_ maxLength: Swift.Int = 1) -> Swift.AnyRandomAccessCollection<Element> {
    return AnyRandomAccessCollection(_box: _box._prefix(maxLength))
  }
  @inlinable public func _customContainsEquatableElement(_ element: Element) -> Swift.Bool? {
    return _box.__customContainsEquatableElement(element)
  }
  @inlinable __consuming public func _copyToContiguousArray() -> Swift.ContiguousArray<Element> {
    return self._box.__copyToContiguousArray()
  }
  @inlinable __consuming public func _copyContents(initializing buf: Swift.UnsafeMutableBufferPointer<Element>) -> (Swift.AnyIterator<Element>, Swift.UnsafeMutableBufferPointer<Element>.Index) {
    let (it,idx) = _box.__copyContents(initializing: buf)
    return (AnyIterator(it),idx)
  }
}
@usableFromInline
internal protocol _AnyIndexBox : AnyObject {
  var _typeID: Swift.ObjectIdentifier { get }
  func _unbox<T>() -> T? where T : Swift.Comparable
  func _isEqual(to rhs: Swift._AnyIndexBox) -> Swift.Bool
  func _isLess(than rhs: Swift._AnyIndexBox) -> Swift.Bool
}
@usableFromInline
@_fixed_layout final internal class _IndexBox<BaseIndex> : Swift._AnyIndexBox where BaseIndex : Swift.Comparable {
  @usableFromInline
  final internal var _base: BaseIndex
  @inlinable internal init(_base: BaseIndex) {
    self._base = _base
  }
  @inlinable final internal func _unsafeUnbox(_ other: Swift._AnyIndexBox) -> BaseIndex {
    return unsafeDowncast(other, to: _IndexBox.self)._base
  }
  @inlinable final internal var _typeID: Swift.ObjectIdentifier {
    get {
    return ObjectIdentifier(type(of: self))
  }
  }
  @inlinable final internal func _unbox<T>() -> T? where T : Swift.Comparable {
    return (self as _AnyIndexBox as? _IndexBox<T>)?._base
  }
  @inlinable final internal func _isEqual(to rhs: Swift._AnyIndexBox) -> Swift.Bool {
    return _base == _unsafeUnbox(rhs)
  }
  @inlinable final internal func _isLess(than rhs: Swift._AnyIndexBox) -> Swift.Bool {
    return _base < _unsafeUnbox(rhs)
  }
  @objc @usableFromInline
  deinit
}
@frozen public struct AnyIndex {
  @usableFromInline
  internal var _box: Swift._AnyIndexBox
  @inlinable public init<BaseIndex>(_ base: BaseIndex) where BaseIndex : Swift.Comparable {
    self._box = _IndexBox(_base: base)
  }
  @inlinable internal init(_box: Swift._AnyIndexBox) {
    self._box = _box
  }
  @inlinable internal var _typeID: Swift.ObjectIdentifier {
    get {
    return _box._typeID
  }
  }
}
extension AnyIndex : Swift.Comparable {
  @inlinable public static func == (lhs: Swift.AnyIndex, rhs: Swift.AnyIndex) -> Swift.Bool {
    _precondition(lhs._typeID == rhs._typeID, "Base index types differ")
    return lhs._box._isEqual(to: rhs._box)
  }
  @inlinable public static func < (lhs: Swift.AnyIndex, rhs: Swift.AnyIndex) -> Swift.Bool {
    _precondition(lhs._typeID == rhs._typeID, "Base index types differ")
    return lhs._box._isLess(than: rhs._box)
  }
}
public protocol _AnyCollectionProtocol : Swift.Collection {
  var _boxID: Swift.ObjectIdentifier { get }
}
@frozen public struct AnyCollection<Element> {
  @usableFromInline
  internal let _box: Swift._AnyCollectionBox<Element>
  @inlinable internal init(_box: Swift._AnyCollectionBox<Element>) {
    self._box = _box
  }
}
extension AnyCollection : Swift.Collection {
  public typealias Indices = Swift.DefaultIndices<Swift.AnyCollection<Element>>
  public typealias Iterator = Swift.AnyIterator<Element>
  public typealias Index = Swift.AnyIndex
  public typealias SubSequence = Swift.AnyCollection<Element>
  @inline(__always) @inlinable public init<C>(_ base: C) where Element == C.Element, C : Swift.Collection {
    // Traversal: Forward
    // SubTraversal: Forward
    self._box = _CollectionBox<C>(
      _base: base)
  }
  @inlinable public init(_ other: Swift.AnyCollection<Element>) {
    self._box = other._box
  }
  @inline(__always) @inlinable public init<C>(_ base: C) where Element == C.Element, C : Swift.BidirectionalCollection {
    // Traversal: Forward
    // SubTraversal: Bidirectional
    self._box = _BidirectionalCollectionBox<C>(
      _base: base)
  }
  @inlinable public init(_ other: Swift.AnyBidirectionalCollection<Element>) {
    self._box = other._box
  }
  @inline(__always) @inlinable public init<C>(_ base: C) where Element == C.Element, C : Swift.RandomAccessCollection {
    // Traversal: Forward
    // SubTraversal: RandomAccess
    self._box = _RandomAccessCollectionBox<C>(
      _base: base)
  }
  @inlinable public init(_ other: Swift.AnyRandomAccessCollection<Element>) {
    self._box = other._box
  }
  @inlinable public var startIndex: Swift.AnyCollection<Element>.Index {
    get {
    return AnyIndex(_box: _box._startIndex)
  }
  }
  @inlinable public var endIndex: Swift.AnyCollection<Element>.Index {
    get {
    return AnyIndex(_box: _box._endIndex)
  }
  }
  @inlinable public subscript(position: Swift.AnyCollection<Element>.Index) -> Element {
    get {
    return _box[position._box]
  }
  }
  @inlinable public subscript(bounds: Swift.Range<Swift.AnyCollection<Element>.Index>) -> Swift.AnyCollection<Element>.SubSequence {
    get {
    return AnyCollection(_box:
      _box[start: bounds.lowerBound._box, end: bounds.upperBound._box])
  }
  }
  @inlinable public func _failEarlyRangeCheck(_ index: Swift.AnyCollection<Element>.Index, bounds: Swift.Range<Swift.AnyCollection<Element>.Index>) {
    // Do nothing.  Doing a range check would involve unboxing indices,
    // performing dynamic dispatch etc.  This seems to be too costly for a fast
    // range check for QoI purposes.
  }
  @inlinable public func _failEarlyRangeCheck(_ range: Swift.Range<Swift.AnyCollection<Element>.Index>, bounds: Swift.Range<Swift.AnyCollection<Element>.Index>) {
    // Do nothing.  Doing a range check would involve unboxing indices,
    // performing dynamic dispatch etc.  This seems to be too costly for a fast
    // range check for QoI purposes.
  }
  @inlinable public func index(after i: Swift.AnyCollection<Element>.Index) -> Swift.AnyCollection<Element>.Index {
    return AnyIndex(_box: _box._index(after: i._box))
  }
  @inlinable public func formIndex(after i: inout Swift.AnyCollection<Element>.Index) {
    if _isUnique(&i._box) {
      _box._formIndex(after: i._box)
    }
    else {
      i = index(after: i)
    }
  }
  @inlinable public func index(_ i: Swift.AnyCollection<Element>.Index, offsetBy n: Swift.Int) -> Swift.AnyCollection<Element>.Index {
    return AnyIndex(_box: _box._index(i._box, offsetBy: n))
  }
  @inlinable public func index(_ i: Swift.AnyCollection<Element>.Index, offsetBy n: Swift.Int, limitedBy limit: Swift.AnyCollection<Element>.Index) -> Swift.AnyCollection<Element>.Index? {
    return _box._index(i._box, offsetBy: n, limitedBy: limit._box)
      .map { AnyIndex(_box:$0) }
  }
  @inlinable public func formIndex(_ i: inout Swift.AnyCollection<Element>.Index, offsetBy n: Swift.Int) {
    if _isUnique(&i._box) {
      return _box._formIndex(&i._box, offsetBy: n)
    } else {
      i = index(i, offsetBy: n)
    }
  }
  @inlinable public func formIndex(_ i: inout Swift.AnyCollection<Element>.Index, offsetBy n: Swift.Int, limitedBy limit: Swift.AnyCollection<Element>.Index) -> Swift.Bool {
    if _isUnique(&i._box) {
      return _box._formIndex(&i._box, offsetBy: n, limitedBy: limit._box)
    }
    if let advanced = index(i, offsetBy: n, limitedBy: limit) {
      i = advanced
      return true
    }
    i = limit
    return false
  }
  @inlinable public func distance(from start: Swift.AnyCollection<Element>.Index, to end: Swift.AnyCollection<Element>.Index) -> Swift.Int {
    return _box._distance(from: start._box, to: end._box)
  }
  @inlinable public var count: Swift.Int {
    get {
    return _box._count
  }
  }
}
extension AnyCollection : Swift._AnyCollectionProtocol {
  @inlinable public var _boxID: Swift.ObjectIdentifier {
    get {
    return ObjectIdentifier(_box)
  }
  }
}
@frozen public struct AnyBidirectionalCollection<Element> {
  @usableFromInline
  internal let _box: Swift._AnyBidirectionalCollectionBox<Element>
  @inlinable internal init(_box: Swift._AnyBidirectionalCollectionBox<Element>) {
    self._box = _box
  }
}
extension AnyBidirectionalCollection : Swift.BidirectionalCollection {
  public typealias Indices = Swift.DefaultIndices<Swift.AnyBidirectionalCollection<Element>>
  public typealias Iterator = Swift.AnyIterator<Element>
  public typealias Index = Swift.AnyIndex
  public typealias SubSequence = Swift.AnyBidirectionalCollection<Element>
  @inline(__always) @inlinable public init<C>(_ base: C) where Element == C.Element, C : Swift.BidirectionalCollection {
    // Traversal: Bidirectional
    // SubTraversal: Bidirectional
    self._box = _BidirectionalCollectionBox<C>(
      _base: base)
  }
  @inlinable public init(_ other: Swift.AnyBidirectionalCollection<Element>) {
    self._box = other._box
  }
  @inline(__always) @inlinable public init<C>(_ base: C) where Element == C.Element, C : Swift.RandomAccessCollection {
    // Traversal: Bidirectional
    // SubTraversal: RandomAccess
    self._box = _RandomAccessCollectionBox<C>(
      _base: base)
  }
  @inlinable public init(_ other: Swift.AnyRandomAccessCollection<Element>) {
    self._box = other._box
  }
  @inlinable public init?(_ other: Swift.AnyCollection<Element>) {
    guard let box =
      other._box as? _AnyBidirectionalCollectionBox<Element> else {
      return nil
    }
    self._box = box
  }
  @inlinable public var startIndex: Swift.AnyBidirectionalCollection<Element>.Index {
    get {
    return AnyIndex(_box: _box._startIndex)
  }
  }
  @inlinable public var endIndex: Swift.AnyBidirectionalCollection<Element>.Index {
    get {
    return AnyIndex(_box: _box._endIndex)
  }
  }
  @inlinable public subscript(position: Swift.AnyBidirectionalCollection<Element>.Index) -> Element {
    get {
    return _box[position._box]
  }
  }
  @inlinable public subscript(bounds: Swift.Range<Swift.AnyBidirectionalCollection<Element>.Index>) -> Swift.AnyBidirectionalCollection<Element>.SubSequence {
    get {
    return AnyBidirectionalCollection(_box:
      _box[start: bounds.lowerBound._box, end: bounds.upperBound._box])
  }
  }
  @inlinable public func _failEarlyRangeCheck(_ index: Swift.AnyBidirectionalCollection<Element>.Index, bounds: Swift.Range<Swift.AnyBidirectionalCollection<Element>.Index>) {
    // Do nothing.  Doing a range check would involve unboxing indices,
    // performing dynamic dispatch etc.  This seems to be too costly for a fast
    // range check for QoI purposes.
  }
  @inlinable public func _failEarlyRangeCheck(_ range: Swift.Range<Swift.AnyBidirectionalCollection<Element>.Index>, bounds: Swift.Range<Swift.AnyBidirectionalCollection<Element>.Index>) {
    // Do nothing.  Doing a range check would involve unboxing indices,
    // performing dynamic dispatch etc.  This seems to be too costly for a fast
    // range check for QoI purposes.
  }
  @inlinable public func index(after i: Swift.AnyBidirectionalCollection<Element>.Index) -> Swift.AnyBidirectionalCollection<Element>.Index {
    return AnyIndex(_box: _box._index(after: i._box))
  }
  @inlinable public func formIndex(after i: inout Swift.AnyBidirectionalCollection<Element>.Index) {
    if _isUnique(&i._box) {
      _box._formIndex(after: i._box)
    }
    else {
      i = index(after: i)
    }
  }
  @inlinable public func index(_ i: Swift.AnyBidirectionalCollection<Element>.Index, offsetBy n: Swift.Int) -> Swift.AnyBidirectionalCollection<Element>.Index {
    return AnyIndex(_box: _box._index(i._box, offsetBy: n))
  }
  @inlinable public func index(_ i: Swift.AnyBidirectionalCollection<Element>.Index, offsetBy n: Swift.Int, limitedBy limit: Swift.AnyBidirectionalCollection<Element>.Index) -> Swift.AnyBidirectionalCollection<Element>.Index? {
    return _box._index(i._box, offsetBy: n, limitedBy: limit._box)
      .map { AnyIndex(_box:$0) }
  }
  @inlinable public func formIndex(_ i: inout Swift.AnyBidirectionalCollection<Element>.Index, offsetBy n: Swift.Int) {
    if _isUnique(&i._box) {
      return _box._formIndex(&i._box, offsetBy: n)
    } else {
      i = index(i, offsetBy: n)
    }
  }
  @inlinable public func formIndex(_ i: inout Swift.AnyBidirectionalCollection<Element>.Index, offsetBy n: Swift.Int, limitedBy limit: Swift.AnyBidirectionalCollection<Element>.Index) -> Swift.Bool {
    if _isUnique(&i._box) {
      return _box._formIndex(&i._box, offsetBy: n, limitedBy: limit._box)
    }
    if let advanced = index(i, offsetBy: n, limitedBy: limit) {
      i = advanced
      return true
    }
    i = limit
    return false
  }
  @inlinable public func distance(from start: Swift.AnyBidirectionalCollection<Element>.Index, to end: Swift.AnyBidirectionalCollection<Element>.Index) -> Swift.Int {
    return _box._distance(from: start._box, to: end._box)
  }
  @inlinable public var count: Swift.Int {
    get {
    return _box._count
  }
  }
  @inlinable public func index(before i: Swift.AnyBidirectionalCollection<Element>.Index) -> Swift.AnyBidirectionalCollection<Element>.Index {
    return AnyIndex(_box: _box._index(before: i._box))
  }
  @inlinable public func formIndex(before i: inout Swift.AnyBidirectionalCollection<Element>.Index) {
    if _isUnique(&i._box) {
      _box._formIndex(before: i._box)
    }
    else {
      i = index(before: i)
    }
  }
}
extension AnyBidirectionalCollection : Swift._AnyCollectionProtocol {
  @inlinable public var _boxID: Swift.ObjectIdentifier {
    get {
    return ObjectIdentifier(_box)
  }
  }
}
@frozen public struct AnyRandomAccessCollection<Element> {
  @usableFromInline
  internal let _box: Swift._AnyRandomAccessCollectionBox<Element>
  @inlinable internal init(_box: Swift._AnyRandomAccessCollectionBox<Element>) {
    self._box = _box
  }
}
extension AnyRandomAccessCollection : Swift.RandomAccessCollection {
  public typealias Indices = Swift.DefaultIndices<Swift.AnyRandomAccessCollection<Element>>
  public typealias Iterator = Swift.AnyIterator<Element>
  public typealias Index = Swift.AnyIndex
  public typealias SubSequence = Swift.AnyRandomAccessCollection<Element>
  @inline(__always) @inlinable public init<C>(_ base: C) where Element == C.Element, C : Swift.RandomAccessCollection {
    // Traversal: RandomAccess
    // SubTraversal: RandomAccess
    self._box = _RandomAccessCollectionBox<C>(
      _base: base)
  }
  @inlinable public init(_ other: Swift.AnyRandomAccessCollection<Element>) {
    self._box = other._box
  }
  @inlinable public init?(_ other: Swift.AnyCollection<Element>) {
    guard let box =
      other._box as? _AnyRandomAccessCollectionBox<Element> else {
      return nil
    }
    self._box = box
  }
  @inlinable public init?(_ other: Swift.AnyBidirectionalCollection<Element>) {
    guard let box =
      other._box as? _AnyRandomAccessCollectionBox<Element> else {
      return nil
    }
    self._box = box
  }
  @inlinable public var startIndex: Swift.AnyRandomAccessCollection<Element>.Index {
    get {
    return AnyIndex(_box: _box._startIndex)
  }
  }
  @inlinable public var endIndex: Swift.AnyRandomAccessCollection<Element>.Index {
    get {
    return AnyIndex(_box: _box._endIndex)
  }
  }
  @inlinable public subscript(position: Swift.AnyRandomAccessCollection<Element>.Index) -> Element {
    get {
    return _box[position._box]
  }
  }
  @inlinable public subscript(bounds: Swift.Range<Swift.AnyRandomAccessCollection<Element>.Index>) -> Swift.AnyRandomAccessCollection<Element>.SubSequence {
    get {
    return AnyRandomAccessCollection(_box:
      _box[start: bounds.lowerBound._box, end: bounds.upperBound._box])
  }
  }
  @inlinable public func _failEarlyRangeCheck(_ index: Swift.AnyRandomAccessCollection<Element>.Index, bounds: Swift.Range<Swift.AnyRandomAccessCollection<Element>.Index>) {
    // Do nothing.  Doing a range check would involve unboxing indices,
    // performing dynamic dispatch etc.  This seems to be too costly for a fast
    // range check for QoI purposes.
  }
  @inlinable public func _failEarlyRangeCheck(_ range: Swift.Range<Swift.AnyRandomAccessCollection<Element>.Index>, bounds: Swift.Range<Swift.AnyRandomAccessCollection<Element>.Index>) {
    // Do nothing.  Doing a range check would involve unboxing indices,
    // performing dynamic dispatch etc.  This seems to be too costly for a fast
    // range check for QoI purposes.
  }
  @inlinable public func index(after i: Swift.AnyRandomAccessCollection<Element>.Index) -> Swift.AnyRandomAccessCollection<Element>.Index {
    return AnyIndex(_box: _box._index(after: i._box))
  }
  @inlinable public func formIndex(after i: inout Swift.AnyRandomAccessCollection<Element>.Index) {
    if _isUnique(&i._box) {
      _box._formIndex(after: i._box)
    }
    else {
      i = index(after: i)
    }
  }
  @inlinable public func index(_ i: Swift.AnyRandomAccessCollection<Element>.Index, offsetBy n: Swift.Int) -> Swift.AnyRandomAccessCollection<Element>.Index {
    return AnyIndex(_box: _box._index(i._box, offsetBy: n))
  }
  @inlinable public func index(_ i: Swift.AnyRandomAccessCollection<Element>.Index, offsetBy n: Swift.Int, limitedBy limit: Swift.AnyRandomAccessCollection<Element>.Index) -> Swift.AnyRandomAccessCollection<Element>.Index? {
    return _box._index(i._box, offsetBy: n, limitedBy: limit._box)
      .map { AnyIndex(_box:$0) }
  }
  @inlinable public func formIndex(_ i: inout Swift.AnyRandomAccessCollection<Element>.Index, offsetBy n: Swift.Int) {
    if _isUnique(&i._box) {
      return _box._formIndex(&i._box, offsetBy: n)
    } else {
      i = index(i, offsetBy: n)
    }
  }
  @inlinable public func formIndex(_ i: inout Swift.AnyRandomAccessCollection<Element>.Index, offsetBy n: Swift.Int, limitedBy limit: Swift.AnyRandomAccessCollection<Element>.Index) -> Swift.Bool {
    if _isUnique(&i._box) {
      return _box._formIndex(&i._box, offsetBy: n, limitedBy: limit._box)
    }
    if let advanced = index(i, offsetBy: n, limitedBy: limit) {
      i = advanced
      return true
    }
    i = limit
    return false
  }
  @inlinable public func distance(from start: Swift.AnyRandomAccessCollection<Element>.Index, to end: Swift.AnyRandomAccessCollection<Element>.Index) -> Swift.Int {
    return _box._distance(from: start._box, to: end._box)
  }
  @inlinable public var count: Swift.Int {
    get {
    return _box._count
  }
  }
  @inlinable public func index(before i: Swift.AnyRandomAccessCollection<Element>.Index) -> Swift.AnyRandomAccessCollection<Element>.Index {
    return AnyIndex(_box: _box._index(before: i._box))
  }
  @inlinable public func formIndex(before i: inout Swift.AnyRandomAccessCollection<Element>.Index) {
    if _isUnique(&i._box) {
      _box._formIndex(before: i._box)
    }
    else {
      i = index(before: i)
    }
  }
}
extension AnyRandomAccessCollection : Swift._AnyCollectionProtocol {
  @inlinable public var _boxID: Swift.ObjectIdentifier {
    get {
    return ObjectIdentifier(_box)
  }
  }
}
@frozen public struct LazyFilterSequence<Base> where Base : Swift.Sequence {
  @usableFromInline
  internal var _base: Base
  @usableFromInline
  internal let _predicate: (Base.Element) -> Swift.Bool
  @inlinable public init(_base base: Base, _ isIncluded: @escaping (Base.Element) -> Swift.Bool) {
    self._base = base
    self._predicate = isIncluded
  }
}
extension LazyFilterSequence {
  @frozen public struct Iterator {
    public var base: Base.Iterator {
      get
    }
    @usableFromInline
    internal var _base: Base.Iterator
    @usableFromInline
    internal let _predicate: (Base.Element) -> Swift.Bool
    @inlinable internal init(_base: Base.Iterator, _ isIncluded: @escaping (Base.Element) -> Swift.Bool) {
      self._base = _base
      self._predicate = isIncluded
    }
  }
}
extension LazyFilterSequence.Iterator : Swift.IteratorProtocol, Swift.Sequence {
  public typealias Element = Base.Element
  @inlinable public mutating func next() -> Swift.LazyFilterSequence<Base>.Iterator.Element? {
    while let n = _base.next() {
      if _predicate(n) {
        return n
      }
    }
    return nil
  }
  public typealias Iterator = Swift.LazyFilterSequence<Base>.Iterator
}
extension LazyFilterSequence : Swift.Sequence {
  public typealias Element = Base.Element
  @inlinable __consuming public func makeIterator() -> Swift.LazyFilterSequence<Base>.Iterator {
    return Iterator(_base: _base.makeIterator(), _predicate)
  }
  @inlinable public func _customContainsEquatableElement(_ element: Swift.LazyFilterSequence<Base>.Element) -> Swift.Bool? {
    // optimization to check the element first matches the predicate
    guard _predicate(element) else { return false }
    return _base._customContainsEquatableElement(element)
  }
}
extension LazyFilterSequence : Swift.LazySequenceProtocol {
  public typealias Elements = Swift.LazyFilterSequence<Base>
}
public typealias LazyFilterCollection<T> = Swift.LazyFilterSequence<T> where T : Swift.Collection
extension Swift.LazyFilterCollection : Swift.Collection where Base : Swift.Collection {
  public typealias SubSequence = Swift.LazyFilterCollection<Base.SubSequence>
  @inlinable public var underestimatedCount: Swift.Int {
    get { return 0 }
  }
  public typealias Index = Base.Index
  @inlinable public var startIndex: Swift.LazyFilterSequence<Base>.Index {
    get {
    var index = _base.startIndex
    while index != _base.endIndex && !_predicate(_base[index]) {
      _base.formIndex(after: &index)
    }
    return index
  }
  }
  @inlinable public var endIndex: Swift.LazyFilterSequence<Base>.Index {
    get {
    return _base.endIndex
  }
  }
  @inlinable public func index(after i: Swift.LazyFilterSequence<Base>.Index) -> Swift.LazyFilterSequence<Base>.Index {
    var i = i
    formIndex(after: &i)
    return i
  }
  @inlinable public func formIndex(after i: inout Swift.LazyFilterSequence<Base>.Index) {
    // TODO: swift-3-indexing-model: _failEarlyRangeCheck i?
    var index = i
    _precondition(index != _base.endIndex, "Can't advance past endIndex")
    repeat {
      _base.formIndex(after: &index)
    } while index != _base.endIndex && !_predicate(_base[index])
    i = index
  }
  @inline(__always) @inlinable internal func _advanceIndex(_ i: inout Swift.LazyFilterSequence<Base>.Index, step: Swift.Int) {
    repeat {
      _base.formIndex(&i, offsetBy: step)
    } while i != _base.endIndex && !_predicate(_base[i])
  }
  @inline(__always) @inlinable internal func _ensureBidirectional(step: Swift.Int) {
    // FIXME: This seems to be the best way of checking whether _base is
    // forward only without adding an extra protocol requirement.
    // index(_:offsetBy:limitedBy:) is chosen becuase it is supposed to return
    // nil when the resulting index lands outside the collection boundaries,
    // and therefore likely does not trap in these cases.
    if step < 0 {
      _ = _base.index(
        _base.endIndex, offsetBy: step, limitedBy: _base.startIndex)
    }
  }
  @inlinable public func distance(from start: Swift.LazyFilterSequence<Base>.Index, to end: Swift.LazyFilterSequence<Base>.Index) -> Swift.Int {
    // The following line makes sure that distance(from:to:) is invoked on the
    // _base at least once, to trigger a _precondition in forward only
    // collections.
    _ = _base.distance(from: start, to: end)
    var _start: Index
    let _end: Index
    let step: Int
    if start > end {
      _start = end
      _end = start
      step = -1
    }
    else {
      _start = start
      _end = end
      step = 1
    }
    var count = 0
    while _start != _end {
      count += step
      formIndex(after: &_start)
    }
    return count
  }
  @inlinable public func index(_ i: Swift.LazyFilterSequence<Base>.Index, offsetBy n: Swift.Int) -> Swift.LazyFilterSequence<Base>.Index {
    var i = i
    let step = n.signum()
    // The following line makes sure that index(_:offsetBy:) is invoked on the
    // _base at least once, to trigger a _precondition in forward only
    // collections.
    _ensureBidirectional(step: step)
    for _ in 0 ..< abs(n) {
      _advanceIndex(&i, step: step)
    }
    return i
  }
  @inlinable public func formIndex(_ i: inout Swift.LazyFilterSequence<Base>.Index, offsetBy n: Swift.Int) {
    i = index(i, offsetBy: n)
  }
  @inlinable public func index(_ i: Swift.LazyFilterSequence<Base>.Index, offsetBy n: Swift.Int, limitedBy limit: Swift.LazyFilterSequence<Base>.Index) -> Swift.LazyFilterSequence<Base>.Index? {
    var i = i
    let step = n.signum()
    // The following line makes sure that index(_:offsetBy:limitedBy:) is
    // invoked on the _base at least once, to trigger a _precondition in
    // forward only collections.
    _ensureBidirectional(step: step)
    for _ in 0 ..< abs(n) {
      if i == limit {
        return nil
      }
      _advanceIndex(&i, step: step)
    }
    return i
  }
  @inlinable public func formIndex(_ i: inout Swift.LazyFilterSequence<Base>.Index, offsetBy n: Swift.Int, limitedBy limit: Swift.LazyFilterSequence<Base>.Index) -> Swift.Bool {
    if let advancedIndex = index(i, offsetBy: n, limitedBy: limit) {
      i = advancedIndex
      return true
    }
    i = limit
    return false
  }
  @inlinable public subscript(position: Swift.LazyFilterSequence<Base>.Index) -> Swift.LazyFilterSequence<Base>.Element {
    get {
    return _base[position]
  }
  }
  @inlinable public subscript(bounds: Swift.Range<Swift.LazyFilterSequence<Base>.Index>) -> Swift.LazyFilterSequence<Base>.SubSequence {
    get {
    return SubSequence(_base: _base[bounds], _predicate)
  }
  }
  @inlinable public func _customLastIndexOfEquatableElement(_ element: Swift.LazyFilterSequence<Base>.Element) -> Swift.LazyFilterSequence<Base>.Index?? {
    guard _predicate(element) else { return .some(nil) }
    return _base._customLastIndexOfEquatableElement(element)
  }
  public typealias Indices = Swift.DefaultIndices<Swift.LazyFilterSequence<Base>>
}
extension Swift.LazyFilterCollection : Swift.LazyCollectionProtocol where Base : Swift.Collection {
}
extension Swift.LazyFilterCollection : Swift.BidirectionalCollection where Base : Swift.BidirectionalCollection {
  @inlinable public func index(before i: Swift.LazyFilterSequence<Base>.Index) -> Swift.LazyFilterSequence<Base>.Index {
    var i = i
    formIndex(before: &i)
    return i
  }
  @inlinable public func formIndex(before i: inout Swift.LazyFilterSequence<Base>.Index) {
    // TODO: swift-3-indexing-model: _failEarlyRangeCheck i?
    var index = i
    _precondition(index != _base.startIndex, "Can't retreat before startIndex")
    repeat {
      _base.formIndex(before: &index)
    } while !_predicate(_base[index])
    i = index
  }
}
extension LazySequenceProtocol {
  @inlinable __consuming public func filter(_ isIncluded: @escaping (Self.Elements.Element) -> Swift.Bool) -> Swift.LazyFilterSequence<Self.Elements> {
    return LazyFilterSequence(_base: self.elements, isIncluded)
  }
}
extension LazyFilterSequence {
  @available(swift 5)
  __consuming public func filter(_ isIncluded: @escaping (Swift.LazyFilterSequence<Base>.Element) -> Swift.Bool) -> Swift.LazyFilterSequence<Base>
}
extension LazySequenceProtocol {
  @inlinable public func flatMap<SegmentOfResult>(_ transform: @escaping (Self.Elements.Element) -> SegmentOfResult) -> Swift.LazySequence<Swift.FlattenSequence<Swift.LazyMapSequence<Self.Elements, SegmentOfResult>>> where SegmentOfResult : Swift.Sequence {
    return self.map(transform).joined()
  }
  @inlinable public func compactMap<ElementOfResult>(_ transform: @escaping (Self.Elements.Element) -> ElementOfResult?) -> Swift.LazyMapSequence<Swift.LazyFilterSequence<Swift.LazyMapSequence<Self.Elements, ElementOfResult?>>, ElementOfResult> {
    return self.map(transform).filter { $0 != nil }.map { $0! }
  }
}
@frozen public struct FlattenSequence<Base> where Base : Swift.Sequence, Base.Element : Swift.Sequence {
  @usableFromInline
  internal var _base: Base
  @inlinable internal init(_base: Base) {
    self._base = _base
  }
}
extension FlattenSequence {
  @frozen public struct Iterator {
    @usableFromInline
    internal var _base: Base.Iterator
    @usableFromInline
    internal var _inner: Base.Element.Iterator?
    @inlinable internal init(_base: Base.Iterator) {
      self._base = _base
    }
  }
}
extension FlattenSequence.Iterator : Swift.IteratorProtocol {
  public typealias Element = Base.Element.Element
  @inlinable public mutating func next() -> Swift.FlattenSequence<Base>.Iterator.Element? {
    repeat {
      if _fastPath(_inner != nil) {
        let ret = _inner!.next()
        if _fastPath(ret != nil) {
          return ret
        }
      }
      let s = _base.next()
      if _slowPath(s == nil) {
        return nil
      }
      _inner = s!.makeIterator()
    }
    while true
  }
}
extension FlattenSequence.Iterator : Swift.Sequence {
  public typealias Iterator = Swift.FlattenSequence<Base>.Iterator
}
extension FlattenSequence : Swift.Sequence {
  @inlinable __consuming public func makeIterator() -> Swift.FlattenSequence<Base>.Iterator {
    return Iterator(_base: _base.makeIterator())
  }
  public typealias Element = Swift.FlattenSequence<Base>.Iterator.Element
}
extension Sequence where Self.Element : Swift.Sequence {
  @inlinable __consuming public func joined() -> Swift.FlattenSequence<Self> {
    return FlattenSequence(_base: self)
  }
}
extension LazySequenceProtocol where Self.Element : Swift.Sequence {
  @inlinable __consuming public func joined() -> Swift.LazySequence<Swift.FlattenSequence<Self.Elements>> {
    return FlattenSequence(_base: elements).lazy
  }
}
public typealias FlattenCollection<T> = Swift.FlattenSequence<T> where T : Swift.Collection, T.Element : Swift.Collection
extension FlattenSequence where Base : Swift.Collection, Base.Element : Swift.Collection {
  @frozen public struct Index {
    @usableFromInline
    internal let _outer: Base.Index
    @usableFromInline
    internal let _inner: Base.Element.Index?
    @inlinable internal init(_ _outer: Base.Index, _ inner: Base.Element.Index?) {
      self._outer = _outer
      self._inner = inner
    }
  }
}
extension FlattenSequence.Index : Swift.Equatable {
  @inlinable public static func == (lhs: Swift.FlattenCollection<Base>.Index, rhs: Swift.FlattenCollection<Base>.Index) -> Swift.Bool {
    return lhs._outer == rhs._outer && lhs._inner == rhs._inner
  }
}
extension FlattenSequence.Index : Swift.Comparable {
  @inlinable public static func < (lhs: Swift.FlattenCollection<Base>.Index, rhs: Swift.FlattenCollection<Base>.Index) -> Swift.Bool {
    // FIXME: swift-3-indexing-model: tests.
    if lhs._outer != rhs._outer {
      return lhs._outer < rhs._outer
    }

    if let lhsInner = lhs._inner, let rhsInner = rhs._inner {
      return lhsInner < rhsInner
    }

    // When combined, the two conditions above guarantee that both
    // `_outer` indices are `_base.endIndex` and both `_inner` indices
    // are `nil`, since `_inner` is `nil` iff `_outer == base.endIndex`.
    _precondition(lhs._inner == nil && rhs._inner == nil)

    return false
  }
}
extension FlattenSequence.Index : Swift.Hashable where Base.Index : Swift.Hashable, Base.Element.Index : Swift.Hashable {
  @inlinable public func hash(into hasher: inout Swift.Hasher) {
    hasher.combine(_outer)
    hasher.combine(_inner)
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension Swift.FlattenCollection : Swift.Collection where Base : Swift.Collection, Base.Element : Swift.Collection {
  @inlinable public var startIndex: Swift.FlattenSequence<Base>.Index {
    get {
    let end = _base.endIndex
    var outer = _base.startIndex
    while outer != end {
      let innerCollection = _base[outer]
      if !innerCollection.isEmpty {
        return Index(outer, innerCollection.startIndex)
      }
      _base.formIndex(after: &outer)
    }

    return endIndex
  }
  }
  @inlinable public var endIndex: Swift.FlattenSequence<Base>.Index {
    get {
    return Index(_base.endIndex, nil)
  }
  }
  @inlinable internal func _index(after i: Swift.FlattenSequence<Base>.Index) -> Swift.FlattenSequence<Base>.Index {
    let innerCollection = _base[i._outer]
    let nextInner = innerCollection.index(after: i._inner!)
    if _fastPath(nextInner != innerCollection.endIndex) {
      return Index(i._outer, nextInner)
    }

    var nextOuter = _base.index(after: i._outer)
    while nextOuter != _base.endIndex {
      let nextInnerCollection = _base[nextOuter]
      if !nextInnerCollection.isEmpty {
        return Index(nextOuter, nextInnerCollection.startIndex)
      }
      _base.formIndex(after: &nextOuter)
    }

    return endIndex
  }
  @inlinable internal func _index(before i: Swift.FlattenSequence<Base>.Index) -> Swift.FlattenSequence<Base>.Index {
    var prevOuter = i._outer
    if prevOuter == _base.endIndex {
      prevOuter = _base.index(prevOuter, offsetBy: -1)
    }
    var prevInnerCollection = _base[prevOuter]
    var prevInner = i._inner ?? prevInnerCollection.endIndex

    while prevInner == prevInnerCollection.startIndex {
      prevOuter = _base.index(prevOuter, offsetBy: -1)
      prevInnerCollection = _base[prevOuter]
      prevInner = prevInnerCollection.endIndex
    }

    return Index(prevOuter, prevInnerCollection.index(prevInner, offsetBy: -1))
  }
  @inlinable public func index(after i: Swift.FlattenSequence<Base>.Index) -> Swift.FlattenSequence<Base>.Index {
    return _index(after: i)
  }
  @inlinable public func formIndex(after i: inout Swift.FlattenSequence<Base>.Index) {
    i = index(after: i)
  }
  @inlinable public func distance(from start: Swift.FlattenSequence<Base>.Index, to end: Swift.FlattenSequence<Base>.Index) -> Swift.Int {
    // The following check makes sure that distance(from:to:) is invoked on the
    // _base at least once, to trigger a _precondition in forward only
    // collections.
    if end < start {
      _ = _base.distance(from: _base.endIndex, to: _base.startIndex)
    }
    var _start: Index
    let _end: Index
    let step: Int
    if start > end {
      _start = end
      _end = start
      step = -1
    }
    else {
      _start = start
      _end = end
      step = 1
    }
    var count = 0
    while _start != _end {
      count += step
      formIndex(after: &_start)
    }
    return count
  }
  @inline(__always) @inlinable internal func _advanceIndex(_ i: inout Swift.FlattenSequence<Base>.Index, step: Swift.Int) {
    _internalInvariant(-1...1 ~= step, "step should be within the -1...1 range")
    i = step < 0 ? _index(before: i) : _index(after: i)
  }
  @inline(__always) @inlinable internal func _ensureBidirectional(step: Swift.Int) {
    // FIXME: This seems to be the best way of checking whether _base is
    // forward only without adding an extra protocol requirement.
    // index(_:offsetBy:limitedBy:) is chosen becuase it is supposed to return
    // nil when the resulting index lands outside the collection boundaries,
    // and therefore likely does not trap in these cases.
    if step < 0 {
      _ = _base.index(
        _base.endIndex, offsetBy: step, limitedBy: _base.startIndex)
    }
  }
  @inlinable public func index(_ i: Swift.FlattenSequence<Base>.Index, offsetBy n: Swift.Int) -> Swift.FlattenSequence<Base>.Index {
    var i = i
    let step = n.signum()
    _ensureBidirectional(step: step)
    for _ in 0 ..< abs(n) {
      _advanceIndex(&i, step: step)
    }
    return i
  }
  @inlinable public func formIndex(_ i: inout Swift.FlattenSequence<Base>.Index, offsetBy n: Swift.Int) {
    i = index(i, offsetBy: n)
  }
  @inlinable public func index(_ i: Swift.FlattenSequence<Base>.Index, offsetBy n: Swift.Int, limitedBy limit: Swift.FlattenSequence<Base>.Index) -> Swift.FlattenSequence<Base>.Index? {
    var i = i
    let step = n.signum()
    // The following line makes sure that index(_:offsetBy:limitedBy:) is
    // invoked on the _base at least once, to trigger a _precondition in
    // forward only collections.
    _ensureBidirectional(step: step)
    for _ in 0 ..< abs(n) {
      if i == limit {
        return nil
      }
      _advanceIndex(&i, step: step)
    }
    return i
  }
  @inlinable public func formIndex(_ i: inout Swift.FlattenSequence<Base>.Index, offsetBy n: Swift.Int, limitedBy limit: Swift.FlattenSequence<Base>.Index) -> Swift.Bool {
    if let advancedIndex = index(i, offsetBy: n, limitedBy: limit) {
      i = advancedIndex
      return true
    }
    i = limit
    return false
  }
  @inlinable public subscript(position: Swift.FlattenSequence<Base>.Index) -> Base.Element.Element {
    get {
    return _base[position._outer][position._inner!]
  }
  }
  @inlinable public subscript(bounds: Swift.Range<Swift.FlattenSequence<Base>.Index>) -> Swift.Slice<Swift.FlattenCollection<Base>> {
    get {
    return Slice(base: self, bounds: bounds)
  }
  }
  public typealias Indices = Swift.DefaultIndices<Swift.FlattenSequence<Base>>
  public typealias SubSequence = Swift.Slice<Swift.FlattenCollection<Base>>
}
extension Swift.FlattenCollection : Swift.BidirectionalCollection where Base : Swift.BidirectionalCollection, Base.Element : Swift.BidirectionalCollection {
  @inlinable public func index(before i: Swift.FlattenSequence<Base>.Index) -> Swift.FlattenSequence<Base>.Index {
    return _index(before: i)
  }
  @inlinable public func formIndex(before i: inout Swift.FlattenSequence<Base>.Index) {
    i = index(before: i)
  }
}
public protocol FloatingPoint : Swift.Hashable, Swift.SignedNumeric, Swift.Strideable where Self == Self.Magnitude {
  associatedtype Exponent : Swift.SignedInteger
  init(sign: Swift.FloatingPointSign, exponent: Self.Exponent, significand: Self)
  init(signOf: Self, magnitudeOf: Self)
  init(_ value: Swift.Int)
  init<Source>(_ value: Source) where Source : Swift.BinaryInteger
  init?<Source>(exactly value: Source) where Source : Swift.BinaryInteger
  static var radix: Swift.Int { get }
  static var nan: Self { get }
  static var signalingNaN: Self { get }
  static var infinity: Self { get }
  static var greatestFiniteMagnitude: Self { get }
  static var pi: Self { get }
  var ulp: Self { get }
  static var ulpOfOne: Self { get }
  static var leastNormalMagnitude: Self { get }
  static var leastNonzeroMagnitude: Self { get }
  var sign: Swift.FloatingPointSign { get }
  var exponent: Self.Exponent { get }
  var significand: Self { get }
  override static func + (lhs: Self, rhs: Self) -> Self
  override static func += (lhs: inout Self, rhs: Self)
  override prefix static func - (operand: Self) -> Self
  override mutating func negate()
  override static func - (lhs: Self, rhs: Self) -> Self
  override static func -= (lhs: inout Self, rhs: Self)
  override static func * (lhs: Self, rhs: Self) -> Self
  override static func *= (lhs: inout Self, rhs: Self)
  static func / (lhs: Self, rhs: Self) -> Self
  static func /= (lhs: inout Self, rhs: Self)
  func remainder(dividingBy other: Self) -> Self
  mutating func formRemainder(dividingBy other: Self)
  func truncatingRemainder(dividingBy other: Self) -> Self
  mutating func formTruncatingRemainder(dividingBy other: Self)
  func squareRoot() -> Self
  mutating func formSquareRoot()
  func addingProduct(_ lhs: Self, _ rhs: Self) -> Self
  mutating func addProduct(_ lhs: Self, _ rhs: Self)
  static func minimum(_ x: Self, _ y: Self) -> Self
  static func maximum(_ x: Self, _ y: Self) -> Self
  static func minimumMagnitude(_ x: Self, _ y: Self) -> Self
  static func maximumMagnitude(_ x: Self, _ y: Self) -> Self
  func rounded(_ rule: Swift.FloatingPointRoundingRule) -> Self
  mutating func round(_ rule: Swift.FloatingPointRoundingRule)
  var nextUp: Self { get }
  var nextDown: Self { get }
  func isEqual(to other: Self) -> Swift.Bool
  func isLess(than other: Self) -> Swift.Bool
  func isLessThanOrEqualTo(_ other: Self) -> Swift.Bool
  func isTotallyOrdered(belowOrEqualTo other: Self) -> Swift.Bool
  var isNormal: Swift.Bool { get }
  var isFinite: Swift.Bool { get }
  var isZero: Swift.Bool { get }
  var isSubnormal: Swift.Bool { get }
  var isInfinite: Swift.Bool { get }
  var isNaN: Swift.Bool { get }
  var isSignalingNaN: Swift.Bool { get }
  var floatingPointClass: Swift.FloatingPointClassification { get }
  var isCanonical: Swift.Bool { get }
}
@frozen public enum FloatingPointSign : Swift.Int {
  case plus
  case minus
  @inlinable public init?(rawValue: Swift.Int) {
    switch rawValue {
    case 0: self = .plus
    case 1: self = .minus
    default: return nil
    }
  }
  @inlinable public var rawValue: Swift.Int {
    get {
    switch self {
    case .plus: return 0
    case .minus: return 1
    }
  }
  }
  @_transparent @inlinable public static func == (a: Swift.FloatingPointSign, b: Swift.FloatingPointSign) -> Swift.Bool {
    return a.rawValue == b.rawValue
  }
  @inlinable public var hashValue: Swift.Int {
    get { return rawValue.hashValue }
  }
  @inlinable public func hash(into hasher: inout Swift.Hasher) {
    hasher.combine(rawValue)
  }
  @inlinable public func _rawHashValue(seed: Swift.Int) -> Swift.Int {
    return rawValue._rawHashValue(seed: seed)
  }
  public typealias RawValue = Swift.Int
}
@frozen public enum FloatingPointClassification {
  case signalingNaN
  case quietNaN
  case negativeInfinity
  case negativeNormal
  case negativeSubnormal
  case negativeZero
  case positiveZero
  case positiveSubnormal
  case positiveNormal
  case positiveInfinity
  public static func == (a: Swift.FloatingPointClassification, b: Swift.FloatingPointClassification) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public enum FloatingPointRoundingRule {
  case toNearestOrAwayFromZero
  case toNearestOrEven
  case up
  case down
  case towardZero
  case awayFromZero
  public static func == (a: Swift.FloatingPointRoundingRule, b: Swift.FloatingPointRoundingRule) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension FloatingPoint {
  @_transparent public static func == (lhs: Self, rhs: Self) -> Swift.Bool {
    return lhs.isEqual(to: rhs)
  }
  @_transparent public static func < (lhs: Self, rhs: Self) -> Swift.Bool {
    return lhs.isLess(than: rhs)
  }
  @_transparent public static func <= (lhs: Self, rhs: Self) -> Swift.Bool {
    return lhs.isLessThanOrEqualTo(rhs)
  }
  @_transparent public static func > (lhs: Self, rhs: Self) -> Swift.Bool {
    return rhs.isLess(than: lhs)
  }
  @_transparent public static func >= (lhs: Self, rhs: Self) -> Swift.Bool {
    return rhs.isLessThanOrEqualTo(lhs)
  }
}
public protocol BinaryFloatingPoint : Swift.ExpressibleByFloatLiteral, Swift.FloatingPoint {
  associatedtype RawSignificand : Swift.UnsignedInteger
  associatedtype RawExponent : Swift.UnsignedInteger
  init(sign: Swift.FloatingPointSign, exponentBitPattern: Self.RawExponent, significandBitPattern: Self.RawSignificand)
  init(_ value: Swift.Float)
  init(_ value: Swift.Double)
  init(_ value: Swift.Float80)
  init<Source>(_ value: Source) where Source : Swift.BinaryFloatingPoint
  init?<Source>(exactly value: Source) where Source : Swift.BinaryFloatingPoint
  static var exponentBitCount: Swift.Int { get }
  static var significandBitCount: Swift.Int { get }
  var exponentBitPattern: Self.RawExponent { get }
  var significandBitPattern: Self.RawSignificand { get }
  var binade: Self { get }
  var significandWidth: Swift.Int { get }
}
extension FloatingPoint {
  @inlinable public static var ulpOfOne: Self {
    get {
    return (1 as Self).ulp
  }
  }
  @_transparent public func rounded(_ rule: Swift.FloatingPointRoundingRule) -> Self {
    var lhs = self
    lhs.round(rule)
    return lhs
  }
  @_transparent public func rounded() -> Self {
    return rounded(.toNearestOrAwayFromZero)
  }
  @_transparent public mutating func round() {
    round(.toNearestOrAwayFromZero)
  }
  @inlinable public var nextDown: Self {
    @inline(__always) get {
      return -(-self).nextUp
    }
  }
  @inlinable @inline(__always) public func truncatingRemainder(dividingBy other: Self) -> Self {
    var lhs = self
    lhs.formTruncatingRemainder(dividingBy: other)
    return lhs
  }
  @inlinable @inline(__always) public func remainder(dividingBy other: Self) -> Self {
    var lhs = self
    lhs.formRemainder(dividingBy: other)
    return lhs
  }
  @_transparent public func squareRoot() -> Self {
    var lhs = self
    lhs.formSquareRoot( )
    return lhs
  }
  @_transparent public func addingProduct(_ lhs: Self, _ rhs: Self) -> Self {
    var addend = self
    addend.addProduct(lhs, rhs)
    return addend
  }
  @inlinable public static func minimum(_ x: Self, _ y: Self) -> Self {
    if x <= y || y.isNaN { return x }
    return y
  }
  @inlinable public static func maximum(_ x: Self, _ y: Self) -> Self {
    if x > y || y.isNaN { return x }
    return y
  }
  @inlinable public static func minimumMagnitude(_ x: Self, _ y: Self) -> Self {
    if x.magnitude <= y.magnitude || y.isNaN { return x }
    return y
  }
  @inlinable public static func maximumMagnitude(_ x: Self, _ y: Self) -> Self {
    if x.magnitude > y.magnitude || y.isNaN { return x }
    return y
  }
  @inlinable public var floatingPointClass: Swift.FloatingPointClassification {
    get {
    if isSignalingNaN { return .signalingNaN }
    if isNaN { return .quietNaN }
    if isInfinite { return sign == .minus ? .negativeInfinity : .positiveInfinity }
    if isNormal { return sign == .minus ? .negativeNormal : .positiveNormal }
    if isSubnormal { return sign == .minus ? .negativeSubnormal : .positiveSubnormal }
    return sign == .minus ? .negativeZero : .positiveZero
  }
  }
}
extension BinaryFloatingPoint {
  @inlinable @inline(__always) public static var radix: Swift.Int {
    get { return 2 }
  }
  @inlinable public init(signOf: Self, magnitudeOf: Self) {
    self.init(
      sign: signOf.sign,
      exponentBitPattern: magnitudeOf.exponentBitPattern,
      significandBitPattern: magnitudeOf.significandBitPattern
    )
  }
  public static func _convert<Source>(from source: Source) -> (value: Self, exact: Swift.Bool) where Source : Swift.BinaryFloatingPoint
  @inlinable public init<Source>(_ value: Source) where Source : Swift.BinaryFloatingPoint {
    // If two IEEE 754 binary interchange formats share the same exponent bit
    // count and significand bit count, then they must share the same encoding
    // for finite and infinite values.
    switch (Source.exponentBitCount, Source.significandBitCount) {
    case (8, 23):
      let value_ = value as? Float ?? Float(
        sign: value.sign,
        exponentBitPattern:
          UInt(truncatingIfNeeded: value.exponentBitPattern),
        significandBitPattern:
          UInt32(truncatingIfNeeded: value.significandBitPattern))
      self = Self(value_)
    case (11, 52):
      let value_ = value as? Double ?? Double(
        sign: value.sign,
        exponentBitPattern:
          UInt(truncatingIfNeeded: value.exponentBitPattern),
        significandBitPattern:
          UInt64(truncatingIfNeeded: value.significandBitPattern))
      self = Self(value_)
    case (15, 63):
      let value_ = value as? Float80 ?? Float80(
        sign: value.sign,
        exponentBitPattern:
          UInt(truncatingIfNeeded: value.exponentBitPattern),
        significandBitPattern:
          UInt64(truncatingIfNeeded: value.significandBitPattern))
      self = Self(value_)
    default:
      // Convert signaling NaN to quiet NaN by multiplying by 1.
      self = Self._convert(from: value).value * 1
    }
  }
  @inlinable public init?<Source>(exactly value: Source) where Source : Swift.BinaryFloatingPoint {
    // We define exactness by equality after roundtripping; since NaN is never
    // equal to itself, it can never be converted exactly.
    if value.isNaN { return nil }
    
    if (Source.exponentBitCount > Self.exponentBitCount
        || Source.significandBitCount > Self.significandBitCount)
      && value.isFinite && !value.isZero {
      let exponent = value.exponent
      if exponent < Self.leastNormalMagnitude.exponent {
        if exponent < Self.leastNonzeroMagnitude.exponent { return nil }
        if value.significandWidth >
          Int(Self.Exponent(exponent) - Self.leastNonzeroMagnitude.exponent) {
          return nil
        }
      } else {
        if exponent > Self.greatestFiniteMagnitude.exponent { return nil }
        if value.significandWidth >
          Self.greatestFiniteMagnitude.significandWidth {
          return nil
        }
      }
    }
    
    self = Self(value)
  }
  @inlinable public func isTotallyOrdered(belowOrEqualTo other: Self) -> Swift.Bool {
    // Quick return when possible.
    if self < other { return true }
    if other > self { return false }
    // Self and other are either equal or unordered.
    // Every negative-signed value (even NaN) is less than every positive-
    // signed value, so if the signs do not match, we simply return the
    // sign bit of self.
    if sign != other.sign { return sign == .minus }
    // Sign bits match; look at exponents.
    if exponentBitPattern > other.exponentBitPattern { return sign == .minus }
    if exponentBitPattern < other.exponentBitPattern { return sign == .plus }
    // Signs and exponents match, look at significands.
    if significandBitPattern > other.significandBitPattern {
      return sign == .minus
    }
    if significandBitPattern < other.significandBitPattern {
      return sign == .plus
    }
    //  Sign, exponent, and significand all match.
    return true
  }
}
extension BinaryFloatingPoint where Self.RawSignificand : Swift.FixedWidthInteger {
  public static func _convert<Source>(from source: Source) -> (value: Self, exact: Swift.Bool) where Source : Swift.BinaryInteger
  @inlinable public init<Source>(_ value: Source) where Source : Swift.BinaryInteger {
    self = Self._convert(from: value).value
  }
  @inlinable public init?<Source>(exactly value: Source) where Source : Swift.BinaryInteger {
    let (value_, exact) = Self._convert(from: value)
    guard exact else { return nil }
    self = value_
  }
}
public protocol Hashable : Swift.Equatable {
  var hashValue: Swift.Int { get }
  func hash(into hasher: inout Swift.Hasher)
  func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Hashable {
  @inlinable @inline(__always) public func _rawHashValue(seed: Swift.Int) -> Swift.Int {
    var hasher = Hasher(_seed: seed)
    hasher.combine(self)
    return hasher._finalize()
  }
}
@inlinable @inline(__always) public func _hashValue<H>(for value: H) -> Swift.Int where H : Swift.Hashable {
  return value._rawHashValue(seed: 0)
}
public protocol _HasCustomAnyHashableRepresentation {
  __consuming func _toCustomAnyHashable() -> Swift.AnyHashable?
}
@usableFromInline
internal protocol _AnyHashableBox {
  var _canonicalBox: Swift._AnyHashableBox { get }
  func _isEqual(to box: Swift._AnyHashableBox) -> Swift.Bool?
  var _hashValue: Swift.Int { get }
  func _hash(into hasher: inout Swift.Hasher)
  func _rawHashValue(_seed: Swift.Int) -> Swift.Int
  var _base: Any { get }
  func _unbox<T>() -> T? where T : Swift.Hashable
  func _downCastConditional<T>(into result: Swift.UnsafeMutablePointer<T>) -> Swift.Bool
}
@frozen public struct AnyHashable {
  internal var _box: Swift._AnyHashableBox
  public init<H>(_ base: H) where H : Swift.Hashable
  public var base: Any {
    get
  }
}
extension AnyHashable : Swift.Equatable {
  public static func == (lhs: Swift.AnyHashable, rhs: Swift.AnyHashable) -> Swift.Bool
}
extension AnyHashable : Swift.Hashable {
  public var hashValue: Swift.Int {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
  public func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AnyHashable : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
extension AnyHashable : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
extension AnyHashable : Swift.CustomReflectable {
  public var customMirror: Swift.Mirror {
    get
  }
}
@inlinable public func _convertToAnyHashable<H>(_ value: H) -> Swift.AnyHashable where H : Swift.Hashable {
  return AnyHashable(value)
}
extension Hasher {
  @usableFromInline
  @frozen internal struct _TailBuffer {
    internal var value: Swift.UInt64
  }
}
extension Hasher {
  @usableFromInline
  @frozen internal struct _Core {
    private var _buffer: Swift.Hasher._TailBuffer
    private var _state: Swift.Hasher._State
  }
}
@frozen public struct Hasher {
  internal var _core: Swift.Hasher._Core
  @_effects(releasenone) public init()
  @usableFromInline
  @_effects(releasenone) internal init(_seed: Swift.Int)
  @usableFromInline
  @_effects(releasenone) internal init(_rawSeed: (Swift.UInt64, Swift.UInt64))
  @inlinable internal static var _isDeterministic: Swift.Bool {
    @inline(__always) get {
      return _swift_stdlib_Hashing_parameters.deterministic
    }
  }
  @inlinable internal static var _executionSeed: (Swift.UInt64, Swift.UInt64) {
    @inline(__always) get {
      // The seed itself is defined in C++ code so that it is initialized during
      // static construction.  Almost every Swift program uses hash tables, so
      // initializing the seed during the startup seems to be the right
      // trade-off.
      return (
        _swift_stdlib_Hashing_parameters.seed0,
        _swift_stdlib_Hashing_parameters.seed1)
    }
  }
  @inlinable @inline(__always) public mutating func combine<H>(_ value: H) where H : Swift.Hashable {
    value.hash(into: &self)
  }
  @usableFromInline
  @_effects(releasenone) internal mutating func _combine(_ value: Swift.UInt)
  @usableFromInline
  @_effects(releasenone) internal mutating func _combine(_ value: Swift.UInt64)
  @usableFromInline
  @_effects(releasenone) internal mutating func _combine(_ value: Swift.UInt32)
  @usableFromInline
  @_effects(releasenone) internal mutating func _combine(_ value: Swift.UInt16)
  @usableFromInline
  @_effects(releasenone) internal mutating func _combine(_ value: Swift.UInt8)
  @usableFromInline
  @_effects(releasenone) internal mutating func _combine(bytes value: Swift.UInt64, count: Swift.Int)
  @_effects(releasenone) public mutating func combine(bytes: Swift.UnsafeRawBufferPointer)
  @usableFromInline
  @_effects(releasenone) internal mutating func _finalize() -> Swift.Int
  @_effects(releasenone) __consuming public func finalize() -> Swift.Int
  @usableFromInline
  @_effects(readnone) internal static func _hash(seed: Swift.Int, _ value: Swift.UInt64) -> Swift.Int
  @usableFromInline
  @_effects(readnone) internal static func _hash(seed: Swift.Int, _ value: Swift.UInt) -> Swift.Int
  @usableFromInline
  @_effects(readnone) internal static func _hash(seed: Swift.Int, bytes value: Swift.UInt64, count: Swift.Int) -> Swift.Int
  @usableFromInline
  @_effects(readnone) internal static func _hash(seed: Swift.Int, bytes: Swift.UnsafeRawBufferPointer) -> Swift.Int
}
@usableFromInline
@_transparent internal var _hashContainerDefaultMaxLoadFactorInverse: Swift.Double {
  @_transparent get {
  return 1.0 / 0.75
}
}
@usableFromInline
internal protocol _HashTableDelegate {
  func hashValue(at bucket: Swift._HashTable.Bucket) -> Swift.Int
  func moveEntry(from source: Swift._HashTable.Bucket, to target: Swift._HashTable.Bucket)
}
@usableFromInline
@frozen internal struct _HashTable {
  @usableFromInline
  internal typealias Word = Swift._UnsafeBitset.Word
  @usableFromInline
  internal var words: Swift.UnsafeMutablePointer<Swift._HashTable.Word>
  @usableFromInline
  internal let bucketMask: Swift.Int
  @inlinable @inline(__always) internal init(words: Swift.UnsafeMutablePointer<Swift._HashTable.Word>, bucketCount: Swift.Int) {
    _internalInvariant(bucketCount > 0 && bucketCount & (bucketCount - 1) == 0,
      "bucketCount must be a power of two")
    self.words = words
    // The bucket count is a power of two, so subtracting 1 will never overflow
    // and get us a nice mask.
    self.bucketMask = bucketCount &- 1
  }
  @inlinable internal var bucketCount: Swift.Int {
    @inline(__always) get {
      return bucketMask &+ 1
    }
  }
  @inlinable internal var wordCount: Swift.Int {
    @inline(__always) get {
      return _UnsafeBitset.wordCount(forCapacity: bucketCount)
    }
  }
}
extension _HashTable {
  @usableFromInline
  @frozen internal struct Bucket {
    @usableFromInline
    internal var offset: Swift.Int
    @inlinable @inline(__always) internal init(offset: Swift.Int) {
      self.offset = offset
    }
    @inlinable @inline(__always) internal init(word: Swift.Int, bit: Swift.Int) {
      self.offset = _UnsafeBitset.join(word: word, bit: bit)
    }
    @inlinable internal var word: Swift.Int {
      @inline(__always) get {
        return _UnsafeBitset.word(for: offset)
      }
    }
    @inlinable internal var bit: Swift.Int {
      @inline(__always) get {
        return _UnsafeBitset.bit(for: offset)
      }
    }
  }
}
extension _HashTable.Bucket : Swift.Equatable {
  @inlinable @inline(__always) internal static func == (lhs: Swift._HashTable.Bucket, rhs: Swift._HashTable.Bucket) -> Swift.Bool {
    return lhs.offset == rhs.offset
  }
}
extension _HashTable.Bucket : Swift.Comparable {
  @inlinable @inline(__always) internal static func < (lhs: Swift._HashTable.Bucket, rhs: Swift._HashTable.Bucket) -> Swift.Bool {
    return lhs.offset < rhs.offset
  }
}
extension _HashTable {
  @usableFromInline
  @frozen internal struct Index {
    @usableFromInline
    internal let bucket: Swift._HashTable.Bucket
    @usableFromInline
    internal let age: Swift.Int32
    @inlinable @inline(__always) internal init(bucket: Swift._HashTable.Bucket, age: Swift.Int32) {
      self.bucket = bucket
      self.age = age
    }
  }
}
extension _HashTable.Index : Swift.Equatable {
  @inlinable @inline(__always) internal static func == (lhs: Swift._HashTable.Index, rhs: Swift._HashTable.Index) -> Swift.Bool {
    _precondition(lhs.age == rhs.age,
      "Can't compare indices belonging to different collections")
    return lhs.bucket == rhs.bucket
  }
}
extension _HashTable.Index : Swift.Comparable {
  @inlinable @inline(__always) internal static func < (lhs: Swift._HashTable.Index, rhs: Swift._HashTable.Index) -> Swift.Bool {
    _precondition(lhs.age == rhs.age,
      "Can't compare indices belonging to different collections")
    return lhs.bucket < rhs.bucket
  }
}
extension _HashTable : Swift.Sequence {
  @usableFromInline
  @frozen internal struct Iterator : Swift.IteratorProtocol {
    @usableFromInline
    internal let hashTable: Swift._HashTable
    @usableFromInline
    internal var wordIndex: Swift.Int
    @usableFromInline
    internal var word: Swift._HashTable.Word
    @inlinable @inline(__always) internal init(_ hashTable: Swift._HashTable) {
      self.hashTable = hashTable
      self.wordIndex = 0
      self.word = hashTable.words[0]
      if hashTable.bucketCount < Word.capacity {
        self.word = self.word.intersecting(elementsBelow: hashTable.bucketCount)
      }
    }
    @inlinable @inline(__always) internal mutating func next() -> Swift._HashTable.Bucket? {
      if let bit = word.next() {
        return Bucket(word: wordIndex, bit: bit)
      }
      while wordIndex + 1 < hashTable.wordCount {
        wordIndex += 1
        word = hashTable.words[wordIndex]
        if let bit = word.next() {
          return Bucket(word: wordIndex, bit: bit)
        }
      }
      return nil
    }
    @usableFromInline
    internal typealias Element = Swift._HashTable.Bucket
  }
  @inlinable @inline(__always) internal func makeIterator() -> Swift._HashTable.Iterator {
    return Iterator(self)
  }
  @usableFromInline
  internal typealias Element = Swift._HashTable.Bucket
}
extension _HashTable {
  @inlinable @inline(__always) internal func isValid(_ bucket: Swift._HashTable.Bucket) -> Swift.Bool {
    return bucket.offset >= 0 && bucket.offset < bucketCount
  }
  @inlinable @inline(__always) internal func _isOccupied(_ bucket: Swift._HashTable.Bucket) -> Swift.Bool {
    _internalInvariant(isValid(bucket))
    return words[bucket.word].uncheckedContains(bucket.bit)
  }
  @inlinable @inline(__always) internal func isOccupied(_ bucket: Swift._HashTable.Bucket) -> Swift.Bool {
    return isValid(bucket) && _isOccupied(bucket)
  }
  @inlinable @inline(__always) internal func checkOccupied(_ bucket: Swift._HashTable.Bucket) {
    _precondition(isOccupied(bucket),
      "Attempting to access Collection elements using an invalid Index")
  }
  @inlinable @inline(__always) internal func _firstOccupiedBucket(fromWord word: Swift.Int) -> Swift._HashTable.Bucket {
    _internalInvariant(word >= 0 && word <= wordCount)
    var word = word
    while word < wordCount {
      if let bit = words[word].minimum {
        return Bucket(word: word, bit: bit)
      }
      word += 1
    }
    return endBucket
  }
  @inlinable internal func occupiedBucket(after bucket: Swift._HashTable.Bucket) -> Swift._HashTable.Bucket {
    _internalInvariant(isValid(bucket))
    let word = bucket.word
    if let bit = words[word].intersecting(elementsAbove: bucket.bit).minimum {
      return Bucket(word: word, bit: bit)
    }
    return _firstOccupiedBucket(fromWord: word + 1)
  }
  @inlinable internal var startBucket: Swift._HashTable.Bucket {
    get {
    return _firstOccupiedBucket(fromWord: 0)
  }
  }
  @inlinable internal var endBucket: Swift._HashTable.Bucket {
    @inline(__always) get {
      return Bucket(offset: bucketCount)
    }
  }
}
extension _HashTable {
  @inlinable @inline(__always) internal func idealBucket(forHashValue hashValue: Swift.Int) -> Swift._HashTable.Bucket {
    return Bucket(offset: hashValue & bucketMask)
  }
  @inlinable @inline(__always) internal func bucket(wrappedAfter bucket: Swift._HashTable.Bucket) -> Swift._HashTable.Bucket {
    // The bucket is less than bucketCount, which is power of two less than
    // Int.max. Therefore adding 1 does not overflow.
    return Bucket(offset: (bucket.offset &+ 1) & bucketMask)
  }
}
extension _HashTable {
  @inlinable internal func previousHole(before bucket: Swift._HashTable.Bucket) -> Swift._HashTable.Bucket {
    _internalInvariant(isValid(bucket))
    // Note that if we have only a single partial word, its out-of-bounds bits
    // are guaranteed to be all set, so the formula below gives correct results.
    var word = bucket.word
    if let bit =
      words[word]
        .complement
        .intersecting(elementsBelow: bucket.bit)
        .maximum {
      return Bucket(word: word, bit: bit)
    }
    var wrap = false
    while true {
      word -= 1
      if word < 0 {
        _precondition(!wrap, "Hash table has no holes")
        wrap = true
        word = wordCount - 1
      }
      if let bit = words[word].complement.maximum {
        return Bucket(word: word, bit: bit)
      }
    }
  }
  @inlinable internal func nextHole(atOrAfter bucket: Swift._HashTable.Bucket) -> Swift._HashTable.Bucket {
    _internalInvariant(isValid(bucket))
    // Note that if we have only a single partial word, its out-of-bounds bits
    // are guaranteed to be all set, so the formula below gives correct results.
    var word = bucket.word
    if let bit =
      words[word]
        .complement
        .subtracting(elementsBelow: bucket.bit)
        .minimum {
      return Bucket(word: word, bit: bit)
    }
    var wrap = false
    while true {
      word &+= 1
      if word == wordCount {
        _precondition(!wrap, "Hash table has no holes")
        wrap = true
        word = 0
      }
      if let bit = words[word].complement.minimum {
        return Bucket(word: word, bit: bit)
      }
    }
  }
}
extension _HashTable {
  @inlinable @inline(__always) @_effects(releasenone) internal func copyContents(of other: Swift._HashTable) {
    _internalInvariant(bucketCount == other.bucketCount)
    self.words.assign(from: other.words, count: wordCount)
  }
  @inlinable @inline(__always) internal func insertNew(hashValue: Swift.Int) -> Swift._HashTable.Bucket {
    let hole = nextHole(atOrAfter: idealBucket(forHashValue: hashValue))
    insert(hole)
    return hole
  }
  @inlinable @inline(__always) internal func insert(_ bucket: Swift._HashTable.Bucket) {
    _internalInvariant(!isOccupied(bucket))
    words[bucket.word].uncheckedInsert(bucket.bit)
  }
  @inlinable @inline(__always) internal func clear() {
    if bucketCount < Word.capacity {
      // We have only a single partial word. Set all out of bounds bits, so that
      // `occupiedBucket(after:)` and `nextHole(atOrAfter:)` works correctly
      // without a special case.
      words[0] = Word.allBits.subtracting(elementsBelow: bucketCount)
    } else {
      words.assign(repeating: .empty, count: wordCount)
    }
  }
  @inline(__always) @inlinable internal func delete<D>(at bucket: Swift._HashTable.Bucket, with delegate: D) where D : Swift._HashTableDelegate {
    _internalInvariant(isOccupied(bucket))

    // If we've put a hole in a chain of contiguous elements, some element after
    // the hole may belong where the new hole is.

    var hole = bucket
    var candidate = self.bucket(wrappedAfter: hole)

    guard _isOccupied(candidate) else {
      // Fast path: Don't get the first bucket when there's nothing to do.
      words[hole.word].uncheckedRemove(hole.bit)
      return
    }

    // Find the first bucket in the contiguous chain that contains the entry
    // we've just deleted.
    let start = self.bucket(wrappedAfter: previousHole(before: bucket))

    // Relocate out-of-place elements in the chain, repeating until we get to
    // the end of the chain.
    while _isOccupied(candidate) {
      let candidateHash = delegate.hashValue(at: candidate)
      let ideal = idealBucket(forHashValue: candidateHash)

      // Does this element belong between start and hole?  We need two
      // separate tests depending on whether [start, hole] wraps around the
      // end of the storage.
      let c0 = ideal >= start
      let c1 = ideal <= hole
      if start <= hole ? (c0 && c1) : (c0 || c1) {
        delegate.moveEntry(from: candidate, to: hole)
        hole = candidate
      }
      candidate = self.bucket(wrappedAfter: candidate)
    }

    words[hole.word].uncheckedRemove(hole.bit)
  }
}
@available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
public protocol Identifiable {
  associatedtype ID : Swift.Hashable
  var id: Self.ID { get }
}
@available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
extension Identifiable where Self : AnyObject {
  public var id: Swift.ObjectIdentifier {
    get
  }
}
@frozen public struct DefaultIndices<Elements> where Elements : Swift.Collection {
  @usableFromInline
  internal var _elements: Elements
  @usableFromInline
  internal var _startIndex: Elements.Index
  @usableFromInline
  internal var _endIndex: Elements.Index
  @inlinable internal init(_elements: Elements, startIndex: Elements.Index, endIndex: Elements.Index) {
    self._elements = _elements
    self._startIndex = startIndex
    self._endIndex = endIndex
  }
}
extension DefaultIndices : Swift.Collection {
  public typealias Index = Elements.Index
  public typealias Element = Elements.Index
  public typealias Indices = Swift.DefaultIndices<Elements>
  public typealias SubSequence = Swift.DefaultIndices<Elements>
  public typealias Iterator = Swift.IndexingIterator<Swift.DefaultIndices<Elements>>
  @inlinable public var startIndex: Swift.DefaultIndices<Elements>.Index {
    get {
    return _startIndex
  }
  }
  @inlinable public var endIndex: Swift.DefaultIndices<Elements>.Index {
    get {
    return _endIndex
  }
  }
  @inlinable public subscript(i: Swift.DefaultIndices<Elements>.Index) -> Elements.Index {
    get {
    // FIXME: swift-3-indexing-model: range check.
    return i
  }
  }
  @inlinable public subscript(bounds: Swift.Range<Swift.DefaultIndices<Elements>.Index>) -> Swift.DefaultIndices<Elements> {
    get {
    // FIXME: swift-3-indexing-model: range check.
    return DefaultIndices(
      _elements: _elements,
      startIndex: bounds.lowerBound,
      endIndex: bounds.upperBound)
  }
  }
  @inlinable public func index(after i: Swift.DefaultIndices<Elements>.Index) -> Swift.DefaultIndices<Elements>.Index {
    // FIXME: swift-3-indexing-model: range check.
    return _elements.index(after: i)
  }
  @inlinable public func formIndex(after i: inout Swift.DefaultIndices<Elements>.Index) {
    // FIXME: swift-3-indexing-model: range check.
    _elements.formIndex(after: &i)
  }
  @inlinable public var indices: Swift.DefaultIndices<Elements>.Indices {
    get {
    return self
  }
  }
  @_alwaysEmitIntoClient public func index(_ i: Swift.DefaultIndices<Elements>.Index, offsetBy distance: Swift.Int) -> Swift.DefaultIndices<Elements>.Index {
    return _elements.index(i, offsetBy: distance)
  }
  @_alwaysEmitIntoClient public func index(_ i: Swift.DefaultIndices<Elements>.Index, offsetBy distance: Swift.Int, limitedBy limit: Swift.DefaultIndices<Elements>.Index) -> Swift.DefaultIndices<Elements>.Index? {
    return _elements.index(i, offsetBy: distance, limitedBy: limit)
  }
  @_alwaysEmitIntoClient public func distance(from start: Swift.DefaultIndices<Elements>.Index, to end: Swift.DefaultIndices<Elements>.Index) -> Swift.Int {
    return _elements.distance(from: start, to: end)
  }
}
extension DefaultIndices : Swift.BidirectionalCollection where Elements : Swift.BidirectionalCollection {
  @inlinable public func index(before i: Swift.DefaultIndices<Elements>.Index) -> Swift.DefaultIndices<Elements>.Index {
    // FIXME: swift-3-indexing-model: range check.
    return _elements.index(before: i)
  }
  @inlinable public func formIndex(before i: inout Swift.DefaultIndices<Elements>.Index) {
    // FIXME: swift-3-indexing-model: range check.
    _elements.formIndex(before: &i)
  }
}
extension DefaultIndices : Swift.RandomAccessCollection where Elements : Swift.RandomAccessCollection {
}
extension Collection where Self.Indices == Swift.DefaultIndices<Self> {
  @inlinable public var indices: Swift.DefaultIndices<Self> {
    get {
    return DefaultIndices(
      _elements: self,
      startIndex: self.startIndex,
      endIndex: self.endIndex)
  }
  }
}
public func readLine(strippingNewline: Swift.Bool = true) -> Swift.String?
@inlinable internal func _ascii16(_ c: Swift.Unicode.Scalar) -> Swift.UTF16.CodeUnit {
  _internalInvariant(c.value >= 0 && c.value <= 0x7F, "not ASCII")
  return UTF16.CodeUnit(c.value)
}
@inlinable @inline(__always) internal func _asciiDigit<CodeUnit, Result>(codeUnit u_: CodeUnit, radix: Result) -> Result? where CodeUnit : Swift.UnsignedInteger, Result : Swift.BinaryInteger {
  let digit = _ascii16("0")..._ascii16("9")
  let lower = _ascii16("a")..._ascii16("z")
  let upper = _ascii16("A")..._ascii16("Z")

  let u = UInt16(truncatingIfNeeded: u_)
  let d: UInt16
  if _fastPath(digit ~= u) { d = u &- digit.lowerBound }
  else if _fastPath(upper ~= u) { d = u &- upper.lowerBound &+ 10 }
  else if _fastPath(lower ~= u) { d = u &- lower.lowerBound &+ 10 }
  else { return nil }
  guard _fastPath(d < radix) else { return nil }
  return Result(truncatingIfNeeded: d)
}
@inlinable @inline(__always) internal func _parseUnsignedASCII<Rest, Result>(first: Rest.Element, rest: inout Rest, radix: Result, positive: Swift.Bool) -> Result? where Rest : Swift.IteratorProtocol, Result : Swift.FixedWidthInteger, Rest.Element : Swift.UnsignedInteger {
  let r0 = _asciiDigit(codeUnit: first, radix: radix)
  guard _fastPath(r0 != nil), var result = r0 else { return nil }
  if !positive {
    let (result0, overflow0)
      = (0 as Result).subtractingReportingOverflow(result)
    guard _fastPath(!overflow0) else { return nil }
    result = result0
  }

  while let u = rest.next() {
    let d0 = _asciiDigit(codeUnit: u, radix: radix)
    guard _fastPath(d0 != nil), let d = d0 else { return nil }
    let (result1, overflow1) = result.multipliedReportingOverflow(by: radix)
    let (result2, overflow2) = positive
      ? result1.addingReportingOverflow(d)
      : result1.subtractingReportingOverflow(d)
    guard _fastPath(!overflow1 && !overflow2)
    else { return nil }
    result = result2
  }
  return result
}
@inlinable @inline(__always) internal func _parseASCII<CodeUnits, Result>(codeUnits: inout CodeUnits, radix: Result) -> Result? where CodeUnits : Swift.IteratorProtocol, Result : Swift.FixedWidthInteger, CodeUnits.Element : Swift.UnsignedInteger {
  let c0_ = codeUnits.next()
  guard _fastPath(c0_ != nil), let c0 = c0_ else { return nil }
  if _fastPath(c0 != _ascii16("+") && c0 != _ascii16("-")) {
    return _parseUnsignedASCII(
      first: c0, rest: &codeUnits, radix: radix, positive: true)
  }
  let c1_ = codeUnits.next()
  guard _fastPath(c1_ != nil), let c1 = c1_ else { return nil }
  if _fastPath(c0 == _ascii16("-")) {
    return _parseUnsignedASCII(
      first: c1, rest: &codeUnits, radix: radix, positive: false)
  }
  else {
    return _parseUnsignedASCII(
      first: c1, rest: &codeUnits, radix: radix, positive: true)
  }
}
extension FixedWidthInteger {
  @usableFromInline
  @_semantics("optimize.sil.specialize.generic.partial.never") @inline(never) internal static func _parseASCIISlowPath<CodeUnits, Result>(codeUnits: inout CodeUnits, radix: Result) -> Result? where CodeUnits : Swift.IteratorProtocol, Result : Swift.FixedWidthInteger, CodeUnits.Element : Swift.UnsignedInteger
  @inlinable @_semantics("optimize.sil.specialize.generic.partial.never") public init?<S>(_ text: S, radix: Swift.Int = 10) where S : Swift.StringProtocol {
    _precondition(2...36 ~= radix, "Radix not in range 2...36")

    if let str = text as? String, str._guts.isFastUTF8 {
      guard let ret = str._guts.withFastUTF8 ({ utf8 -> Self? in
        var iter = utf8.makeIterator()
        return _parseASCII(codeUnits: &iter, radix: Self(radix))
      }) else {
        return nil
      }
      self = ret
      return
    }

    // TODO(String performance): We can provide fast paths for common radices,
    // native UTF-8 storage, etc.

    var iter = text.utf8.makeIterator()
    guard let ret = Self._parseASCIISlowPath(
      codeUnits: &iter, radix: Self(radix)
    ) else { return nil }

    self = ret
  }
  @inlinable @_semantics("optimize.sil.specialize.generic.partial.never") @inline(__always) public init?(_ description: Swift.String) {
    self.init(description, radix: 10)
  }
}
extension ExpressibleByIntegerLiteral where Self : Swift._ExpressibleByBuiltinIntegerLiteral {
  @_transparent public init(integerLiteral value: Self) {
    self = value
  }
}
public protocol AdditiveArithmetic : Swift.Equatable {
  static var zero: Self { get }
  static func + (lhs: Self, rhs: Self) -> Self
  static func += (lhs: inout Self, rhs: Self)
  static func - (lhs: Self, rhs: Self) -> Self
  static func -= (lhs: inout Self, rhs: Self)
}
extension AdditiveArithmetic {
  @_alwaysEmitIntoClient public static func += (lhs: inout Self, rhs: Self) {
    lhs = lhs + rhs
  }
  @_alwaysEmitIntoClient public static func -= (lhs: inout Self, rhs: Self) {
    lhs = lhs - rhs
  }
}
extension AdditiveArithmetic where Self : Swift.ExpressibleByIntegerLiteral {
  @inlinable @inline(__always) public static var zero: Self {
    get {
    return 0
  }
  }
}
public protocol Numeric : Swift.AdditiveArithmetic, Swift.ExpressibleByIntegerLiteral {
  init?<T>(exactly source: T) where T : Swift.BinaryInteger
  associatedtype Magnitude : Swift.Comparable, Swift.Numeric
  var magnitude: Self.Magnitude { get }
  static func * (lhs: Self, rhs: Self) -> Self
  static func *= (lhs: inout Self, rhs: Self)
}
public protocol SignedNumeric : Swift.Numeric {
  prefix static func - (operand: Self) -> Self
  mutating func negate()
}
extension SignedNumeric {
  @_transparent prefix public static func - (operand: Self) -> Self {
    var result = operand
    result.negate()
    return result
  }
  @_transparent public mutating func negate() {
    self = 0 - self
  }
}
@inlinable public func abs<T>(_ x: T) -> T where T : Swift.Comparable, T : Swift.SignedNumeric {
  if T.self == T.Magnitude.self {
    return unsafeBitCast(x.magnitude, to: T.self)
  }

  return x < (0 as T) ? -x : x
}
extension AdditiveArithmetic {
  @_transparent prefix public static func + (x: Self) -> Self {
    return x
  }
}
public protocol BinaryInteger : Swift.CustomStringConvertible, Swift.Hashable, Swift.Numeric, Swift.Strideable where Self.Magnitude : Swift.BinaryInteger, Self.Magnitude == Self.Magnitude.Magnitude {
  static var isSigned: Swift.Bool { get }
  init?<T>(exactly source: T) where T : Swift.BinaryFloatingPoint
  init<T>(_ source: T) where T : Swift.BinaryFloatingPoint
  init<T>(_ source: T) where T : Swift.BinaryInteger
  init<T>(truncatingIfNeeded source: T) where T : Swift.BinaryInteger
  init<T>(clamping source: T) where T : Swift.BinaryInteger
  associatedtype Words : Swift.RandomAccessCollection where Self.Words.Element == Swift.UInt, Self.Words.Index == Swift.Int
  var words: Self.Words { get }
  var _lowWord: Swift.UInt { get }
  var bitWidth: Swift.Int { get }
  func _binaryLogarithm() -> Swift.Int
  var trailingZeroBitCount: Swift.Int { get }
  static func / (lhs: Self, rhs: Self) -> Self
  static func /= (lhs: inout Self, rhs: Self)
  static func % (lhs: Self, rhs: Self) -> Self
  static func %= (lhs: inout Self, rhs: Self)
  override static func + (lhs: Self, rhs: Self) -> Self
  override static func += (lhs: inout Self, rhs: Self)
  override static func - (lhs: Self, rhs: Self) -> Self
  override static func -= (lhs: inout Self, rhs: Self)
  override static func * (lhs: Self, rhs: Self) -> Self
  override static func *= (lhs: inout Self, rhs: Self)
  prefix static func ~ (x: Self) -> Self
  static func & (lhs: Self, rhs: Self) -> Self
  static func &= (lhs: inout Self, rhs: Self)
  static func | (lhs: Self, rhs: Self) -> Self
  static func |= (lhs: inout Self, rhs: Self)
  static func ^ (lhs: Self, rhs: Self) -> Self
  static func ^= (lhs: inout Self, rhs: Self)
  static func >> <RHS>(lhs: Self, rhs: RHS) -> Self where RHS : Swift.BinaryInteger
  static func >>= <RHS>(lhs: inout Self, rhs: RHS) where RHS : Swift.BinaryInteger
  static func << <RHS>(lhs: Self, rhs: RHS) -> Self where RHS : Swift.BinaryInteger
  static func <<= <RHS>(lhs: inout Self, rhs: RHS) where RHS : Swift.BinaryInteger
  func quotientAndRemainder(dividingBy rhs: Self) -> (quotient: Self, remainder: Self)
  func isMultiple(of other: Self) -> Swift.Bool
  func signum() -> Self
}
extension BinaryInteger {
  @_transparent public init() {
    self = 0
  }
  @inlinable public func signum() -> Self {
    return (self > (0 as Self) ? 1 : 0) - (self < (0 as Self) ? 1 : 0)
  }
  @_transparent public var _lowWord: Swift.UInt {
    @_transparent get {
    var it = words.makeIterator()
    return it.next() ?? 0
  }
  }
  @inlinable public func _binaryLogarithm() -> Swift.Int {
    _precondition(self > (0 as Self))
    var (quotient, remainder) =
      (bitWidth &- 1).quotientAndRemainder(dividingBy: UInt.bitWidth)
    remainder = remainder &+ 1
    var word = UInt(truncatingIfNeeded: self >> (bitWidth &- remainder))
    // If, internally, a variable-width binary integer uses digits of greater
    // bit width than that of Magnitude.Words.Element (i.e., UInt), then it is
    // possible that `word` could be zero. Additionally, a signed variable-width
    // binary integer may have a leading word that is zero to store a clear sign
    // bit.
    while word == 0 {
      quotient = quotient &- 1
      remainder = remainder &+ UInt.bitWidth
      word = UInt(truncatingIfNeeded: self >> (bitWidth &- remainder))
    }
    // Note that the order of operations below is important to guarantee that
    // we won't overflow.
    return UInt.bitWidth &* quotient &+
        (UInt.bitWidth &- (word.leadingZeroBitCount &+ 1))
  }
  @inlinable public func quotientAndRemainder(dividingBy rhs: Self) -> (quotient: Self, remainder: Self) {
    return (self / rhs, self % rhs)
  }
  @inlinable public func isMultiple(of other: Self) -> Swift.Bool {
    // Nothing but zero is a multiple of zero.
    if other == 0 { return self == 0 }
    // Do the test in terms of magnitude, which guarantees there are no other
    // edge cases. If we write this as `self % other` instead, it could trap
    // for types that are not symmetric around zero.
    return self.magnitude % other.magnitude == 0
  }
  @_transparent public static func & (lhs: Self, rhs: Self) -> Self {
    var lhs = lhs
    lhs &= rhs
    return lhs
  }
  @_transparent public static func | (lhs: Self, rhs: Self) -> Self {
    var lhs = lhs
    lhs |= rhs
    return lhs
  }
  @_transparent public static func ^ (lhs: Self, rhs: Self) -> Self {
    var lhs = lhs
    lhs ^= rhs
    return lhs
  }
  @_semantics("optimize.sil.specialize.generic.partial.never") @_transparent public static func >> <RHS>(lhs: Self, rhs: RHS) -> Self where RHS : Swift.BinaryInteger {
    var r = lhs
    r >>= rhs
    return r
  }
  @_semantics("optimize.sil.specialize.generic.partial.never") @_transparent public static func << <RHS>(lhs: Self, rhs: RHS) -> Self where RHS : Swift.BinaryInteger {
    var r = lhs
    r <<= rhs
    return r
  }
}
extension BinaryInteger {
  @_semantics("binaryInteger.description") public var description: Swift.String {
    get
  }
}
extension BinaryInteger {
  @inlinable @inline(__always) public func distance(to other: Self) -> Swift.Int {
    if !Self.isSigned {
      if self > other {
        if let result = Int(exactly: self - other) {
          return -result
        }
      } else {
        if let result = Int(exactly: other - self) {
          return result
        }
      }
    } else {
      let isNegative = self < (0 as Self)
      if isNegative == (other < (0 as Self)) {
        if let result = Int(exactly: other - self) {
          return result
        }
      } else {
        if let result = Int(exactly: self.magnitude + other.magnitude) {
          return isNegative ? result : -result
        }
      }
    }
    _preconditionFailure("Distance is not representable in Int")
  }
  @inlinable @inline(__always) public func advanced(by n: Swift.Int) -> Self {
    if !Self.isSigned {
      return n < (0 as Int)
        ? self - Self(-n)
        : self + Self(n)
    }
    if (self < (0 as Self)) == (n < (0 as Self)) {
      return self + Self(n)
    }
    return self.magnitude < n.magnitude
      ? Self(Int(self) + n)
      : self + Self(n)
  }
}
extension BinaryInteger {
  @_transparent public static func == <Other>(lhs: Self, rhs: Other) -> Swift.Bool where Other : Swift.BinaryInteger {
    let lhsNegative = Self.isSigned && lhs < (0 as Self)
    let rhsNegative = Other.isSigned && rhs < (0 as Other)

    if lhsNegative != rhsNegative { return false }

    // Here we know the values are of the same sign.
    //
    // There are a few possible scenarios from here:
    //
    // 1. Both values are negative
    //  - If one value is strictly wider than the other, then it is safe to
    //    convert to the wider type.
    //  - If the values are of the same width, it does not matter which type we
    //    choose to convert to as the values are already negative, and thus
    //    include the sign bit if two's complement representation already.
    // 2. Both values are non-negative
    //  - If one value is strictly wider than the other, then it is safe to
    //    convert to the wider type.
    //  - If the values are of the same width, than signedness matters, as not
    //    unsigned types are 'wider' in a sense they don't need to 'waste' the
    //    sign bit. Therefore it is safe to convert to the unsigned type.

    if lhs.bitWidth < rhs.bitWidth {
      return Other(truncatingIfNeeded: lhs) == rhs
    }
    if lhs.bitWidth > rhs.bitWidth {
      return lhs == Self(truncatingIfNeeded: rhs)
    }

    if Self.isSigned {
      return Other(truncatingIfNeeded: lhs) == rhs
    }
    return lhs == Self(truncatingIfNeeded: rhs)
  }
  @_transparent public static func != <Other>(lhs: Self, rhs: Other) -> Swift.Bool where Other : Swift.BinaryInteger {
    return !(lhs == rhs)
  }
  @_transparent public static func < <Other>(lhs: Self, rhs: Other) -> Swift.Bool where Other : Swift.BinaryInteger {
    let lhsNegative = Self.isSigned && lhs < (0 as Self)
    let rhsNegative = Other.isSigned && rhs < (0 as Other)
    if lhsNegative != rhsNegative { return lhsNegative }

    if lhs == (0 as Self) && rhs == (0 as Other) { return false }

    // if we get here, lhs and rhs have the same sign. If they're negative,
    // then Self and Other are both signed types, and one of them can represent
    // values of the other type. Otherwise, lhs and rhs are positive, and one
    // of Self, Other may be signed and the other unsigned.

    let rhsAsSelf = Self(truncatingIfNeeded: rhs)
    let rhsAsSelfNegative = rhsAsSelf < (0 as Self)


    // Can we round-trip rhs through Other?
    if Other(truncatingIfNeeded: rhsAsSelf) == rhs &&
      // This additional check covers the `Int8.max < (128 as UInt8)` case.
      // Since the types are of the same width, init(truncatingIfNeeded:)
      // will result in a simple bitcast, so that rhsAsSelf would be -128, and
      // `lhs < rhsAsSelf` will return false.
      // We basically guard against that bitcast by requiring rhs and rhsAsSelf
      // to be the same sign.
      rhsNegative == rhsAsSelfNegative {
      return lhs < rhsAsSelf
    }

    return Other(truncatingIfNeeded: lhs) < rhs
  }
  @_transparent public static func <= <Other>(lhs: Self, rhs: Other) -> Swift.Bool where Other : Swift.BinaryInteger {
    return !(rhs < lhs)
  }
  @_transparent public static func >= <Other>(lhs: Self, rhs: Other) -> Swift.Bool where Other : Swift.BinaryInteger {
    return !(lhs < rhs)
  }
  @_transparent public static func > <Other>(lhs: Self, rhs: Other) -> Swift.Bool where Other : Swift.BinaryInteger {
    return rhs < lhs
  }
}
extension BinaryInteger {
  @_transparent public static func != (lhs: Self, rhs: Self) -> Swift.Bool {
    return !(lhs == rhs)
  }
  @_transparent public static func <= (lhs: Self, rhs: Self) -> Swift.Bool {
    return !(rhs < lhs)
  }
  @_transparent public static func >= (lhs: Self, rhs: Self) -> Swift.Bool {
    return !(lhs < rhs)
  }
  @_transparent public static func > (lhs: Self, rhs: Self) -> Swift.Bool {
    return rhs < lhs
  }
}
public protocol FixedWidthInteger : Swift.BinaryInteger, Swift.LosslessStringConvertible where Self.Magnitude : Swift.FixedWidthInteger, Self.Magnitude : Swift.UnsignedInteger, Self.Stride : Swift.FixedWidthInteger, Self.Stride : Swift.SignedInteger {
  static var bitWidth: Swift.Int { get }
  static var max: Self { get }
  static var min: Self { get }
  func addingReportingOverflow(_ rhs: Self) -> (partialValue: Self, overflow: Swift.Bool)
  func subtractingReportingOverflow(_ rhs: Self) -> (partialValue: Self, overflow: Swift.Bool)
  func multipliedReportingOverflow(by rhs: Self) -> (partialValue: Self, overflow: Swift.Bool)
  func dividedReportingOverflow(by rhs: Self) -> (partialValue: Self, overflow: Swift.Bool)
  func remainderReportingOverflow(dividingBy rhs: Self) -> (partialValue: Self, overflow: Swift.Bool)
  func multipliedFullWidth(by other: Self) -> (high: Self, low: Self.Magnitude)
  func dividingFullWidth(_ dividend: (high: Self, low: Self.Magnitude)) -> (quotient: Self, remainder: Self)
  init(_truncatingBits bits: Swift.UInt)
  var nonzeroBitCount: Swift.Int { get }
  var leadingZeroBitCount: Swift.Int { get }
  init(bigEndian value: Self)
  init(littleEndian value: Self)
  var bigEndian: Self { get }
  var littleEndian: Self { get }
  var byteSwapped: Self { get }
  static func &>> (lhs: Self, rhs: Self) -> Self
  static func &>>= (lhs: inout Self, rhs: Self)
  static func &<< (lhs: Self, rhs: Self) -> Self
  static func &<<= (lhs: inout Self, rhs: Self)
}
extension FixedWidthInteger {
  @inlinable public var bitWidth: Swift.Int {
    get { return Self.bitWidth }
  }
  @inlinable public func _binaryLogarithm() -> Swift.Int {
    _precondition(self > (0 as Self))
    return Self.bitWidth &- (leadingZeroBitCount &+ 1)
  }
  @inlinable public init(littleEndian value: Self) {
    self = value
  }
  @inlinable public init(bigEndian value: Self) {
    self = value.byteSwapped
  }
  @inlinable public var littleEndian: Self {
    get {
    return self
  }
  }
  @inlinable public var bigEndian: Self {
    get {
    return byteSwapped
  }
  }
  @_alwaysEmitIntoClient public func multipliedFullWidth(by other: Self) -> (high: Self, low: Self.Magnitude) {
    // We define a utility function for splitting an integer into high and low
    // halves. Note that the low part is always unsigned, while the high part
    // matches the signedness of the input type. Both result types are the
    // full width of the original number; this may be surprising at first, but
    // there are two reasons for it:
    //
    // - we're going to use these as inputs to a multiplication operation, and
    //   &* is quite a bit less verbose than `multipliedFullWidth`, so it makes
    //   the rest of the code in this function somewhat easier to read.
    //
    // - there's no "half width type" that we can get at from this generic
    //   context, so there's not really another option anyway.
    //
    // Fortunately, the compiler is pretty good about propagating the necessary
    // information to optimize away unnecessary arithmetic.
    func split<T: FixedWidthInteger>(_ x: T) -> (high: T, low: T.Magnitude) {
      let n = T.bitWidth/2
      return (x >> n, T.Magnitude(truncatingIfNeeded: x) & ((1 &<< n) &- 1))
    }
    // Split `self` and `other` into high and low parts, compute the partial
    // products carrying high words in as we go. We use the wrapping operators
    // and `truncatingIfNeeded` inits purely as an optimization hint to the
    // compiler; none of these operations will ever wrap due to the constraints
    // on the arithmetic. The bounds are documented before each line for signed
    // types. For unsigned types, the bounds are much more well known and
    // easier to derive, so I haven't bothered to document them here, but they
    // all boil down to the fact that a*b + c + d cannot overflow a double-
    // width result with unsigned a, b, c, d.
    let (x1, x0) = split(self)
    let (y1, y0) = split(other)
    // If B is 2^bitWidth/2, x0 and y0 are in 0 ... B-1, so their product is
    // in 0 ... B^2-2B+1. For further analysis, we'll need the fact that
    // the high word is in 0 ... B-2.
    let p00 = x0 &* y0
    // x1 is in -B/2 ... B/2-1, so the product x1*y0 is in
    // -(B^2-B)/2 ... (B^2-3B+2)/2; after adding the high word of p00, the
    // result is in -(B^2-B)/2 ... (B^2-B-2)/2.
    let p01 = x1 &* Self(y0) &+ Self(split(p00).high)
    // The previous analysis holds for this product as well, and the sum is
    // in -(B^2-B)/2 ... (B^2-B)/2.
    let p10 = Self(x0) &* y1 &+ Self(split(p01).low)
    // No analysis is necessary for this term, because we know the product as
    // a whole cannot overflow, and this term is the final high word of the
    // product.
    let p11 = x1 &* y1 &+ split(p01).high &+ split(p10).high
    // Now we only need to assemble the low word of the product.
    return (p11, split(p10).low << (bitWidth/2) | split(p00).low)
  }
  @_semantics("optimize.sil.specialize.generic.partial.never") @_transparent public static func &>> (lhs: Self, rhs: Self) -> Self {
    var lhs = lhs
    lhs &>>= rhs
    return lhs
  }
  @_semantics("optimize.sil.specialize.generic.partial.never") @_transparent public static func &>> <Other>(lhs: Self, rhs: Other) -> Self where Other : Swift.BinaryInteger {
    return lhs &>> Self(truncatingIfNeeded: rhs)
  }
  @_semantics("optimize.sil.specialize.generic.partial.never") @_transparent public static func &>>= <Other>(lhs: inout Self, rhs: Other) where Other : Swift.BinaryInteger {
    lhs = lhs &>> rhs
  }
  @_semantics("optimize.sil.specialize.generic.partial.never") @_transparent public static func &<< (lhs: Self, rhs: Self) -> Self {
    var lhs = lhs
    lhs &<<= rhs
    return lhs
  }
  @_semantics("optimize.sil.specialize.generic.partial.never") @_transparent public static func &<< <Other>(lhs: Self, rhs: Other) -> Self where Other : Swift.BinaryInteger {
    return lhs &<< Self(truncatingIfNeeded: rhs)
  }
  @_semantics("optimize.sil.specialize.generic.partial.never") @_transparent public static func &<<= <Other>(lhs: inout Self, rhs: Other) where Other : Swift.BinaryInteger {
    lhs = lhs &<< rhs
  }
}
extension FixedWidthInteger {
  @inlinable public static func random<T>(in range: Swift.Range<Self>, using generator: inout T) -> Self where T : Swift.RandomNumberGenerator {
    _precondition(
      !range.isEmpty,
      "Can't get random value with an empty range"
    )

    // Compute delta, the distance between the lower and upper bounds. This
    // value may not representable by the type Bound if Bound is signed, but
    // is always representable as Bound.Magnitude.
    let delta = Magnitude(truncatingIfNeeded: range.upperBound &- range.lowerBound)
    // The mathematical result we want is lowerBound plus a random value in
    // 0 ..< delta. We need to be slightly careful about how we do this
    // arithmetic; the Bound type cannot generally represent the random value,
    // so we use a wrapping addition on Bound.Magnitude. This will often
    // overflow, but produces the correct bit pattern for the result when
    // converted back to Bound.
    return Self(truncatingIfNeeded:
      Magnitude(truncatingIfNeeded: range.lowerBound) &+
      generator.next(upperBound: delta)
    )
  }
  @inlinable public static func random(in range: Swift.Range<Self>) -> Self {
    var g = SystemRandomNumberGenerator()
    return Self.random(in: range, using: &g)
  }
  @inlinable public static func random<T>(in range: Swift.ClosedRange<Self>, using generator: inout T) -> Self where T : Swift.RandomNumberGenerator {
    // Compute delta, the distance between the lower and upper bounds. This
    // value may not representable by the type Bound if Bound is signed, but
    // is always representable as Bound.Magnitude.
    var delta = Magnitude(truncatingIfNeeded: range.upperBound &- range.lowerBound)
    // Subtle edge case: if the range is the whole set of representable values,
    // then adding one to delta to account for a closed range will overflow.
    // If we used &+ instead, the result would be zero, which isn't helpful,
    // so we actually need to handle this case separately.
    if delta == Magnitude.max {
      return Self(truncatingIfNeeded: generator.next() as Magnitude)
    }
    // Need to widen delta to account for the right-endpoint of a closed range.
    delta += 1
    // The mathematical result we want is lowerBound plus a random value in
    // 0 ..< delta. We need to be slightly careful about how we do this
    // arithmetic; the Bound type cannot generally represent the random value,
    // so we use a wrapping addition on Bound.Magnitude. This will often
    // overflow, but produces the correct bit pattern for the result when
    // converted back to Bound.
    return Self(truncatingIfNeeded:
      Magnitude(truncatingIfNeeded: range.lowerBound) &+
      generator.next(upperBound: delta)
    )
  }
  @inlinable public static func random(in range: Swift.ClosedRange<Self>) -> Self {
    var g = SystemRandomNumberGenerator()
    return Self.random(in: range, using: &g)
  }
}
extension FixedWidthInteger {
  @_transparent prefix public static func ~ (x: Self) -> Self {
    return 0 &- x &- 1
  }
  @_semantics("optimize.sil.specialize.generic.partial.never") @_transparent public static func >> <Other>(lhs: Self, rhs: Other) -> Self where Other : Swift.BinaryInteger {
    var lhs = lhs
    _nonMaskingRightShiftGeneric(&lhs, rhs)
    return lhs
  }
  @_transparent @_semantics("optimize.sil.specialize.generic.partial.never") public static func >>= <Other>(lhs: inout Self, rhs: Other) where Other : Swift.BinaryInteger {
    _nonMaskingRightShiftGeneric(&lhs, rhs)
  }
  @_transparent public static func _nonMaskingRightShiftGeneric<Other>(_ lhs: inout Self, _ rhs: Other) where Other : Swift.BinaryInteger {
    let shift = rhs < -Self.bitWidth ? -Self.bitWidth
                : rhs > Self.bitWidth ? Self.bitWidth
                : Int(rhs)
    lhs = _nonMaskingRightShift(lhs, shift)
  }
  @_transparent public static func _nonMaskingRightShift(_ lhs: Self, _ rhs: Swift.Int) -> Self {
    let overshiftR = Self.isSigned ? lhs &>> (Self.bitWidth - 1) : 0
    let overshiftL: Self = 0
    if _fastPath(rhs >= 0) {
      if _fastPath(rhs < Self.bitWidth) {
        return lhs &>> Self(truncatingIfNeeded: rhs)
      }
      return overshiftR
    }

    if _slowPath(rhs <= -Self.bitWidth) {
      return overshiftL
    }
    return lhs &<< -rhs
  }
  @_semantics("optimize.sil.specialize.generic.partial.never") @_transparent public static func << <Other>(lhs: Self, rhs: Other) -> Self where Other : Swift.BinaryInteger {
    var lhs = lhs
    _nonMaskingLeftShiftGeneric(&lhs, rhs)
    return lhs
  }
  @_transparent @_semantics("optimize.sil.specialize.generic.partial.never") public static func <<= <Other>(lhs: inout Self, rhs: Other) where Other : Swift.BinaryInteger {
    _nonMaskingLeftShiftGeneric(&lhs, rhs)
  }
  @_transparent public static func _nonMaskingLeftShiftGeneric<Other>(_ lhs: inout Self, _ rhs: Other) where Other : Swift.BinaryInteger {
    let shift = rhs < -Self.bitWidth ? -Self.bitWidth
                : rhs > Self.bitWidth ? Self.bitWidth
                : Int(rhs)
    lhs = _nonMaskingLeftShift(lhs, shift)
  }
  @_transparent public static func _nonMaskingLeftShift(_ lhs: Self, _ rhs: Swift.Int) -> Self {
    let overshiftR = Self.isSigned ? lhs &>> (Self.bitWidth - 1) : 0
    let overshiftL: Self = 0
    if _fastPath(rhs >= 0) {
      if _fastPath(rhs < Self.bitWidth) {
        return lhs &<< Self(truncatingIfNeeded: rhs)
      }
      return overshiftL
    }

    if _slowPath(rhs <= -Self.bitWidth) {
      return overshiftR
    }
    return lhs &>> -rhs
  }
}
extension FixedWidthInteger {
  @inlinable @_semantics("optimize.sil.specialize.generic.partial.never") public static func _convert<Source>(from source: Source) -> (value: Self?, exact: Swift.Bool) where Source : Swift.BinaryFloatingPoint {
    guard _fastPath(!source.isZero) else { return (0, true) }
    guard _fastPath(source.isFinite) else { return (nil, false) }
    guard Self.isSigned || source > -1 else { return (nil, false) }
    let exponent = source.exponent
    if _slowPath(Self.bitWidth <= exponent) { return (nil, false) }
    let minBitWidth = source.significandWidth
    let isExact = (minBitWidth <= exponent)
    let bitPattern = source.significandBitPattern
    // Determine the actual number of fractional significand bits.
    // `Source.significandBitCount` would not reflect the actual number of
    // fractional significand bits if `Source` is not a fixed-width floating-point
    // type; we can compute this value as follows if `source` is finite:
    let bitWidth = minBitWidth &+ bitPattern.trailingZeroBitCount
    let shift = exponent - Source.Exponent(bitWidth)
    // Use `Self.Magnitude` to prevent sign extension if `shift < 0`.
    let shiftedBitPattern = Self.Magnitude.bitWidth > bitWidth
      ? Self.Magnitude(truncatingIfNeeded: bitPattern) << shift
      : Self.Magnitude(truncatingIfNeeded: bitPattern << shift)
    if _slowPath(Self.isSigned && Self.bitWidth &- 1 == exponent) {
      return source < 0 && shiftedBitPattern == 0
        ? (Self.min, isExact)
        : (nil, false)
    }
    let magnitude = ((1 as Self.Magnitude) << exponent) | shiftedBitPattern
    return (
      Self.isSigned && source < 0 ? 0 &- Self(magnitude) : Self(magnitude),
      isExact)
  }
  @inlinable @_semantics("optimize.sil.specialize.generic.partial.never") @inline(__always) public init<T>(_ source: T) where T : Swift.BinaryFloatingPoint {
    guard let value = Self._convert(from: source).value else {
      fatalError("""
        \(T.self) value cannot be converted to \(Self.self) because it is \
        outside the representable range
        """)
    }
    self = value
  }
  @_semantics("optimize.sil.specialize.generic.partial.never") @inlinable public init?<T>(exactly source: T) where T : Swift.BinaryFloatingPoint {
    let (temporary, exact) = Self._convert(from: source)
    guard exact, let value = temporary else {
      return nil
    }
    self = value
  }
  @inlinable @_semantics("optimize.sil.specialize.generic.partial.never") public init<Other>(clamping source: Other) where Other : Swift.BinaryInteger {
    if _slowPath(source < Self.min) {
      self = Self.min
    }
    else if _slowPath(source > Self.max) {
      self = Self.max
    }
    else { self = Self(truncatingIfNeeded: source) }
  }
  @inlinable @inline(__always) public init<T>(truncatingIfNeeded source: T) where T : Swift.BinaryInteger {
    if Self.bitWidth <= Int.bitWidth {
      self = Self(_truncatingBits: source._lowWord)
    }
    else {
      let neg = source < (0 as T)
      var result: Self = neg ? ~0 : 0
      var shift: Self = 0
      let width = Self(_truncatingBits: Self.bitWidth._lowWord)
      for word in source.words {
        guard shift < width else { break }
        // Masking shift is OK here because we have already ensured
        // that shift < Self.bitWidth. Not masking results in
        // infinite recursion.
        result ^= Self(_truncatingBits: neg ? ~word : word) &<< shift
        shift += Self(_truncatingBits: Int.bitWidth._lowWord)
      }
      self = result
    }
  }
  @_transparent public static var _highBitIndex: Self {
    @_transparent get {
    return Self.init(_truncatingBits: UInt(Self.bitWidth._value) &- 1)
  }
  }
  @_transparent public static func &+ (lhs: Self, rhs: Self) -> Self {
    return lhs.addingReportingOverflow(rhs).partialValue
  }
  @_transparent public static func &+= (lhs: inout Self, rhs: Self) {
    lhs = lhs &+ rhs
  }
  @_transparent public static func &- (lhs: Self, rhs: Self) -> Self {
    return lhs.subtractingReportingOverflow(rhs).partialValue
  }
  @_transparent public static func &-= (lhs: inout Self, rhs: Self) {
    lhs = lhs &- rhs
  }
  @_transparent public static func &* (lhs: Self, rhs: Self) -> Self {
    return lhs.multipliedReportingOverflow(by: rhs).partialValue
  }
  @_transparent public static func &*= (lhs: inout Self, rhs: Self) {
    lhs = lhs &* rhs
  }
}
extension FixedWidthInteger {
  @inlinable public static func _random<R>(using generator: inout R) -> Self where R : Swift.RandomNumberGenerator {
    if bitWidth <= UInt64.bitWidth {
      return Self(truncatingIfNeeded: generator.next())
    }

    let (quotient, remainder) = bitWidth.quotientAndRemainder(
      dividingBy: UInt64.bitWidth
    )
    var tmp: Self = 0
    for i in 0 ..< quotient + remainder.signum() {
      let next: UInt64 = generator.next()
      tmp += Self(truncatingIfNeeded: next) &<< (UInt64.bitWidth * i)
    }
    return tmp
  }
}
public protocol UnsignedInteger : Swift.BinaryInteger {
}
extension UnsignedInteger {
  @inlinable public var magnitude: Self {
    @inline(__always) get { return self }
  }
  @inlinable public static var isSigned: Swift.Bool {
    @inline(__always) get { return false }
  }
}
extension UnsignedInteger where Self : Swift.FixedWidthInteger {
  @_semantics("optimize.sil.specialize.generic.partial.never") @inlinable @inline(__always) public init<T>(_ source: T) where T : Swift.BinaryInteger {
    // This check is potentially removable by the optimizer
    if T.isSigned {
      _precondition(source >= (0 as T), "Negative value is not representable")
    }
    // This check is potentially removable by the optimizer
    if source.bitWidth >= Self.bitWidth {
      _precondition(source <= Self.max,
        "Not enough bits to represent the passed value")
    }
    self.init(truncatingIfNeeded: source)
  }
  @_semantics("optimize.sil.specialize.generic.partial.never") @inlinable @inline(__always) public init?<T>(exactly source: T) where T : Swift.BinaryInteger {
    // This check is potentially removable by the optimizer
    if T.isSigned && source < (0 as T) {
      return nil
    }
    // The width check can be eliminated by the optimizer
    if source.bitWidth >= Self.bitWidth &&
       source > Self.max {
      return nil
    }
    self.init(truncatingIfNeeded: source)
  }
  @_transparent public static var max: Self {
    @_transparent get { return ~0 }
  }
  @_transparent public static var min: Self {
    @_transparent get { return 0 }
  }
}
public protocol SignedInteger : Swift.BinaryInteger, Swift.SignedNumeric {
  static func _maskingAdd(_ lhs: Self, _ rhs: Self) -> Self
  static func _maskingSubtract(_ lhs: Self, _ rhs: Self) -> Self
}
extension SignedInteger {
  @inlinable public static var isSigned: Swift.Bool {
    @inline(__always) get { return true }
  }
}
extension SignedInteger where Self : Swift.FixedWidthInteger {
  @_semantics("optimize.sil.specialize.generic.partial.never") @inlinable @inline(__always) public init<T>(_ source: T) where T : Swift.BinaryInteger {
    // This check is potentially removable by the optimizer
    if T.isSigned && source.bitWidth > Self.bitWidth {
      _precondition(source >= Self.min,
        "Not enough bits to represent a signed value")
    }
    // This check is potentially removable by the optimizer
    if (source.bitWidth > Self.bitWidth) ||
       (source.bitWidth == Self.bitWidth && !T.isSigned) {
      _precondition(source <= Self.max,
        "Not enough bits to represent the passed value")
    }
    self.init(truncatingIfNeeded: source)
  }
  @_semantics("optimize.sil.specialize.generic.partial.never") @inlinable @inline(__always) public init?<T>(exactly source: T) where T : Swift.BinaryInteger {
    // This check is potentially removable by the optimizer
    if T.isSigned && source.bitWidth > Self.bitWidth && source < Self.min {
      return nil
    }
    // The width check can be eliminated by the optimizer
    if (source.bitWidth > Self.bitWidth ||
        (source.bitWidth == Self.bitWidth && !T.isSigned)) &&
       source > Self.max {
      return nil
    }
    self.init(truncatingIfNeeded: source)
  }
  @_transparent public static var max: Self {
    @_transparent get { return ~min }
  }
  @_transparent public static var min: Self {
    @_transparent get {
    return (-1 as Self) &<< Self._highBitIndex
  }
  }
  @inlinable public func isMultiple(of other: Self) -> Swift.Bool {
    // Nothing but zero is a multiple of zero.
    if other == 0 { return self == 0 }
    // Special case to avoid overflow on .min / -1 for signed types.
    if other == -1 { return true }
    // Having handled those special cases, this is safe.
    return self % other == 0
  }
}
@inlinable public func numericCast<T, U>(_ x: T) -> U where T : Swift.BinaryInteger, U : Swift.BinaryInteger {
  return U(x)
}
extension SignedInteger {
  @_transparent public static func _maskingAdd(_ lhs: Self, _ rhs: Self) -> Self {
    fatalError("Should be overridden in a more specific type")
  }
  @_transparent public static func _maskingSubtract(_ lhs: Self, _ rhs: Self) -> Self {
    fatalError("Should be overridden in a more specific type")
  }
}
extension SignedInteger where Self : Swift.FixedWidthInteger {
  @_transparent public static func &+ (lhs: Self, rhs: Self) -> Self {
    return _maskingAdd(lhs, rhs)
  }
  @_transparent public static func _maskingAdd(_ lhs: Self, _ rhs: Self) -> Self {
    return lhs.addingReportingOverflow(rhs).partialValue
  }
  @_transparent public static func &- (lhs: Self, rhs: Self) -> Self {
    return _maskingSubtract(lhs, rhs)
  }
  @_transparent public static func _maskingSubtract(_ lhs: Self, _ rhs: Self) -> Self {
    return lhs.subtractingReportingOverflow(rhs).partialValue
  }
}
@frozen public struct JoinedSequence<Base> where Base : Swift.Sequence, Base.Element : Swift.Sequence {
  public typealias Element = Base.Element.Element
  @usableFromInline
  internal var _base: Base
  @usableFromInline
  internal var _separator: Swift.ContiguousArray<Swift.JoinedSequence<Base>.Element>
  @inlinable public init<Separator>(base: Base, separator: Separator) where Separator : Swift.Sequence, Separator.Element == Base.Element.Element {
    self._base = base
    self._separator = ContiguousArray(separator)
  }
}
extension JoinedSequence {
  @frozen public struct Iterator {
    @usableFromInline
    internal var _base: Base.Iterator
    @usableFromInline
    internal var _inner: Base.Element.Iterator?
    @usableFromInline
    internal var _separatorData: Swift.ContiguousArray<Swift.JoinedSequence<Base>.Iterator.Element>
    @usableFromInline
    internal var _separator: Swift.ContiguousArray<Swift.JoinedSequence<Base>.Iterator.Element>.Iterator?
    @usableFromInline
    @frozen internal enum _JoinIteratorState {
      case start
      case generatingElements
      case generatingSeparator
      case end
      @usableFromInline
      internal static func == (a: Swift.JoinedSequence<Base>.Iterator._JoinIteratorState, b: Swift.JoinedSequence<Base>.Iterator._JoinIteratorState) -> Swift.Bool
      @usableFromInline
      internal func hash(into hasher: inout Swift.Hasher)
      @usableFromInline
      internal var hashValue: Swift.Int {
        @usableFromInline
        get
      }
    }
    @usableFromInline
    internal var _state: Swift.JoinedSequence<Base>.Iterator._JoinIteratorState = .start
    @inlinable public init<Separator>(base: Base.Iterator, separator: Separator) where Separator : Swift.Sequence, Separator.Element == Base.Element.Element {
      self._base = base
      self._separatorData = ContiguousArray(separator)
    }
  }
}
extension JoinedSequence.Iterator : Swift.IteratorProtocol {
  public typealias Element = Base.Element.Element
  @inlinable public mutating func next() -> Swift.JoinedSequence<Base>.Iterator.Element? {
    while true {
      switch _state {
      case .start:
        if let nextSubSequence = _base.next() {
          _inner = nextSubSequence.makeIterator()
          _state = .generatingElements
        } else {
          _state = .end
          return nil
        }

      case .generatingElements:
        let result = _inner!.next()
        if _fastPath(result != nil) {
          return result
        }
        _inner = _base.next()?.makeIterator()
        if _inner == nil {
          _state = .end
          return nil
        }
        if !_separatorData.isEmpty {
          _separator = _separatorData.makeIterator()
          _state = .generatingSeparator
        }

      case .generatingSeparator:
        let result = _separator!.next()
        if _fastPath(result != nil) {
          return result
        }
        _state = .generatingElements

      case .end:
        return nil
      }
    }
  }
}
extension JoinedSequence : Swift.Sequence {
  @inlinable __consuming public func makeIterator() -> Swift.JoinedSequence<Base>.Iterator {
    return Iterator(base: _base.makeIterator(), separator: _separator)
  }
  @inlinable __consuming public func _copyToContiguousArray() -> Swift.ContiguousArray<Swift.JoinedSequence<Base>.Element> {
    var result = ContiguousArray<Element>()
    let separatorSize = _separator.count

    if separatorSize == 0 {
      for x in _base {
        result.append(contentsOf: x)
      }
      return result
    }

    var iter = _base.makeIterator()
    if let first = iter.next() {
      result.append(contentsOf: first)
      while let next = iter.next() {
        result.append(contentsOf: _separator)
        result.append(contentsOf: next)
      }
    }

    return result
  }
}
extension Sequence where Self.Element : Swift.Sequence {
  @inlinable __consuming public func joined<Separator>(separator: Separator) -> Swift.JoinedSequence<Self> where Separator : Swift.Sequence, Separator.Element == Self.Element.Element {
    return JoinedSequence(base: self, separator: separator)
  }
}
@_hasMissingDesignatedInitializers @_objcRuntimeName(_TtCs11_AnyKeyPath) public class AnyKeyPath : Swift.Hashable, Swift._AppendKeyPath {
  @inlinable public static var rootType: Any.Type {
    get {
    return _rootAndValueType.root
  }
  }
  @inlinable public static var valueType: Any.Type {
    get {
    return _rootAndValueType.value
  }
  }
  final public var hashValue: Swift.Int {
    get
  }
  @_effects(releasenone) final public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: Swift.AnyKeyPath, b: Swift.AnyKeyPath) -> Swift.Bool
  public var _kvcKeyPathString: Swift.String? {
    @_semantics("keypath.kvcKeyPathString") get
  }
  @usableFromInline
  internal class var _rootAndValueType: (root: Any.Type, value: Any.Type) {
    get
  }
  @usableFromInline
  internal var _storedInlineOffset: Swift.Int? {
    get
  }
  @objc deinit
}
@_inheritsConvenienceInitializers public class PartialKeyPath<Root> : Swift.AnyKeyPath {
  @objc deinit
}
@_inheritsConvenienceInitializers public class KeyPath<Root, Value> : Swift.PartialKeyPath<Root> {
  @usableFromInline
  final override internal class var _rootAndValueType: (root: Any.Type, value: Any.Type) {
    get
  }
  @usableFromInline
  final internal func _projectReadOnly(from root: Root) -> Value
  @objc deinit
}
@_inheritsConvenienceInitializers public class WritableKeyPath<Root, Value> : Swift.KeyPath<Root, Value> {
  @usableFromInline
  internal func _projectMutableAddress(from base: Swift.UnsafePointer<Root>) -> (pointer: Swift.UnsafeMutablePointer<Value>, owner: Swift.AnyObject?)
  @objc deinit
}
@_inheritsConvenienceInitializers public class ReferenceWritableKeyPath<Root, Value> : Swift.WritableKeyPath<Root, Value> {
  @usableFromInline
  final internal func _projectMutableAddress(from origBase: Root) -> (pointer: Swift.UnsafeMutablePointer<Value>, owner: Swift.AnyObject?)
  @objc deinit
}
@_silgen_name("swift_getAtPartialKeyPath")
public func _getAtPartialKeyPath<Root>(root: Root, keyPath: Swift.PartialKeyPath<Root>) -> Any
@_silgen_name("swift_getAtAnyKeyPath")
public func _getAtAnyKeyPath<RootValue>(root: RootValue, keyPath: Swift.AnyKeyPath) -> Any?
@_silgen_name("swift_getAtKeyPath")
public func _getAtKeyPath<Root, Value>(root: Root, keyPath: Swift.KeyPath<Root, Value>) -> Value
@_silgen_name("_swift_modifyAtWritableKeyPath_impl")
public func _modifyAtWritableKeyPath_impl<Root, Value>(root: inout Root, keyPath: Swift.WritableKeyPath<Root, Value>) -> (Swift.UnsafeMutablePointer<Value>, Swift.AnyObject?)
@_silgen_name("_swift_modifyAtReferenceWritableKeyPath_impl")
public func _modifyAtReferenceWritableKeyPath_impl<Root, Value>(root: Root, keyPath: Swift.ReferenceWritableKeyPath<Root, Value>) -> (Swift.UnsafeMutablePointer<Value>, Swift.AnyObject?)
@_silgen_name("swift_setAtWritableKeyPath")
public func _setAtWritableKeyPath<Root, Value>(root: inout Root, keyPath: Swift.WritableKeyPath<Root, Value>, value: __owned Value)
@_silgen_name("swift_setAtReferenceWritableKeyPath")
public func _setAtReferenceWritableKeyPath<Root, Value>(root: Root, keyPath: Swift.ReferenceWritableKeyPath<Root, Value>, value: __owned Value)
@_show_in_interface public protocol _AppendKeyPath {
}
extension _AppendKeyPath where Self == Swift.AnyKeyPath {
  @inlinable public func appending(path: Swift.AnyKeyPath) -> Swift.AnyKeyPath? {
    return _tryToAppendKeyPaths(root: self, leaf: path)
  }
}
extension _AppendKeyPath {
  @inlinable public func appending<Root>(path: Swift.AnyKeyPath) -> Swift.PartialKeyPath<Root>? where Self == Swift.PartialKeyPath<Root> {
    return _tryToAppendKeyPaths(root: self, leaf: path)
  }
  @inlinable public func appending<Root, AppendedRoot, AppendedValue>(path: Swift.KeyPath<AppendedRoot, AppendedValue>) -> Swift.KeyPath<Root, AppendedValue>? where Self == Swift.PartialKeyPath<Root> {
    return _tryToAppendKeyPaths(root: self, leaf: path)
  }
  @inlinable public func appending<Root, AppendedRoot, AppendedValue>(path: Swift.ReferenceWritableKeyPath<AppendedRoot, AppendedValue>) -> Swift.ReferenceWritableKeyPath<Root, AppendedValue>? where Self == Swift.PartialKeyPath<Root> {
    return _tryToAppendKeyPaths(root: self, leaf: path)
  }
}
extension _AppendKeyPath {
  @inlinable public func appending<Root, Value, AppendedValue>(path: Swift.KeyPath<Value, AppendedValue>) -> Swift.KeyPath<Root, AppendedValue> where Self : Swift.KeyPath<Root, Value> {
    return _appendingKeyPaths(root: self, leaf: path)
  }
  @inlinable public func appending<Root, Value, AppendedValue>(path: Swift.ReferenceWritableKeyPath<Value, AppendedValue>) -> Swift.ReferenceWritableKeyPath<Root, AppendedValue> where Self == Swift.KeyPath<Root, Value> {
    return _appendingKeyPaths(root: self, leaf: path)
  }
}
extension _AppendKeyPath {
  @inlinable public func appending<Root, Value, AppendedValue>(path: Swift.WritableKeyPath<Value, AppendedValue>) -> Swift.WritableKeyPath<Root, AppendedValue> where Self == Swift.WritableKeyPath<Root, Value> {
    return _appendingKeyPaths(root: self, leaf: path)
  }
  @inlinable public func appending<Root, Value, AppendedValue>(path: Swift.ReferenceWritableKeyPath<Value, AppendedValue>) -> Swift.ReferenceWritableKeyPath<Root, AppendedValue> where Self == Swift.WritableKeyPath<Root, Value> {
    return _appendingKeyPaths(root: self, leaf: path)
  }
}
extension _AppendKeyPath {
  @inlinable public func appending<Root, Value, AppendedValue>(path: Swift.WritableKeyPath<Value, AppendedValue>) -> Swift.ReferenceWritableKeyPath<Root, AppendedValue> where Self == Swift.ReferenceWritableKeyPath<Root, Value> {
    return _appendingKeyPaths(root: self, leaf: path)
  }
}
@usableFromInline
internal func _tryToAppendKeyPaths<Result>(root: Swift.AnyKeyPath, leaf: Swift.AnyKeyPath) -> Result? where Result : Swift.AnyKeyPath
@usableFromInline
internal func _appendingKeyPaths<Root, Value, AppendedValue, Result>(root: Swift.KeyPath<Root, Value>, leaf: Swift.KeyPath<Value, AppendedValue>) -> Result where Result : Swift.KeyPath<Root, AppendedValue>
@_cdecl("swift_getKeyPathImpl")
public func _swift_getKeyPath(pattern: Swift.UnsafeMutableRawPointer, arguments: Swift.UnsafeRawPointer) -> Swift.UnsafeRawPointer
@frozen public struct KeyValuePairs<Key, Value> : Swift.ExpressibleByDictionaryLiteral {
  @usableFromInline
  internal let _elements: [(Key, Value)]
  @inlinable public init(dictionaryLiteral elements: (Key, Value)...) {
    self._elements = elements
  }
}
extension KeyValuePairs : Swift.RandomAccessCollection {
  public typealias Element = (key: Key, value: Value)
  public typealias Index = Swift.Int
  public typealias Indices = Swift.Range<Swift.Int>
  public typealias SubSequence = Swift.Slice<Swift.KeyValuePairs<Key, Value>>
  @inlinable public var startIndex: Swift.KeyValuePairs<Key, Value>.Index {
    get { return 0 }
  }
  @inlinable public var endIndex: Swift.KeyValuePairs<Key, Value>.Index {
    get { return _elements.endIndex }
  }
  @inlinable public subscript(position: Swift.KeyValuePairs<Key, Value>.Index) -> Swift.KeyValuePairs<Key, Value>.Element {
    get {
    return _elements[position]
  }
  }
  public typealias Iterator = Swift.IndexingIterator<Swift.KeyValuePairs<Key, Value>>
}
extension KeyValuePairs : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
extension KeyValuePairs : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
public protocol LazyCollectionProtocol : Swift.Collection, Swift.LazySequenceProtocol where Self.Elements : Swift.Collection {
}
extension LazyCollectionProtocol {
  @inlinable public var lazy: Swift.LazyCollection<Self.Elements> {
    get {		
     return elements.lazy		
   }
  }
}
extension LazyCollectionProtocol where Self.Elements : Swift.LazyCollectionProtocol {
  @inlinable public var lazy: Self.Elements {
    get {		
     return elements		
   }
  }
}
public typealias LazyCollection<T> = Swift.LazySequence<T> where T : Swift.Collection
extension Swift.LazyCollection : Swift.Collection where Base : Swift.Collection {
  public typealias Index = Base.Index
  public typealias Indices = Base.Indices
  public typealias SubSequence = Swift.Slice<Swift.LazySequence<Base>>
  @inlinable public var startIndex: Swift.LazySequence<Base>.Index {
    get { return _base.startIndex }
  }
  @inlinable public var endIndex: Swift.LazySequence<Base>.Index {
    get { return _base.endIndex }
  }
  @inlinable public var indices: Swift.LazySequence<Base>.Indices {
    get { return _base.indices }
  }
  @inlinable public func index(after i: Swift.LazySequence<Base>.Index) -> Swift.LazySequence<Base>.Index {
    return _base.index(after: i)
  }
  @inlinable public subscript(position: Swift.LazySequence<Base>.Index) -> Swift.LazySequence<Base>.Element {
    get {
    return _base[position]
  }
  }
  @inlinable public var isEmpty: Swift.Bool {
    get {
    return _base.isEmpty
  }
  }
  @inlinable public var count: Swift.Int {
    get {
    return _base.count
  }
  }
  @inlinable public func _customIndexOfEquatableElement(_ element: Swift.LazySequence<Base>.Element) -> Swift.LazySequence<Base>.Index?? {
    return _base._customIndexOfEquatableElement(element)
  }
  @inlinable public func _customLastIndexOfEquatableElement(_ element: Swift.LazySequence<Base>.Element) -> Swift.LazySequence<Base>.Index?? {
    return _base._customLastIndexOfEquatableElement(element)
  }
  @inlinable public func index(_ i: Swift.LazySequence<Base>.Index, offsetBy n: Swift.Int) -> Swift.LazySequence<Base>.Index {
    return _base.index(i, offsetBy: n)
  }
  @inlinable public func index(_ i: Swift.LazySequence<Base>.Index, offsetBy n: Swift.Int, limitedBy limit: Swift.LazySequence<Base>.Index) -> Swift.LazySequence<Base>.Index? {
    return _base.index(i, offsetBy: n, limitedBy: limit)
  }
  @inlinable public func distance(from start: Swift.LazySequence<Base>.Index, to end: Swift.LazySequence<Base>.Index) -> Swift.Int {
    return _base.distance(from:start, to: end)
  }
}
extension Swift.LazyCollection : Swift.LazyCollectionProtocol where Base : Swift.Collection {
}
extension Swift.LazyCollection : Swift.BidirectionalCollection where Base : Swift.BidirectionalCollection {
  @inlinable public func index(before i: Swift.LazySequence<Base>.Index) -> Swift.LazySequence<Base>.Index {
    return _base.index(before: i)
  }
}
extension Swift.LazyCollection : Swift.RandomAccessCollection where Base : Swift.RandomAccessCollection {
}
extension Slice : Swift.LazySequenceProtocol where Base : Swift.LazySequenceProtocol {
  public typealias Elements = Swift.Slice<Base>
}
extension ReversedCollection : Swift.LazySequenceProtocol where Base : Swift.LazySequenceProtocol {
  public typealias Elements = Swift.ReversedCollection<Base>
}
public protocol LazySequenceProtocol : Swift.Sequence {
  associatedtype Elements : Swift.Sequence = Self where Self.Element == Self.Elements.Element
  var elements: Self.Elements { get }
}
extension LazySequenceProtocol where Self == Self.Elements {
  @inlinable public var elements: Self {
    get { return self }
  }
}
extension LazySequenceProtocol {
  @inlinable public var lazy: Swift.LazySequence<Self.Elements> {
    get {
    return elements.lazy
  }
  }
}
extension LazySequenceProtocol where Self.Elements : Swift.LazySequenceProtocol {
  @inlinable public var lazy: Self.Elements {
    get {
    return elements
  }
  }
}
@frozen public struct LazySequence<Base> where Base : Swift.Sequence {
  @usableFromInline
  internal var _base: Base
  @inlinable internal init(_base: Base) {
    self._base = _base
  }
}
extension LazySequence : Swift.Sequence {
  public typealias Element = Base.Element
  public typealias Iterator = Base.Iterator
  @inlinable __consuming public func makeIterator() -> Swift.LazySequence<Base>.Iterator {
    return _base.makeIterator()
  }
  @inlinable public var underestimatedCount: Swift.Int {
    get {
    return _base.underestimatedCount
  }
  }
  @discardableResult
  @inlinable __consuming public func _copyContents(initializing buf: Swift.UnsafeMutableBufferPointer<Swift.LazySequence<Base>.Element>) -> (Swift.LazySequence<Base>.Iterator, Swift.UnsafeMutableBufferPointer<Swift.LazySequence<Base>.Element>.Index) {
    return _base._copyContents(initializing: buf)
  }
  @inlinable public func _customContainsEquatableElement(_ element: Swift.LazySequence<Base>.Element) -> Swift.Bool? { 
    return _base._customContainsEquatableElement(element)
  }
  @inlinable __consuming public func _copyToContiguousArray() -> Swift.ContiguousArray<Swift.LazySequence<Base>.Element> {
    return _base._copyToContiguousArray()
  }
}
extension LazySequence : Swift.LazySequenceProtocol {
  public typealias Elements = Base
  @inlinable public var elements: Swift.LazySequence<Base>.Elements {
    get { return _base }
  }
}
extension Sequence {
  @inlinable public var lazy: Swift.LazySequence<Self> {
    get {
    return LazySequence(_base: self)
  }
  }
}
extension Unicode.UTF16 {
  @available(*, unavailable, renamed: "Unicode.UTF16.isASCII")
  @inlinable public static func _isASCII(_ x: Swift.Unicode.UTF16.CodeUnit) -> Swift.Bool {
    return Unicode.UTF16.isASCII(x)
  }
}
@available(*, unavailable, renamed: "Unicode.UTF8.isASCII")
@inlinable internal func _isASCII(_ x: Swift.UInt8) -> Swift.Bool {
  return Unicode.UTF8.isASCII(x)
}
@available(*, unavailable, renamed: "Unicode.UTF8.isContinuation")
@inlinable internal func _isContinuation(_ x: Swift.UInt8) -> Swift.Bool {
  return UTF8.isContinuation(x)
}
extension Substring {
  @available(*, unavailable, renamed: "Substring.base")
  @inlinable internal var _wholeString: Swift.String {
    get { return base }
  }
}
extension String {
  @available(*, unavailable, renamed: "String.withUTF8")
  @inlinable internal func _withUTF8<R>(_ body: (Swift.UnsafeBufferPointer<Swift.UInt8>) throws -> R) rethrows -> R {
    var copy = self
    return try copy.withUTF8(body)
  }
}
extension Substring {
  @available(*, unavailable, renamed: "Substring.withUTF8")
  @inlinable internal func _withUTF8<R>(_ body: (Swift.UnsafeBufferPointer<Swift.UInt8>) throws -> R) rethrows -> R {
    var copy = self
    return try copy.withUTF8(body)
  }
}
@usableFromInline
internal func _branchHint(_ actual: Swift.Bool, expected: Swift.Bool) -> Swift.Bool
extension String {
  @usableFromInline
  internal func _nativeCopyUTF16CodeUnits(into buffer: Swift.UnsafeMutableBufferPointer<Swift.UInt16>, range: Swift.Range<Swift.String.Index>)
}
extension String.UTF16View {
  @inlinable @inline(__always) internal var _shortHeuristic: Swift.Int {
    get { return 32 }
  }
}
@inlinable public func withExtendedLifetime<T, Result>(_ x: T, _ body: () throws -> Result) rethrows -> Result {
  defer { _fixLifetime(x) }
  return try body()
}
@inlinable public func withExtendedLifetime<T, Result>(_ x: T, _ body: (T) throws -> Result) rethrows -> Result {
  defer { _fixLifetime(x) }
  return try body(x)
}
@_transparent public func _fixLifetime<T>(_ x: T) {
  Builtin.fixLifetime(x)
}
@inlinable public func withUnsafeMutablePointer<T, Result>(to value: inout T, _ body: (Swift.UnsafeMutablePointer<T>) throws -> Result) rethrows -> Result {
  return try body(UnsafeMutablePointer<T>(Builtin.addressof(&value)))
}
@inlinable public func withUnsafePointer<T, Result>(to value: T, _ body: (Swift.UnsafePointer<T>) throws -> Result) rethrows -> Result {
  return try body(UnsafePointer<T>(Builtin.addressOfBorrow(value)))
}
@inlinable public func withUnsafePointer<T, Result>(to value: inout T, _ body: (Swift.UnsafePointer<T>) throws -> Result) rethrows -> Result {
  return try body(UnsafePointer<T>(Builtin.addressof(&value)))
}
extension String {
  @inlinable public func withCString<Result>(_ body: (Swift.UnsafePointer<Swift.Int8>) throws -> Result) rethrows -> Result {
    return try _guts.withCString(body)
  }
}
@usableFromInline
internal typealias _HeapObject = SwiftShims.HeapObject
@usableFromInline
@_silgen_name("swift_bufferAllocate")
internal func _swift_bufferAllocate(bufferType type: Swift.AnyClass, size: Swift.Int, alignmentMask: Swift.Int) -> Swift.AnyObject
@_fixed_layout open class ManagedBuffer<Header, Element> {
  final public var header: Header
  @usableFromInline
  internal init(_doNotCallMe: ())
  @objc deinit
}
extension ManagedBuffer {
  @inlinable final public class func create(minimumCapacity: Swift.Int, makingHeaderWith factory: (Swift.ManagedBuffer<Header, Element>) throws -> Header) rethrows -> Swift.ManagedBuffer<Header, Element> {

    let p = Builtin.allocWithTailElems_1(
         self,
         minimumCapacity._builtinWordValue, Element.self)

    let initHeaderVal = try factory(p)
    p.headerAddress.initialize(to: initHeaderVal)
    // The _fixLifetime is not really needed, because p is used afterwards.
    // But let's be conservative and fix the lifetime after we use the
    // headerAddress.
    _fixLifetime(p)
    return p
  }
  @available(OpenBSD, unavailable, message: "malloc_size is unavailable.")
  @inlinable final public var capacity: Swift.Int {
    get {
    let storageAddr = UnsafeMutableRawPointer(Builtin.bridgeToRawPointer(self))
    let endAddr = storageAddr + _swift_stdlib_malloc_size(storageAddr)
    let realCapacity = endAddr.assumingMemoryBound(to: Element.self) -
      firstElementAddress
    return realCapacity
  }
  }
  @inlinable final internal var firstElementAddress: Swift.UnsafeMutablePointer<Element> {
    get {
    return UnsafeMutablePointer(
      Builtin.projectTailElems(self, Element.self))
  }
  }
  @inlinable final internal var headerAddress: Swift.UnsafeMutablePointer<Header> {
    get {
    return UnsafeMutablePointer<Header>(Builtin.addressof(&header))
  }
  }
  @inlinable final public func withUnsafeMutablePointerToHeader<R>(_ body: (Swift.UnsafeMutablePointer<Header>) throws -> R) rethrows -> R {
    return try withUnsafeMutablePointers { (v, _) in return try body(v) }
  }
  @inlinable final public func withUnsafeMutablePointerToElements<R>(_ body: (Swift.UnsafeMutablePointer<Element>) throws -> R) rethrows -> R {
    return try withUnsafeMutablePointers { return try body($1) }
  }
  @inlinable final public func withUnsafeMutablePointers<R>(_ body: (Swift.UnsafeMutablePointer<Header>, Swift.UnsafeMutablePointer<Element>) throws -> R) rethrows -> R {
    defer { _fixLifetime(self) }
    return try body(headerAddress, firstElementAddress)
  }
}
@frozen public struct ManagedBufferPointer<Header, Element> {
  @usableFromInline
  internal var _nativeBuffer: Builtin.NativeObject
  @available(OpenBSD, unavailable, message: "malloc_size is unavailable.")
  @inlinable public init(bufferClass: Swift.AnyClass, minimumCapacity: Swift.Int, makingHeaderWith factory: (Swift.AnyObject, (Swift.AnyObject) -> Swift.Int) throws -> Header) rethrows {
    self = ManagedBufferPointer(
      bufferClass: bufferClass, minimumCapacity: minimumCapacity)

    // initialize the header field
    try withUnsafeMutablePointerToHeader {
      $0.initialize(to: 
        try factory(
          self.buffer,
          {
            ManagedBufferPointer(unsafeBufferObject: $0).capacity
          }))
    }
    // FIXME: workaround for <rdar://problem/18619176>.  If we don't
    // access header somewhere, its addressor gets linked away
    _ = header
  }
  @inlinable public init(unsafeBufferObject buffer: Swift.AnyObject) {
    ManagedBufferPointer._checkValidBufferClass(type(of: buffer))

    self._nativeBuffer = Builtin.unsafeCastToNativeObject(buffer)
  }
  @inlinable internal init(_uncheckedUnsafeBufferObject buffer: Swift.AnyObject) {
    ManagedBufferPointer._internalInvariantValidBufferClass(type(of: buffer))
    self._nativeBuffer = Builtin.unsafeCastToNativeObject(buffer)
  }
  @inlinable internal init(bufferClass: Swift.AnyClass, minimumCapacity: Swift.Int) {
    ManagedBufferPointer._checkValidBufferClass(bufferClass, creating: true)
    _precondition(
      minimumCapacity >= 0,
      "ManagedBufferPointer must have non-negative capacity")

    self.init(
      _uncheckedBufferClass: bufferClass, minimumCapacity: minimumCapacity)
  }
  @inlinable internal init(_uncheckedBufferClass: Swift.AnyClass, minimumCapacity: Swift.Int) {
    ManagedBufferPointer._internalInvariantValidBufferClass(_uncheckedBufferClass, creating: true)
    _internalInvariant(
      minimumCapacity >= 0,
      "ManagedBufferPointer must have non-negative capacity")

    let totalSize = ManagedBufferPointer._elementOffset
      +  minimumCapacity * MemoryLayout<Element>.stride

    let newBuffer: AnyObject = _swift_bufferAllocate(
      bufferType: _uncheckedBufferClass,
      size: totalSize,
      alignmentMask: ManagedBufferPointer._alignmentMask)

    self._nativeBuffer = Builtin.unsafeCastToNativeObject(newBuffer)
  }
  @inlinable internal init(_ buffer: Swift.ManagedBuffer<Header, Element>) {
    _nativeBuffer = Builtin.unsafeCastToNativeObject(buffer)
  }
}
extension ManagedBufferPointer {
  @inlinable public var header: Header {
    _read {
      yield _headerPointer.pointee
    }
    _modify {
      yield &_headerPointer.pointee
    }
  }
  @inlinable public var buffer: Swift.AnyObject {
    get {
    return Builtin.castFromNativeObject(_nativeBuffer)
  }
  }
  @available(OpenBSD, unavailable, message: "malloc_size is unavailable.")
  @inlinable public var capacity: Swift.Int {
    get {
    return (
      _capacityInBytes &- ManagedBufferPointer._elementOffset
    ) / MemoryLayout<Element>.stride
  }
  }
  @inlinable public func withUnsafeMutablePointerToHeader<R>(_ body: (Swift.UnsafeMutablePointer<Header>) throws -> R) rethrows -> R {
    return try withUnsafeMutablePointers { (v, _) in return try body(v) }
  }
  @inlinable public func withUnsafeMutablePointerToElements<R>(_ body: (Swift.UnsafeMutablePointer<Element>) throws -> R) rethrows -> R {
    return try withUnsafeMutablePointers { return try body($1) }
  }
  @inlinable public func withUnsafeMutablePointers<R>(_ body: (Swift.UnsafeMutablePointer<Header>, Swift.UnsafeMutablePointer<Element>) throws -> R) rethrows -> R {
    defer { _fixLifetime(_nativeBuffer) }
    return try body(_headerPointer, _elementPointer)
  }
  @inlinable public mutating func isUniqueReference() -> Swift.Bool {
    return _isUnique(&_nativeBuffer)
  }
}
extension ManagedBufferPointer {
  @inlinable internal static func _checkValidBufferClass(_ bufferClass: Swift.AnyClass, creating: Swift.Bool = false) {
    _debugPrecondition(
      _class_getInstancePositiveExtentSize(bufferClass) == MemoryLayout<_HeapObject>.size
      || (
        (!creating || bufferClass is ManagedBuffer<Header, Element>.Type)
        && _class_getInstancePositiveExtentSize(bufferClass)
          == _headerOffset + MemoryLayout<Header>.size),
      "ManagedBufferPointer buffer class has illegal stored properties"
    )
    _debugPrecondition(
      _usesNativeSwiftReferenceCounting(bufferClass),
      "ManagedBufferPointer buffer class must be non-@objc"
    )
  }
  @inlinable internal static func _internalInvariantValidBufferClass(_ bufferClass: Swift.AnyClass, creating: Swift.Bool = false) {
    _internalInvariant(
      _class_getInstancePositiveExtentSize(bufferClass) == MemoryLayout<_HeapObject>.size
      || (
        (!creating || bufferClass is ManagedBuffer<Header, Element>.Type)
        && _class_getInstancePositiveExtentSize(bufferClass)
          == _headerOffset + MemoryLayout<Header>.size),
      "ManagedBufferPointer buffer class has illegal stored properties"
    )
    _internalInvariant(
      _usesNativeSwiftReferenceCounting(bufferClass),
      "ManagedBufferPointer buffer class must be non-@objc"
    )
  }
}
extension ManagedBufferPointer {
  @inlinable internal static var _alignmentMask: Swift.Int {
    get {
    return max(
      MemoryLayout<_HeapObject>.alignment,
      max(MemoryLayout<Header>.alignment, MemoryLayout<Element>.alignment)) &- 1
  }
  }
  @available(OpenBSD, unavailable, message: "malloc_size is unavailable.")
  @inlinable internal var _capacityInBytes: Swift.Int {
    get {
    return _swift_stdlib_malloc_size(_address)
  }
  }
  @inlinable internal var _address: Swift.UnsafeMutableRawPointer {
    get {
    return UnsafeMutableRawPointer(Builtin.bridgeToRawPointer(_nativeBuffer))
  }
  }
  @inlinable internal static var _headerOffset: Swift.Int {
    get {
    _onFastPath()
    return _roundUp(
      MemoryLayout<_HeapObject>.size,
      toAlignment: MemoryLayout<Header>.alignment)
  }
  }
  @inlinable internal var _headerPointer: Swift.UnsafeMutablePointer<Header> {
    get {
    _onFastPath()
    return (_address + ManagedBufferPointer._headerOffset).assumingMemoryBound(
      to: Header.self)
  }
  }
  @inlinable internal var _elementPointer: Swift.UnsafeMutablePointer<Element> {
    get {
    _onFastPath()
    return (_address + ManagedBufferPointer._elementOffset).assumingMemoryBound(
      to: Element.self)
  }
  }
  @inlinable internal static var _elementOffset: Swift.Int {
    get {
    _onFastPath()
    return _roundUp(
      _headerOffset + MemoryLayout<Header>.size,
      toAlignment: MemoryLayout<Element>.alignment)
  }
  }
}
extension ManagedBufferPointer : Swift.Equatable {
  @inlinable public static func == (lhs: Swift.ManagedBufferPointer<Header, Element>, rhs: Swift.ManagedBufferPointer<Header, Element>) -> Swift.Bool {
    return lhs._address == rhs._address
  }
}
@inlinable public func isKnownUniquelyReferenced<T>(_ object: inout T) -> Swift.Bool where T : AnyObject {
  return _isUnique(&object)
}
@inlinable public func isKnownUniquelyReferenced<T>(_ object: inout T?) -> Swift.Bool where T : AnyObject {
  return _isUnique(&object)
}
@frozen public struct LazyMapSequence<Base, Element> where Base : Swift.Sequence {
  public typealias Elements = Swift.LazyMapSequence<Base, Element>
  @usableFromInline
  internal var _base: Base
  @usableFromInline
  internal let _transform: (Base.Element) -> Element
  @inlinable internal init(_base: Base, transform: @escaping (Base.Element) -> Element) {
    self._base = _base
    self._transform = transform
  }
}
extension LazyMapSequence {
  @frozen public struct Iterator {
    @usableFromInline
    internal var _base: Base.Iterator
    @usableFromInline
    internal let _transform: (Base.Element) -> Swift.LazyMapSequence<Base, Element>.Iterator.Element
    @inlinable public var base: Base.Iterator {
      get { return _base }
    }
    @inlinable internal init(_base: Base.Iterator, _transform: @escaping (Base.Element) -> Swift.LazyMapSequence<Base, Element>.Iterator.Element) {
      self._base = _base
      self._transform = _transform
    }
  }
}
extension LazyMapSequence.Iterator : Swift.IteratorProtocol, Swift.Sequence {
  @inlinable public mutating func next() -> Element? {
    return _base.next().map(_transform)
  }
  public typealias Iterator = Swift.LazyMapSequence<Base, Element>.Iterator
}
extension LazyMapSequence : Swift.LazySequenceProtocol {
  @inlinable __consuming public func makeIterator() -> Swift.LazyMapSequence<Base, Element>.Iterator {
    return Iterator(_base: _base.makeIterator(), _transform: _transform)
  }
  @inlinable public var underestimatedCount: Swift.Int {
    get {
    return _base.underestimatedCount
  }
  }
}
public typealias LazyMapCollection<T, U> = Swift.LazyMapSequence<T, U> where T : Swift.Collection
extension Swift.LazyMapCollection : Swift.Collection where Base : Swift.Collection {
  public typealias Index = Base.Index
  public typealias Indices = Base.Indices
  public typealias SubSequence = Swift.LazyMapCollection<Base.SubSequence, Element>
  @inlinable public var startIndex: Base.Index {
    get { return _base.startIndex }
  }
  @inlinable public var endIndex: Base.Index {
    get { return _base.endIndex }
  }
  @inlinable public func index(after i: Swift.LazyMapSequence<Base, Element>.Index) -> Swift.LazyMapSequence<Base, Element>.Index { return _base.index(after: i) }
  @inlinable public func formIndex(after i: inout Swift.LazyMapSequence<Base, Element>.Index) { _base.formIndex(after: &i) }
  @inlinable public subscript(position: Base.Index) -> Element {
    get {
    return _transform(_base[position])
  }
  }
  @inlinable public subscript(bounds: Swift.Range<Base.Index>) -> Swift.LazyMapSequence<Base, Element>.SubSequence {
    get {
    return SubSequence(_base: _base[bounds], transform: _transform)
  }
  }
  @inlinable public var indices: Swift.LazyMapSequence<Base, Element>.Indices {
    get {
    return _base.indices
  }
  }
  @inlinable public var isEmpty: Swift.Bool {
    get { return _base.isEmpty }
  }
  @inlinable public var count: Swift.Int {
    get {
    return _base.count
  }
  }
  @inlinable public func index(_ i: Swift.LazyMapSequence<Base, Element>.Index, offsetBy n: Swift.Int) -> Swift.LazyMapSequence<Base, Element>.Index {
    return _base.index(i, offsetBy: n)
  }
  @inlinable public func index(_ i: Swift.LazyMapSequence<Base, Element>.Index, offsetBy n: Swift.Int, limitedBy limit: Swift.LazyMapSequence<Base, Element>.Index) -> Swift.LazyMapSequence<Base, Element>.Index? {
    return _base.index(i, offsetBy: n, limitedBy: limit)
  }
  @inlinable public func distance(from start: Swift.LazyMapSequence<Base, Element>.Index, to end: Swift.LazyMapSequence<Base, Element>.Index) -> Swift.Int {
    return _base.distance(from: start, to: end)
  }
}
extension Swift.LazyMapCollection : Swift.BidirectionalCollection where Base : Swift.BidirectionalCollection {
  @inlinable public func index(before i: Swift.LazyMapSequence<Base, Element>.Index) -> Swift.LazyMapSequence<Base, Element>.Index { return _base.index(before: i) }
  @inlinable public func formIndex(before i: inout Swift.LazyMapSequence<Base, Element>.Index) {
    _base.formIndex(before: &i)
  }
}
extension Swift.LazyMapCollection : Swift.LazyCollectionProtocol where Base : Swift.Collection {
}
extension Swift.LazyMapCollection : Swift.RandomAccessCollection where Base : Swift.RandomAccessCollection {
}
extension LazySequenceProtocol {
  @inlinable public func map<U>(_ transform: @escaping (Self.Element) -> U) -> Swift.LazyMapSequence<Self.Elements, U> {
    return LazyMapSequence(_base: elements, transform: transform)
  }
}
extension LazyMapSequence {
  @available(swift 5)
  @inlinable public func map<ElementOfResult>(_ transform: @escaping (Element) -> ElementOfResult) -> Swift.LazyMapSequence<Base, ElementOfResult> {
    return LazyMapSequence<Base, ElementOfResult>(
      _base: _base,
      transform: { transform(self._transform($0)) })
  }
}
extension Swift.LazyMapCollection where Base : Swift.Collection {
  @available(swift 5)
  @inlinable public func map<ElementOfResult>(_ transform: @escaping (Element) -> ElementOfResult) -> Swift.LazyMapCollection<Base, ElementOfResult> {
    return LazyMapCollection<Base, ElementOfResult>(
      _base: _base,
      transform: {transform(self._transform($0))})
  }
}
@frozen public enum MemoryLayout<T> {
  @_transparent public static var size: Swift.Int {
    @_transparent get {
    return Int(Builtin.sizeof(T.self))
  }
  }
  @_transparent public static var stride: Swift.Int {
    @_transparent get {
    return Int(Builtin.strideof(T.self))
  }
  }
  @_transparent public static var alignment: Swift.Int {
    @_transparent get {
    return Int(Builtin.alignof(T.self))
  }
  }
}
extension MemoryLayout {
  @_transparent public static func size(ofValue value: T) -> Swift.Int {
    return MemoryLayout.size
  }
  @_transparent public static func stride(ofValue value: T) -> Swift.Int {
    return MemoryLayout.stride
  }
  @_transparent public static func alignment(ofValue value: T) -> Swift.Int {
    return MemoryLayout.alignment
  }
  @_transparent public static func offset(of key: Swift.PartialKeyPath<T>) -> Swift.Int? {
    return key._storedInlineOffset
  }
}
extension Unicode {
  @frozen public struct Scalar {
    @inlinable internal init(_value: Swift.UInt32) {
      self._value = _value
    }
    @usableFromInline
    internal var _value: Swift.UInt32
  }
}
extension Unicode.Scalar : Swift._ExpressibleByBuiltinUnicodeScalarLiteral, Swift.ExpressibleByUnicodeScalarLiteral {
  @inlinable public var value: Swift.UInt32 {
    get { return _value }
  }
  @_transparent public init(_builtinUnicodeScalarLiteral value: Builtin.Int32) {
    self._value = UInt32(value)
  }
  @_transparent public init(unicodeScalarLiteral value: Swift.Unicode.Scalar) {
    self = value
  }
  @inlinable public init?(_ v: Swift.UInt32) {
    // Unicode 6.3.0:
    //
    //     D9.  Unicode codespace: A range of integers from 0 to 10FFFF.
    //
    //     D76. Unicode scalar value: Any Unicode code point except
    //     high-surrogate and low-surrogate code points.
    //
    //     * As a result of this definition, the set of Unicode scalar values
    //     consists of the ranges 0 to D7FF and E000 to 10FFFF, inclusive.
    if (v < 0xD800 || v > 0xDFFF) && v <= 0x10FFFF {
      self._value = v
      return
    }
    // Return nil in case of an invalid unicode scalar value.
    return nil
  }
  @inlinable public init?(_ v: Swift.UInt16) {
    self.init(UInt32(v))
  }
  @inlinable public init(_ v: Swift.UInt8) {
    self._value = UInt32(v)
  }
  @inlinable public init(_ v: Swift.Unicode.Scalar) {
    // This constructor allows one to provide necessary type context to
    // disambiguate between function overloads on 'String' and 'Unicode.Scalar'.
    self = v
  }
  public func escaped(asASCII forceASCII: Swift.Bool) -> Swift.String
  @inlinable public var isASCII: Swift.Bool {
    get {
    return value <= 127
  }
  }
  public typealias UnicodeScalarLiteralType = Swift.Unicode.Scalar
}
extension Unicode.Scalar : Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible {
  @inlinable public var description: Swift.String {
    get {
    return String(self)
  }
  }
  public var debugDescription: Swift.String {
    get
  }
}
extension Unicode.Scalar : Swift.LosslessStringConvertible {
  @inlinable public init?(_ description: Swift.String) {
    let scalars = description.unicodeScalars
    guard let v = scalars.first, scalars.count == 1 else {
      return nil
    }
    self = v
  }
}
extension Unicode.Scalar : Swift.Hashable {
  @inlinable public func hash(into hasher: inout Swift.Hasher) {
    hasher.combine(self.value)
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension Unicode.Scalar {
  @inlinable public init?(_ v: Swift.Int) {
    if let us = Unicode.Scalar(UInt32(v)) {
      self = us
    } else {
      return nil
    }
  }
}
extension UInt8 {
  @inlinable public init(ascii v: Swift.Unicode.Scalar) {
    _precondition(v.value < 128,
        "Code point value does not fit into ASCII")
    self = UInt8(v.value)
  }
}
extension UInt32 {
  @inlinable public init(_ v: Swift.Unicode.Scalar) {
    self = v.value
  }
}
extension UInt64 {
  @inlinable public init(_ v: Swift.Unicode.Scalar) {
    self = UInt64(v.value)
  }
}
extension Unicode.Scalar : Swift.Equatable {
  @inlinable public static func == (lhs: Swift.Unicode.Scalar, rhs: Swift.Unicode.Scalar) -> Swift.Bool {
    return lhs.value == rhs.value
  }
}
extension Unicode.Scalar : Swift.Comparable {
  @inlinable public static func < (lhs: Swift.Unicode.Scalar, rhs: Swift.Unicode.Scalar) -> Swift.Bool {
    return lhs.value < rhs.value
  }
}
extension Unicode.Scalar {
  @frozen public struct UTF16View {
    @inlinable internal init(value: Swift.Unicode.Scalar) {
      self.value = value
    }
    @usableFromInline
    internal var value: Swift.Unicode.Scalar
  }
  @inlinable public var utf16: Swift.Unicode.Scalar.UTF16View {
    get {
    return UTF16View(value: self)
  }
  }
}
extension Unicode.Scalar.UTF16View : Swift.RandomAccessCollection {
  public typealias Indices = Swift.Range<Swift.Int>
  @inlinable public var startIndex: Swift.Int {
    get {
    return 0
  }
  }
  @inlinable public var endIndex: Swift.Int {
    get {
    return 0 + UTF16.width(value)
  }
  }
  @inlinable public subscript(position: Swift.Int) -> Swift.UTF16.CodeUnit {
    get {
    if position == 1 { return UTF16.trailSurrogate(value) }
    if endIndex == 1 { return UTF16.CodeUnit(value.value) }
    return UTF16.leadSurrogate(value)
  }
  }
  public typealias Element = Swift.UTF16.CodeUnit
  public typealias Index = Swift.Int
  public typealias Iterator = Swift.IndexingIterator<Swift.Unicode.Scalar.UTF16View>
  public typealias SubSequence = Swift.Slice<Swift.Unicode.Scalar.UTF16View>
}
extension Unicode.Scalar {
  @available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
  @frozen public struct UTF8View {
    @inlinable internal init(value: Swift.Unicode.Scalar) {
      self.value = value
    }
    @usableFromInline
    internal var value: Swift.Unicode.Scalar
  }
  @available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
  @inlinable public var utf8: Swift.Unicode.Scalar.UTF8View {
    get { return UTF8View(value: self) }
  }
}
@available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
extension Unicode.Scalar.UTF8View : Swift.RandomAccessCollection {
  public typealias Indices = Swift.Range<Swift.Int>
  @inlinable public var startIndex: Swift.Int {
    get { return 0 }
  }
  @inlinable public var endIndex: Swift.Int {
    get { return 0 + UTF8.width(value) }
  }
  @inlinable public subscript(position: Swift.Int) -> Swift.UTF8.CodeUnit {
    get {
    _precondition(position >= startIndex && position < endIndex,
      "Unicode.Scalar.UTF8View index is out of bounds")
    return value.withUTF8CodeUnits { $0[position] }
  }
  }
  public typealias Element = Swift.UTF8.CodeUnit
  public typealias Index = Swift.Int
  public typealias Iterator = Swift.IndexingIterator<Swift.Unicode.Scalar.UTF8View>
  public typealias SubSequence = Swift.Slice<Swift.Unicode.Scalar.UTF8View>
}
extension Unicode.Scalar {
  @available(*, unavailable, message: "use 'Unicode.Scalar(0)'")
  public init()
}
extension Unicode.Scalar {
  @inlinable internal func withUTF8CodeUnits<Result>(_ body: (Swift.UnsafeBufferPointer<Swift.UInt8>) throws -> Result) rethrows -> Result {
    let encodedScalar = UTF8.encode(self)!
    var (codeUnits, utf8Count) = encodedScalar._bytes

    // The first code unit is in the least significant byte of codeUnits.
    codeUnits = codeUnits.littleEndian
    return try Swift.withUnsafePointer(to: &codeUnits) {
      return try $0.withMemoryRebound(to: UInt8.self, capacity: 4) {
        return try body(UnsafeBufferPointer(start: $0, count: utf8Count))
      }
    }
  }
}
extension Float : Swift.CustomReflectable {
  public var customMirror: Swift.Mirror {
    get
  }
}
extension Float : Swift._CustomPlaygroundQuickLookable {
  @available(*, deprecated, message: "Float.customPlaygroundQuickLook will be removed in a future Swift version")
  public var customPlaygroundQuickLook: Swift._PlaygroundQuickLook {
    get
  }
}
extension Double : Swift.CustomReflectable {
  public var customMirror: Swift.Mirror {
    get
  }
}
extension Double : Swift._CustomPlaygroundQuickLookable {
  @available(*, deprecated, message: "Double.customPlaygroundQuickLook will be removed in a future Swift version")
  public var customPlaygroundQuickLook: Swift._PlaygroundQuickLook {
    get
  }
}
extension Bool : Swift.CustomReflectable {
  public var customMirror: Swift.Mirror {
    get
  }
}
extension Bool : Swift._CustomPlaygroundQuickLookable {
  @available(*, deprecated, message: "Bool.customPlaygroundQuickLook will be removed in a future Swift version")
  public var customPlaygroundQuickLook: Swift._PlaygroundQuickLook {
    get
  }
}
extension String : Swift.CustomReflectable {
  public var customMirror: Swift.Mirror {
    get
  }
}
extension String : Swift._CustomPlaygroundQuickLookable {
  @available(*, deprecated, message: "String.customPlaygroundQuickLook will be removed in a future Swift version")
  public var customPlaygroundQuickLook: Swift._PlaygroundQuickLook {
    get
  }
}
extension Character : Swift.CustomReflectable {
  public var customMirror: Swift.Mirror {
    get
  }
}
extension Character : Swift._CustomPlaygroundQuickLookable {
  @available(*, deprecated, message: "Character.customPlaygroundQuickLook will be removed in a future Swift version")
  public var customPlaygroundQuickLook: Swift._PlaygroundQuickLook {
    get
  }
}
extension Unicode.Scalar : Swift.CustomReflectable {
  public var customMirror: Swift.Mirror {
    get
  }
}
extension Unicode.Scalar : Swift._CustomPlaygroundQuickLookable {
  @available(*, deprecated, message: "Unicode.Scalar.customPlaygroundQuickLook will be removed in a future Swift version")
  public var customPlaygroundQuickLook: Swift._PlaygroundQuickLook {
    get
  }
}
extension UInt8 : Swift.CustomReflectable {
  public var customMirror: Swift.Mirror {
    get
  }
}
extension UInt8 : Swift._CustomPlaygroundQuickLookable {
  @available(*, deprecated, message: "UInt8.customPlaygroundQuickLook will be removed in a future Swift version")
  public var customPlaygroundQuickLook: Swift._PlaygroundQuickLook {
    get
  }
}
extension Int8 : Swift.CustomReflectable {
  public var customMirror: Swift.Mirror {
    get
  }
}
extension Int8 : Swift._CustomPlaygroundQuickLookable {
  @available(*, deprecated, message: "Int8.customPlaygroundQuickLook will be removed in a future Swift version")
  public var customPlaygroundQuickLook: Swift._PlaygroundQuickLook {
    get
  }
}
extension UInt16 : Swift.CustomReflectable {
  public var customMirror: Swift.Mirror {
    get
  }
}
extension UInt16 : Swift._CustomPlaygroundQuickLookable {
  @available(*, deprecated, message: "UInt16.customPlaygroundQuickLook will be removed in a future Swift version")
  public var customPlaygroundQuickLook: Swift._PlaygroundQuickLook {
    get
  }
}
extension Int16 : Swift.CustomReflectable {
  public var customMirror: Swift.Mirror {
    get
  }
}
extension Int16 : Swift._CustomPlaygroundQuickLookable {
  @available(*, deprecated, message: "Int16.customPlaygroundQuickLook will be removed in a future Swift version")
  public var customPlaygroundQuickLook: Swift._PlaygroundQuickLook {
    get
  }
}
extension UInt32 : Swift.CustomReflectable {
  public var customMirror: Swift.Mirror {
    get
  }
}
extension UInt32 : Swift._CustomPlaygroundQuickLookable {
  @available(*, deprecated, message: "UInt32.customPlaygroundQuickLook will be removed in a future Swift version")
  public var customPlaygroundQuickLook: Swift._PlaygroundQuickLook {
    get
  }
}
extension Int32 : Swift.CustomReflectable {
  public var customMirror: Swift.Mirror {
    get
  }
}
extension Int32 : Swift._CustomPlaygroundQuickLookable {
  @available(*, deprecated, message: "Int32.customPlaygroundQuickLook will be removed in a future Swift version")
  public var customPlaygroundQuickLook: Swift._PlaygroundQuickLook {
    get
  }
}
extension UInt64 : Swift.CustomReflectable {
  public var customMirror: Swift.Mirror {
    get
  }
}
extension UInt64 : Swift._CustomPlaygroundQuickLookable {
  @available(*, deprecated, message: "UInt64.customPlaygroundQuickLook will be removed in a future Swift version")
  public var customPlaygroundQuickLook: Swift._PlaygroundQuickLook {
    get
  }
}
extension Int64 : Swift.CustomReflectable {
  public var customMirror: Swift.Mirror {
    get
  }
}
extension Int64 : Swift._CustomPlaygroundQuickLookable {
  @available(*, deprecated, message: "Int64.customPlaygroundQuickLook will be removed in a future Swift version")
  public var customPlaygroundQuickLook: Swift._PlaygroundQuickLook {
    get
  }
}
extension UInt : Swift.CustomReflectable {
  public var customMirror: Swift.Mirror {
    get
  }
}
extension UInt : Swift._CustomPlaygroundQuickLookable {
  @available(*, deprecated, message: "UInt.customPlaygroundQuickLook will be removed in a future Swift version")
  public var customPlaygroundQuickLook: Swift._PlaygroundQuickLook {
    get
  }
}
extension Int : Swift.CustomReflectable {
  public var customMirror: Swift.Mirror {
    get
  }
}
extension Int : Swift._CustomPlaygroundQuickLookable {
  @available(*, deprecated, message: "Int.customPlaygroundQuickLook will be removed in a future Swift version")
  public var customPlaygroundQuickLook: Swift._PlaygroundQuickLook {
    get
  }
}
extension Float80 : Swift.CustomReflectable {
  public var customMirror: Swift.Mirror {
    get
  }
}
@_transparent public func _isPowerOf2(_ x: Swift.UInt) -> Swift.Bool {
  if x == 0 {
    return false
  }
  // Note: use unchecked subtraction because we have checked that `x` is not
  // zero.
  return x & (x &- 1) == 0
}
@_transparent public func _isPowerOf2(_ x: Swift.Int) -> Swift.Bool {
  if x <= 0 {
    return false
  }
  // Note: use unchecked subtraction because we have checked that `x` is not
  // `Int.min`.
  return x & (x &- 1) == 0
}
@_transparent public func _autorelease(_ x: Swift.AnyObject) {
  Builtin.retain(x)
  Builtin.autorelease(x)
}
@_silgen_name("swift_getTypeName")
public func _getTypeName(_ type: Any.Type, qualified: Swift.Bool) -> (Swift.UnsafePointer<Swift.UInt8>, Swift.Int)
@_semantics("typeName") public func _typeName(_ type: Any.Type, qualified: Swift.Bool = true) -> Swift.String
@available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
@_silgen_name("swift_getMangledTypeName")
public func _getMangledTypeName(_ type: Any.Type) -> (Swift.UnsafePointer<Swift.UInt8>, Swift.Int)
@available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
public func _mangledTypeName(_ type: Any.Type) -> Swift.String?
public func _typeByName(_ name: Swift.String) -> Any.Type?
@_silgen_name("swift_getTypeByMangledNameInEnvironment")
public func _getTypeByMangledNameInEnvironment(_ name: Swift.UnsafePointer<Swift.UInt8>, _ nameLength: Swift.UInt, genericEnvironment: Swift.UnsafeRawPointer?, genericArguments: Swift.UnsafeRawPointer?) -> Any.Type?
@_silgen_name("swift_getTypeByMangledNameInContext")
public func _getTypeByMangledNameInContext(_ name: Swift.UnsafePointer<Swift.UInt8>, _ nameLength: Swift.UInt, genericContext: Swift.UnsafeRawPointer?, genericArguments: Swift.UnsafeRawPointer?) -> Any.Type?
@_silgen_name("swift_getMetadataSection")
public func _getMetadataSection(_ index: Swift.UInt) -> Swift.UnsafeRawPointer?
@_silgen_name("swift_getMetadataSectionCount")
public func _getMetadataSectionCount() -> Swift.UInt
@_silgen_name("swift_getMetadataSectionName")
public func _getMetadataSectionName(_ metadata_section: Swift.UnsafeRawPointer) -> Swift.UnsafePointer<Swift.CChar>
public protocol MutableCollection : Swift.Collection where Self.SubSequence : Swift.MutableCollection {
  override associatedtype Element
  override associatedtype Index
  override associatedtype SubSequence
  @_borrowed override subscript(position: Self.Index) -> Self.Element { get set }
  override subscript(bounds: Swift.Range<Self.Index>) -> Self.SubSequence { get set }
  mutating func partition(by belongsInSecondPartition: (Self.Element) throws -> Swift.Bool) rethrows -> Self.Index
  mutating func swapAt(_ i: Self.Index, _ j: Self.Index)
  mutating func _withUnsafeMutableBufferPointerIfSupported<R>(_ body: (inout Swift.UnsafeMutableBufferPointer<Self.Element>) throws -> R) rethrows -> R?
  mutating func withContiguousMutableStorageIfAvailable<R>(_ body: (inout Swift.UnsafeMutableBufferPointer<Self.Element>) throws -> R) rethrows -> R?
}
extension MutableCollection {
  @inlinable public mutating func _withUnsafeMutableBufferPointerIfSupported<R>(_ body: (inout Swift.UnsafeMutableBufferPointer<Self.Element>) throws -> R) rethrows -> R? {
    return nil
  }
  @inlinable public mutating func withContiguousMutableStorageIfAvailable<R>(_ body: (inout Swift.UnsafeMutableBufferPointer<Self.Element>) throws -> R) rethrows -> R? {
    return nil
  }
  @inlinable public subscript(bounds: Swift.Range<Self.Index>) -> Swift.Slice<Self> {
    get {
      _failEarlyRangeCheck(bounds, bounds: startIndex..<endIndex)
      return Slice(base: self, bounds: bounds)
    }
    set {
      _writeBackMutableSlice(&self, bounds: bounds, slice: newValue)
    }
  }
  @inlinable public mutating func swapAt(_ i: Self.Index, _ j: Self.Index) {
    guard i != j else { return }
    let tmp = self[i]
    self[i] = self[j]
    self[j] = tmp
  }
}
@inlinable public func swap<T>(_ a: inout T, _ b: inout T) {
  // Semantically equivalent to (a, b) = (b, a).
  // Microoptimized to avoid retain/release traffic.
  let p1 = Builtin.addressof(&a)
  let p2 = Builtin.addressof(&b)
  _debugPrecondition(
    p1 != p2,
    "swapping a location with itself is not supported")

  // Take from P1.
  let tmp: T = Builtin.take(p1)
  // Transfer P2 into P1.
  Builtin.initialize(Builtin.take(p2) as T, p1)
  // Initialize P2.
  Builtin.initialize(tmp, p2)
}
@usableFromInline
@frozen internal struct _NativeDictionary<Key, Value> where Key : Swift.Hashable {
  @usableFromInline
  internal typealias Element = (key: Key, value: Value)
  @usableFromInline
  internal var _storage: Swift.__RawDictionaryStorage
  @inlinable internal init() {
    self._storage = __RawDictionaryStorage.empty
  }
  @inlinable internal init(_ storage: __owned Swift.__RawDictionaryStorage) {
    self._storage = storage
  }
  @inlinable internal init(capacity: Swift.Int) {
    if capacity == 0 {
      self._storage = __RawDictionaryStorage.empty
    } else {
      self._storage = _DictionaryStorage<Key, Value>.allocate(capacity: capacity)
    }
  }
  @inlinable internal init(_ cocoa: __owned Swift.__CocoaDictionary) {
    self.init(cocoa, capacity: cocoa.count)
  }
  @inlinable internal init(_ cocoa: __owned Swift.__CocoaDictionary, capacity: Swift.Int) {
    if capacity == 0 {
      self._storage = __RawDictionaryStorage.empty
    } else {
      _internalInvariant(cocoa.count <= capacity)
      self._storage =
        _DictionaryStorage<Key, Value>.convert(cocoa, capacity: capacity)
      for (key, value) in cocoa {
        insertNew(
          key: _forceBridgeFromObjectiveC(key, Key.self),
          value: _forceBridgeFromObjectiveC(value, Value.self))
      }
    }
  }
}
extension _NativeDictionary {
  @usableFromInline
  internal typealias Bucket = Swift._HashTable.Bucket
  @inlinable internal var capacity: Swift.Int {
    @inline(__always) get {
      return _assumeNonNegative(_storage._capacity)
    }
  }
  @inlinable internal var hashTable: Swift._HashTable {
    @inline(__always) get {
      return _storage._hashTable
    }
  }
  @inlinable internal var age: Swift.Int32 {
    @inline(__always) get {
      return _storage._age
    }
  }
  @inlinable internal var _keys: Swift.UnsafeMutablePointer<Key> {
    get {
    return _storage._rawKeys.assumingMemoryBound(to: Key.self)
  }
  }
  @inlinable internal var _values: Swift.UnsafeMutablePointer<Value> {
    get {
    return _storage._rawValues.assumingMemoryBound(to: Value.self)
  }
  }
  @inlinable @inline(__always) internal func invalidateIndices() {
    _storage._age &+= 1
  }
}
extension _NativeDictionary {
  @inlinable @inline(__always) internal func uncheckedKey(at bucket: Swift._NativeDictionary<Key, Value>.Bucket) -> Key {
    defer { _fixLifetime(self) }
    _internalInvariant(hashTable.isOccupied(bucket))
    return _keys[bucket.offset]
  }
  @inlinable @inline(__always) internal func uncheckedValue(at bucket: Swift._NativeDictionary<Key, Value>.Bucket) -> Value {
    defer { _fixLifetime(self) }
    _internalInvariant(hashTable.isOccupied(bucket))
    return _values[bucket.offset]
  }
  @inlinable @inline(__always) internal func uncheckedInitialize(at bucket: Swift._NativeDictionary<Key, Value>.Bucket, toKey key: __owned Key, value: __owned Value) {
    defer { _fixLifetime(self) }
    _internalInvariant(hashTable.isValid(bucket))
    (_keys + bucket.offset).initialize(to: key)
    (_values + bucket.offset).initialize(to: value)
  }
  @inlinable @inline(__always) internal func uncheckedDestroy(at bucket: Swift._NativeDictionary<Key, Value>.Bucket) {
    defer { _fixLifetime(self) }
    _internalInvariant(hashTable.isValid(bucket))
    (_keys + bucket.offset).deinitialize(count: 1)
    (_values + bucket.offset).deinitialize(count: 1)
  }
}
extension _NativeDictionary {
  @inlinable @inline(__always) internal func hashValue(for key: Key) -> Swift.Int {
    return key._rawHashValue(seed: _storage._seed)
  }
  @inlinable @inline(__always) internal func find(_ key: Key) -> (bucket: Swift._NativeDictionary<Key, Value>.Bucket, found: Swift.Bool) {
    return _storage.find(key)
  }
  @inlinable @inline(__always) internal func find(_ key: Key, hashValue: Swift.Int) -> (bucket: Swift._NativeDictionary<Key, Value>.Bucket, found: Swift.Bool) {
    return _storage.find(key, hashValue: hashValue)
  }
}
extension _NativeDictionary {
  @_alwaysEmitIntoClient @inline(never) internal mutating func _copyOrMoveAndResize(capacity: Swift.Int, moveElements: Swift.Bool) {
    let capacity = Swift.max(capacity, self.capacity)
    let newStorage = _DictionaryStorage<Key, Value>.resize(
      original: _storage,
      capacity: capacity,
      move: moveElements)
    let result = _NativeDictionary(newStorage)
    if count > 0 {
      for bucket in hashTable {
        let key: Key
        let value: Value
        if moveElements {
          key = (_keys + bucket.offset).move()
          value = (_values + bucket.offset).move()
        } else {
          key = self.uncheckedKey(at: bucket)
          value = self.uncheckedValue(at: bucket)
        }
        result._unsafeInsertNew(key: key, value: value)
      }
      if moveElements {
        // Clear out old storage, ensuring that its deinit won't overrelease the
        // elements we've just moved out.
        _storage._hashTable.clear()
        _storage._count = 0
      }
    }
    _storage = result._storage
  }
  @inlinable internal mutating func resize(capacity: Swift.Int) {
    _copyOrMoveAndResize(capacity: capacity, moveElements: true)
  }
  @inlinable internal mutating func copyAndResize(capacity: Swift.Int) {
    _copyOrMoveAndResize(capacity: capacity, moveElements: false)
  }
  @inlinable @_semantics("optimize.sil.specialize.generic.size.never") internal mutating func copy() {
    let newStorage = _DictionaryStorage<Key, Value>.copy(original: _storage)
    _internalInvariant(newStorage._scale == _storage._scale)
    _internalInvariant(newStorage._age == _storage._age)
    _internalInvariant(newStorage._seed == _storage._seed)
    let result = _NativeDictionary(newStorage)
    if count > 0 {
      result.hashTable.copyContents(of: hashTable)
      result._storage._count = self.count
      for bucket in hashTable {
        let key = uncheckedKey(at: bucket)
        let value = uncheckedValue(at: bucket)
        result.uncheckedInitialize(at: bucket, toKey: key, value: value)
      }
    }
    _storage = result._storage
  }
  @inlinable @_semantics("optimize.sil.specialize.generic.size.never") internal mutating func ensureUnique(isUnique: Swift.Bool, capacity: Swift.Int) -> Swift.Bool {
    if _fastPath(capacity <= self.capacity && isUnique) {
      return false
    }
    if isUnique {
      resize(capacity: capacity)
      return true
    }
    if capacity <= self.capacity {
      copy()
      return false
    }
    copyAndResize(capacity: capacity)
    return true
  }
}
extension _NativeDictionary {
  @inlinable @inline(__always) internal func validatedBucket(for index: Swift._HashTable.Index) -> Swift._NativeDictionary<Key, Value>.Bucket {
    _precondition(hashTable.isOccupied(index.bucket) && index.age == age,
      "Attempting to access Dictionary elements using an invalid index")
    return index.bucket
  }
  @inlinable @inline(__always) internal func validatedBucket(for index: Swift.Dictionary<Key, Value>.Index) -> Swift._NativeDictionary<Key, Value>.Bucket {
    guard index._isNative else {
      index._cocoaPath()
      // Accept Cocoa indices as long as they contain a key that exists in this
      // dictionary, and the address of their Cocoa object generates the same
      // age.
      let cocoa = index._asCocoa
      if cocoa.age == self.age {
        let key = _forceBridgeFromObjectiveC(cocoa.key, Key.self)
        let (bucket, found) = find(key)
        if found {
          return bucket
        }
      }
      _preconditionFailure(
        "Attempting to access Dictionary elements using an invalid index")
    }
    return validatedBucket(for: index._asNative)
  }
}
extension _NativeDictionary {
  @usableFromInline
  internal typealias Index = Swift.Dictionary<Key, Value>.Index
  @inlinable internal var startIndex: Swift._NativeDictionary<Key, Value>.Index {
    get {
    let bucket = hashTable.startBucket
    return Index(_native: _HashTable.Index(bucket: bucket, age: age))
  }
  }
  @inlinable internal var endIndex: Swift._NativeDictionary<Key, Value>.Index {
    get {
    let bucket = hashTable.endBucket
    return Index(_native: _HashTable.Index(bucket: bucket, age: age))
  }
  }
  @inlinable internal func index(after index: Swift._NativeDictionary<Key, Value>.Index) -> Swift._NativeDictionary<Key, Value>.Index {
    guard _fastPath(index._isNative) else {
      let _ = validatedBucket(for: index)
      let i = index._asCocoa
      return Index(_cocoa: i.dictionary.index(after: i))
    }
    let bucket = validatedBucket(for: index._asNative)
    let next = hashTable.occupiedBucket(after: bucket)
    return Index(_native: _HashTable.Index(bucket: next, age: age))
  }
  @inlinable internal func index(forKey key: Key) -> Swift._NativeDictionary<Key, Value>.Index? {
    if count == 0 {
      // Fast path that avoids computing the hash of the key.
      return nil
    }
    let (bucket, found) = find(key)
    guard found else { return nil }
    return Index(_native: _HashTable.Index(bucket: bucket, age: age))
  }
  @inlinable internal var count: Swift.Int {
    @inline(__always) get {
      return _assumeNonNegative(_storage._count)
    }
  }
  @inlinable @inline(__always) internal func contains(_ key: Key) -> Swift.Bool {
    return find(key).found
  }
  @inlinable @inline(__always) internal func lookup(_ key: Key) -> Value? {
    if count == 0 {
      // Fast path that avoids computing the hash of the key.
      return nil
    }
    let (bucket, found) = self.find(key)
    guard found else { return nil }
    return self.uncheckedValue(at: bucket)
  }
  @inlinable @inline(__always) internal func lookup(_ index: Swift._NativeDictionary<Key, Value>.Index) -> (key: Key, value: Value) {
    let bucket = validatedBucket(for: index)
    let key = self.uncheckedKey(at: bucket)
    let value = self.uncheckedValue(at: bucket)
    return (key, value)
  }
  @inlinable @inline(__always) internal func key(at index: Swift._NativeDictionary<Key, Value>.Index) -> Key {
    let bucket = validatedBucket(for: index)
    return self.uncheckedKey(at: bucket)
  }
  @inlinable @inline(__always) internal func value(at index: Swift._NativeDictionary<Key, Value>.Index) -> Value {
    let bucket = validatedBucket(for: index)
    return self.uncheckedValue(at: bucket)
  }
}
extension _NativeDictionary {
  @inlinable internal subscript(key: Key, isUnique isUnique: Swift.Bool) -> Value? {
    @inline(__always) get {
      // Dummy definition; don't use.
      return lookup(key)
    }
    @inline(__always) _modify {
      let (bucket, found) = mutatingFind(key, isUnique: isUnique)
      // If found, move the old value out of storage, wrapping it into an
      // optional before yielding it.
      var value: Value? = (found ? (_values + bucket.offset).move() : nil)
      defer {
        // This is in a defer block because yield might throw, and we need to
        // preserve Dictionary invariants when that happens.
        if let value = value {
          if found {
            // **Mutation.** Initialize storage to new value.
            (_values + bucket.offset).initialize(to: value)
          } else {
            // **Insertion.** Insert the new entry at the correct place.  Note
            // that `mutatingFind` already ensured that we have enough capacity.
            _insert(at: bucket, key: key, value: value)
          }
        } else {
          if found {
            // **Removal.** We've already deinitialized the value; deinitialize
            // the key too and register the removal.
            (_keys + bucket.offset).deinitialize(count: 1)
            _delete(at: bucket)
          } else {
            // Noop
          }
        }
      }
      yield &value
    }
  }
}
@usableFromInline
@inline(never) internal func KEY_TYPE_OF_DICTIONARY_VIOLATES_HASHABLE_REQUIREMENTS(_ keyType: Any.Type) -> Swift.Never
extension _NativeDictionary {
  @inlinable internal func _unsafeInsertNew(key: __owned Key, value: __owned Value) {
    _internalInvariant(count + 1 <= capacity)
    let hashValue = self.hashValue(for: key)
    if _isDebugAssertConfiguration() {
      // In debug builds, perform a full lookup and trap if we detect duplicate
      // elements -- these imply that the Element type violates Hashable
      // requirements. This is generally more costly than a direct insertion,
      // because we'll need to compare elements in case of hash collisions.
      let (bucket, found) = find(key, hashValue: hashValue)
      guard !found else {
        KEY_TYPE_OF_DICTIONARY_VIOLATES_HASHABLE_REQUIREMENTS(Key.self)
      }
      hashTable.insert(bucket)
      uncheckedInitialize(at: bucket, toKey: key, value: value)
    } else {
      let bucket = hashTable.insertNew(hashValue: hashValue)
      uncheckedInitialize(at: bucket, toKey: key, value: value)
    }
    _storage._count &+= 1
  }
  @_alwaysEmitIntoClient @inlinable internal mutating func _unsafeUpdate(key: __owned Key, value: __owned Value) {
    let (bucket, found) = find(key)
    if found {
      // Note that we also update the key here. This method is used to handle
      // collisions arising from equality transitions during bridging, and in
      // that case it is desirable to keep values paired with their original
      // keys. This is not how `updateValue(_:, forKey:)` works.
      (_keys + bucket.offset).pointee = key
      (_values + bucket.offset).pointee = value
    } else {
      _precondition(count < capacity)
      _insert(at: bucket, key: key, value: value)
    }
  }
  @inlinable internal mutating func insertNew(key: __owned Key, value: __owned Value) {
    _ = ensureUnique(isUnique: true, capacity: count + 1)
    _unsafeInsertNew(key: key, value: value)
  }
  @inlinable internal mutating func mutatingFind(_ key: Key, isUnique: Swift.Bool) -> (bucket: Swift._NativeDictionary<Key, Value>.Bucket, found: Swift.Bool) {
    let (bucket, found) = find(key)

    // Prepare storage.
    // If `key` isn't in the dictionary yet, assume that this access will end
    // up inserting it. (If we guess wrong, we might needlessly expand
    // storage; that's fine.) Otherwise this can only be a removal or an
    // in-place mutation.
    let rehashed = ensureUnique(
      isUnique: isUnique,
      capacity: count + (found ? 0 : 1))
    guard rehashed else { return (bucket, found) }
    let (b, f) = find(key)
    if f != found {
      KEY_TYPE_OF_DICTIONARY_VIOLATES_HASHABLE_REQUIREMENTS(Key.self)
    }
    return (b, found)
  }
  @inlinable internal func _insert(at bucket: Swift._NativeDictionary<Key, Value>.Bucket, key: __owned Key, value: __owned Value) {
    _internalInvariant(count < capacity)
    hashTable.insert(bucket)
    uncheckedInitialize(at: bucket, toKey: key, value: value)
    _storage._count += 1
  }
  @inlinable internal mutating func updateValue(_ value: __owned Value, forKey key: Key, isUnique: Swift.Bool) -> Value? {
    let (bucket, found) = mutatingFind(key, isUnique: isUnique)
    if found {
      let oldValue = (_values + bucket.offset).move()
      (_values + bucket.offset).initialize(to: value)
      return oldValue
    }
    _insert(at: bucket, key: key, value: value)
    return nil
  }
  @inlinable internal mutating func setValue(_ value: __owned Value, forKey key: Key, isUnique: Swift.Bool) {
    let (bucket, found) = mutatingFind(key, isUnique: isUnique)
    if found {
      (_values + bucket.offset).pointee = value
    } else {
      _insert(at: bucket, key: key, value: value)
    }
  }
}
extension _NativeDictionary {
  @inlinable @inline(__always) internal mutating func swapValuesAt(_ a: Swift._NativeDictionary<Key, Value>.Bucket, _ b: Swift._NativeDictionary<Key, Value>.Bucket, isUnique: Swift.Bool) {
    let rehashed = ensureUnique(isUnique: isUnique, capacity: capacity)
    _internalInvariant(!rehashed)
    _internalInvariant(hashTable.isOccupied(a) && hashTable.isOccupied(b))
    let value = (_values + a.offset).move()
    (_values + a.offset).moveInitialize(from: _values + b.offset, count: 1)
    (_values + b.offset).initialize(to: value)
  }
}
extension _NativeDictionary where Value : Swift.Equatable {
  @inlinable @inline(__always) internal func isEqual(to other: Swift._NativeDictionary<Key, Value>) -> Swift.Bool {
    if self._storage === other._storage { return true }
    if self.count != other.count { return false }

    for (key, value) in self {
      let (bucket, found) = other.find(key)
      guard found, other.uncheckedValue(at: bucket) == value else {
        return false
      }
    }
    return true
  }
  @inlinable internal func isEqual(to other: Swift.__CocoaDictionary) -> Swift.Bool {
    if self.count != other.count { return false }

    defer { _fixLifetime(self) }
    for bucket in self.hashTable {
      let key = self.uncheckedKey(at: bucket)
      let value = self.uncheckedValue(at: bucket)
      guard
        let cocoaValue = other.lookup(_bridgeAnythingToObjectiveC(key)),
        value == _forceBridgeFromObjectiveC(cocoaValue, Value.self)
      else {
        return false
      }
    }
    return true
  }
}
extension _NativeDictionary : Swift._HashTableDelegate {
  @inlinable @inline(__always) internal func hashValue(at bucket: Swift._NativeDictionary<Key, Value>.Bucket) -> Swift.Int {
    return hashValue(for: uncheckedKey(at: bucket))
  }
  @inlinable @inline(__always) internal func moveEntry(from source: Swift._NativeDictionary<Key, Value>.Bucket, to target: Swift._NativeDictionary<Key, Value>.Bucket) {
    _internalInvariant(hashTable.isValid(source))
    _internalInvariant(hashTable.isValid(target))
    (_keys + target.offset)
      .moveInitialize(from: _keys + source.offset, count: 1)
    (_values + target.offset)
      .moveInitialize(from: _values + source.offset, count: 1)
  }
  @inlinable @inline(__always) internal func swapEntry(_ left: Swift._NativeDictionary<Key, Value>.Bucket, with right: Swift._NativeDictionary<Key, Value>.Bucket) {
    _internalInvariant(hashTable.isValid(left))
    _internalInvariant(hashTable.isValid(right))
    swap(&_keys[left.offset], &_keys[right.offset])
    swap(&_values[left.offset], &_values[right.offset])
  }
}
extension _NativeDictionary {
  @inlinable @_effects(releasenone) @_semantics("optimize.sil.specialize.generic.size.never") internal func _delete(at bucket: Swift._NativeDictionary<Key, Value>.Bucket) {
    hashTable.delete(at: bucket, with: self)
    _storage._count -= 1
    _internalInvariant(_storage._count >= 0)
    invalidateIndices()
  }
  @inlinable @_semantics("optimize.sil.specialize.generic.size.never") internal mutating func uncheckedRemove(at bucket: Swift._NativeDictionary<Key, Value>.Bucket, isUnique: Swift.Bool) -> Swift._NativeDictionary<Key, Value>.Element {
    _internalInvariant(hashTable.isOccupied(bucket))
    let rehashed = ensureUnique(isUnique: isUnique, capacity: capacity)
    _internalInvariant(!rehashed)
    let oldKey = (_keys + bucket.offset).move()
    let oldValue = (_values + bucket.offset).move()
    _delete(at: bucket)
    return (oldKey, oldValue)
  }
  @usableFromInline
  internal mutating func removeAll(isUnique: Swift.Bool)
}
extension _NativeDictionary {
  @inlinable internal func mapValues<T>(_ transform: (Value) throws -> T) rethrows -> Swift._NativeDictionary<Key, T> {
    let resultStorage = _DictionaryStorage<Key, T>.copy(original: _storage)
    _internalInvariant(resultStorage._seed == _storage._seed)
    let result = _NativeDictionary<Key, T>(resultStorage)
    // Because the current and new buffer have the same scale and seed, we can
    // initialize to the same locations in the new buffer, skipping hash value
    // recalculations.
    for bucket in hashTable {
      let key = self.uncheckedKey(at: bucket)
      let value = self.uncheckedValue(at: bucket)
      try result._insert(at: bucket, key: key, value: transform(value))
    }
    return result
  }
  @inlinable internal mutating func merge<S>(_ keysAndValues: __owned S, isUnique: Swift.Bool, uniquingKeysWith combine: (Value, Value) throws -> Value) rethrows where S : Swift.Sequence, S.Element == (Key, Value) {
    var isUnique = isUnique
    for (key, value) in keysAndValues {
      let (bucket, found) = mutatingFind(key, isUnique: isUnique)
      isUnique = true
      if found {
        do {
          let newValue = try combine(uncheckedValue(at: bucket), value)
          _values[bucket.offset] = newValue
        } catch _MergeError.keyCollision {
          fatalError("Duplicate values for key: '\(key)'")
        }
      } else {
        _insert(at: bucket, key: key, value: value)
      }
    }
  }
  @inlinable @inline(__always) internal init<S>(grouping values: __owned S, by keyForValue: (S.Element) throws -> Key) rethrows where Value == [S.Element], S : Swift.Sequence {
    self.init()
    for value in values {
      let key = try keyForValue(value)
      let (bucket, found) = mutatingFind(key, isUnique: true)
      if found {
        _values[bucket.offset].append(value)
      } else {
        _insert(at: bucket, key: key, value: [value])
      }
    }
  }
}
extension _NativeDictionary : Swift.Sequence {
  @usableFromInline
  @frozen internal struct Iterator {
    @usableFromInline
    internal let base: Swift._NativeDictionary<Key, Value>
    @usableFromInline
    internal var iterator: Swift._HashTable.Iterator
    @inlinable @inline(__always) internal init(_ base: __owned Swift._NativeDictionary<Key, Value>) {
      self.base = base
      self.iterator = base.hashTable.makeIterator()
    }
  }
  @inlinable __consuming internal func makeIterator() -> Swift._NativeDictionary<Key, Value>.Iterator {
    return Iterator(self)
  }
}
extension _NativeDictionary.Iterator : Swift.IteratorProtocol {
  @usableFromInline
  internal typealias Element = (key: Key, value: Value)
  @inlinable @inline(__always) internal mutating func nextKey() -> Key? {
    guard let index = iterator.next() else { return nil }
    return base.uncheckedKey(at: index)
  }
  @inlinable @inline(__always) internal mutating func nextValue() -> Value? {
    guard let index = iterator.next() else { return nil }
    return base.uncheckedValue(at: index)
  }
  @inlinable @inline(__always) internal mutating func next() -> Swift._NativeDictionary<Key, Value>.Iterator.Element? {
    guard let index = iterator.next() else { return nil }
    let key = base.uncheckedKey(at: index)
    let value = base.uncheckedValue(at: index)
    return (key, value)
  }
}
@usableFromInline
@frozen internal struct _NativeSet<Element> where Element : Swift.Hashable {
  @usableFromInline
  internal var _storage: Swift.__RawSetStorage
  @inlinable @inline(__always) internal init() {
    self._storage = __RawSetStorage.empty
  }
  @inlinable @inline(__always) internal init(_ storage: __owned Swift.__RawSetStorage) {
    self._storage = storage
  }
  @inlinable internal init(capacity: Swift.Int) {
    if capacity == 0 {
      self._storage = __RawSetStorage.empty
    } else {
      self._storage = _SetStorage<Element>.allocate(capacity: capacity)
    }
  }
  @inlinable internal init(_ cocoa: __owned Swift.__CocoaSet) {
    self.init(cocoa, capacity: cocoa.count)
  }
  @inlinable internal init(_ cocoa: __owned Swift.__CocoaSet, capacity: Swift.Int) {
    if capacity == 0 {
      self._storage = __RawSetStorage.empty
    } else {
      _internalInvariant(cocoa.count <= capacity)
      self._storage = _SetStorage<Element>.convert(cocoa, capacity: capacity)
      for element in cocoa {
        let nativeElement = _forceBridgeFromObjectiveC(element, Element.self)
        insertNew(nativeElement, isUnique: true)
      }
    }
  }
}
extension _NativeSet {
  @usableFromInline
  internal typealias Bucket = Swift._HashTable.Bucket
  @inlinable internal var capacity: Swift.Int {
    @inline(__always) get {
      return _assumeNonNegative(_storage._capacity)
    }
  }
  @inlinable internal var hashTable: Swift._HashTable {
    @inline(__always) get {
      return _storage._hashTable
    }
  }
  @inlinable internal var age: Swift.Int32 {
    @inline(__always) get {
      return _storage._age
    }
  }
  @inlinable internal var _elements: Swift.UnsafeMutablePointer<Element> {
    get {
    return _storage._rawElements.assumingMemoryBound(to: Element.self)
  }
  }
  @inlinable @inline(__always) internal func invalidateIndices() {
    _storage._age &+= 1
  }
}
extension _NativeSet {
  @inlinable @inline(__always) internal func uncheckedElement(at bucket: Swift._NativeSet<Element>.Bucket) -> Element {
    defer { _fixLifetime(self) }
    _internalInvariant(hashTable.isOccupied(bucket))
    return _elements[bucket.offset]
  }
  @inlinable @inline(__always) internal func uncheckedInitialize(at bucket: Swift._NativeSet<Element>.Bucket, to element: __owned Element) {
    _internalInvariant(hashTable.isValid(bucket))
    (_elements + bucket.offset).initialize(to: element)
  }
  @_alwaysEmitIntoClient @inlinable @inline(__always) internal func uncheckedAssign(at bucket: Swift._NativeSet<Element>.Bucket, to element: __owned Element) {
    _internalInvariant(hashTable.isOccupied(bucket))
    (_elements + bucket.offset).pointee = element
  }
}
extension _NativeSet {
  @inlinable @inline(__always) internal func hashValue(for element: Element) -> Swift.Int {
    return element._rawHashValue(seed: _storage._seed)
  }
  @inlinable @inline(__always) internal func find(_ element: Element) -> (bucket: Swift._NativeSet<Element>.Bucket, found: Swift.Bool) {
    return find(element, hashValue: self.hashValue(for: element))
  }
  @inlinable @inline(__always) internal func find(_ element: Element, hashValue: Swift.Int) -> (bucket: Swift._NativeSet<Element>.Bucket, found: Swift.Bool) {
    let hashTable = self.hashTable
    var bucket = hashTable.idealBucket(forHashValue: hashValue)
    while hashTable._isOccupied(bucket) {
      if uncheckedElement(at: bucket) == element {
        return (bucket, true)
      }
      bucket = hashTable.bucket(wrappedAfter: bucket)
    }
    return (bucket, false)
  }
}
extension _NativeSet {
  @inlinable internal mutating func resize(capacity: Swift.Int) {
    let capacity = Swift.max(capacity, self.capacity)
    let result = _NativeSet(_SetStorage<Element>.resize(
        original: _storage,
        capacity: capacity,
        move: true))
    if count > 0 {
      for bucket in hashTable {
        let element = (self._elements + bucket.offset).move()
        result._unsafeInsertNew(element)
      }
      // Clear out old storage, ensuring that its deinit won't overrelease the
      // elements we've just moved out.
      _storage._hashTable.clear()
      _storage._count = 0
    }
    _storage = result._storage
  }
  @inlinable internal mutating func copyAndResize(capacity: Swift.Int) {
    let capacity = Swift.max(capacity, self.capacity)
    let result = _NativeSet(_SetStorage<Element>.resize(
        original: _storage,
        capacity: capacity,
        move: false))
    if count > 0 {
      for bucket in hashTable {
        result._unsafeInsertNew(self.uncheckedElement(at: bucket))
      }
    }
    _storage = result._storage
  }
  @inlinable internal mutating func copy() {
    let newStorage = _SetStorage<Element>.copy(original: _storage)
    _internalInvariant(newStorage._scale == _storage._scale)
    _internalInvariant(newStorage._age == _storage._age)
    _internalInvariant(newStorage._seed == _storage._seed)
    let result = _NativeSet(newStorage)
    if count > 0 {
      result.hashTable.copyContents(of: hashTable)
      result._storage._count = self.count
      for bucket in hashTable {
        let element = uncheckedElement(at: bucket)
        result.uncheckedInitialize(at: bucket, to: element)
      }
    }
    _storage = result._storage
  }
  @inlinable @inline(__always) internal mutating func ensureUnique(isUnique: Swift.Bool, capacity: Swift.Int) -> Swift.Bool {
    if _fastPath(capacity <= self.capacity && isUnique) {
      return false
    }
    if isUnique {
      resize(capacity: capacity)
      return true
    }
    if capacity <= self.capacity {
      copy()
      return false
    }
    copyAndResize(capacity: capacity)
    return true
  }
}
extension _NativeSet {
  @inlinable @inline(__always) internal func validatedBucket(for index: Swift._HashTable.Index) -> Swift._NativeSet<Element>.Bucket {
    _precondition(hashTable.isOccupied(index.bucket) && index.age == age,
      "Attempting to access Set elements using an invalid index")
    return index.bucket
  }
  @inlinable @inline(__always) internal func validatedBucket(for index: Swift.Set<Element>.Index) -> Swift._NativeSet<Element>.Bucket {
    guard index._isNative else {
      index._cocoaPath()
      let cocoa = index._asCocoa
      // Accept Cocoa indices as long as they contain an element that exists in
      // this set, and the address of their Cocoa object generates the same age.
      if cocoa.age == self.age {
        let element = _forceBridgeFromObjectiveC(cocoa.element, Element.self)
        let (bucket, found) = find(element)
        if found {
          return bucket
        }
      }
      _preconditionFailure(
        "Attempting to access Set elements using an invalid index")
    }
    return validatedBucket(for: index._asNative)
  }
}
extension _NativeSet {
  @usableFromInline
  internal typealias Index = Swift.Set<Element>.Index
  @inlinable internal var startIndex: Swift._NativeSet<Element>.Index {
    get {
    let bucket = hashTable.startBucket
    return Index(_native: _HashTable.Index(bucket: bucket, age: age))
  }
  }
  @inlinable internal var endIndex: Swift._NativeSet<Element>.Index {
    get {
    let bucket = hashTable.endBucket
    return Index(_native: _HashTable.Index(bucket: bucket, age: age))
  }
  }
  @inlinable internal func index(after index: Swift._NativeSet<Element>.Index) -> Swift._NativeSet<Element>.Index {
    // Note that _asNative forces this not to work on Cocoa indices.
    let bucket = validatedBucket(for: index._asNative)
    let next = hashTable.occupiedBucket(after: bucket)
    return Index(_native: _HashTable.Index(bucket: next, age: age))
  }
  @inlinable @inline(__always) internal func index(for element: Element) -> Swift._NativeSet<Element>.Index? {
    if count == 0 {
      // Fast path that avoids computing the hash of the key.
      return nil
    }
    let (bucket, found) = find(element)
    guard found else { return nil }
    return Index(_native: _HashTable.Index(bucket: bucket, age: age))
  }
  @inlinable internal var count: Swift.Int {
    @inline(__always) get {
      return _assumeNonNegative(_storage._count)
    }
  }
  @inlinable @inline(__always) internal func contains(_ member: Element) -> Swift.Bool {
    // Fast path: Don't calculate the hash if the set has no elements.
    if count == 0 { return false }
    return find(member).found
  }
  @inlinable @inline(__always) internal func element(at index: Swift._NativeSet<Element>.Index) -> Element {
    let bucket = validatedBucket(for: index)
    return uncheckedElement(at: bucket)
  }
}
@usableFromInline
@inline(never) internal func ELEMENT_TYPE_OF_SET_VIOLATES_HASHABLE_REQUIREMENTS(_ elementType: Any.Type) -> Swift.Never
extension _NativeSet {
  @inlinable internal func _unsafeInsertNew(_ element: __owned Element) {
    _internalInvariant(count + 1 <= capacity)
    let hashValue = self.hashValue(for: element)
    if _isDebugAssertConfiguration() {
      // In debug builds, perform a full lookup and trap if we detect duplicate
      // elements -- these imply that the Element type violates Hashable
      // requirements. This is generally more costly than a direct insertion,
      // because we'll need to compare elements in case of hash collisions.
      let (bucket, found) = find(element, hashValue: hashValue)
      guard !found else {
        ELEMENT_TYPE_OF_SET_VIOLATES_HASHABLE_REQUIREMENTS(Element.self)
      }
      hashTable.insert(bucket)
      uncheckedInitialize(at: bucket, to: element)
    } else {
      let bucket = hashTable.insertNew(hashValue: hashValue)
      uncheckedInitialize(at: bucket, to: element)
    }
    _storage._count &+= 1
  }
  @inlinable internal mutating func insertNew(_ element: __owned Element, isUnique: Swift.Bool) {
    _ = ensureUnique(isUnique: isUnique, capacity: count + 1)
    _unsafeInsertNew(element)
  }
  @inlinable internal func _unsafeInsertNew(_ element: __owned Element, at bucket: Swift._NativeSet<Element>.Bucket) {
    hashTable.insert(bucket)
    uncheckedInitialize(at: bucket, to: element)
    _storage._count += 1
  }
  @inlinable internal mutating func insertNew(_ element: __owned Element, at bucket: Swift._NativeSet<Element>.Bucket, isUnique: Swift.Bool) {
    _internalInvariant(!hashTable.isOccupied(bucket))
    var bucket = bucket
    let rehashed = ensureUnique(isUnique: isUnique, capacity: count + 1)
    if rehashed {
      let (b, f) = find(element)
      if f {
        ELEMENT_TYPE_OF_SET_VIOLATES_HASHABLE_REQUIREMENTS(Element.self)
      }
      bucket = b
    }
    _unsafeInsertNew(element, at: bucket)
  }
  @inlinable internal mutating func update(with element: __owned Element, isUnique: Swift.Bool) -> Element? {
    var (bucket, found) = find(element)
    let rehashed = ensureUnique(
      isUnique: isUnique,
      capacity: count + (found ? 0 : 1))
    if rehashed {
      let (b, f) = find(element)
      if f != found {
        ELEMENT_TYPE_OF_SET_VIOLATES_HASHABLE_REQUIREMENTS(Element.self)
      }
      bucket = b
    }
    if found {
      let old = (_elements + bucket.offset).move()
      uncheckedInitialize(at: bucket, to: element)
      return old
    }
    _unsafeInsertNew(element, at: bucket)
    return nil
  }
  @_alwaysEmitIntoClient @inlinable internal mutating func _unsafeUpdate(with element: __owned Element) {
    let (bucket, found) = find(element)
    if found {
      uncheckedAssign(at: bucket, to: element)
    } else {
      _precondition(count < capacity)
      _unsafeInsertNew(element, at: bucket)
    }
  }
}
extension _NativeSet {
  @inlinable @inline(__always) internal func isEqual(to other: Swift._NativeSet<Element>) -> Swift.Bool {
    if self._storage === other._storage { return true }
    if self.count != other.count { return false }

    for member in self {
      guard other.find(member).found else { return false }
    }
    return true
  }
  @inlinable internal func isEqual(to other: Swift.__CocoaSet) -> Swift.Bool {
    if self.count != other.count { return false }

    defer { _fixLifetime(self) }
    for bucket in self.hashTable {
      let key = self.uncheckedElement(at: bucket)
      let bridgedKey = _bridgeAnythingToObjectiveC(key)
      guard other.contains(bridgedKey) else { return false }
    }
    return true
  }
}
extension _NativeSet : Swift._HashTableDelegate {
  @inlinable @inline(__always) internal func hashValue(at bucket: Swift._NativeSet<Element>.Bucket) -> Swift.Int {
    return hashValue(for: uncheckedElement(at: bucket))
  }
  @inlinable @inline(__always) internal func moveEntry(from source: Swift._NativeSet<Element>.Bucket, to target: Swift._NativeSet<Element>.Bucket) {
    (_elements + target.offset)
      .moveInitialize(from: _elements + source.offset, count: 1)
  }
}
extension _NativeSet {
  @inlinable @_effects(releasenone) internal mutating func _delete(at bucket: Swift._NativeSet<Element>.Bucket) {
    hashTable.delete(at: bucket, with: self)
    _storage._count -= 1
    _internalInvariant(_storage._count >= 0)
    invalidateIndices()
  }
  @inlinable @inline(__always) internal mutating func uncheckedRemove(at bucket: Swift._NativeSet<Element>.Bucket, isUnique: Swift.Bool) -> Element {
    _internalInvariant(hashTable.isOccupied(bucket))
    let rehashed = ensureUnique(isUnique: isUnique, capacity: capacity)
    _internalInvariant(!rehashed)
    let old = (_elements + bucket.offset).move()
    _delete(at: bucket)
    return old
  }
  @usableFromInline
  internal mutating func removeAll(isUnique: Swift.Bool)
}
extension _NativeSet : Swift.Sequence {
  @usableFromInline
  @frozen internal struct Iterator {
    @usableFromInline
    internal let base: Swift._NativeSet<Element>
    @usableFromInline
    internal var iterator: Swift._HashTable.Iterator
    @inlinable @inline(__always) internal init(_ base: __owned Swift._NativeSet<Element>) {
      self.base = base
      self.iterator = base.hashTable.makeIterator()
    }
  }
  @inlinable @inline(__always) __consuming internal func makeIterator() -> Swift._NativeSet<Element>.Iterator {
    return Iterator(self)
  }
}
extension _NativeSet.Iterator : Swift.IteratorProtocol {
  @inlinable @inline(__always) internal mutating func next() -> Element? {
    guard let index = iterator.next() else { return nil }
    return base.uncheckedElement(at: index)
  }
}
public protocol _SwiftNewtypeWrapper : Swift.RawRepresentable, Swift._HasCustomAnyHashableRepresentation {
}
extension _SwiftNewtypeWrapper where Self : Swift.Hashable, Self.RawValue : Swift.Hashable {
  @inlinable public var hashValue: Swift.Int {
    get {
    return rawValue.hashValue
  }
  }
  @inlinable public func hash(into hasher: inout Swift.Hasher) {
    hasher.combine(rawValue)
  }
  @inlinable public func _rawHashValue(seed: Swift.Int) -> Swift.Int {
    return rawValue._rawHashValue(seed: seed)
  }
}
extension _SwiftNewtypeWrapper {
  __consuming public func _toCustomAnyHashable() -> Swift.AnyHashable?
}
extension _SwiftNewtypeWrapper where Self : Swift.Hashable, Self.RawValue : Swift.Hashable {
  __consuming public func _toCustomAnyHashable() -> Swift.AnyHashable?
}
extension _SwiftNewtypeWrapper where Self.RawValue : Swift._ObjectiveCBridgeable {
  public typealias _ObjectiveCType = Self.RawValue._ObjectiveCType
  @inlinable public func _bridgeToObjectiveC() -> Self.RawValue._ObjectiveCType {
    return rawValue._bridgeToObjectiveC()
  }
  @inlinable public static func _forceBridgeFromObjectiveC(_ source: Self.RawValue._ObjectiveCType, result: inout Self?) {
    var innerResult: Self.RawValue?
    Self.RawValue._forceBridgeFromObjectiveC(source, result: &innerResult)
    result = innerResult.flatMap { Self(rawValue: $0) }
  }
  @inlinable public static func _conditionallyBridgeFromObjectiveC(_ source: Self.RawValue._ObjectiveCType, result: inout Self?) -> Swift.Bool {
    var innerResult: Self.RawValue?
    let success = Self.RawValue._conditionallyBridgeFromObjectiveC(
      source,
      result: &innerResult)
    result = innerResult.flatMap { Self(rawValue: $0) }
    return success
  }
  @inlinable @_effects(readonly) public static func _unconditionallyBridgeFromObjectiveC(_ source: Self.RawValue._ObjectiveCType?) -> Self {
    return Self(
      rawValue: Self.RawValue._unconditionallyBridgeFromObjectiveC(source))!
  }
}
extension _SwiftNewtypeWrapper where Self.RawValue : AnyObject {
  @inlinable public func _bridgeToObjectiveC() -> Self.RawValue {
    return rawValue
  }
  @inlinable public static func _forceBridgeFromObjectiveC(_ source: Self.RawValue, result: inout Self?) {
    result = Self(rawValue: source)
  }
  @inlinable public static func _conditionallyBridgeFromObjectiveC(_ source: Self.RawValue, result: inout Self?) -> Swift.Bool {
    result = Self(rawValue: source)
    return result != nil
  }
  @inlinable @_effects(readonly) public static func _unconditionallyBridgeFromObjectiveC(_ source: Self.RawValue?) -> Self {
    return Self(rawValue: source!)!
  }
}
@frozen public struct ObjectIdentifier {
  @usableFromInline
  internal let _value: Builtin.RawPointer
  @inlinable public init(_ x: Swift.AnyObject) {
    self._value = Builtin.bridgeToRawPointer(x)
  }
  @inlinable public init(_ x: Any.Type) {
    self._value = unsafeBitCast(x, to: Builtin.RawPointer.self)
  }
}
extension ObjectIdentifier : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
extension ObjectIdentifier : Swift.Equatable {
  @inlinable public static func == (x: Swift.ObjectIdentifier, y: Swift.ObjectIdentifier) -> Swift.Bool {
    return Bool(Builtin.cmp_eq_RawPointer(x._value, y._value))
  }
}
extension ObjectIdentifier : Swift.Comparable {
  @inlinable public static func < (lhs: Swift.ObjectIdentifier, rhs: Swift.ObjectIdentifier) -> Swift.Bool {
    return UInt(bitPattern: lhs) < UInt(bitPattern: rhs)
  }
}
extension ObjectIdentifier : Swift.Hashable {
  @inlinable public func hash(into hasher: inout Swift.Hasher) {
    hasher.combine(Int(Builtin.ptrtoint_Word(_value)))
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension UInt {
  @inlinable public init(bitPattern objectID: Swift.ObjectIdentifier) {
    self.init(Builtin.ptrtoint_Word(objectID._value))
  }
}
extension Int {
  @inlinable public init(bitPattern objectID: Swift.ObjectIdentifier) {
    self.init(bitPattern: UInt(bitPattern: objectID))
  }
}
@frozen public enum Optional<Wrapped> : Swift.ExpressibleByNilLiteral {
  case none
  case some(Wrapped)
  @_transparent public init(_ some: Wrapped) { self = .some(some) }
  @inlinable public func map<U>(_ transform: (Wrapped) throws -> U) rethrows -> U? {
    switch self {
    case .some(let y):
      return .some(try transform(y))
    case .none:
      return .none
    }
  }
  @inlinable public func flatMap<U>(_ transform: (Wrapped) throws -> U?) rethrows -> U? {
    switch self {
    case .some(let y):
      return try transform(y)
    case .none:
      return .none
    }
  }
  @_transparent public init(nilLiteral: ()) {
    self = .none
  }
  @inlinable public var unsafelyUnwrapped: Wrapped {
    @inline(__always) get {
      if let x = self {
        return x
      }
      _debugPreconditionFailure("unsafelyUnwrapped of nil optional")
    }
  }
  @inlinable internal var _unsafelyUnwrappedUnchecked: Wrapped {
    @inline(__always) get {
      if let x = self {
        return x
      }
      _internalInvariantFailure("_unsafelyUnwrappedUnchecked of nil optional")
    }
  }
}
extension Optional : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
extension Optional : Swift.CustomReflectable {
  public var customMirror: Swift.Mirror {
    get
  }
}
@_transparent public func _diagnoseUnexpectedNilOptional(_filenameStart: Builtin.RawPointer, _filenameLength: Builtin.Word, _filenameIsASCII: Builtin.Int1, _line: Builtin.Word, _isImplicitUnwrap: Builtin.Int1) {
  // Cannot use _preconditionFailure as the file and line info would not be
  // printed.
  if Bool(_isImplicitUnwrap) {
    _preconditionFailure(
      "Unexpectedly found nil while implicitly unwrapping an Optional value",
      file: StaticString(_start: _filenameStart,
                         utf8CodeUnitCount: _filenameLength,
                         isASCII: _filenameIsASCII),
      line: UInt(_line))
  } else {
    _preconditionFailure(
      "Unexpectedly found nil while unwrapping an Optional value",
      file: StaticString(_start: _filenameStart,
                         utf8CodeUnitCount: _filenameLength,
                         isASCII: _filenameIsASCII),
      line: UInt(_line))
  }
}
extension Optional : Swift.Equatable where Wrapped : Swift.Equatable {
  @inlinable public static func == (lhs: Wrapped?, rhs: Wrapped?) -> Swift.Bool {
    switch (lhs, rhs) {
    case let (l?, r?):
      return l == r
    case (nil, nil):
      return true
    default:
      return false
    }
  }
}
extension Optional : Swift.Hashable where Wrapped : Swift.Hashable {
  @inlinable public func hash(into hasher: inout Swift.Hasher) {
    switch self {
    case .none:
      hasher.combine(0 as UInt8)
    case .some(let wrapped):
      hasher.combine(1 as UInt8)
      hasher.combine(wrapped)
    }
  }
  public var hashValue: Swift.Int {
    get
  }
}
@frozen public struct _OptionalNilComparisonType : Swift.ExpressibleByNilLiteral {
  @_transparent public init(nilLiteral: ()) {
  }
}
extension Optional {
  @_transparent public static func ~= (lhs: Swift._OptionalNilComparisonType, rhs: Wrapped?) -> Swift.Bool {
    switch rhs {
    case .some:
      return false
    case .none:
      return true
    }
  }
  @_transparent public static func == (lhs: Wrapped?, rhs: Swift._OptionalNilComparisonType) -> Swift.Bool {
    switch lhs {
    case .some:
      return false
    case .none:
      return true
    }
  }
  @_transparent public static func != (lhs: Wrapped?, rhs: Swift._OptionalNilComparisonType) -> Swift.Bool {
    switch lhs {
    case .some:
      return true
    case .none:
      return false
    }
  }
  @_transparent public static func == (lhs: Swift._OptionalNilComparisonType, rhs: Wrapped?) -> Swift.Bool {
    switch rhs {
    case .some:
      return false
    case .none:
      return true
    }
  }
  @_transparent public static func != (lhs: Swift._OptionalNilComparisonType, rhs: Wrapped?) -> Swift.Bool {
    switch rhs {
    case .some:
      return true
    case .none:
      return false
    }
  }
}
@_transparent public func ?? <T>(optional: T?, defaultValue: @autoclosure () throws -> T) rethrows -> T {
  switch optional {
  case .some(let value):
    return value
  case .none:
    return try defaultValue()
  }
}
@_transparent public func ?? <T>(optional: T?, defaultValue: @autoclosure () throws -> T?) rethrows -> T? {
  switch optional {
  case .some(let value):
    return value
  case .none:
    return try defaultValue()
  }
}
extension Optional : Swift._ObjectiveCBridgeable {
  public func _bridgeToObjectiveC() -> Swift.AnyObject
  public static func _forceBridgeFromObjectiveC(_ source: Swift.AnyObject, result: inout Swift.Optional<Wrapped>?)
  public static func _conditionallyBridgeFromObjectiveC(_ source: Swift.AnyObject, result: inout Swift.Optional<Wrapped>?) -> Swift.Bool
  @_effects(readonly) public static func _unconditionallyBridgeFromObjectiveC(_ source: Swift.AnyObject?) -> Swift.Optional<Wrapped>
  public typealias _ObjectiveCType = Swift.AnyObject
}
public protocol OptionSet : Swift.RawRepresentable, Swift.SetAlgebra {
  associatedtype Element = Self
  init(rawValue: Self.RawValue)
}
extension OptionSet {
  @inlinable public func union(_ other: Self) -> Self {
    var r: Self = Self(rawValue: self.rawValue)
    r.formUnion(other)
    return r
  }
  @inlinable public func intersection(_ other: Self) -> Self {
    var r = Self(rawValue: self.rawValue)
    r.formIntersection(other)
    return r
  }
  @inlinable public func symmetricDifference(_ other: Self) -> Self {
    var r = Self(rawValue: self.rawValue)
    r.formSymmetricDifference(other)
    return r
  }
}
extension OptionSet where Self == Self.Element {
  @inlinable public func contains(_ member: Self) -> Swift.Bool {
    return self.isSuperset(of: member)
  }
  @discardableResult
  @inlinable public mutating func insert(_ newMember: Self.Element) -> (inserted: Swift.Bool, memberAfterInsert: Self.Element) {
    let oldMember = self.intersection(newMember)
    let shouldInsert = oldMember != newMember
    let result = (
      inserted: shouldInsert,
      memberAfterInsert: shouldInsert ? newMember : oldMember)
    if shouldInsert {
      self.formUnion(newMember)
    }
    return result
  }
  @discardableResult
  @inlinable public mutating func remove(_ member: Self.Element) -> Self.Element? {
    let intersectionElements = intersection(member)
    guard !intersectionElements.isEmpty else {
      return nil
    }
    
    self.subtract(member)
    return intersectionElements
  }
  @discardableResult
  @inlinable public mutating func update(with newMember: Self.Element) -> Self.Element? {
    let r = self.intersection(newMember)
    self.formUnion(newMember)
    return r.isEmpty ? nil : r
  }
}
extension OptionSet where Self.RawValue : Swift.FixedWidthInteger {
  @inlinable public init() {
    self.init(rawValue: 0)
  }
  @inlinable public mutating func formUnion(_ other: Self) {
    self = Self(rawValue: self.rawValue | other.rawValue)
  }
  @inlinable public mutating func formIntersection(_ other: Self) {
    self = Self(rawValue: self.rawValue & other.rawValue)
  }
  @inlinable public mutating func formSymmetricDifference(_ other: Self) {
    self = Self(rawValue: self.rawValue ^ other.rawValue)
  }
}
public protocol TextOutputStream {
  mutating func _lock()
  mutating func _unlock()
  mutating func write(_ string: Swift.String)
  mutating func _writeASCII(_ buffer: Swift.UnsafeBufferPointer<Swift.UInt8>)
}
extension TextOutputStream {
  public mutating func _lock()
  public mutating func _unlock()
  public mutating func _writeASCII(_ buffer: Swift.UnsafeBufferPointer<Swift.UInt8>)
}
public protocol TextOutputStreamable {
  func write<Target>(to target: inout Target) where Target : Swift.TextOutputStream
}
public protocol CustomStringConvertible {
  var description: Swift.String { get }
}
public protocol LosslessStringConvertible : Swift.CustomStringConvertible {
  init?(_ description: Swift.String)
}
public protocol CustomDebugStringConvertible {
  var debugDescription: Swift.String { get }
}
@usableFromInline
@_semantics("optimize.sil.specialize.generic.never") internal func _print_unlocked<T, TargetStream>(_ value: T, _ target: inout TargetStream) where TargetStream : Swift.TextOutputStream
@_semantics("optimize.sil.specialize.generic.never") @inline(never) public func _debugPrint_unlocked<T, TargetStream>(_ value: T, _ target: inout TargetStream) where TargetStream : Swift.TextOutputStream
extension String : Swift.TextOutputStream {
  public mutating func write(_ other: Swift.String)
  public mutating func _writeASCII(_ buffer: Swift.UnsafeBufferPointer<Swift.UInt8>)
}
extension String : Swift.TextOutputStreamable {
  @inlinable public func write<Target>(to target: inout Target) where Target : Swift.TextOutputStream {
    target.write(self)
  }
}
extension Character : Swift.TextOutputStreamable {
  public func write<Target>(to target: inout Target) where Target : Swift.TextOutputStream
}
extension Unicode.Scalar : Swift.TextOutputStreamable {
  public func write<Target>(to target: inout Target) where Target : Swift.TextOutputStream
}
public var _playgroundPrintHook: ((Swift.String) -> Swift.Void)?
public protocol _Pointer : Swift.CustomDebugStringConvertible, Swift.CustomReflectable, Swift.Hashable, Swift.Strideable {
  typealias Distance = Swift.Int
  associatedtype Pointee
  var _rawValue: Builtin.RawPointer { get }
  init(_ _rawValue: Builtin.RawPointer)
}
extension _Pointer {
  @_transparent public init(_ from: Swift.OpaquePointer) {
    self.init(from._rawValue)
  }
  @_transparent public init?(_ from: Swift.OpaquePointer?) {
    guard let unwrapped = from else { return nil }
    self.init(unwrapped)
  }
  @_transparent public init?(bitPattern: Swift.Int) {
    if bitPattern == 0 { return nil }
    self.init(Builtin.inttoptr_Word(bitPattern._builtinWordValue))
  }
  @_transparent public init?(bitPattern: Swift.UInt) {
    if bitPattern == 0 { return nil }
    self.init(Builtin.inttoptr_Word(bitPattern._builtinWordValue))
  }
  @_transparent public init(@_nonEphemeral _ other: Self) {
    self.init(other._rawValue)
  }
  @_transparent public init?(@_nonEphemeral _ other: Self?) {
    guard let unwrapped = other else { return nil }
    self.init(unwrapped._rawValue)
  }
}
extension _Pointer {
  @_transparent public static func == (lhs: Self, rhs: Self) -> Swift.Bool {
    return Bool(Builtin.cmp_eq_RawPointer(lhs._rawValue, rhs._rawValue))
  }
}
extension _Pointer {
  @_transparent public static func < (lhs: Self, rhs: Self) -> Swift.Bool {
    return Bool(Builtin.cmp_ult_RawPointer(lhs._rawValue, rhs._rawValue))
  }
}
extension _Pointer {
  @_transparent public func successor() -> Self {
    return advanced(by: 1)
  }
  @_transparent public func predecessor() -> Self {
    return advanced(by: -1)
  }
  @_transparent public func distance(to end: Self) -> Swift.Int {
    return
      Int(Builtin.sub_Word(Builtin.ptrtoint_Word(end._rawValue),
                           Builtin.ptrtoint_Word(_rawValue)))
      / MemoryLayout<Pointee>.stride
  }
  @_transparent public func advanced(by n: Swift.Int) -> Self {
    return Self(Builtin.gep_Word(
      self._rawValue, n._builtinWordValue, Pointee.self))
  }
}
extension _Pointer {
  @inlinable public func hash(into hasher: inout Swift.Hasher) {
    hasher.combine(UInt(bitPattern: self))
  }
  @inlinable public func _rawHashValue(seed: Swift.Int) -> Swift.Int {
    return Hasher._hash(seed: seed, UInt(bitPattern: self))
  }
}
extension _Pointer {
  public var debugDescription: Swift.String {
    get
  }
}
extension _Pointer {
  public var customMirror: Swift.Mirror {
    get
  }
}
extension Int {
  @_transparent public init<P>(bitPattern pointer: P?) where P : Swift._Pointer {
    if let pointer = pointer {
      self = Int(Builtin.ptrtoint_Word(pointer._rawValue))
    } else {
      self = 0
    }
  }
}
extension UInt {
  @_transparent public init<P>(bitPattern pointer: P?) where P : Swift._Pointer {
    if let pointer = pointer {
      self = UInt(Builtin.ptrtoint_Word(pointer._rawValue))
    } else {
      self = 0
    }
  }
}
extension Strideable where Self : Swift._Pointer {
  @_transparent public static func + (@_nonEphemeral lhs: Self, rhs: Self.Stride) -> Self {
    return lhs.advanced(by: rhs)
  }
  @_transparent public static func + (lhs: Self.Stride, @_nonEphemeral rhs: Self) -> Self {
    return rhs.advanced(by: lhs)
  }
  @_transparent public static func - (@_nonEphemeral lhs: Self, rhs: Self.Stride) -> Self {
    return lhs.advanced(by: -rhs)
  }
  @_transparent public static func - (lhs: Self, rhs: Self) -> Self.Stride {
    return rhs.distance(to: lhs)
  }
  @_transparent public static func += (lhs: inout Self, rhs: Self.Stride) {
    lhs = lhs.advanced(by: rhs)
  }
  @_transparent public static func -= (lhs: inout Self, rhs: Self.Stride) {
    lhs = lhs.advanced(by: -rhs)
  }
}
@_transparent public func _convertPointerToPointerArgument<FromPointer, ToPointer>(_ from: FromPointer) -> ToPointer where FromPointer : Swift._Pointer, ToPointer : Swift._Pointer {
  return ToPointer(from._rawValue)
}
@_transparent public func _convertInOutToPointerArgument<ToPointer>(_ from: Builtin.RawPointer) -> ToPointer where ToPointer : Swift._Pointer {
  return ToPointer(from)
}
@_transparent public func _convertConstArrayToPointerArgument<FromElement, ToPointer>(_ arr: [FromElement]) -> (Swift.AnyObject?, ToPointer) where ToPointer : Swift._Pointer {
  let (owner, opaquePointer) = arr._cPointerArgs()

  let validPointer: ToPointer
  if let addr = opaquePointer {
    validPointer = ToPointer(addr._rawValue)
  } else {
    let lastAlignedValue = ~(MemoryLayout<FromElement>.alignment - 1)
    let lastAlignedPointer = UnsafeRawPointer(bitPattern: lastAlignedValue)!
    validPointer = ToPointer(lastAlignedPointer._rawValue)
  }
  return (owner, validPointer)
}
@_transparent public func _convertMutableArrayToPointerArgument<FromElement, ToPointer>(_ a: inout [FromElement]) -> (Swift.AnyObject?, ToPointer) where ToPointer : Swift._Pointer {
  // TODO: Putting a canary at the end of the array in checked builds might
  // be a good idea

  // Call reserve to force contiguous storage.
  a.reserveCapacity(0)
  _debugPrecondition(a._baseAddressIfContiguous != nil || a.isEmpty)

  return _convertConstArrayToPointerArgument(a)
}
@_transparent public func _convertConstStringToUTF8PointerArgument<ToPointer>(_ str: Swift.String) -> (Swift.AnyObject?, ToPointer) where ToPointer : Swift._Pointer {
  let utf8 = Array(str.utf8CString)
  return _convertConstArrayToPointerArgument(utf8)
}
@frozen public enum Never {
}
extension Never : Swift.Error {
}
extension Never : Swift.Equatable, Swift.Comparable, Swift.Hashable {
  public static func == (a: Swift.Never, b: Swift.Never) -> Swift.Bool
  public static func < (a: Swift.Never, b: Swift.Never) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public typealias Void = ()
public typealias Float32 = Swift.Float
public typealias Float64 = Swift.Double
public typealias IntegerLiteralType = Swift.Int
public typealias FloatLiteralType = Swift.Double
public typealias BooleanLiteralType = Swift.Bool
public typealias UnicodeScalarType = Swift.String
public typealias ExtendedGraphemeClusterType = Swift.String
public typealias StringLiteralType = Swift.String
public typealias _MaxBuiltinFloatType = Builtin.FPIEEE80
public typealias AnyObject = Builtin.AnyObject
public typealias AnyClass = Swift.AnyObject.Type
@_transparent public func ~= <T>(a: T, b: T) -> Swift.Bool where T : Swift.Equatable {
  return a == b
}
precedencegroup AssignmentPrecedence {
  associativity: right
  assignment: true
}
precedencegroup FunctionArrowPrecedence {
  associativity: right
  higherThan: AssignmentPrecedence
}
precedencegroup TernaryPrecedence {
  associativity: right
  higherThan: FunctionArrowPrecedence
}
precedencegroup DefaultPrecedence {
  higherThan: TernaryPrecedence
}
precedencegroup LogicalDisjunctionPrecedence {
  associativity: left
  higherThan: TernaryPrecedence
}
precedencegroup LogicalConjunctionPrecedence {
  associativity: left
  higherThan: LogicalDisjunctionPrecedence
}
precedencegroup ComparisonPrecedence {
  higherThan: LogicalConjunctionPrecedence
}
precedencegroup NilCoalescingPrecedence {
  associativity: right
  higherThan: ComparisonPrecedence
}
precedencegroup CastingPrecedence {
  higherThan: NilCoalescingPrecedence
}
precedencegroup RangeFormationPrecedence {
  higherThan: CastingPrecedence
}
precedencegroup AdditionPrecedence {
  associativity: left
  higherThan: RangeFormationPrecedence
}
precedencegroup MultiplicationPrecedence {
  associativity: left
  higherThan: AdditionPrecedence
}
precedencegroup BitwiseShiftPrecedence {
  higherThan: MultiplicationPrecedence
}
postfix operator ++
postfix operator --
postfix operator ... : Comparable
prefix operator ++
prefix operator --
prefix operator ! : Bool
prefix operator ~ : BinaryInteger
prefix operator + : AdditiveArithmetic
prefix operator - : SignedNumeric
prefix operator ... : Comparable
prefix operator ..< : Comparable
infix operator << : BitwiseShiftPrecedence, BinaryInteger
infix operator &<< : BitwiseShiftPrecedence, FixedWidthInteger
infix operator >> : BitwiseShiftPrecedence, BinaryInteger
infix operator &>> : BitwiseShiftPrecedence, FixedWidthInteger
infix operator * : MultiplicationPrecedence, Numeric
infix operator &* : MultiplicationPrecedence, FixedWidthInteger
infix operator / : MultiplicationPrecedence, BinaryInteger, FloatingPoint
infix operator % : MultiplicationPrecedence, BinaryInteger
infix operator & : MultiplicationPrecedence, BinaryInteger
infix operator + : AdditionPrecedence, AdditiveArithmetic, String, Array, Strideable
infix operator &+ : AdditionPrecedence, FixedWidthInteger
infix operator - : AdditionPrecedence, AdditiveArithmetic, Strideable
infix operator &- : AdditionPrecedence, FixedWidthInteger
infix operator | : AdditionPrecedence, BinaryInteger
infix operator ^ : AdditionPrecedence, BinaryInteger
infix operator ... : RangeFormationPrecedence, Comparable
infix operator ..< : RangeFormationPrecedence, Comparable
infix operator ?? : NilCoalescingPrecedence
infix operator < : ComparisonPrecedence, Comparable
infix operator <= : ComparisonPrecedence, Comparable
infix operator > : ComparisonPrecedence, Comparable
infix operator >= : ComparisonPrecedence, Comparable
infix operator == : ComparisonPrecedence, Equatable
infix operator != : ComparisonPrecedence, Equatable
infix operator === : ComparisonPrecedence
infix operator !== : ComparisonPrecedence
infix operator ~= : ComparisonPrecedence
infix operator && : LogicalConjunctionPrecedence, Bool
infix operator || : LogicalDisjunctionPrecedence, Bool
infix operator *= : AssignmentPrecedence, Numeric
infix operator &*= : AssignmentPrecedence, FixedWidthInteger
infix operator /= : AssignmentPrecedence, BinaryInteger
infix operator %= : AssignmentPrecedence, BinaryInteger
infix operator += : AssignmentPrecedence, AdditiveArithmetic, String, Array, Strideable
infix operator &+= : AssignmentPrecedence, FixedWidthInteger
infix operator -= : AssignmentPrecedence, AdditiveArithmetic, Strideable
infix operator &-= : AssignmentPrecedence, FixedWidthInteger
infix operator <<= : AssignmentPrecedence, BinaryInteger
infix operator &<<= : AssignmentPrecedence, FixedWidthInteger
infix operator >>= : AssignmentPrecedence, BinaryInteger
infix operator &>>= : AssignmentPrecedence, FixedWidthInteger
infix operator &= : AssignmentPrecedence, BinaryInteger
infix operator ^= : AssignmentPrecedence, BinaryInteger
infix operator |= : AssignmentPrecedence, BinaryInteger
infix operator ~> : DefaultPrecedence
@frozen public struct LazyPrefixWhileSequence<Base> where Base : Swift.Sequence {
  public typealias Element = Base.Element
  @inlinable internal init(_base: Base, predicate: @escaping (Swift.LazyPrefixWhileSequence<Base>.Element) -> Swift.Bool) {
    self._base = _base
    self._predicate = predicate
  }
  @usableFromInline
  internal var _base: Base
  @usableFromInline
  internal let _predicate: (Swift.LazyPrefixWhileSequence<Base>.Element) -> Swift.Bool
}
extension LazyPrefixWhileSequence {
  @frozen public struct Iterator {
    public typealias Element = Base.Element
    @usableFromInline
    internal var _predicateHasFailed: Swift.Bool = false
    @usableFromInline
    internal var _base: Base.Iterator
    @usableFromInline
    internal let _predicate: (Swift.LazyPrefixWhileSequence<Base>.Iterator.Element) -> Swift.Bool
    @inlinable internal init(_base: Base.Iterator, predicate: @escaping (Swift.LazyPrefixWhileSequence<Base>.Iterator.Element) -> Swift.Bool) {
      self._base = _base
      self._predicate = predicate
    }
  }
}
extension LazyPrefixWhileSequence.Iterator : Swift.IteratorProtocol, Swift.Sequence {
  @inlinable public mutating func next() -> Swift.LazyPrefixWhileSequence<Base>.Iterator.Element? {
    // Return elements from the base iterator until one fails the predicate.
    if !_predicateHasFailed, let nextElement = _base.next() {
      if _predicate(nextElement) {
        return nextElement
      } else {
        _predicateHasFailed = true
      }
    }
    return nil
  }
  public typealias Iterator = Swift.LazyPrefixWhileSequence<Base>.Iterator
}
extension LazyPrefixWhileSequence : Swift.Sequence {
  @inlinable __consuming public func makeIterator() -> Swift.LazyPrefixWhileSequence<Base>.Iterator {
    return Iterator(_base: _base.makeIterator(), predicate: _predicate)
  }
}
extension LazyPrefixWhileSequence : Swift.LazySequenceProtocol {
  public typealias Elements = Swift.LazyPrefixWhileSequence<Base>
}
extension LazySequenceProtocol {
  @inlinable __consuming public func prefix(while predicate: @escaping (Self.Elements.Element) -> Swift.Bool) -> Swift.LazyPrefixWhileSequence<Self.Elements> {
    return LazyPrefixWhileSequence(_base: self.elements, predicate: predicate)
  }
}
public typealias LazyPrefixWhileCollection<T> = Swift.LazyPrefixWhileSequence<T> where T : Swift.Collection
extension Swift.LazyPrefixWhileCollection where Base : Swift.Collection {
  @usableFromInline
  @frozen internal enum _IndexRepresentation {
    case index(Base.Index)
    case pastEnd
  }
  @frozen public struct Index {
    @usableFromInline
    internal let _value: Swift.LazyPrefixWhileSequence<Base>._IndexRepresentation
    @inlinable internal init(_ i: Base.Index) {
      self._value = .index(i)
    }
    @inlinable internal init(endOf: Base) {
      self._value = .pastEnd
    }
  }
}
extension LazyPrefixWhileSequence.Index : Swift.Comparable {
  @inlinable public static func == (lhs: Swift.LazyPrefixWhileCollection<Base>.Index, rhs: Swift.LazyPrefixWhileCollection<Base>.Index) -> Swift.Bool {
    switch (lhs._value, rhs._value) {
    case let (.index(l), .index(r)):
      return l == r
    case (.pastEnd, .pastEnd):
      return true
    case (.pastEnd, .index), (.index, .pastEnd):
      return false
    }
  }
  @inlinable public static func < (lhs: Swift.LazyPrefixWhileCollection<Base>.Index, rhs: Swift.LazyPrefixWhileCollection<Base>.Index) -> Swift.Bool {
    switch (lhs._value, rhs._value) {
    case let (.index(l), .index(r)):
      return l < r
    case (.index, .pastEnd):
      return true
    case (.pastEnd, _):
      return false
    }
  }
}
extension LazyPrefixWhileSequence.Index : Swift.Hashable where Base.Index : Swift.Hashable {
  @inlinable public func hash(into hasher: inout Swift.Hasher) {
    switch _value {
    case .index(let value):
      hasher.combine(value)
    case .pastEnd:
      hasher.combine(Int.max)
    }
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension Swift.LazyPrefixWhileCollection : Swift.Collection where Base : Swift.Collection {
  public typealias SubSequence = Swift.Slice<Swift.LazyPrefixWhileCollection<Base>>
  @inlinable public var startIndex: Swift.LazyPrefixWhileSequence<Base>.Index {
    get {
    return Index(_base.startIndex)
  }
  }
  @inlinable public var endIndex: Swift.LazyPrefixWhileSequence<Base>.Index {
    get {
    // If the first element of `_base` satisfies the predicate, there is at
    // least one element in the lazy collection: Use the explicit `.pastEnd` index.
    if let first = _base.first, _predicate(first) {
      return Index(endOf: _base)
    }

    // `_base` is either empty or `_predicate(_base.first!) == false`. In either
    // case, the lazy collection is empty, so `endIndex == startIndex`.
    return startIndex
  }
  }
  @inlinable public func index(after i: Swift.LazyPrefixWhileSequence<Base>.Index) -> Swift.LazyPrefixWhileSequence<Base>.Index {
    _precondition(i != endIndex, "Can't advance past endIndex")
    guard case .index(let i) = i._value else {
      _preconditionFailure("Invalid index passed to index(after:)")
    }
    let nextIndex = _base.index(after: i)
    guard nextIndex != _base.endIndex && _predicate(_base[nextIndex]) else {
      return Index(endOf: _base)
    }
    return Index(nextIndex)
  }
  @inlinable public subscript(position: Swift.LazyPrefixWhileSequence<Base>.Index) -> Swift.LazyPrefixWhileSequence<Base>.Element {
    get {
    switch position._value {
    case .index(let i):
      return _base[i]
    case .pastEnd:
      _preconditionFailure("Index out of range")
    }
  }
  }
  public typealias Indices = Swift.DefaultIndices<Swift.LazyPrefixWhileSequence<Base>>
}
extension Swift.LazyPrefixWhileCollection : Swift.LazyCollectionProtocol where Base : Swift.Collection {
}
extension Swift.LazyPrefixWhileCollection : Swift.BidirectionalCollection where Base : Swift.BidirectionalCollection {
  @inlinable public func index(before i: Swift.LazyPrefixWhileSequence<Base>.Index) -> Swift.LazyPrefixWhileSequence<Base>.Index {
    switch i._value {
    case .index(let i):
      _precondition(i != _base.startIndex, "Can't move before startIndex")
      return Index(_base.index(before: i))
    case .pastEnd:
      // Look for the position of the last element in a non-empty
      // prefix(while:) collection by searching forward for a predicate
      // failure.

      // Safe to assume that `_base.startIndex != _base.endIndex`; if they
      // were equal, `_base.startIndex` would be used as the `endIndex` of
      // this collection.
      _internalInvariant(!_base.isEmpty)
      var result = _base.startIndex
      while true {
        let next = _base.index(after: result)
        if next == _base.endIndex || !_predicate(_base[next]) {
          break
        }
        result = next
      }
      return Index(result)
    }
  }
}
@usableFromInline
internal func _prespecialize()
public func print(_ items: Any..., separator: Swift.String = " ", terminator: Swift.String = "\n")
public func debugPrint(_ items: Any..., separator: Swift.String = " ", terminator: Swift.String = "\n")
public func print<Target>(_ items: Any..., separator: Swift.String = " ", terminator: Swift.String = "\n", to output: inout Target) where Target : Swift.TextOutputStream
public func debugPrint<Target>(_ items: Any..., separator: Swift.String = " ", terminator: Swift.String = "\n", to output: inout Target) where Target : Swift.TextOutputStream
public protocol RandomNumberGenerator {
  mutating func next() -> Swift.UInt64
}
extension RandomNumberGenerator {
  @inlinable public mutating func next<T>() -> T where T : Swift.FixedWidthInteger, T : Swift.UnsignedInteger {
    return T._random(using: &self)
  }
  @inlinable public mutating func next<T>(upperBound: T) -> T where T : Swift.FixedWidthInteger, T : Swift.UnsignedInteger {
    _precondition(upperBound != 0, "upperBound cannot be zero.")
    var random: T = next()
    var m = random.multipliedFullWidth(by: upperBound)
    if m.low < upperBound {
      let t = (0 &- upperBound) % upperBound
      while m.low < t {
        random = next()
        m = random.multipliedFullWidth(by: upperBound)
      }
    }
    return m.high
  }
}
@frozen public struct SystemRandomNumberGenerator : Swift.RandomNumberGenerator {
  @inlinable public init() { }
  @inlinable public mutating func next() -> Swift.UInt64 {
    var random: UInt64 = 0
    swift_stdlib_random(&random, MemoryLayout<UInt64>.size)
    return random
  }
}
public protocol RandomAccessCollection : Swift.BidirectionalCollection where Self.Indices : Swift.RandomAccessCollection, Self.SubSequence : Swift.RandomAccessCollection {
  override associatedtype Element
  override associatedtype Index
  override associatedtype SubSequence
  override associatedtype Indices
  override var indices: Self.Indices { get }
  override subscript(bounds: Swift.Range<Self.Index>) -> Self.SubSequence { get }
  @_borrowed override subscript(position: Self.Index) -> Self.Element { get }
  override var startIndex: Self.Index { get }
  override var endIndex: Self.Index { get }
  override func index(before i: Self.Index) -> Self.Index
  override func formIndex(before i: inout Self.Index)
  override func index(after i: Self.Index) -> Self.Index
  override func formIndex(after i: inout Self.Index)
  @_nonoverride func index(_ i: Self.Index, offsetBy distance: Swift.Int) -> Self.Index
  @_nonoverride func index(_ i: Self.Index, offsetBy distance: Swift.Int, limitedBy limit: Self.Index) -> Self.Index?
  @_nonoverride func distance(from start: Self.Index, to end: Self.Index) -> Swift.Int
}
extension RandomAccessCollection {
  @inlinable public func index(_ i: Self.Index, offsetBy distance: Swift.Int, limitedBy limit: Self.Index) -> Self.Index? {
    // FIXME: swift-3-indexing-model: tests.
    let l = self.distance(from: i, to: limit)
    if distance > 0 ? l >= 0 && l < distance : l <= 0 && distance < l {
      return nil
    }
    return index(i, offsetBy: distance)
  }
}
extension RandomAccessCollection where Self.Index : Swift.Strideable, Self.Index.Stride == Swift.Int {
  @_implements(Swift.Collection, Indices) public typealias _Default_Indices = Swift.Range<Self.Index>
}
extension RandomAccessCollection where Self.Index : Swift.Strideable, Self.Indices == Swift.Range<Self.Index>, Self.Index.Stride == Swift.Int {
  @inlinable public var indices: Swift.Range<Self.Index> {
    get {
    return startIndex..<endIndex
  }
  }
  @inlinable public func index(after i: Self.Index) -> Self.Index {
    // FIXME: swift-3-indexing-model: tests for the trap.
    _failEarlyRangeCheck(
      i, bounds: Range(uncheckedBounds: (startIndex, endIndex)))
    return i.advanced(by: 1)
  }
  @inlinable public func index(before i: Self.Index) -> Self.Index {
    let result = i.advanced(by: -1)
    // FIXME: swift-3-indexing-model: tests for the trap.
    _failEarlyRangeCheck(
      result, bounds: Range(uncheckedBounds: (startIndex, endIndex)))
    return result
  }
  @inlinable public func index(_ i: Self.Index, offsetBy distance: Self.Index.Stride) -> Self.Index {
    let result = i.advanced(by: distance)
    // This range check is not precise, tighter bounds exist based on `n`.
    // Unfortunately, we would need to perform index manipulation to
    // compute those bounds, which is probably too slow in the general
    // case.
    // FIXME: swift-3-indexing-model: tests for the trap.
    _failEarlyRangeCheck(
      result, bounds: ClosedRange(uncheckedBounds: (startIndex, endIndex)))
    return result
  }
  @inlinable public func distance(from start: Self.Index, to end: Self.Index) -> Self.Index.Stride {
    // FIXME: swift-3-indexing-model: tests for traps.
    _failEarlyRangeCheck(
      start, bounds: ClosedRange(uncheckedBounds: (startIndex, endIndex)))
    _failEarlyRangeCheck(
      end, bounds: ClosedRange(uncheckedBounds: (startIndex, endIndex)))
    return start.distance(to: end)
  }
}
public protocol RangeExpression {
  associatedtype Bound : Swift.Comparable
  func relative<C>(to collection: C) -> Swift.Range<Self.Bound> where C : Swift.Collection, Self.Bound == C.Index
  func contains(_ element: Self.Bound) -> Swift.Bool
}
extension RangeExpression {
  @inlinable public static func ~= (pattern: Self, value: Self.Bound) -> Swift.Bool {
    return pattern.contains(value)
  }
}
@frozen public struct Range<Bound> where Bound : Swift.Comparable {
  public let lowerBound: Bound
  public let upperBound: Bound
  @_alwaysEmitIntoClient @inline(__always) internal init(_uncheckedBounds bounds: (lower: Bound, upper: Bound)) {
    self.lowerBound = bounds.lower
    self.upperBound = bounds.upper
  }
  @inlinable public init(uncheckedBounds bounds: (lower: Bound, upper: Bound)) {
    _debugPrecondition(bounds.lower <= bounds.upper,
      "Range requires lowerBound <= upperBound")
    self.init(_uncheckedBounds: (lower: bounds.lower, upper: bounds.upper))
  }
  @inlinable public func contains(_ element: Bound) -> Swift.Bool {
    return lowerBound <= element && element < upperBound
  }
  @inlinable public var isEmpty: Swift.Bool {
    get {
    return lowerBound == upperBound
  }
  }
}
extension Range : Swift.Sequence where Bound : Swift.Strideable, Bound.Stride : Swift.SignedInteger {
  public typealias Element = Bound
  public typealias Iterator = Swift.IndexingIterator<Swift.Range<Bound>>
}
extension Range : Swift.Collection, Swift.BidirectionalCollection, Swift.RandomAccessCollection where Bound : Swift.Strideable, Bound.Stride : Swift.SignedInteger {
  public typealias Index = Bound
  public typealias Indices = Swift.Range<Bound>
  public typealias SubSequence = Swift.Range<Bound>
  @inlinable public var startIndex: Swift.Range<Bound>.Index {
    get { return lowerBound }
  }
  @inlinable public var endIndex: Swift.Range<Bound>.Index {
    get { return upperBound }
  }
  @inlinable public func index(after i: Swift.Range<Bound>.Index) -> Swift.Range<Bound>.Index {
    _failEarlyRangeCheck(i, bounds: startIndex..<endIndex)

    return i.advanced(by: 1)
  }
  @inlinable public func index(before i: Swift.Range<Bound>.Index) -> Swift.Range<Bound>.Index {
    _precondition(i > lowerBound)
    _precondition(i <= upperBound)

    return i.advanced(by: -1)
  }
  @inlinable public func index(_ i: Swift.Range<Bound>.Index, offsetBy n: Swift.Int) -> Swift.Range<Bound>.Index {
    let r = i.advanced(by: numericCast(n))
    _precondition(r >= lowerBound)
    _precondition(r <= upperBound)
    return r
  }
  @inlinable public func distance(from start: Swift.Range<Bound>.Index, to end: Swift.Range<Bound>.Index) -> Swift.Int {
    return numericCast(start.distance(to: end))
  }
  @inlinable public subscript(bounds: Swift.Range<Swift.Range<Bound>.Index>) -> Swift.Range<Bound> {
    get {
    return bounds
  }
  }
  @inlinable public var indices: Swift.Range<Bound>.Indices {
    get {
    return self
  }
  }
  @inlinable public func _customContainsEquatableElement(_ element: Swift.Range<Bound>.Element) -> Swift.Bool? {
    return lowerBound <= element && element < upperBound
  }
  @inlinable public func _customIndexOfEquatableElement(_ element: Bound) -> Swift.Range<Bound>.Index?? {
    return lowerBound <= element && element < upperBound ? element : nil
  }
  @inlinable public func _customLastIndexOfEquatableElement(_ element: Bound) -> Swift.Range<Bound>.Index?? {
    // The first and last elements are the same because each element is unique.
    return _customIndexOfEquatableElement(element)
  }
  @inlinable public subscript(position: Swift.Range<Bound>.Index) -> Swift.Range<Bound>.Element {
    get {
    // FIXME: swift-3-indexing-model: tests for the range check.
    _debugPrecondition(self.contains(position), "Index out of range")
    return position
  }
  }
}
extension Range where Bound : Swift.Strideable, Bound.Stride : Swift.SignedInteger {
  public init(_ other: Swift.ClosedRange<Bound>)
}
extension Range : Swift.RangeExpression {
  @inlinable public func relative<C>(to collection: C) -> Swift.Range<Bound> where Bound == C.Index, C : Swift.Collection {
    self
  }
}
extension Range {
  @inlinable @inline(__always) public func clamped(to limits: Swift.Range<Bound>) -> Swift.Range<Bound> {
    let lower =         
      limits.lowerBound > self.lowerBound ? limits.lowerBound
          : limits.upperBound < self.lowerBound ? limits.upperBound
          : self.lowerBound
    let upper =
      limits.upperBound < self.upperBound ? limits.upperBound
          : limits.lowerBound > self.upperBound ? limits.lowerBound
          : self.upperBound
    return Range(_uncheckedBounds: (lower: lower, upper: upper))
  }
}
extension Range : Swift.CustomStringConvertible {
  @inlinable public var description: Swift.String {
    get {
    return "\(lowerBound)..<\(upperBound)"
  }
  }
}
extension Range : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
extension Range : Swift.CustomReflectable {
  public var customMirror: Swift.Mirror {
    get
  }
}
extension Range : Swift.Equatable {
  @inlinable public static func == (lhs: Swift.Range<Bound>, rhs: Swift.Range<Bound>) -> Swift.Bool {
    return
      lhs.lowerBound == rhs.lowerBound &&
      lhs.upperBound == rhs.upperBound
  }
}
extension Range : Swift.Hashable where Bound : Swift.Hashable {
  @inlinable public func hash(into hasher: inout Swift.Hasher) {
    hasher.combine(lowerBound)
    hasher.combine(upperBound)
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension Range : Swift.Decodable where Bound : Swift.Decodable {
  public init(from decoder: Swift.Decoder) throws
}
extension Range : Swift.Encodable where Bound : Swift.Encodable {
  public func encode(to encoder: Swift.Encoder) throws
}
@frozen public struct PartialRangeUpTo<Bound> where Bound : Swift.Comparable {
  public let upperBound: Bound
  @inlinable public init(_ upperBound: Bound) { self.upperBound = upperBound }
}
extension PartialRangeUpTo : Swift.RangeExpression {
  @_transparent public func relative<C>(to collection: C) -> Swift.Range<Bound> where Bound == C.Index, C : Swift.Collection {
    return collection.startIndex..<self.upperBound
  }
  @_transparent public func contains(_ element: Bound) -> Swift.Bool {
    return element < upperBound
  }
}
extension PartialRangeUpTo : Swift.Decodable where Bound : Swift.Decodable {
  public init(from decoder: Swift.Decoder) throws
}
extension PartialRangeUpTo : Swift.Encodable where Bound : Swift.Encodable {
  public func encode(to encoder: Swift.Encoder) throws
}
@frozen public struct PartialRangeThrough<Bound> where Bound : Swift.Comparable {
  public let upperBound: Bound
  @inlinable public init(_ upperBound: Bound) { self.upperBound = upperBound }
}
extension PartialRangeThrough : Swift.RangeExpression {
  @_transparent public func relative<C>(to collection: C) -> Swift.Range<Bound> where Bound == C.Index, C : Swift.Collection {
    return collection.startIndex..<collection.index(after: self.upperBound)
  }
  @_transparent public func contains(_ element: Bound) -> Swift.Bool {
    return element <= upperBound
  }
}
extension PartialRangeThrough : Swift.Decodable where Bound : Swift.Decodable {
  public init(from decoder: Swift.Decoder) throws
}
extension PartialRangeThrough : Swift.Encodable where Bound : Swift.Encodable {
  public func encode(to encoder: Swift.Encoder) throws
}
@frozen public struct PartialRangeFrom<Bound> where Bound : Swift.Comparable {
  public let lowerBound: Bound
  @inlinable public init(_ lowerBound: Bound) { self.lowerBound = lowerBound }
}
extension PartialRangeFrom : Swift.RangeExpression {
  @_transparent public func relative<C>(to collection: C) -> Swift.Range<Bound> where Bound == C.Index, C : Swift.Collection {
    return self.lowerBound..<collection.endIndex
  }
  @inlinable public func contains(_ element: Bound) -> Swift.Bool {
    return lowerBound <= element
  }
}
extension PartialRangeFrom : Swift.Sequence where Bound : Swift.Strideable, Bound.Stride : Swift.SignedInteger {
  public typealias Element = Bound
  @frozen public struct Iterator : Swift.IteratorProtocol {
    @usableFromInline
    internal var _current: Bound
    @inlinable public init(_current: Bound) { self._current = _current }
    @inlinable public mutating func next() -> Bound? {
      defer { _current = _current.advanced(by: 1) }
      return _current
    }
    public typealias Element = Bound
  }
  @inlinable __consuming public func makeIterator() -> Swift.PartialRangeFrom<Bound>.Iterator { 
    return Iterator(_current: lowerBound) 
  }
}
extension PartialRangeFrom : Swift.Decodable where Bound : Swift.Decodable {
  public init(from decoder: Swift.Decoder) throws
}
extension PartialRangeFrom : Swift.Encodable where Bound : Swift.Encodable {
  public func encode(to encoder: Swift.Encoder) throws
}
extension Comparable {
  @_transparent public static func ..< (minimum: Self, maximum: Self) -> Swift.Range<Self> {
    _precondition(minimum <= maximum,
      "Range requires lowerBound <= upperBound")
    return Range(_uncheckedBounds: (lower: minimum, upper: maximum))
  }
  @_transparent prefix public static func ..< (maximum: Self) -> Swift.PartialRangeUpTo<Self> {
    _precondition(maximum == maximum,
      "Range cannot have an unordered upper bound.")
    return PartialRangeUpTo(maximum)
  }
  @_transparent prefix public static func ... (maximum: Self) -> Swift.PartialRangeThrough<Self> {
    _precondition(maximum == maximum,
      "Range cannot have an unordered upper bound.")
    return PartialRangeThrough(maximum)
  }
  @_transparent postfix public static func ... (minimum: Self) -> Swift.PartialRangeFrom<Self> {
    _precondition(minimum == minimum,
      "Range cannot have an unordered lower bound.")
    return PartialRangeFrom(minimum)
  }
}
@frozen public enum UnboundedRange_ {
  postfix public static func ... (_: Swift.UnboundedRange_)
}
public typealias UnboundedRange = (Swift.UnboundedRange_) -> ()
extension Collection {
  @inlinable public subscript<R>(r: R) -> Self.SubSequence where R : Swift.RangeExpression, Self.Index == R.Bound {
    get {
    return self[r.relative(to: self)]
  }
  }
  @inlinable public subscript(x: (Swift.UnboundedRange_) -> ()) -> Self.SubSequence {
    get {
    return self[startIndex...]
  }
  }
}
extension MutableCollection {
  @inlinable public subscript<R>(r: R) -> Self.SubSequence where R : Swift.RangeExpression, Self.Index == R.Bound {
    get {
      return self[r.relative(to: self)]
    }
    set {
      self[r.relative(to: self)] = newValue
    }
  }
  @inlinable public subscript(x: (Swift.UnboundedRange_) -> ()) -> Self.SubSequence {
    get {
      return self[startIndex...]
    }
    set {
      self[startIndex...] = newValue
    }
  }
}
extension Range {
  @inlinable public func overlaps(_ other: Swift.Range<Bound>) -> Swift.Bool {
    // Disjoint iff the other range is completely before or after our range.
    // Additionally either `Range` (unlike a `ClosedRange`) could be empty, in
    // which case it is disjoint with everything as overlap is defined as having
    // an element in common.
    let isDisjoint = other.upperBound <= self.lowerBound
      || self.upperBound <= other.lowerBound
      || self.isEmpty || other.isEmpty
    return !isDisjoint
  }
  @inlinable public func overlaps(_ other: Swift.ClosedRange<Bound>) -> Swift.Bool {
    // Disjoint iff the other range is completely before or after our range.
    // Additionally the `Range` (unlike the `ClosedRange`) could be empty, in
    // which case it is disjoint with everything as overlap is defined as having
    // an element in common.
    let isDisjoint = other.upperBound < self.lowerBound
      || self.upperBound <= other.lowerBound
      || self.isEmpty
    return !isDisjoint
  }
}
public typealias CountableRange<Bound> = Swift.Range<Bound> where Bound : Swift.Strideable, Bound.Stride : Swift.SignedInteger
public typealias CountablePartialRangeFrom<Bound> = Swift.PartialRangeFrom<Bound> where Bound : Swift.Strideable, Bound.Stride : Swift.SignedInteger
public protocol RangeReplaceableCollection : Swift.Collection where Self.SubSequence : Swift.RangeReplaceableCollection {
  override associatedtype SubSequence
  init()
  mutating func replaceSubrange<C>(_ subrange: Swift.Range<Self.Index>, with newElements: __owned C) where C : Swift.Collection, Self.Element == C.Element
  mutating func reserveCapacity(_ n: Swift.Int)
  init(repeating repeatedValue: Self.Element, count: Swift.Int)
  init<S>(_ elements: S) where S : Swift.Sequence, Self.Element == S.Element
  mutating func append(_ newElement: __owned Self.Element)
  mutating func append<S>(contentsOf newElements: __owned S) where S : Swift.Sequence, Self.Element == S.Element
  mutating func insert(_ newElement: __owned Self.Element, at i: Self.Index)
  mutating func insert<S>(contentsOf newElements: __owned S, at i: Self.Index) where S : Swift.Collection, Self.Element == S.Element
  @discardableResult
  mutating func remove(at i: Self.Index) -> Self.Element
  mutating func removeSubrange(_ bounds: Swift.Range<Self.Index>)
  mutating func _customRemoveLast() -> Self.Element?
  mutating func _customRemoveLast(_ n: Swift.Int) -> Swift.Bool
  @discardableResult
  mutating func removeFirst() -> Self.Element
  mutating func removeFirst(_ k: Swift.Int)
  mutating func removeAll(keepingCapacity keepCapacity: Swift.Bool)
  mutating func removeAll(where shouldBeRemoved: (Self.Element) throws -> Swift.Bool) rethrows
  @_borrowed override subscript(bounds: Self.Index) -> Self.Element { get }
  override subscript(bounds: Swift.Range<Self.Index>) -> Self.SubSequence { get }
}
extension RangeReplaceableCollection {
  @inlinable public init(repeating repeatedValue: Self.Element, count: Swift.Int) {
    self.init()
    if count != 0 {
      let elements = Repeated(_repeating: repeatedValue, count: count)
      append(contentsOf: elements)
    }
  }
  @inlinable public init<S>(_ elements: S) where S : Swift.Sequence, Self.Element == S.Element {
    self.init()
    append(contentsOf: elements)
  }
  @inlinable public mutating func append(_ newElement: __owned Self.Element) {
    insert(newElement, at: endIndex)
  }
  @inlinable public mutating func append<S>(contentsOf newElements: __owned S) where S : Swift.Sequence, Self.Element == S.Element {

    let approximateCapacity = self.count + newElements.underestimatedCount
    self.reserveCapacity(approximateCapacity)
    for element in newElements {
      append(element)
    }
  }
  @inlinable public mutating func insert(_ newElement: __owned Self.Element, at i: Self.Index) {
    replaceSubrange(i..<i, with: CollectionOfOne(newElement))
  }
  @inlinable public mutating func insert<C>(contentsOf newElements: __owned C, at i: Self.Index) where C : Swift.Collection, Self.Element == C.Element {
    replaceSubrange(i..<i, with: newElements)
  }
  @discardableResult
  @inlinable public mutating func remove(at position: Self.Index) -> Self.Element {
    _precondition(!isEmpty, "Can't remove from an empty collection")
    let result: Element = self[position]
    replaceSubrange(position..<index(after: position), with: EmptyCollection())
    return result
  }
  @inlinable public mutating func removeSubrange(_ bounds: Swift.Range<Self.Index>) {
    replaceSubrange(bounds, with: EmptyCollection())
  }
  @inlinable public mutating func removeFirst(_ k: Swift.Int) {
    if k == 0 { return }
    _precondition(k >= 0, "Number of elements to remove should be non-negative")
    guard let end = index(startIndex, offsetBy: k, limitedBy: endIndex) else {
      _preconditionFailure(
        "Can't remove more items from a collection than it has")
    }
    removeSubrange(startIndex..<end)
  }
  @discardableResult
  @inlinable public mutating func removeFirst() -> Self.Element {
    _precondition(!isEmpty,
      "Can't remove first element from an empty collection")
    let firstElement = first!
    removeFirst(1)
    return firstElement
  }
  @inlinable public mutating func removeAll(keepingCapacity keepCapacity: Swift.Bool = false) {
    if !keepCapacity {
      self = Self()
    }
    else {
      replaceSubrange(startIndex..<endIndex, with: EmptyCollection())
    }
  }
  @inlinable public mutating func reserveCapacity(_ n: Swift.Int) {}
}
extension RangeReplaceableCollection where Self == Self.SubSequence {
  @discardableResult
  @inlinable public mutating func removeFirst() -> Self.Element {
    _precondition(!isEmpty, "Can't remove items from an empty collection")
    let element = first!
    self = self[index(after: startIndex)..<endIndex]
    return element
  }
  @inlinable public mutating func removeFirst(_ k: Swift.Int) {
    if k == 0 { return }
    _precondition(k >= 0, "Number of elements to remove should be non-negative")
    guard let idx = index(startIndex, offsetBy: k, limitedBy: endIndex) else {
      _preconditionFailure(
        "Can't remove more items from a collection than it contains")
    }
    self = self[idx..<endIndex]
  }
}
extension RangeReplaceableCollection {
  @inlinable public mutating func replaceSubrange<C, R>(_ subrange: R, with newElements: __owned C) where C : Swift.Collection, R : Swift.RangeExpression, Self.Element == C.Element, Self.Index == R.Bound {
    self.replaceSubrange(subrange.relative(to: self), with: newElements)
  }
  @inlinable public mutating func removeSubrange<R>(_ bounds: R) where R : Swift.RangeExpression, Self.Index == R.Bound {
    removeSubrange(bounds.relative(to: self))
  }
}
extension RangeReplaceableCollection {
  @inlinable public mutating func _customRemoveLast() -> Self.Element? {
    return nil
  }
  @inlinable public mutating func _customRemoveLast(_ n: Swift.Int) -> Swift.Bool {
    return false
  }
}
extension RangeReplaceableCollection where Self : Swift.BidirectionalCollection, Self == Self.SubSequence {
  @inlinable public mutating func _customRemoveLast() -> Self.Element? {
    let element = last!
    self = self[startIndex..<index(before: endIndex)]
    return element
  }
  @inlinable public mutating func _customRemoveLast(_ n: Swift.Int) -> Swift.Bool {
    guard let end = index(endIndex, offsetBy: -n, limitedBy: startIndex)
    else {
      _preconditionFailure(
        "Can't remove more items from a collection than it contains")
    }
    self = self[startIndex..<end]
    return true
  }
}
extension RangeReplaceableCollection where Self : Swift.BidirectionalCollection {
  @inlinable public mutating func popLast() -> Self.Element? {
    if isEmpty { return nil }
    // duplicate of removeLast logic below, to avoid redundant precondition
    if let result = _customRemoveLast() { return result }
    return remove(at: index(before: endIndex))
  }
  @discardableResult
  @inlinable public mutating func removeLast() -> Self.Element {
    _precondition(!isEmpty, "Can't remove last element from an empty collection")
    // NOTE if you change this implementation, change popLast above as well
    // AND change the tie-breaker implementations in the next extension
    if let result = _customRemoveLast() { return result }
    return remove(at: index(before: endIndex))
  }
  @inlinable public mutating func removeLast(_ k: Swift.Int) {
    if k == 0 { return }
    _precondition(k >= 0, "Number of elements to remove should be non-negative")
    if _customRemoveLast(k) {
      return
    }
    let end = endIndex
    guard let start = index(end, offsetBy: -k, limitedBy: startIndex)
    else {
      _preconditionFailure(
        "Can't remove more items from a collection than it contains")
    }

    removeSubrange(start..<end)
  }
}
extension RangeReplaceableCollection where Self : Swift.BidirectionalCollection, Self == Self.SubSequence {
  @inlinable public mutating func popLast() -> Self.Element? {
    if isEmpty { return nil }
    // duplicate of removeLast logic below, to avoid redundant precondition
    if let result = _customRemoveLast() { return result }
    return remove(at: index(before: endIndex))
  }
  @discardableResult
  @inlinable public mutating func removeLast() -> Self.Element {
    _precondition(!isEmpty, "Can't remove last element from an empty collection")
    // NOTE if you change this implementation, change popLast above as well
    if let result = _customRemoveLast() { return result }
    return remove(at: index(before: endIndex))
  }
  @inlinable public mutating func removeLast(_ k: Swift.Int) {
    if k == 0 { return }
    _precondition(k >= 0, "Number of elements to remove should be non-negative")
    if _customRemoveLast(k) {
      return
    }
    let end = endIndex
    guard let start = index(end, offsetBy: -k, limitedBy: startIndex)
    else {
      _preconditionFailure(
        "Can't remove more items from a collection than it contains")
    }
    removeSubrange(start..<end)
  }
}
extension RangeReplaceableCollection {
  @inlinable public static func + <Other>(lhs: Self, rhs: Other) -> Self where Other : Swift.Sequence, Self.Element == Other.Element {
    var lhs = lhs
    // FIXME: what if lhs is a reference type?  This will mutate it.
    lhs.append(contentsOf: rhs)
    return lhs
  }
  @inlinable public static func + <Other>(lhs: Other, rhs: Self) -> Self where Other : Swift.Sequence, Self.Element == Other.Element {
    var result = Self()
    result.reserveCapacity(rhs.count + lhs.underestimatedCount)
    result.append(contentsOf: lhs)
    result.append(contentsOf: rhs)
    return result
  }
  @inlinable public static func += <Other>(lhs: inout Self, rhs: Other) where Other : Swift.Sequence, Self.Element == Other.Element {
    lhs.append(contentsOf: rhs)
  }
  @inlinable public static func + <Other>(lhs: Self, rhs: Other) -> Self where Other : Swift.RangeReplaceableCollection, Self.Element == Other.Element {
    var lhs = lhs
    // FIXME: what if lhs is a reference type?  This will mutate it.
    lhs.append(contentsOf: rhs)
    return lhs
  }
}
extension RangeReplaceableCollection {
  @available(swift 4.0)
  @inlinable __consuming public func filter(_ isIncluded: (Self.Element) throws -> Swift.Bool) rethrows -> Self {
    var result = Self()
    for element in self where try isIncluded(element) {
      result.append(element)
    }
    return result
  }
}
extension RangeReplaceableCollection where Self : Swift.MutableCollection {
  @inlinable public mutating func removeAll(where shouldBeRemoved: (Self.Element) throws -> Swift.Bool) rethrows {
    let suffixStart = try _halfStablePartition(isSuffixElement: shouldBeRemoved)
    removeSubrange(suffixStart...)
  }
}
extension RangeReplaceableCollection {
  @inlinable public mutating func removeAll(where shouldBeRemoved: (Self.Element) throws -> Swift.Bool) rethrows {
    self = try filter { try !shouldBeRemoved($0) }
  }
}
@frozen public struct Repeated<Element> {
  public let count: Swift.Int
  public let repeatedValue: Element
}
extension Repeated : Swift.RandomAccessCollection {
  public typealias Indices = Swift.Range<Swift.Int>
  public typealias Index = Swift.Int
  @inlinable internal init(_repeating repeatedValue: Element, count: Swift.Int) {
    _precondition(count >= 0, "Repetition count should be non-negative")
    self.count = count
    self.repeatedValue = repeatedValue
  }
  @inlinable public var startIndex: Swift.Repeated<Element>.Index {
    get {
    return 0
  }
  }
  @inlinable public var endIndex: Swift.Repeated<Element>.Index {
    get {
    return count
  }
  }
  @inlinable public subscript(position: Swift.Int) -> Element {
    get {
    _precondition(position >= 0 && position < count, "Index out of range")
    return repeatedValue
  }
  }
  public typealias Iterator = Swift.IndexingIterator<Swift.Repeated<Element>>
  public typealias SubSequence = Swift.Slice<Swift.Repeated<Element>>
}
@inlinable public func repeatElement<T>(_ element: T, count n: Swift.Int) -> Swift.Repeated<T> {
  return Repeated(_repeating: element, count: n)
}
public func _replPrintLiteralString(_ text: Swift.String)
@inline(never) public func _replDebugPrintln<T>(_ value: T)
@frozen public enum Result<Success, Failure> where Failure : Swift.Error {
  case success(Success)
  case failure(Failure)
  @inlinable public func map<NewSuccess>(_ transform: (Success) -> NewSuccess) -> Swift.Result<NewSuccess, Failure> {
    switch self {
    case let .success(success):
      return .success(transform(success))
    case let .failure(failure):
      return .failure(failure)
    }
  }
  @inlinable public func mapError<NewFailure>(_ transform: (Failure) -> NewFailure) -> Swift.Result<Success, NewFailure> where NewFailure : Swift.Error {
    switch self {
    case let .success(success):
      return .success(success)
    case let .failure(failure):
      return .failure(transform(failure))
    }
  }
  @inlinable public func flatMap<NewSuccess>(_ transform: (Success) -> Swift.Result<NewSuccess, Failure>) -> Swift.Result<NewSuccess, Failure> {
    switch self {
    case let .success(success):
      return transform(success)
    case let .failure(failure):
      return .failure(failure)
    }
  }
  @inlinable public func flatMapError<NewFailure>(_ transform: (Failure) -> Swift.Result<Success, NewFailure>) -> Swift.Result<Success, NewFailure> where NewFailure : Swift.Error {
    switch self {
    case let .success(success):
      return .success(success)
    case let .failure(failure):
      return transform(failure)
    }
  }
  @inlinable public func get() throws -> Success {
    switch self {
    case let .success(success):
      return success
    case let .failure(failure):
      throw failure
    }
  }
}
extension Result where Failure == Swift.Error {
  @_transparent public init(catching body: () throws -> Success) {
    do {
      self = .success(try body())
    } catch {
      self = .failure(error)
    }
  }
}
extension Result : Swift.Equatable where Success : Swift.Equatable, Failure : Swift.Equatable {
  public static func == (a: Swift.Result<Success, Failure>, b: Swift.Result<Success, Failure>) -> Swift.Bool
}
extension Result : Swift.Hashable where Success : Swift.Hashable, Failure : Swift.Hashable {
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension MutableCollection where Self : Swift.BidirectionalCollection {
  @inlinable public mutating func reverse() {
    if isEmpty { return }
    var f = startIndex
    var l = index(before: endIndex)
    while f < l {
      swapAt(f, l)
      formIndex(after: &f)
      formIndex(before: &l)
    }
  }
}
@frozen public struct ReversedCollection<Base> where Base : Swift.BidirectionalCollection {
  public let _base: Base
  @inlinable internal init(_base: Base) {
    self._base = _base
  }
}
extension ReversedCollection {
  @frozen public struct Iterator {
    @usableFromInline
    internal let _base: Base
    @usableFromInline
    internal var _position: Base.Index
    @inlinable @inline(__always) public init(_base: Base) {
      self._base = _base
      self._position = _base.endIndex
    }
  }
}
extension ReversedCollection.Iterator : Swift.IteratorProtocol, Swift.Sequence {
  public typealias Element = Base.Element
  @inlinable @inline(__always) public mutating func next() -> Swift.ReversedCollection<Base>.Iterator.Element? {
    guard _fastPath(_position != _base.startIndex) else { return nil }
    _base.formIndex(before: &_position)
    return _base[_position]
  }
  public typealias Iterator = Swift.ReversedCollection<Base>.Iterator
}
extension ReversedCollection : Swift.Sequence {
  public typealias Element = Base.Element
  @inlinable @inline(__always) __consuming public func makeIterator() -> Swift.ReversedCollection<Base>.Iterator {
    return Iterator(_base: _base)
  }
}
extension ReversedCollection {
  @frozen public struct Index {
    public let base: Base.Index
    @inlinable public init(_ base: Base.Index) {
      self.base = base
    }
  }
}
extension ReversedCollection.Index : Swift.Comparable {
  @inlinable public static func == (lhs: Swift.ReversedCollection<Base>.Index, rhs: Swift.ReversedCollection<Base>.Index) -> Swift.Bool {
    // Note ReversedIndex has inverted logic compared to base Base.Index
    return lhs.base == rhs.base
  }
  @inlinable public static func < (lhs: Swift.ReversedCollection<Base>.Index, rhs: Swift.ReversedCollection<Base>.Index) -> Swift.Bool {
    // Note ReversedIndex has inverted logic compared to base Base.Index
    return lhs.base > rhs.base
  }
}
extension ReversedCollection.Index : Swift.Hashable where Base.Index : Swift.Hashable {
  @inlinable public func hash(into hasher: inout Swift.Hasher) {
    hasher.combine(base)
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension ReversedCollection : Swift.BidirectionalCollection {
  @inlinable public var startIndex: Swift.ReversedCollection<Base>.Index {
    get {
    return Index(_base.endIndex)
  }
  }
  @inlinable public var endIndex: Swift.ReversedCollection<Base>.Index {
    get {
    return Index(_base.startIndex)
  }
  }
  @inlinable public func index(after i: Swift.ReversedCollection<Base>.Index) -> Swift.ReversedCollection<Base>.Index {
    return Index(_base.index(before: i.base))
  }
  @inlinable public func index(before i: Swift.ReversedCollection<Base>.Index) -> Swift.ReversedCollection<Base>.Index {
    return Index(_base.index(after: i.base))
  }
  @inlinable public func index(_ i: Swift.ReversedCollection<Base>.Index, offsetBy n: Swift.Int) -> Swift.ReversedCollection<Base>.Index {
    // FIXME: swift-3-indexing-model: `-n` can trap on Int.min.
    return Index(_base.index(i.base, offsetBy: -n))
  }
  @inlinable public func index(_ i: Swift.ReversedCollection<Base>.Index, offsetBy n: Swift.Int, limitedBy limit: Swift.ReversedCollection<Base>.Index) -> Swift.ReversedCollection<Base>.Index? {
    // FIXME: swift-3-indexing-model: `-n` can trap on Int.min.
    return _base.index(i.base, offsetBy: -n, limitedBy: limit.base)
                .map(Index.init)
  }
  @inlinable public func distance(from start: Swift.ReversedCollection<Base>.Index, to end: Swift.ReversedCollection<Base>.Index) -> Swift.Int {
    return _base.distance(from: end.base, to: start.base)
  }
  @inlinable public subscript(position: Swift.ReversedCollection<Base>.Index) -> Swift.ReversedCollection<Base>.Element {
    get {
    return _base[_base.index(before: position.base)]
  }
  }
  public typealias Indices = Swift.DefaultIndices<Swift.ReversedCollection<Base>>
  public typealias SubSequence = Swift.Slice<Swift.ReversedCollection<Base>>
}
extension ReversedCollection : Swift.RandomAccessCollection where Base : Swift.RandomAccessCollection {
}
extension ReversedCollection {
  @available(swift 4.2)
  @inlinable __consuming public func reversed() -> Base {
    return _base
  }
}
extension BidirectionalCollection {
  @inlinable __consuming public func reversed() -> Swift.ReversedCollection<Self> {
    return ReversedCollection(_base: self)
  }
}
@_transparent public func _stdlib_atomicCompareExchangeStrongPtr(object target: Swift.UnsafeMutablePointer<Swift.UnsafeRawPointer?>, expected: Swift.UnsafeMutablePointer<Swift.UnsafeRawPointer?>, desired: Swift.UnsafeRawPointer?) -> Swift.Bool {
  // We use Builtin.Word here because Builtin.RawPointer can't be nil.
  let (oldValue, won) = Builtin.cmpxchg_seqcst_seqcst_Word(
    target._rawValue,
    UInt(bitPattern: expected.pointee)._builtinWordValue,
    UInt(bitPattern: desired)._builtinWordValue)
  expected.pointee = UnsafeRawPointer(bitPattern: Int(oldValue))
  return Bool(won)
}
@_transparent public func _stdlib_atomicCompareExchangeStrongPtr<T>(object target: Swift.UnsafeMutablePointer<Swift.UnsafeMutablePointer<T>>, expected: Swift.UnsafeMutablePointer<Swift.UnsafeMutablePointer<T>>, desired: Swift.UnsafeMutablePointer<T>) -> Swift.Bool {
  let rawTarget = UnsafeMutableRawPointer(target).assumingMemoryBound(
    to: Optional<UnsafeRawPointer>.self)
  let rawExpected = UnsafeMutableRawPointer(expected).assumingMemoryBound(
    to: Optional<UnsafeRawPointer>.self)
  return _stdlib_atomicCompareExchangeStrongPtr(
    object: rawTarget,
    expected: rawExpected,
    desired: UnsafeRawPointer(desired))
}
@_transparent public func _stdlib_atomicCompareExchangeStrongPtr<T>(object target: Swift.UnsafeMutablePointer<Swift.UnsafeMutablePointer<T>?>, expected: Swift.UnsafeMutablePointer<Swift.UnsafeMutablePointer<T>?>, desired: Swift.UnsafeMutablePointer<T>?) -> Swift.Bool {
  let rawTarget = UnsafeMutableRawPointer(target).assumingMemoryBound(
    to: Optional<UnsafeRawPointer>.self)
  let rawExpected = UnsafeMutableRawPointer(expected).assumingMemoryBound(
    to: Optional<UnsafeRawPointer>.self)
  return _stdlib_atomicCompareExchangeStrongPtr(
    object: rawTarget,
    expected: rawExpected,
    desired: UnsafeRawPointer(desired))
}
@discardableResult
@_transparent public func _stdlib_atomicInitializeARCRef(object target: Swift.UnsafeMutablePointer<Swift.AnyObject?>, desired: Swift.AnyObject) -> Swift.Bool {
  var expected: UnsafeRawPointer?
  let desiredPtr = Unmanaged.passRetained(desired).toOpaque()
  let rawTarget = UnsafeMutableRawPointer(target).assumingMemoryBound(
    to: Optional<UnsafeRawPointer>.self)
  let wonRace = _stdlib_atomicCompareExchangeStrongPtr(
    object: rawTarget, expected: &expected, desired: desiredPtr)
  if !wonRace {
    // Some other thread initialized the value.  Balance the retain that we
    // performed on 'desired'.
    Unmanaged.passUnretained(desired).release()
  }
  return wonRace
}
@_transparent public func _stdlib_atomicLoadARCRef(object target: Swift.UnsafeMutablePointer<Swift.AnyObject?>) -> Swift.AnyObject? {
  let value = Builtin.atomicload_seqcst_Word(target._rawValue)
  if let unwrapped = UnsafeRawPointer(bitPattern: Int(value)) {
    return Unmanaged<AnyObject>.fromOpaque(unwrapped).takeUnretainedValue()
  }
  return nil
}
public func _uint64ToString(_ value: Swift.UInt64, radix: Swift.Int64 = 10, uppercase: Swift.Bool = false) -> Swift.String
@inlinable internal func _rawPointerToString(_ value: Builtin.RawPointer) -> Swift.String {
  var result = _uint64ToString(
    UInt64(
      UInt(bitPattern: UnsafeRawPointer(value))),
      radix: 16,
      uppercase: false
    )
  for _ in 0..<(2 * MemoryLayout<UnsafeRawPointer>.size - result.utf16.count) {
    result = "0" + result
  }
  return "0x" + result
}
@usableFromInline
@_fixed_layout @objc @_swift_native_objc_runtime_base(__SwiftNativeNSArrayBase) internal class __SwiftNativeNSArray {
  @inlinable @nonobjc internal init() {}
  @objc @inlinable deinit {}
}
@usableFromInline
@_fixed_layout @objc @_swift_native_objc_runtime_base(__SwiftNativeNSMutableArrayBase) internal class _SwiftNativeNSMutableArray {
  @inlinable @nonobjc internal init() {}
  @objc @inlinable deinit {}
}
@_hasMissingDesignatedInitializers @usableFromInline
@_fixed_layout @objc @_swift_native_objc_runtime_base(__SwiftNativeNSDictionaryBase) internal class __SwiftNativeNSDictionary {
  @objc public init(coder: Swift.AnyObject)
  @objc deinit
}
@_hasMissingDesignatedInitializers @usableFromInline
@_fixed_layout @objc @_swift_native_objc_runtime_base(__SwiftNativeNSSetBase) internal class __SwiftNativeNSSet {
  @objc public init(coder: Swift.AnyObject)
  @objc deinit
}
public func _stdlib_initializeReturnAutoreleased()
extension Hasher {
  @usableFromInline
  @frozen internal struct _State {
    private var v0: Swift.UInt64 = 0x736f6d6570736575
    private var v1: Swift.UInt64 = 0x646f72616e646f6d
    private var v2: Swift.UInt64 = 0x6c7967656e657261
    private var v3: Swift.UInt64 = 0x7465646279746573
    private var v4: Swift.UInt64 = 0
    private var v5: Swift.UInt64 = 0
    private var v6: Swift.UInt64 = 0
    private var v7: Swift.UInt64 = 0
  }
}
public protocol IteratorProtocol {
  associatedtype Element
  mutating func next() -> Self.Element?
}
public protocol Sequence {
  associatedtype Element where Self.Element == Self.Iterator.Element
  associatedtype Iterator : Swift.IteratorProtocol
  __consuming func makeIterator() -> Self.Iterator
  var underestimatedCount: Swift.Int { get }
  func _customContainsEquatableElement(_ element: Self.Element) -> Swift.Bool?
  __consuming func _copyToContiguousArray() -> Swift.ContiguousArray<Self.Element>
  __consuming func _copyContents(initializing ptr: Swift.UnsafeMutableBufferPointer<Self.Element>) -> (Self.Iterator, Swift.UnsafeMutableBufferPointer<Self.Element>.Index)
  func withContiguousStorageIfAvailable<R>(_ body: (Swift.UnsafeBufferPointer<Self.Element>) throws -> R) rethrows -> R?
}
extension Sequence where Self : Swift.IteratorProtocol {
  public typealias _Default_Iterator = Self
}
extension Sequence where Self == Self.Iterator {
  @inlinable __consuming public func makeIterator() -> Self {
    return self
  }
}
@frozen public struct DropFirstSequence<Base> where Base : Swift.Sequence {
  @usableFromInline
  internal let _base: Base
  @usableFromInline
  internal let _limit: Swift.Int
  @inlinable public init(_ base: Base, dropping limit: Swift.Int) {
    _precondition(limit >= 0, 
      "Can't drop a negative number of elements from a sequence")
    _base = base
    _limit = limit
  }
}
extension DropFirstSequence : Swift.Sequence {
  public typealias Element = Base.Element
  public typealias Iterator = Base.Iterator
  public typealias SubSequence = Swift.AnySequence<Swift.DropFirstSequence<Base>.Element>
  @inlinable __consuming public func makeIterator() -> Swift.DropFirstSequence<Base>.Iterator {
    var it = _base.makeIterator()
    var dropped = 0
    while dropped < _limit, it.next() != nil { dropped &+= 1 }
    return it
  }
  @inlinable __consuming public func dropFirst(_ k: Swift.Int) -> Swift.DropFirstSequence<Base> {
    // If this is already a _DropFirstSequence, we need to fold in
    // the current drop count and drop limit so no data is lost.
    //
    // i.e. [1,2,3,4].dropFirst(1).dropFirst(1) should be equivalent to
    // [1,2,3,4].dropFirst(2).
    return DropFirstSequence(_base, dropping: _limit + k)
  }
}
@frozen public struct PrefixSequence<Base> where Base : Swift.Sequence {
  @usableFromInline
  internal var _base: Base
  @usableFromInline
  internal let _maxLength: Swift.Int
  @inlinable public init(_ base: Base, maxLength: Swift.Int) {
    _precondition(maxLength >= 0, "Can't take a prefix of negative length")
    _base = base
    _maxLength = maxLength
  }
}
extension PrefixSequence {
  @frozen public struct Iterator {
    @usableFromInline
    internal var _base: Base.Iterator
    @usableFromInline
    internal var _remaining: Swift.Int
    @inlinable internal init(_ base: Base.Iterator, maxLength: Swift.Int) {
      _base = base
      _remaining = maxLength
    }
  }
}
extension PrefixSequence.Iterator : Swift.IteratorProtocol {
  public typealias Element = Base.Element
  @inlinable public mutating func next() -> Swift.PrefixSequence<Base>.Iterator.Element? {
    if _remaining != 0 {
      _remaining &-= 1
      return _base.next()
    } else {
      return nil
    }
  }
}
extension PrefixSequence : Swift.Sequence {
  @inlinable __consuming public func makeIterator() -> Swift.PrefixSequence<Base>.Iterator {
    return Iterator(_base.makeIterator(), maxLength: _maxLength)
  }
  @inlinable __consuming public func prefix(_ maxLength: Swift.Int) -> Swift.PrefixSequence<Base> {
    let length = Swift.min(maxLength, self._maxLength)
    return PrefixSequence(_base, maxLength: length)
  }
  public typealias Element = Swift.PrefixSequence<Base>.Iterator.Element
}
@frozen public struct DropWhileSequence<Base> where Base : Swift.Sequence {
  public typealias Element = Base.Element
  @usableFromInline
  internal var _iterator: Base.Iterator
  @usableFromInline
  internal var _nextElement: Swift.DropWhileSequence<Base>.Element?
  @inlinable internal init(iterator: Base.Iterator, predicate: (Swift.DropWhileSequence<Base>.Element) throws -> Swift.Bool) rethrows {
    _iterator = iterator
    _nextElement = _iterator.next()
    
    while let x = _nextElement, try predicate(x) {
      _nextElement = _iterator.next()
    }
  }
  @inlinable internal init(_ base: Base, predicate: (Swift.DropWhileSequence<Base>.Element) throws -> Swift.Bool) rethrows {
    self = try DropWhileSequence(iterator: base.makeIterator(), predicate: predicate)
  }
}
extension DropWhileSequence {
  @frozen public struct Iterator {
    @usableFromInline
    internal var _iterator: Base.Iterator
    @usableFromInline
    internal var _nextElement: Swift.DropWhileSequence<Base>.Iterator.Element?
    @inlinable internal init(_ iterator: Base.Iterator, nextElement: Swift.DropWhileSequence<Base>.Iterator.Element?) {
      _iterator = iterator
      _nextElement = nextElement
    }
  }
}
extension DropWhileSequence.Iterator : Swift.IteratorProtocol {
  public typealias Element = Base.Element
  @inlinable public mutating func next() -> Swift.DropWhileSequence<Base>.Iterator.Element? {
    guard let next = _nextElement else { return nil }
    _nextElement = _iterator.next()
    return next
  }
}
extension DropWhileSequence : Swift.Sequence {
  @inlinable public func makeIterator() -> Swift.DropWhileSequence<Base>.Iterator {
    return Iterator(_iterator, nextElement: _nextElement)
  }
  @inlinable __consuming public func drop(while predicate: (Swift.DropWhileSequence<Base>.Element) throws -> Swift.Bool) rethrows -> Swift.DropWhileSequence<Base> {
    guard let x = _nextElement, try predicate(x) else { return self }
    return try DropWhileSequence(iterator: _iterator, predicate: predicate)
  }
}
extension Sequence {
  @inlinable public func map<T>(_ transform: (Self.Element) throws -> T) rethrows -> [T] {
    let initialCapacity = underestimatedCount
    var result = ContiguousArray<T>()
    result.reserveCapacity(initialCapacity)

    var iterator = self.makeIterator()

    // Add elements up to the initial capacity without checking for regrowth.
    for _ in 0..<initialCapacity {
      result.append(try transform(iterator.next()!))
    }
    // Add remaining elements, if any.
    while let element = iterator.next() {
      result.append(try transform(element))
    }
    return Array(result)
  }
  @inlinable __consuming public func filter(_ isIncluded: (Self.Element) throws -> Swift.Bool) rethrows -> [Self.Element] {
    return try _filter(isIncluded)
  }
  @_transparent public func _filter(_ isIncluded: (Self.Element) throws -> Swift.Bool) rethrows -> [Self.Element] {

    var result = ContiguousArray<Element>()

    var iterator = self.makeIterator()

    while let element = iterator.next() {
      if try isIncluded(element) {
        result.append(element)
      }
    }

    return Array(result)
  }
  @inlinable public var underestimatedCount: Swift.Int {
    get {
    return 0
  }
  }
  @inlinable @inline(__always) public func _customContainsEquatableElement(_ element: Self.Iterator.Element) -> Swift.Bool? {
    return nil
  }
  @_semantics("sequence.forEach") @inlinable public func forEach(_ body: (Self.Element) throws -> Swift.Void) rethrows {
    for element in self {
      try body(element)
    }
  }
}
extension Sequence {
  @inlinable public func first(where predicate: (Self.Element) throws -> Swift.Bool) rethrows -> Self.Element? {
    for element in self {
      if try predicate(element) {
        return element
      }
    }
    return nil
  }
}
extension Sequence where Self.Element : Swift.Equatable {
  @inlinable __consuming public func split(separator: Self.Element, maxSplits: Swift.Int = Int.max, omittingEmptySubsequences: Swift.Bool = true) -> [Swift.ArraySlice<Self.Element>] {
    return split(
      maxSplits: maxSplits,
      omittingEmptySubsequences: omittingEmptySubsequences,
      whereSeparator: { $0 == separator })
  }
}
extension Sequence {
  @inlinable __consuming public func split(maxSplits: Swift.Int = Int.max, omittingEmptySubsequences: Swift.Bool = true, whereSeparator isSeparator: (Self.Element) throws -> Swift.Bool) rethrows -> [Swift.ArraySlice<Self.Element>] {
    _precondition(maxSplits >= 0, "Must take zero or more splits")
    let whole = Array(self)
    return try whole.split(
                  maxSplits: maxSplits, 
                  omittingEmptySubsequences: omittingEmptySubsequences, 
                  whereSeparator: isSeparator)
  }
  @inlinable __consuming public func suffix(_ maxLength: Swift.Int) -> [Self.Element] {
    _precondition(maxLength >= 0, "Can't take a suffix of negative length from a sequence")
    guard maxLength != 0 else { return [] }

    // FIXME: <rdar://problem/21885650> Create reusable RingBuffer<T>
    // Put incoming elements into a ring buffer to save space. Once all
    // elements are consumed, reorder the ring buffer into a copy and return it.
    // This saves memory for sequences particularly longer than `maxLength`.
    var ringBuffer = ContiguousArray<Element>()
    ringBuffer.reserveCapacity(Swift.min(maxLength, underestimatedCount))

    var i = 0

    for element in self {
      if ringBuffer.count < maxLength {
        ringBuffer.append(element)
      } else {
        ringBuffer[i] = element
        i = (i + 1) % maxLength
      }
    }

    if i != ringBuffer.startIndex {
      var rotated = ContiguousArray<Element>()
      rotated.reserveCapacity(ringBuffer.count)
      rotated += ringBuffer[i..<ringBuffer.endIndex]
      rotated += ringBuffer[0..<i]
      return Array(rotated)
    } else {
      return Array(ringBuffer)
    }
  }
  @inlinable __consuming public func dropFirst(_ k: Swift.Int = 1) -> Swift.DropFirstSequence<Self> {
    return DropFirstSequence(self, dropping: k)
  }
  @inlinable __consuming public func dropLast(_ k: Swift.Int = 1) -> [Self.Element] {
    _precondition(k >= 0, "Can't drop a negative number of elements from a sequence")
    guard k != 0 else { return Array(self) }

    // FIXME: <rdar://problem/21885650> Create reusable RingBuffer<T>
    // Put incoming elements from this sequence in a holding tank, a ring buffer
    // of size <= k. If more elements keep coming in, pull them out of the
    // holding tank into the result, an `Array`. This saves
    // `k` * sizeof(Element) of memory, because slices keep the entire
    // memory of an `Array` alive.
    var result = ContiguousArray<Element>()
    var ringBuffer = ContiguousArray<Element>()
    var i = ringBuffer.startIndex

    for element in self {
      if ringBuffer.count < k {
        ringBuffer.append(element)
      } else {
        result.append(ringBuffer[i])
        ringBuffer[i] = element
        i = (i + 1) % k
      }
    }
    return Array(result)
  }
  @inlinable __consuming public func drop(while predicate: (Self.Element) throws -> Swift.Bool) rethrows -> Swift.DropWhileSequence<Self> {
    return try DropWhileSequence(self, predicate: predicate)
  }
  @inlinable __consuming public func prefix(_ maxLength: Swift.Int) -> Swift.PrefixSequence<Self> {
    return PrefixSequence(self, maxLength: maxLength)
  }
  @inlinable __consuming public func prefix(while predicate: (Self.Element) throws -> Swift.Bool) rethrows -> [Self.Element] {
    var result = ContiguousArray<Element>()

    for element in self {
      guard try predicate(element) else {
        break
      }
      result.append(element)
    }
    return Array(result)
  }
}
extension Sequence {
  @inlinable __consuming public func _copyContents(initializing buffer: Swift.UnsafeMutableBufferPointer<Self.Element>) -> (Self.Iterator, Swift.UnsafeMutableBufferPointer<Self.Element>.Index) {
    var it = self.makeIterator()
    guard var ptr = buffer.baseAddress else { return (it,buffer.startIndex) }
    for idx in buffer.startIndex..<buffer.count {
      guard let x = it.next() else {
        return (it, idx)
      }
      ptr.initialize(to: x)
      ptr += 1
    }
    return (it,buffer.endIndex)
  }
  @inlinable public func withContiguousStorageIfAvailable<R>(_ body: (Swift.UnsafeBufferPointer<Self.Element>) throws -> R) rethrows -> R? {
    return nil
  }
}
@frozen public struct IteratorSequence<Base> where Base : Swift.IteratorProtocol {
  @usableFromInline
  internal var _base: Base
  @inlinable public init(_ base: Base) {
    _base = base
  }
}
extension IteratorSequence : Swift.IteratorProtocol, Swift.Sequence {
  @inlinable public mutating func next() -> Base.Element? {
    return _base.next()
  }
  public typealias Element = Base.Element
  public typealias Iterator = Swift.IteratorSequence<Base>
}
extension Sequence {
  @inlinable public func enumerated() -> Swift.EnumeratedSequence<Self> {
    return EnumeratedSequence(_base: self)
  }
}
extension Sequence {
  @warn_unqualified_access
  @inlinable public func min(by areInIncreasingOrder: (Self.Element, Self.Element) throws -> Swift.Bool) rethrows -> Self.Element? {
    var it = makeIterator()
    guard var result = it.next() else { return nil }
    while let e = it.next() {
      if try areInIncreasingOrder(e, result) { result = e }
    }
    return result
  }
  @warn_unqualified_access
  @inlinable public func max(by areInIncreasingOrder: (Self.Element, Self.Element) throws -> Swift.Bool) rethrows -> Self.Element? {
    var it = makeIterator()
    guard var result = it.next() else { return nil }
    while let e = it.next() {
      if try areInIncreasingOrder(result, e) { result = e }
    }
    return result
  }
}
extension Sequence where Self.Element : Swift.Comparable {
  @warn_unqualified_access
  @inlinable public func min() -> Self.Element? {
    return self.min(by: <)
  }
  @warn_unqualified_access
  @inlinable public func max() -> Self.Element? {
    return self.max(by: <)
  }
}
extension Sequence {
  @inlinable public func starts<PossiblePrefix>(with possiblePrefix: PossiblePrefix, by areEquivalent: (Self.Element, PossiblePrefix.Element) throws -> Swift.Bool) rethrows -> Swift.Bool where PossiblePrefix : Swift.Sequence {
    var possiblePrefixIterator = possiblePrefix.makeIterator()
    for e0 in self {
      if let e1 = possiblePrefixIterator.next() {
        if try !areEquivalent(e0, e1) {
          return false
        }
      }
      else {
        return true
      }
    }
    return possiblePrefixIterator.next() == nil
  }
}
extension Sequence where Self.Element : Swift.Equatable {
  @inlinable public func starts<PossiblePrefix>(with possiblePrefix: PossiblePrefix) -> Swift.Bool where PossiblePrefix : Swift.Sequence, Self.Element == PossiblePrefix.Element {
    return self.starts(with: possiblePrefix, by: ==)
  }
}
extension Sequence {
  @inlinable public func elementsEqual<OtherSequence>(_ other: OtherSequence, by areEquivalent: (Self.Element, OtherSequence.Element) throws -> Swift.Bool) rethrows -> Swift.Bool where OtherSequence : Swift.Sequence {
    var iter1 = self.makeIterator()
    var iter2 = other.makeIterator()
    while true {
      switch (iter1.next(), iter2.next()) {
      case let (e1?, e2?):
        if try !areEquivalent(e1, e2) {
          return false
        }
      case (_?, nil), (nil, _?): return false
      case (nil, nil):           return true
      }
    }
  }
}
extension Sequence where Self.Element : Swift.Equatable {
  @inlinable public func elementsEqual<OtherSequence>(_ other: OtherSequence) -> Swift.Bool where OtherSequence : Swift.Sequence, Self.Element == OtherSequence.Element {
    return self.elementsEqual(other, by: ==)
  }
}
extension Sequence {
  @inlinable public func lexicographicallyPrecedes<OtherSequence>(_ other: OtherSequence, by areInIncreasingOrder: (Self.Element, Self.Element) throws -> Swift.Bool) rethrows -> Swift.Bool where OtherSequence : Swift.Sequence, Self.Element == OtherSequence.Element {
    var iter1 = self.makeIterator()
    var iter2 = other.makeIterator()
    while true {
      if let e1 = iter1.next() {
        if let e2 = iter2.next() {
          if try areInIncreasingOrder(e1, e2) {
            return true
          }
          if try areInIncreasingOrder(e2, e1) {
            return false
          }
          continue // Equivalent
        }
        return false
      }

      return iter2.next() != nil
    }
  }
}
extension Sequence where Self.Element : Swift.Comparable {
  @inlinable public func lexicographicallyPrecedes<OtherSequence>(_ other: OtherSequence) -> Swift.Bool where OtherSequence : Swift.Sequence, Self.Element == OtherSequence.Element {
    return self.lexicographicallyPrecedes(other, by: <)
  }
}
extension Sequence {
  @inlinable public func contains(where predicate: (Self.Element) throws -> Swift.Bool) rethrows -> Swift.Bool {
    for e in self {
      if try predicate(e) {
        return true
      }
    }
    return false
  }
  @inlinable public func allSatisfy(_ predicate: (Self.Element) throws -> Swift.Bool) rethrows -> Swift.Bool {
    return try !contains { try !predicate($0) }
  }
}
extension Sequence where Self.Element : Swift.Equatable {
  @inlinable public func contains(_ element: Self.Element) -> Swift.Bool {
    if let result = _customContainsEquatableElement(element) {
      return result
    } else {
      return self.contains { $0 == element }
    }
  }
}
extension Sequence {
  @inlinable public func reduce<Result>(_ initialResult: Result, _ nextPartialResult: (Result, Self.Element) throws -> Result) rethrows -> Result {
    var accumulator = initialResult
    for element in self {
      accumulator = try nextPartialResult(accumulator, element)
    }
    return accumulator
  }
  @inlinable public func reduce<Result>(into initialResult: __owned Result, _ updateAccumulatingResult: (inout Result, Self.Element) throws -> ()) rethrows -> Result {
    var accumulator = initialResult
    for element in self {
      try updateAccumulatingResult(&accumulator, element)
    }
    return accumulator
  }
}
extension Sequence {
  @inlinable __consuming public func reversed() -> [Self.Element] {
    // FIXME(performance): optimize to 1 pass?  But Array(self) can be
    // optimized to a memcpy() sometimes.  Those cases are usually collections,
    // though.
    var result = Array(self)
    let count = result.count
    for i in 0..<count/2 {
      result.swapAt(i, count - ((i + 1) as Int))
    }
    return result
  }
}
extension Sequence {
  @inlinable public func flatMap<SegmentOfResult>(_ transform: (Self.Element) throws -> SegmentOfResult) rethrows -> [SegmentOfResult.Element] where SegmentOfResult : Swift.Sequence {
    var result: [SegmentOfResult.Element] = []
    for element in self {
      result.append(contentsOf: try transform(element))
    }
    return result
  }
}
extension Sequence {
  @inlinable public func compactMap<ElementOfResult>(_ transform: (Self.Element) throws -> ElementOfResult?) rethrows -> [ElementOfResult] {
    return try _compactMap(transform)
  }
  @inlinable @inline(__always) public func _compactMap<ElementOfResult>(_ transform: (Self.Element) throws -> ElementOfResult?) rethrows -> [ElementOfResult] {
    var result: [ElementOfResult] = []
    for element in self {
      if let newElement = try transform(element) {
        result.append(newElement)
      }
    }
    return result
  }
}
@frozen public struct Set<Element> where Element : Swift.Hashable {
  @usableFromInline
  internal var _variant: Swift.Set<Element>._Variant
  public init(minimumCapacity: Swift.Int)
  @inlinable internal init(_native: __owned Swift._NativeSet<Element>) {
    _variant = _Variant(native: _native)
  }
  @inlinable internal init(_cocoa: __owned Swift.__CocoaSet) {
    _variant = _Variant(cocoa: _cocoa)
  }
  @inlinable public init(_immutableCocoaSet: __owned Swift.AnyObject) {
    _internalInvariant(_isBridgedVerbatimToObjectiveC(Element.self),
      "Set can be backed by NSSet _variant only when the member type can be bridged verbatim to Objective-C")
    self.init(_cocoa: __CocoaSet(_immutableCocoaSet))
  }
}
extension Set : Swift.ExpressibleByArrayLiteral {
  @inlinable public init(arrayLiteral elements: Element...) {
    if elements.isEmpty {
      self.init()
      return
    }
    let native = _NativeSet<Element>(capacity: elements.count)
    for element in elements {
      let (bucket, found) = native.find(element)
      if found {
        // FIXME: Shouldn't this trap?
        continue
      }
      native._unsafeInsertNew(element, at: bucket)
    }
    self.init(_native: native)
  }
  public typealias ArrayLiteralElement = Element
}
extension Set : Swift.Sequence {
  @inlinable @inline(__always) __consuming public func makeIterator() -> Swift.Set<Element>.Iterator {
    return _variant.makeIterator()
  }
  @inlinable public func contains(_ member: Element) -> Swift.Bool {
    return _variant.contains(member)
  }
  @inlinable @inline(__always) public func _customContainsEquatableElement(_ member: Element) -> Swift.Bool? {
    return contains(member)
  }
}
extension Set {
  @available(swift 4.0)
  @inlinable __consuming public func filter(_ isIncluded: (Element) throws -> Swift.Bool) rethrows -> Swift.Set<Element> {
    // FIXME(performance): Eliminate rehashes by using a bitmap.
    var result = Set()
    for element in self {
      if try isIncluded(element) {
        result.insert(element)
      }
    }
    return result
  }
}
extension Set : Swift.Collection {
  @inlinable public var startIndex: Swift.Set<Element>.Index {
    get {
    return _variant.startIndex
  }
  }
  @inlinable public var endIndex: Swift.Set<Element>.Index {
    get {
    return _variant.endIndex
  }
  }
  @inlinable public subscript(position: Swift.Set<Element>.Index) -> Element {
    get {
      return _variant.element(at: position)
    }
  }
  @inlinable public func index(after i: Swift.Set<Element>.Index) -> Swift.Set<Element>.Index {
    return _variant.index(after: i)
  }
  @inlinable public func formIndex(after i: inout Swift.Set<Element>.Index) {
    _variant.formIndex(after: &i)
  }
  @inlinable public func firstIndex(of member: Element) -> Swift.Set<Element>.Index? {
    return _variant.index(for: member)
  }
  @inlinable @inline(__always) public func _customIndexOfEquatableElement(_ member: Element) -> Swift.Set<Element>.Index?? {
    return Optional(firstIndex(of: member))
  }
  @inlinable @inline(__always) public func _customLastIndexOfEquatableElement(_ member: Element) -> Swift.Set<Element>.Index?? {
    // The first and last elements are the same because each element is unique.
    return _customIndexOfEquatableElement(member)
  }
  @inlinable public var count: Swift.Int {
    get {
    return _variant.count
  }
  }
  @inlinable public var isEmpty: Swift.Bool {
    get {
    return count == 0
  }
  }
  public typealias Indices = Swift.DefaultIndices<Swift.Set<Element>>
  public typealias SubSequence = Swift.Slice<Swift.Set<Element>>
}
extension Set : Swift.Equatable {
  @inlinable public static func == (lhs: Swift.Set<Element>, rhs: Swift.Set<Element>) -> Swift.Bool {
    switch (lhs._variant.isNative, rhs._variant.isNative) {
    case (true, true):
      return lhs._variant.asNative.isEqual(to: rhs._variant.asNative)
    case (false, false):
      return lhs._variant.asCocoa.isEqual(to: rhs._variant.asCocoa)
    case (true, false):
      return lhs._variant.asNative.isEqual(to: rhs._variant.asCocoa)
    case (false, true):
      return rhs._variant.asNative.isEqual(to: lhs._variant.asCocoa)
    }
  }
}
extension Set : Swift.Hashable {
  @inlinable public func hash(into hasher: inout Swift.Hasher) {
    // FIXME(ABI)#177: <rdar://problem/18915294> Cache Set<T> hashValue

    // Generate a seed from a snapshot of the hasher.  This makes members' hash
    // values depend on the state of the hasher, which improves hashing
    // quality. (E.g., it makes it possible to resolve collisions by passing in
    // a different hasher.)
    var copy = hasher
    let seed = copy._finalize()

    var hash = 0
    for member in self {
      hash ^= member._rawHashValue(seed: seed)
    }
    hasher.combine(hash)
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension Set : Swift._HasCustomAnyHashableRepresentation {
  __consuming public func _toCustomAnyHashable() -> Swift.AnyHashable?
}
extension Set : Swift.SetAlgebra {
  @discardableResult
  @inlinable public mutating func insert(_ newMember: __owned Element) -> (inserted: Swift.Bool, memberAfterInsert: Element) {
    return _variant.insert(newMember)
  }
  @discardableResult
  @inlinable public mutating func update(with newMember: __owned Element) -> Element? {
    return _variant.update(with: newMember)
  }
  @discardableResult
  @inlinable public mutating func remove(_ member: Element) -> Element? {
    return _variant.remove(member)
  }
  @discardableResult
  @inlinable public mutating func remove(at position: Swift.Set<Element>.Index) -> Element {
    return _variant.remove(at: position)
  }
  @inlinable public mutating func removeAll(keepingCapacity keepCapacity: Swift.Bool = false) {
    _variant.removeAll(keepingCapacity: keepCapacity)
  }
  @discardableResult
  @inlinable public mutating func removeFirst() -> Element {
    _precondition(!isEmpty, "Can't removeFirst from an empty Set")
    return remove(at: startIndex)
  }
  @inlinable public init() {
    self = Set<Element>(_native: _NativeSet())
  }
  @inlinable public init<Source>(_ sequence: __owned Source) where Element == Source.Element, Source : Swift.Sequence {
    self.init(minimumCapacity: sequence.underestimatedCount)
    if let s = sequence as? Set<Element> {
      // If this sequence is actually a native `Set`, then we can quickly
      // adopt its native buffer and let COW handle uniquing only
      // if necessary.
      self._variant = s._variant
    } else {
      for item in sequence {
        insert(item)
      }
    }
  }
  @inlinable public func isSubset<S>(of possibleSuperset: S) -> Swift.Bool where Element == S.Element, S : Swift.Sequence {
    guard !isEmpty else { return true }
    
    let other = Set(possibleSuperset)
    return isSubset(of: other)
  }
  @inlinable public func isStrictSubset<S>(of possibleStrictSuperset: S) -> Swift.Bool where Element == S.Element, S : Swift.Sequence {
    // FIXME: code duplication.
    let other = Set(possibleStrictSuperset)
    return isStrictSubset(of: other)
  }
  @inlinable public func isSuperset<S>(of possibleSubset: __owned S) -> Swift.Bool where Element == S.Element, S : Swift.Sequence {
    for member in possibleSubset {
      if !contains(member) {
        return false
      }
    }
    return true
  }
  @inlinable public func isStrictSuperset<S>(of possibleStrictSubset: S) -> Swift.Bool where Element == S.Element, S : Swift.Sequence {
    let other = Set(possibleStrictSubset)
    return other.isStrictSubset(of: self)
  }
  @inlinable public func isDisjoint<S>(with other: S) -> Swift.Bool where Element == S.Element, S : Swift.Sequence {
    return _isDisjoint(with: other)
  }
  @inlinable __consuming public func union<S>(_ other: __owned S) -> Swift.Set<Element> where Element == S.Element, S : Swift.Sequence {
    var newSet = self
    newSet.formUnion(other)
    return newSet
  }
  @inlinable public mutating func formUnion<S>(_ other: __owned S) where Element == S.Element, S : Swift.Sequence {
    for item in other {
      insert(item)
    }
  }
  @inlinable __consuming public func subtracting<S>(_ other: S) -> Swift.Set<Element> where Element == S.Element, S : Swift.Sequence {
    return self._subtracting(other)
  }
  @inlinable __consuming internal func _subtracting<S>(_ other: S) -> Swift.Set<Element> where Element == S.Element, S : Swift.Sequence {
    var newSet = self
    newSet.subtract(other)
    return newSet
  }
  @inlinable public mutating func subtract<S>(_ other: S) where Element == S.Element, S : Swift.Sequence {
    _subtract(other)
  }
  @inlinable internal mutating func _subtract<S>(_ other: S) where Element == S.Element, S : Swift.Sequence {
    // If self is empty we don't need to iterate over `other` because there's
    // nothing to remove on self.
    guard !isEmpty else { return }

    for item in other {
      remove(item)
    }
  }
  @inlinable __consuming public func intersection<S>(_ other: S) -> Swift.Set<Element> where Element == S.Element, S : Swift.Sequence {
    let otherSet = Set(other)
    return intersection(otherSet)
  }
  @inlinable public mutating func formIntersection<S>(_ other: S) where Element == S.Element, S : Swift.Sequence {
    // Because `intersect` needs to both modify and iterate over
    // the left-hand side, the index may become invalidated during
    // traversal so an intermediate set must be created.
    //
    // FIXME(performance): perform this operation at a lower level
    // to avoid invalidating the index and avoiding a copy.
    let result = self.intersection(other)

    // The result can only have fewer or the same number of elements.
    // If no elements were removed, don't perform a reassignment
    // as this may cause an unnecessary uniquing COW.
    if result.count != count {
      self = result
    }
  }
  @inlinable __consuming public func symmetricDifference<S>(_ other: __owned S) -> Swift.Set<Element> where Element == S.Element, S : Swift.Sequence {
    var newSet = self
    newSet.formSymmetricDifference(other)
    return newSet
  }
  @inlinable public mutating func formSymmetricDifference<S>(_ other: __owned S) where Element == S.Element, S : Swift.Sequence {
    let otherSet = Set(other)
    formSymmetricDifference(otherSet)
  }
}
extension Set : Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible {
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
}
extension Set {
  @inlinable public mutating func subtract(_ other: Swift.Set<Element>) {
    _subtract(other)
  }
  @inlinable public func isSubset(of other: Swift.Set<Element>) -> Swift.Bool {
    guard self.count <= other.count else { return false }
    for member in self {
      if !other.contains(member) {
        return false
      }
    }
    return true
  }
  @inlinable public func isSuperset(of other: Swift.Set<Element>) -> Swift.Bool {
    return other.isSubset(of: self)
  }
  @inlinable public func isDisjoint(with other: Swift.Set<Element>) -> Swift.Bool {
    return _isDisjoint(with: other)
  }
  @inlinable internal func _isDisjoint<S>(with other: S) -> Swift.Bool where Element == S.Element, S : Swift.Sequence {
    guard !isEmpty else { return true }

    for member in other {
      if contains(member) {
        return false
      }
    }
    return true
  }
  @inlinable __consuming public func subtracting(_ other: Swift.Set<Element>) -> Swift.Set<Element> {
    return self._subtracting(other)
  }
  @inlinable public func isStrictSuperset(of other: Swift.Set<Element>) -> Swift.Bool {
    return self.isSuperset(of: other) && self != other
  }
  @inlinable public func isStrictSubset(of other: Swift.Set<Element>) -> Swift.Bool {
    return other.isStrictSuperset(of: self)
  }
  @inlinable __consuming public func intersection(_ other: Swift.Set<Element>) -> Swift.Set<Element> {
    var newSet = Set<Element>()
    for member in self {
      if other.contains(member) {
        newSet.insert(member)
      }
    }
    return newSet
  }
  @inlinable public mutating func formSymmetricDifference(_ other: __owned Swift.Set<Element>) {
    for member in other {
      if contains(member) {
        remove(member)
      } else {
        insert(member)
      }
    }
  }
}
extension Set {
  @frozen public struct Index {
    @usableFromInline
    @frozen internal enum _Variant {
      case native(Swift._HashTable.Index)
      case cocoa(Swift.__CocoaSet.Index)
    }
    @usableFromInline
    internal var _variant: Swift.Set<Element>.Index._Variant
    @inlinable @inline(__always) internal init(_variant: __owned Swift.Set<Element>.Index._Variant) {
      self._variant = _variant
    }
    @inlinable @inline(__always) internal init(_native index: Swift._HashTable.Index) {
      self.init(_variant: .native(index))
    }
    @inlinable @inline(__always) internal init(_cocoa index: __owned Swift.__CocoaSet.Index) {
      self.init(_variant: .cocoa(index))
    }
  }
}
extension Set.Index {
  @usableFromInline
  @_transparent internal var _guaranteedNative: Swift.Bool {
    @_transparent get {
    return _canBeClass(Element.self) == 0
  }
  }
  @usableFromInline
  @_transparent internal func _cocoaPath() {
    if _guaranteedNative {
      _conditionallyUnreachable()
    }
  }
  @inlinable @inline(__always) internal mutating func _isUniquelyReferenced() -> Swift.Bool {
    defer { _fixLifetime(self) }
    var handle = _asCocoa.handleBitPattern
    return handle == 0 || _isUnique_native(&handle)
  }
  @usableFromInline
  @_transparent internal var _isNative: Swift.Bool {
    @_transparent get {
    switch _variant {
    case .native:
      return true
    case .cocoa:
      _cocoaPath()
      return false
    }
  }
  }
  @usableFromInline
  @_transparent internal var _asNative: Swift._HashTable.Index {
    @_transparent get {
    switch _variant {
    case .native(let nativeIndex):
      return nativeIndex
    case .cocoa:
      _preconditionFailure(
        "Attempting to access Set elements using an invalid index")
    }
  }
  }
  @usableFromInline
  internal var _asCocoa: Swift.__CocoaSet.Index {
    @_transparent get {
      switch _variant {
      case .native:
        _preconditionFailure(
          "Attempting to access Set elements using an invalid index")
      case .cocoa(let cocoaIndex):
        return cocoaIndex
      }
    }
    _modify
  }
}
extension Set.Index : Swift.Equatable {
  @inlinable public static func == (lhs: Swift.Set<Element>.Index, rhs: Swift.Set<Element>.Index) -> Swift.Bool {
    switch (lhs._variant, rhs._variant) {
    case (.native(let lhsNative), .native(let rhsNative)):
      return lhsNative == rhsNative
    case (.cocoa(let lhsCocoa), .cocoa(let rhsCocoa)):
      lhs._cocoaPath()
      return lhsCocoa == rhsCocoa
    default:
      _preconditionFailure("Comparing indexes from different sets")
    }
  }
}
extension Set.Index : Swift.Comparable {
  @inlinable public static func < (lhs: Swift.Set<Element>.Index, rhs: Swift.Set<Element>.Index) -> Swift.Bool {
    switch (lhs._variant, rhs._variant) {
    case (.native(let lhsNative), .native(let rhsNative)):
      return lhsNative < rhsNative
    case (.cocoa(let lhsCocoa), .cocoa(let rhsCocoa)):
      lhs._cocoaPath()
      return lhsCocoa < rhsCocoa
    default:
      _preconditionFailure("Comparing indexes from different sets")
    }
  }
}
extension Set.Index : Swift.Hashable {
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension Set {
  @frozen public struct Iterator {
    @usableFromInline
    @frozen internal enum _Variant {
      case native(Swift._NativeSet<Swift.Set<Element>.Iterator.Element>.Iterator)
      case cocoa(Swift.__CocoaSet.Iterator)
    }
    @usableFromInline
    internal var _variant: Swift.Set<Element>.Iterator._Variant
    @inlinable internal init(_variant: __owned Swift.Set<Element>.Iterator._Variant) {
      self._variant = _variant
    }
    @inlinable internal init(_native: __owned Swift._NativeSet<Swift.Set<Element>.Iterator.Element>.Iterator) {
      self.init(_variant: .native(_native))
    }
    @usableFromInline
    internal init(_cocoa: __owned Swift.__CocoaSet.Iterator)
  }
}
extension Set.Iterator {
  @usableFromInline
  @_transparent internal var _guaranteedNative: Swift.Bool {
    @_transparent get {
    return _canBeClass(Element.self) == 0
  }
  }
  @usableFromInline
  @_transparent internal func _cocoaPath() {
    if _guaranteedNative {
      _conditionallyUnreachable()
    }
  }
  @usableFromInline
  @_transparent internal var _isNative: Swift.Bool {
    @_transparent get {
    switch _variant {
    case .native:
      return true
    case .cocoa:
      _cocoaPath()
      return false
    }
  }
  }
  @usableFromInline
  @_transparent internal var _asNative: Swift._NativeSet<Element>.Iterator {
    @_transparent get {
      switch _variant {
      case .native(let nativeIterator):
        return nativeIterator
      case .cocoa:
        _internalInvariantFailure("internal error: does not contain a native index")
      }
    }
    @_transparent set {
      self._variant = .native(newValue)
    }
  }
  @usableFromInline
  @_transparent internal var _asCocoa: Swift.__CocoaSet.Iterator {
    @_transparent get {
      switch _variant {
      case .native:
        _internalInvariantFailure("internal error: does not contain a Cocoa index")
      case .cocoa(let cocoa):
        return cocoa
      }
    }
  }
}
extension Set.Iterator : Swift.IteratorProtocol {
  @inlinable @inline(__always) public mutating func next() -> Element? {
    guard _isNative else {
      guard let cocoaElement = _asCocoa.next() else { return nil }
      return _forceBridgeFromObjectiveC(cocoaElement, Element.self)
    }
    return _asNative.next()
  }
}
extension Set.Iterator : Swift.CustomReflectable {
  public var customMirror: Swift.Mirror {
    get
  }
}
extension Set : Swift.CustomReflectable {
  public var customMirror: Swift.Mirror {
    get
  }
}
extension Set {
  @inlinable public mutating func popFirst() -> Element? {
    guard !isEmpty else { return nil }
    return remove(at: startIndex)
  }
  @inlinable public var capacity: Swift.Int {
    get {
    return _variant.capacity
  }
  }
  public mutating func reserveCapacity(_ minimumCapacity: Swift.Int)
}
public typealias SetIndex<Element> = Swift.Set<Element>.Index where Element : Swift.Hashable
public typealias SetIterator<Element> = Swift.Set<Element>.Iterator where Element : Swift.Hashable
public protocol SetAlgebra : Swift.Equatable, Swift.ExpressibleByArrayLiteral {
  associatedtype Element
  init()
  func contains(_ member: Self.Element) -> Swift.Bool
  __consuming func union(_ other: __owned Self) -> Self
  __consuming func intersection(_ other: Self) -> Self
  __consuming func symmetricDifference(_ other: __owned Self) -> Self
  @discardableResult
  mutating func insert(_ newMember: __owned Self.Element) -> (inserted: Swift.Bool, memberAfterInsert: Self.Element)
  @discardableResult
  mutating func remove(_ member: Self.Element) -> Self.Element?
  @discardableResult
  mutating func update(with newMember: __owned Self.Element) -> Self.Element?
  mutating func formUnion(_ other: __owned Self)
  mutating func formIntersection(_ other: Self)
  mutating func formSymmetricDifference(_ other: __owned Self)
  __consuming func subtracting(_ other: Self) -> Self
  func isSubset(of other: Self) -> Swift.Bool
  func isDisjoint(with other: Self) -> Swift.Bool
  func isSuperset(of other: Self) -> Swift.Bool
  var isEmpty: Swift.Bool { get }
  init<S>(_ sequence: __owned S) where S : Swift.Sequence, Self.Element == S.Element
  mutating func subtract(_ other: Self)
}
extension SetAlgebra {
  @inlinable public init<S>(_ sequence: __owned S) where S : Swift.Sequence, Self.Element == S.Element {
    self.init()
    // Needed to fully optimize OptionSet literals.
    _onFastPath()
    for e in sequence { insert(e) }
  }
  @inlinable public mutating func subtract(_ other: Self) {
    self.formIntersection(self.symmetricDifference(other))
  }
  @inlinable public func isSubset(of other: Self) -> Swift.Bool {
    return self.intersection(other) == self
  }
  @inlinable public func isSuperset(of other: Self) -> Swift.Bool {
    return other.isSubset(of: self)
  }
  @inlinable public func isDisjoint(with other: Self) -> Swift.Bool {
    return self.intersection(other).isEmpty
  }
  @inlinable public func subtracting(_ other: Self) -> Self {
    return self.intersection(self.symmetricDifference(other))
  }
  @inlinable public var isEmpty: Swift.Bool {
    get {
    return self == Self()
  }
  }
  @inlinable public func isStrictSuperset(of other: Self) -> Swift.Bool {
    return self.isSuperset(of: other) && self != other
  }
  @inlinable public func isStrictSubset(of other: Self) -> Swift.Bool {
    return other.isStrictSuperset(of: self)
  }
}
extension SetAlgebra where Self.ArrayLiteralElement == Self.Element {
  @inlinable public init(arrayLiteral: Self.Element...) {
    self.init(arrayLiteral)
  }
}
extension Set where Element == Swift.AnyHashable {
  @inlinable public mutating func insert<ConcreteElement>(_ newMember: __owned ConcreteElement) -> (inserted: Swift.Bool, memberAfterInsert: ConcreteElement) where ConcreteElement : Swift.Hashable {
    let (inserted, memberAfterInsert) =
      insert(AnyHashable(newMember))
    return (
      inserted: inserted,
      memberAfterInsert: memberAfterInsert.base as! ConcreteElement)
  }
  @discardableResult
  @inlinable public mutating func update<ConcreteElement>(with newMember: __owned ConcreteElement) -> ConcreteElement? where ConcreteElement : Swift.Hashable {
    return update(with: AnyHashable(newMember))
      .map { $0.base as! ConcreteElement }
  }
  @discardableResult
  @inlinable public mutating func remove<ConcreteElement>(_ member: ConcreteElement) -> ConcreteElement? where ConcreteElement : Swift.Hashable {
    return remove(AnyHashable(member))
      .map { $0.base as! ConcreteElement }
  }
}
extension _NativeSet {
  @usableFromInline
  __consuming internal func bridged() -> Swift.AnyObject
}
@usableFromInline
@frozen internal struct __CocoaSet {
  @usableFromInline
  internal let object: Swift.AnyObject
  @inlinable internal init(_ object: __owned Swift.AnyObject) {
    self.object = object
  }
}
extension __CocoaSet {
  @usableFromInline
  @_effects(releasenone) internal func member(for index: Swift.__CocoaSet.Index) -> Swift.AnyObject
  @usableFromInline
  internal func member(for element: Swift.AnyObject) -> Swift.AnyObject?
}
extension __CocoaSet {
  @usableFromInline
  internal func isEqual(to other: Swift.__CocoaSet) -> Swift.Bool
}
extension __CocoaSet {
  @usableFromInline
  internal typealias Element = Swift.AnyObject
  @usableFromInline
  internal var startIndex: Swift.__CocoaSet.Index {
    @_effects(releasenone) get
  }
  @usableFromInline
  internal var endIndex: Swift.__CocoaSet.Index {
    @_effects(releasenone) get
  }
  @usableFromInline
  @_effects(releasenone) internal func index(after index: Swift.__CocoaSet.Index) -> Swift.__CocoaSet.Index
  @usableFromInline
  internal func formIndex(after index: inout Swift.__CocoaSet.Index, isUnique: Swift.Bool)
  @usableFromInline
  @_effects(releasenone) internal func index(for element: Swift.AnyObject) -> Swift.__CocoaSet.Index?
  @usableFromInline
  internal var count: Swift.Int {
    get
  }
  @usableFromInline
  internal func contains(_ element: Swift.AnyObject) -> Swift.Bool
  @usableFromInline
  @_effects(releasenone) internal func element(at i: Swift.__CocoaSet.Index) -> Swift.AnyObject
}
extension __CocoaSet {
  @usableFromInline
  @frozen internal struct Index {
    internal var _storage: Builtin.BridgeObject
    internal var _offset: Swift.Int
  }
}
extension __CocoaSet.Index {
  @usableFromInline
  internal var handleBitPattern: Swift.UInt {
    @_effects(readonly) get
  }
}
extension __CocoaSet.Index {
  @usableFromInline
  @nonobjc internal var element: Swift.AnyObject {
    @_effects(readonly) get
  }
  @usableFromInline
  @nonobjc internal var age: Swift.Int32 {
    @_effects(releasenone) get
  }
}
extension __CocoaSet.Index : Swift.Equatable {
  @usableFromInline
  @_effects(readonly) internal static func == (lhs: Swift.__CocoaSet.Index, rhs: Swift.__CocoaSet.Index) -> Swift.Bool
}
extension __CocoaSet.Index : Swift.Comparable {
  @usableFromInline
  @_effects(readonly) internal static func < (lhs: Swift.__CocoaSet.Index, rhs: Swift.__CocoaSet.Index) -> Swift.Bool
}
extension __CocoaSet : Swift.Sequence {
  @_hasMissingDesignatedInitializers @usableFromInline
  final internal class Iterator {
    @objc @usableFromInline
    deinit
  }
  @usableFromInline
  __consuming internal func makeIterator() -> Swift.__CocoaSet.Iterator
}
extension __CocoaSet.Iterator : Swift.IteratorProtocol {
  @usableFromInline
  internal typealias Element = Swift.AnyObject
  @usableFromInline
  final internal func next() -> Swift.__CocoaSet.Iterator.Element?
}
extension Set {
  @inlinable __consuming public func _bridgeToObjectiveCImpl() -> Swift.AnyObject {
    guard _variant.isNative else {
      return _variant.asCocoa.object
    }
    return _variant.asNative.bridged()
  }
  public static func _bridgeFromObjectiveCAdoptingNativeStorageOf(_ s: __owned Swift.AnyObject) -> Swift.Set<Element>?
}
@frozen public struct _SetBuilder<Element> where Element : Swift.Hashable {
  @usableFromInline
  internal var _target: Swift._NativeSet<Element>
  @usableFromInline
  internal let _requestedCount: Swift.Int
  @inlinable public init(count: Swift.Int) {
    _target = _NativeSet(capacity: count)
    _requestedCount = count
  }
  @inlinable @inline(__always) public mutating func add(member: Element) {
    _precondition(_target.count < _requestedCount,
      "Can't add more members than promised")
    _target._unsafeInsertNew(member)
  }
  @inlinable __consuming public func take() -> Swift.Set<Element> {
    _precondition(_target.count == _requestedCount,
      "The number of members added does not match the promised count")
    return Set(_native: _target)
  }
}
extension Set {
  @_alwaysEmitIntoClient @inlinable @inline(__always) internal init?<C>(_mapping source: C, allowingDuplicates: Swift.Bool, transform: (C.Element) -> Element?) where C : Swift.Collection {
    var target = _NativeSet<Element>(capacity: source.count)
    if allowingDuplicates {
      for m in source {
        guard let member = transform(m) else { return nil }
        target._unsafeUpdate(with: member)
      }
    } else {
      for m in source {
        guard let member = transform(m) else { return nil }
        target._unsafeInsertNew(member)
      }
    }
    self.init(_native: target)
  }
}
@inlinable public func _setUpCast<DerivedValue, BaseValue>(_ source: Swift.Set<DerivedValue>) -> Swift.Set<BaseValue> where DerivedValue : Swift.Hashable, BaseValue : Swift.Hashable {
  return Set(
    _mapping: source,
    // String and NSString have different concepts of equality, so Set<NSString>
    // may generate key collisions when "upcasted" to Set<String>.
    // See rdar://problem/35995647
    allowingDuplicates: (BaseValue.self == String.self)
  ) { member in
    (member as! BaseValue)
  }!
}
@inlinable public func _setDownCast<BaseValue, DerivedValue>(_ source: Swift.Set<BaseValue>) -> Swift.Set<DerivedValue> where BaseValue : Swift.Hashable, DerivedValue : Swift.Hashable {

  if _isClassOrObjCExistential(BaseValue.self)
  && _isClassOrObjCExistential(DerivedValue.self) {
    guard source._variant.isNative else {
      return Set(_immutableCocoaSet: source._variant.asCocoa.object)
    }
    return Set(_immutableCocoaSet: source._variant.asNative.bridged())
  }
  // We can't just delegate to _setDownCastConditional here because we rely on
  // `as!` to generate nice runtime errors when the downcast fails.

  return Set(
    _mapping: source,
    // String and NSString have different concepts of equality, so
    // NSString-keyed Sets may generate key collisions when downcasted
    // to String. See rdar://problem/35995647
    allowingDuplicates: (DerivedValue.self == String.self)
  ) { member in
    (member as! DerivedValue)
  }!
}
@inlinable public func _setDownCastConditional<BaseValue, DerivedValue>(_ source: Swift.Set<BaseValue>) -> Swift.Set<DerivedValue>? where BaseValue : Swift.Hashable, DerivedValue : Swift.Hashable {
  return Set(
    _mapping: source,
    // String and NSString have different concepts of equality, so
    // NSString-keyed Sets may generate key collisions when downcasted
    // to String. See rdar://problem/35995647
    allowingDuplicates: (DerivedValue.self == String.self)
  ) { member in
    member as? DerivedValue
  }
}
@objc @_hasMissingDesignatedInitializers @usableFromInline
@_fixed_layout @_objc_non_lazy_realization internal class __RawSetStorage : Swift.__SwiftNativeNSSet {
  @usableFromInline
  @nonobjc final internal var _count: Swift.Int
  @usableFromInline
  @nonobjc final internal var _capacity: Swift.Int
  @usableFromInline
  @nonobjc final internal var _scale: Swift.Int8
  @usableFromInline
  @nonobjc final internal var _reservedScale: Swift.Int8
  @nonobjc final internal var _extra: Swift.Int16
  @usableFromInline
  @nonobjc final internal var _age: Swift.Int32
  @usableFromInline
  final internal var _seed: Swift.Int
  @usableFromInline
  @nonobjc final internal var _rawElements: Swift.UnsafeMutableRawPointer
  @inlinable @nonobjc final internal var _bucketCount: Swift.Int {
    @inline(__always) get { return 1 &<< _scale }
  }
  @inlinable @nonobjc final internal var _metadata: Swift.UnsafeMutablePointer<Swift._HashTable.Word> {
    @inline(__always) get {
      let address = Builtin.projectTailElems(self, _HashTable.Word.self)
      return UnsafeMutablePointer(address)
    }
  }
  @inlinable @nonobjc final internal var _hashTable: Swift._HashTable {
    @inline(__always) get {
      return _HashTable(words: _metadata, bucketCount: _bucketCount)
    }
  }
  @usableFromInline
  @objc override internal init(coder: Swift.AnyObject)
  @objc @usableFromInline
  deinit
}
@objc @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers @usableFromInline
@_fixed_layout @_objc_non_lazy_realization internal class __EmptySetSingleton : Swift.__RawSetStorage {
  @objc @usableFromInline
  deinit
}
extension __RawSetStorage {
  @inlinable @nonobjc internal static var empty: Swift.__EmptySetSingleton {
    get {
    return Builtin.bridgeFromRawPointer(
      Builtin.addressof(&_swiftEmptySetSingleton))
  }
  }
}
extension __EmptySetSingleton {
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers @usableFromInline
final internal class _SetStorage<Element> : Swift.__RawSetStorage where Element : Swift.Hashable {
  @objc deinit
  @inlinable final internal var _elements: Swift.UnsafeMutablePointer<Element> {
    @inline(__always) get {
      return self._rawElements.assumingMemoryBound(to: Element.self)
    }
  }
}
extension _SetStorage {
  @usableFromInline
  @_effects(releasenone) internal static func copy(original: Swift.__RawSetStorage) -> Swift._SetStorage<Element>
  @usableFromInline
  @_effects(releasenone) internal static func resize(original: Swift.__RawSetStorage, capacity: Swift.Int, move: Swift.Bool) -> Swift._SetStorage<Element>
  @usableFromInline
  @_effects(releasenone) internal static func allocate(capacity: Swift.Int) -> Swift._SetStorage<Element>
  @usableFromInline
  @_effects(releasenone) internal static func convert(_ cocoa: Swift.__CocoaSet, capacity: Swift.Int) -> Swift._SetStorage<Element>
}
extension Set {
  @usableFromInline
  @frozen internal struct _Variant {
    @usableFromInline
    internal var object: Swift._BridgeStorage<Swift.__RawSetStorage>
    @inlinable @inline(__always) internal init(dummy: ()) {
      self.object = _BridgeStorage(taggedPayload: 0)
    }
    @inlinable @inline(__always) internal init(native: __owned Swift._NativeSet<Element>) {
      self.object = _BridgeStorage(native: native._storage)
    }
    @inlinable @inline(__always) internal init(cocoa: __owned Swift.__CocoaSet) {
      self.object = _BridgeStorage(objC: cocoa.object)
    }
  }
}
extension Set._Variant {
  @usableFromInline
  @_transparent internal var guaranteedNative: Swift.Bool {
    @_transparent get {
    return _canBeClass(Element.self) == 0
  }
  }
  @inlinable internal mutating func isUniquelyReferenced() -> Swift.Bool {
    return object.isUniquelyReferencedUnflaggedNative()
  }
  @usableFromInline
  @_transparent internal var isNative: Swift.Bool {
    @_transparent get {
    if guaranteedNative { return true }
    return object.isUnflaggedNative
  }
  }
  @usableFromInline
  @_transparent internal var asNative: Swift._NativeSet<Element> {
    @_transparent get {
      return _NativeSet(object.unflaggedNativeInstance)
    }
    @_transparent set {
      self = .init(native: newValue)
    }
    @_transparent _modify {
      var native = _NativeSet<Element>(object.unflaggedNativeInstance)
      self = .init(dummy: ())
      defer {
        // This is in a defer block because yield might throw, and we need to
        // preserve Set's storage invariants when that happens.
        object = .init(native: native._storage)
      }
      yield &native
    }
  }
  @inlinable internal var asCocoa: Swift.__CocoaSet {
    get {
    return __CocoaSet(object.objCInstance)
  }
  }
  @inlinable internal var capacity: Swift.Int {
    get {
    guard isNative else {
      return asCocoa.count
    }
    return asNative.capacity
  }
  }
}
extension Set._Variant {
  @usableFromInline
  internal typealias Index = Swift.Set<Element>.Index
  @inlinable internal var startIndex: Swift.Set<Element>._Variant.Index {
    get {
    guard isNative else {
      return Index(_cocoa: asCocoa.startIndex)
    }
    return asNative.startIndex
  }
  }
  @inlinable internal var endIndex: Swift.Set<Element>._Variant.Index {
    get {
    guard isNative else {
      return Index(_cocoa: asCocoa.endIndex)
    }
    return asNative.endIndex
  }
  }
  @inlinable internal func index(after index: Swift.Set<Element>._Variant.Index) -> Swift.Set<Element>._Variant.Index {
    guard isNative else {
      return Index(_cocoa: asCocoa.index(after: index._asCocoa))
    }
    return asNative.index(after: index)
  }
  @inlinable internal func formIndex(after index: inout Swift.Set<Element>._Variant.Index) {
    guard isNative else {
      let isUnique = index._isUniquelyReferenced()
      asCocoa.formIndex(after: &index._asCocoa, isUnique: isUnique)
      return
    }
    index = asNative.index(after: index)
  }
  @inlinable @inline(__always) internal func index(for element: Element) -> Swift.Set<Element>._Variant.Index? {
    guard isNative else {
      let cocoaElement = _bridgeAnythingToObjectiveC(element)
      guard let index = asCocoa.index(for: cocoaElement) else { return nil }
      return Index(_cocoa: index)
    }
    return asNative.index(for: element)
  }
  @inlinable internal var count: Swift.Int {
    @inline(__always) get {
      guard isNative else {
        return asCocoa.count
      }
      return asNative.count
    }
  }
  @inlinable @inline(__always) internal func contains(_ member: Element) -> Swift.Bool {
    guard isNative else {
      return asCocoa.contains(_bridgeAnythingToObjectiveC(member))
    }
    return asNative.contains(member)
  }
  @inlinable @inline(__always) internal func element(at index: Swift.Set<Element>._Variant.Index) -> Element {
    guard isNative else {
      let cocoaMember = asCocoa.element(at: index._asCocoa)
      return _forceBridgeFromObjectiveC(cocoaMember, Element.self)
    }
    return asNative.element(at: index)
  }
}
extension Set._Variant {
  @inlinable internal mutating func update(with value: __owned Element) -> Element? {
    guard isNative else {
      // Make sure we have space for an extra element.
      var native = _NativeSet<Element>(asCocoa, capacity: asCocoa.count + 1)
      let old = native.update(with: value, isUnique: true)
      self = .init(native: native)
      return old
    }
    let isUnique = self.isUniquelyReferenced()
    return asNative.update(with: value, isUnique: isUnique)
  }
  @inlinable internal mutating func insert(_ element: __owned Element) -> (inserted: Swift.Bool, memberAfterInsert: Element) {
    guard isNative else {
      // Make sure we have space for an extra element.
      let cocoaMember = _bridgeAnythingToObjectiveC(element)
      let cocoa = asCocoa
      if let m = cocoa.member(for: cocoaMember) {
        return (false, _forceBridgeFromObjectiveC(m, Element.self))
      }
      var native = _NativeSet<Element>(cocoa, capacity: cocoa.count + 1)
      native.insertNew(element, isUnique: true)
      self = .init(native: native)
      return (true, element)
    }
    let (bucket, found) = asNative.find(element)
    if found {
      return (false, asNative.uncheckedElement(at: bucket))
    }
    let isUnique = self.isUniquelyReferenced()
    asNative.insertNew(element, at: bucket, isUnique: isUnique)
    return (true, element)
  }
  @discardableResult
  @inlinable internal mutating func remove(at index: Swift.Set<Element>._Variant.Index) -> Element {
    guard isNative else {
      // We have to migrate the data first.  But after we do so, the Cocoa
      // index becomes useless, so get the element first.
      let cocoa = asCocoa
      let cocoaMember = cocoa.member(for: index._asCocoa)
      let nativeMember = _forceBridgeFromObjectiveC(cocoaMember, Element.self)
      return _migrateToNative(cocoa, removing: nativeMember)
    }
    let isUnique = isUniquelyReferenced()
    let bucket = asNative.validatedBucket(for: index)
    return asNative.uncheckedRemove(at: bucket, isUnique: isUnique)
  }
  @discardableResult
  @inlinable internal mutating func remove(_ member: Element) -> Element? {
    guard isNative else {
      let cocoa = asCocoa
      let cocoaMember = _bridgeAnythingToObjectiveC(member)
      guard cocoa.contains(cocoaMember) else { return nil }
      return _migrateToNative(cocoa, removing: member)
    }
    let (bucket, found) = asNative.find(member)
    guard found else { return nil }
    let isUnique = isUniquelyReferenced()
    return asNative.uncheckedRemove(at: bucket, isUnique: isUnique)
  }
  @inlinable internal mutating func _migrateToNative(_ cocoa: Swift.__CocoaSet, removing member: Element) -> Element {
    // FIXME(performance): fuse data migration and element deletion into one
    // operation.
    var native = _NativeSet<Element>(cocoa)
    let (bucket, found) = native.find(member)
    _precondition(found, "Bridging did not preserve equality")
    let old = native.uncheckedRemove(at: bucket, isUnique: true)
    _precondition(member == old, "Bridging did not preserve equality")
    self = .init(native: native)
    return old
  }
  @inlinable internal mutating func removeAll(keepingCapacity keepCapacity: Swift.Bool) {
    if !keepCapacity {
      self = .init(native: _NativeSet<Element>())
      return
    }
    guard count > 0 else { return }

    guard isNative else {
      self = .init(native: _NativeSet(capacity: asCocoa.count))
      return
    }
    let isUnique = isUniquelyReferenced()
    asNative.removeAll(isUnique: isUnique)
  }
}
extension Set._Variant {
  @inlinable @inline(__always) __consuming internal func makeIterator() -> Swift.Set<Element>.Iterator {
    guard isNative else {
      return Set.Iterator(_cocoa: asCocoa.makeIterator())
    }
    return Set.Iterator(_native: asNative.makeIterator())
  }
}
@inlinable internal func _makeSwiftNSFastEnumerationState() -> SwiftShims._SwiftNSFastEnumerationState {
  return _SwiftNSFastEnumerationState(
    state: 0, itemsPtr: nil, mutationsPtr: nil,
    extra: (0, 0, 0, 0, 0))
}
@usableFromInline
internal var _fastEnumerationStorageMutationsTarget: Swift.CUnsignedLong
@usableFromInline
internal let _fastEnumerationStorageMutationsPtr: Swift.UnsafeMutablePointer<Swift.CUnsignedLong>
@usableFromInline
@_alwaysEmitIntoClient internal func _mallocSize(ofAllocation ptr: Swift.UnsafeRawPointer) -> Swift.Int? {
  return _swift_stdlib_has_malloc_size() ? _swift_stdlib_malloc_size(ptr) : nil
}
@frozen public struct Slice<Base> where Base : Swift.Collection {
  public var _startIndex: Base.Index
  public var _endIndex: Base.Index
  @usableFromInline
  internal var _base: Base
  @inlinable public init(base: Base, bounds: Swift.Range<Base.Index>) {
    self._base = base
    self._startIndex = bounds.lowerBound
    self._endIndex = bounds.upperBound
  }
  @inlinable public var base: Base {
    get {
    return _base
  }
  }
}
extension Slice : Swift.Collection {
  public typealias Index = Base.Index
  public typealias Indices = Base.Indices
  public typealias Element = Base.Element
  public typealias SubSequence = Swift.Slice<Base>
  public typealias Iterator = Swift.IndexingIterator<Swift.Slice<Base>>
  @inlinable public var startIndex: Swift.Slice<Base>.Index {
    get {
    return _startIndex
  }
  }
  @inlinable public var endIndex: Swift.Slice<Base>.Index {
    get {
    return _endIndex
  }
  }
  @inlinable public subscript(index: Swift.Slice<Base>.Index) -> Base.Element {
    get {
      _failEarlyRangeCheck(index, bounds: startIndex..<endIndex)
      return _base[index]
    }
  }
  @inlinable public subscript(bounds: Swift.Range<Swift.Slice<Base>.Index>) -> Swift.Slice<Base> {
    get {
      _failEarlyRangeCheck(bounds, bounds: startIndex..<endIndex)
      return Slice(base: _base, bounds: bounds)
    }
  }
  public var indices: Swift.Slice<Base>.Indices {
    get
  }
  @inlinable public func index(after i: Swift.Slice<Base>.Index) -> Swift.Slice<Base>.Index {
    // FIXME: swift-3-indexing-model: range check.
    return _base.index(after: i)
  }
  @inlinable public func formIndex(after i: inout Swift.Slice<Base>.Index) {
    // FIXME: swift-3-indexing-model: range check.
    _base.formIndex(after: &i)
  }
  @inlinable public func index(_ i: Swift.Slice<Base>.Index, offsetBy n: Swift.Int) -> Swift.Slice<Base>.Index {
    // FIXME: swift-3-indexing-model: range check.
    return _base.index(i, offsetBy: n)
  }
  @inlinable public func index(_ i: Swift.Slice<Base>.Index, offsetBy n: Swift.Int, limitedBy limit: Swift.Slice<Base>.Index) -> Swift.Slice<Base>.Index? {
    // FIXME: swift-3-indexing-model: range check.
    return _base.index(i, offsetBy: n, limitedBy: limit)
  }
  @inlinable public func distance(from start: Swift.Slice<Base>.Index, to end: Swift.Slice<Base>.Index) -> Swift.Int {
    // FIXME: swift-3-indexing-model: range check.
    return _base.distance(from: start, to: end)
  }
  @inlinable public func _failEarlyRangeCheck(_ index: Swift.Slice<Base>.Index, bounds: Swift.Range<Swift.Slice<Base>.Index>) {
    _base._failEarlyRangeCheck(index, bounds: bounds)
  }
  @inlinable public func _failEarlyRangeCheck(_ range: Swift.Range<Swift.Slice<Base>.Index>, bounds: Swift.Range<Swift.Slice<Base>.Index>) {
    _base._failEarlyRangeCheck(range, bounds: bounds)
  }
  @_alwaysEmitIntoClient @inlinable public func withContiguousStorageIfAvailable<R>(_ body: (Swift.UnsafeBufferPointer<Swift.Slice<Base>.Element>) throws -> R) rethrows -> R? {
    try _base.withContiguousStorageIfAvailable { buffer in
      let start = _base.distance(from: _base.startIndex, to: _startIndex)
      let count = _base.distance(from: _startIndex, to: _endIndex)
      let slice = UnsafeBufferPointer(rebasing: buffer[start ..< start + count])
      return try body(slice)
    }
  }
}
extension Slice : Swift.BidirectionalCollection where Base : Swift.BidirectionalCollection {
  @inlinable public func index(before i: Swift.Slice<Base>.Index) -> Swift.Slice<Base>.Index {
    // FIXME: swift-3-indexing-model: range check.
    return _base.index(before: i)
  }
  @inlinable public func formIndex(before i: inout Swift.Slice<Base>.Index) {
    // FIXME: swift-3-indexing-model: range check.
    _base.formIndex(before: &i)
  }
}
extension Slice : Swift.MutableCollection where Base : Swift.MutableCollection {
  @inlinable public subscript(index: Swift.Slice<Base>.Index) -> Base.Element {
    get {
      _failEarlyRangeCheck(index, bounds: startIndex..<endIndex)
      return _base[index]
    }
    set {
      _failEarlyRangeCheck(index, bounds: startIndex..<endIndex)
      _base[index] = newValue
      // MutableSlice requires that the underlying collection's subscript
      // setter does not invalidate indices, so our `startIndex` and `endIndex`
      // continue to be valid.
    }
  }
  @inlinable public subscript(bounds: Swift.Range<Swift.Slice<Base>.Index>) -> Swift.Slice<Base> {
    get {
      _failEarlyRangeCheck(bounds, bounds: startIndex..<endIndex)
      return Slice(base: _base, bounds: bounds)
    }
    set {
      _writeBackMutableSlice(&self, bounds: bounds, slice: newValue)
    }
  }
  @_alwaysEmitIntoClient @inlinable public mutating func withContiguousMutableStorageIfAvailable<R>(_ body: (inout Swift.UnsafeMutableBufferPointer<Swift.Slice<Base>.Element>) throws -> R) rethrows -> R? {
    // We're calling `withContiguousMutableStorageIfAvailable` twice here so
    // that we don't calculate index distances unless we know we'll use them.
    // The expectation here is that the base collection will make itself
    // contiguous on the first try and the second call will be relatively cheap.
    guard _base.withContiguousMutableStorageIfAvailable({ _ in }) != nil
    else {
      return nil
    }
    let start = _base.distance(from: _base.startIndex, to: _startIndex)
    let count = _base.distance(from: _startIndex, to: _endIndex)
    return try _base.withContiguousMutableStorageIfAvailable { buffer in
      var slice = UnsafeMutableBufferPointer(
        rebasing: buffer[start ..< start + count])
      let copy = slice
      defer {
        _precondition(
          slice.baseAddress == copy.baseAddress &&
          slice.count == copy.count,
          "Slice.withUnsafeMutableBufferPointer: replacing the buffer is not allowed")
      }
      return try body(&slice)
    }
  }
}
extension Slice : Swift.RandomAccessCollection where Base : Swift.RandomAccessCollection {
}
extension Slice : Swift.RangeReplaceableCollection where Base : Swift.RangeReplaceableCollection {
  @inlinable public init() {
    self._base = Base()
    self._startIndex = _base.startIndex
    self._endIndex = _base.endIndex
  }
  @inlinable public init(repeating repeatedValue: Base.Element, count: Swift.Int) {
    self._base = Base(repeating: repeatedValue, count: count)
    self._startIndex = _base.startIndex
    self._endIndex = _base.endIndex
  }
  @inlinable public init<S>(_ elements: S) where S : Swift.Sequence, Base.Element == S.Element {
    self._base = Base(elements)
    self._startIndex = _base.startIndex
    self._endIndex = _base.endIndex
  }
  @inlinable public mutating func replaceSubrange<C>(_ subRange: Swift.Range<Swift.Slice<Base>.Index>, with newElements: C) where C : Swift.Collection, Base.Element == C.Element {

    // FIXME: swift-3-indexing-model: range check.
    let sliceOffset =
      _base.distance(from: _base.startIndex, to: _startIndex)
    let newSliceCount =
      _base.distance(from: _startIndex, to: subRange.lowerBound)
      + _base.distance(from: subRange.upperBound, to: _endIndex)
      + newElements.count
    _base.replaceSubrange(subRange, with: newElements)
    _startIndex = _base.index(_base.startIndex, offsetBy: sliceOffset)
    _endIndex = _base.index(_startIndex, offsetBy: newSliceCount)
  }
  @inlinable public mutating func insert(_ newElement: Base.Element, at i: Swift.Slice<Base>.Index) {
    // FIXME: swift-3-indexing-model: range check.
    let sliceOffset = _base.distance(from: _base.startIndex, to: _startIndex)
    let newSliceCount = count + 1
    _base.insert(newElement, at: i)
    _startIndex = _base.index(_base.startIndex, offsetBy: sliceOffset)
    _endIndex = _base.index(_startIndex, offsetBy: newSliceCount)
  }
  @inlinable public mutating func insert<S>(contentsOf newElements: S, at i: Swift.Slice<Base>.Index) where S : Swift.Collection, Base.Element == S.Element {

    // FIXME: swift-3-indexing-model: range check.
    let sliceOffset = _base.distance(from: _base.startIndex, to: _startIndex)
    let newSliceCount = count + newElements.count
    _base.insert(contentsOf: newElements, at: i)
    _startIndex = _base.index(_base.startIndex, offsetBy: sliceOffset)
    _endIndex = _base.index(_startIndex, offsetBy: newSliceCount)
  }
  @inlinable public mutating func remove(at i: Swift.Slice<Base>.Index) -> Base.Element {
    // FIXME: swift-3-indexing-model: range check.
    let sliceOffset = _base.distance(from: _base.startIndex, to: _startIndex)
    let newSliceCount = count - 1
    let result = _base.remove(at: i)
    _startIndex = _base.index(_base.startIndex, offsetBy: sliceOffset)
    _endIndex = _base.index(_startIndex, offsetBy: newSliceCount)
    return result
  }
  @inlinable public mutating func removeSubrange(_ bounds: Swift.Range<Swift.Slice<Base>.Index>) {
    // FIXME: swift-3-indexing-model: range check.
    let sliceOffset = _base.distance(from: _base.startIndex, to: _startIndex)
    let newSliceCount =
      count - distance(from: bounds.lowerBound, to: bounds.upperBound)
    _base.removeSubrange(bounds)
    _startIndex = _base.index(_base.startIndex, offsetBy: sliceOffset)
    _endIndex = _base.index(_startIndex, offsetBy: newSliceCount)
  }
}
extension Slice where Base : Swift.BidirectionalCollection, Base : Swift.RangeReplaceableCollection {
  @inlinable public mutating func replaceSubrange<C>(_ subRange: Swift.Range<Swift.Slice<Base>.Index>, with newElements: C) where C : Swift.Collection, Base.Element == C.Element {
    // FIXME: swift-3-indexing-model: range check.
    if subRange.lowerBound == _base.startIndex {
      let newSliceCount =
        _base.distance(from: _startIndex, to: subRange.lowerBound)
        + _base.distance(from: subRange.upperBound, to: _endIndex)
        + newElements.count
      _base.replaceSubrange(subRange, with: newElements)
      _startIndex = _base.startIndex
      _endIndex = _base.index(_startIndex, offsetBy: newSliceCount)
    } else {
      let shouldUpdateStartIndex = subRange.lowerBound == _startIndex
      let lastValidIndex = _base.index(before: subRange.lowerBound)
      let newEndIndexOffset =
        _base.distance(from: subRange.upperBound, to: _endIndex)
        + newElements.count + 1
      _base.replaceSubrange(subRange, with: newElements)
      if shouldUpdateStartIndex {
        _startIndex = _base.index(after: lastValidIndex)
      }
      _endIndex = _base.index(lastValidIndex, offsetBy: newEndIndexOffset)
    }
  }
  @inlinable public mutating func insert(_ newElement: Base.Element, at i: Swift.Slice<Base>.Index) {
    // FIXME: swift-3-indexing-model: range check.
    if i == _base.startIndex {
      let newSliceCount = count + 1
      _base.insert(newElement, at: i)
      _startIndex = _base.startIndex
      _endIndex = _base.index(_startIndex, offsetBy: newSliceCount)
    } else {
      let shouldUpdateStartIndex = i == _startIndex
      let lastValidIndex = _base.index(before: i)
      let newEndIndexOffset = _base.distance(from: i, to: _endIndex) + 2
      _base.insert(newElement, at: i)
      if shouldUpdateStartIndex {
        _startIndex = _base.index(after: lastValidIndex)
      }
      _endIndex = _base.index(lastValidIndex, offsetBy: newEndIndexOffset)
    }
  }
  @inlinable public mutating func insert<S>(contentsOf newElements: S, at i: Swift.Slice<Base>.Index) where S : Swift.Collection, Base.Element == S.Element {
    // FIXME: swift-3-indexing-model: range check.
    if i == _base.startIndex {
      let newSliceCount = count + newElements.count
      _base.insert(contentsOf: newElements, at: i)
      _startIndex = _base.startIndex
      _endIndex = _base.index(_startIndex, offsetBy: newSliceCount)
    } else {
      let shouldUpdateStartIndex = i == _startIndex
      let lastValidIndex = _base.index(before: i)
      let newEndIndexOffset =
        _base.distance(from: i, to: _endIndex)
        + newElements.count + 1
      _base.insert(contentsOf: newElements, at: i)
      if shouldUpdateStartIndex {
        _startIndex = _base.index(after: lastValidIndex)
      }
      _endIndex = _base.index(lastValidIndex, offsetBy: newEndIndexOffset)
    }
  }
  @inlinable public mutating func remove(at i: Swift.Slice<Base>.Index) -> Base.Element {
    // FIXME: swift-3-indexing-model: range check.
    if i == _base.startIndex {
      let newSliceCount = count - 1
      let result = _base.remove(at: i)
      _startIndex = _base.startIndex
      _endIndex = _base.index(_startIndex, offsetBy: newSliceCount)
      return result
    } else {
      let shouldUpdateStartIndex = i == _startIndex
      let lastValidIndex = _base.index(before: i)
      let newEndIndexOffset = _base.distance(from: i, to: _endIndex)
      let result = _base.remove(at: i)
      if shouldUpdateStartIndex {
        _startIndex = _base.index(after: lastValidIndex)
      }
      _endIndex = _base.index(lastValidIndex, offsetBy: newEndIndexOffset)
      return result
    }
  }
  @inlinable public mutating func removeSubrange(_ bounds: Swift.Range<Swift.Slice<Base>.Index>) {
    // FIXME: swift-3-indexing-model: range check.
    if bounds.lowerBound == _base.startIndex {
      let newSliceCount =
        count - _base.distance(from: bounds.lowerBound, to: bounds.upperBound)
      _base.removeSubrange(bounds)
      _startIndex = _base.startIndex
      _endIndex = _base.index(_startIndex, offsetBy: newSliceCount)
    } else {
      let shouldUpdateStartIndex = bounds.lowerBound == _startIndex
      let lastValidIndex = _base.index(before: bounds.lowerBound)
      let newEndIndexOffset =
          _base.distance(from: bounds.lowerBound, to: _endIndex)
        - _base.distance(from: bounds.lowerBound, to: bounds.upperBound)
        + 1
      _base.removeSubrange(bounds)
      if shouldUpdateStartIndex {
        _startIndex = _base.index(after: lastValidIndex)
      }
      _endIndex = _base.index(lastValidIndex, offsetBy: newEndIndexOffset)
    }
  }
}
@usableFromInline
@frozen internal struct _SmallString {
  @usableFromInline
  internal typealias RawBitPattern = (Swift.UInt64, Swift.UInt64)
  @usableFromInline
  internal var _storage: Swift._SmallString.RawBitPattern
  @inlinable @inline(__always) internal var rawBits: Swift._SmallString.RawBitPattern {
    get { return _storage }
  }
  @inlinable internal var leadingRawBits: Swift.UInt64 {
    @inline(__always) get { return _storage.0 }
    @inline(__always) set { _storage.0 = newValue }
  }
  @inlinable internal var trailingRawBits: Swift.UInt64 {
    @inline(__always) get { return _storage.1 }
    @inline(__always) set { _storage.1 = newValue }
  }
  @inlinable @inline(__always) internal init(rawUnchecked bits: Swift._SmallString.RawBitPattern) {
    self._storage = bits
  }
  @inlinable @inline(__always) internal init(raw bits: Swift._SmallString.RawBitPattern) {
    self.init(rawUnchecked: bits)
    _invariantCheck()
  }
  @inlinable @inline(__always) internal init(_ object: Swift._StringObject) {
    _internalInvariant(object.isSmall)
    // On big-endian platforms the byte order is the reverse of _StringObject.
    let leading = object.rawBits.0.littleEndian
    let trailing = object.rawBits.1.littleEndian
    self.init(raw: (leading, trailing))
  }
  @inlinable @inline(__always) internal init() {
    self.init(_StringObject(empty:()))
  }
}
extension _SmallString {
  @inlinable @inline(__always) internal static var capacity: Swift.Int {
    get {
    return 15
  }
  }
  @inlinable @inline(__always) internal var rawDiscriminatedObject: Swift.UInt64 {
    get {
    // Reverse the bytes on big-endian systems.
    return _storage.1.littleEndian
  }
  }
  @inlinable @inline(__always) internal var capacity: Swift.Int {
    get { return _SmallString.capacity }
  }
  @inlinable @inline(__always) internal var count: Swift.Int {
    get {
    return _StringObject.getSmallCount(fromRaw: rawDiscriminatedObject)
  }
  }
  @inlinable @inline(__always) internal var unusedCapacity: Swift.Int {
    get { return capacity &- count }
  }
  @inlinable @inline(__always) internal var isASCII: Swift.Bool {
    get {
    return _StringObject.getSmallIsASCII(fromRaw: rawDiscriminatedObject)
  }
  }
  @inlinable @inline(__always) internal var zeroTerminatedRawCodeUnits: Swift._SmallString.RawBitPattern {
    get {
    let smallStringCodeUnitMask = ~UInt64(0xFF).bigEndian // zero last byte
    return (self._storage.0, self._storage.1 & smallStringCodeUnitMask)
  }
  }
}
extension _SmallString {
  @inlinable @inline(__always) internal func _invariantCheck() {}
}
extension _SmallString : Swift.RandomAccessCollection, Swift.MutableCollection {
  @usableFromInline
  internal typealias Index = Swift.Int
  @usableFromInline
  internal typealias Element = Swift.UInt8
  @usableFromInline
  internal typealias SubSequence = Swift._SmallString
  @inlinable @inline(__always) internal var startIndex: Swift.Int {
    get { return 0 }
  }
  @inlinable @inline(__always) internal var endIndex: Swift.Int {
    get { return count }
  }
  @inlinable internal subscript(idx: Swift.Int) -> Swift.UInt8 {
    @inline(__always) get {
      _internalInvariant(idx >= 0 && idx <= 15)
      if idx < 8 {
        return leadingRawBits._uncheckedGetByte(at: idx)
      } else {
        return trailingRawBits._uncheckedGetByte(at: idx &- 8)
      }
    }
    @inline(__always) set {
      _internalInvariant(idx >= 0 && idx <= 15)
      if idx < 8 {
        leadingRawBits._uncheckedSetByte(at: idx, to: newValue)
      } else {
        trailingRawBits._uncheckedSetByte(at: idx &- 8, to: newValue)
      }
    }
  }
  @inlinable @inline(__always) internal subscript(bounds: Swift.Range<Swift._SmallString.Index>) -> Swift._SmallString.SubSequence {
    get {
    // TODO(String performance): In-vector-register operation
    return self.withUTF8 { utf8 in
      let rebased = UnsafeBufferPointer(rebasing: utf8[bounds])
      return _SmallString(rebased)._unsafelyUnwrappedUnchecked
    }
  }
  }
  @usableFromInline
  internal typealias Indices = Swift.Range<Swift._SmallString.Index>
  @usableFromInline
  internal typealias Iterator = Swift.IndexingIterator<Swift._SmallString>
}
extension _SmallString {
  @inlinable @inline(__always) internal func withUTF8<Result>(_ f: (Swift.UnsafeBufferPointer<Swift.UInt8>) throws -> Result) rethrows -> Result {
    let count = self.count
    var raw = self.zeroTerminatedRawCodeUnits
    return try Swift.withUnsafeBytes(of: &raw) {
      let rawPtr = $0.baseAddress._unsafelyUnwrappedUnchecked
      // Rebind the underlying (UInt64, UInt64) tuple to UInt8 for the
      // duration of the closure. Accessing self after this rebind is undefined.
      let ptr = rawPtr.bindMemory(to: UInt8.self, capacity: count)
      defer {
        // Restore the memory type of self._storage
        _ = rawPtr.bindMemory(to: RawBitPattern.self, capacity: 1)
      }
      return try f(UnsafeBufferPointer(_uncheckedStart: ptr, count: count))
    }
  }
}
extension _SmallString {
  @inlinable @inline(__always) internal init(leading: Swift.UInt64, trailing: Swift.UInt64, count: Swift.Int) {
    _internalInvariant(count <= _SmallString.capacity)

    let isASCII = (leading | trailing) & 0x8080_8080_8080_8080 == 0
    let discriminator = _StringObject.Nibbles
      .small(withCount: count, isASCII: isASCII)
      .littleEndian // reversed byte order on big-endian platforms
    _internalInvariant(trailing & discriminator == 0)

    self.init(raw: (leading, trailing | discriminator))
    _internalInvariant(self.count == count)
  }
  @inlinable @inline(__always) internal init?(_ input: Swift.UnsafeBufferPointer<Swift.UInt8>) {
    if input.isEmpty {
      self.init()
      return
    }

    let count = input.count
    guard count <= _SmallString.capacity else { return nil }

    // TODO(SIMD): The below can be replaced with just be a masked unaligned
    // vector load
    let ptr = input.baseAddress._unsafelyUnwrappedUnchecked
    let leading = _bytesToUInt64(ptr, Swift.min(input.count, 8))
    let trailing = count > 8 ? _bytesToUInt64(ptr + 8, count &- 8) : 0

    self.init(leading: leading, trailing: trailing, count: count)
  }
  @usableFromInline
  internal init?(_ base: Swift._SmallString, appending other: Swift._SmallString)
}
extension _SmallString {
  @usableFromInline
  @_effects(readonly) internal init(taggedCocoa cocoa: Swift.AnyObject)
}
extension UInt64 {
  @inlinable @inline(__always) internal func _uncheckedGetByte(at i: Swift.Int) -> Swift.UInt8 {
    _internalInvariant(i >= 0 && i < MemoryLayout<UInt64>.stride)
    let shift = UInt64(truncatingIfNeeded: i) &* 8
    return UInt8(truncatingIfNeeded: (self &>> shift))
  }
  @inlinable @inline(__always) internal mutating func _uncheckedSetByte(at i: Swift.Int, to value: Swift.UInt8) {
    _internalInvariant(i >= 0 && i < MemoryLayout<UInt64>.stride)
    let shift = UInt64(truncatingIfNeeded: i) &* 8
    let valueMask: UInt64 = 0xFF &<< shift
    self = (self & ~valueMask) | (UInt64(truncatingIfNeeded: value) &<< shift)
  }
}
@inlinable @inline(__always) internal func _bytesToUInt64(_ input: Swift.UnsafePointer<Swift.UInt8>, _ c: Swift.Int) -> Swift.UInt64 {
  // FIXME: This should be unified with _loadPartialUnalignedUInt64LE.
  // Unfortunately that causes regressions in literal concatenation tests. (Some
  // owned to guaranteed specializations don't get inlined.)
  var r: UInt64 = 0
  var shift: Int = 0
  for idx in 0..<c {
    r = r | (UInt64(input[idx]) &<< shift)
    shift = shift &+ 8
  }
  // Convert from little-endian to host byte order.
  return r.littleEndian
}
extension Sequence where Self.Element : Swift.Comparable {
  @inlinable public func sorted() -> [Self.Element] {
    return sorted(by: <)
  }
}
extension Sequence {
  @inlinable public func sorted(by areInIncreasingOrder: (Self.Element, Self.Element) throws -> Swift.Bool) rethrows -> [Self.Element] {
    var result = ContiguousArray(self)
    try result.sort(by: areInIncreasingOrder)
    return Array(result)
  }
}
extension MutableCollection where Self : Swift.RandomAccessCollection, Self.Element : Swift.Comparable {
  @inlinable public mutating func sort() {
    sort(by: <)
  }
}
extension MutableCollection where Self : Swift.RandomAccessCollection {
  @inlinable public mutating func sort(by areInIncreasingOrder: (Self.Element, Self.Element) throws -> Swift.Bool) rethrows {
    let didSortUnsafeBuffer: Void? = try _withUnsafeMutableBufferPointerIfSupported {
      buffer -> Void in
        try buffer._stableSortImpl(by: areInIncreasingOrder)
    }
    if didSortUnsafeBuffer == nil {
      // Fallback since we can't use an unsafe buffer: sort into an outside
      // array, then copy elements back in.
      let sortedElements = try sorted(by: areInIncreasingOrder)
      for (i, j) in zip(indices, sortedElements.indices) {
        self[i] = sortedElements[j]
      }
    }
  }
}
extension MutableCollection where Self : Swift.BidirectionalCollection {
  @inlinable internal mutating func _insertionSort(within range: Swift.Range<Self.Index>, sortedEnd: Self.Index, by areInIncreasingOrder: (Self.Element, Self.Element) throws -> Swift.Bool) rethrows {
    var sortedEnd = sortedEnd
    
    // Continue sorting until the sorted elements cover the whole sequence.
    while sortedEnd != range.upperBound {
      var i = sortedEnd
      // Look backwards for `self[i]`'s position in the sorted sequence,
      // moving each element forward to make room.
      repeat {
        let j = index(before: i)
        
        // If `self[i]` doesn't belong before `self[j]`, we've found
        // its position.
        if try !areInIncreasingOrder(self[i], self[j]) {
          break
        }
        
        swapAt(i, j)
        i = j
      } while i != range.lowerBound
      
      formIndex(after: &sortedEnd)
    }
  }
  @inlinable public mutating func _insertionSort(within range: Swift.Range<Self.Index>, by areInIncreasingOrder: (Self.Element, Self.Element) throws -> Swift.Bool) rethrows {
    if range.isEmpty {
      return
    }
    
    // One element is trivially already-sorted, so the actual sort can
    // start on the second element.
    let sortedEnd = index(after: range.lowerBound)
    try _insertionSort(
      within: range, sortedEnd: sortedEnd, by: areInIncreasingOrder)
  }
  @inlinable internal mutating func _reverse(within range: Swift.Range<Self.Index>) {
    var f = range.lowerBound
    var l = range.upperBound
    while f < l {
      formIndex(before: &l)
      swapAt(f, l)
      formIndex(after: &f)
    }
  }
}
@inlinable internal func _merge<Element>(low: Swift.UnsafeMutablePointer<Element>, mid: Swift.UnsafeMutablePointer<Element>, high: Swift.UnsafeMutablePointer<Element>, buffer: Swift.UnsafeMutablePointer<Element>, by areInIncreasingOrder: (Element, Element) throws -> Swift.Bool) rethrows -> Swift.Bool {
  let lowCount = mid - low
  let highCount = high - mid
  
  var destLow = low         // Lower bound of uninitialized storage
  var bufferLow = buffer    // Lower bound of the initialized buffer
  var bufferHigh = buffer   // Upper bound of the initialized buffer

  // When we exit the merge, move any remaining elements from the buffer back
  // into `destLow` (aka the collection we're sorting). The buffer can have
  // remaining elements if `areIncreasingOrder` throws, or more likely if the
  // merge runs out of elements from the array before exhausting the buffer.
  defer {
    destLow.moveInitialize(from: bufferLow, count: bufferHigh - bufferLow)
  }
  
  if lowCount < highCount {
    // Move the lower group of elements into the buffer, then traverse from
    // low to high in both the buffer and the higher group of elements.
    //
    // After moving elements, the storage and buffer look like this, where
    // `x` is uninitialized memory:
    //
    // Storage: [x, x, x, x, x, 6, 8, 8, 10, 12, 15]
    //           ^              ^
    //        destLow        srcLow
    //
    // Buffer:  [4, 4, 7, 8, 9, x, ...]
    //           ^              ^
    //        bufferLow     bufferHigh
    buffer.moveInitialize(from: low, count: lowCount)
    bufferHigh = bufferLow + lowCount
    
    var srcLow = mid

    // Each iteration moves the element that compares lower into `destLow`,
    // preferring the buffer when equal to maintain stability. Elements are
    // moved from either `bufferLow` or `srcLow`, with those pointers
    // incrementing as elements are moved.
    while bufferLow < bufferHigh && srcLow < high {
      if try areInIncreasingOrder(srcLow.pointee, bufferLow.pointee) {
        destLow.moveInitialize(from: srcLow, count: 1)
        srcLow += 1
      } else {
        destLow.moveInitialize(from: bufferLow, count: 1)
        bufferLow += 1
      }
      destLow += 1
    }
  } else {
    // Move the higher group of elements into the buffer, then traverse from
    // high to low in both the buffer and the lower group of elements.
    //
    // After moving elements, the storage and buffer look like this, where
    // `x` is uninitialized memory:
    //
    // Storage: [4, 4, 7, 8, 9, 6, x, x,  x,  x,  x]
    //                          ^  ^                 ^
    //                    srcHigh  destLow        destHigh (past the end)
    //
    // Buffer:                    [8, 8, 10, 12, 15, x, ...]
    //                             ^                 ^
    //                          bufferLow        bufferHigh
    buffer.moveInitialize(from: mid, count: highCount)
    bufferHigh = bufferLow + highCount
    
    var destHigh = high
    var srcHigh = mid
    destLow = mid

    // Each iteration moves the element that compares higher into `destHigh`,
    // preferring the buffer when equal to maintain stability. Elements are
    // moved from either `bufferHigh - 1` or `srcHigh - 1`, with those
    // pointers decrementing as elements are moved.
    //
    // Note: At the start of each iteration, each `...High` pointer points one
    // past the element they're referring to.
    while bufferHigh > bufferLow && srcHigh > low {
      destHigh -= 1
      if try areInIncreasingOrder(
        (bufferHigh - 1).pointee, (srcHigh - 1).pointee
      ) {
        srcHigh -= 1
        destHigh.moveInitialize(from: srcHigh, count: 1)
        
        // Moved an element from the lower initialized portion to the upper,
        // sorted, initialized portion, so `destLow` moves down one.
        destLow -= 1
      } else {
        bufferHigh -= 1
        destHigh.moveInitialize(from: bufferHigh, count: 1)
      }
    }
  }

  // FIXME: Remove this, it works around rdar://problem/45044610
  return true
}
@inlinable internal func _minimumMergeRunLength(_ c: Swift.Int) -> Swift.Int {
  // Max out at `2^6 == 64` elements
  let bitsToUse = 6
  
  if c < 1 << bitsToUse {
    return c
  }
  let offset = (Int.bitWidth - bitsToUse) - c.leadingZeroBitCount
  let mask = (1 << offset) - 1
  return c >> offset + (c & mask == 0 ? 0 : 1)
}
@inlinable internal func _findNextRun<C>(in elements: C, from start: C.Index, by areInIncreasingOrder: (C.Element, C.Element) throws -> Swift.Bool) rethrows -> (end: C.Index, descending: Swift.Bool) where C : Swift.RandomAccessCollection {
  _internalInvariant(start < elements.endIndex)

  var previous = start
  var current = elements.index(after: start)
  guard current < elements.endIndex else {
    // This is a one-element run, so treating it as ascending saves a
    // meaningless call to `reverse()`.
    return (current, false)
  }

  // Check whether the run beginning at `start` is ascending or descending.
  // An ascending run can include consecutive equal elements, but because a
  // descending run will be reversed, it must be strictly descending.
  let isDescending =
    try areInIncreasingOrder(elements[current], elements[previous])
  
  // Advance `current` until there's a break in the ascending / descending
  // pattern.
  repeat {
    previous = current
    elements.formIndex(after: &current)
  } while try current < elements.endIndex &&
    isDescending == areInIncreasingOrder(elements[current], elements[previous])
    
  return(current, isDescending)
}
extension UnsafeMutableBufferPointer {
  @inlinable public mutating func _mergeRuns(_ runs: inout [Swift.Range<Swift.UnsafeMutableBufferPointer<Element>.Index>], at i: Swift.Int, buffer: Swift.UnsafeMutablePointer<Element>, by areInIncreasingOrder: (Element, Element) throws -> Swift.Bool) rethrows -> Swift.Bool {
    _internalInvariant(runs[i - 1].upperBound == runs[i].lowerBound)
    let low = runs[i - 1].lowerBound
    let middle = runs[i].lowerBound
    let high = runs[i].upperBound
    
    let result = try _merge(
      low: baseAddress! + low,
      mid: baseAddress! + middle,
      high: baseAddress! + high,
      buffer: buffer,
      by: areInIncreasingOrder)
    
    runs[i - 1] = low..<high
    runs.remove(at: i)

    // FIXME: Remove this, it works around rdar://problem/45044610
    return result
  }
  @inlinable public mutating func _mergeTopRuns(_ runs: inout [Swift.Range<Swift.UnsafeMutableBufferPointer<Element>.Index>], buffer: Swift.UnsafeMutablePointer<Element>, by areInIncreasingOrder: (Element, Element) throws -> Swift.Bool) rethrows -> Swift.Bool {
    // The invariants for the `runs` array are:
    // (a) - for all i in 2..<runs.count:
    //         - runs[i - 2].count > runs[i - 1].count + runs[i].count
    // (b) - for c = runs.count - 1:
    //         - runs[i - 1].count > runs[i].count
    //
    // Loop until the invariant is satisified for the top four elements of
    // `runs`. Because this method is called for every added run, and only
    // the top three runs are ever merged, this guarantees the invariant holds
    // for the whole array.
    //
    // At all times, `runs` is one of the following, where W, X, Y, and Z are
    // the counts of their respective ranges:
    // - [ ...?, W, X, Y, Z ]
    // - [ X, Y, Z ]
    // - [ Y, Z ]
    //
    // If W > X + Y, X > Y + Z, and Y > Z, then the invariants are satisfied
    // for the entirety of `runs`.
    
    // FIXME: Remove this, it works around rdar://problem/45044610
    var result = true

    // The invariant is always in place for a single element.
    while runs.count > 1 {
      var lastIndex = runs.count - 1
      
      // Check for the three invariant-breaking conditions, and break out of
      // the while loop if none are met.
      if lastIndex >= 3 &&
        (runs[lastIndex - 3].count <=
          runs[lastIndex - 2].count + runs[lastIndex - 1].count)
      {
        // Second-to-last three runs do not follow W > X + Y.
        // Always merge Y with the smaller of X or Z.
        if runs[lastIndex - 2].count < runs[lastIndex].count {
          lastIndex -= 1
        }
      } else if lastIndex >= 2 &&
        (runs[lastIndex - 2].count <=
          runs[lastIndex - 1].count + runs[lastIndex].count)
      {
        // Last three runs do not follow X > Y + Z.
        // Always merge Y with the smaller of X or Z.
        if runs[lastIndex - 2].count < runs[lastIndex].count {
          lastIndex -= 1
        }
      } else if runs[lastIndex - 1].count <= runs[lastIndex].count {
        // Last two runs do not follow Y > Z, so merge Y and Z.
        // This block is intentionally blank--the merge happens below.
      } else {
        // All invariants satisfied!
        break
      }
      
      // Merge the runs at `i` and `i - 1`.
      result = try result && _mergeRuns(
        &runs, at: lastIndex, buffer: buffer, by: areInIncreasingOrder)
    }

    return result
  }
  @inlinable public mutating func _finalizeRuns(_ runs: inout [Swift.Range<Swift.UnsafeMutableBufferPointer<Element>.Index>], buffer: Swift.UnsafeMutablePointer<Element>, by areInIncreasingOrder: (Element, Element) throws -> Swift.Bool) rethrows -> Swift.Bool {
    // FIXME: Remove this, it works around rdar://problem/45044610
    var result = true
    while runs.count > 1 {
      result = try result && _mergeRuns(
        &runs, at: runs.count - 1, buffer: buffer, by: areInIncreasingOrder)
    }
    return result
  }
  @inlinable public mutating func _stableSortImpl(by areInIncreasingOrder: (Element, Element) throws -> Swift.Bool) rethrows {
    let minimumRunLength = _minimumMergeRunLength(count)
    if count <= minimumRunLength {
      try _insertionSort(
        within: startIndex..<endIndex, by: areInIncreasingOrder)
      return
    }

    // FIXME: Remove this, it works around rdar://problem/45044610
    var result = true

    // Use array's allocating initializer to create a temporary buffer---this
    // keeps the buffer allocation going through the same tail-allocated path
    // as other allocating methods.
    //
    // There's no need to set the initialized count within the initializing
    // closure, since the buffer is guaranteed to be uninitialized at exit.
    _ = try Array<Element>(_unsafeUninitializedCapacity: count / 2) {
      buffer, _ in
      var runs: [Range<Index>] = []
      
      var start = startIndex
      while start < endIndex {
        // Find the next consecutive run, reversing it if necessary.
        var (end, descending) =
          try _findNextRun(in: self, from: start, by: areInIncreasingOrder)
        if descending {
          _reverse(within: start..<end)
        }
        
        // If the current run is shorter than the minimum length, use the
        // insertion sort to extend it.
        if end < endIndex && end - start < minimumRunLength {
          let newEnd = Swift.min(endIndex, start + minimumRunLength)
          try _insertionSort(
            within: start..<newEnd, sortedEnd: end, by: areInIncreasingOrder)
          end = newEnd
        }
        
        // Append this run and merge down as needed to maintain the `runs`
        // invariants.
        runs.append(start..<end)
        result = try result && _mergeTopRuns(
          &runs, buffer: buffer.baseAddress!, by: areInIncreasingOrder)
        start = end
      }
      
      result = try result && _finalizeRuns(
        &runs, buffer: buffer.baseAddress!, by: areInIncreasingOrder)
      _internalInvariant(runs.count == 1, "Didn't complete final merge")
    }

    // FIXME: Remove this, it works around rdar://problem/45044610
    precondition(result)
  }
}
@frozen public struct StaticString {
  @usableFromInline
  internal var _startPtrOrData: Builtin.Word
  @usableFromInline
  internal var _utf8CodeUnitCount: Builtin.Word
  @usableFromInline
  internal var _flags: Builtin.Int8
  @_transparent public var utf8Start: Swift.UnsafePointer<Swift.UInt8> {
    @_transparent get {
    _precondition(
      hasPointerRepresentation,
      "StaticString should have pointer representation")
    return UnsafePointer(bitPattern: UInt(_startPtrOrData))!
  }
  }
  @_transparent public var unicodeScalar: Swift.Unicode.Scalar {
    @_transparent get {
    _precondition(
      !hasPointerRepresentation,
      "StaticString should have Unicode scalar representation")
    return Unicode.Scalar(UInt32(UInt(_startPtrOrData)))!
  }
  }
  @_transparent public var utf8CodeUnitCount: Swift.Int {
    @_transparent get {
    _precondition(
      hasPointerRepresentation,
      "StaticString should have pointer representation")
    return Int(_utf8CodeUnitCount)
  }
  }
  @_alwaysEmitIntoClient @_transparent internal var unsafeRawPointer: Builtin.RawPointer {
    @_transparent get {
    return Builtin.inttoptr_Word(_startPtrOrData)
  }
  }
  @_transparent public var hasPointerRepresentation: Swift.Bool {
    @_transparent get {
    return (UInt8(_flags) & 0x1) == 0
  }
  }
  @_transparent public var isASCII: Swift.Bool {
    @_transparent get {
    return (UInt8(_flags) & 0x2) != 0
  }
  }
  @_transparent public func withUTF8Buffer<R>(_ body: (Swift.UnsafeBufferPointer<Swift.UInt8>) -> R) -> R {
    if hasPointerRepresentation {
      return body(UnsafeBufferPointer(
        start: utf8Start, count: utf8CodeUnitCount))
    } else {
      return unicodeScalar.withUTF8CodeUnits { body($0) }
    }
  }
  @_transparent public init() {
    self = ""
  }
  @usableFromInline
  @_transparent internal init(_start: Builtin.RawPointer, utf8CodeUnitCount: Builtin.Word, isASCII: Builtin.Int1) {
    // We don't go through UnsafePointer here to make things simpler for alias
    // analysis. A higher-level algorithm may be trying to make sure an
    // unrelated buffer is not accessed or freed.
    self._startPtrOrData = Builtin.ptrtoint_Word(_start)
    self._utf8CodeUnitCount = utf8CodeUnitCount
    self._flags = Bool(isASCII)
      ? (0x2 as UInt8)._value
      : (0x0 as UInt8)._value
  }
  @usableFromInline
  @_transparent internal init(unicodeScalar: Builtin.Int32) {
    self._startPtrOrData = UInt(UInt32(unicodeScalar))._builtinWordValue
    self._utf8CodeUnitCount = 0._builtinWordValue
    self._flags = Unicode.Scalar(_builtinUnicodeScalarLiteral: unicodeScalar).isASCII
      ? (0x3 as UInt8)._value
      : (0x1 as UInt8)._value
  }
}
extension StaticString : Swift._ExpressibleByBuiltinUnicodeScalarLiteral {
  @_effects(readonly) @_transparent public init(_builtinUnicodeScalarLiteral value: Builtin.Int32) {
    self = StaticString(unicodeScalar: value)
  }
}
extension StaticString : Swift.ExpressibleByUnicodeScalarLiteral {
  @_effects(readonly) @_transparent public init(unicodeScalarLiteral value: Swift.StaticString) {
    self = value
  }
  public typealias UnicodeScalarLiteralType = Swift.StaticString
}
extension StaticString : Swift._ExpressibleByBuiltinExtendedGraphemeClusterLiteral {
  @_effects(readonly) @_transparent public init(_builtinExtendedGraphemeClusterLiteral start: Builtin.RawPointer, utf8CodeUnitCount: Builtin.Word, isASCII: Builtin.Int1) {
    self = StaticString(
      _builtinStringLiteral: start,
      utf8CodeUnitCount: utf8CodeUnitCount,
      isASCII: isASCII
    )
  }
}
extension StaticString : Swift.ExpressibleByExtendedGraphemeClusterLiteral {
  @_effects(readonly) @_transparent public init(extendedGraphemeClusterLiteral value: Swift.StaticString) {
    self = value
  }
  public typealias ExtendedGraphemeClusterLiteralType = Swift.StaticString
}
extension StaticString : Swift._ExpressibleByBuiltinStringLiteral {
  @_effects(readonly) @_transparent public init(_builtinStringLiteral start: Builtin.RawPointer, utf8CodeUnitCount: Builtin.Word, isASCII: Builtin.Int1) {
    self = StaticString(
      _start: start,
      utf8CodeUnitCount: utf8CodeUnitCount,
      isASCII: isASCII)
  }
}
extension StaticString : Swift.ExpressibleByStringLiteral {
  @_effects(readonly) @_transparent public init(stringLiteral value: Swift.StaticString) {
    self = value
  }
  public typealias StringLiteralType = Swift.StaticString
}
extension StaticString : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
extension StaticString : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
extension StaticString : Swift.CustomReflectable {
  public var customMirror: Swift.Mirror {
    get
  }
}
public protocol Strideable : Swift.Comparable {
  associatedtype Stride : Swift.Comparable, Swift.SignedNumeric
  func distance(to other: Self) -> Self.Stride
  func advanced(by n: Self.Stride) -> Self
  static func _step(after current: (index: Swift.Int?, value: Self), from start: Self, by distance: Self.Stride) -> (index: Swift.Int?, value: Self)
}
extension Strideable {
  @inlinable public static func < (x: Self, y: Self) -> Swift.Bool {
    return x.distance(to: y) > 0
  }
  @inlinable public static func == (x: Self, y: Self) -> Swift.Bool {
    return x.distance(to: y) == 0
  }
}
extension Strideable {
  @inlinable public static func _step(after current: (index: Swift.Int?, value: Self), from start: Self, by distance: Self.Stride) -> (index: Swift.Int?, value: Self) {
    return (nil, current.value.advanced(by: distance))
  }
}
extension Strideable where Self.Stride : Swift.FloatingPoint {
  @inlinable public static func _step(after current: (index: Swift.Int?, value: Self), from start: Self, by distance: Self.Stride) -> (index: Swift.Int?, value: Self) {
    if let i = current.index {
      // When Stride is a floating-point type, we should avoid accumulating
      // rounding error from repeated addition.
      return (i + 1, start.advanced(by: Stride(i + 1) * distance))
    }
    return (nil, current.value.advanced(by: distance))
  }
}
extension Strideable where Self : Swift.FloatingPoint, Self == Self.Stride {
  @inlinable public static func _step(after current: (index: Swift.Int?, value: Self), from start: Self, by distance: Self.Stride) -> (index: Swift.Int?, value: Self) {
    if let i = current.index {
      // When both Self and Stride are the same floating-point type, we should
      // take advantage of fused multiply-add (where supported) to eliminate
      // intermediate rounding error.
      return (i + 1, start.addingProduct(Stride(i + 1), distance))
    }
    return (nil, current.value.advanced(by: distance))
  }
}
@frozen public struct StrideToIterator<Element> where Element : Swift.Strideable {
  @usableFromInline
  internal let _start: Element
  @usableFromInline
  internal let _end: Element
  @usableFromInline
  internal let _stride: Element.Stride
  @usableFromInline
  internal var _current: (index: Swift.Int?, value: Element)
  @inlinable internal init(_start: Element, end: Element, stride: Element.Stride) {
    self._start = _start
    _end = end
    _stride = stride
    _current = (0, _start)
  }
}
extension StrideToIterator : Swift.IteratorProtocol {
  @inlinable public mutating func next() -> Element? {
    let result = _current.value
    if _stride > 0 ? result >= _end : result <= _end {
      return nil
    }
    _current = Element._step(after: _current, from: _start, by: _stride)
    return result
  }
}
@frozen public struct StrideTo<Element> where Element : Swift.Strideable {
  @usableFromInline
  internal let _start: Element
  @usableFromInline
  internal let _end: Element
  @usableFromInline
  internal let _stride: Element.Stride
  @inlinable internal init(_start: Element, end: Element, stride: Element.Stride) {
    _precondition(stride != 0, "Stride size must not be zero")
    // At start, striding away from end is allowed; it just makes for an
    // already-empty Sequence.
    self._start = _start
    self._end = end
    self._stride = stride
  }
}
extension StrideTo : Swift.Sequence {
  @inlinable __consuming public func makeIterator() -> Swift.StrideToIterator<Element> {
    return StrideToIterator(_start: _start, end: _end, stride: _stride)
  }
  @inlinable public var underestimatedCount: Swift.Int {
    get {
    var it = self.makeIterator()
    var count = 0
    while it.next() != nil {
      count += 1
    }
    return count
  }
  }
  @inlinable public func _customContainsEquatableElement(_ element: Element) -> Swift.Bool? {
    if element < _start || _end <= element {
      return false
    }
    return nil
  }
  public typealias Iterator = Swift.StrideToIterator<Element>
}
extension StrideTo : Swift.CustomReflectable {
  public var customMirror: Swift.Mirror {
    get
  }
}
@inlinable public func stride<T>(from start: T, to end: T, by stride: T.Stride) -> Swift.StrideTo<T> where T : Swift.Strideable {
  return StrideTo(_start: start, end: end, stride: stride)
}
@frozen public struct StrideThroughIterator<Element> where Element : Swift.Strideable {
  @usableFromInline
  internal let _start: Element
  @usableFromInline
  internal let _end: Element
  @usableFromInline
  internal let _stride: Element.Stride
  @usableFromInline
  internal var _current: (index: Swift.Int?, value: Element)
  @usableFromInline
  internal var _didReturnEnd: Swift.Bool = false
  @inlinable internal init(_start: Element, end: Element, stride: Element.Stride) {
    self._start = _start
    _end = end
    _stride = stride
    _current = (0, _start)
  }
}
extension StrideThroughIterator : Swift.IteratorProtocol {
  @inlinable public mutating func next() -> Element? {
    let result = _current.value
    if _stride > 0 ? result >= _end : result <= _end {
      // This check is needed because if we just changed the above operators
      // to > and <, respectively, we might advance current past the end
      // and throw it out of bounds (e.g. above Int.max) unnecessarily.
      if result == _end && !_didReturnEnd {
        _didReturnEnd = true
        return result
      }
      return nil
    }
    _current = Element._step(after: _current, from: _start, by: _stride)
    return result
  }
}
@frozen public struct StrideThrough<Element> where Element : Swift.Strideable {
  @usableFromInline
  internal let _start: Element
  @usableFromInline
  internal let _end: Element
  @usableFromInline
  internal let _stride: Element.Stride
  @inlinable internal init(_start: Element, end: Element, stride: Element.Stride) {
    _precondition(stride != 0, "Stride size must not be zero")
    self._start = _start
    self._end = end
    self._stride = stride
  }
}
extension StrideThrough : Swift.Sequence {
  @inlinable __consuming public func makeIterator() -> Swift.StrideThroughIterator<Element> {
    return StrideThroughIterator(_start: _start, end: _end, stride: _stride)
  }
  @inlinable public var underestimatedCount: Swift.Int {
    get {
    var it = self.makeIterator()
    var count = 0
    while it.next() != nil {
      count += 1
    }
    return count
  }
  }
  @inlinable public func _customContainsEquatableElement(_ element: Element) -> Swift.Bool? {
    if element < _start || _end < element {
      return false
    }
    return nil
  }
  public typealias Iterator = Swift.StrideThroughIterator<Element>
}
extension StrideThrough : Swift.CustomReflectable {
  public var customMirror: Swift.Mirror {
    get
  }
}
@inlinable public func stride<T>(from start: T, through end: T, by stride: T.Stride) -> Swift.StrideThrough<T> where T : Swift.Strideable {
  return StrideThrough(_start: start, end: end, stride: stride)
}
extension String : Swift.Hashable {
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension StringProtocol {
  @_specialize(exported: false, kind: full, where Self == Swift.String)
  @_specialize(exported: false, kind: full, where Self == Swift.Substring)
  public func hash(into hasher: inout Swift.Hasher)
}
@inlinable @_transparent internal func unimplemented_utf8_32bit(_ message: Swift.String = "", file: Swift.StaticString = #file, line: Swift.UInt = #line) -> Swift.Never {
  fatalError("32-bit: Unimplemented for UTF-8 support", file: file, line: line)
}
@frozen public struct String {
  public var _guts: Swift._StringGuts
  @inlinable @inline(__always) internal init(_ _guts: Swift._StringGuts) {
    self._guts = _guts
    _invariantCheck()
  }
  @_alwaysEmitIntoClient @_semantics("string.init_empty_with_capacity") @_semantics("inline_late") @inlinable internal static func _createEmpty(withInitialCapacity: Swift.Int) -> Swift.String {
    return String(_StringGuts(_initialCapacity: withInitialCapacity))
  }
  @inlinable @inline(__always) @_semantics("string.init_empty") public init() { self.init(_StringGuts()) }
}
extension String {
  @inlinable @inline(__always) internal func _invariantCheck() {}
  public func _dump()
}
extension String {
  @_alwaysEmitIntoClient @inline(never) private static func _fromNonContiguousUnsafeBitcastUTF8Repairing<C>(_ input: C) -> (result: Swift.String, repairsMade: Swift.Bool) where C : Swift.Collection {
    _internalInvariant(C.Element.self == UInt8.self)
    return Array(input).withUnsafeBufferPointer {
      let raw = UnsafeRawBufferPointer($0)
      return String._fromUTF8Repairing(raw.bindMemory(to: UInt8.self))
    }
  }
  @inlinable @inline(__always) public init<C, Encoding>(decoding codeUnits: C, as sourceEncoding: Encoding.Type) where C : Swift.Collection, Encoding : Swift._UnicodeEncoding, C.Element == Encoding.CodeUnit {
    guard _fastPath(sourceEncoding == UTF8.self) else {
      self = String._fromCodeUnits(
        codeUnits, encoding: sourceEncoding, repair: true)!.0
      return
    }

    // Fast path for user-defined Collections and typed contiguous collections.
    //
    // Note: this comes first, as the optimizer nearly always has insight into
    // wCSIA, but cannot prove that a type does not have conformance to
    // _HasContiguousBytes.
    if let str = codeUnits.withContiguousStorageIfAvailable({
      (buffer: UnsafeBufferPointer<C.Element>) -> String in
      Builtin.onFastPath() // encourage SIL Optimizer to inline this closure :-(
      let rawBufPtr = UnsafeRawBufferPointer(buffer)
      return String._fromUTF8Repairing(
        UnsafeBufferPointer(
          start: rawBufPtr.baseAddress?.assumingMemoryBound(to: UInt8.self),
          count: rawBufPtr.count)).0
    }) {
      self = str
      return
    }

    // Fast path for untyped raw storage and known stdlib types
    if let contigBytes = codeUnits as? _HasContiguousBytes,
      contigBytes._providesContiguousBytesNoCopy
    {
      self = contigBytes.withUnsafeBytes { rawBufPtr in
        Builtin.onFastPath() // encourage SIL Optimizer to inline this closure
        return String._fromUTF8Repairing(
          UnsafeBufferPointer(
            start: rawBufPtr.baseAddress?.assumingMemoryBound(to: UInt8.self),
            count: rawBufPtr.count)).0
      }
      return
    }

    self = String._fromNonContiguousUnsafeBitcastUTF8Repairing(codeUnits).0
  }
  @available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
  @inline(__always) public init(unsafeUninitializedCapacity capacity: Swift.Int, initializingUTF8With initializer: (Swift.UnsafeMutableBufferPointer<Swift.UInt8>) throws -> Swift.Int) rethrows
  @inlinable @inline(__always) public func withCString<Result, TargetEncoding>(encodedAs targetEncoding: TargetEncoding.Type, _ body: (Swift.UnsafePointer<TargetEncoding.CodeUnit>) throws -> Result) rethrows -> Result where TargetEncoding : Swift._UnicodeEncoding {
    if targetEncoding == UTF8.self {
      return try self.withCString {
        (cPtr: UnsafePointer<CChar>) -> Result  in
        _internalInvariant(UInt8.self == TargetEncoding.CodeUnit.self)
        let ptr = UnsafeRawPointer(cPtr).assumingMemoryBound(
          to: TargetEncoding.CodeUnit.self)
        return try body(ptr)
      }
    }
    return try _slowWithCString(encodedAs: targetEncoding, body)
  }
  @usableFromInline
  @inline(never) @_effects(releasenone) internal func _slowWithCString<Result, TargetEncoding>(encodedAs targetEncoding: TargetEncoding.Type, _ body: (Swift.UnsafePointer<TargetEncoding.CodeUnit>) throws -> Result) rethrows -> Result where TargetEncoding : Swift._UnicodeEncoding
}
extension String : Swift._ExpressibleByBuiltinUnicodeScalarLiteral {
  @_effects(readonly) @inlinable @inline(__always) public init(_builtinUnicodeScalarLiteral value: Builtin.Int32) {
    self.init(Unicode.Scalar(_unchecked: UInt32(value)))
  }
  @inlinable @inline(__always) public init(_ scalar: Swift.Unicode.Scalar) {
    self = scalar.withUTF8CodeUnits { String._uncheckedFromUTF8($0) }
  }
}
extension String : Swift._ExpressibleByBuiltinExtendedGraphemeClusterLiteral {
  @inlinable @inline(__always) @_effects(readonly) @_semantics("string.makeUTF8") public init(_builtinExtendedGraphemeClusterLiteral start: Builtin.RawPointer, utf8CodeUnitCount: Builtin.Word, isASCII: Builtin.Int1) {
    self.init(
      _builtinStringLiteral: start,
      utf8CodeUnitCount: utf8CodeUnitCount,
      isASCII: isASCII)
  }
}
extension String : Swift._ExpressibleByBuiltinStringLiteral {
  @inlinable @inline(__always) @_effects(readonly) @_semantics("string.makeUTF8") public init(_builtinStringLiteral start: Builtin.RawPointer, utf8CodeUnitCount: Builtin.Word, isASCII: Builtin.Int1) {
    let bufPtr = UnsafeBufferPointer(
      start: UnsafeRawPointer(start).assumingMemoryBound(to: UInt8.self),
      count: Int(utf8CodeUnitCount))
    if let smol = _SmallString(bufPtr) {
      self = String(_StringGuts(smol))
      return
    }
    self.init(_StringGuts(bufPtr, isASCII: Bool(isASCII)))
  }
}
extension String : Swift.ExpressibleByStringLiteral {
  @inlinable @inline(__always) public init(stringLiteral value: Swift.String) {
    self = value
  }
  public typealias ExtendedGraphemeClusterLiteralType = Swift.String
  public typealias StringLiteralType = Swift.String
  public typealias UnicodeScalarLiteralType = Swift.String
}
extension String : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
extension String {
  @inlinable @_effects(readonly) @_semantics("string.concat") public static func + (lhs: Swift.String, rhs: Swift.String) -> Swift.String {
    var result = lhs
    result.append(rhs)
    return result
  }
  @inlinable @_semantics("string.plusequals") public static func += (lhs: inout Swift.String, rhs: Swift.String) {
    lhs.append(rhs)
  }
}
extension Sequence where Self.Element : Swift.StringProtocol {
  @_specialize(exported: false, kind: full, where Self == Swift.Array<Swift.Substring>)
  @_specialize(exported: false, kind: full, where Self == Swift.Array<Swift.String>)
  public func joined(separator: Swift.String = "") -> Swift.String
}
extension BidirectionalCollection where Self.Element == Swift.String {
  @_specialize(exported: false, kind: full, where Self == Swift.Array<Swift.String>)
  public func joined(separator: Swift.String = "") -> Swift.String
}
extension String {
  @_effects(releasenone) public func lowercased() -> Swift.String
  @_effects(releasenone) public func uppercased() -> Swift.String
  @inlinable @inline(__always) public init<T>(_ value: T) where T : Swift.LosslessStringConvertible {
    self = value.description
  }
}
extension String : Swift.CustomStringConvertible {
  @inlinable public var description: Swift.String {
    get { return self }
  }
}
extension String {
  public var _nfcCodeUnits: [Swift.UInt8] {
    get
  }
  public func _withNFCCodeUnits(_ f: (Swift.UInt8) throws -> Swift.Void) rethrows
}
@usableFromInline
internal typealias _CocoaString = Swift.AnyObject
@usableFromInline
@_effects(releasenone) internal func _stdlib_binary_CFStringCreateCopy(_ source: Swift._CocoaString) -> Swift._CocoaString
@usableFromInline
@_effects(readonly) internal func _stdlib_binary_CFStringGetLength(_ source: Swift._CocoaString) -> Swift.Int
@usableFromInline
@_effects(readonly) internal func _stdlib_binary_CFStringGetCharactersPtr(_ source: Swift._CocoaString) -> Swift.UnsafeMutablePointer<Swift.UTF16.CodeUnit>?
@usableFromInline
@_effects(releasenone) internal func _bridgeCocoaString(_ cocoaString: Swift._CocoaString) -> Swift._StringGuts
extension String {
  @_effects(releasenone) public func _bridgeToObjectiveCImpl() -> Swift.AnyObject
}
@available(macOS 10.15.4, iOS 13.4, watchOS 6.2, tvOS 13.4, *)
@_cdecl("_SwiftCreateBridgedString")
@usableFromInline
internal func _SwiftCreateBridgedString_DoNotCall(bytes: Swift.UnsafePointer<Swift.UInt8>, length: Swift.Int, encoding: SwiftShims._swift_shims_CFStringEncoding) -> Swift.Unmanaged<Swift.AnyObject>
@_silgen_name("swift_stdlib_getDescription")
public func _getDescription<T>(_ x: T) -> Swift.AnyObject
@available(macOS 10.15.4, iOS 13.4, watchOS 6.2, tvOS 13.4, *)
@_silgen_name("swift_stdlib_NSStringFromUTF8")
@usableFromInline
internal func _NSStringFromUTF8(_ s: Swift.UnsafePointer<Swift.UInt8>, _ len: Swift.Int) -> Swift.AnyObject
extension StringProtocol {
  @_specialize(exported: false, kind: full, where Self == Swift.String)
  @_specialize(exported: false, kind: full, where Self == Swift.Substring)
  public func _toUTF16Offset(_ idx: Self.Index) -> Swift.Int
  @_specialize(exported: false, kind: full, where Self == Swift.String)
  @_specialize(exported: false, kind: full, where Self == Swift.Substring)
  public func _toUTF16Index(_ offset: Swift.Int) -> Self.Index
  @_specialize(exported: false, kind: full, where Self == Swift.String)
  @_specialize(exported: false, kind: full, where Self == Swift.Substring)
  public func _toUTF16Offsets(_ indices: Swift.Range<Self.Index>) -> Swift.Range<Swift.Int>
  @_specialize(exported: false, kind: full, where Self == Swift.String)
  @_specialize(exported: false, kind: full, where Self == Swift.Substring)
  public func _toUTF16Indices(_ range: Swift.Range<Swift.Int>) -> Swift.Range<Self.Index>
}
extension String {
  public func _copyUTF16CodeUnits(into buffer: Swift.UnsafeMutableBufferPointer<Swift.UInt16>, range: Swift.Range<Swift.Int>)
}
extension String : Swift.BidirectionalCollection {
  public typealias IndexDistance = Swift.Int
  public typealias SubSequence = Swift.Substring
  public typealias Element = Swift.Character
  @inlinable @inline(__always) public var startIndex: Swift.String.Index {
    get { return _guts.startIndex }
  }
  @inlinable @inline(__always) public var endIndex: Swift.String.Index {
    get { return _guts.endIndex }
  }
  @inline(__always) public var count: Swift.Int {
    get
  }
  public func index(after i: Swift.String.Index) -> Swift.String.Index
  public func index(before i: Swift.String.Index) -> Swift.String.Index
  @inlinable @inline(__always) public func index(_ i: Swift.String.Index, offsetBy n: Swift.String.IndexDistance) -> Swift.String.Index {
    // TODO: known-ASCII and single-scalar-grapheme fast path, etc.
    return _index(i, offsetBy: n)
  }
  @inlinable @inline(__always) public func index(_ i: Swift.String.Index, offsetBy n: Swift.String.IndexDistance, limitedBy limit: Swift.String.Index) -> Swift.String.Index? {
    // TODO: known-ASCII and single-scalar-grapheme fast path, etc.
    return _index(i, offsetBy: n, limitedBy: limit)
  }
  @inlinable @inline(__always) public func distance(from start: Swift.String.Index, to end: Swift.String.Index) -> Swift.String.IndexDistance {
    // TODO: known-ASCII and single-scalar-grapheme fast path, etc.
    return _distance(from: _guts.scalarAlign(start), to: _guts.scalarAlign(end))
  }
  @inlinable @inline(__always) public subscript(i: Swift.String.Index) -> Swift.Character {
    get {
    _boundsCheck(i)

    let i = _guts.scalarAlign(i)
    let distance = _characterStride(startingAt: i)

    return _guts.errorCorrectedCharacter(
      startingAt: i._encodedOffset, endingAt: i._encodedOffset &+ distance)
  }
  }
  @inlinable @inline(__always) internal func _characterStride(startingAt i: Swift.String.Index) -> Swift.Int {
    _internalInvariant_5_1(i._isScalarAligned)

    // Fast check if it's already been measured, otherwise check resiliently
    if let d = i.characterStride { return d }

    if i == endIndex { return 0 }

    return _guts._opaqueCharacterStride(startingAt: i._encodedOffset)
  }
  @inlinable @inline(__always) internal func _characterStride(endingAt i: Swift.String.Index) -> Swift.Int {
    _internalInvariant_5_1(i._isScalarAligned)

    if i == startIndex { return 0 }

    return _guts._opaqueCharacterStride(endingAt: i._encodedOffset)
  }
  public typealias Indices = Swift.DefaultIndices<Swift.String>
}
extension String {
  @frozen public struct Iterator : Swift.IteratorProtocol {
    @usableFromInline
    internal var _guts: Swift._StringGuts
    @usableFromInline
    internal var _position: Swift.Int = 0
    @usableFromInline
    internal var _end: Swift.Int
    @inlinable internal init(_ guts: Swift._StringGuts) {
      self._end = guts.count
      self._guts = guts
    }
    @inlinable public mutating func next() -> Swift.Character? {
      guard _fastPath(_position < _end) else { return nil }

      let len = _guts._opaqueCharacterStride(startingAt: _position)
      let nextPosition = _position &+ len
      let result = _guts.errorCorrectedCharacter(
        startingAt: _position, endingAt: nextPosition)
      _position = nextPosition
      return result
    }
    public typealias Element = Swift.Character
  }
  @inlinable __consuming public func makeIterator() -> Swift.String.Iterator {
    return Iterator(_guts)
  }
}
extension StringProtocol {
  @_specialize(exported: false, kind: full, where Self == Swift.String, RHS == Swift.String)
  @_specialize(exported: false, kind: full, where Self == Swift.String, RHS == Swift.Substring)
  @_specialize(exported: false, kind: full, where Self == Swift.Substring, RHS == Swift.String)
  @_specialize(exported: false, kind: full, where Self == Swift.Substring, RHS == Swift.Substring)
  @inlinable @_effects(readonly) public static func == <RHS>(lhs: Self, rhs: RHS) -> Swift.Bool where RHS : Swift.StringProtocol {
    return _stringCompare(
      lhs._wholeGuts, lhs._offsetRange,
      rhs._wholeGuts, rhs._offsetRange,
      expecting: .equal)
  }
  @inlinable @inline(__always) @_effects(readonly) public static func != <RHS>(lhs: Self, rhs: RHS) -> Swift.Bool where RHS : Swift.StringProtocol {
    return !(lhs == rhs)
  }
  @_specialize(exported: false, kind: full, where Self == Swift.String, RHS == Swift.String)
  @_specialize(exported: false, kind: full, where Self == Swift.String, RHS == Swift.Substring)
  @_specialize(exported: false, kind: full, where Self == Swift.Substring, RHS == Swift.String)
  @_specialize(exported: false, kind: full, where Self == Swift.Substring, RHS == Swift.Substring)
  @inlinable @_effects(readonly) public static func < <RHS>(lhs: Self, rhs: RHS) -> Swift.Bool where RHS : Swift.StringProtocol {
    return _stringCompare(
      lhs._wholeGuts, lhs._offsetRange,
      rhs._wholeGuts, rhs._offsetRange,
      expecting: .less)
  }
  @inlinable @inline(__always) @_effects(readonly) public static func > <RHS>(lhs: Self, rhs: RHS) -> Swift.Bool where RHS : Swift.StringProtocol {
    return rhs < lhs
  }
  @inlinable @inline(__always) @_effects(readonly) public static func <= <RHS>(lhs: Self, rhs: RHS) -> Swift.Bool where RHS : Swift.StringProtocol {
    return !(rhs < lhs)
  }
  @inlinable @inline(__always) @_effects(readonly) public static func >= <RHS>(lhs: Self, rhs: RHS) -> Swift.Bool where RHS : Swift.StringProtocol {
    return !(lhs < rhs)
  }
}
extension String : Swift.Equatable {
  @inlinable @inline(__always) @_effects(readonly) @_semantics("string.equals") public static func == (lhs: Swift.String, rhs: Swift.String) -> Swift.Bool {
    return _stringCompare(lhs._guts, rhs._guts, expecting: .equal)
  }
}
extension String : Swift.Comparable {
  @inlinable @inline(__always) @_effects(readonly) public static func < (lhs: Swift.String, rhs: Swift.String) -> Swift.Bool {
    return _stringCompare(lhs._guts, rhs._guts, expecting: .less)
  }
}
extension Substring : Swift.Equatable {
}
extension String {
  @_alwaysEmitIntoClient @inline(__always) @_effects(readonly) public static func ~= (lhs: Swift.String, rhs: Swift.Substring) -> Swift.Bool {
    return lhs == rhs
  }
}
extension Substring {
  @_alwaysEmitIntoClient @inline(__always) @_effects(readonly) public static func ~= (lhs: Swift.Substring, rhs: Swift.String) -> Swift.Bool {
    return lhs == rhs
  }
}
@inlinable @inline(__always) @_effects(readonly) internal func _stringCompare(_ lhs: Swift._StringGuts, _ rhs: Swift._StringGuts, expecting: Swift._StringComparisonResult) -> Swift.Bool {
  if lhs.rawBits == rhs.rawBits { return expecting == .equal }
  return _stringCompareWithSmolCheck(lhs, rhs, expecting: expecting)
}
@usableFromInline
@_effects(readonly) internal func _stringCompareWithSmolCheck(_ lhs: Swift._StringGuts, _ rhs: Swift._StringGuts, expecting: Swift._StringComparisonResult) -> Swift.Bool
@usableFromInline
@inline(never) @_effects(readonly) internal func _stringCompareInternal(_ lhs: Swift._StringGuts, _ rhs: Swift._StringGuts, expecting: Swift._StringComparisonResult) -> Swift.Bool
@inlinable @inline(__always) @_effects(readonly) internal func _stringCompare(_ lhs: Swift._StringGuts, _ lhsRange: Swift.Range<Swift.Int>, _ rhs: Swift._StringGuts, _ rhsRange: Swift.Range<Swift.Int>, expecting: Swift._StringComparisonResult) -> Swift.Bool {
  if lhs.rawBits == rhs.rawBits && lhsRange == rhsRange {
    return expecting == .equal
  }
  return _stringCompareInternal(
    lhs, lhsRange, rhs, rhsRange, expecting: expecting)
}
@usableFromInline
@_effects(readonly) internal func _stringCompareInternal(_ lhs: Swift._StringGuts, _ lhsRange: Swift.Range<Swift.Int>, _ rhs: Swift._StringGuts, _ rhsRange: Swift.Range<Swift.Int>, expecting: Swift._StringComparisonResult) -> Swift.Bool
@usableFromInline
@frozen internal enum _StringComparisonResult {
  case equal
  case less
  @inlinable @inline(__always) internal init(signedNotation int: Swift.Int) {
    _internalInvariant(int <= 0)
    self = int == 0 ? .equal : .less
  }
  @inlinable @inline(__always) internal static func == (lhs: Swift._StringComparisonResult, rhs: Swift._StringComparisonResult) -> Swift.Bool {
    switch (lhs, rhs) {
      case (.equal, .equal): return true
      case (.less, .less): return true
      default: return false
    }
  }
  @usableFromInline
  internal func hash(into hasher: inout Swift.Hasher)
  @usableFromInline
  internal var hashValue: Swift.Int {
    @usableFromInline
    get
  }
}
extension String {
  @usableFromInline
  internal static func _fromASCII(_ input: Swift.UnsafeBufferPointer<Swift.UInt8>) -> Swift.String
  public static func _tryFromUTF8(_ input: Swift.UnsafeBufferPointer<Swift.UInt8>) -> Swift.String?
  @usableFromInline
  internal static func _fromUTF8Repairing(_ input: Swift.UnsafeBufferPointer<Swift.UInt8>) -> (result: Swift.String, repairsMade: Swift.Bool)
  @usableFromInline
  internal static func _uncheckedFromUTF8(_ input: Swift.UnsafeBufferPointer<Swift.UInt8>) -> Swift.String
  @usableFromInline
  internal static func _uncheckedFromUTF8(_ input: Swift.UnsafeBufferPointer<Swift.UInt8>, isASCII: Swift.Bool) -> Swift.String
  @usableFromInline
  internal static func _uncheckedFromUTF8(_ input: Swift.UnsafeBufferPointer<Swift.UInt8>, asciiPreScanResult: Swift.Bool) -> Swift.String
  @usableFromInline
  internal static func _uncheckedFromUTF16(_ input: Swift.UnsafeBufferPointer<Swift.UInt16>) -> Swift.String
  @usableFromInline
  @_specialize(exported: false, kind: full, where Input == Swift.UnsafeBufferPointer<Swift.UInt8>, Encoding == Swift.Unicode.ASCII)
  @_specialize(exported: false, kind: full, where Input == Swift.Array<Swift.UInt8>, Encoding == Swift.Unicode.ASCII)
  @inline(never) internal static func _fromCodeUnits<Input, Encoding>(_ input: Input, encoding: Encoding.Type, repair: Swift.Bool) -> (Swift.String, repairsMade: Swift.Bool)? where Input : Swift.Collection, Encoding : Swift._UnicodeEncoding, Input.Element == Encoding.CodeUnit
  public static func _fromInvalidUTF16(_ utf16: Swift.UnsafeBufferPointer<Swift.UInt16>) -> Swift.String
  @usableFromInline
  internal static func _fromSubstring(_ substring: __shared Swift.Substring) -> Swift.String
  @_alwaysEmitIntoClient @inline(never) internal static func _copying(_ str: Swift.String) -> Swift.String {
    return String._copying(str[...])
  }
  @_alwaysEmitIntoClient @inline(never) internal static func _copying(_ str: Swift.Substring) -> Swift.String {
    if _fastPath(str._wholeGuts.isFastUTF8) {
      return str._wholeGuts.withFastUTF8(range: str._offsetRange) {
        String._uncheckedFromUTF8($0)
      }
    }
    return Array(str.utf8).withUnsafeBufferPointer {
      String._uncheckedFromUTF8($0)
    }
  }
}
@frozen public struct _StringGuts {
  @usableFromInline
  internal var _object: Swift._StringObject
  @inlinable @inline(__always) internal init(_ object: Swift._StringObject) {
    self._object = object
    _invariantCheck()
  }
  @inlinable @inline(__always) internal init() {
    self.init(_StringObject(empty: ()))
  }
}
extension _StringGuts {
  @inlinable @inline(__always) internal var rawBits: Swift._StringObject.RawBitPattern {
    get {
    return _object.rawBits
  }
  }
}
extension _StringGuts {
  @inlinable @inline(__always) internal init(_ smol: Swift._SmallString) {
    self.init(_StringObject(smol))
  }
  @inlinable @inline(__always) internal init(_ bufPtr: Swift.UnsafeBufferPointer<Swift.UInt8>, isASCII: Swift.Bool) {
    self.init(_StringObject(immortal: bufPtr, isASCII: isASCII))
  }
}
extension _StringGuts {
  @inlinable @inline(__always) internal var count: Swift.Int {
    get { return _object.count }
  }
  @inlinable @inline(__always) internal var isEmpty: Swift.Bool {
    get { return count == 0 }
  }
  @inlinable @inline(__always) internal var isSmall: Swift.Bool {
    get { return _object.isSmall }
  }
  @inlinable @inline(__always) internal var asSmall: Swift._SmallString {
    get {
    return _SmallString(_object)
  }
  }
  @inlinable @inline(__always) internal var isASCII: Swift.Bool {
    get {
    return _object.isASCII
  }
  }
  @inlinable @inline(__always) internal var isFastASCII: Swift.Bool {
    get {
    return isFastUTF8 && _object.isASCII
  }
  }
}
extension _StringGuts {
  @_transparent @inlinable internal var isFastUTF8: Swift.Bool {
    @_transparent get { return _fastPath(_object.providesFastUTF8) }
  }
  @inlinable @inline(__always) internal var isForeign: Swift.Bool {
    get {
     return _slowPath(_object.isForeign)
  }
  }
  @inlinable @inline(__always) internal func withFastUTF8<R>(_ f: (Swift.UnsafeBufferPointer<Swift.UInt8>) throws -> R) rethrows -> R {
    _internalInvariant(isFastUTF8)

    if self.isSmall { return try _SmallString(_object).withUTF8(f) }

    defer { _fixLifetime(self) }
    return try f(_object.fastUTF8)
  }
  @inlinable @inline(__always) internal func withFastUTF8<R>(range: Swift.Range<Swift.Int>, _ f: (Swift.UnsafeBufferPointer<Swift.UInt8>) throws -> R) rethrows -> R {
    return try self.withFastUTF8 { wholeUTF8 in
      return try f(UnsafeBufferPointer(rebasing: wholeUTF8[range]))
    }
  }
  @inlinable @inline(__always) internal func withFastCChar<R>(_ f: (Swift.UnsafeBufferPointer<Swift.CChar>) throws -> R) rethrows -> R {
    return try self.withFastUTF8 { utf8 in
      let ptr = utf8.baseAddress._unsafelyUnwrappedUnchecked._asCChar
      return try f(UnsafeBufferPointer(start: ptr, count: utf8.count))
    }
  }
}
extension _StringGuts {
  @inlinable @inline(__always) internal func _invariantCheck() {}
}
extension _StringGuts {
  @inlinable @inline(__always) internal func withCString<Result>(_ body: (Swift.UnsafePointer<Swift.Int8>) throws -> Result) rethrows -> Result {
    if _slowPath(!_object.isFastZeroTerminated) {
      return try _slowWithCString(body)
    }

    return try self.withFastCChar {
      return try body($0.baseAddress._unsafelyUnwrappedUnchecked)
    }
  }
  @usableFromInline
  @inline(never) internal func _slowWithCString<Result>(_ body: (Swift.UnsafePointer<Swift.Int8>) throws -> Result) rethrows -> Result
}
extension _StringGuts {
  @inlinable internal func copyUTF8(into mbp: Swift.UnsafeMutableBufferPointer<Swift.UInt8>) -> Swift.Int? {
    let ptr = mbp.baseAddress._unsafelyUnwrappedUnchecked
    if _fastPath(self.isFastUTF8) {
      return self.withFastUTF8 { utf8 in
        guard utf8.count <= mbp.count else { return nil }

        let utf8Start = utf8.baseAddress._unsafelyUnwrappedUnchecked
        ptr.initialize(from: utf8Start, count: utf8.count)
        return utf8.count
      }
    }

    return _foreignCopyUTF8(into: mbp)
  }
  @usableFromInline
  @_effects(releasenone) @inline(never) internal func _foreignCopyUTF8(into mbp: Swift.UnsafeMutableBufferPointer<Swift.UInt8>) -> Swift.Int?
}
extension _StringGuts {
  @usableFromInline
  internal typealias Index = Swift.String.Index
  @inlinable @inline(__always) internal var startIndex: Swift.String.Index {
    get {
   return Index(_encodedOffset: 0)._scalarAligned
  }
  }
  @inlinable @inline(__always) internal var endIndex: Swift.String.Index {
    get {
    return Index(_encodedOffset: self.count)._scalarAligned
  }
  }
}
extension _StringGuts {
  @available(*, deprecated)
  public var _isContiguousASCII: Swift.Bool {
    get
  }
  @available(*, deprecated)
  public var _isContiguousUTF16: Swift.Bool {
    get
  }
  @available(*, deprecated)
  public var startASCII: Swift.UnsafeMutablePointer<Swift.UInt8> {
    get
  }
  @available(*, deprecated)
  public var startUTF16: Swift.UnsafeMutablePointer<Swift.UTF16.CodeUnit> {
    get
  }
}
extension _StringGuts {
  @inlinable public var _isSmall: Swift.Bool {
    get { return isSmall }
  }
  @inlinable public var _smallCodeUnits: (Swift.UInt64, Swift.UInt64) {
    get {
    return asSmall.zeroTerminatedRawCodeUnits
  }
  }
  @inlinable public var _isLargeZeroTerminatedContiguousUTF8: Swift.Bool {
    get {
    return !isSmall && _object.isFastZeroTerminated
  }
  }
  @inlinable public var _largeContiguousUTF8CodeUnits: Swift.UnsafeBufferPointer<Swift.UInt8> {
    get {
    return _object.fastUTF8
  }
  }
}
@available(*, deprecated)
public func _persistCString(_ p: Swift.UnsafePointer<Swift.CChar>?) -> [Swift.CChar]?
extension _StringGuts {
  @usableFromInline
  internal var isUniqueNative: Swift.Bool {
    @inline(__always) mutating get
  }
}
extension _StringGuts {
  @inlinable internal init(_initialCapacity capacity: Swift.Int) {
    self.init()
    if _slowPath(capacity > _SmallString.capacity) {
      self.grow(capacity) // TODO: no factor should be applied
    }
  }
  @usableFromInline
  internal mutating func grow(_ n: Swift.Int)
}
@usableFromInline
@frozen internal struct _StringObject {
  @usableFromInline
  @frozen internal enum Nibbles {
  }
  @usableFromInline
  @frozen internal struct CountAndFlags {
    @usableFromInline
    internal var _storage: Swift.UInt64
    @inlinable @inline(__always) internal init(zero: ()) { self._storage = 0 }
  }
  @usableFromInline
  internal var _countAndFlagsBits: Swift.UInt64
  @usableFromInline
  internal var _object: Builtin.BridgeObject
  @inlinable @inline(__always) internal init(zero: ()) {
    self._countAndFlagsBits = 0
    self._object = Builtin.valueToBridgeObject(UInt64(0)._value)
  }
  @inlinable @inline(__always) internal var _countAndFlags: Swift._StringObject.CountAndFlags {
    get {
    _internalInvariant(!isSmall)
    return CountAndFlags(rawUnchecked: _countAndFlagsBits)
  }
  }
}
extension _StringObject {
  @usableFromInline
  internal typealias RawBitPattern = (Swift.UInt64, Swift.UInt64)
  @inlinable @inline(__always) internal var rawBits: Swift._StringObject.RawBitPattern {
    get {
    return (_countAndFlagsBits, discriminatedObjectRawBits)
  }
  }
  @inlinable @inline(__always) internal init(bridgeObject: Builtin.BridgeObject, countAndFlags: Swift._StringObject.CountAndFlags) {
    self._object = bridgeObject
    self._countAndFlagsBits = countAndFlags._storage
    _invariantCheck()
  }
  @inlinable @inline(__always) internal init(object: Swift.AnyObject, discriminator: Swift.UInt64, countAndFlags: Swift._StringObject.CountAndFlags) {
    defer { _fixLifetime(object) }
    let builtinRawObject: Builtin.Int64 = Builtin.reinterpretCast(object)
    let builtinDiscrim: Builtin.Int64 = discriminator._value
    self.init(
      bridgeObject: Builtin.reinterpretCast(
        Builtin.stringObjectOr_Int64(builtinRawObject, builtinDiscrim)),
      countAndFlags: countAndFlags)
  }
  @inlinable @inline(__always) internal init(pointerBits: Swift.UInt64, discriminator: Swift.UInt64, countAndFlags: Swift._StringObject.CountAndFlags) {
    let builtinValueBits: Builtin.Int64 = pointerBits._value
    let builtinDiscrim: Builtin.Int64 = discriminator._value
    self.init(
      bridgeObject: Builtin.valueToBridgeObject(Builtin.stringObjectOr_Int64(
        builtinValueBits, builtinDiscrim)),
      countAndFlags: countAndFlags)
  }
  @inlinable @inline(__always) internal init(rawUncheckedValue bits: Swift._StringObject.RawBitPattern) {
    self.init(zero:())
    self._countAndFlagsBits = bits.0
    self._object = Builtin.valueToBridgeObject(bits.1._value)
    _internalInvariant(self.rawBits == bits)
  }
  @inlinable @inline(__always) internal init(rawValue bits: Swift._StringObject.RawBitPattern) {
    self.init(rawUncheckedValue: bits)
    _invariantCheck()
  }
  @inlinable @_transparent internal var discriminatedObjectRawBits: Swift.UInt64 {
    @_transparent get {
    return Builtin.reinterpretCast(_object)
  }
  }
}
extension _StringObject.CountAndFlags {
  @usableFromInline
  internal typealias RawBitPattern = Swift.UInt64
  @inlinable @inline(__always) internal var rawBits: Swift._StringObject.CountAndFlags.RawBitPattern {
    get {
   return _storage
  }
  }
  @inlinable @inline(__always) internal init(rawUnchecked bits: Swift._StringObject.CountAndFlags.RawBitPattern) {
    self._storage = bits
  }
  @inlinable @inline(__always) internal init(raw bits: Swift._StringObject.CountAndFlags.RawBitPattern) {
    self.init(rawUnchecked: bits)
    _invariantCheck()
  }
}
extension _StringObject.Nibbles {
  @inlinable @inline(__always) internal static var emptyString: Swift.UInt64 {
    get {
    return _StringObject.Nibbles.small(isASCII: true)
  }
  }
}
extension _StringObject.Nibbles {
  @inlinable @inline(__always) internal static var largeAddressMask: Swift.UInt64 {
    get { return 0x0FFF_FFFF_FFFF_FFFF }
  }
  @inlinable @inline(__always) internal static var discriminatorMask: Swift.UInt64 {
    get { return ~largeAddressMask }
  }
}
extension _StringObject.Nibbles {
  @inlinable @inline(__always) internal static func small(isASCII: Swift.Bool) -> Swift.UInt64 {
    return isASCII ? 0xE000_0000_0000_0000 : 0xA000_0000_0000_0000
  }
  @inlinable @inline(__always) internal static func small(withCount count: Swift.Int, isASCII: Swift.Bool) -> Swift.UInt64 {
    _internalInvariant(count <= _SmallString.capacity)
    return small(isASCII: isASCII) | UInt64(truncatingIfNeeded: count) &<< 56
  }
  @inlinable @inline(__always) internal static func largeImmortal() -> Swift.UInt64 {
    return 0x8000_0000_0000_0000
  }
  @inlinable @inline(__always) internal static func largeMortal() -> Swift.UInt64 { return 0x0000_0000_0000_0000 }
}
extension _StringObject {
  @inlinable @inline(__always) internal static var nativeBias: Swift.UInt {
    get {
    return 32
  }
  }
  @inlinable @inline(__always) internal var isImmortal: Swift.Bool {
    get {
    return (discriminatedObjectRawBits & 0x8000_0000_0000_0000) != 0
  }
  }
  @inlinable @inline(__always) internal var isMortal: Swift.Bool {
    get { return !isImmortal }
  }
  @inlinable @inline(__always) internal var isSmall: Swift.Bool {
    get {
    return (discriminatedObjectRawBits & 0x2000_0000_0000_0000) != 0
  }
  }
  @inlinable @inline(__always) internal var isLarge: Swift.Bool {
    get { return !isSmall }
  }
  @inlinable @inline(__always) internal var providesFastUTF8: Swift.Bool {
    get {
    return (discriminatedObjectRawBits & 0x1000_0000_0000_0000) == 0
  }
  }
  @inlinable @inline(__always) internal var isForeign: Swift.Bool {
    get { return !providesFastUTF8 }
  }
}
extension _StringObject {
  @inlinable @inline(__always) internal var largeFastIsTailAllocated: Swift.Bool {
    get {
    _internalInvariant(isLarge && providesFastUTF8)
    return _countAndFlags.isTailAllocated
  }
  }
  @_alwaysEmitIntoClient @inline(__always) internal var isPreferredRepresentation: Swift.Bool {
    get {
    return _fastPath(isSmall || _countAndFlags.isTailAllocated)
  }
  }
}
extension _StringObject {
  @inlinable @inline(__always) internal init(_ small: Swift._SmallString) {
    // Small strings are encoded as _StringObjects in reverse byte order
    // on big-endian platforms. This is to match the discriminator to the
    // spare bits (the most significant nibble) in a pointer.
    let word1 = small.rawBits.0.littleEndian
    let word2 = small.rawBits.1.littleEndian
    // On 64-bit, we copy the raw bits (to host byte order).
    self.init(rawValue: (word1, word2))
    _internalInvariant(isSmall)
  }
  @inlinable internal static func getSmallCount(fromRaw x: Swift.UInt64) -> Swift.Int {
    return Int(truncatingIfNeeded: (x & 0x0F00_0000_0000_0000) &>> 56)
  }
  @inlinable @inline(__always) internal var smallCount: Swift.Int {
    get {
    _internalInvariant(isSmall)
    return _StringObject.getSmallCount(fromRaw: discriminatedObjectRawBits)
  }
  }
  @inlinable internal static func getSmallIsASCII(fromRaw x: Swift.UInt64) -> Swift.Bool {
    return x & 0x4000_0000_0000_0000 != 0
  }
  @inlinable @inline(__always) internal var smallIsASCII: Swift.Bool {
    get {
    _internalInvariant(isSmall)
    return _StringObject.getSmallIsASCII(fromRaw: discriminatedObjectRawBits)
  }
  }
  @inlinable @inline(__always) internal init(empty: ()) {
    // Canonical empty pattern: small zero-length string
    self._countAndFlagsBits = 0
    self._object = Builtin.valueToBridgeObject(Nibbles.emptyString._value)
    _internalInvariant(self.smallCount == 0)
    _invariantCheck()
  }
}
extension _StringObject.CountAndFlags {
  @inlinable @inline(__always) internal static var countMask: Swift.UInt64 {
    get { return 0x0000_FFFF_FFFF_FFFF }
  }
  @inlinable @inline(__always) internal static var flagsMask: Swift.UInt64 {
    get { return ~countMask }
  }
  @inlinable @inline(__always) internal static var isASCIIMask: Swift.UInt64 {
    get { return 0x8000_0000_0000_0000 }
  }
  @inlinable @inline(__always) internal static var isNFCMask: Swift.UInt64 {
    get { return 0x4000_0000_0000_0000 }
  }
  @inlinable @inline(__always) internal static var isNativelyStoredMask: Swift.UInt64 {
    get {
    return 0x2000_0000_0000_0000
  }
  }
  @inlinable @inline(__always) internal static var isTailAllocatedMask: Swift.UInt64 {
    get {
    return 0x1000_0000_0000_0000
  }
  }
  @inlinable @inline(__always) internal init(count: Swift.Int, isASCII: Swift.Bool, isNFC: Swift.Bool, isNativelyStored: Swift.Bool, isTailAllocated: Swift.Bool) {
    var rawBits = UInt64(truncatingIfNeeded: count)
    _internalInvariant(rawBits <= _StringObject.CountAndFlags.countMask)

    if isASCII {
      _internalInvariant(isNFC)
      rawBits |= _StringObject.CountAndFlags.isASCIIMask
    }

    if isNFC {
      rawBits |= _StringObject.CountAndFlags.isNFCMask
    }

    if isNativelyStored {
      _internalInvariant(isTailAllocated)
      rawBits |= _StringObject.CountAndFlags.isNativelyStoredMask
    }

    if isTailAllocated {
      rawBits |= _StringObject.CountAndFlags.isTailAllocatedMask
    }

    self.init(raw: rawBits)
    _internalInvariant(count == self.count)
    _internalInvariant(isASCII == self.isASCII)
    _internalInvariant(isNFC == self.isNFC)
    _internalInvariant(isNativelyStored == self.isNativelyStored)
    _internalInvariant(isTailAllocated == self.isTailAllocated)
  }
  @inlinable @inline(__always) internal init(count: Swift.Int, flags: Swift.UInt16) {
    // Currently, we only use top 4 flags
    _internalInvariant(flags & 0xF000 == flags)

    let rawBits = UInt64(truncatingIfNeeded: flags) &<< 48
                | UInt64(truncatingIfNeeded: count)
    self.init(raw: rawBits)
    _internalInvariant(self.count == count && self.flags == flags)
  }
  @inlinable @inline(__always) internal init(immortalCount: Swift.Int, isASCII: Swift.Bool) {
    self.init(
      count: immortalCount,
      isASCII: isASCII,
      isNFC: isASCII,
      isNativelyStored: false,
      isTailAllocated: true)
  }
  @inlinable @inline(__always) internal var count: Swift.Int {
    get {
    return Int(
      truncatingIfNeeded: _storage & _StringObject.CountAndFlags.countMask)
  }
  }
  @inlinable @inline(__always) internal var flags: Swift.UInt16 {
    get {
    return UInt16(truncatingIfNeeded: _storage &>> 48)
  }
  }
  @inlinable @inline(__always) internal var isASCII: Swift.Bool {
    get {
    return 0 != _storage & _StringObject.CountAndFlags.isASCIIMask
  }
  }
  @inlinable @inline(__always) internal var isNFC: Swift.Bool {
    get {
    return 0 != _storage & _StringObject.CountAndFlags.isNFCMask
  }
  }
  @inlinable @inline(__always) internal var isNativelyStored: Swift.Bool {
    get {
    return 0 != _storage & _StringObject.CountAndFlags.isNativelyStoredMask
  }
  }
  @inlinable @inline(__always) internal var isTailAllocated: Swift.Bool {
    get {
    return 0 != _storage & _StringObject.CountAndFlags.isTailAllocatedMask
  }
  }
  @inlinable @inline(__always) internal func _invariantCheck() {}
}
extension _StringObject {
  @inlinable @inline(__always) internal var largeCount: Swift.Int {
    get {
    _internalInvariant(isLarge)
    return _countAndFlags.count
  }
  }
  @inlinable @inline(__always) internal var largeAddressBits: Swift.UInt {
    get {
    _internalInvariant(isLarge)
    return UInt(truncatingIfNeeded:
      discriminatedObjectRawBits & Nibbles.largeAddressMask)
  }
  }
  @inlinable @inline(__always) internal var nativeUTF8Start: Swift.UnsafePointer<Swift.UInt8> {
    get {
    _internalInvariant(largeFastIsTailAllocated)
    return UnsafePointer(
      bitPattern: largeAddressBits &+ _StringObject.nativeBias
    )._unsafelyUnwrappedUnchecked
  }
  }
  @inlinable @inline(__always) internal var nativeUTF8: Swift.UnsafeBufferPointer<Swift.UInt8> {
    get {
    _internalInvariant(largeFastIsTailAllocated)
    return UnsafeBufferPointer(start: nativeUTF8Start, count: largeCount)
  }
  }
  @usableFromInline
  @inline(never) @_effects(releasenone) internal func getSharedUTF8Start() -> Swift.UnsafePointer<Swift.UInt8>
  @usableFromInline
  internal var sharedUTF8: Swift.UnsafeBufferPointer<Swift.UInt8> {
    @_effects(releasenone) @inline(never) get
  }
  @_alwaysEmitIntoClient @inlinable @inline(__always) internal var owner: Swift.AnyObject? {
    get {
    guard self.isMortal else { return nil }
    return Builtin.reinterpretCast(largeAddressBits)
  }
  }
}
extension _StringObject {
  @inlinable @inline(__always) internal var count: Swift.Int {
    get { return isSmall ? smallCount : largeCount }
  }
  @inlinable @inline(__always) internal var isASCII: Swift.Bool {
    get {
    if isSmall { return smallIsASCII }
    return _countAndFlags.isASCII
  }
  }
  @inlinable @inline(__always) internal var fastUTF8: Swift.UnsafeBufferPointer<Swift.UInt8> {
    get {
    _internalInvariant(self.isLarge && self.providesFastUTF8)
    guard _fastPath(self.largeFastIsTailAllocated) else {
      return sharedUTF8
    }
    return UnsafeBufferPointer(
      _uncheckedStart: self.nativeUTF8Start, count: self.largeCount)
  }
  }
  @usableFromInline
  internal var hasObjCBridgeableObject: Swift.Bool {
    @_effects(releasenone) get
  }
  @inlinable internal var isFastZeroTerminated: Swift.Bool {
    get {
    if _slowPath(!providesFastUTF8) { return false }

    // Small strings nul-terminate when spilling for contiguous access
    if isSmall { return true }

    // TODO(String performance): Use performance flag, which could be more
    // inclusive. For now, we only know native strings and small strings (when
    // accessed) are. We could also know about some shared strings.

    return largeFastIsTailAllocated
  }
  }
}
extension _StringObject {
  @inlinable @inline(__always) internal init(immortal bufPtr: Swift.UnsafeBufferPointer<Swift.UInt8>, isASCII: Swift.Bool) {
    let countAndFlags = CountAndFlags(
      immortalCount: bufPtr.count, isASCII: isASCII)
    // We bias to align code paths for mortal and immortal strings
    let biasedAddress = UInt(
      bitPattern: bufPtr.baseAddress._unsafelyUnwrappedUnchecked
    ) &- _StringObject.nativeBias

    self.init(
      pointerBits: UInt64(truncatingIfNeeded: biasedAddress),
      discriminator: Nibbles.largeImmortal(),
      countAndFlags: countAndFlags)
  }
}
extension _StringObject {
  @inlinable @inline(__always) internal func _invariantCheck() {}
}
public protocol StringProtocol : Swift.BidirectionalCollection, Swift.Comparable, Swift.ExpressibleByStringInterpolation, Swift.Hashable, Swift.LosslessStringConvertible, Swift.TextOutputStream, Swift.TextOutputStreamable where Self.Element == Swift.Character, Self.Index == Swift.String.Index, Self.StringInterpolation == Swift.DefaultStringInterpolation, Self.SubSequence : Swift.StringProtocol {
  associatedtype UTF8View : Swift.Collection where Self.UTF8View.Element == Swift.UInt8, Self.UTF8View.Index == Swift.String.Index, Self.SubSequence.UTF8View.Index == Swift.String.Index
  associatedtype UTF16View : Swift.BidirectionalCollection where Self.UTF16View.Element == Swift.UInt16, Self.UTF16View.Index == Swift.String.Index, Self.SubSequence.UTF16View.Index == Swift.String.Index
  associatedtype UnicodeScalarView : Swift.BidirectionalCollection where Self.UnicodeScalarView.Element == Swift.Unicode.Scalar, Self.UnicodeScalarView.Index == Swift.String.Index, Self.SubSequence.UnicodeScalarView.Index == Swift.String.Index
  associatedtype SubSequence = Swift.Substring
  var utf8: Self.UTF8View { get }
  var utf16: Self.UTF16View { get }
  var unicodeScalars: Self.UnicodeScalarView { get }
  func hasPrefix(_ prefix: Swift.String) -> Swift.Bool
  func hasSuffix(_ prefix: Swift.String) -> Swift.Bool
  func lowercased() -> Swift.String
  func uppercased() -> Swift.String
  init<C, Encoding>(decoding codeUnits: C, as sourceEncoding: Encoding.Type) where C : Swift.Collection, Encoding : Swift._UnicodeEncoding, C.Element == Encoding.CodeUnit
  init(cString nullTerminatedUTF8: Swift.UnsafePointer<Swift.CChar>)
  init<Encoding>(decodingCString nullTerminatedCodeUnits: Swift.UnsafePointer<Encoding.CodeUnit>, as sourceEncoding: Encoding.Type) where Encoding : Swift._UnicodeEncoding
  func withCString<Result>(_ body: (Swift.UnsafePointer<Swift.CChar>) throws -> Result) rethrows -> Result
  func withCString<Result, Encoding>(encodedAs targetEncoding: Encoding.Type, _ body: (Swift.UnsafePointer<Encoding.CodeUnit>) throws -> Result) rethrows -> Result where Encoding : Swift._UnicodeEncoding
}
extension StringProtocol {
  public var _ephemeralString: Swift.String {
    @_specialize(exported: false, kind: full, where Self == Swift.String)
    @_specialize(exported: false, kind: full, where Self == Swift.Substring)
    get
  }
  @inlinable internal var _offsetRange: Swift.Range<Swift.Int> {
    @inline(__always) get {
      let start = startIndex
      let end = endIndex
      _internalInvariant(
        start.transcodedOffset == 0 && end.transcodedOffset == 0)
      return Range(_uncheckedBounds: (start._encodedOffset, end._encodedOffset))
    }
  }
  @inlinable internal var _wholeGuts: Swift._StringGuts {
    @_specialize(exported: false, kind: full, where Self == Swift.String)
    @_specialize(exported: false, kind: full, where Self == Swift.Substring)
    @inline(__always) get {
      if let str = self as? String {
        return str._guts
      }
      if let subStr = self as? Substring {
        return subStr._wholeGuts
      }
      return String(self)._guts
    }
  }
}
extension String {
  @_alwaysEmitIntoClient public var isContiguousUTF8: Swift.Bool {
    get { return _guts.isFastUTF8 }
  }
  @_alwaysEmitIntoClient public mutating func makeContiguousUTF8() {
    if _fastPath(isContiguousUTF8) { return }
    self = String._copying(self)
  }
  @_alwaysEmitIntoClient public mutating func withUTF8<R>(_ body: (Swift.UnsafeBufferPointer<Swift.UInt8>) throws -> R) rethrows -> R {
    makeContiguousUTF8()
    return try _guts.withFastUTF8(body)
  }
}
extension Substring {
  @_alwaysEmitIntoClient public var isContiguousUTF8: Swift.Bool {
    get { return self.base.isContiguousUTF8 }
  }
  @_alwaysEmitIntoClient public mutating func makeContiguousUTF8() {
    if _fastPath(isContiguousUTF8) { return }
    self = String._copying(self)[...]
  }
  @_alwaysEmitIntoClient public mutating func withUTF8<R>(_ body: (Swift.UnsafeBufferPointer<Swift.UInt8>) throws -> R) rethrows -> R {
    if _fastPath(isContiguousUTF8) {
      return try _wholeGuts.withFastUTF8(range: self._offsetRange) {
        return try body($0)
      }
    }

    makeContiguousUTF8()
    return try _wholeGuts.withFastUTF8(body)
  }
}
extension String {
  @frozen public struct Index {
    @usableFromInline
    internal var _rawBits: Swift.UInt64
    @inlinable @inline(__always) internal init(_ raw: Swift.UInt64) {
      self._rawBits = raw
      self._invariantCheck()
    }
  }
}
extension String.Index {
  @inlinable @inline(__always) internal var orderingValue: Swift.UInt64 {
    get { return _rawBits &>> 14 }
  }
  @inlinable @inline(__always) internal var isZeroPosition: Swift.Bool {
    get { return orderingValue == 0 }
  }
  public func utf16Offset<S>(in s: S) -> Swift.Int where S : Swift.StringProtocol
  @available(swift, deprecated: 4.2, message: "encodedOffset has been deprecated as most common usage is incorrect. Use utf16Offset(in:) to achieve the same behavior.")
  @inlinable public var encodedOffset: Swift.Int {
    get { return _encodedOffset }
  }
  @inlinable @inline(__always) internal var _encodedOffset: Swift.Int {
    get {
    return Int(truncatingIfNeeded: _rawBits &>> 16)
  }
  }
  @inlinable @inline(__always) internal var transcodedOffset: Swift.Int {
    get {
    return Int(truncatingIfNeeded: orderingValue & 0x3)
  }
  }
  @usableFromInline
  internal var characterStride: Swift.Int? {
    get
  }
  @inlinable @inline(__always) internal init(encodedOffset: Swift.Int, transcodedOffset: Swift.Int) {
    let pos = UInt64(truncatingIfNeeded: encodedOffset)
    let trans = UInt64(truncatingIfNeeded: transcodedOffset)
    _internalInvariant(pos == pos & 0x0000_FFFF_FFFF_FFFF)
    _internalInvariant(trans <= 3)

    self.init((pos &<< 16) | (trans &<< 14))
  }
  public init<S>(utf16Offset offset: Swift.Int, in s: S) where S : Swift.StringProtocol
  @available(swift, deprecated: 4.2, message: "encodedOffset has been deprecated as most common usage is incorrect. Use String.Index(utf16Offset:in:) to achieve the same behavior.")
  @inlinable public init(encodedOffset offset: Swift.Int) {
    self.init(_encodedOffset: offset)
  }
  @inlinable @inline(__always) internal init(_encodedOffset offset: Swift.Int) {
    self.init(encodedOffset: offset, transcodedOffset: 0)
  }
  @usableFromInline
  internal init(encodedOffset: Swift.Int, transcodedOffset: Swift.Int, characterStride: Swift.Int)
  @usableFromInline
  internal init(encodedOffset pos: Swift.Int, characterStride char: Swift.Int)
  @inlinable @inline(__always) internal func _invariantCheck() {}
}
extension String.Index {
  @inlinable @inline(__always) internal var strippingTranscoding: Swift.String.Index {
    get {
    return String.Index(_encodedOffset: self._encodedOffset)
  }
  }
  @inlinable @inline(__always) internal var nextEncoded: Swift.String.Index {
    get {
    _internalInvariant(self.transcodedOffset == 0)
    return String.Index(_encodedOffset: self._encodedOffset &+ 1)
  }
  }
  @inlinable @inline(__always) internal var priorEncoded: Swift.String.Index {
    get {
    _internalInvariant(self.transcodedOffset == 0)
    return String.Index(_encodedOffset: self._encodedOffset &- 1)
  }
  }
  @inlinable @inline(__always) internal var nextTranscoded: Swift.String.Index {
    get {
    return String.Index(
      encodedOffset: self._encodedOffset,
      transcodedOffset: self.transcodedOffset &+ 1)
  }
  }
  @inlinable @inline(__always) internal var priorTranscoded: Swift.String.Index {
    get {
    return String.Index(
      encodedOffset: self._encodedOffset,
      transcodedOffset: self.transcodedOffset &- 1)
  }
  }
  @inlinable @inline(__always) internal func encoded(offsetBy n: Swift.Int) -> Swift.String.Index {
    return String.Index(_encodedOffset: self._encodedOffset &+ n)
  }
  @inlinable @inline(__always) internal func transcoded(withOffset n: Swift.Int) -> Swift.String.Index {
    _internalInvariant(self.transcodedOffset == 0)
    return String.Index(encodedOffset: self._encodedOffset, transcodedOffset: n)
  }
}
extension String.Index {
  @_alwaysEmitIntoClient @inline(__always) internal var _isScalarAligned: Swift.Bool {
    get { return 0 != _rawBits & 0x1 }
  }
  @_alwaysEmitIntoClient @inline(__always) internal var _scalarAligned: Swift.String.Index {
    get {
    var idx = self
    idx._rawBits |= 0x1
    idx._invariantCheck()
    return idx
  }
  }
}
extension String.Index : Swift.Equatable {
  @inlinable @inline(__always) public static func == (lhs: Swift.String.Index, rhs: Swift.String.Index) -> Swift.Bool {
    return lhs.orderingValue == rhs.orderingValue
  }
}
extension String.Index : Swift.Comparable {
  @inlinable @inline(__always) public static func < (lhs: Swift.String.Index, rhs: Swift.String.Index) -> Swift.Bool {
    return lhs.orderingValue < rhs.orderingValue
  }
}
extension String.Index : Swift.Hashable {
  @inlinable public func hash(into hasher: inout Swift.Hasher) {
    hasher.combine(orderingValue)
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension String.Index {
  public init?(_ sourcePosition: Swift.String.Index, within target: Swift.String)
  @available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
  public init?<S>(_ sourcePosition: Swift.String.Index, within target: S) where S : Swift.StringProtocol
  public func samePosition(in utf8: Swift.String.UTF8View) -> Swift.String.UTF8View.Index?
  public func samePosition(in utf16: Swift.String.UTF16View) -> Swift.String.UTF16View.Index?
}
@frozen public struct DefaultStringInterpolation : Swift.StringInterpolationProtocol {
  @usableFromInline
  internal var _storage: Swift.String
  @inlinable public init(literalCapacity: Swift.Int, interpolationCount: Swift.Int) {
    let capacityPerInterpolation = 2
    let initialCapacity = literalCapacity +
      interpolationCount * capacityPerInterpolation
    _storage = String._createEmpty(withInitialCapacity: initialCapacity)
  }
  @inlinable public mutating func appendLiteral(_ literal: Swift.String) {
    literal.write(to: &self)
  }
  @inlinable public mutating func appendInterpolation<T>(_ value: T) where T : Swift.CustomStringConvertible, T : Swift.TextOutputStreamable {
    value.write(to: &self)
  }
  @inlinable public mutating func appendInterpolation<T>(_ value: T) where T : Swift.TextOutputStreamable {
    value.write(to: &self)
  }
  @inlinable public mutating func appendInterpolation<T>(_ value: T) where T : Swift.CustomStringConvertible {
    value.description.write(to: &self)
  }
  @inlinable public mutating func appendInterpolation<T>(_ value: T) {
    _print_unlocked(value, &self)
  }
  @_alwaysEmitIntoClient public mutating func appendInterpolation(_ value: Any.Type) {
	  _typeName(value, qualified: false).write(to: &self)
  }
  @inlinable __consuming internal func make() -> Swift.String {
    return _storage
  }
  public typealias StringLiteralType = Swift.String
}
extension DefaultStringInterpolation : Swift.CustomStringConvertible {
  @inlinable public var description: Swift.String {
    get {
    return _storage
  }
  }
}
extension DefaultStringInterpolation : Swift.TextOutputStream {
  @inlinable public mutating func write(_ string: Swift.String) {
    _storage.append(string)
  }
  public mutating func _writeASCII(_ buffer: Swift.UnsafeBufferPointer<Swift.UInt8>)
}
extension String {
  @inlinable @_effects(readonly) public init(stringInterpolation: Swift.DefaultStringInterpolation) {
    self = stringInterpolation.make()
  }
}
extension Substring {
  @inlinable @_effects(readonly) public init(stringInterpolation: Swift.DefaultStringInterpolation) {
    self.init(stringInterpolation.make())
  }
}
extension String {
  public init(repeating repeatedValue: Swift.String, count: Swift.Int)
  @inlinable public var isEmpty: Swift.Bool {
    @inline(__always) get { return _guts.isEmpty }
  }
}
extension StringProtocol {
  @inlinable public func hasPrefix<Prefix>(_ prefix: Prefix) -> Swift.Bool where Prefix : Swift.StringProtocol {
    return self.starts(with: prefix)
  }
  @inlinable public func hasSuffix<Suffix>(_ suffix: Suffix) -> Swift.Bool where Suffix : Swift.StringProtocol {
    return self.reversed().starts(with: suffix.reversed())
  }
}
extension String {
  public func hasPrefix(_ prefix: Swift.String) -> Swift.Bool
  public func hasSuffix(_ suffix: Swift.String) -> Swift.Bool
}
extension String {
  public init<T>(_ value: T, radix: Swift.Int = 10, uppercase: Swift.Bool = false) where T : Swift.BinaryInteger
}
extension String : Swift.StringProtocol {
  public typealias StringInterpolation = Swift.DefaultStringInterpolation
}
extension String : Swift.RangeReplaceableCollection {
  public init(repeating repeatedValue: Swift.Character, count: Swift.Int)
  @_specialize(exported: false, kind: full, where S == Swift.String)
  @_specialize(exported: false, kind: full, where S == Swift.Substring)
  public init<S>(_ other: S) where S : Swift.LosslessStringConvertible, S : Swift.Sequence, S.Element == Swift.Character
  @_specialize(exported: false, kind: full, where S == Swift.String)
  @_specialize(exported: false, kind: full, where S == Swift.Substring)
  @_specialize(exported: false, kind: full, where S == Swift.Array<Swift.Character>)
  public init<S>(_ characters: S) where S : Swift.Sequence, S.Element == Swift.Character
  public mutating func reserveCapacity(_ n: Swift.Int)
  @_semantics("string.append") public mutating func append(_ other: Swift.String)
  public mutating func append(_ c: Swift.Character)
  public mutating func append(contentsOf newElements: Swift.String)
  public mutating func append(contentsOf newElements: Swift.Substring)
  @_specialize(exported: false, kind: full, where S == Swift.String)
  @_specialize(exported: false, kind: full, where S == Swift.Substring)
  @_specialize(exported: false, kind: full, where S == Swift.Array<Swift.Character>)
  public mutating func append<S>(contentsOf newElements: S) where S : Swift.Sequence, S.Element == Swift.Character
  @_specialize(exported: false, kind: full, where C == Swift.String)
  @_specialize(exported: false, kind: full, where C == Swift.Substring)
  @_specialize(exported: false, kind: full, where C == Swift.Array<Swift.Character>)
  public mutating func replaceSubrange<C>(_ bounds: Swift.Range<Swift.String.Index>, with newElements: C) where C : Swift.Collection, C.Element == Swift.Character
  public mutating func insert(_ newElement: Swift.Character, at i: Swift.String.Index)
  @_specialize(exported: false, kind: full, where S == Swift.String)
  @_specialize(exported: false, kind: full, where S == Swift.Substring)
  @_specialize(exported: false, kind: full, where S == Swift.Array<Swift.Character>)
  public mutating func insert<S>(contentsOf newElements: S, at i: Swift.String.Index) where S : Swift.Collection, S.Element == Swift.Character
  @discardableResult
  public mutating func remove(at i: Swift.String.Index) -> Swift.Character
  public mutating func removeSubrange(_ bounds: Swift.Range<Swift.String.Index>)
  public mutating func removeAll(keepingCapacity keepCapacity: Swift.Bool = false)
}
extension String {
  @inlinable @inline(__always) internal func _boundsCheck(_ index: Swift.String.Index) {
    _precondition(index._encodedOffset >= 0 && index._encodedOffset < _guts.count,
      "String index is out of bounds")
  }
  @inlinable @inline(__always) internal func _boundsCheck(_ range: Swift.Range<Swift.String.Index>) {
    _precondition(
      range.lowerBound._encodedOffset >= 0 &&
      range.upperBound._encodedOffset <= _guts.count,
      "String index range is out of bounds")
  }
  @inlinable @inline(__always) internal func _boundsCheck(_ range: Swift.ClosedRange<Swift.String.Index>) {
    _precondition(
      range.lowerBound._encodedOffset >= 0 &&
      range.upperBound._encodedOffset < _guts.count,
      "String index range is out of bounds")
  }
}
extension String {
  @_transparent public func max<T>(_ x: T, _ y: T) -> T where T : Swift.Comparable {
    return Swift.max(x,y)
  }
  @_transparent public func min<T>(_ x: T, _ y: T) -> T where T : Swift.Comparable {
    return Swift.min(x,y)
  }
}
extension Sequence where Self.Element == Swift.String {
  @available(*, unavailable, message: "Operator '+' cannot be used to append a String to a sequence of strings")
  public static func + (lhs: Self, rhs: Swift.String) -> Swift.Never
  @available(*, unavailable, message: "Operator '+' cannot be used to append a String to a sequence of strings")
  public static func + (lhs: Swift.String, rhs: Self) -> Swift.Never
}
@_semantics("findStringSwitchCase") public func _findStringSwitchCase(cases: [Swift.StaticString], string: Swift.String) -> Swift.Int
@frozen public struct _OpaqueStringSwitchCache {
  internal var a: Builtin.Word
  internal var b: Builtin.Word
}
@_semantics("findStringSwitchCaseWithCache") public func _findStringSwitchCaseWithCache(cases: [Swift.StaticString], string: Swift.String, cache: inout Swift._OpaqueStringSwitchCache) -> Swift.Int
public struct _StringRepresentation {
  public var _isASCII: Swift.Bool
  public var _count: Swift.Int
  public var _capacity: Swift.Int
  public enum _Form {
    case _small
    case _cocoa(object: Swift.AnyObject)
    case _native(object: Swift.AnyObject)
    case _immortal(address: Swift.UInt)
  }
  public var _form: Swift._StringRepresentation._Form
  public var _objectIdentifier: Swift.ObjectIdentifier? {
    get
  }
}
extension String {
  public func _classify() -> Swift._StringRepresentation
  @_alwaysEmitIntoClient public func _deconstructUTF8<ToPointer>(scratch: Swift.UnsafeMutableRawBufferPointer?) -> (owner: Swift.AnyObject?, ToPointer, length: Swift.Int, usesScratch: Swift.Bool, allocatedMemory: Swift.Bool) where ToPointer : Swift._Pointer {
    _guts._deconstructUTF8(scratch: scratch)
  }
}
extension _StringGuts {
  @_alwaysEmitIntoClient internal func _deconstructUTF8<ToPointer>(scratch: Swift.UnsafeMutableRawBufferPointer?) -> (owner: Swift.AnyObject?, ToPointer, length: Swift.Int, usesScratch: Swift.Bool, allocatedMemory: Swift.Bool) where ToPointer : Swift._Pointer {

    // If we're small, try to copy into the scratch space provided
    if self.isSmall {
      let smol = self.asSmall
      if let scratch = scratch, scratch.count > smol.count {
        let scratchStart =
          scratch.baseAddress!
        smol.withUTF8 { smolUTF8 -> () in
          scratchStart.initializeMemory(
            as: UInt8.self, from: smolUTF8.baseAddress!, count: smolUTF8.count)
        }
        scratch[smol.count] = 0
        return (
          owner: nil,
          _convertPointerToPointerArgument(scratchStart),
          length: smol.count,
          usesScratch: true, allocatedMemory: false)
      }
    } else if _fastPath(self.isFastUTF8) {
      let ptr: ToPointer =
        _convertPointerToPointerArgument(self._object.fastUTF8.baseAddress!)
      return (
        owner: self._object.owner,
        ptr,
        length: self._object.count,
        usesScratch: false, allocatedMemory: false)
    }

    let (object, ptr, len) = self._allocateForDeconstruct()
    return (
      owner: object,
      _convertPointerToPointerArgument(ptr),
      length: len,
      usesScratch: false,
      allocatedMemory: true)
  }
  @_alwaysEmitIntoClient @inline(never) internal func _allocateForDeconstruct() -> (owner: Swift.AnyObject, Swift.UnsafeRawPointer, length: Swift.Int) {
    let utf8 = Array(String(self).utf8) + [0]
    let (owner, ptr): (AnyObject?, UnsafeRawPointer) =
      _convertConstArrayToPointerArgument(utf8)

    // Array's owner cannot be nil, even though it is declared optional...
    return (owner: owner!, ptr, length: utf8.count - 1)
  }
}
extension String {
  @frozen public struct UnicodeScalarView {
    @usableFromInline
    internal var _guts: Swift._StringGuts
    @inlinable @inline(__always) internal init(_ _guts: Swift._StringGuts) {
      self._guts = _guts
      _invariantCheck()
    }
  }
}
extension String.UnicodeScalarView {
  @inlinable @inline(__always) internal func _invariantCheck() {}
}
extension String.UnicodeScalarView : Swift.BidirectionalCollection {
  public typealias Index = Swift.String.Index
  @inlinable @inline(__always) public var startIndex: Swift.String.UnicodeScalarView.Index {
    get { return _guts.startIndex }
  }
  @inlinable @inline(__always) public var endIndex: Swift.String.UnicodeScalarView.Index {
    get { return _guts.endIndex }
  }
  @inlinable @inline(__always) public func index(after i: Swift.String.UnicodeScalarView.Index) -> Swift.String.UnicodeScalarView.Index {
    let i = _guts.scalarAlign(i)
    _internalInvariant(i < endIndex)
    // TODO(String performance): isASCII fast-path

    if _fastPath(_guts.isFastUTF8) {
      let len = _guts.fastUTF8ScalarLength(startingAt: i._encodedOffset)
      return i.encoded(offsetBy: len)._scalarAligned
    }

    return _foreignIndex(after: i)
  }
  @_alwaysEmitIntoClient public func distance(from start: Swift.String.UnicodeScalarView.Index, to end: Swift.String.UnicodeScalarView.Index) -> Swift.Int {
    return _distance(from: _guts.scalarAlign(start), to: _guts.scalarAlign(end))
  }
  @inlinable @inline(__always) public func index(before i: Swift.String.UnicodeScalarView.Index) -> Swift.String.UnicodeScalarView.Index {
    let i = _guts.scalarAlign(i)
    precondition(i._encodedOffset > 0)
    // TODO(String performance): isASCII fast-path

    if _fastPath(_guts.isFastUTF8) {
      let len = _guts.withFastUTF8 { utf8 -> Int in
        return _utf8ScalarLength(utf8, endingAt: i._encodedOffset)
      }
      _internalInvariant(len <= 4, "invalid UTF8")
      return i.encoded(offsetBy: -len)._scalarAligned
    }

    return _foreignIndex(before: i)
  }
  @inlinable @inline(__always) public subscript(position: Swift.String.UnicodeScalarView.Index) -> Swift.Unicode.Scalar {
    get {
    String(_guts)._boundsCheck(position)
    let i = _guts.scalarAlign(position)
    return _guts.errorCorrectedScalar(startingAt: i._encodedOffset).0
  }
  }
  public typealias Element = Swift.Unicode.Scalar
  public typealias Indices = Swift.DefaultIndices<Swift.String.UnicodeScalarView>
}
extension String.UnicodeScalarView {
  @frozen public struct Iterator : Swift.IteratorProtocol {
    @usableFromInline
    internal var _guts: Swift._StringGuts
    @usableFromInline
    internal var _position: Swift.Int = 0
    @usableFromInline
    internal var _end: Swift.Int
    @inlinable internal init(_ guts: Swift._StringGuts) {
      self._end = guts.count
      self._guts = guts
    }
    @inlinable @inline(__always) public mutating func next() -> Swift.Unicode.Scalar? {
      guard _fastPath(_position < _end) else { return nil }

      let (result, len) = _guts.errorCorrectedScalar(startingAt: _position)
      _position &+= len
      return result
    }
    public typealias Element = Swift.Unicode.Scalar
  }
  @inlinable __consuming public func makeIterator() -> Swift.String.UnicodeScalarView.Iterator {
    return Iterator(_guts)
  }
}
extension String.UnicodeScalarView : Swift.CustomStringConvertible {
  @inlinable @inline(__always) public var description: Swift.String {
    get { return String(_guts) }
  }
}
extension String.UnicodeScalarView : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
extension String {
  @inlinable @inline(__always) public init(_ unicodeScalars: Swift.String.UnicodeScalarView) {
    self.init(unicodeScalars._guts)
  }
  public typealias UnicodeScalarIndex = Swift.String.UnicodeScalarView.Index
  @inlinable public var unicodeScalars: Swift.String.UnicodeScalarView {
    @inline(__always) get { return UnicodeScalarView(_guts) }
    @inline(__always) set { _guts = newValue._guts }
  }
}
extension String.UnicodeScalarView : Swift.RangeReplaceableCollection {
  @inlinable @inline(__always) public init() {
    self.init(_StringGuts())
  }
  public mutating func reserveCapacity(_ n: Swift.Int)
  public mutating func append(_ c: Swift.Unicode.Scalar)
  public mutating func append<S>(contentsOf newElements: S) where S : Swift.Sequence, S.Element == Swift.Unicode.Scalar
  public mutating func replaceSubrange<C>(_ bounds: Swift.Range<Swift.String.UnicodeScalarView.Index>, with newElements: C) where C : Swift.Collection, C.Element == Swift.Unicode.Scalar
}
extension String.Index {
  public init?(_ sourcePosition: Swift.String.Index, within unicodeScalars: Swift.String.UnicodeScalarView)
  public func samePosition(in characters: Swift.String) -> Swift.String.Index?
}
extension String.UnicodeScalarView : Swift.CustomReflectable {
  public var customMirror: Swift.Mirror {
    get
  }
}
extension String.UnicodeScalarView {
  public typealias SubSequence = Swift.Substring.UnicodeScalarView
  @available(swift 4)
  public subscript(r: Swift.Range<Swift.String.UnicodeScalarView.Index>) -> Swift.String.UnicodeScalarView.SubSequence {
    get
  }
}
extension String.UnicodeScalarView {
  @usableFromInline
  @inline(never) @_effects(releasenone) internal func _foreignIndex(after i: Swift.String.UnicodeScalarView.Index) -> Swift.String.UnicodeScalarView.Index
  @usableFromInline
  @inline(never) @_effects(releasenone) internal func _foreignIndex(before i: Swift.String.UnicodeScalarView.Index) -> Swift.String.UnicodeScalarView.Index
}
extension String {
  @frozen public struct UTF16View {
    @usableFromInline
    internal var _guts: Swift._StringGuts
    @inlinable internal init(_ guts: Swift._StringGuts) {
      self._guts = guts
      _invariantCheck()
    }
  }
}
extension String.UTF16View {
  @inlinable @inline(__always) internal func _invariantCheck() {}
}
extension String.UTF16View : Swift.BidirectionalCollection {
  public typealias Index = Swift.String.Index
  @inlinable @inline(__always) public var startIndex: Swift.String.UTF16View.Index {
    get { return _guts.startIndex }
  }
  @inlinable @inline(__always) public var endIndex: Swift.String.UTF16View.Index {
    get { return _guts.endIndex }
  }
  @inlinable @inline(__always) public func index(after idx: Swift.String.UTF16View.Index) -> Swift.String.UTF16View.Index {
    if _slowPath(_guts.isForeign) { return _foreignIndex(after: idx) }
    if _guts.isASCII { return idx.nextEncoded }

    // For a BMP scalar (1-3 UTF-8 code units), advance past it. For a non-BMP
    // scalar, use a transcoded offset first.

    // TODO: If transcoded is 1, can we just skip ahead 4?

    let idx = _utf16AlignNativeIndex(idx)
    let len = _guts.fastUTF8ScalarLength(startingAt: idx._encodedOffset)
    if len == 4 && idx.transcodedOffset == 0 {
      return idx.nextTranscoded
    }
    return idx.strippingTranscoding.encoded(offsetBy: len)._scalarAligned
  }
  @inlinable @inline(__always) public func index(before idx: Swift.String.UTF16View.Index) -> Swift.String.UTF16View.Index {
    precondition(!idx.isZeroPosition)
    if _slowPath(_guts.isForeign) { return _foreignIndex(before: idx) }
    if _guts.isASCII { return idx.priorEncoded }

    if idx.transcodedOffset != 0 {
      _internalInvariant(idx.transcodedOffset == 1)
      return idx.strippingTranscoding
    }

    let idx = _utf16AlignNativeIndex(idx)
    let len = _guts.fastUTF8ScalarLength(endingAt: idx._encodedOffset)
    if len == 4 {
      // 2 UTF-16 code units comprise this scalar; advance to the beginning and
      // start mid-scalar transcoding
      return idx.encoded(offsetBy: -len).nextTranscoded
    }

    // Single UTF-16 code unit
    _internalInvariant((1...3) ~= len)
    return idx.encoded(offsetBy: -len)._scalarAligned
  }
  public func index(_ i: Swift.String.UTF16View.Index, offsetBy n: Swift.Int) -> Swift.String.UTF16View.Index
  public func index(_ i: Swift.String.UTF16View.Index, offsetBy n: Swift.Int, limitedBy limit: Swift.String.UTF16View.Index) -> Swift.String.UTF16View.Index?
  public func distance(from start: Swift.String.UTF16View.Index, to end: Swift.String.UTF16View.Index) -> Swift.Int
  @inlinable public var count: Swift.Int {
    get {
    if _slowPath(_guts.isForeign) {
      return _foreignCount()
    }
    return _nativeGetOffset(for: endIndex)
  }
  }
  @inlinable @inline(__always) public subscript(idx: Swift.String.UTF16View.Index) -> Swift.UTF16.CodeUnit {
    get {
    String(_guts)._boundsCheck(idx)

    if _fastPath(_guts.isFastUTF8) {
      let scalar = _guts.fastUTF8Scalar(
        startingAt: _guts.scalarAlign(idx)._encodedOffset)
      return scalar.utf16[idx.transcodedOffset]
    }

    return _foreignSubscript(position: idx)
  }
  }
  public typealias Element = Swift.UTF16.CodeUnit
  public typealias Indices = Swift.DefaultIndices<Swift.String.UTF16View>
}
extension String.UTF16View {
  @frozen public struct Iterator : Swift.IteratorProtocol {
    @usableFromInline
    internal var _guts: Swift._StringGuts
    @usableFromInline
    internal var _position: Swift.Int = 0
    @usableFromInline
    internal var _end: Swift.Int
    @usableFromInline
    internal var _nextIsTrailingSurrogate: Swift.UInt16? = nil
    @inlinable internal init(_ guts: Swift._StringGuts) {
      self._end = guts.count
      self._guts = guts
    }
    @inlinable public mutating func next() -> Swift.UInt16? {
      if _slowPath(_nextIsTrailingSurrogate != nil) {
        let trailing = self._nextIsTrailingSurrogate._unsafelyUnwrappedUnchecked
        self._nextIsTrailingSurrogate = nil
        return trailing
      }
      guard _fastPath(_position < _end) else { return nil }

      let (scalar, len) = _guts.errorCorrectedScalar(startingAt: _position)
      _position &+= len

      if _slowPath(scalar.value > UInt16.max) {
        self._nextIsTrailingSurrogate = scalar.utf16[1]
        return scalar.utf16[0]
      }
      return UInt16(truncatingIfNeeded: scalar.value)
    }
    public typealias Element = Swift.UInt16
  }
  @inlinable __consuming public func makeIterator() -> Swift.String.UTF16View.Iterator {
    return Iterator(_guts)
  }
}
extension String.UTF16View : Swift.CustomStringConvertible {
  @inlinable @inline(__always) public var description: Swift.String {
    get { return String(_guts) }
  }
}
extension String.UTF16View : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
extension String {
  @inlinable public var utf16: Swift.String.UTF16View {
    @inline(__always) get { return UTF16View(_guts) }
    @inline(__always) set { self = String(newValue._guts) }
  }
  @available(swift 4.0)
  @inlinable @inline(__always) public init(_ utf16: Swift.String.UTF16View) {
    self.init(utf16._guts)
  }
}
extension String.Index {
  public init?(_ idx: Swift.String.Index, within target: Swift.String.UTF16View)
  public func samePosition(in unicodeScalars: Swift.String.UnicodeScalarView) -> Swift.String.UnicodeScalarIndex?
}
extension String.UTF16View : Swift.CustomReflectable {
  public var customMirror: Swift.Mirror {
    get
  }
}
extension String.UTF16View {
  public typealias SubSequence = Swift.Substring.UTF16View
  public subscript(r: Swift.Range<Swift.String.UTF16View.Index>) -> Swift.Substring.UTF16View {
    get
  }
}
extension String.UTF16View {
  @usableFromInline
  @inline(never) @_effects(releasenone) internal func _foreignIndex(after i: Swift.String.UTF16View.Index) -> Swift.String.UTF16View.Index
  @usableFromInline
  @inline(never) @_effects(releasenone) internal func _foreignIndex(before i: Swift.String.UTF16View.Index) -> Swift.String.UTF16View.Index
  @usableFromInline
  @inline(never) @_effects(releasenone) internal func _foreignSubscript(position i: Swift.String.UTF16View.Index) -> Swift.UTF16.CodeUnit
  @usableFromInline
  @inline(never) @_effects(releasenone) internal func _foreignDistance(from start: Swift.String.UTF16View.Index, to end: Swift.String.UTF16View.Index) -> Swift.Int
  @usableFromInline
  @inline(never) @_effects(releasenone) internal func _foreignIndex(_ i: Swift.String.UTF16View.Index, offsetBy n: Swift.Int, limitedBy limit: Swift.String.UTF16View.Index) -> Swift.String.UTF16View.Index?
  @usableFromInline
  @inline(never) @_effects(releasenone) internal func _foreignIndex(_ i: Swift.String.UTF16View.Index, offsetBy n: Swift.Int) -> Swift.String.UTF16View.Index
  @usableFromInline
  @inline(never) @_effects(releasenone) internal func _foreignCount() -> Swift.Int
  @_alwaysEmitIntoClient @inline(__always) internal func _utf16AlignNativeIndex(_ idx: Swift.String.Index) -> Swift.String.Index {
    _internalInvariant(!_guts.isForeign)
    guard idx.transcodedOffset == 0 else { return idx }
    return _guts.scalarAlign(idx)
  }
}
extension String.Index {
  @usableFromInline
  @inline(never) @_effects(releasenone) internal func _foreignIsWithin(_ target: Swift.String.UTF16View) -> Swift.Bool
}
extension String.UTF16View {
  @usableFromInline
  @_effects(releasenone) internal func _nativeGetOffset(for idx: Swift.String.UTF16View.Index) -> Swift.Int
  @usableFromInline
  @_effects(releasenone) internal func _nativeGetIndex(for offset: Swift.Int) -> Swift.String.UTF16View.Index
}
extension String {
  @frozen public struct UTF8View {
    @usableFromInline
    internal var _guts: Swift._StringGuts
    @inlinable @inline(__always) internal init(_ guts: Swift._StringGuts) {
      self._guts = guts
      _invariantCheck()
    }
  }
}
extension String.UTF8View {
  @inlinable @inline(__always) internal func _invariantCheck() {}
}
extension String.UTF8View : Swift.BidirectionalCollection {
  public typealias Index = Swift.String.Index
  public typealias Element = Swift.UTF8.CodeUnit
  @inlinable @inline(__always) public var startIndex: Swift.String.UTF8View.Index {
    get { return _guts.startIndex }
  }
  @inlinable @inline(__always) public var endIndex: Swift.String.UTF8View.Index {
    get { return _guts.endIndex }
  }
  @inlinable @inline(__always) public func index(after i: Swift.String.UTF8View.Index) -> Swift.String.UTF8View.Index {
    if _fastPath(_guts.isFastUTF8) {
      return i.strippingTranscoding.nextEncoded
    }

    return _foreignIndex(after: i)
  }
  @inlinable @inline(__always) public func index(before i: Swift.String.UTF8View.Index) -> Swift.String.UTF8View.Index {
    precondition(!i.isZeroPosition)
    if _fastPath(_guts.isFastUTF8) {
      return i.strippingTranscoding.priorEncoded
    }

    return _foreignIndex(before: i)
  }
  @inlinable @inline(__always) public func index(_ i: Swift.String.UTF8View.Index, offsetBy n: Swift.Int) -> Swift.String.UTF8View.Index {
    if _fastPath(_guts.isFastUTF8) {
      _precondition(n + i._encodedOffset <= _guts.count)
      return i.strippingTranscoding.encoded(offsetBy: n)
    }

    return _foreignIndex(i, offsetBy: n)
  }
  @inlinable @inline(__always) public func index(_ i: Swift.String.UTF8View.Index, offsetBy n: Swift.Int, limitedBy limit: Swift.String.UTF8View.Index) -> Swift.String.UTF8View.Index? {
    if _fastPath(_guts.isFastUTF8) {
      // Check the limit: ignore limit if it precedes `i` (in the correct
      // direction), otherwise must not be beyond limit (in the correct
      // direction).
      let iOffset = i._encodedOffset
      let result = iOffset + n
      let limitOffset = limit._encodedOffset
      if n >= 0 {
        guard limitOffset < iOffset || result <= limitOffset else { return nil }
      } else {
        guard limitOffset > iOffset || result >= limitOffset else { return nil }
      }
      return Index(_encodedOffset: result)
    }

    return _foreignIndex(i, offsetBy: n, limitedBy: limit)
  }
  @inlinable @inline(__always) public func distance(from i: Swift.String.UTF8View.Index, to j: Swift.String.UTF8View.Index) -> Swift.Int {
    if _fastPath(_guts.isFastUTF8) {
      return j._encodedOffset &- i._encodedOffset
    }
    return _foreignDistance(from: i, to: j)
  }
  @inlinable @inline(__always) public subscript(i: Swift.String.UTF8View.Index) -> Swift.UTF8.CodeUnit {
    get {
    String(_guts)._boundsCheck(i)
    if _fastPath(_guts.isFastUTF8) {
      return _guts.withFastUTF8 { utf8 in utf8[_unchecked: i._encodedOffset] }
    }

    return _foreignSubscript(position: i)
  }
  }
  public typealias Indices = Swift.DefaultIndices<Swift.String.UTF8View>
  public typealias Iterator = Swift.IndexingIterator<Swift.String.UTF8View>
}
extension String.UTF8View : Swift.CustomStringConvertible {
  @inlinable @inline(__always) public var description: Swift.String {
    get { return String(_guts) }
  }
}
extension String.UTF8View : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
extension String {
  @inlinable public var utf8: Swift.String.UTF8View {
    @inline(__always) get { return UTF8View(self._guts) }
    set { self = String(newValue._guts) }
  }
  public var utf8CString: Swift.ContiguousArray<Swift.CChar> {
    get
  }
  @usableFromInline
  @inline(never) internal func _slowUTF8CString() -> Swift.ContiguousArray<Swift.CChar>
  @available(swift, introduced: 4.0, message: "Please use failable String.init?(_:UTF8View) when in Swift 3.2 mode")
  @inlinable @inline(__always) public init(_ utf8: Swift.String.UTF8View) {
    self = String(utf8._guts)
  }
}
extension String.UTF8View {
  @inlinable @inline(__always) public var count: Swift.Int {
    get {
    if _fastPath(_guts.isFastUTF8) {
      return _guts.count
    }
    return _foreignCount()
  }
  }
}
extension String.Index {
  @inlinable public init?(_ idx: Swift.String.Index, within target: Swift.String.UTF8View) {
    if _slowPath(target._guts.isForeign) {
      guard idx._foreignIsWithin(target) else { return nil }
    } else {
      // All indices, except sub-scalar UTF-16 indices pointing at trailing
      // surrogates, are valid.
      guard idx.transcodedOffset == 0 else { return nil }
    }

    self = idx
  }
}
extension String.UTF8View : Swift.CustomReflectable {
  public var customMirror: Swift.Mirror {
    get
  }
}
extension String.UTF8View {
  public typealias SubSequence = Swift.Substring.UTF8View
  @available(swift 4)
  @inlinable public subscript(r: Swift.Range<Swift.String.UTF8View.Index>) -> Swift.String.UTF8View.SubSequence {
    get {
    return Substring.UTF8View(self, _bounds: r)
  }
  }
}
extension String.UTF8View {
  @inlinable @inline(__always) public func _copyContents(initializing buffer: Swift.UnsafeMutableBufferPointer<Swift.String.UTF8View.Iterator.Element>) -> (Swift.IndexingIterator<Swift.String.UTF8View>, Swift.UnsafeMutableBufferPointer<Swift.String.UTF8View.Iterator.Element>.Index) {
    guard buffer.baseAddress != nil else {
        _preconditionFailure(
          "Attempt to copy string contents into nil buffer pointer")
    }
    guard let written = _guts.copyUTF8(into: buffer) else {
      _preconditionFailure(
        "Insufficient space allocated to copy string contents")
    }

    let it = String().utf8.makeIterator()
    return (it, buffer.index(buffer.startIndex, offsetBy: written))
  }
}
extension String.UTF8View {
  @usableFromInline
  @inline(never) @_effects(releasenone) internal func _foreignIndex(after idx: Swift.String.UTF8View.Index) -> Swift.String.UTF8View.Index
  @usableFromInline
  @inline(never) @_effects(releasenone) internal func _foreignIndex(before idx: Swift.String.UTF8View.Index) -> Swift.String.UTF8View.Index
  @usableFromInline
  @inline(never) @_effects(releasenone) internal func _foreignSubscript(position idx: Swift.String.UTF8View.Index) -> Swift.UTF8.CodeUnit
  @usableFromInline
  @inline(never) @_effects(releasenone) internal func _foreignIndex(_ i: Swift.String.UTF8View.Index, offsetBy n: Swift.Int) -> Swift.String.UTF8View.Index
  @usableFromInline
  @inline(never) @_effects(releasenone) internal func _foreignIndex(_ i: Swift.String.UTF8View.Index, offsetBy n: Swift.Int, limitedBy limit: Swift.String.UTF8View.Index) -> Swift.String.UTF8View.Index?
  @usableFromInline
  @inline(never) @_effects(releasenone) internal func _foreignDistance(from i: Swift.String.UTF8View.Index, to j: Swift.String.UTF8View.Index) -> Swift.Int
  @usableFromInline
  @inline(never) @_effects(releasenone) internal func _foreignCount() -> Swift.Int
}
extension String.Index {
  @usableFromInline
  @inline(never) @_effects(releasenone) internal func _foreignIsWithin(_ target: Swift.String.UTF8View) -> Swift.Bool
}
extension String.UTF8View {
  @inlinable public func withContiguousStorageIfAvailable<R>(_ body: (Swift.UnsafeBufferPointer<Swift.String.UTF8View.Element>) throws -> R) rethrows -> R? {
    guard _guts.isFastUTF8 else { return nil }
    return try _guts.withFastUTF8(body)
  }
}
extension String {
  @inlinable public init(_ substring: __shared Swift.Substring) {
    self = String._fromSubstring(substring)
  }
}
@frozen public struct Substring {
  @usableFromInline
  internal var _slice: Swift.Slice<Swift.String>
  @inlinable internal init(_ slice: Swift.Slice<Swift.String>) {
    let _guts = slice.base._guts
    let start = _guts.scalarAlign(slice.startIndex)
    let end = _guts.scalarAlign(slice.endIndex)

    self._slice = Slice(
      base: slice.base,
      bounds: Range(_uncheckedBounds: (start, end)))
    _invariantCheck()
  }
  @inlinable @inline(__always) public init() {
    self.init(Slice())
  }
}
extension Substring {
  @_alwaysEmitIntoClient public var base: Swift.String {
    get { return _slice.base }
  }
  @inlinable @inline(__always) internal var _wholeGuts: Swift._StringGuts {
    get { return base._guts }
  }
  @inlinable @inline(__always) internal var _offsetRange: Swift.Range<Swift.Int> {
    get {
    return Range(
      _uncheckedBounds: (startIndex._encodedOffset, endIndex._encodedOffset))
  }
  }
  @inlinable @inline(__always) internal func _invariantCheck() {}
}
extension Substring : Swift.StringProtocol {
  public typealias Index = Swift.String.Index
  public typealias SubSequence = Swift.Substring
  @inlinable @inline(__always) public var startIndex: Swift.Substring.Index {
    get { return _slice.startIndex }
  }
  @inlinable @inline(__always) public var endIndex: Swift.Substring.Index {
    get { return _slice.endIndex }
  }
  @inlinable @inline(__always) public func index(after i: Swift.Substring.Index) -> Swift.Substring.Index {
    _precondition(i < endIndex, "Cannot increment beyond endIndex")
    _precondition(i >= startIndex, "Cannot increment an invalid index")
    return _slice.index(after: i)
  }
  @inlinable @inline(__always) public func index(before i: Swift.Substring.Index) -> Swift.Substring.Index {
    _precondition(i <= endIndex, "Cannot decrement an invalid index")
    _precondition(i > startIndex, "Cannot decrement beyond startIndex")
    return _slice.index(before: i)
  }
  @inlinable @inline(__always) public func index(_ i: Swift.Substring.Index, offsetBy n: Swift.Int) -> Swift.Substring.Index {
    let result = _slice.index(i, offsetBy: n)
    _precondition(
      (_slice._startIndex ... _slice.endIndex).contains(result),
      "Operation results in an invalid index")
    return result
  }
  @inlinable @inline(__always) public func index(_ i: Swift.Substring.Index, offsetBy n: Swift.Int, limitedBy limit: Swift.Substring.Index) -> Swift.Substring.Index? {
    let result = _slice.index(i, offsetBy: n, limitedBy: limit)
    _precondition(result.map {
        (_slice._startIndex ... _slice.endIndex).contains($0)
      } ?? true,
      "Operation results in an invalid index")
    return result
  }
  @inlinable @inline(__always) public func distance(from start: Swift.Substring.Index, to end: Swift.Substring.Index) -> Swift.Int {
    return _slice.distance(from: start, to: end)
  }
  public subscript(i: Swift.Substring.Index) -> Swift.Character {
    get
  }
  public mutating func replaceSubrange<C>(_ bounds: Swift.Range<Swift.Substring.Index>, with newElements: C) where C : Swift.Collection, C.Element == Swift.Substring.Iterator.Element
  public mutating func replaceSubrange(_ bounds: Swift.Range<Swift.Substring.Index>, with newElements: Swift.Substring)
  @inlinable public init<C, Encoding>(decoding codeUnits: C, as sourceEncoding: Encoding.Type) where C : Swift.Collection, Encoding : Swift._UnicodeEncoding, C.Element == Encoding.CodeUnit {
    self.init(String(decoding: codeUnits, as: sourceEncoding))
  }
  public init(cString nullTerminatedUTF8: Swift.UnsafePointer<Swift.CChar>)
  @inlinable public init<Encoding>(decodingCString nullTerminatedCodeUnits: Swift.UnsafePointer<Encoding.CodeUnit>, as sourceEncoding: Encoding.Type) where Encoding : Swift._UnicodeEncoding {
    self.init(
      String(decodingCString: nullTerminatedCodeUnits, as: sourceEncoding))
  }
  @inlinable public func withCString<Result>(_ body: (Swift.UnsafePointer<Swift.CChar>) throws -> Result) rethrows -> Result {
    // TODO(String performance): Detect when we cover the rest of a nul-
    // terminated String, and thus can avoid a copy.
    return try String(self).withCString(body)
  }
  @inlinable public func withCString<Result, TargetEncoding>(encodedAs targetEncoding: TargetEncoding.Type, _ body: (Swift.UnsafePointer<TargetEncoding.CodeUnit>) throws -> Result) rethrows -> Result where TargetEncoding : Swift._UnicodeEncoding {
    // TODO(String performance): Detect when we cover the rest of a nul-
    // terminated String, and thus can avoid a copy.
    return try String(self).withCString(encodedAs: targetEncoding, body)
  }
  public typealias Element = Swift.Character
  public typealias Indices = Swift.DefaultIndices<Swift.Substring>
  public typealias Iterator = Swift.IndexingIterator<Swift.Substring>
  public typealias StringInterpolation = Swift.DefaultStringInterpolation
  public var hashValue: Swift.Int {
    get
  }
}
extension Substring : Swift.CustomReflectable {
  public var customMirror: Swift.Mirror {
    get
  }
}
extension Substring : Swift.CustomStringConvertible {
  @inlinable @inline(__always) public var description: Swift.String {
    get { return String(self) }
  }
}
extension Substring : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
extension Substring : Swift.LosslessStringConvertible {
  public init(_ content: Swift.String)
}
extension Substring {
  @frozen public struct UTF8View {
    @usableFromInline
    internal var _slice: Swift.Slice<Swift.String.UTF8View>
  }
}
extension Substring.UTF8View : Swift.BidirectionalCollection {
  public typealias Index = Swift.String.UTF8View.Index
  public typealias Indices = Swift.String.UTF8View.Indices
  public typealias Element = Swift.String.UTF8View.Element
  public typealias SubSequence = Swift.Substring.UTF8View
  @inlinable internal init(_ base: Swift.String.UTF8View, _bounds: Swift.Range<Swift.Substring.UTF8View.Index>) {
    _slice = Slice(
      base: String(base._guts).utf8,
      bounds: _bounds)
  }
  @inlinable public var startIndex: Swift.Substring.UTF8View.Index {
    get { return _slice.startIndex }
  }
  @inlinable public var endIndex: Swift.Substring.UTF8View.Index {
    get { return _slice.endIndex }
  }
  @inlinable public subscript(index: Swift.Substring.UTF8View.Index) -> Swift.Substring.UTF8View.Element {
    get { return _slice[index] }
  }
  @inlinable public var indices: Swift.Substring.UTF8View.Indices {
    get { return _slice.indices }
  }
  @inlinable public func index(after i: Swift.Substring.UTF8View.Index) -> Swift.Substring.UTF8View.Index { return _slice.index(after: i) }
  @inlinable public func formIndex(after i: inout Swift.Substring.UTF8View.Index) {
    _slice.formIndex(after: &i)
  }
  @inlinable public func index(_ i: Swift.Substring.UTF8View.Index, offsetBy n: Swift.Int) -> Swift.Substring.UTF8View.Index {
    return _slice.index(i, offsetBy: n)
  }
  @inlinable public func index(_ i: Swift.Substring.UTF8View.Index, offsetBy n: Swift.Int, limitedBy limit: Swift.Substring.UTF8View.Index) -> Swift.Substring.UTF8View.Index? {
    return _slice.index(i, offsetBy: n, limitedBy: limit)
  }
  @inlinable public func distance(from start: Swift.Substring.UTF8View.Index, to end: Swift.Substring.UTF8View.Index) -> Swift.Int {
    return _slice.distance(from: start, to: end)
  }
  @_alwaysEmitIntoClient @inlinable public func withContiguousStorageIfAvailable<R>(_ body: (Swift.UnsafeBufferPointer<Swift.Substring.UTF8View.Element>) throws -> R) rethrows -> R? {
    return try _slice.withContiguousStorageIfAvailable(body)
  }
  @inlinable public func _failEarlyRangeCheck(_ index: Swift.Substring.UTF8View.Index, bounds: Swift.Range<Swift.Substring.UTF8View.Index>) {
    _slice._failEarlyRangeCheck(index, bounds: bounds)
  }
  @inlinable public func _failEarlyRangeCheck(_ range: Swift.Range<Swift.Substring.UTF8View.Index>, bounds: Swift.Range<Swift.Substring.UTF8View.Index>) {
    _slice._failEarlyRangeCheck(range, bounds: bounds)
  }
  @inlinable public func index(before i: Swift.Substring.UTF8View.Index) -> Swift.Substring.UTF8View.Index { return _slice.index(before: i) }
  @inlinable public func formIndex(before i: inout Swift.Substring.UTF8View.Index) {
    _slice.formIndex(before: &i)
  }
  @inlinable public subscript(r: Swift.Range<Swift.Substring.UTF8View.Index>) -> Swift.Substring.UTF8View {
    get {
    // FIXME(strings): tests.
    _precondition(r.lowerBound >= startIndex && r.upperBound <= endIndex,
      "UTF8View index range out of bounds")
    return Substring.UTF8View(_slice.base, _bounds: r)
  }
  }
  public typealias Iterator = Swift.IndexingIterator<Swift.Substring.UTF8View>
}
extension Substring {
  @inlinable public var utf8: Swift.Substring.UTF8View {
    get {
      return base.utf8[startIndex..<endIndex]
    }
    set {
      self = Substring(newValue)
    }
  }
  public init(_ content: Swift.Substring.UTF8View)
}
extension String {
  public init?(_ codeUnits: Swift.Substring.UTF8View)
}
extension Substring {
  @frozen public struct UTF16View {
    @usableFromInline
    internal var _slice: Swift.Slice<Swift.String.UTF16View>
  }
}
extension Substring.UTF16View : Swift.BidirectionalCollection {
  public typealias Index = Swift.String.UTF16View.Index
  public typealias Indices = Swift.String.UTF16View.Indices
  public typealias Element = Swift.String.UTF16View.Element
  public typealias SubSequence = Swift.Substring.UTF16View
  @inlinable internal init(_ base: Swift.String.UTF16View, _bounds: Swift.Range<Swift.Substring.UTF16View.Index>) {
    _slice = Slice(
      base: String(base._guts).utf16,
      bounds: _bounds)
  }
  @inlinable public var startIndex: Swift.Substring.UTF16View.Index {
    get { return _slice.startIndex }
  }
  @inlinable public var endIndex: Swift.Substring.UTF16View.Index {
    get { return _slice.endIndex }
  }
  @inlinable public subscript(index: Swift.Substring.UTF16View.Index) -> Swift.Substring.UTF16View.Element {
    get { return _slice[index] }
  }
  @inlinable public var indices: Swift.Substring.UTF16View.Indices {
    get { return _slice.indices }
  }
  @inlinable public func index(after i: Swift.Substring.UTF16View.Index) -> Swift.Substring.UTF16View.Index { return _slice.index(after: i) }
  @inlinable public func formIndex(after i: inout Swift.Substring.UTF16View.Index) {
    _slice.formIndex(after: &i)
  }
  @inlinable public func index(_ i: Swift.Substring.UTF16View.Index, offsetBy n: Swift.Int) -> Swift.Substring.UTF16View.Index {
    return _slice.index(i, offsetBy: n)
  }
  @inlinable public func index(_ i: Swift.Substring.UTF16View.Index, offsetBy n: Swift.Int, limitedBy limit: Swift.Substring.UTF16View.Index) -> Swift.Substring.UTF16View.Index? {
    return _slice.index(i, offsetBy: n, limitedBy: limit)
  }
  @inlinable public func distance(from start: Swift.Substring.UTF16View.Index, to end: Swift.Substring.UTF16View.Index) -> Swift.Int {
    return _slice.distance(from: start, to: end)
  }
  @inlinable public func _failEarlyRangeCheck(_ index: Swift.Substring.UTF16View.Index, bounds: Swift.Range<Swift.Substring.UTF16View.Index>) {
    _slice._failEarlyRangeCheck(index, bounds: bounds)
  }
  @inlinable public func _failEarlyRangeCheck(_ range: Swift.Range<Swift.Substring.UTF16View.Index>, bounds: Swift.Range<Swift.Substring.UTF16View.Index>) {
    _slice._failEarlyRangeCheck(range, bounds: bounds)
  }
  @inlinable public func index(before i: Swift.Substring.UTF16View.Index) -> Swift.Substring.UTF16View.Index { return _slice.index(before: i) }
  @inlinable public func formIndex(before i: inout Swift.Substring.UTF16View.Index) {
    _slice.formIndex(before: &i)
  }
  @inlinable public subscript(r: Swift.Range<Swift.Substring.UTF16View.Index>) -> Swift.Substring.UTF16View {
    get {
    return Substring.UTF16View(_slice.base, _bounds: r)
  }
  }
  public typealias Iterator = Swift.IndexingIterator<Swift.Substring.UTF16View>
}
extension Substring {
  @inlinable public var utf16: Swift.Substring.UTF16View {
    get {
      return base.utf16[startIndex..<endIndex]
    }
    set {
      self = Substring(newValue)
    }
  }
  public init(_ content: Swift.Substring.UTF16View)
}
extension String {
  public init?(_ codeUnits: Swift.Substring.UTF16View)
}
extension Substring {
  @frozen public struct UnicodeScalarView {
    @usableFromInline
    internal var _slice: Swift.Slice<Swift.String.UnicodeScalarView>
  }
}
extension Substring.UnicodeScalarView : Swift.BidirectionalCollection {
  public typealias Index = Swift.String.UnicodeScalarView.Index
  public typealias Indices = Swift.String.UnicodeScalarView.Indices
  public typealias Element = Swift.String.UnicodeScalarView.Element
  public typealias SubSequence = Swift.Substring.UnicodeScalarView
  @inlinable internal init(_ base: Swift.String.UnicodeScalarView, _bounds: Swift.Range<Swift.Substring.UnicodeScalarView.Index>) {
    _slice = Slice(
      base: String(base._guts).unicodeScalars,
      bounds: _bounds)
  }
  @inlinable public var startIndex: Swift.Substring.UnicodeScalarView.Index {
    get { return _slice.startIndex }
  }
  @inlinable public var endIndex: Swift.Substring.UnicodeScalarView.Index {
    get { return _slice.endIndex }
  }
  @inlinable public subscript(index: Swift.Substring.UnicodeScalarView.Index) -> Swift.Substring.UnicodeScalarView.Element {
    get { return _slice[index] }
  }
  @inlinable public var indices: Swift.Substring.UnicodeScalarView.Indices {
    get { return _slice.indices }
  }
  @inlinable public func index(after i: Swift.Substring.UnicodeScalarView.Index) -> Swift.Substring.UnicodeScalarView.Index { return _slice.index(after: i) }
  @inlinable public func formIndex(after i: inout Swift.Substring.UnicodeScalarView.Index) {
    _slice.formIndex(after: &i)
  }
  @inlinable public func index(_ i: Swift.Substring.UnicodeScalarView.Index, offsetBy n: Swift.Int) -> Swift.Substring.UnicodeScalarView.Index {
    return _slice.index(i, offsetBy: n)
  }
  @inlinable public func index(_ i: Swift.Substring.UnicodeScalarView.Index, offsetBy n: Swift.Int, limitedBy limit: Swift.Substring.UnicodeScalarView.Index) -> Swift.Substring.UnicodeScalarView.Index? {
    return _slice.index(i, offsetBy: n, limitedBy: limit)
  }
  @inlinable public func distance(from start: Swift.Substring.UnicodeScalarView.Index, to end: Swift.Substring.UnicodeScalarView.Index) -> Swift.Int {
    return _slice.distance(from: start, to: end)
  }
  @inlinable public func _failEarlyRangeCheck(_ index: Swift.Substring.UnicodeScalarView.Index, bounds: Swift.Range<Swift.Substring.UnicodeScalarView.Index>) {
    _slice._failEarlyRangeCheck(index, bounds: bounds)
  }
  @inlinable public func _failEarlyRangeCheck(_ range: Swift.Range<Swift.Substring.UnicodeScalarView.Index>, bounds: Swift.Range<Swift.Substring.UnicodeScalarView.Index>) {
    _slice._failEarlyRangeCheck(range, bounds: bounds)
  }
  @inlinable public func index(before i: Swift.Substring.UnicodeScalarView.Index) -> Swift.Substring.UnicodeScalarView.Index { return _slice.index(before: i) }
  @inlinable public func formIndex(before i: inout Swift.Substring.UnicodeScalarView.Index) {
    _slice.formIndex(before: &i)
  }
  @inlinable public subscript(r: Swift.Range<Swift.Substring.UnicodeScalarView.Index>) -> Swift.Substring.UnicodeScalarView {
    get {
    return Substring.UnicodeScalarView(_slice.base, _bounds: r)
  }
  }
  public typealias Iterator = Swift.IndexingIterator<Swift.Substring.UnicodeScalarView>
}
extension Substring {
  @inlinable public var unicodeScalars: Swift.Substring.UnicodeScalarView {
    get {
      return base.unicodeScalars[startIndex..<endIndex]
    }
    set {
      self = Substring(newValue)
    }
  }
  public init(_ content: Swift.Substring.UnicodeScalarView)
}
extension String {
  public init(_ content: Swift.Substring.UnicodeScalarView)
}
extension Substring.UnicodeScalarView : Swift.RangeReplaceableCollection {
  @inlinable public init() { _slice = Slice.init() }
  public mutating func replaceSubrange<C>(_ target: Swift.Range<Swift.Substring.UnicodeScalarView.Index>, with replacement: C) where C : Swift.Collection, C.Element == Swift.Substring.UnicodeScalarView.Element
}
extension Substring : Swift.RangeReplaceableCollection {
  @_specialize(exported: false, kind: full, where S == Swift.String)
  @_specialize(exported: false, kind: full, where S == Swift.Substring)
  @_specialize(exported: false, kind: full, where S == Swift.Array<Swift.Character>)
  public init<S>(_ elements: S) where S : Swift.Sequence, S.Element == Swift.Character
  @inlinable public mutating func append<S>(contentsOf elements: S) where S : Swift.Sequence, S.Element == Swift.Character {
    var string = String(self)
    self = Substring() // Keep unique storage if possible
    string.append(contentsOf: elements)
    self = Substring(string)
  }
}
extension Substring {
  public func lowercased() -> Swift.String
  public func uppercased() -> Swift.String
  public func filter(_ isIncluded: (Swift.Substring.Element) throws -> Swift.Bool) rethrows -> Swift.String
}
extension Substring : Swift.TextOutputStream {
  public mutating func write(_ other: Swift.String)
}
extension Substring : Swift.TextOutputStreamable {
  @inlinable public func write<Target>(to target: inout Target) where Target : Swift.TextOutputStream {
    target.write(String(self))
  }
}
extension Substring : Swift.ExpressibleByUnicodeScalarLiteral {
  @inlinable public init(unicodeScalarLiteral value: Swift.String) {
     self.init(value)
  }
  public typealias UnicodeScalarLiteralType = Swift.String
}
extension Substring : Swift.ExpressibleByExtendedGraphemeClusterLiteral {
  @inlinable public init(extendedGraphemeClusterLiteral value: Swift.String) {
     self.init(value)
  }
  public typealias ExtendedGraphemeClusterLiteralType = Swift.String
}
extension Substring : Swift.ExpressibleByStringLiteral {
  @inlinable public init(stringLiteral value: Swift.String) {
     self.init(value)
  }
  public typealias StringLiteralType = Swift.String
}
extension String {
  @available(swift 4)
  public subscript(r: Swift.Range<Swift.String.Index>) -> Swift.Substring {
    get
  }
}
extension Substring {
  @available(swift 4)
  public subscript(r: Swift.Range<Swift.Substring.Index>) -> Swift.Substring {
    get
  }
}
@usableFromInline
@_transparent internal func _isValidArrayIndex(_ index: Swift.Int, count: Swift.Int) -> Swift.Bool {
  return (index >= 0) && (index <= count)
}
@usableFromInline
@_transparent internal func _isValidArraySubscript(_ index: Swift.Int, count: Swift.Int) -> Swift.Bool {
  return (index >= 0) && (index < count)
}
@objc @_inheritsConvenienceInitializers @usableFromInline
@_fixed_layout internal class __SwiftNativeNSArrayWithContiguousStorage : Swift.__SwiftNativeNSArray {
  @inlinable @nonobjc override internal init() { super.init() }
  @objc @inlinable deinit {}
}
@_hasMissingDesignatedInitializers @usableFromInline
@_fixed_layout @objc final internal class _SwiftNSMutableArray : Swift._SwiftNativeNSMutableArray {
  final internal var contents: [Swift.AnyObject]
  @inlinable override internal init()
  @objc @usableFromInline
  deinit
}
@usableFromInline
@_fixed_layout @objc final internal class __SwiftDeferredNSArray : Swift.__SwiftNativeNSArrayWithContiguousStorage {
  @nonobjc final internal var _heapBufferBridged_DoNotUse: Swift.AnyObject?
  @usableFromInline
  @nonobjc final internal let _nativeStorage: Swift.__ContiguousArrayStorageBase
  @inlinable @nonobjc internal init(_nativeStorage: Swift.__ContiguousArrayStorageBase) {
    self._nativeStorage = _nativeStorage
  }
  @objc deinit
  @inlinable override internal init()
}
@objc @usableFromInline
@_fixed_layout internal class __ContiguousArrayStorageBase : Swift.__SwiftNativeNSArrayWithContiguousStorage {
  @usableFromInline
  final internal var countAndCapacity: Swift._ArrayBody
  @inlinable @nonobjc internal init(_doNotCallMeBase: ()) {
    _internalInvariantFailure("creating instance of __ContiguousArrayStorageBase")
  }
  @inlinable internal func canStoreElements(ofDynamicType _: Any.Type) -> Swift.Bool {
    _internalInvariantFailure(
      "Concrete subclasses must implement canStoreElements(ofDynamicType:)")
  }
  @inlinable internal var staticElementType: Any.Type {
    get {
    _internalInvariantFailure(
      "Concrete subclasses must implement staticElementType")
  }
  }
  @objc @inlinable deinit {
    _internalInvariant(
      self !== _emptyArrayStorage, "Deallocating empty array storage?!")
  }
  @inlinable override internal init()
}
@frozen public struct _UIntBuffer<Element> where Element : Swift.FixedWidthInteger, Element : Swift.UnsignedInteger {
  public typealias Storage = Swift.UInt32
  public var _storage: Swift._UIntBuffer<Element>.Storage
  public var _bitCount: Swift.UInt8
  @inlinable @inline(__always) public init(_storage: Swift._UIntBuffer<Element>.Storage, _bitCount: Swift.UInt8) {
    self._storage = _storage
    self._bitCount = _bitCount
  }
  @inlinable @inline(__always) public init(containing e: Element) {
    _storage = Storage(truncatingIfNeeded: e)
    _bitCount = UInt8(truncatingIfNeeded: Element.bitWidth)
  }
}
extension _UIntBuffer : Swift.Sequence {
  public typealias SubSequence = Swift.Slice<Swift._UIntBuffer<Element>>
  @frozen public struct Iterator : Swift.IteratorProtocol, Swift.Sequence {
    @inlinable @inline(__always) public init(_ x: Swift._UIntBuffer<Element>) { _impl = x }
    @inlinable @inline(__always) public mutating func next() -> Element? {
      if _impl._bitCount == 0 { return nil }
      defer {
        _impl._storage = _impl._storage &>> Element.bitWidth
        _impl._bitCount = _impl._bitCount &- _impl._elementWidth
      }
      return Element(truncatingIfNeeded: _impl._storage)
    }
    public var _impl: Swift._UIntBuffer<Element>
    public typealias Iterator = Swift._UIntBuffer<Element>.Iterator
  }
  @inlinable @inline(__always) public func makeIterator() -> Swift._UIntBuffer<Element>.Iterator {
    return Iterator(self)
  }
}
extension _UIntBuffer : Swift.Collection {
  @frozen public struct Index : Swift.Comparable {
    @usableFromInline
    internal var bitOffset: Swift.UInt8
    @inlinable internal init(bitOffset: Swift.UInt8) { self.bitOffset = bitOffset }
    @inlinable public static func == (lhs: Swift._UIntBuffer<Element>.Index, rhs: Swift._UIntBuffer<Element>.Index) -> Swift.Bool {
      return lhs.bitOffset == rhs.bitOffset
    }
    @inlinable public static func < (lhs: Swift._UIntBuffer<Element>.Index, rhs: Swift._UIntBuffer<Element>.Index) -> Swift.Bool {
      return lhs.bitOffset < rhs.bitOffset
    }
  }
  @inlinable public var startIndex: Swift._UIntBuffer<Element>.Index {
    @inline(__always) get { return Index(bitOffset: 0) }
  }
  @inlinable public var endIndex: Swift._UIntBuffer<Element>.Index {
    @inline(__always) get { return Index(bitOffset: _bitCount) }
  }
  @inlinable @inline(__always) public func index(after i: Swift._UIntBuffer<Element>.Index) -> Swift._UIntBuffer<Element>.Index {
    return Index(bitOffset: i.bitOffset &+ _elementWidth)
  }
  @inlinable internal var _elementWidth: Swift.UInt8 {
    get {
    return UInt8(truncatingIfNeeded: Element.bitWidth)
  }
  }
  @inlinable public subscript(i: Swift._UIntBuffer<Element>.Index) -> Element {
    @inline(__always) get {
      return Element(truncatingIfNeeded: _storage &>> i.bitOffset)
    }
  }
}
extension _UIntBuffer : Swift.BidirectionalCollection {
  @inlinable @inline(__always) public func index(before i: Swift._UIntBuffer<Element>.Index) -> Swift._UIntBuffer<Element>.Index {
    return Index(bitOffset: i.bitOffset &- _elementWidth)
  }
}
extension _UIntBuffer : Swift.RandomAccessCollection {
  public typealias Indices = Swift.DefaultIndices<Swift._UIntBuffer<Element>>
  @inlinable @inline(__always) public func index(_ i: Swift._UIntBuffer<Element>.Index, offsetBy n: Swift.Int) -> Swift._UIntBuffer<Element>.Index {
    let x = Int(i.bitOffset) &+ n &* Element.bitWidth
    return Index(bitOffset: UInt8(truncatingIfNeeded: x))
  }
  @inlinable @inline(__always) public func distance(from i: Swift._UIntBuffer<Element>.Index, to j: Swift._UIntBuffer<Element>.Index) -> Swift.Int {
    return (Int(j.bitOffset) &- Int(i.bitOffset)) / Element.bitWidth
  }
}
extension FixedWidthInteger {
  @inline(__always) @inlinable internal func _fullShiftLeft<N>(_ n: N) -> Self where N : Swift.FixedWidthInteger {
    return (self &<< ((n &+ 1) &>> 1)) &<< (n &>> 1)
  }
  @inline(__always) @inlinable internal func _fullShiftRight<N>(_ n: N) -> Self where N : Swift.FixedWidthInteger {
    return (self &>> ((n &+ 1) &>> 1)) &>> (n &>> 1)
  }
  @inline(__always) @inlinable internal static func _lowBits<N>(_ n: N) -> Self where N : Swift.FixedWidthInteger {
    return ~((~0 as Self)._fullShiftLeft(n))
  }
}
extension Range {
  @inline(__always) @inlinable internal func _contains_(_ other: Swift.Range<Bound>) -> Swift.Bool {
    return other.clamped(to: self) == other
  }
}
extension _UIntBuffer : Swift.RangeReplaceableCollection {
  @inlinable @inline(__always) public init() {
    _storage = 0
    _bitCount = 0
  }
  @inlinable public var capacity: Swift.Int {
    get {
    return Storage.bitWidth / Element.bitWidth
  }
  }
  @inlinable @inline(__always) public mutating func append(_ newElement: Element) {
    _debugPrecondition(count + 1 <= capacity)
    _storage &= ~(Storage(Element.max) &<< _bitCount)
    _storage |= Storage(newElement) &<< _bitCount
    _bitCount = _bitCount &+ _elementWidth
  }
  @discardableResult
  @inlinable @inline(__always) public mutating func removeFirst() -> Element {
    _debugPrecondition(!isEmpty)
    let result = Element(truncatingIfNeeded: _storage)
    _bitCount = _bitCount &- _elementWidth
    _storage = _storage._fullShiftRight(_elementWidth)
    return result
  }
  @inlinable @inline(__always) public mutating func replaceSubrange<C>(_ target: Swift.Range<Swift._UIntBuffer<Element>.Index>, with replacement: C) where Element == C.Element, C : Swift.Collection {
    _debugPrecondition(
      (0..<_bitCount)._contains_(
        target.lowerBound.bitOffset..<target.upperBound.bitOffset))
    
    let replacement1 = _UIntBuffer(replacement)

    let targetCount = distance(
      from: target.lowerBound, to: target.upperBound)
    let growth = replacement1.count &- targetCount
    _debugPrecondition(count + growth <= capacity)

    let headCount = distance(from: startIndex, to: target.lowerBound)
    let tailOffset = distance(from: startIndex, to: target.upperBound)

    let w = Element.bitWidth
    let headBits = _storage & ._lowBits(headCount &* w)
    let tailBits = _storage._fullShiftRight(tailOffset &* w)

    _storage = headBits
    _storage |= replacement1._storage &<< (headCount &* w)
    _storage |= tailBits &<< ((tailOffset &+ growth) &* w)
    _bitCount = UInt8(
      truncatingIfNeeded: Int(_bitCount) &+ growth &* w)
  }
}
extension String {
  @available(*, unavailable, message: "cannot subscript String with an Int, use a String.Index instead.")
  public subscript(i: Swift.Int) -> Swift.Character {
    get
  }
  @available(*, unavailable, message: "cannot subscript String with an integer range, use a String.Index range instead.")
  public subscript<R>(bounds: R) -> Swift.String where R : Swift.RangeExpression, R.Bound == Swift.Int {
    get
  }
}
public protocol _UnicodeEncoding {
  associatedtype CodeUnit : Swift.FixedWidthInteger, Swift.UnsignedInteger where Self.CodeUnit == Self.EncodedScalar.Element
  associatedtype EncodedScalar : Swift.BidirectionalCollection
  static var encodedReplacementCharacter: Self.EncodedScalar { get }
  static func decode(_ content: Self.EncodedScalar) -> Swift.Unicode.Scalar
  static func encode(_ content: Swift.Unicode.Scalar) -> Self.EncodedScalar?
  static func transcode<FromEncoding>(_ content: FromEncoding.EncodedScalar, from _: FromEncoding.Type) -> Self.EncodedScalar? where FromEncoding : Swift._UnicodeEncoding
  associatedtype ForwardParser : Swift._UnicodeParser where Self == Self.ForwardParser.Encoding, Self.ForwardParser.Encoding == Self.ReverseParser.Encoding
  associatedtype ReverseParser : Swift._UnicodeParser
  static func _isScalar(_ x: Self.CodeUnit) -> Swift.Bool
}
extension _UnicodeEncoding {
  @inlinable public static func _isScalar(_ x: Self.CodeUnit) -> Swift.Bool { return false }
  @inlinable public static func transcode<FromEncoding>(_ content: FromEncoding.EncodedScalar, from _: FromEncoding.Type) -> Self.EncodedScalar? where FromEncoding : Swift._UnicodeEncoding {
    return encode(FromEncoding.decode(content))
  }
  @inlinable internal static func _encode(_ content: Swift.Unicode.Scalar) -> Self.EncodedScalar {
    return encode(content) ?? encodedReplacementCharacter
  }
  @inlinable internal static func _transcode<FromEncoding>(_ content: FromEncoding.EncodedScalar, from _: FromEncoding.Type) -> Self.EncodedScalar where FromEncoding : Swift._UnicodeEncoding {
    return transcode(content, from: FromEncoding.self)
      ?? encodedReplacementCharacter
  }
  @inlinable internal static func _transcode<Source, SourceEncoding>(_ source: Source, from sourceEncoding: SourceEncoding.Type, into processScalar: (Self.EncodedScalar) -> Swift.Void) where Source : Swift.Sequence, SourceEncoding : Swift._UnicodeEncoding, Source.Element == SourceEncoding.CodeUnit {
    var p = SourceEncoding.ForwardParser()
    var i = source.makeIterator()
    while true {
      switch p.parseScalar(from: &i) {
      case .valid(let e): processScalar(_transcode(e, from: sourceEncoding))
      case .error(_): processScalar(encodedReplacementCharacter)
      case .emptyInput: return
      }
    }
  }
}
extension Unicode {
  public typealias Encoding = Swift._UnicodeEncoding
}
@inlinable @inline(__always) internal func _decodeUTF8(_ x: Swift.UInt8) -> Swift.Unicode.Scalar {
  _internalInvariant(UTF8.isASCII(x))
  return Unicode.Scalar(_unchecked: UInt32(x))
}
@inlinable @inline(__always) internal func _decodeUTF8(_ x: Swift.UInt8, _ y: Swift.UInt8) -> Swift.Unicode.Scalar {
  _internalInvariant(_utf8ScalarLength(x) == 2)
  _internalInvariant(UTF8.isContinuation(y))
  let x = UInt32(x)
  let value = ((x & 0b0001_1111) &<< 6) | _continuationPayload(y)
  return Unicode.Scalar(_unchecked: value)
}
@inlinable @inline(__always) internal func _decodeUTF8(_ x: Swift.UInt8, _ y: Swift.UInt8, _ z: Swift.UInt8) -> Swift.Unicode.Scalar {
  _internalInvariant(_utf8ScalarLength(x) == 3)
  _internalInvariant(UTF8.isContinuation(y) && UTF8.isContinuation(z))
  let x = UInt32(x)
  let value = ((x & 0b0000_1111) &<< 12)
            | (_continuationPayload(y) &<< 6)
            | _continuationPayload(z)
  return Unicode.Scalar(_unchecked: value)
}
@inlinable @inline(__always) internal func _decodeUTF8(_ x: Swift.UInt8, _ y: Swift.UInt8, _ z: Swift.UInt8, _ w: Swift.UInt8) -> Swift.Unicode.Scalar {
  _internalInvariant(_utf8ScalarLength(x) == 4)
  _internalInvariant(
    UTF8.isContinuation(y) && UTF8.isContinuation(z)
    && UTF8.isContinuation(w))
  let x = UInt32(x)
  let value = ((x & 0b0000_1111) &<< 18)
            | (_continuationPayload(y) &<< 12)
            | (_continuationPayload(z) &<< 6)
            | _continuationPayload(w)
  return Unicode.Scalar(_unchecked: value)
}
@inlinable internal func _decodeScalar(_ utf8: Swift.UnsafeBufferPointer<Swift.UInt8>, startingAt i: Swift.Int) -> (Swift.Unicode.Scalar, scalarLength: Swift.Int) {
  let cu0 = utf8[_unchecked: i]
  let len = _utf8ScalarLength(cu0)
  switch  len {
  case 1: return (_decodeUTF8(cu0), len)
  case 2: return (_decodeUTF8(cu0, utf8[_unchecked: i &+ 1]), len)
  case 3: return (_decodeUTF8(
    cu0, utf8[_unchecked: i &+ 1], utf8[_unchecked: i &+ 2]), len)
  case 4:
    return (_decodeUTF8(
      cu0,
      utf8[_unchecked: i &+ 1],
      utf8[_unchecked: i &+ 2],
      utf8[_unchecked: i &+ 3]),
    len)
  default: Builtin.unreachable()
  }
}
@inlinable internal func _decodeScalar(_ utf8: Swift.UnsafeBufferPointer<Swift.UInt8>, endingAt i: Swift.Int) -> (Swift.Unicode.Scalar, scalarLength: Swift.Int) {
  let len = _utf8ScalarLength(utf8, endingAt: i)
  let (scalar, scalarLen) = _decodeScalar(utf8, startingAt: i &- len)
  _internalInvariant(len == scalarLen)
  return (scalar, len)
}
@inlinable @inline(__always) internal func _utf8ScalarLength(_ x: Swift.UInt8) -> Swift.Int {
  _internalInvariant(!UTF8.isContinuation(x))
  if UTF8.isASCII(x) { return 1 }
  // TODO(String micro-performance): check codegen
  return (~x).leadingZeroBitCount
}
@inlinable @inline(__always) internal func _utf8ScalarLength(_ utf8: Swift.UnsafeBufferPointer<Swift.UInt8>, endingAt i: Swift.Int) -> Swift.Int {
  var len = 1
  while UTF8.isContinuation(utf8[_unchecked: i &- len]) {
    len &+= 1
  }
  _internalInvariant(len == _utf8ScalarLength(utf8[i &- len]))
  return len
}
@inlinable @inline(__always) internal func _continuationPayload(_ x: Swift.UInt8) -> Swift.UInt32 {
  return UInt32(x & 0x3F)
}
@inlinable internal func _scalarAlign(_ utf8: Swift.UnsafeBufferPointer<Swift.UInt8>, _ idx: Swift.Int) -> Swift.Int {
  guard _fastPath(idx != utf8.count) else { return idx }

  var i = idx
  while _slowPath(UTF8.isContinuation(utf8[_unchecked: i])) {
    i &-= 1
    _internalInvariant(i >= 0,
      "Malformed contents: starts with continuation byte")
  }
  return i
}
extension _StringGuts {
  @inlinable @inline(__always) internal func scalarAlign(_ idx: Swift._StringGuts.Index) -> Swift._StringGuts.Index {
    let result: String.Index
    if _fastPath(idx._isScalarAligned) {
      result = idx
    } else {
      // TODO(String performance): isASCII check
      result = scalarAlignSlow(idx)
    }

    _internalInvariant(isOnUnicodeScalarBoundary(result),
      "Alignment bit is set for non-aligned index")
    _internalInvariant_5_1(result._isScalarAligned)
    return result
  }
  @inline(never) @_alwaysEmitIntoClient internal func scalarAlignSlow(_ idx: Swift._StringGuts.Index) -> Swift._StringGuts.Index {
    _internalInvariant_5_1(!idx._isScalarAligned)

    if _slowPath(idx.transcodedOffset != 0 || idx._encodedOffset == 0) {
      // Transcoded index offsets are already scalar aligned
      return String.Index(_encodedOffset: idx._encodedOffset)._scalarAligned
    }
    if _slowPath(self.isForeign) {
      // In 5.1 this check was added to foreignScalarAlign, but when this is
      // emitted into a client that then runs against a 5.0 stdlib, it calls
      // a version of foreignScalarAlign that doesn't check for this, which
      // ends up asking CFString for its endIndex'th character, which throws
      // an exception. So we duplicate the check here for back deployment.
      guard idx._encodedOffset != self.count else { return idx._scalarAligned }

      let foreignIdx = foreignScalarAlign(idx)
      _internalInvariant_5_1(foreignIdx._isScalarAligned)
      return foreignIdx
    }

    return String.Index(_encodedOffset:
      self.withFastUTF8 { _scalarAlign($0, idx._encodedOffset) }
    )._scalarAligned
  }
  @inlinable internal func fastUTF8ScalarLength(startingAt i: Swift.Int) -> Swift.Int {
    _internalInvariant(isFastUTF8)
    let len = _utf8ScalarLength(self.withFastUTF8 { $0[i] })
    _internalInvariant((1...4) ~= len)
    return len
  }
  @inlinable internal func fastUTF8ScalarLength(endingAt i: Swift.Int) -> Swift.Int {
    _internalInvariant(isFastUTF8)

    return self.withFastUTF8 { utf8 in
      _internalInvariant(i == utf8.count || !UTF8.isContinuation(utf8[i]))
      var len = 1
      while UTF8.isContinuation(utf8[i &- len]) {
        _internalInvariant(i &- len > 0)
        len += 1
      }
      _internalInvariant(len <= 4)
      return len
    }
  }
  @inlinable internal func fastUTF8Scalar(startingAt i: Swift.Int) -> Swift.Unicode.Scalar {
    _internalInvariant(isFastUTF8)
    return self.withFastUTF8 { _decodeScalar($0, startingAt: i).0 }
  }
  @usableFromInline
  @_effects(releasenone) internal func isOnUnicodeScalarBoundary(_ i: Swift.String.Index) -> Swift.Bool
}
extension _StringGuts {
  @usableFromInline
  @_effects(releasenone) internal func foreignErrorCorrectedScalar(startingAt idx: Swift.String.Index) -> (Swift.Unicode.Scalar, scalarLength: Swift.Int)
  @usableFromInline
  @inline(never) @_effects(releasenone) internal func foreignScalarAlign(_ idx: Swift._StringGuts.Index) -> Swift._StringGuts.Index
  @usableFromInline
  @inline(never) @_effects(releasenone) internal func foreignErrorCorrectedGrapheme(startingAt start: Swift.Int, endingAt end: Swift.Int) -> Swift.Character
}
extension _StringGuts {
  @inlinable @inline(__always) internal func errorCorrectedScalar(startingAt i: Swift.Int) -> (Swift.Unicode.Scalar, scalarLength: Swift.Int) {
    if _fastPath(isFastUTF8) {
      return withFastUTF8 { _decodeScalar($0, startingAt: i) }
    }
    return foreignErrorCorrectedScalar(
      startingAt: String.Index(_encodedOffset: i))
  }
  @inlinable @inline(__always) internal func errorCorrectedCharacter(startingAt start: Swift.Int, endingAt end: Swift.Int) -> Swift.Character {
    if _fastPath(isFastUTF8) {
      return withFastUTF8(range: start..<end) { utf8 in
        return Character(unchecked: String._uncheckedFromUTF8(utf8))
      }
    }

    return foreignErrorCorrectedGrapheme(startingAt: start, endingAt: end)
  }
}
extension Unicode {
  @frozen public enum ParseResult<T> {
    case valid(T)
    case emptyInput
    case error(length: Swift.Int)
    @inlinable internal var _valid: T? {
      get {
      if case .valid(let result) = self { return result }
      return nil
    }
    }
    @inlinable internal var _error: Swift.Int? {
      get {
      if case .error(let result) = self { return result }
      return nil
    }
    }
  }
}
public protocol _UnicodeParser {
  associatedtype Encoding : Swift._UnicodeEncoding
  init()
  mutating func parseScalar<I>(from input: inout I) -> Swift.Unicode.ParseResult<Self.Encoding.EncodedScalar> where I : Swift.IteratorProtocol, I.Element == Self.Encoding.CodeUnit
}
extension Unicode {
  public typealias Parser = Swift._UnicodeParser
}
extension Unicode.Scalar {
  public struct Properties {
    @usableFromInline
    internal var _scalar: Swift.Unicode.Scalar
  }
  public var properties: Swift.Unicode.Scalar.Properties {
    get
  }
}
extension Unicode.Scalar.Properties {
  public var isAlphabetic: Swift.Bool {
    get
  }
  public var isASCIIHexDigit: Swift.Bool {
    get
  }
  public var isBidiControl: Swift.Bool {
    get
  }
  public var isBidiMirrored: Swift.Bool {
    get
  }
  public var isDash: Swift.Bool {
    get
  }
  public var isDefaultIgnorableCodePoint: Swift.Bool {
    get
  }
  public var isDeprecated: Swift.Bool {
    get
  }
  public var isDiacritic: Swift.Bool {
    get
  }
  public var isExtender: Swift.Bool {
    get
  }
  public var isFullCompositionExclusion: Swift.Bool {
    get
  }
  public var isGraphemeBase: Swift.Bool {
    get
  }
  public var isGraphemeExtend: Swift.Bool {
    get
  }
  public var isHexDigit: Swift.Bool {
    get
  }
  public var isIDContinue: Swift.Bool {
    get
  }
  public var isIDStart: Swift.Bool {
    get
  }
  public var isIdeographic: Swift.Bool {
    get
  }
  public var isIDSBinaryOperator: Swift.Bool {
    get
  }
  public var isIDSTrinaryOperator: Swift.Bool {
    get
  }
  public var isJoinControl: Swift.Bool {
    get
  }
  public var isLogicalOrderException: Swift.Bool {
    get
  }
  public var isLowercase: Swift.Bool {
    get
  }
  public var isMath: Swift.Bool {
    get
  }
  public var isNoncharacterCodePoint: Swift.Bool {
    get
  }
  public var isQuotationMark: Swift.Bool {
    get
  }
  public var isRadical: Swift.Bool {
    get
  }
  public var isSoftDotted: Swift.Bool {
    get
  }
  public var isTerminalPunctuation: Swift.Bool {
    get
  }
  public var isUnifiedIdeograph: Swift.Bool {
    get
  }
  public var isUppercase: Swift.Bool {
    get
  }
  public var isWhitespace: Swift.Bool {
    get
  }
  public var isXIDContinue: Swift.Bool {
    get
  }
  public var isXIDStart: Swift.Bool {
    get
  }
  public var isSentenceTerminal: Swift.Bool {
    get
  }
  public var isVariationSelector: Swift.Bool {
    get
  }
  public var isPatternSyntax: Swift.Bool {
    get
  }
  public var isPatternWhitespace: Swift.Bool {
    get
  }
  public var isCased: Swift.Bool {
    get
  }
  public var isCaseIgnorable: Swift.Bool {
    get
  }
  public var changesWhenLowercased: Swift.Bool {
    get
  }
  public var changesWhenUppercased: Swift.Bool {
    get
  }
  public var changesWhenTitlecased: Swift.Bool {
    get
  }
  public var changesWhenCaseFolded: Swift.Bool {
    get
  }
  public var changesWhenCaseMapped: Swift.Bool {
    get
  }
  public var changesWhenNFKCCaseFolded: Swift.Bool {
    get
  }
  @available(macOS 10.12.2, iOS 10.2, tvOS 10.1, watchOS 3.1.1, *)
  public var isEmoji: Swift.Bool {
    get
  }
  @available(macOS 10.12.2, iOS 10.2, tvOS 10.1, watchOS 3.1.1, *)
  public var isEmojiPresentation: Swift.Bool {
    get
  }
  @available(macOS 10.12.2, iOS 10.2, tvOS 10.1, watchOS 3.1.1, *)
  public var isEmojiModifier: Swift.Bool {
    get
  }
  @available(macOS 10.12.2, iOS 10.2, tvOS 10.1, watchOS 3.1.1, *)
  public var isEmojiModifierBase: Swift.Bool {
    get
  }
}
extension Unicode.Scalar.Properties {
  public var lowercaseMapping: Swift.String {
    get
  }
  public var titlecaseMapping: Swift.String {
    get
  }
  public var uppercaseMapping: Swift.String {
    get
  }
}
extension Unicode {
  public typealias Version = (major: Swift.Int, minor: Swift.Int)
}
extension Unicode.Scalar.Properties {
  public var age: Swift.Unicode.Version? {
    get
  }
}
extension Unicode {
  public enum GeneralCategory {
    case uppercaseLetter
    case lowercaseLetter
    case titlecaseLetter
    case modifierLetter
    case otherLetter
    case nonspacingMark
    case spacingMark
    case enclosingMark
    case decimalNumber
    case letterNumber
    case otherNumber
    case connectorPunctuation
    case dashPunctuation
    case openPunctuation
    case closePunctuation
    case initialPunctuation
    case finalPunctuation
    case otherPunctuation
    case mathSymbol
    case currencySymbol
    case modifierSymbol
    case otherSymbol
    case spaceSeparator
    case lineSeparator
    case paragraphSeparator
    case control
    case format
    case surrogate
    case privateUse
    case unassigned
    public static func == (a: Swift.Unicode.GeneralCategory, b: Swift.Unicode.GeneralCategory) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
}
extension Unicode.Scalar.Properties {
  public var generalCategory: Swift.Unicode.GeneralCategory {
    get
  }
}
extension Unicode.Scalar.Properties {
  public var name: Swift.String? {
    get
  }
  public var nameAlias: Swift.String? {
    get
  }
}
extension Unicode {
  public struct CanonicalCombiningClass : Swift.Comparable, Swift.Hashable, Swift.RawRepresentable {
    public static let notReordered: Swift.Unicode.CanonicalCombiningClass
    public static let overlay: Swift.Unicode.CanonicalCombiningClass
    public static let nukta: Swift.Unicode.CanonicalCombiningClass
    public static let kanaVoicing: Swift.Unicode.CanonicalCombiningClass
    public static let virama: Swift.Unicode.CanonicalCombiningClass
    public static let attachedBelowLeft: Swift.Unicode.CanonicalCombiningClass
    public static let attachedBelow: Swift.Unicode.CanonicalCombiningClass
    public static let attachedAbove: Swift.Unicode.CanonicalCombiningClass
    public static let attachedAboveRight: Swift.Unicode.CanonicalCombiningClass
    public static let belowLeft: Swift.Unicode.CanonicalCombiningClass
    public static let below: Swift.Unicode.CanonicalCombiningClass
    public static let belowRight: Swift.Unicode.CanonicalCombiningClass
    public static let left: Swift.Unicode.CanonicalCombiningClass
    public static let right: Swift.Unicode.CanonicalCombiningClass
    public static let aboveLeft: Swift.Unicode.CanonicalCombiningClass
    public static let above: Swift.Unicode.CanonicalCombiningClass
    public static let aboveRight: Swift.Unicode.CanonicalCombiningClass
    public static let doubleBelow: Swift.Unicode.CanonicalCombiningClass
    public static let doubleAbove: Swift.Unicode.CanonicalCombiningClass
    public static let iotaSubscript: Swift.Unicode.CanonicalCombiningClass
    public let rawValue: Swift.UInt8
    public init(rawValue: Swift.UInt8)
    public static func == (lhs: Swift.Unicode.CanonicalCombiningClass, rhs: Swift.Unicode.CanonicalCombiningClass) -> Swift.Bool
    public static func < (lhs: Swift.Unicode.CanonicalCombiningClass, rhs: Swift.Unicode.CanonicalCombiningClass) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
    public typealias RawValue = Swift.UInt8
  }
}
extension Unicode.Scalar.Properties {
  public var canonicalCombiningClass: Swift.Unicode.CanonicalCombiningClass {
    get
  }
}
extension Unicode {
  public enum NumericType {
    case decimal
    case digit
    case numeric
    public static func == (a: Swift.Unicode.NumericType, b: Swift.Unicode.NumericType) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
}
extension Unicode.Scalar.Properties {
  public var numericType: Swift.Unicode.NumericType? {
    get
  }
  public var numericValue: Swift.Double? {
    get
  }
}
extension Character {
  @inlinable internal var _firstScalar: Swift.Unicode.Scalar {
    get {
    return self.unicodeScalars.first!
  }
  }
  @inlinable internal var _isSingleScalar: Swift.Bool {
    get {
    return self.unicodeScalars.index(
      after: self.unicodeScalars.startIndex
    ) == self.unicodeScalars.endIndex
  }
  }
  @inlinable public var isASCII: Swift.Bool {
    get {
    return asciiValue != nil
  }
  }
  @inlinable public var asciiValue: Swift.UInt8? {
    get {
    if _slowPath(self == "\r\n") { return 0x000A /* LINE FEED (LF) */ }
    if _slowPath(!_isSingleScalar || _firstScalar.value >= 0x80) { return nil }
    return UInt8(_firstScalar.value)
  }
  }
  public var isWhitespace: Swift.Bool {
    get
  }
  @inlinable public var isNewline: Swift.Bool {
    get {
    switch _firstScalar.value {
      case 0x000A...0x000D /* LF ... CR */: return true
      case 0x0085 /* NEXT LINE (NEL) */: return true
      case 0x2028 /* LINE SEPARATOR */: return true
      case 0x2029 /* PARAGRAPH SEPARATOR */: return true
      default: return false
    }
  }
  }
  public var isNumber: Swift.Bool {
    get
  }
  @inlinable public var isWholeNumber: Swift.Bool {
    get {
    return wholeNumberValue != nil
  }
  }
  public var wholeNumberValue: Swift.Int? {
    get
  }
  @inlinable public var isHexDigit: Swift.Bool {
    get {
    return hexDigitValue != nil
  }
  }
  public var hexDigitValue: Swift.Int? {
    get
  }
  public var isLetter: Swift.Bool {
    get
  }
  public func uppercased() -> Swift.String
  public func lowercased() -> Swift.String
  @usableFromInline
  internal var _isUppercased: Swift.Bool {
    get
  }
  @usableFromInline
  internal var _isLowercased: Swift.Bool {
    get
  }
  @inlinable public var isUppercase: Swift.Bool {
    get {
    if _fastPath(_isSingleScalar && _firstScalar.properties.isUppercase) {
      return true
    }
    return _isUppercased && isCased
  }
  }
  @inlinable public var isLowercase: Swift.Bool {
    get {
    if _fastPath(_isSingleScalar && _firstScalar.properties.isLowercase) {
      return true
    }
    return _isLowercased && isCased
  }
  }
  @inlinable public var isCased: Swift.Bool {
    get {
    if _fastPath(_isSingleScalar && _firstScalar.properties.isCased) {
      return true
    }
    return !_isUppercased || !_isLowercased
  }
  }
  public var isSymbol: Swift.Bool {
    get
  }
  public var isMathSymbol: Swift.Bool {
    get
  }
  public var isCurrencySymbol: Swift.Bool {
    get
  }
  public var isPunctuation: Swift.Bool {
    get
  }
}
@frozen public struct Unmanaged<Instance> where Instance : AnyObject {
  @usableFromInline
  unowned(unsafe) internal var _value: Instance
  @usableFromInline
  @_transparent internal init(_private: Instance) { _value = _private }
  @_transparent public static func fromOpaque(@_nonEphemeral _ value: Swift.UnsafeRawPointer) -> Swift.Unmanaged<Instance> {
    return Unmanaged(_private: unsafeBitCast(value, to: Instance.self))
  }
  @_transparent public func toOpaque() -> Swift.UnsafeMutableRawPointer {
    return unsafeBitCast(_value, to: UnsafeMutableRawPointer.self)
  }
  @_transparent public static func passRetained(_ value: Instance) -> Swift.Unmanaged<Instance> {
    return Unmanaged(_private: value).retain()
  }
  @_transparent public static func passUnretained(_ value: Instance) -> Swift.Unmanaged<Instance> {
    return Unmanaged(_private: value)
  }
  @_transparent public func takeUnretainedValue() -> Instance {
    return _value
  }
  @_transparent public func takeRetainedValue() -> Instance {
    let result = _value
    release()
    return result
  }
  @inlinable @_transparent public func _withUnsafeGuaranteedRef<Result>(_ body: (Instance) throws -> Result) rethrows -> Result {
    var tmp = self
    // Builtin.convertUnownedUnsafeToGuaranteed expects to have a base value
    // that the +0 value depends on. In this case, we are assuming that is done
    // for us opaquely already. So, the builtin will emit a mark_dependence on a
    // trivial object. The optimizer knows to eliminate that so we do not have
    // any overhead from this.
    let fakeBase: Int? = nil
    return try body(Builtin.convertUnownedUnsafeToGuaranteed(fakeBase,
                                                             &tmp._value))
  }
  @_transparent public func retain() -> Swift.Unmanaged<Instance> {
    Builtin.retain(_value)
    return self
  }
  @_transparent public func release() {
    Builtin.release(_value)
  }
  @_transparent public func autorelease() -> Swift.Unmanaged<Instance> {
    Builtin.autorelease(_value)
    return self
  }
}
@frozen public struct UnsafePointer<Pointee> : Swift._Pointer {
  public typealias Distance = Swift.Int
  public let _rawValue: Builtin.RawPointer
  @_transparent public init(_ _rawValue: Builtin.RawPointer) {
    self._rawValue = _rawValue
  }
  @inlinable public func deallocate() {
    // Passing zero alignment to the runtime forces "aligned
    // deallocation". Since allocation via `UnsafeMutable[Raw][Buffer]Pointer`
    // always uses the "aligned allocation" path, this ensures that the
    // runtime's allocation and deallocation paths are compatible.
    Builtin.deallocRaw(_rawValue, (-1)._builtinWordValue, (0)._builtinWordValue)
  }
  @inlinable public var pointee: Pointee {
    @_transparent unsafeAddress {
      return self
    }
  }
  @inlinable public func withMemoryRebound<T, Result>(to type: T.Type, capacity count: Swift.Int, _ body: (Swift.UnsafePointer<T>) throws -> Result) rethrows -> Result {
    Builtin.bindMemory(_rawValue, count._builtinWordValue, T.self)
    defer {
      Builtin.bindMemory(_rawValue, count._builtinWordValue, Pointee.self)
    }
    return try body(UnsafePointer<T>(_rawValue))
  }
  @inlinable public subscript(i: Swift.Int) -> Pointee {
    @_transparent unsafeAddress {
      return self + i
    }
  }
  @inlinable internal static var _max: Swift.UnsafePointer<Pointee> {
    get {
    return UnsafePointer(
      bitPattern: 0 as Int &- MemoryLayout<Pointee>.stride
    )._unsafelyUnwrappedUnchecked
  }
  }
  public typealias Stride = Swift.Int
  public var hashValue: Swift.Int {
    get
  }
}
@frozen public struct UnsafeMutablePointer<Pointee> : Swift._Pointer {
  public typealias Distance = Swift.Int
  public let _rawValue: Builtin.RawPointer
  @_transparent public init(_ _rawValue: Builtin.RawPointer) {
    self._rawValue = _rawValue
  }
  @_transparent public init(@_nonEphemeral mutating other: Swift.UnsafePointer<Pointee>) {
    self._rawValue = other._rawValue
  }
  @_transparent public init?(@_nonEphemeral mutating other: Swift.UnsafePointer<Pointee>?) {
    guard let unwrapped = other else { return nil }
    self.init(mutating: unwrapped)
  }
  @_transparent public init(@_nonEphemeral _ other: Swift.UnsafeMutablePointer<Pointee>) {
   self._rawValue = other._rawValue		
  }
  @_transparent public init?(@_nonEphemeral _ other: Swift.UnsafeMutablePointer<Pointee>?) {
   guard let unwrapped = other else { return nil }		
   self.init(unwrapped)		
  }
  @inlinable public static func allocate(capacity count: Swift.Int) -> Swift.UnsafeMutablePointer<Pointee> {
    let size = MemoryLayout<Pointee>.stride * count
    // For any alignment <= _minAllocationAlignment, force alignment = 0.
    // This forces the runtime's "aligned" allocation path so that
    // deallocation does not require the original alignment.
    //
    // The runtime guarantees:
    //
    // align == 0 || align > _minAllocationAlignment:
    //   Runtime uses "aligned allocation".
    //
    // 0 < align <= _minAllocationAlignment:
    //   Runtime may use either malloc or "aligned allocation".
    var align = Builtin.alignof(Pointee.self)
    if Int(align) <= _minAllocationAlignment() {
      align = (0)._builtinWordValue
    }
    let rawPtr = Builtin.allocRaw(size._builtinWordValue, align)
    Builtin.bindMemory(rawPtr, count._builtinWordValue, Pointee.self)
    return UnsafeMutablePointer(rawPtr)
  }
  @inlinable public func deallocate() {
    // Passing zero alignment to the runtime forces "aligned
    // deallocation". Since allocation via `UnsafeMutable[Raw][Buffer]Pointer`
    // always uses the "aligned allocation" path, this ensures that the
    // runtime's allocation and deallocation paths are compatible.
    Builtin.deallocRaw(_rawValue, (-1)._builtinWordValue, (0)._builtinWordValue)
  }
  @inlinable public var pointee: Pointee {
    @_transparent unsafeAddress {
      return UnsafePointer(self)
    }
    @_transparent nonmutating unsafeMutableAddress {
      return self
    }
  }
  @inlinable public func initialize(repeating repeatedValue: Pointee, count: Swift.Int) {
    // FIXME: add tests (since the `count` has been added)
    _debugPrecondition(count >= 0,
      "UnsafeMutablePointer.initialize(repeating:count:): negative count")
    // Must not use `initializeFrom` with a `Collection` as that will introduce
    // a cycle.
    for offset in 0..<count {
      Builtin.initialize(repeatedValue, (self + offset)._rawValue)
    }
  }
  @inlinable public func initialize(to value: Pointee) {
    Builtin.initialize(value, self._rawValue)
  }
  @inlinable public func move() -> Pointee {
    return Builtin.take(_rawValue)
  }
  @inlinable public func assign(repeating repeatedValue: Pointee, count: Swift.Int) {
    _debugPrecondition(count >= 0, "UnsafeMutablePointer.assign(repeating:count:) with negative count")
    for i in 0..<count {
      self[i] = repeatedValue
    }
  }
  @inlinable public func assign(from source: Swift.UnsafePointer<Pointee>, count: Swift.Int) {
    _debugPrecondition(
      count >= 0, "UnsafeMutablePointer.assign with negative count")
    if UnsafePointer(self) < source || UnsafePointer(self) >= source + count {
      // assign forward from a disjoint or following overlapping range.
      Builtin.assignCopyArrayFrontToBack(
        Pointee.self, self._rawValue, source._rawValue, count._builtinWordValue)
      // This builtin is equivalent to:
      // for i in 0..<count {
      //   self[i] = source[i]
      // }
    }
    else if UnsafePointer(self) != source {
      // assign backward from a non-following overlapping range.
      Builtin.assignCopyArrayBackToFront(
        Pointee.self, self._rawValue, source._rawValue, count._builtinWordValue)
      // This builtin is equivalent to:
      // var i = count-1
      // while i >= 0 {
      //   self[i] = source[i]
      //   i -= 1
      // }
    }
  }
  @inlinable public func moveInitialize(@_nonEphemeral from source: Swift.UnsafeMutablePointer<Pointee>, count: Swift.Int) {
    _debugPrecondition(
      count >= 0, "UnsafeMutablePointer.moveInitialize with negative count")
    if self < source || self >= source + count {
      // initialize forward from a disjoint or following overlapping range.
      Builtin.takeArrayFrontToBack(
        Pointee.self, self._rawValue, source._rawValue, count._builtinWordValue)
      // This builtin is equivalent to:
      // for i in 0..<count {
      //   (self + i).initialize(to: (source + i).move())
      // }
    }
    else {
      // initialize backward from a non-following overlapping range.
      Builtin.takeArrayBackToFront(
        Pointee.self, self._rawValue, source._rawValue, count._builtinWordValue)
      // This builtin is equivalent to:
      // var src = source + count
      // var dst = self + count
      // while dst != self {
      //   (--dst).initialize(to: (--src).move())
      // }
    }
  }
  @inlinable public func initialize(from source: Swift.UnsafePointer<Pointee>, count: Swift.Int) {
    _debugPrecondition(
      count >= 0, "UnsafeMutablePointer.initialize with negative count")
    _debugPrecondition(
      UnsafePointer(self) + count <= source ||
      source + count <= UnsafePointer(self),
      "UnsafeMutablePointer.initialize overlapping range")
    Builtin.copyArray(
      Pointee.self, self._rawValue, source._rawValue, count._builtinWordValue)
    // This builtin is equivalent to:
    // for i in 0..<count {
    //   (self + i).initialize(to: source[i])
    // }
  }
  @inlinable public func moveAssign(@_nonEphemeral from source: Swift.UnsafeMutablePointer<Pointee>, count: Swift.Int) {
    _debugPrecondition(
      count >= 0, "UnsafeMutablePointer.moveAssign(from:) with negative count")
    _debugPrecondition(
      self + count <= source || source + count <= self,
      "moveAssign overlapping range")
    Builtin.assignTakeArray(
      Pointee.self, self._rawValue, source._rawValue, count._builtinWordValue)
    // These builtins are equivalent to:
    // for i in 0..<count {
    //   self[i] = (source + i).move()
    // }
  }
  @discardableResult
  @inlinable public func deinitialize(count: Swift.Int) -> Swift.UnsafeMutableRawPointer {
    _debugPrecondition(count >= 0, "UnsafeMutablePointer.deinitialize with negative count")
    // FIXME: optimization should be implemented, where if the `count` value
    // is 1, the `Builtin.destroy(Pointee.self, _rawValue)` gets called.
    Builtin.destroyArray(Pointee.self, _rawValue, count._builtinWordValue)
    return UnsafeMutableRawPointer(self)
  }
  @inlinable public func withMemoryRebound<T, Result>(to type: T.Type, capacity count: Swift.Int, _ body: (Swift.UnsafeMutablePointer<T>) throws -> Result) rethrows -> Result {
    Builtin.bindMemory(_rawValue, count._builtinWordValue, T.self)
    defer {
      Builtin.bindMemory(_rawValue, count._builtinWordValue, Pointee.self)
    }
    return try body(UnsafeMutablePointer<T>(_rawValue))
  }
  @inlinable public subscript(i: Swift.Int) -> Pointee {
    @_transparent unsafeAddress {
      return UnsafePointer(self + i)
    }
    @_transparent nonmutating unsafeMutableAddress {
      return self + i
    }
  }
  @inlinable internal static var _max: Swift.UnsafeMutablePointer<Pointee> {
    get {
    return UnsafeMutablePointer(
      bitPattern: 0 as Int &- MemoryLayout<Pointee>.stride
    )._unsafelyUnwrappedUnchecked
  }
  }
  public typealias Stride = Swift.Int
  public var hashValue: Swift.Int {
    get
  }
}
@frozen public struct UnsafeRawPointer : Swift._Pointer {
  public typealias Pointee = Swift.UInt8
  public let _rawValue: Builtin.RawPointer
  @_transparent public init(_ _rawValue: Builtin.RawPointer) {
    self._rawValue = _rawValue
  }
  @_transparent public init<T>(@_nonEphemeral _ other: Swift.UnsafePointer<T>) {
    _rawValue = other._rawValue
  }
  @_transparent public init?<T>(@_nonEphemeral _ other: Swift.UnsafePointer<T>?) {
    guard let unwrapped = other else { return nil }
    _rawValue = unwrapped._rawValue
  }
  @_transparent public init(@_nonEphemeral _ other: Swift.UnsafeMutableRawPointer) {
    _rawValue = other._rawValue
  }
  @_transparent public init?(@_nonEphemeral _ other: Swift.UnsafeMutableRawPointer?) {
    guard let unwrapped = other else { return nil }
    _rawValue = unwrapped._rawValue
  }
  @_transparent public init<T>(@_nonEphemeral _ other: Swift.UnsafeMutablePointer<T>) {
   _rawValue = other._rawValue		
  }
  @_transparent public init?<T>(@_nonEphemeral _ other: Swift.UnsafeMutablePointer<T>?) {
   guard let unwrapped = other else { return nil }		
   _rawValue = unwrapped._rawValue		
  }
  @inlinable public func deallocate() {
    // Passing zero alignment to the runtime forces "aligned
    // deallocation". Since allocation via `UnsafeMutable[Raw][Buffer]Pointer`
    // always uses the "aligned allocation" path, this ensures that the
    // runtime's allocation and deallocation paths are compatible.
    Builtin.deallocRaw(_rawValue, (-1)._builtinWordValue, (0)._builtinWordValue)
  }
  @discardableResult
  @_transparent public func bindMemory<T>(to type: T.Type, capacity count: Swift.Int) -> Swift.UnsafePointer<T> {
    Builtin.bindMemory(_rawValue, count._builtinWordValue, type)
    return UnsafePointer<T>(_rawValue)
  }
  @_transparent public func assumingMemoryBound<T>(to: T.Type) -> Swift.UnsafePointer<T> {
    return UnsafePointer<T>(_rawValue)
  }
  @inlinable public func load<T>(fromByteOffset offset: Swift.Int = 0, as type: T.Type) -> T {
    _debugPrecondition(0 == (UInt(bitPattern: self + offset)
        & (UInt(MemoryLayout<T>.alignment) - 1)),
      "load from misaligned raw pointer")

    return Builtin.loadRaw((self + offset)._rawValue)
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension UnsafeRawPointer : Swift.Strideable {
  @_transparent public func advanced(by n: Swift.Int) -> Swift.UnsafeRawPointer {
    return UnsafeRawPointer(Builtin.gepRaw_Word(_rawValue, n._builtinWordValue))
  }
  public typealias Stride = Swift.Int
}
@frozen public struct UnsafeMutableRawPointer : Swift._Pointer {
  public typealias Pointee = Swift.UInt8
  public let _rawValue: Builtin.RawPointer
  @_transparent public init(_ _rawValue: Builtin.RawPointer) {
    self._rawValue = _rawValue
  }
  @_transparent public init<T>(@_nonEphemeral _ other: Swift.UnsafeMutablePointer<T>) {
    _rawValue = other._rawValue
  }
  @_transparent public init?<T>(@_nonEphemeral _ other: Swift.UnsafeMutablePointer<T>?) {
    guard let unwrapped = other else { return nil }
    _rawValue = unwrapped._rawValue
  }
  @_transparent public init(@_nonEphemeral mutating other: Swift.UnsafeRawPointer) {
    _rawValue = other._rawValue
  }
  @_transparent public init?(@_nonEphemeral mutating other: Swift.UnsafeRawPointer?) {
    guard let unwrapped = other else { return nil }
    _rawValue = unwrapped._rawValue
  }
  @inlinable public static func allocate(byteCount: Swift.Int, alignment: Swift.Int) -> Swift.UnsafeMutableRawPointer {
    // For any alignment <= _minAllocationAlignment, force alignment = 0.
    // This forces the runtime's "aligned" allocation path so that
    // deallocation does not require the original alignment.
    //
    // The runtime guarantees:
    //
    // align == 0 || align > _minAllocationAlignment:
    //   Runtime uses "aligned allocation".
    //
    // 0 < align <= _minAllocationAlignment:
    //   Runtime may use either malloc or "aligned allocation".
    var alignment = alignment
    if alignment <= _minAllocationAlignment() {
      alignment = 0
    }
    return UnsafeMutableRawPointer(Builtin.allocRaw(
        byteCount._builtinWordValue, alignment._builtinWordValue))
  }
  @inlinable public func deallocate() {
    // Passing zero alignment to the runtime forces "aligned
    // deallocation". Since allocation via `UnsafeMutable[Raw][Buffer]Pointer`
    // always uses the "aligned allocation" path, this ensures that the
    // runtime's allocation and deallocation paths are compatible.
    Builtin.deallocRaw(_rawValue, (-1)._builtinWordValue, (0)._builtinWordValue)
  }
  @discardableResult
  @_transparent public func bindMemory<T>(to type: T.Type, capacity count: Swift.Int) -> Swift.UnsafeMutablePointer<T> {
    Builtin.bindMemory(_rawValue, count._builtinWordValue, type)
    return UnsafeMutablePointer<T>(_rawValue)
  }
  @_transparent public func assumingMemoryBound<T>(to: T.Type) -> Swift.UnsafeMutablePointer<T> {
    return UnsafeMutablePointer<T>(_rawValue)
  }
  @discardableResult
  @inlinable public func initializeMemory<T>(as type: T.Type, repeating repeatedValue: T, count: Swift.Int) -> Swift.UnsafeMutablePointer<T> {
    _debugPrecondition(count >= 0,
      "UnsafeMutableRawPointer.initializeMemory: negative count")

    Builtin.bindMemory(_rawValue, count._builtinWordValue, type)
    var nextPtr = self
    for _ in 0..<count {
      Builtin.initialize(repeatedValue, nextPtr._rawValue)
      nextPtr += MemoryLayout<T>.stride
    }
    return UnsafeMutablePointer(_rawValue)
  }
  @discardableResult
  @inlinable public func initializeMemory<T>(as type: T.Type, from source: Swift.UnsafePointer<T>, count: Swift.Int) -> Swift.UnsafeMutablePointer<T> {
    _debugPrecondition(
      count >= 0,
      "UnsafeMutableRawPointer.initializeMemory with negative count")
    _debugPrecondition(
      (UnsafeRawPointer(self + count * MemoryLayout<T>.stride)
        <= UnsafeRawPointer(source))
      || UnsafeRawPointer(source + count) <= UnsafeRawPointer(self),
      "UnsafeMutableRawPointer.initializeMemory overlapping range")

    Builtin.bindMemory(_rawValue, count._builtinWordValue, type)
    Builtin.copyArray(
      T.self, self._rawValue, source._rawValue, count._builtinWordValue)
    // This builtin is equivalent to:
    // for i in 0..<count {
    //   (self.assumingMemoryBound(to: T.self) + i).initialize(to: source[i])
    // }
    return UnsafeMutablePointer(_rawValue)
  }
  @discardableResult
  @inlinable public func moveInitializeMemory<T>(as type: T.Type, from source: Swift.UnsafeMutablePointer<T>, count: Swift.Int) -> Swift.UnsafeMutablePointer<T> {
    _debugPrecondition(
      count >= 0,
      "UnsafeMutableRawPointer.moveInitializeMemory with negative count")

    Builtin.bindMemory(_rawValue, count._builtinWordValue, type)
    if self < UnsafeMutableRawPointer(source)
       || self >= UnsafeMutableRawPointer(source + count) {
      // initialize forward from a disjoint or following overlapping range.
      Builtin.takeArrayFrontToBack(
        T.self, self._rawValue, source._rawValue, count._builtinWordValue)
      // This builtin is equivalent to:
      // for i in 0..<count {
      //   (self.assumingMemoryBound(to: T.self) + i)
      //   .initialize(to: (source + i).move())
      // }
    }
    else {
      // initialize backward from a non-following overlapping range.
      Builtin.takeArrayBackToFront(
        T.self, self._rawValue, source._rawValue, count._builtinWordValue)
      // This builtin is equivalent to:
      // var src = source + count
      // var dst = self.assumingMemoryBound(to: T.self) + count
      // while dst != self {
      //   (--dst).initialize(to: (--src).move())
      // }
    }
    return UnsafeMutablePointer(_rawValue)
  }
  @inlinable public func load<T>(fromByteOffset offset: Swift.Int = 0, as type: T.Type) -> T {
    _debugPrecondition(0 == (UInt(bitPattern: self + offset)
        & (UInt(MemoryLayout<T>.alignment) - 1)),
      "load from misaligned raw pointer")

    return Builtin.loadRaw((self + offset)._rawValue)
  }
  @inlinable public func storeBytes<T>(of value: T, toByteOffset offset: Swift.Int = 0, as type: T.Type) {
    _debugPrecondition(0 == (UInt(bitPattern: self + offset)
        & (UInt(MemoryLayout<T>.alignment) - 1)),
      "storeBytes to misaligned raw pointer")

    var temp = value
    withUnsafeMutablePointer(to: &temp) { source in
      let rawSrc = UnsafeMutableRawPointer(source)._rawValue
      // FIXME: to be replaced by _memcpy when conversions are implemented.
      Builtin.int_memcpy_RawPointer_RawPointer_Int64(
        (self + offset)._rawValue, rawSrc, UInt64(MemoryLayout<T>.size)._value,
        /*volatile:*/ false._value)
    }
  }
  @inlinable public func copyMemory(from source: Swift.UnsafeRawPointer, byteCount: Swift.Int) {
    _debugPrecondition(
      byteCount >= 0, "UnsafeMutableRawPointer.copyMemory with negative count")

    _memmove(dest: self, src: source, size: UInt(byteCount))
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension UnsafeMutableRawPointer : Swift.Strideable {
  @_transparent public func advanced(by n: Swift.Int) -> Swift.UnsafeMutableRawPointer {
    return UnsafeMutableRawPointer(Builtin.gepRaw_Word(_rawValue, n._builtinWordValue))
  }
  public typealias Stride = Swift.Int
}
extension OpaquePointer {
  @_transparent public init(@_nonEphemeral _ from: Swift.UnsafeMutableRawPointer) {
    self._rawValue = from._rawValue
  }
  @_transparent public init?(@_nonEphemeral _ from: Swift.UnsafeMutableRawPointer?) {
    guard let unwrapped = from else { return nil }
    self._rawValue = unwrapped._rawValue
  }
  @_transparent public init(@_nonEphemeral _ from: Swift.UnsafeRawPointer) {
    self._rawValue = from._rawValue
  }
  @_transparent public init?(@_nonEphemeral _ from: Swift.UnsafeRawPointer?) {
    guard let unwrapped = from else { return nil }
    self._rawValue = unwrapped._rawValue
  }
}
public protocol _UTFParser {
  associatedtype Encoding : Swift._UnicodeEncoding
  func _parseMultipleCodeUnits() -> (isValid: Swift.Bool, bitCount: Swift.UInt8)
  func _bufferedScalar(bitCount: Swift.UInt8) -> Self.Encoding.EncodedScalar
  var _buffer: Swift._UIntBuffer<Self.Encoding.CodeUnit> { get set }
}
extension _UTFParser where Self.Encoding.EncodedScalar : Swift.RangeReplaceableCollection {
  @inlinable @inline(__always) public mutating func parseScalar<I>(from input: inout I) -> Swift.Unicode.ParseResult<Self.Encoding.EncodedScalar> where I : Swift.IteratorProtocol, I.Element == Self.Encoding.CodeUnit {

    // Bufferless single-scalar fastpath.
    if _fastPath(_buffer.isEmpty) {
      guard let codeUnit = input.next() else { return .emptyInput }
      // ASCII, return immediately.
      if Encoding._isScalar(codeUnit) {
        return .valid(Encoding.EncodedScalar(CollectionOfOne(codeUnit)))
      }
      // Non-ASCII, proceed to buffering mode.
      _buffer.append(codeUnit)
    } else if Encoding._isScalar(
      Encoding.CodeUnit(truncatingIfNeeded: _buffer._storage)
    ) {
      // ASCII in _buffer.  We don't refill the buffer so we can return
      // to bufferless mode once we've exhausted it.
      let codeUnit = Encoding.CodeUnit(truncatingIfNeeded: _buffer._storage)
      _buffer.remove(at: _buffer.startIndex)
      return .valid(Encoding.EncodedScalar(CollectionOfOne(codeUnit)))
    }
    // Buffering mode.
    // Fill buffer back to 4 bytes (or as many as are left in the iterator).
    repeat {
      if let codeUnit = input.next() {
        _buffer.append(codeUnit)
      } else {
        if _buffer.isEmpty { return .emptyInput }
        break // We still have some bytes left in our buffer.
      }
    } while _buffer.count < _buffer.capacity

    // Find one unicode scalar.
    let (isValid, scalarBitCount) = _parseMultipleCodeUnits()
    _internalInvariant(scalarBitCount % numericCast(Encoding.CodeUnit.bitWidth) == 0)
    _internalInvariant(1...4 ~= scalarBitCount / 8)
    _internalInvariant(scalarBitCount <= _buffer._bitCount)
    
    // Consume the decoded bytes (or maximal subpart of ill-formed sequence).
    let encodedScalar = _bufferedScalar(bitCount: scalarBitCount)
    
    _buffer._storage = UInt32(
      // widen to 64 bits so that we can empty the buffer in the 4-byte case
      truncatingIfNeeded: UInt64(_buffer._storage) &>> scalarBitCount)
      
    _buffer._bitCount = _buffer._bitCount &- scalarBitCount

    if _fastPath(isValid) {
      return .valid(encodedScalar)
    }
    return .error(
      length: Int(scalarBitCount / numericCast(Encoding.CodeUnit.bitWidth)))
  }
}
extension Unicode {
  @frozen public enum UTF8 {
    case _swift3Buffer(Swift.Unicode.UTF8.ForwardParser)
  }
}
extension Unicode.UTF8 {
  @_alwaysEmitIntoClient public static func width(_ x: Swift.Unicode.Scalar) -> Swift.Int {
    switch x.value {
      case 0..<0x80: return 1
      case 0x80..<0x0800: return 2
      case 0x0800..<0x1_0000: return 3
      default: return 4
    }
  }
}
extension Unicode.UTF8 : Swift._UnicodeEncoding {
  public typealias CodeUnit = Swift.UInt8
  public typealias EncodedScalar = Swift._ValidUTF8Buffer
  @inlinable public static var encodedReplacementCharacter: Swift.Unicode.UTF8.EncodedScalar {
    get {
    return EncodedScalar.encodedReplacementCharacter
  }
  }
  @inline(__always) @inlinable public static func _isScalar(_ x: Swift.Unicode.UTF8.CodeUnit) -> Swift.Bool {
    return isASCII(x)
  }
  @_alwaysEmitIntoClient @inline(__always) public static func isASCII(_ x: Swift.Unicode.UTF8.CodeUnit) -> Swift.Bool {
    return x & 0b1000_0000 == 0
  }
  @inline(__always) @inlinable public static func decode(_ source: Swift.Unicode.UTF8.EncodedScalar) -> Swift.Unicode.Scalar {
    switch source.count {
    case 1:
      return Unicode.Scalar(_unchecked: source._biasedBits &- 0x01)
    case 2:
      let bits = source._biasedBits &- 0x0101
      var value = (bits & 0b0_______________________11_1111__0000_0000) &>> 8
      value    |= (bits & 0b0________________________________0001_1111) &<< 6
      return Unicode.Scalar(_unchecked: value)
    case 3:
      let bits = source._biasedBits &- 0x010101
      var value = (bits & 0b0____________11_1111__0000_0000__0000_0000) &>> 16
      value    |= (bits & 0b0_______________________11_1111__0000_0000) &>> 2
      value    |= (bits & 0b0________________________________0000_1111) &<< 12
      return Unicode.Scalar(_unchecked: value)
    default:
      _internalInvariant(source.count == 4)
      let bits = source._biasedBits &- 0x01010101
      var value = (bits & 0b0_11_1111__0000_0000__0000_0000__0000_0000) &>> 24
      value    |= (bits & 0b0____________11_1111__0000_0000__0000_0000) &>> 10
      value    |= (bits & 0b0_______________________11_1111__0000_0000) &<< 4
      value    |= (bits & 0b0________________________________0000_0111) &<< 18
      return Unicode.Scalar(_unchecked: value)
    }
  }
  @inline(__always) @inlinable public static func encode(_ source: Swift.Unicode.Scalar) -> Swift.Unicode.UTF8.EncodedScalar? {
    var c = source.value
    if _fastPath(c < (1&<<7)) {
      return EncodedScalar(_containing: UInt8(c))
    }
    var o = c & 0b0__0011_1111
    c &>>= 6
    o &<<= 8
    if _fastPath(c < (1&<<5)) {
      return EncodedScalar(_biasedBits: (o | c) &+ 0b0__1000_0001__1100_0001)
    }
    o |= c & 0b0__0011_1111
    c &>>= 6
    o &<<= 8
    if _fastPath(c < (1&<<4)) {
      return EncodedScalar(
        _biasedBits: (o | c) &+ 0b0__1000_0001__1000_0001__1110_0001)
    }
    o |= c & 0b0__0011_1111
    c &>>= 6
    o &<<= 8
    return EncodedScalar(
      _biasedBits: (o | c ) &+ 0b0__1000_0001__1000_0001__1000_0001__1111_0001)
  }
  @inlinable @inline(__always) public static func transcode<FromEncoding>(_ content: FromEncoding.EncodedScalar, from _: FromEncoding.Type) -> Swift.Unicode.UTF8.EncodedScalar? where FromEncoding : Swift._UnicodeEncoding {
    if _fastPath(FromEncoding.self == UTF16.self) {
      let c = _identityCast(content, to: UTF16.EncodedScalar.self)
      var u0 = UInt16(truncatingIfNeeded: c._storage)
      if _fastPath(u0 < 0x80) {
        return EncodedScalar(_containing: UInt8(truncatingIfNeeded: u0))
      }
      var r = UInt32(u0 & 0b0__11_1111)
      r &<<= 8
      u0 &>>= 6
      if _fastPath(u0 < (1&<<5)) {
        return EncodedScalar(
          _biasedBits: (UInt32(u0) | r) &+ 0b0__1000_0001__1100_0001)
      }
      r |= UInt32(u0 & 0b0__11_1111)
      r &<<= 8
      if _fastPath(u0 & (0xF800 &>> 6) != (0xD800 &>> 6)) {
        u0 &>>= 6
        return EncodedScalar(
          _biasedBits: (UInt32(u0) | r) &+ 0b0__1000_0001__1000_0001__1110_0001)
      }
    }
    else if _fastPath(FromEncoding.self == UTF8.self) {
      return _identityCast(content, to: UTF8.EncodedScalar.self)
    }
    return encode(FromEncoding.decode(content))
  }
  @frozen public struct ForwardParser {
    public typealias _Buffer = Swift._UIntBuffer<Swift.UInt8>
    @inline(__always) @inlinable public init() { _buffer = _Buffer() }
    public var _buffer: Swift.Unicode.UTF8.ForwardParser._Buffer
  }
  @frozen public struct ReverseParser {
    public typealias _Buffer = Swift._UIntBuffer<Swift.UInt8>
    @inline(__always) @inlinable public init() { _buffer = _Buffer() }
    public var _buffer: Swift.Unicode.UTF8.ReverseParser._Buffer
  }
}
extension Unicode.UTF8.ReverseParser : Swift.Unicode.Parser, Swift._UTFParser {
  public typealias Encoding = Swift.Unicode.UTF8
  @inline(__always) @inlinable public func _parseMultipleCodeUnits() -> (isValid: Swift.Bool, bitCount: Swift.UInt8) {
    _internalInvariant(_buffer._storage & 0x80 != 0) // this case handled elsewhere
    if _buffer._storage                & 0b0__1110_0000__1100_0000
                                      == 0b0__1100_0000__1000_0000 {
      // 2-byte sequence.  Top 4 bits of decoded result must be nonzero
      let top4Bits =  _buffer._storage & 0b0__0001_1110__0000_0000
      if _fastPath(top4Bits != 0) { return (true, 2*8) }
    }
    else if _buffer._storage     & 0b0__1111_0000__1100_0000__1100_0000
                                == 0b0__1110_0000__1000_0000__1000_0000 {
      // 3-byte sequence. The top 5 bits of the decoded result must be nonzero
      // and not a surrogate
      let top5Bits = _buffer._storage & 0b0__1111__0010_0000__0000_0000
      if _fastPath(
        top5Bits != 0 &&    top5Bits != 0b0__1101__0010_0000__0000_0000) {
        return (true, 3*8)
      }
    }
    else if _buffer._storage & 0b0__1111_1000__1100_0000__1100_0000__1100_0000
                            == 0b0__1111_0000__1000_0000__1000_0000__1000_0000 {
      // Make sure the top 5 bits of the decoded result would be in range
      let top5bits = _buffer._storage
                                  & 0b0__0111__0011_0000__0000_0000__0000_0000
      if _fastPath(
        top5bits != 0
        && top5bits <=              0b0__0100__0000_0000__0000_0000__0000_0000
      ) { return (true, 4*8) }
    }
    return (false, _invalidLength() &* 8)
  }
  @usableFromInline
  @inline(never) internal func _invalidLength() -> Swift.UInt8
  @inline(__always) @inlinable public func _bufferedScalar(bitCount: Swift.UInt8) -> Swift.Unicode.UTF8.ReverseParser.Encoding.EncodedScalar {
    let x = UInt32(truncatingIfNeeded: _buffer._storage.byteSwapped)
    let shift = 32 &- bitCount
    return Encoding.EncodedScalar(_biasedBits: (x &+ 0x01010101) &>> shift)
  }
}
extension Unicode.UTF8.ForwardParser : Swift.Unicode.Parser, Swift._UTFParser {
  public typealias Encoding = Swift.Unicode.UTF8
  @inline(__always) @inlinable public func _parseMultipleCodeUnits() -> (isValid: Swift.Bool, bitCount: Swift.UInt8) {
    _internalInvariant(_buffer._storage & 0x80 != 0) // this case handled elsewhere

    if _buffer._storage & 0b0__1100_0000__1110_0000
                       == 0b0__1000_0000__1100_0000 {
      // 2-byte sequence. At least one of the top 4 bits of the decoded result
      // must be nonzero.
      if _fastPath(_buffer._storage & 0b0_0001_1110 != 0) { return (true, 2*8) }
    }
    else if _buffer._storage         & 0b0__1100_0000__1100_0000__1111_0000
                                    == 0b0__1000_0000__1000_0000__1110_0000 {
      // 3-byte sequence. The top 5 bits of the decoded result must be nonzero
      // and not a surrogate
      let top5Bits =          _buffer._storage & 0b0___0010_0000__0000_1111
      if _fastPath(top5Bits != 0 && top5Bits != 0b0___0010_0000__0000_1101) {
        return (true, 3*8)
      }
    }
    else if _buffer._storage & 0b0__1100_0000__1100_0000__1100_0000__1111_1000
                            == 0b0__1000_0000__1000_0000__1000_0000__1111_0000 {
      // 4-byte sequence.  The top 5 bits of the decoded result must be nonzero
      // and no greater than 0b0__0100_0000
      let top5bits = UInt16(_buffer._storage       & 0b0__0011_0000__0000_0111)
      if _fastPath(
        top5bits != 0
        && top5bits.byteSwapped                   <= 0b0__0000_0100__0000_0000
      ) { return (true, 4*8) }
    }
    return (false, _invalidLength() &* 8)
  }
  @usableFromInline
  @inline(never) internal func _invalidLength() -> Swift.UInt8
  @inlinable public func _bufferedScalar(bitCount: Swift.UInt8) -> Swift.Unicode.UTF8.ForwardParser.Encoding.EncodedScalar {
    let x = UInt32(_buffer._storage) &+ 0x01010101
    return _ValidUTF8Buffer(_biasedBits: x & ._lowBits(bitCount))
  }
}
extension Unicode {
  @frozen public enum UTF16 {
    case _swift3Buffer(Swift.Unicode.UTF16.ForwardParser)
  }
}
extension Unicode.UTF16 {
  @inlinable public static func width(_ x: Swift.Unicode.Scalar) -> Swift.Int {
    return x.value <= UInt16.max ? 1 : 2
  }
  @inlinable public static func leadSurrogate(_ x: Swift.Unicode.Scalar) -> Swift.UTF16.CodeUnit {
    _precondition(width(x) == 2)
    return 0xD800 + UTF16.CodeUnit(truncatingIfNeeded:
      (x.value - 0x1_0000) &>> (10 as UInt32))
  }
  @inlinable public static func trailSurrogate(_ x: Swift.Unicode.Scalar) -> Swift.UTF16.CodeUnit {
    _precondition(width(x) == 2)
    return 0xDC00 + UTF16.CodeUnit(truncatingIfNeeded:
      (x.value - 0x1_0000) & (((1 as UInt32) &<< 10) - 1))
  }
  @inlinable public static func isLeadSurrogate(_ x: Swift.Unicode.UTF16.CodeUnit) -> Swift.Bool {
    return (x & 0xFC00) == 0xD800
  }
  @inlinable public static func isTrailSurrogate(_ x: Swift.Unicode.UTF16.CodeUnit) -> Swift.Bool {
    return (x & 0xFC00) == 0xDC00
  }
  @_alwaysEmitIntoClient public static func isSurrogate(_ x: Swift.Unicode.UTF16.CodeUnit) -> Swift.Bool {
    return isLeadSurrogate(x) || isTrailSurrogate(x)
  }
  @inlinable public static func _copy<T, U>(source: Swift.UnsafeMutablePointer<T>, destination: Swift.UnsafeMutablePointer<U>, count: Swift.Int) where T : Swift._StringElement, U : Swift._StringElement {
    if MemoryLayout<T>.stride == MemoryLayout<U>.stride {
      _memcpy(
        dest: UnsafeMutablePointer(destination),
        src: UnsafeMutablePointer(source),
        size: UInt(count) * UInt(MemoryLayout<U>.stride))
    }
    else {
      for i in 0..<count {
        let u16 = T._toUTF16CodeUnit((source + i).pointee)
        (destination + i).pointee = U._fromUTF16CodeUnit(u16)
      }
    }
  }
  @inlinable public static func transcodedLength<Input, Encoding>(of input: Input, decodedAs sourceEncoding: Encoding.Type, repairingIllFormedSequences: Swift.Bool) -> (count: Swift.Int, isASCII: Swift.Bool)? where Input : Swift.IteratorProtocol, Encoding : Swift._UnicodeEncoding, Input.Element == Encoding.CodeUnit {

    var utf16Count = 0
    var i = input
    var d = Encoding.ForwardParser()

    // Fast path for ASCII in a UTF8 buffer
    if sourceEncoding == Unicode.UTF8.self {
      var peek: Encoding.CodeUnit = 0
      while let u = i.next() {
        peek = u
        guard _fastPath(peek < 0x80) else { break }
        utf16Count = utf16Count + 1
      }
      if _fastPath(peek < 0x80) { return (utf16Count, true) }

      var d1 = UTF8.ForwardParser()
      d1._buffer.append(numericCast(peek))
      d = _identityCast(d1, to: Encoding.ForwardParser.self)
    }

    var utf16BitUnion: CodeUnit = 0
    while true {
      let s = d.parseScalar(from: &i)
      if _fastPath(s._valid != nil), let scalarContent = s._valid {
        let utf16 = transcode(scalarContent, from: sourceEncoding)
          ._unsafelyUnwrappedUnchecked
        utf16Count += utf16.count
        for x in utf16 { utf16BitUnion |= x }
      }
      else if let _ = s._error {
        guard _fastPath(repairingIllFormedSequences) else { return nil }
        utf16Count += 1
        utf16BitUnion |= UTF16._replacementCodeUnit
      }
      else {
        return (utf16Count, utf16BitUnion < 0x80)
      }
    }
  }
}
extension Unicode.UTF16 : Swift.Unicode.Encoding {
  public typealias CodeUnit = Swift.UInt16
  public typealias EncodedScalar = Swift._UIntBuffer<Swift.UInt16>
  @inlinable internal static var _replacementCodeUnit: Swift.Unicode.UTF16.CodeUnit {
    @inline(__always) get { return 0xfffd }
  }
  @inlinable public static var encodedReplacementCharacter: Swift.Unicode.UTF16.EncodedScalar {
    get {
    return EncodedScalar(_storage: 0xFFFD, _bitCount: 16)
  }
  }
  @_alwaysEmitIntoClient public static func isASCII(_ x: Swift.Unicode.UTF16.CodeUnit) -> Swift.Bool {
    return x <= 0x7f
  }
  @inlinable public static func _isScalar(_ x: Swift.Unicode.UTF16.CodeUnit) -> Swift.Bool {
    return x & 0xf800 != 0xd800
  }
  @inlinable @inline(__always) internal static func _decodeSurrogates(_ lead: Swift.Unicode.UTF16.CodeUnit, _ trail: Swift.Unicode.UTF16.CodeUnit) -> Swift.Unicode.Scalar {
    _internalInvariant(isLeadSurrogate(lead))
    _internalInvariant(isTrailSurrogate(trail))
    return Unicode.Scalar(
      _unchecked: 0x10000 +
        (UInt32(lead & 0x03ff) &<< 10 | UInt32(trail & 0x03ff)))
  }
  @inlinable public static func decode(_ source: Swift.Unicode.UTF16.EncodedScalar) -> Swift.Unicode.Scalar {
    let bits = source._storage
    if _fastPath(source._bitCount == 16) {
      return Unicode.Scalar(_unchecked: bits & 0xffff)
    }
    _internalInvariant(source._bitCount == 32)
    let lower: UInt32 = bits >> 16 & 0x03ff
    let upper: UInt32 = (bits & 0x03ff) << 10
    let value = 0x10000 + (lower | upper)
    return Unicode.Scalar(_unchecked: value)
  }
  @inlinable public static func encode(_ source: Swift.Unicode.Scalar) -> Swift.Unicode.UTF16.EncodedScalar? {
    let x = source.value
    if _fastPath(x < ((1 as UInt32) << 16)) {
      return EncodedScalar(_storage: x, _bitCount: 16)
    }
    let x1 = x - ((1 as UInt32) << 16)
    var r = (0xdc00 + (x1 & 0x3ff))
    r &<<= 16
    r |= (0xd800 + (x1 &>> 10 & 0x3ff))
    return EncodedScalar(_storage: r, _bitCount: 32)
  }
  @inlinable @inline(__always) public static func transcode<FromEncoding>(_ content: FromEncoding.EncodedScalar, from _: FromEncoding.Type) -> Swift.Unicode.UTF16.EncodedScalar? where FromEncoding : Swift._UnicodeEncoding {
    if _fastPath(FromEncoding.self == UTF8.self) {
      let c = _identityCast(content, to: UTF8.EncodedScalar.self)
      var b = c.count
      b = b &- 1
      if _fastPath(b == 0) {
        return EncodedScalar(
          _storage: (c._biasedBits &- 0x1) & 0b0__111_1111, _bitCount: 16)
      }
      var s = c._biasedBits &- 0x01010101
      var r = s
      r &<<= 6
      s &>>= 8
      r |= s & 0b0__11_1111
      b = b &- 1
      
      if _fastPath(b == 0) {
        return EncodedScalar(_storage: r & 0b0__111_1111_1111, _bitCount: 16)
      }
      r &<<= 6
      s &>>= 8
      r |= s & 0b0__11_1111
      b = b &- 1
      
      if _fastPath(b == 0) {
        return EncodedScalar(_storage: r & 0xFFFF, _bitCount: 16)
      }
      
      r &<<= 6
      s &>>= 8
      r |= s & 0b0__11_1111
      r &= (1 &<< 21) - 1
      return encode(Unicode.Scalar(_unchecked: r))
    }
    else if _fastPath(FromEncoding.self == UTF16.self) {
      return unsafeBitCast(content, to: UTF16.EncodedScalar.self)
    }
    return encode(FromEncoding.decode(content))
  }
  @frozen public struct ForwardParser {
    public typealias _Buffer = Swift._UIntBuffer<Swift.UInt16>
    @inlinable public init() { _buffer = _Buffer() }
    public var _buffer: Swift.Unicode.UTF16.ForwardParser._Buffer
  }
  @frozen public struct ReverseParser {
    public typealias _Buffer = Swift._UIntBuffer<Swift.UInt16>
    @inlinable public init() { _buffer = _Buffer() }
    public var _buffer: Swift.Unicode.UTF16.ReverseParser._Buffer
  }
}
extension Unicode.UTF16.ReverseParser : Swift.Unicode.Parser, Swift._UTFParser {
  public typealias Encoding = Swift.Unicode.UTF16
  @inlinable public func _parseMultipleCodeUnits() -> (isValid: Swift.Bool, bitCount: Swift.UInt8) {
    _internalInvariant(  // this case handled elsewhere
      !Encoding._isScalar(UInt16(truncatingIfNeeded: _buffer._storage)))
    if _fastPath(_buffer._storage & 0xFC00_FC00 == 0xD800_DC00) {
      return (true, 2*16)
    }
    return (false, 1*16)
  }
  @inlinable public func _bufferedScalar(bitCount: Swift.UInt8) -> Swift.Unicode.UTF16.ReverseParser.Encoding.EncodedScalar {
    return Encoding.EncodedScalar(
      _storage:
        (_buffer._storage &<< 16 | _buffer._storage &>> 16) &>> (32 - bitCount),
      _bitCount: bitCount
    )
  }
}
extension Unicode.UTF16.ForwardParser : Swift.Unicode.Parser, Swift._UTFParser {
  public typealias Encoding = Swift.Unicode.UTF16
  @inlinable public func _parseMultipleCodeUnits() -> (isValid: Swift.Bool, bitCount: Swift.UInt8) {
    _internalInvariant(  // this case handled elsewhere
      !Encoding._isScalar(UInt16(truncatingIfNeeded: _buffer._storage)))
    if _fastPath(_buffer._storage & 0xFC00_FC00 == 0xDC00_D800) {
      return (true, 2*16)
    }
    return (false, 1*16)
  }
  @inlinable public func _bufferedScalar(bitCount: Swift.UInt8) -> Swift.Unicode.UTF16.ForwardParser.Encoding.EncodedScalar {
    var r = _buffer
    r._bitCount = bitCount
    return r
  }
}
extension Unicode {
  @frozen public enum UTF32 {
    case _swift3Codec
    public static func == (a: Swift.Unicode.UTF32, b: Swift.Unicode.UTF32) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
}
extension Unicode.UTF32 : Swift.Unicode.Encoding {
  public typealias CodeUnit = Swift.UInt32
  public typealias EncodedScalar = Swift.CollectionOfOne<Swift.UInt32>
  @inlinable internal static var _replacementCodeUnit: Swift.Unicode.UTF32.CodeUnit {
    @inline(__always) get { return 0xFFFD }
  }
  @inlinable public static var encodedReplacementCharacter: Swift.Unicode.UTF32.EncodedScalar {
    get {
    return EncodedScalar(_replacementCodeUnit)
  }
  }
  @inlinable @inline(__always) public static func _isScalar(_ x: Swift.Unicode.UTF32.CodeUnit) -> Swift.Bool {
    return true
  }
  @_alwaysEmitIntoClient public static func isASCII(_ x: Swift.Unicode.UTF32.CodeUnit) -> Swift.Bool {
    return x <= 0x7F
  }
  @inlinable @inline(__always) public static func decode(_ source: Swift.Unicode.UTF32.EncodedScalar) -> Swift.Unicode.Scalar {
    return Unicode.Scalar(_unchecked: source.first!)
  }
  @inlinable @inline(__always) public static func encode(_ source: Swift.Unicode.Scalar) -> Swift.Unicode.UTF32.EncodedScalar? {
    return EncodedScalar(source.value)
  }
  @frozen public struct Parser {
    @inlinable public init() { }
  }
  public typealias ForwardParser = Swift.Unicode.UTF32.Parser
  public typealias ReverseParser = Swift.Unicode.UTF32.Parser
}
extension Unicode.UTF32.Parser : Swift.Unicode.Parser {
  public typealias Encoding = Swift.Unicode.UTF32
  @inlinable public mutating func parseScalar<I>(from input: inout I) -> Swift.Unicode.ParseResult<Swift.Unicode.UTF32.Parser.Encoding.EncodedScalar> where I : Swift.IteratorProtocol, I.Element == Swift.Unicode.UTF32.Parser.Encoding.CodeUnit {
    let n = input.next()
    if _fastPath(n != nil), let x = n {
      // Check code unit is valid: not surrogate-reserved and within range.
      guard _fastPath((x &>> 11) != 0b1101_1 && x <= 0x10ffff)
      else { return .error(length: 1) }
      
      // x is a valid scalar.
      return .valid(UTF32.EncodedScalar(x))
    }
    return .emptyInput
  }
}
@frozen public enum UnicodeDecodingResult : Swift.Equatable {
  case scalarValue(Swift.Unicode.Scalar)
  case emptyInput
  case error
  @inlinable public static func == (lhs: Swift.UnicodeDecodingResult, rhs: Swift.UnicodeDecodingResult) -> Swift.Bool {
    switch (lhs, rhs) {
    case (.scalarValue(let lhsScalar), .scalarValue(let rhsScalar)):
      return lhsScalar == rhsScalar
    case (.emptyInput, .emptyInput):
      return true
    case (.error, .error):
      return true
    default:
      return false
    }
  }
}
public protocol UnicodeCodec : Swift._UnicodeEncoding {
  init()
  mutating func decode<I>(_ input: inout I) -> Swift.UnicodeDecodingResult where I : Swift.IteratorProtocol, Self.CodeUnit == I.Element
  static func encode(_ input: Swift.Unicode.Scalar, into processCodeUnit: (Self.CodeUnit) -> Swift.Void)
  static func _nullCodeUnitOffset(in input: Swift.UnsafePointer<Self.CodeUnit>) -> Swift.Int
}
extension Unicode.UTF8 : Swift.UnicodeCodec {
  @inlinable public init() { self = ._swift3Buffer(ForwardParser()) }
  @inlinable @inline(__always) public mutating func decode<I>(_ input: inout I) -> Swift.UnicodeDecodingResult where I : Swift.IteratorProtocol, I.Element == Swift.Unicode.UTF8.CodeUnit {
    guard case ._swift3Buffer(var parser) = self else {
      Builtin.unreachable()
    }
    defer { self = ._swift3Buffer(parser) }

    switch parser.parseScalar(from: &input) {
    case .valid(let s): return .scalarValue(UTF8.decode(s))
    case .error: return .error
    case .emptyInput: return .emptyInput
    }
  }
  @inlinable public static func _decodeOne(_ buffer: Swift.UInt32) -> (result: Swift.UInt32?, length: Swift.UInt8) {
    // Note the buffer is read least significant byte first: [ #3 #2 #1 #0 ].

    if buffer & 0x80 == 0 { // 1-byte sequence (ASCII), buffer: [ ... ... ... CU0 ].
      let value = buffer & 0xff
      return (value, 1)
    }
    var p = ForwardParser()
    p._buffer._storage = buffer
    p._buffer._bitCount = 32
    var i = EmptyCollection<UInt8>().makeIterator()
    switch p.parseScalar(from: &i) {
    case .valid(let s):
      return (
        result: UTF8.decode(s).value,
        length: UInt8(truncatingIfNeeded: s.count))
    case .error(let l):
      return (result: nil, length: UInt8(truncatingIfNeeded: l))
    case .emptyInput: Builtin.unreachable()
    }
  }
  @inlinable @inline(__always) public static func encode(_ input: Swift.Unicode.Scalar, into processCodeUnit: (Swift.Unicode.UTF8.CodeUnit) -> Swift.Void) {
    var s = encode(input)!._biasedBits
    processCodeUnit(UInt8(truncatingIfNeeded: s) &- 0x01)
    s &>>= 8
    if _fastPath(s == 0) { return }
    processCodeUnit(UInt8(truncatingIfNeeded: s) &- 0x01)
    s &>>= 8
    if _fastPath(s == 0) { return }
    processCodeUnit(UInt8(truncatingIfNeeded: s) &- 0x01)
    s &>>= 8
    if _fastPath(s == 0) { return }
    processCodeUnit(UInt8(truncatingIfNeeded: s) &- 0x01)
  }
  @inlinable public static func isContinuation(_ byte: Swift.Unicode.UTF8.CodeUnit) -> Swift.Bool {
    return byte & 0b11_00__0000 == 0b10_00__0000
  }
  @inlinable public static func _nullCodeUnitOffset(in input: Swift.UnsafePointer<Swift.Unicode.UTF8.CodeUnit>) -> Swift.Int {
    return Int(_swift_stdlib_strlen_unsigned(input))
  }
  @inlinable public static func _nullCodeUnitOffset(in input: Swift.UnsafePointer<Swift.CChar>) -> Swift.Int {
    return Int(_swift_stdlib_strlen(input))
  }
}
extension Unicode.UTF16 : Swift.UnicodeCodec {
  @inlinable public init() { self = ._swift3Buffer(ForwardParser()) }
  @inlinable public mutating func decode<I>(_ input: inout I) -> Swift.UnicodeDecodingResult where I : Swift.IteratorProtocol, I.Element == Swift.Unicode.UTF16.CodeUnit {
    guard case ._swift3Buffer(var parser) = self else {
      Builtin.unreachable()
    }
    defer { self = ._swift3Buffer(parser) }
    switch parser.parseScalar(from: &input) {
    case .valid(let s): return .scalarValue(UTF16.decode(s))
    case .error: return .error
    case .emptyInput: return .emptyInput
    }
  }
  @inlinable internal mutating func _decodeOne<I>(_ input: inout I) -> (Swift.UnicodeDecodingResult, Swift.Int) where I : Swift.IteratorProtocol, I.Element == Swift.Unicode.UTF16.CodeUnit {
    let result = decode(&input)
    switch result {
    case .scalarValue(let us):
      return (result, UTF16.width(us))

    case .emptyInput:
      return (result, 0)

    case .error:
      return (result, 1)
    }
  }
  @inlinable public static func encode(_ input: Swift.Unicode.Scalar, into processCodeUnit: (Swift.Unicode.UTF16.CodeUnit) -> Swift.Void) {
    var s = encode(input)!._storage
    processCodeUnit(UInt16(truncatingIfNeeded: s))
    s &>>= 16
    if _fastPath(s == 0) { return }
    processCodeUnit(UInt16(truncatingIfNeeded: s))
  }
}
extension Unicode.UTF32 : Swift.UnicodeCodec {
  @inlinable public init() { self = ._swift3Codec }
  @inlinable public mutating func decode<I>(_ input: inout I) -> Swift.UnicodeDecodingResult where I : Swift.IteratorProtocol, I.Element == Swift.Unicode.UTF32.CodeUnit {
    var parser = ForwardParser()
    
    switch parser.parseScalar(from: &input) {
    case .valid(let s): return .scalarValue(UTF32.decode(s))
    case .error:      return .error
    case .emptyInput:   return .emptyInput
    }
  }
  @inlinable public static func encode(_ input: Swift.Unicode.Scalar, into processCodeUnit: (Swift.Unicode.UTF32.CodeUnit) -> Swift.Void) {
    processCodeUnit(UInt32(input))
  }
}
@inlinable @inline(__always) public func transcode<Input, InputEncoding, OutputEncoding>(_ input: Input, from inputEncoding: InputEncoding.Type, to outputEncoding: OutputEncoding.Type, stoppingOnError stopOnError: Swift.Bool, into processCodeUnit: (OutputEncoding.CodeUnit) -> Swift.Void) -> Swift.Bool where Input : Swift.IteratorProtocol, InputEncoding : Swift._UnicodeEncoding, OutputEncoding : Swift._UnicodeEncoding, Input.Element == InputEncoding.CodeUnit {
  var input = input

  // NB.  It is not possible to optimize this routine to a memcpy if
  // InputEncoding == OutputEncoding.  The reason is that memcpy will not
  // substitute U+FFFD replacement characters for ill-formed sequences.

  var p = InputEncoding.ForwardParser()
  var hadError = false
  loop:
  while true {
    switch p.parseScalar(from: &input) {
    case .valid(let s):
      let t = OutputEncoding.transcode(s, from: inputEncoding)
      guard _fastPath(t != nil), let s = t else { break }
      s.forEach(processCodeUnit)
      continue loop
    case .emptyInput:
      return hadError
    case .error:
      if _slowPath(stopOnError) { return true }
      hadError = true
    }
    OutputEncoding.encodedReplacementCharacter.forEach(processCodeUnit)
  }
}
public protocol _StringElement {
  static func _toUTF16CodeUnit(_: Self) -> Swift.UTF16.CodeUnit
  static func _fromUTF16CodeUnit(_ utf16: Swift.UTF16.CodeUnit) -> Self
}
extension UInt16 : Swift._StringElement {
  @inlinable public static func _toUTF16CodeUnit(_ x: Swift.UTF16.CodeUnit) -> Swift.UTF16.CodeUnit {
    return x
  }
  @inlinable public static func _fromUTF16CodeUnit(_ utf16: Swift.UTF16.CodeUnit) -> Swift.UTF16.CodeUnit {
    return utf16
  }
}
extension UInt8 : Swift._StringElement {
  @inlinable public static func _toUTF16CodeUnit(_ x: Swift.UTF8.CodeUnit) -> Swift.UTF16.CodeUnit {
    _internalInvariant(x <= 0x7f, "should only be doing this with ASCII")
    return UTF16.CodeUnit(truncatingIfNeeded: x)
  }
  @inlinable public static func _fromUTF16CodeUnit(_ utf16: Swift.UTF16.CodeUnit) -> Swift.UTF8.CodeUnit {
    _internalInvariant(utf16 <= 0x7f, "should only be doing this with ASCII")
    return UTF8.CodeUnit(truncatingIfNeeded: utf16)
  }
}
extension Unicode.Scalar {
  @inlinable internal init(_unchecked value: Swift.UInt32) {
    _internalInvariant(value < 0xD800 || value > 0xDFFF,
      "high- and low-surrogate code points are not valid Unicode scalar values")
    _internalInvariant(value <= 0x10FFFF, "value is outside of Unicode codespace")

    self._value = value
  }
}
extension UnicodeCodec {
  @inlinable public static func _nullCodeUnitOffset(in input: Swift.UnsafePointer<Self.CodeUnit>) -> Swift.Int {
    var length = 0
    while input[length] != 0 {
      length += 1
    }
    return length
  }
}
@available(*, unavailable, message: "use 'transcode(_:from:to:stoppingOnError:into:)'")
public func transcode<Input, InputEncoding, OutputEncoding>(_ inputEncoding: InputEncoding.Type, _ outputEncoding: OutputEncoding.Type, _ input: Input, _ output: (OutputEncoding.CodeUnit) -> Swift.Void, stopOnError: Swift.Bool) -> Swift.Bool where Input : Swift.IteratorProtocol, InputEncoding : Swift.UnicodeCodec, OutputEncoding : Swift.UnicodeCodec, Input.Element == InputEncoding.CodeUnit
@frozen public enum Unicode {
}
extension _StringGuts {
  @usableFromInline
  @inline(never) @_effects(releasenone) internal func isOnGraphemeClusterBoundary(_ i: Swift.String.Index) -> Swift.Bool
  @usableFromInline
  @inline(never) @_effects(releasenone) internal func _opaqueCharacterStride(startingAt i: Swift.Int) -> Swift.Int
  @usableFromInline
  @inline(never) @_effects(releasenone) internal func _opaqueCharacterStride(endingAt i: Swift.Int) -> Swift.Int
}
@frozen public struct _ValidUTF8Buffer {
  public typealias Element = Swift.Unicode.UTF8.CodeUnit
  @usableFromInline
  internal var _biasedBits: Swift.UInt32
  @inlinable internal init(_biasedBits: Swift.UInt32) {
    self._biasedBits = _biasedBits
  }
  @inlinable internal init(_containing e: Swift._ValidUTF8Buffer.Element) {
    _internalInvariant(
      e != 192 && e != 193 && !(245...255).contains(e), "invalid UTF8 byte")
    _biasedBits = UInt32(truncatingIfNeeded: e &+ 1)
  }
}
extension _ValidUTF8Buffer : Swift.Sequence {
  public typealias SubSequence = Swift.Slice<Swift._ValidUTF8Buffer>
  @frozen public struct Iterator : Swift.IteratorProtocol, Swift.Sequence {
    @inlinable public init(_ x: Swift._ValidUTF8Buffer) { _biasedBits = x._biasedBits }
    @inlinable public mutating func next() -> Swift._ValidUTF8Buffer.Element? {
      if _biasedBits == 0 { return nil }
      defer { _biasedBits >>= 8 }
      return Element(truncatingIfNeeded: _biasedBits) &- 1
    }
    @usableFromInline
    internal var _biasedBits: Swift.UInt32
    public typealias Element = Swift.UInt8
    public typealias Iterator = Swift._ValidUTF8Buffer.Iterator
  }
  @inlinable public func makeIterator() -> Swift._ValidUTF8Buffer.Iterator {
    return Iterator(self)
  }
}
extension _ValidUTF8Buffer : Swift.Collection {
  @frozen public struct Index : Swift.Comparable {
    @usableFromInline
    internal var _biasedBits: Swift.UInt32
    @inlinable internal init(_biasedBits: Swift.UInt32) { self._biasedBits = _biasedBits }
    @inlinable public static func == (lhs: Swift._ValidUTF8Buffer.Index, rhs: Swift._ValidUTF8Buffer.Index) -> Swift.Bool {
      return lhs._biasedBits == rhs._biasedBits
    }
    @inlinable public static func < (lhs: Swift._ValidUTF8Buffer.Index, rhs: Swift._ValidUTF8Buffer.Index) -> Swift.Bool {
      return lhs._biasedBits > rhs._biasedBits
    }
  }
  @inlinable public var startIndex: Swift._ValidUTF8Buffer.Index {
    get {
    return Index(_biasedBits: _biasedBits)
  }
  }
  @inlinable public var endIndex: Swift._ValidUTF8Buffer.Index {
    get {
    return Index(_biasedBits: 0)
  }
  }
  @inlinable public var count: Swift.Int {
    get {
    return UInt32.bitWidth &>> 3 &- _biasedBits.leadingZeroBitCount &>> 3
  }
  }
  @inlinable public var isEmpty: Swift.Bool {
    get {
    return _biasedBits == 0
  }
  }
  @inlinable public func index(after i: Swift._ValidUTF8Buffer.Index) -> Swift._ValidUTF8Buffer.Index {
    _debugPrecondition(i._biasedBits != 0)
    return Index(_biasedBits: i._biasedBits >> 8)
  }
  @inlinable public subscript(i: Swift._ValidUTF8Buffer.Index) -> Swift._ValidUTF8Buffer.Element {
    get {
    return Element(truncatingIfNeeded: i._biasedBits) &- 1
  }
  }
}
extension _ValidUTF8Buffer : Swift.BidirectionalCollection {
  @inlinable public func index(before i: Swift._ValidUTF8Buffer.Index) -> Swift._ValidUTF8Buffer.Index {
    let offset = _ValidUTF8Buffer(_biasedBits: i._biasedBits).count
    _debugPrecondition(offset != 0)
    return Index(_biasedBits: _biasedBits &>> (offset &<< 3 - 8))
  }
}
extension _ValidUTF8Buffer : Swift.RandomAccessCollection {
  public typealias Indices = Swift.DefaultIndices<Swift._ValidUTF8Buffer>
  @inlinable @inline(__always) public func distance(from i: Swift._ValidUTF8Buffer.Index, to j: Swift._ValidUTF8Buffer.Index) -> Swift.Int {
    _debugPrecondition(_isValid(i))
    _debugPrecondition(_isValid(j))
    return (
      i._biasedBits.leadingZeroBitCount - j._biasedBits.leadingZeroBitCount
    ) &>> 3
  }
  @inlinable @inline(__always) public func index(_ i: Swift._ValidUTF8Buffer.Index, offsetBy n: Swift.Int) -> Swift._ValidUTF8Buffer.Index {
    let startOffset = distance(from: startIndex, to: i)
    let newOffset = startOffset + n
    _debugPrecondition(newOffset >= 0)
    _debugPrecondition(newOffset <= count)
    return Index(_biasedBits: _biasedBits._fullShiftRight(newOffset &<< 3))
  }
}
extension _ValidUTF8Buffer : Swift.RangeReplaceableCollection {
  @inlinable public init() {
    _biasedBits = 0
  }
  @inlinable public var capacity: Swift.Int {
    get {
    return _ValidUTF8Buffer.capacity
  }
  }
  @inlinable public static var capacity: Swift.Int {
    get {
    return UInt32.bitWidth / Element.bitWidth
  }
  }
  @inlinable @inline(__always) public mutating func append(_ e: Swift._ValidUTF8Buffer.Element) {
    _debugPrecondition(count + 1 <= capacity)
    _internalInvariant(
      e != 192 && e != 193 && !(245...255).contains(e), "invalid UTF8 byte")
    _biasedBits |= UInt32(e &+ 1) &<< (count &<< 3)
  }
  @discardableResult
  @inlinable @inline(__always) public mutating func removeFirst() -> Swift._ValidUTF8Buffer.Element {
    _debugPrecondition(!isEmpty)
    let result = Element(truncatingIfNeeded: _biasedBits) &- 1
    _biasedBits = _biasedBits._fullShiftRight(8)
    return result
  }
  @inlinable internal func _isValid(_ i: Swift._ValidUTF8Buffer.Index) -> Swift.Bool {
    return i == endIndex || indices.contains(i)
  }
  @inlinable @inline(__always) public mutating func replaceSubrange<C>(_ target: Swift.Range<Swift._ValidUTF8Buffer.Index>, with replacement: C) where C : Swift.Collection, C.Element == Swift._ValidUTF8Buffer.Element {
    _debugPrecondition(_isValid(target.lowerBound))
    _debugPrecondition(_isValid(target.upperBound))
    var r = _ValidUTF8Buffer()
    for x in self[..<target.lowerBound] { r.append(x) }
    for x in replacement                { r.append(x) }
    for x in self[target.upperBound...] { r.append(x) }
    self = r
  }
}
extension _ValidUTF8Buffer {
  @inlinable @inline(__always) public mutating func append(contentsOf other: Swift._ValidUTF8Buffer) {
    _debugPrecondition(count + other.count <= capacity)
    _biasedBits |= UInt32(
      truncatingIfNeeded: other._biasedBits) &<< (count &<< 3)
  }
}
extension _ValidUTF8Buffer {
  @inlinable public static var encodedReplacementCharacter: Swift._ValidUTF8Buffer {
    get {
    return _ValidUTF8Buffer(_biasedBits: 0xBD_BF_EF &+ 0x01_01_01)
  }
  }
  @inlinable internal var _bytes: (bytes: Swift.UInt64, count: Swift.Int) {
    get {
    let count = self.count
    let mask: UInt64 = 1 &<< (UInt64(truncatingIfNeeded: count) &<< 3) &- 1
    let unbiased = UInt64(truncatingIfNeeded: _biasedBits) &- 0x0101010101010101
    return (unbiased & mask, count)
  }
  }
}
@inlinable internal func _writeBackMutableSlice<C, Slice_>(_ self_: inout C, bounds: Swift.Range<C.Index>, slice: Slice_) where C : Swift.MutableCollection, Slice_ : Swift.Collection, C.Element == Slice_.Element, C.Index == Slice_.Index {

  self_._failEarlyRangeCheck(bounds, bounds: self_.startIndex..<self_.endIndex)

  // FIXME(performance): can we use
  // _withUnsafeMutableBufferPointerIfSupported?  Would that create inout
  // aliasing violations if the newValue points to the same buffer?

  var selfElementIndex = bounds.lowerBound
  let selfElementsEndIndex = bounds.upperBound
  var newElementIndex = slice.startIndex
  let newElementsEndIndex = slice.endIndex

  while selfElementIndex != selfElementsEndIndex &&
    newElementIndex != newElementsEndIndex {

    self_[selfElementIndex] = slice[newElementIndex]
    self_.formIndex(after: &selfElementIndex)
    slice.formIndex(after: &newElementIndex)
  }

  _precondition(
    selfElementIndex == selfElementsEndIndex,
    "Cannot replace a slice of a MutableCollection with a slice of a smaller size")
  _precondition(
    newElementIndex == newElementsEndIndex,
    "Cannot replace a slice of a MutableCollection with a slice of a larger size")
}
@available(swift, deprecated: 3.0, obsoleted: 5.0, renamed: "BidirectionalCollection")
public typealias BidirectionalIndexable = Swift.BidirectionalCollection
@available(swift, deprecated: 3.0, obsoleted: 5.0, renamed: "Collection")
public typealias IndexableBase = Swift.Collection
@available(swift, deprecated: 3.0, obsoleted: 5.0, renamed: "Collection")
public typealias Indexable = Swift.Collection
@available(swift, deprecated: 3.0, obsoleted: 5.0, renamed: "MutableCollection")
public typealias MutableIndexable = Swift.MutableCollection
@available(swift, deprecated: 3.0, obsoleted: 5.0, renamed: "RandomAccessCollection")
public typealias RandomAccessIndexable = Swift.RandomAccessCollection
@available(swift, deprecated: 3.0, obsoleted: 5.0, renamed: "RangeReplaceableIndexable")
public typealias RangeReplaceableIndexable = Swift.RangeReplaceableCollection
@available(swift, deprecated: 4.2, renamed: "EnumeratedSequence.Iterator")
public typealias EnumeratedIterator<T> = Swift.EnumeratedSequence<T>.Iterator where T : Swift.Sequence
@available(swift, deprecated: 4.2, obsoleted: 5.0, renamed: "CollectionOfOne.Iterator")
public typealias IteratorOverOne<T> = Swift.CollectionOfOne<T>.Iterator
@available(swift, deprecated: 4.2, obsoleted: 5.0, renamed: "EmptyCollection.Iterator")
public typealias EmptyIterator<T> = Swift.EmptyCollection<T>.Iterator
@available(swift, deprecated: 4.2, obsoleted: 5.0, renamed: "LazyFilterSequence.Iterator")
public typealias LazyFilterIterator<T> = Swift.LazyFilterSequence<T>.Iterator where T : Swift.Sequence
@available(swift, deprecated: 3.1, obsoleted: 5.0, message: "Use Base.Index")
public typealias LazyFilterIndex<Base> = Base.Index where Base : Swift.Collection
@available(swift, deprecated: 4.2, obsoleted: 5.0, renamed: "LazyDropWhileSequence.Iterator")
public typealias LazyDropWhileIterator<T> = Swift.LazyDropWhileSequence<T>.Iterator where T : Swift.Sequence
@available(swift, deprecated: 4.2, obsoleted: 5.0, renamed: "LazyDropWhileCollection.Index")
public typealias LazyDropWhileIndex<T> = Swift.LazyDropWhileCollection<T>.Index where T : Swift.Collection
@available(swift, deprecated: 4.2, obsoleted: 5.0, renamed: "LazyDropWhileCollection")
public typealias LazyDropWhileBidirectionalCollection<T> = Swift.LazyDropWhileCollection<T> where T : Swift.BidirectionalCollection
@available(swift, deprecated: 4.2, obsoleted: 5.0, renamed: "LazyFilterCollection")
public typealias LazyFilterBidirectionalCollection<T> = Swift.LazyFilterCollection<T> where T : Swift.BidirectionalCollection
@available(swift, deprecated: 4.2, obsoleted: 5.0, renamed: "LazyMapSequence.Iterator")
public typealias LazyMapIterator<T, E> = Swift.LazyMapSequence<T, E>.Iterator where T : Swift.Sequence
@available(swift, deprecated: 4.2, obsoleted: 5.0, renamed: "LazyMapCollection")
public typealias LazyMapBidirectionalCollection<T, E> = Swift.LazyMapCollection<T, E> where T : Swift.BidirectionalCollection
@available(swift, deprecated: 4.2, obsoleted: 5.0, renamed: "LazyMapCollection")
public typealias LazyMapRandomAccessCollection<T, E> = Swift.LazyMapCollection<T, E> where T : Swift.RandomAccessCollection
@available(swift, deprecated: 4.2, obsoleted: 5.0, renamed: "LazyCollection")
public typealias LazyBidirectionalCollection<T> = Swift.LazyCollection<T> where T : Swift.BidirectionalCollection
@available(swift, deprecated: 4.2, obsoleted: 5.0, renamed: "LazyCollection")
public typealias LazyRandomAccessCollection<T> = Swift.LazyCollection<T> where T : Swift.RandomAccessCollection
@available(swift, deprecated: 4.2, obsoleted: 5.0, renamed: "FlattenCollection.Index")
public typealias FlattenCollectionIndex<T> = Swift.FlattenCollection<T>.Index where T : Swift.Collection, T.Element : Swift.Collection
@available(swift, deprecated: 4.2, obsoleted: 5.0, renamed: "FlattenCollection.Index")
public typealias FlattenBidirectionalCollectionIndex<T> = Swift.FlattenCollection<T>.Index where T : Swift.BidirectionalCollection, T.Element : Swift.BidirectionalCollection
@available(swift, deprecated: 4.2, obsoleted: 5.0, renamed: "FlattenCollection")
public typealias FlattenBidirectionalCollection<T> = Swift.FlattenCollection<T> where T : Swift.BidirectionalCollection, T.Element : Swift.BidirectionalCollection
@available(swift, deprecated: 4.2, obsoleted: 5.0, renamed: "JoinedSequence.Iterator")
public typealias JoinedIterator<T> = Swift.JoinedSequence<T>.Iterator where T : Swift.Sequence, T.Element : Swift.Sequence
@available(swift, deprecated: 4.2, obsoleted: 5.0, renamed: "Zip2Sequence.Iterator")
public typealias Zip2Iterator<T, U> = Swift.Zip2Sequence<T, U>.Iterator where T : Swift.Sequence, U : Swift.Sequence
@available(swift, deprecated: 4.2, obsoleted: 5.0, renamed: "LazyPrefixWhileSequence.Iterator")
public typealias LazyPrefixWhileIterator<T> = Swift.LazyPrefixWhileSequence<T>.Iterator where T : Swift.Sequence
@available(swift, deprecated: 4.2, obsoleted: 5.0, renamed: "LazyPrefixWhileCollection.Index")
public typealias LazyPrefixWhileIndex<T> = Swift.LazyPrefixWhileCollection<T>.Index where T : Swift.Collection
@available(swift, deprecated: 4.2, obsoleted: 5.0, renamed: "LazyPrefixWhileCollection")
public typealias LazyPrefixWhileBidirectionalCollection<T> = Swift.LazyPrefixWhileCollection<T> where T : Swift.BidirectionalCollection
@available(swift, deprecated: 4.2, obsoleted: 5.0, renamed: "ReversedCollection")
public typealias ReversedRandomAccessCollection<T> = Swift.ReversedCollection<T> where T : Swift.RandomAccessCollection
@available(swift, deprecated: 4.2, obsoleted: 5.0, renamed: "ReversedCollection.Index")
public typealias ReversedIndex<T> = Swift.ReversedCollection<T>.Index where T : Swift.BidirectionalCollection
@available(swift, deprecated: 4.0, obsoleted: 5.0, renamed: "Slice")
public typealias BidirectionalSlice<T> = Swift.Slice<T> where T : Swift.BidirectionalCollection
@available(swift, deprecated: 4.0, obsoleted: 5.0, renamed: "Slice")
public typealias RandomAccessSlice<T> = Swift.Slice<T> where T : Swift.RandomAccessCollection
@available(swift, deprecated: 4.0, obsoleted: 5.0, renamed: "Slice")
public typealias RangeReplaceableSlice<T> = Swift.Slice<T> where T : Swift.RangeReplaceableCollection
@available(swift, deprecated: 4.0, obsoleted: 5.0, renamed: "Slice")
public typealias RangeReplaceableBidirectionalSlice<T> = Swift.Slice<T> where T : Swift.BidirectionalCollection, T : Swift.RangeReplaceableCollection
@available(swift, deprecated: 4.0, obsoleted: 5.0, renamed: "Slice")
public typealias RangeReplaceableRandomAccessSlice<T> = Swift.Slice<T> where T : Swift.RandomAccessCollection, T : Swift.RangeReplaceableCollection
@available(swift, deprecated: 4.0, obsoleted: 5.0, renamed: "Slice")
public typealias MutableSlice<T> = Swift.Slice<T> where T : Swift.MutableCollection
@available(swift, deprecated: 4.0, obsoleted: 5.0, renamed: "Slice")
public typealias MutableBidirectionalSlice<T> = Swift.Slice<T> where T : Swift.BidirectionalCollection, T : Swift.MutableCollection
@available(swift, deprecated: 4.0, obsoleted: 5.0, renamed: "Slice")
public typealias MutableRandomAccessSlice<T> = Swift.Slice<T> where T : Swift.MutableCollection, T : Swift.RandomAccessCollection
@available(swift, deprecated: 4.0, obsoleted: 5.0, renamed: "Slice")
public typealias MutableRangeReplaceableSlice<T> = Swift.Slice<T> where T : Swift.MutableCollection, T : Swift.RangeReplaceableCollection
@available(swift, deprecated: 4.0, obsoleted: 5.0, renamed: "Slice")
public typealias MutableRangeReplaceableBidirectionalSlice<T> = Swift.Slice<T> where T : Swift.BidirectionalCollection, T : Swift.MutableCollection, T : Swift.RangeReplaceableCollection
@available(swift, deprecated: 4.0, obsoleted: 5.0, renamed: "Slice")
public typealias MutableRangeReplaceableRandomAccessSlice<T> = Swift.Slice<T> where T : Swift.MutableCollection, T : Swift.RandomAccessCollection, T : Swift.RangeReplaceableCollection
@available(swift, deprecated: 4.0, obsoleted: 5.0, renamed: "DefaultIndices")
public typealias DefaultBidirectionalIndices<T> = Swift.DefaultIndices<T> where T : Swift.BidirectionalCollection
@available(swift, deprecated: 4.0, obsoleted: 5.0, renamed: "DefaultIndices")
public typealias DefaultRandomAccessIndices<T> = Swift.DefaultIndices<T> where T : Swift.RandomAccessCollection
@available(swift, deprecated: 3.0, obsoleted: 5.0, renamed: "ExpressibleByNilLiteral")
public typealias NilLiteralConvertible = Swift.ExpressibleByNilLiteral
@available(swift, deprecated: 3.0, obsoleted: 5.0, renamed: "_ExpressibleByBuiltinIntegerLiteral")
public typealias _BuiltinIntegerLiteralConvertible = Swift._ExpressibleByBuiltinIntegerLiteral
@available(swift, deprecated: 3.0, obsoleted: 5.0, renamed: "ExpressibleByIntegerLiteral")
public typealias IntegerLiteralConvertible = Swift.ExpressibleByIntegerLiteral
@available(swift, deprecated: 3.0, obsoleted: 5.0, renamed: "_ExpressibleByBuiltinFloatLiteral")
public typealias _BuiltinFloatLiteralConvertible = Swift._ExpressibleByBuiltinFloatLiteral
@available(swift, deprecated: 3.0, obsoleted: 5.0, renamed: "ExpressibleByFloatLiteral")
public typealias FloatLiteralConvertible = Swift.ExpressibleByFloatLiteral
@available(swift, deprecated: 3.0, obsoleted: 5.0, renamed: "_ExpressibleByBuiltinBooleanLiteral")
public typealias _BuiltinBooleanLiteralConvertible = Swift._ExpressibleByBuiltinBooleanLiteral
@available(swift, deprecated: 3.0, obsoleted: 5.0, renamed: "ExpressibleByBooleanLiteral")
public typealias BooleanLiteralConvertible = Swift.ExpressibleByBooleanLiteral
@available(swift, deprecated: 3.0, obsoleted: 5.0, renamed: "_ExpressibleByBuiltinUnicodeScalarLiteral")
public typealias _BuiltinUnicodeScalarLiteralConvertible = Swift._ExpressibleByBuiltinUnicodeScalarLiteral
@available(swift, deprecated: 3.0, obsoleted: 5.0, renamed: "ExpressibleByUnicodeScalarLiteral")
public typealias UnicodeScalarLiteralConvertible = Swift.ExpressibleByUnicodeScalarLiteral
@available(swift, deprecated: 3.0, obsoleted: 5.0, renamed: "_ExpressibleByBuiltinExtendedGraphemeClusterLiteral")
public typealias _BuiltinExtendedGraphemeClusterLiteralConvertible = Swift._ExpressibleByBuiltinExtendedGraphemeClusterLiteral
@available(swift, deprecated: 3.0, obsoleted: 5.0, renamed: "ExpressibleByExtendedGraphemeClusterLiteral")
public typealias ExtendedGraphemeClusterLiteralConvertible = Swift.ExpressibleByExtendedGraphemeClusterLiteral
@available(swift, deprecated: 3.0, obsoleted: 5.0, renamed: "_ExpressibleByBuiltinStringLiteral")
public typealias _BuiltinStringLiteralConvertible = Swift._ExpressibleByBuiltinStringLiteral
@available(swift, deprecated: 3.0, obsoleted: 5.0, renamed: "ExpressibleByStringLiteral")
public typealias StringLiteralConvertible = Swift.ExpressibleByStringLiteral
@available(swift, deprecated: 3.0, obsoleted: 5.0, renamed: "ExpressibleByArrayLiteral")
public typealias ArrayLiteralConvertible = Swift.ExpressibleByArrayLiteral
@available(swift, deprecated: 3.0, obsoleted: 5.0, renamed: "ExpressibleByDictionaryLiteral")
public typealias DictionaryLiteralConvertible = Swift.ExpressibleByDictionaryLiteral
@available(swift, deprecated: 3.0, obsoleted: 5.0, renamed: "ExpressibleByStringInterpolation")
public typealias StringInterpolationConvertible = Swift.ExpressibleByStringInterpolation
@available(swift, deprecated: 3.0, obsoleted: 5.0, renamed: "_ExpressibleByColorLiteral")
public typealias _ColorLiteralConvertible = Swift._ExpressibleByColorLiteral
@available(swift, deprecated: 3.0, obsoleted: 5.0, renamed: "_ExpressibleByImageLiteral")
public typealias _ImageLiteralConvertible = Swift._ExpressibleByImageLiteral
@available(swift, deprecated: 3.0, obsoleted: 5.0, renamed: "_ExpressibleByFileReferenceLiteral")
public typealias _FileReferenceLiteralConvertible = Swift._ExpressibleByFileReferenceLiteral
@available(swift, deprecated: 4.2, obsoleted: 5.0, renamed: "ClosedRange.Index")
public typealias ClosedRangeIndex<T> = Swift.ClosedRange<T>.Index where T : Swift.Strideable, T.Stride : Swift.SignedInteger
@available(*, unavailable, renamed: "Optional")
public typealias ImplicitlyUnwrappedOptional<Wrapped> = Swift.Optional<Wrapped>
extension Range where Bound : Swift.Strideable, Bound.Stride : Swift.SignedInteger {
  @available(swift, deprecated: 4.2, obsoleted: 5.0, message: "CountableRange is now a Range. No need to convert any more.")
  public init(_ other: Swift.Range<Bound>)
}
extension ClosedRange where Bound : Swift.Strideable, Bound.Stride : Swift.SignedInteger {
  @available(swift, deprecated: 4.2, obsoleted: 5.0, message: "CountableClosedRange is now a ClosedRange. No need to convert any more.")
  public init(_ other: Swift.ClosedRange<Bound>)
}
@available(swift, deprecated: 5.0, renamed: "KeyValuePairs")
public typealias DictionaryLiteral<Key, Value> = Swift.KeyValuePairs<Key, Value>
extension LazySequenceProtocol {
  @available(swift, deprecated: 4.1, renamed: "compactMap(_:)", message: "Please use compactMap(_:) for the case where closure returns an optional value")
  public func flatMap<ElementOfResult>(_ transform: @escaping (Self.Elements.Element) -> ElementOfResult?) -> Swift.LazyMapSequence<Swift.LazyFilterSequence<Swift.LazyMapSequence<Self.Elements, ElementOfResult?>>, ElementOfResult>
}
extension String {
  @available(swift, deprecated: 3.2, obsoleted: 5.0, message: "Please use String directly")
  public typealias CharacterView = Swift.String
  @available(swift, deprecated: 3.2, obsoleted: 5.0, message: "Please use String directly")
  public var characters: Swift.String {
    get
    set
  }
  @available(swift, deprecated: 3.2, obsoleted: 5.0, message: "Please mutate the String directly")
  public mutating func withMutableCharacters<R>(_ body: (inout Swift.String) -> R) -> R
}
extension String.UnicodeScalarView : Swift._CustomPlaygroundQuickLookable {
  @available(swift, deprecated: 4.2, message: "UnicodeScalarView.customPlaygroundQuickLook will be removed in Swift 5.0")
  public var customPlaygroundQuickLook: Swift._PlaygroundQuickLook {
    get
  }
}
public typealias UTF8 = Swift.Unicode.UTF8
public typealias UTF16 = Swift.Unicode.UTF16
public typealias UTF32 = Swift.Unicode.UTF32
public typealias UnicodeScalar = Swift.Unicode.Scalar
extension String.UTF16View : Swift._CustomPlaygroundQuickLookable {
  @available(swift, deprecated: 4.2, message: "UTF16View.customPlaygroundQuickLook will be removed in Swift 5.0")
  public var customPlaygroundQuickLook: Swift._PlaygroundQuickLook {
    get
  }
}
extension String.UTF8View : Swift._CustomPlaygroundQuickLookable {
  @available(swift, deprecated: 4.2, message: "UTF8View.customPlaygroundQuickLook will be removed in Swift 5.0")
  public var customPlaygroundQuickLook: Swift._PlaygroundQuickLook {
    get
  }
}
extension Substring {
  @available(swift, deprecated: 3.2, obsoleted: 5.0, message: "Please use Substring directly")
  public typealias CharacterView = Swift.Substring
  @available(swift, deprecated: 3.2, obsoleted: 5.0, message: "Please use Substring directly")
  public var characters: Swift.Substring {
    get
    set
  }
  @available(swift, deprecated: 3.2, obsoleted: 5.0, message: "Please mutate the Substring directly")
  public mutating func withMutableCharacters<R>(_ body: (inout Swift.Substring) -> R) -> R
}
extension Substring : Swift._CustomPlaygroundQuickLookable {
  @available(swift, deprecated: 4.2, message: "Substring.customPlaygroundQuickLook will be removed in Swift 5.0")
  public var customPlaygroundQuickLook: Swift._PlaygroundQuickLook {
    get
  }
}
extension Collection {
  @available(*, unavailable, renamed: "Iterator")
  public typealias Generator = Self.Iterator
  @available(swift, deprecated: 3.2, obsoleted: 5.0, renamed: "Element")
  public typealias _Element = Self.Element
  @available(swift, deprecated: 4.0, obsoleted: 5.0, message: "all index distances are now of type Int")
  public func index<T>(_ i: Self.Index, offsetBy n: T) -> Self.Index where T : Swift.BinaryInteger
  @available(swift, deprecated: 4.0, obsoleted: 5.0, message: "all index distances are now of type Int")
  public func formIndex<T>(_ i: inout Self.Index, offsetBy n: T) where T : Swift.BinaryInteger
  @available(swift, deprecated: 4.0, obsoleted: 5.0, message: "all index distances are now of type Int")
  public func index<T>(_ i: Self.Index, offsetBy n: T, limitedBy limit: Self.Index) -> Self.Index? where T : Swift.BinaryInteger
  @available(swift, deprecated: 4.0, obsoleted: 5.0, message: "all index distances are now of type Int")
  public func formIndex<T>(_ i: inout Self.Index, offsetBy n: T, limitedBy limit: Self.Index) -> Swift.Bool where T : Swift.BinaryInteger
  @available(swift, deprecated: 4.0, obsoleted: 5.0, message: "all index distances are now of type Int")
  public func distance<T>(from start: Self.Index, to end: Self.Index) -> T where T : Swift.BinaryInteger
}
extension UnsafeMutablePointer {
  @available(swift, deprecated: 4.1, obsoleted: 5.0, renamed: "initialize(repeating:count:)")
  public func initialize(to newValue: Pointee, count: Swift.Int = 1)
  @available(swift, deprecated: 4.1, obsoleted: 5.0, message: "the default argument to deinitialize(count:) has been removed, please specify the count explicitly")
  @discardableResult
  public func deinitialize() -> Swift.UnsafeMutableRawPointer
  @available(swift, deprecated: 4.1, obsoleted: 5.0, message: "Swift currently only supports freeing entire heap blocks, use deallocate() instead")
  public func deallocate(capacity _: Swift.Int)
  @available(swift, deprecated: 4.2, obsoleted: 5.0, message: "it will be removed in Swift 5.0.  Please use 'UnsafeMutableBufferPointer.initialize(from:)' instead")
  public func initialize<C>(from source: C) where Pointee == C.Element, C : Swift.Collection
}
extension UnsafeMutableRawPointer {
  @available(*, unavailable, renamed: "init(mutating:)")
  public init(@_nonEphemeral _ from: Swift.UnsafeRawPointer)
  @available(*, unavailable, renamed: "init(mutating:)")
  public init?(@_nonEphemeral _ from: Swift.UnsafeRawPointer?)
  @available(*, unavailable, renamed: "init(mutating:)")
  public init<T>(@_nonEphemeral _ from: Swift.UnsafePointer<T>)
  @available(*, unavailable, renamed: "init(mutating:)")
  public init?<T>(@_nonEphemeral _ from: Swift.UnsafePointer<T>?)
}
extension UnsafeRawPointer : Swift._CustomPlaygroundQuickLookable {
  @available(swift, deprecated: 4.2, message: "UnsafeRawPointer.customPlaygroundQuickLook will be removed in a future Swift version")
  public var customPlaygroundQuickLook: Swift._PlaygroundQuickLook {
    get
  }
}
extension UnsafeMutableRawPointer : Swift._CustomPlaygroundQuickLookable {
  @available(swift, deprecated: 4.2, message: "UnsafeMutableRawPointer.customPlaygroundQuickLook will be removed in a future Swift version")
  public var customPlaygroundQuickLook: Swift._PlaygroundQuickLook {
    get
  }
}
extension UnsafePointer : Swift._CustomPlaygroundQuickLookable {
  @available(swift, deprecated: 4.2, message: "UnsafePointer.customPlaygroundQuickLook will be removed in a future Swift version")
  public var customPlaygroundQuickLook: Swift.PlaygroundQuickLook {
    get
  }
}
extension UnsafeMutablePointer : Swift._CustomPlaygroundQuickLookable {
  @available(swift, deprecated: 4.2, message: "UnsafeMutablePointer.customPlaygroundQuickLook will be removed in a future Swift version")
  public var customPlaygroundQuickLook: Swift.PlaygroundQuickLook {
    get
  }
}
@available(swift, deprecated: 4.1, obsoleted: 5.0, renamed: "UnsafeBufferPointer.Iterator")
public typealias UnsafeBufferPointerIterator<T> = Swift.UnsafeBufferPointer<T>.Iterator
@available(swift, deprecated: 4.1, obsoleted: 5.0, renamed: "UnsafeRawBufferPointer.Iterator")
public typealias UnsafeRawBufferPointerIterator<T> = Swift.UnsafeBufferPointer<T>.Iterator
@available(swift, deprecated: 4.1, obsoleted: 5.0, renamed: "UnsafeRawBufferPointer.Iterator")
public typealias UnsafeMutableRawBufferPointerIterator<T> = Swift.UnsafeBufferPointer<T>.Iterator
extension UnsafeMutableRawPointer {
  @available(swift, deprecated: 4.1, obsoleted: 5.0, renamed: "allocate(byteCount:alignment:)")
  public static func allocate(bytes size: Swift.Int, alignedTo alignment: Swift.Int) -> Swift.UnsafeMutableRawPointer
  @available(swift, deprecated: 4.1, obsoleted: 5.0, renamed: "deallocate()", message: "Swift currently only supports freeing entire heap blocks, use deallocate() instead")
  public func deallocate(bytes _: Swift.Int, alignedTo _: Swift.Int)
  @available(swift, deprecated: 4.1, obsoleted: 5.0, renamed: "copyMemory(from:byteCount:)")
  public func copyBytes(from source: Swift.UnsafeRawPointer, count: Swift.Int)
  @available(swift, deprecated: 4.1, obsoleted: 5.0, renamed: "initializeMemory(as:repeating:count:)")
  @discardableResult
  public func initializeMemory<T>(as type: T.Type, at offset: Swift.Int = 0, count: Swift.Int = 1, to repeatedValue: T) -> Swift.UnsafeMutablePointer<T>
  @available(swift, deprecated: 4.1, obsoleted: 5.0, message: "it will be removed in Swift 5.0.  Please use 'UnsafeMutableRawBufferPointer.initialize(from:)' instead")
  @discardableResult
  public func initializeMemory<C>(as type: C.Element.Type, from source: C) -> Swift.UnsafeMutablePointer<C.Element> where C : Swift.Collection
}
extension UnsafeMutableRawBufferPointer {
  @available(swift, deprecated: 4.1, obsoleted: 5.0, renamed: "allocate(byteCount:alignment:)")
  public static func allocate(count: Swift.Int) -> Swift.UnsafeMutableRawBufferPointer
  @available(swift, deprecated: 4.1, obsoleted: 5.0, renamed: "copyMemory(from:)")
  public func copyBytes(from source: Swift.UnsafeRawBufferPointer)
}
extension Sequence {
  @available(swift, deprecated: 4.1, renamed: "compactMap(_:)", message: "Please use compactMap(_:) for the case where closure returns an optional value")
  public func flatMap<ElementOfResult>(_ transform: (Self.Element) throws -> ElementOfResult?) rethrows -> [ElementOfResult]
}
extension Collection {
  @available(swift, deprecated: 4.1, obsoleted: 5.0, renamed: "compactMap(_:)", message: "Please use compactMap(_:) for the case where closure returns an optional value")
  public func flatMap(_ transform: (Self.Element) throws -> Swift.String?) rethrows -> [Swift.String]
}
extension Collection {
  @available(swift, deprecated: 5.0, renamed: "firstIndex(where:)")
  @inlinable public func index(where _predicate: (Self.Element) throws -> Swift.Bool) rethrows -> Self.Index? {
    return try firstIndex(where: _predicate)
  }
}
extension Collection where Self.Element : Swift.Equatable {
  @available(swift, deprecated: 5.0, renamed: "firstIndex(of:)")
  @inlinable public func index(of element: Self.Element) -> Self.Index? {
    return firstIndex(of: element)
  }
}
extension Zip2Sequence {
  @available(swift, deprecated: 4.2, obsoleted: 5.0, renamed: "Sequence1.Iterator")
  public typealias Stream1 = Sequence1.Iterator
  @available(swift, deprecated: 4.2, obsoleted: 5.0, renamed: "Sequence2.Iterator")
  public typealias Stream2 = Sequence2.Iterator
}
@available(swift, deprecated: 4.2, message: "PlaygroundQuickLook will be removed in a future Swift version. For customizing how types are presented in playgrounds, use CustomPlaygroundDisplayConvertible instead.")
public typealias PlaygroundQuickLook = Swift._PlaygroundQuickLook
@frozen public enum _PlaygroundQuickLook {
  case text(Swift.String)
  case int(Swift.Int64)
  case uInt(Swift.UInt64)
  case float(Swift.Float32)
  case double(Swift.Float64)
  case image(Any)
  case sound(Any)
  case color(Any)
  case bezierPath(Any)
  case attributedString(Any)
  case rectangle(Swift.Float64, Swift.Float64, Swift.Float64, Swift.Float64)
  case point(Swift.Float64, Swift.Float64)
  case size(Swift.Float64, Swift.Float64)
  case bool(Swift.Bool)
  case range(Swift.Int64, Swift.Int64)
  case view(Any)
  case sprite(Any)
  case url(Swift.String)
  case _raw([Swift.UInt8], Swift.String)
}
extension _PlaygroundQuickLook {
  @available(swift, deprecated: 4.2, obsoleted: 5.0, message: "PlaygroundQuickLook will be removed in a future Swift version.")
  public init(reflecting subject: Any)
}
@available(swift, deprecated: 4.2, obsoleted: 5.0, message: "CustomPlaygroundQuickLookable will be removed in a future Swift version. For customizing how types are presented in playgrounds, use CustomPlaygroundDisplayConvertible instead.")
public typealias CustomPlaygroundQuickLookable = Swift._CustomPlaygroundQuickLookable
public protocol _CustomPlaygroundQuickLookable {
  var customPlaygroundQuickLook: Swift._PlaygroundQuickLook { get }
}
@available(swift, deprecated: 4.2, obsoleted: 5.0, message: "_DefaultCustomPlaygroundQuickLookable will be removed in a future Swift version. For customizing how types are presented in playgrounds, use CustomPlaygroundDisplayConvertible instead.")
public typealias _DefaultCustomPlaygroundQuickLookable = Swift.__DefaultCustomPlaygroundQuickLookable
public protocol __DefaultCustomPlaygroundQuickLookable {
  var _defaultCustomPlaygroundQuickLook: Swift._PlaygroundQuickLook { get }
}
@available(macOS 10.15, *)
@usableFromInline
internal let _availabilityNextMajorVersion: (Swift.Int, Swift.Int, Swift.Int)
@_semantics("availability.osversion") @_effects(readnone) public func _stdlib_isOSVersionAtLeast(_ major: Builtin.Word, _ minor: Builtin.Word, _ patch: Builtin.Word) -> Builtin.Int1
@available(macOS 10.15, iOS 13.0, *)
@_semantics("availability.osversion") @_effects(readnone) public func _stdlib_isVariantOSVersionAtLeast(_ major: Builtin.Word, _ minor: Builtin.Word, _ patch: Builtin.Word) -> Builtin.Int1
@_semantics("availability.osversion") @_effects(readnone) public func _stdlib_isOSVersionAtLeastOrVariantVersionAtLeast(_ major: Builtin.Word, _ minor: Builtin.Word, _ patch: Builtin.Word, _ variantMajor: Builtin.Word, _ variantMinor: Builtin.Word, _ variantPatch: Builtin.Word) -> Builtin.Int1
@available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
public struct CollectionDifference<ChangeElement> {
  @frozen public enum Change {
    case insert(offset: Swift.Int, element: ChangeElement, associatedWith: Swift.Int?)
    case remove(offset: Swift.Int, element: ChangeElement, associatedWith: Swift.Int?)
  }
  public let insertions: [Swift.CollectionDifference<ChangeElement>.Change]
  public let removals: [Swift.CollectionDifference<ChangeElement>.Change]
  public init?<Changes>(_ changes: Changes) where Changes : Swift.Collection, Changes.Element == Swift.CollectionDifference<ChangeElement>.Change
  public func inverse() -> Swift.CollectionDifference<ChangeElement>
}
@available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
extension CollectionDifference : Swift.Collection {
  public typealias Element = Swift.CollectionDifference<ChangeElement>.Change
  @frozen public struct Index {
    @usableFromInline
    internal let _offset: Swift.Int
  }
  public var startIndex: Swift.CollectionDifference<ChangeElement>.Index {
    get
  }
  public var endIndex: Swift.CollectionDifference<ChangeElement>.Index {
    get
  }
  public func index(after index: Swift.CollectionDifference<ChangeElement>.Index) -> Swift.CollectionDifference<ChangeElement>.Index
  public subscript(position: Swift.CollectionDifference<ChangeElement>.Index) -> Swift.CollectionDifference<ChangeElement>.Element {
    get
  }
  public func index(before index: Swift.CollectionDifference<ChangeElement>.Index) -> Swift.CollectionDifference<ChangeElement>.Index
  public func formIndex(_ index: inout Swift.CollectionDifference<ChangeElement>.Index, offsetBy distance: Swift.Int)
  public func distance(from start: Swift.CollectionDifference<ChangeElement>.Index, to end: Swift.CollectionDifference<ChangeElement>.Index) -> Swift.Int
  public typealias Indices = Swift.DefaultIndices<Swift.CollectionDifference<ChangeElement>>
  public typealias Iterator = Swift.IndexingIterator<Swift.CollectionDifference<ChangeElement>>
  public typealias SubSequence = Swift.Slice<Swift.CollectionDifference<ChangeElement>>
}
@available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
extension CollectionDifference.Index : Swift.Equatable {
  @inlinable public static func == (lhs: Swift.CollectionDifference<ChangeElement>.Index, rhs: Swift.CollectionDifference<ChangeElement>.Index) -> Swift.Bool {
    return lhs._offset == rhs._offset
  }
}
@available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
extension CollectionDifference.Index : Swift.Comparable {
  @inlinable public static func < (lhs: Swift.CollectionDifference<ChangeElement>.Index, rhs: Swift.CollectionDifference<ChangeElement>.Index) -> Swift.Bool {
    return lhs._offset < rhs._offset
  }
}
@available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
extension CollectionDifference.Index : Swift.Hashable {
  @inlinable public func hash(into hasher: inout Swift.Hasher) {
    hasher.combine(_offset)
  }
  public var hashValue: Swift.Int {
    get
  }
}
@available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
extension CollectionDifference.Change : Swift.Equatable where ChangeElement : Swift.Equatable {
  public static func == (a: Swift.CollectionDifference<ChangeElement>.Change, b: Swift.CollectionDifference<ChangeElement>.Change) -> Swift.Bool
}
@available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
extension CollectionDifference : Swift.Equatable where ChangeElement : Swift.Equatable {
  public static func == (a: Swift.CollectionDifference<ChangeElement>, b: Swift.CollectionDifference<ChangeElement>) -> Swift.Bool
}
@available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
extension CollectionDifference.Change : Swift.Hashable where ChangeElement : Swift.Hashable {
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
extension CollectionDifference : Swift.Hashable where ChangeElement : Swift.Hashable {
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
extension CollectionDifference where ChangeElement : Swift.Hashable {
  public func inferringMoves() -> Swift.CollectionDifference<ChangeElement>
}
@available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
extension CollectionDifference.Change : Swift.Codable where ChangeElement : Swift.Decodable, ChangeElement : Swift.Encodable {
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
@available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
extension CollectionDifference : Swift.Codable where ChangeElement : Swift.Decodable, ChangeElement : Swift.Encodable {
  public func encode(to encoder: Swift.Encoder) throws
  public init(from decoder: Swift.Decoder) throws
}
@frozen public struct CollectionOfOne<Element> {
  @usableFromInline
  internal var _element: Element
  @inlinable public init(_ element: Element) {
    self._element = element
  }
}
extension CollectionOfOne {
  @frozen public struct Iterator {
    @usableFromInline
    internal var _elements: Swift.CollectionOfOne<Element>.Iterator.Element?
    @inlinable public init(_elements: Swift.CollectionOfOne<Element>.Iterator.Element?) {
      self._elements = _elements
    }
  }
}
extension CollectionOfOne.Iterator : Swift.IteratorProtocol {
  @inlinable public mutating func next() -> Element? {
    let result = _elements
    _elements = nil
    return result
  }
}
extension CollectionOfOne : Swift.RandomAccessCollection, Swift.MutableCollection {
  public typealias Index = Swift.Int
  public typealias Indices = Swift.Range<Swift.Int>
  public typealias SubSequence = Swift.Slice<Swift.CollectionOfOne<Element>>
  @inlinable public var startIndex: Swift.CollectionOfOne<Element>.Index {
    get {
    return 0
  }
  }
  @inlinable public var endIndex: Swift.CollectionOfOne<Element>.Index {
    get {
    return 1
  }
  }
  @inlinable public func index(after i: Swift.CollectionOfOne<Element>.Index) -> Swift.CollectionOfOne<Element>.Index {
    _precondition(i == startIndex)
    return 1
  }
  @inlinable public func index(before i: Swift.CollectionOfOne<Element>.Index) -> Swift.CollectionOfOne<Element>.Index {
    _precondition(i == endIndex)
    return 0
  }
  @inlinable __consuming public func makeIterator() -> Swift.CollectionOfOne<Element>.Iterator {
    return Iterator(_elements: _element)
  }
  @inlinable public subscript(position: Swift.Int) -> Element {
    _read {
      _precondition(position == 0, "Index out of range")
      yield _element
    }
    _modify {
      _precondition(position == 0, "Index out of range")
      yield &_element
    }
  }
  @inlinable public subscript(bounds: Swift.Range<Swift.Int>) -> Swift.CollectionOfOne<Element>.SubSequence {
    get {
      _failEarlyRangeCheck(bounds, bounds: 0..<1)
      return Slice(base: self, bounds: bounds)
    }
    set {
      _failEarlyRangeCheck(bounds, bounds: 0..<1)
      let n = newValue.count
      _precondition(bounds.count == n, "CollectionOfOne can't be resized")
      if n == 1 { self = newValue.base }
    }
  }
  @inlinable public var count: Swift.Int {
    get {
    return 1
  }
  }
}
extension CollectionOfOne : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
extension CollectionOfOne : Swift.CustomReflectable {
  public var customMirror: Swift.Mirror {
    get
  }
}
extension RangeReplaceableCollection {
  @available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
  public func applying(_ difference: Swift.CollectionDifference<Self.Element>) -> Self?
}
extension BidirectionalCollection {
  @available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
  public func difference<C>(from other: C, by areEquivalent: (C.Element, Self.Element) -> Swift.Bool) -> Swift.CollectionDifference<Self.Element> where C : Swift.BidirectionalCollection, Self.Element == C.Element
}
extension BidirectionalCollection where Self.Element : Swift.Equatable {
  @available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
  public func difference<C>(from other: C) -> Swift.CollectionDifference<Self.Element> where C : Swift.BidirectionalCollection, Self.Element == C.Element
}
extension BinaryFloatingPoint where Self.RawSignificand : Swift.FixedWidthInteger {
  @inlinable public static func random<T>(in range: Swift.Range<Self>, using generator: inout T) -> Self where T : Swift.RandomNumberGenerator {
    _precondition(
      !range.isEmpty,
      "Can't get random value with an empty range"
    )
    let delta = range.upperBound - range.lowerBound
    //  TODO: this still isn't quite right, because the computation of delta
    //  can overflow (e.g. if .upperBound = .maximumFiniteMagnitude and
    //  .lowerBound = -.upperBound); this should be re-written with an
    //  algorithm that handles that case correctly, but this precondition
    //  is an acceptable short-term fix.
    _precondition(
      delta.isFinite,
      "There is no uniform distribution on an infinite range"
    )
    let rand: Self.RawSignificand
    if Self.RawSignificand.bitWidth == Self.significandBitCount + 1 {
      rand = generator.next()
    } else {
      let significandCount = Self.significandBitCount + 1
      let maxSignificand: Self.RawSignificand = 1 << significandCount
      // Rather than use .next(upperBound:), which has to work with arbitrary
      // upper bounds, and therefore does extra work to avoid bias, we can take
      // a shortcut because we know that maxSignificand is a power of two.
      rand = generator.next() & (maxSignificand - 1)
    }
    let unitRandom = Self.init(rand) * (Self.ulpOfOne / 2)
    let randFloat = delta * unitRandom + range.lowerBound
    if randFloat == range.upperBound {
      return Self.random(in: range, using: &generator)
    }
    return randFloat
  }
  @inlinable public static func random(in range: Swift.Range<Self>) -> Self {
    var g = SystemRandomNumberGenerator()
    return Self.random(in: range, using: &g)
  }
  @inlinable public static func random<T>(in range: Swift.ClosedRange<Self>, using generator: inout T) -> Self where T : Swift.RandomNumberGenerator {
    _precondition(
      !range.isEmpty,
      "Can't get random value with an empty range"
    )
    let delta = range.upperBound - range.lowerBound
    //  TODO: this still isn't quite right, because the computation of delta
    //  can overflow (e.g. if .upperBound = .maximumFiniteMagnitude and
    //  .lowerBound = -.upperBound); this should be re-written with an
    //  algorithm that handles that case correctly, but this precondition
    //  is an acceptable short-term fix.
    _precondition(
      delta.isFinite,
      "There is no uniform distribution on an infinite range"
    )
    let rand: Self.RawSignificand
    if Self.RawSignificand.bitWidth == Self.significandBitCount + 1 {
      rand = generator.next()
      let tmp: UInt8 = generator.next() & 1
      if rand == Self.RawSignificand.max && tmp == 1 {
        return range.upperBound
      }
    } else {
      let significandCount = Self.significandBitCount + 1
      let maxSignificand: Self.RawSignificand = 1 << significandCount
      rand = generator.next(upperBound: maxSignificand + 1)
      if rand == maxSignificand {
        return range.upperBound
      }
    }
    let unitRandom = Self.init(rand) * (Self.ulpOfOne / 2)
    let randFloat = delta * unitRandom + range.lowerBound
    return randFloat
  }
  @inlinable public static func random(in range: Swift.ClosedRange<Self>) -> Self {
    var g = SystemRandomNumberGenerator()
    return Self.random(in: range, using: &g)
  }
}
public struct Mirror {
  public enum AncestorRepresentation {
    case generated
    case customized(() -> Swift.Mirror)
    case suppressed
  }
  public init(reflecting subject: Any)
  public typealias Child = (label: Swift.String?, value: Any)
  public typealias Children = Swift.AnyCollection<Swift.Mirror.Child>
  public enum DisplayStyle {
    case `struct`, `class`, `enum`, tuple, optional, collection
    case dictionary, set
    public static func == (a: Swift.Mirror.DisplayStyle, b: Swift.Mirror.DisplayStyle) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public init<Subject, C>(_ subject: Subject, children: C, displayStyle: Swift.Mirror.DisplayStyle? = nil, ancestorRepresentation: Swift.Mirror.AncestorRepresentation = .generated) where C : Swift.Collection, C.Element == Swift.Mirror.Child
  public init<Subject, C>(_ subject: Subject, unlabeledChildren: C, displayStyle: Swift.Mirror.DisplayStyle? = nil, ancestorRepresentation: Swift.Mirror.AncestorRepresentation = .generated) where C : Swift.Collection
  public init<Subject>(_ subject: Subject, children: Swift.KeyValuePairs<Swift.String, Any>, displayStyle: Swift.Mirror.DisplayStyle? = nil, ancestorRepresentation: Swift.Mirror.AncestorRepresentation = .generated)
  public let subjectType: Any.Type
  public let children: Swift.Mirror.Children
  public let displayStyle: Swift.Mirror.DisplayStyle?
  public var superclassMirror: Swift.Mirror? {
    get
  }
}
public protocol CustomReflectable {
  var customMirror: Swift.Mirror { get }
}
public protocol CustomLeafReflectable : Swift.CustomReflectable {
}
public protocol MirrorPath {
}
extension Int : Swift.MirrorPath {
}
extension String : Swift.MirrorPath {
}
extension Mirror {
  public func descendant(_ first: Swift.MirrorPath, _ rest: Swift.MirrorPath...) -> Any?
}
extension String {
  public init<Subject>(describing instance: Subject)
  @inlinable public init<Subject>(describing instance: Subject) where Subject : Swift.CustomStringConvertible {
    self = instance.description
  }
  @inlinable public init<Subject>(describing instance: Subject) where Subject : Swift.TextOutputStreamable {
    self.init()
    instance.write(to: &self)
  }
  @inlinable public init<Subject>(describing instance: Subject) where Subject : Swift.CustomStringConvertible, Subject : Swift.TextOutputStreamable {
    self = instance.description
  }
  public init<Subject>(reflecting subject: Subject)
}
extension Mirror : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
extension Mirror : Swift.CustomReflectable {
  public var customMirror: Swift.Mirror {
    get
  }
}
public protocol CustomPlaygroundDisplayConvertible {
  var playgroundDescription: Any { get }
}
@frozen public enum CommandLine {
  @usableFromInline
  internal static var _argc: Swift.Int32
  @usableFromInline
  internal static var _unsafeArgv: Swift.UnsafeMutablePointer<Swift.UnsafeMutablePointer<Swift.CChar>?>
  public static var argc: Swift.Int32 {
    get
  }
  public static var unsafeArgv: Swift.UnsafeMutablePointer<Swift.UnsafeMutablePointer<Swift.Int8>?> {
    get
  }
  public static var arguments: [Swift.String]
}
@usableFromInline
@frozen internal struct _SliceBuffer<Element> : Swift._ArrayBufferProtocol, Swift.RandomAccessCollection {
  @usableFromInline
  internal typealias NativeBuffer = Swift._ContiguousArrayBuffer<Element>
  @usableFromInline
  internal var owner: Swift.AnyObject
  @usableFromInline
  internal let subscriptBaseAddress: Swift.UnsafeMutablePointer<Element>
  @usableFromInline
  internal var startIndex: Swift.Int
  @usableFromInline
  internal var endIndexAndFlags: Swift.UInt
  @inlinable internal init(owner: Swift.AnyObject, subscriptBaseAddress: Swift.UnsafeMutablePointer<Element>, startIndex: Swift.Int, endIndexAndFlags: Swift.UInt) {
    self.owner = owner
    self.subscriptBaseAddress = subscriptBaseAddress
    self.startIndex = startIndex
    self.endIndexAndFlags = endIndexAndFlags
  }
  @inlinable internal init(owner: Swift.AnyObject, subscriptBaseAddress: Swift.UnsafeMutablePointer<Element>, indices: Swift.Range<Swift.Int>, hasNativeBuffer: Swift.Bool) {
    self.owner = owner
    self.subscriptBaseAddress = subscriptBaseAddress
    self.startIndex = indices.lowerBound
    let bufferFlag = UInt(hasNativeBuffer ? 1 : 0)
    self.endIndexAndFlags = (UInt(indices.upperBound) << 1) | bufferFlag
    _invariantCheck()
  }
  @inlinable internal init() {
    let empty = _ContiguousArrayBuffer<Element>()
    self.owner = empty.owner
    self.subscriptBaseAddress = empty.firstElementAddress
    self.startIndex = empty.startIndex
    self.endIndexAndFlags = 1
    _invariantCheck()
  }
  @inlinable internal init(_buffer buffer: Swift._SliceBuffer<Element>.NativeBuffer, shiftedToStartIndex: Swift.Int) {
    let shift = buffer.startIndex - shiftedToStartIndex
    self.init(
      owner: buffer.owner,
      subscriptBaseAddress: buffer.subscriptBaseAddress + shift,
      indices: shiftedToStartIndex..<shiftedToStartIndex + buffer.count,
      hasNativeBuffer: true)
  }
  @inlinable internal func _invariantCheck() {
    let isNative = _hasNativeBuffer
    let isNativeStorage: Bool = owner is __ContiguousArrayStorageBase
    _internalInvariant(isNativeStorage == isNative)
    if isNative {
      _internalInvariant(count <= nativeBuffer.count)
    }
  }
  @inlinable internal var _hasNativeBuffer: Swift.Bool {
    get {
    return (endIndexAndFlags & 1) != 0
  }
  }
  @inlinable internal var nativeBuffer: Swift._SliceBuffer<Element>.NativeBuffer {
    get {
    _internalInvariant(_hasNativeBuffer)
    return NativeBuffer(
      owner as? __ContiguousArrayStorageBase ?? _emptyArrayStorage)
  }
  }
  @inlinable internal var nativeOwner: Swift.AnyObject {
    get {
    _internalInvariant(_hasNativeBuffer, "Expect a native array")
    return owner
  }
  }
  @inlinable internal mutating func replaceSubrange<C>(_ subrange: Swift.Range<Swift.Int>, with insertCount: Swift.Int, elementsOf newValues: __owned C) where Element == C.Element, C : Swift.Collection {

    _invariantCheck()
    _internalInvariant(insertCount <= newValues.count)

    _internalInvariant(_hasNativeBuffer)
    _internalInvariant(isUniquelyReferenced())

    let eraseCount = subrange.count
    let growth = insertCount - eraseCount
    let oldCount = count

    var native = nativeBuffer
    let hiddenElementCount = firstElementAddress - native.firstElementAddress

    _internalInvariant(native.count + growth <= native.capacity)

    let start = subrange.lowerBound - startIndex + hiddenElementCount
    let end = subrange.upperBound - startIndex + hiddenElementCount
    native.replaceSubrange(
      start..<end,
      with: insertCount,
      elementsOf: newValues)

    self.endIndex = self.startIndex + oldCount + growth

    _invariantCheck()
  }
  @inlinable internal var identity: Swift.UnsafeRawPointer {
    get {
    return UnsafeRawPointer(firstElementAddress)
  }
  }
  @inlinable internal var firstElementAddress: Swift.UnsafeMutablePointer<Element> {
    get {
    return subscriptBaseAddress + startIndex
  }
  }
  @inlinable internal var firstElementAddressIfContiguous: Swift.UnsafeMutablePointer<Element>? {
    get {
    return firstElementAddress
  }
  }
  @inlinable internal mutating func requestUniqueMutableBackingBuffer(minimumCapacity: Swift.Int) -> Swift._SliceBuffer<Element>.NativeBuffer? {
    _invariantCheck()
    // Note: with COW support it's already guaranteed to have a uniquely
    // referenced buffer. This check is only needed for backward compatibility.
    if _fastPath(isUniquelyReferenced()) {
      if capacity >= minimumCapacity {
        // Since we have the last reference, drop any inaccessible
        // trailing elements in the underlying storage.  That will
        // tend to reduce shuffling of later elements.  Since this
        // function isn't called for subscripting, this won't slow
        // down that case.
        var native = nativeBuffer
        let offset = self.firstElementAddress - native.firstElementAddress
        let backingCount = native.count
        let myCount = count

        if _slowPath(backingCount > myCount + offset) {
          native.replaceSubrange(
            (myCount+offset)..<backingCount,
            with: 0,
            elementsOf: EmptyCollection())
        }
        _invariantCheck()
        return native
      }
    }
    return nil
  }
  @inlinable internal mutating func isMutableAndUniquelyReferenced() -> Swift.Bool {
    // This is a performance optimization that ensures that the copy of self
    // that occurs at -Onone is destroyed before we call
    // isUniquelyReferenced. This code used to be:
    //
    //   return _hasNativeBuffer && isUniquelyReferenced()
    //
    // SR-6437
    if !_hasNativeBuffer {
      return false
    }
    return isUniquelyReferenced()
  }
  @inlinable internal func requestNativeBuffer() -> Swift._ContiguousArrayBuffer<Element>? {
    _invariantCheck()
    if _fastPath(_hasNativeBuffer && nativeBuffer.count == count) {
      return nativeBuffer
    }
    return nil
  }
  @discardableResult
  @inlinable __consuming internal func _copyContents(subRange bounds: Swift.Range<Swift.Int>, initializing target: Swift.UnsafeMutablePointer<Element>) -> Swift.UnsafeMutablePointer<Element> {
    _invariantCheck()
    _internalInvariant(bounds.lowerBound >= startIndex)
    _internalInvariant(bounds.upperBound >= bounds.lowerBound)
    _internalInvariant(bounds.upperBound <= endIndex)
    let c = bounds.count
    target.initialize(from: subscriptBaseAddress + bounds.lowerBound, count: c)
    return target + c
  }
  __consuming public func _copyContents(initializing buffer: Swift.UnsafeMutableBufferPointer<Element>) -> (Swift._SliceBuffer<Element>.Iterator, Swift.UnsafeMutableBufferPointer<Element>.Index)
  @inlinable internal var arrayPropertyIsNativeTypeChecked: Swift.Bool {
    get {
    return _hasNativeBuffer
  }
  }
  @inlinable internal var count: Swift.Int {
    get {
      return endIndex - startIndex
    }
    set {
      let growth = newValue - count
      if growth != 0 {
        nativeBuffer.mutableCount += growth
        self.endIndex += growth
      }
      _invariantCheck()
    }
  }
  @inlinable internal func _checkValidSubscript(_ index: Swift.Int) {
    _precondition(
      index >= startIndex && index < endIndex, "Index out of bounds")
  }
  @inlinable internal var capacity: Swift.Int {
    get {
    let count = self.count
    if _slowPath(!_hasNativeBuffer) {
      return count
    }
    let n = nativeBuffer
    let nativeEnd = n.firstElementAddress + n.count
    if (firstElementAddress + count) == nativeEnd {
      return count + (n.capacity - n.count)
    }
    return count
  }
  }
  @inlinable internal mutating func isUniquelyReferenced() -> Swift.Bool {
    return isKnownUniquelyReferenced(&owner)
  }
  @_alwaysEmitIntoClient internal mutating func beginCOWMutation() -> Swift.Bool {
    if !_hasNativeBuffer {
      return false
    }
    if Bool(Builtin.beginCOWMutation(&owner)) {
      return true
    }
    return false;
  }
  @_alwaysEmitIntoClient @inline(__always) internal mutating func endCOWMutation() {
    Builtin.endCOWMutation(&owner)
  }
  @inlinable internal func getElement(_ i: Swift.Int) -> Element {
    _internalInvariant(i >= startIndex, "slice index is out of range (before startIndex)")
    _internalInvariant(i < endIndex, "slice index is out of range")
    return subscriptBaseAddress[i]
  }
  @inlinable internal subscript(position: Swift.Int) -> Element {
    get {
      return getElement(position)
    }
    nonmutating set {
      _internalInvariant(position >= startIndex, "slice index is out of range (before startIndex)")
      _internalInvariant(position < endIndex, "slice index is out of range")
      subscriptBaseAddress[position] = newValue
    }
  }
  @inlinable internal subscript(bounds: Swift.Range<Swift.Int>) -> Swift._SliceBuffer<Element> {
    get {
      _internalInvariant(bounds.lowerBound >= startIndex)
      _internalInvariant(bounds.upperBound >= bounds.lowerBound)
      _internalInvariant(bounds.upperBound <= endIndex)
      return _SliceBuffer(
        owner: owner,
        subscriptBaseAddress: subscriptBaseAddress,
        indices: bounds,
        hasNativeBuffer: _hasNativeBuffer)
    }
    set {
      fatalError("not implemented")
    }
  }
  @inlinable internal var endIndex: Swift.Int {
    get {
      return Int(endIndexAndFlags >> 1)
    }
    set {
      endIndexAndFlags = (UInt(newValue) << 1) | (_hasNativeBuffer ? 1 : 0)
    }
  }
  @usableFromInline
  internal typealias Indices = Swift.Range<Swift.Int>
  @inlinable internal func withUnsafeBufferPointer<R>(_ body: (Swift.UnsafeBufferPointer<Element>) throws -> R) rethrows -> R {
    defer { _fixLifetime(self) }
    return try body(UnsafeBufferPointer(start: firstElementAddress,
      count: count))
  }
  @inlinable internal mutating func withUnsafeMutableBufferPointer<R>(_ body: (Swift.UnsafeMutableBufferPointer<Element>) throws -> R) rethrows -> R {
    defer { _fixLifetime(self) }
    return try body(
      UnsafeMutableBufferPointer(start: firstElementAddress, count: count))
  }
  @inlinable internal func unsafeCastElements<T>(to type: T.Type) -> Swift._SliceBuffer<T> {
    _internalInvariant(_isClassOrObjCExistential(T.self))
    let baseAddress = UnsafeMutableRawPointer(self.subscriptBaseAddress)
      .assumingMemoryBound(to: T.self)
    return _SliceBuffer<T>(
      owner: self.owner,
      subscriptBaseAddress: baseAddress,
      startIndex: self.startIndex,
      endIndexAndFlags: self.endIndexAndFlags)
  }
  @usableFromInline
  internal typealias Index = Swift.Int
  @usableFromInline
  internal typealias Iterator = Swift.IndexingIterator<Swift._SliceBuffer<Element>>
  @usableFromInline
  internal typealias SubSequence = Swift._SliceBuffer<Element>
}
extension _SliceBuffer {
  @inlinable __consuming internal func _copyToContiguousArray() -> Swift.ContiguousArray<Element> {
    if _hasNativeBuffer {
      let n = nativeBuffer
      if count == n.count {
        return ContiguousArray(_buffer: n)
      }
    }

    let result = _ContiguousArrayBuffer<Element>(
      _uninitializedCount: count,
      minimumCapacity: 0)
    result.firstElementAddress.initialize(
      from: firstElementAddress, count: count)
    return ContiguousArray(_buffer: result)
  }
}
infix operator .== : ComparisonPrecedence
infix operator .!= : ComparisonPrecedence
infix operator .< : ComparisonPrecedence
infix operator .<= : ComparisonPrecedence
infix operator .> : ComparisonPrecedence
infix operator .>= : ComparisonPrecedence
infix operator .& : LogicalConjunctionPrecedence
infix operator .^ : LogicalDisjunctionPrecedence
infix operator .| : LogicalDisjunctionPrecedence
infix operator .&= : AssignmentPrecedence
infix operator .^= : AssignmentPrecedence
infix operator .|= : AssignmentPrecedence
prefix operator .!
public protocol SIMDStorage {
  associatedtype Scalar : Swift.Decodable, Swift.Encodable, Swift.Hashable
  var scalarCount: Swift.Int { get }
  init()
  subscript(index: Swift.Int) -> Self.Scalar { get set }
}
extension SIMDStorage {
  @_alwaysEmitIntoClient public static var scalarCount: Swift.Int {
    get {
    // Wouldn't it make more sense to define the instance var in terms of the
    // static var? Yes, probably, but by doing it this way we make the static
    // var backdeployable.
    return Self().scalarCount
  }
  }
}
public protocol SIMDScalar {
  associatedtype SIMDMaskScalar : Swift.FixedWidthInteger, Swift.SIMDScalar, Swift.SignedInteger
  associatedtype SIMD2Storage : Swift.SIMDStorage where Self.SIMD2Storage.Scalar == Self.SIMD32Storage.Scalar
  associatedtype SIMD4Storage : Swift.SIMDStorage where Self.SIMD4Storage.Scalar == Self.SIMD64Storage.Scalar
  associatedtype SIMD8Storage : Swift.SIMDStorage
  associatedtype SIMD16Storage : Swift.SIMDStorage where Self == Self.SIMD16Storage.Scalar, Self.SIMD16Storage.Scalar == Self.SIMD2Storage.Scalar
  associatedtype SIMD32Storage : Swift.SIMDStorage where Self.SIMD32Storage.Scalar == Self.SIMD4Storage.Scalar
  associatedtype SIMD64Storage : Swift.SIMDStorage where Self.SIMD64Storage.Scalar == Self.SIMD8Storage.Scalar
}
public protocol SIMD : Swift.CustomStringConvertible, Swift.Decodable, Swift.Encodable, Swift.ExpressibleByArrayLiteral, Swift.Hashable, Swift.SIMDStorage {
  associatedtype MaskStorage : Swift.SIMD where Self.MaskStorage.Scalar : Swift.FixedWidthInteger, Self.MaskStorage.Scalar : Swift.SignedInteger
}
extension SIMD {
  @_transparent public var indices: Swift.Range<Swift.Int> {
    @_transparent get {
    return 0 ..< scalarCount
  }
  }
  @_transparent public init(repeating value: Self.Scalar) {
    self.init()
    for i in indices { self[i] = value }
  }
  @_transparent public static func == (lhs: Self, rhs: Self) -> Swift.Bool {
    var result = true
    for i in lhs.indices { result = result && lhs[i] == rhs[i] }
    return result
  }
  @inlinable public func hash(into hasher: inout Swift.Hasher) {
    for i in indices { hasher.combine(self[i]) }
  }
  public func encode(to encoder: Swift.Encoder) throws
  public init(from decoder: Swift.Decoder) throws
  public var description: Swift.String {
    get
  }
  @_transparent public static func .== (lhs: Self, rhs: Self) -> Swift.SIMDMask<Self.MaskStorage> {
    var result = SIMDMask<MaskStorage>()
    for i in result.indices { result[i] = lhs[i] == rhs[i] }
    return result
  }
  @_transparent public static func .!= (lhs: Self, rhs: Self) -> Swift.SIMDMask<Self.MaskStorage> {
    var result = SIMDMask<MaskStorage>()
    for i in result.indices { result[i] = lhs[i] != rhs[i] }
    return result
  }
  @_transparent public mutating func replace(with other: Self, where mask: Swift.SIMDMask<Self.MaskStorage>) {
    for i in indices { self[i] = mask[i] ? other[i] : self[i] }
  }
  @inlinable public init(arrayLiteral scalars: Self.Scalar...) {
    self.init(scalars)
  }
  @inlinable public init<S>(_ scalars: S) where S : Swift.Sequence, Self.Scalar == S.Element {
    self.init()
    var index = 0
    for scalar in scalars {
      if index == scalarCount {
        _preconditionFailure("Too many elements in sequence.")
      }
      self[index] = scalar
      index += 1
    }
    if index < scalarCount {
      _preconditionFailure("Not enough elements in sequence.")
    }
  }
  @_alwaysEmitIntoClient public subscript<Index>(index: Swift.SIMD2<Index>) -> Swift.SIMD2<Self.Scalar> where Index : Swift.FixedWidthInteger, Index : Swift.SIMDScalar, Self.Scalar : Swift.SIMDScalar {
    get {
    var result = SIMD2<Scalar>()
    for i in result.indices {
      result[i] = self[Int(index[i]) % scalarCount]
    }
    return result
  }
  }
  @_alwaysEmitIntoClient public subscript<Index>(index: Swift.SIMD3<Index>) -> Swift.SIMD3<Self.Scalar> where Index : Swift.FixedWidthInteger, Index : Swift.SIMDScalar, Self.Scalar : Swift.SIMDScalar {
    get {
    var result = SIMD3<Scalar>()
    for i in result.indices {
      result[i] = self[Int(index[i]) % scalarCount]
    }
    return result
  }
  }
  @_alwaysEmitIntoClient public subscript<Index>(index: Swift.SIMD4<Index>) -> Swift.SIMD4<Self.Scalar> where Index : Swift.FixedWidthInteger, Index : Swift.SIMDScalar, Self.Scalar : Swift.SIMDScalar {
    get {
    var result = SIMD4<Scalar>()
    for i in result.indices {
      result[i] = self[Int(index[i]) % scalarCount]
    }
    return result
  }
  }
  @_alwaysEmitIntoClient public subscript<Index>(index: Swift.SIMD8<Index>) -> Swift.SIMD8<Self.Scalar> where Index : Swift.FixedWidthInteger, Index : Swift.SIMDScalar, Self.Scalar : Swift.SIMDScalar {
    get {
    var result = SIMD8<Scalar>()
    for i in result.indices {
      result[i] = self[Int(index[i]) % scalarCount]
    }
    return result
  }
  }
  @_alwaysEmitIntoClient public subscript<Index>(index: Swift.SIMD16<Index>) -> Swift.SIMD16<Self.Scalar> where Index : Swift.FixedWidthInteger, Index : Swift.SIMDScalar, Self.Scalar : Swift.SIMDScalar {
    get {
    var result = SIMD16<Scalar>()
    for i in result.indices {
      result[i] = self[Int(index[i]) % scalarCount]
    }
    return result
  }
  }
  @_alwaysEmitIntoClient public subscript<Index>(index: Swift.SIMD32<Index>) -> Swift.SIMD32<Self.Scalar> where Index : Swift.FixedWidthInteger, Index : Swift.SIMDScalar, Self.Scalar : Swift.SIMDScalar {
    get {
    var result = SIMD32<Scalar>()
    for i in result.indices {
      result[i] = self[Int(index[i]) % scalarCount]
    }
    return result
  }
  }
  @_alwaysEmitIntoClient public subscript<Index>(index: Swift.SIMD64<Index>) -> Swift.SIMD64<Self.Scalar> where Index : Swift.FixedWidthInteger, Index : Swift.SIMDScalar, Self.Scalar : Swift.SIMDScalar {
    get {
    var result = SIMD64<Scalar>()
    for i in result.indices {
      result[i] = self[Int(index[i]) % scalarCount]
    }
    return result
  }
  }
}
extension SIMD where Self.Scalar : Swift.Comparable {
  @_transparent public static func .< (lhs: Self, rhs: Self) -> Swift.SIMDMask<Self.MaskStorage> {
    var result = SIMDMask<MaskStorage>()
    for i in result.indices { result[i] = lhs[i] < rhs[i] }
    return result
  }
  @_transparent public static func .<= (lhs: Self, rhs: Self) -> Swift.SIMDMask<Self.MaskStorage> {
    var result = SIMDMask<MaskStorage>()
    for i in result.indices { result[i] = lhs[i] <= rhs[i] }
    return result
  }
  @_alwaysEmitIntoClient public func min() -> Self.Scalar {
    return indices.reduce(into: self[0]) { $0 = Swift.min($0, self[$1]) }
  }
  @_alwaysEmitIntoClient public func max() -> Self.Scalar {
    return indices.reduce(into: self[0]) { $0 = Swift.max($0, self[$1]) }
  }
}
extension SIMD {
  @_transparent public static func .== (lhs: Self.Scalar, rhs: Self) -> Swift.SIMDMask<Self.MaskStorage> {
    return Self(repeating: lhs) .== rhs
  }
  @_transparent public static func .!= (lhs: Self.Scalar, rhs: Self) -> Swift.SIMDMask<Self.MaskStorage> {
    return Self(repeating: lhs) .!= rhs
  }
  @_transparent public static func .== (lhs: Self, rhs: Self.Scalar) -> Swift.SIMDMask<Self.MaskStorage> {
    return lhs .== Self(repeating: rhs)
  }
  @_transparent public static func .!= (lhs: Self, rhs: Self.Scalar) -> Swift.SIMDMask<Self.MaskStorage> {
    return lhs .!= Self(repeating: rhs)
  }
  @_transparent public mutating func replace(with other: Self.Scalar, where mask: Swift.SIMDMask<Self.MaskStorage>) {
    replace(with: Self(repeating: other), where: mask)
  }
  @_transparent public func replacing(with other: Self, where mask: Swift.SIMDMask<Self.MaskStorage>) -> Self {
    var result = self
    result.replace(with: other, where: mask)
    return result
  }
  @_transparent public func replacing(with other: Self.Scalar, where mask: Swift.SIMDMask<Self.MaskStorage>) -> Self {
    return replacing(with: Self(repeating: other), where: mask)
  }
}
extension SIMD where Self.Scalar : Swift.Comparable {
  @_transparent public static func .>= (lhs: Self, rhs: Self) -> Swift.SIMDMask<Self.MaskStorage> {
    return rhs .<= lhs
  }
  @_transparent public static func .> (lhs: Self, rhs: Self) -> Swift.SIMDMask<Self.MaskStorage> {
    return rhs .< lhs
  }
  @_transparent public static func .< (lhs: Self.Scalar, rhs: Self) -> Swift.SIMDMask<Self.MaskStorage> {
    return Self(repeating: lhs) .< rhs
  }
  @_transparent public static func .<= (lhs: Self.Scalar, rhs: Self) -> Swift.SIMDMask<Self.MaskStorage> {
    return Self(repeating: lhs) .<= rhs
  }
  @_transparent public static func .>= (lhs: Self.Scalar, rhs: Self) -> Swift.SIMDMask<Self.MaskStorage> {
    return Self(repeating: lhs) .>= rhs
  }
  @_transparent public static func .> (lhs: Self.Scalar, rhs: Self) -> Swift.SIMDMask<Self.MaskStorage> {
    return Self(repeating: lhs) .> rhs
  }
  @_transparent public static func .< (lhs: Self, rhs: Self.Scalar) -> Swift.SIMDMask<Self.MaskStorage> {
    return lhs .< Self(repeating: rhs)
  }
  @_transparent public static func .<= (lhs: Self, rhs: Self.Scalar) -> Swift.SIMDMask<Self.MaskStorage> {
    return lhs .<= Self(repeating: rhs)
  }
  @_transparent public static func .>= (lhs: Self, rhs: Self.Scalar) -> Swift.SIMDMask<Self.MaskStorage> {
    return lhs .>= Self(repeating: rhs)
  }
  @_transparent public static func .> (lhs: Self, rhs: Self.Scalar) -> Swift.SIMDMask<Self.MaskStorage> {
    return lhs .> Self(repeating: rhs)
  }
  @_alwaysEmitIntoClient public mutating func clamp(lowerBound: Self, upperBound: Self) {
    self = self.clamped(lowerBound: lowerBound, upperBound: upperBound)
  }
  @_alwaysEmitIntoClient public func clamped(lowerBound: Self, upperBound: Self) -> Self {
    return pointwiseMin(upperBound, pointwiseMax(lowerBound, self))
  }
}
extension SIMD where Self.Scalar : Swift.FixedWidthInteger {
  @_transparent public static var zero: Self {
    @_transparent get {
    return Self()
  }
  }
  @_alwaysEmitIntoClient public static var one: Self {
    get {
    return Self(repeating: 1)
  }
  }
  @inlinable public static func random<T>(in range: Swift.Range<Self.Scalar>, using generator: inout T) -> Self where T : Swift.RandomNumberGenerator {
    var result = Self()
    for i in result.indices {
      result[i] = Scalar.random(in: range, using: &generator)
    }
    return result
  }
  @inlinable public static func random(in range: Swift.Range<Self.Scalar>) -> Self {
    var g = SystemRandomNumberGenerator()
    return Self.random(in: range, using: &g)
  }
  @inlinable public static func random<T>(in range: Swift.ClosedRange<Self.Scalar>, using generator: inout T) -> Self where T : Swift.RandomNumberGenerator {
    var result = Self()
    for i in result.indices {
      result[i] = Scalar.random(in: range, using: &generator)
    }
    return result
  }
  @inlinable public static func random(in range: Swift.ClosedRange<Self.Scalar>) -> Self {
    var g = SystemRandomNumberGenerator()
    return Self.random(in: range, using: &g)
  }
}
extension SIMD where Self.Scalar : Swift.FloatingPoint {
  @_transparent public static var zero: Self {
    @_transparent get {
    return Self()
  }
  }
  @_alwaysEmitIntoClient public static var one: Self {
    get {
    return Self(repeating: 1)
  }
  }
  @_alwaysEmitIntoClient public mutating func clamp(lowerBound: Self, upperBound: Self) {
    self = self.clamped(lowerBound: lowerBound, upperBound: upperBound)
  }
  @_alwaysEmitIntoClient public func clamped(lowerBound: Self, upperBound: Self) -> Self {
    return pointwiseMin(upperBound, pointwiseMax(lowerBound, self))
  }
}
extension SIMD where Self.Scalar : Swift.BinaryFloatingPoint, Self.Scalar.RawSignificand : Swift.FixedWidthInteger {
  @inlinable public static func random<T>(in range: Swift.Range<Self.Scalar>, using generator: inout T) -> Self where T : Swift.RandomNumberGenerator {
    var result = Self()
    for i in result.indices {
      result[i] = Scalar.random(in: range, using: &generator)
    }
    return result
  }
  @inlinable public static func random(in range: Swift.Range<Self.Scalar>) -> Self {
    var g = SystemRandomNumberGenerator()
    return Self.random(in: range, using: &g)
  }
  @inlinable public static func random<T>(in range: Swift.ClosedRange<Self.Scalar>, using generator: inout T) -> Self where T : Swift.RandomNumberGenerator {
    var result = Self()
    for i in result.indices {
      result[i] = Scalar.random(in: range, using: &generator)
    }
    return result
  }
  @inlinable public static func random(in range: Swift.ClosedRange<Self.Scalar>) -> Self {
    var g = SystemRandomNumberGenerator()
    return Self.random(in: range, using: &g)
  }
}
@frozen public struct SIMDMask<Storage> : Swift.SIMD where Storage : Swift.SIMD, Storage.Scalar : Swift.FixedWidthInteger, Storage.Scalar : Swift.SignedInteger {
  public var _storage: Storage
  public typealias MaskStorage = Storage
  public typealias Scalar = Swift.Bool
  @_transparent public var scalarCount: Swift.Int {
    @_transparent get {
    return _storage.scalarCount
  }
  }
  @_transparent public init() {
    _storage = Storage()
  }
  @_transparent public init(_ _storage: Storage) {
    self._storage = _storage
  }
  public subscript(index: Swift.Int) -> Swift.Bool {
    @_transparent get {
      _precondition(indices.contains(index))
      return _storage[index] < 0
    }
    @_transparent set {
      _precondition(indices.contains(index))
      _storage[index] = newValue ? -1 : 0
    }
  }
  public typealias ArrayLiteralElement = Swift.SIMDMask<Storage>.Scalar
  public var hashValue: Swift.Int {
    get
  }
}
extension SIMDMask {
  @inlinable public static func random<T>(using generator: inout T) -> Swift.SIMDMask<Storage> where T : Swift.RandomNumberGenerator {
    var result = SIMDMask()
    for i in result.indices { result[i] = Bool.random(using: &generator) }
    return result
  }
  @inlinable public static func random() -> Swift.SIMDMask<Storage> {
    var g = SystemRandomNumberGenerator()
    return SIMDMask.random(using: &g)
  }
}
extension SIMD where Self.Scalar : Swift.FixedWidthInteger {
  @_transparent public var leadingZeroBitCount: Self {
    @_transparent get {
    var result = Self()
    for i in indices { result[i] = Scalar(self[i].leadingZeroBitCount) }
    return result
  }
  }
  @_transparent public var trailingZeroBitCount: Self {
    @_transparent get {
    var result = Self()
    for i in indices { result[i] = Scalar(self[i].trailingZeroBitCount) }
    return result
  }
  }
  @_transparent public var nonzeroBitCount: Self {
    @_transparent get {
    var result = Self()
    for i in indices { result[i] = Scalar(self[i].nonzeroBitCount) }
    return result
  }
  }
  @_transparent prefix public static func ~ (rhs: Self) -> Self {
    var result = Self()
    for i in result.indices { result[i] = ~rhs[i] }
    return result
  }
  @_transparent public static func & (lhs: Self, rhs: Self) -> Self {
    var result = Self()
    for i in result.indices { result[i] = lhs[i] & rhs[i] }
    return result
  }
  @_transparent public static func ^ (lhs: Self, rhs: Self) -> Self {
    var result = Self()
    for i in result.indices { result[i] = lhs[i] ^ rhs[i] }
    return result
  }
  @_transparent public static func | (lhs: Self, rhs: Self) -> Self {
    var result = Self()
    for i in result.indices { result[i] = lhs[i] | rhs[i] }
    return result
  }
  @_transparent public static func &<< (lhs: Self, rhs: Self) -> Self {
    var result = Self()
    for i in result.indices { result[i] = lhs[i] &<< rhs[i] }
    return result
  }
  @_transparent public static func &>> (lhs: Self, rhs: Self) -> Self {
    var result = Self()
    for i in result.indices { result[i] = lhs[i] &>> rhs[i] }
    return result
  }
  @_transparent public static func &+ (lhs: Self, rhs: Self) -> Self {
    var result = Self()
    for i in result.indices { result[i] = lhs[i] &+ rhs[i] }
    return result
  }
  @_transparent public static func &- (lhs: Self, rhs: Self) -> Self {
    var result = Self()
    for i in result.indices { result[i] = lhs[i] &- rhs[i] }
    return result
  }
  @_transparent public static func &* (lhs: Self, rhs: Self) -> Self {
    var result = Self()
    for i in result.indices { result[i] = lhs[i] &* rhs[i] }
    return result
  }
  @_transparent public static func / (lhs: Self, rhs: Self) -> Self {
    var result = Self()
    for i in result.indices { result[i] = lhs[i] / rhs[i] }
    return result
  }
  @_transparent public static func % (lhs: Self, rhs: Self) -> Self {
    var result = Self()
    for i in result.indices { result[i] = lhs[i] % rhs[i] }
    return result
  }
  @_alwaysEmitIntoClient public func wrappedSum() -> Self.Scalar {
    return indices.reduce(into: 0) { $0 &+= self[$1] }
  }
}
extension SIMD where Self.Scalar : Swift.FloatingPoint {
  @_transparent public static func + (lhs: Self, rhs: Self) -> Self {
    var result = Self()
    for i in result.indices { result[i] = lhs[i] + rhs[i] }
    return result
  }
  @_transparent public static func - (lhs: Self, rhs: Self) -> Self {
    var result = Self()
    for i in result.indices { result[i] = lhs[i] - rhs[i] }
    return result
  }
  @_transparent public static func * (lhs: Self, rhs: Self) -> Self {
    var result = Self()
    for i in result.indices { result[i] = lhs[i] * rhs[i] }
    return result
  }
  @_transparent public static func / (lhs: Self, rhs: Self) -> Self {
    var result = Self()
    for i in result.indices { result[i] = lhs[i] / rhs[i] }
    return result
  }
  @_transparent public func addingProduct(_ lhs: Self, _ rhs: Self) -> Self {
    var result = Self()
    for i in result.indices { result[i] = self[i].addingProduct(lhs[i], rhs[i]) }
    return result
  }
  @_transparent public func squareRoot() -> Self {
    var result = Self()
    for i in result.indices { result[i] = self[i].squareRoot() }
    return result
  }
  @_transparent public func rounded(_ rule: Swift.FloatingPointRoundingRule) -> Self {
    var result = Self()
    for i in result.indices { result[i] = self[i].rounded(rule) }
    return result
  }
  @_alwaysEmitIntoClient public func min() -> Self.Scalar {
    return indices.reduce(into: self[0]) { $0 = Scalar.minimum($0, self[$1]) }
  }
  @_alwaysEmitIntoClient public func max() -> Self.Scalar {
    return indices.reduce(into: self[0]) { $0 = Scalar.maximum($0, self[$1]) }
  }
  @_alwaysEmitIntoClient public func sum() -> Self.Scalar {
    // Implementation note: this eventually be defined to lower to either
    // llvm.experimental.vector.reduce.fadd or an explicit tree-sum. Open-
    // coding the tree sum is problematic, we probably need to define a
    // Swift Builtin to support it.
    return indices.reduce(into: 0) { $0 += self[$1] }
  }
}
extension SIMDMask {
  @_transparent prefix public static func .! (rhs: Swift.SIMDMask<Storage>) -> Swift.SIMDMask<Storage> {
    return SIMDMask(~rhs._storage)
  }
  @_transparent public static func .& (lhs: Swift.SIMDMask<Storage>, rhs: Swift.SIMDMask<Storage>) -> Swift.SIMDMask<Storage> {
    return SIMDMask(lhs._storage & rhs._storage)
  }
  @_transparent public static func .^ (lhs: Swift.SIMDMask<Storage>, rhs: Swift.SIMDMask<Storage>) -> Swift.SIMDMask<Storage> {
    return SIMDMask(lhs._storage ^ rhs._storage)
  }
  @_transparent public static func .| (lhs: Swift.SIMDMask<Storage>, rhs: Swift.SIMDMask<Storage>) -> Swift.SIMDMask<Storage> {
    return SIMDMask(lhs._storage | rhs._storage)
  }
}
extension SIMD where Self.Scalar : Swift.FixedWidthInteger {
  @_transparent public static func & (lhs: Self.Scalar, rhs: Self) -> Self {
    return Self(repeating: lhs) & rhs
  }
  @_transparent public static func ^ (lhs: Self.Scalar, rhs: Self) -> Self {
    return Self(repeating: lhs) ^ rhs
  }
  @_transparent public static func | (lhs: Self.Scalar, rhs: Self) -> Self {
    return Self(repeating: lhs) | rhs
  }
  @_transparent public static func &<< (lhs: Self.Scalar, rhs: Self) -> Self {
    return Self(repeating: lhs) &<< rhs
  }
  @_transparent public static func &>> (lhs: Self.Scalar, rhs: Self) -> Self {
    return Self(repeating: lhs) &>> rhs
  }
  @_transparent public static func &+ (lhs: Self.Scalar, rhs: Self) -> Self {
    return Self(repeating: lhs) &+ rhs
  }
  @_transparent public static func &- (lhs: Self.Scalar, rhs: Self) -> Self {
    return Self(repeating: lhs) &- rhs
  }
  @_transparent public static func &* (lhs: Self.Scalar, rhs: Self) -> Self {
    return Self(repeating: lhs) &* rhs
  }
  @_transparent public static func / (lhs: Self.Scalar, rhs: Self) -> Self {
    return Self(repeating: lhs) / rhs
  }
  @_transparent public static func % (lhs: Self.Scalar, rhs: Self) -> Self {
    return Self(repeating: lhs) % rhs
  }
  @_transparent public static func & (lhs: Self, rhs: Self.Scalar) -> Self {
    return lhs & Self(repeating: rhs)
  }
  @_transparent public static func ^ (lhs: Self, rhs: Self.Scalar) -> Self {
    return lhs ^ Self(repeating: rhs)
  }
  @_transparent public static func | (lhs: Self, rhs: Self.Scalar) -> Self {
    return lhs | Self(repeating: rhs)
  }
  @_transparent public static func &<< (lhs: Self, rhs: Self.Scalar) -> Self {
    return lhs &<< Self(repeating: rhs)
  }
  @_transparent public static func &>> (lhs: Self, rhs: Self.Scalar) -> Self {
    return lhs &>> Self(repeating: rhs)
  }
  @_transparent public static func &+ (lhs: Self, rhs: Self.Scalar) -> Self {
    return lhs &+ Self(repeating: rhs)
  }
  @_transparent public static func &- (lhs: Self, rhs: Self.Scalar) -> Self {
    return lhs &- Self(repeating: rhs)
  }
  @_transparent public static func &* (lhs: Self, rhs: Self.Scalar) -> Self {
    return lhs &* Self(repeating: rhs)
  }
  @_transparent public static func / (lhs: Self, rhs: Self.Scalar) -> Self {
    return lhs / Self(repeating: rhs)
  }
  @_transparent public static func % (lhs: Self, rhs: Self.Scalar) -> Self {
    return lhs % Self(repeating: rhs)
  }
  @_transparent public static func &= (lhs: inout Self, rhs: Self) {
    lhs = lhs & rhs
  }
  @_transparent public static func ^= (lhs: inout Self, rhs: Self) {
    lhs = lhs ^ rhs
  }
  @_transparent public static func |= (lhs: inout Self, rhs: Self) {
    lhs = lhs | rhs
  }
  @_transparent public static func &<<= (lhs: inout Self, rhs: Self) {
    lhs = lhs &<< rhs
  }
  @_transparent public static func &>>= (lhs: inout Self, rhs: Self) {
    lhs = lhs &>> rhs
  }
  @_transparent public static func &+= (lhs: inout Self, rhs: Self) {
    lhs = lhs &+ rhs
  }
  @_transparent public static func &-= (lhs: inout Self, rhs: Self) {
    lhs = lhs &- rhs
  }
  @_transparent public static func &*= (lhs: inout Self, rhs: Self) {
    lhs = lhs &* rhs
  }
  @_transparent public static func /= (lhs: inout Self, rhs: Self) {
    lhs = lhs / rhs
  }
  @_transparent public static func %= (lhs: inout Self, rhs: Self) {
    lhs = lhs % rhs
  }
  @_transparent public static func &= (lhs: inout Self, rhs: Self.Scalar) {
    lhs = lhs & rhs
  }
  @_transparent public static func ^= (lhs: inout Self, rhs: Self.Scalar) {
    lhs = lhs ^ rhs
  }
  @_transparent public static func |= (lhs: inout Self, rhs: Self.Scalar) {
    lhs = lhs | rhs
  }
  @_transparent public static func &<<= (lhs: inout Self, rhs: Self.Scalar) {
    lhs = lhs &<< rhs
  }
  @_transparent public static func &>>= (lhs: inout Self, rhs: Self.Scalar) {
    lhs = lhs &>> rhs
  }
  @_transparent public static func &+= (lhs: inout Self, rhs: Self.Scalar) {
    lhs = lhs &+ rhs
  }
  @_transparent public static func &-= (lhs: inout Self, rhs: Self.Scalar) {
    lhs = lhs &- rhs
  }
  @_transparent public static func &*= (lhs: inout Self, rhs: Self.Scalar) {
    lhs = lhs &* rhs
  }
  @_transparent public static func /= (lhs: inout Self, rhs: Self.Scalar) {
    lhs = lhs / rhs
  }
  @_transparent public static func %= (lhs: inout Self, rhs: Self.Scalar) {
    lhs = lhs % rhs
  }
  @available(*, unavailable, message: "integer vector types do not support checked arithmetic; use the wrapping operator '&+' instead")
  public static func + (lhs: Self, rhs: Self) -> Self
  @available(*, unavailable, message: "integer vector types do not support checked arithmetic; use the wrapping operator '&-' instead")
  public static func - (lhs: Self, rhs: Self) -> Self
  @available(*, unavailable, message: "integer vector types do not support checked arithmetic; use the wrapping operator '&*' instead")
  public static func * (lhs: Self, rhs: Self) -> Self
  @available(*, unavailable, message: "integer vector types do not support checked arithmetic; use the wrapping operator '&+' instead")
  public static func + (lhs: Self, rhs: Self.Scalar) -> Self
  @available(*, unavailable, message: "integer vector types do not support checked arithmetic; use the wrapping operator '&-' instead")
  public static func - (lhs: Self, rhs: Self.Scalar) -> Self
  @available(*, unavailable, message: "integer vector types do not support checked arithmetic; use the wrapping operator '&*' instead")
  public static func * (lhs: Self, rhs: Self.Scalar) -> Self
  @available(*, unavailable, message: "integer vector types do not support checked arithmetic; use the wrapping operator '&+' instead")
  public static func + (lhs: Self.Scalar, rhs: Self) -> Self
  @available(*, unavailable, message: "integer vector types do not support checked arithmetic; use the wrapping operator '&-' instead")
  public static func - (lhs: Self.Scalar, rhs: Self) -> Self
  @available(*, unavailable, message: "integer vector types do not support checked arithmetic; use the wrapping operator '&*' instead")
  public static func * (lhs: Self.Scalar, rhs: Self) -> Self
  @available(*, unavailable, message: "integer vector types do not support checked arithmetic; use the wrapping operator '&+=' instead")
  public static func += (lhs: inout Self, rhs: Self)
  @available(*, unavailable, message: "integer vector types do not support checked arithmetic; use the wrapping operator '&-=' instead")
  public static func -= (lhs: inout Self, rhs: Self)
  @available(*, unavailable, message: "integer vector types do not support checked arithmetic; use the wrapping operator '&*=' instead")
  public static func *= (lhs: inout Self, rhs: Self)
  @available(*, unavailable, message: "integer vector types do not support checked arithmetic; use the wrapping operator '&+=' instead")
  public static func += (lhs: inout Self, rhs: Self.Scalar)
  @available(*, unavailable, message: "integer vector types do not support checked arithmetic; use the wrapping operator '&-=' instead")
  public static func -= (lhs: inout Self, rhs: Self.Scalar)
  @available(*, unavailable, message: "integer vector types do not support checked arithmetic; use the wrapping operator '&*=' instead")
  public static func *= (lhs: inout Self, rhs: Self.Scalar)
}
extension SIMD where Self.Scalar : Swift.FloatingPoint {
  @_transparent prefix public static func - (rhs: Self) -> Self {
    return 0 - rhs
  }
  @_transparent public static func + (lhs: Self.Scalar, rhs: Self) -> Self {
    return Self(repeating: lhs) + rhs
  }
  @_transparent public static func - (lhs: Self.Scalar, rhs: Self) -> Self {
    return Self(repeating: lhs) - rhs
  }
  @_transparent public static func * (lhs: Self.Scalar, rhs: Self) -> Self {
    return Self(repeating: lhs) * rhs
  }
  @_transparent public static func / (lhs: Self.Scalar, rhs: Self) -> Self {
    return Self(repeating: lhs) / rhs
  }
  @_transparent public static func + (lhs: Self, rhs: Self.Scalar) -> Self {
    return lhs + Self(repeating: rhs)
  }
  @_transparent public static func - (lhs: Self, rhs: Self.Scalar) -> Self {
    return lhs - Self(repeating: rhs)
  }
  @_transparent public static func * (lhs: Self, rhs: Self.Scalar) -> Self {
    return lhs * Self(repeating: rhs)
  }
  @_transparent public static func / (lhs: Self, rhs: Self.Scalar) -> Self {
    return lhs / Self(repeating: rhs)
  }
  @_transparent public static func += (lhs: inout Self, rhs: Self) {
    lhs = lhs + rhs
  }
  @_transparent public static func -= (lhs: inout Self, rhs: Self) {
    lhs = lhs - rhs
  }
  @_transparent public static func *= (lhs: inout Self, rhs: Self) {
    lhs = lhs * rhs
  }
  @_transparent public static func /= (lhs: inout Self, rhs: Self) {
    lhs = lhs / rhs
  }
  @_transparent public static func += (lhs: inout Self, rhs: Self.Scalar) {
    lhs = lhs + rhs
  }
  @_transparent public static func -= (lhs: inout Self, rhs: Self.Scalar) {
    lhs = lhs - rhs
  }
  @_transparent public static func *= (lhs: inout Self, rhs: Self.Scalar) {
    lhs = lhs * rhs
  }
  @_transparent public static func /= (lhs: inout Self, rhs: Self.Scalar) {
    lhs = lhs / rhs
  }
  @_transparent public func addingProduct(_ lhs: Self.Scalar, _ rhs: Self) -> Self {
    return self.addingProduct(Self(repeating: lhs), rhs)
  }
  @_transparent public func addingProduct(_ lhs: Self, _ rhs: Self.Scalar) -> Self {
    return self.addingProduct(lhs, Self(repeating: rhs))
  }
  @_transparent public mutating func addProduct(_ lhs: Self, _ rhs: Self) {
    self = self.addingProduct(lhs, rhs)
  }
  @_transparent public mutating func addProduct(_ lhs: Self.Scalar, _ rhs: Self) {
    self = self.addingProduct(lhs, rhs)
  }
  @_transparent public mutating func addProduct(_ lhs: Self, _ rhs: Self.Scalar) {
    self = self.addingProduct(lhs, rhs)
  }
  @_transparent public mutating func formSquareRoot() {
    self = self.squareRoot()
  }
  @_transparent public mutating func round(_ rule: Swift.FloatingPointRoundingRule) {
    self = self.rounded(rule)
  }
}
extension SIMDMask {
  @_transparent public static func .& (lhs: Swift.Bool, rhs: Swift.SIMDMask<Storage>) -> Swift.SIMDMask<Storage> {
    return SIMDMask(repeating: lhs) .& rhs
  }
  @_transparent public static func .^ (lhs: Swift.Bool, rhs: Swift.SIMDMask<Storage>) -> Swift.SIMDMask<Storage> {
    return SIMDMask(repeating: lhs) .^ rhs
  }
  @_transparent public static func .| (lhs: Swift.Bool, rhs: Swift.SIMDMask<Storage>) -> Swift.SIMDMask<Storage> {
    return SIMDMask(repeating: lhs) .| rhs
  }
  @_transparent public static func .& (lhs: Swift.SIMDMask<Storage>, rhs: Swift.Bool) -> Swift.SIMDMask<Storage> {
    return lhs .& SIMDMask(repeating: rhs)
  }
  @_transparent public static func .^ (lhs: Swift.SIMDMask<Storage>, rhs: Swift.Bool) -> Swift.SIMDMask<Storage> {
    return lhs .^ SIMDMask(repeating: rhs)
  }
  @_transparent public static func .| (lhs: Swift.SIMDMask<Storage>, rhs: Swift.Bool) -> Swift.SIMDMask<Storage> {
    return lhs .| SIMDMask(repeating: rhs)
  }
  @_transparent public static func .&= (lhs: inout Swift.SIMDMask<Storage>, rhs: Swift.SIMDMask<Storage>) {
    lhs = lhs .& rhs
  }
  @_transparent public static func .^= (lhs: inout Swift.SIMDMask<Storage>, rhs: Swift.SIMDMask<Storage>) {
    lhs = lhs .^ rhs
  }
  @_transparent public static func .|= (lhs: inout Swift.SIMDMask<Storage>, rhs: Swift.SIMDMask<Storage>) {
    lhs = lhs .| rhs
  }
  @_transparent public static func .&= (lhs: inout Swift.SIMDMask<Storage>, rhs: Swift.Bool) {
    lhs = lhs .& rhs
  }
  @_transparent public static func .^= (lhs: inout Swift.SIMDMask<Storage>, rhs: Swift.Bool) {
    lhs = lhs .^ rhs
  }
  @_transparent public static func .|= (lhs: inout Swift.SIMDMask<Storage>, rhs: Swift.Bool) {
    lhs = lhs .| rhs
  }
}
@_alwaysEmitIntoClient public func any<Storage>(_ mask: Swift.SIMDMask<Storage>) -> Swift.Bool where Storage : Swift.SIMD, Storage.Scalar : Swift.FixedWidthInteger, Storage.Scalar : Swift.SignedInteger {
  return mask._storage.min() < 0
}
@_alwaysEmitIntoClient public func all<Storage>(_ mask: Swift.SIMDMask<Storage>) -> Swift.Bool where Storage : Swift.SIMD, Storage.Scalar : Swift.FixedWidthInteger, Storage.Scalar : Swift.SignedInteger {
  return mask._storage.max() < 0
}
@_alwaysEmitIntoClient public func pointwiseMin<T>(_ a: T, _ b: T) -> T where T : Swift.SIMD, T.Scalar : Swift.Comparable {
  var result = T()
  for i in result.indices {
    result[i] = min(a[i], b[i])
  }
  return result
}
@_alwaysEmitIntoClient public func pointwiseMax<T>(_ a: T, _ b: T) -> T where T : Swift.SIMD, T.Scalar : Swift.Comparable {
  var result = T()
  for i in result.indices {
    result[i] = max(a[i], b[i])
  }
  return result
}
@_alwaysEmitIntoClient public func pointwiseMin<T>(_ a: T, _ b: T) -> T where T : Swift.SIMD, T.Scalar : Swift.FloatingPoint {
  var result = T()
  for i in result.indices {
    result[i] = T.Scalar.minimum(a[i], b[i])
  }
  return result
}
@_alwaysEmitIntoClient public func pointwiseMax<T>(_ a: T, _ b: T) -> T where T : Swift.SIMD, T.Scalar : Swift.FloatingPoint {
  var result = T()
  for i in result.indices {
    result[i] = T.Scalar.maximum(a[i], b[i])
  }
  return result
}
extension SIMD where Self : Swift.AdditiveArithmetic, Self.Scalar : Swift.FloatingPoint {
  @_alwaysEmitIntoClient public static func += (lhs: inout Self, rhs: Self) {
    lhs = lhs + rhs
  }
  @_alwaysEmitIntoClient public static func -= (lhs: inout Self, rhs: Self) {
    lhs = lhs - rhs
  }
}
@inlinable public func sequence<T>(first: T, next: @escaping (T) -> T?) -> Swift.UnfoldFirstSequence<T> {
  // The trivial implementation where the state is the next value to return
  // has the downside of being unnecessarily eager (it evaluates `next` one
  // step in advance). We solve this by using a boolean value to disambiguate
  // between the first value (that's computed in advance) and the rest.
  return sequence(state: (first, true), next: { (state: inout (T?, Bool)) -> T? in
    switch state {
    case (let value, true):
      state.1 = false
      return value
    case (let value?, _):
      let nextValue = next(value)
      state.0 = nextValue
      return nextValue
    case (nil, _):
      return nil
    }
  })
}
@inlinable public func sequence<T, State>(state: State, next: @escaping (inout State) -> T?) -> Swift.UnfoldSequence<T, State> {
  return UnfoldSequence(_state: state, _next: next)
}
public typealias UnfoldFirstSequence<T> = Swift.UnfoldSequence<T, (T?, Swift.Bool)>
@frozen public struct UnfoldSequence<Element, State> : Swift.Sequence, Swift.IteratorProtocol {
  @inlinable public mutating func next() -> Element? {
    guard !_done else { return nil }
    if let elt = _next(&_state) {
        return elt
    } else {
        _done = true
        return nil
    }
  }
  @inlinable internal init(_state: State, _next: @escaping (inout State) -> Element?) {
    self._state = _state
    self._next = _next
  }
  @usableFromInline
  internal var _state: State
  @usableFromInline
  internal let _next: (inout State) -> Element?
  @usableFromInline
  internal var _done: Swift.Bool = false
  public typealias Iterator = Swift.UnfoldSequence<Element, State>
}
public protocol CVarArg {
  var _cVarArgEncoding: [Swift.Int] { get }
}
public protocol _CVarArgPassedAsDouble : Swift.CVarArg {
}
public protocol _CVarArgAligned : Swift.CVarArg {
  var _cVarArgAlignment: Swift.Int { get }
}
@usableFromInline
internal let _countGPRegisters: Swift.Int
@usableFromInline
internal let _countFPRegisters: Swift.Int
@usableFromInline
internal let _fpRegisterWords: Swift.Int
@usableFromInline
internal let _registerSaveWords: Swift.Int
@usableFromInline
internal typealias _VAUInt = Swift.CUnsignedInt
@usableFromInline
internal typealias _VAInt = Swift.Int32
@inlinable public func withVaList<R>(_ args: [Swift.CVarArg], _ body: (Swift.CVaListPointer) -> R) -> R {
  let builder = __VaListBuilder()
  for a in args {
    builder.append(a)
  }
  return _withVaList(builder, body)
}
@inlinable internal func _withVaList<R>(_ builder: Swift.__VaListBuilder, _ body: (Swift.CVaListPointer) -> R) -> R {
  let result = body(builder.va_list())
  _fixLifetime(builder)
  return result
}
@inlinable public func getVaList(_ args: [Swift.CVarArg]) -> Swift.CVaListPointer {
  let builder = __VaListBuilder()
  for a in args {
    builder.append(a)
  }
  // FIXME: Use some Swift equivalent of NS_RETURNS_INNER_POINTER if we get one.
  Builtin.retain(builder)
  Builtin.autorelease(builder)
  return builder.va_list()
}
@inlinable public func _encodeBitsAsWords<T>(_ x: T) -> [Swift.Int] {
  let result = [Int](
    repeating: 0,
    count: (MemoryLayout<T>.size + MemoryLayout<Int>.size - 1) / MemoryLayout<Int>.size)
  _internalInvariant(!result.isEmpty)
  var tmp = x
  // FIXME: use UnsafeMutablePointer.assign(from:) instead of memcpy.
  _memcpy(dest: UnsafeMutablePointer(result._baseAddressIfContiguous!),
          src: UnsafeMutablePointer(Builtin.addressof(&tmp)),
          size: UInt(MemoryLayout<T>.size))
  return result
}
extension Int : Swift.CVarArg {
  @inlinable public var _cVarArgEncoding: [Swift.Int] {
    get {
    return _encodeBitsAsWords(self)
  }
  }
}
extension Bool : Swift.CVarArg {
  public var _cVarArgEncoding: [Swift.Int] {
    get
  }
}
extension Int64 : Swift.CVarArg, Swift._CVarArgAligned {
  @inlinable public var _cVarArgEncoding: [Swift.Int] {
    get {
    return _encodeBitsAsWords(self)
  }
  }
  @inlinable public var _cVarArgAlignment: Swift.Int {
    get {
    // FIXME: alignof differs from the ABI alignment on some architectures
    return MemoryLayout.alignment(ofValue: self)
  }
  }
}
extension Int32 : Swift.CVarArg {
  @inlinable public var _cVarArgEncoding: [Swift.Int] {
    get {
    return _encodeBitsAsWords(_VAInt(self))
  }
  }
}
extension Int16 : Swift.CVarArg {
  @inlinable public var _cVarArgEncoding: [Swift.Int] {
    get {
    return _encodeBitsAsWords(_VAInt(self))
  }
  }
}
extension Int8 : Swift.CVarArg {
  @inlinable public var _cVarArgEncoding: [Swift.Int] {
    get {
    return _encodeBitsAsWords(_VAInt(self))
  }
  }
}
extension UInt : Swift.CVarArg {
  @inlinable public var _cVarArgEncoding: [Swift.Int] {
    get {
    return _encodeBitsAsWords(self)
  }
  }
}
extension UInt64 : Swift.CVarArg, Swift._CVarArgAligned {
  @inlinable public var _cVarArgEncoding: [Swift.Int] {
    get {
    return _encodeBitsAsWords(self)
  }
  }
  @inlinable public var _cVarArgAlignment: Swift.Int {
    get {
    // FIXME: alignof differs from the ABI alignment on some architectures
    return MemoryLayout.alignment(ofValue: self)
  }
  }
}
extension UInt32 : Swift.CVarArg {
  @inlinable public var _cVarArgEncoding: [Swift.Int] {
    get {
    return _encodeBitsAsWords(_VAUInt(self))
  }
  }
}
extension UInt16 : Swift.CVarArg {
  @inlinable public var _cVarArgEncoding: [Swift.Int] {
    get {
    return _encodeBitsAsWords(_VAUInt(self))
  }
  }
}
extension UInt8 : Swift.CVarArg {
  @inlinable public var _cVarArgEncoding: [Swift.Int] {
    get {
    return _encodeBitsAsWords(_VAUInt(self))
  }
  }
}
extension OpaquePointer : Swift.CVarArg {
  @inlinable public var _cVarArgEncoding: [Swift.Int] {
    get {
    return _encodeBitsAsWords(self)
  }
  }
}
extension UnsafePointer : Swift.CVarArg {
  @inlinable public var _cVarArgEncoding: [Swift.Int] {
    get {
    return _encodeBitsAsWords(self)
  }
  }
}
extension UnsafeMutablePointer : Swift.CVarArg {
  @inlinable public var _cVarArgEncoding: [Swift.Int] {
    get {
    return _encodeBitsAsWords(self)
  }
  }
}
extension AutoreleasingUnsafeMutablePointer : Swift.CVarArg {
  @inlinable public var _cVarArgEncoding: [Swift.Int] {
    get {
    return _encodeBitsAsWords(self)
  }
  }
}
extension Float : Swift._CVarArgPassedAsDouble, Swift._CVarArgAligned {
  @inlinable public var _cVarArgEncoding: [Swift.Int] {
    get {
    return _encodeBitsAsWords(Double(self))
  }
  }
  @inlinable public var _cVarArgAlignment: Swift.Int {
    get {
    // FIXME: alignof differs from the ABI alignment on some architectures
    return MemoryLayout.alignment(ofValue: Double(self))
  }
  }
}
extension Double : Swift._CVarArgPassedAsDouble, Swift._CVarArgAligned {
  @inlinable public var _cVarArgEncoding: [Swift.Int] {
    get {
    return _encodeBitsAsWords(self)
  }
  }
  @inlinable public var _cVarArgAlignment: Swift.Int {
    get {
    // FIXME: alignof differs from the ABI alignment on some architectures
    return MemoryLayout.alignment(ofValue: self)
  }
  }
}
extension Float80 : Swift.CVarArg, Swift._CVarArgAligned {
  @inlinable public var _cVarArgEncoding: [Swift.Int] {
    get {
    return _encodeBitsAsWords(self)
  }
  }
  @inlinable public var _cVarArgAlignment: Swift.Int {
    get {
    // FIXME: alignof differs from the ABI alignment on some architectures
    return MemoryLayout.alignment(ofValue: self)
  }
  }
}
@usableFromInline
@_fixed_layout final internal class __VaListBuilder {
  @usableFromInline
  @frozen internal struct Header {
    @inlinable internal init() {}
    @usableFromInline
    internal var gp_offset: Swift.CUnsignedInt = CUnsignedInt(0)
    @usableFromInline
    internal var fp_offset: Swift.CUnsignedInt = CUnsignedInt(_countGPRegisters * MemoryLayout<Int>.stride)
    @usableFromInline
    internal var overflow_arg_area: Swift.UnsafeMutablePointer<Swift.Int>?
    @usableFromInline
    internal var reg_save_area: Swift.UnsafeMutablePointer<Swift.Int>?
  }
  @usableFromInline
  final internal var gpRegistersUsed: Swift.Int = 0
  @usableFromInline
  final internal var fpRegistersUsed: Swift.Int = 0
  @usableFromInline
  final internal var header: Swift.__VaListBuilder.Header = Header()
  @usableFromInline
  final internal var storage: Swift.ContiguousArray<Swift.Int>
  @inlinable internal init() {
    // prepare the register save area
    storage = ContiguousArray(repeating: 0, count: _registerSaveWords)
  }
  @objc @inlinable deinit {}
  @inlinable final internal func append(_ arg: Swift.CVarArg) {

    var encoded = arg._cVarArgEncoding

    let isDouble = arg is _CVarArgPassedAsDouble

    if isDouble && fpRegistersUsed < _countFPRegisters {
        var startIndex = _countGPRegisters
             + (fpRegistersUsed * _fpRegisterWords)
      for w in encoded {
        storage[startIndex] = w
        startIndex += 1
      }
      fpRegistersUsed += 1
    }
    else if encoded.count == 1
      && !isDouble
      && gpRegistersUsed < _countGPRegisters {
        let startIndex = gpRegistersUsed
      storage[startIndex] = encoded[0]
      gpRegistersUsed += 1
    }
    else {
      for w in encoded {
        storage.append(w)
      }
    }

  }
  @inlinable final internal func va_list() -> Swift.CVaListPointer {
      header.reg_save_area = storage._baseAddress
      header.overflow_arg_area
        = storage._baseAddress + _registerSaveWords
      return CVaListPointer(
               _fromUnsafeMutablePointer: UnsafeMutableRawPointer(
                 Builtin.addressof(&self.header)))
  }
}
@inlinable public func zip<Sequence1, Sequence2>(_ sequence1: Sequence1, _ sequence2: Sequence2) -> Swift.Zip2Sequence<Sequence1, Sequence2> where Sequence1 : Swift.Sequence, Sequence2 : Swift.Sequence {
  return Zip2Sequence(sequence1, sequence2)
}
@frozen public struct Zip2Sequence<Sequence1, Sequence2> where Sequence1 : Swift.Sequence, Sequence2 : Swift.Sequence {
  @usableFromInline
  internal let _sequence1: Sequence1
  @usableFromInline
  internal let _sequence2: Sequence2
  @inlinable internal init(_ sequence1: Sequence1, _ sequence2: Sequence2) {
    (_sequence1, _sequence2) = (sequence1, sequence2)
  }
}
extension Zip2Sequence {
  @frozen public struct Iterator {
    @usableFromInline
    internal var _baseStream1: Sequence1.Iterator
    @usableFromInline
    internal var _baseStream2: Sequence2.Iterator
    @usableFromInline
    internal var _reachedEnd: Swift.Bool = false
    @inlinable internal init(_ iterator1: Sequence1.Iterator, _ iterator2: Sequence2.Iterator) {
      (_baseStream1, _baseStream2) = (iterator1, iterator2)
    }
  }
}
extension Zip2Sequence.Iterator : Swift.IteratorProtocol {
  public typealias Element = (Sequence1.Element, Sequence2.Element)
  @inlinable public mutating func next() -> Swift.Zip2Sequence<Sequence1, Sequence2>.Iterator.Element? {
    // The next() function needs to track if it has reached the end.  If we
    // didn't, and the first sequence is longer than the second, then when we
    // have already exhausted the second sequence, on every subsequent call to
    // next() we would consume and discard one additional element from the
    // first sequence, even though next() had already returned nil.

    if _reachedEnd {
      return nil
    }

    guard let element1 = _baseStream1.next(),
          let element2 = _baseStream2.next() else {
      _reachedEnd = true
      return nil
    }

    return (element1, element2)
  }
}
extension Zip2Sequence : Swift.Sequence {
  public typealias Element = (Sequence1.Element, Sequence2.Element)
  @inlinable __consuming public func makeIterator() -> Swift.Zip2Sequence<Sequence1, Sequence2>.Iterator {
    return Iterator(
      _sequence1.makeIterator(),
      _sequence2.makeIterator())
  }
  @inlinable public var underestimatedCount: Swift.Int {
    get {
    return Swift.min(
      _sequence1.underestimatedCount,
      _sequence2.underestimatedCount
    )
  }
  }
}
@available(swift, deprecated: 4.2, obsoleted: 5.0)
@_objcRuntimeName(_TtCs18__stdlib_AtomicInt) final public class _stdlib_AtomicInt {
  public init(_ value: Swift.Int = 0)
  final public func store(_ desired: Swift.Int)
  final public func load() -> Swift.Int
  @discardableResult
  final public func fetchAndAdd(_ operand: Swift.Int) -> Swift.Int
  final public func addAndFetch(_ operand: Swift.Int) -> Swift.Int
  @discardableResult
  final public func fetchAndAnd(_ operand: Swift.Int) -> Swift.Int
  final public func andAndFetch(_ operand: Swift.Int) -> Swift.Int
  @discardableResult
  final public func fetchAndOr(_ operand: Swift.Int) -> Swift.Int
  final public func orAndFetch(_ operand: Swift.Int) -> Swift.Int
  @discardableResult
  final public func fetchAndXor(_ operand: Swift.Int) -> Swift.Int
  final public func xorAndFetch(_ operand: Swift.Int) -> Swift.Int
  final public func compareExchange(expected: inout Swift.Int, desired: Swift.Int) -> Swift.Bool
  @objc deinit
}
@usableFromInline
internal func _swift_stdlib_atomicCompareExchangeStrongInt(object target: Swift.UnsafeMutablePointer<Swift.Int>, expected: Swift.UnsafeMutablePointer<Swift.Int>, desired: Swift.Int) -> Swift.Bool
public func _swift_stdlib_atomicLoadInt(object target: Swift.UnsafeMutablePointer<Swift.Int>) -> Swift.Int
@usableFromInline
internal func _swift_stdlib_atomicStoreInt(object target: Swift.UnsafeMutablePointer<Swift.Int>, desired: Swift.Int)
public func _swift_stdlib_atomicFetchAddInt(object target: Swift.UnsafeMutablePointer<Swift.Int>, operand: Swift.Int) -> Swift.Int
@usableFromInline
internal func _swift_stdlib_atomicFetchAddInt32(object target: Swift.UnsafeMutablePointer<Swift.Int32>, operand: Swift.Int32) -> Swift.Int32
@usableFromInline
internal func _swift_stdlib_atomicFetchAddInt64(object target: Swift.UnsafeMutablePointer<Swift.Int64>, operand: Swift.Int64) -> Swift.Int64
public func _swift_stdlib_atomicFetchAndInt(object target: Swift.UnsafeMutablePointer<Swift.Int>, operand: Swift.Int) -> Swift.Int
@usableFromInline
internal func _swift_stdlib_atomicFetchAndInt32(object target: Swift.UnsafeMutablePointer<Swift.Int32>, operand: Swift.Int32) -> Swift.Int32
@usableFromInline
internal func _swift_stdlib_atomicFetchAndInt64(object target: Swift.UnsafeMutablePointer<Swift.Int64>, operand: Swift.Int64) -> Swift.Int64
public func _swift_stdlib_atomicFetchOrInt(object target: Swift.UnsafeMutablePointer<Swift.Int>, operand: Swift.Int) -> Swift.Int
@usableFromInline
internal func _swift_stdlib_atomicFetchOrInt32(object target: Swift.UnsafeMutablePointer<Swift.Int32>, operand: Swift.Int32) -> Swift.Int32
@usableFromInline
internal func _swift_stdlib_atomicFetchOrInt64(object target: Swift.UnsafeMutablePointer<Swift.Int64>, operand: Swift.Int64) -> Swift.Int64
public func _swift_stdlib_atomicFetchXorInt(object target: Swift.UnsafeMutablePointer<Swift.Int>, operand: Swift.Int) -> Swift.Int
@usableFromInline
internal func _swift_stdlib_atomicFetchXorInt32(object target: Swift.UnsafeMutablePointer<Swift.Int32>, operand: Swift.Int32) -> Swift.Int32
@usableFromInline
internal func _swift_stdlib_atomicFetchXorInt64(object target: Swift.UnsafeMutablePointer<Swift.Int64>, operand: Swift.Int64) -> Swift.Int64
@inlinable internal func _isspace_clocale(_ u: Swift.UTF16.CodeUnit) -> Swift.Bool {
  return "\t\n\u{b}\u{c}\r ".utf16.contains(u)
}
extension Float : Swift.LosslessStringConvertible {
  @inlinable public init?<S>(_ text: S) where S : Swift.StringProtocol {
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/FloatingPointParsing.swift.gyb", line: 138)
// TODO: Uncomment this someday when availability guards actually work...
//    if #available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *) {
//      self.init(Substring(text))
//    } else
//    {
      self = 0.0
      let success = withUnsafeMutablePointer(to: &self) { p -> Bool in
        text.withCString { chars -> Bool in
          switch chars[0] {
          case 9, 10, 11, 12, 13, 32:
            return false // Reject leading whitespace
          case 0:
            return false // Reject empty string
          default:
            break
          }
          let endPtr = _swift_stdlib_strtof_clocale(chars, p)
          // Succeed only if endPtr points to end of C string
          return endPtr != nil && endPtr![0] == 0
        }
      }
      if !success {
        return nil
      }
//    }
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/FloatingPointParsing.swift.gyb", line: 164)
  }
  @available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
  public init?(_ text: Swift.Substring)
}
extension Double : Swift.LosslessStringConvertible {
  @inlinable public init?<S>(_ text: S) where S : Swift.StringProtocol {
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/FloatingPointParsing.swift.gyb", line: 138)
// TODO: Uncomment this someday when availability guards actually work...
//    if #available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *) {
//      self.init(Substring(text))
//    } else
//    {
      self = 0.0
      let success = withUnsafeMutablePointer(to: &self) { p -> Bool in
        text.withCString { chars -> Bool in
          switch chars[0] {
          case 9, 10, 11, 12, 13, 32:
            return false // Reject leading whitespace
          case 0:
            return false // Reject empty string
          default:
            break
          }
          let endPtr = _swift_stdlib_strtod_clocale(chars, p)
          // Succeed only if endPtr points to end of C string
          return endPtr != nil && endPtr![0] == 0
        }
      }
      if !success {
        return nil
      }
//    }
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/FloatingPointParsing.swift.gyb", line: 164)
  }
  @available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
  public init?(_ text: Swift.Substring)
}
extension Float80 : Swift.LosslessStringConvertible {
  @inlinable public init?<S>(_ text: S) where S : Swift.StringProtocol {
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/FloatingPointParsing.swift.gyb", line: 138)
// TODO: Uncomment this someday when availability guards actually work...
//    if #available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *) {
//      self.init(Substring(text))
//    } else
//    {
      self = 0.0
      let success = withUnsafeMutablePointer(to: &self) { p -> Bool in
        text.withCString { chars -> Bool in
          switch chars[0] {
          case 9, 10, 11, 12, 13, 32:
            return false // Reject leading whitespace
          case 0:
            return false // Reject empty string
          default:
            break
          }
          let endPtr = _swift_stdlib_strtold_clocale(chars, p)
          // Succeed only if endPtr points to end of C string
          return endPtr != nil && endPtr![0] == 0
        }
      }
      if !success {
        return nil
      }
//    }
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/FloatingPointParsing.swift.gyb", line: 164)
  }
  @available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
  public init?(_ text: Swift.Substring)
}
@available(macOS 11, iOS 14, tvOS 14, watchOS 7, *)
@available(macOS, unavailable)
@available(macCatalyst, unavailable)
@frozen public struct Float16 {
  @_transparent public init() {
    fatalError("Float16 is not available")
  }
}
@frozen public struct Float {
  public var _value: Builtin.FPIEEE32
  @_transparent public init() {
    let zero: Int64 = 0
    self._value = Builtin.sitofp_Int64_FPIEEE32(zero._value)
  }
  @_transparent public init(_ _value: Builtin.FPIEEE32) {
    self._value = _value
  }
}
extension Float : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
extension Float : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
extension Float : Swift.TextOutputStreamable {
  public func write<Target>(to target: inout Target) where Target : Swift.TextOutputStream
}
extension Float : Swift.BinaryFloatingPoint {
  public typealias Magnitude = Swift.Float
  public typealias Exponent = Swift.Int
  public typealias RawSignificand = Swift.UInt32
  @inlinable public static var exponentBitCount: Swift.Int {
    get {
    return 8
  }
  }
  @inlinable public static var significandBitCount: Swift.Int {
    get {
    return 23
  }
  }
  @inlinable internal static var _infinityExponent: Swift.UInt {
    @inline(__always) get { return 1 &<< UInt(exponentBitCount) - 1 }
  }
  @inlinable internal static var _exponentBias: Swift.UInt {
    @inline(__always) get { return _infinityExponent &>> 1 }
  }
  @inlinable internal static var _significandMask: Swift.UInt32 {
    @inline(__always) get {
      return 1 &<< UInt32(significandBitCount) - 1
    }
  }
  @inlinable internal static var _quietNaNMask: Swift.UInt32 {
    @inline(__always) get {
      return 1 &<< UInt32(significandBitCount - 1)
    }
  }
  @inlinable public var bitPattern: Swift.UInt32 {
    get {
    return UInt32(Builtin.bitcast_FPIEEE32_Int32(_value))
  }
  }
  @inlinable public init(bitPattern: Swift.UInt32) {
    self.init(Builtin.bitcast_Int32_FPIEEE32(bitPattern._value))
  }
  @inlinable public var sign: Swift.FloatingPointSign {
    get {
    let shift = Float.significandBitCount + Float.exponentBitCount
    return FloatingPointSign(
      rawValue: Int(bitPattern &>> UInt32(shift))
    )!
  }
  }
  @available(*, unavailable, renamed: "sign")
  public var isSignMinus: Swift.Bool {
    get
  }
  @inlinable public var exponentBitPattern: Swift.UInt {
    get {
    return UInt(bitPattern &>> UInt32(Float.significandBitCount)) &
      Float._infinityExponent
  }
  }
  @inlinable public var significandBitPattern: Swift.UInt32 {
    get {
    return UInt32(bitPattern) & Float._significandMask
  }
  }
  @inlinable public init(sign: Swift.FloatingPointSign, exponentBitPattern: Swift.UInt, significandBitPattern: Swift.UInt32) {
    let signShift = Float.significandBitCount + Float.exponentBitCount
    let sign = UInt32(sign == .minus ? 1 : 0)
    let exponent = UInt32(
      exponentBitPattern & Float._infinityExponent
    )
    let significand = UInt32(
      significandBitPattern & Float._significandMask
    )
    self.init(bitPattern:
      sign &<< UInt32(signShift) |
      exponent &<< UInt32(Float.significandBitCount) |
      significand
    )
  }
  @inlinable public var isCanonical: Swift.Bool {
    get {
    // All Float and Double encodings are canonical in IEEE 754.
    //
    // On platforms that do not support subnormals, we treat them as
    // non-canonical encodings of zero.
    if Self.leastNonzeroMagnitude == Self.leastNormalMagnitude {
      if exponentBitPattern == 0 && significandBitPattern != 0 {
        return false
      }
    }
    return true
  }
  }
  @inlinable public static var infinity: Swift.Float {
    get {
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/FloatingPointTypes.swift.gyb", line: 389)
    return Float(bitPattern: 0x7f800000)
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/FloatingPointTypes.swift.gyb", line: 405)
  }
  }
  @inlinable public static var nan: Swift.Float {
    get {
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/FloatingPointTypes.swift.gyb", line: 410)
    return Float(bitPattern: 0x7fc00000)
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/FloatingPointTypes.swift.gyb", line: 422)
  }
  }
  @inlinable public static var signalingNaN: Swift.Float {
    get {
    return Float(nan: 0, signaling: true)
  }
  }
  @available(*, unavailable, renamed: "nan")
  public static var quietNaN: Swift.Float {
    get
  }
  @inlinable public static var greatestFiniteMagnitude: Swift.Float {
    get {
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/FloatingPointTypes.swift.gyb", line: 435)
    return 0x1.fffffep127
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/FloatingPointTypes.swift.gyb", line: 447)
  }
  }
  @inlinable public static var pi: Swift.Float {
    get {
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/FloatingPointTypes.swift.gyb", line: 454)
    // Note: this is not the correctly rounded (to nearest) value of pi,
    // because pi would round *up* in Float precision, which can result
    // in angles in the wrong quadrant if users aren't careful.  This is
    // not a problem for Double or Float80, as pi rounds down in both of
    // those formats.
    return 0x1.921fb4p1
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/FloatingPointTypes.swift.gyb", line: 465)
  }
  }
  @inlinable public var ulp: Swift.Float {
    get {
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/FloatingPointTypes.swift.gyb", line: 470)
    guard _fastPath(isFinite) else { return .nan }
    if _fastPath(isNormal) {
      let bitPattern_ = bitPattern & Float.infinity.bitPattern
      return Float(bitPattern: bitPattern_) * 0x1p-23
    }
    // On arm, flush subnormal values to 0.
    return .leastNormalMagnitude * 0x1p-23
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/FloatingPointTypes.swift.gyb", line: 505)
  }
  }
  @inlinable public static var leastNormalMagnitude: Swift.Float {
    get {
    return 0x1.0p-126
  }
  }
  @inlinable public static var leastNonzeroMagnitude: Swift.Float {
    get {
    return leastNormalMagnitude * ulpOfOne
  }
  }
  @inlinable public static var ulpOfOne: Swift.Float {
    get {
    return 0x1.0p-23
  }
  }
  @inlinable public var exponent: Swift.Int {
    get {
    if !isFinite { return .max }
    if isZero { return .min }
    let provisional = Int(exponentBitPattern) - Int(Float._exponentBias)
    if isNormal { return provisional }
    let shift =
      Float.significandBitCount - significandBitPattern._binaryLogarithm()
    return provisional + 1 - shift
  }
  }
  @inlinable public var significand: Swift.Float {
    get {
    if isNaN { return self }
    if isNormal {
      return Float(sign: .plus,
        exponentBitPattern: Float._exponentBias,
        significandBitPattern: significandBitPattern)
    }
    if isSubnormal {
      let shift =
        Float.significandBitCount - significandBitPattern._binaryLogarithm()
      return Float(
        sign: .plus,
        exponentBitPattern: Float._exponentBias,
        significandBitPattern: significandBitPattern &<< shift
      )
    }
    // zero or infinity.
    return Float(
      sign: .plus,
      exponentBitPattern: exponentBitPattern,
      significandBitPattern: 0
    )
  }
  }
  @inlinable public init(sign: Swift.FloatingPointSign, exponent: Swift.Int, significand: Swift.Float) {
    var result = significand
    if sign == .minus { result = -result }
    if significand.isFinite && !significand.isZero {
      var clamped = exponent
      let leastNormalExponent = 1 - Int(Float._exponentBias)
      let greatestFiniteExponent = Int(Float._exponentBias)
      if clamped < leastNormalExponent {
        clamped = max(clamped, 3*leastNormalExponent)
        while clamped < leastNormalExponent {
          result  *= Float.leastNormalMagnitude
          clamped -= leastNormalExponent
        }
      }
      else if clamped > greatestFiniteExponent {
        clamped = min(clamped, 3*greatestFiniteExponent)
        let step = Float(sign: .plus,
          exponentBitPattern: Float._infinityExponent - 1,
          significandBitPattern: 0)
        while clamped > greatestFiniteExponent {
          result  *= step
          clamped -= greatestFiniteExponent
        }
      }
      let scale = Float(
        sign: .plus,
        exponentBitPattern: UInt(Int(Float._exponentBias) + clamped),
        significandBitPattern: 0
      )
      result = result * scale
    }
    self = result
  }
  @inlinable public init(nan payload: Swift.Float.RawSignificand, signaling: Swift.Bool) {
    // We use significandBitCount - 2 bits for NaN payload.
    _precondition(payload < (Float._quietNaNMask &>> 1),
      "NaN payload is not encodable.")
    var significand = payload
    significand |= Float._quietNaNMask &>> (signaling ? 1 : 0)
    self.init(
      sign: .plus,
      exponentBitPattern: Float._infinityExponent,
      significandBitPattern: significand
    )
  }
  @inlinable public var nextUp: Swift.Float {
    get {
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/FloatingPointTypes.swift.gyb", line: 637)
    // Silence signaling NaNs, map -0 to +0.
    let x = self + 0
    if _fastPath(x < .infinity) {
      let increment = Int32(bitPattern: x.bitPattern) &>> 31 | 1
      let bitPattern_ = x.bitPattern &+ UInt32(bitPattern: increment)
      return Float(bitPattern: bitPattern_)
    }
    return x
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/FloatingPointTypes.swift.gyb", line: 675)
  }
  }
  @_transparent public init(signOf sign: Swift.Float, magnitudeOf mag: Swift.Float) {
    _value = Builtin.int_copysign_FPIEEE32(mag._value, sign._value)
  }
  @_transparent public mutating func round(_ rule: Swift.FloatingPointRoundingRule) {
    switch rule {
    case .toNearestOrAwayFromZero:
      _value = Builtin.int_round_FPIEEE32(_value)
    case .toNearestOrEven:
      _value = Builtin.int_rint_FPIEEE32(_value)
    case .towardZero:
      _value = Builtin.int_trunc_FPIEEE32(_value)
    case .awayFromZero:
      if sign == .minus {
        _value = Builtin.int_floor_FPIEEE32(_value)
      }
      else {
        _value = Builtin.int_ceil_FPIEEE32(_value)
      }
    case .up:
      _value = Builtin.int_ceil_FPIEEE32(_value)
    case .down:
      _value = Builtin.int_floor_FPIEEE32(_value)
    @unknown default:
      self._roundSlowPath(rule)
    }
  }
  @usableFromInline
  internal mutating func _roundSlowPath(_ rule: Swift.FloatingPointRoundingRule)
  @_transparent public mutating func negate() {
    _value = Builtin.fneg_FPIEEE32(self._value)
  }
  @_transparent public static func += (lhs: inout Swift.Float, rhs: Swift.Float) {
    lhs._value = Builtin.fadd_FPIEEE32(lhs._value, rhs._value)
  }
  @_transparent public static func -= (lhs: inout Swift.Float, rhs: Swift.Float) {
    lhs._value = Builtin.fsub_FPIEEE32(lhs._value, rhs._value)
  }
  @_transparent public static func *= (lhs: inout Swift.Float, rhs: Swift.Float) {
    lhs._value = Builtin.fmul_FPIEEE32(lhs._value, rhs._value)
  }
  @_transparent public static func /= (lhs: inout Swift.Float, rhs: Swift.Float) {
    lhs._value = Builtin.fdiv_FPIEEE32(lhs._value, rhs._value)
  }
  @inlinable @inline(__always) public mutating func formRemainder(dividingBy other: Swift.Float) {
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/FloatingPointTypes.swift.gyb", line: 751)
    self = _stdlib_remainderf(self, other)
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/FloatingPointTypes.swift.gyb", line: 753)
  }
  @inlinable @inline(__always) public mutating func formTruncatingRemainder(dividingBy other: Swift.Float) {
    _value = Builtin.frem_FPIEEE32(self._value, other._value)
  }
  @_transparent public mutating func formSquareRoot() {
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/FloatingPointTypes.swift.gyb", line: 766)
    self = _stdlib_squareRootf(self)
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/FloatingPointTypes.swift.gyb", line: 768)
  }
  @_transparent public mutating func addProduct(_ lhs: Swift.Float, _ rhs: Swift.Float) {
    _value = Builtin.int_fma_FPIEEE32(lhs._value, rhs._value, _value)
  }
  @_transparent public func isEqual(to other: Swift.Float) -> Swift.Bool {
    return Bool(Builtin.fcmp_oeq_FPIEEE32(self._value, other._value))
  }
  @_transparent public func isLess(than other: Swift.Float) -> Swift.Bool {
    return Bool(Builtin.fcmp_olt_FPIEEE32(self._value, other._value))
  }
  @_transparent public func isLessThanOrEqualTo(_ other: Swift.Float) -> Swift.Bool {
    return Bool(Builtin.fcmp_ole_FPIEEE32(self._value, other._value))
  }
  @inlinable public var isNormal: Swift.Bool {
    @inline(__always) get {
      return exponentBitPattern > 0 && isFinite
    }
  }
  @inlinable public var isFinite: Swift.Bool {
    @inline(__always) get {
      return exponentBitPattern < Float._infinityExponent
    }
  }
  @inlinable public var isZero: Swift.Bool {
    @inline(__always) get {
      return exponentBitPattern == 0 && significandBitPattern == 0
    }
  }
  @inlinable public var isSubnormal: Swift.Bool {
    @inline(__always) get {
      return exponentBitPattern == 0 && significandBitPattern != 0
    }
  }
  @inlinable public var isInfinite: Swift.Bool {
    @inline(__always) get {
      return !isFinite && significandBitPattern == 0
    }
  }
  @inlinable public var isNaN: Swift.Bool {
    @inline(__always) get {
      return !isFinite && significandBitPattern != 0
    }
  }
  @inlinable public var isSignalingNaN: Swift.Bool {
    @inline(__always) get {
      return isNaN && (significandBitPattern & Float._quietNaNMask) == 0
    }
  }
  @inlinable public var binade: Swift.Float {
    get {
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/FloatingPointTypes.swift.gyb", line: 849)
    guard _fastPath(isFinite) else { return .nan }
    if _slowPath(isSubnormal) {
      let bitPattern_ =
        (self * 0x1p23).bitPattern
          & (-Float.infinity).bitPattern
      return Float(bitPattern: bitPattern_) * 0x1p-23
    }
    return Float(bitPattern: bitPattern & (-Float.infinity).bitPattern)
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/FloatingPointTypes.swift.gyb", line: 871)
  }
  }
  @inlinable public var significandWidth: Swift.Int {
    get {
    let trailingZeroBits = significandBitPattern.trailingZeroBitCount
    if isNormal {
      guard significandBitPattern != 0 else { return 0 }
      return Float.significandBitCount &- trailingZeroBits
    }
    if isSubnormal {
      let leadingZeroBits = significandBitPattern.leadingZeroBitCount
      return UInt32.bitWidth &- (trailingZeroBits &+ leadingZeroBits &+ 1)
    }
    return -1
  }
  }
  @inlinable @inline(__always) public init(floatLiteral value: Swift.Float) {
    self = value
  }
  public typealias FloatLiteralType = Swift.Float
  public typealias RawExponent = Swift.UInt
}
extension Float : Swift._ExpressibleByBuiltinIntegerLiteral, Swift.ExpressibleByIntegerLiteral {
  @_transparent public init(_builtinIntegerLiteral value: Builtin.IntLiteral) {
    self = Float(Builtin.itofp_with_overflow_IntLiteral_FPIEEE32(value))
  }
  @_transparent public init(integerLiteral value: Swift.Int64) {
    self = Float(Builtin.sitofp_Int64_FPIEEE32(value._value))
  }
  public typealias IntegerLiteralType = Swift.Int64
}
extension Float : Swift._ExpressibleByBuiltinFloatLiteral {
  @_transparent public init(_builtinFloatLiteral value: Builtin.FPIEEE80) {
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/FloatingPointTypes.swift.gyb", line: 924)
    self = Float(Builtin.fptrunc_FPIEEE80_FPIEEE32(value))
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/FloatingPointTypes.swift.gyb", line: 929)
  }
}
extension Float : Swift.Hashable {
  @inlinable public func hash(into hasher: inout Swift.Hasher) {
    var v = self
    if isZero {
      // To satisfy the axiom that equality implies hash equality, we need to
      // finesse the hash value of -0.0 to match +0.0.
      v = 0
    }
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/FloatingPointTypes.swift.gyb", line: 970)
    hasher.combine(v.bitPattern)
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/FloatingPointTypes.swift.gyb", line: 972)
  }
  @inlinable public func _rawHashValue(seed: Swift.Int) -> Swift.Int {
    // To satisfy the axiom that equality implies hash equality, we need to
    // finesse the hash value of -0.0 to match +0.0.
    let v = isZero ? 0 : self
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/FloatingPointTypes.swift.gyb", line: 987)
    return Hasher._hash(seed: seed, bytes: UInt64(v.bitPattern), count: 4)
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/FloatingPointTypes.swift.gyb", line: 991)
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension Float : Swift._HasCustomAnyHashableRepresentation {
  public func _toCustomAnyHashable() -> Swift.AnyHashable?
}
extension Float {
  @inlinable public var magnitude: Swift.Float {
    @inline(__always) get {
      return Float(Builtin.int_fabs_FPIEEE32(_value))
    }
  }
}
extension Float {
  @_transparent prefix public static func - (x: Swift.Float) -> Swift.Float {
    return Float(Builtin.fneg_FPIEEE32(x._value))
  }
}
extension Float {
  @_transparent public init(_ v: Swift.Int) {
    _value = Builtin.sitofp_Int64_FPIEEE32(v._value)
  }
  @inlinable @inline(__always) public init<Source>(_ value: Source) where Source : Swift.BinaryInteger {
    if value.bitWidth <= 64 {
      if Source.isSigned {
        let asInt = Int(truncatingIfNeeded: value)
        _value = Builtin.sitofp_Int64_FPIEEE32(asInt._value)
      } else {
        let asUInt = UInt(truncatingIfNeeded: value)
        _value = Builtin.uitofp_Int64_FPIEEE32(asUInt._value)
      }
    } else {
      // TODO: we can do much better than the generic _convert here for Float
      // and Double by pulling out the high-order 32/64b of the integer, ORing
      // in a sticky bit, and then using the builtin.
      self = Float._convert(from: value).value
    }
  }
  @_alwaysEmitIntoClient @inline(never) public init?<Source>(exactly value: Source) where Source : Swift.BinaryInteger {
    if value.bitWidth <= 64 {
      // If the source is small enough to fit in a word, we can use the LLVM
      // conversion intrinsic, then check if we can round-trip back to the
      // the original value; if so, the conversion was exact. We need to be
      // careful, however, to make sure that the first conversion does not
      // round to a value that is out of the defined range of the second
      // converion. E.g. Float(Int.max) rounds to Int.max + 1, and converting
      // that back to Int will trap. For Float, Double, and Float80, this is
      // only an issue for the upper bound (because the lower bound of [U]Int
      // is either zero or a power of two, both of which are exactly
      // representable). For Float16, we also need to check for overflow to
      // -.infinity.
      if Source.isSigned {
        let extended = Int(truncatingIfNeeded: value)
        _value = Builtin.sitofp_Int64_FPIEEE32(extended._value)
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/FloatingPointTypes.swift.gyb", line: 1082)
        guard self < 0x1.0p63 && Int(self) == extended else {
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/FloatingPointTypes.swift.gyb", line: 1084)
          return nil
        }
      } else {
        let extended = UInt(truncatingIfNeeded: value)
        _value = Builtin.uitofp_Int64_FPIEEE32(extended._value)
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/FloatingPointTypes.swift.gyb", line: 1092)
        guard self < 0x1.0p64 && UInt(self) == extended else {
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/FloatingPointTypes.swift.gyb", line: 1094)
          return nil
        }
      }
    } else {
      // TODO: we can do much better than the generic _convert here for Float
      // and Double by pulling out the high-order 32/64b of the integer, ORing
      // in a sticky bit, and then using the builtin.
      let (value_, exact) = Self._convert(from: value)
      guard exact else { return nil }
      self = value_
    }
  }
  @inlinable @inline(__always) public init(_ other: Swift.Float) {
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/FloatingPointTypes.swift.gyb", line: 1166)
    _value = other._value
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/FloatingPointTypes.swift.gyb", line: 1168)
  }
  @inlinable @inline(__always) public init?(exactly other: Swift.Float) {
    self.init(other)
    // Converting the infinity value is considered value preserving.
    // In other cases, check that we can round-trip and get the same value.
    // NaN always fails.
    if Float(self) != other {
      return nil
    }
  }
  @inlinable @inline(__always) public init(_ other: Swift.Double) {
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/FloatingPointTypes.swift.gyb", line: 1162)
    _value = Builtin.fptrunc_FPIEEE64_FPIEEE32(other._value)
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/FloatingPointTypes.swift.gyb", line: 1168)
  }
  @inlinable @inline(__always) public init?(exactly other: Swift.Double) {
    self.init(other)
    // Converting the infinity value is considered value preserving.
    // In other cases, check that we can round-trip and get the same value.
    // NaN always fails.
    if Double(self) != other {
      return nil
    }
  }
  @inlinable @inline(__always) public init(_ other: Swift.Float80) {
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/FloatingPointTypes.swift.gyb", line: 1162)
    _value = Builtin.fptrunc_FPIEEE80_FPIEEE32(other._value)
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/FloatingPointTypes.swift.gyb", line: 1168)
  }
  @inlinable @inline(__always) public init?(exactly other: Swift.Float80) {
    self.init(other)
    // Converting the infinity value is considered value preserving.
    // In other cases, check that we can round-trip and get the same value.
    // NaN always fails.
    if Float80(self) != other {
      return nil
    }
  }
}
extension Float {
  @_transparent public static func + (lhs: Swift.Float, rhs: Swift.Float) -> Swift.Float {
    var lhs = lhs
    lhs += rhs
    return lhs
  }
  @_transparent public static func - (lhs: Swift.Float, rhs: Swift.Float) -> Swift.Float {
    var lhs = lhs
    lhs -= rhs
    return lhs
  }
  @_transparent public static func * (lhs: Swift.Float, rhs: Swift.Float) -> Swift.Float {
    var lhs = lhs
    lhs *= rhs
    return lhs
  }
  @_transparent public static func / (lhs: Swift.Float, rhs: Swift.Float) -> Swift.Float {
    var lhs = lhs
    lhs /= rhs
    return lhs
  }
}
extension Float : Swift.Strideable {
  @_transparent public func distance(to other: Swift.Float) -> Swift.Float {
    return other - self
  }
  @_transparent public func advanced(by amount: Swift.Float) -> Swift.Float {
    return self + amount
  }
  public typealias Stride = Swift.Float
}
@frozen public struct Double {
  public var _value: Builtin.FPIEEE64
  @_transparent public init() {
    let zero: Int64 = 0
    self._value = Builtin.sitofp_Int64_FPIEEE64(zero._value)
  }
  @_transparent public init(_ _value: Builtin.FPIEEE64) {
    self._value = _value
  }
}
extension Double : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
extension Double : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
extension Double : Swift.TextOutputStreamable {
  public func write<Target>(to target: inout Target) where Target : Swift.TextOutputStream
}
extension Double : Swift.BinaryFloatingPoint {
  public typealias Magnitude = Swift.Double
  public typealias Exponent = Swift.Int
  public typealias RawSignificand = Swift.UInt64
  @inlinable public static var exponentBitCount: Swift.Int {
    get {
    return 11
  }
  }
  @inlinable public static var significandBitCount: Swift.Int {
    get {
    return 52
  }
  }
  @inlinable internal static var _infinityExponent: Swift.UInt {
    @inline(__always) get { return 1 &<< UInt(exponentBitCount) - 1 }
  }
  @inlinable internal static var _exponentBias: Swift.UInt {
    @inline(__always) get { return _infinityExponent &>> 1 }
  }
  @inlinable internal static var _significandMask: Swift.UInt64 {
    @inline(__always) get {
      return 1 &<< UInt64(significandBitCount) - 1
    }
  }
  @inlinable internal static var _quietNaNMask: Swift.UInt64 {
    @inline(__always) get {
      return 1 &<< UInt64(significandBitCount - 1)
    }
  }
  @inlinable public var bitPattern: Swift.UInt64 {
    get {
    return UInt64(Builtin.bitcast_FPIEEE64_Int64(_value))
  }
  }
  @inlinable public init(bitPattern: Swift.UInt64) {
    self.init(Builtin.bitcast_Int64_FPIEEE64(bitPattern._value))
  }
  @inlinable public var sign: Swift.FloatingPointSign {
    get {
    let shift = Double.significandBitCount + Double.exponentBitCount
    return FloatingPointSign(
      rawValue: Int(bitPattern &>> UInt64(shift))
    )!
  }
  }
  @available(*, unavailable, renamed: "sign")
  public var isSignMinus: Swift.Bool {
    get
  }
  @inlinable public var exponentBitPattern: Swift.UInt {
    get {
    return UInt(bitPattern &>> UInt64(Double.significandBitCount)) &
      Double._infinityExponent
  }
  }
  @inlinable public var significandBitPattern: Swift.UInt64 {
    get {
    return UInt64(bitPattern) & Double._significandMask
  }
  }
  @inlinable public init(sign: Swift.FloatingPointSign, exponentBitPattern: Swift.UInt, significandBitPattern: Swift.UInt64) {
    let signShift = Double.significandBitCount + Double.exponentBitCount
    let sign = UInt64(sign == .minus ? 1 : 0)
    let exponent = UInt64(
      exponentBitPattern & Double._infinityExponent
    )
    let significand = UInt64(
      significandBitPattern & Double._significandMask
    )
    self.init(bitPattern:
      sign &<< UInt64(signShift) |
      exponent &<< UInt64(Double.significandBitCount) |
      significand
    )
  }
  @inlinable public var isCanonical: Swift.Bool {
    get {
    // All Float and Double encodings are canonical in IEEE 754.
    //
    // On platforms that do not support subnormals, we treat them as
    // non-canonical encodings of zero.
    if Self.leastNonzeroMagnitude == Self.leastNormalMagnitude {
      if exponentBitPattern == 0 && significandBitPattern != 0 {
        return false
      }
    }
    return true
  }
  }
  @inlinable public static var infinity: Swift.Double {
    get {
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/FloatingPointTypes.swift.gyb", line: 391)
    return Double(bitPattern: 0x7ff0000000000000)
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/FloatingPointTypes.swift.gyb", line: 405)
  }
  }
  @inlinable public static var nan: Swift.Double {
    get {
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/FloatingPointTypes.swift.gyb", line: 412)
    return Double(bitPattern: 0x7ff8000000000000)
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/FloatingPointTypes.swift.gyb", line: 422)
  }
  }
  @inlinable public static var signalingNaN: Swift.Double {
    get {
    return Double(nan: 0, signaling: true)
  }
  }
  @available(*, unavailable, renamed: "nan")
  public static var quietNaN: Swift.Double {
    get
  }
  @inlinable public static var greatestFiniteMagnitude: Swift.Double {
    get {
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/FloatingPointTypes.swift.gyb", line: 437)
    return 0x1.fffffffffffffp1023
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/FloatingPointTypes.swift.gyb", line: 447)
  }
  }
  @inlinable public static var pi: Swift.Double {
    get {
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/FloatingPointTypes.swift.gyb", line: 461)
    return 0x1.921fb54442d18p1
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/FloatingPointTypes.swift.gyb", line: 465)
  }
  }
  @inlinable public var ulp: Swift.Double {
    get {
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/FloatingPointTypes.swift.gyb", line: 470)
    guard _fastPath(isFinite) else { return .nan }
    if _fastPath(isNormal) {
      let bitPattern_ = bitPattern & Double.infinity.bitPattern
      return Double(bitPattern: bitPattern_) * 0x1p-52
    }
    // On arm, flush subnormal values to 0.
    return .leastNormalMagnitude * 0x1p-52
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/FloatingPointTypes.swift.gyb", line: 505)
  }
  }
  @inlinable public static var leastNormalMagnitude: Swift.Double {
    get {
    return 0x1.0p-1022
  }
  }
  @inlinable public static var leastNonzeroMagnitude: Swift.Double {
    get {
    return leastNormalMagnitude * ulpOfOne
  }
  }
  @inlinable public static var ulpOfOne: Swift.Double {
    get {
    return 0x1.0p-52
  }
  }
  @inlinable public var exponent: Swift.Int {
    get {
    if !isFinite { return .max }
    if isZero { return .min }
    let provisional = Int(exponentBitPattern) - Int(Double._exponentBias)
    if isNormal { return provisional }
    let shift =
      Double.significandBitCount - significandBitPattern._binaryLogarithm()
    return provisional + 1 - shift
  }
  }
  @inlinable public var significand: Swift.Double {
    get {
    if isNaN { return self }
    if isNormal {
      return Double(sign: .plus,
        exponentBitPattern: Double._exponentBias,
        significandBitPattern: significandBitPattern)
    }
    if isSubnormal {
      let shift =
        Double.significandBitCount - significandBitPattern._binaryLogarithm()
      return Double(
        sign: .plus,
        exponentBitPattern: Double._exponentBias,
        significandBitPattern: significandBitPattern &<< shift
      )
    }
    // zero or infinity.
    return Double(
      sign: .plus,
      exponentBitPattern: exponentBitPattern,
      significandBitPattern: 0
    )
  }
  }
  @inlinable public init(sign: Swift.FloatingPointSign, exponent: Swift.Int, significand: Swift.Double) {
    var result = significand
    if sign == .minus { result = -result }
    if significand.isFinite && !significand.isZero {
      var clamped = exponent
      let leastNormalExponent = 1 - Int(Double._exponentBias)
      let greatestFiniteExponent = Int(Double._exponentBias)
      if clamped < leastNormalExponent {
        clamped = max(clamped, 3*leastNormalExponent)
        while clamped < leastNormalExponent {
          result  *= Double.leastNormalMagnitude
          clamped -= leastNormalExponent
        }
      }
      else if clamped > greatestFiniteExponent {
        clamped = min(clamped, 3*greatestFiniteExponent)
        let step = Double(sign: .plus,
          exponentBitPattern: Double._infinityExponent - 1,
          significandBitPattern: 0)
        while clamped > greatestFiniteExponent {
          result  *= step
          clamped -= greatestFiniteExponent
        }
      }
      let scale = Double(
        sign: .plus,
        exponentBitPattern: UInt(Int(Double._exponentBias) + clamped),
        significandBitPattern: 0
      )
      result = result * scale
    }
    self = result
  }
  @inlinable public init(nan payload: Swift.Double.RawSignificand, signaling: Swift.Bool) {
    // We use significandBitCount - 2 bits for NaN payload.
    _precondition(payload < (Double._quietNaNMask &>> 1),
      "NaN payload is not encodable.")
    var significand = payload
    significand |= Double._quietNaNMask &>> (signaling ? 1 : 0)
    self.init(
      sign: .plus,
      exponentBitPattern: Double._infinityExponent,
      significandBitPattern: significand
    )
  }
  @inlinable public var nextUp: Swift.Double {
    get {
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/FloatingPointTypes.swift.gyb", line: 637)
    // Silence signaling NaNs, map -0 to +0.
    let x = self + 0
    if _fastPath(x < .infinity) {
      let increment = Int64(bitPattern: x.bitPattern) &>> 63 | 1
      let bitPattern_ = x.bitPattern &+ UInt64(bitPattern: increment)
      return Double(bitPattern: bitPattern_)
    }
    return x
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/FloatingPointTypes.swift.gyb", line: 675)
  }
  }
  @_transparent public init(signOf sign: Swift.Double, magnitudeOf mag: Swift.Double) {
    _value = Builtin.int_copysign_FPIEEE64(mag._value, sign._value)
  }
  @_transparent public mutating func round(_ rule: Swift.FloatingPointRoundingRule) {
    switch rule {
    case .toNearestOrAwayFromZero:
      _value = Builtin.int_round_FPIEEE64(_value)
    case .toNearestOrEven:
      _value = Builtin.int_rint_FPIEEE64(_value)
    case .towardZero:
      _value = Builtin.int_trunc_FPIEEE64(_value)
    case .awayFromZero:
      if sign == .minus {
        _value = Builtin.int_floor_FPIEEE64(_value)
      }
      else {
        _value = Builtin.int_ceil_FPIEEE64(_value)
      }
    case .up:
      _value = Builtin.int_ceil_FPIEEE64(_value)
    case .down:
      _value = Builtin.int_floor_FPIEEE64(_value)
    @unknown default:
      self._roundSlowPath(rule)
    }
  }
  @usableFromInline
  internal mutating func _roundSlowPath(_ rule: Swift.FloatingPointRoundingRule)
  @_transparent public mutating func negate() {
    _value = Builtin.fneg_FPIEEE64(self._value)
  }
  @_transparent public static func += (lhs: inout Swift.Double, rhs: Swift.Double) {
    lhs._value = Builtin.fadd_FPIEEE64(lhs._value, rhs._value)
  }
  @_transparent public static func -= (lhs: inout Swift.Double, rhs: Swift.Double) {
    lhs._value = Builtin.fsub_FPIEEE64(lhs._value, rhs._value)
  }
  @_transparent public static func *= (lhs: inout Swift.Double, rhs: Swift.Double) {
    lhs._value = Builtin.fmul_FPIEEE64(lhs._value, rhs._value)
  }
  @_transparent public static func /= (lhs: inout Swift.Double, rhs: Swift.Double) {
    lhs._value = Builtin.fdiv_FPIEEE64(lhs._value, rhs._value)
  }
  @inlinable @inline(__always) public mutating func formRemainder(dividingBy other: Swift.Double) {
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/FloatingPointTypes.swift.gyb", line: 751)
    self = _stdlib_remainder(self, other)
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/FloatingPointTypes.swift.gyb", line: 753)
  }
  @inlinable @inline(__always) public mutating func formTruncatingRemainder(dividingBy other: Swift.Double) {
    _value = Builtin.frem_FPIEEE64(self._value, other._value)
  }
  @_transparent public mutating func formSquareRoot() {
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/FloatingPointTypes.swift.gyb", line: 766)
    self = _stdlib_squareRoot(self)
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/FloatingPointTypes.swift.gyb", line: 768)
  }
  @_transparent public mutating func addProduct(_ lhs: Swift.Double, _ rhs: Swift.Double) {
    _value = Builtin.int_fma_FPIEEE64(lhs._value, rhs._value, _value)
  }
  @_transparent public func isEqual(to other: Swift.Double) -> Swift.Bool {
    return Bool(Builtin.fcmp_oeq_FPIEEE64(self._value, other._value))
  }
  @_transparent public func isLess(than other: Swift.Double) -> Swift.Bool {
    return Bool(Builtin.fcmp_olt_FPIEEE64(self._value, other._value))
  }
  @_transparent public func isLessThanOrEqualTo(_ other: Swift.Double) -> Swift.Bool {
    return Bool(Builtin.fcmp_ole_FPIEEE64(self._value, other._value))
  }
  @inlinable public var isNormal: Swift.Bool {
    @inline(__always) get {
      return exponentBitPattern > 0 && isFinite
    }
  }
  @inlinable public var isFinite: Swift.Bool {
    @inline(__always) get {
      return exponentBitPattern < Double._infinityExponent
    }
  }
  @inlinable public var isZero: Swift.Bool {
    @inline(__always) get {
      return exponentBitPattern == 0 && significandBitPattern == 0
    }
  }
  @inlinable public var isSubnormal: Swift.Bool {
    @inline(__always) get {
      return exponentBitPattern == 0 && significandBitPattern != 0
    }
  }
  @inlinable public var isInfinite: Swift.Bool {
    @inline(__always) get {
      return !isFinite && significandBitPattern == 0
    }
  }
  @inlinable public var isNaN: Swift.Bool {
    @inline(__always) get {
      return !isFinite && significandBitPattern != 0
    }
  }
  @inlinable public var isSignalingNaN: Swift.Bool {
    @inline(__always) get {
      return isNaN && (significandBitPattern & Double._quietNaNMask) == 0
    }
  }
  @inlinable public var binade: Swift.Double {
    get {
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/FloatingPointTypes.swift.gyb", line: 849)
    guard _fastPath(isFinite) else { return .nan }
    if _slowPath(isSubnormal) {
      let bitPattern_ =
        (self * 0x1p52).bitPattern
          & (-Double.infinity).bitPattern
      return Double(bitPattern: bitPattern_) * 0x1p-52
    }
    return Double(bitPattern: bitPattern & (-Double.infinity).bitPattern)
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/FloatingPointTypes.swift.gyb", line: 871)
  }
  }
  @inlinable public var significandWidth: Swift.Int {
    get {
    let trailingZeroBits = significandBitPattern.trailingZeroBitCount
    if isNormal {
      guard significandBitPattern != 0 else { return 0 }
      return Double.significandBitCount &- trailingZeroBits
    }
    if isSubnormal {
      let leadingZeroBits = significandBitPattern.leadingZeroBitCount
      return UInt64.bitWidth &- (trailingZeroBits &+ leadingZeroBits &+ 1)
    }
    return -1
  }
  }
  @inlinable @inline(__always) public init(floatLiteral value: Swift.Double) {
    self = value
  }
  public typealias FloatLiteralType = Swift.Double
  public typealias RawExponent = Swift.UInt
}
extension Double : Swift._ExpressibleByBuiltinIntegerLiteral, Swift.ExpressibleByIntegerLiteral {
  @_transparent public init(_builtinIntegerLiteral value: Builtin.IntLiteral) {
    self = Double(Builtin.itofp_with_overflow_IntLiteral_FPIEEE64(value))
  }
  @_transparent public init(integerLiteral value: Swift.Int64) {
    self = Double(Builtin.sitofp_Int64_FPIEEE64(value._value))
  }
  public typealias IntegerLiteralType = Swift.Int64
}
extension Double : Swift._ExpressibleByBuiltinFloatLiteral {
  @_transparent public init(_builtinFloatLiteral value: Builtin.FPIEEE80) {
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/FloatingPointTypes.swift.gyb", line: 924)
    self = Double(Builtin.fptrunc_FPIEEE80_FPIEEE64(value))
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/FloatingPointTypes.swift.gyb", line: 929)
  }
}
extension Double : Swift.Hashable {
  @inlinable public func hash(into hasher: inout Swift.Hasher) {
    var v = self
    if isZero {
      // To satisfy the axiom that equality implies hash equality, we need to
      // finesse the hash value of -0.0 to match +0.0.
      v = 0
    }
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/FloatingPointTypes.swift.gyb", line: 970)
    hasher.combine(v.bitPattern)
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/FloatingPointTypes.swift.gyb", line: 972)
  }
  @inlinable public func _rawHashValue(seed: Swift.Int) -> Swift.Int {
    // To satisfy the axiom that equality implies hash equality, we need to
    // finesse the hash value of -0.0 to match +0.0.
    let v = isZero ? 0 : self
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/FloatingPointTypes.swift.gyb", line: 985)
    return Hasher._hash(seed: seed, v.bitPattern)
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/FloatingPointTypes.swift.gyb", line: 991)
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension Double : Swift._HasCustomAnyHashableRepresentation {
  public func _toCustomAnyHashable() -> Swift.AnyHashable?
}
extension Double {
  @inlinable public var magnitude: Swift.Double {
    @inline(__always) get {
      return Double(Builtin.int_fabs_FPIEEE64(_value))
    }
  }
}
extension Double {
  @_transparent prefix public static func - (x: Swift.Double) -> Swift.Double {
    return Double(Builtin.fneg_FPIEEE64(x._value))
  }
}
extension Double {
  @_transparent public init(_ v: Swift.Int) {
    _value = Builtin.sitofp_Int64_FPIEEE64(v._value)
  }
  @inlinable @inline(__always) public init<Source>(_ value: Source) where Source : Swift.BinaryInteger {
    if value.bitWidth <= 64 {
      if Source.isSigned {
        let asInt = Int(truncatingIfNeeded: value)
        _value = Builtin.sitofp_Int64_FPIEEE64(asInt._value)
      } else {
        let asUInt = UInt(truncatingIfNeeded: value)
        _value = Builtin.uitofp_Int64_FPIEEE64(asUInt._value)
      }
    } else {
      // TODO: we can do much better than the generic _convert here for Float
      // and Double by pulling out the high-order 32/64b of the integer, ORing
      // in a sticky bit, and then using the builtin.
      self = Double._convert(from: value).value
    }
  }
  @_alwaysEmitIntoClient @inline(never) public init?<Source>(exactly value: Source) where Source : Swift.BinaryInteger {
    if value.bitWidth <= 64 {
      // If the source is small enough to fit in a word, we can use the LLVM
      // conversion intrinsic, then check if we can round-trip back to the
      // the original value; if so, the conversion was exact. We need to be
      // careful, however, to make sure that the first conversion does not
      // round to a value that is out of the defined range of the second
      // converion. E.g. Float(Int.max) rounds to Int.max + 1, and converting
      // that back to Int will trap. For Float, Double, and Float80, this is
      // only an issue for the upper bound (because the lower bound of [U]Int
      // is either zero or a power of two, both of which are exactly
      // representable). For Float16, we also need to check for overflow to
      // -.infinity.
      if Source.isSigned {
        let extended = Int(truncatingIfNeeded: value)
        _value = Builtin.sitofp_Int64_FPIEEE64(extended._value)
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/FloatingPointTypes.swift.gyb", line: 1082)
        guard self < 0x1.0p63 && Int(self) == extended else {
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/FloatingPointTypes.swift.gyb", line: 1084)
          return nil
        }
      } else {
        let extended = UInt(truncatingIfNeeded: value)
        _value = Builtin.uitofp_Int64_FPIEEE64(extended._value)
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/FloatingPointTypes.swift.gyb", line: 1092)
        guard self < 0x1.0p64 && UInt(self) == extended else {
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/FloatingPointTypes.swift.gyb", line: 1094)
          return nil
        }
      }
    } else {
      // TODO: we can do much better than the generic _convert here for Float
      // and Double by pulling out the high-order 32/64b of the integer, ORing
      // in a sticky bit, and then using the builtin.
      let (value_, exact) = Self._convert(from: value)
      guard exact else { return nil }
      self = value_
    }
  }
  @inlinable @inline(__always) public init(_ other: Swift.Float) {
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/FloatingPointTypes.swift.gyb", line: 1164)
    _value = Builtin.fpext_FPIEEE32_FPIEEE64(other._value)
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/FloatingPointTypes.swift.gyb", line: 1168)
  }
  @inlinable @inline(__always) public init?(exactly other: Swift.Float) {
    self.init(other)
    // Converting the infinity value is considered value preserving.
    // In other cases, check that we can round-trip and get the same value.
    // NaN always fails.
    if Float(self) != other {
      return nil
    }
  }
  @inlinable @inline(__always) public init(_ other: Swift.Double) {
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/FloatingPointTypes.swift.gyb", line: 1166)
    _value = other._value
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/FloatingPointTypes.swift.gyb", line: 1168)
  }
  @inlinable @inline(__always) public init?(exactly other: Swift.Double) {
    self.init(other)
    // Converting the infinity value is considered value preserving.
    // In other cases, check that we can round-trip and get the same value.
    // NaN always fails.
    if Double(self) != other {
      return nil
    }
  }
  @inlinable @inline(__always) public init(_ other: Swift.Float80) {
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/FloatingPointTypes.swift.gyb", line: 1162)
    _value = Builtin.fptrunc_FPIEEE80_FPIEEE64(other._value)
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/FloatingPointTypes.swift.gyb", line: 1168)
  }
  @inlinable @inline(__always) public init?(exactly other: Swift.Float80) {
    self.init(other)
    // Converting the infinity value is considered value preserving.
    // In other cases, check that we can round-trip and get the same value.
    // NaN always fails.
    if Float80(self) != other {
      return nil
    }
  }
}
extension Double {
  @_transparent public static func + (lhs: Swift.Double, rhs: Swift.Double) -> Swift.Double {
    var lhs = lhs
    lhs += rhs
    return lhs
  }
  @_transparent public static func - (lhs: Swift.Double, rhs: Swift.Double) -> Swift.Double {
    var lhs = lhs
    lhs -= rhs
    return lhs
  }
  @_transparent public static func * (lhs: Swift.Double, rhs: Swift.Double) -> Swift.Double {
    var lhs = lhs
    lhs *= rhs
    return lhs
  }
  @_transparent public static func / (lhs: Swift.Double, rhs: Swift.Double) -> Swift.Double {
    var lhs = lhs
    lhs /= rhs
    return lhs
  }
}
extension Double : Swift.Strideable {
  @_transparent public func distance(to other: Swift.Double) -> Swift.Double {
    return other - self
  }
  @_transparent public func advanced(by amount: Swift.Double) -> Swift.Double {
    return self + amount
  }
  public typealias Stride = Swift.Double
}
@frozen public struct Float80 {
  public var _value: Builtin.FPIEEE80
  @_transparent public init() {
    let zero: Int64 = 0
    self._value = Builtin.sitofp_Int64_FPIEEE80(zero._value)
  }
  @_transparent public init(_ _value: Builtin.FPIEEE80) {
    self._value = _value
  }
}
extension Float80 : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
extension Float80 : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
extension Float80 : Swift.TextOutputStreamable {
  public func write<Target>(to target: inout Target) where Target : Swift.TextOutputStream
}
extension Float80 : Swift.BinaryFloatingPoint {
  public typealias Magnitude = Swift.Float80
  public typealias Exponent = Swift.Int
  public typealias RawSignificand = Swift.UInt64
  @inlinable public static var exponentBitCount: Swift.Int {
    get {
    return 15
  }
  }
  @inlinable public static var significandBitCount: Swift.Int {
    get {
    return 63
  }
  }
  @inlinable internal static var _infinityExponent: Swift.UInt {
    @inline(__always) get { return 1 &<< UInt(exponentBitCount) - 1 }
  }
  @inlinable internal static var _exponentBias: Swift.UInt {
    @inline(__always) get { return _infinityExponent &>> 1 }
  }
  @inlinable internal static var _significandMask: Swift.UInt64 {
    @inline(__always) get {
      return 1 &<< UInt64(significandBitCount) - 1
    }
  }
  @inlinable internal static var _quietNaNMask: Swift.UInt64 {
    @inline(__always) get {
      return 1 &<< UInt64(significandBitCount - 1)
    }
  }
  @usableFromInline
  @frozen internal struct _Representation {
    @usableFromInline
    internal var _storage: (Swift.UInt64, Swift.UInt16, Swift.UInt16, Swift.UInt16, Swift.UInt16)
    @usableFromInline
    @_transparent internal var explicitSignificand: Swift.UInt64 {
      @_transparent get { return _storage.0 }
    }
    @usableFromInline
    @_transparent internal var signAndExponent: Swift.UInt16 {
      @_transparent get { return _storage.1 }
    }
    @usableFromInline
    @_transparent internal var sign: Swift.FloatingPointSign {
      @_transparent get {
      return FloatingPointSign(rawValue: Int(signAndExponent &>> 15))!
    }
    }
    @usableFromInline
    @_transparent internal var exponentBitPattern: Swift.UInt {
      @_transparent get {
      return UInt(signAndExponent) & 0x7fff
    }
    }
    @usableFromInline
    @_transparent internal init(explicitSignificand: Swift.UInt64, signAndExponent: Swift.UInt16) {
      _storage = (explicitSignificand, signAndExponent, 0, 0, 0)
    }
  }
  @inlinable internal var _representation: Swift.Float80._Representation {
    get {
    return unsafeBitCast(self, to: _Representation.self)
  }
  }
  @inlinable public var sign: Swift.FloatingPointSign {
    get {
    return _representation.sign
  }
  }
  @inlinable internal static var _explicitBitMask: Swift.UInt64 {
    @inline(__always) get { return 1 &<< 63 }
  }
  @inlinable public var exponentBitPattern: Swift.UInt {
    get {
    let provisional = _representation.exponentBitPattern
    if provisional == 0 {
      if _representation.explicitSignificand >= Float80._explicitBitMask {
        //  Pseudo-denormals have an exponent of 0 but the leading bit of the
        //  significand field is set.  These are noncanonical encodings of the
        //  same significand with an exponent of 1.
        return 1
      }
      //  Exponent is zero, leading bit of significand is clear, so this is
      //  a canonical zero or subnormal number.
      return 0
    }
    if _representation.explicitSignificand < Float80._explicitBitMask {
      //  If the exponent is not-zero but the leading bit of the significand
      //  is clear, then we have an invalid operand (unnormal, pseudo-inf, or
      //  pseudo-NaN).  All of these are noncanonical encodings of NaN.
      return Float80._infinityExponent
    }
    //  We have a canonical number, so the provisional exponent is correct.
    return provisional
  }
  }
  @inlinable public var significandBitPattern: Swift.UInt64 {
    get {
    if _representation.exponentBitPattern > 0 &&
      _representation.explicitSignificand < Float80._explicitBitMask {
        //  If the exponent is nonzero and the leading bit of the significand
        //  is clear, then we have an invalid operand (unnormal, pseudo-inf, or
        //  pseudo-NaN).  All of these are noncanonical encodings of qNaN.
        return _representation.explicitSignificand | Float80._quietNaNMask
    }
    //  Otherwise we always get the "right" significand by simply clearing the
    //  integral bit.
    return _representation.explicitSignificand & Float80._significandMask
  }
  }
  @inlinable public init(sign: Swift.FloatingPointSign, exponentBitPattern: Swift.UInt, significandBitPattern: Swift.UInt64) {
    let signBit = UInt16(sign == .minus ? 0x8000 : 0)
    let exponent = UInt16(exponentBitPattern)
    var significand = significandBitPattern
    if exponent != 0 { significand |= Float80._explicitBitMask }
    let rep = _Representation(
      explicitSignificand: significand, signAndExponent: signBit|exponent)
    self = unsafeBitCast(rep, to: Float80.self)
  }
  @inlinable public var isCanonical: Swift.Bool {
    get {
    if exponentBitPattern == 0 {
      // If exponent field is zero, canonical numbers have the explicit
      // significand bit clear.
      return _representation.explicitSignificand < Float80._explicitBitMask
    }
    // If exponent is nonzero, canonical values have the explicit significand
    // bit set.
    return _representation.explicitSignificand >= Float80._explicitBitMask
  }
  }
  @inlinable public static var infinity: Swift.Float80 {
    get {
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/FloatingPointTypes.swift.gyb", line: 393)
    let rep = _Representation(
      explicitSignificand: Float80._explicitBitMask,
      signAndExponent: 0x7fff
    )
    return unsafeBitCast(rep, to: Float80.self)
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/FloatingPointTypes.swift.gyb", line: 405)
  }
  }
  @inlinable public static var nan: Swift.Float80 {
    get {
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/FloatingPointTypes.swift.gyb", line: 414)
    let rep = _Representation(
      explicitSignificand: Float80._explicitBitMask | Float80._quietNaNMask,
      signAndExponent: 0x7fff
    )
    return unsafeBitCast(rep, to: Float80.self)
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/FloatingPointTypes.swift.gyb", line: 422)
  }
  }
  @inlinable public static var signalingNaN: Swift.Float80 {
    get {
    return Float80(nan: 0, signaling: true)
  }
  }
  @available(*, unavailable, renamed: "nan")
  public static var quietNaN: Swift.Float80 {
    get
  }
  @inlinable public static var greatestFiniteMagnitude: Swift.Float80 {
    get {
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/FloatingPointTypes.swift.gyb", line: 439)
    return 0x1.fffffffffffffffep16383
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/FloatingPointTypes.swift.gyb", line: 447)
  }
  }
  @inlinable public static var pi: Swift.Float80 {
    get {
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/FloatingPointTypes.swift.gyb", line: 463)
    return 0x1.921fb54442d1846ap1
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/FloatingPointTypes.swift.gyb", line: 465)
  }
  }
  @inlinable public var ulp: Swift.Float80 {
    get {
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/FloatingPointTypes.swift.gyb", line: 478)
    guard _fastPath(isFinite) else { return .nan }
    if exponentBitPattern > UInt(Float80.significandBitCount) {
      // self is large enough that self.ulp is normal, so we just compute its
      // exponent and construct it with a significand of zero.
      let ulpExponent =
        exponentBitPattern - UInt(Float80.significandBitCount)
      return Float80(
        sign: .plus,
        exponentBitPattern: ulpExponent,
        significandBitPattern: 0
      )
    }
    if exponentBitPattern >= 1 {
      // self is normal but ulp is subnormal.
      let ulpShift = UInt64(exponentBitPattern - 1)
      return Float80(
        sign: .plus,
        exponentBitPattern: 0,
        significandBitPattern: 1 &<< ulpShift
      )
    }
    return Float80(
      sign: .plus,
      exponentBitPattern: 0,
      significandBitPattern: 1
    )
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/FloatingPointTypes.swift.gyb", line: 505)
  }
  }
  @inlinable public static var leastNormalMagnitude: Swift.Float80 {
    get {
    return 0x1.0p-16382
  }
  }
  @inlinable public static var leastNonzeroMagnitude: Swift.Float80 {
    get {
    return leastNormalMagnitude * ulpOfOne
  }
  }
  @inlinable public static var ulpOfOne: Swift.Float80 {
    get {
    return 0x1.0p-63
  }
  }
  @inlinable public var exponent: Swift.Int {
    get {
    if !isFinite { return .max }
    if isZero { return .min }
    let provisional = Int(exponentBitPattern) - Int(Float80._exponentBias)
    if isNormal { return provisional }
    let shift =
      Float80.significandBitCount - significandBitPattern._binaryLogarithm()
    return provisional + 1 - shift
  }
  }
  @inlinable public var significand: Swift.Float80 {
    get {
    if isNaN { return self }
    if isNormal {
      return Float80(sign: .plus,
        exponentBitPattern: Float80._exponentBias,
        significandBitPattern: significandBitPattern)
    }
    if isSubnormal {
      let shift =
        Float80.significandBitCount - significandBitPattern._binaryLogarithm()
      return Float80(
        sign: .plus,
        exponentBitPattern: Float80._exponentBias,
        significandBitPattern: significandBitPattern &<< shift
      )
    }
    // zero or infinity.
    return Float80(
      sign: .plus,
      exponentBitPattern: exponentBitPattern,
      significandBitPattern: 0
    )
  }
  }
  @inlinable public init(sign: Swift.FloatingPointSign, exponent: Swift.Int, significand: Swift.Float80) {
    var result = significand
    if sign == .minus { result = -result }
    if significand.isFinite && !significand.isZero {
      var clamped = exponent
      let leastNormalExponent = 1 - Int(Float80._exponentBias)
      let greatestFiniteExponent = Int(Float80._exponentBias)
      if clamped < leastNormalExponent {
        clamped = max(clamped, 3*leastNormalExponent)
        while clamped < leastNormalExponent {
          result  *= Float80.leastNormalMagnitude
          clamped -= leastNormalExponent
        }
      }
      else if clamped > greatestFiniteExponent {
        clamped = min(clamped, 3*greatestFiniteExponent)
        let step = Float80(sign: .plus,
          exponentBitPattern: Float80._infinityExponent - 1,
          significandBitPattern: 0)
        while clamped > greatestFiniteExponent {
          result  *= step
          clamped -= greatestFiniteExponent
        }
      }
      let scale = Float80(
        sign: .plus,
        exponentBitPattern: UInt(Int(Float80._exponentBias) + clamped),
        significandBitPattern: 0
      )
      result = result * scale
    }
    self = result
  }
  @inlinable public init(nan payload: Swift.Float80.RawSignificand, signaling: Swift.Bool) {
    // We use significandBitCount - 2 bits for NaN payload.
    _precondition(payload < (Float80._quietNaNMask &>> 1),
      "NaN payload is not encodable.")
    var significand = payload
    significand |= Float80._quietNaNMask &>> (signaling ? 1 : 0)
    self.init(
      sign: .plus,
      exponentBitPattern: Float80._infinityExponent,
      significandBitPattern: significand
    )
  }
  @inlinable public var nextUp: Swift.Float80 {
    get {
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/FloatingPointTypes.swift.gyb", line: 651)
    if isNaN { /* Silence signaling NaNs. */ return self + 0 }
    if sign == .minus {
      if significandBitPattern == 0 {
        if exponentBitPattern == 0 {
          return .leastNonzeroMagnitude
        }
        return Float80(sign: .minus,
          exponentBitPattern: exponentBitPattern - 1,
          significandBitPattern: Float80._significandMask)
      }
      return Float80(sign: .minus,
        exponentBitPattern: exponentBitPattern,
        significandBitPattern: significandBitPattern - 1)
    }
    if isInfinite { return self }
    if significandBitPattern == Float80._significandMask {
      return Float80(sign: .plus,
        exponentBitPattern: exponentBitPattern + 1,
        significandBitPattern: 0)
    }
    return Float80(sign: .plus,
      exponentBitPattern: exponentBitPattern,
      significandBitPattern: significandBitPattern + 1)
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/FloatingPointTypes.swift.gyb", line: 675)
  }
  }
  @_transparent public init(signOf sign: Swift.Float80, magnitudeOf mag: Swift.Float80) {
    _value = Builtin.int_copysign_FPIEEE80(mag._value, sign._value)
  }
  @_transparent public mutating func round(_ rule: Swift.FloatingPointRoundingRule) {
    switch rule {
    case .toNearestOrAwayFromZero:
      _value = Builtin.int_round_FPIEEE80(_value)
    case .toNearestOrEven:
      _value = Builtin.int_rint_FPIEEE80(_value)
    case .towardZero:
      _value = Builtin.int_trunc_FPIEEE80(_value)
    case .awayFromZero:
      if sign == .minus {
        _value = Builtin.int_floor_FPIEEE80(_value)
      }
      else {
        _value = Builtin.int_ceil_FPIEEE80(_value)
      }
    case .up:
      _value = Builtin.int_ceil_FPIEEE80(_value)
    case .down:
      _value = Builtin.int_floor_FPIEEE80(_value)
    @unknown default:
      self._roundSlowPath(rule)
    }
  }
  @usableFromInline
  internal mutating func _roundSlowPath(_ rule: Swift.FloatingPointRoundingRule)
  @_transparent public mutating func negate() {
    _value = Builtin.fneg_FPIEEE80(self._value)
  }
  @_transparent public static func += (lhs: inout Swift.Float80, rhs: Swift.Float80) {
    lhs._value = Builtin.fadd_FPIEEE80(lhs._value, rhs._value)
  }
  @_transparent public static func -= (lhs: inout Swift.Float80, rhs: Swift.Float80) {
    lhs._value = Builtin.fsub_FPIEEE80(lhs._value, rhs._value)
  }
  @_transparent public static func *= (lhs: inout Swift.Float80, rhs: Swift.Float80) {
    lhs._value = Builtin.fmul_FPIEEE80(lhs._value, rhs._value)
  }
  @_transparent public static func /= (lhs: inout Swift.Float80, rhs: Swift.Float80) {
    lhs._value = Builtin.fdiv_FPIEEE80(lhs._value, rhs._value)
  }
  @inlinable @inline(__always) public mutating func formRemainder(dividingBy other: Swift.Float80) {
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/FloatingPointTypes.swift.gyb", line: 751)
    self = _stdlib_remainderl(self, other)
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/FloatingPointTypes.swift.gyb", line: 753)
  }
  @inlinable @inline(__always) public mutating func formTruncatingRemainder(dividingBy other: Swift.Float80) {
    _value = Builtin.frem_FPIEEE80(self._value, other._value)
  }
  @_transparent public mutating func formSquareRoot() {
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/FloatingPointTypes.swift.gyb", line: 766)
    self = _stdlib_squareRootl(self)
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/FloatingPointTypes.swift.gyb", line: 768)
  }
  @_transparent public mutating func addProduct(_ lhs: Swift.Float80, _ rhs: Swift.Float80) {
    _value = Builtin.int_fma_FPIEEE80(lhs._value, rhs._value, _value)
  }
  @_transparent public func isEqual(to other: Swift.Float80) -> Swift.Bool {
    return Bool(Builtin.fcmp_oeq_FPIEEE80(self._value, other._value))
  }
  @_transparent public func isLess(than other: Swift.Float80) -> Swift.Bool {
    return Bool(Builtin.fcmp_olt_FPIEEE80(self._value, other._value))
  }
  @_transparent public func isLessThanOrEqualTo(_ other: Swift.Float80) -> Swift.Bool {
    return Bool(Builtin.fcmp_ole_FPIEEE80(self._value, other._value))
  }
  @inlinable public var isNormal: Swift.Bool {
    @inline(__always) get {
      return exponentBitPattern > 0 && isFinite
    }
  }
  @inlinable public var isFinite: Swift.Bool {
    @inline(__always) get {
      return exponentBitPattern < Float80._infinityExponent
    }
  }
  @inlinable public var isZero: Swift.Bool {
    @inline(__always) get {
      return exponentBitPattern == 0 && significandBitPattern == 0
    }
  }
  @inlinable public var isSubnormal: Swift.Bool {
    @inline(__always) get {
      return exponentBitPattern == 0 && significandBitPattern != 0
    }
  }
  @inlinable public var isInfinite: Swift.Bool {
    @inline(__always) get {
      return !isFinite && significandBitPattern == 0
    }
  }
  @inlinable public var isNaN: Swift.Bool {
    @inline(__always) get {
      return !isFinite && significandBitPattern != 0
    }
  }
  @inlinable public var isSignalingNaN: Swift.Bool {
    @inline(__always) get {
      return isNaN && (significandBitPattern & Float80._quietNaNMask) == 0
    }
  }
  @inlinable public var binade: Swift.Float80 {
    get {
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/FloatingPointTypes.swift.gyb", line: 860)
    guard _fastPath(isFinite) else { return .nan }
    if exponentBitPattern != 0 {
      return Float80(sign: sign, exponentBitPattern: exponentBitPattern,
        significandBitPattern: 0)
    }
    if significandBitPattern == 0 { return self }
    // For subnormals, we isolate the leading significand bit.
    let index = significandBitPattern._binaryLogarithm()
    return Float80(sign: sign, exponentBitPattern: 0,
      significandBitPattern: 1 &<< index)
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/FloatingPointTypes.swift.gyb", line: 871)
  }
  }
  @inlinable public var significandWidth: Swift.Int {
    get {
    let trailingZeroBits = significandBitPattern.trailingZeroBitCount
    if isNormal {
      guard significandBitPattern != 0 else { return 0 }
      return Float80.significandBitCount &- trailingZeroBits
    }
    if isSubnormal {
      let leadingZeroBits = significandBitPattern.leadingZeroBitCount
      return UInt64.bitWidth &- (trailingZeroBits &+ leadingZeroBits &+ 1)
    }
    return -1
  }
  }
  @inlinable @inline(__always) public init(floatLiteral value: Swift.Float80) {
    self = value
  }
  public typealias FloatLiteralType = Swift.Float80
  public typealias RawExponent = Swift.UInt
}
extension Float80 : Swift._ExpressibleByBuiltinIntegerLiteral, Swift.ExpressibleByIntegerLiteral {
  @_transparent public init(_builtinIntegerLiteral value: Builtin.IntLiteral) {
    self = Float80(Builtin.itofp_with_overflow_IntLiteral_FPIEEE80(value))
  }
  @_transparent public init(integerLiteral value: Swift.Int64) {
    self = Float80(Builtin.sitofp_Int64_FPIEEE80(value._value))
  }
  public typealias IntegerLiteralType = Swift.Int64
}
extension Float80 : Swift._ExpressibleByBuiltinFloatLiteral {
  @_transparent public init(_builtinFloatLiteral value: Builtin.FPIEEE80) {
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/FloatingPointTypes.swift.gyb", line: 919)
    self = Float80(value)
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/FloatingPointTypes.swift.gyb", line: 929)
  }
}
extension Float80 : Swift.Hashable {
  @inlinable public func hash(into hasher: inout Swift.Hasher) {
    var v = self
    if isZero {
      // To satisfy the axiom that equality implies hash equality, we need to
      // finesse the hash value of -0.0 to match +0.0.
      v = 0
    }
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/FloatingPointTypes.swift.gyb", line: 967)
    hasher.combine(v._representation.signAndExponent)
    hasher.combine(v.significandBitPattern)
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/FloatingPointTypes.swift.gyb", line: 972)
  }
  @inlinable public func _rawHashValue(seed: Swift.Int) -> Swift.Int {
    // To satisfy the axiom that equality implies hash equality, we need to
    // finesse the hash value of -0.0 to match +0.0.
    let v = isZero ? 0 : self
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/FloatingPointTypes.swift.gyb", line: 980)
    var hasher = Hasher(_seed: seed)
    hasher.combine(v._representation.signAndExponent)
    hasher.combine(v.significandBitPattern)
    return hasher._finalize()
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/FloatingPointTypes.swift.gyb", line: 991)
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension Float80 : Swift._HasCustomAnyHashableRepresentation {
  public func _toCustomAnyHashable() -> Swift.AnyHashable?
}
extension Float80 {
  @inlinable public var magnitude: Swift.Float80 {
    @inline(__always) get {
      return Float80(Builtin.int_fabs_FPIEEE80(_value))
    }
  }
}
extension Float80 {
  @_transparent prefix public static func - (x: Swift.Float80) -> Swift.Float80 {
    return Float80(Builtin.fneg_FPIEEE80(x._value))
  }
}
extension Float80 {
  @_transparent public init(_ v: Swift.Int) {
    _value = Builtin.sitofp_Int64_FPIEEE80(v._value)
  }
  @inlinable @inline(__always) public init<Source>(_ value: Source) where Source : Swift.BinaryInteger {
    if value.bitWidth <= 64 {
      if Source.isSigned {
        let asInt = Int(truncatingIfNeeded: value)
        _value = Builtin.sitofp_Int64_FPIEEE80(asInt._value)
      } else {
        let asUInt = UInt(truncatingIfNeeded: value)
        _value = Builtin.uitofp_Int64_FPIEEE80(asUInt._value)
      }
    } else {
      // TODO: we can do much better than the generic _convert here for Float
      // and Double by pulling out the high-order 32/64b of the integer, ORing
      // in a sticky bit, and then using the builtin.
      self = Float80._convert(from: value).value
    }
  }
  @_alwaysEmitIntoClient @inline(never) public init?<Source>(exactly value: Source) where Source : Swift.BinaryInteger {
    if value.bitWidth <= 64 {
      // If the source is small enough to fit in a word, we can use the LLVM
      // conversion intrinsic, then check if we can round-trip back to the
      // the original value; if so, the conversion was exact. We need to be
      // careful, however, to make sure that the first conversion does not
      // round to a value that is out of the defined range of the second
      // converion. E.g. Float(Int.max) rounds to Int.max + 1, and converting
      // that back to Int will trap. For Float, Double, and Float80, this is
      // only an issue for the upper bound (because the lower bound of [U]Int
      // is either zero or a power of two, both of which are exactly
      // representable). For Float16, we also need to check for overflow to
      // -.infinity.
      if Source.isSigned {
        let extended = Int(truncatingIfNeeded: value)
        _value = Builtin.sitofp_Int64_FPIEEE80(extended._value)
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/FloatingPointTypes.swift.gyb", line: 1082)
        guard self < 0x1.0p63 && Int(self) == extended else {
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/FloatingPointTypes.swift.gyb", line: 1084)
          return nil
        }
      } else {
        let extended = UInt(truncatingIfNeeded: value)
        _value = Builtin.uitofp_Int64_FPIEEE80(extended._value)
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/FloatingPointTypes.swift.gyb", line: 1092)
        guard self < 0x1.0p64 && UInt(self) == extended else {
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/FloatingPointTypes.swift.gyb", line: 1094)
          return nil
        }
      }
    } else {
      // TODO: we can do much better than the generic _convert here for Float
      // and Double by pulling out the high-order 32/64b of the integer, ORing
      // in a sticky bit, and then using the builtin.
      let (value_, exact) = Self._convert(from: value)
      guard exact else { return nil }
      self = value_
    }
  }
  @inlinable @inline(__always) public init(_ other: Swift.Float) {
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/FloatingPointTypes.swift.gyb", line: 1164)
    _value = Builtin.fpext_FPIEEE32_FPIEEE80(other._value)
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/FloatingPointTypes.swift.gyb", line: 1168)
  }
  @inlinable @inline(__always) public init?(exactly other: Swift.Float) {
    self.init(other)
    // Converting the infinity value is considered value preserving.
    // In other cases, check that we can round-trip and get the same value.
    // NaN always fails.
    if Float(self) != other {
      return nil
    }
  }
  @inlinable @inline(__always) public init(_ other: Swift.Double) {
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/FloatingPointTypes.swift.gyb", line: 1164)
    _value = Builtin.fpext_FPIEEE64_FPIEEE80(other._value)
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/FloatingPointTypes.swift.gyb", line: 1168)
  }
  @inlinable @inline(__always) public init?(exactly other: Swift.Double) {
    self.init(other)
    // Converting the infinity value is considered value preserving.
    // In other cases, check that we can round-trip and get the same value.
    // NaN always fails.
    if Double(self) != other {
      return nil
    }
  }
  @inlinable @inline(__always) public init(_ other: Swift.Float80) {
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/FloatingPointTypes.swift.gyb", line: 1166)
    _value = other._value
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/FloatingPointTypes.swift.gyb", line: 1168)
  }
  @inlinable @inline(__always) public init?(exactly other: Swift.Float80) {
    self.init(other)
    // Converting the infinity value is considered value preserving.
    // In other cases, check that we can round-trip and get the same value.
    // NaN always fails.
    if Float80(self) != other {
      return nil
    }
  }
}
extension Float80 {
  @_transparent public static func + (lhs: Swift.Float80, rhs: Swift.Float80) -> Swift.Float80 {
    var lhs = lhs
    lhs += rhs
    return lhs
  }
  @_transparent public static func - (lhs: Swift.Float80, rhs: Swift.Float80) -> Swift.Float80 {
    var lhs = lhs
    lhs -= rhs
    return lhs
  }
  @_transparent public static func * (lhs: Swift.Float80, rhs: Swift.Float80) -> Swift.Float80 {
    var lhs = lhs
    lhs *= rhs
    return lhs
  }
  @_transparent public static func / (lhs: Swift.Float80, rhs: Swift.Float80) -> Swift.Float80 {
    var lhs = lhs
    lhs /= rhs
    return lhs
  }
}
extension Float80 : Swift.Strideable {
  @_transparent public func distance(to other: Swift.Float80) -> Swift.Float80 {
    return other - self
  }
  @_transparent public func advanced(by amount: Swift.Float80) -> Swift.Float80 {
    return self + amount
  }
  public typealias Stride = Swift.Float80
}
@available(*, unavailable, message: "For floating point numbers use truncatingRemainder instead")
@_transparent public func % <T>(lhs: T, rhs: T) -> T where T : Swift.BinaryFloatingPoint {
  fatalError("% is not available.")
}
@available(*, unavailable, message: "For floating point numbers use formTruncatingRemainder instead")
@_transparent public func %= <T>(lhs: inout T, rhs: T) where T : Swift.BinaryFloatingPoint {
  fatalError("%= is not available.")
}
@frozen public struct UInt8 : Swift.FixedWidthInteger, Swift.UnsignedInteger, Swift._ExpressibleByBuiltinIntegerLiteral {
  public typealias IntegerLiteralType = Swift.UInt8
  @_transparent public init(_builtinIntegerLiteral x: Builtin.IntLiteral) {
    _value = Builtin.s_to_u_checked_trunc_IntLiteral_Int8(x).0
  }
  @_transparent public init(bitPattern x: Swift.Int8) {
    _value = x._value
  }
  @_transparent public init(_ source: Swift.Float) {
    _precondition(source.isFinite,
      "Float value cannot be converted to UInt8 because it is either infinite or NaN")
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1164)
    _precondition(source > -1.0,
      "Float value cannot be converted to UInt8 because the result would be less than UInt8.min")
    _precondition(source < 256.0,
      "Float value cannot be converted to UInt8 because the result would be greater than UInt8.max")
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1169)
    self._value = Builtin.fptoui_FPIEEE32_Int8(source._value)
  }
  @_transparent public init?(exactly source: Swift.Float) {
    // The value passed as `source` must not be infinite, NaN, or exceed the
    // bounds of the integer type; the result of `fptosi` or `fptoui` is
    // undefined if it overflows.
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1195)
    guard source > -1.0 && source < 256.0 else {
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1199)
      return nil
    }
    guard source == source.rounded(.towardZero) else {
      return nil
    }
    self._value = Builtin.fptoui_FPIEEE32_Int8(source._value)
  }
  @_transparent public init(_ source: Swift.Double) {
    _precondition(source.isFinite,
      "Double value cannot be converted to UInt8 because it is either infinite or NaN")
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1164)
    _precondition(source > -1.0,
      "Double value cannot be converted to UInt8 because the result would be less than UInt8.min")
    _precondition(source < 256.0,
      "Double value cannot be converted to UInt8 because the result would be greater than UInt8.max")
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1169)
    self._value = Builtin.fptoui_FPIEEE64_Int8(source._value)
  }
  @_transparent public init?(exactly source: Swift.Double) {
    // The value passed as `source` must not be infinite, NaN, or exceed the
    // bounds of the integer type; the result of `fptosi` or `fptoui` is
    // undefined if it overflows.
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1195)
    guard source > -1.0 && source < 256.0 else {
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1199)
      return nil
    }
    guard source == source.rounded(.towardZero) else {
      return nil
    }
    self._value = Builtin.fptoui_FPIEEE64_Int8(source._value)
  }
  @_transparent public init(_ source: Swift.Float80) {
    _precondition(source.isFinite,
      "Float80 value cannot be converted to UInt8 because it is either infinite or NaN")
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1164)
    _precondition(source > -1.0,
      "Float80 value cannot be converted to UInt8 because the result would be less than UInt8.min")
    _precondition(source < 256.0,
      "Float80 value cannot be converted to UInt8 because the result would be greater than UInt8.max")
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1169)
    self._value = Builtin.fptoui_FPIEEE80_Int8(source._value)
  }
  @_transparent public init?(exactly source: Swift.Float80) {
    // The value passed as `source` must not be infinite, NaN, or exceed the
    // bounds of the integer type; the result of `fptosi` or `fptoui` is
    // undefined if it overflows.
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1195)
    guard source > -1.0 && source < 256.0 else {
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1199)
      return nil
    }
    guard source == source.rounded(.towardZero) else {
      return nil
    }
    self._value = Builtin.fptoui_FPIEEE80_Int8(source._value)
  }
  @_transparent public static func == (lhs: Swift.UInt8, rhs: Swift.UInt8) -> Swift.Bool {
    return Bool(Builtin.cmp_eq_Int8(lhs._value, rhs._value))
  }
  @_transparent public static func < (lhs: Swift.UInt8, rhs: Swift.UInt8) -> Swift.Bool {
    return Bool(Builtin.cmp_ult_Int8(lhs._value, rhs._value))
  }
  @_transparent public static func += (lhs: inout Swift.UInt8, rhs: Swift.UInt8) {
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1247)
    let (result, overflow) =
      Builtin.uadd_with_overflow_Int8(
        lhs._value, rhs._value, true._value)
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1251)
    Builtin.condfail_message(overflow,
      StaticString("arithmetic overflow").unsafeRawPointer)
    lhs = UInt8(result)
  }
  @_transparent public static func -= (lhs: inout Swift.UInt8, rhs: Swift.UInt8) {
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1247)
    let (result, overflow) =
      Builtin.usub_with_overflow_Int8(
        lhs._value, rhs._value, true._value)
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1251)
    Builtin.condfail_message(overflow,
      StaticString("arithmetic overflow").unsafeRawPointer)
    lhs = UInt8(result)
  }
  @_transparent public static func *= (lhs: inout Swift.UInt8, rhs: Swift.UInt8) {
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1247)
    let (result, overflow) =
      Builtin.umul_with_overflow_Int8(
        lhs._value, rhs._value, true._value)
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1251)
    Builtin.condfail_message(overflow,
      StaticString("arithmetic overflow").unsafeRawPointer)
    lhs = UInt8(result)
  }
  @_transparent public static func /= (lhs: inout Swift.UInt8, rhs: Swift.UInt8) {
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1229)
    // No LLVM primitives for checking overflow of division operations, so we
    // check manually.
    if _slowPath(rhs == (0 as UInt8)) {
      _preconditionFailure(
        "Division by zero")
    }
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1243)
    let (result, overflow) =
      (Builtin.udiv_Int8(lhs._value, rhs._value),
      false._value)
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1251)
    Builtin.condfail_message(overflow,
      StaticString("arithmetic overflow").unsafeRawPointer)
    lhs = UInt8(result)
  }
  @_transparent public func addingReportingOverflow(_ other: Swift.UInt8) -> (partialValue: Swift.UInt8, overflow: Swift.Bool) {
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1282)

    let (newStorage, overflow) =
      Builtin.uadd_with_overflow_Int8(
        self._value, other._value, false._value)
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1287)

    return (
      partialValue: UInt8(newStorage),
      overflow: Bool(overflow))
  }
  @_transparent public func subtractingReportingOverflow(_ other: Swift.UInt8) -> (partialValue: Swift.UInt8, overflow: Swift.Bool) {
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1282)

    let (newStorage, overflow) =
      Builtin.usub_with_overflow_Int8(
        self._value, other._value, false._value)
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1287)

    return (
      partialValue: UInt8(newStorage),
      overflow: Bool(overflow))
  }
  @_transparent public func multipliedReportingOverflow(by other: Swift.UInt8) -> (partialValue: Swift.UInt8, overflow: Swift.Bool) {
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1282)

    let (newStorage, overflow) =
      Builtin.umul_with_overflow_Int8(
        self._value, other._value, false._value)
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1287)

    return (
      partialValue: UInt8(newStorage),
      overflow: Bool(overflow))
  }
  @_transparent public func dividedReportingOverflow(by other: Swift.UInt8) -> (partialValue: Swift.UInt8, overflow: Swift.Bool) {
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1265)
    // No LLVM primitives for checking overflow of division operations, so we
    // check manually.
    if _slowPath(other == (0 as UInt8)) {
      return (partialValue: self, overflow: true)
    }
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1276)

    let (newStorage, overflow) = (
      Builtin.udiv_Int8(self._value, other._value),
      false._value)

// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1287)

    return (
      partialValue: UInt8(newStorage),
      overflow: Bool(overflow))
  }
  @_transparent public func remainderReportingOverflow(dividingBy other: Swift.UInt8) -> (partialValue: Swift.UInt8, overflow: Swift.Bool) {
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1265)
    // No LLVM primitives for checking overflow of division operations, so we
    // check manually.
    if _slowPath(other == (0 as UInt8)) {
      return (partialValue: self, overflow: true)
    }
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1276)

    let (newStorage, overflow) = (
      Builtin.urem_Int8(self._value, other._value),
      false._value)

// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1287)

    return (
      partialValue: UInt8(newStorage),
      overflow: Bool(overflow))
  }
  @_transparent public static func %= (lhs: inout Swift.UInt8, rhs: Swift.UInt8) {
    // No LLVM primitives for checking overflow of division operations, so we
    // check manually.
    if _slowPath(rhs == (0 as UInt8)) {
      _preconditionFailure(
        "Division by zero in remainder operation")
    }
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1309)

    let (newStorage, _) = (
      Builtin.urem_Int8(lhs._value, rhs._value),
      false._value)
    lhs = UInt8(newStorage)
  }
  @_transparent public init(_ _value: Builtin.Int8) {
    self._value = _value
  }
  @_transparent public static func &= (lhs: inout Swift.UInt8, rhs: Swift.UInt8) {
    lhs = UInt8(Builtin.and_Int8(lhs._value, rhs._value))
  }
  @_transparent public static func |= (lhs: inout Swift.UInt8, rhs: Swift.UInt8) {
    lhs = UInt8(Builtin.or_Int8(lhs._value, rhs._value))
  }
  @_transparent public static func ^= (lhs: inout Swift.UInt8, rhs: Swift.UInt8) {
    lhs = UInt8(Builtin.xor_Int8(lhs._value, rhs._value))
  }
  @_transparent public static func &>>= (lhs: inout Swift.UInt8, rhs: Swift.UInt8) {
    let rhs_ = rhs & 7
    lhs = UInt8(
      Builtin.lshr_Int8(lhs._value, rhs_._value))
  }
  @_transparent public static func &<<= (lhs: inout Swift.UInt8, rhs: Swift.UInt8) {
    let rhs_ = rhs & 7
    lhs = UInt8(
      Builtin.shl_Int8(lhs._value, rhs_._value))
  }
  @_transparent public static var bitWidth: Swift.Int {
    @_transparent get { return 8 }
  }
  @_transparent public var leadingZeroBitCount: Swift.Int {
    @_transparent get {
    return Int(
      UInt8(
        Builtin.int_ctlz_Int8(self._value, false._value)
      )._lowWord._value)
  }
  }
  @_transparent public var trailingZeroBitCount: Swift.Int {
    @_transparent get {
    return Int(
      UInt8(
        Builtin.int_cttz_Int8(self._value, false._value)
      )._lowWord._value)
  }
  }
  @_transparent public var nonzeroBitCount: Swift.Int {
    @_transparent get {
    return Int(
      UInt8(
        Builtin.int_ctpop_Int8(self._value)
      )._lowWord._value)
  }
  }
  @frozen public struct Words : Swift.RandomAccessCollection {
    public typealias Indices = Swift.Range<Swift.Int>
    public typealias SubSequence = Swift.Slice<Swift.UInt8.Words>
    @usableFromInline
    internal var _value: Swift.UInt8
    @inlinable public init(_ value: Swift.UInt8) {
      self._value = value
    }
    @inlinable public var count: Swift.Int {
      get {
      return (8 + 64 - 1) / 64
    }
    }
    @inlinable public var startIndex: Swift.Int {
      get { return 0 }
    }
    @inlinable public var endIndex: Swift.Int {
      get { return count }
    }
    @inlinable public var indices: Swift.UInt8.Words.Indices {
      get { return startIndex ..< endIndex }
    }
    @_transparent public func index(after i: Swift.Int) -> Swift.Int { return i + 1 }
    @_transparent public func index(before i: Swift.Int) -> Swift.Int { return i - 1 }
    @inlinable public subscript(position: Swift.Int) -> Swift.UInt {
      get {
        _precondition(position >= 0, "Negative word index")
        _precondition(position < endIndex, "Word index out of range")
        let shift = UInt(position._value) &* 64
        _internalInvariant(shift < UInt(_value.bitWidth._value))
        return (_value &>> UInt8(_truncatingBits: shift))._lowWord
      }
    }
    public typealias Element = Swift.UInt
    public typealias Index = Swift.Int
    public typealias Iterator = Swift.IndexingIterator<Swift.UInt8.Words>
  }
  @_transparent public var words: Swift.UInt8.Words {
    @_transparent get {
    return Words(self)
  }
  }
  @_transparent public var _lowWord: Swift.UInt {
    @_transparent get {
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1462)
    return UInt(
      Builtin.zextOrBitCast_Int8_Int64(_value)
    )
  }
  }
  @_transparent public init(_truncatingBits bits: Swift.UInt) {
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1471)
    self.init(
      Builtin.truncOrBitCast_Int64_Int8(bits._value))
  }
  public typealias Magnitude = Swift.UInt8
  @inlinable public func multipliedFullWidth(by other: Swift.UInt8) -> (high: Swift.UInt8, low: Swift.UInt8.Magnitude) {
    // FIXME(integers): tests
    let lhs_ = Builtin.zext_Int8_Int16(self._value)
    let rhs_ = Builtin.zext_Int8_Int16(other._value)

    let res = Builtin.mul_Int16(lhs_, rhs_)
    let low = UInt8.Magnitude(Builtin.truncOrBitCast_Int16_Int8(res))
    let shift = Builtin.zextOrBitCast_Int8_Int16(UInt8(8)._value)
    let shifted = Builtin.ashr_Int16(res, shift)
    let high = UInt8(Builtin.truncOrBitCast_Int16_Int8(shifted))
    return (high: high, low: low)
  }
  @inlinable public func dividingFullWidth(_ dividend: (high: Swift.UInt8, low: Swift.UInt8.Magnitude)) -> (quotient: Swift.UInt8, remainder: Swift.UInt8) {
    // FIXME(integers): tests
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1572)
    // FIXME(integers): handle division by zero and overflows
    _precondition(self != 0, "Division by zero")
    let lhsHigh = Builtin.zext_Int8_Int16(dividend.high._value)
    let shift = Builtin.zextOrBitCast_Int8_Int16(UInt8(8)._value)
    let lhsHighShifted = Builtin.shl_Int16(lhsHigh, shift)
    let lhsLow = Builtin.zext_Int8_Int16(dividend.low._value)
    let lhs_ = Builtin.or_Int16(lhsHighShifted, lhsLow)
    let rhs_ = Builtin.zext_Int8_Int16(self._value)

    let quotient_ = Builtin.udiv_Int16(lhs_, rhs_)
    let remainder_ = Builtin.urem_Int16(lhs_, rhs_)

    let quotient = UInt8(
      Builtin.truncOrBitCast_Int16_Int8(quotient_))
    let remainder = UInt8(
      Builtin.truncOrBitCast_Int16_Int8(remainder_))

    return (quotient: quotient, remainder: remainder)
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1591)
  }
  @_transparent public var byteSwapped: Swift.UInt8 {
    @_transparent get {
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1597)
    return self
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1601)
  }
  }
  public var _value: Builtin.Int8
  @inlinable @inline(__always) public func signum() -> Swift.UInt8 {
    let isPositive = UInt8(Builtin.zext_Int1_Int8(
      (self > (0 as UInt8))._value))
    return isPositive | (self &>> 7)
  }
  public typealias Stride = Swift.Int
}
extension UInt8 : Swift.Hashable {
  @inlinable public func hash(into hasher: inout Swift.Hasher) {
    hasher._combine(UInt8(_value))
  }
  @inlinable public func _rawHashValue(seed: Swift.Int) -> Swift.Int {
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1662)
    return Hasher._hash(
      seed: seed,
      bytes: UInt64(truncatingIfNeeded: UInt8(_value)),
      count: 1)
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1667)
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension UInt8 : Swift._HasCustomAnyHashableRepresentation {
  public func _toCustomAnyHashable() -> Swift.AnyHashable?
}
extension UInt8 {
  @_transparent public static func & (lhs: Swift.UInt8, rhs: Swift.UInt8) -> Swift.UInt8 {
    var lhs = lhs
    lhs &= rhs
    return lhs
  }
  @_transparent public static func | (lhs: Swift.UInt8, rhs: Swift.UInt8) -> Swift.UInt8 {
    var lhs = lhs
    lhs |= rhs
    return lhs
  }
  @_transparent public static func ^ (lhs: Swift.UInt8, rhs: Swift.UInt8) -> Swift.UInt8 {
    var lhs = lhs
    lhs ^= rhs
    return lhs
  }
  @_transparent public static func &>> (lhs: Swift.UInt8, rhs: Swift.UInt8) -> Swift.UInt8 {
    var lhs = lhs
    lhs &>>= rhs
    return lhs
  }
  @_transparent public static func &<< (lhs: Swift.UInt8, rhs: Swift.UInt8) -> Swift.UInt8 {
    var lhs = lhs
    lhs &<<= rhs
    return lhs
  }
  @_transparent public static func + (lhs: Swift.UInt8, rhs: Swift.UInt8) -> Swift.UInt8 {
    var lhs = lhs
    lhs += rhs
    return lhs
  }
  @_transparent public static func - (lhs: Swift.UInt8, rhs: Swift.UInt8) -> Swift.UInt8 {
    var lhs = lhs
    lhs -= rhs
    return lhs
  }
  @_transparent public static func * (lhs: Swift.UInt8, rhs: Swift.UInt8) -> Swift.UInt8 {
    var lhs = lhs
    lhs *= rhs
    return lhs
  }
  @_transparent public static func / (lhs: Swift.UInt8, rhs: Swift.UInt8) -> Swift.UInt8 {
    var lhs = lhs
    lhs /= rhs
    return lhs
  }
  @_transparent public static func % (lhs: Swift.UInt8, rhs: Swift.UInt8) -> Swift.UInt8 {
    var lhs = lhs
    lhs %= rhs
    return lhs
  }
  @_transparent public static func <= (lhs: Swift.UInt8, rhs: Swift.UInt8) -> Swift.Bool {
    return !(rhs < lhs)
  }
  @_transparent public static func >= (lhs: Swift.UInt8, rhs: Swift.UInt8) -> Swift.Bool {
    return !(lhs < rhs)
  }
  @_transparent public static func > (lhs: Swift.UInt8, rhs: Swift.UInt8) -> Swift.Bool {
    return rhs < lhs
  }
}
@frozen public struct Int8 : Swift.FixedWidthInteger, Swift.SignedInteger, Swift._ExpressibleByBuiltinIntegerLiteral {
  public typealias IntegerLiteralType = Swift.Int8
  @_transparent public init(_builtinIntegerLiteral x: Builtin.IntLiteral) {
    _value = Builtin.s_to_s_checked_trunc_IntLiteral_Int8(x).0
  }
  @_transparent public init(bitPattern x: Swift.UInt8) {
    _value = x._value
  }
  @_transparent public init(_ source: Swift.Float) {
    _precondition(source.isFinite,
      "Float value cannot be converted to Int8 because it is either infinite or NaN")
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1164)
    _precondition(source > -129.0,
      "Float value cannot be converted to Int8 because the result would be less than Int8.min")
    _precondition(source < 128.0,
      "Float value cannot be converted to Int8 because the result would be greater than Int8.max")
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1169)
    self._value = Builtin.fptosi_FPIEEE32_Int8(source._value)
  }
  @_transparent public init?(exactly source: Swift.Float) {
    // The value passed as `source` must not be infinite, NaN, or exceed the
    // bounds of the integer type; the result of `fptosi` or `fptoui` is
    // undefined if it overflows.
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1195)
    guard source > -129.0 && source < 128.0 else {
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1199)
      return nil
    }
    guard source == source.rounded(.towardZero) else {
      return nil
    }
    self._value = Builtin.fptosi_FPIEEE32_Int8(source._value)
  }
  @_transparent public init(_ source: Swift.Double) {
    _precondition(source.isFinite,
      "Double value cannot be converted to Int8 because it is either infinite or NaN")
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1164)
    _precondition(source > -129.0,
      "Double value cannot be converted to Int8 because the result would be less than Int8.min")
    _precondition(source < 128.0,
      "Double value cannot be converted to Int8 because the result would be greater than Int8.max")
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1169)
    self._value = Builtin.fptosi_FPIEEE64_Int8(source._value)
  }
  @_transparent public init?(exactly source: Swift.Double) {
    // The value passed as `source` must not be infinite, NaN, or exceed the
    // bounds of the integer type; the result of `fptosi` or `fptoui` is
    // undefined if it overflows.
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1195)
    guard source > -129.0 && source < 128.0 else {
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1199)
      return nil
    }
    guard source == source.rounded(.towardZero) else {
      return nil
    }
    self._value = Builtin.fptosi_FPIEEE64_Int8(source._value)
  }
  @_transparent public init(_ source: Swift.Float80) {
    _precondition(source.isFinite,
      "Float80 value cannot be converted to Int8 because it is either infinite or NaN")
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1164)
    _precondition(source > -129.0,
      "Float80 value cannot be converted to Int8 because the result would be less than Int8.min")
    _precondition(source < 128.0,
      "Float80 value cannot be converted to Int8 because the result would be greater than Int8.max")
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1169)
    self._value = Builtin.fptosi_FPIEEE80_Int8(source._value)
  }
  @_transparent public init?(exactly source: Swift.Float80) {
    // The value passed as `source` must not be infinite, NaN, or exceed the
    // bounds of the integer type; the result of `fptosi` or `fptoui` is
    // undefined if it overflows.
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1195)
    guard source > -129.0 && source < 128.0 else {
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1199)
      return nil
    }
    guard source == source.rounded(.towardZero) else {
      return nil
    }
    self._value = Builtin.fptosi_FPIEEE80_Int8(source._value)
  }
  @_transparent public static func == (lhs: Swift.Int8, rhs: Swift.Int8) -> Swift.Bool {
    return Bool(Builtin.cmp_eq_Int8(lhs._value, rhs._value))
  }
  @_transparent public static func < (lhs: Swift.Int8, rhs: Swift.Int8) -> Swift.Bool {
    return Bool(Builtin.cmp_slt_Int8(lhs._value, rhs._value))
  }
  @_transparent public static func += (lhs: inout Swift.Int8, rhs: Swift.Int8) {
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1247)
    let (result, overflow) =
      Builtin.sadd_with_overflow_Int8(
        lhs._value, rhs._value, true._value)
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1251)
    Builtin.condfail_message(overflow,
      StaticString("arithmetic overflow").unsafeRawPointer)
    lhs = Int8(result)
  }
  @_transparent public static func -= (lhs: inout Swift.Int8, rhs: Swift.Int8) {
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1247)
    let (result, overflow) =
      Builtin.ssub_with_overflow_Int8(
        lhs._value, rhs._value, true._value)
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1251)
    Builtin.condfail_message(overflow,
      StaticString("arithmetic overflow").unsafeRawPointer)
    lhs = Int8(result)
  }
  @_transparent public static func *= (lhs: inout Swift.Int8, rhs: Swift.Int8) {
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1247)
    let (result, overflow) =
      Builtin.smul_with_overflow_Int8(
        lhs._value, rhs._value, true._value)
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1251)
    Builtin.condfail_message(overflow,
      StaticString("arithmetic overflow").unsafeRawPointer)
    lhs = Int8(result)
  }
  @_transparent public static func /= (lhs: inout Swift.Int8, rhs: Swift.Int8) {
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1229)
    // No LLVM primitives for checking overflow of division operations, so we
    // check manually.
    if _slowPath(rhs == (0 as Int8)) {
      _preconditionFailure(
        "Division by zero")
    }
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1236)
    if _slowPath(
      lhs == Int8.min && rhs == (-1 as Int8)
    ) {
      _preconditionFailure(
        "Division results in an overflow")
    }
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1243)
    let (result, overflow) =
      (Builtin.sdiv_Int8(lhs._value, rhs._value),
      false._value)
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1251)
    Builtin.condfail_message(overflow,
      StaticString("arithmetic overflow").unsafeRawPointer)
    lhs = Int8(result)
  }
  @_transparent public func addingReportingOverflow(_ other: Swift.Int8) -> (partialValue: Swift.Int8, overflow: Swift.Bool) {
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1282)

    let (newStorage, overflow) =
      Builtin.sadd_with_overflow_Int8(
        self._value, other._value, false._value)
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1287)

    return (
      partialValue: Int8(newStorage),
      overflow: Bool(overflow))
  }
  @_transparent public func subtractingReportingOverflow(_ other: Swift.Int8) -> (partialValue: Swift.Int8, overflow: Swift.Bool) {
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1282)

    let (newStorage, overflow) =
      Builtin.ssub_with_overflow_Int8(
        self._value, other._value, false._value)
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1287)

    return (
      partialValue: Int8(newStorage),
      overflow: Bool(overflow))
  }
  @_transparent public func multipliedReportingOverflow(by other: Swift.Int8) -> (partialValue: Swift.Int8, overflow: Swift.Bool) {
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1282)

    let (newStorage, overflow) =
      Builtin.smul_with_overflow_Int8(
        self._value, other._value, false._value)
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1287)

    return (
      partialValue: Int8(newStorage),
      overflow: Bool(overflow))
  }
  @_transparent public func dividedReportingOverflow(by other: Swift.Int8) -> (partialValue: Swift.Int8, overflow: Swift.Bool) {
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1265)
    // No LLVM primitives for checking overflow of division operations, so we
    // check manually.
    if _slowPath(other == (0 as Int8)) {
      return (partialValue: self, overflow: true)
    }
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1271)
    if _slowPath(self == Int8.min && other == (-1 as Int8)) {
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1273)
      return (partialValue: self, overflow: true)
    }
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1276)

    let (newStorage, overflow) = (
      Builtin.sdiv_Int8(self._value, other._value),
      false._value)

// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1287)

    return (
      partialValue: Int8(newStorage),
      overflow: Bool(overflow))
  }
  @_transparent public func remainderReportingOverflow(dividingBy other: Swift.Int8) -> (partialValue: Swift.Int8, overflow: Swift.Bool) {
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1265)
    // No LLVM primitives for checking overflow of division operations, so we
    // check manually.
    if _slowPath(other == (0 as Int8)) {
      return (partialValue: self, overflow: true)
    }
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1271)
    if _slowPath(self == Int8.min && other == (-1 as Int8)) {
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1273)
      return (partialValue: 0, overflow: true)
    }
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1276)

    let (newStorage, overflow) = (
      Builtin.srem_Int8(self._value, other._value),
      false._value)

// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1287)

    return (
      partialValue: Int8(newStorage),
      overflow: Bool(overflow))
  }
  @_transparent public static func %= (lhs: inout Swift.Int8, rhs: Swift.Int8) {
    // No LLVM primitives for checking overflow of division operations, so we
    // check manually.
    if _slowPath(rhs == (0 as Int8)) {
      _preconditionFailure(
        "Division by zero in remainder operation")
    }
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1304)
    if _slowPath(lhs == Int8.min && rhs == (-1 as Int8)) {
      _preconditionFailure(
        "Division results in an overflow in remainder operation")
    }
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1309)

    let (newStorage, _) = (
      Builtin.srem_Int8(lhs._value, rhs._value),
      false._value)
    lhs = Int8(newStorage)
  }
  @_transparent public init(_ _value: Builtin.Int8) {
    self._value = _value
  }
  @_transparent public static func &= (lhs: inout Swift.Int8, rhs: Swift.Int8) {
    lhs = Int8(Builtin.and_Int8(lhs._value, rhs._value))
  }
  @_transparent public static func |= (lhs: inout Swift.Int8, rhs: Swift.Int8) {
    lhs = Int8(Builtin.or_Int8(lhs._value, rhs._value))
  }
  @_transparent public static func ^= (lhs: inout Swift.Int8, rhs: Swift.Int8) {
    lhs = Int8(Builtin.xor_Int8(lhs._value, rhs._value))
  }
  @_transparent public static func &>>= (lhs: inout Swift.Int8, rhs: Swift.Int8) {
    let rhs_ = rhs & 7
    lhs = Int8(
      Builtin.ashr_Int8(lhs._value, rhs_._value))
  }
  @_transparent public static func &<<= (lhs: inout Swift.Int8, rhs: Swift.Int8) {
    let rhs_ = rhs & 7
    lhs = Int8(
      Builtin.shl_Int8(lhs._value, rhs_._value))
  }
  @_transparent public static var bitWidth: Swift.Int {
    @_transparent get { return 8 }
  }
  @_transparent public var leadingZeroBitCount: Swift.Int {
    @_transparent get {
    return Int(
      Int8(
        Builtin.int_ctlz_Int8(self._value, false._value)
      )._lowWord._value)
  }
  }
  @_transparent public var trailingZeroBitCount: Swift.Int {
    @_transparent get {
    return Int(
      Int8(
        Builtin.int_cttz_Int8(self._value, false._value)
      )._lowWord._value)
  }
  }
  @_transparent public var nonzeroBitCount: Swift.Int {
    @_transparent get {
    return Int(
      Int8(
        Builtin.int_ctpop_Int8(self._value)
      )._lowWord._value)
  }
  }
  @frozen public struct Words : Swift.RandomAccessCollection {
    public typealias Indices = Swift.Range<Swift.Int>
    public typealias SubSequence = Swift.Slice<Swift.Int8.Words>
    @usableFromInline
    internal var _value: Swift.Int8
    @inlinable public init(_ value: Swift.Int8) {
      self._value = value
    }
    @inlinable public var count: Swift.Int {
      get {
      return (8 + 64 - 1) / 64
    }
    }
    @inlinable public var startIndex: Swift.Int {
      get { return 0 }
    }
    @inlinable public var endIndex: Swift.Int {
      get { return count }
    }
    @inlinable public var indices: Swift.Int8.Words.Indices {
      get { return startIndex ..< endIndex }
    }
    @_transparent public func index(after i: Swift.Int) -> Swift.Int { return i + 1 }
    @_transparent public func index(before i: Swift.Int) -> Swift.Int { return i - 1 }
    @inlinable public subscript(position: Swift.Int) -> Swift.UInt {
      get {
        _precondition(position >= 0, "Negative word index")
        _precondition(position < endIndex, "Word index out of range")
        let shift = UInt(position._value) &* 64
        _internalInvariant(shift < UInt(_value.bitWidth._value))
        return (_value &>> Int8(_truncatingBits: shift))._lowWord
      }
    }
    public typealias Element = Swift.UInt
    public typealias Index = Swift.Int
    public typealias Iterator = Swift.IndexingIterator<Swift.Int8.Words>
  }
  @_transparent public var words: Swift.Int8.Words {
    @_transparent get {
    return Words(self)
  }
  }
  @_transparent public var _lowWord: Swift.UInt {
    @_transparent get {
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1462)
    return UInt(
      Builtin.sextOrBitCast_Int8_Int64(_value)
    )
  }
  }
  @_transparent public init(_truncatingBits bits: Swift.UInt) {
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1471)
    self.init(
      Builtin.truncOrBitCast_Int64_Int8(bits._value))
  }
  public typealias Magnitude = Swift.UInt8
  @_transparent public var magnitude: Swift.UInt8 {
    @_transparent get {
    let base = UInt8(_value)
    return self < (0 as Int8) ? ~base &+ 1 : base
  }
  }
  @inlinable public func multipliedFullWidth(by other: Swift.Int8) -> (high: Swift.Int8, low: Swift.Int8.Magnitude) {
    // FIXME(integers): tests
    let lhs_ = Builtin.sext_Int8_Int16(self._value)
    let rhs_ = Builtin.sext_Int8_Int16(other._value)

    let res = Builtin.mul_Int16(lhs_, rhs_)
    let low = Int8.Magnitude(Builtin.truncOrBitCast_Int16_Int8(res))
    let shift = Builtin.zextOrBitCast_Int8_Int16(UInt8(8)._value)
    let shifted = Builtin.ashr_Int16(res, shift)
    let high = Int8(Builtin.truncOrBitCast_Int16_Int8(shifted))
    return (high: high, low: low)
  }
  @inlinable public func dividingFullWidth(_ dividend: (high: Swift.Int8, low: Swift.Int8.Magnitude)) -> (quotient: Swift.Int8, remainder: Swift.Int8) {
    // FIXME(integers): tests
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1572)
    // FIXME(integers): handle division by zero and overflows
    _precondition(self != 0, "Division by zero")
    let lhsHigh = Builtin.sext_Int8_Int16(dividend.high._value)
    let shift = Builtin.zextOrBitCast_Int8_Int16(UInt8(8)._value)
    let lhsHighShifted = Builtin.shl_Int16(lhsHigh, shift)
    let lhsLow = Builtin.zext_Int8_Int16(dividend.low._value)
    let lhs_ = Builtin.or_Int16(lhsHighShifted, lhsLow)
    let rhs_ = Builtin.sext_Int8_Int16(self._value)

    let quotient_ = Builtin.sdiv_Int16(lhs_, rhs_)
    let remainder_ = Builtin.srem_Int16(lhs_, rhs_)

    let quotient = Int8(
      Builtin.truncOrBitCast_Int16_Int8(quotient_))
    let remainder = Int8(
      Builtin.truncOrBitCast_Int16_Int8(remainder_))

    return (quotient: quotient, remainder: remainder)
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1591)
  }
  @_transparent public var byteSwapped: Swift.Int8 {
    @_transparent get {
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1597)
    return self
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1601)
  }
  }
  public var _value: Builtin.Int8
  @inlinable @inline(__always) public func signum() -> Swift.Int8 {
    let isPositive = Int8(Builtin.zext_Int1_Int8(
      (self > (0 as Int8))._value))
    return isPositive | (self &>> 7)
  }
  public typealias Stride = Swift.Int
}
extension Int8 : Swift.Hashable {
  @inlinable public func hash(into hasher: inout Swift.Hasher) {
    hasher._combine(UInt8(_value))
  }
  @inlinable public func _rawHashValue(seed: Swift.Int) -> Swift.Int {
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1662)
    return Hasher._hash(
      seed: seed,
      bytes: UInt64(truncatingIfNeeded: UInt8(_value)),
      count: 1)
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1667)
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension Int8 : Swift._HasCustomAnyHashableRepresentation {
  public func _toCustomAnyHashable() -> Swift.AnyHashable?
}
extension Int8 {
  @_transparent public static func & (lhs: Swift.Int8, rhs: Swift.Int8) -> Swift.Int8 {
    var lhs = lhs
    lhs &= rhs
    return lhs
  }
  @_transparent public static func | (lhs: Swift.Int8, rhs: Swift.Int8) -> Swift.Int8 {
    var lhs = lhs
    lhs |= rhs
    return lhs
  }
  @_transparent public static func ^ (lhs: Swift.Int8, rhs: Swift.Int8) -> Swift.Int8 {
    var lhs = lhs
    lhs ^= rhs
    return lhs
  }
  @_transparent public static func &>> (lhs: Swift.Int8, rhs: Swift.Int8) -> Swift.Int8 {
    var lhs = lhs
    lhs &>>= rhs
    return lhs
  }
  @_transparent public static func &<< (lhs: Swift.Int8, rhs: Swift.Int8) -> Swift.Int8 {
    var lhs = lhs
    lhs &<<= rhs
    return lhs
  }
  @_transparent public static func + (lhs: Swift.Int8, rhs: Swift.Int8) -> Swift.Int8 {
    var lhs = lhs
    lhs += rhs
    return lhs
  }
  @_transparent public static func - (lhs: Swift.Int8, rhs: Swift.Int8) -> Swift.Int8 {
    var lhs = lhs
    lhs -= rhs
    return lhs
  }
  @_transparent public static func * (lhs: Swift.Int8, rhs: Swift.Int8) -> Swift.Int8 {
    var lhs = lhs
    lhs *= rhs
    return lhs
  }
  @_transparent public static func / (lhs: Swift.Int8, rhs: Swift.Int8) -> Swift.Int8 {
    var lhs = lhs
    lhs /= rhs
    return lhs
  }
  @_transparent public static func % (lhs: Swift.Int8, rhs: Swift.Int8) -> Swift.Int8 {
    var lhs = lhs
    lhs %= rhs
    return lhs
  }
  @_transparent public static func <= (lhs: Swift.Int8, rhs: Swift.Int8) -> Swift.Bool {
    return !(rhs < lhs)
  }
  @_transparent public static func >= (lhs: Swift.Int8, rhs: Swift.Int8) -> Swift.Bool {
    return !(lhs < rhs)
  }
  @_transparent public static func > (lhs: Swift.Int8, rhs: Swift.Int8) -> Swift.Bool {
    return rhs < lhs
  }
}
@_transparent public func _assumeNonNegative(_ x: Swift.Int8) -> Swift.Int8 {
  _internalInvariant(x >= (0 as Int8))
  return Int8(Builtin.assumeNonNegative_Int8(x._value))
}
@frozen public struct UInt16 : Swift.FixedWidthInteger, Swift.UnsignedInteger, Swift._ExpressibleByBuiltinIntegerLiteral {
  public typealias IntegerLiteralType = Swift.UInt16
  @_transparent public init(_builtinIntegerLiteral x: Builtin.IntLiteral) {
    _value = Builtin.s_to_u_checked_trunc_IntLiteral_Int16(x).0
  }
  @_transparent public init(bitPattern x: Swift.Int16) {
    _value = x._value
  }
  @_transparent public init(_ source: Swift.Float) {
    _precondition(source.isFinite,
      "Float value cannot be converted to UInt16 because it is either infinite or NaN")
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1164)
    _precondition(source > -1.0,
      "Float value cannot be converted to UInt16 because the result would be less than UInt16.min")
    _precondition(source < 65536.0,
      "Float value cannot be converted to UInt16 because the result would be greater than UInt16.max")
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1169)
    self._value = Builtin.fptoui_FPIEEE32_Int16(source._value)
  }
  @_transparent public init?(exactly source: Swift.Float) {
    // The value passed as `source` must not be infinite, NaN, or exceed the
    // bounds of the integer type; the result of `fptosi` or `fptoui` is
    // undefined if it overflows.
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1195)
    guard source > -1.0 && source < 65536.0 else {
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1199)
      return nil
    }
    guard source == source.rounded(.towardZero) else {
      return nil
    }
    self._value = Builtin.fptoui_FPIEEE32_Int16(source._value)
  }
  @_transparent public init(_ source: Swift.Double) {
    _precondition(source.isFinite,
      "Double value cannot be converted to UInt16 because it is either infinite or NaN")
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1164)
    _precondition(source > -1.0,
      "Double value cannot be converted to UInt16 because the result would be less than UInt16.min")
    _precondition(source < 65536.0,
      "Double value cannot be converted to UInt16 because the result would be greater than UInt16.max")
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1169)
    self._value = Builtin.fptoui_FPIEEE64_Int16(source._value)
  }
  @_transparent public init?(exactly source: Swift.Double) {
    // The value passed as `source` must not be infinite, NaN, or exceed the
    // bounds of the integer type; the result of `fptosi` or `fptoui` is
    // undefined if it overflows.
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1195)
    guard source > -1.0 && source < 65536.0 else {
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1199)
      return nil
    }
    guard source == source.rounded(.towardZero) else {
      return nil
    }
    self._value = Builtin.fptoui_FPIEEE64_Int16(source._value)
  }
  @_transparent public init(_ source: Swift.Float80) {
    _precondition(source.isFinite,
      "Float80 value cannot be converted to UInt16 because it is either infinite or NaN")
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1164)
    _precondition(source > -1.0,
      "Float80 value cannot be converted to UInt16 because the result would be less than UInt16.min")
    _precondition(source < 65536.0,
      "Float80 value cannot be converted to UInt16 because the result would be greater than UInt16.max")
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1169)
    self._value = Builtin.fptoui_FPIEEE80_Int16(source._value)
  }
  @_transparent public init?(exactly source: Swift.Float80) {
    // The value passed as `source` must not be infinite, NaN, or exceed the
    // bounds of the integer type; the result of `fptosi` or `fptoui` is
    // undefined if it overflows.
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1195)
    guard source > -1.0 && source < 65536.0 else {
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1199)
      return nil
    }
    guard source == source.rounded(.towardZero) else {
      return nil
    }
    self._value = Builtin.fptoui_FPIEEE80_Int16(source._value)
  }
  @_transparent public static func == (lhs: Swift.UInt16, rhs: Swift.UInt16) -> Swift.Bool {
    return Bool(Builtin.cmp_eq_Int16(lhs._value, rhs._value))
  }
  @_transparent public static func < (lhs: Swift.UInt16, rhs: Swift.UInt16) -> Swift.Bool {
    return Bool(Builtin.cmp_ult_Int16(lhs._value, rhs._value))
  }
  @_transparent public static func += (lhs: inout Swift.UInt16, rhs: Swift.UInt16) {
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1247)
    let (result, overflow) =
      Builtin.uadd_with_overflow_Int16(
        lhs._value, rhs._value, true._value)
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1251)
    Builtin.condfail_message(overflow,
      StaticString("arithmetic overflow").unsafeRawPointer)
    lhs = UInt16(result)
  }
  @_transparent public static func -= (lhs: inout Swift.UInt16, rhs: Swift.UInt16) {
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1247)
    let (result, overflow) =
      Builtin.usub_with_overflow_Int16(
        lhs._value, rhs._value, true._value)
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1251)
    Builtin.condfail_message(overflow,
      StaticString("arithmetic overflow").unsafeRawPointer)
    lhs = UInt16(result)
  }
  @_transparent public static func *= (lhs: inout Swift.UInt16, rhs: Swift.UInt16) {
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1247)
    let (result, overflow) =
      Builtin.umul_with_overflow_Int16(
        lhs._value, rhs._value, true._value)
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1251)
    Builtin.condfail_message(overflow,
      StaticString("arithmetic overflow").unsafeRawPointer)
    lhs = UInt16(result)
  }
  @_transparent public static func /= (lhs: inout Swift.UInt16, rhs: Swift.UInt16) {
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1229)
    // No LLVM primitives for checking overflow of division operations, so we
    // check manually.
    if _slowPath(rhs == (0 as UInt16)) {
      _preconditionFailure(
        "Division by zero")
    }
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1243)
    let (result, overflow) =
      (Builtin.udiv_Int16(lhs._value, rhs._value),
      false._value)
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1251)
    Builtin.condfail_message(overflow,
      StaticString("arithmetic overflow").unsafeRawPointer)
    lhs = UInt16(result)
  }
  @_transparent public func addingReportingOverflow(_ other: Swift.UInt16) -> (partialValue: Swift.UInt16, overflow: Swift.Bool) {
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1282)

    let (newStorage, overflow) =
      Builtin.uadd_with_overflow_Int16(
        self._value, other._value, false._value)
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1287)

    return (
      partialValue: UInt16(newStorage),
      overflow: Bool(overflow))
  }
  @_transparent public func subtractingReportingOverflow(_ other: Swift.UInt16) -> (partialValue: Swift.UInt16, overflow: Swift.Bool) {
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1282)

    let (newStorage, overflow) =
      Builtin.usub_with_overflow_Int16(
        self._value, other._value, false._value)
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1287)

    return (
      partialValue: UInt16(newStorage),
      overflow: Bool(overflow))
  }
  @_transparent public func multipliedReportingOverflow(by other: Swift.UInt16) -> (partialValue: Swift.UInt16, overflow: Swift.Bool) {
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1282)

    let (newStorage, overflow) =
      Builtin.umul_with_overflow_Int16(
        self._value, other._value, false._value)
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1287)

    return (
      partialValue: UInt16(newStorage),
      overflow: Bool(overflow))
  }
  @_transparent public func dividedReportingOverflow(by other: Swift.UInt16) -> (partialValue: Swift.UInt16, overflow: Swift.Bool) {
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1265)
    // No LLVM primitives for checking overflow of division operations, so we
    // check manually.
    if _slowPath(other == (0 as UInt16)) {
      return (partialValue: self, overflow: true)
    }
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1276)

    let (newStorage, overflow) = (
      Builtin.udiv_Int16(self._value, other._value),
      false._value)

// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1287)

    return (
      partialValue: UInt16(newStorage),
      overflow: Bool(overflow))
  }
  @_transparent public func remainderReportingOverflow(dividingBy other: Swift.UInt16) -> (partialValue: Swift.UInt16, overflow: Swift.Bool) {
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1265)
    // No LLVM primitives for checking overflow of division operations, so we
    // check manually.
    if _slowPath(other == (0 as UInt16)) {
      return (partialValue: self, overflow: true)
    }
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1276)

    let (newStorage, overflow) = (
      Builtin.urem_Int16(self._value, other._value),
      false._value)

// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1287)

    return (
      partialValue: UInt16(newStorage),
      overflow: Bool(overflow))
  }
  @_transparent public static func %= (lhs: inout Swift.UInt16, rhs: Swift.UInt16) {
    // No LLVM primitives for checking overflow of division operations, so we
    // check manually.
    if _slowPath(rhs == (0 as UInt16)) {
      _preconditionFailure(
        "Division by zero in remainder operation")
    }
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1309)

    let (newStorage, _) = (
      Builtin.urem_Int16(lhs._value, rhs._value),
      false._value)
    lhs = UInt16(newStorage)
  }
  @_transparent public init(_ _value: Builtin.Int16) {
    self._value = _value
  }
  @_transparent public static func &= (lhs: inout Swift.UInt16, rhs: Swift.UInt16) {
    lhs = UInt16(Builtin.and_Int16(lhs._value, rhs._value))
  }
  @_transparent public static func |= (lhs: inout Swift.UInt16, rhs: Swift.UInt16) {
    lhs = UInt16(Builtin.or_Int16(lhs._value, rhs._value))
  }
  @_transparent public static func ^= (lhs: inout Swift.UInt16, rhs: Swift.UInt16) {
    lhs = UInt16(Builtin.xor_Int16(lhs._value, rhs._value))
  }
  @_transparent public static func &>>= (lhs: inout Swift.UInt16, rhs: Swift.UInt16) {
    let rhs_ = rhs & 15
    lhs = UInt16(
      Builtin.lshr_Int16(lhs._value, rhs_._value))
  }
  @_transparent public static func &<<= (lhs: inout Swift.UInt16, rhs: Swift.UInt16) {
    let rhs_ = rhs & 15
    lhs = UInt16(
      Builtin.shl_Int16(lhs._value, rhs_._value))
  }
  @_transparent public static var bitWidth: Swift.Int {
    @_transparent get { return 16 }
  }
  @_transparent public var leadingZeroBitCount: Swift.Int {
    @_transparent get {
    return Int(
      UInt16(
        Builtin.int_ctlz_Int16(self._value, false._value)
      )._lowWord._value)
  }
  }
  @_transparent public var trailingZeroBitCount: Swift.Int {
    @_transparent get {
    return Int(
      UInt16(
        Builtin.int_cttz_Int16(self._value, false._value)
      )._lowWord._value)
  }
  }
  @_transparent public var nonzeroBitCount: Swift.Int {
    @_transparent get {
    return Int(
      UInt16(
        Builtin.int_ctpop_Int16(self._value)
      )._lowWord._value)
  }
  }
  @frozen public struct Words : Swift.RandomAccessCollection {
    public typealias Indices = Swift.Range<Swift.Int>
    public typealias SubSequence = Swift.Slice<Swift.UInt16.Words>
    @usableFromInline
    internal var _value: Swift.UInt16
    @inlinable public init(_ value: Swift.UInt16) {
      self._value = value
    }
    @inlinable public var count: Swift.Int {
      get {
      return (16 + 64 - 1) / 64
    }
    }
    @inlinable public var startIndex: Swift.Int {
      get { return 0 }
    }
    @inlinable public var endIndex: Swift.Int {
      get { return count }
    }
    @inlinable public var indices: Swift.UInt16.Words.Indices {
      get { return startIndex ..< endIndex }
    }
    @_transparent public func index(after i: Swift.Int) -> Swift.Int { return i + 1 }
    @_transparent public func index(before i: Swift.Int) -> Swift.Int { return i - 1 }
    @inlinable public subscript(position: Swift.Int) -> Swift.UInt {
      get {
        _precondition(position >= 0, "Negative word index")
        _precondition(position < endIndex, "Word index out of range")
        let shift = UInt(position._value) &* 64
        _internalInvariant(shift < UInt(_value.bitWidth._value))
        return (_value &>> UInt16(_truncatingBits: shift))._lowWord
      }
    }
    public typealias Element = Swift.UInt
    public typealias Index = Swift.Int
    public typealias Iterator = Swift.IndexingIterator<Swift.UInt16.Words>
  }
  @_transparent public var words: Swift.UInt16.Words {
    @_transparent get {
    return Words(self)
  }
  }
  @_transparent public var _lowWord: Swift.UInt {
    @_transparent get {
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1462)
    return UInt(
      Builtin.zextOrBitCast_Int16_Int64(_value)
    )
  }
  }
  @_transparent public init(_truncatingBits bits: Swift.UInt) {
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1471)
    self.init(
      Builtin.truncOrBitCast_Int64_Int16(bits._value))
  }
  public typealias Magnitude = Swift.UInt16
  @inlinable public func multipliedFullWidth(by other: Swift.UInt16) -> (high: Swift.UInt16, low: Swift.UInt16.Magnitude) {
    // FIXME(integers): tests
    let lhs_ = Builtin.zext_Int16_Int32(self._value)
    let rhs_ = Builtin.zext_Int16_Int32(other._value)

    let res = Builtin.mul_Int32(lhs_, rhs_)
    let low = UInt16.Magnitude(Builtin.truncOrBitCast_Int32_Int16(res))
    let shift = Builtin.zextOrBitCast_Int8_Int32(UInt8(16)._value)
    let shifted = Builtin.ashr_Int32(res, shift)
    let high = UInt16(Builtin.truncOrBitCast_Int32_Int16(shifted))
    return (high: high, low: low)
  }
  @inlinable public func dividingFullWidth(_ dividend: (high: Swift.UInt16, low: Swift.UInt16.Magnitude)) -> (quotient: Swift.UInt16, remainder: Swift.UInt16) {
    // FIXME(integers): tests
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1572)
    // FIXME(integers): handle division by zero and overflows
    _precondition(self != 0, "Division by zero")
    let lhsHigh = Builtin.zext_Int16_Int32(dividend.high._value)
    let shift = Builtin.zextOrBitCast_Int8_Int32(UInt8(16)._value)
    let lhsHighShifted = Builtin.shl_Int32(lhsHigh, shift)
    let lhsLow = Builtin.zext_Int16_Int32(dividend.low._value)
    let lhs_ = Builtin.or_Int32(lhsHighShifted, lhsLow)
    let rhs_ = Builtin.zext_Int16_Int32(self._value)

    let quotient_ = Builtin.udiv_Int32(lhs_, rhs_)
    let remainder_ = Builtin.urem_Int32(lhs_, rhs_)

    let quotient = UInt16(
      Builtin.truncOrBitCast_Int32_Int16(quotient_))
    let remainder = UInt16(
      Builtin.truncOrBitCast_Int32_Int16(remainder_))

    return (quotient: quotient, remainder: remainder)
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1591)
  }
  @_transparent public var byteSwapped: Swift.UInt16 {
    @_transparent get {
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1599)
    return UInt16(Builtin.int_bswap_Int16(_value))
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1601)
  }
  }
  public var _value: Builtin.Int16
  @inlinable @inline(__always) public func signum() -> Swift.UInt16 {
    let isPositive = UInt16(Builtin.zext_Int1_Int16(
      (self > (0 as UInt16))._value))
    return isPositive | (self &>> 15)
  }
  public typealias Stride = Swift.Int
}
extension UInt16 : Swift.Hashable {
  @inlinable public func hash(into hasher: inout Swift.Hasher) {
    hasher._combine(UInt16(_value))
  }
  @inlinable public func _rawHashValue(seed: Swift.Int) -> Swift.Int {
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1662)
    return Hasher._hash(
      seed: seed,
      bytes: UInt64(truncatingIfNeeded: UInt16(_value)),
      count: 2)
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1667)
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension UInt16 : Swift._HasCustomAnyHashableRepresentation {
  public func _toCustomAnyHashable() -> Swift.AnyHashable?
}
extension UInt16 {
  @_transparent public static func & (lhs: Swift.UInt16, rhs: Swift.UInt16) -> Swift.UInt16 {
    var lhs = lhs
    lhs &= rhs
    return lhs
  }
  @_transparent public static func | (lhs: Swift.UInt16, rhs: Swift.UInt16) -> Swift.UInt16 {
    var lhs = lhs
    lhs |= rhs
    return lhs
  }
  @_transparent public static func ^ (lhs: Swift.UInt16, rhs: Swift.UInt16) -> Swift.UInt16 {
    var lhs = lhs
    lhs ^= rhs
    return lhs
  }
  @_transparent public static func &>> (lhs: Swift.UInt16, rhs: Swift.UInt16) -> Swift.UInt16 {
    var lhs = lhs
    lhs &>>= rhs
    return lhs
  }
  @_transparent public static func &<< (lhs: Swift.UInt16, rhs: Swift.UInt16) -> Swift.UInt16 {
    var lhs = lhs
    lhs &<<= rhs
    return lhs
  }
  @_transparent public static func + (lhs: Swift.UInt16, rhs: Swift.UInt16) -> Swift.UInt16 {
    var lhs = lhs
    lhs += rhs
    return lhs
  }
  @_transparent public static func - (lhs: Swift.UInt16, rhs: Swift.UInt16) -> Swift.UInt16 {
    var lhs = lhs
    lhs -= rhs
    return lhs
  }
  @_transparent public static func * (lhs: Swift.UInt16, rhs: Swift.UInt16) -> Swift.UInt16 {
    var lhs = lhs
    lhs *= rhs
    return lhs
  }
  @_transparent public static func / (lhs: Swift.UInt16, rhs: Swift.UInt16) -> Swift.UInt16 {
    var lhs = lhs
    lhs /= rhs
    return lhs
  }
  @_transparent public static func % (lhs: Swift.UInt16, rhs: Swift.UInt16) -> Swift.UInt16 {
    var lhs = lhs
    lhs %= rhs
    return lhs
  }
  @_transparent public static func <= (lhs: Swift.UInt16, rhs: Swift.UInt16) -> Swift.Bool {
    return !(rhs < lhs)
  }
  @_transparent public static func >= (lhs: Swift.UInt16, rhs: Swift.UInt16) -> Swift.Bool {
    return !(lhs < rhs)
  }
  @_transparent public static func > (lhs: Swift.UInt16, rhs: Swift.UInt16) -> Swift.Bool {
    return rhs < lhs
  }
}
@frozen public struct Int16 : Swift.FixedWidthInteger, Swift.SignedInteger, Swift._ExpressibleByBuiltinIntegerLiteral {
  public typealias IntegerLiteralType = Swift.Int16
  @_transparent public init(_builtinIntegerLiteral x: Builtin.IntLiteral) {
    _value = Builtin.s_to_s_checked_trunc_IntLiteral_Int16(x).0
  }
  @_transparent public init(bitPattern x: Swift.UInt16) {
    _value = x._value
  }
  @_transparent public init(_ source: Swift.Float) {
    _precondition(source.isFinite,
      "Float value cannot be converted to Int16 because it is either infinite or NaN")
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1164)
    _precondition(source > -32769.0,
      "Float value cannot be converted to Int16 because the result would be less than Int16.min")
    _precondition(source < 32768.0,
      "Float value cannot be converted to Int16 because the result would be greater than Int16.max")
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1169)
    self._value = Builtin.fptosi_FPIEEE32_Int16(source._value)
  }
  @_transparent public init?(exactly source: Swift.Float) {
    // The value passed as `source` must not be infinite, NaN, or exceed the
    // bounds of the integer type; the result of `fptosi` or `fptoui` is
    // undefined if it overflows.
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1195)
    guard source > -32769.0 && source < 32768.0 else {
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1199)
      return nil
    }
    guard source == source.rounded(.towardZero) else {
      return nil
    }
    self._value = Builtin.fptosi_FPIEEE32_Int16(source._value)
  }
  @_transparent public init(_ source: Swift.Double) {
    _precondition(source.isFinite,
      "Double value cannot be converted to Int16 because it is either infinite or NaN")
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1164)
    _precondition(source > -32769.0,
      "Double value cannot be converted to Int16 because the result would be less than Int16.min")
    _precondition(source < 32768.0,
      "Double value cannot be converted to Int16 because the result would be greater than Int16.max")
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1169)
    self._value = Builtin.fptosi_FPIEEE64_Int16(source._value)
  }
  @_transparent public init?(exactly source: Swift.Double) {
    // The value passed as `source` must not be infinite, NaN, or exceed the
    // bounds of the integer type; the result of `fptosi` or `fptoui` is
    // undefined if it overflows.
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1195)
    guard source > -32769.0 && source < 32768.0 else {
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1199)
      return nil
    }
    guard source == source.rounded(.towardZero) else {
      return nil
    }
    self._value = Builtin.fptosi_FPIEEE64_Int16(source._value)
  }
  @_transparent public init(_ source: Swift.Float80) {
    _precondition(source.isFinite,
      "Float80 value cannot be converted to Int16 because it is either infinite or NaN")
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1164)
    _precondition(source > -32769.0,
      "Float80 value cannot be converted to Int16 because the result would be less than Int16.min")
    _precondition(source < 32768.0,
      "Float80 value cannot be converted to Int16 because the result would be greater than Int16.max")
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1169)
    self._value = Builtin.fptosi_FPIEEE80_Int16(source._value)
  }
  @_transparent public init?(exactly source: Swift.Float80) {
    // The value passed as `source` must not be infinite, NaN, or exceed the
    // bounds of the integer type; the result of `fptosi` or `fptoui` is
    // undefined if it overflows.
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1195)
    guard source > -32769.0 && source < 32768.0 else {
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1199)
      return nil
    }
    guard source == source.rounded(.towardZero) else {
      return nil
    }
    self._value = Builtin.fptosi_FPIEEE80_Int16(source._value)
  }
  @_transparent public static func == (lhs: Swift.Int16, rhs: Swift.Int16) -> Swift.Bool {
    return Bool(Builtin.cmp_eq_Int16(lhs._value, rhs._value))
  }
  @_transparent public static func < (lhs: Swift.Int16, rhs: Swift.Int16) -> Swift.Bool {
    return Bool(Builtin.cmp_slt_Int16(lhs._value, rhs._value))
  }
  @_transparent public static func += (lhs: inout Swift.Int16, rhs: Swift.Int16) {
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1247)
    let (result, overflow) =
      Builtin.sadd_with_overflow_Int16(
        lhs._value, rhs._value, true._value)
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1251)
    Builtin.condfail_message(overflow,
      StaticString("arithmetic overflow").unsafeRawPointer)
    lhs = Int16(result)
  }
  @_transparent public static func -= (lhs: inout Swift.Int16, rhs: Swift.Int16) {
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1247)
    let (result, overflow) =
      Builtin.ssub_with_overflow_Int16(
        lhs._value, rhs._value, true._value)
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1251)
    Builtin.condfail_message(overflow,
      StaticString("arithmetic overflow").unsafeRawPointer)
    lhs = Int16(result)
  }
  @_transparent public static func *= (lhs: inout Swift.Int16, rhs: Swift.Int16) {
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1247)
    let (result, overflow) =
      Builtin.smul_with_overflow_Int16(
        lhs._value, rhs._value, true._value)
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1251)
    Builtin.condfail_message(overflow,
      StaticString("arithmetic overflow").unsafeRawPointer)
    lhs = Int16(result)
  }
  @_transparent public static func /= (lhs: inout Swift.Int16, rhs: Swift.Int16) {
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1229)
    // No LLVM primitives for checking overflow of division operations, so we
    // check manually.
    if _slowPath(rhs == (0 as Int16)) {
      _preconditionFailure(
        "Division by zero")
    }
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1236)
    if _slowPath(
      lhs == Int16.min && rhs == (-1 as Int16)
    ) {
      _preconditionFailure(
        "Division results in an overflow")
    }
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1243)
    let (result, overflow) =
      (Builtin.sdiv_Int16(lhs._value, rhs._value),
      false._value)
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1251)
    Builtin.condfail_message(overflow,
      StaticString("arithmetic overflow").unsafeRawPointer)
    lhs = Int16(result)
  }
  @_transparent public func addingReportingOverflow(_ other: Swift.Int16) -> (partialValue: Swift.Int16, overflow: Swift.Bool) {
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1282)

    let (newStorage, overflow) =
      Builtin.sadd_with_overflow_Int16(
        self._value, other._value, false._value)
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1287)

    return (
      partialValue: Int16(newStorage),
      overflow: Bool(overflow))
  }
  @_transparent public func subtractingReportingOverflow(_ other: Swift.Int16) -> (partialValue: Swift.Int16, overflow: Swift.Bool) {
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1282)

    let (newStorage, overflow) =
      Builtin.ssub_with_overflow_Int16(
        self._value, other._value, false._value)
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1287)

    return (
      partialValue: Int16(newStorage),
      overflow: Bool(overflow))
  }
  @_transparent public func multipliedReportingOverflow(by other: Swift.Int16) -> (partialValue: Swift.Int16, overflow: Swift.Bool) {
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1282)

    let (newStorage, overflow) =
      Builtin.smul_with_overflow_Int16(
        self._value, other._value, false._value)
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1287)

    return (
      partialValue: Int16(newStorage),
      overflow: Bool(overflow))
  }
  @_transparent public func dividedReportingOverflow(by other: Swift.Int16) -> (partialValue: Swift.Int16, overflow: Swift.Bool) {
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1265)
    // No LLVM primitives for checking overflow of division operations, so we
    // check manually.
    if _slowPath(other == (0 as Int16)) {
      return (partialValue: self, overflow: true)
    }
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1271)
    if _slowPath(self == Int16.min && other == (-1 as Int16)) {
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1273)
      return (partialValue: self, overflow: true)
    }
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1276)

    let (newStorage, overflow) = (
      Builtin.sdiv_Int16(self._value, other._value),
      false._value)

// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1287)

    return (
      partialValue: Int16(newStorage),
      overflow: Bool(overflow))
  }
  @_transparent public func remainderReportingOverflow(dividingBy other: Swift.Int16) -> (partialValue: Swift.Int16, overflow: Swift.Bool) {
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1265)
    // No LLVM primitives for checking overflow of division operations, so we
    // check manually.
    if _slowPath(other == (0 as Int16)) {
      return (partialValue: self, overflow: true)
    }
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1271)
    if _slowPath(self == Int16.min && other == (-1 as Int16)) {
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1273)
      return (partialValue: 0, overflow: true)
    }
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1276)

    let (newStorage, overflow) = (
      Builtin.srem_Int16(self._value, other._value),
      false._value)

// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1287)

    return (
      partialValue: Int16(newStorage),
      overflow: Bool(overflow))
  }
  @_transparent public static func %= (lhs: inout Swift.Int16, rhs: Swift.Int16) {
    // No LLVM primitives for checking overflow of division operations, so we
    // check manually.
    if _slowPath(rhs == (0 as Int16)) {
      _preconditionFailure(
        "Division by zero in remainder operation")
    }
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1304)
    if _slowPath(lhs == Int16.min && rhs == (-1 as Int16)) {
      _preconditionFailure(
        "Division results in an overflow in remainder operation")
    }
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1309)

    let (newStorage, _) = (
      Builtin.srem_Int16(lhs._value, rhs._value),
      false._value)
    lhs = Int16(newStorage)
  }
  @_transparent public init(_ _value: Builtin.Int16) {
    self._value = _value
  }
  @_transparent public static func &= (lhs: inout Swift.Int16, rhs: Swift.Int16) {
    lhs = Int16(Builtin.and_Int16(lhs._value, rhs._value))
  }
  @_transparent public static func |= (lhs: inout Swift.Int16, rhs: Swift.Int16) {
    lhs = Int16(Builtin.or_Int16(lhs._value, rhs._value))
  }
  @_transparent public static func ^= (lhs: inout Swift.Int16, rhs: Swift.Int16) {
    lhs = Int16(Builtin.xor_Int16(lhs._value, rhs._value))
  }
  @_transparent public static func &>>= (lhs: inout Swift.Int16, rhs: Swift.Int16) {
    let rhs_ = rhs & 15
    lhs = Int16(
      Builtin.ashr_Int16(lhs._value, rhs_._value))
  }
  @_transparent public static func &<<= (lhs: inout Swift.Int16, rhs: Swift.Int16) {
    let rhs_ = rhs & 15
    lhs = Int16(
      Builtin.shl_Int16(lhs._value, rhs_._value))
  }
  @_transparent public static var bitWidth: Swift.Int {
    @_transparent get { return 16 }
  }
  @_transparent public var leadingZeroBitCount: Swift.Int {
    @_transparent get {
    return Int(
      Int16(
        Builtin.int_ctlz_Int16(self._value, false._value)
      )._lowWord._value)
  }
  }
  @_transparent public var trailingZeroBitCount: Swift.Int {
    @_transparent get {
    return Int(
      Int16(
        Builtin.int_cttz_Int16(self._value, false._value)
      )._lowWord._value)
  }
  }
  @_transparent public var nonzeroBitCount: Swift.Int {
    @_transparent get {
    return Int(
      Int16(
        Builtin.int_ctpop_Int16(self._value)
      )._lowWord._value)
  }
  }
  @frozen public struct Words : Swift.RandomAccessCollection {
    public typealias Indices = Swift.Range<Swift.Int>
    public typealias SubSequence = Swift.Slice<Swift.Int16.Words>
    @usableFromInline
    internal var _value: Swift.Int16
    @inlinable public init(_ value: Swift.Int16) {
      self._value = value
    }
    @inlinable public var count: Swift.Int {
      get {
      return (16 + 64 - 1) / 64
    }
    }
    @inlinable public var startIndex: Swift.Int {
      get { return 0 }
    }
    @inlinable public var endIndex: Swift.Int {
      get { return count }
    }
    @inlinable public var indices: Swift.Int16.Words.Indices {
      get { return startIndex ..< endIndex }
    }
    @_transparent public func index(after i: Swift.Int) -> Swift.Int { return i + 1 }
    @_transparent public func index(before i: Swift.Int) -> Swift.Int { return i - 1 }
    @inlinable public subscript(position: Swift.Int) -> Swift.UInt {
      get {
        _precondition(position >= 0, "Negative word index")
        _precondition(position < endIndex, "Word index out of range")
        let shift = UInt(position._value) &* 64
        _internalInvariant(shift < UInt(_value.bitWidth._value))
        return (_value &>> Int16(_truncatingBits: shift))._lowWord
      }
    }
    public typealias Element = Swift.UInt
    public typealias Index = Swift.Int
    public typealias Iterator = Swift.IndexingIterator<Swift.Int16.Words>
  }
  @_transparent public var words: Swift.Int16.Words {
    @_transparent get {
    return Words(self)
  }
  }
  @_transparent public var _lowWord: Swift.UInt {
    @_transparent get {
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1462)
    return UInt(
      Builtin.sextOrBitCast_Int16_Int64(_value)
    )
  }
  }
  @_transparent public init(_truncatingBits bits: Swift.UInt) {
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1471)
    self.init(
      Builtin.truncOrBitCast_Int64_Int16(bits._value))
  }
  public typealias Magnitude = Swift.UInt16
  @_transparent public var magnitude: Swift.UInt16 {
    @_transparent get {
    let base = UInt16(_value)
    return self < (0 as Int16) ? ~base &+ 1 : base
  }
  }
  @inlinable public func multipliedFullWidth(by other: Swift.Int16) -> (high: Swift.Int16, low: Swift.Int16.Magnitude) {
    // FIXME(integers): tests
    let lhs_ = Builtin.sext_Int16_Int32(self._value)
    let rhs_ = Builtin.sext_Int16_Int32(other._value)

    let res = Builtin.mul_Int32(lhs_, rhs_)
    let low = Int16.Magnitude(Builtin.truncOrBitCast_Int32_Int16(res))
    let shift = Builtin.zextOrBitCast_Int8_Int32(UInt8(16)._value)
    let shifted = Builtin.ashr_Int32(res, shift)
    let high = Int16(Builtin.truncOrBitCast_Int32_Int16(shifted))
    return (high: high, low: low)
  }
  @inlinable public func dividingFullWidth(_ dividend: (high: Swift.Int16, low: Swift.Int16.Magnitude)) -> (quotient: Swift.Int16, remainder: Swift.Int16) {
    // FIXME(integers): tests
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1572)
    // FIXME(integers): handle division by zero and overflows
    _precondition(self != 0, "Division by zero")
    let lhsHigh = Builtin.sext_Int16_Int32(dividend.high._value)
    let shift = Builtin.zextOrBitCast_Int8_Int32(UInt8(16)._value)
    let lhsHighShifted = Builtin.shl_Int32(lhsHigh, shift)
    let lhsLow = Builtin.zext_Int16_Int32(dividend.low._value)
    let lhs_ = Builtin.or_Int32(lhsHighShifted, lhsLow)
    let rhs_ = Builtin.sext_Int16_Int32(self._value)

    let quotient_ = Builtin.sdiv_Int32(lhs_, rhs_)
    let remainder_ = Builtin.srem_Int32(lhs_, rhs_)

    let quotient = Int16(
      Builtin.truncOrBitCast_Int32_Int16(quotient_))
    let remainder = Int16(
      Builtin.truncOrBitCast_Int32_Int16(remainder_))

    return (quotient: quotient, remainder: remainder)
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1591)
  }
  @_transparent public var byteSwapped: Swift.Int16 {
    @_transparent get {
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1599)
    return Int16(Builtin.int_bswap_Int16(_value))
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1601)
  }
  }
  public var _value: Builtin.Int16
  @inlinable @inline(__always) public func signum() -> Swift.Int16 {
    let isPositive = Int16(Builtin.zext_Int1_Int16(
      (self > (0 as Int16))._value))
    return isPositive | (self &>> 15)
  }
  public typealias Stride = Swift.Int
}
extension Int16 : Swift.Hashable {
  @inlinable public func hash(into hasher: inout Swift.Hasher) {
    hasher._combine(UInt16(_value))
  }
  @inlinable public func _rawHashValue(seed: Swift.Int) -> Swift.Int {
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1662)
    return Hasher._hash(
      seed: seed,
      bytes: UInt64(truncatingIfNeeded: UInt16(_value)),
      count: 2)
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1667)
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension Int16 : Swift._HasCustomAnyHashableRepresentation {
  public func _toCustomAnyHashable() -> Swift.AnyHashable?
}
extension Int16 {
  @_transparent public static func & (lhs: Swift.Int16, rhs: Swift.Int16) -> Swift.Int16 {
    var lhs = lhs
    lhs &= rhs
    return lhs
  }
  @_transparent public static func | (lhs: Swift.Int16, rhs: Swift.Int16) -> Swift.Int16 {
    var lhs = lhs
    lhs |= rhs
    return lhs
  }
  @_transparent public static func ^ (lhs: Swift.Int16, rhs: Swift.Int16) -> Swift.Int16 {
    var lhs = lhs
    lhs ^= rhs
    return lhs
  }
  @_transparent public static func &>> (lhs: Swift.Int16, rhs: Swift.Int16) -> Swift.Int16 {
    var lhs = lhs
    lhs &>>= rhs
    return lhs
  }
  @_transparent public static func &<< (lhs: Swift.Int16, rhs: Swift.Int16) -> Swift.Int16 {
    var lhs = lhs
    lhs &<<= rhs
    return lhs
  }
  @_transparent public static func + (lhs: Swift.Int16, rhs: Swift.Int16) -> Swift.Int16 {
    var lhs = lhs
    lhs += rhs
    return lhs
  }
  @_transparent public static func - (lhs: Swift.Int16, rhs: Swift.Int16) -> Swift.Int16 {
    var lhs = lhs
    lhs -= rhs
    return lhs
  }
  @_transparent public static func * (lhs: Swift.Int16, rhs: Swift.Int16) -> Swift.Int16 {
    var lhs = lhs
    lhs *= rhs
    return lhs
  }
  @_transparent public static func / (lhs: Swift.Int16, rhs: Swift.Int16) -> Swift.Int16 {
    var lhs = lhs
    lhs /= rhs
    return lhs
  }
  @_transparent public static func % (lhs: Swift.Int16, rhs: Swift.Int16) -> Swift.Int16 {
    var lhs = lhs
    lhs %= rhs
    return lhs
  }
  @_transparent public static func <= (lhs: Swift.Int16, rhs: Swift.Int16) -> Swift.Bool {
    return !(rhs < lhs)
  }
  @_transparent public static func >= (lhs: Swift.Int16, rhs: Swift.Int16) -> Swift.Bool {
    return !(lhs < rhs)
  }
  @_transparent public static func > (lhs: Swift.Int16, rhs: Swift.Int16) -> Swift.Bool {
    return rhs < lhs
  }
}
@_transparent public func _assumeNonNegative(_ x: Swift.Int16) -> Swift.Int16 {
  _internalInvariant(x >= (0 as Int16))
  return Int16(Builtin.assumeNonNegative_Int16(x._value))
}
@frozen public struct UInt32 : Swift.FixedWidthInteger, Swift.UnsignedInteger, Swift._ExpressibleByBuiltinIntegerLiteral {
  public typealias IntegerLiteralType = Swift.UInt32
  @_transparent public init(_builtinIntegerLiteral x: Builtin.IntLiteral) {
    _value = Builtin.s_to_u_checked_trunc_IntLiteral_Int32(x).0
  }
  @_transparent public init(bitPattern x: Swift.Int32) {
    _value = x._value
  }
  @_transparent public init(_ source: Swift.Float) {
    _precondition(source.isFinite,
      "Float value cannot be converted to UInt32 because it is either infinite or NaN")
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1164)
    _precondition(source > -1.0,
      "Float value cannot be converted to UInt32 because the result would be less than UInt32.min")
    _precondition(source < 4294967296.0,
      "Float value cannot be converted to UInt32 because the result would be greater than UInt32.max")
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1169)
    self._value = Builtin.fptoui_FPIEEE32_Int32(source._value)
  }
  @_transparent public init?(exactly source: Swift.Float) {
    // The value passed as `source` must not be infinite, NaN, or exceed the
    // bounds of the integer type; the result of `fptosi` or `fptoui` is
    // undefined if it overflows.
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1195)
    guard source > -1.0 && source < 4294967296.0 else {
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1199)
      return nil
    }
    guard source == source.rounded(.towardZero) else {
      return nil
    }
    self._value = Builtin.fptoui_FPIEEE32_Int32(source._value)
  }
  @_transparent public init(_ source: Swift.Double) {
    _precondition(source.isFinite,
      "Double value cannot be converted to UInt32 because it is either infinite or NaN")
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1164)
    _precondition(source > -1.0,
      "Double value cannot be converted to UInt32 because the result would be less than UInt32.min")
    _precondition(source < 4294967296.0,
      "Double value cannot be converted to UInt32 because the result would be greater than UInt32.max")
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1169)
    self._value = Builtin.fptoui_FPIEEE64_Int32(source._value)
  }
  @_transparent public init?(exactly source: Swift.Double) {
    // The value passed as `source` must not be infinite, NaN, or exceed the
    // bounds of the integer type; the result of `fptosi` or `fptoui` is
    // undefined if it overflows.
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1195)
    guard source > -1.0 && source < 4294967296.0 else {
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1199)
      return nil
    }
    guard source == source.rounded(.towardZero) else {
      return nil
    }
    self._value = Builtin.fptoui_FPIEEE64_Int32(source._value)
  }
  @_transparent public init(_ source: Swift.Float80) {
    _precondition(source.isFinite,
      "Float80 value cannot be converted to UInt32 because it is either infinite or NaN")
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1164)
    _precondition(source > -1.0,
      "Float80 value cannot be converted to UInt32 because the result would be less than UInt32.min")
    _precondition(source < 4294967296.0,
      "Float80 value cannot be converted to UInt32 because the result would be greater than UInt32.max")
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1169)
    self._value = Builtin.fptoui_FPIEEE80_Int32(source._value)
  }
  @_transparent public init?(exactly source: Swift.Float80) {
    // The value passed as `source` must not be infinite, NaN, or exceed the
    // bounds of the integer type; the result of `fptosi` or `fptoui` is
    // undefined if it overflows.
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1195)
    guard source > -1.0 && source < 4294967296.0 else {
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1199)
      return nil
    }
    guard source == source.rounded(.towardZero) else {
      return nil
    }
    self._value = Builtin.fptoui_FPIEEE80_Int32(source._value)
  }
  @_transparent public static func == (lhs: Swift.UInt32, rhs: Swift.UInt32) -> Swift.Bool {
    return Bool(Builtin.cmp_eq_Int32(lhs._value, rhs._value))
  }
  @_transparent public static func < (lhs: Swift.UInt32, rhs: Swift.UInt32) -> Swift.Bool {
    return Bool(Builtin.cmp_ult_Int32(lhs._value, rhs._value))
  }
  @_transparent public static func += (lhs: inout Swift.UInt32, rhs: Swift.UInt32) {
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1247)
    let (result, overflow) =
      Builtin.uadd_with_overflow_Int32(
        lhs._value, rhs._value, true._value)
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1251)
    Builtin.condfail_message(overflow,
      StaticString("arithmetic overflow").unsafeRawPointer)
    lhs = UInt32(result)
  }
  @_transparent public static func -= (lhs: inout Swift.UInt32, rhs: Swift.UInt32) {
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1247)
    let (result, overflow) =
      Builtin.usub_with_overflow_Int32(
        lhs._value, rhs._value, true._value)
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1251)
    Builtin.condfail_message(overflow,
      StaticString("arithmetic overflow").unsafeRawPointer)
    lhs = UInt32(result)
  }
  @_transparent public static func *= (lhs: inout Swift.UInt32, rhs: Swift.UInt32) {
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1247)
    let (result, overflow) =
      Builtin.umul_with_overflow_Int32(
        lhs._value, rhs._value, true._value)
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1251)
    Builtin.condfail_message(overflow,
      StaticString("arithmetic overflow").unsafeRawPointer)
    lhs = UInt32(result)
  }
  @_transparent public static func /= (lhs: inout Swift.UInt32, rhs: Swift.UInt32) {
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1229)
    // No LLVM primitives for checking overflow of division operations, so we
    // check manually.
    if _slowPath(rhs == (0 as UInt32)) {
      _preconditionFailure(
        "Division by zero")
    }
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1243)
    let (result, overflow) =
      (Builtin.udiv_Int32(lhs._value, rhs._value),
      false._value)
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1251)
    Builtin.condfail_message(overflow,
      StaticString("arithmetic overflow").unsafeRawPointer)
    lhs = UInt32(result)
  }
  @_transparent public func addingReportingOverflow(_ other: Swift.UInt32) -> (partialValue: Swift.UInt32, overflow: Swift.Bool) {
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1282)

    let (newStorage, overflow) =
      Builtin.uadd_with_overflow_Int32(
        self._value, other._value, false._value)
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1287)

    return (
      partialValue: UInt32(newStorage),
      overflow: Bool(overflow))
  }
  @_transparent public func subtractingReportingOverflow(_ other: Swift.UInt32) -> (partialValue: Swift.UInt32, overflow: Swift.Bool) {
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1282)

    let (newStorage, overflow) =
      Builtin.usub_with_overflow_Int32(
        self._value, other._value, false._value)
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1287)

    return (
      partialValue: UInt32(newStorage),
      overflow: Bool(overflow))
  }
  @_transparent public func multipliedReportingOverflow(by other: Swift.UInt32) -> (partialValue: Swift.UInt32, overflow: Swift.Bool) {
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1282)

    let (newStorage, overflow) =
      Builtin.umul_with_overflow_Int32(
        self._value, other._value, false._value)
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1287)

    return (
      partialValue: UInt32(newStorage),
      overflow: Bool(overflow))
  }
  @_transparent public func dividedReportingOverflow(by other: Swift.UInt32) -> (partialValue: Swift.UInt32, overflow: Swift.Bool) {
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1265)
    // No LLVM primitives for checking overflow of division operations, so we
    // check manually.
    if _slowPath(other == (0 as UInt32)) {
      return (partialValue: self, overflow: true)
    }
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1276)

    let (newStorage, overflow) = (
      Builtin.udiv_Int32(self._value, other._value),
      false._value)

// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1287)

    return (
      partialValue: UInt32(newStorage),
      overflow: Bool(overflow))
  }
  @_transparent public func remainderReportingOverflow(dividingBy other: Swift.UInt32) -> (partialValue: Swift.UInt32, overflow: Swift.Bool) {
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1265)
    // No LLVM primitives for checking overflow of division operations, so we
    // check manually.
    if _slowPath(other == (0 as UInt32)) {
      return (partialValue: self, overflow: true)
    }
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1276)

    let (newStorage, overflow) = (
      Builtin.urem_Int32(self._value, other._value),
      false._value)

// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1287)

    return (
      partialValue: UInt32(newStorage),
      overflow: Bool(overflow))
  }
  @_transparent public static func %= (lhs: inout Swift.UInt32, rhs: Swift.UInt32) {
    // No LLVM primitives for checking overflow of division operations, so we
    // check manually.
    if _slowPath(rhs == (0 as UInt32)) {
      _preconditionFailure(
        "Division by zero in remainder operation")
    }
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1309)

    let (newStorage, _) = (
      Builtin.urem_Int32(lhs._value, rhs._value),
      false._value)
    lhs = UInt32(newStorage)
  }
  @_transparent public init(_ _value: Builtin.Int32) {
    self._value = _value
  }
  @_transparent public static func &= (lhs: inout Swift.UInt32, rhs: Swift.UInt32) {
    lhs = UInt32(Builtin.and_Int32(lhs._value, rhs._value))
  }
  @_transparent public static func |= (lhs: inout Swift.UInt32, rhs: Swift.UInt32) {
    lhs = UInt32(Builtin.or_Int32(lhs._value, rhs._value))
  }
  @_transparent public static func ^= (lhs: inout Swift.UInt32, rhs: Swift.UInt32) {
    lhs = UInt32(Builtin.xor_Int32(lhs._value, rhs._value))
  }
  @_transparent public static func &>>= (lhs: inout Swift.UInt32, rhs: Swift.UInt32) {
    let rhs_ = rhs & 31
    lhs = UInt32(
      Builtin.lshr_Int32(lhs._value, rhs_._value))
  }
  @_transparent public static func &<<= (lhs: inout Swift.UInt32, rhs: Swift.UInt32) {
    let rhs_ = rhs & 31
    lhs = UInt32(
      Builtin.shl_Int32(lhs._value, rhs_._value))
  }
  @_transparent public static var bitWidth: Swift.Int {
    @_transparent get { return 32 }
  }
  @_transparent public var leadingZeroBitCount: Swift.Int {
    @_transparent get {
    return Int(
      UInt32(
        Builtin.int_ctlz_Int32(self._value, false._value)
      )._lowWord._value)
  }
  }
  @_transparent public var trailingZeroBitCount: Swift.Int {
    @_transparent get {
    return Int(
      UInt32(
        Builtin.int_cttz_Int32(self._value, false._value)
      )._lowWord._value)
  }
  }
  @_transparent public var nonzeroBitCount: Swift.Int {
    @_transparent get {
    return Int(
      UInt32(
        Builtin.int_ctpop_Int32(self._value)
      )._lowWord._value)
  }
  }
  @frozen public struct Words : Swift.RandomAccessCollection {
    public typealias Indices = Swift.Range<Swift.Int>
    public typealias SubSequence = Swift.Slice<Swift.UInt32.Words>
    @usableFromInline
    internal var _value: Swift.UInt32
    @inlinable public init(_ value: Swift.UInt32) {
      self._value = value
    }
    @inlinable public var count: Swift.Int {
      get {
      return (32 + 64 - 1) / 64
    }
    }
    @inlinable public var startIndex: Swift.Int {
      get { return 0 }
    }
    @inlinable public var endIndex: Swift.Int {
      get { return count }
    }
    @inlinable public var indices: Swift.UInt32.Words.Indices {
      get { return startIndex ..< endIndex }
    }
    @_transparent public func index(after i: Swift.Int) -> Swift.Int { return i + 1 }
    @_transparent public func index(before i: Swift.Int) -> Swift.Int { return i - 1 }
    @inlinable public subscript(position: Swift.Int) -> Swift.UInt {
      get {
        _precondition(position >= 0, "Negative word index")
        _precondition(position < endIndex, "Word index out of range")
        let shift = UInt(position._value) &* 64
        _internalInvariant(shift < UInt(_value.bitWidth._value))
        return (_value &>> UInt32(_truncatingBits: shift))._lowWord
      }
    }
    public typealias Element = Swift.UInt
    public typealias Index = Swift.Int
    public typealias Iterator = Swift.IndexingIterator<Swift.UInt32.Words>
  }
  @_transparent public var words: Swift.UInt32.Words {
    @_transparent get {
    return Words(self)
  }
  }
  @_transparent public var _lowWord: Swift.UInt {
    @_transparent get {
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1462)
    return UInt(
      Builtin.zextOrBitCast_Int32_Int64(_value)
    )
  }
  }
  @_transparent public init(_truncatingBits bits: Swift.UInt) {
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1471)
    self.init(
      Builtin.truncOrBitCast_Int64_Int32(bits._value))
  }
  public typealias Magnitude = Swift.UInt32
  @inlinable public func multipliedFullWidth(by other: Swift.UInt32) -> (high: Swift.UInt32, low: Swift.UInt32.Magnitude) {
    // FIXME(integers): tests
    let lhs_ = Builtin.zext_Int32_Int64(self._value)
    let rhs_ = Builtin.zext_Int32_Int64(other._value)

    let res = Builtin.mul_Int64(lhs_, rhs_)
    let low = UInt32.Magnitude(Builtin.truncOrBitCast_Int64_Int32(res))
    let shift = Builtin.zextOrBitCast_Int8_Int64(UInt8(32)._value)
    let shifted = Builtin.ashr_Int64(res, shift)
    let high = UInt32(Builtin.truncOrBitCast_Int64_Int32(shifted))
    return (high: high, low: low)
  }
  @inlinable public func dividingFullWidth(_ dividend: (high: Swift.UInt32, low: Swift.UInt32.Magnitude)) -> (quotient: Swift.UInt32, remainder: Swift.UInt32) {
    // FIXME(integers): tests
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1572)
    // FIXME(integers): handle division by zero and overflows
    _precondition(self != 0, "Division by zero")
    let lhsHigh = Builtin.zext_Int32_Int64(dividend.high._value)
    let shift = Builtin.zextOrBitCast_Int8_Int64(UInt8(32)._value)
    let lhsHighShifted = Builtin.shl_Int64(lhsHigh, shift)
    let lhsLow = Builtin.zext_Int32_Int64(dividend.low._value)
    let lhs_ = Builtin.or_Int64(lhsHighShifted, lhsLow)
    let rhs_ = Builtin.zext_Int32_Int64(self._value)

    let quotient_ = Builtin.udiv_Int64(lhs_, rhs_)
    let remainder_ = Builtin.urem_Int64(lhs_, rhs_)

    let quotient = UInt32(
      Builtin.truncOrBitCast_Int64_Int32(quotient_))
    let remainder = UInt32(
      Builtin.truncOrBitCast_Int64_Int32(remainder_))

    return (quotient: quotient, remainder: remainder)
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1591)
  }
  @_transparent public var byteSwapped: Swift.UInt32 {
    @_transparent get {
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1599)
    return UInt32(Builtin.int_bswap_Int32(_value))
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1601)
  }
  }
  public var _value: Builtin.Int32
  @inlinable @inline(__always) public func signum() -> Swift.UInt32 {
    let isPositive = UInt32(Builtin.zext_Int1_Int32(
      (self > (0 as UInt32))._value))
    return isPositive | (self &>> 31)
  }
  public typealias Stride = Swift.Int
}
extension UInt32 : Swift.Hashable {
  @inlinable public func hash(into hasher: inout Swift.Hasher) {
    hasher._combine(UInt32(_value))
  }
  @inlinable public func _rawHashValue(seed: Swift.Int) -> Swift.Int {
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1662)
    return Hasher._hash(
      seed: seed,
      bytes: UInt64(truncatingIfNeeded: UInt32(_value)),
      count: 4)
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1667)
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension UInt32 : Swift._HasCustomAnyHashableRepresentation {
  public func _toCustomAnyHashable() -> Swift.AnyHashable?
}
extension UInt32 {
  @_transparent public static func & (lhs: Swift.UInt32, rhs: Swift.UInt32) -> Swift.UInt32 {
    var lhs = lhs
    lhs &= rhs
    return lhs
  }
  @_transparent public static func | (lhs: Swift.UInt32, rhs: Swift.UInt32) -> Swift.UInt32 {
    var lhs = lhs
    lhs |= rhs
    return lhs
  }
  @_transparent public static func ^ (lhs: Swift.UInt32, rhs: Swift.UInt32) -> Swift.UInt32 {
    var lhs = lhs
    lhs ^= rhs
    return lhs
  }
  @_transparent public static func &>> (lhs: Swift.UInt32, rhs: Swift.UInt32) -> Swift.UInt32 {
    var lhs = lhs
    lhs &>>= rhs
    return lhs
  }
  @_transparent public static func &<< (lhs: Swift.UInt32, rhs: Swift.UInt32) -> Swift.UInt32 {
    var lhs = lhs
    lhs &<<= rhs
    return lhs
  }
  @_transparent public static func + (lhs: Swift.UInt32, rhs: Swift.UInt32) -> Swift.UInt32 {
    var lhs = lhs
    lhs += rhs
    return lhs
  }
  @_transparent public static func - (lhs: Swift.UInt32, rhs: Swift.UInt32) -> Swift.UInt32 {
    var lhs = lhs
    lhs -= rhs
    return lhs
  }
  @_transparent public static func * (lhs: Swift.UInt32, rhs: Swift.UInt32) -> Swift.UInt32 {
    var lhs = lhs
    lhs *= rhs
    return lhs
  }
  @_transparent public static func / (lhs: Swift.UInt32, rhs: Swift.UInt32) -> Swift.UInt32 {
    var lhs = lhs
    lhs /= rhs
    return lhs
  }
  @_transparent public static func % (lhs: Swift.UInt32, rhs: Swift.UInt32) -> Swift.UInt32 {
    var lhs = lhs
    lhs %= rhs
    return lhs
  }
  @_transparent public static func <= (lhs: Swift.UInt32, rhs: Swift.UInt32) -> Swift.Bool {
    return !(rhs < lhs)
  }
  @_transparent public static func >= (lhs: Swift.UInt32, rhs: Swift.UInt32) -> Swift.Bool {
    return !(lhs < rhs)
  }
  @_transparent public static func > (lhs: Swift.UInt32, rhs: Swift.UInt32) -> Swift.Bool {
    return rhs < lhs
  }
}
@frozen public struct Int32 : Swift.FixedWidthInteger, Swift.SignedInteger, Swift._ExpressibleByBuiltinIntegerLiteral {
  public typealias IntegerLiteralType = Swift.Int32
  @_transparent public init(_builtinIntegerLiteral x: Builtin.IntLiteral) {
    _value = Builtin.s_to_s_checked_trunc_IntLiteral_Int32(x).0
  }
  @_transparent public init(bitPattern x: Swift.UInt32) {
    _value = x._value
  }
  @available(*, unavailable, message: "Please use Int32(bitPattern: UInt32) in combination with Float.bitPattern property.")
  public init(bitPattern x: Swift.Float)
  @_transparent public init(_ source: Swift.Float) {
    _precondition(source.isFinite,
      "Float value cannot be converted to Int32 because it is either infinite or NaN")
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1164)
    _precondition(source > -2147483904.0,
      "Float value cannot be converted to Int32 because the result would be less than Int32.min")
    _precondition(source < 2147483648.0,
      "Float value cannot be converted to Int32 because the result would be greater than Int32.max")
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1169)
    self._value = Builtin.fptosi_FPIEEE32_Int32(source._value)
  }
  @_transparent public init?(exactly source: Swift.Float) {
    // The value passed as `source` must not be infinite, NaN, or exceed the
    // bounds of the integer type; the result of `fptosi` or `fptoui` is
    // undefined if it overflows.
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1195)
    guard source > -2147483904.0 && source < 2147483648.0 else {
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1199)
      return nil
    }
    guard source == source.rounded(.towardZero) else {
      return nil
    }
    self._value = Builtin.fptosi_FPIEEE32_Int32(source._value)
  }
  @_transparent public init(_ source: Swift.Double) {
    _precondition(source.isFinite,
      "Double value cannot be converted to Int32 because it is either infinite or NaN")
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1164)
    _precondition(source > -2147483649.0,
      "Double value cannot be converted to Int32 because the result would be less than Int32.min")
    _precondition(source < 2147483648.0,
      "Double value cannot be converted to Int32 because the result would be greater than Int32.max")
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1169)
    self._value = Builtin.fptosi_FPIEEE64_Int32(source._value)
  }
  @_transparent public init?(exactly source: Swift.Double) {
    // The value passed as `source` must not be infinite, NaN, or exceed the
    // bounds of the integer type; the result of `fptosi` or `fptoui` is
    // undefined if it overflows.
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1195)
    guard source > -2147483649.0 && source < 2147483648.0 else {
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1199)
      return nil
    }
    guard source == source.rounded(.towardZero) else {
      return nil
    }
    self._value = Builtin.fptosi_FPIEEE64_Int32(source._value)
  }
  @_transparent public init(_ source: Swift.Float80) {
    _precondition(source.isFinite,
      "Float80 value cannot be converted to Int32 because it is either infinite or NaN")
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1164)
    _precondition(source > -2147483649.0,
      "Float80 value cannot be converted to Int32 because the result would be less than Int32.min")
    _precondition(source < 2147483648.0,
      "Float80 value cannot be converted to Int32 because the result would be greater than Int32.max")
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1169)
    self._value = Builtin.fptosi_FPIEEE80_Int32(source._value)
  }
  @_transparent public init?(exactly source: Swift.Float80) {
    // The value passed as `source` must not be infinite, NaN, or exceed the
    // bounds of the integer type; the result of `fptosi` or `fptoui` is
    // undefined if it overflows.
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1195)
    guard source > -2147483649.0 && source < 2147483648.0 else {
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1199)
      return nil
    }
    guard source == source.rounded(.towardZero) else {
      return nil
    }
    self._value = Builtin.fptosi_FPIEEE80_Int32(source._value)
  }
  @_transparent public static func == (lhs: Swift.Int32, rhs: Swift.Int32) -> Swift.Bool {
    return Bool(Builtin.cmp_eq_Int32(lhs._value, rhs._value))
  }
  @_transparent public static func < (lhs: Swift.Int32, rhs: Swift.Int32) -> Swift.Bool {
    return Bool(Builtin.cmp_slt_Int32(lhs._value, rhs._value))
  }
  @_transparent public static func += (lhs: inout Swift.Int32, rhs: Swift.Int32) {
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1247)
    let (result, overflow) =
      Builtin.sadd_with_overflow_Int32(
        lhs._value, rhs._value, true._value)
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1251)
    Builtin.condfail_message(overflow,
      StaticString("arithmetic overflow").unsafeRawPointer)
    lhs = Int32(result)
  }
  @_transparent public static func -= (lhs: inout Swift.Int32, rhs: Swift.Int32) {
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1247)
    let (result, overflow) =
      Builtin.ssub_with_overflow_Int32(
        lhs._value, rhs._value, true._value)
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1251)
    Builtin.condfail_message(overflow,
      StaticString("arithmetic overflow").unsafeRawPointer)
    lhs = Int32(result)
  }
  @_transparent public static func *= (lhs: inout Swift.Int32, rhs: Swift.Int32) {
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1247)
    let (result, overflow) =
      Builtin.smul_with_overflow_Int32(
        lhs._value, rhs._value, true._value)
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1251)
    Builtin.condfail_message(overflow,
      StaticString("arithmetic overflow").unsafeRawPointer)
    lhs = Int32(result)
  }
  @_transparent public static func /= (lhs: inout Swift.Int32, rhs: Swift.Int32) {
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1229)
    // No LLVM primitives for checking overflow of division operations, so we
    // check manually.
    if _slowPath(rhs == (0 as Int32)) {
      _preconditionFailure(
        "Division by zero")
    }
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1236)
    if _slowPath(
      lhs == Int32.min && rhs == (-1 as Int32)
    ) {
      _preconditionFailure(
        "Division results in an overflow")
    }
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1243)
    let (result, overflow) =
      (Builtin.sdiv_Int32(lhs._value, rhs._value),
      false._value)
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1251)
    Builtin.condfail_message(overflow,
      StaticString("arithmetic overflow").unsafeRawPointer)
    lhs = Int32(result)
  }
  @_transparent public func addingReportingOverflow(_ other: Swift.Int32) -> (partialValue: Swift.Int32, overflow: Swift.Bool) {
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1282)

    let (newStorage, overflow) =
      Builtin.sadd_with_overflow_Int32(
        self._value, other._value, false._value)
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1287)

    return (
      partialValue: Int32(newStorage),
      overflow: Bool(overflow))
  }
  @_transparent public func subtractingReportingOverflow(_ other: Swift.Int32) -> (partialValue: Swift.Int32, overflow: Swift.Bool) {
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1282)

    let (newStorage, overflow) =
      Builtin.ssub_with_overflow_Int32(
        self._value, other._value, false._value)
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1287)

    return (
      partialValue: Int32(newStorage),
      overflow: Bool(overflow))
  }
  @_transparent public func multipliedReportingOverflow(by other: Swift.Int32) -> (partialValue: Swift.Int32, overflow: Swift.Bool) {
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1282)

    let (newStorage, overflow) =
      Builtin.smul_with_overflow_Int32(
        self._value, other._value, false._value)
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1287)

    return (
      partialValue: Int32(newStorage),
      overflow: Bool(overflow))
  }
  @_transparent public func dividedReportingOverflow(by other: Swift.Int32) -> (partialValue: Swift.Int32, overflow: Swift.Bool) {
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1265)
    // No LLVM primitives for checking overflow of division operations, so we
    // check manually.
    if _slowPath(other == (0 as Int32)) {
      return (partialValue: self, overflow: true)
    }
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1271)
    if _slowPath(self == Int32.min && other == (-1 as Int32)) {
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1273)
      return (partialValue: self, overflow: true)
    }
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1276)

    let (newStorage, overflow) = (
      Builtin.sdiv_Int32(self._value, other._value),
      false._value)

// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1287)

    return (
      partialValue: Int32(newStorage),
      overflow: Bool(overflow))
  }
  @_transparent public func remainderReportingOverflow(dividingBy other: Swift.Int32) -> (partialValue: Swift.Int32, overflow: Swift.Bool) {
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1265)
    // No LLVM primitives for checking overflow of division operations, so we
    // check manually.
    if _slowPath(other == (0 as Int32)) {
      return (partialValue: self, overflow: true)
    }
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1271)
    if _slowPath(self == Int32.min && other == (-1 as Int32)) {
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1273)
      return (partialValue: 0, overflow: true)
    }
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1276)

    let (newStorage, overflow) = (
      Builtin.srem_Int32(self._value, other._value),
      false._value)

// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1287)

    return (
      partialValue: Int32(newStorage),
      overflow: Bool(overflow))
  }
  @_transparent public static func %= (lhs: inout Swift.Int32, rhs: Swift.Int32) {
    // No LLVM primitives for checking overflow of division operations, so we
    // check manually.
    if _slowPath(rhs == (0 as Int32)) {
      _preconditionFailure(
        "Division by zero in remainder operation")
    }
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1304)
    if _slowPath(lhs == Int32.min && rhs == (-1 as Int32)) {
      _preconditionFailure(
        "Division results in an overflow in remainder operation")
    }
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1309)

    let (newStorage, _) = (
      Builtin.srem_Int32(lhs._value, rhs._value),
      false._value)
    lhs = Int32(newStorage)
  }
  @_transparent public init(_ _value: Builtin.Int32) {
    self._value = _value
  }
  @_transparent public static func &= (lhs: inout Swift.Int32, rhs: Swift.Int32) {
    lhs = Int32(Builtin.and_Int32(lhs._value, rhs._value))
  }
  @_transparent public static func |= (lhs: inout Swift.Int32, rhs: Swift.Int32) {
    lhs = Int32(Builtin.or_Int32(lhs._value, rhs._value))
  }
  @_transparent public static func ^= (lhs: inout Swift.Int32, rhs: Swift.Int32) {
    lhs = Int32(Builtin.xor_Int32(lhs._value, rhs._value))
  }
  @_transparent public static func &>>= (lhs: inout Swift.Int32, rhs: Swift.Int32) {
    let rhs_ = rhs & 31
    lhs = Int32(
      Builtin.ashr_Int32(lhs._value, rhs_._value))
  }
  @_transparent public static func &<<= (lhs: inout Swift.Int32, rhs: Swift.Int32) {
    let rhs_ = rhs & 31
    lhs = Int32(
      Builtin.shl_Int32(lhs._value, rhs_._value))
  }
  @_transparent public static var bitWidth: Swift.Int {
    @_transparent get { return 32 }
  }
  @_transparent public var leadingZeroBitCount: Swift.Int {
    @_transparent get {
    return Int(
      Int32(
        Builtin.int_ctlz_Int32(self._value, false._value)
      )._lowWord._value)
  }
  }
  @_transparent public var trailingZeroBitCount: Swift.Int {
    @_transparent get {
    return Int(
      Int32(
        Builtin.int_cttz_Int32(self._value, false._value)
      )._lowWord._value)
  }
  }
  @_transparent public var nonzeroBitCount: Swift.Int {
    @_transparent get {
    return Int(
      Int32(
        Builtin.int_ctpop_Int32(self._value)
      )._lowWord._value)
  }
  }
  @frozen public struct Words : Swift.RandomAccessCollection {
    public typealias Indices = Swift.Range<Swift.Int>
    public typealias SubSequence = Swift.Slice<Swift.Int32.Words>
    @usableFromInline
    internal var _value: Swift.Int32
    @inlinable public init(_ value: Swift.Int32) {
      self._value = value
    }
    @inlinable public var count: Swift.Int {
      get {
      return (32 + 64 - 1) / 64
    }
    }
    @inlinable public var startIndex: Swift.Int {
      get { return 0 }
    }
    @inlinable public var endIndex: Swift.Int {
      get { return count }
    }
    @inlinable public var indices: Swift.Int32.Words.Indices {
      get { return startIndex ..< endIndex }
    }
    @_transparent public func index(after i: Swift.Int) -> Swift.Int { return i + 1 }
    @_transparent public func index(before i: Swift.Int) -> Swift.Int { return i - 1 }
    @inlinable public subscript(position: Swift.Int) -> Swift.UInt {
      get {
        _precondition(position >= 0, "Negative word index")
        _precondition(position < endIndex, "Word index out of range")
        let shift = UInt(position._value) &* 64
        _internalInvariant(shift < UInt(_value.bitWidth._value))
        return (_value &>> Int32(_truncatingBits: shift))._lowWord
      }
    }
    public typealias Element = Swift.UInt
    public typealias Index = Swift.Int
    public typealias Iterator = Swift.IndexingIterator<Swift.Int32.Words>
  }
  @_transparent public var words: Swift.Int32.Words {
    @_transparent get {
    return Words(self)
  }
  }
  @_transparent public var _lowWord: Swift.UInt {
    @_transparent get {
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1462)
    return UInt(
      Builtin.sextOrBitCast_Int32_Int64(_value)
    )
  }
  }
  @_transparent public init(_truncatingBits bits: Swift.UInt) {
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1471)
    self.init(
      Builtin.truncOrBitCast_Int64_Int32(bits._value))
  }
  public typealias Magnitude = Swift.UInt32
  @_transparent public var magnitude: Swift.UInt32 {
    @_transparent get {
    let base = UInt32(_value)
    return self < (0 as Int32) ? ~base &+ 1 : base
  }
  }
  @inlinable public func multipliedFullWidth(by other: Swift.Int32) -> (high: Swift.Int32, low: Swift.Int32.Magnitude) {
    // FIXME(integers): tests
    let lhs_ = Builtin.sext_Int32_Int64(self._value)
    let rhs_ = Builtin.sext_Int32_Int64(other._value)

    let res = Builtin.mul_Int64(lhs_, rhs_)
    let low = Int32.Magnitude(Builtin.truncOrBitCast_Int64_Int32(res))
    let shift = Builtin.zextOrBitCast_Int8_Int64(UInt8(32)._value)
    let shifted = Builtin.ashr_Int64(res, shift)
    let high = Int32(Builtin.truncOrBitCast_Int64_Int32(shifted))
    return (high: high, low: low)
  }
  @inlinable public func dividingFullWidth(_ dividend: (high: Swift.Int32, low: Swift.Int32.Magnitude)) -> (quotient: Swift.Int32, remainder: Swift.Int32) {
    // FIXME(integers): tests
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1572)
    // FIXME(integers): handle division by zero and overflows
    _precondition(self != 0, "Division by zero")
    let lhsHigh = Builtin.sext_Int32_Int64(dividend.high._value)
    let shift = Builtin.zextOrBitCast_Int8_Int64(UInt8(32)._value)
    let lhsHighShifted = Builtin.shl_Int64(lhsHigh, shift)
    let lhsLow = Builtin.zext_Int32_Int64(dividend.low._value)
    let lhs_ = Builtin.or_Int64(lhsHighShifted, lhsLow)
    let rhs_ = Builtin.sext_Int32_Int64(self._value)

    let quotient_ = Builtin.sdiv_Int64(lhs_, rhs_)
    let remainder_ = Builtin.srem_Int64(lhs_, rhs_)

    let quotient = Int32(
      Builtin.truncOrBitCast_Int64_Int32(quotient_))
    let remainder = Int32(
      Builtin.truncOrBitCast_Int64_Int32(remainder_))

    return (quotient: quotient, remainder: remainder)
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1591)
  }
  @_transparent public var byteSwapped: Swift.Int32 {
    @_transparent get {
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1599)
    return Int32(Builtin.int_bswap_Int32(_value))
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1601)
  }
  }
  public var _value: Builtin.Int32
  @inlinable @inline(__always) public func signum() -> Swift.Int32 {
    let isPositive = Int32(Builtin.zext_Int1_Int32(
      (self > (0 as Int32))._value))
    return isPositive | (self &>> 31)
  }
  public typealias Stride = Swift.Int
}
extension Int32 : Swift.Hashable {
  @inlinable public func hash(into hasher: inout Swift.Hasher) {
    hasher._combine(UInt32(_value))
  }
  @inlinable public func _rawHashValue(seed: Swift.Int) -> Swift.Int {
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1662)
    return Hasher._hash(
      seed: seed,
      bytes: UInt64(truncatingIfNeeded: UInt32(_value)),
      count: 4)
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1667)
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension Int32 : Swift._HasCustomAnyHashableRepresentation {
  public func _toCustomAnyHashable() -> Swift.AnyHashable?
}
extension Int32 {
  @_transparent public static func & (lhs: Swift.Int32, rhs: Swift.Int32) -> Swift.Int32 {
    var lhs = lhs
    lhs &= rhs
    return lhs
  }
  @_transparent public static func | (lhs: Swift.Int32, rhs: Swift.Int32) -> Swift.Int32 {
    var lhs = lhs
    lhs |= rhs
    return lhs
  }
  @_transparent public static func ^ (lhs: Swift.Int32, rhs: Swift.Int32) -> Swift.Int32 {
    var lhs = lhs
    lhs ^= rhs
    return lhs
  }
  @_transparent public static func &>> (lhs: Swift.Int32, rhs: Swift.Int32) -> Swift.Int32 {
    var lhs = lhs
    lhs &>>= rhs
    return lhs
  }
  @_transparent public static func &<< (lhs: Swift.Int32, rhs: Swift.Int32) -> Swift.Int32 {
    var lhs = lhs
    lhs &<<= rhs
    return lhs
  }
  @_transparent public static func + (lhs: Swift.Int32, rhs: Swift.Int32) -> Swift.Int32 {
    var lhs = lhs
    lhs += rhs
    return lhs
  }
  @_transparent public static func - (lhs: Swift.Int32, rhs: Swift.Int32) -> Swift.Int32 {
    var lhs = lhs
    lhs -= rhs
    return lhs
  }
  @_transparent public static func * (lhs: Swift.Int32, rhs: Swift.Int32) -> Swift.Int32 {
    var lhs = lhs
    lhs *= rhs
    return lhs
  }
  @_transparent public static func / (lhs: Swift.Int32, rhs: Swift.Int32) -> Swift.Int32 {
    var lhs = lhs
    lhs /= rhs
    return lhs
  }
  @_transparent public static func % (lhs: Swift.Int32, rhs: Swift.Int32) -> Swift.Int32 {
    var lhs = lhs
    lhs %= rhs
    return lhs
  }
  @_transparent public static func <= (lhs: Swift.Int32, rhs: Swift.Int32) -> Swift.Bool {
    return !(rhs < lhs)
  }
  @_transparent public static func >= (lhs: Swift.Int32, rhs: Swift.Int32) -> Swift.Bool {
    return !(lhs < rhs)
  }
  @_transparent public static func > (lhs: Swift.Int32, rhs: Swift.Int32) -> Swift.Bool {
    return rhs < lhs
  }
}
@_transparent public func _assumeNonNegative(_ x: Swift.Int32) -> Swift.Int32 {
  _internalInvariant(x >= (0 as Int32))
  return Int32(Builtin.assumeNonNegative_Int32(x._value))
}
@frozen public struct UInt64 : Swift.FixedWidthInteger, Swift.UnsignedInteger, Swift._ExpressibleByBuiltinIntegerLiteral {
  public typealias IntegerLiteralType = Swift.UInt64
  @_transparent public init(_builtinIntegerLiteral x: Builtin.IntLiteral) {
    _value = Builtin.s_to_u_checked_trunc_IntLiteral_Int64(x).0
  }
  @_transparent public init(bitPattern x: Swift.Int64) {
    _value = x._value
  }
  @_transparent public init(_ source: Swift.Float) {
    _precondition(source.isFinite,
      "Float value cannot be converted to UInt64 because it is either infinite or NaN")
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1164)
    _precondition(source > -1.0,
      "Float value cannot be converted to UInt64 because the result would be less than UInt64.min")
    _precondition(source < 18446744073709551616.0,
      "Float value cannot be converted to UInt64 because the result would be greater than UInt64.max")
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1169)
    self._value = Builtin.fptoui_FPIEEE32_Int64(source._value)
  }
  @_transparent public init?(exactly source: Swift.Float) {
    // The value passed as `source` must not be infinite, NaN, or exceed the
    // bounds of the integer type; the result of `fptosi` or `fptoui` is
    // undefined if it overflows.
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1195)
    guard source > -1.0 && source < 18446744073709551616.0 else {
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1199)
      return nil
    }
    guard source == source.rounded(.towardZero) else {
      return nil
    }
    self._value = Builtin.fptoui_FPIEEE32_Int64(source._value)
  }
  @_transparent public init(_ source: Swift.Double) {
    _precondition(source.isFinite,
      "Double value cannot be converted to UInt64 because it is either infinite or NaN")
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1164)
    _precondition(source > -1.0,
      "Double value cannot be converted to UInt64 because the result would be less than UInt64.min")
    _precondition(source < 18446744073709551616.0,
      "Double value cannot be converted to UInt64 because the result would be greater than UInt64.max")
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1169)
    self._value = Builtin.fptoui_FPIEEE64_Int64(source._value)
  }
  @_transparent public init?(exactly source: Swift.Double) {
    // The value passed as `source` must not be infinite, NaN, or exceed the
    // bounds of the integer type; the result of `fptosi` or `fptoui` is
    // undefined if it overflows.
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1195)
    guard source > -1.0 && source < 18446744073709551616.0 else {
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1199)
      return nil
    }
    guard source == source.rounded(.towardZero) else {
      return nil
    }
    self._value = Builtin.fptoui_FPIEEE64_Int64(source._value)
  }
  @_transparent public init(_ source: Swift.Float80) {
    _precondition(source.isFinite,
      "Float80 value cannot be converted to UInt64 because it is either infinite or NaN")
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1164)
    _precondition(source > -1.0,
      "Float80 value cannot be converted to UInt64 because the result would be less than UInt64.min")
    _precondition(source < 18446744073709551616.0,
      "Float80 value cannot be converted to UInt64 because the result would be greater than UInt64.max")
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1169)
    self._value = Builtin.fptoui_FPIEEE80_Int64(source._value)
  }
  @_transparent public init?(exactly source: Swift.Float80) {
    // The value passed as `source` must not be infinite, NaN, or exceed the
    // bounds of the integer type; the result of `fptosi` or `fptoui` is
    // undefined if it overflows.
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1195)
    guard source > -1.0 && source < 18446744073709551616.0 else {
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1199)
      return nil
    }
    guard source == source.rounded(.towardZero) else {
      return nil
    }
    self._value = Builtin.fptoui_FPIEEE80_Int64(source._value)
  }
  @_transparent public static func == (lhs: Swift.UInt64, rhs: Swift.UInt64) -> Swift.Bool {
    return Bool(Builtin.cmp_eq_Int64(lhs._value, rhs._value))
  }
  @_transparent public static func < (lhs: Swift.UInt64, rhs: Swift.UInt64) -> Swift.Bool {
    return Bool(Builtin.cmp_ult_Int64(lhs._value, rhs._value))
  }
  @_transparent public static func += (lhs: inout Swift.UInt64, rhs: Swift.UInt64) {
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1247)
    let (result, overflow) =
      Builtin.uadd_with_overflow_Int64(
        lhs._value, rhs._value, true._value)
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1251)
    Builtin.condfail_message(overflow,
      StaticString("arithmetic overflow").unsafeRawPointer)
    lhs = UInt64(result)
  }
  @_transparent public static func -= (lhs: inout Swift.UInt64, rhs: Swift.UInt64) {
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1247)
    let (result, overflow) =
      Builtin.usub_with_overflow_Int64(
        lhs._value, rhs._value, true._value)
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1251)
    Builtin.condfail_message(overflow,
      StaticString("arithmetic overflow").unsafeRawPointer)
    lhs = UInt64(result)
  }
  @_transparent public static func *= (lhs: inout Swift.UInt64, rhs: Swift.UInt64) {
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1247)
    let (result, overflow) =
      Builtin.umul_with_overflow_Int64(
        lhs._value, rhs._value, true._value)
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1251)
    Builtin.condfail_message(overflow,
      StaticString("arithmetic overflow").unsafeRawPointer)
    lhs = UInt64(result)
  }
  @_transparent public static func /= (lhs: inout Swift.UInt64, rhs: Swift.UInt64) {
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1229)
    // No LLVM primitives for checking overflow of division operations, so we
    // check manually.
    if _slowPath(rhs == (0 as UInt64)) {
      _preconditionFailure(
        "Division by zero")
    }
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1243)
    let (result, overflow) =
      (Builtin.udiv_Int64(lhs._value, rhs._value),
      false._value)
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1251)
    Builtin.condfail_message(overflow,
      StaticString("arithmetic overflow").unsafeRawPointer)
    lhs = UInt64(result)
  }
  @_transparent public func addingReportingOverflow(_ other: Swift.UInt64) -> (partialValue: Swift.UInt64, overflow: Swift.Bool) {
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1282)

    let (newStorage, overflow) =
      Builtin.uadd_with_overflow_Int64(
        self._value, other._value, false._value)
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1287)

    return (
      partialValue: UInt64(newStorage),
      overflow: Bool(overflow))
  }
  @_transparent public func subtractingReportingOverflow(_ other: Swift.UInt64) -> (partialValue: Swift.UInt64, overflow: Swift.Bool) {
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1282)

    let (newStorage, overflow) =
      Builtin.usub_with_overflow_Int64(
        self._value, other._value, false._value)
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1287)

    return (
      partialValue: UInt64(newStorage),
      overflow: Bool(overflow))
  }
  @_transparent public func multipliedReportingOverflow(by other: Swift.UInt64) -> (partialValue: Swift.UInt64, overflow: Swift.Bool) {
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1282)

    let (newStorage, overflow) =
      Builtin.umul_with_overflow_Int64(
        self._value, other._value, false._value)
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1287)

    return (
      partialValue: UInt64(newStorage),
      overflow: Bool(overflow))
  }
  @_transparent public func dividedReportingOverflow(by other: Swift.UInt64) -> (partialValue: Swift.UInt64, overflow: Swift.Bool) {
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1265)
    // No LLVM primitives for checking overflow of division operations, so we
    // check manually.
    if _slowPath(other == (0 as UInt64)) {
      return (partialValue: self, overflow: true)
    }
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1276)

    let (newStorage, overflow) = (
      Builtin.udiv_Int64(self._value, other._value),
      false._value)

// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1287)

    return (
      partialValue: UInt64(newStorage),
      overflow: Bool(overflow))
  }
  @_transparent public func remainderReportingOverflow(dividingBy other: Swift.UInt64) -> (partialValue: Swift.UInt64, overflow: Swift.Bool) {
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1265)
    // No LLVM primitives for checking overflow of division operations, so we
    // check manually.
    if _slowPath(other == (0 as UInt64)) {
      return (partialValue: self, overflow: true)
    }
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1276)

    let (newStorage, overflow) = (
      Builtin.urem_Int64(self._value, other._value),
      false._value)

// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1287)

    return (
      partialValue: UInt64(newStorage),
      overflow: Bool(overflow))
  }
  @_transparent public static func %= (lhs: inout Swift.UInt64, rhs: Swift.UInt64) {
    // No LLVM primitives for checking overflow of division operations, so we
    // check manually.
    if _slowPath(rhs == (0 as UInt64)) {
      _preconditionFailure(
        "Division by zero in remainder operation")
    }
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1309)

    let (newStorage, _) = (
      Builtin.urem_Int64(lhs._value, rhs._value),
      false._value)
    lhs = UInt64(newStorage)
  }
  @_transparent public init(_ _value: Builtin.Int64) {
    self._value = _value
  }
  @_transparent public static func &= (lhs: inout Swift.UInt64, rhs: Swift.UInt64) {
    lhs = UInt64(Builtin.and_Int64(lhs._value, rhs._value))
  }
  @_transparent public static func |= (lhs: inout Swift.UInt64, rhs: Swift.UInt64) {
    lhs = UInt64(Builtin.or_Int64(lhs._value, rhs._value))
  }
  @_transparent public static func ^= (lhs: inout Swift.UInt64, rhs: Swift.UInt64) {
    lhs = UInt64(Builtin.xor_Int64(lhs._value, rhs._value))
  }
  @_transparent public static func &>>= (lhs: inout Swift.UInt64, rhs: Swift.UInt64) {
    let rhs_ = rhs & 63
    lhs = UInt64(
      Builtin.lshr_Int64(lhs._value, rhs_._value))
  }
  @_transparent public static func &<<= (lhs: inout Swift.UInt64, rhs: Swift.UInt64) {
    let rhs_ = rhs & 63
    lhs = UInt64(
      Builtin.shl_Int64(lhs._value, rhs_._value))
  }
  @_transparent public static var bitWidth: Swift.Int {
    @_transparent get { return 64 }
  }
  @_transparent public var leadingZeroBitCount: Swift.Int {
    @_transparent get {
    return Int(
      UInt64(
        Builtin.int_ctlz_Int64(self._value, false._value)
      )._lowWord._value)
  }
  }
  @_transparent public var trailingZeroBitCount: Swift.Int {
    @_transparent get {
    return Int(
      UInt64(
        Builtin.int_cttz_Int64(self._value, false._value)
      )._lowWord._value)
  }
  }
  @_transparent public var nonzeroBitCount: Swift.Int {
    @_transparent get {
    return Int(
      UInt64(
        Builtin.int_ctpop_Int64(self._value)
      )._lowWord._value)
  }
  }
  @frozen public struct Words : Swift.RandomAccessCollection {
    public typealias Indices = Swift.Range<Swift.Int>
    public typealias SubSequence = Swift.Slice<Swift.UInt64.Words>
    @usableFromInline
    internal var _value: Swift.UInt64
    @inlinable public init(_ value: Swift.UInt64) {
      self._value = value
    }
    @inlinable public var count: Swift.Int {
      get {
      return (64 + 64 - 1) / 64
    }
    }
    @inlinable public var startIndex: Swift.Int {
      get { return 0 }
    }
    @inlinable public var endIndex: Swift.Int {
      get { return count }
    }
    @inlinable public var indices: Swift.UInt64.Words.Indices {
      get { return startIndex ..< endIndex }
    }
    @_transparent public func index(after i: Swift.Int) -> Swift.Int { return i + 1 }
    @_transparent public func index(before i: Swift.Int) -> Swift.Int { return i - 1 }
    @inlinable public subscript(position: Swift.Int) -> Swift.UInt {
      get {
        _precondition(position >= 0, "Negative word index")
        _precondition(position < endIndex, "Word index out of range")
        let shift = UInt(position._value) &* 64
        _internalInvariant(shift < UInt(_value.bitWidth._value))
        return (_value &>> UInt64(_truncatingBits: shift))._lowWord
      }
    }
    public typealias Element = Swift.UInt
    public typealias Index = Swift.Int
    public typealias Iterator = Swift.IndexingIterator<Swift.UInt64.Words>
  }
  @_transparent public var words: Swift.UInt64.Words {
    @_transparent get {
    return Words(self)
  }
  }
  @_transparent public var _lowWord: Swift.UInt {
    @_transparent get {
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1462)
    return UInt(
      Builtin.zextOrBitCast_Int64_Int64(_value)
    )
  }
  }
  @_transparent public init(_truncatingBits bits: Swift.UInt) {
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1471)
    self.init(
      Builtin.truncOrBitCast_Int64_Int64(bits._value))
  }
  public typealias Magnitude = Swift.UInt64
  @inlinable public func multipliedFullWidth(by other: Swift.UInt64) -> (high: Swift.UInt64, low: Swift.UInt64.Magnitude) {
    // FIXME(integers): tests
    let lhs_ = Builtin.zext_Int64_Int128(self._value)
    let rhs_ = Builtin.zext_Int64_Int128(other._value)

    let res = Builtin.mul_Int128(lhs_, rhs_)
    let low = UInt64.Magnitude(Builtin.truncOrBitCast_Int128_Int64(res))
    let shift = Builtin.zextOrBitCast_Int8_Int128(UInt8(64)._value)
    let shifted = Builtin.ashr_Int128(res, shift)
    let high = UInt64(Builtin.truncOrBitCast_Int128_Int64(shifted))
    return (high: high, low: low)
  }
  @inlinable public func dividingFullWidth(_ dividend: (high: Swift.UInt64, low: Swift.UInt64.Magnitude)) -> (quotient: Swift.UInt64, remainder: Swift.UInt64) {
    // FIXME(integers): tests
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1572)
    // FIXME(integers): handle division by zero and overflows
    _precondition(self != 0, "Division by zero")
    let lhsHigh = Builtin.zext_Int64_Int128(dividend.high._value)
    let shift = Builtin.zextOrBitCast_Int8_Int128(UInt8(64)._value)
    let lhsHighShifted = Builtin.shl_Int128(lhsHigh, shift)
    let lhsLow = Builtin.zext_Int64_Int128(dividend.low._value)
    let lhs_ = Builtin.or_Int128(lhsHighShifted, lhsLow)
    let rhs_ = Builtin.zext_Int64_Int128(self._value)

    let quotient_ = Builtin.udiv_Int128(lhs_, rhs_)
    let remainder_ = Builtin.urem_Int128(lhs_, rhs_)

    let quotient = UInt64(
      Builtin.truncOrBitCast_Int128_Int64(quotient_))
    let remainder = UInt64(
      Builtin.truncOrBitCast_Int128_Int64(remainder_))

    return (quotient: quotient, remainder: remainder)
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1591)
  }
  @_transparent public var byteSwapped: Swift.UInt64 {
    @_transparent get {
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1599)
    return UInt64(Builtin.int_bswap_Int64(_value))
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1601)
  }
  }
  public var _value: Builtin.Int64
  @inlinable @inline(__always) public func signum() -> Swift.UInt64 {
    let isPositive = UInt64(Builtin.zext_Int1_Int64(
      (self > (0 as UInt64))._value))
    return isPositive | (self &>> 63)
  }
  public typealias Stride = Swift.Int
}
extension UInt64 : Swift.Hashable {
  @inlinable public func hash(into hasher: inout Swift.Hasher) {
    hasher._combine(UInt64(_value))
  }
  @inlinable public func _rawHashValue(seed: Swift.Int) -> Swift.Int {
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1658)
    return Hasher._hash(seed: seed, UInt64(_value))
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1667)
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension UInt64 : Swift._HasCustomAnyHashableRepresentation {
  public func _toCustomAnyHashable() -> Swift.AnyHashable?
}
extension UInt64 {
  @_transparent public static func & (lhs: Swift.UInt64, rhs: Swift.UInt64) -> Swift.UInt64 {
    var lhs = lhs
    lhs &= rhs
    return lhs
  }
  @_transparent public static func | (lhs: Swift.UInt64, rhs: Swift.UInt64) -> Swift.UInt64 {
    var lhs = lhs
    lhs |= rhs
    return lhs
  }
  @_transparent public static func ^ (lhs: Swift.UInt64, rhs: Swift.UInt64) -> Swift.UInt64 {
    var lhs = lhs
    lhs ^= rhs
    return lhs
  }
  @_transparent public static func &>> (lhs: Swift.UInt64, rhs: Swift.UInt64) -> Swift.UInt64 {
    var lhs = lhs
    lhs &>>= rhs
    return lhs
  }
  @_transparent public static func &<< (lhs: Swift.UInt64, rhs: Swift.UInt64) -> Swift.UInt64 {
    var lhs = lhs
    lhs &<<= rhs
    return lhs
  }
  @_transparent public static func + (lhs: Swift.UInt64, rhs: Swift.UInt64) -> Swift.UInt64 {
    var lhs = lhs
    lhs += rhs
    return lhs
  }
  @_transparent public static func - (lhs: Swift.UInt64, rhs: Swift.UInt64) -> Swift.UInt64 {
    var lhs = lhs
    lhs -= rhs
    return lhs
  }
  @_transparent public static func * (lhs: Swift.UInt64, rhs: Swift.UInt64) -> Swift.UInt64 {
    var lhs = lhs
    lhs *= rhs
    return lhs
  }
  @_transparent public static func / (lhs: Swift.UInt64, rhs: Swift.UInt64) -> Swift.UInt64 {
    var lhs = lhs
    lhs /= rhs
    return lhs
  }
  @_transparent public static func % (lhs: Swift.UInt64, rhs: Swift.UInt64) -> Swift.UInt64 {
    var lhs = lhs
    lhs %= rhs
    return lhs
  }
  @_transparent public static func <= (lhs: Swift.UInt64, rhs: Swift.UInt64) -> Swift.Bool {
    return !(rhs < lhs)
  }
  @_transparent public static func >= (lhs: Swift.UInt64, rhs: Swift.UInt64) -> Swift.Bool {
    return !(lhs < rhs)
  }
  @_transparent public static func > (lhs: Swift.UInt64, rhs: Swift.UInt64) -> Swift.Bool {
    return rhs < lhs
  }
}
@frozen public struct Int64 : Swift.FixedWidthInteger, Swift.SignedInteger, Swift._ExpressibleByBuiltinIntegerLiteral {
  public typealias IntegerLiteralType = Swift.Int64
  @_transparent public init(_builtinIntegerLiteral x: Builtin.IntLiteral) {
    _value = Builtin.s_to_s_checked_trunc_IntLiteral_Int64(x).0
  }
  @_transparent public init(bitPattern x: Swift.UInt64) {
    _value = x._value
  }
  @available(*, unavailable, message: "Please use Int64(bitPattern: UInt64) in combination with Double.bitPattern property.")
  public init(bitPattern x: Swift.Double)
  @_transparent public init(_ source: Swift.Float) {
    _precondition(source.isFinite,
      "Float value cannot be converted to Int64 because it is either infinite or NaN")
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1164)
    _precondition(source > -9223373136366403584.0,
      "Float value cannot be converted to Int64 because the result would be less than Int64.min")
    _precondition(source < 9223372036854775808.0,
      "Float value cannot be converted to Int64 because the result would be greater than Int64.max")
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1169)
    self._value = Builtin.fptosi_FPIEEE32_Int64(source._value)
  }
  @_transparent public init?(exactly source: Swift.Float) {
    // The value passed as `source` must not be infinite, NaN, or exceed the
    // bounds of the integer type; the result of `fptosi` or `fptoui` is
    // undefined if it overflows.
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1195)
    guard source > -9223373136366403584.0 && source < 9223372036854775808.0 else {
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1199)
      return nil
    }
    guard source == source.rounded(.towardZero) else {
      return nil
    }
    self._value = Builtin.fptosi_FPIEEE32_Int64(source._value)
  }
  @_transparent public init(_ source: Swift.Double) {
    _precondition(source.isFinite,
      "Double value cannot be converted to Int64 because it is either infinite or NaN")
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1164)
    _precondition(source > -9223372036854777856.0,
      "Double value cannot be converted to Int64 because the result would be less than Int64.min")
    _precondition(source < 9223372036854775808.0,
      "Double value cannot be converted to Int64 because the result would be greater than Int64.max")
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1169)
    self._value = Builtin.fptosi_FPIEEE64_Int64(source._value)
  }
  @_transparent public init?(exactly source: Swift.Double) {
    // The value passed as `source` must not be infinite, NaN, or exceed the
    // bounds of the integer type; the result of `fptosi` or `fptoui` is
    // undefined if it overflows.
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1195)
    guard source > -9223372036854777856.0 && source < 9223372036854775808.0 else {
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1199)
      return nil
    }
    guard source == source.rounded(.towardZero) else {
      return nil
    }
    self._value = Builtin.fptosi_FPIEEE64_Int64(source._value)
  }
  @_transparent public init(_ source: Swift.Float80) {
    _precondition(source.isFinite,
      "Float80 value cannot be converted to Int64 because it is either infinite or NaN")
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1164)
    _precondition(source > -9223372036854775809.0,
      "Float80 value cannot be converted to Int64 because the result would be less than Int64.min")
    _precondition(source < 9223372036854775808.0,
      "Float80 value cannot be converted to Int64 because the result would be greater than Int64.max")
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1169)
    self._value = Builtin.fptosi_FPIEEE80_Int64(source._value)
  }
  @_transparent public init?(exactly source: Swift.Float80) {
    // The value passed as `source` must not be infinite, NaN, or exceed the
    // bounds of the integer type; the result of `fptosi` or `fptoui` is
    // undefined if it overflows.
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1195)
    guard source > -9223372036854775809.0 && source < 9223372036854775808.0 else {
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1199)
      return nil
    }
    guard source == source.rounded(.towardZero) else {
      return nil
    }
    self._value = Builtin.fptosi_FPIEEE80_Int64(source._value)
  }
  @_transparent public static func == (lhs: Swift.Int64, rhs: Swift.Int64) -> Swift.Bool {
    return Bool(Builtin.cmp_eq_Int64(lhs._value, rhs._value))
  }
  @_transparent public static func < (lhs: Swift.Int64, rhs: Swift.Int64) -> Swift.Bool {
    return Bool(Builtin.cmp_slt_Int64(lhs._value, rhs._value))
  }
  @_transparent public static func += (lhs: inout Swift.Int64, rhs: Swift.Int64) {
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1247)
    let (result, overflow) =
      Builtin.sadd_with_overflow_Int64(
        lhs._value, rhs._value, true._value)
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1251)
    Builtin.condfail_message(overflow,
      StaticString("arithmetic overflow").unsafeRawPointer)
    lhs = Int64(result)
  }
  @_transparent public static func -= (lhs: inout Swift.Int64, rhs: Swift.Int64) {
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1247)
    let (result, overflow) =
      Builtin.ssub_with_overflow_Int64(
        lhs._value, rhs._value, true._value)
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1251)
    Builtin.condfail_message(overflow,
      StaticString("arithmetic overflow").unsafeRawPointer)
    lhs = Int64(result)
  }
  @_transparent public static func *= (lhs: inout Swift.Int64, rhs: Swift.Int64) {
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1247)
    let (result, overflow) =
      Builtin.smul_with_overflow_Int64(
        lhs._value, rhs._value, true._value)
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1251)
    Builtin.condfail_message(overflow,
      StaticString("arithmetic overflow").unsafeRawPointer)
    lhs = Int64(result)
  }
  @_transparent public static func /= (lhs: inout Swift.Int64, rhs: Swift.Int64) {
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1229)
    // No LLVM primitives for checking overflow of division operations, so we
    // check manually.
    if _slowPath(rhs == (0 as Int64)) {
      _preconditionFailure(
        "Division by zero")
    }
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1236)
    if _slowPath(
      lhs == Int64.min && rhs == (-1 as Int64)
    ) {
      _preconditionFailure(
        "Division results in an overflow")
    }
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1243)
    let (result, overflow) =
      (Builtin.sdiv_Int64(lhs._value, rhs._value),
      false._value)
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1251)
    Builtin.condfail_message(overflow,
      StaticString("arithmetic overflow").unsafeRawPointer)
    lhs = Int64(result)
  }
  @_transparent public func addingReportingOverflow(_ other: Swift.Int64) -> (partialValue: Swift.Int64, overflow: Swift.Bool) {
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1282)

    let (newStorage, overflow) =
      Builtin.sadd_with_overflow_Int64(
        self._value, other._value, false._value)
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1287)

    return (
      partialValue: Int64(newStorage),
      overflow: Bool(overflow))
  }
  @_transparent public func subtractingReportingOverflow(_ other: Swift.Int64) -> (partialValue: Swift.Int64, overflow: Swift.Bool) {
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1282)

    let (newStorage, overflow) =
      Builtin.ssub_with_overflow_Int64(
        self._value, other._value, false._value)
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1287)

    return (
      partialValue: Int64(newStorage),
      overflow: Bool(overflow))
  }
  @_transparent public func multipliedReportingOverflow(by other: Swift.Int64) -> (partialValue: Swift.Int64, overflow: Swift.Bool) {
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1282)

    let (newStorage, overflow) =
      Builtin.smul_with_overflow_Int64(
        self._value, other._value, false._value)
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1287)

    return (
      partialValue: Int64(newStorage),
      overflow: Bool(overflow))
  }
  @_transparent public func dividedReportingOverflow(by other: Swift.Int64) -> (partialValue: Swift.Int64, overflow: Swift.Bool) {
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1265)
    // No LLVM primitives for checking overflow of division operations, so we
    // check manually.
    if _slowPath(other == (0 as Int64)) {
      return (partialValue: self, overflow: true)
    }
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1271)
    if _slowPath(self == Int64.min && other == (-1 as Int64)) {
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1273)
      return (partialValue: self, overflow: true)
    }
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1276)

    let (newStorage, overflow) = (
      Builtin.sdiv_Int64(self._value, other._value),
      false._value)

// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1287)

    return (
      partialValue: Int64(newStorage),
      overflow: Bool(overflow))
  }
  @_transparent public func remainderReportingOverflow(dividingBy other: Swift.Int64) -> (partialValue: Swift.Int64, overflow: Swift.Bool) {
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1265)
    // No LLVM primitives for checking overflow of division operations, so we
    // check manually.
    if _slowPath(other == (0 as Int64)) {
      return (partialValue: self, overflow: true)
    }
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1271)
    if _slowPath(self == Int64.min && other == (-1 as Int64)) {
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1273)
      return (partialValue: 0, overflow: true)
    }
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1276)

    let (newStorage, overflow) = (
      Builtin.srem_Int64(self._value, other._value),
      false._value)

// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1287)

    return (
      partialValue: Int64(newStorage),
      overflow: Bool(overflow))
  }
  @_transparent public static func %= (lhs: inout Swift.Int64, rhs: Swift.Int64) {
    // No LLVM primitives for checking overflow of division operations, so we
    // check manually.
    if _slowPath(rhs == (0 as Int64)) {
      _preconditionFailure(
        "Division by zero in remainder operation")
    }
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1304)
    if _slowPath(lhs == Int64.min && rhs == (-1 as Int64)) {
      _preconditionFailure(
        "Division results in an overflow in remainder operation")
    }
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1309)

    let (newStorage, _) = (
      Builtin.srem_Int64(lhs._value, rhs._value),
      false._value)
    lhs = Int64(newStorage)
  }
  @_transparent public init(_ _value: Builtin.Int64) {
    self._value = _value
  }
  @_transparent public static func &= (lhs: inout Swift.Int64, rhs: Swift.Int64) {
    lhs = Int64(Builtin.and_Int64(lhs._value, rhs._value))
  }
  @_transparent public static func |= (lhs: inout Swift.Int64, rhs: Swift.Int64) {
    lhs = Int64(Builtin.or_Int64(lhs._value, rhs._value))
  }
  @_transparent public static func ^= (lhs: inout Swift.Int64, rhs: Swift.Int64) {
    lhs = Int64(Builtin.xor_Int64(lhs._value, rhs._value))
  }
  @_transparent public static func &>>= (lhs: inout Swift.Int64, rhs: Swift.Int64) {
    let rhs_ = rhs & 63
    lhs = Int64(
      Builtin.ashr_Int64(lhs._value, rhs_._value))
  }
  @_transparent public static func &<<= (lhs: inout Swift.Int64, rhs: Swift.Int64) {
    let rhs_ = rhs & 63
    lhs = Int64(
      Builtin.shl_Int64(lhs._value, rhs_._value))
  }
  @_transparent public static var bitWidth: Swift.Int {
    @_transparent get { return 64 }
  }
  @_transparent public var leadingZeroBitCount: Swift.Int {
    @_transparent get {
    return Int(
      Int64(
        Builtin.int_ctlz_Int64(self._value, false._value)
      )._lowWord._value)
  }
  }
  @_transparent public var trailingZeroBitCount: Swift.Int {
    @_transparent get {
    return Int(
      Int64(
        Builtin.int_cttz_Int64(self._value, false._value)
      )._lowWord._value)
  }
  }
  @_transparent public var nonzeroBitCount: Swift.Int {
    @_transparent get {
    return Int(
      Int64(
        Builtin.int_ctpop_Int64(self._value)
      )._lowWord._value)
  }
  }
  @frozen public struct Words : Swift.RandomAccessCollection {
    public typealias Indices = Swift.Range<Swift.Int>
    public typealias SubSequence = Swift.Slice<Swift.Int64.Words>
    @usableFromInline
    internal var _value: Swift.Int64
    @inlinable public init(_ value: Swift.Int64) {
      self._value = value
    }
    @inlinable public var count: Swift.Int {
      get {
      return (64 + 64 - 1) / 64
    }
    }
    @inlinable public var startIndex: Swift.Int {
      get { return 0 }
    }
    @inlinable public var endIndex: Swift.Int {
      get { return count }
    }
    @inlinable public var indices: Swift.Int64.Words.Indices {
      get { return startIndex ..< endIndex }
    }
    @_transparent public func index(after i: Swift.Int) -> Swift.Int { return i + 1 }
    @_transparent public func index(before i: Swift.Int) -> Swift.Int { return i - 1 }
    @inlinable public subscript(position: Swift.Int) -> Swift.UInt {
      get {
        _precondition(position >= 0, "Negative word index")
        _precondition(position < endIndex, "Word index out of range")
        let shift = UInt(position._value) &* 64
        _internalInvariant(shift < UInt(_value.bitWidth._value))
        return (_value &>> Int64(_truncatingBits: shift))._lowWord
      }
    }
    public typealias Element = Swift.UInt
    public typealias Index = Swift.Int
    public typealias Iterator = Swift.IndexingIterator<Swift.Int64.Words>
  }
  @_transparent public var words: Swift.Int64.Words {
    @_transparent get {
    return Words(self)
  }
  }
  @_transparent public var _lowWord: Swift.UInt {
    @_transparent get {
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1462)
    return UInt(
      Builtin.sextOrBitCast_Int64_Int64(_value)
    )
  }
  }
  @_transparent public init(_truncatingBits bits: Swift.UInt) {
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1471)
    self.init(
      Builtin.truncOrBitCast_Int64_Int64(bits._value))
  }
  public typealias Magnitude = Swift.UInt64
  @_transparent public var magnitude: Swift.UInt64 {
    @_transparent get {
    let base = UInt64(_value)
    return self < (0 as Int64) ? ~base &+ 1 : base
  }
  }
  @inlinable public func multipliedFullWidth(by other: Swift.Int64) -> (high: Swift.Int64, low: Swift.Int64.Magnitude) {
    // FIXME(integers): tests
    let lhs_ = Builtin.sext_Int64_Int128(self._value)
    let rhs_ = Builtin.sext_Int64_Int128(other._value)

    let res = Builtin.mul_Int128(lhs_, rhs_)
    let low = Int64.Magnitude(Builtin.truncOrBitCast_Int128_Int64(res))
    let shift = Builtin.zextOrBitCast_Int8_Int128(UInt8(64)._value)
    let shifted = Builtin.ashr_Int128(res, shift)
    let high = Int64(Builtin.truncOrBitCast_Int128_Int64(shifted))
    return (high: high, low: low)
  }
  @inlinable public func dividingFullWidth(_ dividend: (high: Swift.Int64, low: Swift.Int64.Magnitude)) -> (quotient: Swift.Int64, remainder: Swift.Int64) {
    // FIXME(integers): tests
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1572)
    // FIXME(integers): handle division by zero and overflows
    _precondition(self != 0, "Division by zero")
    let lhsHigh = Builtin.sext_Int64_Int128(dividend.high._value)
    let shift = Builtin.zextOrBitCast_Int8_Int128(UInt8(64)._value)
    let lhsHighShifted = Builtin.shl_Int128(lhsHigh, shift)
    let lhsLow = Builtin.zext_Int64_Int128(dividend.low._value)
    let lhs_ = Builtin.or_Int128(lhsHighShifted, lhsLow)
    let rhs_ = Builtin.sext_Int64_Int128(self._value)

    let quotient_ = Builtin.sdiv_Int128(lhs_, rhs_)
    let remainder_ = Builtin.srem_Int128(lhs_, rhs_)

    let quotient = Int64(
      Builtin.truncOrBitCast_Int128_Int64(quotient_))
    let remainder = Int64(
      Builtin.truncOrBitCast_Int128_Int64(remainder_))

    return (quotient: quotient, remainder: remainder)
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1591)
  }
  @_transparent public var byteSwapped: Swift.Int64 {
    @_transparent get {
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1599)
    return Int64(Builtin.int_bswap_Int64(_value))
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1601)
  }
  }
  public var _value: Builtin.Int64
  @inlinable @inline(__always) public func signum() -> Swift.Int64 {
    let isPositive = Int64(Builtin.zext_Int1_Int64(
      (self > (0 as Int64))._value))
    return isPositive | (self &>> 63)
  }
  public typealias Stride = Swift.Int
}
extension Int64 : Swift.Hashable {
  @inlinable public func hash(into hasher: inout Swift.Hasher) {
    hasher._combine(UInt64(_value))
  }
  @inlinable public func _rawHashValue(seed: Swift.Int) -> Swift.Int {
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1658)
    return Hasher._hash(seed: seed, UInt64(_value))
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1667)
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension Int64 : Swift._HasCustomAnyHashableRepresentation {
  public func _toCustomAnyHashable() -> Swift.AnyHashable?
}
extension Int64 {
  @_transparent public static func & (lhs: Swift.Int64, rhs: Swift.Int64) -> Swift.Int64 {
    var lhs = lhs
    lhs &= rhs
    return lhs
  }
  @_transparent public static func | (lhs: Swift.Int64, rhs: Swift.Int64) -> Swift.Int64 {
    var lhs = lhs
    lhs |= rhs
    return lhs
  }
  @_transparent public static func ^ (lhs: Swift.Int64, rhs: Swift.Int64) -> Swift.Int64 {
    var lhs = lhs
    lhs ^= rhs
    return lhs
  }
  @_transparent public static func &>> (lhs: Swift.Int64, rhs: Swift.Int64) -> Swift.Int64 {
    var lhs = lhs
    lhs &>>= rhs
    return lhs
  }
  @_transparent public static func &<< (lhs: Swift.Int64, rhs: Swift.Int64) -> Swift.Int64 {
    var lhs = lhs
    lhs &<<= rhs
    return lhs
  }
  @_transparent public static func + (lhs: Swift.Int64, rhs: Swift.Int64) -> Swift.Int64 {
    var lhs = lhs
    lhs += rhs
    return lhs
  }
  @_transparent public static func - (lhs: Swift.Int64, rhs: Swift.Int64) -> Swift.Int64 {
    var lhs = lhs
    lhs -= rhs
    return lhs
  }
  @_transparent public static func * (lhs: Swift.Int64, rhs: Swift.Int64) -> Swift.Int64 {
    var lhs = lhs
    lhs *= rhs
    return lhs
  }
  @_transparent public static func / (lhs: Swift.Int64, rhs: Swift.Int64) -> Swift.Int64 {
    var lhs = lhs
    lhs /= rhs
    return lhs
  }
  @_transparent public static func % (lhs: Swift.Int64, rhs: Swift.Int64) -> Swift.Int64 {
    var lhs = lhs
    lhs %= rhs
    return lhs
  }
  @_transparent public static func <= (lhs: Swift.Int64, rhs: Swift.Int64) -> Swift.Bool {
    return !(rhs < lhs)
  }
  @_transparent public static func >= (lhs: Swift.Int64, rhs: Swift.Int64) -> Swift.Bool {
    return !(lhs < rhs)
  }
  @_transparent public static func > (lhs: Swift.Int64, rhs: Swift.Int64) -> Swift.Bool {
    return rhs < lhs
  }
}
@_transparent public func _assumeNonNegative(_ x: Swift.Int64) -> Swift.Int64 {
  _internalInvariant(x >= (0 as Int64))
  return Int64(Builtin.assumeNonNegative_Int64(x._value))
}
@frozen public struct UInt : Swift.FixedWidthInteger, Swift.UnsignedInteger, Swift._ExpressibleByBuiltinIntegerLiteral {
  public typealias IntegerLiteralType = Swift.UInt
  @_transparent public init(_builtinIntegerLiteral x: Builtin.IntLiteral) {
    _value = Builtin.s_to_u_checked_trunc_IntLiteral_Int64(x).0
  }
  @_transparent public init(bitPattern x: Swift.Int) {
    _value = x._value
  }
  @_transparent public init(_ source: Swift.Float) {
    _precondition(source.isFinite,
      "Float value cannot be converted to UInt because it is either infinite or NaN")
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1164)
    _precondition(source > -1.0,
      "Float value cannot be converted to UInt because the result would be less than UInt.min")
    _precondition(source < 18446744073709551616.0,
      "Float value cannot be converted to UInt because the result would be greater than UInt.max")
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1169)
    self._value = Builtin.fptoui_FPIEEE32_Int64(source._value)
  }
  @_transparent public init?(exactly source: Swift.Float) {
    // The value passed as `source` must not be infinite, NaN, or exceed the
    // bounds of the integer type; the result of `fptosi` or `fptoui` is
    // undefined if it overflows.
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1195)
    guard source > -1.0 && source < 18446744073709551616.0 else {
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1199)
      return nil
    }
    guard source == source.rounded(.towardZero) else {
      return nil
    }
    self._value = Builtin.fptoui_FPIEEE32_Int64(source._value)
  }
  @_transparent public init(_ source: Swift.Double) {
    _precondition(source.isFinite,
      "Double value cannot be converted to UInt because it is either infinite or NaN")
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1164)
    _precondition(source > -1.0,
      "Double value cannot be converted to UInt because the result would be less than UInt.min")
    _precondition(source < 18446744073709551616.0,
      "Double value cannot be converted to UInt because the result would be greater than UInt.max")
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1169)
    self._value = Builtin.fptoui_FPIEEE64_Int64(source._value)
  }
  @_transparent public init?(exactly source: Swift.Double) {
    // The value passed as `source` must not be infinite, NaN, or exceed the
    // bounds of the integer type; the result of `fptosi` or `fptoui` is
    // undefined if it overflows.
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1195)
    guard source > -1.0 && source < 18446744073709551616.0 else {
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1199)
      return nil
    }
    guard source == source.rounded(.towardZero) else {
      return nil
    }
    self._value = Builtin.fptoui_FPIEEE64_Int64(source._value)
  }
  @_transparent public init(_ source: Swift.Float80) {
    _precondition(source.isFinite,
      "Float80 value cannot be converted to UInt because it is either infinite or NaN")
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1164)
    _precondition(source > -1.0,
      "Float80 value cannot be converted to UInt because the result would be less than UInt.min")
    _precondition(source < 18446744073709551616.0,
      "Float80 value cannot be converted to UInt because the result would be greater than UInt.max")
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1169)
    self._value = Builtin.fptoui_FPIEEE80_Int64(source._value)
  }
  @_transparent public init?(exactly source: Swift.Float80) {
    // The value passed as `source` must not be infinite, NaN, or exceed the
    // bounds of the integer type; the result of `fptosi` or `fptoui` is
    // undefined if it overflows.
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1195)
    guard source > -1.0 && source < 18446744073709551616.0 else {
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1199)
      return nil
    }
    guard source == source.rounded(.towardZero) else {
      return nil
    }
    self._value = Builtin.fptoui_FPIEEE80_Int64(source._value)
  }
  @_transparent public static func == (lhs: Swift.UInt, rhs: Swift.UInt) -> Swift.Bool {
    return Bool(Builtin.cmp_eq_Int64(lhs._value, rhs._value))
  }
  @_transparent public static func < (lhs: Swift.UInt, rhs: Swift.UInt) -> Swift.Bool {
    return Bool(Builtin.cmp_ult_Int64(lhs._value, rhs._value))
  }
  @_transparent public static func += (lhs: inout Swift.UInt, rhs: Swift.UInt) {
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1247)
    let (result, overflow) =
      Builtin.uadd_with_overflow_Int64(
        lhs._value, rhs._value, true._value)
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1251)
    Builtin.condfail_message(overflow,
      StaticString("arithmetic overflow").unsafeRawPointer)
    lhs = UInt(result)
  }
  @_transparent public static func -= (lhs: inout Swift.UInt, rhs: Swift.UInt) {
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1247)
    let (result, overflow) =
      Builtin.usub_with_overflow_Int64(
        lhs._value, rhs._value, true._value)
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1251)
    Builtin.condfail_message(overflow,
      StaticString("arithmetic overflow").unsafeRawPointer)
    lhs = UInt(result)
  }
  @_transparent public static func *= (lhs: inout Swift.UInt, rhs: Swift.UInt) {
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1247)
    let (result, overflow) =
      Builtin.umul_with_overflow_Int64(
        lhs._value, rhs._value, true._value)
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1251)
    Builtin.condfail_message(overflow,
      StaticString("arithmetic overflow").unsafeRawPointer)
    lhs = UInt(result)
  }
  @_transparent public static func /= (lhs: inout Swift.UInt, rhs: Swift.UInt) {
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1229)
    // No LLVM primitives for checking overflow of division operations, so we
    // check manually.
    if _slowPath(rhs == (0 as UInt)) {
      _preconditionFailure(
        "Division by zero")
    }
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1243)
    let (result, overflow) =
      (Builtin.udiv_Int64(lhs._value, rhs._value),
      false._value)
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1251)
    Builtin.condfail_message(overflow,
      StaticString("arithmetic overflow").unsafeRawPointer)
    lhs = UInt(result)
  }
  @_transparent public func addingReportingOverflow(_ other: Swift.UInt) -> (partialValue: Swift.UInt, overflow: Swift.Bool) {
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1282)

    let (newStorage, overflow) =
      Builtin.uadd_with_overflow_Int64(
        self._value, other._value, false._value)
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1287)

    return (
      partialValue: UInt(newStorage),
      overflow: Bool(overflow))
  }
  @_transparent public func subtractingReportingOverflow(_ other: Swift.UInt) -> (partialValue: Swift.UInt, overflow: Swift.Bool) {
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1282)

    let (newStorage, overflow) =
      Builtin.usub_with_overflow_Int64(
        self._value, other._value, false._value)
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1287)

    return (
      partialValue: UInt(newStorage),
      overflow: Bool(overflow))
  }
  @_transparent public func multipliedReportingOverflow(by other: Swift.UInt) -> (partialValue: Swift.UInt, overflow: Swift.Bool) {
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1282)

    let (newStorage, overflow) =
      Builtin.umul_with_overflow_Int64(
        self._value, other._value, false._value)
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1287)

    return (
      partialValue: UInt(newStorage),
      overflow: Bool(overflow))
  }
  @_transparent public func dividedReportingOverflow(by other: Swift.UInt) -> (partialValue: Swift.UInt, overflow: Swift.Bool) {
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1265)
    // No LLVM primitives for checking overflow of division operations, so we
    // check manually.
    if _slowPath(other == (0 as UInt)) {
      return (partialValue: self, overflow: true)
    }
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1276)

    let (newStorage, overflow) = (
      Builtin.udiv_Int64(self._value, other._value),
      false._value)

// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1287)

    return (
      partialValue: UInt(newStorage),
      overflow: Bool(overflow))
  }
  @_transparent public func remainderReportingOverflow(dividingBy other: Swift.UInt) -> (partialValue: Swift.UInt, overflow: Swift.Bool) {
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1265)
    // No LLVM primitives for checking overflow of division operations, so we
    // check manually.
    if _slowPath(other == (0 as UInt)) {
      return (partialValue: self, overflow: true)
    }
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1276)

    let (newStorage, overflow) = (
      Builtin.urem_Int64(self._value, other._value),
      false._value)

// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1287)

    return (
      partialValue: UInt(newStorage),
      overflow: Bool(overflow))
  }
  @_transparent public static func %= (lhs: inout Swift.UInt, rhs: Swift.UInt) {
    // No LLVM primitives for checking overflow of division operations, so we
    // check manually.
    if _slowPath(rhs == (0 as UInt)) {
      _preconditionFailure(
        "Division by zero in remainder operation")
    }
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1309)

    let (newStorage, _) = (
      Builtin.urem_Int64(lhs._value, rhs._value),
      false._value)
    lhs = UInt(newStorage)
  }
  @_transparent public init(_ _value: Builtin.Int64) {
    self._value = _value
  }
  @_transparent public static func &= (lhs: inout Swift.UInt, rhs: Swift.UInt) {
    lhs = UInt(Builtin.and_Int64(lhs._value, rhs._value))
  }
  @_transparent public static func |= (lhs: inout Swift.UInt, rhs: Swift.UInt) {
    lhs = UInt(Builtin.or_Int64(lhs._value, rhs._value))
  }
  @_transparent public static func ^= (lhs: inout Swift.UInt, rhs: Swift.UInt) {
    lhs = UInt(Builtin.xor_Int64(lhs._value, rhs._value))
  }
  @_transparent public static func &>>= (lhs: inout Swift.UInt, rhs: Swift.UInt) {
    let rhs_ = rhs & 63
    lhs = UInt(
      Builtin.lshr_Int64(lhs._value, rhs_._value))
  }
  @_transparent public static func &<<= (lhs: inout Swift.UInt, rhs: Swift.UInt) {
    let rhs_ = rhs & 63
    lhs = UInt(
      Builtin.shl_Int64(lhs._value, rhs_._value))
  }
  @_transparent public static var bitWidth: Swift.Int {
    @_transparent get { return 64 }
  }
  @_transparent public var leadingZeroBitCount: Swift.Int {
    @_transparent get {
    return Int(
      UInt(
        Builtin.int_ctlz_Int64(self._value, false._value)
      )._lowWord._value)
  }
  }
  @_transparent public var trailingZeroBitCount: Swift.Int {
    @_transparent get {
    return Int(
      UInt(
        Builtin.int_cttz_Int64(self._value, false._value)
      )._lowWord._value)
  }
  }
  @_transparent public var nonzeroBitCount: Swift.Int {
    @_transparent get {
    return Int(
      UInt(
        Builtin.int_ctpop_Int64(self._value)
      )._lowWord._value)
  }
  }
  @frozen public struct Words : Swift.RandomAccessCollection {
    public typealias Indices = Swift.Range<Swift.Int>
    public typealias SubSequence = Swift.Slice<Swift.UInt.Words>
    @usableFromInline
    internal var _value: Swift.UInt
    @inlinable public init(_ value: Swift.UInt) {
      self._value = value
    }
    @inlinable public var count: Swift.Int {
      get {
      return (64 + 64 - 1) / 64
    }
    }
    @inlinable public var startIndex: Swift.Int {
      get { return 0 }
    }
    @inlinable public var endIndex: Swift.Int {
      get { return count }
    }
    @inlinable public var indices: Swift.UInt.Words.Indices {
      get { return startIndex ..< endIndex }
    }
    @_transparent public func index(after i: Swift.Int) -> Swift.Int { return i + 1 }
    @_transparent public func index(before i: Swift.Int) -> Swift.Int { return i - 1 }
    @inlinable public subscript(position: Swift.Int) -> Swift.UInt {
      get {
        _precondition(position >= 0, "Negative word index")
        _precondition(position < endIndex, "Word index out of range")
        let shift = UInt(position._value) &* 64
        _internalInvariant(shift < UInt(_value.bitWidth._value))
        return (_value &>> UInt(_truncatingBits: shift))._lowWord
      }
    }
    public typealias Element = Swift.UInt
    public typealias Index = Swift.Int
    public typealias Iterator = Swift.IndexingIterator<Swift.UInt.Words>
  }
  @_transparent public var words: Swift.UInt.Words {
    @_transparent get {
    return Words(self)
  }
  }
  @_transparent public var _lowWord: Swift.UInt {
    @_transparent get {
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1462)
    return UInt(
      Builtin.zextOrBitCast_Int64_Int64(_value)
    )
  }
  }
  @_transparent public init(_truncatingBits bits: Swift.UInt) {
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1471)
    self.init(
      Builtin.truncOrBitCast_Int64_Int64(bits._value))
  }
  public typealias Magnitude = Swift.UInt
  @inlinable public func multipliedFullWidth(by other: Swift.UInt) -> (high: Swift.UInt, low: Swift.UInt.Magnitude) {
    // FIXME(integers): tests
    let lhs_ = Builtin.zext_Int64_Int128(self._value)
    let rhs_ = Builtin.zext_Int64_Int128(other._value)

    let res = Builtin.mul_Int128(lhs_, rhs_)
    let low = UInt.Magnitude(Builtin.truncOrBitCast_Int128_Int64(res))
    let shift = Builtin.zextOrBitCast_Int8_Int128(UInt8(64)._value)
    let shifted = Builtin.ashr_Int128(res, shift)
    let high = UInt(Builtin.truncOrBitCast_Int128_Int64(shifted))
    return (high: high, low: low)
  }
  @inlinable public func dividingFullWidth(_ dividend: (high: Swift.UInt, low: Swift.UInt.Magnitude)) -> (quotient: Swift.UInt, remainder: Swift.UInt) {
    // FIXME(integers): tests
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1572)
    // FIXME(integers): handle division by zero and overflows
    _precondition(self != 0, "Division by zero")
    let lhsHigh = Builtin.zext_Int64_Int128(dividend.high._value)
    let shift = Builtin.zextOrBitCast_Int8_Int128(UInt8(64)._value)
    let lhsHighShifted = Builtin.shl_Int128(lhsHigh, shift)
    let lhsLow = Builtin.zext_Int64_Int128(dividend.low._value)
    let lhs_ = Builtin.or_Int128(lhsHighShifted, lhsLow)
    let rhs_ = Builtin.zext_Int64_Int128(self._value)

    let quotient_ = Builtin.udiv_Int128(lhs_, rhs_)
    let remainder_ = Builtin.urem_Int128(lhs_, rhs_)

    let quotient = UInt(
      Builtin.truncOrBitCast_Int128_Int64(quotient_))
    let remainder = UInt(
      Builtin.truncOrBitCast_Int128_Int64(remainder_))

    return (quotient: quotient, remainder: remainder)
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1591)
  }
  @_transparent public var byteSwapped: Swift.UInt {
    @_transparent get {
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1599)
    return UInt(Builtin.int_bswap_Int64(_value))
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1601)
  }
  }
  public var _value: Builtin.Int64
  @_transparent public init(_ _v: Builtin.Word) {
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1614)
    self._value = Builtin.zextOrBitCast_Word_Int64(_v)
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1616)
  }
  @_transparent public var _builtinWordValue: Builtin.Word {
    @_transparent get {
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1624)
    return Builtin.truncOrBitCast_Int64_Word(_value)
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1626)
  }
  }
  @inlinable @inline(__always) public func signum() -> Swift.UInt {
    let isPositive = UInt(Builtin.zext_Int1_Int64(
      (self > (0 as UInt))._value))
    return isPositive | (self &>> 63)
  }
  public typealias Stride = Swift.Int
}
extension UInt : Swift.Hashable {
  @inlinable public func hash(into hasher: inout Swift.Hasher) {
    hasher._combine(UInt(_value))
  }
  @inlinable public func _rawHashValue(seed: Swift.Int) -> Swift.Int {
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1658)
    return Hasher._hash(seed: seed, UInt64(_value))
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1667)
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension UInt : Swift._HasCustomAnyHashableRepresentation {
  public func _toCustomAnyHashable() -> Swift.AnyHashable?
}
extension UInt {
  @_transparent public static func & (lhs: Swift.UInt, rhs: Swift.UInt) -> Swift.UInt {
    var lhs = lhs
    lhs &= rhs
    return lhs
  }
  @_transparent public static func | (lhs: Swift.UInt, rhs: Swift.UInt) -> Swift.UInt {
    var lhs = lhs
    lhs |= rhs
    return lhs
  }
  @_transparent public static func ^ (lhs: Swift.UInt, rhs: Swift.UInt) -> Swift.UInt {
    var lhs = lhs
    lhs ^= rhs
    return lhs
  }
  @_transparent public static func &>> (lhs: Swift.UInt, rhs: Swift.UInt) -> Swift.UInt {
    var lhs = lhs
    lhs &>>= rhs
    return lhs
  }
  @_transparent public static func &<< (lhs: Swift.UInt, rhs: Swift.UInt) -> Swift.UInt {
    var lhs = lhs
    lhs &<<= rhs
    return lhs
  }
  @_transparent public static func + (lhs: Swift.UInt, rhs: Swift.UInt) -> Swift.UInt {
    var lhs = lhs
    lhs += rhs
    return lhs
  }
  @_transparent public static func - (lhs: Swift.UInt, rhs: Swift.UInt) -> Swift.UInt {
    var lhs = lhs
    lhs -= rhs
    return lhs
  }
  @_transparent public static func * (lhs: Swift.UInt, rhs: Swift.UInt) -> Swift.UInt {
    var lhs = lhs
    lhs *= rhs
    return lhs
  }
  @_transparent public static func / (lhs: Swift.UInt, rhs: Swift.UInt) -> Swift.UInt {
    var lhs = lhs
    lhs /= rhs
    return lhs
  }
  @_transparent public static func % (lhs: Swift.UInt, rhs: Swift.UInt) -> Swift.UInt {
    var lhs = lhs
    lhs %= rhs
    return lhs
  }
  @_transparent public static func <= (lhs: Swift.UInt, rhs: Swift.UInt) -> Swift.Bool {
    return !(rhs < lhs)
  }
  @_transparent public static func >= (lhs: Swift.UInt, rhs: Swift.UInt) -> Swift.Bool {
    return !(lhs < rhs)
  }
  @_transparent public static func > (lhs: Swift.UInt, rhs: Swift.UInt) -> Swift.Bool {
    return rhs < lhs
  }
}
@frozen public struct Int : Swift.FixedWidthInteger, Swift.SignedInteger, Swift._ExpressibleByBuiltinIntegerLiteral {
  public typealias IntegerLiteralType = Swift.Int
  @_transparent public init(_builtinIntegerLiteral x: Builtin.IntLiteral) {
    _value = Builtin.s_to_s_checked_trunc_IntLiteral_Int64(x).0
  }
  @_transparent public init(bitPattern x: Swift.UInt) {
    _value = x._value
  }
  @_transparent public init(_ source: Swift.Float) {
    _precondition(source.isFinite,
      "Float value cannot be converted to Int because it is either infinite or NaN")
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1164)
    _precondition(source > -9223373136366403584.0,
      "Float value cannot be converted to Int because the result would be less than Int.min")
    _precondition(source < 9223372036854775808.0,
      "Float value cannot be converted to Int because the result would be greater than Int.max")
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1169)
    self._value = Builtin.fptosi_FPIEEE32_Int64(source._value)
  }
  @_transparent public init?(exactly source: Swift.Float) {
    // The value passed as `source` must not be infinite, NaN, or exceed the
    // bounds of the integer type; the result of `fptosi` or `fptoui` is
    // undefined if it overflows.
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1195)
    guard source > -9223373136366403584.0 && source < 9223372036854775808.0 else {
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1199)
      return nil
    }
    guard source == source.rounded(.towardZero) else {
      return nil
    }
    self._value = Builtin.fptosi_FPIEEE32_Int64(source._value)
  }
  @_transparent public init(_ source: Swift.Double) {
    _precondition(source.isFinite,
      "Double value cannot be converted to Int because it is either infinite or NaN")
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1164)
    _precondition(source > -9223372036854777856.0,
      "Double value cannot be converted to Int because the result would be less than Int.min")
    _precondition(source < 9223372036854775808.0,
      "Double value cannot be converted to Int because the result would be greater than Int.max")
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1169)
    self._value = Builtin.fptosi_FPIEEE64_Int64(source._value)
  }
  @_transparent public init?(exactly source: Swift.Double) {
    // The value passed as `source` must not be infinite, NaN, or exceed the
    // bounds of the integer type; the result of `fptosi` or `fptoui` is
    // undefined if it overflows.
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1195)
    guard source > -9223372036854777856.0 && source < 9223372036854775808.0 else {
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1199)
      return nil
    }
    guard source == source.rounded(.towardZero) else {
      return nil
    }
    self._value = Builtin.fptosi_FPIEEE64_Int64(source._value)
  }
  @_transparent public init(_ source: Swift.Float80) {
    _precondition(source.isFinite,
      "Float80 value cannot be converted to Int because it is either infinite or NaN")
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1164)
    _precondition(source > -9223372036854775809.0,
      "Float80 value cannot be converted to Int because the result would be less than Int.min")
    _precondition(source < 9223372036854775808.0,
      "Float80 value cannot be converted to Int because the result would be greater than Int.max")
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1169)
    self._value = Builtin.fptosi_FPIEEE80_Int64(source._value)
  }
  @_transparent public init?(exactly source: Swift.Float80) {
    // The value passed as `source` must not be infinite, NaN, or exceed the
    // bounds of the integer type; the result of `fptosi` or `fptoui` is
    // undefined if it overflows.
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1195)
    guard source > -9223372036854775809.0 && source < 9223372036854775808.0 else {
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1199)
      return nil
    }
    guard source == source.rounded(.towardZero) else {
      return nil
    }
    self._value = Builtin.fptosi_FPIEEE80_Int64(source._value)
  }
  @_transparent public static func == (lhs: Swift.Int, rhs: Swift.Int) -> Swift.Bool {
    return Bool(Builtin.cmp_eq_Int64(lhs._value, rhs._value))
  }
  @_transparent public static func < (lhs: Swift.Int, rhs: Swift.Int) -> Swift.Bool {
    return Bool(Builtin.cmp_slt_Int64(lhs._value, rhs._value))
  }
  @_transparent public static func += (lhs: inout Swift.Int, rhs: Swift.Int) {
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1247)
    let (result, overflow) =
      Builtin.sadd_with_overflow_Int64(
        lhs._value, rhs._value, true._value)
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1251)
    Builtin.condfail_message(overflow,
      StaticString("arithmetic overflow").unsafeRawPointer)
    lhs = Int(result)
  }
  @_transparent public static func -= (lhs: inout Swift.Int, rhs: Swift.Int) {
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1247)
    let (result, overflow) =
      Builtin.ssub_with_overflow_Int64(
        lhs._value, rhs._value, true._value)
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1251)
    Builtin.condfail_message(overflow,
      StaticString("arithmetic overflow").unsafeRawPointer)
    lhs = Int(result)
  }
  @_transparent public static func *= (lhs: inout Swift.Int, rhs: Swift.Int) {
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1247)
    let (result, overflow) =
      Builtin.smul_with_overflow_Int64(
        lhs._value, rhs._value, true._value)
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1251)
    Builtin.condfail_message(overflow,
      StaticString("arithmetic overflow").unsafeRawPointer)
    lhs = Int(result)
  }
  @_transparent public static func /= (lhs: inout Swift.Int, rhs: Swift.Int) {
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1229)
    // No LLVM primitives for checking overflow of division operations, so we
    // check manually.
    if _slowPath(rhs == (0 as Int)) {
      _preconditionFailure(
        "Division by zero")
    }
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1236)
    if _slowPath(
      lhs == Int.min && rhs == (-1 as Int)
    ) {
      _preconditionFailure(
        "Division results in an overflow")
    }
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1243)
    let (result, overflow) =
      (Builtin.sdiv_Int64(lhs._value, rhs._value),
      false._value)
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1251)
    Builtin.condfail_message(overflow,
      StaticString("arithmetic overflow").unsafeRawPointer)
    lhs = Int(result)
  }
  @_transparent public func addingReportingOverflow(_ other: Swift.Int) -> (partialValue: Swift.Int, overflow: Swift.Bool) {
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1282)

    let (newStorage, overflow) =
      Builtin.sadd_with_overflow_Int64(
        self._value, other._value, false._value)
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1287)

    return (
      partialValue: Int(newStorage),
      overflow: Bool(overflow))
  }
  @_transparent public func subtractingReportingOverflow(_ other: Swift.Int) -> (partialValue: Swift.Int, overflow: Swift.Bool) {
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1282)

    let (newStorage, overflow) =
      Builtin.ssub_with_overflow_Int64(
        self._value, other._value, false._value)
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1287)

    return (
      partialValue: Int(newStorage),
      overflow: Bool(overflow))
  }
  @_transparent public func multipliedReportingOverflow(by other: Swift.Int) -> (partialValue: Swift.Int, overflow: Swift.Bool) {
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1282)

    let (newStorage, overflow) =
      Builtin.smul_with_overflow_Int64(
        self._value, other._value, false._value)
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1287)

    return (
      partialValue: Int(newStorage),
      overflow: Bool(overflow))
  }
  @_transparent public func dividedReportingOverflow(by other: Swift.Int) -> (partialValue: Swift.Int, overflow: Swift.Bool) {
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1265)
    // No LLVM primitives for checking overflow of division operations, so we
    // check manually.
    if _slowPath(other == (0 as Int)) {
      return (partialValue: self, overflow: true)
    }
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1271)
    if _slowPath(self == Int.min && other == (-1 as Int)) {
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1273)
      return (partialValue: self, overflow: true)
    }
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1276)

    let (newStorage, overflow) = (
      Builtin.sdiv_Int64(self._value, other._value),
      false._value)

// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1287)

    return (
      partialValue: Int(newStorage),
      overflow: Bool(overflow))
  }
  @_transparent public func remainderReportingOverflow(dividingBy other: Swift.Int) -> (partialValue: Swift.Int, overflow: Swift.Bool) {
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1265)
    // No LLVM primitives for checking overflow of division operations, so we
    // check manually.
    if _slowPath(other == (0 as Int)) {
      return (partialValue: self, overflow: true)
    }
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1271)
    if _slowPath(self == Int.min && other == (-1 as Int)) {
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1273)
      return (partialValue: 0, overflow: true)
    }
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1276)

    let (newStorage, overflow) = (
      Builtin.srem_Int64(self._value, other._value),
      false._value)

// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1287)

    return (
      partialValue: Int(newStorage),
      overflow: Bool(overflow))
  }
  @_transparent public static func %= (lhs: inout Swift.Int, rhs: Swift.Int) {
    // No LLVM primitives for checking overflow of division operations, so we
    // check manually.
    if _slowPath(rhs == (0 as Int)) {
      _preconditionFailure(
        "Division by zero in remainder operation")
    }
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1304)
    if _slowPath(lhs == Int.min && rhs == (-1 as Int)) {
      _preconditionFailure(
        "Division results in an overflow in remainder operation")
    }
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1309)

    let (newStorage, _) = (
      Builtin.srem_Int64(lhs._value, rhs._value),
      false._value)
    lhs = Int(newStorage)
  }
  @_transparent public init(_ _value: Builtin.Int64) {
    self._value = _value
  }
  @_transparent public static func &= (lhs: inout Swift.Int, rhs: Swift.Int) {
    lhs = Int(Builtin.and_Int64(lhs._value, rhs._value))
  }
  @_transparent public static func |= (lhs: inout Swift.Int, rhs: Swift.Int) {
    lhs = Int(Builtin.or_Int64(lhs._value, rhs._value))
  }
  @_transparent public static func ^= (lhs: inout Swift.Int, rhs: Swift.Int) {
    lhs = Int(Builtin.xor_Int64(lhs._value, rhs._value))
  }
  @_transparent public static func &>>= (lhs: inout Swift.Int, rhs: Swift.Int) {
    let rhs_ = rhs & 63
    lhs = Int(
      Builtin.ashr_Int64(lhs._value, rhs_._value))
  }
  @_transparent public static func &<<= (lhs: inout Swift.Int, rhs: Swift.Int) {
    let rhs_ = rhs & 63
    lhs = Int(
      Builtin.shl_Int64(lhs._value, rhs_._value))
  }
  @_transparent public static var bitWidth: Swift.Int {
    @_transparent get { return 64 }
  }
  @_transparent public var leadingZeroBitCount: Swift.Int {
    @_transparent get {
    return Int(
      Int(
        Builtin.int_ctlz_Int64(self._value, false._value)
      )._lowWord._value)
  }
  }
  @_transparent public var trailingZeroBitCount: Swift.Int {
    @_transparent get {
    return Int(
      Int(
        Builtin.int_cttz_Int64(self._value, false._value)
      )._lowWord._value)
  }
  }
  @_transparent public var nonzeroBitCount: Swift.Int {
    @_transparent get {
    return Int(
      Int(
        Builtin.int_ctpop_Int64(self._value)
      )._lowWord._value)
  }
  }
  @frozen public struct Words : Swift.RandomAccessCollection {
    public typealias Indices = Swift.Range<Swift.Int>
    public typealias SubSequence = Swift.Slice<Swift.Int.Words>
    @usableFromInline
    internal var _value: Swift.Int
    @inlinable public init(_ value: Swift.Int) {
      self._value = value
    }
    @inlinable public var count: Swift.Int {
      get {
      return (64 + 64 - 1) / 64
    }
    }
    @inlinable public var startIndex: Swift.Int {
      get { return 0 }
    }
    @inlinable public var endIndex: Swift.Int {
      get { return count }
    }
    @inlinable public var indices: Swift.Int.Words.Indices {
      get { return startIndex ..< endIndex }
    }
    @_transparent public func index(after i: Swift.Int) -> Swift.Int { return i + 1 }
    @_transparent public func index(before i: Swift.Int) -> Swift.Int { return i - 1 }
    @inlinable public subscript(position: Swift.Int) -> Swift.UInt {
      get {
        _precondition(position >= 0, "Negative word index")
        _precondition(position < endIndex, "Word index out of range")
        let shift = UInt(position._value) &* 64
        _internalInvariant(shift < UInt(_value.bitWidth._value))
        return (_value &>> Int(_truncatingBits: shift))._lowWord
      }
    }
    public typealias Element = Swift.UInt
    public typealias Index = Swift.Int
    public typealias Iterator = Swift.IndexingIterator<Swift.Int.Words>
  }
  @_transparent public var words: Swift.Int.Words {
    @_transparent get {
    return Words(self)
  }
  }
  @_transparent public var _lowWord: Swift.UInt {
    @_transparent get {
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1462)
    return UInt(
      Builtin.sextOrBitCast_Int64_Int64(_value)
    )
  }
  }
  @_transparent public init(_truncatingBits bits: Swift.UInt) {
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1471)
    self.init(
      Builtin.truncOrBitCast_Int64_Int64(bits._value))
  }
  public typealias Magnitude = Swift.UInt
  @_transparent public var magnitude: Swift.UInt {
    @_transparent get {
    let base = UInt(_value)
    return self < (0 as Int) ? ~base &+ 1 : base
  }
  }
  @inlinable public func multipliedFullWidth(by other: Swift.Int) -> (high: Swift.Int, low: Swift.Int.Magnitude) {
    // FIXME(integers): tests
    let lhs_ = Builtin.sext_Int64_Int128(self._value)
    let rhs_ = Builtin.sext_Int64_Int128(other._value)

    let res = Builtin.mul_Int128(lhs_, rhs_)
    let low = Int.Magnitude(Builtin.truncOrBitCast_Int128_Int64(res))
    let shift = Builtin.zextOrBitCast_Int8_Int128(UInt8(64)._value)
    let shifted = Builtin.ashr_Int128(res, shift)
    let high = Int(Builtin.truncOrBitCast_Int128_Int64(shifted))
    return (high: high, low: low)
  }
  @inlinable public func dividingFullWidth(_ dividend: (high: Swift.Int, low: Swift.Int.Magnitude)) -> (quotient: Swift.Int, remainder: Swift.Int) {
    // FIXME(integers): tests
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1572)
    // FIXME(integers): handle division by zero and overflows
    _precondition(self != 0, "Division by zero")
    let lhsHigh = Builtin.sext_Int64_Int128(dividend.high._value)
    let shift = Builtin.zextOrBitCast_Int8_Int128(UInt8(64)._value)
    let lhsHighShifted = Builtin.shl_Int128(lhsHigh, shift)
    let lhsLow = Builtin.zext_Int64_Int128(dividend.low._value)
    let lhs_ = Builtin.or_Int128(lhsHighShifted, lhsLow)
    let rhs_ = Builtin.sext_Int64_Int128(self._value)

    let quotient_ = Builtin.sdiv_Int128(lhs_, rhs_)
    let remainder_ = Builtin.srem_Int128(lhs_, rhs_)

    let quotient = Int(
      Builtin.truncOrBitCast_Int128_Int64(quotient_))
    let remainder = Int(
      Builtin.truncOrBitCast_Int128_Int64(remainder_))

    return (quotient: quotient, remainder: remainder)
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1591)
  }
  @_transparent public var byteSwapped: Swift.Int {
    @_transparent get {
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1599)
    return Int(Builtin.int_bswap_Int64(_value))
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1601)
  }
  }
  public var _value: Builtin.Int64
  @_transparent public init(_ _v: Builtin.Word) {
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1614)
    self._value = Builtin.sextOrBitCast_Word_Int64(_v)
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1616)
  }
  @_transparent public var _builtinWordValue: Builtin.Word {
    @_transparent get {
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1624)
    return Builtin.truncOrBitCast_Int64_Word(_value)
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1626)
  }
  }
  @inlinable @inline(__always) public func signum() -> Swift.Int {
    let isPositive = Int(Builtin.zext_Int1_Int64(
      (self > (0 as Int))._value))
    return isPositive | (self &>> 63)
  }
  public typealias Stride = Swift.Int
}
extension Int : Swift.Hashable {
  @inlinable public func hash(into hasher: inout Swift.Hasher) {
    hasher._combine(UInt(_value))
  }
  @inlinable public func _rawHashValue(seed: Swift.Int) -> Swift.Int {
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1658)
    return Hasher._hash(seed: seed, UInt64(_value))
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1667)
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension Int : Swift._HasCustomAnyHashableRepresentation {
  public func _toCustomAnyHashable() -> Swift.AnyHashable?
}
extension Int {
  @_transparent public static func & (lhs: Swift.Int, rhs: Swift.Int) -> Swift.Int {
    var lhs = lhs
    lhs &= rhs
    return lhs
  }
  @_transparent public static func | (lhs: Swift.Int, rhs: Swift.Int) -> Swift.Int {
    var lhs = lhs
    lhs |= rhs
    return lhs
  }
  @_transparent public static func ^ (lhs: Swift.Int, rhs: Swift.Int) -> Swift.Int {
    var lhs = lhs
    lhs ^= rhs
    return lhs
  }
  @_transparent public static func &>> (lhs: Swift.Int, rhs: Swift.Int) -> Swift.Int {
    var lhs = lhs
    lhs &>>= rhs
    return lhs
  }
  @_transparent public static func &<< (lhs: Swift.Int, rhs: Swift.Int) -> Swift.Int {
    var lhs = lhs
    lhs &<<= rhs
    return lhs
  }
  @_transparent public static func + (lhs: Swift.Int, rhs: Swift.Int) -> Swift.Int {
    var lhs = lhs
    lhs += rhs
    return lhs
  }
  @_transparent public static func - (lhs: Swift.Int, rhs: Swift.Int) -> Swift.Int {
    var lhs = lhs
    lhs -= rhs
    return lhs
  }
  @_transparent public static func * (lhs: Swift.Int, rhs: Swift.Int) -> Swift.Int {
    var lhs = lhs
    lhs *= rhs
    return lhs
  }
  @_transparent public static func / (lhs: Swift.Int, rhs: Swift.Int) -> Swift.Int {
    var lhs = lhs
    lhs /= rhs
    return lhs
  }
  @_transparent public static func % (lhs: Swift.Int, rhs: Swift.Int) -> Swift.Int {
    var lhs = lhs
    lhs %= rhs
    return lhs
  }
  @_transparent public static func <= (lhs: Swift.Int, rhs: Swift.Int) -> Swift.Bool {
    return !(rhs < lhs)
  }
  @_transparent public static func >= (lhs: Swift.Int, rhs: Swift.Int) -> Swift.Bool {
    return !(lhs < rhs)
  }
  @_transparent public static func > (lhs: Swift.Int, rhs: Swift.Int) -> Swift.Bool {
    return rhs < lhs
  }
}
@_transparent public func _assumeNonNegative(_ x: Swift.Int) -> Swift.Int {
  _internalInvariant(x >= (0 as Int))
  return Int(Builtin.assumeNonNegative_Int64(x._value))
}
extension Int {
  @_transparent public func distance(to other: Swift.Int) -> Swift.Int {
    return other - self
  }
  @_transparent public func advanced(by n: Swift.Int) -> Swift.Int {
    return self + n
  }
}
@_transparent @inlinable internal func _unsafePlus(_ lhs: Swift.Int, _ rhs: Swift.Int) -> Swift.Int {
  return lhs &+ rhs
}
@_transparent @inlinable internal func _unsafeMinus(_ lhs: Swift.Int, _ rhs: Swift.Int) -> Swift.Int {
  return lhs &- rhs
}
@frozen public struct UnsafeMutableBufferPointer<Element> {
  @usableFromInline
  internal let _position: Swift.UnsafeMutablePointer<Element>?
  public let count: Swift.Int
}
extension UnsafeMutableBufferPointer {
  public typealias Iterator = Swift.UnsafeBufferPointer<Element>.Iterator
}
extension UnsafeMutableBufferPointer : Swift.Sequence {
  @inlinable public func makeIterator() -> Swift.UnsafeMutableBufferPointer<Element>.Iterator {
    guard let start = _position else {
      return Iterator(_position: nil, _end: nil)
    }
    return Iterator(_position: start, _end: start + count)
  }
  @inlinable public func _copyContents(initializing destination: Swift.UnsafeMutableBufferPointer<Element>) -> (Swift.UnsafeMutableBufferPointer<Element>.Iterator, Swift.UnsafeMutableBufferPointer<Element>.Index) {
    guard !isEmpty && !destination.isEmpty else { return (makeIterator(), 0) }
    let s = self.baseAddress._unsafelyUnwrappedUnchecked
    let d = destination.baseAddress._unsafelyUnwrappedUnchecked
    let n = Swift.min(destination.count, self.count)
    d.initialize(from: s, count: n)
    return (Iterator(_position: s + n, _end: s + count), n)
  }
}
extension UnsafeMutableBufferPointer : Swift.MutableCollection, Swift.RandomAccessCollection {
  public typealias Index = Swift.Int
  public typealias Indices = Swift.Range<Swift.Int>
  @inlinable public var startIndex: Swift.Int {
    get { return 0 }
  }
  @inlinable public var endIndex: Swift.Int {
    get { return count }
  }
  @inlinable public func index(after i: Swift.Int) -> Swift.Int {
    // NOTE: this is a manual specialization of index movement for a Strideable
    // index that is required for UnsafeBufferPointer performance. The
    // optimizer is not capable of creating partial specializations yet.
    // NOTE: Range checks are not performed here, because it is done later by
    // the subscript function.
    return i + 1
  }
  @inlinable public func formIndex(after i: inout Swift.Int) {
    // NOTE: this is a manual specialization of index movement for a Strideable
    // index that is required for UnsafeBufferPointer performance. The
    // optimizer is not capable of creating partial specializations yet.
    // NOTE: Range checks are not performed here, because it is done later by
    // the subscript function.
    i += 1
  }
  @inlinable public func index(before i: Swift.Int) -> Swift.Int {
    // NOTE: this is a manual specialization of index movement for a Strideable
    // index that is required for UnsafeBufferPointer performance. The
    // optimizer is not capable of creating partial specializations yet.
    // NOTE: Range checks are not performed here, because it is done later by
    // the subscript function.
    return i - 1
  }
  @inlinable public func formIndex(before i: inout Swift.Int) {
    // NOTE: this is a manual specialization of index movement for a Strideable
    // index that is required for UnsafeBufferPointer performance. The
    // optimizer is not capable of creating partial specializations yet.
    // NOTE: Range checks are not performed here, because it is done later by
    // the subscript function.
    i -= 1
  }
  @inlinable public func index(_ i: Swift.Int, offsetBy n: Swift.Int) -> Swift.Int {
    // NOTE: this is a manual specialization of index movement for a Strideable
    // index that is required for UnsafeBufferPointer performance. The
    // optimizer is not capable of creating partial specializations yet.
    // NOTE: Range checks are not performed here, because it is done later by
    // the subscript function.
    return i + n
  }
  @inlinable public func index(_ i: Swift.Int, offsetBy n: Swift.Int, limitedBy limit: Swift.Int) -> Swift.Int? {
    // NOTE: this is a manual specialization of index movement for a Strideable
    // index that is required for UnsafeBufferPointer performance. The
    // optimizer is not capable of creating partial specializations yet.
    // NOTE: Range checks are not performed here, because it is done later by
    // the subscript function.
    let l = limit - i
    if n > 0 ? l >= 0 && l < n : l <= 0 && n < l {
      return nil
    }
    return i + n
  }
  @inlinable public func distance(from start: Swift.Int, to end: Swift.Int) -> Swift.Int {
    // NOTE: this is a manual specialization of index movement for a Strideable
    // index that is required for UnsafeBufferPointer performance. The
    // optimizer is not capable of creating partial specializations yet.
    // NOTE: Range checks are not performed here, because it is done later by
    // the subscript function.
    // NOTE: We allow the subtraction to silently overflow in release builds
    // to eliminate a superflous check when `start` and `end` are both valid
    // indices. (The operation can only overflow if `start` is negative, which
    // implies it's an invalid index.) `Collection` does not specify what
    // `distance` should return when given an invalid index pair.
    let result = end.subtractingReportingOverflow(start)
    _debugPrecondition(!result.overflow)
    return result.partialValue
  }
  @inlinable public func _failEarlyRangeCheck(_ index: Swift.Int, bounds: Swift.Range<Swift.Int>) {
    // NOTE: In release mode, this method is a no-op for performance reasons.
    _debugPrecondition(index >= bounds.lowerBound)
    _debugPrecondition(index < bounds.upperBound)
  }
  @inlinable public func _failEarlyRangeCheck(_ range: Swift.Range<Swift.Int>, bounds: Swift.Range<Swift.Int>) {
    // NOTE: In release mode, this method is a no-op for performance reasons.
    _debugPrecondition(range.lowerBound >= bounds.lowerBound)
    _debugPrecondition(range.upperBound <= bounds.upperBound)
  }
  @inlinable public var indices: Swift.UnsafeMutableBufferPointer<Element>.Indices {
    get {
    return startIndex..<endIndex
  }
  }
  @inlinable public subscript(i: Swift.Int) -> Element {
    get {
      _debugPrecondition(i >= 0)
      _debugPrecondition(i < endIndex)
      return _position._unsafelyUnwrappedUnchecked[i]
    }
    nonmutating _modify {
      _debugPrecondition(i >= 0)
      _debugPrecondition(i < endIndex)
      yield &_position._unsafelyUnwrappedUnchecked[i]
    }
  }
  @inlinable internal subscript(_unchecked i: Swift.Int) -> Element {
    get {
      _internalInvariant(i >= 0)
      _internalInvariant(i < endIndex)
      return _position._unsafelyUnwrappedUnchecked[i]
    }
    nonmutating _modify {
      _internalInvariant(i >= 0)
      _internalInvariant(i < endIndex)
      yield &_position._unsafelyUnwrappedUnchecked[i]
    }
  }
  @inlinable public subscript(bounds: Swift.Range<Swift.Int>) -> Swift.Slice<Swift.UnsafeMutableBufferPointer<Element>> {
    get {
      _debugPrecondition(bounds.lowerBound >= startIndex)
      _debugPrecondition(bounds.upperBound <= endIndex)
      return Slice(
        base: self, bounds: bounds)
    }
    nonmutating set {
      _debugPrecondition(bounds.lowerBound >= startIndex)
      _debugPrecondition(bounds.upperBound <= endIndex)
      _debugPrecondition(bounds.count == newValue.count)

      // FIXME: swift-3-indexing-model: tests.
      if !newValue.isEmpty {
        (_position! + bounds.lowerBound).assign(
          from: newValue.base._position! + newValue.startIndex,
          count: newValue.count)
      }
    }
  }
  @inlinable public func swapAt(_ i: Swift.Int, _ j: Swift.Int) {
    guard i != j else { return }
    _debugPrecondition(i >= 0 && j >= 0)
    _debugPrecondition(i < endIndex && j < endIndex)
    let pi = (_position! + i)
    let pj = (_position! + j)
    let tmp = pi.move()
    pi.moveInitialize(from: pj, count: 1)
    pj.initialize(to: tmp)
  }
  public typealias SubSequence = Swift.Slice<Swift.UnsafeMutableBufferPointer<Element>>
}
extension UnsafeMutableBufferPointer {
  @_alwaysEmitIntoClient internal init(@_nonEphemeral _uncheckedStart start: Swift.UnsafeMutablePointer<Element>?, count: Swift.Int) {
    _position = start
    self.count = count
  }
  @inlinable public init(@_nonEphemeral start: Swift.UnsafeMutablePointer<Element>?, count: Swift.Int) {
    _debugPrecondition(
      count >= 0, "UnsafeMutableBufferPointer with negative count")
    _debugPrecondition(
      count == 0 || start != nil,
      "UnsafeMutableBufferPointer has a nil start and nonzero count")
    self.init(_uncheckedStart: start, count: _assumeNonNegative(count))
  }
  @inlinable public init(_empty: ()) {
    _position = nil
    count = 0
  }
  @inlinable public init(mutating other: Swift.UnsafeBufferPointer<Element>) {
    _position = UnsafeMutablePointer<Element>(mutating: other._position)
    count = other.count
  }
  @inlinable public mutating func _withUnsafeMutableBufferPointerIfSupported<R>(_ body: (inout Swift.UnsafeMutableBufferPointer<Element>) throws -> R) rethrows -> R? {
    return try body(&self)
  }
  @inlinable public mutating func withContiguousMutableStorageIfAvailable<R>(_ body: (inout Swift.UnsafeMutableBufferPointer<Element>) throws -> R) rethrows -> R? {
    let (oldBase, oldCount) = (self.baseAddress, self.count)
    defer { 
      _debugPrecondition((oldBase, oldCount) == (self.baseAddress, self.count),
      "UnsafeMutableBufferPointer.withUnsafeMutableBufferPointer: replacing the buffer is not allowed")
    } 
    return try body(&self)
  }
  @inlinable public func withContiguousStorageIfAvailable<R>(_ body: (Swift.UnsafeBufferPointer<Element>) throws -> R) rethrows -> R? {
    return try body(UnsafeBufferPointer(self))
  }
  @inlinable public init(rebasing slice: Swift.Slice<Swift.UnsafeMutableBufferPointer<Element>>) {
    let base = slice.base.baseAddress?.advanced(by: slice.startIndex)
    let count = slice.endIndex &- slice.startIndex
    self.init(start: base, count: count)
  }
  @inlinable public func deallocate() {
    _position?.deallocate()
  }
  @inlinable public static func allocate(capacity count: Swift.Int) -> Swift.UnsafeMutableBufferPointer<Element> {
    let size = MemoryLayout<Element>.stride * count
    // For any alignment <= _minAllocationAlignment, force alignment = 0.
    // This forces the runtime's "aligned" allocation path so that
    // deallocation does not require the original alignment.
    //
    // The runtime guarantees:
    //
    // align == 0 || align > _minAllocationAlignment:
    //   Runtime uses "aligned allocation".
    //
    // 0 < align <= _minAllocationAlignment:
    //   Runtime may use either malloc or "aligned allocation".
    var align = Builtin.alignof(Element.self)
    if Int(align) <= _minAllocationAlignment() {
      align = (0)._builtinWordValue
    }
    let raw  = Builtin.allocRaw(size._builtinWordValue, align)
    Builtin.bindMemory(raw, count._builtinWordValue, Element.self)
    return UnsafeMutableBufferPointer(
      start: UnsafeMutablePointer(raw), count: count)
  }
  @inlinable public func initialize(repeating repeatedValue: Element) {
    guard let dstBase = _position else {
      return
    }

    dstBase.initialize(repeating: repeatedValue, count: count)
  }
  @inlinable public func assign(repeating repeatedValue: Element) {
    guard let dstBase = _position else {
      return
    }

    dstBase.assign(repeating: repeatedValue, count: count)
  }
  @inlinable public func withMemoryRebound<T, Result>(to type: T.Type, _ body: (Swift.UnsafeMutableBufferPointer<T>) throws -> Result) rethrows -> Result {
    if let base = _position {
      _debugPrecondition(MemoryLayout<Element>.stride == MemoryLayout<T>.stride)
      Builtin.bindMemory(base._rawValue, count._builtinWordValue, T.self)
      defer {
        Builtin.bindMemory(base._rawValue, count._builtinWordValue, Element.self)
      }

      return try body(UnsafeMutableBufferPointer<T>(
        start: UnsafeMutablePointer<T>(base._rawValue), count: count))
    }
    else {
      return try body(UnsafeMutableBufferPointer<T>(start: nil, count: 0))
    }
  }
  @inlinable public var baseAddress: Swift.UnsafeMutablePointer<Element>? {
    get {
    return _position
  }
  }
}
extension UnsafeMutableBufferPointer : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
@frozen public struct UnsafeBufferPointer<Element> {
  @usableFromInline
  internal let _position: Swift.UnsafePointer<Element>?
  public let count: Swift.Int
}
extension UnsafeBufferPointer {
  @frozen public struct Iterator {
    @usableFromInline
    internal var _position: Swift.UnsafePointer<Swift.UnsafeBufferPointer<Element>.Iterator.Element>?, _end: Swift.UnsafePointer<Swift.UnsafeBufferPointer<Element>.Iterator.Element>?
    @inlinable public init(_position: Swift.UnsafePointer<Swift.UnsafeBufferPointer<Element>.Iterator.Element>?, _end: Swift.UnsafePointer<Swift.UnsafeBufferPointer<Element>.Iterator.Element>?) {
        self._position = _position
        self._end = _end
    }
  }
}
extension UnsafeBufferPointer.Iterator : Swift.IteratorProtocol {
  @inlinable public mutating func next() -> Element? {
    guard let start = _position else {
      return nil
    }
    _internalInvariant(_end != nil, "inconsistent _position, _end pointers")

    if start == _end._unsafelyUnwrappedUnchecked { return nil }

    let result = start.pointee
    _position  = start + 1
    return result
  }
}
extension UnsafeBufferPointer : Swift.Sequence {
  @inlinable public func makeIterator() -> Swift.UnsafeBufferPointer<Element>.Iterator {
    guard let start = _position else {
      return Iterator(_position: nil, _end: nil)
    }
    return Iterator(_position: start, _end: start + count)
  }
  @inlinable public func _copyContents(initializing destination: Swift.UnsafeMutableBufferPointer<Element>) -> (Swift.UnsafeBufferPointer<Element>.Iterator, Swift.UnsafeMutableBufferPointer<Element>.Index) {
    guard !isEmpty && !destination.isEmpty else { return (makeIterator(), 0) }
    let s = self.baseAddress._unsafelyUnwrappedUnchecked
    let d = destination.baseAddress._unsafelyUnwrappedUnchecked
    let n = Swift.min(destination.count, self.count)
    d.initialize(from: s, count: n)
    return (Iterator(_position: s + n, _end: s + count), n)
  }
}
extension UnsafeBufferPointer : Swift.Collection, Swift.RandomAccessCollection {
  public typealias Index = Swift.Int
  public typealias Indices = Swift.Range<Swift.Int>
  @inlinable public var startIndex: Swift.Int {
    get { return 0 }
  }
  @inlinable public var endIndex: Swift.Int {
    get { return count }
  }
  @inlinable public func index(after i: Swift.Int) -> Swift.Int {
    // NOTE: this is a manual specialization of index movement for a Strideable
    // index that is required for UnsafeBufferPointer performance. The
    // optimizer is not capable of creating partial specializations yet.
    // NOTE: Range checks are not performed here, because it is done later by
    // the subscript function.
    return i + 1
  }
  @inlinable public func formIndex(after i: inout Swift.Int) {
    // NOTE: this is a manual specialization of index movement for a Strideable
    // index that is required for UnsafeBufferPointer performance. The
    // optimizer is not capable of creating partial specializations yet.
    // NOTE: Range checks are not performed here, because it is done later by
    // the subscript function.
    i += 1
  }
  @inlinable public func index(before i: Swift.Int) -> Swift.Int {
    // NOTE: this is a manual specialization of index movement for a Strideable
    // index that is required for UnsafeBufferPointer performance. The
    // optimizer is not capable of creating partial specializations yet.
    // NOTE: Range checks are not performed here, because it is done later by
    // the subscript function.
    return i - 1
  }
  @inlinable public func formIndex(before i: inout Swift.Int) {
    // NOTE: this is a manual specialization of index movement for a Strideable
    // index that is required for UnsafeBufferPointer performance. The
    // optimizer is not capable of creating partial specializations yet.
    // NOTE: Range checks are not performed here, because it is done later by
    // the subscript function.
    i -= 1
  }
  @inlinable public func index(_ i: Swift.Int, offsetBy n: Swift.Int) -> Swift.Int {
    // NOTE: this is a manual specialization of index movement for a Strideable
    // index that is required for UnsafeBufferPointer performance. The
    // optimizer is not capable of creating partial specializations yet.
    // NOTE: Range checks are not performed here, because it is done later by
    // the subscript function.
    return i + n
  }
  @inlinable public func index(_ i: Swift.Int, offsetBy n: Swift.Int, limitedBy limit: Swift.Int) -> Swift.Int? {
    // NOTE: this is a manual specialization of index movement for a Strideable
    // index that is required for UnsafeBufferPointer performance. The
    // optimizer is not capable of creating partial specializations yet.
    // NOTE: Range checks are not performed here, because it is done later by
    // the subscript function.
    let l = limit - i
    if n > 0 ? l >= 0 && l < n : l <= 0 && n < l {
      return nil
    }
    return i + n
  }
  @inlinable public func distance(from start: Swift.Int, to end: Swift.Int) -> Swift.Int {
    // NOTE: this is a manual specialization of index movement for a Strideable
    // index that is required for UnsafeBufferPointer performance. The
    // optimizer is not capable of creating partial specializations yet.
    // NOTE: Range checks are not performed here, because it is done later by
    // the subscript function.
    // NOTE: We allow the subtraction to silently overflow in release builds
    // to eliminate a superflous check when `start` and `end` are both valid
    // indices. (The operation can only overflow if `start` is negative, which
    // implies it's an invalid index.) `Collection` does not specify what
    // `distance` should return when given an invalid index pair.
    let result = end.subtractingReportingOverflow(start)
    _debugPrecondition(!result.overflow)
    return result.partialValue
  }
  @inlinable public func _failEarlyRangeCheck(_ index: Swift.Int, bounds: Swift.Range<Swift.Int>) {
    // NOTE: In release mode, this method is a no-op for performance reasons.
    _debugPrecondition(index >= bounds.lowerBound)
    _debugPrecondition(index < bounds.upperBound)
  }
  @inlinable public func _failEarlyRangeCheck(_ range: Swift.Range<Swift.Int>, bounds: Swift.Range<Swift.Int>) {
    // NOTE: In release mode, this method is a no-op for performance reasons.
    _debugPrecondition(range.lowerBound >= bounds.lowerBound)
    _debugPrecondition(range.upperBound <= bounds.upperBound)
  }
  @inlinable public var indices: Swift.UnsafeBufferPointer<Element>.Indices {
    get {
    return startIndex..<endIndex
  }
  }
  @inlinable public subscript(i: Swift.Int) -> Element {
    get {
      _debugPrecondition(i >= 0)
      _debugPrecondition(i < endIndex)
      return _position._unsafelyUnwrappedUnchecked[i]
    }
  }
  @inlinable internal subscript(_unchecked i: Swift.Int) -> Element {
    get {
      _internalInvariant(i >= 0)
      _internalInvariant(i < endIndex)
      return _position._unsafelyUnwrappedUnchecked[i]
    }
  }
  @inlinable public subscript(bounds: Swift.Range<Swift.Int>) -> Swift.Slice<Swift.UnsafeBufferPointer<Element>> {
    get {
      _debugPrecondition(bounds.lowerBound >= startIndex)
      _debugPrecondition(bounds.upperBound <= endIndex)
      return Slice(
        base: self, bounds: bounds)
    }
  }
  public typealias SubSequence = Swift.Slice<Swift.UnsafeBufferPointer<Element>>
}
extension UnsafeBufferPointer {
  @_alwaysEmitIntoClient internal init(@_nonEphemeral _uncheckedStart start: Swift.UnsafePointer<Element>?, count: Swift.Int) {
    _position = start
    self.count = count
  }
  @inlinable public init(@_nonEphemeral start: Swift.UnsafePointer<Element>?, count: Swift.Int) {
    _debugPrecondition(
      count >= 0, "UnsafeBufferPointer with negative count")
    _debugPrecondition(
      count == 0 || start != nil,
      "UnsafeBufferPointer has a nil start and nonzero count")
    self.init(_uncheckedStart: start, count: _assumeNonNegative(count))
  }
  @inlinable public init(_empty: ()) {
    _position = nil
    count = 0
  }
  @inlinable public init(_ other: Swift.UnsafeMutableBufferPointer<Element>) {
    _position = UnsafePointer<Element>(other._position)
    count = other.count
  }
  @inlinable public func withContiguousStorageIfAvailable<R>(_ body: (Swift.UnsafeBufferPointer<Element>) throws -> R) rethrows -> R? {
    return try body(self)
  }
  @inlinable public init(rebasing slice: Swift.Slice<Swift.UnsafeBufferPointer<Element>>) {
    // NOTE: `Slice` does not guarantee that its start/end indices are valid
    // in `base` -- it merely ensures that `startIndex <= endIndex`.
    // We need manually check that we aren't given an invalid slice,
    // or the resulting collection would allow access that was
    // out-of-bounds with respect to the original base buffer.
    // We only do this in debug builds to prevent a measurable performance
    // degradation wrt passing around pointers not wrapped in a BufferPointer
    // construct.
    _debugPrecondition(
      slice.startIndex >= 0 && slice.endIndex <= slice.base.count,
      "Invalid slice")
    let base = slice.base.baseAddress?.advanced(by: slice.startIndex)
    let count = slice.endIndex &- slice.startIndex
    self.init(start: base, count: count)
  }
  @inlinable public init(rebasing slice: Swift.Slice<Swift.UnsafeMutableBufferPointer<Element>>) {
    let base = slice.base.baseAddress?.advanced(by: slice.startIndex)
    let count = slice.endIndex &- slice.startIndex
    self.init(start: base, count: count)
  }
  @inlinable public func deallocate() {
    _position?.deallocate()
  }
  @inlinable public func withMemoryRebound<T, Result>(to type: T.Type, _ body: (Swift.UnsafeBufferPointer<T>) throws -> Result) rethrows -> Result {
    if let base = _position {
      _debugPrecondition(MemoryLayout<Element>.stride == MemoryLayout<T>.stride)
      Builtin.bindMemory(base._rawValue, count._builtinWordValue, T.self)
      defer {
        Builtin.bindMemory(base._rawValue, count._builtinWordValue, Element.self)
      }

      return try body(UnsafeBufferPointer<T>(
        start: UnsafePointer<T>(base._rawValue), count: count))
    }
    else {
      return try body(UnsafeBufferPointer<T>(start: nil, count: 0))
    }
  }
  @inlinable public var baseAddress: Swift.UnsafePointer<Element>? {
    get {
    return _position
  }
  }
}
extension UnsafeBufferPointer : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
extension UnsafeMutableBufferPointer {
  @inlinable public func initialize<S>(from source: S) -> (S.Iterator, Swift.UnsafeMutableBufferPointer<Element>.Index) where Element == S.Element, S : Swift.Sequence {
    return source._copyContents(initializing: self)
  }
}
@frozen public struct UnsafeMutableRawBufferPointer {
  @usableFromInline
  internal let _position: Swift.UnsafeMutableRawPointer?, _end: Swift.UnsafeMutableRawPointer?
}
extension UnsafeMutableRawBufferPointer {
  public typealias Iterator = Swift.UnsafeRawBufferPointer.Iterator
}
extension UnsafeMutableRawBufferPointer : Swift.Sequence {
  public typealias SubSequence = Swift.Slice<Swift.UnsafeMutableRawBufferPointer>
  @inlinable public func makeIterator() -> Swift.UnsafeMutableRawBufferPointer.Iterator {
    return Iterator(_position: _position, _end: _end)
  }
}
extension UnsafeMutableRawBufferPointer : Swift.MutableCollection {
  public typealias Element = Swift.UInt8
  public typealias Index = Swift.Int
  public typealias Indices = Swift.Range<Swift.Int>
  @inlinable public var startIndex: Swift.UnsafeMutableRawBufferPointer.Index {
    get {
    return 0
  }
  }
  @inlinable public var endIndex: Swift.UnsafeMutableRawBufferPointer.Index {
    get {
    return count
  }
  }
  @inlinable public var indices: Swift.UnsafeMutableRawBufferPointer.Indices {
    get {
    return startIndex..<endIndex
  }
  }
  @inlinable public subscript(i: Swift.Int) -> Swift.UnsafeMutableRawBufferPointer.Element {
    get {
      _debugPrecondition(i >= 0)
      _debugPrecondition(i < endIndex)
      return _position._unsafelyUnwrappedUnchecked.load(fromByteOffset: i, as: UInt8.self)
    }
    nonmutating set {
      _debugPrecondition(i >= 0)
      _debugPrecondition(i < endIndex)
      _position._unsafelyUnwrappedUnchecked.storeBytes(of: newValue, toByteOffset: i, as: UInt8.self)
    }
  }
  @inlinable public subscript(bounds: Swift.Range<Swift.Int>) -> Swift.UnsafeMutableRawBufferPointer.SubSequence {
    get {
      _debugPrecondition(bounds.lowerBound >= startIndex)
      _debugPrecondition(bounds.upperBound <= endIndex)
      return Slice(base: self, bounds: bounds)
    }
    nonmutating set {
      _debugPrecondition(bounds.lowerBound >= startIndex)
      _debugPrecondition(bounds.upperBound <= endIndex)
      _debugPrecondition(bounds.count == newValue.count)

      if !newValue.isEmpty {
        (baseAddress! + bounds.lowerBound).copyMemory(
          from: newValue.base.baseAddress! + newValue.startIndex,
          byteCount: newValue.count)
      }
    }
  }
  @inlinable public func swapAt(_ i: Swift.Int, _ j: Swift.Int) {
    guard i != j else { return }
    _debugPrecondition(i >= 0 && j >= 0)
    _debugPrecondition(i < endIndex && j < endIndex)
    let pi = (_position! + i)
    let pj = (_position! + j)
    let tmp = pi.load(fromByteOffset: 0, as: UInt8.self)
    pi.copyMemory(from: pj, byteCount: MemoryLayout<UInt8>.size)
    pj.storeBytes(of: tmp, toByteOffset: 0, as: UInt8.self)
  }
  @inlinable public var count: Swift.Int {
    get {
    if let pos = _position {
      return _assumeNonNegative(_end! - pos)
    }
    return 0
  }
  }
}
extension UnsafeMutableRawBufferPointer : Swift.RandomAccessCollection {
}
extension UnsafeMutableRawBufferPointer {
  @inlinable public static func allocate(byteCount: Swift.Int, alignment: Swift.Int) -> Swift.UnsafeMutableRawBufferPointer {
    let base = UnsafeMutableRawPointer.allocate(
      byteCount: byteCount, alignment: alignment)
    return UnsafeMutableRawBufferPointer(start: base, count: byteCount)
  }
  @inlinable public func deallocate() {
    _position?.deallocate()
  }
  @inlinable public func load<T>(fromByteOffset offset: Swift.Int = 0, as type: T.Type) -> T {
    _debugPrecondition(offset >= 0, "UnsafeMutableRawBufferPointer.load with negative offset")
    _debugPrecondition(offset + MemoryLayout<T>.size <= self.count,
      "UnsafeMutableRawBufferPointer.load out of bounds")
    return baseAddress!.load(fromByteOffset: offset, as: T.self)
  }
  @inlinable public func storeBytes<T>(of value: T, toByteOffset offset: Swift.Int = 0, as: T.Type) {
    _debugPrecondition(offset >= 0, "UnsafeMutableRawBufferPointer.storeBytes with negative offset")
    _debugPrecondition(offset + MemoryLayout<T>.size <= self.count,
      "UnsafeMutableRawBufferPointer.storeBytes out of bounds")

    baseAddress!.storeBytes(of: value, toByteOffset: offset, as: T.self)
  }
  @inlinable public func copyMemory(from source: Swift.UnsafeRawBufferPointer) {
    _debugPrecondition(source.count <= self.count,
      "UnsafeMutableRawBufferPointer.copyMemory source has too many elements")
    baseAddress?.copyMemory(from: source.baseAddress!, byteCount: source.count)
  }
  @inlinable public func copyBytes<C>(from source: C) where C : Swift.Collection, C.Element == Swift.UInt8 {
    _debugPrecondition(source.count <= self.count,
      "UnsafeMutableRawBufferPointer.copyBytes source has too many elements")
    guard let position = _position else {
      return
    }
    for (index, byteValue) in source.enumerated() {
      position.storeBytes(
        of: byteValue, toByteOffset: index, as: UInt8.self)
    }
  }
  @inlinable public init(@_nonEphemeral start: Swift.UnsafeMutableRawPointer?, count: Swift.Int) {
    _debugPrecondition(count >= 0, "UnsafeMutableRawBufferPointer with negative count")
    _debugPrecondition(count == 0 || start != nil,
      "UnsafeMutableRawBufferPointer has a nil start and nonzero count")
    _position = start
    _end = start.map { $0 + _assumeNonNegative(count) }
  }
  @inlinable public init(_ bytes: Swift.UnsafeMutableRawBufferPointer) {
    self.init(start: bytes.baseAddress, count: bytes.count)
  }
  @inlinable public init(mutating bytes: Swift.UnsafeRawBufferPointer) {
    self.init(start: UnsafeMutableRawPointer(mutating: bytes.baseAddress),
      count: bytes.count)
  }
  @inlinable public init<T>(_ buffer: Swift.UnsafeMutableBufferPointer<T>) {
    self.init(start: buffer.baseAddress,
      count: buffer.count * MemoryLayout<T>.stride)
  }
  @inlinable public init(rebasing slice: Swift.Slice<Swift.UnsafeMutableRawBufferPointer>) {
    let base = slice.base.baseAddress?.advanced(by: slice.startIndex)
    let count = slice.endIndex &- slice.startIndex
    self.init(start: base, count: count)
  }
  @inlinable public var baseAddress: Swift.UnsafeMutableRawPointer? {
    get {
    return _position
  }
  }
  @discardableResult
  @inlinable public func initializeMemory<T>(as type: T.Type, repeating repeatedValue: T) -> Swift.UnsafeMutableBufferPointer<T> {
    guard let base = _position else {
      return UnsafeMutableBufferPointer<T>(start: nil, count: 0)
    }
    
    let count = (_end! - base) / MemoryLayout<T>.stride
    let typed = base.initializeMemory(
      as: type, repeating: repeatedValue, count: count)
    return UnsafeMutableBufferPointer<T>(start: typed, count: count)
  }
  @inlinable public func initializeMemory<S>(as type: S.Element.Type, from source: S) -> (unwritten: S.Iterator, initialized: Swift.UnsafeMutableBufferPointer<S.Element>) where S : Swift.Sequence {
    // TODO: Optimize where `C` is a `ContiguousArrayBuffer`.

    var it = source.makeIterator()
    var idx = startIndex
    let elementStride = MemoryLayout<S.Element>.stride
    
    // This has to be a debug precondition due to the cost of walking over some collections.
    _debugPrecondition(source.underestimatedCount <= (count / elementStride),
      "insufficient space to accommodate source.underestimatedCount elements")
    guard let base = baseAddress else {
      // this can be a precondition since only an invalid argument should be costly
      _precondition(source.underestimatedCount == 0, 
        "no memory available to initialize from source")
      return (it, UnsafeMutableBufferPointer(start: nil, count: 0))
    }  

    for p in stride(from: base, 
      // only advance to as far as the last element that will fit
      to: base + count - elementStride + 1, 
      by: elementStride
    ) {
      // underflow is permitted -- e.g. a sequence into
      // the spare capacity of an Array buffer
      guard let x = it.next() else { break }
      p.initializeMemory(as: S.Element.self, repeating: x, count: 1)
      formIndex(&idx, offsetBy: elementStride)
    }

    return (it, UnsafeMutableBufferPointer(
                  start: base.assumingMemoryBound(to: S.Element.self), 
                  count: idx / elementStride))
  }
  @discardableResult
  @_transparent public func bindMemory<T>(to type: T.Type) -> Swift.UnsafeMutableBufferPointer<T> {
    guard let base = _position else {
      return UnsafeMutableBufferPointer<T>(start: nil, count: 0)
    }

    let capacity = count / MemoryLayout<T>.stride
    Builtin.bindMemory(base._rawValue, capacity._builtinWordValue, type)
    return UnsafeMutableBufferPointer<T>(
      start: UnsafeMutablePointer<T>(base._rawValue), count: capacity)
  }
}
extension UnsafeMutableRawBufferPointer : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
extension UnsafeMutableRawBufferPointer {
  @available(*, unavailable, message: "use 'UnsafeMutableRawBufferPointer(rebasing:)' to convert a slice into a zero-based raw buffer.")
  public subscript(bounds: Swift.Range<Swift.Int>) -> Swift.UnsafeMutableRawBufferPointer {
    get
    nonmutating set
  }
  @available(*, unavailable, message: "use 'UnsafeRawBufferPointer(rebasing:)' to convert a slice into a zero-based raw buffer.")
  public subscript(bounds: Swift.Range<Swift.Int>) -> Swift.UnsafeRawBufferPointer {
    get
    nonmutating set
  }
}
@frozen public struct UnsafeRawBufferPointer {
  @usableFromInline
  internal let _position: Swift.UnsafeRawPointer?, _end: Swift.UnsafeRawPointer?
}
extension UnsafeRawBufferPointer {
  @frozen public struct Iterator {
    @usableFromInline
    internal var _position: Swift.UnsafeRawPointer?, _end: Swift.UnsafeRawPointer?
    @inlinable internal init(_position: Swift.UnsafeRawPointer?, _end: Swift.UnsafeRawPointer?) {
      self._position = _position
      self._end = _end
    }
  }
}
extension UnsafeRawBufferPointer.Iterator : Swift.IteratorProtocol, Swift.Sequence {
  @inlinable public mutating func next() -> Swift.UInt8? {
    if _position == _end { return nil }

    let result = _position!.load(as: UInt8.self)
    _position! += 1
    return result
  }
  public typealias Element = Swift.UInt8
  public typealias Iterator = Swift.UnsafeRawBufferPointer.Iterator
}
extension UnsafeRawBufferPointer : Swift.Sequence {
  public typealias SubSequence = Swift.Slice<Swift.UnsafeRawBufferPointer>
  @inlinable public func makeIterator() -> Swift.UnsafeRawBufferPointer.Iterator {
    return Iterator(_position: _position, _end: _end)
  }
}
extension UnsafeRawBufferPointer : Swift.Collection {
  public typealias Element = Swift.UInt8
  public typealias Index = Swift.Int
  public typealias Indices = Swift.Range<Swift.Int>
  @inlinable public var startIndex: Swift.UnsafeRawBufferPointer.Index {
    get {
    return 0
  }
  }
  @inlinable public var endIndex: Swift.UnsafeRawBufferPointer.Index {
    get {
    return count
  }
  }
  @inlinable public var indices: Swift.UnsafeRawBufferPointer.Indices {
    get {
    return startIndex..<endIndex
  }
  }
  @inlinable public subscript(i: Swift.Int) -> Swift.UnsafeRawBufferPointer.Element {
    get {
      _debugPrecondition(i >= 0)
      _debugPrecondition(i < endIndex)
      return _position._unsafelyUnwrappedUnchecked.load(fromByteOffset: i, as: UInt8.self)
    }
  }
  @inlinable public subscript(bounds: Swift.Range<Swift.Int>) -> Swift.UnsafeRawBufferPointer.SubSequence {
    get {
      _debugPrecondition(bounds.lowerBound >= startIndex)
      _debugPrecondition(bounds.upperBound <= endIndex)
      return Slice(base: self, bounds: bounds)
    }
  }
  @inlinable public var count: Swift.Int {
    get {
    if let pos = _position {
      return _assumeNonNegative(_end! - pos)
    }
    return 0
  }
  }
}
extension UnsafeRawBufferPointer : Swift.RandomAccessCollection {
}
extension UnsafeRawBufferPointer {
  @inlinable public func deallocate() {
    _position?.deallocate()
  }
  @inlinable public func load<T>(fromByteOffset offset: Swift.Int = 0, as type: T.Type) -> T {
    _debugPrecondition(offset >= 0, "UnsafeRawBufferPointer.load with negative offset")
    _debugPrecondition(offset + MemoryLayout<T>.size <= self.count,
      "UnsafeRawBufferPointer.load out of bounds")
    return baseAddress!.load(fromByteOffset: offset, as: T.self)
  }
  @inlinable public init(@_nonEphemeral start: Swift.UnsafeRawPointer?, count: Swift.Int) {
    _debugPrecondition(count >= 0, "UnsafeRawBufferPointer with negative count")
    _debugPrecondition(count == 0 || start != nil,
      "UnsafeRawBufferPointer has a nil start and nonzero count")
    _position = start
    _end = start.map { $0 + _assumeNonNegative(count) }
  }
  @inlinable public init(_ bytes: Swift.UnsafeMutableRawBufferPointer) {
    self.init(start: bytes.baseAddress, count: bytes.count)
  }
  @inlinable public init(_ bytes: Swift.UnsafeRawBufferPointer) {
    self.init(start: bytes.baseAddress, count: bytes.count)
  }
  @inlinable public init<T>(_ buffer: Swift.UnsafeMutableBufferPointer<T>) {
    self.init(start: buffer.baseAddress,
      count: buffer.count * MemoryLayout<T>.stride)
  }
  @inlinable public init<T>(_ buffer: Swift.UnsafeBufferPointer<T>) {
    self.init(start: buffer.baseAddress,
      count: buffer.count * MemoryLayout<T>.stride)
  }
  @inlinable public init(rebasing slice: Swift.Slice<Swift.UnsafeRawBufferPointer>) {
    // NOTE: `Slice` does not guarantee that its start/end indices are valid
    // in `base` -- it merely ensures that `startIndex <= endIndex`.
    // We need manually check that we aren't given an invalid slice,
    // or the resulting collection would allow access that was
    // out-of-bounds with respect to the original base buffer.
    // We only do this in debug builds to prevent a measurable performance
    // degradation wrt passing around pointers not wrapped in a BufferPointer
    // construct.
    _debugPrecondition(
      slice.startIndex >= 0 && slice.endIndex <= slice.base.count,
      "Invalid slice")
    let base = slice.base.baseAddress?.advanced(by: slice.startIndex)
    let count = slice.endIndex &- slice.startIndex
    self.init(start: base, count: count)
  }
  @inlinable public init(rebasing slice: Swift.Slice<Swift.UnsafeMutableRawBufferPointer>) {
    let base = slice.base.baseAddress?.advanced(by: slice.startIndex)
    let count = slice.endIndex &- slice.startIndex
    self.init(start: base, count: count)
  }
  @inlinable public var baseAddress: Swift.UnsafeRawPointer? {
    get {
    return _position
  }
  }
  @discardableResult
  @_transparent public func bindMemory<T>(to type: T.Type) -> Swift.UnsafeBufferPointer<T> {
    guard let base = _position else {
      return UnsafeBufferPointer<T>(start: nil, count: 0)
    }

    let capacity = count / MemoryLayout<T>.stride
    Builtin.bindMemory(base._rawValue, capacity._builtinWordValue, type)
    return UnsafeBufferPointer<T>(
      start: UnsafePointer<T>(base._rawValue), count: capacity)
  }
}
extension UnsafeRawBufferPointer : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
extension UnsafeRawBufferPointer {
  @available(*, unavailable, message: "use 'UnsafeRawBufferPointer(rebasing:)' to convert a slice into a zero-based raw buffer.")
  public subscript(bounds: Swift.Range<Swift.Int>) -> Swift.UnsafeRawBufferPointer {
    get
  }
}
@inlinable public func withUnsafeMutableBytes<T, Result>(of value: inout T, _ body: (Swift.UnsafeMutableRawBufferPointer) throws -> Result) rethrows -> Result {
  return try withUnsafeMutablePointer(to: &value) {
    return try body(UnsafeMutableRawBufferPointer(
        start: $0, count: MemoryLayout<T>.size))
  }
}
@inlinable public func withUnsafeBytes<T, Result>(of value: inout T, _ body: (Swift.UnsafeRawBufferPointer) throws -> Result) rethrows -> Result {
  return try withUnsafePointer(to: &value) {
    try body(UnsafeRawBufferPointer(start: $0, count: MemoryLayout<T>.size))
  }
}
@inlinable public func withUnsafeBytes<T, Result>(of value: T, _ body: (Swift.UnsafeRawBufferPointer) throws -> Result) rethrows -> Result {
  let addr = UnsafeRawPointer(Builtin.addressOfBorrow(value))
  let buffer = UnsafeRawBufferPointer(start: addr, count: MemoryLayout<T>.size)
  return try body(buffer)
}
@frozen public struct SIMD2<Scalar> : Swift.SIMD where Scalar : Swift.SIMDScalar {
  public var _storage: Scalar.SIMD2Storage
  public typealias MaskStorage = Swift.SIMD2<Scalar.SIMDMaskScalar>
  @_transparent public var scalarCount: Swift.Int {
    @_transparent get {
    return 2
  }
  }
  @_transparent public init() {
    _storage = Scalar.SIMD2Storage()
  }
  public subscript(index: Swift.Int) -> Scalar {
    @_transparent get {
      _precondition(indices.contains(index))
      return _storage[index]
    }
    @_transparent set {
      _precondition(indices.contains(index))
      _storage[index] = newValue
    }
  }
  @_transparent public init(_ v0: Scalar, _ v1: Scalar) {
    self.init()
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 65)
    self[0] = v0
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 65)
    self[1] = v1
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 67)
  }
  @_transparent public init(x: Scalar, y: Scalar) {
    self.init(x, y)
  }
  @_transparent public var x: Scalar {
    @_transparent get { return self[0]}
    @_transparent set { self[0] = newValue }
  }
  @_transparent public var y: Scalar {
    @_transparent get { return self[1]}
    @_transparent set { self[1] = newValue }
  }
  public typealias ArrayLiteralElement = Scalar
  public var hashValue: Swift.Int {
    get
  }
}
extension SIMD2 where Scalar : Swift.FixedWidthInteger {
  @inlinable public init<Other>(truncatingIfNeeded other: Swift.SIMD2<Other>) where Other : Swift.FixedWidthInteger, Other : Swift.SIMDScalar {
    self.init()
    for i in indices { self[i] = Scalar(truncatingIfNeeded: other[i]) }
  }
  @inlinable public init<Other>(clamping other: Swift.SIMD2<Other>) where Other : Swift.FixedWidthInteger, Other : Swift.SIMDScalar {
    self.init()
    for i in indices { self[i] = Scalar(clamping: other[i]) }
  }
  @inlinable public init<Other>(_ other: Swift.SIMD2<Other>, rounding rule: Swift.FloatingPointRoundingRule = .towardZero) where Other : Swift.BinaryFloatingPoint, Other : Swift.SIMDScalar {
    self.init()
    // TODO: this should clamp
    for i in indices { self[i] = Scalar(other[i].rounded(rule)) }
  }
}
extension SIMD2 : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
extension SIMD2 where Scalar : Swift.BinaryFloatingPoint {
  @inlinable public init<Other>(_ other: Swift.SIMD2<Other>) where Other : Swift.FixedWidthInteger, Other : Swift.SIMDScalar {
    self.init()
    for i in indices { self[i] = Scalar(other[i]) }
  }
  @inlinable public init<Other>(_ other: Swift.SIMD2<Other>) where Other : Swift.BinaryFloatingPoint, Other : Swift.SIMDScalar {
    self.init()
    for i in indices { self[i] = Scalar(other[i]) }
  }
}
@frozen public struct SIMD4<Scalar> : Swift.SIMD where Scalar : Swift.SIMDScalar {
  public var _storage: Scalar.SIMD4Storage
  public typealias MaskStorage = Swift.SIMD4<Scalar.SIMDMaskScalar>
  @_transparent public var scalarCount: Swift.Int {
    @_transparent get {
    return 4
  }
  }
  @_transparent public init() {
    _storage = Scalar.SIMD4Storage()
  }
  public subscript(index: Swift.Int) -> Scalar {
    @_transparent get {
      _precondition(indices.contains(index))
      return _storage[index]
    }
    @_transparent set {
      _precondition(indices.contains(index))
      _storage[index] = newValue
    }
  }
  @_transparent public init(_ v0: Scalar, _ v1: Scalar, _ v2: Scalar, _ v3: Scalar) {
    self.init()
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 65)
    self[0] = v0
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 65)
    self[1] = v1
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 65)
    self[2] = v2
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 65)
    self[3] = v3
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 67)
  }
  @_transparent public init(x: Scalar, y: Scalar, z: Scalar, w: Scalar) {
    self.init(x, y, z, w)
  }
  @_transparent public var x: Scalar {
    @_transparent get { return self[0]}
    @_transparent set { self[0] = newValue }
  }
  @_transparent public var y: Scalar {
    @_transparent get { return self[1]}
    @_transparent set { self[1] = newValue }
  }
  @_transparent public var z: Scalar {
    @_transparent get { return self[2]}
    @_transparent set { self[2] = newValue }
  }
  @_transparent public var w: Scalar {
    @_transparent get { return self[3]}
    @_transparent set { self[3] = newValue }
  }
  @_transparent public init(lowHalf: Swift.SIMD2<Scalar>, highHalf: Swift.SIMD2<Scalar>) {
    self.init()
    self.lowHalf = lowHalf
    self.highHalf = highHalf
  }
  public var lowHalf: Swift.SIMD2<Scalar> {
    @inlinable get {
      var result = SIMD2<Scalar>()
      for i in result.indices { result[i] = self[i] }
      return result
    }
    @inlinable set {
      for i in newValue.indices { self[i] = newValue[i] }
    }
  }
  public var highHalf: Swift.SIMD2<Scalar> {
    @inlinable get {
      var result = SIMD2<Scalar>()
      for i in result.indices { result[i] = self[2+i] }
      return result
    }
    @inlinable set {
      for i in newValue.indices { self[2+i] = newValue[i] }
    }
  }
  public var evenHalf: Swift.SIMD2<Scalar> {
    @inlinable get {
      var result = SIMD2<Scalar>()
      for i in result.indices { result[i] = self[2*i] }
      return result
    }
    @inlinable set {
      for i in newValue.indices { self[2*i] = newValue[i] }
    }
  }
  public var oddHalf: Swift.SIMD2<Scalar> {
    @inlinable get {
      var result = SIMD2<Scalar>()
      for i in result.indices { result[i] = self[2*i+1] }
      return result
    }
    @inlinable set {
      for i in newValue.indices { self[2*i+1] = newValue[i] }
    }
  }
  public typealias ArrayLiteralElement = Scalar
  public var hashValue: Swift.Int {
    get
  }
}
extension SIMD4 where Scalar : Swift.FixedWidthInteger {
  @inlinable public init<Other>(truncatingIfNeeded other: Swift.SIMD4<Other>) where Other : Swift.FixedWidthInteger, Other : Swift.SIMDScalar {
    self.init()
    for i in indices { self[i] = Scalar(truncatingIfNeeded: other[i]) }
  }
  @inlinable public init<Other>(clamping other: Swift.SIMD4<Other>) where Other : Swift.FixedWidthInteger, Other : Swift.SIMDScalar {
    self.init()
    for i in indices { self[i] = Scalar(clamping: other[i]) }
  }
  @inlinable public init<Other>(_ other: Swift.SIMD4<Other>, rounding rule: Swift.FloatingPointRoundingRule = .towardZero) where Other : Swift.BinaryFloatingPoint, Other : Swift.SIMDScalar {
    self.init()
    // TODO: this should clamp
    for i in indices { self[i] = Scalar(other[i].rounded(rule)) }
  }
}
extension SIMD4 : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
extension SIMD4 where Scalar : Swift.BinaryFloatingPoint {
  @inlinable public init<Other>(_ other: Swift.SIMD4<Other>) where Other : Swift.FixedWidthInteger, Other : Swift.SIMDScalar {
    self.init()
    for i in indices { self[i] = Scalar(other[i]) }
  }
  @inlinable public init<Other>(_ other: Swift.SIMD4<Other>) where Other : Swift.BinaryFloatingPoint, Other : Swift.SIMDScalar {
    self.init()
    for i in indices { self[i] = Scalar(other[i]) }
  }
}
@frozen public struct SIMD8<Scalar> : Swift.SIMD where Scalar : Swift.SIMDScalar {
  public var _storage: Scalar.SIMD8Storage
  public typealias MaskStorage = Swift.SIMD8<Scalar.SIMDMaskScalar>
  @_transparent public var scalarCount: Swift.Int {
    @_transparent get {
    return 8
  }
  }
  @_transparent public init() {
    _storage = Scalar.SIMD8Storage()
  }
  public subscript(index: Swift.Int) -> Scalar {
    @_transparent get {
      _precondition(indices.contains(index))
      return _storage[index]
    }
    @_transparent set {
      _precondition(indices.contains(index))
      _storage[index] = newValue
    }
  }
  @_transparent public init(_ v0: Scalar, _ v1: Scalar, _ v2: Scalar, _ v3: Scalar, _ v4: Scalar, _ v5: Scalar, _ v6: Scalar, _ v7: Scalar) {
    self.init()
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 65)
    self[0] = v0
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 65)
    self[1] = v1
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 65)
    self[2] = v2
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 65)
    self[3] = v3
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 65)
    self[4] = v4
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 65)
    self[5] = v5
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 65)
    self[6] = v6
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 65)
    self[7] = v7
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 67)
  }
  @_transparent public init(lowHalf: Swift.SIMD4<Scalar>, highHalf: Swift.SIMD4<Scalar>) {
    self.init()
    self.lowHalf = lowHalf
    self.highHalf = highHalf
  }
  public var lowHalf: Swift.SIMD4<Scalar> {
    @inlinable get {
      var result = SIMD4<Scalar>()
      for i in result.indices { result[i] = self[i] }
      return result
    }
    @inlinable set {
      for i in newValue.indices { self[i] = newValue[i] }
    }
  }
  public var highHalf: Swift.SIMD4<Scalar> {
    @inlinable get {
      var result = SIMD4<Scalar>()
      for i in result.indices { result[i] = self[4+i] }
      return result
    }
    @inlinable set {
      for i in newValue.indices { self[4+i] = newValue[i] }
    }
  }
  public var evenHalf: Swift.SIMD4<Scalar> {
    @inlinable get {
      var result = SIMD4<Scalar>()
      for i in result.indices { result[i] = self[2*i] }
      return result
    }
    @inlinable set {
      for i in newValue.indices { self[2*i] = newValue[i] }
    }
  }
  public var oddHalf: Swift.SIMD4<Scalar> {
    @inlinable get {
      var result = SIMD4<Scalar>()
      for i in result.indices { result[i] = self[2*i+1] }
      return result
    }
    @inlinable set {
      for i in newValue.indices { self[2*i+1] = newValue[i] }
    }
  }
  public typealias ArrayLiteralElement = Scalar
  public var hashValue: Swift.Int {
    get
  }
}
extension SIMD8 where Scalar : Swift.FixedWidthInteger {
  @inlinable public init<Other>(truncatingIfNeeded other: Swift.SIMD8<Other>) where Other : Swift.FixedWidthInteger, Other : Swift.SIMDScalar {
    self.init()
    for i in indices { self[i] = Scalar(truncatingIfNeeded: other[i]) }
  }
  @inlinable public init<Other>(clamping other: Swift.SIMD8<Other>) where Other : Swift.FixedWidthInteger, Other : Swift.SIMDScalar {
    self.init()
    for i in indices { self[i] = Scalar(clamping: other[i]) }
  }
  @inlinable public init<Other>(_ other: Swift.SIMD8<Other>, rounding rule: Swift.FloatingPointRoundingRule = .towardZero) where Other : Swift.BinaryFloatingPoint, Other : Swift.SIMDScalar {
    self.init()
    // TODO: this should clamp
    for i in indices { self[i] = Scalar(other[i].rounded(rule)) }
  }
}
extension SIMD8 : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
extension SIMD8 where Scalar : Swift.BinaryFloatingPoint {
  @inlinable public init<Other>(_ other: Swift.SIMD8<Other>) where Other : Swift.FixedWidthInteger, Other : Swift.SIMDScalar {
    self.init()
    for i in indices { self[i] = Scalar(other[i]) }
  }
  @inlinable public init<Other>(_ other: Swift.SIMD8<Other>) where Other : Swift.BinaryFloatingPoint, Other : Swift.SIMDScalar {
    self.init()
    for i in indices { self[i] = Scalar(other[i]) }
  }
}
@frozen public struct SIMD16<Scalar> : Swift.SIMD where Scalar : Swift.SIMDScalar {
  public var _storage: Scalar.SIMD16Storage
  public typealias MaskStorage = Swift.SIMD16<Scalar.SIMDMaskScalar>
  @_transparent public var scalarCount: Swift.Int {
    @_transparent get {
    return 16
  }
  }
  @_transparent public init() {
    _storage = Scalar.SIMD16Storage()
  }
  public subscript(index: Swift.Int) -> Scalar {
    @_transparent get {
      _precondition(indices.contains(index))
      return _storage[index]
    }
    @_transparent set {
      _precondition(indices.contains(index))
      _storage[index] = newValue
    }
  }
  @_transparent public init(_ v0: Scalar, _ v1: Scalar, _ v2: Scalar, _ v3: Scalar, _ v4: Scalar, _ v5: Scalar, _ v6: Scalar, _ v7: Scalar, _ v8: Scalar, _ v9: Scalar, _ v10: Scalar, _ v11: Scalar, _ v12: Scalar, _ v13: Scalar, _ v14: Scalar, _ v15: Scalar) {
    self.init()
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 65)
    self[0] = v0
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 65)
    self[1] = v1
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 65)
    self[2] = v2
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 65)
    self[3] = v3
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 65)
    self[4] = v4
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 65)
    self[5] = v5
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 65)
    self[6] = v6
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 65)
    self[7] = v7
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 65)
    self[8] = v8
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 65)
    self[9] = v9
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 65)
    self[10] = v10
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 65)
    self[11] = v11
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 65)
    self[12] = v12
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 65)
    self[13] = v13
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 65)
    self[14] = v14
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 65)
    self[15] = v15
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 67)
  }
  @_transparent public init(lowHalf: Swift.SIMD8<Scalar>, highHalf: Swift.SIMD8<Scalar>) {
    self.init()
    self.lowHalf = lowHalf
    self.highHalf = highHalf
  }
  public var lowHalf: Swift.SIMD8<Scalar> {
    @inlinable get {
      var result = SIMD8<Scalar>()
      for i in result.indices { result[i] = self[i] }
      return result
    }
    @inlinable set {
      for i in newValue.indices { self[i] = newValue[i] }
    }
  }
  public var highHalf: Swift.SIMD8<Scalar> {
    @inlinable get {
      var result = SIMD8<Scalar>()
      for i in result.indices { result[i] = self[8+i] }
      return result
    }
    @inlinable set {
      for i in newValue.indices { self[8+i] = newValue[i] }
    }
  }
  public var evenHalf: Swift.SIMD8<Scalar> {
    @inlinable get {
      var result = SIMD8<Scalar>()
      for i in result.indices { result[i] = self[2*i] }
      return result
    }
    @inlinable set {
      for i in newValue.indices { self[2*i] = newValue[i] }
    }
  }
  public var oddHalf: Swift.SIMD8<Scalar> {
    @inlinable get {
      var result = SIMD8<Scalar>()
      for i in result.indices { result[i] = self[2*i+1] }
      return result
    }
    @inlinable set {
      for i in newValue.indices { self[2*i+1] = newValue[i] }
    }
  }
  public typealias ArrayLiteralElement = Scalar
  public var hashValue: Swift.Int {
    get
  }
}
extension SIMD16 where Scalar : Swift.FixedWidthInteger {
  @inlinable public init<Other>(truncatingIfNeeded other: Swift.SIMD16<Other>) where Other : Swift.FixedWidthInteger, Other : Swift.SIMDScalar {
    self.init()
    for i in indices { self[i] = Scalar(truncatingIfNeeded: other[i]) }
  }
  @inlinable public init<Other>(clamping other: Swift.SIMD16<Other>) where Other : Swift.FixedWidthInteger, Other : Swift.SIMDScalar {
    self.init()
    for i in indices { self[i] = Scalar(clamping: other[i]) }
  }
  @inlinable public init<Other>(_ other: Swift.SIMD16<Other>, rounding rule: Swift.FloatingPointRoundingRule = .towardZero) where Other : Swift.BinaryFloatingPoint, Other : Swift.SIMDScalar {
    self.init()
    // TODO: this should clamp
    for i in indices { self[i] = Scalar(other[i].rounded(rule)) }
  }
}
extension SIMD16 : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
extension SIMD16 where Scalar : Swift.BinaryFloatingPoint {
  @inlinable public init<Other>(_ other: Swift.SIMD16<Other>) where Other : Swift.FixedWidthInteger, Other : Swift.SIMDScalar {
    self.init()
    for i in indices { self[i] = Scalar(other[i]) }
  }
  @inlinable public init<Other>(_ other: Swift.SIMD16<Other>) where Other : Swift.BinaryFloatingPoint, Other : Swift.SIMDScalar {
    self.init()
    for i in indices { self[i] = Scalar(other[i]) }
  }
}
@frozen public struct SIMD32<Scalar> : Swift.SIMD where Scalar : Swift.SIMDScalar {
  public var _storage: Scalar.SIMD32Storage
  public typealias MaskStorage = Swift.SIMD32<Scalar.SIMDMaskScalar>
  @_transparent public var scalarCount: Swift.Int {
    @_transparent get {
    return 32
  }
  }
  @_transparent public init() {
    _storage = Scalar.SIMD32Storage()
  }
  public subscript(index: Swift.Int) -> Scalar {
    @_transparent get {
      _precondition(indices.contains(index))
      return _storage[index]
    }
    @_transparent set {
      _precondition(indices.contains(index))
      _storage[index] = newValue
    }
  }
  @_transparent public init(_ v0: Scalar, _ v1: Scalar, _ v2: Scalar, _ v3: Scalar, _ v4: Scalar, _ v5: Scalar, _ v6: Scalar, _ v7: Scalar, _ v8: Scalar, _ v9: Scalar, _ v10: Scalar, _ v11: Scalar, _ v12: Scalar, _ v13: Scalar, _ v14: Scalar, _ v15: Scalar, _ v16: Scalar, _ v17: Scalar, _ v18: Scalar, _ v19: Scalar, _ v20: Scalar, _ v21: Scalar, _ v22: Scalar, _ v23: Scalar, _ v24: Scalar, _ v25: Scalar, _ v26: Scalar, _ v27: Scalar, _ v28: Scalar, _ v29: Scalar, _ v30: Scalar, _ v31: Scalar) {
    self.init()
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 65)
    self[0] = v0
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 65)
    self[1] = v1
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 65)
    self[2] = v2
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 65)
    self[3] = v3
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 65)
    self[4] = v4
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 65)
    self[5] = v5
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 65)
    self[6] = v6
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 65)
    self[7] = v7
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 65)
    self[8] = v8
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 65)
    self[9] = v9
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 65)
    self[10] = v10
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 65)
    self[11] = v11
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 65)
    self[12] = v12
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 65)
    self[13] = v13
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 65)
    self[14] = v14
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 65)
    self[15] = v15
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 65)
    self[16] = v16
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 65)
    self[17] = v17
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 65)
    self[18] = v18
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 65)
    self[19] = v19
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 65)
    self[20] = v20
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 65)
    self[21] = v21
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 65)
    self[22] = v22
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 65)
    self[23] = v23
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 65)
    self[24] = v24
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 65)
    self[25] = v25
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 65)
    self[26] = v26
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 65)
    self[27] = v27
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 65)
    self[28] = v28
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 65)
    self[29] = v29
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 65)
    self[30] = v30
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 65)
    self[31] = v31
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 67)
  }
  @_transparent public init(lowHalf: Swift.SIMD16<Scalar>, highHalf: Swift.SIMD16<Scalar>) {
    self.init()
    self.lowHalf = lowHalf
    self.highHalf = highHalf
  }
  public var lowHalf: Swift.SIMD16<Scalar> {
    @inlinable get {
      var result = SIMD16<Scalar>()
      for i in result.indices { result[i] = self[i] }
      return result
    }
    @inlinable set {
      for i in newValue.indices { self[i] = newValue[i] }
    }
  }
  public var highHalf: Swift.SIMD16<Scalar> {
    @inlinable get {
      var result = SIMD16<Scalar>()
      for i in result.indices { result[i] = self[16+i] }
      return result
    }
    @inlinable set {
      for i in newValue.indices { self[16+i] = newValue[i] }
    }
  }
  public var evenHalf: Swift.SIMD16<Scalar> {
    @inlinable get {
      var result = SIMD16<Scalar>()
      for i in result.indices { result[i] = self[2*i] }
      return result
    }
    @inlinable set {
      for i in newValue.indices { self[2*i] = newValue[i] }
    }
  }
  public var oddHalf: Swift.SIMD16<Scalar> {
    @inlinable get {
      var result = SIMD16<Scalar>()
      for i in result.indices { result[i] = self[2*i+1] }
      return result
    }
    @inlinable set {
      for i in newValue.indices { self[2*i+1] = newValue[i] }
    }
  }
  public typealias ArrayLiteralElement = Scalar
  public var hashValue: Swift.Int {
    get
  }
}
extension SIMD32 where Scalar : Swift.FixedWidthInteger {
  @inlinable public init<Other>(truncatingIfNeeded other: Swift.SIMD32<Other>) where Other : Swift.FixedWidthInteger, Other : Swift.SIMDScalar {
    self.init()
    for i in indices { self[i] = Scalar(truncatingIfNeeded: other[i]) }
  }
  @inlinable public init<Other>(clamping other: Swift.SIMD32<Other>) where Other : Swift.FixedWidthInteger, Other : Swift.SIMDScalar {
    self.init()
    for i in indices { self[i] = Scalar(clamping: other[i]) }
  }
  @inlinable public init<Other>(_ other: Swift.SIMD32<Other>, rounding rule: Swift.FloatingPointRoundingRule = .towardZero) where Other : Swift.BinaryFloatingPoint, Other : Swift.SIMDScalar {
    self.init()
    // TODO: this should clamp
    for i in indices { self[i] = Scalar(other[i].rounded(rule)) }
  }
}
extension SIMD32 : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
extension SIMD32 where Scalar : Swift.BinaryFloatingPoint {
  @inlinable public init<Other>(_ other: Swift.SIMD32<Other>) where Other : Swift.FixedWidthInteger, Other : Swift.SIMDScalar {
    self.init()
    for i in indices { self[i] = Scalar(other[i]) }
  }
  @inlinable public init<Other>(_ other: Swift.SIMD32<Other>) where Other : Swift.BinaryFloatingPoint, Other : Swift.SIMDScalar {
    self.init()
    for i in indices { self[i] = Scalar(other[i]) }
  }
}
@frozen public struct SIMD64<Scalar> : Swift.SIMD where Scalar : Swift.SIMDScalar {
  public var _storage: Scalar.SIMD64Storage
  public typealias MaskStorage = Swift.SIMD64<Scalar.SIMDMaskScalar>
  @_transparent public var scalarCount: Swift.Int {
    @_transparent get {
    return 64
  }
  }
  @_transparent public init() {
    _storage = Scalar.SIMD64Storage()
  }
  public subscript(index: Swift.Int) -> Scalar {
    @_transparent get {
      _precondition(indices.contains(index))
      return _storage[index]
    }
    @_transparent set {
      _precondition(indices.contains(index))
      _storage[index] = newValue
    }
  }
  @_transparent public init(_ v0: Scalar, _ v1: Scalar, _ v2: Scalar, _ v3: Scalar, _ v4: Scalar, _ v5: Scalar, _ v6: Scalar, _ v7: Scalar, _ v8: Scalar, _ v9: Scalar, _ v10: Scalar, _ v11: Scalar, _ v12: Scalar, _ v13: Scalar, _ v14: Scalar, _ v15: Scalar, _ v16: Scalar, _ v17: Scalar, _ v18: Scalar, _ v19: Scalar, _ v20: Scalar, _ v21: Scalar, _ v22: Scalar, _ v23: Scalar, _ v24: Scalar, _ v25: Scalar, _ v26: Scalar, _ v27: Scalar, _ v28: Scalar, _ v29: Scalar, _ v30: Scalar, _ v31: Scalar, _ v32: Scalar, _ v33: Scalar, _ v34: Scalar, _ v35: Scalar, _ v36: Scalar, _ v37: Scalar, _ v38: Scalar, _ v39: Scalar, _ v40: Scalar, _ v41: Scalar, _ v42: Scalar, _ v43: Scalar, _ v44: Scalar, _ v45: Scalar, _ v46: Scalar, _ v47: Scalar, _ v48: Scalar, _ v49: Scalar, _ v50: Scalar, _ v51: Scalar, _ v52: Scalar, _ v53: Scalar, _ v54: Scalar, _ v55: Scalar, _ v56: Scalar, _ v57: Scalar, _ v58: Scalar, _ v59: Scalar, _ v60: Scalar, _ v61: Scalar, _ v62: Scalar, _ v63: Scalar) {
    self.init()
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 65)
    self[0] = v0
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 65)
    self[1] = v1
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 65)
    self[2] = v2
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 65)
    self[3] = v3
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 65)
    self[4] = v4
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 65)
    self[5] = v5
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 65)
    self[6] = v6
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 65)
    self[7] = v7
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 65)
    self[8] = v8
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 65)
    self[9] = v9
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 65)
    self[10] = v10
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 65)
    self[11] = v11
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 65)
    self[12] = v12
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 65)
    self[13] = v13
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 65)
    self[14] = v14
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 65)
    self[15] = v15
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 65)
    self[16] = v16
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 65)
    self[17] = v17
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 65)
    self[18] = v18
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 65)
    self[19] = v19
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 65)
    self[20] = v20
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 65)
    self[21] = v21
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 65)
    self[22] = v22
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 65)
    self[23] = v23
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 65)
    self[24] = v24
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 65)
    self[25] = v25
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 65)
    self[26] = v26
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 65)
    self[27] = v27
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 65)
    self[28] = v28
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 65)
    self[29] = v29
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 65)
    self[30] = v30
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 65)
    self[31] = v31
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 65)
    self[32] = v32
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 65)
    self[33] = v33
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 65)
    self[34] = v34
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 65)
    self[35] = v35
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 65)
    self[36] = v36
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 65)
    self[37] = v37
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 65)
    self[38] = v38
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 65)
    self[39] = v39
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 65)
    self[40] = v40
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 65)
    self[41] = v41
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 65)
    self[42] = v42
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 65)
    self[43] = v43
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 65)
    self[44] = v44
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 65)
    self[45] = v45
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 65)
    self[46] = v46
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 65)
    self[47] = v47
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 65)
    self[48] = v48
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 65)
    self[49] = v49
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 65)
    self[50] = v50
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 65)
    self[51] = v51
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 65)
    self[52] = v52
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 65)
    self[53] = v53
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 65)
    self[54] = v54
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 65)
    self[55] = v55
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 65)
    self[56] = v56
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 65)
    self[57] = v57
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 65)
    self[58] = v58
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 65)
    self[59] = v59
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 65)
    self[60] = v60
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 65)
    self[61] = v61
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 65)
    self[62] = v62
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 65)
    self[63] = v63
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 67)
  }
  @_transparent public init(lowHalf: Swift.SIMD32<Scalar>, highHalf: Swift.SIMD32<Scalar>) {
    self.init()
    self.lowHalf = lowHalf
    self.highHalf = highHalf
  }
  public var lowHalf: Swift.SIMD32<Scalar> {
    @inlinable get {
      var result = SIMD32<Scalar>()
      for i in result.indices { result[i] = self[i] }
      return result
    }
    @inlinable set {
      for i in newValue.indices { self[i] = newValue[i] }
    }
  }
  public var highHalf: Swift.SIMD32<Scalar> {
    @inlinable get {
      var result = SIMD32<Scalar>()
      for i in result.indices { result[i] = self[32+i] }
      return result
    }
    @inlinable set {
      for i in newValue.indices { self[32+i] = newValue[i] }
    }
  }
  public var evenHalf: Swift.SIMD32<Scalar> {
    @inlinable get {
      var result = SIMD32<Scalar>()
      for i in result.indices { result[i] = self[2*i] }
      return result
    }
    @inlinable set {
      for i in newValue.indices { self[2*i] = newValue[i] }
    }
  }
  public var oddHalf: Swift.SIMD32<Scalar> {
    @inlinable get {
      var result = SIMD32<Scalar>()
      for i in result.indices { result[i] = self[2*i+1] }
      return result
    }
    @inlinable set {
      for i in newValue.indices { self[2*i+1] = newValue[i] }
    }
  }
  public typealias ArrayLiteralElement = Scalar
  public var hashValue: Swift.Int {
    get
  }
}
extension SIMD64 where Scalar : Swift.FixedWidthInteger {
  @inlinable public init<Other>(truncatingIfNeeded other: Swift.SIMD64<Other>) where Other : Swift.FixedWidthInteger, Other : Swift.SIMDScalar {
    self.init()
    for i in indices { self[i] = Scalar(truncatingIfNeeded: other[i]) }
  }
  @inlinable public init<Other>(clamping other: Swift.SIMD64<Other>) where Other : Swift.FixedWidthInteger, Other : Swift.SIMDScalar {
    self.init()
    for i in indices { self[i] = Scalar(clamping: other[i]) }
  }
  @inlinable public init<Other>(_ other: Swift.SIMD64<Other>, rounding rule: Swift.FloatingPointRoundingRule = .towardZero) where Other : Swift.BinaryFloatingPoint, Other : Swift.SIMDScalar {
    self.init()
    // TODO: this should clamp
    for i in indices { self[i] = Scalar(other[i].rounded(rule)) }
  }
}
extension SIMD64 : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
extension SIMD64 where Scalar : Swift.BinaryFloatingPoint {
  @inlinable public init<Other>(_ other: Swift.SIMD64<Other>) where Other : Swift.FixedWidthInteger, Other : Swift.SIMDScalar {
    self.init()
    for i in indices { self[i] = Scalar(other[i]) }
  }
  @inlinable public init<Other>(_ other: Swift.SIMD64<Other>) where Other : Swift.BinaryFloatingPoint, Other : Swift.SIMDScalar {
    self.init()
    for i in indices { self[i] = Scalar(other[i]) }
  }
}
@frozen public struct SIMD3<Scalar> : Swift.SIMD where Scalar : Swift.SIMDScalar {
  public var _storage: Scalar.SIMD4Storage
  public typealias MaskStorage = Swift.SIMD3<Scalar.SIMDMaskScalar>
  @_transparent public var scalarCount: Swift.Int {
    @_transparent get {
    return 3
  }
  }
  @_transparent public init() {
    _storage = Scalar.SIMD4Storage()
  }
  public subscript(index: Swift.Int) -> Scalar {
    @_transparent get {
      _precondition(indices.contains(index))
      return _storage[index]
    }
    @_transparent set {
      _precondition(indices.contains(index))
      _storage[index] = newValue
    }
  }
  @_transparent public init(_ v0: Scalar, _ v1: Scalar, _ v2: Scalar) {
    self.init()
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 65)
    self[0] = v0
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 65)
    self[1] = v1
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 65)
    self[2] = v2
// ###sourceLocation(file: "/System/Volumes/Data/SWE/macOS/BuildRoots/2288acc43c/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1205.0.24.14/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 67)
  }
  @_transparent public init(x: Scalar, y: Scalar, z: Scalar) {
    self.init(x, y, z)
  }
  @_transparent public var x: Scalar {
    @_transparent get { return self[0]}
    @_transparent set { self[0] = newValue }
  }
  @_transparent public var y: Scalar {
    @_transparent get { return self[1]}
    @_transparent set { self[1] = newValue }
  }
  @_transparent public var z: Scalar {
    @_transparent get { return self[2]}
    @_transparent set { self[2] = newValue }
  }
  public typealias ArrayLiteralElement = Scalar
  public var hashValue: Swift.Int {
    get
  }
}
extension SIMD3 where Scalar : Swift.FixedWidthInteger {
  @inlinable public init<Other>(truncatingIfNeeded other: Swift.SIMD3<Other>) where Other : Swift.FixedWidthInteger, Other : Swift.SIMDScalar {
    self.init()
    for i in indices { self[i] = Scalar(truncatingIfNeeded: other[i]) }
  }
  @inlinable public init<Other>(clamping other: Swift.SIMD3<Other>) where Other : Swift.FixedWidthInteger, Other : Swift.SIMDScalar {
    self.init()
    for i in indices { self[i] = Scalar(clamping: other[i]) }
  }
  @inlinable public init<Other>(_ other: Swift.SIMD3<Other>, rounding rule: Swift.FloatingPointRoundingRule = .towardZero) where Other : Swift.BinaryFloatingPoint, Other : Swift.SIMDScalar {
    self.init()
    // TODO: this should clamp
    for i in indices { self[i] = Scalar(other[i].rounded(rule)) }
  }
}
extension SIMD3 : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
extension SIMD3 where Scalar : Swift.BinaryFloatingPoint {
  @inlinable public init<Other>(_ other: Swift.SIMD3<Other>) where Other : Swift.FixedWidthInteger, Other : Swift.SIMDScalar {
    self.init()
    for i in indices { self[i] = Scalar(other[i]) }
  }
  @inlinable public init<Other>(_ other: Swift.SIMD3<Other>) where Other : Swift.BinaryFloatingPoint, Other : Swift.SIMDScalar {
    self.init()
    for i in indices { self[i] = Scalar(other[i]) }
  }
}
extension SIMD3 {
  @_alwaysEmitIntoClient public init(_ xy: Swift.SIMD2<Scalar>, _ z: Scalar) {
    self.init(xy.x, xy.y, z)
  }
}
extension SIMD4 {
  @_alwaysEmitIntoClient public init(_ xyz: Swift.SIMD3<Scalar>, _ w: Scalar) {
    self.init(xyz.x, xyz.y, xyz.z, w)
  }
}
extension UInt8 : Swift.SIMDScalar {
  public typealias SIMDMaskScalar = Swift.Int8
  @frozen @_alignment(2) public struct SIMD2Storage : Swift.SIMDStorage {
    public var _value: Builtin.Vec2xInt8
    @_transparent public var scalarCount: Swift.Int {
      @_transparent get {
      return 2
    }
    }
    @_transparent public init() {
      _value = Builtin.zeroInitializer()
    }
    public subscript(index: Swift.Int) -> Swift.UInt8 {
      @_transparent get {
        return UInt8(Builtin.extractelement_Vec2xInt8_Int32(
          _value, Int32(truncatingIfNeeded: index)._value
        ))
      }
      @_transparent set {
        _value = Builtin.insertelement_Vec2xInt8_Int8_Int32(
          _value, newValue._value, Int32(truncatingIfNeeded: index)._value
        )
      }
    }
    public typealias Scalar = Swift.UInt8
  }
  @frozen @_alignment(4) public struct SIMD4Storage : Swift.SIMDStorage {
    public var _value: Builtin.Vec4xInt8
    @_transparent public var scalarCount: Swift.Int {
      @_transparent get {
      return 4
    }
    }
    @_transparent public init() {
      _value = Builtin.zeroInitializer()
    }
    public subscript(index: Swift.Int) -> Swift.UInt8 {
      @_transparent get {
        return UInt8(Builtin.extractelement_Vec4xInt8_Int32(
          _value, Int32(truncatingIfNeeded: index)._value
        ))
      }
      @_transparent set {
        _value = Builtin.insertelement_Vec4xInt8_Int8_Int32(
          _value, newValue._value, Int32(truncatingIfNeeded: index)._value
        )
      }
    }
    public typealias Scalar = Swift.UInt8
  }
  @frozen @_alignment(8) public struct SIMD8Storage : Swift.SIMDStorage {
    public var _value: Builtin.Vec8xInt8
    @_transparent public var scalarCount: Swift.Int {
      @_transparent get {
      return 8
    }
    }
    @_transparent public init() {
      _value = Builtin.zeroInitializer()
    }
    public subscript(index: Swift.Int) -> Swift.UInt8 {
      @_transparent get {
        return UInt8(Builtin.extractelement_Vec8xInt8_Int32(
          _value, Int32(truncatingIfNeeded: index)._value
        ))
      }
      @_transparent set {
        _value = Builtin.insertelement_Vec8xInt8_Int8_Int32(
          _value, newValue._value, Int32(truncatingIfNeeded: index)._value
        )
      }
    }
    public typealias Scalar = Swift.UInt8
  }
  @frozen @_alignment(16) public struct SIMD16Storage : Swift.SIMDStorage {
    public var _value: Builtin.Vec16xInt8
    @_transparent public var scalarCount: Swift.Int {
      @_transparent get {
      return 16
    }
    }
    @_transparent public init() {
      _value = Builtin.zeroInitializer()
    }
    public subscript(index: Swift.Int) -> Swift.UInt8 {
      @_transparent get {
        return UInt8(Builtin.extractelement_Vec16xInt8_Int32(
          _value, Int32(truncatingIfNeeded: index)._value
        ))
      }
      @_transparent set {
        _value = Builtin.insertelement_Vec16xInt8_Int8_Int32(
          _value, newValue._value, Int32(truncatingIfNeeded: index)._value
        )
      }
    }
    public typealias Scalar = Swift.UInt8
  }
  @frozen @_alignment(16) public struct SIMD32Storage : Swift.SIMDStorage {
    public var _value: Builtin.Vec32xInt8
    @_transparent public var scalarCount: Swift.Int {
      @_transparent get {
      return 32
    }
    }
    @_transparent public init() {
      _value = Builtin.zeroInitializer()
    }
    public subscript(index: Swift.Int) -> Swift.UInt8 {
      @_transparent get {
        return UInt8(Builtin.extractelement_Vec32xInt8_Int32(
          _value, Int32(truncatingIfNeeded: index)._value
        ))
      }
      @_transparent set {
        _value = Builtin.insertelement_Vec32xInt8_Int8_Int32(
          _value, newValue._value, Int32(truncatingIfNeeded: index)._value
        )
      }
    }
    public typealias Scalar = Swift.UInt8
  }
  @frozen @_alignment(16) public struct SIMD64Storage : Swift.SIMDStorage {
    public var _value: Builtin.Vec64xInt8
    @_transparent public var scalarCount: Swift.Int {
      @_transparent get {
      return 64
    }
    }
    @_transparent public init() {
      _value = Builtin.zeroInitializer()
    }
    public subscript(index: Swift.Int) -> Swift.UInt8 {
      @_transparent get {
        return UInt8(Builtin.extractelement_Vec64xInt8_Int32(
          _value, Int32(truncatingIfNeeded: index)._value
        ))
      }
      @_transparent set {
        _value = Builtin.insertelement_Vec64xInt8_Int8_Int32(
          _value, newValue._value, Int32(truncatingIfNeeded: index)._value
        )
      }
    }
    public typealias Scalar = Swift.UInt8
  }
}
extension Int8 : Swift.SIMDScalar {
  public typealias SIMDMaskScalar = Swift.Int8
  @frozen @_alignment(2) public struct SIMD2Storage : Swift.SIMDStorage {
    public var _value: Builtin.Vec2xInt8
    @_transparent public var scalarCount: Swift.Int {
      @_transparent get {
      return 2
    }
    }
    @_transparent public init() {
      _value = Builtin.zeroInitializer()
    }
    public subscript(index: Swift.Int) -> Swift.Int8 {
      @_transparent get {
        return Int8(Builtin.extractelement_Vec2xInt8_Int32(
          _value, Int32(truncatingIfNeeded: index)._value
        ))
      }
      @_transparent set {
        _value = Builtin.insertelement_Vec2xInt8_Int8_Int32(
          _value, newValue._value, Int32(truncatingIfNeeded: index)._value
        )
      }
    }
    public typealias Scalar = Swift.Int8
  }
  @frozen @_alignment(4) public struct SIMD4Storage : Swift.SIMDStorage {
    public var _value: Builtin.Vec4xInt8
    @_transparent public var scalarCount: Swift.Int {
      @_transparent get {
      return 4
    }
    }
    @_transparent public init() {
      _value = Builtin.zeroInitializer()
    }
    public subscript(index: Swift.Int) -> Swift.Int8 {
      @_transparent get {
        return Int8(Builtin.extractelement_Vec4xInt8_Int32(
          _value, Int32(truncatingIfNeeded: index)._value
        ))
      }
      @_transparent set {
        _value = Builtin.insertelement_Vec4xInt8_Int8_Int32(
          _value, newValue._value, Int32(truncatingIfNeeded: index)._value
        )
      }
    }
    public typealias Scalar = Swift.Int8
  }
  @frozen @_alignment(8) public struct SIMD8Storage : Swift.SIMDStorage {
    public var _value: Builtin.Vec8xInt8
    @_transparent public var scalarCount: Swift.Int {
      @_transparent get {
      return 8
    }
    }
    @_transparent public init() {
      _value = Builtin.zeroInitializer()
    }
    public subscript(index: Swift.Int) -> Swift.Int8 {
      @_transparent get {
        return Int8(Builtin.extractelement_Vec8xInt8_Int32(
          _value, Int32(truncatingIfNeeded: index)._value
        ))
      }
      @_transparent set {
        _value = Builtin.insertelement_Vec8xInt8_Int8_Int32(
          _value, newValue._value, Int32(truncatingIfNeeded: index)._value
        )
      }
    }
    public typealias Scalar = Swift.Int8
  }
  @frozen @_alignment(16) public struct SIMD16Storage : Swift.SIMDStorage {
    public var _value: Builtin.Vec16xInt8
    @_transparent public var scalarCount: Swift.Int {
      @_transparent get {
      return 16
    }
    }
    @_transparent public init() {
      _value = Builtin.zeroInitializer()
    }
    public subscript(index: Swift.Int) -> Swift.Int8 {
      @_transparent get {
        return Int8(Builtin.extractelement_Vec16xInt8_Int32(
          _value, Int32(truncatingIfNeeded: index)._value
        ))
      }
      @_transparent set {
        _value = Builtin.insertelement_Vec16xInt8_Int8_Int32(
          _value, newValue._value, Int32(truncatingIfNeeded: index)._value
        )
      }
    }
    public typealias Scalar = Swift.Int8
  }
  @frozen @_alignment(16) public struct SIMD32Storage : Swift.SIMDStorage {
    public var _value: Builtin.Vec32xInt8
    @_transparent public var scalarCount: Swift.Int {
      @_transparent get {
      return 32
    }
    }
    @_transparent public init() {
      _value = Builtin.zeroInitializer()
    }
    public subscript(index: Swift.Int) -> Swift.Int8 {
      @_transparent get {
        return Int8(Builtin.extractelement_Vec32xInt8_Int32(
          _value, Int32(truncatingIfNeeded: index)._value
        ))
      }
      @_transparent set {
        _value = Builtin.insertelement_Vec32xInt8_Int8_Int32(
          _value, newValue._value, Int32(truncatingIfNeeded: index)._value
        )
      }
    }
    public typealias Scalar = Swift.Int8
  }
  @frozen @_alignment(16) public struct SIMD64Storage : Swift.SIMDStorage {
    public var _value: Builtin.Vec64xInt8
    @_transparent public var scalarCount: Swift.Int {
      @_transparent get {
      return 64
    }
    }
    @_transparent public init() {
      _value = Builtin.zeroInitializer()
    }
    public subscript(index: Swift.Int) -> Swift.Int8 {
      @_transparent get {
        return Int8(Builtin.extractelement_Vec64xInt8_Int32(
          _value, Int32(truncatingIfNeeded: index)._value
        ))
      }
      @_transparent set {
        _value = Builtin.insertelement_Vec64xInt8_Int8_Int32(
          _value, newValue._value, Int32(truncatingIfNeeded: index)._value
        )
      }
    }
    public typealias Scalar = Swift.Int8
  }
}
extension UInt16 : Swift.SIMDScalar {
  public typealias SIMDMaskScalar = Swift.Int16
  @frozen @_alignment(4) public struct SIMD2Storage : Swift.SIMDStorage {
    public var _value: Builtin.Vec2xInt16
    @_transparent public var scalarCount: Swift.Int {
      @_transparent get {
      return 2
    }
    }
    @_transparent public init() {
      _value = Builtin.zeroInitializer()
    }
    public subscript(index: Swift.Int) -> Swift.UInt16 {
      @_transparent get {
        return UInt16(Builtin.extractelement_Vec2xInt16_Int32(
          _value, Int32(truncatingIfNeeded: index)._value
        ))
      }
      @_transparent set {
        _value = Builtin.insertelement_Vec2xInt16_Int16_Int32(
          _value, newValue._value, Int32(truncatingIfNeeded: index)._value
        )
      }
    }
    public typealias Scalar = Swift.UInt16
  }
  @frozen @_alignment(8) public struct SIMD4Storage : Swift.SIMDStorage {
    public var _value: Builtin.Vec4xInt16
    @_transparent public var scalarCount: Swift.Int {
      @_transparent get {
      return 4
    }
    }
    @_transparent public init() {
      _value = Builtin.zeroInitializer()
    }
    public subscript(index: Swift.Int) -> Swift.UInt16 {
      @_transparent get {
        return UInt16(Builtin.extractelement_Vec4xInt16_Int32(
          _value, Int32(truncatingIfNeeded: index)._value
        ))
      }
      @_transparent set {
        _value = Builtin.insertelement_Vec4xInt16_Int16_Int32(
          _value, newValue._value, Int32(truncatingIfNeeded: index)._value
        )
      }
    }
    public typealias Scalar = Swift.UInt16
  }
  @frozen @_alignment(16) public struct SIMD8Storage : Swift.SIMDStorage {
    public var _value: Builtin.Vec8xInt16
    @_transparent public var scalarCount: Swift.Int {
      @_transparent get {
      return 8
    }
    }
    @_transparent public init() {
      _value = Builtin.zeroInitializer()
    }
    public subscript(index: Swift.Int) -> Swift.UInt16 {
      @_transparent get {
        return UInt16(Builtin.extractelement_Vec8xInt16_Int32(
          _value, Int32(truncatingIfNeeded: index)._value
        ))
      }
      @_transparent set {
        _value = Builtin.insertelement_Vec8xInt16_Int16_Int32(
          _value, newValue._value, Int32(truncatingIfNeeded: index)._value
        )
      }
    }
    public typealias Scalar = Swift.UInt16
  }
  @frozen @_alignment(16) public struct SIMD16Storage : Swift.SIMDStorage {
    public var _value: Builtin.Vec16xInt16
    @_transparent public var scalarCount: Swift.Int {
      @_transparent get {
      return 16
    }
    }
    @_transparent public init() {
      _value = Builtin.zeroInitializer()
    }
    public subscript(index: Swift.Int) -> Swift.UInt16 {
      @_transparent get {
        return UInt16(Builtin.extractelement_Vec16xInt16_Int32(
          _value, Int32(truncatingIfNeeded: index)._value
        ))
      }
      @_transparent set {
        _value = Builtin.insertelement_Vec16xInt16_Int16_Int32(
          _value, newValue._value, Int32(truncatingIfNeeded: index)._value
        )
      }
    }
    public typealias Scalar = Swift.UInt16
  }
  @frozen @_alignment(16) public struct SIMD32Storage : Swift.SIMDStorage {
    public var _value: Builtin.Vec32xInt16
    @_transparent public var scalarCount: Swift.Int {
      @_transparent get {
      return 32
    }
    }
    @_transparent public init() {
      _value = Builtin.zeroInitializer()
    }
    public subscript(index: Swift.Int) -> Swift.UInt16 {
      @_transparent get {
        return UInt16(Builtin.extractelement_Vec32xInt16_Int32(
          _value, Int32(truncatingIfNeeded: index)._value
        ))
      }
      @_transparent set {
        _value = Builtin.insertelement_Vec32xInt16_Int16_Int32(
          _value, newValue._value, Int32(truncatingIfNeeded: index)._value
        )
      }
    }
    public typealias Scalar = Swift.UInt16
  }
  @frozen @_alignment(16) public struct SIMD64Storage : Swift.SIMDStorage {
    public var _value: Builtin.Vec64xInt16
    @_transparent public var scalarCount: Swift.Int {
      @_transparent get {
      return 64
    }
    }
    @_transparent public init() {
      _value = Builtin.zeroInitializer()
    }
    public subscript(index: Swift.Int) -> Swift.UInt16 {
      @_transparent get {
        return UInt16(Builtin.extractelement_Vec64xInt16_Int32(
          _value, Int32(truncatingIfNeeded: index)._value
        ))
      }
      @_transparent set {
        _value = Builtin.insertelement_Vec64xInt16_Int16_Int32(
          _value, newValue._value, Int32(truncatingIfNeeded: index)._value
        )
      }
    }
    public typealias Scalar = Swift.UInt16
  }
}
extension Int16 : Swift.SIMDScalar {
  public typealias SIMDMaskScalar = Swift.Int16
  @frozen @_alignment(4) public struct SIMD2Storage : Swift.SIMDStorage {
    public var _value: Builtin.Vec2xInt16
    @_transparent public var scalarCount: Swift.Int {
      @_transparent get {
      return 2
    }
    }
    @_transparent public init() {
      _value = Builtin.zeroInitializer()
    }
    public subscript(index: Swift.Int) -> Swift.Int16 {
      @_transparent get {
        return Int16(Builtin.extractelement_Vec2xInt16_Int32(
          _value, Int32(truncatingIfNeeded: index)._value
        ))
      }
      @_transparent set {
        _value = Builtin.insertelement_Vec2xInt16_Int16_Int32(
          _value, newValue._value, Int32(truncatingIfNeeded: index)._value
        )
      }
    }
    public typealias Scalar = Swift.Int16
  }
  @frozen @_alignment(8) public struct SIMD4Storage : Swift.SIMDStorage {
    public var _value: Builtin.Vec4xInt16
    @_transparent public var scalarCount: Swift.Int {
      @_transparent get {
      return 4
    }
    }
    @_transparent public init() {
      _value = Builtin.zeroInitializer()
    }
    public subscript(index: Swift.Int) -> Swift.Int16 {
      @_transparent get {
        return Int16(Builtin.extractelement_Vec4xInt16_Int32(
          _value, Int32(truncatingIfNeeded: index)._value
        ))
      }
      @_transparent set {
        _value = Builtin.insertelement_Vec4xInt16_Int16_Int32(
          _value, newValue._value, Int32(truncatingIfNeeded: index)._value
        )
      }
    }
    public typealias Scalar = Swift.Int16
  }
  @frozen @_alignment(16) public struct SIMD8Storage : Swift.SIMDStorage {
    public var _value: Builtin.Vec8xInt16
    @_transparent public var scalarCount: Swift.Int {
      @_transparent get {
      return 8
    }
    }
    @_transparent public init() {
      _value = Builtin.zeroInitializer()
    }
    public subscript(index: Swift.Int) -> Swift.Int16 {
      @_transparent get {
        return Int16(Builtin.extractelement_Vec8xInt16_Int32(
          _value, Int32(truncatingIfNeeded: index)._value
        ))
      }
      @_transparent set {
        _value = Builtin.insertelement_Vec8xInt16_Int16_Int32(
          _value, newValue._value, Int32(truncatingIfNeeded: index)._value
        )
      }
    }
    public typealias Scalar = Swift.Int16
  }
  @frozen @_alignment(16) public struct SIMD16Storage : Swift.SIMDStorage {
    public var _value: Builtin.Vec16xInt16
    @_transparent public var scalarCount: Swift.Int {
      @_transparent get {
      return 16
    }
    }
    @_transparent public init() {
      _value = Builtin.zeroInitializer()
    }
    public subscript(index: Swift.Int) -> Swift.Int16 {
      @_transparent get {
        return Int16(Builtin.extractelement_Vec16xInt16_Int32(
          _value, Int32(truncatingIfNeeded: index)._value
        ))
      }
      @_transparent set {
        _value = Builtin.insertelement_Vec16xInt16_Int16_Int32(
          _value, newValue._value, Int32(truncatingIfNeeded: index)._value
        )
      }
    }
    public typealias Scalar = Swift.Int16
  }
  @frozen @_alignment(16) public struct SIMD32Storage : Swift.SIMDStorage {
    public var _value: Builtin.Vec32xInt16
    @_transparent public var scalarCount: Swift.Int {
      @_transparent get {
      return 32
    }
    }
    @_transparent public init() {
      _value = Builtin.zeroInitializer()
    }
    public subscript(index: Swift.Int) -> Swift.Int16 {
      @_transparent get {
        return Int16(Builtin.extractelement_Vec32xInt16_Int32(
          _value, Int32(truncatingIfNeeded: index)._value
        ))
      }
      @_transparent set {
        _value = Builtin.insertelement_Vec32xInt16_Int16_Int32(
          _value, newValue._value, Int32(truncatingIfNeeded: index)._value
        )
      }
    }
    public typealias Scalar = Swift.Int16
  }
  @frozen @_alignment(16) public struct SIMD64Storage : Swift.SIMDStorage {
    public var _value: Builtin.Vec64xInt16
    @_transparent public var scalarCount: Swift.Int {
      @_transparent get {
      return 64
    }
    }
    @_transparent public init() {
      _value = Builtin.zeroInitializer()
    }
    public subscript(index: Swift.Int) -> Swift.Int16 {
      @_transparent get {
        return Int16(Builtin.extractelement_Vec64xInt16_Int32(
          _value, Int32(truncatingIfNeeded: index)._value
        ))
      }
      @_transparent set {
        _value = Builtin.insertelement_Vec64xInt16_Int16_Int32(
          _value, newValue._value, Int32(truncatingIfNeeded: index)._value
        )
      }
    }
    public typealias Scalar = Swift.Int16
  }
}
extension UInt32 : Swift.SIMDScalar {
  public typealias SIMDMaskScalar = Swift.Int32
  @frozen @_alignment(8) public struct SIMD2Storage : Swift.SIMDStorage {
    public var _value: Builtin.Vec2xInt32
    @_transparent public var scalarCount: Swift.Int {
      @_transparent get {
      return 2
    }
    }
    @_transparent public init() {
      _value = Builtin.zeroInitializer()
    }
    public subscript(index: Swift.Int) -> Swift.UInt32 {
      @_transparent get {
        return UInt32(Builtin.extractelement_Vec2xInt32_Int32(
          _value, Int32(truncatingIfNeeded: index)._value
        ))
      }
      @_transparent set {
        _value = Builtin.insertelement_Vec2xInt32_Int32_Int32(
          _value, newValue._value, Int32(truncatingIfNeeded: index)._value
        )
      }
    }
    public typealias Scalar = Swift.UInt32
  }
  @frozen @_alignment(16) public struct SIMD4Storage : Swift.SIMDStorage {
    public var _value: Builtin.Vec4xInt32
    @_transparent public var scalarCount: Swift.Int {
      @_transparent get {
      return 4
    }
    }
    @_transparent public init() {
      _value = Builtin.zeroInitializer()
    }
    public subscript(index: Swift.Int) -> Swift.UInt32 {
      @_transparent get {
        return UInt32(Builtin.extractelement_Vec4xInt32_Int32(
          _value, Int32(truncatingIfNeeded: index)._value
        ))
      }
      @_transparent set {
        _value = Builtin.insertelement_Vec4xInt32_Int32_Int32(
          _value, newValue._value, Int32(truncatingIfNeeded: index)._value
        )
      }
    }
    public typealias Scalar = Swift.UInt32
  }
  @frozen @_alignment(16) public struct SIMD8Storage : Swift.SIMDStorage {
    public var _value: Builtin.Vec8xInt32
    @_transparent public var scalarCount: Swift.Int {
      @_transparent get {
      return 8
    }
    }
    @_transparent public init() {
      _value = Builtin.zeroInitializer()
    }
    public subscript(index: Swift.Int) -> Swift.UInt32 {
      @_transparent get {
        return UInt32(Builtin.extractelement_Vec8xInt32_Int32(
          _value, Int32(truncatingIfNeeded: index)._value
        ))
      }
      @_transparent set {
        _value = Builtin.insertelement_Vec8xInt32_Int32_Int32(
          _value, newValue._value, Int32(truncatingIfNeeded: index)._value
        )
      }
    }
    public typealias Scalar = Swift.UInt32
  }
  @frozen @_alignment(16) public struct SIMD16Storage : Swift.SIMDStorage {
    public var _value: Builtin.Vec16xInt32
    @_transparent public var scalarCount: Swift.Int {
      @_transparent get {
      return 16
    }
    }
    @_transparent public init() {
      _value = Builtin.zeroInitializer()
    }
    public subscript(index: Swift.Int) -> Swift.UInt32 {
      @_transparent get {
        return UInt32(Builtin.extractelement_Vec16xInt32_Int32(
          _value, Int32(truncatingIfNeeded: index)._value
        ))
      }
      @_transparent set {
        _value = Builtin.insertelement_Vec16xInt32_Int32_Int32(
          _value, newValue._value, Int32(truncatingIfNeeded: index)._value
        )
      }
    }
    public typealias Scalar = Swift.UInt32
  }
  @frozen @_alignment(16) public struct SIMD32Storage : Swift.SIMDStorage {
    public var _value: Builtin.Vec32xInt32
    @_transparent public var scalarCount: Swift.Int {
      @_transparent get {
      return 32
    }
    }
    @_transparent public init() {
      _value = Builtin.zeroInitializer()
    }
    public subscript(index: Swift.Int) -> Swift.UInt32 {
      @_transparent get {
        return UInt32(Builtin.extractelement_Vec32xInt32_Int32(
          _value, Int32(truncatingIfNeeded: index)._value
        ))
      }
      @_transparent set {
        _value = Builtin.insertelement_Vec32xInt32_Int32_Int32(
          _value, newValue._value, Int32(truncatingIfNeeded: index)._value
        )
      }
    }
    public typealias Scalar = Swift.UInt32
  }
  @frozen @_alignment(16) public struct SIMD64Storage : Swift.SIMDStorage {
    public var _value: Builtin.Vec64xInt32
    @_transparent public var scalarCount: Swift.Int {
      @_transparent get {
      return 64
    }
    }
    @_transparent public init() {
      _value = Builtin.zeroInitializer()
    }
    public subscript(index: Swift.Int) -> Swift.UInt32 {
      @_transparent get {
        return UInt32(Builtin.extractelement_Vec64xInt32_Int32(
          _value, Int32(truncatingIfNeeded: index)._value
        ))
      }
      @_transparent set {
        _value = Builtin.insertelement_Vec64xInt32_Int32_Int32(
          _value, newValue._value, Int32(truncatingIfNeeded: index)._value
        )
      }
    }
    public typealias Scalar = Swift.UInt32
  }
}
extension Int32 : Swift.SIMDScalar {
  public typealias SIMDMaskScalar = Swift.Int32
  @frozen @_alignment(8) public struct SIMD2Storage : Swift.SIMDStorage {
    public var _value: Builtin.Vec2xInt32
    @_transparent public var scalarCount: Swift.Int {
      @_transparent get {
      return 2
    }
    }
    @_transparent public init() {
      _value = Builtin.zeroInitializer()
    }
    public subscript(index: Swift.Int) -> Swift.Int32 {
      @_transparent get {
        return Int32(Builtin.extractelement_Vec2xInt32_Int32(
          _value, Int32(truncatingIfNeeded: index)._value
        ))
      }
      @_transparent set {
        _value = Builtin.insertelement_Vec2xInt32_Int32_Int32(
          _value, newValue._value, Int32(truncatingIfNeeded: index)._value
        )
      }
    }
    public typealias Scalar = Swift.Int32
  }
  @frozen @_alignment(16) public struct SIMD4Storage : Swift.SIMDStorage {
    public var _value: Builtin.Vec4xInt32
    @_transparent public var scalarCount: Swift.Int {
      @_transparent get {
      return 4
    }
    }
    @_transparent public init() {
      _value = Builtin.zeroInitializer()
    }
    public subscript(index: Swift.Int) -> Swift.Int32 {
      @_transparent get {
        return Int32(Builtin.extractelement_Vec4xInt32_Int32(
          _value, Int32(truncatingIfNeeded: index)._value
        ))
      }
      @_transparent set {
        _value = Builtin.insertelement_Vec4xInt32_Int32_Int32(
          _value, newValue._value, Int32(truncatingIfNeeded: index)._value
        )
      }
    }
    public typealias Scalar = Swift.Int32
  }
  @frozen @_alignment(16) public struct SIMD8Storage : Swift.SIMDStorage {
    public var _value: Builtin.Vec8xInt32
    @_transparent public var scalarCount: Swift.Int {
      @_transparent get {
      return 8
    }
    }
    @_transparent public init() {
      _value = Builtin.zeroInitializer()
    }
    public subscript(index: Swift.Int) -> Swift.Int32 {
      @_transparent get {
        return Int32(Builtin.extractelement_Vec8xInt32_Int32(
          _value, Int32(truncatingIfNeeded: index)._value
        ))
      }
      @_transparent set {
        _value = Builtin.insertelement_Vec8xInt32_Int32_Int32(
          _value, newValue._value, Int32(truncatingIfNeeded: index)._value
        )
      }
    }
    public typealias Scalar = Swift.Int32
  }
  @frozen @_alignment(16) public struct SIMD16Storage : Swift.SIMDStorage {
    public var _value: Builtin.Vec16xInt32
    @_transparent public var scalarCount: Swift.Int {
      @_transparent get {
      return 16
    }
    }
    @_transparent public init() {
      _value = Builtin.zeroInitializer()
    }
    public subscript(index: Swift.Int) -> Swift.Int32 {
      @_transparent get {
        return Int32(Builtin.extractelement_Vec16xInt32_Int32(
          _value, Int32(truncatingIfNeeded: index)._value
        ))
      }
      @_transparent set {
        _value = Builtin.insertelement_Vec16xInt32_Int32_Int32(
          _value, newValue._value, Int32(truncatingIfNeeded: index)._value
        )
      }
    }
    public typealias Scalar = Swift.Int32
  }
  @frozen @_alignment(16) public struct SIMD32Storage : Swift.SIMDStorage {
    public var _value: Builtin.Vec32xInt32
    @_transparent public var scalarCount: Swift.Int {
      @_transparent get {
      return 32
    }
    }
    @_transparent public init() {
      _value = Builtin.zeroInitializer()
    }
    public subscript(index: Swift.Int) -> Swift.Int32 {
      @_transparent get {
        return Int32(Builtin.extractelement_Vec32xInt32_Int32(
          _value, Int32(truncatingIfNeeded: index)._value
        ))
      }
      @_transparent set {
        _value = Builtin.insertelement_Vec32xInt32_Int32_Int32(
          _value, newValue._value, Int32(truncatingIfNeeded: index)._value
        )
      }
    }
    public typealias Scalar = Swift.Int32
  }
  @frozen @_alignment(16) public struct SIMD64Storage : Swift.SIMDStorage {
    public var _value: Builtin.Vec64xInt32
    @_transparent public var scalarCount: Swift.Int {
      @_transparent get {
      return 64
    }
    }
    @_transparent public init() {
      _value = Builtin.zeroInitializer()
    }
    public subscript(index: Swift.Int) -> Swift.Int32 {
      @_transparent get {
        return Int32(Builtin.extractelement_Vec64xInt32_Int32(
          _value, Int32(truncatingIfNeeded: index)._value
        ))
      }
      @_transparent set {
        _value = Builtin.insertelement_Vec64xInt32_Int32_Int32(
          _value, newValue._value, Int32(truncatingIfNeeded: index)._value
        )
      }
    }
    public typealias Scalar = Swift.Int32
  }
}
extension UInt64 : Swift.SIMDScalar {
  public typealias SIMDMaskScalar = Swift.Int64
  @frozen @_alignment(16) public struct SIMD2Storage : Swift.SIMDStorage {
    public var _value: Builtin.Vec2xInt64
    @_transparent public var scalarCount: Swift.Int {
      @_transparent get {
      return 2
    }
    }
    @_transparent public init() {
      _value = Builtin.zeroInitializer()
    }
    public subscript(index: Swift.Int) -> Swift.UInt64 {
      @_transparent get {
        return UInt64(Builtin.extractelement_Vec2xInt64_Int32(
          _value, Int32(truncatingIfNeeded: index)._value
        ))
      }
      @_transparent set {
        _value = Builtin.insertelement_Vec2xInt64_Int64_Int32(
          _value, newValue._value, Int32(truncatingIfNeeded: index)._value
        )
      }
    }
    public typealias Scalar = Swift.UInt64
  }
  @frozen @_alignment(16) public struct SIMD4Storage : Swift.SIMDStorage {
    public var _value: Builtin.Vec4xInt64
    @_transparent public var scalarCount: Swift.Int {
      @_transparent get {
      return 4
    }
    }
    @_transparent public init() {
      _value = Builtin.zeroInitializer()
    }
    public subscript(index: Swift.Int) -> Swift.UInt64 {
      @_transparent get {
        return UInt64(Builtin.extractelement_Vec4xInt64_Int32(
          _value, Int32(truncatingIfNeeded: index)._value
        ))
      }
      @_transparent set {
        _value = Builtin.insertelement_Vec4xInt64_Int64_Int32(
          _value, newValue._value, Int32(truncatingIfNeeded: index)._value
        )
      }
    }
    public typealias Scalar = Swift.UInt64
  }
  @frozen @_alignment(16) public struct SIMD8Storage : Swift.SIMDStorage {
    public var _value: Builtin.Vec8xInt64
    @_transparent public var scalarCount: Swift.Int {
      @_transparent get {
      return 8
    }
    }
    @_transparent public init() {
      _value = Builtin.zeroInitializer()
    }
    public subscript(index: Swift.Int) -> Swift.UInt64 {
      @_transparent get {
        return UInt64(Builtin.extractelement_Vec8xInt64_Int32(
          _value, Int32(truncatingIfNeeded: index)._value
        ))
      }
      @_transparent set {
        _value = Builtin.insertelement_Vec8xInt64_Int64_Int32(
          _value, newValue._value, Int32(truncatingIfNeeded: index)._value
        )
      }
    }
    public typealias Scalar = Swift.UInt64
  }
  @frozen @_alignment(16) public struct SIMD16Storage : Swift.SIMDStorage {
    public var _value: Builtin.Vec16xInt64
    @_transparent public var scalarCount: Swift.Int {
      @_transparent get {
      return 16
    }
    }
    @_transparent public init() {
      _value = Builtin.zeroInitializer()
    }
    public subscript(index: Swift.Int) -> Swift.UInt64 {
      @_transparent get {
        return UInt64(Builtin.extractelement_Vec16xInt64_Int32(
          _value, Int32(truncatingIfNeeded: index)._value
        ))
      }
      @_transparent set {
        _value = Builtin.insertelement_Vec16xInt64_Int64_Int32(
          _value, newValue._value, Int32(truncatingIfNeeded: index)._value
        )
      }
    }
    public typealias Scalar = Swift.UInt64
  }
  @frozen @_alignment(16) public struct SIMD32Storage : Swift.SIMDStorage {
    public var _value: Builtin.Vec32xInt64
    @_transparent public var scalarCount: Swift.Int {
      @_transparent get {
      return 32
    }
    }
    @_transparent public init() {
      _value = Builtin.zeroInitializer()
    }
    public subscript(index: Swift.Int) -> Swift.UInt64 {
      @_transparent get {
        return UInt64(Builtin.extractelement_Vec32xInt64_Int32(
          _value, Int32(truncatingIfNeeded: index)._value
        ))
      }
      @_transparent set {
        _value = Builtin.insertelement_Vec32xInt64_Int64_Int32(
          _value, newValue._value, Int32(truncatingIfNeeded: index)._value
        )
      }
    }
    public typealias Scalar = Swift.UInt64
  }
  @frozen @_alignment(16) public struct SIMD64Storage : Swift.SIMDStorage {
    public var _value: Builtin.Vec64xInt64
    @_transparent public var scalarCount: Swift.Int {
      @_transparent get {
      return 64
    }
    }
    @_transparent public init() {
      _value = Builtin.zeroInitializer()
    }
    public subscript(index: Swift.Int) -> Swift.UInt64 {
      @_transparent get {
        return UInt64(Builtin.extractelement_Vec64xInt64_Int32(
          _value, Int32(truncatingIfNeeded: index)._value
        ))
      }
      @_transparent set {
        _value = Builtin.insertelement_Vec64xInt64_Int64_Int32(
          _value, newValue._value, Int32(truncatingIfNeeded: index)._value
        )
      }
    }
    public typealias Scalar = Swift.UInt64
  }
}
extension Int64 : Swift.SIMDScalar {
  public typealias SIMDMaskScalar = Swift.Int64
  @frozen @_alignment(16) public struct SIMD2Storage : Swift.SIMDStorage {
    public var _value: Builtin.Vec2xInt64
    @_transparent public var scalarCount: Swift.Int {
      @_transparent get {
      return 2
    }
    }
    @_transparent public init() {
      _value = Builtin.zeroInitializer()
    }
    public subscript(index: Swift.Int) -> Swift.Int64 {
      @_transparent get {
        return Int64(Builtin.extractelement_Vec2xInt64_Int32(
          _value, Int32(truncatingIfNeeded: index)._value
        ))
      }
      @_transparent set {
        _value = Builtin.insertelement_Vec2xInt64_Int64_Int32(
          _value, newValue._value, Int32(truncatingIfNeeded: index)._value
        )
      }
    }
    public typealias Scalar = Swift.Int64
  }
  @frozen @_alignment(16) public struct SIMD4Storage : Swift.SIMDStorage {
    public var _value: Builtin.Vec4xInt64
    @_transparent public var scalarCount: Swift.Int {
      @_transparent get {
      return 4
    }
    }
    @_transparent public init() {
      _value = Builtin.zeroInitializer()
    }
    public subscript(index: Swift.Int) -> Swift.Int64 {
      @_transparent get {
        return Int64(Builtin.extractelement_Vec4xInt64_Int32(
          _value, Int32(truncatingIfNeeded: index)._value
        ))
      }
      @_transparent set {
        _value = Builtin.insertelement_Vec4xInt64_Int64_Int32(
          _value, newValue._value, Int32(truncatingIfNeeded: index)._value
        )
      }
    }
    public typealias Scalar = Swift.Int64
  }
  @frozen @_alignment(16) public struct SIMD8Storage : Swift.SIMDStorage {
    public var _value: Builtin.Vec8xInt64
    @_transparent public var scalarCount: Swift.Int {
      @_transparent get {
      return 8
    }
    }
    @_transparent public init() {
      _value = Builtin.zeroInitializer()
    }
    public subscript(index: Swift.Int) -> Swift.Int64 {
      @_transparent get {
        return Int64(Builtin.extractelement_Vec8xInt64_Int32(
          _value, Int32(truncatingIfNeeded: index)._value
        ))
      }
      @_transparent set {
        _value = Builtin.insertelement_Vec8xInt64_Int64_Int32(
          _value, newValue._value, Int32(truncatingIfNeeded: index)._value
        )
      }
    }
    public typealias Scalar = Swift.Int64
  }
  @frozen @_alignment(16) public struct SIMD16Storage : Swift.SIMDStorage {
    public var _value: Builtin.Vec16xInt64
    @_transparent public var scalarCount: Swift.Int {
      @_transparent get {
      return 16
    }
    }
    @_transparent public init() {
      _value = Builtin.zeroInitializer()
    }
    public subscript(index: Swift.Int) -> Swift.Int64 {
      @_transparent get {
        return Int64(Builtin.extractelement_Vec16xInt64_Int32(
          _value, Int32(truncatingIfNeeded: index)._value
        ))
      }
      @_transparent set {
        _value = Builtin.insertelement_Vec16xInt64_Int64_Int32(
          _value, newValue._value, Int32(truncatingIfNeeded: index)._value
        )
      }
    }
    public typealias Scalar = Swift.Int64
  }
  @frozen @_alignment(16) public struct SIMD32Storage : Swift.SIMDStorage {
    public var _value: Builtin.Vec32xInt64
    @_transparent public var scalarCount: Swift.Int {
      @_transparent get {
      return 32
    }
    }
    @_transparent public init() {
      _value = Builtin.zeroInitializer()
    }
    public subscript(index: Swift.Int) -> Swift.Int64 {
      @_transparent get {
        return Int64(Builtin.extractelement_Vec32xInt64_Int32(
          _value, Int32(truncatingIfNeeded: index)._value
        ))
      }
      @_transparent set {
        _value = Builtin.insertelement_Vec32xInt64_Int64_Int32(
          _value, newValue._value, Int32(truncatingIfNeeded: index)._value
        )
      }
    }
    public typealias Scalar = Swift.Int64
  }
  @frozen @_alignment(16) public struct SIMD64Storage : Swift.SIMDStorage {
    public var _value: Builtin.Vec64xInt64
    @_transparent public var scalarCount: Swift.Int {
      @_transparent get {
      return 64
    }
    }
    @_transparent public init() {
      _value = Builtin.zeroInitializer()
    }
    public subscript(index: Swift.Int) -> Swift.Int64 {
      @_transparent get {
        return Int64(Builtin.extractelement_Vec64xInt64_Int32(
          _value, Int32(truncatingIfNeeded: index)._value
        ))
      }
      @_transparent set {
        _value = Builtin.insertelement_Vec64xInt64_Int64_Int32(
          _value, newValue._value, Int32(truncatingIfNeeded: index)._value
        )
      }
    }
    public typealias Scalar = Swift.Int64
  }
}
extension UInt : Swift.SIMDScalar {
  public typealias SIMDMaskScalar = Swift.Int
  @frozen @_alignment(16) public struct SIMD2Storage : Swift.SIMDStorage {
    public var _value: Builtin.Vec2xInt64
    @_transparent public var scalarCount: Swift.Int {
      @_transparent get {
      return 2
    }
    }
    @_transparent public init() {
      _value = Builtin.zeroInitializer()
    }
    public subscript(index: Swift.Int) -> Swift.UInt {
      @_transparent get {
        return UInt(Builtin.extractelement_Vec2xInt64_Int32(
          _value, Int32(truncatingIfNeeded: index)._value
        ))
      }
      @_transparent set {
        _value = Builtin.insertelement_Vec2xInt64_Int64_Int32(
          _value, newValue._value, Int32(truncatingIfNeeded: index)._value
        )
      }
    }
    public typealias Scalar = Swift.UInt
  }
  @frozen @_alignment(16) public struct SIMD4Storage : Swift.SIMDStorage {
    public var _value: Builtin.Vec4xInt64
    @_transparent public var scalarCount: Swift.Int {
      @_transparent get {
      return 4
    }
    }
    @_transparent public init() {
      _value = Builtin.zeroInitializer()
    }
    public subscript(index: Swift.Int) -> Swift.UInt {
      @_transparent get {
        return UInt(Builtin.extractelement_Vec4xInt64_Int32(
          _value, Int32(truncatingIfNeeded: index)._value
        ))
      }
      @_transparent set {
        _value = Builtin.insertelement_Vec4xInt64_Int64_Int32(
          _value, newValue._value, Int32(truncatingIfNeeded: index)._value
        )
      }
    }
    public typealias Scalar = Swift.UInt
  }
  @frozen @_alignment(16) public struct SIMD8Storage : Swift.SIMDStorage {
    public var _value: Builtin.Vec8xInt64
    @_transparent public var scalarCount: Swift.Int {
      @_transparent get {
      return 8
    }
    }
    @_transparent public init() {
      _value = Builtin.zeroInitializer()
    }
    public subscript(index: Swift.Int) -> Swift.UInt {
      @_transparent get {
        return UInt(Builtin.extractelement_Vec8xInt64_Int32(
          _value, Int32(truncatingIfNeeded: index)._value
        ))
      }
      @_transparent set {
        _value = Builtin.insertelement_Vec8xInt64_Int64_Int32(
          _value, newValue._value, Int32(truncatingIfNeeded: index)._value
        )
      }
    }
    public typealias Scalar = Swift.UInt
  }
  @frozen @_alignment(16) public struct SIMD16Storage : Swift.SIMDStorage {
    public var _value: Builtin.Vec16xInt64
    @_transparent public var scalarCount: Swift.Int {
      @_transparent get {
      return 16
    }
    }
    @_transparent public init() {
      _value = Builtin.zeroInitializer()
    }
    public subscript(index: Swift.Int) -> Swift.UInt {
      @_transparent get {
        return UInt(Builtin.extractelement_Vec16xInt64_Int32(
          _value, Int32(truncatingIfNeeded: index)._value
        ))
      }
      @_transparent set {
        _value = Builtin.insertelement_Vec16xInt64_Int64_Int32(
          _value, newValue._value, Int32(truncatingIfNeeded: index)._value
        )
      }
    }
    public typealias Scalar = Swift.UInt
  }
  @frozen @_alignment(16) public struct SIMD32Storage : Swift.SIMDStorage {
    public var _value: Builtin.Vec32xInt64
    @_transparent public var scalarCount: Swift.Int {
      @_transparent get {
      return 32
    }
    }
    @_transparent public init() {
      _value = Builtin.zeroInitializer()
    }
    public subscript(index: Swift.Int) -> Swift.UInt {
      @_transparent get {
        return UInt(Builtin.extractelement_Vec32xInt64_Int32(
          _value, Int32(truncatingIfNeeded: index)._value
        ))
      }
      @_transparent set {
        _value = Builtin.insertelement_Vec32xInt64_Int64_Int32(
          _value, newValue._value, Int32(truncatingIfNeeded: index)._value
        )
      }
    }
    public typealias Scalar = Swift.UInt
  }
  @frozen @_alignment(16) public struct SIMD64Storage : Swift.SIMDStorage {
    public var _value: Builtin.Vec64xInt64
    @_transparent public var scalarCount: Swift.Int {
      @_transparent get {
      return 64
    }
    }
    @_transparent public init() {
      _value = Builtin.zeroInitializer()
    }
    public subscript(index: Swift.Int) -> Swift.UInt {
      @_transparent get {
        return UInt(Builtin.extractelement_Vec64xInt64_Int32(
          _value, Int32(truncatingIfNeeded: index)._value
        ))
      }
      @_transparent set {
        _value = Builtin.insertelement_Vec64xInt64_Int64_Int32(
          _value, newValue._value, Int32(truncatingIfNeeded: index)._value
        )
      }
    }
    public typealias Scalar = Swift.UInt
  }
}
extension Int : Swift.SIMDScalar {
  public typealias SIMDMaskScalar = Swift.Int
  @frozen @_alignment(16) public struct SIMD2Storage : Swift.SIMDStorage {
    public var _value: Builtin.Vec2xInt64
    @_transparent public var scalarCount: Swift.Int {
      @_transparent get {
      return 2
    }
    }
    @_transparent public init() {
      _value = Builtin.zeroInitializer()
    }
    public subscript(index: Swift.Int) -> Swift.Int {
      @_transparent get {
        return Int(Builtin.extractelement_Vec2xInt64_Int32(
          _value, Int32(truncatingIfNeeded: index)._value
        ))
      }
      @_transparent set {
        _value = Builtin.insertelement_Vec2xInt64_Int64_Int32(
          _value, newValue._value, Int32(truncatingIfNeeded: index)._value
        )
      }
    }
    public typealias Scalar = Swift.Int
  }
  @frozen @_alignment(16) public struct SIMD4Storage : Swift.SIMDStorage {
    public var _value: Builtin.Vec4xInt64
    @_transparent public var scalarCount: Swift.Int {
      @_transparent get {
      return 4
    }
    }
    @_transparent public init() {
      _value = Builtin.zeroInitializer()
    }
    public subscript(index: Swift.Int) -> Swift.Int {
      @_transparent get {
        return Int(Builtin.extractelement_Vec4xInt64_Int32(
          _value, Int32(truncatingIfNeeded: index)._value
        ))
      }
      @_transparent set {
        _value = Builtin.insertelement_Vec4xInt64_Int64_Int32(
          _value, newValue._value, Int32(truncatingIfNeeded: index)._value
        )
      }
    }
    public typealias Scalar = Swift.Int
  }
  @frozen @_alignment(16) public struct SIMD8Storage : Swift.SIMDStorage {
    public var _value: Builtin.Vec8xInt64
    @_transparent public var scalarCount: Swift.Int {
      @_transparent get {
      return 8
    }
    }
    @_transparent public init() {
      _value = Builtin.zeroInitializer()
    }
    public subscript(index: Swift.Int) -> Swift.Int {
      @_transparent get {
        return Int(Builtin.extractelement_Vec8xInt64_Int32(
          _value, Int32(truncatingIfNeeded: index)._value
        ))
      }
      @_transparent set {
        _value = Builtin.insertelement_Vec8xInt64_Int64_Int32(
          _value, newValue._value, Int32(truncatingIfNeeded: index)._value
        )
      }
    }
    public typealias Scalar = Swift.Int
  }
  @frozen @_alignment(16) public struct SIMD16Storage : Swift.SIMDStorage {
    public var _value: Builtin.Vec16xInt64
    @_transparent public var scalarCount: Swift.Int {
      @_transparent get {
      return 16
    }
    }
    @_transparent public init() {
      _value = Builtin.zeroInitializer()
    }
    public subscript(index: Swift.Int) -> Swift.Int {
      @_transparent get {
        return Int(Builtin.extractelement_Vec16xInt64_Int32(
          _value, Int32(truncatingIfNeeded: index)._value
        ))
      }
      @_transparent set {
        _value = Builtin.insertelement_Vec16xInt64_Int64_Int32(
          _value, newValue._value, Int32(truncatingIfNeeded: index)._value
        )
      }
    }
    public typealias Scalar = Swift.Int
  }
  @frozen @_alignment(16) public struct SIMD32Storage : Swift.SIMDStorage {
    public var _value: Builtin.Vec32xInt64
    @_transparent public var scalarCount: Swift.Int {
      @_transparent get {
      return 32
    }
    }
    @_transparent public init() {
      _value = Builtin.zeroInitializer()
    }
    public subscript(index: Swift.Int) -> Swift.Int {
      @_transparent get {
        return Int(Builtin.extractelement_Vec32xInt64_Int32(
          _value, Int32(truncatingIfNeeded: index)._value
        ))
      }
      @_transparent set {
        _value = Builtin.insertelement_Vec32xInt64_Int64_Int32(
          _value, newValue._value, Int32(truncatingIfNeeded: index)._value
        )
      }
    }
    public typealias Scalar = Swift.Int
  }
  @frozen @_alignment(16) public struct SIMD64Storage : Swift.SIMDStorage {
    public var _value: Builtin.Vec64xInt64
    @_transparent public var scalarCount: Swift.Int {
      @_transparent get {
      return 64
    }
    }
    @_transparent public init() {
      _value = Builtin.zeroInitializer()
    }
    public subscript(index: Swift.Int) -> Swift.Int {
      @_transparent get {
        return Int(Builtin.extractelement_Vec64xInt64_Int32(
          _value, Int32(truncatingIfNeeded: index)._value
        ))
      }
      @_transparent set {
        _value = Builtin.insertelement_Vec64xInt64_Int64_Int32(
          _value, newValue._value, Int32(truncatingIfNeeded: index)._value
        )
      }
    }
    public typealias Scalar = Swift.Int
  }
}
extension Float : Swift.SIMDScalar {
  public typealias SIMDMaskScalar = Swift.Int32
  @frozen @_alignment(8) public struct SIMD2Storage : Swift.SIMDStorage {
    public var _value: Builtin.Vec2xFPIEEE32
    @_transparent public var scalarCount: Swift.Int {
      @_transparent get {
      return 2
    }
    }
    @_transparent public init() {
      _value = Builtin.zeroInitializer()
    }
    public subscript(index: Swift.Int) -> Swift.Float {
      @_transparent get {
        return Float(Builtin.extractelement_Vec2xFPIEEE32_Int32(
          _value, Int32(truncatingIfNeeded: index)._value
        ))
      }
      @_transparent set {
        _value = Builtin.insertelement_Vec2xFPIEEE32_FPIEEE32_Int32(
          _value, newValue._value, Int32(truncatingIfNeeded: index)._value
        )
      }
    }
    public typealias Scalar = Swift.Float
  }
  @frozen @_alignment(16) public struct SIMD4Storage : Swift.SIMDStorage {
    public var _value: Builtin.Vec4xFPIEEE32
    @_transparent public var scalarCount: Swift.Int {
      @_transparent get {
      return 4
    }
    }
    @_transparent public init() {
      _value = Builtin.zeroInitializer()
    }
    public subscript(index: Swift.Int) -> Swift.Float {
      @_transparent get {
        return Float(Builtin.extractelement_Vec4xFPIEEE32_Int32(
          _value, Int32(truncatingIfNeeded: index)._value
        ))
      }
      @_transparent set {
        _value = Builtin.insertelement_Vec4xFPIEEE32_FPIEEE32_Int32(
          _value, newValue._value, Int32(truncatingIfNeeded: index)._value
        )
      }
    }
    public typealias Scalar = Swift.Float
  }
  @frozen @_alignment(16) public struct SIMD8Storage : Swift.SIMDStorage {
    public var _value: Builtin.Vec8xFPIEEE32
    @_transparent public var scalarCount: Swift.Int {
      @_transparent get {
      return 8
    }
    }
    @_transparent public init() {
      _value = Builtin.zeroInitializer()
    }
    public subscript(index: Swift.Int) -> Swift.Float {
      @_transparent get {
        return Float(Builtin.extractelement_Vec8xFPIEEE32_Int32(
          _value, Int32(truncatingIfNeeded: index)._value
        ))
      }
      @_transparent set {
        _value = Builtin.insertelement_Vec8xFPIEEE32_FPIEEE32_Int32(
          _value, newValue._value, Int32(truncatingIfNeeded: index)._value
        )
      }
    }
    public typealias Scalar = Swift.Float
  }
  @frozen @_alignment(16) public struct SIMD16Storage : Swift.SIMDStorage {
    public var _value: Builtin.Vec16xFPIEEE32
    @_transparent public var scalarCount: Swift.Int {
      @_transparent get {
      return 16
    }
    }
    @_transparent public init() {
      _value = Builtin.zeroInitializer()
    }
    public subscript(index: Swift.Int) -> Swift.Float {
      @_transparent get {
        return Float(Builtin.extractelement_Vec16xFPIEEE32_Int32(
          _value, Int32(truncatingIfNeeded: index)._value
        ))
      }
      @_transparent set {
        _value = Builtin.insertelement_Vec16xFPIEEE32_FPIEEE32_Int32(
          _value, newValue._value, Int32(truncatingIfNeeded: index)._value
        )
      }
    }
    public typealias Scalar = Swift.Float
  }
  @frozen @_alignment(16) public struct SIMD32Storage : Swift.SIMDStorage {
    public var _value: Builtin.Vec32xFPIEEE32
    @_transparent public var scalarCount: Swift.Int {
      @_transparent get {
      return 32
    }
    }
    @_transparent public init() {
      _value = Builtin.zeroInitializer()
    }
    public subscript(index: Swift.Int) -> Swift.Float {
      @_transparent get {
        return Float(Builtin.extractelement_Vec32xFPIEEE32_Int32(
          _value, Int32(truncatingIfNeeded: index)._value
        ))
      }
      @_transparent set {
        _value = Builtin.insertelement_Vec32xFPIEEE32_FPIEEE32_Int32(
          _value, newValue._value, Int32(truncatingIfNeeded: index)._value
        )
      }
    }
    public typealias Scalar = Swift.Float
  }
  @frozen @_alignment(16) public struct SIMD64Storage : Swift.SIMDStorage {
    public var _value: Builtin.Vec64xFPIEEE32
    @_transparent public var scalarCount: Swift.Int {
      @_transparent get {
      return 64
    }
    }
    @_transparent public init() {
      _value = Builtin.zeroInitializer()
    }
    public subscript(index: Swift.Int) -> Swift.Float {
      @_transparent get {
        return Float(Builtin.extractelement_Vec64xFPIEEE32_Int32(
          _value, Int32(truncatingIfNeeded: index)._value
        ))
      }
      @_transparent set {
        _value = Builtin.insertelement_Vec64xFPIEEE32_FPIEEE32_Int32(
          _value, newValue._value, Int32(truncatingIfNeeded: index)._value
        )
      }
    }
    public typealias Scalar = Swift.Float
  }
}
extension Double : Swift.SIMDScalar {
  public typealias SIMDMaskScalar = Swift.Int64
  @frozen @_alignment(16) public struct SIMD2Storage : Swift.SIMDStorage {
    public var _value: Builtin.Vec2xFPIEEE64
    @_transparent public var scalarCount: Swift.Int {
      @_transparent get {
      return 2
    }
    }
    @_transparent public init() {
      _value = Builtin.zeroInitializer()
    }
    public subscript(index: Swift.Int) -> Swift.Double {
      @_transparent get {
        return Double(Builtin.extractelement_Vec2xFPIEEE64_Int32(
          _value, Int32(truncatingIfNeeded: index)._value
        ))
      }
      @_transparent set {
        _value = Builtin.insertelement_Vec2xFPIEEE64_FPIEEE64_Int32(
          _value, newValue._value, Int32(truncatingIfNeeded: index)._value
        )
      }
    }
    public typealias Scalar = Swift.Double
  }
  @frozen @_alignment(16) public struct SIMD4Storage : Swift.SIMDStorage {
    public var _value: Builtin.Vec4xFPIEEE64
    @_transparent public var scalarCount: Swift.Int {
      @_transparent get {
      return 4
    }
    }
    @_transparent public init() {
      _value = Builtin.zeroInitializer()
    }
    public subscript(index: Swift.Int) -> Swift.Double {
      @_transparent get {
        return Double(Builtin.extractelement_Vec4xFPIEEE64_Int32(
          _value, Int32(truncatingIfNeeded: index)._value
        ))
      }
      @_transparent set {
        _value = Builtin.insertelement_Vec4xFPIEEE64_FPIEEE64_Int32(
          _value, newValue._value, Int32(truncatingIfNeeded: index)._value
        )
      }
    }
    public typealias Scalar = Swift.Double
  }
  @frozen @_alignment(16) public struct SIMD8Storage : Swift.SIMDStorage {
    public var _value: Builtin.Vec8xFPIEEE64
    @_transparent public var scalarCount: Swift.Int {
      @_transparent get {
      return 8
    }
    }
    @_transparent public init() {
      _value = Builtin.zeroInitializer()
    }
    public subscript(index: Swift.Int) -> Swift.Double {
      @_transparent get {
        return Double(Builtin.extractelement_Vec8xFPIEEE64_Int32(
          _value, Int32(truncatingIfNeeded: index)._value
        ))
      }
      @_transparent set {
        _value = Builtin.insertelement_Vec8xFPIEEE64_FPIEEE64_Int32(
          _value, newValue._value, Int32(truncatingIfNeeded: index)._value
        )
      }
    }
    public typealias Scalar = Swift.Double
  }
  @frozen @_alignment(16) public struct SIMD16Storage : Swift.SIMDStorage {
    public var _value: Builtin.Vec16xFPIEEE64
    @_transparent public var scalarCount: Swift.Int {
      @_transparent get {
      return 16
    }
    }
    @_transparent public init() {
      _value = Builtin.zeroInitializer()
    }
    public subscript(index: Swift.Int) -> Swift.Double {
      @_transparent get {
        return Double(Builtin.extractelement_Vec16xFPIEEE64_Int32(
          _value, Int32(truncatingIfNeeded: index)._value
        ))
      }
      @_transparent set {
        _value = Builtin.insertelement_Vec16xFPIEEE64_FPIEEE64_Int32(
          _value, newValue._value, Int32(truncatingIfNeeded: index)._value
        )
      }
    }
    public typealias Scalar = Swift.Double
  }
  @frozen @_alignment(16) public struct SIMD32Storage : Swift.SIMDStorage {
    public var _value: Builtin.Vec32xFPIEEE64
    @_transparent public var scalarCount: Swift.Int {
      @_transparent get {
      return 32
    }
    }
    @_transparent public init() {
      _value = Builtin.zeroInitializer()
    }
    public subscript(index: Swift.Int) -> Swift.Double {
      @_transparent get {
        return Double(Builtin.extractelement_Vec32xFPIEEE64_Int32(
          _value, Int32(truncatingIfNeeded: index)._value
        ))
      }
      @_transparent set {
        _value = Builtin.insertelement_Vec32xFPIEEE64_FPIEEE64_Int32(
          _value, newValue._value, Int32(truncatingIfNeeded: index)._value
        )
      }
    }
    public typealias Scalar = Swift.Double
  }
  @frozen @_alignment(16) public struct SIMD64Storage : Swift.SIMDStorage {
    public var _value: Builtin.Vec64xFPIEEE64
    @_transparent public var scalarCount: Swift.Int {
      @_transparent get {
      return 64
    }
    }
    @_transparent public init() {
      _value = Builtin.zeroInitializer()
    }
    public subscript(index: Swift.Int) -> Swift.Double {
      @_transparent get {
        return Double(Builtin.extractelement_Vec64xFPIEEE64_Int32(
          _value, Int32(truncatingIfNeeded: index)._value
        ))
      }
      @_transparent set {
        _value = Builtin.insertelement_Vec64xFPIEEE64_FPIEEE64_Int32(
          _value, newValue._value, Int32(truncatingIfNeeded: index)._value
        )
      }
    }
    public typealias Scalar = Swift.Double
  }
}
@inlinable public func == (lhs: (), rhs: ()) -> Swift.Bool {
  return true
}
@inlinable public func != (lhs: (), rhs: ()) -> Swift.Bool {
    return false
}
@inlinable public func < (lhs: (), rhs: ()) -> Swift.Bool {
    return false
}
@inlinable public func <= (lhs: (), rhs: ()) -> Swift.Bool {
    return true
}
@inlinable public func > (lhs: (), rhs: ()) -> Swift.Bool {
    return false
}
@inlinable public func >= (lhs: (), rhs: ()) -> Swift.Bool {
    return true
}
@inlinable public func == <A, B>(lhs: (A, B), rhs: (A, B)) -> Swift.Bool where A : Swift.Equatable, B : Swift.Equatable {
  guard lhs.0 == rhs.0 else { return false }
  /*tail*/ return (
    lhs.1
  ) == (
    rhs.1
  )
}
@inlinable public func != <A, B>(lhs: (A, B), rhs: (A, B)) -> Swift.Bool where A : Swift.Equatable, B : Swift.Equatable {
  guard lhs.0 == rhs.0 else { return true }
  /*tail*/ return (
    lhs.1
  ) != (
    rhs.1
  )
}
@inlinable public func < <A, B>(lhs: (A, B), rhs: (A, B)) -> Swift.Bool where A : Swift.Comparable, B : Swift.Comparable {
  if lhs.0 != rhs.0 { return lhs.0 < rhs.0 }
  /*tail*/ return (
    lhs.1
  ) < (
    rhs.1
  )
}
@inlinable public func <= <A, B>(lhs: (A, B), rhs: (A, B)) -> Swift.Bool where A : Swift.Comparable, B : Swift.Comparable {
  if lhs.0 != rhs.0 { return lhs.0 <= rhs.0 }
  /*tail*/ return (
    lhs.1
  ) <= (
    rhs.1
  )
}
@inlinable public func > <A, B>(lhs: (A, B), rhs: (A, B)) -> Swift.Bool where A : Swift.Comparable, B : Swift.Comparable {
  if lhs.0 != rhs.0 { return lhs.0 > rhs.0 }
  /*tail*/ return (
    lhs.1
  ) > (
    rhs.1
  )
}
@inlinable public func >= <A, B>(lhs: (A, B), rhs: (A, B)) -> Swift.Bool where A : Swift.Comparable, B : Swift.Comparable {
  if lhs.0 != rhs.0 { return lhs.0 >= rhs.0 }
  /*tail*/ return (
    lhs.1
  ) >= (
    rhs.1
  )
}
@inlinable public func == <A, B, C>(lhs: (A, B, C), rhs: (A, B, C)) -> Swift.Bool where A : Swift.Equatable, B : Swift.Equatable, C : Swift.Equatable {
  guard lhs.0 == rhs.0 else { return false }
  /*tail*/ return (
    lhs.1, lhs.2
  ) == (
    rhs.1, rhs.2
  )
}
@inlinable public func != <A, B, C>(lhs: (A, B, C), rhs: (A, B, C)) -> Swift.Bool where A : Swift.Equatable, B : Swift.Equatable, C : Swift.Equatable {
  guard lhs.0 == rhs.0 else { return true }
  /*tail*/ return (
    lhs.1, lhs.2
  ) != (
    rhs.1, rhs.2
  )
}
@inlinable public func < <A, B, C>(lhs: (A, B, C), rhs: (A, B, C)) -> Swift.Bool where A : Swift.Comparable, B : Swift.Comparable, C : Swift.Comparable {
  if lhs.0 != rhs.0 { return lhs.0 < rhs.0 }
  /*tail*/ return (
    lhs.1, lhs.2
  ) < (
    rhs.1, rhs.2
  )
}
@inlinable public func <= <A, B, C>(lhs: (A, B, C), rhs: (A, B, C)) -> Swift.Bool where A : Swift.Comparable, B : Swift.Comparable, C : Swift.Comparable {
  if lhs.0 != rhs.0 { return lhs.0 <= rhs.0 }
  /*tail*/ return (
    lhs.1, lhs.2
  ) <= (
    rhs.1, rhs.2
  )
}
@inlinable public func > <A, B, C>(lhs: (A, B, C), rhs: (A, B, C)) -> Swift.Bool where A : Swift.Comparable, B : Swift.Comparable, C : Swift.Comparable {
  if lhs.0 != rhs.0 { return lhs.0 > rhs.0 }
  /*tail*/ return (
    lhs.1, lhs.2
  ) > (
    rhs.1, rhs.2
  )
}
@inlinable public func >= <A, B, C>(lhs: (A, B, C), rhs: (A, B, C)) -> Swift.Bool where A : Swift.Comparable, B : Swift.Comparable, C : Swift.Comparable {
  if lhs.0 != rhs.0 { return lhs.0 >= rhs.0 }
  /*tail*/ return (
    lhs.1, lhs.2
  ) >= (
    rhs.1, rhs.2
  )
}
@inlinable public func == <A, B, C, D>(lhs: (A, B, C, D), rhs: (A, B, C, D)) -> Swift.Bool where A : Swift.Equatable, B : Swift.Equatable, C : Swift.Equatable, D : Swift.Equatable {
  guard lhs.0 == rhs.0 else { return false }
  /*tail*/ return (
    lhs.1, lhs.2, lhs.3
  ) == (
    rhs.1, rhs.2, rhs.3
  )
}
@inlinable public func != <A, B, C, D>(lhs: (A, B, C, D), rhs: (A, B, C, D)) -> Swift.Bool where A : Swift.Equatable, B : Swift.Equatable, C : Swift.Equatable, D : Swift.Equatable {
  guard lhs.0 == rhs.0 else { return true }
  /*tail*/ return (
    lhs.1, lhs.2, lhs.3
  ) != (
    rhs.1, rhs.2, rhs.3
  )
}
@inlinable public func < <A, B, C, D>(lhs: (A, B, C, D), rhs: (A, B, C, D)) -> Swift.Bool where A : Swift.Comparable, B : Swift.Comparable, C : Swift.Comparable, D : Swift.Comparable {
  if lhs.0 != rhs.0 { return lhs.0 < rhs.0 }
  /*tail*/ return (
    lhs.1, lhs.2, lhs.3
  ) < (
    rhs.1, rhs.2, rhs.3
  )
}
@inlinable public func <= <A, B, C, D>(lhs: (A, B, C, D), rhs: (A, B, C, D)) -> Swift.Bool where A : Swift.Comparable, B : Swift.Comparable, C : Swift.Comparable, D : Swift.Comparable {
  if lhs.0 != rhs.0 { return lhs.0 <= rhs.0 }
  /*tail*/ return (
    lhs.1, lhs.2, lhs.3
  ) <= (
    rhs.1, rhs.2, rhs.3
  )
}
@inlinable public func > <A, B, C, D>(lhs: (A, B, C, D), rhs: (A, B, C, D)) -> Swift.Bool where A : Swift.Comparable, B : Swift.Comparable, C : Swift.Comparable, D : Swift.Comparable {
  if lhs.0 != rhs.0 { return lhs.0 > rhs.0 }
  /*tail*/ return (
    lhs.1, lhs.2, lhs.3
  ) > (
    rhs.1, rhs.2, rhs.3
  )
}
@inlinable public func >= <A, B, C, D>(lhs: (A, B, C, D), rhs: (A, B, C, D)) -> Swift.Bool where A : Swift.Comparable, B : Swift.Comparable, C : Swift.Comparable, D : Swift.Comparable {
  if lhs.0 != rhs.0 { return lhs.0 >= rhs.0 }
  /*tail*/ return (
    lhs.1, lhs.2, lhs.3
  ) >= (
    rhs.1, rhs.2, rhs.3
  )
}
@inlinable public func == <A, B, C, D, E>(lhs: (A, B, C, D, E), rhs: (A, B, C, D, E)) -> Swift.Bool where A : Swift.Equatable, B : Swift.Equatable, C : Swift.Equatable, D : Swift.Equatable, E : Swift.Equatable {
  guard lhs.0 == rhs.0 else { return false }
  /*tail*/ return (
    lhs.1, lhs.2, lhs.3, lhs.4
  ) == (
    rhs.1, rhs.2, rhs.3, rhs.4
  )
}
@inlinable public func != <A, B, C, D, E>(lhs: (A, B, C, D, E), rhs: (A, B, C, D, E)) -> Swift.Bool where A : Swift.Equatable, B : Swift.Equatable, C : Swift.Equatable, D : Swift.Equatable, E : Swift.Equatable {
  guard lhs.0 == rhs.0 else { return true }
  /*tail*/ return (
    lhs.1, lhs.2, lhs.3, lhs.4
  ) != (
    rhs.1, rhs.2, rhs.3, rhs.4
  )
}
@inlinable public func < <A, B, C, D, E>(lhs: (A, B, C, D, E), rhs: (A, B, C, D, E)) -> Swift.Bool where A : Swift.Comparable, B : Swift.Comparable, C : Swift.Comparable, D : Swift.Comparable, E : Swift.Comparable {
  if lhs.0 != rhs.0 { return lhs.0 < rhs.0 }
  /*tail*/ return (
    lhs.1, lhs.2, lhs.3, lhs.4
  ) < (
    rhs.1, rhs.2, rhs.3, rhs.4
  )
}
@inlinable public func <= <A, B, C, D, E>(lhs: (A, B, C, D, E), rhs: (A, B, C, D, E)) -> Swift.Bool where A : Swift.Comparable, B : Swift.Comparable, C : Swift.Comparable, D : Swift.Comparable, E : Swift.Comparable {
  if lhs.0 != rhs.0 { return lhs.0 <= rhs.0 }
  /*tail*/ return (
    lhs.1, lhs.2, lhs.3, lhs.4
  ) <= (
    rhs.1, rhs.2, rhs.3, rhs.4
  )
}
@inlinable public func > <A, B, C, D, E>(lhs: (A, B, C, D, E), rhs: (A, B, C, D, E)) -> Swift.Bool where A : Swift.Comparable, B : Swift.Comparable, C : Swift.Comparable, D : Swift.Comparable, E : Swift.Comparable {
  if lhs.0 != rhs.0 { return lhs.0 > rhs.0 }
  /*tail*/ return (
    lhs.1, lhs.2, lhs.3, lhs.4
  ) > (
    rhs.1, rhs.2, rhs.3, rhs.4
  )
}
@inlinable public func >= <A, B, C, D, E>(lhs: (A, B, C, D, E), rhs: (A, B, C, D, E)) -> Swift.Bool where A : Swift.Comparable, B : Swift.Comparable, C : Swift.Comparable, D : Swift.Comparable, E : Swift.Comparable {
  if lhs.0 != rhs.0 { return lhs.0 >= rhs.0 }
  /*tail*/ return (
    lhs.1, lhs.2, lhs.3, lhs.4
  ) >= (
    rhs.1, rhs.2, rhs.3, rhs.4
  )
}
@inlinable public func == <A, B, C, D, E, F>(lhs: (A, B, C, D, E, F), rhs: (A, B, C, D, E, F)) -> Swift.Bool where A : Swift.Equatable, B : Swift.Equatable, C : Swift.Equatable, D : Swift.Equatable, E : Swift.Equatable, F : Swift.Equatable {
  guard lhs.0 == rhs.0 else { return false }
  /*tail*/ return (
    lhs.1, lhs.2, lhs.3, lhs.4, lhs.5
  ) == (
    rhs.1, rhs.2, rhs.3, rhs.4, rhs.5
  )
}
@inlinable public func != <A, B, C, D, E, F>(lhs: (A, B, C, D, E, F), rhs: (A, B, C, D, E, F)) -> Swift.Bool where A : Swift.Equatable, B : Swift.Equatable, C : Swift.Equatable, D : Swift.Equatable, E : Swift.Equatable, F : Swift.Equatable {
  guard lhs.0 == rhs.0 else { return true }
  /*tail*/ return (
    lhs.1, lhs.2, lhs.3, lhs.4, lhs.5
  ) != (
    rhs.1, rhs.2, rhs.3, rhs.4, rhs.5
  )
}
@inlinable public func < <A, B, C, D, E, F>(lhs: (A, B, C, D, E, F), rhs: (A, B, C, D, E, F)) -> Swift.Bool where A : Swift.Comparable, B : Swift.Comparable, C : Swift.Comparable, D : Swift.Comparable, E : Swift.Comparable, F : Swift.Comparable {
  if lhs.0 != rhs.0 { return lhs.0 < rhs.0 }
  /*tail*/ return (
    lhs.1, lhs.2, lhs.3, lhs.4, lhs.5
  ) < (
    rhs.1, rhs.2, rhs.3, rhs.4, rhs.5
  )
}
@inlinable public func <= <A, B, C, D, E, F>(lhs: (A, B, C, D, E, F), rhs: (A, B, C, D, E, F)) -> Swift.Bool where A : Swift.Comparable, B : Swift.Comparable, C : Swift.Comparable, D : Swift.Comparable, E : Swift.Comparable, F : Swift.Comparable {
  if lhs.0 != rhs.0 { return lhs.0 <= rhs.0 }
  /*tail*/ return (
    lhs.1, lhs.2, lhs.3, lhs.4, lhs.5
  ) <= (
    rhs.1, rhs.2, rhs.3, rhs.4, rhs.5
  )
}
@inlinable public func > <A, B, C, D, E, F>(lhs: (A, B, C, D, E, F), rhs: (A, B, C, D, E, F)) -> Swift.Bool where A : Swift.Comparable, B : Swift.Comparable, C : Swift.Comparable, D : Swift.Comparable, E : Swift.Comparable, F : Swift.Comparable {
  if lhs.0 != rhs.0 { return lhs.0 > rhs.0 }
  /*tail*/ return (
    lhs.1, lhs.2, lhs.3, lhs.4, lhs.5
  ) > (
    rhs.1, rhs.2, rhs.3, rhs.4, rhs.5
  )
}
@inlinable public func >= <A, B, C, D, E, F>(lhs: (A, B, C, D, E, F), rhs: (A, B, C, D, E, F)) -> Swift.Bool where A : Swift.Comparable, B : Swift.Comparable, C : Swift.Comparable, D : Swift.Comparable, E : Swift.Comparable, F : Swift.Comparable {
  if lhs.0 != rhs.0 { return lhs.0 >= rhs.0 }
  /*tail*/ return (
    lhs.1, lhs.2, lhs.3, lhs.4, lhs.5
  ) >= (
    rhs.1, rhs.2, rhs.3, rhs.4, rhs.5
  )
}
extension Swift._MergeError : Swift.Equatable {}
extension Swift._MergeError : Swift.Hashable {}
extension Swift.FloatingPointSign : Swift.Equatable {}
extension Swift.FloatingPointSign : Swift.Hashable {}
extension Swift.FloatingPointSign : Swift.RawRepresentable {}
extension Swift.FloatingPointClassification : Swift.Equatable {}
extension Swift.FloatingPointClassification : Swift.Hashable {}
extension Swift.FloatingPointRoundingRule : Swift.Equatable {}
extension Swift.FloatingPointRoundingRule : Swift.Hashable {}
extension Swift.JoinedSequence.Iterator._JoinIteratorState : Swift.Equatable {}
extension Swift.JoinedSequence.Iterator._JoinIteratorState : Swift.Hashable {}
extension Swift._StringComparisonResult : Swift.Equatable {}
extension Swift._StringComparisonResult : Swift.Hashable {}
extension Swift.Unicode.GeneralCategory : Swift.Equatable {}
extension Swift.Unicode.GeneralCategory : Swift.Hashable {}
extension Swift.Unicode.NumericType : Swift.Equatable {}
extension Swift.Unicode.NumericType : Swift.Hashable {}
extension Swift.Unicode.UTF32 : Swift.Equatable {}
extension Swift.Unicode.UTF32 : Swift.Hashable {}
extension Swift.Mirror.DisplayStyle : Swift.Equatable {}
extension Swift.Mirror.DisplayStyle : Swift.Hashable {}
