// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 5.4 (swiftlang-1205.0.24.14 clang-1205.0.19.54)
// swift-module-flags: -target x86_64-apple-ios14.5-macabi -enable-objc-interop -autolink-force-load -enable-library-evolution -module-link-name swiftDispatch -swift-version 5 -enforce-exclusivity=checked -O -module-name Dispatch
import Combine
@_exported import Dispatch
import Swift
public struct DispatchData : Swift.RandomAccessCollection, Swift._ObjectiveCBridgeable {
  public typealias Iterator = Dispatch.DispatchDataIterator
  public typealias Index = Swift.Int
  public typealias Indices = Swift.DefaultIndices<Dispatch.DispatchData>
  public static let empty: Dispatch.DispatchData
  public enum Deallocator {
    case free
    case unmap
    case custom(Dispatch.DispatchQueue?, @convention(block) () -> Swift.Void)
  }
  @available(swift, deprecated: 4, message: "Use init(bytes: UnsafeRawBufferPointer) instead")
  public init(bytes buffer: Swift.UnsafeBufferPointer<Swift.UInt8>)
  public init(bytes buffer: Swift.UnsafeRawBufferPointer)
  @available(swift, deprecated: 4, message: "Use init(bytesNoCopy: UnsafeRawBufferPointer, deallocater: Deallocator) instead")
  public init(bytesNoCopy bytes: Swift.UnsafeBufferPointer<Swift.UInt8>, deallocator: Dispatch.DispatchData.Deallocator = .free)
  public init(bytesNoCopy bytes: Swift.UnsafeRawBufferPointer, deallocator: Dispatch.DispatchData.Deallocator = .free)
  public var count: Swift.Int {
    get
  }
  public func withUnsafeBytes<Result, ContentType>(body: (Swift.UnsafePointer<ContentType>) throws -> Result) rethrows -> Result
  @available(swift 4.2)
  public func enumerateBytes(_ block: (Swift.UnsafeBufferPointer<Swift.UInt8>, Swift.Int, inout Swift.Bool) -> Swift.Void)
  @available(swift, obsoleted: 4.2, renamed: "enumerateBytes(_:)")
  public func enumerateBytes(block: (Swift.UnsafeBufferPointer<Swift.UInt8>, Swift.Int, inout Swift.Bool) -> Swift.Void)
  @available(swift, deprecated: 4, message: "Use append(_: UnsafeRawBufferPointer) instead")
  public mutating func append(_ bytes: Swift.UnsafePointer<Swift.UInt8>, count: Swift.Int)
  public mutating func append(_ bytes: Swift.UnsafeRawBufferPointer)
  public mutating func append(_ other: Dispatch.DispatchData)
  public mutating func append<SourceType>(_ buffer: Swift.UnsafeBufferPointer<SourceType>)
  @available(swift, deprecated: 4, message: "Use copyBytes(to: UnsafeMutableRawBufferPointer, count: Int) instead")
  public func copyBytes(to pointer: Swift.UnsafeMutablePointer<Swift.UInt8>, count: Swift.Int)
  public func copyBytes(to pointer: Swift.UnsafeMutableRawBufferPointer, count: Swift.Int)
  @available(swift, deprecated: 4, message: "Use copyBytes(to: UnsafeMutableRawBufferPointer, from: Range<Index>) instead")
  public func copyBytes(to pointer: Swift.UnsafeMutablePointer<Swift.UInt8>, from range: Swift.Range<Dispatch.DispatchData.Index>)
  public func copyBytes(to pointer: Swift.UnsafeMutableRawBufferPointer, from range: Swift.Range<Dispatch.DispatchData.Index>)
  public func copyBytes<DestinationType>(to buffer: Swift.UnsafeMutableBufferPointer<DestinationType>, from range: Swift.Range<Dispatch.DispatchData.Index>? = nil) -> Swift.Int
  public subscript(index: Dispatch.DispatchData.Index) -> Swift.UInt8 {
    get
  }
  public subscript(bounds: Swift.Range<Swift.Int>) -> Swift.Slice<Dispatch.DispatchData> {
    get
  }
  public func subdata(in range: Swift.Range<Dispatch.DispatchData.Index>) -> Dispatch.DispatchData
  public func region(location: Swift.Int) -> (data: Dispatch.DispatchData, offset: Swift.Int)
  public var startIndex: Dispatch.DispatchData.Index {
    get
  }
  public var endIndex: Dispatch.DispatchData.Index {
    get
  }
  public func index(before i: Dispatch.DispatchData.Index) -> Dispatch.DispatchData.Index
  public func index(after i: Dispatch.DispatchData.Index) -> Dispatch.DispatchData.Index
  public func makeIterator() -> Dispatch.DispatchData.Iterator
  public typealias Element = Swift.UInt8
  public typealias SubSequence = Swift.Slice<Dispatch.DispatchData>
  public typealias _ObjectiveCType = Dispatch.__DispatchData
}
public struct DispatchDataIterator : Swift.IteratorProtocol, Swift.Sequence {
  public typealias Element = Swift.UInt8
  public init(_data: Dispatch.DispatchData)
  public mutating func next() -> Dispatch.DispatchData.Element?
  public typealias Iterator = Dispatch.DispatchDataIterator
}
extension DispatchData {
  @_semantics("convertToObjectiveC") public func _bridgeToObjectiveC() -> Dispatch.__DispatchData
  public static func _forceBridgeFromObjectiveC(_ input: Dispatch.__DispatchData, result: inout Dispatch.DispatchData?)
  public static func _conditionallyBridgeFromObjectiveC(_ input: Dispatch.__DispatchData, result: inout Dispatch.DispatchData?) -> Swift.Bool
  @_effects(readonly) public static func _unconditionallyBridgeFromObjectiveC(_ source: Dispatch.__DispatchData?) -> Dispatch.DispatchData
}
final public class DispatchSpecificKey<T> {
  public init()
  @objc deinit
}
extension DispatchQueue {
  public struct Attributes : Swift.OptionSet {
    public let rawValue: Swift.UInt64
    public init(rawValue: Swift.UInt64)
    public static let concurrent: Dispatch.DispatchQueue.Attributes
    @available(macOS 10.12, iOS 10.0, tvOS 10.0, watchOS 3.0, *)
    public static let initiallyInactive: Dispatch.DispatchQueue.Attributes
    public typealias ArrayLiteralElement = Dispatch.DispatchQueue.Attributes
    public typealias Element = Dispatch.DispatchQueue.Attributes
    public typealias RawValue = Swift.UInt64
  }
  public enum GlobalQueuePriority {
    @available(macOS, deprecated: 10.10, message: "Use qos attributes instead")
    @available(iOS, deprecated: 8.0, message: "Use qos attributes instead")
    @available(tvOS, deprecated, message: "Use qos attributes instead")
    @available(watchOS, deprecated, message: "Use qos attributes instead")
    case high
    @available(macOS, deprecated: 10.10, message: "Use qos attributes instead")
    @available(iOS, deprecated: 8.0, message: "Use qos attributes instead")
    @available(tvOS, deprecated, message: "Use qos attributes instead")
    @available(watchOS, deprecated, message: "Use qos attributes instead")
    case `default`
    @available(macOS, deprecated: 10.10, message: "Use qos attributes instead")
    @available(iOS, deprecated: 8.0, message: "Use qos attributes instead")
    @available(tvOS, deprecated, message: "Use qos attributes instead")
    @available(watchOS, deprecated, message: "Use qos attributes instead")
    case low
    @available(macOS, deprecated: 10.10, message: "Use qos attributes instead")
    @available(iOS, deprecated: 8.0, message: "Use qos attributes instead")
    @available(tvOS, deprecated, message: "Use qos attributes instead")
    @available(watchOS, deprecated, message: "Use qos attributes instead")
    case background
    public static func == (a: Dispatch.DispatchQueue.GlobalQueuePriority, b: Dispatch.DispatchQueue.GlobalQueuePriority) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public enum AutoreleaseFrequency {
    case inherit
    @available(macOS 10.12, iOS 10.0, tvOS 10.0, watchOS 3.0, *)
    case workItem
    @available(macOS 10.12, iOS 10.0, tvOS 10.0, watchOS 3.0, *)
    case never
    public static func == (a: Dispatch.DispatchQueue.AutoreleaseFrequency, b: Dispatch.DispatchQueue.AutoreleaseFrequency) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public class func concurrentPerform(iterations: Swift.Int, execute work: (Swift.Int) -> Swift.Void)
  public class var main: Dispatch.DispatchQueue {
    get
  }
  @available(macOS, deprecated: 10.10)
  @available(iOS, deprecated: 8.0)
  @available(tvOS, deprecated)
  @available(watchOS, deprecated)
  public class func global(priority: Dispatch.DispatchQueue.GlobalQueuePriority) -> Dispatch.DispatchQueue
  @available(macOS 10.10, iOS 8.0, *)
  public class func global(qos: Dispatch.DispatchQoS.QoSClass = .default) -> Dispatch.DispatchQueue
  public class func getSpecific<T>(key: Dispatch.DispatchSpecificKey<T>) -> T?
  convenience public init(label: Swift.String, qos: Dispatch.DispatchQoS = .unspecified, attributes: Dispatch.DispatchQueue.Attributes = [], autoreleaseFrequency: Dispatch.DispatchQueue.AutoreleaseFrequency = .inherit, target: Dispatch.DispatchQueue? = nil)
  public var label: Swift.String {
    get
  }
  @available(macOS 10.10, iOS 8.0, *)
  public func sync(execute workItem: Dispatch.DispatchWorkItem)
  @available(macOS 10.10, iOS 8.0, *)
  public func async(execute workItem: Dispatch.DispatchWorkItem)
  @available(macOS 10.14, iOS 12.0, *)
  public func asyncAndWait(execute workItem: Dispatch.DispatchWorkItem)
  @available(macOS 10.10, iOS 8.0, *)
  public func async(group: Dispatch.DispatchGroup, execute workItem: Dispatch.DispatchWorkItem)
  public func async(group: Dispatch.DispatchGroup? = nil, qos: Dispatch.DispatchQoS = .unspecified, flags: Dispatch.DispatchWorkItemFlags = [], execute work: @escaping @convention(block) () -> Swift.Void)
  public func sync<T>(execute work: () throws -> T) rethrows -> T
  public func sync<T>(flags: Dispatch.DispatchWorkItemFlags, execute work: () throws -> T) rethrows -> T
  public func asyncAfter(deadline: Dispatch.DispatchTime, qos: Dispatch.DispatchQoS = .unspecified, flags: Dispatch.DispatchWorkItemFlags = [], execute work: @escaping @convention(block) () -> Swift.Void)
  public func asyncAfter(wallDeadline: Dispatch.DispatchWallTime, qos: Dispatch.DispatchQoS = .unspecified, flags: Dispatch.DispatchWorkItemFlags = [], execute work: @escaping @convention(block) () -> Swift.Void)
  @available(macOS 10.10, iOS 8.0, *)
  public func asyncAfter(deadline: Dispatch.DispatchTime, execute: Dispatch.DispatchWorkItem)
  @available(macOS 10.10, iOS 8.0, *)
  public func asyncAfter(wallDeadline: Dispatch.DispatchWallTime, execute: Dispatch.DispatchWorkItem)
  @available(macOS 10.10, iOS 8.0, *)
  public var qos: Dispatch.DispatchQoS {
    get
  }
  public func getSpecific<T>(key: Dispatch.DispatchSpecificKey<T>) -> T?
  public func setSpecific<T>(key: Dispatch.DispatchSpecificKey<T>, value: T?)
}
extension DispatchSourceProtocol {
  public typealias DispatchSourceHandler = @convention(block) () -> Swift.Void
  public func setEventHandler(qos: Dispatch.DispatchQoS = .unspecified, flags: Dispatch.DispatchWorkItemFlags = [], handler: Self.DispatchSourceHandler?)
  @available(macOS 10.10, iOS 8.0, *)
  public func setEventHandler(handler: Dispatch.DispatchWorkItem)
  public func setCancelHandler(qos: Dispatch.DispatchQoS = .unspecified, flags: Dispatch.DispatchWorkItemFlags = [], handler: Self.DispatchSourceHandler?)
  @available(macOS 10.10, iOS 8.0, *)
  public func setCancelHandler(handler: Dispatch.DispatchWorkItem)
  public func setRegistrationHandler(qos: Dispatch.DispatchQoS = .unspecified, flags: Dispatch.DispatchWorkItemFlags = [], handler: Self.DispatchSourceHandler?)
  @available(macOS 10.10, iOS 8.0, *)
  public func setRegistrationHandler(handler: Dispatch.DispatchWorkItem)
  @available(macOS 10.12, iOS 10.0, tvOS 10.0, watchOS 3.0, *)
  public func activate()
  public func cancel()
  public func resume()
  public func suspend()
  public var handle: Swift.UInt {
    get
  }
  public var mask: Swift.UInt {
    get
  }
  public var data: Swift.UInt {
    get
  }
  public var isCancelled: Swift.Bool {
    get
  }
}
extension DispatchSource {
  public struct MachSendEvent : Swift.OptionSet, Swift.RawRepresentable {
    public let rawValue: Swift.UInt
    public init(rawValue: Swift.UInt)
    public static let dead: Dispatch.DispatchSource.MachSendEvent
    public typealias ArrayLiteralElement = Dispatch.DispatchSource.MachSendEvent
    public typealias Element = Dispatch.DispatchSource.MachSendEvent
    public typealias RawValue = Swift.UInt
  }
  public struct MemoryPressureEvent : Swift.OptionSet, Swift.RawRepresentable {
    public let rawValue: Swift.UInt
    public init(rawValue: Swift.UInt)
    public static let normal: Dispatch.DispatchSource.MemoryPressureEvent
    public static let warning: Dispatch.DispatchSource.MemoryPressureEvent
    public static let critical: Dispatch.DispatchSource.MemoryPressureEvent
    public static let all: Dispatch.DispatchSource.MemoryPressureEvent
    public typealias ArrayLiteralElement = Dispatch.DispatchSource.MemoryPressureEvent
    public typealias Element = Dispatch.DispatchSource.MemoryPressureEvent
    public typealias RawValue = Swift.UInt
  }
  public struct ProcessEvent : Swift.OptionSet, Swift.RawRepresentable {
    public let rawValue: Swift.UInt
    public init(rawValue: Swift.UInt)
    public static let exit: Dispatch.DispatchSource.ProcessEvent
    public static let fork: Dispatch.DispatchSource.ProcessEvent
    public static let exec: Dispatch.DispatchSource.ProcessEvent
    public static let signal: Dispatch.DispatchSource.ProcessEvent
    public static let all: Dispatch.DispatchSource.ProcessEvent
    public typealias ArrayLiteralElement = Dispatch.DispatchSource.ProcessEvent
    public typealias Element = Dispatch.DispatchSource.ProcessEvent
    public typealias RawValue = Swift.UInt
  }
  public struct TimerFlags : Swift.OptionSet, Swift.RawRepresentable {
    public let rawValue: Swift.UInt
    public init(rawValue: Swift.UInt)
    public static let strict: Dispatch.DispatchSource.TimerFlags
    public typealias ArrayLiteralElement = Dispatch.DispatchSource.TimerFlags
    public typealias Element = Dispatch.DispatchSource.TimerFlags
    public typealias RawValue = Swift.UInt
  }
  public struct FileSystemEvent : Swift.OptionSet, Swift.RawRepresentable {
    public let rawValue: Swift.UInt
    public init(rawValue: Swift.UInt)
    public static let delete: Dispatch.DispatchSource.FileSystemEvent
    public static let write: Dispatch.DispatchSource.FileSystemEvent
    public static let extend: Dispatch.DispatchSource.FileSystemEvent
    public static let attrib: Dispatch.DispatchSource.FileSystemEvent
    public static let link: Dispatch.DispatchSource.FileSystemEvent
    public static let rename: Dispatch.DispatchSource.FileSystemEvent
    public static let revoke: Dispatch.DispatchSource.FileSystemEvent
    public static let funlock: Dispatch.DispatchSource.FileSystemEvent
    public static let all: Dispatch.DispatchSource.FileSystemEvent
    public typealias ArrayLiteralElement = Dispatch.DispatchSource.FileSystemEvent
    public typealias Element = Dispatch.DispatchSource.FileSystemEvent
    public typealias RawValue = Swift.UInt
  }
  public class func makeMachSendSource(port: Darwin.mach_port_t, eventMask: Dispatch.DispatchSource.MachSendEvent, queue: Dispatch.DispatchQueue? = nil) -> Dispatch.DispatchSourceMachSend
  public class func makeMachReceiveSource(port: Darwin.mach_port_t, queue: Dispatch.DispatchQueue? = nil) -> Dispatch.DispatchSourceMachReceive
  public class func makeMemoryPressureSource(eventMask: Dispatch.DispatchSource.MemoryPressureEvent, queue: Dispatch.DispatchQueue? = nil) -> Dispatch.DispatchSourceMemoryPressure
  public class func makeProcessSource(identifier: Darwin.pid_t, eventMask: Dispatch.DispatchSource.ProcessEvent, queue: Dispatch.DispatchQueue? = nil) -> Dispatch.DispatchSourceProcess
  public class func makeReadSource(fileDescriptor: Swift.Int32, queue: Dispatch.DispatchQueue? = nil) -> Dispatch.DispatchSourceRead
  public class func makeSignalSource(signal: Swift.Int32, queue: Dispatch.DispatchQueue? = nil) -> Dispatch.DispatchSourceSignal
  public class func makeTimerSource(flags: Dispatch.DispatchSource.TimerFlags = [], queue: Dispatch.DispatchQueue? = nil) -> Dispatch.DispatchSourceTimer
  public class func makeUserDataAddSource(queue: Dispatch.DispatchQueue? = nil) -> Dispatch.DispatchSourceUserDataAdd
  public class func makeUserDataOrSource(queue: Dispatch.DispatchQueue? = nil) -> Dispatch.DispatchSourceUserDataOr
  public class func makeUserDataReplaceSource(queue: Dispatch.DispatchQueue? = nil) -> Dispatch.DispatchSourceUserDataReplace
  public class func makeFileSystemObjectSource(fileDescriptor: Swift.Int32, eventMask: Dispatch.DispatchSource.FileSystemEvent, queue: Dispatch.DispatchQueue? = nil) -> Dispatch.DispatchSourceFileSystemObject
  public class func makeWriteSource(fileDescriptor: Swift.Int32, queue: Dispatch.DispatchQueue? = nil) -> Dispatch.DispatchSourceWrite
}
extension DispatchSourceMachSend {
  public var handle: Darwin.mach_port_t {
    get
  }
  public var data: Dispatch.DispatchSource.MachSendEvent {
    get
  }
  public var mask: Dispatch.DispatchSource.MachSendEvent {
    get
  }
}
extension DispatchSourceMachReceive {
  public var handle: Darwin.mach_port_t {
    get
  }
}
extension DispatchSourceMemoryPressure {
  public var data: Dispatch.DispatchSource.MemoryPressureEvent {
    get
  }
  public var mask: Dispatch.DispatchSource.MemoryPressureEvent {
    get
  }
}
extension DispatchSourceProcess {
  public var handle: Darwin.pid_t {
    get
  }
  public var data: Dispatch.DispatchSource.ProcessEvent {
    get
  }
  public var mask: Dispatch.DispatchSource.ProcessEvent {
    get
  }
}
extension DispatchSourceTimer {
  @available(swift, deprecated: 4, renamed: "schedule(deadline:repeating:leeway:)")
  public func scheduleOneshot(deadline: Dispatch.DispatchTime, leeway: Dispatch.DispatchTimeInterval = .nanoseconds(0))
  @available(swift, deprecated: 4, renamed: "schedule(wallDeadline:repeating:leeway:)")
  public func scheduleOneshot(wallDeadline: Dispatch.DispatchWallTime, leeway: Dispatch.DispatchTimeInterval = .nanoseconds(0))
  @available(swift, deprecated: 4, renamed: "schedule(deadline:repeating:leeway:)")
  public func scheduleRepeating(deadline: Dispatch.DispatchTime, interval: Dispatch.DispatchTimeInterval, leeway: Dispatch.DispatchTimeInterval = .nanoseconds(0))
  @available(swift, deprecated: 4, renamed: "schedule(deadline:repeating:leeway:)")
  public func scheduleRepeating(deadline: Dispatch.DispatchTime, interval: Swift.Double, leeway: Dispatch.DispatchTimeInterval = .nanoseconds(0))
  @available(swift, deprecated: 4, renamed: "schedule(wallDeadline:repeating:leeway:)")
  public func scheduleRepeating(wallDeadline: Dispatch.DispatchWallTime, interval: Dispatch.DispatchTimeInterval, leeway: Dispatch.DispatchTimeInterval = .nanoseconds(0))
  @available(swift, deprecated: 4, renamed: "schedule(wallDeadline:repeating:leeway:)")
  public func scheduleRepeating(wallDeadline: Dispatch.DispatchWallTime, interval: Swift.Double, leeway: Dispatch.DispatchTimeInterval = .nanoseconds(0))
  @available(swift 4)
  public func schedule(deadline: Dispatch.DispatchTime, repeating interval: Dispatch.DispatchTimeInterval = .never, leeway: Dispatch.DispatchTimeInterval = .nanoseconds(0))
  @available(swift 4)
  public func schedule(deadline: Dispatch.DispatchTime, repeating interval: Swift.Double, leeway: Dispatch.DispatchTimeInterval = .nanoseconds(0))
  @available(swift 4)
  public func schedule(wallDeadline: Dispatch.DispatchWallTime, repeating interval: Dispatch.DispatchTimeInterval = .never, leeway: Dispatch.DispatchTimeInterval = .nanoseconds(0))
  @available(swift 4)
  public func schedule(wallDeadline: Dispatch.DispatchWallTime, repeating interval: Swift.Double, leeway: Dispatch.DispatchTimeInterval = .nanoseconds(0))
}
extension DispatchSourceFileSystemObject {
  public var handle: Swift.Int32 {
    get
  }
  public var data: Dispatch.DispatchSource.FileSystemEvent {
    get
  }
  public var mask: Dispatch.DispatchSource.FileSystemEvent {
    get
  }
}
extension DispatchSourceUserDataAdd {
  public func add(data: Swift.UInt)
}
extension DispatchSourceUserDataOr {
  public func or(data: Swift.UInt)
}
extension DispatchSourceUserDataReplace {
  public func replace(data: Swift.UInt)
}
public struct DispatchTime : Swift.Comparable {
  public let rawValue: Dispatch.dispatch_time_t
  public static func now() -> Dispatch.DispatchTime
  public static let distantFuture: Dispatch.DispatchTime
  public init(uptimeNanoseconds: Swift.UInt64)
  public var uptimeNanoseconds: Swift.UInt64 {
    get
  }
}
extension DispatchTime {
  public static func < (a: Dispatch.DispatchTime, b: Dispatch.DispatchTime) -> Swift.Bool
  public static func == (a: Dispatch.DispatchTime, b: Dispatch.DispatchTime) -> Swift.Bool
}
public struct DispatchWallTime : Swift.Comparable {
  public let rawValue: Dispatch.dispatch_time_t
  public static func now() -> Dispatch.DispatchWallTime
  public static let distantFuture: Dispatch.DispatchWallTime
  public init(timespec: Darwin.timespec)
}
extension DispatchWallTime {
  public static func < (a: Dispatch.DispatchWallTime, b: Dispatch.DispatchWallTime) -> Swift.Bool
  public static func == (a: Dispatch.DispatchWallTime, b: Dispatch.DispatchWallTime) -> Swift.Bool
}
public enum DispatchTimeInterval : Swift.Equatable {
  case seconds(Swift.Int)
  case milliseconds(Swift.Int)
  case microseconds(Swift.Int)
  case nanoseconds(Swift.Int)
  case never
  public static func == (lhs: Dispatch.DispatchTimeInterval, rhs: Dispatch.DispatchTimeInterval) -> Swift.Bool
}
public func + (time: Dispatch.DispatchTime, interval: Dispatch.DispatchTimeInterval) -> Dispatch.DispatchTime
public func - (time: Dispatch.DispatchTime, interval: Dispatch.DispatchTimeInterval) -> Dispatch.DispatchTime
public func + (time: Dispatch.DispatchTime, seconds: Swift.Double) -> Dispatch.DispatchTime
public func - (time: Dispatch.DispatchTime, seconds: Swift.Double) -> Dispatch.DispatchTime
public func + (time: Dispatch.DispatchWallTime, interval: Dispatch.DispatchTimeInterval) -> Dispatch.DispatchWallTime
public func - (time: Dispatch.DispatchWallTime, interval: Dispatch.DispatchTimeInterval) -> Dispatch.DispatchWallTime
public func + (time: Dispatch.DispatchWallTime, seconds: Swift.Double) -> Dispatch.DispatchWallTime
public func - (time: Dispatch.DispatchWallTime, seconds: Swift.Double) -> Dispatch.DispatchWallTime
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension DispatchTime {
  public func distance(to other: Dispatch.DispatchTime) -> Dispatch.DispatchTimeInterval
  public func advanced(by n: Dispatch.DispatchTimeInterval) -> Dispatch.DispatchTime
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension DispatchQueue : Combine.Scheduler {
  public struct SchedulerTimeType : Swift.Strideable, Swift.Codable, Swift.Hashable {
    public var dispatchTime: Dispatch.DispatchTime
    public init(_ time: Dispatch.DispatchTime)
    public init(from decoder: Swift.Decoder) throws
    public func encode(to encoder: Swift.Encoder) throws
    public func distance(to other: Dispatch.DispatchQueue.SchedulerTimeType) -> Dispatch.DispatchQueue.SchedulerTimeType.Stride
    public func advanced(by n: Dispatch.DispatchQueue.SchedulerTimeType.Stride) -> Dispatch.DispatchQueue.SchedulerTimeType
    public func hash(into hasher: inout Swift.Hasher)
    @_alwaysEmitIntoClient public static func < (lhs: Dispatch.DispatchQueue.SchedulerTimeType, rhs: Dispatch.DispatchQueue.SchedulerTimeType) -> Swift.Bool {
            return lhs.dispatchTime < rhs.dispatchTime
        }
    public struct Stride : Combine.SchedulerTimeIntervalConvertible, Swift.Comparable, Swift.SignedNumeric, Swift.ExpressibleByFloatLiteral, Swift.Hashable, Swift.Codable {
      public typealias FloatLiteralType = Swift.Double
      public typealias IntegerLiteralType = Swift.Int
      public typealias Magnitude = Swift.Int
      public var magnitude: Swift.Int
      public var timeInterval: Dispatch.DispatchTimeInterval {
        get
      }
      public init(_ timeInterval: Dispatch.DispatchTimeInterval)
      public init(floatLiteral value: Swift.Double)
      public init(integerLiteral value: Swift.Int)
      public init?<T>(exactly source: T) where T : Swift.BinaryInteger
      public static func < (lhs: Dispatch.DispatchQueue.SchedulerTimeType.Stride, rhs: Dispatch.DispatchQueue.SchedulerTimeType.Stride) -> Swift.Bool
      public static func * (lhs: Dispatch.DispatchQueue.SchedulerTimeType.Stride, rhs: Dispatch.DispatchQueue.SchedulerTimeType.Stride) -> Dispatch.DispatchQueue.SchedulerTimeType.Stride
      public static func + (lhs: Dispatch.DispatchQueue.SchedulerTimeType.Stride, rhs: Dispatch.DispatchQueue.SchedulerTimeType.Stride) -> Dispatch.DispatchQueue.SchedulerTimeType.Stride
      public static func - (lhs: Dispatch.DispatchQueue.SchedulerTimeType.Stride, rhs: Dispatch.DispatchQueue.SchedulerTimeType.Stride) -> Dispatch.DispatchQueue.SchedulerTimeType.Stride
      public static func -= (lhs: inout Dispatch.DispatchQueue.SchedulerTimeType.Stride, rhs: Dispatch.DispatchQueue.SchedulerTimeType.Stride)
      public static func *= (lhs: inout Dispatch.DispatchQueue.SchedulerTimeType.Stride, rhs: Dispatch.DispatchQueue.SchedulerTimeType.Stride)
      public static func += (lhs: inout Dispatch.DispatchQueue.SchedulerTimeType.Stride, rhs: Dispatch.DispatchQueue.SchedulerTimeType.Stride)
      public static func seconds(_ s: Swift.Double) -> Dispatch.DispatchQueue.SchedulerTimeType.Stride
      public static func seconds(_ s: Swift.Int) -> Dispatch.DispatchQueue.SchedulerTimeType.Stride
      public static func milliseconds(_ ms: Swift.Int) -> Dispatch.DispatchQueue.SchedulerTimeType.Stride
      public static func microseconds(_ us: Swift.Int) -> Dispatch.DispatchQueue.SchedulerTimeType.Stride
      public static func nanoseconds(_ ns: Swift.Int) -> Dispatch.DispatchQueue.SchedulerTimeType.Stride
      public func hash(into hasher: inout Swift.Hasher)
      public static func == (a: Dispatch.DispatchQueue.SchedulerTimeType.Stride, b: Dispatch.DispatchQueue.SchedulerTimeType.Stride) -> Swift.Bool
      public func encode(to encoder: Swift.Encoder) throws
      public var hashValue: Swift.Int {
        get
      }
      public init(from decoder: Swift.Decoder) throws
    }
    public var hashValue: Swift.Int {
      get
    }
  }
  public struct SchedulerOptions {
    public var qos: Dispatch.DispatchQoS
    public var flags: Dispatch.DispatchWorkItemFlags
    public var group: Dispatch.DispatchGroup?
    public init(qos: Dispatch.DispatchQoS = .unspecified, flags: Dispatch.DispatchWorkItemFlags = [], group: Dispatch.DispatchGroup? = nil)
  }
  public var minimumTolerance: Dispatch.DispatchQueue.SchedulerTimeType.Stride {
    get
  }
  public var now: Dispatch.DispatchQueue.SchedulerTimeType {
    get
  }
  public func schedule(options: Dispatch.DispatchQueue.SchedulerOptions?, _ action: @escaping () -> Swift.Void)
  public func schedule(after date: Dispatch.DispatchQueue.SchedulerTimeType, tolerance: Dispatch.DispatchQueue.SchedulerTimeType.Stride, options: Dispatch.DispatchQueue.SchedulerOptions?, _ action: @escaping () -> Swift.Void)
  public func schedule(after date: Dispatch.DispatchQueue.SchedulerTimeType, interval: Dispatch.DispatchQueue.SchedulerTimeType.Stride, tolerance: Dispatch.DispatchQueue.SchedulerTimeType.Stride, options: Dispatch.DispatchQueue.SchedulerOptions?, _ action: @escaping () -> Swift.Void) -> Combine.Cancellable
}
public struct DispatchWorkItemFlags : Swift.OptionSet, Swift.RawRepresentable {
  public let rawValue: Swift.UInt
  public init(rawValue: Swift.UInt)
  public static let barrier: Dispatch.DispatchWorkItemFlags
  @available(macOS 10.10, iOS 8.0, *)
  public static let detached: Dispatch.DispatchWorkItemFlags
  @available(macOS 10.10, iOS 8.0, *)
  public static let assignCurrentContext: Dispatch.DispatchWorkItemFlags
  @available(macOS 10.10, iOS 8.0, *)
  public static let noQoS: Dispatch.DispatchWorkItemFlags
  @available(macOS 10.10, iOS 8.0, *)
  public static let inheritQoS: Dispatch.DispatchWorkItemFlags
  @available(macOS 10.10, iOS 8.0, *)
  public static let enforceQoS: Dispatch.DispatchWorkItemFlags
  public typealias ArrayLiteralElement = Dispatch.DispatchWorkItemFlags
  public typealias Element = Dispatch.DispatchWorkItemFlags
  public typealias RawValue = Swift.UInt
}
@_hasMissingDesignatedInitializers @available(macOS 10.10, iOS 8.0, *)
@_objcRuntimeName(_TtC8Dispatch17_DispatchWorkItem) public class DispatchWorkItem {
  public init(qos: Dispatch.DispatchQoS = .unspecified, flags: Dispatch.DispatchWorkItemFlags = [], block: @escaping @convention(block) () -> Swift.Void)
  @available(macOS 11.3, iOS 14.5, watchOS 7.4, tvOS 14.5, *)
  public init(flags: Dispatch.DispatchWorkItemFlags = [], block: @escaping @convention(block) () -> Swift.Void)
  public func perform()
  public func wait()
  public func wait(timeout: Dispatch.DispatchTime) -> Dispatch.DispatchTimeoutResult
  public func wait(wallTimeout: Dispatch.DispatchWallTime) -> Dispatch.DispatchTimeoutResult
  public func notify(qos: Dispatch.DispatchQoS = .unspecified, flags: Dispatch.DispatchWorkItemFlags = [], queue: Dispatch.DispatchQueue, execute: @escaping @convention(block) () -> Swift.Void)
  public func notify(queue: Dispatch.DispatchQueue, execute: Dispatch.DispatchWorkItem)
  public func cancel()
  public var isCancelled: Swift.Bool {
    get
  }
  @objc deinit
}
extension DispatchIO {
  public enum StreamType : Swift.UInt {
    case stream
    case random
    public init?(rawValue: Swift.UInt)
    public typealias RawValue = Swift.UInt
    public var rawValue: Swift.UInt {
      get
    }
  }
  public struct CloseFlags : Swift.OptionSet, Swift.RawRepresentable {
    public let rawValue: Swift.UInt
    public init(rawValue: Swift.UInt)
    public static let stop: Dispatch.DispatchIO.CloseFlags
    public typealias ArrayLiteralElement = Dispatch.DispatchIO.CloseFlags
    public typealias Element = Dispatch.DispatchIO.CloseFlags
    public typealias RawValue = Swift.UInt
  }
  public struct IntervalFlags : Swift.OptionSet, Swift.RawRepresentable {
    public let rawValue: Swift.UInt
    public init(rawValue: Swift.UInt)
    public init(nilLiteral: ())
    public static let strictInterval: Dispatch.DispatchIO.IntervalFlags
    public typealias ArrayLiteralElement = Dispatch.DispatchIO.IntervalFlags
    public typealias Element = Dispatch.DispatchIO.IntervalFlags
    public typealias RawValue = Swift.UInt
  }
  public class func read(fromFileDescriptor: Swift.Int32, maxLength: Swift.Int, runningHandlerOn queue: Dispatch.DispatchQueue, handler: @escaping (Dispatch.DispatchData, Swift.Int32) -> Swift.Void)
  public class func write(toFileDescriptor: Swift.Int32, data: Dispatch.DispatchData, runningHandlerOn queue: Dispatch.DispatchQueue, handler: @escaping (Dispatch.DispatchData?, Swift.Int32) -> Swift.Void)
  convenience public init(type: Dispatch.DispatchIO.StreamType, fileDescriptor: Swift.Int32, queue: Dispatch.DispatchQueue, cleanupHandler: @escaping (Swift.Int32) -> Swift.Void)
  @available(swift, obsoleted: 4)
  convenience public init(type: Dispatch.DispatchIO.StreamType, path: Swift.UnsafePointer<Swift.Int8>, oflag: Swift.Int32, mode: Darwin.mode_t, queue: Dispatch.DispatchQueue, cleanupHandler: @escaping (Swift.Int32) -> Swift.Void)
  @available(swift 4)
  convenience public init?(type: Dispatch.DispatchIO.StreamType, path: Swift.UnsafePointer<Swift.Int8>, oflag: Swift.Int32, mode: Darwin.mode_t, queue: Dispatch.DispatchQueue, cleanupHandler: @escaping (Swift.Int32) -> Swift.Void)
  convenience public init(type: Dispatch.DispatchIO.StreamType, io: Dispatch.DispatchIO, queue: Dispatch.DispatchQueue, cleanupHandler: @escaping (Swift.Int32) -> Swift.Void)
  public func read(offset: Darwin.off_t, length: Swift.Int, queue: Dispatch.DispatchQueue, ioHandler: @escaping (Swift.Bool, Dispatch.DispatchData?, Swift.Int32) -> Swift.Void)
  public func write(offset: Darwin.off_t, data: Dispatch.DispatchData, queue: Dispatch.DispatchQueue, ioHandler: @escaping (Swift.Bool, Dispatch.DispatchData?, Swift.Int32) -> Swift.Void)
  public func setInterval(interval: Dispatch.DispatchTimeInterval, flags: Dispatch.DispatchIO.IntervalFlags = [])
  public func close(flags: Dispatch.DispatchIO.CloseFlags = [])
}
@available(macOS 10.12, iOS 10.0, tvOS 10.0, watchOS 3.0, *)
public enum DispatchPredicate {
  case onQueue(Dispatch.DispatchQueue)
  case onQueueAsBarrier(Dispatch.DispatchQueue)
  case notOnQueue(Dispatch.DispatchQueue)
}
@available(macOS 10.12, iOS 10.0, tvOS 10.0, watchOS 3.0, *)
public func _dispatchPreconditionTest(_ condition: Dispatch.DispatchPredicate) -> Swift.Bool
@available(macOS 10.12, iOS 10.0, tvOS 10.0, watchOS 3.0, *)
@_transparent public func dispatchPrecondition(condition: @autoclosure () -> Dispatch.DispatchPredicate) {
	// precondition is able to determine release-vs-debug asserts where the overlay
	// cannot, so formulating this into a call that we can call with precondition()
	precondition(_dispatchPreconditionTest(condition()), "dispatchPrecondition failure")
}
public struct DispatchQoS : Swift.Equatable {
  public let qosClass: Dispatch.DispatchQoS.QoSClass
  public let relativePriority: Swift.Int
  @available(macOS 10.10, iOS 8.0, *)
  public static let background: Dispatch.DispatchQoS
  @available(macOS 10.10, iOS 8.0, *)
  public static let utility: Dispatch.DispatchQoS
  @available(macOS 10.10, iOS 8.0, *)
  public static let `default`: Dispatch.DispatchQoS
  @available(macOS 10.10, iOS 8.0, *)
  public static let userInitiated: Dispatch.DispatchQoS
  @available(macOS 10.10, iOS 8.0, *)
  public static let userInteractive: Dispatch.DispatchQoS
  public static let unspecified: Dispatch.DispatchQoS
  public enum QoSClass {
    @available(macOS 10.10, iOS 8.0, *)
    case background
    @available(macOS 10.10, iOS 8.0, *)
    case utility
    @available(macOS 10.10, iOS 8.0, *)
    case `default`
    @available(macOS 10.10, iOS 8.0, *)
    case userInitiated
    @available(macOS 10.10, iOS 8.0, *)
    case userInteractive
    case unspecified
    @available(macOS 10.10, iOS 8.0, *)
    public init?(rawValue: Darwin.qos_class_t)
    @available(macOS 10.10, iOS 8.0, *)
    public var rawValue: Darwin.qos_class_t {
      get
    }
    public static func == (a: Dispatch.DispatchQoS.QoSClass, b: Dispatch.DispatchQoS.QoSClass) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public init(qosClass: Dispatch.DispatchQoS.QoSClass, relativePriority: Swift.Int)
  public static func == (a: Dispatch.DispatchQoS, b: Dispatch.DispatchQoS) -> Swift.Bool
}
@frozen public enum DispatchTimeoutResult {
  case success
  case timedOut
  public static func == (a: Dispatch.DispatchTimeoutResult, b: Dispatch.DispatchTimeoutResult) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension DispatchGroup {
  public func notify(qos: Dispatch.DispatchQoS = .unspecified, flags: Dispatch.DispatchWorkItemFlags = [], queue: Dispatch.DispatchQueue, execute work: @escaping @convention(block) () -> Swift.Void)
  @available(macOS 10.10, iOS 8.0, *)
  public func notify(queue: Dispatch.DispatchQueue, work: Dispatch.DispatchWorkItem)
  public func wait()
  public func wait(timeout: Dispatch.DispatchTime) -> Dispatch.DispatchTimeoutResult
  public func wait(wallTimeout timeout: Dispatch.DispatchWallTime) -> Dispatch.DispatchTimeoutResult
}
extension DispatchSemaphore {
  @discardableResult
  public func signal() -> Swift.Int
  public func wait()
  public func wait(timeout: Dispatch.DispatchTime) -> Dispatch.DispatchTimeoutResult
  public func wait(wallTimeout: Dispatch.DispatchWallTime) -> Dispatch.DispatchTimeoutResult
}
@available(*, unavailable, renamed: "DispatchQueue.init(label:qos:attributes:autoreleaseFrequency:target:)")
public func dispatch_queue_create(_ label: Swift.UnsafePointer<Swift.Int8>?, _ attr: Dispatch.__OS_dispatch_queue_attr?) -> Dispatch.DispatchQueue
@available(*, unavailable, renamed: "DispatchQueue.init(label:qos:attributes:autoreleaseFrequency:target:)")
public func dispatch_queue_create_with_target(_ label: Swift.UnsafePointer<Swift.Int8>?, _ attr: Dispatch.__OS_dispatch_queue_attr?, _ queue: Dispatch.DispatchQueue?) -> Dispatch.DispatchQueue
@available(*, unavailable, renamed: "DispatchIO.init(type:fileDescriptor:queue:cleanupHandler:)")
public func dispatch_io_create(_ type: Swift.UInt, _ fd: Swift.Int32, _ queue: Dispatch.DispatchQueue, _ cleanup_handler: (Swift.Int32) -> Swift.Void) -> Dispatch.DispatchIO
@available(*, unavailable, renamed: "DispatchIO.init(type:path:oflag:mode:queue:cleanupHandler:)")
public func dispatch_io_create_with_path(_ type: Swift.UInt, _ path: Swift.UnsafePointer<Swift.Int8>, _ oflag: Swift.Int32, _ mode: Darwin.mode_t, _ queue: Dispatch.DispatchQueue, _ cleanup_handler: (Swift.Int32) -> Swift.Void) -> Dispatch.DispatchIO
@available(*, unavailable, renamed: "DispatchIO.init(type:io:queue:cleanupHandler:)")
public func dispatch_io_create_with_io(_ type: Swift.UInt, _ io: Dispatch.DispatchIO, _ queue: Dispatch.DispatchQueue, _ cleanup_handler: (Swift.Int32) -> Swift.Void) -> Dispatch.DispatchIO
@available(*, unavailable, renamed: "DispatchIO.read(fileDescriptor:length:queue:handler:)")
public func dispatch_read(_ fd: Swift.Int32, _ length: Swift.Int, _ queue: Dispatch.DispatchQueue, _ handler: (Dispatch.__DispatchData, Swift.Int32) -> Swift.Void)
@available(*, unavailable, renamed: "DispatchData.init(bytes:)")
public func dispatch_data_create(_ buffer: Swift.UnsafeRawPointer, _ size: Swift.Int, _ queue: Dispatch.DispatchQueue?, _ destructor: (() -> Swift.Void)?) -> Dispatch.__DispatchData
@available(*, unavailable, renamed: "getter:DispatchData.count(self:)")
public func dispatch_data_get_size(_ data: Dispatch.__DispatchData) -> Swift.Int
@available(*, unavailable, renamed: "DispatchData.withUnsafeBytes(self:body:)")
public func dispatch_data_create_map(_ data: Dispatch.__DispatchData, _ buffer_ptr: Swift.UnsafeMutablePointer<Swift.UnsafeRawPointer?>?, _ size_ptr: Swift.UnsafeMutablePointer<Swift.Int>?) -> Dispatch.__DispatchData
@available(*, unavailable, renamed: "DispatchData.append(self:_:)")
public func dispatch_data_create_concat(_ data1: Dispatch.__DispatchData, _ data2: Dispatch.__DispatchData) -> Dispatch.__DispatchData
@available(*, unavailable, renamed: "DispatchData.subdata(self:in:)")
public func dispatch_data_create_subrange(_ data: Dispatch.__DispatchData, _ offset: Swift.Int, _ length: Swift.Int) -> Dispatch.__DispatchData
@available(*, unavailable, renamed: "DispatchData.enumerateBytes(self:block:)")
public func dispatch_data_apply(_ data: Dispatch.__DispatchData, _ applier: (Dispatch.__DispatchData, Swift.Int, Swift.UnsafeRawPointer, Swift.Int) -> Swift.Bool) -> Swift.Bool
@available(*, unavailable, renamed: "DispatchData.region(self:location:)")
public func dispatch_data_copy_region(_ data: Dispatch.__DispatchData, _ location: Swift.Int, _ offset_ptr: Swift.UnsafeMutablePointer<Swift.Int>) -> Dispatch.__DispatchData
@available(*, unavailable, renamed: "DispatchQueue.async(self:group:qos:flags:execute:)")
public func dispatch_group_async(_ group: Dispatch.DispatchGroup, _ queue: Dispatch.DispatchQueue, _ block: () -> Swift.Void)
@available(*, unavailable, renamed: "DispatchGroup.notify(self:qos:flags:queue:execute:)")
public func dispatch_group_notify(_ group: Dispatch.DispatchGroup, _ queue: Dispatch.DispatchQueue, _ block: () -> Swift.Void)
@available(*, unavailable, renamed: "DispatchGroup.wait(self:timeout:)")
public func dispatch_group_wait(_ group: Dispatch.DispatchGroup, _ timeout: Dispatch.dispatch_time_t) -> Swift.Int
@available(*, unavailable, renamed: "DispatchIO.close(self:flags:)")
public func dispatch_io_close(_ channel: Dispatch.DispatchIO, _ flags: Swift.UInt)
@available(*, unavailable, renamed: "DispatchIO.setInterval(self:interval:flags:)")
public func dispatch_io_set_interval(_ channel: Dispatch.DispatchIO, _ interval: Swift.UInt64, _ flags: Swift.UInt)
@available(*, unavailable, message: "Use DispatchQueue.concurrentPerform(iterations:execute:). The 'queue' argument is not required because the system chooses the appropriate execution context for the block")
public func dispatch_apply(_ iterations: Swift.Int, _ queue: Dispatch.DispatchQueue, _ block: (Swift.Int) -> Swift.Void)
@available(*, unavailable, renamed: "DispatchQueue.async(self:execute:)")
public func dispatch_async(_ queue: Dispatch.DispatchQueue, _ block: () -> Swift.Void)
@available(*, unavailable, renamed: "DispatchQueue.global(attributes:)")
public func dispatch_get_global_queue(_ identifier: Swift.Int, _ flags: Swift.UInt) -> Dispatch.DispatchQueue
@available(*, unavailable, renamed: "getter:DispatchQueue.main()")
public func dispatch_get_main_queue() -> Dispatch.DispatchQueue
@available(*, unavailable, renamed: "DispatchQueue.Attributes.initiallyInactive")
public func dispatch_queue_attr_make_initially_inactive(_ attr: Dispatch.__OS_dispatch_queue_attr?) -> Dispatch.__OS_dispatch_queue_attr
@available(*, unavailable, renamed: "DispatchQueue.AutoreleaseFrequency.workItem")
public func dispatch_queue_attr_make_with_autorelease_frequency(_ attr: Dispatch.__OS_dispatch_queue_attr?, _ frequency: Dispatch.__dispatch_autorelease_frequency_t) -> Dispatch.__OS_dispatch_queue_attr
@available(*, unavailable, renamed: "DispatchQoS")
public func dispatch_queue_attr_make_with_qos_class(_ attr: Dispatch.__OS_dispatch_queue_attr?, _ qos_class: Darwin.qos_class_t, _ relative_priority: Swift.Int32) -> Dispatch.__OS_dispatch_queue_attr
@available(*, unavailable, renamed: "getter:DispatchQueue.label(self:)")
public func dispatch_queue_get_label(_ queue: Dispatch.DispatchQueue?) -> Swift.UnsafePointer<Swift.Int8>
@available(*, unavailable, renamed: "getter:DispatchQueue.qos(self:)")
public func dispatch_queue_get_qos_class(_ queue: Dispatch.DispatchQueue, _ relative_priority_ptr: Swift.UnsafeMutablePointer<Swift.Int32>?) -> Darwin.qos_class_t
@available(*, unavailable, renamed: "DispatchQueue.asyncAfter(self:deadline:qos:flags:execute:)")
public func dispatch_after(_ when: Dispatch.dispatch_time_t, _ queue: Dispatch.DispatchQueue, _ block: () -> Swift.Void)
@available(*, unavailable, renamed: "DispatchQueue.async(self:group:qos:flags:execute:)")
public func dispatch_barrier_async(_ queue: Dispatch.DispatchQueue, _ block: () -> Swift.Void)
@available(*, unavailable, renamed: "DispatchQueue.sync(self:flags:execute:)")
public func dispatch_barrier_sync(_ queue: Dispatch.DispatchQueue, _ block: () -> Swift.Void)
@available(*, unavailable, renamed: "DispatchQueue.setSpecific(self:key:value:)")
public func dispatch_queue_set_specific(_ queue: Dispatch.DispatchQueue, _ key: Swift.UnsafeRawPointer, _ context: Swift.UnsafeMutableRawPointer?, _ destructor: (@convention(c) (Swift.UnsafeMutableRawPointer?) -> Swift.Void)?)
@available(*, unavailable, renamed: "DispatchQueue.getSpecific(self:key:)")
public func dispatch_queue_get_specific(_ queue: Dispatch.DispatchQueue, _ key: Swift.UnsafeRawPointer) -> Swift.UnsafeMutableRawPointer?
@available(*, unavailable, renamed: "DispatchQueue.getSpecific(key:)")
public func dispatch_get_specific(_ key: Swift.UnsafeRawPointer) -> Swift.UnsafeMutableRawPointer?
@available(*, unavailable, renamed: "dispatchPrecondition(_:)")
public func dispatch_assert_queue(_ queue: Dispatch.DispatchQueue)
@available(*, unavailable, renamed: "dispatchPrecondition(_:)")
public func dispatch_assert_queue_barrier(_ queue: Dispatch.DispatchQueue)
@available(*, unavailable, renamed: "dispatchPrecondition(_:)")
public func dispatch_assert_queue_not(_ queue: Dispatch.DispatchQueue)
@available(*, unavailable, renamed: "DispatchSemaphore.wait(self:timeout:)")
public func dispatch_semaphore_wait(_ dsema: Dispatch.DispatchSemaphore, _ timeout: Dispatch.dispatch_time_t) -> Swift.Int
@available(*, unavailable, renamed: "DispatchSemaphore.signal(self:)")
public func dispatch_semaphore_signal(_ dsema: Dispatch.DispatchSemaphore) -> Swift.Int
@available(*, unavailable, message: "Use DispatchSource class methods")
public func dispatch_source_create(_ type: Dispatch.__dispatch_source_type_t, _ handle: Swift.UInt, _ mask: Swift.UInt, _ queue: Dispatch.DispatchQueue?) -> Dispatch.DispatchSource
@available(*, unavailable, renamed: "DispatchSource.setEventHandler(self:handler:)")
public func dispatch_source_set_event_handler(_ source: Dispatch.DispatchSource, _ handler: (() -> Swift.Void)?)
@available(*, unavailable, renamed: "DispatchSource.setCancelHandler(self:handler:)")
public func dispatch_source_set_cancel_handler(_ source: Dispatch.DispatchSource, _ handler: (() -> Swift.Void)?)
@available(*, unavailable, renamed: "DispatchSource.cancel(self:)")
public func dispatch_source_cancel(_ source: Dispatch.DispatchSource)
@available(*, unavailable, renamed: "getter:DispatchSource.isCancelled(self:)")
public func dispatch_source_testcancel(_ source: Dispatch.DispatchSource) -> Swift.Int
@available(*, unavailable, renamed: "getter:DispatchSource.handle(self:)")
public func dispatch_source_get_handle(_ source: Dispatch.DispatchSource) -> Swift.UInt
@available(*, unavailable, renamed: "getter:DispatchSource.mask(self:)")
public func dispatch_source_get_mask(_ source: Dispatch.DispatchSource) -> Swift.UInt
@available(*, unavailable, renamed: "getter:DispatchSource.data(self:)")
public func dispatch_source_get_data(_ source: Dispatch.DispatchSource) -> Swift.UInt
@available(*, unavailable, renamed: "DispatchUserDataAdd.mergeData(self:value:)")
public func dispatch_source_merge_data(_ source: Dispatch.DispatchSource, _ value: Swift.UInt)
@available(*, unavailable, renamed: "DispatchTimerSource.setTimer(self:start:interval:leeway:)")
public func dispatch_source_set_timer(_ source: Dispatch.DispatchSource, _ start: Dispatch.dispatch_time_t, _ interval: Swift.UInt64, _ leeway: Swift.UInt64)
@available(*, unavailable, renamed: "DispatchSource.setRegistrationHandler(self:handler:)")
public func dispatch_source_set_registration_handler(_ source: Dispatch.DispatchSource, _ handler: (() -> Swift.Void)?)
@available(*, unavailable, renamed: "DispatchTime.now()")
public func dispatch_time(_ when: Dispatch.dispatch_time_t, _ delta: Swift.Int64) -> Dispatch.dispatch_time_t
@available(*, unavailable, renamed: "DispatchWalltime.init(time:)")
public func dispatch_walltime(_ when: Swift.UnsafePointer<Darwin.timespec>?, _ delta: Swift.Int64) -> Dispatch.dispatch_time_t
@available(*, unavailable, renamed: "DispatchQueue.GlobalQueuePriority.high")
public var DISPATCH_QUEUE_PRIORITY_HIGH: Swift.Int {
  get
}
@available(*, unavailable, renamed: "DispatchQueue.GlobalQueuePriority.default")
public var DISPATCH_QUEUE_PRIORITY_DEFAULT: Swift.Int {
  get
}
@available(*, unavailable, renamed: "DispatchQueue.GlobalQueuePriority.low")
public var DISPATCH_QUEUE_PRIORITY_LOW: Swift.Int {
  get
}
@available(*, unavailable, renamed: "DispatchQueue.GlobalQueuePriority.background")
public var DISPATCH_QUEUE_PRIORITY_BACKGROUND: Swift.Int {
  get
}
@available(*, unavailable, renamed: "DispatchIO.StreamType.stream")
public var DISPATCH_IO_STREAM: Swift.Int {
  get
}
@available(*, unavailable, renamed: "DispatchIO.StreamType.random")
public var DISPATCH_IO_RANDOM: Swift.Int {
  get
}
@available(*, unavailable, renamed: "DispatchIO.CloseFlags.stop")
public var DISPATCH_IO_STOP: Swift.Int {
  get
}
@available(*, unavailable, renamed: "DispatchIO.IntervalFlags.strictInterval")
public var DISPATCH_IO_STRICT_INTERVAL: Swift.Int {
  get
}
@available(*, unavailable, renamed: "DispatchSource.MachSendEvent.dead")
public var DISPATCH_MACH_SEND_DEAD: Swift.Int {
  get
}
@available(*, unavailable, renamed: "DispatchSource.MemoryPressureEvent.normal")
public var DISPATCH_MEMORYPRESSURE_NORMAL: Swift.Int {
  get
}
@available(*, unavailable, renamed: "DispatchSource.MemoryPressureEvent.warning")
public var DISPATCH_MEMORYPRESSURE_WARN: Swift.Int {
  get
}
@available(*, unavailable, renamed: "DispatchSource.MemoryPressureEvent.critical")
public var DISPATCH_MEMORYPRESSURE_CRITICAL: Swift.Int {
  get
}
@available(*, unavailable, renamed: "DispatchSource.ProcessEvent.exit")
public var DISPATCH_PROC_EXIT: Swift.Int {
  get
}
@available(*, unavailable, renamed: "DispatchSource.ProcessEvent.fork")
public var DISPATCH_PROC_FORK: Swift.Int {
  get
}
@available(*, unavailable, renamed: "DispatchSource.ProcessEvent.exec")
public var DISPATCH_PROC_EXEC: Swift.Int {
  get
}
@available(*, unavailable, renamed: "DispatchSource.ProcessEvent.signal")
public var DISPATCH_PROC_SIGNAL: Swift.Int {
  get
}
@available(*, unavailable, renamed: "DispatchSource.TimerFlags.strict")
public var DISPATCH_TIMER_STRICT: Swift.Int {
  get
}
@available(*, unavailable, renamed: "DispatchSource.FileSystemEvent.delete")
public var DISPATCH_VNODE_DELETE: Swift.Int {
  get
}
@available(*, unavailable, renamed: "DispatchSource.FileSystemEvent.write")
public var DISPATCH_VNODE_WRITE: Swift.Int {
  get
}
@available(*, unavailable, renamed: "DispatchSource.FileSystemEvent.extend")
public var DISPATCH_VNODE_EXTEND: Swift.Int {
  get
}
@available(*, unavailable, renamed: "DispatchSource.FileSystemEvent.attrib")
public var DISPATCH_VNODE_ATTRIB: Swift.Int {
  get
}
@available(*, unavailable, renamed: "DispatchSource.FileSystemEvent.link")
public var DISPATCH_VNODE_LINK: Swift.Int {
  get
}
@available(*, unavailable, renamed: "DispatchSource.FileSystemEvent.rename")
public var DISPATCH_VNODE_RENAME: Swift.Int {
  get
}
@available(*, unavailable, renamed: "DispatchSource.FileSystemEvent.revoke")
public var DISPATCH_VNODE_REVOKE: Swift.Int {
  get
}
@available(*, unavailable, renamed: "DispatchSource.FileSystemEvent.funlock")
public var DISPATCH_VNODE_FUNLOCK: Swift.Int {
  get
}
@available(*, unavailable, renamed: "DispatchTime.now()")
public var DISPATCH_TIME_NOW: Swift.Int {
  get
}
@available(*, unavailable, renamed: "DispatchTime.distantFuture")
public var DISPATCH_TIME_FOREVER: Swift.Int {
  get
}
extension Dispatch.DispatchQueue.GlobalQueuePriority : Swift.Equatable {}
extension Dispatch.DispatchQueue.GlobalQueuePriority : Swift.Hashable {}
extension Dispatch.DispatchQueue.AutoreleaseFrequency : Swift.Equatable {}
extension Dispatch.DispatchQueue.AutoreleaseFrequency : Swift.Hashable {}
extension Dispatch.DispatchIO.StreamType : Swift.Equatable {}
extension Dispatch.DispatchIO.StreamType : Swift.Hashable {}
extension Dispatch.DispatchIO.StreamType : Swift.RawRepresentable {}
extension Dispatch.DispatchQoS.QoSClass : Swift.Equatable {}
extension Dispatch.DispatchQoS.QoSClass : Swift.Hashable {}
extension Dispatch.DispatchTimeoutResult : Swift.Equatable {}
extension Dispatch.DispatchTimeoutResult : Swift.Hashable {}
