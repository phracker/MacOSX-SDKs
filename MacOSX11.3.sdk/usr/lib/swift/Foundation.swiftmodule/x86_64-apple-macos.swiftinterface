// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 5.4 (swiftlang-1205.0.24.14 clang-1205.0.19.54)
// swift-module-flags: -target x86_64-apple-macos11.3 -enable-objc-interop -autolink-force-load -enable-library-evolution -module-link-name swiftFoundation -swift-version 5 -enforce-exclusivity=unchecked -O -module-name Foundation
import Combine
import CoreFoundation
import CoreGraphics
import Darwin
import Dispatch
@_exported import Foundation
import ObjectiveC
import Swift
import Darwin.uuid
extension String {
  public init(_ cocoaString: Foundation.NSString)
}
extension String : Swift._ObjectiveCBridgeable {
  @_semantics("convertToObjectiveC") public func _bridgeToObjectiveC() -> Foundation.NSString
  public static func _forceBridgeFromObjectiveC(_ x: Foundation.NSString, result: inout Swift.String?)
  public static func _conditionallyBridgeFromObjectiveC(_ x: Foundation.NSString, result: inout Swift.String?) -> Swift.Bool
  @_effects(readonly) public static func _unconditionallyBridgeFromObjectiveC(_ source: Foundation.NSString?) -> Swift.String
  public typealias _ObjectiveCType = Foundation.NSString
}
extension Substring : Swift._ObjectiveCBridgeable {
  @_semantics("convertToObjectiveC") public func _bridgeToObjectiveC() -> Foundation.NSString
  public static func _forceBridgeFromObjectiveC(_ x: Foundation.NSString, result: inout Swift.Substring?)
  public static func _conditionallyBridgeFromObjectiveC(_ x: Foundation.NSString, result: inout Swift.Substring?) -> Swift.Bool
  @_effects(readonly) public static func _unconditionallyBridgeFromObjectiveC(_ source: Foundation.NSString?) -> Swift.Substring
  public typealias _ObjectiveCType = Foundation.NSString
}
extension String : Swift.CVarArg {
}
extension NSURL : Swift._CustomPlaygroundQuickLookable {
  @available(*, deprecated, message: "NSURL.customPlaygroundQuickLook will be removed in a future Swift version")
  public var customPlaygroundQuickLook: Swift.PlaygroundQuickLook {
    get
  }
}
public protocol DataProtocol : Swift.RandomAccessCollection where Self.Element == Swift.UInt8, Self.SubSequence : Foundation.DataProtocol {
  associatedtype Regions : Swift.BidirectionalCollection where Self.Regions.Element : Foundation.ContiguousBytes, Self.Regions.Element : Foundation.DataProtocol, Self.Regions.Element.SubSequence : Foundation.ContiguousBytes
  var regions: Self.Regions { get }
  func firstRange<D, R>(of: D, in: R) -> Swift.Range<Self.Index>? where D : Foundation.DataProtocol, R : Swift.RangeExpression, Self.Index == R.Bound
  func lastRange<D, R>(of: D, in: R) -> Swift.Range<Self.Index>? where D : Foundation.DataProtocol, R : Swift.RangeExpression, Self.Index == R.Bound
  @discardableResult
  func copyBytes(to: Swift.UnsafeMutableRawBufferPointer, count: Swift.Int) -> Swift.Int
  @discardableResult
  func copyBytes<DestinationType>(to: Swift.UnsafeMutableBufferPointer<DestinationType>, count: Swift.Int) -> Swift.Int
  @discardableResult
  func copyBytes<R>(to: Swift.UnsafeMutableRawBufferPointer, from: R) -> Swift.Int where R : Swift.RangeExpression, Self.Index == R.Bound
  @discardableResult
  func copyBytes<DestinationType, R>(to: Swift.UnsafeMutableBufferPointer<DestinationType>, from: R) -> Swift.Int where R : Swift.RangeExpression, Self.Index == R.Bound
}
public protocol MutableDataProtocol : Foundation.DataProtocol, Swift.MutableCollection, Swift.RangeReplaceableCollection {
  mutating func resetBytes<R>(in range: R) where R : Swift.RangeExpression, Self.Index == R.Bound
}
extension DataProtocol {
  public func firstRange<D>(of data: D) -> Swift.Range<Self.Index>? where D : Foundation.DataProtocol
  public func lastRange<D>(of data: D) -> Swift.Range<Self.Index>? where D : Foundation.DataProtocol
  @discardableResult
  public func copyBytes(to ptr: Swift.UnsafeMutableRawBufferPointer) -> Swift.Int
  @discardableResult
  public func copyBytes<DestinationType>(to ptr: Swift.UnsafeMutableBufferPointer<DestinationType>) -> Swift.Int
  @discardableResult
  public func copyBytes(to ptr: Swift.UnsafeMutableRawBufferPointer, count: Swift.Int) -> Swift.Int
  @discardableResult
  public func copyBytes<DestinationType>(to ptr: Swift.UnsafeMutableBufferPointer<DestinationType>, count: Swift.Int) -> Swift.Int
  @discardableResult
  public func copyBytes<R>(to ptr: Swift.UnsafeMutableRawBufferPointer, from range: R) -> Swift.Int where R : Swift.RangeExpression, Self.Index == R.Bound
  @discardableResult
  public func copyBytes<DestinationType, R>(to ptr: Swift.UnsafeMutableBufferPointer<DestinationType>, from range: R) -> Swift.Int where R : Swift.RangeExpression, Self.Index == R.Bound
  public func firstRange<D, R>(of data: D, in range: R) -> Swift.Range<Self.Index>? where D : Foundation.DataProtocol, R : Swift.RangeExpression, Self.Index == R.Bound
  public func lastRange<D, R>(of data: D, in range: R) -> Swift.Range<Self.Index>? where D : Foundation.DataProtocol, R : Swift.RangeExpression, Self.Index == R.Bound
}
extension DataProtocol where Self : Foundation.ContiguousBytes {
  public func copyBytes<DestinationType, R>(to ptr: Swift.UnsafeMutableBufferPointer<DestinationType>, from range: R) where R : Swift.RangeExpression, Self.Index == R.Bound
}
extension MutableDataProtocol {
  public mutating func resetBytes<R>(in range: R) where R : Swift.RangeExpression, Self.Index == R.Bound
}
extension Slice : Foundation.DataProtocol where Base : Foundation.DataProtocol {
  public typealias Regions = [Base.Regions.Element.SubSequence]
  public var regions: [Base.Regions.Element.SubSequence] {
    get
  }
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Date {
  public typealias Stride = Foundation.TimeInterval
  public func distance(to other: Foundation.Date) -> Foundation.TimeInterval
  public func advanced(by n: Foundation.TimeInterval) -> Foundation.Date
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension URLSessionWebSocketTask {
  public enum Message {
    case data(Foundation.Data)
    case string(Swift.String)
  }
  public func send(_ message: Foundation.URLSessionWebSocketTask.Message, completionHandler: @escaping (Swift.Error?) -> Swift.Void)
  public func receive(completionHandler: @escaping (Swift.Result<Foundation.URLSessionWebSocketTask.Message, Swift.Error>) -> Swift.Void)
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension URLSessionTaskTransactionMetrics {
  public var localPort: Swift.Int? {
    get
  }
  public var remotePort: Swift.Int? {
    get
  }
  public var negotiatedTLSProtocolVersion: Security.tls_protocol_version_t? {
    get
  }
  public var negotiatedTLSCipherSuite: Security.tls_ciphersuite_t? {
    get
  }
}
public struct DateComponents : Foundation.ReferenceConvertible, Swift.Hashable, Swift.Equatable {
  public typealias ReferenceType = Foundation.NSDateComponents
  public init(calendar: Foundation.Calendar? = nil, timeZone: Foundation.TimeZone? = nil, era: Swift.Int? = nil, year: Swift.Int? = nil, month: Swift.Int? = nil, day: Swift.Int? = nil, hour: Swift.Int? = nil, minute: Swift.Int? = nil, second: Swift.Int? = nil, nanosecond: Swift.Int? = nil, weekday: Swift.Int? = nil, weekdayOrdinal: Swift.Int? = nil, quarter: Swift.Int? = nil, weekOfMonth: Swift.Int? = nil, weekOfYear: Swift.Int? = nil, yearForWeekOfYear: Swift.Int? = nil)
  public var calendar: Foundation.Calendar? {
    get
    set
  }
  public var timeZone: Foundation.TimeZone? {
    get
    set
  }
  public var era: Swift.Int? {
    get
    set
  }
  public var year: Swift.Int? {
    get
    set
  }
  public var month: Swift.Int? {
    get
    set
  }
  public var day: Swift.Int? {
    get
    set
  }
  public var hour: Swift.Int? {
    get
    set
  }
  public var minute: Swift.Int? {
    get
    set
  }
  public var second: Swift.Int? {
    get
    set
  }
  public var nanosecond: Swift.Int? {
    get
    set
  }
  public var weekday: Swift.Int? {
    get
    set
  }
  public var weekdayOrdinal: Swift.Int? {
    get
    set
  }
  public var quarter: Swift.Int? {
    get
    set
  }
  public var weekOfMonth: Swift.Int? {
    get
    set
  }
  public var weekOfYear: Swift.Int? {
    get
    set
  }
  public var yearForWeekOfYear: Swift.Int? {
    get
    set
  }
  public var isLeapMonth: Swift.Bool? {
    get
    set
  }
  public var date: Foundation.Date? {
    get
  }
  @available(macOS 10.9, iOS 8.0, *)
  public mutating func setValue(_ value: Swift.Int?, for component: Foundation.Calendar.Component)
  @available(macOS 10.9, iOS 8.0, *)
  public func value(for component: Foundation.Calendar.Component) -> Swift.Int?
  @available(macOS 10.9, iOS 8.0, *)
  public var isValidDate: Swift.Bool {
    get
  }
  @available(macOS 10.9, iOS 8.0, *)
  public func isValidDate(in calendar: Foundation.Calendar) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (lhs: Foundation.DateComponents, rhs: Foundation.DateComponents) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
extension DateComponents : Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible, Swift.CustomReflectable {
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
  public var customMirror: Swift.Mirror {
    get
  }
}
extension DateComponents : Swift._ObjectiveCBridgeable {
  public static func _getObjectiveCType() -> Any.Type
  @_semantics("convertToObjectiveC") public func _bridgeToObjectiveC() -> Foundation.NSDateComponents
  public static func _forceBridgeFromObjectiveC(_ dateComponents: Foundation.NSDateComponents, result: inout Foundation.DateComponents?)
  public static func _conditionallyBridgeFromObjectiveC(_ dateComponents: Foundation.NSDateComponents, result: inout Foundation.DateComponents?) -> Swift.Bool
  @_effects(readonly) public static func _unconditionallyBridgeFromObjectiveC(_ source: Foundation.NSDateComponents?) -> Foundation.DateComponents
  public typealias _ObjectiveCType = Foundation.NSDateComponents
}
extension NSDateComponents : Swift._HasCustomAnyHashableRepresentation {
  @nonobjc public func _toCustomAnyHashable() -> Swift.AnyHashable?
}
extension DateComponents : Swift.Codable {
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
public protocol _KeyValueCodingAndObservingPublishing {
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension NSObject : Foundation._KeyValueCodingAndObservingPublishing {
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension _KeyValueCodingAndObservingPublishing where Self : ObjectiveC.NSObject {
  public func publisher<Value>(for keyPath: Swift.KeyPath<Self, Value>, options: Foundation.NSKeyValueObservingOptions = [.initial, .new]) -> ObjectiveC.NSObject.KeyValueObservingPublisher<Self, Value>
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension NSObject.KeyValueObservingPublisher {
  public func didChange() -> Combine.Publishers.Map<ObjectiveC.NSObject.KeyValueObservingPublisher<Subject, Value>, Swift.Void>
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension NSObject {
  public struct KeyValueObservingPublisher<Subject, Value> : Swift.Equatable where Subject : ObjectiveC.NSObject {
    public let object: Subject
    public let keyPath: Swift.KeyPath<Subject, Value>
    public let options: Foundation.NSKeyValueObservingOptions
    public init(object: Subject, keyPath: Swift.KeyPath<Subject, Value>, options: Foundation.NSKeyValueObservingOptions)
    public static func == (lhs: ObjectiveC.NSObject.KeyValueObservingPublisher<Subject, Value>, rhs: ObjectiveC.NSObject.KeyValueObservingPublisher<Subject, Value>) -> Swift.Bool
  }
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension NSObject.KeyValueObservingPublisher : Combine.Publisher {
  public typealias Output = Value
  public typealias Failure = Swift.Never
  public func receive<S>(subscriber: S) where Value == S.Input, S : Combine.Subscriber, S.Failure == ObjectiveC.NSObject.KeyValueObservingPublisher<Subject, Value>.Failure
}
public protocol _KeyValueCodingAndObserving {
}
extension NSObject : Foundation._KeyValueCodingAndObserving {
}
public struct NSKeyValueObservedChange<Value> {
  public typealias Kind = Foundation.NSKeyValueChange
  public let kind: Foundation.NSKeyValueObservedChange<Value>.Kind
  public let newValue: Value?
  public let oldValue: Value?
  public let indexes: Foundation.IndexSet?
  public let isPrior: Swift.Bool
}
public protocol NSKeyValueObservingCustomization : ObjectiveC.NSObjectProtocol {
  static func keyPathsAffectingValue(for key: Swift.AnyKeyPath) -> Swift.Set<Swift.AnyKeyPath>
  static func automaticallyNotifiesObservers(for key: Swift.AnyKeyPath) -> Swift.Bool
}
@_hasMissingDesignatedInitializers @objc(_NSKeyValueObservation) public class NSKeyValueObservation : ObjectiveC.NSObject {
  @objc public func invalidate()
  @objc deinit
  @objc override dynamic public init()
}
extension _KeyValueCodingAndObserving {
  public func observe<Value>(_ keyPath: Swift.KeyPath<Self, Value>, options: Foundation.NSKeyValueObservingOptions = [], changeHandler: @escaping (Self, Foundation.NSKeyValueObservedChange<Value>) -> Swift.Void) -> Foundation.NSKeyValueObservation
  public func willChangeValue<Value>(for keyPath: __owned Swift.KeyPath<Self, Value>)
  public func willChange<Value>(_ changeKind: Foundation.NSKeyValueChange, valuesAt indexes: Foundation.IndexSet, for keyPath: __owned Swift.KeyPath<Self, Value>)
  public func willChangeValue<Value>(for keyPath: __owned Swift.KeyPath<Self, Value>, withSetMutation mutation: Foundation.NSKeyValueSetMutationKind, using set: Swift.Set<Value>) where Value : Swift.Hashable
  public func didChangeValue<Value>(for keyPath: __owned Swift.KeyPath<Self, Value>)
  public func didChange<Value>(_ changeKind: Foundation.NSKeyValueChange, valuesAt indexes: Foundation.IndexSet, for keyPath: __owned Swift.KeyPath<Self, Value>)
  public func didChangeValue<Value>(for keyPath: __owned Swift.KeyPath<Self, Value>, withSetMutation mutation: Foundation.NSKeyValueSetMutationKind, using set: Swift.Set<Value>) where Value : Swift.Hashable
}
extension Progress {
  @available(macOS 10.13, iOS 11.0, watchOS 4.0, tvOS 11.0, *)
  public var estimatedTimeRemaining: Foundation.TimeInterval? {
    get
    set
  }
  @available(macOS 10.13, iOS 11.0, watchOS 4.0, tvOS 11.0, *)
  public var throughput: Swift.Int? {
    get
    set
  }
  @available(macOS 10.13, iOS 11.0, watchOS 4.0, tvOS 11.0, *)
  public var fileTotalCount: Swift.Int? {
    get
    set
  }
  @available(macOS 10.13, iOS 11.0, watchOS 4.0, tvOS 11.0, *)
  public var fileCompletedCount: Swift.Int? {
    get
    set
  }
  public func performAsCurrent<ReturnType>(withPendingUnitCount unitCount: Swift.Int64, using work: () throws -> ReturnType) rethrows -> ReturnType
}
public struct AffineTransform : Foundation.ReferenceConvertible, Swift.Hashable, Swift.CustomStringConvertible {
  public var m11: CoreGraphics.CGFloat, m12: CoreGraphics.CGFloat, m21: CoreGraphics.CGFloat, m22: CoreGraphics.CGFloat, tX: CoreGraphics.CGFloat, tY: CoreGraphics.CGFloat
  public typealias ReferenceType = Foundation.NSAffineTransform
  public init(m11: CoreGraphics.CGFloat, m12: CoreGraphics.CGFloat, m21: CoreGraphics.CGFloat, m22: CoreGraphics.CGFloat, tX: CoreGraphics.CGFloat, tY: CoreGraphics.CGFloat)
  public init()
  public init(translationByX x: CoreGraphics.CGFloat, byY y: CoreGraphics.CGFloat)
  public init(scaleByX x: CoreGraphics.CGFloat, byY y: CoreGraphics.CGFloat)
  public init(scale factor: CoreGraphics.CGFloat)
  public init(rotationByRadians angle: CoreGraphics.CGFloat)
  public init(rotationByDegrees angle: CoreGraphics.CGFloat)
  public static let identity: Foundation.AffineTransform
  public mutating func translate(x: CoreGraphics.CGFloat, y: CoreGraphics.CGFloat)
  public mutating func rotate(byDegrees angle: CoreGraphics.CGFloat)
  public mutating func rotate(byRadians angle: CoreGraphics.CGFloat)
  public mutating func scale(_ scale: CoreGraphics.CGFloat)
  public mutating func scale(x: CoreGraphics.CGFloat, y: CoreGraphics.CGFloat)
  public mutating func invert()
  public func inverted() -> Foundation.AffineTransform?
  public mutating func append(_ transform: Foundation.AffineTransform)
  public mutating func prepend(_ transform: Foundation.AffineTransform)
  public func transform(_ point: Foundation.NSPoint) -> Foundation.NSPoint
  public func transform(_ size: Foundation.NSSize) -> Foundation.NSSize
  public func hash(into hasher: inout Swift.Hasher)
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
  public static func == (lhs: Foundation.AffineTransform, rhs: Foundation.AffineTransform) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
extension AffineTransform : Swift._ObjectiveCBridgeable {
  public static func _getObjectiveCType() -> Any.Type
  @_semantics("convertToObjectiveC") public func _bridgeToObjectiveC() -> Foundation.NSAffineTransform
  public static func _forceBridgeFromObjectiveC(_ x: Foundation.NSAffineTransform, result: inout Foundation.AffineTransform?)
  public static func _conditionallyBridgeFromObjectiveC(_ x: Foundation.NSAffineTransform, result: inout Foundation.AffineTransform?) -> Swift.Bool
  @_effects(readonly) public static func _unconditionallyBridgeFromObjectiveC(_ x: Foundation.NSAffineTransform?) -> Foundation.AffineTransform
  public typealias _ObjectiveCType = Foundation.NSAffineTransform
}
extension NSAffineTransform : Swift._HasCustomAnyHashableRepresentation {
  @nonobjc public func _toCustomAnyHashable() -> Swift.AnyHashable?
}
extension AffineTransform : Swift.Codable {
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
extension NSString : Swift.ExpressibleByStringLiteral {
  required convenience public init(stringLiteral value: Swift.StaticString)
  public typealias ExtendedGraphemeClusterLiteralType = Swift.StaticString
  public typealias StringLiteralType = Swift.StaticString
  public typealias UnicodeScalarLiteralType = Swift.StaticString
}
extension NSString : Swift._HasCustomAnyHashableRepresentation {
  @nonobjc public func _toCustomAnyHashable() -> Swift.AnyHashable?
}
extension NSString {
  convenience public init(format: __shared Foundation.NSString, _ args: Swift.CVarArg...)
  convenience public init(format: __shared Foundation.NSString, locale: Foundation.Locale?, _ args: Swift.CVarArg...)
  public class func localizedStringWithFormat(_ format: Foundation.NSString, _ args: Swift.CVarArg...) -> Self
  public func appendingFormat(_ format: Foundation.NSString, _ args: Swift.CVarArg...) -> Foundation.NSString
}
extension NSMutableString {
  public func appendFormat(_ format: Foundation.NSString, _ args: Swift.CVarArg...)
}
extension NSString {
  @nonobjc convenience public init(string aString: __shared Foundation.NSString)
}
extension NSString : Swift._CustomPlaygroundQuickLookable {
  @available(*, deprecated, message: "NSString.customPlaygroundQuickLook will be removed in a future Swift version")
  public var customPlaygroundQuickLook: Swift.PlaygroundQuickLook {
    get
  }
}
extension UndoManager {
  @available(*, unavailable, renamed: "registerUndo(withTarget:handler:)")
  public func registerUndoWithTarget<TargetType>(_ target: TargetType, handler: (TargetType) -> Swift.Void) where TargetType : AnyObject
  @available(macOS 10.11, iOS 9.0, *)
  public func registerUndo<TargetType>(withTarget target: TargetType, handler: @escaping (TargetType) -> Swift.Void) where TargetType : AnyObject
}
public struct IndexPath : Foundation.ReferenceConvertible, Swift.Equatable, Swift.Hashable, Swift.MutableCollection, Swift.RandomAccessCollection, Swift.Comparable, Swift.ExpressibleByArrayLiteral {
  public typealias ReferenceType = Foundation.NSIndexPath
  public typealias Element = Swift.Int
  public typealias Index = Swift.Array<Swift.Int>.Index
  public typealias Indices = Swift.DefaultIndices<Foundation.IndexPath>
  public init()
  public init<ElementSequence>(indexes: ElementSequence) where ElementSequence : Swift.Sequence, ElementSequence.Element == Foundation.IndexPath.Element
  public init(arrayLiteral indexes: Foundation.IndexPath.Element...)
  public init(indexes: Swift.Array<Foundation.IndexPath.Element>)
  public init(index: Foundation.IndexPath.Element)
  public func dropLast() -> Foundation.IndexPath
  public mutating func append(_ other: Foundation.IndexPath)
  public mutating func append(_ other: Foundation.IndexPath.Element)
  public mutating func append(_ other: Swift.Array<Foundation.IndexPath.Element>)
  public func appending(_ other: Foundation.IndexPath.Element) -> Foundation.IndexPath
  public func appending(_ other: Foundation.IndexPath) -> Foundation.IndexPath
  public func appending(_ other: Swift.Array<Foundation.IndexPath.Element>) -> Foundation.IndexPath
  public subscript(index: Foundation.IndexPath.Index) -> Foundation.IndexPath.Element {
    get
    set
  }
  public subscript(range: Swift.Range<Foundation.IndexPath.Index>) -> Foundation.IndexPath {
    get
    set
  }
  public func makeIterator() -> Swift.IndexingIterator<Foundation.IndexPath>
  public var count: Swift.Int {
    get
  }
  public var startIndex: Foundation.IndexPath.Index {
    get
  }
  public var endIndex: Foundation.IndexPath.Index {
    get
  }
  public func index(before i: Foundation.IndexPath.Index) -> Foundation.IndexPath.Index
  public func index(after i: Foundation.IndexPath.Index) -> Foundation.IndexPath.Index
  public func compare(_ other: Foundation.IndexPath) -> Foundation.ComparisonResult
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (lhs: Foundation.IndexPath, rhs: Foundation.IndexPath) -> Swift.Bool
  public static func + (lhs: Foundation.IndexPath, rhs: Foundation.IndexPath) -> Foundation.IndexPath
  public static func += (lhs: inout Foundation.IndexPath, rhs: Foundation.IndexPath)
  public static func < (lhs: Foundation.IndexPath, rhs: Foundation.IndexPath) -> Swift.Bool
  public static func <= (lhs: Foundation.IndexPath, rhs: Foundation.IndexPath) -> Swift.Bool
  public static func > (lhs: Foundation.IndexPath, rhs: Foundation.IndexPath) -> Swift.Bool
  public static func >= (lhs: Foundation.IndexPath, rhs: Foundation.IndexPath) -> Swift.Bool
  public typealias ArrayLiteralElement = Foundation.IndexPath.Element
  public typealias Iterator = Swift.IndexingIterator<Foundation.IndexPath>
  public typealias SubSequence = Foundation.IndexPath
  public var hashValue: Swift.Int {
    get
  }
}
extension IndexPath : Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible, Swift.CustomReflectable {
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
  public var customMirror: Swift.Mirror {
    get
  }
}
extension IndexPath : Swift._ObjectiveCBridgeable {
  public static func _getObjectiveCType() -> Any.Type
  @_semantics("convertToObjectiveC") public func _bridgeToObjectiveC() -> Foundation.NSIndexPath
  public static func _forceBridgeFromObjectiveC(_ x: Foundation.NSIndexPath, result: inout Foundation.IndexPath?)
  public static func _conditionallyBridgeFromObjectiveC(_ x: Foundation.NSIndexPath, result: inout Foundation.IndexPath?) -> Swift.Bool
  @_effects(readonly) public static func _unconditionallyBridgeFromObjectiveC(_ source: Foundation.NSIndexPath?) -> Foundation.IndexPath
  public typealias _ObjectiveCType = Foundation.NSIndexPath
}
extension NSIndexPath : Swift._HasCustomAnyHashableRepresentation {
  @nonobjc public func _toCustomAnyHashable() -> Swift.AnyHashable?
}
extension IndexPath : Swift.Codable {
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
extension Array : Foundation.DataProtocol where Element == Swift.UInt8 {
  public var regions: Swift.CollectionOfOne<Swift.Array<Swift.UInt8>> {
    get
  }
  public typealias Regions = Swift.CollectionOfOne<Swift.Array<Swift.UInt8>>
}
extension ArraySlice : Foundation.DataProtocol where Element == Swift.UInt8 {
  public var regions: Swift.CollectionOfOne<Swift.ArraySlice<Swift.UInt8>> {
    get
  }
  public typealias Regions = Swift.CollectionOfOne<Swift.ArraySlice<Swift.UInt8>>
}
extension ContiguousArray : Foundation.DataProtocol where Element == Swift.UInt8 {
  public var regions: Swift.CollectionOfOne<Swift.ContiguousArray<Swift.UInt8>> {
    get
  }
  public typealias Regions = Swift.CollectionOfOne<Swift.ContiguousArray<Swift.UInt8>>
}
extension EmptyCollection : Foundation.DataProtocol where Element == Swift.UInt8 {
  public var regions: Swift.EmptyCollection<Foundation.Data> {
    get
  }
  public typealias Regions = Swift.EmptyCollection<Foundation.Data>
}
extension Repeated : Foundation.DataProtocol where Element == Swift.UInt8 {
  public typealias Regions = Swift.Repeated<Foundation.Data>
  public var regions: Swift.Repeated<Foundation.Data> {
    get
  }
}
extension Array : Foundation.MutableDataProtocol where Element == Swift.UInt8 {
}
extension ContiguousArray : Foundation.MutableDataProtocol where Element == Swift.UInt8 {
}
public struct TimeZone : Swift.Hashable, Swift.Equatable, Foundation.ReferenceConvertible {
  public typealias ReferenceType = Foundation.NSTimeZone
  public static var current: Foundation.TimeZone {
    get
  }
  public static var autoupdatingCurrent: Foundation.TimeZone {
    get
  }
  public init?(identifier: __shared Swift.String)
  @available(*, unavailable, renamed: "init(secondsFromGMT:)")
  public init(forSecondsFromGMT seconds: Swift.Int)
  public init?(secondsFromGMT seconds: Swift.Int)
  public init?(abbreviation: __shared Swift.String)
  @available(*, unavailable, renamed: "identifier")
  public var name: Swift.String {
    get
  }
  public var identifier: Swift.String {
    get
  }
  @available(*, unavailable, message: "use the identifier instead")
  public var data: Foundation.Data {
    get
  }
  public func secondsFromGMT(for date: Foundation.Date = Date()) -> Swift.Int
  public func abbreviation(for date: Foundation.Date = Date()) -> Swift.String?
  public func isDaylightSavingTime(for date: Foundation.Date = Date()) -> Swift.Bool
  public func daylightSavingTimeOffset(for date: Foundation.Date = Date()) -> Foundation.TimeInterval
  public func nextDaylightSavingTimeTransition(after date: Foundation.Date) -> Foundation.Date?
  public static var knownTimeZoneIdentifiers: [Swift.String] {
    get
  }
  public static var abbreviationDictionary: [Swift.String : Swift.String] {
    get
    set
  }
  public static var timeZoneDataVersion: Swift.String {
    get
  }
  public var nextDaylightSavingTimeTransition: Foundation.Date? {
    get
  }
  @available(*, unavailable, renamed: "localizedName(for:locale:)")
  public func localizedName(_ style: Foundation.NSTimeZone.NameStyle, locale: Foundation.Locale?) -> Swift.String?
  public func localizedName(for style: Foundation.NSTimeZone.NameStyle, locale: Foundation.Locale?) -> Swift.String?
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (lhs: Foundation.TimeZone, rhs: Foundation.TimeZone) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
extension TimeZone : Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible, Swift.CustomReflectable {
  public var customMirror: Swift.Mirror {
    get
  }
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
}
extension TimeZone : Swift._ObjectiveCBridgeable {
  @_semantics("convertToObjectiveC") public func _bridgeToObjectiveC() -> Foundation.NSTimeZone
  public static func _forceBridgeFromObjectiveC(_ input: Foundation.NSTimeZone, result: inout Foundation.TimeZone?)
  public static func _conditionallyBridgeFromObjectiveC(_ input: Foundation.NSTimeZone, result: inout Foundation.TimeZone?) -> Swift.Bool
  @_effects(readonly) public static func _unconditionallyBridgeFromObjectiveC(_ source: Foundation.NSTimeZone?) -> Foundation.TimeZone
  public typealias _ObjectiveCType = Foundation.NSTimeZone
}
extension NSTimeZone : Swift._HasCustomAnyHashableRepresentation {
  @nonobjc public func _toCustomAnyHashable() -> Swift.AnyHashable?
}
extension TimeZone : Swift.Codable {
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
extension IndexSet.Index {
  public static func == (lhs: Foundation.IndexSet.Index, rhs: Foundation.IndexSet.Index) -> Swift.Bool
  public static func < (lhs: Foundation.IndexSet.Index, rhs: Foundation.IndexSet.Index) -> Swift.Bool
  public static func <= (lhs: Foundation.IndexSet.Index, rhs: Foundation.IndexSet.Index) -> Swift.Bool
  public static func > (lhs: Foundation.IndexSet.Index, rhs: Foundation.IndexSet.Index) -> Swift.Bool
  public static func >= (lhs: Foundation.IndexSet.Index, rhs: Foundation.IndexSet.Index) -> Swift.Bool
}
extension IndexSet.RangeView {
  public static func == (lhs: Foundation.IndexSet.RangeView, rhs: Foundation.IndexSet.RangeView) -> Swift.Bool
}
public struct IndexSet : Foundation.ReferenceConvertible, Swift.Equatable, Swift.BidirectionalCollection, Swift.SetAlgebra {
  public struct RangeView : Swift.Equatable, Swift.BidirectionalCollection {
    public typealias Index = Swift.Int
    public let startIndex: Foundation.IndexSet.RangeView.Index
    public let endIndex: Foundation.IndexSet.RangeView.Index
    public func makeIterator() -> Swift.IndexingIterator<Foundation.IndexSet.RangeView>
    public subscript(index: Foundation.IndexSet.RangeView.Index) -> Swift.Range<Foundation.IndexSet.Element> {
      get
    }
    public subscript(bounds: Swift.Range<Foundation.IndexSet.RangeView.Index>) -> Swift.Slice<Foundation.IndexSet.RangeView> {
      get
    }
    public func index(after i: Foundation.IndexSet.RangeView.Index) -> Foundation.IndexSet.RangeView.Index
    public func index(before i: Foundation.IndexSet.RangeView.Index) -> Foundation.IndexSet.RangeView.Index
    public typealias Element = Swift.Range<Foundation.IndexSet.Element>
    public typealias Indices = Swift.DefaultIndices<Foundation.IndexSet.RangeView>
    public typealias Iterator = Swift.IndexingIterator<Foundation.IndexSet.RangeView>
    public typealias SubSequence = Swift.Slice<Foundation.IndexSet.RangeView>
  }
  public struct Index : Swift.CustomStringConvertible, Swift.Comparable {
    public var description: Swift.String {
      get
    }
  }
  public typealias ReferenceType = Foundation.NSIndexSet
  public typealias Element = Swift.Int
  public init(integersIn range: Swift.Range<Foundation.IndexSet.Element>)
  public init<R>(integersIn range: R) where R : Swift.RangeExpression, R.Bound == Foundation.IndexSet.Element
  public init(integer: Foundation.IndexSet.Element)
  public init()
  public func hash(into hasher: inout Swift.Hasher)
  public var count: Swift.Int {
    get
  }
  public func makeIterator() -> Swift.IndexingIterator<Foundation.IndexSet>
  public var rangeView: Foundation.IndexSet.RangeView {
    get
  }
  public func rangeView(of range: Swift.Range<Foundation.IndexSet.Element>) -> Foundation.IndexSet.RangeView
  public func rangeView<R>(of range: R) -> Foundation.IndexSet.RangeView where R : Swift.RangeExpression, R.Bound == Foundation.IndexSet.Element
  public var startIndex: Foundation.IndexSet.Index {
    get
  }
  public var endIndex: Foundation.IndexSet.Index {
    get
  }
  public subscript(index: Foundation.IndexSet.Index) -> Foundation.IndexSet.Element {
    get
  }
  public subscript(bounds: Swift.Range<Foundation.IndexSet.Index>) -> Swift.Slice<Foundation.IndexSet> {
    get
  }
  public var first: Foundation.IndexSet.Element? {
    get
  }
  public var last: Foundation.IndexSet.Element? {
    get
  }
  public func integerGreaterThan(_ integer: Foundation.IndexSet.Element) -> Foundation.IndexSet.Element?
  public func integerLessThan(_ integer: Foundation.IndexSet.Element) -> Foundation.IndexSet.Element?
  public func integerGreaterThanOrEqualTo(_ integer: Foundation.IndexSet.Element) -> Foundation.IndexSet.Element?
  public func integerLessThanOrEqualTo(_ integer: Foundation.IndexSet.Element) -> Foundation.IndexSet.Element?
  public func indexRange(in range: Swift.Range<Foundation.IndexSet.Element>) -> Swift.Range<Foundation.IndexSet.Index>
  public func indexRange<R>(in range: R) -> Swift.Range<Foundation.IndexSet.Index> where R : Swift.RangeExpression, R.Bound == Foundation.IndexSet.Element
  public func count(in range: Swift.Range<Foundation.IndexSet.Element>) -> Swift.Int
  public func count<R>(in range: R) -> Swift.Int where R : Swift.RangeExpression, R.Bound == Foundation.IndexSet.Element
  public func contains(_ integer: Foundation.IndexSet.Element) -> Swift.Bool
  public func contains(integersIn range: Swift.Range<Foundation.IndexSet.Element>) -> Swift.Bool
  public func contains<R>(integersIn range: R) -> Swift.Bool where R : Swift.RangeExpression, R.Bound == Foundation.IndexSet.Element
  public func contains(integersIn indexSet: Foundation.IndexSet) -> Swift.Bool
  public func intersects(integersIn range: Swift.Range<Foundation.IndexSet.Element>) -> Swift.Bool
  public func intersects<R>(integersIn range: R) -> Swift.Bool where R : Swift.RangeExpression, R.Bound == Foundation.IndexSet.Element
  public func index(after i: Foundation.IndexSet.Index) -> Foundation.IndexSet.Index
  public func formIndex(after i: inout Foundation.IndexSet.Index)
  public func index(before i: Foundation.IndexSet.Index) -> Foundation.IndexSet.Index
  public func formIndex(before i: inout Foundation.IndexSet.Index)
  public mutating func formUnion(_ other: Foundation.IndexSet)
  public func union(_ other: Foundation.IndexSet) -> Foundation.IndexSet
  public func symmetricDifference(_ other: Foundation.IndexSet) -> Foundation.IndexSet
  public mutating func formSymmetricDifference(_ other: Foundation.IndexSet)
  public func intersection(_ other: Foundation.IndexSet) -> Foundation.IndexSet
  public mutating func formIntersection(_ other: Foundation.IndexSet)
  @discardableResult
  public mutating func insert(_ integer: Foundation.IndexSet.Element) -> (inserted: Swift.Bool, memberAfterInsert: Foundation.IndexSet.Element)
  @discardableResult
  public mutating func update(with integer: Foundation.IndexSet.Element) -> Foundation.IndexSet.Element?
  @discardableResult
  public mutating func remove(_ integer: Foundation.IndexSet.Element) -> Foundation.IndexSet.Element?
  public mutating func removeAll()
  public mutating func insert(integersIn range: Swift.Range<Foundation.IndexSet.Element>)
  public mutating func insert<R>(integersIn range: R) where R : Swift.RangeExpression, R.Bound == Foundation.IndexSet.Element
  public mutating func remove(integersIn range: Swift.Range<Foundation.IndexSet.Element>)
  public mutating func remove(integersIn range: Swift.ClosedRange<Foundation.IndexSet.Element>)
  public var isEmpty: Swift.Bool {
    get
  }
  public func filteredIndexSet(in range: Swift.Range<Foundation.IndexSet.Element>, includeInteger: (Foundation.IndexSet.Element) throws -> Swift.Bool) rethrows -> Foundation.IndexSet
  public func filteredIndexSet(in range: Swift.ClosedRange<Foundation.IndexSet.Element>, includeInteger: (Foundation.IndexSet.Element) throws -> Swift.Bool) rethrows -> Foundation.IndexSet
  public func filteredIndexSet(includeInteger: (Foundation.IndexSet.Element) throws -> Swift.Bool) rethrows -> Foundation.IndexSet
  public mutating func shift(startingAt integer: Foundation.IndexSet.Element, by delta: Swift.Int)
  public typealias ArrayLiteralElement = Foundation.IndexSet.Element
  public typealias Indices = Swift.DefaultIndices<Foundation.IndexSet>
  public typealias Iterator = Swift.IndexingIterator<Foundation.IndexSet>
  public typealias SubSequence = Swift.Slice<Foundation.IndexSet>
  public var hashValue: Swift.Int {
    get
  }
}
extension IndexSet : Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible, Swift.CustomReflectable {
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
  public var customMirror: Swift.Mirror {
    get
  }
}
extension IndexSet {
  public static func == (lhs: Foundation.IndexSet, rhs: Foundation.IndexSet) -> Swift.Bool
}
extension IndexSet : Swift._ObjectiveCBridgeable {
  public static func _getObjectiveCType() -> Any.Type
  @_semantics("convertToObjectiveC") public func _bridgeToObjectiveC() -> Foundation.NSIndexSet
  public static func _forceBridgeFromObjectiveC(_ x: Foundation.NSIndexSet, result: inout Foundation.IndexSet?)
  public static func _conditionallyBridgeFromObjectiveC(_ x: Foundation.NSIndexSet, result: inout Foundation.IndexSet?) -> Swift.Bool
  @_effects(readonly) public static func _unconditionallyBridgeFromObjectiveC(_ source: Foundation.NSIndexSet?) -> Foundation.IndexSet
  public typealias _ObjectiveCType = Foundation.NSIndexSet
}
extension NSIndexSet : Swift._HasCustomAnyHashableRepresentation {
  @nonobjc public func _toCustomAnyHashable() -> Swift.AnyHashable?
}
extension IndexSet : Swift.Codable {
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
public struct NSFastEnumerationIterator : Swift.IteratorProtocol {
  public init(_ enumerable: Foundation.NSFastEnumeration)
  public mutating func next() -> Any?
  public typealias Element = Any
}
extension NSEnumerator : Swift.Sequence {
  public func makeIterator() -> Foundation.NSFastEnumerationIterator
  public typealias Element = Any
  public typealias Iterator = Foundation.NSFastEnumerationIterator
}
extension NSTextCheckingResult.CheckingType {
  public static var allSystemTypes: Foundation.NSTextCheckingResult.CheckingType {
    get
  }
  public static var allCustomTypes: Foundation.NSTextCheckingResult.CheckingType {
    get
  }
  public static var allTypes: Foundation.NSTextCheckingResult.CheckingType {
    get
  }
}
extension NSDictionary : Swift.ExpressibleByDictionaryLiteral {
  required convenience public init(dictionaryLiteral elements: (Any, Any)...)
  public typealias Key = Any
  public typealias Value = Any
}
extension Dictionary : Swift._ObjectiveCBridgeable {
  @_semantics("convertToObjectiveC") public func _bridgeToObjectiveC() -> Foundation.NSDictionary
  @_specialize(exported: false, kind: full, where Key == Swift.String, Value == Any)
  public static func _forceBridgeFromObjectiveC(_ d: Foundation.NSDictionary, result: inout Swift.Dictionary<Key, Value>?)
  @_specialize(exported: false, kind: full, where Key == Swift.String, Value == Any)
  public static func _conditionallyBridgeFromObjectiveC(_ x: Foundation.NSDictionary, result: inout Swift.Dictionary<Key, Value>?) -> Swift.Bool
  @_effects(readonly) public static func _unconditionallyBridgeFromObjectiveC(_ d: Foundation.NSDictionary?) -> Swift.Dictionary<Key, Value>
  public typealias _ObjectiveCType = Foundation.NSDictionary
}
extension NSDictionary : Swift._HasCustomAnyHashableRepresentation {
  @nonobjc public func _toCustomAnyHashable() -> Swift.AnyHashable?
}
extension NSDictionary : Swift.Sequence {
  @_hasMissingDesignatedInitializers @_objcRuntimeName(_TtCE10FoundationCSo12NSDictionary9_Iterator) final public class Iterator : Swift.IteratorProtocol {
    final public func next() -> (key: Any, value: Any)?
    public typealias Element = (key: Any, value: Any)
    @objc deinit
  }
  @objc dynamic public subscript(key: Any) -> Any? {
    @objc(__swift_objectForKeyedSubscript:) get
  }
  public func makeIterator() -> Foundation.NSDictionary.Iterator
  public typealias Element = (key: Any, value: Any)
}
extension NSMutableDictionary {
  @objc override dynamic public subscript(key: Any) -> Any? {
    @objc(__swift_objectForKeyedSubscript:) get
    @objc(__swift_setObject:forKeyedSubscript:) set
  }
}
extension NSDictionary {
  @objc(__swiftInitWithDictionary_NSDictionary:) convenience dynamic public init(dictionary otherDictionary: __shared Foundation.NSDictionary)
}
extension NSDictionary : Swift.CustomReflectable {
  public var customMirror: Swift.Mirror {
    get
  }
}
extension Dictionary : Swift.CVarArg {
}
extension NSObject : Swift.CustomStringConvertible {
}
extension NSObject : Swift.CustomDebugStringConvertible {
}
public let NSNotFound: Swift.Int
public func NSLocalizedString(_ key: Swift.String, tableName: Swift.String? = nil, bundle: Foundation.Bundle = Bundle.main, value: Swift.String = "", comment: Swift.String) -> Swift.String
public func NSLog(_ format: Swift.String, _ args: Swift.CVarArg...)
extension AnyHashable : Swift._ObjectiveCBridgeable {
  public func _bridgeToObjectiveC() -> ObjectiveC.NSObject
  public static func _forceBridgeFromObjectiveC(_ x: ObjectiveC.NSObject, result: inout Swift.AnyHashable?)
  public static func _conditionallyBridgeFromObjectiveC(_ x: ObjectiveC.NSObject, result: inout Swift.AnyHashable?) -> Swift.Bool
  @_effects(readonly) public static func _unconditionallyBridgeFromObjectiveC(_ source: ObjectiveC.NSObject?) -> Swift.AnyHashable
  public typealias _ObjectiveCType = ObjectiveC.NSObject
}
extension CVarArg where Self : Swift._ObjectiveCBridgeable {
  public var _cVarArgEncoding: [Swift.Int] {
    get
  }
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Timer {
  public static func publish(every interval: Foundation.TimeInterval, tolerance: Foundation.TimeInterval? = nil, on runLoop: Foundation.RunLoop, in mode: Foundation.RunLoop.Mode, options: Foundation.RunLoop.SchedulerOptions? = nil) -> Foundation.Timer.TimerPublisher
  final public class TimerPublisher : Combine.ConnectablePublisher {
    public typealias Output = Foundation.Date
    public typealias Failure = Swift.Never
    final public let interval: Foundation.TimeInterval
    final public let tolerance: Foundation.TimeInterval?
    final public let runLoop: Foundation.RunLoop
    final public let mode: Foundation.RunLoop.Mode
    final public let options: Foundation.RunLoop.SchedulerOptions?
    public init(interval: Foundation.TimeInterval, tolerance: Foundation.TimeInterval? = nil, runLoop: Foundation.RunLoop, mode: Foundation.RunLoop.Mode, options: Foundation.RunLoop.SchedulerOptions? = nil)
    @objc deinit
    final public func connect() -> Combine.Cancellable
    final public func receive<S>(subscriber: S) where S : Combine.Subscriber, S.Failure == Foundation.Timer.TimerPublisher.Failure, S.Input == Foundation.Timer.TimerPublisher.Output
  }
}
@available(macOS 10.13, iOS 11.0, watchOS 4.0, tvOS 11.0, *)
extension NSItemProvider {
  @available(macOS 10.13, iOS 11.0, watchOS 4.0, tvOS 11.0, *)
  public func registerObject<T>(ofClass: T.Type, visibility: Foundation.NSItemProviderRepresentationVisibility, loadHandler: @escaping ((T?, Swift.Error?) -> Swift.Void) -> Foundation.Progress?) where T : Swift._ObjectiveCBridgeable, T._ObjectiveCType : Foundation.NSItemProviderWriting
  @available(macOS 10.13, iOS 11.0, watchOS 4.0, tvOS 11.0, *)
  public func canLoadObject<T>(ofClass: T.Type) -> Swift.Bool where T : Swift._ObjectiveCBridgeable, T._ObjectiveCType : Foundation.NSItemProviderReading
  @available(macOS 10.13, iOS 11.0, watchOS 4.0, tvOS 11.0, *)
  public func loadObject<T>(ofClass: T.Type, completionHandler: @escaping (T?, Swift.Error?) -> Swift.Void) -> Foundation.Progress where T : Swift._ObjectiveCBridgeable, T._ObjectiveCType : Foundation.NSItemProviderReading
}
extension NSArray : Swift.ExpressibleByArrayLiteral {
  required convenience public init(arrayLiteral elements: Any...)
  public typealias ArrayLiteralElement = Any
}
extension Array : Swift._ObjectiveCBridgeable {
  @_semantics("convertToObjectiveC") public func _bridgeToObjectiveC() -> Foundation.NSArray
  public static func _forceBridgeFromObjectiveC(_ source: Foundation.NSArray, result: inout Swift.Array<Element>?)
  public static func _conditionallyBridgeFromObjectiveC(_ source: Foundation.NSArray, result: inout Swift.Array<Element>?) -> Swift.Bool
  @_effects(readonly) public static func _unconditionallyBridgeFromObjectiveC(_ source: Foundation.NSArray?) -> Swift.Array<Element>
  public typealias _ObjectiveCType = Foundation.NSArray
}
extension NSArray : Swift._HasCustomAnyHashableRepresentation {
  @nonobjc public func _toCustomAnyHashable() -> Swift.AnyHashable?
}
extension NSArray : Swift.Sequence {
  final public func makeIterator() -> Foundation.NSFastEnumerationIterator
  public typealias Element = Any
  public typealias Iterator = Foundation.NSFastEnumerationIterator
}
extension NSArray {
  convenience public init(objects elements: Any...)
}
extension NSArray {
  @nonobjc convenience public init(array anArray: __shared Foundation.NSArray)
}
extension NSArray : Swift.CustomReflectable {
  public var customMirror: Swift.Mirror {
    get
  }
}
extension Array : Swift.CVarArg {
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension NotificationCenter {
  public func publisher(for name: Foundation.Notification.Name, object: Swift.AnyObject? = nil) -> Foundation.NotificationCenter.Publisher
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension NotificationCenter {
  public struct Publisher : Combine.Publisher {
    public typealias Output = Foundation.Notification
    public typealias Failure = Swift.Never
    public let center: Foundation.NotificationCenter
    public let name: Foundation.Notification.Name
    public let object: Swift.AnyObject?
    public init(center: Foundation.NotificationCenter, name: Foundation.Notification.Name, object: Swift.AnyObject? = nil)
    public func receive<S>(subscriber: S) where S : Combine.Subscriber, S.Failure == Foundation.NotificationCenter.Publisher.Failure, S.Input == Foundation.NotificationCenter.Publisher.Output
  }
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension NotificationCenter.Publisher : Swift.Equatable {
  public static func == (lhs: Foundation.NotificationCenter.Publisher, rhs: Foundation.NotificationCenter.Publisher) -> Swift.Bool
}
@_objcRuntimeName(_TtC10Foundation20_PropertyListEncoder) open class PropertyListEncoder {
  open var outputFormat: Foundation.PropertyListSerialization.PropertyListFormat
  open var userInfo: [Swift.CodingUserInfoKey : Any]
  public init()
  open func encode<Value>(_ value: Value) throws -> Foundation.Data where Value : Swift.Encodable
  @objc deinit
}
@_objcRuntimeName(_TtC10Foundation20_PropertyListDecoder) open class PropertyListDecoder {
  open var userInfo: [Swift.CodingUserInfoKey : Any]
  public init()
  open func decode<T>(_ type: T.Type, from data: Foundation.Data) throws -> T where T : Swift.Decodable
  open func decode<T>(_ type: T.Type, from data: Foundation.Data, format: inout Foundation.PropertyListSerialization.PropertyListFormat) throws -> T where T : Swift.Decodable
  @objc deinit
}
@_alwaysEmitIntoClient @inlinable internal func _withStackOrHeapBuffer(capacity: Swift.Int, _ body: (Swift.UnsafeMutableBufferPointer<Swift.UInt8>) -> Swift.Void) {
    guard capacity > 0 else {
        body(UnsafeMutableBufferPointer(start: nil, count: 0))
        return
    }
    typealias InlineBuffer = ( // 32 bytes
        UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8,
        UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8,
        UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8,
        UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8
    )
    let inlineCount = MemoryLayout<InlineBuffer>.size
    if capacity <= inlineCount {
        var buffer: InlineBuffer = (
            0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0
        )
        withUnsafeMutableBytes(of: &buffer) { buffer in
            assert(buffer.count == inlineCount)
            let start = buffer.baseAddress!.assumingMemoryBound(to: UInt8.self)
            body(UnsafeMutableBufferPointer(start: start, count: capacity))
        }
        return
    }

    let buffer = UnsafeMutableBufferPointer<UInt8>.allocate(capacity: capacity)
    defer { buffer.deallocate() }
    body(buffer)
}
@usableFromInline
final internal class __DataStorage {
  @usableFromInline
  internal static let maxSize: Swift.Int
  @usableFromInline
  internal static let vmOpsThreshold: Swift.Int
  @inlinable internal static func allocate(_ size: Swift.Int, _ clear: Swift.Bool) -> Swift.UnsafeMutableRawPointer? {
        if clear {
            return calloc(1, size)
        } else {
            return malloc(size)
        }
    }
  @usableFromInline
  internal static func move(_ dest_: Swift.UnsafeMutableRawPointer, _ source_: Swift.UnsafeRawPointer?, _ num_: Swift.Int)
  @inlinable internal static func shouldAllocateCleared(_ size: Swift.Int) -> Swift.Bool {
        return (size > (128 * 1024))
    }
  @usableFromInline
  final internal var _bytes: Swift.UnsafeMutableRawPointer?
  @usableFromInline
  final internal var _length: Swift.Int
  @usableFromInline
  final internal var _capacity: Swift.Int
  @usableFromInline
  final internal var _offset: Swift.Int
  @usableFromInline
  final internal var _deallocator: ((Swift.UnsafeMutableRawPointer, Swift.Int) -> Swift.Void)?
  @usableFromInline
  final internal var _needToZero: Swift.Bool
  @inlinable final internal var bytes: Swift.UnsafeRawPointer? {
    get {
        return UnsafeRawPointer(_bytes)?.advanced(by: -_offset)
    }
  }
  @discardableResult
  @inlinable final internal func withUnsafeBytes<Result>(in range: Swift.Range<Swift.Int>, apply: (Swift.UnsafeRawBufferPointer) throws -> Result) rethrows -> Result {
        return try apply(UnsafeRawBufferPointer(start: _bytes?.advanced(by: range.lowerBound - _offset), count: Swift.min(range.upperBound - range.lowerBound, _length)))
    }
  @discardableResult
  @inlinable final internal func withUnsafeMutableBytes<Result>(in range: Swift.Range<Swift.Int>, apply: (Swift.UnsafeMutableRawBufferPointer) throws -> Result) rethrows -> Result {
        return try apply(UnsafeMutableRawBufferPointer(start: _bytes!.advanced(by:range.lowerBound - _offset), count: Swift.min(range.upperBound - range.lowerBound, _length)))
    }
  @inlinable final internal var mutableBytes: Swift.UnsafeMutableRawPointer? {
    get {
        return _bytes?.advanced(by: -_offset)
    }
  }
  @inlinable final internal var capacity: Swift.Int {
    get {
        return _capacity
    }
  }
  @inlinable final internal var length: Swift.Int {
    get {
            return _length
        }
    set {
            setLength(newValue)
        }
  }
  @inlinable final internal var isExternallyOwned: Swift.Bool {
    get {
        // all __DataStorages will have some sort of capacity, because empty cases hit the .empty enum _Representation
        // anything with 0 capacity means that we have not allocated this pointer and concequently mutation is not ours to make.
        return _capacity == 0
    }
  }
  @usableFromInline
  final internal func ensureUniqueBufferReference(growingTo newLength: Swift.Int = 0, clear: Swift.Bool = false)
  @inlinable final internal func _freeBytes() {
        if let bytes = _bytes {
            if let dealloc = _deallocator {
                dealloc(bytes, length)
            } else {
                free(bytes)
            }
        }
        _deallocator = nil
    }
  @inlinable final internal func enumerateBytes(in range: Swift.Range<Swift.Int>, _ block: (Swift.UnsafeBufferPointer<Swift.UInt8>, Foundation.Data.Index, inout Swift.Bool) -> Swift.Void) {
        var stopv: Bool = false
        block(UnsafeBufferPointer<UInt8>(start: _bytes?.advanced(by: range.lowerBound - _offset).assumingMemoryBound(to: UInt8.self), count: Swift.min(range.upperBound - range.lowerBound, _length)), 0, &stopv)
    }
  @inlinable final internal func setLength(_ length: Swift.Int) {
        let origLength = _length
        let newLength = length
        if _capacity < newLength || _bytes == nil {
            ensureUniqueBufferReference(growingTo: newLength, clear: true)
        } else if origLength < newLength && _needToZero {
            memset(_bytes! + origLength, 0, newLength - origLength)
        } else if newLength < origLength {
            _needToZero = true
        }
        _length = newLength
    }
  @inlinable final internal func append(_ bytes: Swift.UnsafeRawPointer, length: Swift.Int) {
        precondition(length >= 0, "Length of appending bytes must not be negative")
        let origLength = _length
        let newLength = origLength + length
        if _capacity < newLength || _bytes == nil {
            ensureUniqueBufferReference(growingTo: newLength, clear: false)
        }
        _length = newLength
        __DataStorage.move(_bytes!.advanced(by: origLength), bytes, length)
    }
  @inlinable final internal func get(_ index: Swift.Int) -> Swift.UInt8 {
        return _bytes!.advanced(by: index - _offset).assumingMemoryBound(to: UInt8.self).pointee
    }
  @inlinable final internal func set(_ index: Swift.Int, to value: Swift.UInt8) {
        ensureUniqueBufferReference()
        _bytes!.advanced(by: index - _offset).assumingMemoryBound(to: UInt8.self).pointee = value
    }
  @inlinable final internal func copyBytes(to pointer: Swift.UnsafeMutableRawPointer, from range: Swift.Range<Swift.Int>) {
        let offsetPointer = UnsafeRawBufferPointer(start: _bytes?.advanced(by: range.lowerBound - _offset), count: Swift.min(range.upperBound - range.lowerBound, _length))
        UnsafeMutableRawBufferPointer(start: pointer, count: range.upperBound - range.lowerBound).copyMemory(from: offsetPointer)
    }
  @usableFromInline
  final internal func replaceBytes(in range_: Foundation.NSRange, with replacementBytes: Swift.UnsafeRawPointer?, length replacementLength: Swift.Int)
  @usableFromInline
  final internal func resetBytes(in range_: Swift.Range<Swift.Int>)
  @usableFromInline
  internal init(length: Swift.Int)
  @usableFromInline
  internal init(capacity capacity_: Swift.Int = 0)
  @usableFromInline
  internal init(bytes: Swift.UnsafeRawPointer?, length: Swift.Int)
  @usableFromInline
  internal init(bytes: Swift.UnsafeMutableRawPointer?, length: Swift.Int, copy: Swift.Bool, deallocator: ((Swift.UnsafeMutableRawPointer, Swift.Int) -> Swift.Void)?, offset: Swift.Int)
  @usableFromInline
  internal init(immutableReference: Foundation.NSData, offset: Swift.Int)
  @usableFromInline
  internal init(mutableReference: Foundation.NSMutableData, offset: Swift.Int)
  @usableFromInline
  internal init(customReference: Foundation.NSData, offset: Swift.Int)
  @usableFromInline
  internal init(customMutableReference: Foundation.NSMutableData, offset: Swift.Int)
  @objc deinit
  @inlinable final internal func mutableCopy(_ range: Swift.Range<Swift.Int>) -> Foundation.__DataStorage {
        return __DataStorage(bytes: _bytes?.advanced(by: range.lowerBound - _offset), length: range.upperBound - range.lowerBound, copy: true, deallocator: nil, offset: range.lowerBound)
    }
  @inlinable final internal func withInteriorPointerReference<T>(_ range: Swift.Range<Swift.Int>, _ work: (Foundation.NSData) throws -> T) rethrows -> T {
        if range.isEmpty {
            return try work(NSData()) // zero length data can be optimized as a singleton
        }
        return try work(NSData(bytesNoCopy: _bytes!.advanced(by: range.lowerBound - _offset), length: range.upperBound - range.lowerBound, freeWhenDone: false))
    }
  @usableFromInline
  @inline(never) final internal func bridgedReference(_ range: Swift.Range<Swift.Int>) -> Foundation.NSData
}
@frozen public struct Data : Foundation.ReferenceConvertible, Swift.Equatable, Swift.Hashable, Swift.RandomAccessCollection, Swift.MutableCollection, Swift.RangeReplaceableCollection, Foundation.MutableDataProtocol, Foundation.ContiguousBytes {
  public typealias ReferenceType = Foundation.NSData
  public typealias ReadingOptions = Foundation.NSData.ReadingOptions
  public typealias WritingOptions = Foundation.NSData.WritingOptions
  public typealias SearchOptions = Foundation.NSData.SearchOptions
  public typealias Base64EncodingOptions = Foundation.NSData.Base64EncodingOptions
  public typealias Base64DecodingOptions = Foundation.NSData.Base64DecodingOptions
  public typealias Index = Swift.Int
  public typealias Indices = Swift.Range<Swift.Int>
  @usableFromInline
  @frozen internal struct InlineData {
    @usableFromInline
    internal typealias Buffer = (Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8)
    @usableFromInline
    internal var bytes: Foundation.Data.InlineData.Buffer
    @usableFromInline
    internal var length: Swift.UInt8
    @inlinable internal static func canStore(count: Swift.Int) -> Swift.Bool {
            return count <= MemoryLayout<Buffer>.size
        }
    @inlinable internal init(_ srcBuffer: Swift.UnsafeRawBufferPointer) {
            self.init(count: srcBuffer.count)
            if !srcBuffer.isEmpty {
                Swift.withUnsafeMutableBytes(of: &bytes) { dstBuffer in
                    dstBuffer.baseAddress?.copyMemory(from: srcBuffer.baseAddress!, byteCount: srcBuffer.count)
                }
            }
        }
    @inlinable internal init(count: Swift.Int = 0) {
            assert(count <= MemoryLayout<Buffer>.size)
            bytes = (UInt8(0), UInt8(0), UInt8(0), UInt8(0), UInt8(0), UInt8(0), UInt8(0), UInt8(0), UInt8(0), UInt8(0), UInt8(0), UInt8(0), UInt8(0), UInt8(0))
            length = UInt8(count)
        }
    @inlinable internal init(_ slice: Foundation.Data.InlineSlice, count: Swift.Int) {
            self.init(count: count)
            Swift.withUnsafeMutableBytes(of: &bytes) { dstBuffer in
                slice.withUnsafeBytes { srcBuffer in
                    dstBuffer.copyMemory(from: UnsafeRawBufferPointer(start: srcBuffer.baseAddress, count: count))
                }
            }
        }
    @inlinable internal init(_ slice: Foundation.Data.LargeSlice, count: Swift.Int) {
            self.init(count: count)
            Swift.withUnsafeMutableBytes(of: &bytes) { dstBuffer in
                slice.withUnsafeBytes { srcBuffer in
                    dstBuffer.copyMemory(from: UnsafeRawBufferPointer(start: srcBuffer.baseAddress, count: count))
                }
            }
        }
    @inlinable internal var capacity: Swift.Int {
      get {
            return MemoryLayout<Buffer>.size
        }
    }
    @inlinable internal var count: Swift.Int {
      get {
                return Int(length)
            }
      set(newValue) {
                assert(newValue <= MemoryLayout<Buffer>.size)
                if newValue > length {
                    resetBytes(in: Int(length) ..< newValue) // Also extends length
                } else {
                    length = UInt8(newValue)
                }
            }
    }
    @inlinable internal var startIndex: Swift.Int {
      get {
            return 0
        }
    }
    @inlinable internal var endIndex: Swift.Int {
      get {
            return count
        }
    }
    @inlinable internal func withUnsafeBytes<Result>(_ apply: (Swift.UnsafeRawBufferPointer) throws -> Result) rethrows -> Result {
            let count = Int(length)
            return try Swift.withUnsafeBytes(of: bytes) { (rawBuffer) throws -> Result in
                return try apply(UnsafeRawBufferPointer(start: rawBuffer.baseAddress, count: count))
            }
        }
    @inlinable internal mutating func withUnsafeMutableBytes<Result>(_ apply: (Swift.UnsafeMutableRawBufferPointer) throws -> Result) rethrows -> Result {
            let count = Int(length)
            return try Swift.withUnsafeMutableBytes(of: &bytes) { (rawBuffer) throws -> Result in
                return try apply(UnsafeMutableRawBufferPointer(start: rawBuffer.baseAddress, count: count))
            }
        }
    @inlinable internal mutating func append(byte: Swift.UInt8) {
            let count = self.count
            assert(count + 1 <= MemoryLayout<Buffer>.size)
            Swift.withUnsafeMutableBytes(of: &bytes) { $0[count] = byte }
            self.length += 1
        }
    @inlinable internal mutating func append(contentsOf buffer: Swift.UnsafeRawBufferPointer) {
            guard !buffer.isEmpty else { return }
            assert(count + buffer.count <= MemoryLayout<Buffer>.size)
            let cnt = count
            _ = Swift.withUnsafeMutableBytes(of: &bytes) { rawBuffer in
                rawBuffer.baseAddress?.advanced(by: cnt).copyMemory(from: buffer.baseAddress!, byteCount: buffer.count)
            }

            length += UInt8(buffer.count)
        }
    @inlinable internal subscript(index: Foundation.Data.Index) -> Swift.UInt8 {
      get {
                assert(index <= MemoryLayout<Buffer>.size)
                precondition(index < length, "index \(index) is out of bounds of 0..<\(length)")
                return Swift.withUnsafeBytes(of: bytes) { rawBuffer -> UInt8 in
                    return rawBuffer[index]
                }
            }
      set(newValue) {
                assert(index <= MemoryLayout<Buffer>.size)
                precondition(index < length, "index \(index) is out of bounds of 0..<\(length)")
                Swift.withUnsafeMutableBytes(of: &bytes) { rawBuffer in
                    rawBuffer[index] = newValue
                }
            }
    }
    @inlinable internal mutating func resetBytes(in range: Swift.Range<Foundation.Data.Index>) {
            assert(range.lowerBound <= MemoryLayout<Buffer>.size)
            assert(range.upperBound <= MemoryLayout<Buffer>.size)
            precondition(range.lowerBound <= length, "index \(range.lowerBound) is out of bounds of 0..<\(length)")
            if length < range.upperBound {
                length = UInt8(range.upperBound)
            }

            let _ = Swift.withUnsafeMutableBytes(of: &bytes) { rawBuffer in
              memset(rawBuffer.baseAddress?.advanced(by: range.lowerBound), 0, range.upperBound - range.lowerBound)
            }
        }
    @usableFromInline
    internal mutating func replaceSubrange(_ subrange: Swift.Range<Foundation.Data.Index>, with replacementBytes: Swift.UnsafeRawPointer?, count replacementLength: Swift.Int)
    @inlinable internal func copyBytes(to pointer: Swift.UnsafeMutableRawPointer, from range: Swift.Range<Swift.Int>) {
            precondition(startIndex <= range.lowerBound, "index \(range.lowerBound) is out of bounds of \(startIndex)..<\(endIndex)")
            precondition(range.lowerBound <= endIndex, "index \(range.lowerBound) is out of bounds of \(startIndex)..<\(endIndex)")
            precondition(startIndex <= range.upperBound, "index \(range.upperBound) is out of bounds of \(startIndex)..<\(endIndex)")
            precondition(range.upperBound <= endIndex, "index \(range.upperBound) is out of bounds of \(startIndex)..<\(endIndex)")

            Swift.withUnsafeBytes(of: bytes) {
                let cnt = Swift.min($0.count, range.upperBound - range.lowerBound)
                guard cnt > 0 else { return }
                pointer.copyMemory(from: $0.baseAddress!.advanced(by: range.lowerBound), byteCount: cnt)
            }
        }
  }
  @usableFromInline
  internal typealias HalfInt = Swift.Int32
  @usableFromInline
  @frozen internal struct InlineSlice {
    @usableFromInline
    internal var slice: Swift.Range<Foundation.Data.HalfInt>
    @usableFromInline
    internal var storage: Foundation.__DataStorage
    @inlinable internal static func canStore(count: Swift.Int) -> Swift.Bool {
            return count < HalfInt.max
        }
    @inlinable internal init(_ buffer: Swift.UnsafeRawBufferPointer) {
            assert(buffer.count < HalfInt.max)
            self.init(__DataStorage(bytes: buffer.baseAddress, length: buffer.count), count: buffer.count)
        }
    @inlinable internal init(capacity: Swift.Int) {
            assert(capacity < HalfInt.max)
            self.init(__DataStorage(capacity: capacity), count: 0)
        }
    @inlinable internal init(count: Swift.Int) {
            assert(count < HalfInt.max)
            self.init(__DataStorage(length: count), count: count)
        }
    @inlinable internal init(_ inline: Foundation.Data.InlineData) {
            assert(inline.count < HalfInt.max)
            self.init(inline.withUnsafeBytes { return __DataStorage(bytes: $0.baseAddress, length: $0.count) }, count: inline.count)
        }
    @inlinable internal init(_ inline: Foundation.Data.InlineData, range: Swift.Range<Swift.Int>) {
            assert(range.lowerBound < HalfInt.max)
            assert(range.upperBound < HalfInt.max)
            self.init(inline.withUnsafeBytes { return __DataStorage(bytes: $0.baseAddress, length: $0.count) }, range: range)
        }
    @inlinable internal init(_ large: Foundation.Data.LargeSlice) {
            assert(large.range.lowerBound < HalfInt.max)
            assert(large.range.upperBound < HalfInt.max)
            self.init(large.storage, range: large.range)
        }
    @inlinable internal init(_ large: Foundation.Data.LargeSlice, range: Swift.Range<Swift.Int>) {
            assert(range.lowerBound < HalfInt.max)
            assert(range.upperBound < HalfInt.max)
            self.init(large.storage, range: range)
        }
    @inlinable internal init(_ storage: Foundation.__DataStorage, count: Swift.Int) {
            assert(count < HalfInt.max)
            self.storage = storage
            slice = 0..<HalfInt(count)
        }
    @inlinable internal init(_ storage: Foundation.__DataStorage, range: Swift.Range<Swift.Int>) {
            assert(range.lowerBound < HalfInt.max)
            assert(range.upperBound < HalfInt.max)
            self.storage = storage
            slice = HalfInt(range.lowerBound)..<HalfInt(range.upperBound)
        }
    @inlinable internal mutating func ensureUniqueReference() {
            if !isKnownUniquelyReferenced(&storage) {
                storage = storage.mutableCopy(self.range)
            }
        }
    @inlinable internal var startIndex: Swift.Int {
      get {
            return Int(slice.lowerBound)
        }
    }
    @inlinable internal var endIndex: Swift.Int {
      get {
            return Int(slice.upperBound)
        }
    }
    @inlinable internal var capacity: Swift.Int {
      get {
            return storage.capacity
        }
    }
    @inlinable internal mutating func reserveCapacity(_ minimumCapacity: Swift.Int) {
            ensureUniqueReference()
            // the current capacity can be zero (representing externally owned buffer), and count can be greater than the capacity
            storage.ensureUniqueBufferReference(growingTo: Swift.max(minimumCapacity, count))
        }
    @inlinable internal var count: Swift.Int {
      get {
                return Int(slice.upperBound - slice.lowerBound)
            }
      set(newValue) {
                assert(newValue < HalfInt.max)
                ensureUniqueReference()
                
                let difference = newValue - count
                if difference > 0 {
                    let additionalRange = Int(slice.upperBound) ..< Int(slice.upperBound) + difference
                    storage.resetBytes(in: additionalRange) // Also extends storage length
                } else {
                    storage.length += difference
                }
                slice = slice.lowerBound..<(slice.lowerBound + HalfInt(newValue))
            }
    }
    @inlinable internal var range: Swift.Range<Swift.Int> {
      get {
                return Int(slice.lowerBound)..<Int(slice.upperBound)
            }
      set(newValue) {
                assert(newValue.lowerBound < HalfInt.max)
                assert(newValue.upperBound < HalfInt.max)
                slice = HalfInt(newValue.lowerBound)..<HalfInt(newValue.upperBound)
            }
    }
    @inlinable internal func withUnsafeBytes<Result>(_ apply: (Swift.UnsafeRawBufferPointer) throws -> Result) rethrows -> Result {
            return try storage.withUnsafeBytes(in: range, apply: apply)
        }
    @inlinable internal mutating func withUnsafeMutableBytes<Result>(_ apply: (Swift.UnsafeMutableRawBufferPointer) throws -> Result) rethrows -> Result {
            ensureUniqueReference()
            return try storage.withUnsafeMutableBytes(in: range, apply: apply)
        }
    @inlinable internal mutating func append(contentsOf buffer: Swift.UnsafeRawBufferPointer) {
            assert(endIndex + buffer.count < HalfInt.max)
            ensureUniqueReference()
            storage.replaceBytes(in: NSRange(location: range.upperBound, length: storage.length - (range.upperBound - storage._offset)), with: buffer.baseAddress, length: buffer.count)
            slice = slice.lowerBound..<HalfInt(Int(slice.upperBound) + buffer.count)
        }
    @inlinable internal subscript(index: Foundation.Data.Index) -> Swift.UInt8 {
      get {
                assert(index < HalfInt.max)
                precondition(startIndex <= index, "index \(index) is out of bounds of \(startIndex)..<\(endIndex)")
                precondition(index < endIndex, "index \(index) is out of bounds of \(startIndex)..<\(endIndex)")
                return storage.get(index)
            }
      set(newValue) {
                assert(index < HalfInt.max)
                precondition(startIndex <= index, "index \(index) is out of bounds of \(startIndex)..<\(endIndex)")
                precondition(index < endIndex, "index \(index) is out of bounds of \(startIndex)..<\(endIndex)")
                ensureUniqueReference()
                storage.set(index, to: newValue)
            }
    }
    @inlinable internal func bridgedReference() -> Foundation.NSData {
            return storage.bridgedReference(self.range)
        }
    @inlinable internal mutating func resetBytes(in range: Swift.Range<Foundation.Data.Index>) {
            assert(range.lowerBound < HalfInt.max)
            assert(range.upperBound < HalfInt.max)
            precondition(range.lowerBound <= endIndex, "index \(range.lowerBound) is out of bounds of \(startIndex)..<\(endIndex)")
            ensureUniqueReference()
            storage.resetBytes(in: range)
            if slice.upperBound < range.upperBound {
                slice = slice.lowerBound..<HalfInt(range.upperBound)
            }
        }
    @inlinable internal mutating func replaceSubrange(_ subrange: Swift.Range<Foundation.Data.Index>, with bytes: Swift.UnsafeRawPointer?, count cnt: Swift.Int) {
            precondition(startIndex <= subrange.lowerBound, "index \(subrange.lowerBound) is out of bounds of \(startIndex)..<\(endIndex)")
            precondition(subrange.lowerBound <= endIndex, "index \(subrange.lowerBound) is out of bounds of \(startIndex)..<\(endIndex)")
            precondition(startIndex <= subrange.upperBound, "index \(subrange.upperBound) is out of bounds of \(startIndex)..<\(endIndex)")
            precondition(subrange.upperBound <= endIndex, "index \(subrange.upperBound) is out of bounds of \(startIndex)..<\(endIndex)")

            let nsRange = NSRange(location: subrange.lowerBound, length: subrange.upperBound - subrange.lowerBound)
            ensureUniqueReference()
            let upper = range.upperBound
            storage.replaceBytes(in: nsRange, with: bytes, length: cnt)
            let resultingUpper = upper - nsRange.length + cnt
            slice = slice.lowerBound..<HalfInt(resultingUpper)
        }
    @inlinable internal func copyBytes(to pointer: Swift.UnsafeMutableRawPointer, from range: Swift.Range<Swift.Int>) {
            precondition(startIndex <= range.lowerBound, "index \(range.lowerBound) is out of bounds of \(startIndex)..<\(endIndex)")
            precondition(range.lowerBound <= endIndex, "index \(range.lowerBound) is out of bounds of \(startIndex)..<\(endIndex)")
            precondition(startIndex <= range.upperBound, "index \(range.upperBound) is out of bounds of \(startIndex)..<\(endIndex)")
            precondition(range.upperBound <= endIndex, "index \(range.upperBound) is out of bounds of \(startIndex)..<\(endIndex)")
            storage.copyBytes(to: pointer, from: range)
        }
  }
  @usableFromInline
  @_fixed_layout final internal class RangeReference {
    @usableFromInline
    final internal var range: Swift.Range<Swift.Int>
    @inlinable @inline(__always) final internal var lowerBound: Swift.Int {
      get {
            return range.lowerBound
        }
    }
    @inlinable @inline(__always) final internal var upperBound: Swift.Int {
      get {
            return range.upperBound
        }
    }
    @inlinable @inline(__always) final internal var count: Swift.Int {
      get {
            return range.upperBound - range.lowerBound
        }
    }
    @inlinable @inline(__always) internal init(_ range: Swift.Range<Swift.Int>) {
            self.range = range
        }
    @objc @usableFromInline
    deinit
  }
  @usableFromInline
  @frozen internal struct LargeSlice {
    @usableFromInline
    internal var slice: Foundation.Data.RangeReference
    @usableFromInline
    internal var storage: Foundation.__DataStorage
    @inlinable internal init(_ buffer: Swift.UnsafeRawBufferPointer) {
            self.init(__DataStorage(bytes: buffer.baseAddress, length: buffer.count), count: buffer.count)
        }
    @inlinable internal init(capacity: Swift.Int) {
            self.init(__DataStorage(capacity: capacity), count: 0)
        }
    @inlinable internal init(count: Swift.Int) {
            self.init(__DataStorage(length: count), count: count)
        }
    @inlinable internal init(_ inline: Foundation.Data.InlineData) {
            let storage = inline.withUnsafeBytes { return __DataStorage(bytes: $0.baseAddress, length: $0.count) }
            self.init(storage, count: inline.count)
        }
    @inlinable internal init(_ slice: Foundation.Data.InlineSlice) {
            self.storage = slice.storage
            self.slice = RangeReference(slice.range)
        }
    @inlinable internal init(_ storage: Foundation.__DataStorage, count: Swift.Int) {
            self.storage = storage
            self.slice = RangeReference(0..<count)
        }
    @inlinable internal mutating func ensureUniqueReference() {
            if !isKnownUniquelyReferenced(&storage) {
                storage = storage.mutableCopy(range)
            }
            if !isKnownUniquelyReferenced(&slice) {
                slice = RangeReference(range)
            }
        }
    @inlinable internal var startIndex: Swift.Int {
      get {
            return slice.range.lowerBound
        }
    }
    @inlinable internal var endIndex: Swift.Int {
      get {
          return slice.range.upperBound
        }
    }
    @inlinable internal var capacity: Swift.Int {
      get {
            return storage.capacity
        }
    }
    @inlinable internal mutating func reserveCapacity(_ minimumCapacity: Swift.Int) {
            ensureUniqueReference()
            // the current capacity can be zero (representing externally owned buffer), and count can be greater than the capacity
            storage.ensureUniqueBufferReference(growingTo: Swift.max(minimumCapacity, count))
        }
    @inlinable internal var count: Swift.Int {
      get {
                return slice.count
            }
      set(newValue) {
                ensureUniqueReference()
                let difference = newValue - count
                if difference > 0 {
                    let additionalRange = Int(slice.upperBound) ..< Int(slice.upperBound) + difference
                    storage.resetBytes(in: additionalRange) // Already sets the length
                } else {
                    storage.length += difference
                }
                slice.range = slice.range.lowerBound..<(slice.range.lowerBound + newValue)
            }
    }
    @inlinable internal var range: Swift.Range<Swift.Int> {
      get {
            return slice.range
        }
    }
    @inlinable internal func withUnsafeBytes<Result>(_ apply: (Swift.UnsafeRawBufferPointer) throws -> Result) rethrows -> Result {
            return try storage.withUnsafeBytes(in: range, apply: apply)
        }
    @inlinable internal mutating func withUnsafeMutableBytes<Result>(_ apply: (Swift.UnsafeMutableRawBufferPointer) throws -> Result) rethrows -> Result {
            ensureUniqueReference()
            return try storage.withUnsafeMutableBytes(in: range, apply: apply)
        }
    @inlinable internal mutating func append(contentsOf buffer: Swift.UnsafeRawBufferPointer) {
            ensureUniqueReference()
            storage.replaceBytes(in: NSRange(location: range.upperBound, length: storage.length - (range.upperBound - storage._offset)), with: buffer.baseAddress, length: buffer.count)
            slice.range = slice.range.lowerBound..<slice.range.upperBound + buffer.count
        }
    @inlinable internal subscript(index: Foundation.Data.Index) -> Swift.UInt8 {
      get {
                precondition(startIndex <= index, "index \(index) is out of bounds of \(startIndex)..<\(endIndex)")
                precondition(index < endIndex, "index \(index) is out of bounds of \(startIndex)..<\(endIndex)")
                return storage.get(index)
            }
      set(newValue) {
                precondition(startIndex <= index, "index \(index) is out of bounds of \(startIndex)..<\(endIndex)")
                precondition(index < endIndex, "index \(index) is out of bounds of \(startIndex)..<\(endIndex)")
                ensureUniqueReference()
                storage.set(index, to: newValue)
            }
    }
    @inlinable internal func bridgedReference() -> Foundation.NSData {
            return storage.bridgedReference(self.range)
        }
    @inlinable internal mutating func resetBytes(in range: Swift.Range<Swift.Int>) {
            precondition(range.lowerBound <= endIndex, "index \(range.lowerBound) is out of bounds of \(startIndex)..<\(endIndex)")
            ensureUniqueReference()
            storage.resetBytes(in: range)
            if slice.range.upperBound < range.upperBound {
                slice.range = slice.range.lowerBound..<range.upperBound
            }
        }
    @inlinable internal mutating func replaceSubrange(_ subrange: Swift.Range<Foundation.Data.Index>, with bytes: Swift.UnsafeRawPointer?, count cnt: Swift.Int) {
            precondition(startIndex <= subrange.lowerBound, "index \(subrange.lowerBound) is out of bounds of \(startIndex)..<\(endIndex)")
            precondition(subrange.lowerBound <= endIndex, "index \(subrange.lowerBound) is out of bounds of \(startIndex)..<\(endIndex)")
            precondition(startIndex <= subrange.upperBound, "index \(subrange.upperBound) is out of bounds of \(startIndex)..<\(endIndex)")
            precondition(subrange.upperBound <= endIndex, "index \(subrange.upperBound) is out of bounds of \(startIndex)..<\(endIndex)")

            let nsRange = NSRange(location: subrange.lowerBound, length: subrange.upperBound - subrange.lowerBound)
            ensureUniqueReference()
            let upper = range.upperBound
            storage.replaceBytes(in: nsRange, with: bytes, length: cnt)
            let resultingUpper = upper - nsRange.length + cnt
            slice.range = slice.range.lowerBound..<resultingUpper
        }
    @inlinable internal func copyBytes(to pointer: Swift.UnsafeMutableRawPointer, from range: Swift.Range<Swift.Int>) {
            precondition(startIndex <= range.lowerBound, "index \(range.lowerBound) is out of bounds of \(startIndex)..<\(endIndex)")
            precondition(range.lowerBound <= endIndex, "index \(range.lowerBound) is out of bounds of \(startIndex)..<\(endIndex)")
            precondition(startIndex <= range.upperBound, "index \(range.upperBound) is out of bounds of \(startIndex)..<\(endIndex)")
            precondition(range.upperBound <= endIndex, "index \(range.upperBound) is out of bounds of \(startIndex)..<\(endIndex)")
            storage.copyBytes(to: pointer, from: range)
        }
  }
  @usableFromInline
  @frozen internal enum _Representation {
    case empty
    case inline(Foundation.Data.InlineData)
    case slice(Foundation.Data.InlineSlice)
    case large(Foundation.Data.LargeSlice)
    @inlinable internal init(_ buffer: Swift.UnsafeRawBufferPointer) {
            if buffer.isEmpty {
                self = .empty
            } else if InlineData.canStore(count: buffer.count) {
                self = .inline(InlineData(buffer))
            } else if InlineSlice.canStore(count: buffer.count) {
                self = .slice(InlineSlice(buffer))
            } else {
                self = .large(LargeSlice(buffer))
            }
        }
    @inlinable internal init(_ buffer: Swift.UnsafeRawBufferPointer, owner: Swift.AnyObject) {
            if buffer.isEmpty {
                self = .empty
            } else if InlineData.canStore(count: buffer.count) {
                self = .inline(InlineData(buffer))
            } else {
                let count = buffer.count
                let storage = __DataStorage(bytes: UnsafeMutableRawPointer(mutating: buffer.baseAddress), length: count, copy: false, deallocator: { _, _ in
                    _fixLifetime(owner)
                }, offset: 0)
                if InlineSlice.canStore(count: count) {
                    self = .slice(InlineSlice(storage, count: count))
                } else {
                    self = .large(LargeSlice(storage, count: count))
                }
            }
        }
    @inlinable internal init(capacity: Swift.Int) {
            if capacity == 0 {
                self = .empty
            } else if InlineData.canStore(count: capacity) {
                self = .inline(InlineData())
            } else if InlineSlice.canStore(count: capacity) {
                self = .slice(InlineSlice(capacity: capacity))
            } else {
                self = .large(LargeSlice(capacity: capacity))
            }
        }
    @inlinable internal init(count: Swift.Int) {
            if count == 0 {
                self = .empty
            } else if InlineData.canStore(count: count) {
                self = .inline(InlineData(count: count))
            } else if InlineSlice.canStore(count: count) {
                self = .slice(InlineSlice(count: count))
            } else {
                self = .large(LargeSlice(count: count))
            }
        }
    @inlinable internal init(_ storage: Foundation.__DataStorage, count: Swift.Int) {
            if count == 0 {
                self = .empty
            } else if InlineData.canStore(count: count) {
                self = .inline(storage.withUnsafeBytes(in: 0..<count) { InlineData($0) })
            } else if InlineSlice.canStore(count: count) {
                self = .slice(InlineSlice(storage, count: count))
            } else {
                self = .large(LargeSlice(storage, count: count))
            }
        }
    @usableFromInline
    internal mutating func reserveCapacity(_ minimumCapacity: Swift.Int)
    @inlinable internal var count: Swift.Int {
      get {
                switch self {
                case .empty: return 0
                case .inline(let inline): return inline.count
                case .slice(let slice): return slice.count
                case .large(let slice): return slice.count
                }
            }
      set(newValue) {
                // HACK: The definition of this inline function takes an inout reference to self, giving the optimizer a unique referencing guarantee.
                //       This allows us to avoid excessive retain-release traffic around modifying enum values, and inlining the function then avoids the additional frame.
                @inline(__always)
                func apply(_ representation: inout _Representation, _ newValue: Int) -> _Representation? {
                    switch representation {
                    case .empty:
                        if newValue == 0 {
                            return nil
                        } else if InlineData.canStore(count: newValue) {
                            return .inline(InlineData(count: newValue))
                        } else if InlineSlice.canStore(count: newValue) {
                            return .slice(InlineSlice(count: newValue))
                        } else {
                            return .large(LargeSlice(count: newValue))
                        }
                    case .inline(var inline):
                        if newValue == 0 {
                            return .empty
                        } else if InlineData.canStore(count: newValue) {
                            guard inline.count != newValue else { return nil }
                            inline.count = newValue
                            return .inline(inline)
                        } else if InlineSlice.canStore(count: newValue) {
                            var slice = InlineSlice(inline)
                            slice.count = newValue
                            return .slice(slice)
                        } else {
                            var slice = LargeSlice(inline)
                            slice.count = newValue
                            return .large(slice)
                        }
                    case .slice(var slice):
                        if newValue == 0 && slice.startIndex == 0 {
                            return .empty
                        } else if slice.startIndex == 0 && InlineData.canStore(count: newValue) {
                            return .inline(InlineData(slice, count: newValue))
                        } else if InlineSlice.canStore(count: newValue + slice.startIndex) {
                            guard slice.count != newValue else { return nil }
                            representation = .empty // TODO: remove this when mgottesman lands optimizations
                            slice.count = newValue
                            return .slice(slice)
                        } else {
                            var newSlice = LargeSlice(slice)
                            newSlice.count = newValue
                            return .large(newSlice)
                        }
                    case .large(var slice):
                        if newValue == 0 && slice.startIndex == 0 {
                            return .empty
                        } else if slice.startIndex == 0 && InlineData.canStore(count: newValue) {
                            return .inline(InlineData(slice, count: newValue))
                        } else {
                            guard slice.count != newValue else { return nil}
                            representation = .empty // TODO: remove this when mgottesman lands optimizations
                            slice.count = newValue
                            return .large(slice)
                        }
                    }
                }

                if let rep = apply(&self, newValue) {
                    self = rep
                }
            }
    }
    @inlinable internal func withUnsafeBytes<Result>(_ apply: (Swift.UnsafeRawBufferPointer) throws -> Result) rethrows -> Result {
            switch self {
            case .empty:
                let empty = InlineData()
                return try empty.withUnsafeBytes(apply)
            case .inline(let inline):
                return try inline.withUnsafeBytes(apply)
            case .slice(let slice):
                return try slice.withUnsafeBytes(apply)
            case .large(let slice):
                return try slice.withUnsafeBytes(apply)
            }
        }
    @inlinable internal mutating func withUnsafeMutableBytes<Result>(_ apply: (Swift.UnsafeMutableRawBufferPointer) throws -> Result) rethrows -> Result {
            switch self {
            case .empty:
                var empty = InlineData()
                return try empty.withUnsafeMutableBytes(apply)
            case .inline(var inline):
                defer { self = .inline(inline) }
                return try inline.withUnsafeMutableBytes(apply)
            case .slice(var slice):
                self = .empty
                defer { self = .slice(slice) }
                return try slice.withUnsafeMutableBytes(apply)
            case .large(var slice):
                self = .empty
                defer { self = .large(slice) }
                return try slice.withUnsafeMutableBytes(apply)
            }
        }
    @inlinable internal func withInteriorPointerReference<T>(_ work: (Foundation.NSData) throws -> T) rethrows -> T {
            switch self {
            case .empty:
                return try work(NSData())
            case .inline(let inline):
                return try inline.withUnsafeBytes {
                    return try work(NSData(bytesNoCopy: UnsafeMutableRawPointer(mutating: $0.baseAddress ?? UnsafeRawPointer(bitPattern: 0xBAD0)!), length: $0.count, freeWhenDone: false))
                }
            case .slice(let slice):
                return try slice.storage.withInteriorPointerReference(slice.range, work)
            case .large(let slice):
                return try slice.storage.withInteriorPointerReference(slice.range, work)
            }
        }
    @usableFromInline
    internal func enumerateBytes(_ block: (Swift.UnsafeBufferPointer<Swift.UInt8>, Foundation.Data.Index, inout Swift.Bool) -> Swift.Void)
    @inlinable internal mutating func append(contentsOf buffer: Swift.UnsafeRawBufferPointer) {
            switch self {
            case .empty:
                self = _Representation(buffer)
            case .inline(var inline):
                if InlineData.canStore(count: inline.count + buffer.count) {
                    inline.append(contentsOf: buffer)
                    self = .inline(inline)
                } else if InlineSlice.canStore(count: inline.count + buffer.count) {
                    var newSlice = InlineSlice(inline)
                    newSlice.append(contentsOf: buffer)
                    self = .slice(newSlice)
                } else {
                    var newSlice = LargeSlice(inline)
                    newSlice.append(contentsOf: buffer)
                    self = .large(newSlice)
                }
            case .slice(var slice):
                if InlineSlice.canStore(count: slice.range.upperBound + buffer.count) {
                    self = .empty
                    defer { self = .slice(slice) }
                    slice.append(contentsOf: buffer)
                } else {
                    self = .empty
                    var newSlice = LargeSlice(slice)
                    newSlice.append(contentsOf: buffer)
                    self = .large(newSlice)
                }
            case .large(var slice):
                self = .empty
                defer { self = .large(slice) }
                slice.append(contentsOf: buffer)
            }
        }
    @inlinable internal mutating func resetBytes(in range: Swift.Range<Foundation.Data.Index>) {
            switch self {
            case .empty:
                if range.upperBound == 0 {
                    self = .empty
                } else if InlineData.canStore(count: range.upperBound) {
                    precondition(range.lowerBound <= endIndex, "index \(range.lowerBound) is out of bounds of \(startIndex)..<\(endIndex)")
                    self = .inline(InlineData(count: range.upperBound))
                } else if InlineSlice.canStore(count: range.upperBound) {
                    precondition(range.lowerBound <= endIndex, "index \(range.lowerBound) is out of bounds of \(startIndex)..<\(endIndex)")
                    self = .slice(InlineSlice(count: range.upperBound))
                } else {
                    precondition(range.lowerBound <= endIndex, "index \(range.lowerBound) is out of bounds of \(startIndex)..<\(endIndex)")
                    self = .large(LargeSlice(count: range.upperBound))
                }
            case .inline(var inline):
                if inline.count < range.upperBound {
                    if InlineSlice.canStore(count: range.upperBound) {
                        var slice = InlineSlice(inline)
                        slice.resetBytes(in: range)
                        self = .slice(slice)
                    } else {
                        var slice = LargeSlice(inline)
                        slice.resetBytes(in: range)
                        self = .large(slice)
                    }
                } else {
                    inline.resetBytes(in: range)
                    self = .inline(inline)
                }
            case .slice(var slice):
                if InlineSlice.canStore(count: range.upperBound) {
                    self = .empty
                    slice.resetBytes(in: range)
                    self = .slice(slice)
                } else {
                    self = .empty
                    var newSlice = LargeSlice(slice)
                    newSlice.resetBytes(in: range)
                    self = .large(newSlice)
                }
            case .large(var slice):
                self = .empty
                slice.resetBytes(in: range)
                self = .large(slice)
            }
        }
    @usableFromInline
    internal mutating func replaceSubrange(_ subrange: Swift.Range<Foundation.Data.Index>, with bytes: Swift.UnsafeRawPointer?, count cnt: Swift.Int)
    @inlinable internal subscript(index: Foundation.Data.Index) -> Swift.UInt8 {
      get {
                switch self {
                case .empty: preconditionFailure("index \(index) out of range of 0")
                case .inline(let inline): return inline[index]
                case .slice(let slice): return slice[index]
                case .large(let slice): return slice[index]
                }
            }
      set(newValue) {
                switch self {
                case .empty: preconditionFailure("index \(index) out of range of 0")
                case .inline(var inline):
                    inline[index] = newValue
                    self = .inline(inline)
                case .slice(var slice):
                    self = .empty
                    slice[index] = newValue
                    self = .slice(slice)
                case .large(var slice):
                    self = .empty
                    slice[index] = newValue
                    self = .large(slice)
                }
            }
    }
    @inlinable internal subscript(bounds: Swift.Range<Foundation.Data.Index>) -> Foundation.Data {
      get {
                switch self {
                case .empty:
                    precondition(bounds.lowerBound == 0 && (bounds.upperBound - bounds.lowerBound) == 0, "Range \(bounds) out of bounds 0..<0")
                    return Data()
                case .inline(let inline):
                    precondition(bounds.upperBound <= inline.count, "Range \(bounds) out of bounds 0..<\(inline.count)")
                    if bounds.lowerBound == 0 {
                        var newInline = inline
                        newInline.count = bounds.upperBound
                        return Data(representation: .inline(newInline))
                    } else {
                        return Data(representation: .slice(InlineSlice(inline, range: bounds)))
                    }
                case .slice(let slice):
                    precondition(slice.startIndex <= bounds.lowerBound, "Range \(bounds) out of bounds \(slice.range)")
                    precondition(bounds.lowerBound <= slice.endIndex, "Range \(bounds) out of bounds \(slice.range)")
                    precondition(slice.startIndex <= bounds.upperBound, "Range \(bounds) out of bounds \(slice.range)")
                    precondition(bounds.upperBound <= slice.endIndex, "Range \(bounds) out of bounds \(slice.range)")
                    if bounds.lowerBound == 0 && bounds.upperBound == 0 {
                        return Data()
                    } else if bounds.lowerBound == 0 && InlineData.canStore(count: bounds.count) {
                        return Data(representation: .inline(InlineData(slice, count: bounds.count)))
                    } else {
                        var newSlice = slice
                        newSlice.range = bounds
                        return Data(representation: .slice(newSlice))
                    }
                case .large(let slice):
                    precondition(slice.startIndex <= bounds.lowerBound, "Range \(bounds) out of bounds \(slice.range)")
                    precondition(bounds.lowerBound <= slice.endIndex, "Range \(bounds) out of bounds \(slice.range)")
                    precondition(slice.startIndex <= bounds.upperBound, "Range \(bounds) out of bounds \(slice.range)")
                    precondition(bounds.upperBound <= slice.endIndex, "Range \(bounds) out of bounds \(slice.range)")
                    if bounds.lowerBound == 0 && bounds.upperBound == 0 {
                        return Data()
                    } else if bounds.lowerBound == 0 && InlineData.canStore(count: bounds.upperBound) {
                        return Data(representation: .inline(InlineData(slice, count: bounds.upperBound)))
                    } else if InlineSlice.canStore(count: bounds.lowerBound) && InlineSlice.canStore(count: bounds.upperBound) {
                        return Data(representation: .slice(InlineSlice(slice, range: bounds)))
                    } else {
                        var newSlice = slice
                        newSlice.slice = RangeReference(bounds)
                        return Data(representation: .large(newSlice))
                    }
                }
            }
    }
    @inlinable internal var startIndex: Swift.Int {
      get {
            switch self {
            case .empty: return 0
            case .inline: return 0
            case .slice(let slice): return slice.startIndex
            case .large(let slice): return slice.startIndex
            }
        }
    }
    @inlinable internal var endIndex: Swift.Int {
      get {
            switch self {
            case .empty: return 0
            case .inline(let inline): return inline.count
            case .slice(let slice): return slice.endIndex
            case .large(let slice): return slice.endIndex
            }
        }
    }
    @inlinable internal func bridgedReference() -> Foundation.NSData {
            switch self {
            case .empty: return NSData()
            case .inline(let inline):
                return inline.withUnsafeBytes {
                    return NSData(bytes: $0.baseAddress, length: $0.count)
                }
            case .slice(let slice):
                return slice.bridgedReference()
            case .large(let slice):
                return slice.bridgedReference()
            }
        }
    @inlinable internal func copyBytes(to pointer: Swift.UnsafeMutableRawPointer, from range: Swift.Range<Swift.Int>) {
            switch self {
            case .empty:
                precondition(range.lowerBound == 0 && range.upperBound == 0, "Range \(range) out of bounds 0..<0")
                return
            case .inline(let inline):
                inline.copyBytes(to: pointer, from: range)
            case .slice(let slice):
                slice.copyBytes(to: pointer, from: range)
            case .large(let slice):
                slice.copyBytes(to: pointer, from: range)
            }
        }
  }
  @usableFromInline
  internal var _representation: Foundation.Data._Representation
  public enum Deallocator {
    case virtualMemory
    case unmap
    case free
    case none
    case custom((Swift.UnsafeMutableRawPointer, Swift.Int) -> Swift.Void)
    @usableFromInline
    internal var _deallocator: ((Swift.UnsafeMutableRawPointer, Swift.Int) -> Swift.Void) {
      get
    }
  }
  @inlinable public init(bytes: Swift.UnsafeRawPointer, count: Swift.Int) {
        _representation = _Representation(UnsafeRawBufferPointer(start: bytes, count: count))
    }
  @inlinable public init<SourceType>(buffer: Swift.UnsafeBufferPointer<SourceType>) {
        _representation = _Representation(UnsafeRawBufferPointer(buffer))
    }
  @inlinable public init<SourceType>(buffer: Swift.UnsafeMutableBufferPointer<SourceType>) {
        _representation = _Representation(UnsafeRawBufferPointer(buffer))
    }
  @inlinable public init(repeating repeatedValue: Swift.UInt8, count: Swift.Int) {
        self.init(count: count)
        withUnsafeMutableBytes { (buffer: UnsafeMutableRawBufferPointer) -> Void in
            memset(buffer.baseAddress, Int32(repeatedValue), buffer.count)
        }
    }
  @inlinable public init(capacity: Swift.Int) {
        _representation = _Representation(capacity: capacity)
    }
  @inlinable public init(count: Swift.Int) {
        _representation = _Representation(count: count)
    }
  @inlinable public init() {
        _representation = .empty
    }
  @inlinable public init(bytesNoCopy bytes: Swift.UnsafeMutableRawPointer, count: Swift.Int, deallocator: Foundation.Data.Deallocator) {
        let whichDeallocator = deallocator._deallocator
        if count == 0 {
            deallocator._deallocator(bytes, count)
            _representation = .empty
        } else {
            _representation = _Representation(__DataStorage(bytes: bytes, length: count, copy: false, deallocator: whichDeallocator, offset: 0), count: count)
        }
    }
  @inlinable public init(contentsOf url: __shared Foundation.URL, options: Foundation.Data.ReadingOptions = []) throws {
        let d = try NSData(contentsOf: url, options: ReadingOptions(rawValue: options.rawValue))
        self.init(referencing: d)
    }
  @inlinable public init?(base64Encoded base64String: __shared Swift.String, options: Foundation.Data.Base64DecodingOptions = []) {
        if let d = NSData(base64Encoded: base64String, options: Base64DecodingOptions(rawValue: options.rawValue)) {
            self.init(referencing: d)
        } else {
            return nil
        }
    }
  @inlinable public init?(base64Encoded base64Data: __shared Foundation.Data, options: Foundation.Data.Base64DecodingOptions = []) {
        if let d = NSData(base64Encoded: base64Data, options: Base64DecodingOptions(rawValue: options.rawValue)) {
            self.init(referencing: d)
        } else {
            return nil
        }
    }
  public init(referencing reference: __shared Foundation.NSData)
  @inlinable public init<S>(_ elements: S) where S : Swift.Sequence, S.Element == Swift.UInt8 {
        // If the sequence is already contiguous, access the underlying raw memory directly.
        if let contiguous = elements as? ContiguousBytes {
            _representation = contiguous.withUnsafeBytes { return _Representation($0) }
            return
        }

        // The sequence might still be able to provide direct access to typed memory.
        // NOTE: It's safe to do this because we're already guarding on S's element as `UInt8`. This would not be safe on arbitrary sequences.
        let representation = elements.withContiguousStorageIfAvailable {
            _Representation(UnsafeRawBufferPointer($0))
        }
        if let representation = representation {
            _representation = representation
            return
        }

        // Copy as much as we can in one shot from the sequence.
        let underestimatedCount = elements.underestimatedCount
        _representation = _Representation(count: underestimatedCount)
        var (iter, endIndex): (S.Iterator, Int) = _representation.withUnsafeMutableBytes { buffer in
            let start = buffer.baseAddress!.assumingMemoryBound(to: UInt8.self)
            let b = UnsafeMutableBufferPointer(start: start, count: buffer.count)
            return elements._copyContents(initializing: b)
        }
        guard endIndex == _representation.count else {
            // We can't trap here. We have to allow an underfilled buffer
            // to emulate the previous implementation.
            _representation.replaceSubrange(endIndex ..< _representation.endIndex, with: nil, count: 0)
            return
        }

        // Append the rest byte-wise, buffering through an InlineData.
        var buffer = InlineData()
        while let element = iter.next() {
            buffer.append(byte: element)
            if buffer.count == buffer.capacity {
                buffer.withUnsafeBytes { _representation.append(contentsOf: $0) }
                buffer.count = 0
            }
        }

        // If we've still got bytes left in the buffer (i.e. the loop ended before we filled up the buffer and cleared it out), append them.
        if buffer.count > 0 {
            buffer.withUnsafeBytes { _representation.append(contentsOf: $0) }
            buffer.count = 0
        }
    }
  @available(swift 4.2)
  @available(swift, deprecated: 5, message: "use `init(_:)` instead")
  public init<S>(bytes elements: S) where S : Swift.Sequence, S.Element == Swift.UInt8
  @available(swift, obsoleted: 4.2)
  public init(bytes: Swift.Array<Swift.UInt8>)
  @available(swift, obsoleted: 4.2)
  public init(bytes: Swift.ArraySlice<Swift.UInt8>)
  @inlinable internal init(representation: Foundation.Data._Representation) {
        _representation = representation
    }
  @inlinable public mutating func reserveCapacity(_ minimumCapacity: Swift.Int) {
        _representation.reserveCapacity(minimumCapacity)
    }
  @inlinable public var count: Swift.Int {
    get {
            return _representation.count
        }
    set(newValue) {
            precondition(newValue >= 0, "count must not be negative")
            _representation.count = newValue
        }
  }
  @inlinable public var regions: Swift.CollectionOfOne<Foundation.Data> {
    get {
        return CollectionOfOne(self)
    }
  }
  @available(swift, deprecated: 5, message: "use `withUnsafeBytes<R>(_: (UnsafeRawBufferPointer) throws -> R) rethrows -> R` instead")
  public func withUnsafeBytes<ResultType, ContentType>(_ body: (Swift.UnsafePointer<ContentType>) throws -> ResultType) rethrows -> ResultType
  @inlinable public func withUnsafeBytes<ResultType>(_ body: (Swift.UnsafeRawBufferPointer) throws -> ResultType) rethrows -> ResultType {
        return try _representation.withUnsafeBytes(body)
    }
  @available(swift, deprecated: 5, message: "use `withUnsafeMutableBytes<R>(_: (UnsafeMutableRawBufferPointer) throws -> R) rethrows -> R` instead")
  public mutating func withUnsafeMutableBytes<ResultType, ContentType>(_ body: (Swift.UnsafeMutablePointer<ContentType>) throws -> ResultType) rethrows -> ResultType
  @inlinable public mutating func withUnsafeMutableBytes<ResultType>(_ body: (Swift.UnsafeMutableRawBufferPointer) throws -> ResultType) rethrows -> ResultType {
        return try _representation.withUnsafeMutableBytes(body)
    }
  @inlinable public func copyBytes(to pointer: Swift.UnsafeMutablePointer<Swift.UInt8>, count: Swift.Int) {
        precondition(count >= 0, "count of bytes to copy must not be negative")
        if count == 0 { return }
        _copyBytesHelper(to: UnsafeMutableRawPointer(pointer), from: startIndex..<(startIndex + count))
    }
  @inlinable internal func _copyBytesHelper(to pointer: Swift.UnsafeMutableRawPointer, from range: Swift.Range<Swift.Int>) {
        if range.isEmpty { return }
        _representation.copyBytes(to: pointer, from: range)
    }
  @inlinable public func copyBytes(to pointer: Swift.UnsafeMutablePointer<Swift.UInt8>, from range: Swift.Range<Foundation.Data.Index>) {
        _copyBytesHelper(to: pointer, from: range)
    }
  @inlinable public func copyBytes<DestinationType>(to buffer: Swift.UnsafeMutableBufferPointer<DestinationType>, from range: Swift.Range<Foundation.Data.Index>? = nil) -> Swift.Int {
        let cnt = count
        guard cnt > 0 else { return 0 }
        
        let copyRange : Range<Index>
        if let r = range {
            guard !r.isEmpty else { return 0 }
            copyRange = r.lowerBound..<(r.lowerBound + Swift.min(buffer.count * MemoryLayout<DestinationType>.stride, r.upperBound - r.lowerBound))
        } else {
            copyRange = 0..<Swift.min(buffer.count * MemoryLayout<DestinationType>.stride, cnt)
        }
        
        guard !copyRange.isEmpty else { return 0 }
        
        _copyBytesHelper(to: buffer.baseAddress!, from: copyRange)
        return copyRange.upperBound - copyRange.lowerBound
    }
  public func write(to url: Foundation.URL, options: Foundation.Data.WritingOptions = []) throws
  public func range(of dataToFind: Foundation.Data, options: Foundation.Data.SearchOptions = [], in range: Swift.Range<Foundation.Data.Index>? = nil) -> Swift.Range<Foundation.Data.Index>?
  @available(swift, deprecated: 5, message: "use `regions` or `for-in` instead")
  public func enumerateBytes(_ block: (Swift.UnsafeBufferPointer<Swift.UInt8>, Foundation.Data.Index, inout Swift.Bool) -> Swift.Void)
  @inlinable internal mutating func _append<SourceType>(_ buffer: Swift.UnsafeBufferPointer<SourceType>) {
        if buffer.isEmpty { return }
        _representation.append(contentsOf: UnsafeRawBufferPointer(buffer))
    }
  @inlinable public mutating func append(_ bytes: Swift.UnsafePointer<Swift.UInt8>, count: Swift.Int) {
        if count == 0 { return }
        _append(UnsafeBufferPointer(start: bytes, count: count))
    }
  public mutating func append(_ other: Foundation.Data)
  @inlinable public mutating func append<SourceType>(_ buffer: Swift.UnsafeBufferPointer<SourceType>) {
        _append(buffer)
    }
  @inlinable public mutating func append(contentsOf bytes: [Swift.UInt8]) {
        bytes.withUnsafeBufferPointer { (buffer: UnsafeBufferPointer<UInt8>) -> Void in
            _append(buffer)
        }
    }
  @inlinable public mutating func append<S>(contentsOf elements: S) where S : Swift.Sequence, S.Element == Foundation.Data.Element {
        // If the sequence is already contiguous, access the underlying raw memory directly.
        if let contiguous = elements as? ContiguousBytes {
            contiguous.withUnsafeBytes {
                _representation.append(contentsOf: $0)
            }

            return
        }

        // The sequence might still be able to provide direct access to typed memory.
        // NOTE: It's safe to do this because we're already guarding on S's element as `UInt8`. This would not be safe on arbitrary sequences.
        let appended: Void? = elements.withContiguousStorageIfAvailable {
            _representation.append(contentsOf: UnsafeRawBufferPointer($0))
        }
        guard appended == nil else { return }

        // The sequence is really not contiguous.
        // Copy as much as we can in one shot.
        let underestimatedCount = elements.underestimatedCount
        let originalCount = _representation.count
        resetBytes(in: self.endIndex ..< self.endIndex + underestimatedCount)
        var (iter, copiedCount): (S.Iterator, Int) = _representation.withUnsafeMutableBytes { buffer in
            assert(buffer.count == originalCount + underestimatedCount)
            let start = buffer.baseAddress!.assumingMemoryBound(to: UInt8.self) + originalCount
            let b = UnsafeMutableBufferPointer(start: start, count: buffer.count - originalCount)
            return elements._copyContents(initializing: b)
        }
        guard copiedCount == underestimatedCount else {
            // We can't trap here. We have to allow an underfilled buffer
            // to emulate the previous implementation.
            _representation.replaceSubrange(startIndex + originalCount + copiedCount ..< endIndex, with: nil, count: 0)
            return
        }

        // Append the rest byte-wise, buffering through an InlineData.
        var buffer = InlineData()
        while let element = iter.next() {
            buffer.append(byte: element)
            if buffer.count == buffer.capacity {
                buffer.withUnsafeBytes { _representation.append(contentsOf: $0) }
                buffer.count = 0
            }
        }

        // If we've still got bytes left in the buffer (i.e. the loop ended before we filled up the buffer and cleared it out), append them.
        if buffer.count > 0 {
            buffer.withUnsafeBytes { _representation.append(contentsOf: $0) }
            buffer.count = 0
        }
    }
  @inlinable public mutating func resetBytes(in range: Swift.Range<Foundation.Data.Index>) {
        // it is worth noting that the range here may be out of bounds of the Data itself (which triggers a growth)
        precondition(range.lowerBound >= 0, "Ranges must not be negative bounds")
        precondition(range.upperBound >= 0, "Ranges must not be negative bounds")
        _representation.resetBytes(in: range)
    }
  @inlinable public mutating func replaceSubrange(_ subrange: Swift.Range<Foundation.Data.Index>, with data: Foundation.Data) {
        data.withUnsafeBytes { (buffer: UnsafeRawBufferPointer) in
            _representation.replaceSubrange(subrange, with: buffer.baseAddress, count: buffer.count)
        }
    }
  @inlinable public mutating func replaceSubrange<SourceType>(_ subrange: Swift.Range<Foundation.Data.Index>, with buffer: Swift.UnsafeBufferPointer<SourceType>) {
        guard !buffer.isEmpty  else { return }
        replaceSubrange(subrange, with: buffer.baseAddress!, count: buffer.count * MemoryLayout<SourceType>.stride)
    }
  @inlinable public mutating func replaceSubrange<ByteCollection>(_ subrange: Swift.Range<Foundation.Data.Index>, with newElements: ByteCollection) where ByteCollection : Swift.Collection, ByteCollection.Element == Foundation.Data.Iterator.Element {
        // If the collection is already contiguous, access the underlying raw memory directly.
        if let contiguous = newElements as? ContiguousBytes {
            contiguous.withUnsafeBytes { buffer in
                _representation.replaceSubrange(subrange, with: buffer.baseAddress, count: buffer.count)
            }
            return
        }
        // The collection might still be able to provide direct access to typed memory.
        // NOTE: It's safe to do this because we're already guarding on ByteCollection's element as `UInt8`. This would not be safe on arbitrary collections.
        let replaced: Void? = newElements.withContiguousStorageIfAvailable { buffer in
            _representation.replaceSubrange(subrange, with: buffer.baseAddress, count: buffer.count)
        }
        guard replaced == nil else { return }

        let totalCount = Int(newElements.count)
        _withStackOrHeapBuffer(capacity: totalCount) { buffer in
            var (iterator, index) = newElements._copyContents(initializing: buffer)
            precondition(index == buffer.endIndex, "Collection has less elements than its count")
            precondition(iterator.next() == nil, "Collection has more elements than its count")
            _representation.replaceSubrange(subrange, with: buffer.baseAddress, count: totalCount)
        }
    }
  @inlinable public mutating func replaceSubrange(_ subrange: Swift.Range<Foundation.Data.Index>, with bytes: Swift.UnsafeRawPointer, count cnt: Swift.Int) {
        _representation.replaceSubrange(subrange, with: bytes, count: cnt)
    }
  public func subdata(in range: Swift.Range<Foundation.Data.Index>) -> Foundation.Data
  @inlinable public func base64EncodedString(options: Foundation.Data.Base64EncodingOptions = []) -> Swift.String {
        return _representation.withInteriorPointerReference {
            return $0.base64EncodedString(options: options)
        }
    }
  @inlinable public func base64EncodedData(options: Foundation.Data.Base64EncodingOptions = []) -> Foundation.Data {
        return _representation.withInteriorPointerReference {
            return $0.base64EncodedData(options: options)
        }
    }
  @inline(never) public func hash(into hasher: inout Swift.Hasher)
  public func advanced(by amount: Swift.Int) -> Foundation.Data
  @inlinable public subscript(index: Foundation.Data.Index) -> Swift.UInt8 {
    get {
            return _representation[index]
        }
    set(newValue) {
            _representation[index] = newValue
        }
  }
  @inlinable public subscript(bounds: Swift.Range<Foundation.Data.Index>) -> Foundation.Data {
    get {
            return _representation[bounds]
        }
    set {
            replaceSubrange(bounds, with: newValue)
        }
  }
  @inlinable public subscript<R>(rangeExpression: R) -> Foundation.Data where R : Swift.RangeExpression, R.Bound : Swift.FixedWidthInteger {
    get {
            let lower = R.Bound(startIndex)
            let upper = R.Bound(endIndex)
            let range = rangeExpression.relative(to: lower..<upper)
            let start = Int(range.lowerBound)
            let end = Int(range.upperBound)
            let r: Range<Int> = start..<end
            return _representation[r]
        }
    set {
            let lower = R.Bound(startIndex)
            let upper = R.Bound(endIndex)
            let range = rangeExpression.relative(to: lower..<upper)
            let start = Int(range.lowerBound)
            let end = Int(range.upperBound)
            let r: Range<Int> = start..<end
            replaceSubrange(r, with: newValue)
        }
  }
  @inlinable public var startIndex: Foundation.Data.Index {
    get {
            return _representation.startIndex
        }
  }
  @inlinable public var endIndex: Foundation.Data.Index {
    get {
            return _representation.endIndex
        }
  }
  @inlinable public func index(before i: Foundation.Data.Index) -> Foundation.Data.Index {
        return i - 1
    }
  @inlinable public func index(after i: Foundation.Data.Index) -> Foundation.Data.Index {
        return i + 1
    }
  @inlinable public var indices: Swift.Range<Swift.Int> {
    get {
            return startIndex..<endIndex
        }
  }
  @inlinable public func _copyContents(initializing buffer: Swift.UnsafeMutableBufferPointer<Swift.UInt8>) -> (Foundation.Data.Iterator, Swift.UnsafeMutableBufferPointer<Swift.UInt8>.Index) {
        guard !isEmpty else { return (makeIterator(), buffer.startIndex) }
        let cnt = Swift.min(count, buffer.count)
        
        withUnsafeBytes { (bytes: UnsafeRawBufferPointer) in
            _ = memcpy(UnsafeMutableRawPointer(buffer.baseAddress), bytes.baseAddress, cnt)
        }
        
        return (Iterator(self, at: startIndex + cnt), buffer.index(buffer.startIndex, offsetBy: cnt))
    }
  @inlinable public func makeIterator() -> Foundation.Data.Iterator {
        return Iterator(self, at: startIndex)
    }
  public struct Iterator : Swift.IteratorProtocol {
    @usableFromInline
    internal typealias Buffer = (Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8)
    @usableFromInline
    internal let _data: Foundation.Data
    @usableFromInline
    internal var _buffer: Foundation.Data.Iterator.Buffer
    @usableFromInline
    internal var _idx: Foundation.Data.Index
    @usableFromInline
    internal let _endIdx: Foundation.Data.Index
    @usableFromInline
    internal init(_ data: Foundation.Data, at loc: Foundation.Data.Index)
    public mutating func next() -> Swift.UInt8?
    public typealias Element = Swift.UInt8
  }
  @available(*, unavailable, renamed: "count")
  public var length: Swift.Int {
    get
    set
  }
  @available(*, unavailable, message: "use withUnsafeBytes instead")
  public var bytes: Swift.UnsafeRawPointer {
    get
  }
  @available(*, unavailable, message: "use withUnsafeMutableBytes instead")
  public var mutableBytes: Swift.UnsafeMutableRawPointer {
    get
  }
  @inlinable public static func == (d1: Foundation.Data, d2: Foundation.Data) -> Swift.Bool {
        let length1 = d1.count
        if length1 != d2.count {
            return false
        }
        if length1 > 0 {
            return d1.withUnsafeBytes { (b1: UnsafeRawBufferPointer) in
                return d2.withUnsafeBytes { (b2: UnsafeRawBufferPointer) in
                    return memcmp(b1.baseAddress!, b2.baseAddress!, b2.count) == 0
                }
            }
        }
        return true
    }
  public typealias Element = Swift.UInt8
  public typealias Regions = Swift.CollectionOfOne<Foundation.Data>
  public typealias SubSequence = Foundation.Data
  public var hashValue: Swift.Int {
    get
  }
}
extension Data : Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible, Swift.CustomReflectable {
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
  public var customMirror: Swift.Mirror {
    get
  }
}
extension Data {
  @available(*, unavailable, renamed: "copyBytes(to:count:)")
  public func getBytes<UnsafeMutablePointerVoid>(_ buffer: UnsafeMutablePointerVoid, length: Swift.Int) where UnsafeMutablePointerVoid : Swift._Pointer
  @available(*, unavailable, renamed: "copyBytes(to:from:)")
  public func getBytes<UnsafeMutablePointerVoid>(_ buffer: UnsafeMutablePointerVoid, range: Foundation.NSRange) where UnsafeMutablePointerVoid : Swift._Pointer
}
extension Data : Swift._ObjectiveCBridgeable {
  @_semantics("convertToObjectiveC") public func _bridgeToObjectiveC() -> Foundation.NSData
  public static func _forceBridgeFromObjectiveC(_ input: Foundation.NSData, result: inout Foundation.Data?)
  public static func _conditionallyBridgeFromObjectiveC(_ input: Foundation.NSData, result: inout Foundation.Data?) -> Swift.Bool
  public static func _unconditionallyBridgeFromObjectiveC(_ source: Foundation.NSData?) -> Foundation.Data
  public typealias _ObjectiveCType = Foundation.NSData
}
extension NSData : Swift._HasCustomAnyHashableRepresentation {
  @nonobjc public func _toCustomAnyHashable() -> Swift.AnyHashable?
}
extension Data : Swift.Codable {
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
public typealias Published = Combine.Published
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
public typealias ObservableObject = Combine.ObservableObject
extension NSPredicate {
  convenience public init(format predicateFormat: __shared Swift.String, _ args: Swift.CVarArg...)
}
extension NSSortDescriptor {
  convenience public init<Root, Value>(keyPath: Swift.KeyPath<Root, Value>, ascending: Swift.Bool)
  convenience public init<Root, Value>(keyPath: Swift.KeyPath<Root, Value>, ascending: Swift.Bool, comparator cmptr: @escaping Foundation.Comparator)
  public var keyPath: Swift.AnyKeyPath? {
    get
  }
}
extension FileHandle {
  @available(macOS 10.15.4, iOS 13.4, watchOS 6.2, tvOS 13.4, *)
  public func readToEnd() throws -> Foundation.Data?
  @available(macOS 10.15.4, iOS 13.4, watchOS 6.2, tvOS 13.4, *)
  public func read(upToCount count: Swift.Int) throws -> Foundation.Data?
  @available(macOS 10.15.4, iOS 13.4, watchOS 6.2, tvOS 13.4, *)
  public func offset() throws -> Swift.UInt64
  @available(macOS 10.15.4, iOS 13.4, watchOS 6.2, tvOS 13.4, *)
  @discardableResult
  public func seekToEnd() throws -> Swift.UInt64
  @available(macOS 10.15.4, iOS 13.4, watchOS 6.2, tvOS 13.4, *)
  @_specialize(exported: false, kind: full, where T == Foundation.Data)
  @_specialize(exported: false, kind: full, where T == Dispatch.DispatchData)
  public func write<T>(contentsOf data: T) throws where T : Foundation.DataProtocol
}
extension EncodingError : Foundation.LocalizedError {
}
extension DecodingError : Foundation.LocalizedError {
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension JSONEncoder : Combine.TopLevelEncoder {
  public typealias Output = Foundation.Data
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension PropertyListEncoder : Combine.TopLevelEncoder {
  public typealias Output = Foundation.Data
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension JSONDecoder : Combine.TopLevelDecoder {
  public typealias Input = Foundation.Data
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension PropertyListDecoder : Combine.TopLevelDecoder {
  public typealias Input = Foundation.Data
}
extension _NSRange : Swift.Hashable {
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (lhs: Foundation.NSRange, rhs: Foundation.NSRange) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
extension _NSRange : Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible {
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
}
extension _NSRange {
  public init?(_ string: __shared Swift.String)
}
extension _NSRange {
  public var lowerBound: Swift.Int {
    get
  }
  public var upperBound: Swift.Int {
    get
  }
  public func contains(_ index: Swift.Int) -> Swift.Bool
  public mutating func formUnion(_ other: Foundation.NSRange)
  public func union(_ other: Foundation.NSRange) -> Foundation.NSRange
  public func intersection(_ other: Foundation.NSRange) -> Foundation.NSRange?
}
extension _NSRange {
  public init<R>(_ region: R) where R : Swift.RangeExpression, R.Bound : Swift.FixedWidthInteger
  public init<R, S>(_ region: R, in target: S) where R : Swift.RangeExpression, S : Swift.StringProtocol, R.Bound == Swift.String.Index
  @available(swift, deprecated: 4, renamed: "Range.init(_:)")
  public func toRange() -> Swift.Range<Swift.Int>?
}
extension Range where Bound : Swift.BinaryInteger {
  public init?(_ range: Foundation.NSRange)
}
extension Range where Bound == Swift.Int {
  public init?(_ range: Foundation.NSRange)
}
extension Range where Bound == Swift.String.Index {
  public init?(_ range: Foundation.NSRange, in string: __shared Swift.String)
  @available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
  public init?<S>(_ range: Foundation.NSRange, in string: __shared S) where S : Swift.StringProtocol
}
extension _NSRange : Swift.CustomReflectable {
  public var customMirror: Swift.Mirror {
    get
  }
}
extension _NSRange : Swift._CustomPlaygroundQuickLookable {
  @available(*, deprecated, message: "NSRange.customPlaygroundQuickLook will be removed in a future Swift version")
  public var customPlaygroundQuickLook: Swift.PlaygroundQuickLook {
    get
  }
}
extension _NSRange : Swift.Codable {
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension OperationQueue : Combine.Scheduler {
  public struct SchedulerTimeType : Swift.Strideable, Swift.Codable, Swift.Hashable {
    public var date: Foundation.Date
    public init(_ date: Foundation.Date)
    public func distance(to other: Foundation.OperationQueue.SchedulerTimeType) -> Foundation.OperationQueue.SchedulerTimeType.Stride
    public func advanced(by n: Foundation.OperationQueue.SchedulerTimeType.Stride) -> Foundation.OperationQueue.SchedulerTimeType
    public struct Stride : Swift.ExpressibleByFloatLiteral, Swift.Comparable, Swift.SignedNumeric, Swift.Codable, Combine.SchedulerTimeIntervalConvertible {
      public typealias FloatLiteralType = Foundation.TimeInterval
      public typealias IntegerLiteralType = Foundation.TimeInterval
      public typealias Magnitude = Foundation.TimeInterval
      public var magnitude: Foundation.TimeInterval
      public var timeInterval: Foundation.TimeInterval {
        get
      }
      public init(integerLiteral value: Foundation.TimeInterval)
      public init(floatLiteral value: Foundation.TimeInterval)
      public init(_ timeInterval: Foundation.TimeInterval)
      public init?<T>(exactly source: T) where T : Swift.BinaryInteger
      public static func < (lhs: Foundation.OperationQueue.SchedulerTimeType.Stride, rhs: Foundation.OperationQueue.SchedulerTimeType.Stride) -> Swift.Bool
      public static func * (lhs: Foundation.OperationQueue.SchedulerTimeType.Stride, rhs: Foundation.OperationQueue.SchedulerTimeType.Stride) -> Foundation.OperationQueue.SchedulerTimeType.Stride
      public static func + (lhs: Foundation.OperationQueue.SchedulerTimeType.Stride, rhs: Foundation.OperationQueue.SchedulerTimeType.Stride) -> Foundation.OperationQueue.SchedulerTimeType.Stride
      public static func - (lhs: Foundation.OperationQueue.SchedulerTimeType.Stride, rhs: Foundation.OperationQueue.SchedulerTimeType.Stride) -> Foundation.OperationQueue.SchedulerTimeType.Stride
      public static func *= (lhs: inout Foundation.OperationQueue.SchedulerTimeType.Stride, rhs: Foundation.OperationQueue.SchedulerTimeType.Stride)
      public static func += (lhs: inout Foundation.OperationQueue.SchedulerTimeType.Stride, rhs: Foundation.OperationQueue.SchedulerTimeType.Stride)
      public static func -= (lhs: inout Foundation.OperationQueue.SchedulerTimeType.Stride, rhs: Foundation.OperationQueue.SchedulerTimeType.Stride)
      public static func seconds(_ s: Swift.Int) -> Foundation.OperationQueue.SchedulerTimeType.Stride
      public static func seconds(_ s: Swift.Double) -> Foundation.OperationQueue.SchedulerTimeType.Stride
      public static func milliseconds(_ ms: Swift.Int) -> Foundation.OperationQueue.SchedulerTimeType.Stride
      public static func microseconds(_ us: Swift.Int) -> Foundation.OperationQueue.SchedulerTimeType.Stride
      public static func nanoseconds(_ ns: Swift.Int) -> Foundation.OperationQueue.SchedulerTimeType.Stride
      public static func == (a: Foundation.OperationQueue.SchedulerTimeType.Stride, b: Foundation.OperationQueue.SchedulerTimeType.Stride) -> Swift.Bool
      public func encode(to encoder: Swift.Encoder) throws
      public init(from decoder: Swift.Decoder) throws
    }
    public func hash(into hasher: inout Swift.Hasher)
    public func encode(to encoder: Swift.Encoder) throws
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: Swift.Decoder) throws
  }
  public struct SchedulerOptions {
  }
  public func schedule(options: Foundation.OperationQueue.SchedulerOptions?, _ action: @escaping () -> Swift.Void)
  public func schedule(after date: Foundation.OperationQueue.SchedulerTimeType, tolerance: Foundation.OperationQueue.SchedulerTimeType.Stride, options: Foundation.OperationQueue.SchedulerOptions?, _ action: @escaping () -> Swift.Void)
  public func schedule(after date: Foundation.OperationQueue.SchedulerTimeType, interval: Foundation.OperationQueue.SchedulerTimeType.Stride, tolerance: Foundation.OperationQueue.SchedulerTimeType.Stride, options: Foundation.OperationQueue.SchedulerOptions?, _ action: @escaping () -> Swift.Void) -> Combine.Cancellable
  public var now: Foundation.OperationQueue.SchedulerTimeType {
    get
  }
  public var minimumTolerance: Foundation.OperationQueue.SchedulerTimeType.Stride {
    get
  }
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension Scanner {
  public enum NumberRepresentation {
    case decimal
    case hexadecimal
    public static func == (a: Foundation.Scanner.NumberRepresentation, b: Foundation.Scanner.NumberRepresentation) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public var currentIndex: Swift.String.Index {
    get
    set
  }
  public func scanInt(representation: Foundation.Scanner.NumberRepresentation = .decimal) -> Swift.Int?
  public func scanInt32(representation: Foundation.Scanner.NumberRepresentation = .decimal) -> Swift.Int32?
  public func scanInt64(representation: Foundation.Scanner.NumberRepresentation = .decimal) -> Swift.Int64?
  public func scanUInt64(representation: Foundation.Scanner.NumberRepresentation = .decimal) -> Swift.UInt64?
  public func scanFloat(representation: Foundation.Scanner.NumberRepresentation = .decimal) -> Swift.Float?
  public func scanDouble(representation: Foundation.Scanner.NumberRepresentation = .decimal) -> Swift.Double?
  public func scanDecimal() -> Foundation.Decimal?
  public func scanString(_ searchString: Swift.String) -> Swift.String?
  public func scanCharacters(from set: Foundation.CharacterSet) -> Swift.String?
  public func scanUpToString(_ substring: Swift.String) -> Swift.String?
  public func scanUpToCharacters(from set: Foundation.CharacterSet) -> Swift.String?
  public func scanCharacter() -> Swift.Character?
}
public protocol ReferenceConvertible : Swift.CustomDebugStringConvertible, Swift.CustomStringConvertible, Swift.Hashable, Swift._ObjectiveCBridgeable {
  associatedtype ReferenceType : ObjectiveC.NSObject, Foundation.NSCopying
}
public struct Locale : Swift.Hashable, Swift.Equatable, Foundation.ReferenceConvertible {
  public typealias ReferenceType = Foundation.NSLocale
  public typealias LanguageDirection = Foundation.NSLocale.LanguageDirection
  public static var autoupdatingCurrent: Foundation.Locale {
    get
  }
  public static var current: Foundation.Locale {
    get
  }
  @available(*, unavailable, message: "Consider using the user's locale or nil instead, depending on use case")
  public static var system: Foundation.Locale {
    get
  }
  public init(identifier: Swift.String)
  public func localizedString(forIdentifier identifier: Swift.String) -> Swift.String?
  public func localizedString(forLanguageCode languageCode: Swift.String) -> Swift.String?
  public func localizedString(forRegionCode regionCode: Swift.String) -> Swift.String?
  public func localizedString(forScriptCode scriptCode: Swift.String) -> Swift.String?
  public func localizedString(forVariantCode variantCode: Swift.String) -> Swift.String?
  public func localizedString(for calendarIdentifier: Foundation.Calendar.Identifier) -> Swift.String?
  public func localizedString(forCurrencyCode currencyCode: Swift.String) -> Swift.String?
  public func localizedString(forCollationIdentifier collationIdentifier: Swift.String) -> Swift.String?
  public func localizedString(forCollatorIdentifier collatorIdentifier: Swift.String) -> Swift.String?
  public var identifier: Swift.String {
    get
  }
  public var languageCode: Swift.String? {
    get
  }
  public var regionCode: Swift.String? {
    get
  }
  public var scriptCode: Swift.String? {
    get
  }
  public var variantCode: Swift.String? {
    get
  }
  public var exemplarCharacterSet: Foundation.CharacterSet? {
    get
  }
  public var calendar: Foundation.Calendar {
    get
  }
  public var collationIdentifier: Swift.String? {
    get
  }
  public var usesMetricSystem: Swift.Bool {
    get
  }
  public var decimalSeparator: Swift.String? {
    get
  }
  public var groupingSeparator: Swift.String? {
    get
  }
  public var currencySymbol: Swift.String? {
    get
  }
  public var currencyCode: Swift.String? {
    get
  }
  public var collatorIdentifier: Swift.String? {
    get
  }
  public var quotationBeginDelimiter: Swift.String? {
    get
  }
  public var quotationEndDelimiter: Swift.String? {
    get
  }
  public var alternateQuotationBeginDelimiter: Swift.String? {
    get
  }
  public var alternateQuotationEndDelimiter: Swift.String? {
    get
  }
  public static var availableIdentifiers: [Swift.String] {
    get
  }
  public static var isoLanguageCodes: [Swift.String] {
    get
  }
  public static var isoRegionCodes: [Swift.String] {
    get
  }
  public static var isoCurrencyCodes: [Swift.String] {
    get
  }
  public static var commonISOCurrencyCodes: [Swift.String] {
    get
  }
  public static var preferredLanguages: [Swift.String] {
    get
  }
  public static func components(fromIdentifier string: Swift.String) -> [Swift.String : Swift.String]
  public static func identifier(fromComponents components: [Swift.String : Swift.String]) -> Swift.String
  public static func canonicalIdentifier(from string: Swift.String) -> Swift.String
  public static func canonicalLanguageIdentifier(from string: Swift.String) -> Swift.String
  public static func identifier(fromWindowsLocaleCode code: Swift.Int) -> Swift.String?
  public static func windowsLocaleCode(fromIdentifier identifier: Swift.String) -> Swift.Int?
  public static func characterDirection(forLanguage isoLangCode: Swift.String) -> Foundation.Locale.LanguageDirection
  public static func lineDirection(forLanguage isoLangCode: Swift.String) -> Foundation.Locale.LanguageDirection
  @available(*, unavailable, renamed: "init(identifier:)")
  public init(localeIdentifier: Swift.String)
  @available(*, unavailable, renamed: "identifier")
  public var localeIdentifier: Swift.String {
    get
  }
  @available(*, unavailable, renamed: "localizedString(forIdentifier:)")
  public func localizedString(forLocaleIdentifier localeIdentifier: Swift.String) -> Swift.String
  @available(*, unavailable, renamed: "availableIdentifiers")
  public static var availableLocaleIdentifiers: [Swift.String] {
    get
  }
  @available(*, unavailable, renamed: "components(fromIdentifier:)")
  public static func components(fromLocaleIdentifier string: Swift.String) -> [Swift.String : Swift.String]
  @available(*, unavailable, renamed: "identifier(fromComponents:)")
  public static func localeIdentifier(fromComponents dict: [Swift.String : Swift.String]) -> Swift.String
  @available(*, unavailable, renamed: "canonicalIdentifier(from:)")
  public static func canonicalLocaleIdentifier(from string: Swift.String) -> Swift.String
  @available(*, unavailable, renamed: "identifier(fromWindowsLocaleCode:)")
  public static func localeIdentifier(fromWindowsLocaleCode lcid: Swift.UInt32) -> Swift.String?
  @available(*, unavailable, renamed: "windowsLocaleCode(fromIdentifier:)")
  public static func windowsLocaleCode(fromLocaleIdentifier localeIdentifier: Swift.String) -> Swift.UInt32
  @available(*, unavailable, message: "use regionCode instead")
  public var countryCode: Swift.String {
    get
  }
  @available(*, unavailable, message: "use localizedString(forRegionCode:) instead")
  public func localizedString(forCountryCode countryCode: Swift.String) -> Swift.String
  @available(*, unavailable, renamed: "isoRegionCodes")
  public static var isoCountryCodes: [Swift.String] {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (lhs: Foundation.Locale, rhs: Foundation.Locale) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
extension Locale : Swift.CustomDebugStringConvertible, Swift.CustomStringConvertible, Swift.CustomReflectable {
  public var customMirror: Swift.Mirror {
    get
  }
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
}
extension Locale : Swift._ObjectiveCBridgeable {
  @_semantics("convertToObjectiveC") public func _bridgeToObjectiveC() -> Foundation.NSLocale
  public static func _forceBridgeFromObjectiveC(_ input: Foundation.NSLocale, result: inout Foundation.Locale?)
  public static func _conditionallyBridgeFromObjectiveC(_ input: Foundation.NSLocale, result: inout Foundation.Locale?) -> Swift.Bool
  @_effects(readonly) public static func _unconditionallyBridgeFromObjectiveC(_ source: Foundation.NSLocale?) -> Foundation.Locale
  public typealias _ObjectiveCType = Foundation.NSLocale
}
extension NSLocale : Swift._HasCustomAnyHashableRepresentation {
  @nonobjc public func _toCustomAnyHashable() -> Swift.AnyHashable?
}
extension Locale : Swift.Codable {
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
@available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
extension CollectionDifference.Change : Swift._ObjectiveCBridgeable {
  @_semantics("convertToObjectiveC") public func _bridgeToObjectiveC() -> Foundation.NSOrderedCollectionChange
  public static func _forceBridgeFromObjectiveC(_ input: Foundation.NSOrderedCollectionChange, result: inout Swift.CollectionDifference<ChangeElement>.Change?)
  public static func _conditionallyBridgeFromObjectiveC(_ x: Foundation.NSOrderedCollectionChange, result: inout Swift.CollectionDifference<ChangeElement>.Change?) -> Swift.Bool
  @_effects(readonly) public static func _unconditionallyBridgeFromObjectiveC(_ s: Foundation.NSOrderedCollectionChange?) -> Swift.CollectionDifference<ChangeElement>.Change
  public typealias _ObjectiveCType = Foundation.NSOrderedCollectionChange
}
@available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
extension CollectionDifference : Swift._ObjectiveCBridgeable {
  @_semantics("convertToObjectiveC") public func _bridgeToObjectiveC() -> Foundation.NSOrderedCollectionDifference
  public static func _forceBridgeFromObjectiveC(_ input: Foundation.NSOrderedCollectionDifference, result: inout Swift.CollectionDifference<ChangeElement>?)
  public static func _conditionallyBridgeFromObjectiveC(_ input: Foundation.NSOrderedCollectionDifference, result: inout Swift.CollectionDifference<ChangeElement>?) -> Swift.Bool
  @_effects(readonly) public static func _unconditionallyBridgeFromObjectiveC(_ s: Foundation.NSOrderedCollectionDifference?) -> Swift.CollectionDifference<ChangeElement>
  public typealias _ObjectiveCType = Foundation.NSOrderedCollectionDifference
}
@available(macOS 10.12, iOS 10.0, watchOS 3.0, tvOS 10.0, *)
public struct DateInterval : Foundation.ReferenceConvertible, Swift.Comparable, Swift.Hashable, Swift.Codable {
  public typealias ReferenceType = Foundation.NSDateInterval
  public var start: Foundation.Date
  public var end: Foundation.Date {
    get
    set
  }
  public var duration: Foundation.TimeInterval {
    get
    set
  }
  public init()
  public init(start: Foundation.Date, end: Foundation.Date)
  public init(start: Foundation.Date, duration: Foundation.TimeInterval)
  public func compare(_ dateInterval: Foundation.DateInterval) -> Foundation.ComparisonResult
  public func intersects(_ dateInterval: Foundation.DateInterval) -> Swift.Bool
  public func intersection(with dateInterval: Foundation.DateInterval) -> Foundation.DateInterval?
  public func contains(_ date: Foundation.Date) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  @available(macOS 10.12, iOS 10.0, watchOS 3.0, tvOS 10.0, *)
  public static func == (lhs: Foundation.DateInterval, rhs: Foundation.DateInterval) -> Swift.Bool
  @available(macOS 10.12, iOS 10.0, watchOS 3.0, tvOS 10.0, *)
  public static func < (lhs: Foundation.DateInterval, rhs: Foundation.DateInterval) -> Swift.Bool
  public func encode(to encoder: Swift.Encoder) throws
  public var hashValue: Swift.Int {
    get
  }
  public init(from decoder: Swift.Decoder) throws
}
@available(macOS 10.12, iOS 10.0, watchOS 3.0, tvOS 10.0, *)
extension DateInterval : Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible, Swift.CustomReflectable {
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
  public var customMirror: Swift.Mirror {
    get
  }
}
@available(macOS 10.12, iOS 10.0, watchOS 3.0, tvOS 10.0, *)
extension DateInterval : Swift._ObjectiveCBridgeable {
  public static func _getObjectiveCType() -> Any.Type
  @_semantics("convertToObjectiveC") public func _bridgeToObjectiveC() -> Foundation.NSDateInterval
  public static func _forceBridgeFromObjectiveC(_ dateInterval: Foundation.NSDateInterval, result: inout Foundation.DateInterval?)
  public static func _conditionallyBridgeFromObjectiveC(_ dateInterval: Foundation.NSDateInterval, result: inout Foundation.DateInterval?) -> Swift.Bool
  @_effects(readonly) public static func _unconditionallyBridgeFromObjectiveC(_ source: Foundation.NSDateInterval?) -> Foundation.DateInterval
  public typealias _ObjectiveCType = Foundation.NSDateInterval
}
@available(macOS 10.12, iOS 10.0, watchOS 3.0, tvOS 10.0, *)
extension NSDateInterval : Swift._HasCustomAnyHashableRepresentation {
  @nonobjc public func _toCustomAnyHashable() -> Swift.AnyHashable?
}
public struct URLResourceValues {
  public init()
  public var allValues: [Foundation.URLResourceKey : Any] {
    get
  }
  public var name: Swift.String? {
    get
    set
  }
  public var localizedName: Swift.String? {
    get
  }
  public var isRegularFile: Swift.Bool? {
    get
  }
  public var isDirectory: Swift.Bool? {
    get
  }
  public var isSymbolicLink: Swift.Bool? {
    get
  }
  public var isVolume: Swift.Bool? {
    get
  }
  public var isPackage: Swift.Bool? {
    get
    set
  }
  @available(macOS 10.11, iOS 9.0, *)
  public var isApplication: Swift.Bool? {
    get
  }
  @available(macOS 10.11, *)
  public var applicationIsScriptable: Swift.Bool? {
    get
  }
  public var isSystemImmutable: Swift.Bool? {
    get
  }
  public var isUserImmutable: Swift.Bool? {
    get
    set
  }
  public var isHidden: Swift.Bool? {
    get
    set
  }
  public var hasHiddenExtension: Swift.Bool? {
    get
    set
  }
  public var creationDate: Foundation.Date? {
    get
    set
  }
  public var contentAccessDate: Foundation.Date? {
    get
    set
  }
  public var contentModificationDate: Foundation.Date? {
    get
    set
  }
  public var attributeModificationDate: Foundation.Date? {
    get
  }
  public var linkCount: Swift.Int? {
    get
  }
  public var parentDirectory: Foundation.URL? {
    get
  }
  public var volume: Foundation.URL? {
    get
  }
  @available(macOS, introduced: 10.6, deprecated: 100000.0, message: "Use .contentType instead")
  @available(iOS, introduced: 4.0, deprecated: 100000.0, message: "Use .contentType instead")
  @available(watchOS, introduced: 2.0, deprecated: 100000.0, message: "Use .contentType instead")
  @available(tvOS, introduced: 9.0, deprecated: 100000.0, message: "Use .contentType instead")
  public var typeIdentifier: Swift.String? {
    get
  }
  public var localizedTypeDescription: Swift.String? {
    get
  }
  public var labelNumber: Swift.Int? {
    get
    set
  }
  public var localizedLabel: Swift.String? {
    get
  }
  public var fileResourceIdentifier: (Foundation.NSCopying & Foundation.NSSecureCoding & ObjectiveC.NSObjectProtocol)? {
    get
  }
  public var volumeIdentifier: (Foundation.NSCopying & Foundation.NSSecureCoding & ObjectiveC.NSObjectProtocol)? {
    get
  }
  @available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
  public var fileContentIdentifier: Swift.Int64? {
    get
  }
  public var preferredIOBlockSize: Swift.Int? {
    get
  }
  public var isReadable: Swift.Bool? {
    get
  }
  public var isWritable: Swift.Bool? {
    get
  }
  public var isExecutable: Swift.Bool? {
    get
  }
  public var fileSecurity: Foundation.NSFileSecurity? {
    get
    set
  }
  public var isExcludedFromBackup: Swift.Bool? {
    get
    set
  }
  public var tagNames: [Swift.String]? {
    get
  }
  public var path: Swift.String? {
    get
  }
  @available(macOS 10.12, iOS 10.0, tvOS 10.0, watchOS 3.0, *)
  public var canonicalPath: Swift.String? {
    get
  }
  public var isMountTrigger: Swift.Bool? {
    get
  }
  @available(macOS 10.10, iOS 8.0, *)
  public var generationIdentifier: (Foundation.NSCopying & Foundation.NSSecureCoding & ObjectiveC.NSObjectProtocol)? {
    get
  }
  @available(macOS 10.10, iOS 8.0, *)
  public var documentIdentifier: Swift.Int? {
    get
  }
  @available(macOS 10.10, iOS 8.0, *)
  public var addedToDirectoryDate: Foundation.Date? {
    get
  }
  @available(macOS 10.10, *)
  public var quarantineProperties: [Swift.String : Any]? {
    get
    set
  }
  @available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
  public var mayHaveExtendedAttributes: Swift.Bool? {
    get
  }
  @available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
  public var isPurgeable: Swift.Bool? {
    get
  }
  @available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
  public var isSparse: Swift.Bool? {
    get
  }
  @available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
  public var mayShareFileContent: Swift.Bool? {
    get
  }
  public var fileResourceType: Foundation.URLFileResourceType? {
    get
  }
  public var volumeLocalizedFormatDescription: Swift.String? {
    get
  }
  public var volumeTotalCapacity: Swift.Int? {
    get
  }
  public var volumeAvailableCapacity: Swift.Int? {
    get
  }
  @available(macOS 10.13, iOS 11.0, *)
  @available(tvOS, unavailable)
  @available(watchOS, unavailable)
  public var volumeAvailableCapacityForImportantUsage: Swift.Int64? {
    get
  }
  @available(macOS 10.13, iOS 11.0, *)
  @available(tvOS, unavailable)
  @available(watchOS, unavailable)
  public var volumeAvailableCapacityForOpportunisticUsage: Swift.Int64? {
    get
  }
  public var volumeResourceCount: Swift.Int? {
    get
  }
  public var volumeSupportsPersistentIDs: Swift.Bool? {
    get
  }
  public var volumeSupportsSymbolicLinks: Swift.Bool? {
    get
  }
  public var volumeSupportsHardLinks: Swift.Bool? {
    get
  }
  public var volumeSupportsJournaling: Swift.Bool? {
    get
  }
  public var volumeIsJournaling: Swift.Bool? {
    get
  }
  public var volumeSupportsSparseFiles: Swift.Bool? {
    get
  }
  public var volumeSupportsZeroRuns: Swift.Bool? {
    get
  }
  public var volumeSupportsCaseSensitiveNames: Swift.Bool? {
    get
  }
  public var volumeSupportsCasePreservedNames: Swift.Bool? {
    get
  }
  public var volumeSupportsRootDirectoryDates: Swift.Bool? {
    get
  }
  public var volumeSupportsVolumeSizes: Swift.Bool? {
    get
  }
  public var volumeSupportsRenaming: Swift.Bool? {
    get
  }
  public var volumeSupportsAdvisoryFileLocking: Swift.Bool? {
    get
  }
  public var volumeSupportsExtendedSecurity: Swift.Bool? {
    get
  }
  public var volumeIsBrowsable: Swift.Bool? {
    get
  }
  public var volumeMaximumFileSize: Swift.Int? {
    get
  }
  public var volumeIsEjectable: Swift.Bool? {
    get
  }
  public var volumeIsRemovable: Swift.Bool? {
    get
  }
  public var volumeIsInternal: Swift.Bool? {
    get
  }
  public var volumeIsAutomounted: Swift.Bool? {
    get
  }
  public var volumeIsLocal: Swift.Bool? {
    get
  }
  public var volumeIsReadOnly: Swift.Bool? {
    get
  }
  public var volumeCreationDate: Foundation.Date? {
    get
  }
  public var volumeURLForRemounting: Foundation.URL? {
    get
  }
  public var volumeUUIDString: Swift.String? {
    get
  }
  public var volumeName: Swift.String? {
    get
    set
  }
  public var volumeLocalizedName: Swift.String? {
    get
  }
  @available(macOS 10.12, iOS 10.0, tvOS 10.0, watchOS 3.0, *)
  public var volumeIsEncrypted: Swift.Bool? {
    get
  }
  @available(macOS 10.12, iOS 10.0, tvOS 10.0, watchOS 3.0, *)
  public var volumeIsRootFileSystem: Swift.Bool? {
    get
  }
  @available(macOS 10.12, iOS 10.0, tvOS 10.0, watchOS 3.0, *)
  public var volumeSupportsCompression: Swift.Bool? {
    get
  }
  @available(macOS 10.12, iOS 10.0, tvOS 10.0, watchOS 3.0, *)
  public var volumeSupportsFileCloning: Swift.Bool? {
    get
  }
  @available(macOS 10.12, iOS 10.0, tvOS 10.0, watchOS 3.0, *)
  public var volumeSupportsSwapRenaming: Swift.Bool? {
    get
  }
  @available(macOS 10.12, iOS 10.0, tvOS 10.0, watchOS 3.0, *)
  public var volumeSupportsExclusiveRenaming: Swift.Bool? {
    get
  }
  @available(macOS 10.13, iOS 11.0, tvOS 11.0, watchOS 4.0, *)
  public var volumeSupportsImmutableFiles: Swift.Bool? {
    get
  }
  @available(macOS 10.13, iOS 11.0, tvOS 11.0, watchOS 4.0, *)
  public var volumeSupportsAccessPermissions: Swift.Bool? {
    get
  }
  public var isUbiquitousItem: Swift.Bool? {
    get
  }
  public var ubiquitousItemHasUnresolvedConflicts: Swift.Bool? {
    get
  }
  public var ubiquitousItemIsDownloading: Swift.Bool? {
    get
  }
  public var ubiquitousItemIsUploaded: Swift.Bool? {
    get
  }
  public var ubiquitousItemIsUploading: Swift.Bool? {
    get
  }
  public var ubiquitousItemDownloadingStatus: Foundation.URLUbiquitousItemDownloadingStatus? {
    get
  }
  public var ubiquitousItemDownloadingError: Foundation.NSError? {
    get
  }
  public var ubiquitousItemUploadingError: Foundation.NSError? {
    get
  }
  @available(macOS 10.10, iOS 8.0, *)
  public var ubiquitousItemDownloadRequested: Swift.Bool? {
    get
  }
  @available(macOS 10.10, iOS 8.0, *)
  public var ubiquitousItemContainerDisplayName: Swift.String? {
    get
  }
  @available(macOS 11.3, iOS 14.5, watchOS 7.4, tvOS 14.5, *)
  public var ubiquitousItemIsExcludedFromSync: Swift.Bool? {
    get
    set
  }
  @available(macOS 10.13, iOS 11.0, *)
  @available(tvOS, unavailable)
  @available(watchOS, unavailable)
  public var ubiquitousItemIsShared: Swift.Bool? {
    get
  }
  @available(macOS 10.13, iOS 11.0, *)
  @available(tvOS, unavailable)
  @available(watchOS, unavailable)
  public var ubiquitousSharedItemCurrentUserRole: Foundation.URLUbiquitousSharedItemRole? {
    get
  }
  @available(macOS 10.13, iOS 11.0, *)
  @available(tvOS, unavailable)
  @available(watchOS, unavailable)
  public var ubiquitousSharedItemCurrentUserPermissions: Foundation.URLUbiquitousSharedItemPermissions? {
    get
  }
  @available(macOS 10.13, iOS 11.0, *)
  @available(tvOS, unavailable)
  @available(watchOS, unavailable)
  public var ubiquitousSharedItemOwnerNameComponents: Foundation.PersonNameComponents? {
    get
  }
  @available(macOS 10.13, iOS 11.0, *)
  @available(tvOS, unavailable)
  @available(watchOS, unavailable)
  public var ubiquitousSharedItemMostRecentEditorNameComponents: Foundation.PersonNameComponents? {
    get
  }
  @available(macOS 11.0, iOS 9.0, *)
  public var fileProtection: Foundation.URLFileProtection? {
    get
  }
  public var fileSize: Swift.Int? {
    get
  }
  public var fileAllocatedSize: Swift.Int? {
    get
  }
  public var totalFileSize: Swift.Int? {
    get
  }
  public var totalFileAllocatedSize: Swift.Int? {
    get
  }
  public var isAliasFile: Swift.Bool? {
    get
  }
}
public struct URL : Foundation.ReferenceConvertible, Swift.Equatable {
  public typealias ReferenceType = Foundation.NSURL
  public typealias BookmarkResolutionOptions = Foundation.NSURL.BookmarkResolutionOptions
  public typealias BookmarkCreationOptions = Foundation.NSURL.BookmarkCreationOptions
  public init?(string: __shared Swift.String)
  public init?(string: __shared Swift.String, relativeTo url: __shared Foundation.URL?)
  @available(macOS 10.11, iOS 9.0, *)
  public init(fileURLWithPath path: __shared Swift.String, isDirectory: Swift.Bool, relativeTo base: __shared Foundation.URL?)
  @available(macOS 10.11, iOS 9.0, *)
  public init(fileURLWithPath path: __shared Swift.String, relativeTo base: __shared Foundation.URL?)
  public init(fileURLWithPath path: __shared Swift.String, isDirectory: Swift.Bool)
  public init(fileURLWithPath path: __shared Swift.String)
  @available(macOS 10.11, iOS 9.0, *)
  public init?(dataRepresentation: __shared Foundation.Data, relativeTo url: __shared Foundation.URL?, isAbsolute: Swift.Bool = false)
  @available(swift, obsoleted: 4.2)
  public init?(resolvingBookmarkData data: __shared Foundation.Data, options: Foundation.URL.BookmarkResolutionOptions = [], relativeTo url: __shared Foundation.URL? = nil, bookmarkDataIsStale: inout Swift.Bool) throws
  @available(swift 4.2)
  public init(resolvingBookmarkData data: __shared Foundation.Data, options: Foundation.URL.BookmarkResolutionOptions = [], relativeTo url: __shared Foundation.URL? = nil, bookmarkDataIsStale: inout Swift.Bool) throws
  @available(macOS 10.10, iOS 8.0, *)
  public init(resolvingAliasFileAt url: __shared Foundation.URL, options: Foundation.URL.BookmarkResolutionOptions = []) throws
  public init(fileURLWithFileSystemRepresentation path: Swift.UnsafePointer<Swift.Int8>, isDirectory: Swift.Bool, relativeTo baseURL: __shared Foundation.URL?)
  public func hash(into hasher: inout Swift.Hasher)
  @available(macOS 10.11, iOS 9.0, *)
  public var dataRepresentation: Foundation.Data {
    get
  }
  public var absoluteString: Swift.String {
    get
  }
  public var relativeString: Swift.String {
    get
  }
  public var baseURL: Foundation.URL? {
    get
  }
  public var absoluteURL: Foundation.URL {
    get
  }
  public var scheme: Swift.String? {
    get
  }
  public var isFileURL: Swift.Bool {
    get
  }
  @available(*, unavailable, message: "Use `path`, `query`, and `fragment` instead")
  public var resourceSpecifier: Swift.String {
    get
  }
  public var host: Swift.String? {
    get
  }
  public var port: Swift.Int? {
    get
  }
  public var user: Swift.String? {
    get
  }
  public var password: Swift.String? {
    get
  }
  public var path: Swift.String {
    get
  }
  public var relativePath: Swift.String {
    get
  }
  public var fragment: Swift.String? {
    get
  }
  @available(*, unavailable, message: "use the 'path' property")
  public var parameterString: Swift.String? {
    get
  }
  public var query: Swift.String? {
    get
  }
  @available(macOS 10.11, iOS 9.0, *)
  public var hasDirectoryPath: Swift.Bool {
    get
  }
  @available(macOS 10.9, iOS 7.0, *)
  public func withUnsafeFileSystemRepresentation<ResultType>(_ block: (Swift.UnsafePointer<Swift.Int8>?) throws -> ResultType) rethrows -> ResultType
  public var pathComponents: [Swift.String] {
    get
  }
  public var lastPathComponent: Swift.String {
    get
  }
  public var pathExtension: Swift.String {
    get
  }
  public func appendingPathComponent(_ pathComponent: Swift.String, isDirectory: Swift.Bool) -> Foundation.URL
  public func appendingPathComponent(_ pathComponent: Swift.String) -> Foundation.URL
  public func deletingLastPathComponent() -> Foundation.URL
  public func appendingPathExtension(_ pathExtension: Swift.String) -> Foundation.URL
  public func deletingPathExtension() -> Foundation.URL
  public mutating func appendPathComponent(_ pathComponent: Swift.String, isDirectory: Swift.Bool)
  public mutating func appendPathComponent(_ pathComponent: Swift.String)
  public mutating func appendPathExtension(_ pathExtension: Swift.String)
  public mutating func deleteLastPathComponent()
  public mutating func deletePathExtension()
  public var standardized: Foundation.URL {
    get
  }
  public mutating func standardize()
  public var standardizedFileURL: Foundation.URL {
    get
  }
  public func resolvingSymlinksInPath() -> Foundation.URL
  public mutating func resolveSymlinksInPath()
  public func checkResourceIsReachable() throws -> Swift.Bool
  @available(macOS 10.10, iOS 8.0, *)
  public func checkPromisedItemIsReachable() throws -> Swift.Bool
  public mutating func setResourceValues(_ values: Foundation.URLResourceValues) throws
  public func resourceValues(forKeys keys: Swift.Set<Foundation.URLResourceKey>) throws -> Foundation.URLResourceValues
  public mutating func setTemporaryResourceValue(_ value: Any, forKey key: Foundation.URLResourceKey)
  public mutating func removeAllCachedResourceValues()
  public mutating func removeCachedResourceValue(forKey key: Foundation.URLResourceKey)
  @available(macOS 10.10, iOS 8.0, *)
  public func promisedItemResourceValues(forKeys keys: Swift.Set<Foundation.URLResourceKey>) throws -> Foundation.URLResourceValues
  @available(*, unavailable, message: "Use struct URLResourceValues and URL.setResourceValues(_:) instead")
  public func setResourceValue(_ value: Swift.AnyObject?, forKey key: Foundation.URLResourceKey) throws
  @available(*, unavailable, message: "Use struct URLResourceValues and URL.setResourceValues(_:) instead")
  public func setResourceValues(_ keyedValues: [Foundation.URLResourceKey : Swift.AnyObject]) throws
  @available(*, unavailable, message: "Use struct URLResourceValues and URL.setResourceValues(_:) instead")
  public func getResourceValue(_ value: Swift.AutoreleasingUnsafeMutablePointer<Swift.AnyObject?>, forKey key: Foundation.URLResourceKey) throws
  public func bookmarkData(options: Foundation.URL.BookmarkCreationOptions = [], includingResourceValuesForKeys keys: Swift.Set<Foundation.URLResourceKey>? = nil, relativeTo url: Foundation.URL? = nil) throws -> Foundation.Data
  public static func resourceValues(forKeys keys: Swift.Set<Foundation.URLResourceKey>, fromBookmarkData data: Foundation.Data) -> Foundation.URLResourceValues?
  public static func writeBookmarkData(_ data: Foundation.Data, to url: Foundation.URL) throws
  public static func bookmarkData(withContentsOf url: Foundation.URL) throws -> Foundation.Data
  @available(macOS 10.7, iOS 8.0, *)
  public func startAccessingSecurityScopedResource() -> Swift.Bool
  @available(macOS 10.7, iOS 8.0, *)
  public func stopAccessingSecurityScopedResource()
  public static func == (lhs: Foundation.URL, rhs: Foundation.URL) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
extension URL : Swift._ObjectiveCBridgeable {
  @_semantics("convertToObjectiveC") public func _bridgeToObjectiveC() -> Foundation.NSURL
  public static func _forceBridgeFromObjectiveC(_ source: Foundation.NSURL, result: inout Foundation.URL?)
  public static func _conditionallyBridgeFromObjectiveC(_ source: Foundation.NSURL, result: inout Foundation.URL?) -> Swift.Bool
  @_effects(readonly) public static func _unconditionallyBridgeFromObjectiveC(_ source: Foundation.NSURL?) -> Foundation.URL
  public typealias _ObjectiveCType = Foundation.NSURL
}
extension URL : Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible {
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
}
extension NSURL : Swift._HasCustomAnyHashableRepresentation {
  @nonobjc public func _toCustomAnyHashable() -> Swift.AnyHashable?
}
extension URL : Swift._CustomPlaygroundQuickLookable {
  @available(*, deprecated, message: "URL.customPlaygroundQuickLook will be removed in a future Swift version")
  public var customPlaygroundQuickLook: Swift.PlaygroundQuickLook {
    get
  }
}
extension URL : Swift.Codable {
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
extension URL : Swift._ExpressibleByFileReferenceLiteral {
  public init(fileReferenceLiteralResourceName name: Swift.String)
}
public typealias _FileReferenceLiteralType = Foundation.URL
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension URLSession {
  public func dataTaskPublisher(for url: Foundation.URL) -> Foundation.URLSession.DataTaskPublisher
  public func dataTaskPublisher(for request: Foundation.URLRequest) -> Foundation.URLSession.DataTaskPublisher
  public struct DataTaskPublisher : Combine.Publisher {
    public typealias Output = (data: Foundation.Data, response: Foundation.URLResponse)
    public typealias Failure = Foundation.URLError
    public let request: Foundation.URLRequest
    public let session: Foundation.URLSession
    public init(request: Foundation.URLRequest, session: Foundation.URLSession)
    public func receive<S>(subscriber: S) where S : Combine.Subscriber, S.Failure == Foundation.URLSession.DataTaskPublisher.Failure, S.Input == Foundation.URLSession.DataTaskPublisher.Output
  }
}
@_objcRuntimeName(_TtC10Foundation13__JSONEncoder) open class JSONEncoder {
  public struct OutputFormatting : Swift.OptionSet {
    public let rawValue: Swift.UInt
    public init(rawValue: Swift.UInt)
    public static let prettyPrinted: Foundation.JSONEncoder.OutputFormatting
    @available(macOS 10.13, iOS 11.0, watchOS 4.0, tvOS 11.0, *)
    public static let sortedKeys: Foundation.JSONEncoder.OutputFormatting
    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    public static let withoutEscapingSlashes: Foundation.JSONEncoder.OutputFormatting
    public typealias ArrayLiteralElement = Foundation.JSONEncoder.OutputFormatting
    public typealias Element = Foundation.JSONEncoder.OutputFormatting
    public typealias RawValue = Swift.UInt
  }
  public enum DateEncodingStrategy {
    case deferredToDate
    case secondsSince1970
    case millisecondsSince1970
    @available(macOS 10.12, iOS 10.0, watchOS 3.0, tvOS 10.0, *)
    case iso8601
    case formatted(Foundation.DateFormatter)
    case custom((Foundation.Date, Swift.Encoder) throws -> Swift.Void)
  }
  public enum DataEncodingStrategy {
    case deferredToData
    case base64
    case custom((Foundation.Data, Swift.Encoder) throws -> Swift.Void)
  }
  public enum NonConformingFloatEncodingStrategy {
    case `throw`
    case convertToString(positiveInfinity: Swift.String, negativeInfinity: Swift.String, nan: Swift.String)
  }
  public enum KeyEncodingStrategy {
    case useDefaultKeys
    case convertToSnakeCase
    case custom(([Swift.CodingKey]) -> Swift.CodingKey)
  }
  open var outputFormatting: Foundation.JSONEncoder.OutputFormatting
  open var dateEncodingStrategy: Foundation.JSONEncoder.DateEncodingStrategy
  open var dataEncodingStrategy: Foundation.JSONEncoder.DataEncodingStrategy
  open var nonConformingFloatEncodingStrategy: Foundation.JSONEncoder.NonConformingFloatEncodingStrategy
  open var keyEncodingStrategy: Foundation.JSONEncoder.KeyEncodingStrategy
  open var userInfo: [Swift.CodingUserInfoKey : Any]
  public init()
  open func encode<T>(_ value: T) throws -> Foundation.Data where T : Swift.Encodable
  @objc deinit
}
@_objcRuntimeName(_TtC10Foundation13__JSONDecoder) open class JSONDecoder {
  public enum DateDecodingStrategy {
    case deferredToDate
    case secondsSince1970
    case millisecondsSince1970
    @available(macOS 10.12, iOS 10.0, watchOS 3.0, tvOS 10.0, *)
    case iso8601
    case formatted(Foundation.DateFormatter)
    case custom((Swift.Decoder) throws -> Foundation.Date)
  }
  public enum DataDecodingStrategy {
    case deferredToData
    case base64
    case custom((Swift.Decoder) throws -> Foundation.Data)
  }
  public enum NonConformingFloatDecodingStrategy {
    case `throw`
    case convertFromString(positiveInfinity: Swift.String, negativeInfinity: Swift.String, nan: Swift.String)
  }
  public enum KeyDecodingStrategy {
    case useDefaultKeys
    case convertFromSnakeCase
    case custom(([Swift.CodingKey]) -> Swift.CodingKey)
  }
  open var dateDecodingStrategy: Foundation.JSONDecoder.DateDecodingStrategy
  open var dataDecodingStrategy: Foundation.JSONDecoder.DataDecodingStrategy
  open var nonConformingFloatDecodingStrategy: Foundation.JSONDecoder.NonConformingFloatDecodingStrategy
  open var keyDecodingStrategy: Foundation.JSONDecoder.KeyDecodingStrategy
  open var userInfo: [Swift.CodingUserInfoKey : Any]
  public init()
  open func decode<T>(_ type: T.Type, from data: Foundation.Data) throws -> T where T : Swift.Decodable
  @objc deinit
}
extension NSDate : Swift._CustomPlaygroundQuickLookable {
  @available(*, deprecated, message: "NSDate.customPlaygroundQuickLook will be removed in a future Swift version")
  public var customPlaygroundQuickLook: Swift.PlaygroundQuickLook {
    get
  }
}
extension FileManager {
  @available(*, deprecated, renamed: "replaceItemAt(_:withItemAt:backupItemName:options:)")
  public func replaceItemAtURL(originalItemURL: Foundation.NSURL, withItemAtURL newItemURL: Foundation.NSURL, backupItemName: Swift.String? = nil, options: Foundation.FileManager.ItemReplacementOptions = []) throws -> Foundation.NSURL?
  @available(macOS 10.6, iOS 4.0, *)
  @available(swift, obsoleted: 4)
  public func replaceItemAt(_ originalItemURL: Foundation.URL, withItemAt newItemURL: Foundation.URL, backupItemName: Swift.String? = nil, options: Foundation.FileManager.ItemReplacementOptions = []) throws -> Foundation.NSURL?
  @available(swift 4)
  @available(macOS 10.6, iOS 4.0, *)
  public func replaceItemAt(_ originalItemURL: Foundation.URL, withItemAt newItemURL: Foundation.URL, backupItemName: Swift.String? = nil, options: Foundation.FileManager.ItemReplacementOptions = []) throws -> Foundation.URL?
  @available(macOS 10.6, iOS 4.0, *)
  @nonobjc public func enumerator(at url: Foundation.URL, includingPropertiesForKeys keys: [Foundation.URLResourceKey]?, options mask: Foundation.FileManager.DirectoryEnumerationOptions = [], errorHandler handler: ((Foundation.URL, Swift.Error) -> Swift.Bool)? = nil) -> Foundation.FileManager.DirectoryEnumerator?
}
extension NSExpression {
  convenience public init(format expressionFormat: __shared Swift.String, _ args: Swift.CVarArg...)
}
extension NSExpression {
  convenience public init<Root, Value>(forKeyPath keyPath: Swift.KeyPath<Root, Value>)
}
extension NSData : Foundation.DataProtocol {
  @nonobjc public var startIndex: Swift.Int {
    get
  }
  @nonobjc public var endIndex: Swift.Int {
    get
  }
  @nonobjc public func lastRange<D, R>(of data: D, in r: R) -> Swift.Range<Swift.Int>? where D : Foundation.DataProtocol, R : Swift.RangeExpression, R.Bound == Foundation.NSData.Index
  @nonobjc public func firstRange<D, R>(of data: D, in r: R) -> Swift.Range<Swift.Int>? where D : Foundation.DataProtocol, R : Swift.RangeExpression, R.Bound == Foundation.NSData.Index
  @nonobjc public var regions: [Foundation.Data] {
    get
  }
  @nonobjc public subscript(position: Swift.Int) -> Swift.UInt8 {
    get
  }
  public typealias Element = Swift.UInt8
  public typealias Index = Swift.Int
  public typealias Indices = Swift.Range<Swift.Int>
  public typealias Iterator = Swift.IndexingIterator<Foundation.NSData>
  public typealias Regions = [Foundation.Data]
  public typealias SubSequence = Swift.Slice<Foundation.NSData>
}
extension NSCoder {
  @available(*, unavailable, renamed: "decodeObject(of:forKey:)")
  public func decodeObjectOfClass<DecodedObjectType>(_ cls: DecodedObjectType.Type, forKey key: Swift.String) -> DecodedObjectType? where DecodedObjectType : ObjectiveC.NSObject, DecodedObjectType : Foundation.NSCoding
  public func decodeObject<DecodedObjectType>(of cls: DecodedObjectType.Type, forKey key: Swift.String) -> DecodedObjectType? where DecodedObjectType : ObjectiveC.NSObject, DecodedObjectType : Foundation.NSCoding
  @available(*, unavailable, renamed: "decodeObject(of:forKey:)")
  @nonobjc public func decodeObjectOfClasses(_ classes: Foundation.NSSet?, forKey key: Swift.String) -> Swift.AnyObject?
  @nonobjc public func decodeObject(of classes: [Swift.AnyClass]?, forKey key: Swift.String) -> Any?
  @available(macOS 10.11, iOS 9.0, *)
  @available(macOS, introduced: 10.11, deprecated: 100000.0, message: "Use decodeTopLevelObject(of:forKey:) instead")
  @available(iOS, introduced: 9.0, deprecated: 100000.0, message: "Use decodeTopLevelObject(of:forKey:) instead")
  @available(tvOS, introduced: 9.0, deprecated: 100000.0, message: "Use decodeTopLevelObject(of:forKey:) instead")
  @available(watchOS, introduced: 2.0, deprecated: 100000.0, message: "Use decodeTopLevelObject(of:forKey:) instead")
  @nonobjc public func decodeTopLevelObject() throws -> Any?
  @available(*, unavailable, renamed: "decodeTopLevelObject(forKey:)")
  public func decodeTopLevelObjectForKey(_ key: Swift.String) throws -> Swift.AnyObject?
  @available(macOS 10.11, iOS 9.0, *)
  @available(swift, obsoleted: 4)
  @available(macOS, introduced: 10.11, deprecated: 100000.0, message: "Use decodeTopLevelObject(of:forKey:) instead")
  @available(iOS, introduced: 9.0, deprecated: 100000.0, message: "Use decodeTopLevelObject(of:forKey:) instead")
  @available(tvOS, introduced: 9.0, deprecated: 100000.0, message: "Use decodeTopLevelObject(of:forKey:) instead")
  @available(watchOS, introduced: 2.0, deprecated: 100000.0, message: "Use decodeTopLevelObject(of:forKey:) instead")
  @nonobjc public func decodeTopLevelObject(forKey key: Swift.String) throws -> Swift.AnyObject?
  @available(swift 4)
  @available(macOS 10.11, iOS 9.0, *)
  @available(macOS, introduced: 10.11, deprecated: 100000.0, message: "Use decodeTopLevelObject(of:forKey:) instead")
  @available(iOS, introduced: 9.0, deprecated: 100000.0, message: "Use decodeTopLevelObject(of:forKey:) instead")
  @available(tvOS, introduced: 9.0, deprecated: 100000.0, message: "Use decodeTopLevelObject(of:forKey:) instead")
  @available(watchOS, introduced: 2.0, deprecated: 100000.0, message: "Use decodeTopLevelObject(of:forKey:) instead")
  @nonobjc public func decodeTopLevelObject(forKey key: Swift.String) throws -> Any?
  @available(*, unavailable, renamed: "decodeTopLevelObject(of:forKey:)")
  public func decodeTopLevelObjectOfClass<DecodedObjectType>(_ cls: DecodedObjectType.Type, forKey key: Swift.String) throws -> DecodedObjectType? where DecodedObjectType : ObjectiveC.NSObject, DecodedObjectType : Foundation.NSCoding
  @available(macOS 10.11, iOS 9.0, *)
  public func decodeTopLevelObject<DecodedObjectType>(of cls: DecodedObjectType.Type, forKey key: Swift.String) throws -> DecodedObjectType? where DecodedObjectType : ObjectiveC.NSObject, DecodedObjectType : Foundation.NSCoding
  @available(*, unavailable, renamed: "decodeTopLevelObject(of:forKey:)")
  @nonobjc public func decodeTopLevelObjectOfClasses(_ classes: Foundation.NSSet?, forKey key: Swift.String) throws -> Swift.AnyObject?
  @available(macOS 10.11, iOS 9.0, *)
  @nonobjc public func decodeTopLevelObject(of classes: [Swift.AnyClass]?, forKey key: Swift.String) throws -> Any?
  @available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
  @nonobjc public func decodeArrayOfObjects<DecodedObject>(ofClass cls: DecodedObject.Type, forKey key: Swift.String) -> [DecodedObject]? where DecodedObject : ObjectiveC.NSObject, DecodedObject : Foundation.NSSecureCoding
  @available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
  @nonobjc public func decodeArrayOfObjects(ofClasses classes: [Swift.AnyClass], forKey key: Swift.String) -> [Any]?
  @available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
  @nonobjc public func decodeDictionary<DecodedKey, DecodedObject>(withKeyClass keyClass: DecodedKey.Type, objectClass: DecodedObject.Type, forKey key: Swift.String) -> [DecodedKey : DecodedObject]? where DecodedKey : ObjectiveC.NSObject, DecodedKey : Foundation.NSCopying, DecodedKey : Foundation.NSSecureCoding, DecodedObject : ObjectiveC.NSObject, DecodedObject : Foundation.NSSecureCoding
  @available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
  @nonobjc public func decodeDictionary(withKeysOfClasses keyClasses: [Swift.AnyClass], objectsOfClasses classes: [Swift.AnyClass], forKey key: Swift.String) -> [Swift.AnyHashable : Any]?
}
extension NSKeyedArchiver {
  @available(macOS 10.11, iOS 9.0, *)
  @nonobjc public func encodeEncodable<T>(_ value: T, forKey key: Swift.String) throws where T : Swift.Encodable
}
extension NSKeyedUnarchiver {
  @available(macOS 10.11, iOS 9.0, *)
  @available(swift, obsoleted: 4)
  @available(macOS, introduced: 10.11, deprecated: 100000.0, message: "Use unarchivedObject(ofClass:from:) instead")
  @available(iOS, introduced: 9.0, deprecated: 100000.0, message: "Use unarchivedObject(ofClass:from:) instead")
  @available(tvOS, introduced: 9.0, deprecated: 100000.0, message: "Use unarchivedObject(ofClass:from:) instead")
  @available(watchOS, introduced: 2.0, deprecated: 100000.0, message: "Use unarchivedObject(ofClass:from:) instead")
  @nonobjc public class func unarchiveTopLevelObjectWithData(_ data: Foundation.NSData) throws -> Swift.AnyObject?
  @available(swift 4)
  @available(macOS 10.11, iOS 9.0, *)
  @available(macOS, introduced: 10.11, deprecated: 100000.0, message: "Use unarchivedObject(ofClass:from:) instead")
  @available(iOS, introduced: 9.0, deprecated: 100000.0, message: "Use unarchivedObject(ofClass:from:) instead")
  @available(tvOS, introduced: 9.0, deprecated: 100000.0, message: "Use unarchivedObject(ofClass:from:) instead")
  @available(watchOS, introduced: 2.0, deprecated: 100000.0, message: "Use unarchivedObject(ofClass:from:) instead")
  @nonobjc public class func unarchiveTopLevelObjectWithData(_ data: Foundation.Data) throws -> Any?
  @available(macOS 10.13, iOS 11.0, watchOS 4.0, tvOS 11.0, *)
  @nonobjc public static func unarchivedObject<DecodedObjectType>(ofClass cls: DecodedObjectType.Type, from data: Foundation.Data) throws -> DecodedObjectType? where DecodedObjectType : ObjectiveC.NSObject, DecodedObjectType : Foundation.NSCoding
  @available(macOS 10.13, iOS 11.0, watchOS 4.0, tvOS 11.0, *)
  @nonobjc public static func unarchivedObject(ofClasses classes: [Swift.AnyClass], from data: Foundation.Data) throws -> Any?
  @available(macOS 10.11, iOS 9.0, *)
  @nonobjc public func decodeDecodable<T>(_ type: T.Type, forKey key: Swift.String) -> T? where T : Swift.Decodable
  @available(macOS 10.11, iOS 9.0, *)
  @nonobjc public func decodeTopLevelDecodable<T>(_ type: T.Type, forKey key: Swift.String) throws -> T? where T : Swift.Decodable
  @available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
  @nonobjc public static func unarchivedArrayOfObjects<DecodedObject>(ofClass cls: DecodedObject.Type, from data: Foundation.Data) throws -> [DecodedObject]? where DecodedObject : ObjectiveC.NSObject, DecodedObject : Foundation.NSSecureCoding
  @available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
  @nonobjc public static func unarchivedArrayOfObjects(ofClasses classes: [Swift.AnyClass], from data: Foundation.Data) throws -> [Any]?
  @available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
  @nonobjc public static func unarchivedDictionary<DecodedKey, DecodedObject>(ofKeyClass keyClass: DecodedKey.Type, objectClass: DecodedObject.Type, from data: Foundation.Data) throws -> [DecodedKey : DecodedObject]? where DecodedKey : ObjectiveC.NSObject, DecodedKey : Foundation.NSCopying, DecodedKey : Foundation.NSSecureCoding, DecodedObject : ObjectiveC.NSObject, DecodedObject : Foundation.NSSecureCoding
  @available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
  @nonobjc public static func unarchivedDictionary(keysOfClasses keyClasses: [Swift.AnyClass], objectsOfClasses objectClasses: [Swift.AnyClass], from data: Foundation.Data) throws -> [Swift.AnyHashable : Any]?
}
extension DispatchData : Foundation.DataProtocol {
  public struct Region : Foundation.DataProtocol, Foundation.ContiguousBytes {
    public var regions: Swift.CollectionOfOne<Dispatch.DispatchData.Region> {
      get
    }
    public subscript(position: Dispatch.DispatchData.Index) -> Swift.UInt8 {
      get
    }
    public var startIndex: Dispatch.DispatchData.Index {
      get
    }
    public var endIndex: Dispatch.DispatchData.Index {
      get
    }
    public func withUnsafeBytes<ResultType>(_ body: (Swift.UnsafeRawBufferPointer) throws -> ResultType) rethrows -> ResultType
    public typealias Element = Swift.UInt8
    public typealias Index = Dispatch.DispatchData.Index
    public typealias Indices = Swift.Range<Dispatch.DispatchData.Index>
    public typealias Iterator = Swift.IndexingIterator<Dispatch.DispatchData.Region>
    public typealias Regions = Swift.CollectionOfOne<Dispatch.DispatchData.Region>
    public typealias SubSequence = Swift.Slice<Dispatch.DispatchData.Region>
  }
  public var regions: [Dispatch.DispatchData.Region] {
    get
  }
  public typealias Regions = [Dispatch.DispatchData.Region]
}
@available(macOS 10.8, iOS 6.0, *)
public struct UUID : Foundation.ReferenceConvertible, Swift.Hashable, Swift.Equatable, Swift.CustomStringConvertible {
  public typealias ReferenceType = Foundation.NSUUID
  public var uuid: (Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8) {
    get
  }
  public init()
  public init?(uuidString string: __shared Swift.String)
  public init(uuid: Darwin.uuid_t)
  public var uuidString: Swift.String {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
  public static func == (lhs: Foundation.UUID, rhs: Foundation.UUID) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
extension UUID : Swift.CustomReflectable {
  public var customMirror: Swift.Mirror {
    get
  }
}
extension UUID : Swift._ObjectiveCBridgeable {
  @_semantics("convertToObjectiveC") public func _bridgeToObjectiveC() -> Foundation.NSUUID
  public static func _forceBridgeFromObjectiveC(_ x: Foundation.NSUUID, result: inout Foundation.UUID?)
  public static func _conditionallyBridgeFromObjectiveC(_ input: Foundation.NSUUID, result: inout Foundation.UUID?) -> Swift.Bool
  @_effects(readonly) public static func _unconditionallyBridgeFromObjectiveC(_ source: Foundation.NSUUID?) -> Foundation.UUID
  public typealias _ObjectiveCType = Foundation.NSUUID
}
extension NSUUID : Swift._HasCustomAnyHashableRepresentation {
  @nonobjc public func _toCustomAnyHashable() -> Swift.AnyHashable?
}
extension UUID : Swift.Codable {
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
extension Decimal {
  public typealias RoundingMode = Foundation.NSDecimalNumber.RoundingMode
  public typealias CalculationError = Foundation.NSDecimalNumber.CalculationError
}
public func pow(_ x: Foundation.Decimal, _ y: Swift.Int) -> Foundation.Decimal
extension Decimal : Swift.Hashable, Swift.Comparable {
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (lhs: Foundation.Decimal, rhs: Foundation.Decimal) -> Swift.Bool
  public static func < (lhs: Foundation.Decimal, rhs: Foundation.Decimal) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
extension Decimal : Swift.CustomStringConvertible {
  public init?(string: __shared Swift.String, locale: __shared Foundation.Locale? = nil)
  public var description: Swift.String {
    get
  }
}
extension Decimal : Swift.Codable {
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
extension Decimal : Swift.ExpressibleByFloatLiteral {
  public init(floatLiteral value: Swift.Double)
  public typealias FloatLiteralType = Swift.Double
}
extension Decimal : Swift.ExpressibleByIntegerLiteral {
  public init(integerLiteral value: Swift.Int)
  public typealias IntegerLiteralType = Swift.Int
}
extension Decimal : Swift.SignedNumeric {
  public var magnitude: Foundation.Decimal {
    get
  }
  public init?<T>(exactly source: T) where T : Swift.BinaryInteger
  public static func += (lhs: inout Foundation.Decimal, rhs: Foundation.Decimal)
  public static func -= (lhs: inout Foundation.Decimal, rhs: Foundation.Decimal)
  public static func *= (lhs: inout Foundation.Decimal, rhs: Foundation.Decimal)
  public static func /= (lhs: inout Foundation.Decimal, rhs: Foundation.Decimal)
  public static func + (lhs: Foundation.Decimal, rhs: Foundation.Decimal) -> Foundation.Decimal
  public static func - (lhs: Foundation.Decimal, rhs: Foundation.Decimal) -> Foundation.Decimal
  public static func * (lhs: Foundation.Decimal, rhs: Foundation.Decimal) -> Foundation.Decimal
  public static func / (lhs: Foundation.Decimal, rhs: Foundation.Decimal) -> Foundation.Decimal
  public mutating func negate()
  public typealias Magnitude = Foundation.Decimal
}
extension Decimal {
  @available(swift, obsoleted: 4, message: "Please use arithmetic operators instead")
  @_transparent public mutating func add(_ other: Foundation.Decimal) {
        self += other
    }
  @available(swift, obsoleted: 4, message: "Please use arithmetic operators instead")
  @_transparent public mutating func subtract(_ other: Foundation.Decimal) {
        self -= other
    }
  @available(swift, obsoleted: 4, message: "Please use arithmetic operators instead")
  @_transparent public mutating func multiply(by other: Foundation.Decimal) {
        self *= other
    }
  @available(swift, obsoleted: 4, message: "Please use arithmetic operators instead")
  @_transparent public mutating func divide(by other: Foundation.Decimal) {
        self /= other
    }
}
extension Decimal : Swift.Strideable {
  public func distance(to other: Foundation.Decimal) -> Foundation.Decimal
  public func advanced(by n: Foundation.Decimal) -> Foundation.Decimal
  public typealias Stride = Foundation.Decimal
}
extension Decimal {
  public static let leastFiniteMagnitude: Foundation.Decimal
  public static let greatestFiniteMagnitude: Foundation.Decimal
  public static let leastNormalMagnitude: Foundation.Decimal
  public static let leastNonzeroMagnitude: Foundation.Decimal
  public static let pi: Foundation.Decimal
  @available(*, unavailable, message: "Decimal does not yet fully adopt FloatingPoint.")
  public static var infinity: Foundation.Decimal {
    get
  }
  @available(*, unavailable, message: "Decimal does not yet fully adopt FloatingPoint.")
  public static var signalingNaN: Foundation.Decimal {
    get
  }
  public static var quietNaN: Foundation.Decimal {
    get
  }
  public static var nan: Foundation.Decimal {
    get
  }
  public static var radix: Swift.Int {
    get
  }
  public init(_ value: Swift.UInt8)
  public init(_ value: Swift.Int8)
  public init(_ value: Swift.UInt16)
  public init(_ value: Swift.Int16)
  public init(_ value: Swift.UInt32)
  public init(_ value: Swift.Int32)
  public init(_ value: Swift.UInt64)
  public init(_ value: Swift.Int64)
  public init(_ value: Swift.UInt)
  public init(_ value: Swift.Int)
  public init(_ value: Swift.Double)
  public init(sign: Swift.FloatingPointSign, exponent: Swift.Int, significand: Foundation.Decimal)
  public init(signOf: Foundation.Decimal, magnitudeOf magnitude: Foundation.Decimal)
  public var exponent: Swift.Int {
    get
  }
  public var significand: Foundation.Decimal {
    get
  }
  public var sign: Swift.FloatingPointSign {
    get
  }
  public var ulp: Foundation.Decimal {
    get
  }
  public var nextUp: Foundation.Decimal {
    get
  }
  public var nextDown: Foundation.Decimal {
    get
  }
  public var floatingPointClass: Swift.FloatingPointClassification {
    get
  }
  public var isCanonical: Swift.Bool {
    get
  }
  public var isSignMinus: Swift.Bool {
    get
  }
  public var isZero: Swift.Bool {
    get
  }
  public var isSubnormal: Swift.Bool {
    get
  }
  public var isNormal: Swift.Bool {
    get
  }
  public var isFinite: Swift.Bool {
    get
  }
  public var isInfinite: Swift.Bool {
    get
  }
  public var isNaN: Swift.Bool {
    get
  }
  public var isSignaling: Swift.Bool {
    get
  }
  public var isSignalingNaN: Swift.Bool {
    get
  }
  public func isEqual(to other: Foundation.Decimal) -> Swift.Bool
  public func isLess(than other: Foundation.Decimal) -> Swift.Bool
  public func isLessThanOrEqualTo(_ other: Foundation.Decimal) -> Swift.Bool
  public func isTotallyOrdered(belowOrEqualTo other: Foundation.Decimal) -> Swift.Bool
  @available(*, unavailable, message: "Decimal does not yet fully adopt FloatingPoint.")
  public mutating func formTruncatingRemainder(dividingBy other: Foundation.Decimal)
}
extension Decimal : Swift._ObjectiveCBridgeable {
  @_semantics("convertToObjectiveC") public func _bridgeToObjectiveC() -> Foundation.NSDecimalNumber
  public static func _forceBridgeFromObjectiveC(_ x: Foundation.NSDecimalNumber, result: inout Foundation.Decimal?)
  public static func _conditionallyBridgeFromObjectiveC(_ input: Foundation.NSDecimalNumber, result: inout Foundation.Decimal?) -> Swift.Bool
  @_effects(readonly) public static func _unconditionallyBridgeFromObjectiveC(_ source: Foundation.NSDecimalNumber?) -> Foundation.Decimal
  public typealias _ObjectiveCType = Foundation.NSDecimalNumber
}
extension URLCache {
  @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
  convenience public init(memoryCapacity: Swift.Int, diskCapacity: Swift.Int, directory: Foundation.URL? = nil)
}
extension UnsafeRawBufferPointer : Foundation.DataProtocol {
  public var regions: Swift.CollectionOfOne<Swift.UnsafeRawBufferPointer> {
    get
  }
  public typealias Regions = Swift.CollectionOfOne<Swift.UnsafeRawBufferPointer>
}
extension UnsafeBufferPointer : Foundation.DataProtocol where Element == Swift.UInt8 {
  public var regions: Swift.CollectionOfOne<Swift.UnsafeBufferPointer<Swift.UInt8>> {
    get
  }
  public typealias Regions = Swift.CollectionOfOne<Swift.UnsafeBufferPointer<Swift.UInt8>>
}
extension NSRectEdge {
  @inlinable public init(rectEdge: CoreGraphics.CGRectEdge) {
    self = NSRectEdge(rawValue: UInt(rectEdge.rawValue))!
  }
}
extension CGRectEdge {
  @inlinable public init(rectEdge: Foundation.NSRectEdge) {
    self = CGRectEdge(rawValue: UInt32(rectEdge.rawValue))!
  }
}
public typealias NSErrorPointer = Swift.AutoreleasingUnsafeMutablePointer<Foundation.NSError?>?
public typealias ErrorPointer = Foundation.NSErrorPointer
public func _convertNSErrorToError(_ error: Foundation.NSError?) -> Swift.Error
public func _convertErrorToNSError(_ error: Swift.Error) -> Foundation.NSError
public protocol LocalizedError : Swift.Error {
  var errorDescription: Swift.String? { get }
  var failureReason: Swift.String? { get }
  var recoverySuggestion: Swift.String? { get }
  var helpAnchor: Swift.String? { get }
}
extension LocalizedError {
  public var errorDescription: Swift.String? {
    get
  }
  public var failureReason: Swift.String? {
    get
  }
  public var recoverySuggestion: Swift.String? {
    get
  }
  public var helpAnchor: Swift.String? {
    get
  }
}
public protocol RecoverableError : Swift.Error {
  var recoveryOptions: [Swift.String] { get }
  func attemptRecovery(optionIndex recoveryOptionIndex: Swift.Int, resultHandler handler: @escaping (Swift.Bool) -> Swift.Void)
  func attemptRecovery(optionIndex recoveryOptionIndex: Swift.Int) -> Swift.Bool
}
extension RecoverableError {
  public func attemptRecovery(optionIndex recoveryOptionIndex: Swift.Int, resultHandler handler: @escaping (Swift.Bool) -> Swift.Void)
}
public protocol CustomNSError : Swift.Error {
  static var errorDomain: Swift.String { get }
  var errorCode: Swift.Int { get }
  var errorUserInfo: [Swift.String : Any] { get }
}
extension CustomNSError {
  public static var errorDomain: Swift.String {
    get
  }
  public var errorCode: Swift.Int {
    get
  }
  public var errorUserInfo: [Swift.String : Any] {
    get
  }
}
extension CustomNSError where Self : Swift.RawRepresentable, Self.RawValue : Swift.FixedWidthInteger {
  public var errorCode: Swift.Int {
    get
  }
}
extension Error where Self : Foundation.CustomNSError {
  public var _domain: Swift.String {
    get
  }
  public var _code: Swift.Int {
    get
  }
}
extension Error where Self : Foundation.CustomNSError, Self : Swift.RawRepresentable, Self.RawValue : Swift.FixedWidthInteger {
  public var _code: Swift.Int {
    get
  }
}
extension Error {
  public var localizedDescription: Swift.String {
    get
  }
}
public func _getErrorDefaultUserInfo<T>(_ error: T) -> Swift.AnyObject? where T : Swift.Error
extension NSError : Swift.Error {
  @nonobjc public var _domain: Swift.String {
    get
  }
  @nonobjc public var _code: Swift.Int {
    get
  }
  @nonobjc public var _userInfo: Swift.AnyObject? {
    get
  }
  @nonobjc public func _getEmbeddedNSError() -> Swift.AnyObject?
}
extension CFError : Swift.Error {
  public var _domain: Swift.String {
    get
  }
  public var _code: Swift.Int {
    get
  }
  public var _userInfo: Swift.AnyObject? {
    get
  }
  public func _getEmbeddedNSError() -> Swift.AnyObject?
}
public protocol _ObjectiveCBridgeableError : Swift.Error {
  init?(_bridgedNSError: __shared Foundation.NSError)
}
public func _bridgeNSErrorToError<T>(_ error: Foundation.NSError, out: Swift.UnsafeMutablePointer<T>) -> Swift.Bool where T : Foundation._ObjectiveCBridgeableError
public protocol _BridgedNSError : Foundation._ObjectiveCBridgeableError, Swift.Hashable, Swift.RawRepresentable where Self.RawValue : Swift.FixedWidthInteger {
  static var _nsErrorDomain: Swift.String { get }
}
extension _BridgedNSError {
  public var _domain: Swift.String {
    get
  }
}
extension _BridgedNSError {
  public var _code: Swift.Int {
    get
  }
  public init?(_bridgedNSError: __shared Foundation.NSError)
  public func hash(into hasher: inout Swift.Hasher)
}
public protocol _BridgedStoredNSError : Foundation.CustomNSError, Foundation._ObjectiveCBridgeableError, Swift.Hashable {
  associatedtype Code : Foundation._ErrorCodeProtocol, Swift.RawRepresentable where Self.Code.RawValue : Swift.FixedWidthInteger
  var _nsError: Foundation.NSError { get }
  init(_nsError error: Foundation.NSError)
}
extension _BridgedStoredNSError {
  public var code: Self.Code {
    get
  }
  public init(_ code: Self.Code, userInfo: [Swift.String : Any] = [:])
  public var userInfo: [Swift.String : Any] {
    get
  }
}
extension _BridgedStoredNSError {
  public init?(_bridgedNSError error: Foundation.NSError)
}
extension _BridgedStoredNSError {
  public var errorCode: Swift.Int {
    get
  }
  public var errorUserInfo: [Swift.String : Any] {
    get
  }
}
extension _BridgedStoredNSError {
  public func hash(into hasher: inout Swift.Hasher)
  @_alwaysEmitIntoClient public var hashValue: Swift.Int {
    get {
    return _nsError.hashValue
  }
  }
}
public protocol _ErrorCodeProtocol : Swift.Equatable {
  associatedtype _ErrorType : Foundation._BridgedStoredNSError where Self == Self._ErrorType.Code
}
extension _ErrorCodeProtocol {
  public static func ~= (match: Self, error: Swift.Error) -> Swift.Bool
}
extension _BridgedStoredNSError {
  public func _getEmbeddedNSError() -> Swift.AnyObject?
  public static func == (lhs: Self, rhs: Self) -> Swift.Bool
}
extension _SwiftNewtypeWrapper where Self.RawValue == Swift.Error {
  @inlinable public func _bridgeToObjectiveC() -> Foundation.NSError {
    return rawValue as NSError
  }
  @inlinable public static func _forceBridgeFromObjectiveC(_ source: Foundation.NSError, result: inout Self?) {
    result = Self(rawValue: source)
  }
  @inlinable public static func _conditionallyBridgeFromObjectiveC(_ source: Foundation.NSError, result: inout Self?) -> Swift.Bool {
    result = Self(rawValue: source)
    return result != nil
  }
  @inlinable @_effects(readonly) public static func _unconditionallyBridgeFromObjectiveC(_ source: Foundation.NSError?) -> Self {
    return Self(rawValue: _convertNSErrorToError(source))!
  }
}
@available(*, unavailable, renamed: "CocoaError")
public typealias NSCocoaError = Foundation.CocoaError
public struct CocoaError : Foundation._BridgedStoredNSError {
  public let _nsError: Foundation.NSError
  public init(_nsError error: Foundation.NSError)
  public static var errorDomain: Swift.String {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
  public struct Code : Swift.RawRepresentable, Swift.Hashable, Foundation._ErrorCodeProtocol {
    public typealias _ErrorType = Foundation.CocoaError
    public let rawValue: Swift.Int
    public init(rawValue: Swift.Int)
    public typealias RawValue = Swift.Int
  }
}
extension CocoaError {
  public var filePath: Swift.String? {
    get
  }
  public var stringEncoding: Swift.String.Encoding? {
    get
  }
  public var underlying: Swift.Error? {
    get
  }
  public var underlyingErrors: [Swift.Error] {
    get
  }
  public var url: Foundation.URL? {
    get
  }
}
extension CocoaError {
  public static func error(_ code: Foundation.CocoaError.Code, userInfo: [Swift.AnyHashable : Any]? = nil, url: Foundation.URL? = nil) -> Swift.Error
}
extension CocoaError.Code {
  public static var fileNoSuchFile: Foundation.CocoaError.Code {
    get
  }
  public static var fileLocking: Foundation.CocoaError.Code {
    get
  }
  public static var fileReadUnknown: Foundation.CocoaError.Code {
    get
  }
  public static var fileReadNoPermission: Foundation.CocoaError.Code {
    get
  }
  public static var fileReadInvalidFileName: Foundation.CocoaError.Code {
    get
  }
  public static var fileReadCorruptFile: Foundation.CocoaError.Code {
    get
  }
  public static var fileReadNoSuchFile: Foundation.CocoaError.Code {
    get
  }
  public static var fileReadInapplicableStringEncoding: Foundation.CocoaError.Code {
    get
  }
  public static var fileReadUnsupportedScheme: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.5, iOS 2.0, *)
  public static var fileReadTooLarge: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.5, iOS 2.0, *)
  public static var fileReadUnknownStringEncoding: Foundation.CocoaError.Code {
    get
  }
  public static var fileWriteUnknown: Foundation.CocoaError.Code {
    get
  }
  public static var fileWriteNoPermission: Foundation.CocoaError.Code {
    get
  }
  public static var fileWriteInvalidFileName: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.7, iOS 5.0, *)
  public static var fileWriteFileExists: Foundation.CocoaError.Code {
    get
  }
  public static var fileWriteInapplicableStringEncoding: Foundation.CocoaError.Code {
    get
  }
  public static var fileWriteUnsupportedScheme: Foundation.CocoaError.Code {
    get
  }
  public static var fileWriteOutOfSpace: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.6, iOS 4.0, *)
  public static var fileWriteVolumeReadOnly: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.11, *)
  @available(iOS, unavailable)
  public static var fileManagerUnmountUnknown: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.11, *)
  @available(iOS, unavailable)
  public static var fileManagerUnmountBusy: Foundation.CocoaError.Code {
    get
  }
  public static var keyValueValidation: Foundation.CocoaError.Code {
    get
  }
  public static var formatting: Foundation.CocoaError.Code {
    get
  }
  public static var userCancelled: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.8, iOS 6.0, *)
  public static var featureUnsupported: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.5, iOS 2.0, *)
  public static var executableNotLoadable: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.5, iOS 2.0, *)
  public static var executableArchitectureMismatch: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.5, iOS 2.0, *)
  public static var executableRuntimeMismatch: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.5, iOS 2.0, *)
  public static var executableLoad: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.5, iOS 2.0, *)
  public static var executableLink: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.6, iOS 4.0, *)
  public static var propertyListReadCorrupt: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.6, iOS 4.0, *)
  public static var propertyListReadUnknownVersion: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.6, iOS 4.0, *)
  public static var propertyListReadStream: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.6, iOS 4.0, *)
  public static var propertyListWriteStream: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.10, iOS 8.0, *)
  public static var propertyListWriteInvalid: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.8, iOS 6.0, *)
  public static var xpcConnectionInterrupted: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.8, iOS 6.0, *)
  public static var xpcConnectionInvalid: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.8, iOS 6.0, *)
  public static var xpcConnectionReplyInvalid: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.9, iOS 7.0, *)
  public static var ubiquitousFileUnavailable: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.9, iOS 7.0, *)
  public static var ubiquitousFileNotUploadedDueToQuota: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.9, iOS 7.0, *)
  public static var ubiquitousFileUbiquityServerNotAvailable: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.10, iOS 8.0, *)
  public static var userActivityHandoffFailed: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.10, iOS 8.0, *)
  public static var userActivityConnectionUnavailable: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.10, iOS 8.0, *)
  public static var userActivityRemoteApplicationTimedOut: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.10, iOS 8.0, *)
  public static var userActivityHandoffUserInfoTooLarge: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.11, iOS 9.0, *)
  public static var coderReadCorrupt: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.11, iOS 9.0, *)
  public static var coderValueNotFound: Foundation.CocoaError.Code {
    get
  }
  public static var coderInvalidValue: Foundation.CocoaError.Code {
    get
  }
}
extension CocoaError.Code {
  @available(*, deprecated, renamed: "fileNoSuchFile")
  public static var fileNoSuchFileError: Foundation.CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "fileLocking")
  public static var fileLockingError: Foundation.CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "fileReadUnknown")
  public static var fileReadUnknownError: Foundation.CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "fileReadNoPermission")
  public static var fileReadNoPermissionError: Foundation.CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "fileReadInvalidFileName")
  public static var fileReadInvalidFileNameError: Foundation.CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "fileReadCorruptFile")
  public static var fileReadCorruptFileError: Foundation.CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "fileReadNoSuchFile")
  public static var fileReadNoSuchFileError: Foundation.CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "fileReadInapplicableStringEncoding")
  public static var fileReadInapplicableStringEncodingError: Foundation.CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "fileReadUnsupportedScheme")
  public static var fileReadUnsupportedSchemeError: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.5, iOS 2.0, *)
  @available(*, deprecated, renamed: "fileReadTooLarge")
  public static var fileReadTooLargeError: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.5, iOS 2.0, *)
  @available(*, deprecated, renamed: "fileReadUnknownStringEncoding")
  public static var fileReadUnknownStringEncodingError: Foundation.CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "fileWriteUnknown")
  public static var fileWriteUnknownError: Foundation.CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "fileWriteNoPermission")
  public static var fileWriteNoPermissionError: Foundation.CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "fileWriteInvalidFileName")
  public static var fileWriteInvalidFileNameError: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.7, iOS 5.0, *)
  @available(*, deprecated, renamed: "fileWriteFileExists")
  public static var fileWriteFileExistsError: Foundation.CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "fileWriteInapplicableStringEncoding")
  public static var fileWriteInapplicableStringEncodingError: Foundation.CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "fileWriteUnsupportedScheme")
  public static var fileWriteUnsupportedSchemeError: Foundation.CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "fileWriteOutOfSpace")
  public static var fileWriteOutOfSpaceError: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.6, iOS 4.0, *)
  @available(*, deprecated, renamed: "fileWriteVolumeReadOnly")
  public static var fileWriteVolumeReadOnlyError: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.11, *)
  @available(iOS, unavailable)
  @available(*, deprecated, renamed: "fileManagerUnmountUnknown")
  public static var fileManagerUnmountUnknownError: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.11, *)
  @available(iOS, unavailable)
  @available(*, deprecated, renamed: "fileManagerUnmountBusy")
  public static var fileManagerUnmountBusyError: Foundation.CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "keyValueValidation")
  public static var keyValueValidationError: Foundation.CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "formatting")
  public static var formattingError: Foundation.CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "userCancelled")
  public static var userCancelledError: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.8, iOS 6.0, *)
  @available(*, deprecated, renamed: "featureUnsupported")
  public static var featureUnsupportedError: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.5, iOS 2.0, *)
  @available(*, deprecated, renamed: "executableNotLoadable")
  public static var executableNotLoadableError: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.5, iOS 2.0, *)
  @available(*, deprecated, renamed: "executableArchitectureMismatch")
  public static var executableArchitectureMismatchError: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.5, iOS 2.0, *)
  @available(*, deprecated, renamed: "executableRuntimeMismatch")
  public static var executableRuntimeMismatchError: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.5, iOS 2.0, *)
  @available(*, deprecated, renamed: "executableLoad")
  public static var executableLoadError: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.5, iOS 2.0, *)
  @available(*, deprecated, renamed: "executableLink")
  public static var executableLinkError: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.6, iOS 4.0, *)
  @available(*, deprecated, renamed: "propertyListReadCorrupt")
  public static var propertyListReadCorruptError: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.6, iOS 4.0, *)
  @available(*, deprecated, renamed: "propertyListReadUnknownVersion")
  public static var propertyListReadUnknownVersionError: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.6, iOS 4.0, *)
  @available(*, deprecated, renamed: "propertyListReadStream")
  public static var propertyListReadStreamError: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.6, iOS 4.0, *)
  @available(*, deprecated, renamed: "propertyListWriteStream")
  public static var propertyListWriteStreamError: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.10, iOS 8.0, *)
  @available(*, deprecated, renamed: "propertyListWriteInvalid")
  public static var propertyListWriteInvalidError: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.9, iOS 7.0, *)
  @available(*, deprecated, renamed: "ubiquitousFileUnavailable")
  public static var ubiquitousFileUnavailableError: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.9, iOS 7.0, *)
  @available(*, deprecated, renamed: "ubiquitousFileNotUploadedDueToQuota")
  public static var ubiquitousFileNotUploadedDueToQuotaError: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.10, iOS 8.0, *)
  @available(*, deprecated, renamed: "userActivityHandoffFailed")
  public static var userActivityHandoffFailedError: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.10, iOS 8.0, *)
  @available(*, deprecated, renamed: "userActivityConnectionUnavailable")
  public static var userActivityConnectionUnavailableError: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.10, iOS 8.0, *)
  @available(*, deprecated, renamed: "userActivityRemoteApplicationTimedOut")
  public static var userActivityRemoteApplicationTimedOutError: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.10, iOS 8.0, *)
  @available(*, deprecated, renamed: "userActivityHandoffUserInfoTooLarge")
  public static var userActivityHandoffUserInfoTooLargeError: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.11, iOS 9.0, *)
  @available(*, deprecated, renamed: "coderReadCorrupt")
  public static var coderReadCorruptError: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.11, iOS 9.0, *)
  @available(*, deprecated, renamed: "coderValueNotFound")
  public static var coderValueNotFoundError: Foundation.CocoaError.Code {
    get
  }
}
extension CocoaError {
  public static var fileNoSuchFile: Foundation.CocoaError.Code {
    get
  }
  public static var fileLocking: Foundation.CocoaError.Code {
    get
  }
  public static var fileReadUnknown: Foundation.CocoaError.Code {
    get
  }
  public static var fileReadNoPermission: Foundation.CocoaError.Code {
    get
  }
  public static var fileReadInvalidFileName: Foundation.CocoaError.Code {
    get
  }
  public static var fileReadCorruptFile: Foundation.CocoaError.Code {
    get
  }
  public static var fileReadNoSuchFile: Foundation.CocoaError.Code {
    get
  }
  public static var fileReadInapplicableStringEncoding: Foundation.CocoaError.Code {
    get
  }
  public static var fileReadUnsupportedScheme: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.5, iOS 2.0, *)
  public static var fileReadTooLarge: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.5, iOS 2.0, *)
  public static var fileReadUnknownStringEncoding: Foundation.CocoaError.Code {
    get
  }
  public static var fileWriteUnknown: Foundation.CocoaError.Code {
    get
  }
  public static var fileWriteNoPermission: Foundation.CocoaError.Code {
    get
  }
  public static var fileWriteInvalidFileName: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.7, iOS 5.0, *)
  public static var fileWriteFileExists: Foundation.CocoaError.Code {
    get
  }
  public static var fileWriteInapplicableStringEncoding: Foundation.CocoaError.Code {
    get
  }
  public static var fileWriteUnsupportedScheme: Foundation.CocoaError.Code {
    get
  }
  public static var fileWriteOutOfSpace: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.6, iOS 4.0, *)
  public static var fileWriteVolumeReadOnly: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.11, *)
  @available(iOS, unavailable)
  public static var fileManagerUnmountUnknown: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.11, *)
  @available(iOS, unavailable)
  public static var fileManagerUnmountBusy: Foundation.CocoaError.Code {
    get
  }
  public static var keyValueValidation: Foundation.CocoaError.Code {
    get
  }
  public static var formatting: Foundation.CocoaError.Code {
    get
  }
  public static var userCancelled: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.8, iOS 6.0, *)
  public static var featureUnsupported: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.5, iOS 2.0, *)
  public static var executableNotLoadable: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.5, iOS 2.0, *)
  public static var executableArchitectureMismatch: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.5, iOS 2.0, *)
  public static var executableRuntimeMismatch: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.5, iOS 2.0, *)
  public static var executableLoad: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.5, iOS 2.0, *)
  public static var executableLink: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.6, iOS 4.0, *)
  public static var propertyListReadCorrupt: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.6, iOS 4.0, *)
  public static var propertyListReadUnknownVersion: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.6, iOS 4.0, *)
  public static var propertyListReadStream: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.6, iOS 4.0, *)
  public static var propertyListWriteStream: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.10, iOS 8.0, *)
  public static var propertyListWriteInvalid: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.8, iOS 6.0, *)
  public static var xpcConnectionInterrupted: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.8, iOS 6.0, *)
  public static var xpcConnectionInvalid: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.8, iOS 6.0, *)
  public static var xpcConnectionReplyInvalid: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.9, iOS 7.0, *)
  public static var ubiquitousFileUnavailable: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.9, iOS 7.0, *)
  public static var ubiquitousFileNotUploadedDueToQuota: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.9, iOS 7.0, *)
  public static var ubiquitousFileUbiquityServerNotAvailable: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.10, iOS 8.0, *)
  public static var userActivityHandoffFailed: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.10, iOS 8.0, *)
  public static var userActivityConnectionUnavailable: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.10, iOS 8.0, *)
  public static var userActivityRemoteApplicationTimedOut: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.10, iOS 8.0, *)
  public static var userActivityHandoffUserInfoTooLarge: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.11, iOS 9.0, *)
  public static var coderReadCorrupt: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.11, iOS 9.0, *)
  public static var coderValueNotFound: Foundation.CocoaError.Code {
    get
  }
  public static var coderInvalidValue: Foundation.CocoaError.Code {
    get
  }
}
extension CocoaError {
  @available(*, deprecated, renamed: "fileNoSuchFile")
  public static var fileNoSuchFileError: Foundation.CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "fileLocking")
  public static var fileLockingError: Foundation.CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "fileReadUnknown")
  public static var fileReadUnknownError: Foundation.CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "fileReadNoPermission")
  public static var fileReadNoPermissionError: Foundation.CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "fileReadInvalidFileName")
  public static var fileReadInvalidFileNameError: Foundation.CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "fileReadCorruptFile")
  public static var fileReadCorruptFileError: Foundation.CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "fileReadNoSuchFile")
  public static var fileReadNoSuchFileError: Foundation.CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "fileReadInapplicableStringEncoding")
  public static var fileReadInapplicableStringEncodingError: Foundation.CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "fileReadUnsupportedScheme")
  public static var fileReadUnsupportedSchemeError: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.5, iOS 2.0, *)
  @available(*, deprecated, renamed: "fileReadTooLarge")
  public static var fileReadTooLargeError: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.5, iOS 2.0, *)
  @available(*, deprecated, renamed: "fileReadUnknownStringEncoding")
  public static var fileReadUnknownStringEncodingError: Foundation.CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "fileWriteUnknown")
  public static var fileWriteUnknownError: Foundation.CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "fileWriteNoPermission")
  public static var fileWriteNoPermissionError: Foundation.CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "fileWriteInvalidFileName")
  public static var fileWriteInvalidFileNameError: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.7, iOS 5.0, *)
  @available(*, deprecated, renamed: "fileWriteFileExists")
  public static var fileWriteFileExistsError: Foundation.CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "fileWriteInapplicableStringEncoding")
  public static var fileWriteInapplicableStringEncodingError: Foundation.CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "fileWriteUnsupportedScheme")
  public static var fileWriteUnsupportedSchemeError: Foundation.CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "fileWriteOutOfSpace")
  public static var fileWriteOutOfSpaceError: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.6, iOS 4.0, *)
  @available(*, deprecated, renamed: "fileWriteVolumeReadOnly")
  public static var fileWriteVolumeReadOnlyError: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.11, *)
  @available(iOS, unavailable)
  @available(*, deprecated, renamed: "fileManagerUnmountUnknown")
  public static var fileManagerUnmountUnknownError: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.11, *)
  @available(iOS, unavailable)
  @available(*, deprecated, renamed: "fileManagerUnmountBusy")
  public static var fileManagerUnmountBusyError: Foundation.CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "keyValueValidation")
  public static var keyValueValidationError: Foundation.CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "formatting")
  public static var formattingError: Foundation.CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "userCancelled")
  public static var userCancelledError: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.8, iOS 6.0, *)
  @available(*, deprecated, renamed: "featureUnsupported")
  public static var featureUnsupportedError: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.5, iOS 2.0, *)
  @available(*, deprecated, renamed: "executableNotLoadable")
  public static var executableNotLoadableError: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.5, iOS 2.0, *)
  @available(*, deprecated, renamed: "executableArchitectureMismatch")
  public static var executableArchitectureMismatchError: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.5, iOS 2.0, *)
  @available(*, deprecated, renamed: "executableRuntimeMismatch")
  public static var executableRuntimeMismatchError: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.5, iOS 2.0, *)
  @available(*, deprecated, renamed: "executableLoad")
  public static var executableLoadError: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.5, iOS 2.0, *)
  @available(*, deprecated, renamed: "executableLink")
  public static var executableLinkError: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.6, iOS 4.0, *)
  @available(*, deprecated, renamed: "propertyListReadCorrupt")
  public static var propertyListReadCorruptError: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.6, iOS 4.0, *)
  @available(*, deprecated, renamed: "propertyListReadUnknownVersion")
  public static var propertyListReadUnknownVersionError: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.6, iOS 4.0, *)
  @available(*, deprecated, renamed: "propertyListReadStream")
  public static var propertyListReadStreamError: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.6, iOS 4.0, *)
  @available(*, deprecated, renamed: "propertyListWriteStream")
  public static var propertyListWriteStreamError: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.10, iOS 8.0, *)
  @available(*, deprecated, renamed: "propertyListWriteInvalid")
  public static var propertyListWriteInvalidError: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.9, iOS 7.0, *)
  @available(*, deprecated, renamed: "ubiquitousFileUnavailable")
  public static var ubiquitousFileUnavailableError: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.9, iOS 7.0, *)
  @available(*, deprecated, renamed: "ubiquitousFileNotUploadedDueToQuota")
  public static var ubiquitousFileNotUploadedDueToQuotaError: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.10, iOS 8.0, *)
  @available(*, deprecated, renamed: "userActivityHandoffFailed")
  public static var userActivityHandoffFailedError: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.10, iOS 8.0, *)
  @available(*, deprecated, renamed: "userActivityConnectionUnavailable")
  public static var userActivityConnectionUnavailableError: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.10, iOS 8.0, *)
  @available(*, deprecated, renamed: "userActivityRemoteApplicationTimedOut")
  public static var userActivityRemoteApplicationTimedOutError: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.10, iOS 8.0, *)
  @available(*, deprecated, renamed: "userActivityHandoffUserInfoTooLarge")
  public static var userActivityHandoffUserInfoTooLargeError: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.11, iOS 9.0, *)
  @available(*, deprecated, renamed: "coderReadCorrupt")
  public static var coderReadCorruptError: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.11, iOS 9.0, *)
  @available(*, deprecated, renamed: "coderValueNotFound")
  public static var coderValueNotFoundError: Foundation.CocoaError.Code {
    get
  }
}
extension CocoaError {
  @available(macOS 10.11, iOS 9.0, *)
  public var isCoderError: Swift.Bool {
    get
  }
  @available(macOS 10.5, iOS 2.0, *)
  public var isExecutableError: Swift.Bool {
    get
  }
  public var isFileError: Swift.Bool {
    get
  }
  public var isFormattingError: Swift.Bool {
    get
  }
  @available(macOS 10.6, iOS 4.0, *)
  public var isPropertyListError: Swift.Bool {
    get
  }
  @available(macOS 10.9, iOS 7.0, *)
  public var isUbiquitousFileError: Swift.Bool {
    get
  }
  @available(macOS 10.10, iOS 8.0, *)
  public var isUserActivityError: Swift.Bool {
    get
  }
  public var isValidationError: Swift.Bool {
    get
  }
  @available(macOS 10.8, iOS 6.0, *)
  public var isXPCConnectionError: Swift.Bool {
    get
  }
}
extension CocoaError.Code {
  @available(*, unavailable, renamed: "fileNoSuchFile")
  public static var FileNoSuchFileError: Foundation.CocoaError.Code {
    get
  }
  @available(*, unavailable, renamed: "fileLocking")
  public static var FileLockingError: Foundation.CocoaError.Code {
    get
  }
  @available(*, unavailable, renamed: "fileReadUnknown")
  public static var FileReadUnknownError: Foundation.CocoaError.Code {
    get
  }
  @available(*, unavailable, renamed: "fileReadNoPermission")
  public static var FileReadNoPermissionError: Foundation.CocoaError.Code {
    get
  }
  @available(*, unavailable, renamed: "fileReadInvalidFileName")
  public static var FileReadInvalidFileNameError: Foundation.CocoaError.Code {
    get
  }
  @available(*, unavailable, renamed: "fileReadCorruptFile")
  public static var FileReadCorruptFileError: Foundation.CocoaError.Code {
    get
  }
  @available(*, unavailable, renamed: "fileReadNoSuchFile")
  public static var FileReadNoSuchFileError: Foundation.CocoaError.Code {
    get
  }
  @available(*, unavailable, renamed: "fileReadInapplicableStringEncoding")
  public static var FileReadInapplicableStringEncodingError: Foundation.CocoaError.Code {
    get
  }
  @available(*, unavailable, renamed: "fileReadUnsupportedScheme")
  public static var FileReadUnsupportedSchemeError: Foundation.CocoaError.Code {
    get
  }
  @available(*, unavailable, renamed: "fileReadTooLarge")
  public static var FileReadTooLargeError: Foundation.CocoaError.Code {
    get
  }
  @available(*, unavailable, renamed: "fileReadUnknownStringEncoding")
  public static var FileReadUnknownStringEncodingError: Foundation.CocoaError.Code {
    get
  }
  @available(*, unavailable, renamed: "fileWriteUnknown")
  public static var FileWriteUnknownError: Foundation.CocoaError.Code {
    get
  }
  @available(*, unavailable, renamed: "fileWriteNoPermission")
  public static var FileWriteNoPermissionError: Foundation.CocoaError.Code {
    get
  }
  @available(*, unavailable, renamed: "fileWriteInvalidFileName")
  public static var FileWriteInvalidFileNameError: Foundation.CocoaError.Code {
    get
  }
  @available(*, unavailable, renamed: "fileWriteFileExists")
  public static var FileWriteFileExistsError: Foundation.CocoaError.Code {
    get
  }
  @available(*, unavailable, renamed: "fileWriteInapplicableStringEncoding")
  public static var FileWriteInapplicableStringEncodingError: Foundation.CocoaError.Code {
    get
  }
  @available(*, unavailable, renamed: "fileWriteUnsupportedScheme")
  public static var FileWriteUnsupportedSchemeError: Foundation.CocoaError.Code {
    get
  }
  @available(*, unavailable, renamed: "fileWriteOutOfSpace")
  public static var FileWriteOutOfSpaceError: Foundation.CocoaError.Code {
    get
  }
  @available(*, unavailable, renamed: "fileWriteVolumeReadOnly")
  public static var FileWriteVolumeReadOnlyError: Foundation.CocoaError.Code {
    get
  }
  @available(*, unavailable, renamed: "fileManagerUnmountUnknown")
  public static var FileManagerUnmountUnknownError: Foundation.CocoaError.Code {
    get
  }
  @available(*, unavailable, renamed: "fileManagerUnmountBusy")
  public static var FileManagerUnmountBusyError: Foundation.CocoaError.Code {
    get
  }
  @available(*, unavailable, renamed: "keyValueValidation")
  public static var KeyValueValidationError: Foundation.CocoaError.Code {
    get
  }
  @available(*, unavailable, renamed: "formatting")
  public static var FormattingError: Foundation.CocoaError.Code {
    get
  }
  @available(*, unavailable, renamed: "userCancelled")
  public static var UserCancelledError: Foundation.CocoaError.Code {
    get
  }
  @available(*, unavailable, renamed: "featureUnsupported")
  public static var FeatureUnsupportedError: Foundation.CocoaError.Code {
    get
  }
  @available(*, unavailable, renamed: "executableNotLoadable")
  public static var ExecutableNotLoadableError: Foundation.CocoaError.Code {
    get
  }
  @available(*, unavailable, renamed: "executableArchitectureMismatch")
  public static var ExecutableArchitectureMismatchError: Foundation.CocoaError.Code {
    get
  }
  @available(*, unavailable, renamed: "executableRuntimeMismatch")
  public static var ExecutableRuntimeMismatchError: Foundation.CocoaError.Code {
    get
  }
  @available(*, unavailable, renamed: "executableLoad")
  public static var ExecutableLoadError: Foundation.CocoaError.Code {
    get
  }
  @available(*, unavailable, renamed: "executableLink")
  public static var ExecutableLinkError: Foundation.CocoaError.Code {
    get
  }
  @available(*, unavailable, renamed: "propertyListReadCorrupt")
  public static var PropertyListReadCorruptError: Foundation.CocoaError.Code {
    get
  }
  @available(*, unavailable, renamed: "propertyListReadUnknownVersion")
  public static var PropertyListReadUnknownVersionError: Foundation.CocoaError.Code {
    get
  }
  @available(*, unavailable, renamed: "propertyListReadStream")
  public static var PropertyListReadStreamError: Foundation.CocoaError.Code {
    get
  }
  @available(*, unavailable, renamed: "propertyListWriteStream")
  public static var PropertyListWriteStreamError: Foundation.CocoaError.Code {
    get
  }
  @available(*, unavailable, renamed: "propertyListWriteInvalid")
  public static var PropertyListWriteInvalidError: Foundation.CocoaError.Code {
    get
  }
  @available(*, unavailable, renamed: "xpcConnectionInterrupted")
  public static var XPCConnectionInterrupted: Foundation.CocoaError.Code {
    get
  }
  @available(*, unavailable, renamed: "xpcConnectionInvalid")
  public static var XPCConnectionInvalid: Foundation.CocoaError.Code {
    get
  }
  @available(*, unavailable, renamed: "xpcConnectionReplyInvalid")
  public static var XPCConnectionReplyInvalid: Foundation.CocoaError.Code {
    get
  }
  @available(*, unavailable, renamed: "ubiquitousFileUnavailable")
  public static var UbiquitousFileUnavailableError: Foundation.CocoaError.Code {
    get
  }
  @available(*, unavailable, renamed: "ubiquitousFileNotUploadedDueToQuota")
  public static var UbiquitousFileNotUploadedDueToQuotaError: Foundation.CocoaError.Code {
    get
  }
  @available(*, unavailable, renamed: "ubiquitousFileUbiquityServerNotAvailable")
  public static var UbiquitousFileUbiquityServerNotAvailable: Foundation.CocoaError.Code {
    get
  }
  @available(*, unavailable, renamed: "userActivityHandoffFailed")
  public static var UserActivityHandoffFailedError: Foundation.CocoaError.Code {
    get
  }
  @available(*, unavailable, renamed: "userActivityConnectionUnavailable")
  public static var UserActivityConnectionUnavailableError: Foundation.CocoaError.Code {
    get
  }
  @available(*, unavailable, renamed: "userActivityRemoteApplicationTimedOut")
  public static var UserActivityRemoteApplicationTimedOutError: Foundation.CocoaError.Code {
    get
  }
  @available(*, unavailable, renamed: "userActivityHandoffUserInfoTooLarge")
  public static var UserActivityHandoffUserInfoTooLargeError: Foundation.CocoaError.Code {
    get
  }
  @available(*, unavailable, renamed: "coderReadCorrupt")
  public static var CoderReadCorruptError: Foundation.CocoaError.Code {
    get
  }
  @available(*, unavailable, renamed: "coderValueNotFound")
  public static var CoderValueNotFoundError: Foundation.CocoaError.Code {
    get
  }
}
public struct URLError : Foundation._BridgedStoredNSError {
  public let _nsError: Foundation.NSError
  public init(_nsError error: Foundation.NSError)
  public static var errorDomain: Swift.String {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
  public struct Code : Swift.RawRepresentable, Swift.Hashable, Foundation._ErrorCodeProtocol {
    public typealias _ErrorType = Foundation.URLError
    public let rawValue: Swift.Int
    public init(rawValue: Swift.Int)
    public typealias RawValue = Swift.Int
  }
}
extension URLError.Code {
  public static var unknown: Foundation.URLError.Code {
    get
  }
  public static var cancelled: Foundation.URLError.Code {
    get
  }
  public static var badURL: Foundation.URLError.Code {
    get
  }
  public static var timedOut: Foundation.URLError.Code {
    get
  }
  public static var unsupportedURL: Foundation.URLError.Code {
    get
  }
  public static var cannotFindHost: Foundation.URLError.Code {
    get
  }
  public static var cannotConnectToHost: Foundation.URLError.Code {
    get
  }
  public static var networkConnectionLost: Foundation.URLError.Code {
    get
  }
  public static var dnsLookupFailed: Foundation.URLError.Code {
    get
  }
  public static var httpTooManyRedirects: Foundation.URLError.Code {
    get
  }
  public static var resourceUnavailable: Foundation.URLError.Code {
    get
  }
  public static var notConnectedToInternet: Foundation.URLError.Code {
    get
  }
  public static var redirectToNonExistentLocation: Foundation.URLError.Code {
    get
  }
  public static var badServerResponse: Foundation.URLError.Code {
    get
  }
  public static var userCancelledAuthentication: Foundation.URLError.Code {
    get
  }
  public static var userAuthenticationRequired: Foundation.URLError.Code {
    get
  }
  public static var zeroByteResource: Foundation.URLError.Code {
    get
  }
  public static var cannotDecodeRawData: Foundation.URLError.Code {
    get
  }
  public static var cannotDecodeContentData: Foundation.URLError.Code {
    get
  }
  public static var cannotParseResponse: Foundation.URLError.Code {
    get
  }
  @available(macOS 10.11, iOS 9.0, *)
  public static var appTransportSecurityRequiresSecureConnection: Foundation.URLError.Code {
    get
  }
  public static var fileDoesNotExist: Foundation.URLError.Code {
    get
  }
  public static var fileIsDirectory: Foundation.URLError.Code {
    get
  }
  public static var noPermissionsToReadFile: Foundation.URLError.Code {
    get
  }
  @available(macOS 10.5, iOS 2.0, *)
  public static var dataLengthExceedsMaximum: Foundation.URLError.Code {
    get
  }
  public static var secureConnectionFailed: Foundation.URLError.Code {
    get
  }
  public static var serverCertificateHasBadDate: Foundation.URLError.Code {
    get
  }
  public static var serverCertificateUntrusted: Foundation.URLError.Code {
    get
  }
  public static var serverCertificateHasUnknownRoot: Foundation.URLError.Code {
    get
  }
  public static var serverCertificateNotYetValid: Foundation.URLError.Code {
    get
  }
  public static var clientCertificateRejected: Foundation.URLError.Code {
    get
  }
  public static var clientCertificateRequired: Foundation.URLError.Code {
    get
  }
  public static var cannotLoadFromNetwork: Foundation.URLError.Code {
    get
  }
  public static var cannotCreateFile: Foundation.URLError.Code {
    get
  }
  public static var cannotOpenFile: Foundation.URLError.Code {
    get
  }
  public static var cannotCloseFile: Foundation.URLError.Code {
    get
  }
  public static var cannotWriteToFile: Foundation.URLError.Code {
    get
  }
  public static var cannotRemoveFile: Foundation.URLError.Code {
    get
  }
  public static var cannotMoveFile: Foundation.URLError.Code {
    get
  }
  public static var downloadDecodingFailedMidStream: Foundation.URLError.Code {
    get
  }
  public static var downloadDecodingFailedToComplete: Foundation.URLError.Code {
    get
  }
  @available(macOS 10.7, iOS 3.0, *)
  public static var internationalRoamingOff: Foundation.URLError.Code {
    get
  }
  @available(macOS 10.7, iOS 3.0, *)
  public static var callIsActive: Foundation.URLError.Code {
    get
  }
  @available(macOS 10.7, iOS 3.0, *)
  public static var dataNotAllowed: Foundation.URLError.Code {
    get
  }
  @available(macOS 10.7, iOS 3.0, *)
  public static var requestBodyStreamExhausted: Foundation.URLError.Code {
    get
  }
  @available(macOS 10.10, iOS 8.0, *)
  public static var backgroundSessionRequiresSharedContainer: Foundation.URLError.Code {
    get
  }
  @available(macOS 10.10, iOS 8.0, *)
  public static var backgroundSessionInUseByAnotherProcess: Foundation.URLError.Code {
    get
  }
  @available(macOS 10.10, iOS 8.0, *)
  public static var backgroundSessionWasDisconnected: Foundation.URLError.Code {
    get
  }
}
extension URLError {
  @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
  public enum BackgroundTaskCancelledReason : Swift.Int {
    case userForceQuitApplication
    case backgroundUpdatesDisabled
    case insufficientSystemResources
    public init?(rawValue: Swift.Int)
    public typealias RawValue = Swift.Int
    public var rawValue: Swift.Int {
      get
    }
  }
}
extension URLError {
  @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
  public enum NetworkUnavailableReason : Swift.Int {
    case cellular
    case expensive
    case constrained
    public init?(rawValue: Swift.Int)
    public typealias RawValue = Swift.Int
    public var rawValue: Swift.Int {
      get
    }
  }
}
extension URLError {
  public var failingURL: Foundation.URL? {
    get
  }
  public var failureURLString: Swift.String? {
    get
  }
  public var failureURLPeerTrust: Security.SecTrust? {
    get
  }
  @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
  public var backgroundTaskCancelledReason: Foundation.URLError.BackgroundTaskCancelledReason? {
    get
  }
  @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
  public var networkUnavailableReason: Foundation.URLError.NetworkUnavailableReason? {
    get
  }
  @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
  public var downloadTaskResumeData: Foundation.Data? {
    get
  }
}
extension URLError {
  public static var unknown: Foundation.URLError.Code {
    get
  }
  public static var cancelled: Foundation.URLError.Code {
    get
  }
  public static var badURL: Foundation.URLError.Code {
    get
  }
  public static var timedOut: Foundation.URLError.Code {
    get
  }
  public static var unsupportedURL: Foundation.URLError.Code {
    get
  }
  public static var cannotFindHost: Foundation.URLError.Code {
    get
  }
  public static var cannotConnectToHost: Foundation.URLError.Code {
    get
  }
  public static var networkConnectionLost: Foundation.URLError.Code {
    get
  }
  public static var dnsLookupFailed: Foundation.URLError.Code {
    get
  }
  public static var httpTooManyRedirects: Foundation.URLError.Code {
    get
  }
  public static var resourceUnavailable: Foundation.URLError.Code {
    get
  }
  public static var notConnectedToInternet: Foundation.URLError.Code {
    get
  }
  public static var redirectToNonExistentLocation: Foundation.URLError.Code {
    get
  }
  public static var badServerResponse: Foundation.URLError.Code {
    get
  }
  public static var userCancelledAuthentication: Foundation.URLError.Code {
    get
  }
  public static var userAuthenticationRequired: Foundation.URLError.Code {
    get
  }
  public static var zeroByteResource: Foundation.URLError.Code {
    get
  }
  public static var cannotDecodeRawData: Foundation.URLError.Code {
    get
  }
  public static var cannotDecodeContentData: Foundation.URLError.Code {
    get
  }
  public static var cannotParseResponse: Foundation.URLError.Code {
    get
  }
  @available(macOS 10.11, iOS 9.0, *)
  public static var appTransportSecurityRequiresSecureConnection: Foundation.URLError.Code {
    get
  }
  public static var fileDoesNotExist: Foundation.URLError.Code {
    get
  }
  public static var fileIsDirectory: Foundation.URLError.Code {
    get
  }
  public static var noPermissionsToReadFile: Foundation.URLError.Code {
    get
  }
  @available(macOS 10.5, iOS 2.0, *)
  public static var dataLengthExceedsMaximum: Foundation.URLError.Code {
    get
  }
  public static var secureConnectionFailed: Foundation.URLError.Code {
    get
  }
  public static var serverCertificateHasBadDate: Foundation.URLError.Code {
    get
  }
  public static var serverCertificateUntrusted: Foundation.URLError.Code {
    get
  }
  public static var serverCertificateHasUnknownRoot: Foundation.URLError.Code {
    get
  }
  public static var serverCertificateNotYetValid: Foundation.URLError.Code {
    get
  }
  public static var clientCertificateRejected: Foundation.URLError.Code {
    get
  }
  public static var clientCertificateRequired: Foundation.URLError.Code {
    get
  }
  public static var cannotLoadFromNetwork: Foundation.URLError.Code {
    get
  }
  public static var cannotCreateFile: Foundation.URLError.Code {
    get
  }
  public static var cannotOpenFile: Foundation.URLError.Code {
    get
  }
  public static var cannotCloseFile: Foundation.URLError.Code {
    get
  }
  public static var cannotWriteToFile: Foundation.URLError.Code {
    get
  }
  public static var cannotRemoveFile: Foundation.URLError.Code {
    get
  }
  public static var cannotMoveFile: Foundation.URLError.Code {
    get
  }
  public static var downloadDecodingFailedMidStream: Foundation.URLError.Code {
    get
  }
  public static var downloadDecodingFailedToComplete: Foundation.URLError.Code {
    get
  }
  @available(macOS 10.7, iOS 3.0, *)
  public static var internationalRoamingOff: Foundation.URLError.Code {
    get
  }
  @available(macOS 10.7, iOS 3.0, *)
  public static var callIsActive: Foundation.URLError.Code {
    get
  }
  @available(macOS 10.7, iOS 3.0, *)
  public static var dataNotAllowed: Foundation.URLError.Code {
    get
  }
  @available(macOS 10.7, iOS 3.0, *)
  public static var requestBodyStreamExhausted: Foundation.URLError.Code {
    get
  }
  @available(macOS 10.10, iOS 8.0, *)
  public static var backgroundSessionRequiresSharedContainer: Foundation.URLError.Code {
    get
  }
  @available(macOS 10.10, iOS 8.0, *)
  public static var backgroundSessionInUseByAnotherProcess: Foundation.URLError.Code {
    get
  }
  @available(macOS 10.10, iOS 8.0, *)
  public static var backgroundSessionWasDisconnected: Foundation.URLError.Code {
    get
  }
}
extension URLError {
  @available(*, unavailable, renamed: "unknown")
  public static var Unknown: Foundation.URLError.Code {
    get
  }
  @available(*, unavailable, renamed: "cancelled")
  public static var Cancelled: Foundation.URLError.Code {
    get
  }
  @available(*, unavailable, renamed: "badURL")
  public static var BadURL: Foundation.URLError.Code {
    get
  }
  @available(*, unavailable, renamed: "timedOut")
  public static var TimedOut: Foundation.URLError.Code {
    get
  }
  @available(*, unavailable, renamed: "unsupportedURL")
  public static var UnsupportedURL: Foundation.URLError.Code {
    get
  }
  @available(*, unavailable, renamed: "cannotFindHost")
  public static var CannotFindHost: Foundation.URLError.Code {
    get
  }
  @available(*, unavailable, renamed: "cannotConnectToHost")
  public static var CannotConnectToHost: Foundation.URLError.Code {
    get
  }
  @available(*, unavailable, renamed: "networkConnectionLost")
  public static var NetworkConnectionLost: Foundation.URLError.Code {
    get
  }
  @available(*, unavailable, renamed: "dnsLookupFailed")
  public static var DNSLookupFailed: Foundation.URLError.Code {
    get
  }
  @available(*, unavailable, renamed: "httpTooManyRedirects")
  public static var HTTPTooManyRedirects: Foundation.URLError.Code {
    get
  }
  @available(*, unavailable, renamed: "resourceUnavailable")
  public static var ResourceUnavailable: Foundation.URLError.Code {
    get
  }
  @available(*, unavailable, renamed: "notConnectedToInternet")
  public static var NotConnectedToInternet: Foundation.URLError.Code {
    get
  }
  @available(*, unavailable, renamed: "redirectToNonExistentLocation")
  public static var RedirectToNonExistentLocation: Foundation.URLError.Code {
    get
  }
  @available(*, unavailable, renamed: "badServerResponse")
  public static var BadServerResponse: Foundation.URLError.Code {
    get
  }
  @available(*, unavailable, renamed: "userCancelledAuthentication")
  public static var UserCancelledAuthentication: Foundation.URLError.Code {
    get
  }
  @available(*, unavailable, renamed: "userAuthenticationRequired")
  public static var UserAuthenticationRequired: Foundation.URLError.Code {
    get
  }
  @available(*, unavailable, renamed: "zeroByteResource")
  public static var ZeroByteResource: Foundation.URLError.Code {
    get
  }
  @available(*, unavailable, renamed: "cannotDecodeRawData")
  public static var CannotDecodeRawData: Foundation.URLError.Code {
    get
  }
  @available(*, unavailable, renamed: "cannotDecodeContentData")
  public static var CannotDecodeContentData: Foundation.URLError.Code {
    get
  }
  @available(*, unavailable, renamed: "cannotParseResponse")
  public static var CannotParseResponse: Foundation.URLError.Code {
    get
  }
  @available(*, unavailable, renamed: "appTransportSecurityRequiresSecureConnection")
  public static var AppTransportSecurityRequiresSecureConnection: Foundation.URLError.Code {
    get
  }
  @available(*, unavailable, renamed: "fileDoesNotExist")
  public static var FileDoesNotExist: Foundation.URLError.Code {
    get
  }
  @available(*, unavailable, renamed: "fileIsDirectory")
  public static var FileIsDirectory: Foundation.URLError.Code {
    get
  }
  @available(*, unavailable, renamed: "noPermissionsToReadFile")
  public static var NoPermissionsToReadFile: Foundation.URLError.Code {
    get
  }
  @available(*, unavailable, renamed: "dataLengthExceedsMaximum")
  public static var DataLengthExceedsMaximum: Foundation.URLError.Code {
    get
  }
  @available(*, unavailable, renamed: "secureConnectionFailed")
  public static var SecureConnectionFailed: Foundation.URLError.Code {
    get
  }
  @available(*, unavailable, renamed: "serverCertificateHasBadDate")
  public static var ServerCertificateHasBadDate: Foundation.URLError.Code {
    get
  }
  @available(*, unavailable, renamed: "serverCertificateUntrusted")
  public static var ServerCertificateUntrusted: Foundation.URLError.Code {
    get
  }
  @available(*, unavailable, renamed: "serverCertificateHasUnknownRoot")
  public static var ServerCertificateHasUnknownRoot: Foundation.URLError.Code {
    get
  }
  @available(*, unavailable, renamed: "serverCertificateNotYetValid")
  public static var ServerCertificateNotYetValid: Foundation.URLError.Code {
    get
  }
  @available(*, unavailable, renamed: "clientCertificateRejected")
  public static var ClientCertificateRejected: Foundation.URLError.Code {
    get
  }
  @available(*, unavailable, renamed: "clientCertificateRequired")
  public static var ClientCertificateRequired: Foundation.URLError.Code {
    get
  }
  @available(*, unavailable, renamed: "cannotLoadFromNetwork")
  public static var CannotLoadFromNetwork: Foundation.URLError.Code {
    get
  }
  @available(*, unavailable, renamed: "cannotCreateFile")
  public static var CannotCreateFile: Foundation.URLError.Code {
    get
  }
  @available(*, unavailable, renamed: "cannotOpenFile")
  public static var CannotOpenFile: Foundation.URLError.Code {
    get
  }
  @available(*, unavailable, renamed: "cannotCloseFile")
  public static var CannotCloseFile: Foundation.URLError.Code {
    get
  }
  @available(*, unavailable, renamed: "cannotWriteToFile")
  public static var CannotWriteToFile: Foundation.URLError.Code {
    get
  }
  @available(*, unavailable, renamed: "cannotRemoveFile")
  public static var CannotRemoveFile: Foundation.URLError.Code {
    get
  }
  @available(*, unavailable, renamed: "cannotMoveFile")
  public static var CannotMoveFile: Foundation.URLError.Code {
    get
  }
  @available(*, unavailable, renamed: "downloadDecodingFailedMidStream")
  public static var DownloadDecodingFailedMidStream: Foundation.URLError.Code {
    get
  }
  @available(*, unavailable, renamed: "downloadDecodingFailedToComplete")
  public static var DownloadDecodingFailedToComplete: Foundation.URLError.Code {
    get
  }
  @available(*, unavailable, renamed: "internationalRoamingOff")
  public static var InternationalRoamingOff: Foundation.URLError.Code {
    get
  }
  @available(*, unavailable, renamed: "callIsActive")
  public static var CallIsActive: Foundation.URLError.Code {
    get
  }
  @available(*, unavailable, renamed: "dataNotAllowed")
  public static var DataNotAllowed: Foundation.URLError.Code {
    get
  }
  @available(*, unavailable, renamed: "requestBodyStreamExhausted")
  public static var RequestBodyStreamExhausted: Foundation.URLError.Code {
    get
  }
  @available(*, unavailable, renamed: "backgroundSessionRequiresSharedContainer")
  public static var BackgroundSessionRequiresSharedContainer: Foundation.URLError.Code {
    get
  }
  @available(*, unavailable, renamed: "backgroundSessionInUseByAnotherProcess")
  public static var BackgroundSessionInUseByAnotherProcess: Foundation.URLError.Code {
    get
  }
  @available(*, unavailable, renamed: "backgroundSessionWasDisconnected")
  public static var BackgroundSessionWasDisconnected: Foundation.URLError.Code {
    get
  }
}
public struct POSIXError : Foundation._BridgedStoredNSError {
  public let _nsError: Foundation.NSError
  public init(_nsError error: Foundation.NSError)
  public static var errorDomain: Swift.String {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
  public typealias Code = Darwin.POSIXErrorCode
}
extension POSIXErrorCode : Foundation._ErrorCodeProtocol {
  public typealias _ErrorType = Foundation.POSIXError
}
extension POSIXError {
  public static var EPERM: Darwin.POSIXErrorCode {
    get
  }
  public static var ENOENT: Darwin.POSIXErrorCode {
    get
  }
  public static var ESRCH: Darwin.POSIXErrorCode {
    get
  }
  public static var EINTR: Darwin.POSIXErrorCode {
    get
  }
  public static var EIO: Darwin.POSIXErrorCode {
    get
  }
  public static var ENXIO: Darwin.POSIXErrorCode {
    get
  }
  public static var E2BIG: Darwin.POSIXErrorCode {
    get
  }
  public static var ENOEXEC: Darwin.POSIXErrorCode {
    get
  }
  public static var EBADF: Darwin.POSIXErrorCode {
    get
  }
  public static var ECHILD: Darwin.POSIXErrorCode {
    get
  }
  public static var EDEADLK: Darwin.POSIXErrorCode {
    get
  }
  public static var ENOMEM: Darwin.POSIXErrorCode {
    get
  }
  public static var EACCES: Darwin.POSIXErrorCode {
    get
  }
  public static var EFAULT: Darwin.POSIXErrorCode {
    get
  }
  public static var ENOTBLK: Darwin.POSIXErrorCode {
    get
  }
  public static var EBUSY: Darwin.POSIXErrorCode {
    get
  }
  public static var EEXIST: Darwin.POSIXErrorCode {
    get
  }
  public static var EXDEV: Darwin.POSIXErrorCode {
    get
  }
  public static var ENODEV: Darwin.POSIXErrorCode {
    get
  }
  public static var ENOTDIR: Darwin.POSIXErrorCode {
    get
  }
  public static var EISDIR: Darwin.POSIXErrorCode {
    get
  }
  public static var EINVAL: Darwin.POSIXErrorCode {
    get
  }
  public static var ENFILE: Darwin.POSIXErrorCode {
    get
  }
  public static var EMFILE: Darwin.POSIXErrorCode {
    get
  }
  public static var ENOTTY: Darwin.POSIXErrorCode {
    get
  }
  public static var ETXTBSY: Darwin.POSIXErrorCode {
    get
  }
  public static var EFBIG: Darwin.POSIXErrorCode {
    get
  }
  public static var ENOSPC: Darwin.POSIXErrorCode {
    get
  }
  public static var ESPIPE: Darwin.POSIXErrorCode {
    get
  }
  public static var EROFS: Darwin.POSIXErrorCode {
    get
  }
  public static var EMLINK: Darwin.POSIXErrorCode {
    get
  }
  public static var EPIPE: Darwin.POSIXErrorCode {
    get
  }
  public static var EDOM: Darwin.POSIXErrorCode {
    get
  }
  public static var ERANGE: Darwin.POSIXErrorCode {
    get
  }
  public static var EAGAIN: Darwin.POSIXErrorCode {
    get
  }
  public static var EWOULDBLOCK: Darwin.POSIXErrorCode {
    get
  }
  public static var EINPROGRESS: Darwin.POSIXErrorCode {
    get
  }
  public static var EALREADY: Darwin.POSIXErrorCode {
    get
  }
  public static var ENOTSOCK: Darwin.POSIXErrorCode {
    get
  }
  public static var EDESTADDRREQ: Darwin.POSIXErrorCode {
    get
  }
  public static var EMSGSIZE: Darwin.POSIXErrorCode {
    get
  }
  public static var EPROTOTYPE: Darwin.POSIXErrorCode {
    get
  }
  public static var ENOPROTOOPT: Darwin.POSIXErrorCode {
    get
  }
  public static var EPROTONOSUPPORT: Darwin.POSIXErrorCode {
    get
  }
  public static var ESOCKTNOSUPPORT: Darwin.POSIXErrorCode {
    get
  }
  public static var ENOTSUP: Darwin.POSIXErrorCode {
    get
  }
  public static var EPFNOSUPPORT: Darwin.POSIXErrorCode {
    get
  }
  public static var EAFNOSUPPORT: Darwin.POSIXErrorCode {
    get
  }
  public static var EADDRINUSE: Darwin.POSIXErrorCode {
    get
  }
  public static var EADDRNOTAVAIL: Darwin.POSIXErrorCode {
    get
  }
  public static var ENETDOWN: Darwin.POSIXErrorCode {
    get
  }
  public static var ENETUNREACH: Darwin.POSIXErrorCode {
    get
  }
  public static var ENETRESET: Darwin.POSIXErrorCode {
    get
  }
  public static var ECONNABORTED: Darwin.POSIXErrorCode {
    get
  }
  public static var ECONNRESET: Darwin.POSIXErrorCode {
    get
  }
  public static var ENOBUFS: Darwin.POSIXErrorCode {
    get
  }
  public static var EISCONN: Darwin.POSIXErrorCode {
    get
  }
  public static var ENOTCONN: Darwin.POSIXErrorCode {
    get
  }
  public static var ESHUTDOWN: Darwin.POSIXErrorCode {
    get
  }
  public static var ETOOMANYREFS: Darwin.POSIXErrorCode {
    get
  }
  public static var ETIMEDOUT: Darwin.POSIXErrorCode {
    get
  }
  public static var ECONNREFUSED: Darwin.POSIXErrorCode {
    get
  }
  public static var ELOOP: Darwin.POSIXErrorCode {
    get
  }
  public static var ENAMETOOLONG: Darwin.POSIXErrorCode {
    get
  }
  public static var EHOSTDOWN: Darwin.POSIXErrorCode {
    get
  }
  public static var EHOSTUNREACH: Darwin.POSIXErrorCode {
    get
  }
  public static var ENOTEMPTY: Darwin.POSIXErrorCode {
    get
  }
  public static var EPROCLIM: Darwin.POSIXErrorCode {
    get
  }
  public static var EUSERS: Darwin.POSIXErrorCode {
    get
  }
  public static var EDQUOT: Darwin.POSIXErrorCode {
    get
  }
  public static var ESTALE: Darwin.POSIXErrorCode {
    get
  }
  public static var EREMOTE: Darwin.POSIXErrorCode {
    get
  }
  public static var EBADRPC: Darwin.POSIXErrorCode {
    get
  }
  public static var ERPCMISMATCH: Darwin.POSIXErrorCode {
    get
  }
  public static var EPROGUNAVAIL: Darwin.POSIXErrorCode {
    get
  }
  public static var EPROGMISMATCH: Darwin.POSIXErrorCode {
    get
  }
  public static var EPROCUNAVAIL: Darwin.POSIXErrorCode {
    get
  }
  public static var ENOLCK: Darwin.POSIXErrorCode {
    get
  }
  public static var ENOSYS: Darwin.POSIXErrorCode {
    get
  }
  public static var EFTYPE: Darwin.POSIXErrorCode {
    get
  }
  public static var EAUTH: Darwin.POSIXErrorCode {
    get
  }
  public static var ENEEDAUTH: Darwin.POSIXErrorCode {
    get
  }
  public static var EPWROFF: Darwin.POSIXErrorCode {
    get
  }
  public static var EDEVERR: Darwin.POSIXErrorCode {
    get
  }
  public static var EOVERFLOW: Darwin.POSIXErrorCode {
    get
  }
  public static var EBADEXEC: Darwin.POSIXErrorCode {
    get
  }
  public static var EBADARCH: Darwin.POSIXErrorCode {
    get
  }
  public static var ESHLIBVERS: Darwin.POSIXErrorCode {
    get
  }
  public static var EBADMACHO: Darwin.POSIXErrorCode {
    get
  }
  public static var ECANCELED: Darwin.POSIXErrorCode {
    get
  }
  public static var EIDRM: Darwin.POSIXErrorCode {
    get
  }
  public static var ENOMSG: Darwin.POSIXErrorCode {
    get
  }
  public static var EILSEQ: Darwin.POSIXErrorCode {
    get
  }
  public static var ENOATTR: Darwin.POSIXErrorCode {
    get
  }
  public static var EBADMSG: Darwin.POSIXErrorCode {
    get
  }
  public static var EMULTIHOP: Darwin.POSIXErrorCode {
    get
  }
  public static var ENODATA: Darwin.POSIXErrorCode {
    get
  }
  public static var ENOLINK: Darwin.POSIXErrorCode {
    get
  }
  public static var ENOSR: Darwin.POSIXErrorCode {
    get
  }
  public static var ENOSTR: Darwin.POSIXErrorCode {
    get
  }
  public static var EPROTO: Darwin.POSIXErrorCode {
    get
  }
  public static var ETIME: Darwin.POSIXErrorCode {
    get
  }
  public static var ENOPOLICY: Darwin.POSIXErrorCode {
    get
  }
  public static var ENOTRECOVERABLE: Darwin.POSIXErrorCode {
    get
  }
  public static var EOWNERDEAD: Darwin.POSIXErrorCode {
    get
  }
  public static var EQFULL: Darwin.POSIXErrorCode {
    get
  }
}
public struct MachError : Foundation._BridgedStoredNSError {
  public let _nsError: Foundation.NSError
  public init(_nsError error: Foundation.NSError)
  public static var errorDomain: Swift.String {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
  public typealias Code = Darwin.MachErrorCode
}
extension MachErrorCode : Foundation._ErrorCodeProtocol {
  public typealias _ErrorType = Foundation.MachError
}
extension MachError {
  public static var success: Foundation.MachError.Code {
    get
  }
  public static var invalidAddress: Foundation.MachError.Code {
    get
  }
  public static var protectionFailure: Foundation.MachError.Code {
    get
  }
  public static var noSpace: Foundation.MachError.Code {
    get
  }
  public static var invalidArgument: Foundation.MachError.Code {
    get
  }
  public static var failure: Foundation.MachError.Code {
    get
  }
  public static var resourceShortage: Foundation.MachError.Code {
    get
  }
  public static var notReceiver: Foundation.MachError.Code {
    get
  }
  public static var noAccess: Foundation.MachError.Code {
    get
  }
  public static var memoryFailure: Foundation.MachError.Code {
    get
  }
  public static var memoryError: Foundation.MachError.Code {
    get
  }
  public static var alreadyInSet: Foundation.MachError.Code {
    get
  }
  public static var notInSet: Foundation.MachError.Code {
    get
  }
  public static var nameExists: Foundation.MachError.Code {
    get
  }
  public static var aborted: Foundation.MachError.Code {
    get
  }
  public static var invalidName: Foundation.MachError.Code {
    get
  }
  public static var invalidTask: Foundation.MachError.Code {
    get
  }
  public static var invalidRight: Foundation.MachError.Code {
    get
  }
  public static var invalidValue: Foundation.MachError.Code {
    get
  }
  public static var userReferencesOverflow: Foundation.MachError.Code {
    get
  }
  public static var invalidCapability: Foundation.MachError.Code {
    get
  }
  public static var rightExists: Foundation.MachError.Code {
    get
  }
  public static var invalidHost: Foundation.MachError.Code {
    get
  }
  public static var memoryPresent: Foundation.MachError.Code {
    get
  }
  public static var memoryDataMoved: Foundation.MachError.Code {
    get
  }
  public static var memoryRestartCopy: Foundation.MachError.Code {
    get
  }
  public static var invalidProcessorSet: Foundation.MachError.Code {
    get
  }
  public static var policyLimit: Foundation.MachError.Code {
    get
  }
  public static var invalidPolicy: Foundation.MachError.Code {
    get
  }
  public static var invalidObject: Foundation.MachError.Code {
    get
  }
  public static var alreadyWaiting: Foundation.MachError.Code {
    get
  }
  public static var defaultSet: Foundation.MachError.Code {
    get
  }
  public static var exceptionProtected: Foundation.MachError.Code {
    get
  }
  public static var invalidLedger: Foundation.MachError.Code {
    get
  }
  public static var invalidMemoryControl: Foundation.MachError.Code {
    get
  }
  public static var invalidSecurity: Foundation.MachError.Code {
    get
  }
  public static var notDepressed: Foundation.MachError.Code {
    get
  }
  public static var terminated: Foundation.MachError.Code {
    get
  }
  public static var lockSetDestroyed: Foundation.MachError.Code {
    get
  }
  public static var lockUnstable: Foundation.MachError.Code {
    get
  }
  public static var lockOwned: Foundation.MachError.Code {
    get
  }
  public static var lockOwnedSelf: Foundation.MachError.Code {
    get
  }
  public static var semaphoreDestroyed: Foundation.MachError.Code {
    get
  }
  public static var rpcServerTerminated: Foundation.MachError.Code {
    get
  }
  public static var rpcTerminateOrphan: Foundation.MachError.Code {
    get
  }
  public static var rpcContinueOrphan: Foundation.MachError.Code {
    get
  }
  public static var notSupported: Foundation.MachError.Code {
    get
  }
  public static var nodeDown: Foundation.MachError.Code {
    get
  }
  public static var notWaiting: Foundation.MachError.Code {
    get
  }
  public static var operationTimedOut: Foundation.MachError.Code {
    get
  }
  public static var codesignError: Foundation.MachError.Code {
    get
  }
  public static var policyStatic: Foundation.MachError.Code {
    get
  }
}
public struct ErrorUserInfoKey : Swift.RawRepresentable, Swift._SwiftNewtypeWrapper, Swift.Equatable, Swift.Hashable, Swift._ObjectiveCBridgeable {
  public typealias _ObjectiveCType = Foundation.NSString
  public init(rawValue: Swift.String)
  public var rawValue: Swift.String
  public typealias RawValue = Swift.String
}
extension ErrorUserInfoKey {
  @available(*, deprecated, renamed: "NSUnderlyingErrorKey")
  public static let underlyingErrorKey: Foundation.ErrorUserInfoKey
  @available(*, deprecated, renamed: "NSLocalizedDescriptionKey")
  public static let localizedDescriptionKey: Foundation.ErrorUserInfoKey
  @available(*, deprecated, renamed: "NSLocalizedFailureReasonErrorKey")
  public static let localizedFailureReasonErrorKey: Foundation.ErrorUserInfoKey
  @available(*, deprecated, renamed: "NSLocalizedRecoverySuggestionErrorKey")
  public static let localizedRecoverySuggestionErrorKey: Foundation.ErrorUserInfoKey
  @available(*, deprecated, renamed: "NSLocalizedRecoveryOptionsErrorKey")
  public static let localizedRecoveryOptionsErrorKey: Foundation.ErrorUserInfoKey
  @available(*, deprecated, renamed: "NSRecoveryAttempterErrorKey")
  public static let recoveryAttempterErrorKey: Foundation.ErrorUserInfoKey
  @available(*, deprecated, renamed: "NSHelpAnchorErrorKey")
  public static let helpAnchorErrorKey: Foundation.ErrorUserInfoKey
  @available(*, deprecated, renamed: "NSStringEncodingErrorKey")
  public static let stringEncodingErrorKey: Foundation.ErrorUserInfoKey
  @available(*, deprecated, renamed: "NSURLErrorKey")
  public static let NSURLErrorKey: Foundation.ErrorUserInfoKey
  @available(*, deprecated, renamed: "NSFilePathErrorKey")
  public static let filePathErrorKey: Foundation.ErrorUserInfoKey
}
extension Int8 : Swift._ObjectiveCBridgeable {
  @available(swift, deprecated: 4, renamed: "init(truncating:)")
  public init(_ number: __shared Foundation.NSNumber)
  public init(truncating number: __shared Foundation.NSNumber)
  public init?(exactly number: __shared Foundation.NSNumber)
  @_semantics("convertToObjectiveC") public func _bridgeToObjectiveC() -> Foundation.NSNumber
  public static func _forceBridgeFromObjectiveC(_ x: Foundation.NSNumber, result: inout Swift.Int8?)
  public static func _conditionallyBridgeFromObjectiveC(_ x: Foundation.NSNumber, result: inout Swift.Int8?) -> Swift.Bool
  @_effects(readonly) public static func _unconditionallyBridgeFromObjectiveC(_ source: Foundation.NSNumber?) -> Swift.Int8
  public typealias _ObjectiveCType = Foundation.NSNumber
}
extension UInt8 : Swift._ObjectiveCBridgeable {
  @available(swift, deprecated: 4, renamed: "init(truncating:)")
  public init(_ number: __shared Foundation.NSNumber)
  public init(truncating number: __shared Foundation.NSNumber)
  public init?(exactly number: __shared Foundation.NSNumber)
  @_semantics("convertToObjectiveC") public func _bridgeToObjectiveC() -> Foundation.NSNumber
  public static func _forceBridgeFromObjectiveC(_ x: Foundation.NSNumber, result: inout Swift.UInt8?)
  public static func _conditionallyBridgeFromObjectiveC(_ x: Foundation.NSNumber, result: inout Swift.UInt8?) -> Swift.Bool
  @_effects(readonly) public static func _unconditionallyBridgeFromObjectiveC(_ source: Foundation.NSNumber?) -> Swift.UInt8
  public typealias _ObjectiveCType = Foundation.NSNumber
}
extension Int16 : Swift._ObjectiveCBridgeable {
  @available(swift, deprecated: 4, renamed: "init(truncating:)")
  public init(_ number: __shared Foundation.NSNumber)
  public init(truncating number: __shared Foundation.NSNumber)
  public init?(exactly number: __shared Foundation.NSNumber)
  @_semantics("convertToObjectiveC") public func _bridgeToObjectiveC() -> Foundation.NSNumber
  public static func _forceBridgeFromObjectiveC(_ x: Foundation.NSNumber, result: inout Swift.Int16?)
  public static func _conditionallyBridgeFromObjectiveC(_ x: Foundation.NSNumber, result: inout Swift.Int16?) -> Swift.Bool
  @_effects(readonly) public static func _unconditionallyBridgeFromObjectiveC(_ source: Foundation.NSNumber?) -> Swift.Int16
  public typealias _ObjectiveCType = Foundation.NSNumber
}
extension UInt16 : Swift._ObjectiveCBridgeable {
  @available(swift, deprecated: 4, renamed: "init(truncating:)")
  public init(_ number: __shared Foundation.NSNumber)
  public init(truncating number: __shared Foundation.NSNumber)
  public init?(exactly number: __shared Foundation.NSNumber)
  @_semantics("convertToObjectiveC") public func _bridgeToObjectiveC() -> Foundation.NSNumber
  public static func _forceBridgeFromObjectiveC(_ x: Foundation.NSNumber, result: inout Swift.UInt16?)
  public static func _conditionallyBridgeFromObjectiveC(_ x: Foundation.NSNumber, result: inout Swift.UInt16?) -> Swift.Bool
  @_effects(readonly) public static func _unconditionallyBridgeFromObjectiveC(_ source: Foundation.NSNumber?) -> Swift.UInt16
  public typealias _ObjectiveCType = Foundation.NSNumber
}
extension Int32 : Swift._ObjectiveCBridgeable {
  @available(swift, deprecated: 4, renamed: "init(truncating:)")
  public init(_ number: __shared Foundation.NSNumber)
  public init(truncating number: __shared Foundation.NSNumber)
  public init?(exactly number: __shared Foundation.NSNumber)
  @_semantics("convertToObjectiveC") public func _bridgeToObjectiveC() -> Foundation.NSNumber
  public static func _forceBridgeFromObjectiveC(_ x: Foundation.NSNumber, result: inout Swift.Int32?)
  public static func _conditionallyBridgeFromObjectiveC(_ x: Foundation.NSNumber, result: inout Swift.Int32?) -> Swift.Bool
  @_effects(readonly) public static func _unconditionallyBridgeFromObjectiveC(_ source: Foundation.NSNumber?) -> Swift.Int32
  public typealias _ObjectiveCType = Foundation.NSNumber
}
extension UInt32 : Swift._ObjectiveCBridgeable {
  @available(swift, deprecated: 4, renamed: "init(truncating:)")
  public init(_ number: __shared Foundation.NSNumber)
  public init(truncating number: __shared Foundation.NSNumber)
  public init?(exactly number: __shared Foundation.NSNumber)
  @_semantics("convertToObjectiveC") public func _bridgeToObjectiveC() -> Foundation.NSNumber
  public static func _forceBridgeFromObjectiveC(_ x: Foundation.NSNumber, result: inout Swift.UInt32?)
  public static func _conditionallyBridgeFromObjectiveC(_ x: Foundation.NSNumber, result: inout Swift.UInt32?) -> Swift.Bool
  @_effects(readonly) public static func _unconditionallyBridgeFromObjectiveC(_ source: Foundation.NSNumber?) -> Swift.UInt32
  public typealias _ObjectiveCType = Foundation.NSNumber
}
extension Int64 : Swift._ObjectiveCBridgeable {
  @available(swift, deprecated: 4, renamed: "init(truncating:)")
  public init(_ number: __shared Foundation.NSNumber)
  public init(truncating number: __shared Foundation.NSNumber)
  public init?(exactly number: __shared Foundation.NSNumber)
  @_semantics("convertToObjectiveC") public func _bridgeToObjectiveC() -> Foundation.NSNumber
  public static func _forceBridgeFromObjectiveC(_ x: Foundation.NSNumber, result: inout Swift.Int64?)
  public static func _conditionallyBridgeFromObjectiveC(_ x: Foundation.NSNumber, result: inout Swift.Int64?) -> Swift.Bool
  @_effects(readonly) public static func _unconditionallyBridgeFromObjectiveC(_ source: Foundation.NSNumber?) -> Swift.Int64
  public typealias _ObjectiveCType = Foundation.NSNumber
}
extension UInt64 : Swift._ObjectiveCBridgeable {
  @available(swift, deprecated: 4, renamed: "init(truncating:)")
  public init(_ number: __shared Foundation.NSNumber)
  public init(truncating number: __shared Foundation.NSNumber)
  public init?(exactly number: __shared Foundation.NSNumber)
  @_semantics("convertToObjectiveC") public func _bridgeToObjectiveC() -> Foundation.NSNumber
  public static func _forceBridgeFromObjectiveC(_ x: Foundation.NSNumber, result: inout Swift.UInt64?)
  public static func _conditionallyBridgeFromObjectiveC(_ x: Foundation.NSNumber, result: inout Swift.UInt64?) -> Swift.Bool
  @_effects(readonly) public static func _unconditionallyBridgeFromObjectiveC(_ source: Foundation.NSNumber?) -> Swift.UInt64
  public typealias _ObjectiveCType = Foundation.NSNumber
}
extension Int : Swift._ObjectiveCBridgeable {
  @available(swift, deprecated: 4, renamed: "init(truncating:)")
  public init(_ number: __shared Foundation.NSNumber)
  public init(truncating number: __shared Foundation.NSNumber)
  public init?(exactly number: __shared Foundation.NSNumber)
  @_semantics("convertToObjectiveC") public func _bridgeToObjectiveC() -> Foundation.NSNumber
  public static func _forceBridgeFromObjectiveC(_ x: Foundation.NSNumber, result: inout Swift.Int?)
  public static func _conditionallyBridgeFromObjectiveC(_ x: Foundation.NSNumber, result: inout Swift.Int?) -> Swift.Bool
  @_effects(readonly) public static func _unconditionallyBridgeFromObjectiveC(_ source: Foundation.NSNumber?) -> Swift.Int
  public typealias _ObjectiveCType = Foundation.NSNumber
}
extension UInt : Swift._ObjectiveCBridgeable {
  @available(swift, deprecated: 4, renamed: "init(truncating:)")
  public init(_ number: __shared Foundation.NSNumber)
  public init(truncating number: __shared Foundation.NSNumber)
  public init?(exactly number: __shared Foundation.NSNumber)
  @_semantics("convertToObjectiveC") public func _bridgeToObjectiveC() -> Foundation.NSNumber
  public static func _forceBridgeFromObjectiveC(_ x: Foundation.NSNumber, result: inout Swift.UInt?)
  public static func _conditionallyBridgeFromObjectiveC(_ x: Foundation.NSNumber, result: inout Swift.UInt?) -> Swift.Bool
  @_effects(readonly) public static func _unconditionallyBridgeFromObjectiveC(_ source: Foundation.NSNumber?) -> Swift.UInt
  public typealias _ObjectiveCType = Foundation.NSNumber
}
extension Float : Swift._ObjectiveCBridgeable {
  @available(swift, deprecated: 4, renamed: "init(truncating:)")
  public init(_ number: __shared Foundation.NSNumber)
  public init(truncating number: __shared Foundation.NSNumber)
  public init?(exactly number: __shared Foundation.NSNumber)
  @_semantics("convertToObjectiveC") public func _bridgeToObjectiveC() -> Foundation.NSNumber
  public static func _forceBridgeFromObjectiveC(_ x: Foundation.NSNumber, result: inout Swift.Float?)
  public static func _conditionallyBridgeFromObjectiveC(_ x: Foundation.NSNumber, result: inout Swift.Float?) -> Swift.Bool
  @_effects(readonly) public static func _unconditionallyBridgeFromObjectiveC(_ source: Foundation.NSNumber?) -> Swift.Float
  public typealias _ObjectiveCType = Foundation.NSNumber
}
extension Double : Swift._ObjectiveCBridgeable {
  @available(swift, deprecated: 4, renamed: "init(truncating:)")
  public init(_ number: __shared Foundation.NSNumber)
  public init(truncating number: __shared Foundation.NSNumber)
  public init?(exactly number: __shared Foundation.NSNumber)
  @_semantics("convertToObjectiveC") public func _bridgeToObjectiveC() -> Foundation.NSNumber
  public static func _forceBridgeFromObjectiveC(_ x: Foundation.NSNumber, result: inout Swift.Double?)
  public static func _conditionallyBridgeFromObjectiveC(_ x: Foundation.NSNumber, result: inout Swift.Double?) -> Swift.Bool
  @_effects(readonly) public static func _unconditionallyBridgeFromObjectiveC(_ source: Foundation.NSNumber?) -> Swift.Double
  public typealias _ObjectiveCType = Foundation.NSNumber
}
extension Bool : Swift._ObjectiveCBridgeable {
  @available(swift, deprecated: 4, renamed: "init(truncating:)")
  public init(_ number: __shared Foundation.NSNumber)
  public init(truncating number: __shared Foundation.NSNumber)
  public init?(exactly number: __shared Foundation.NSNumber)
  @_semantics("convertToObjectiveC") public func _bridgeToObjectiveC() -> Foundation.NSNumber
  public static func _forceBridgeFromObjectiveC(_ x: Foundation.NSNumber, result: inout Swift.Bool?)
  public static func _conditionallyBridgeFromObjectiveC(_ x: Foundation.NSNumber, result: inout Swift.Bool?) -> Swift.Bool
  @_effects(readonly) public static func _unconditionallyBridgeFromObjectiveC(_ source: Foundation.NSNumber?) -> Swift.Bool
  public typealias _ObjectiveCType = Foundation.NSNumber
}
extension CGFloat : Swift._ObjectiveCBridgeable {
  @available(swift, deprecated: 4, renamed: "init(truncating:)")
  public init(_ number: __shared Foundation.NSNumber)
  public init(truncating number: __shared Foundation.NSNumber)
  public init?(exactly number: __shared Foundation.NSNumber)
  @_semantics("convertToObjectiveC") public func _bridgeToObjectiveC() -> Foundation.NSNumber
  public static func _forceBridgeFromObjectiveC(_ x: Foundation.NSNumber, result: inout CoreGraphics.CGFloat?)
  public static func _conditionallyBridgeFromObjectiveC(_ x: Foundation.NSNumber, result: inout CoreGraphics.CGFloat?) -> Swift.Bool
  @_effects(readonly) public static func _unconditionallyBridgeFromObjectiveC(_ source: Foundation.NSNumber?) -> CoreGraphics.CGFloat
  public typealias _ObjectiveCType = Foundation.NSNumber
}
extension NSNumber : Swift.ExpressibleByFloatLiteral, Swift.ExpressibleByIntegerLiteral, Swift.ExpressibleByBooleanLiteral {
  @nonobjc required convenience public init(integerLiteral value: Swift.Int)
  @nonobjc required convenience public init(floatLiteral value: Swift.Double)
  @nonobjc required convenience public init(booleanLiteral value: Swift.Bool)
  public typealias BooleanLiteralType = Swift.Bool
  public typealias FloatLiteralType = Swift.Double
  public typealias IntegerLiteralType = Swift.Int
}
extension NSNumber : Swift._HasCustomAnyHashableRepresentation {
  @nonobjc public func _toCustomAnyHashable() -> Swift.AnyHashable?
}
@available(macOS 10.12, iOS 10.0, watchOS 3.0, tvOS 10.0, *)
public struct Measurement<UnitType> : Foundation.ReferenceConvertible, Swift.Comparable, Swift.Equatable where UnitType : Foundation.Unit {
  public typealias ReferenceType = Foundation.NSMeasurement
  public let unit: UnitType
  public var value: Swift.Double
  public init(value: Swift.Double, unit: UnitType)
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@available(macOS 10.12, iOS 10.0, watchOS 3.0, tvOS 10.0, *)
extension Measurement : Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible, Swift.CustomReflectable {
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
  public var customMirror: Swift.Mirror {
    get
  }
}
@available(macOS 10.12, iOS 10.0, watchOS 3.0, tvOS 10.0, *)
extension Measurement where UnitType : Foundation.Dimension {
  public func converted(to otherUnit: UnitType) -> Foundation.Measurement<UnitType>
  public mutating func convert(to otherUnit: UnitType)
  public static func + (lhs: Foundation.Measurement<UnitType>, rhs: Foundation.Measurement<UnitType>) -> Foundation.Measurement<UnitType>
  public static func - (lhs: Foundation.Measurement<UnitType>, rhs: Foundation.Measurement<UnitType>) -> Foundation.Measurement<UnitType>
}
@available(macOS 10.12, iOS 10.0, watchOS 3.0, tvOS 10.0, *)
extension Measurement {
  public static func + (lhs: Foundation.Measurement<UnitType>, rhs: Foundation.Measurement<UnitType>) -> Foundation.Measurement<UnitType>
  public static func - (lhs: Foundation.Measurement<UnitType>, rhs: Foundation.Measurement<UnitType>) -> Foundation.Measurement<UnitType>
  public static func * (lhs: Foundation.Measurement<UnitType>, rhs: Swift.Double) -> Foundation.Measurement<UnitType>
  public static func * (lhs: Swift.Double, rhs: Foundation.Measurement<UnitType>) -> Foundation.Measurement<UnitType>
  public static func / (lhs: Foundation.Measurement<UnitType>, rhs: Swift.Double) -> Foundation.Measurement<UnitType>
  public static func / (lhs: Swift.Double, rhs: Foundation.Measurement<UnitType>) -> Foundation.Measurement<UnitType>
  public static func == <LeftHandSideType, RightHandSideType>(lhs: Foundation.Measurement<LeftHandSideType>, rhs: Foundation.Measurement<RightHandSideType>) -> Swift.Bool where LeftHandSideType : Foundation.Unit, RightHandSideType : Foundation.Unit
  public static func < <LeftHandSideType, RightHandSideType>(lhs: Foundation.Measurement<LeftHandSideType>, rhs: Foundation.Measurement<RightHandSideType>) -> Swift.Bool where LeftHandSideType : Foundation.Unit, RightHandSideType : Foundation.Unit
}
@usableFromInline
internal typealias MeasurementBridgeType = Swift._ObjectiveCBridgeable
@available(macOS 10.12, iOS 10.0, watchOS 3.0, tvOS 10.0, *)
extension Measurement : Foundation.MeasurementBridgeType {
  @_semantics("convertToObjectiveC") public func _bridgeToObjectiveC() -> Foundation.NSMeasurement
  public static func _forceBridgeFromObjectiveC(_ source: Foundation.NSMeasurement, result: inout Foundation.Measurement<UnitType>?)
  public static func _conditionallyBridgeFromObjectiveC(_ source: Foundation.NSMeasurement, result: inout Foundation.Measurement<UnitType>?) -> Swift.Bool
  @_effects(readonly) public static func _unconditionallyBridgeFromObjectiveC(_ source: Foundation.NSMeasurement?) -> Foundation.Measurement<UnitType>
  public typealias _ObjectiveCType = Foundation.NSMeasurement
}
@available(macOS 10.12, iOS 10.0, watchOS 3.0, tvOS 10.0, *)
extension NSMeasurement : Swift._HasCustomAnyHashableRepresentation {
  @nonobjc public func _toCustomAnyHashable() -> Swift.AnyHashable?
}
@available(macOS 10.12, iOS 10.0, watchOS 3.0, tvOS 10.0, *)
extension MeasurementFormatter {
  public func string<UnitType>(from measurement: Foundation.Measurement<UnitType>) -> Swift.String where UnitType : Foundation.Unit
}
@available(macOS 10.12, iOS 10.0, watchOS 3.0, tvOS 10.0, *)
extension Measurement : Swift.Codable {
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
public var kCFStringEncodingASCII: CoreFoundation.CFStringEncoding {
  get
}
extension String {
  public struct Encoding : Swift.RawRepresentable {
    public var rawValue: Swift.UInt
    public init(rawValue: Swift.UInt)
    public static let ascii: Swift.String.Encoding
    public static let nextstep: Swift.String.Encoding
    public static let japaneseEUC: Swift.String.Encoding
    public static let utf8: Swift.String.Encoding
    public static let isoLatin1: Swift.String.Encoding
    public static let symbol: Swift.String.Encoding
    public static let nonLossyASCII: Swift.String.Encoding
    public static let shiftJIS: Swift.String.Encoding
    public static let isoLatin2: Swift.String.Encoding
    public static let unicode: Swift.String.Encoding
    public static let windowsCP1251: Swift.String.Encoding
    public static let windowsCP1252: Swift.String.Encoding
    public static let windowsCP1253: Swift.String.Encoding
    public static let windowsCP1254: Swift.String.Encoding
    public static let windowsCP1250: Swift.String.Encoding
    public static let iso2022JP: Swift.String.Encoding
    public static let macOSRoman: Swift.String.Encoding
    public static let utf16: Swift.String.Encoding
    public static let utf16BigEndian: Swift.String.Encoding
    public static let utf16LittleEndian: Swift.String.Encoding
    public static let utf32: Swift.String.Encoding
    public static let utf32BigEndian: Swift.String.Encoding
    public static let utf32LittleEndian: Swift.String.Encoding
    public typealias RawValue = Swift.UInt
  }
  public typealias EncodingConversionOptions = Foundation.NSString.EncodingConversionOptions
  public typealias EnumerationOptions = Foundation.NSString.EnumerationOptions
  public typealias CompareOptions = Foundation.NSString.CompareOptions
}
extension String.Encoding : Swift.Hashable {
  public var hashValue: Swift.Int {
    get
  }
  @_alwaysEmitIntoClient public func hash(into hasher: inout Swift.Hasher) {
        // Note: `hash(only:)` is only defined here because we also define
        // `hashValue`.
        //
        // In 5.0, `hash(into:)` was resolved to RawRepresentable's functionally
        // equivalent definition; we added this definition in 5.1 to make it
        // clear this `hash(into:)` isn't synthesized by the compiler.
        // (Otherwise someone may be tempted to define it, possibly breaking the
        // hash encoding and thus the ABI. RawRepresentable's definition is
        // inlinable.)
        hasher.combine(rawValue)
    }
  public static func == (lhs: Swift.String.Encoding, rhs: Swift.String.Encoding) -> Swift.Bool
}
extension String.Encoding : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
@available(*, unavailable, renamed: "String.Encoding")
public typealias NSStringEncoding = Swift.UInt
@available(*, unavailable, renamed: "String.Encoding.ascii")
public var NSASCIIStringEncoding: Swift.String.Encoding {
  get
}
@available(*, unavailable, renamed: "String.Encoding.nextstep")
public var NSNEXTSTEPStringEncoding: Swift.String.Encoding {
  get
}
@available(*, unavailable, renamed: "String.Encoding.japaneseEUC")
public var NSJapaneseEUCStringEncoding: Swift.String.Encoding {
  get
}
@available(*, unavailable, renamed: "String.Encoding.utf8")
public var NSUTF8StringEncoding: Swift.String.Encoding {
  get
}
@available(*, unavailable, renamed: "String.Encoding.isoLatin1")
public var NSISOLatin1StringEncoding: Swift.String.Encoding {
  get
}
@available(*, unavailable, renamed: "String.Encoding.symbol")
public var NSSymbolStringEncoding: Swift.String.Encoding {
  get
}
@available(*, unavailable, renamed: "String.Encoding.nonLossyASCII")
public var NSNonLossyASCIIStringEncoding: Swift.String.Encoding {
  get
}
@available(*, unavailable, renamed: "String.Encoding.shiftJIS")
public var NSShiftJISStringEncoding: Swift.String.Encoding {
  get
}
@available(*, unavailable, renamed: "String.Encoding.isoLatin2")
public var NSISOLatin2StringEncoding: Swift.String.Encoding {
  get
}
@available(*, unavailable, renamed: "String.Encoding.unicode")
public var NSUnicodeStringEncoding: Swift.String.Encoding {
  get
}
@available(*, unavailable, renamed: "String.Encoding.windowsCP1251")
public var NSWindowsCP1251StringEncoding: Swift.String.Encoding {
  get
}
@available(*, unavailable, renamed: "String.Encoding.windowsCP1252")
public var NSWindowsCP1252StringEncoding: Swift.String.Encoding {
  get
}
@available(*, unavailable, renamed: "String.Encoding.windowsCP1253")
public var NSWindowsCP1253StringEncoding: Swift.String.Encoding {
  get
}
@available(*, unavailable, renamed: "String.Encoding.windowsCP1254")
public var NSWindowsCP1254StringEncoding: Swift.String.Encoding {
  get
}
@available(*, unavailable, renamed: "String.Encoding.windowsCP1250")
public var NSWindowsCP1250StringEncoding: Swift.String.Encoding {
  get
}
@available(*, unavailable, renamed: "String.Encoding.iso2022JP")
public var NSISO2022JPStringEncoding: Swift.String.Encoding {
  get
}
@available(*, unavailable, renamed: "String.Encoding.macOSRoman")
public var NSMacOSRomanStringEncoding: Swift.String.Encoding {
  get
}
@available(*, unavailable, renamed: "String.Encoding.utf16")
public var NSUTF16StringEncoding: Swift.String.Encoding {
  get
}
@available(*, unavailable, renamed: "String.Encoding.utf16BigEndian")
public var NSUTF16BigEndianStringEncoding: Swift.String.Encoding {
  get
}
@available(*, unavailable, renamed: "String.Encoding.utf16LittleEndian")
public var NSUTF16LittleEndianStringEncoding: Swift.String.Encoding {
  get
}
@available(*, unavailable, renamed: "String.Encoding.utf32")
public var NSUTF32StringEncoding: Swift.String.Encoding {
  get
}
@available(*, unavailable, renamed: "String.Encoding.utf32BigEndian")
public var NSUTF32BigEndianStringEncoding: Swift.String.Encoding {
  get
}
@available(*, unavailable, renamed: "String.Encoding.utf32LittleEndian")
public var NSUTF32LittleEndianStringEncoding: Swift.String.Encoding {
  get
}
public protocol ContiguousBytes {
  func withUnsafeBytes<R>(_ body: (Swift.UnsafeRawBufferPointer) throws -> R) rethrows -> R
}
extension Array : Foundation.ContiguousBytes where Element == Swift.UInt8 {
}
extension ArraySlice : Foundation.ContiguousBytes where Element == Swift.UInt8 {
}
extension ContiguousArray : Foundation.ContiguousBytes where Element == Swift.UInt8 {
}
extension UnsafeRawBufferPointer : Foundation.ContiguousBytes {
  @inlinable public func withUnsafeBytes<R>(_ body: (Swift.UnsafeRawBufferPointer) throws -> R) rethrows -> R {
        return try body(self)
    }
}
extension UnsafeMutableRawBufferPointer : Foundation.ContiguousBytes {
  @inlinable public func withUnsafeBytes<R>(_ body: (Swift.UnsafeRawBufferPointer) throws -> R) rethrows -> R {
        return try body(UnsafeRawBufferPointer(self))
    }
}
extension UnsafeBufferPointer : Foundation.ContiguousBytes where Element == Swift.UInt8 {
  @inlinable public func withUnsafeBytes<R>(_ body: (Swift.UnsafeRawBufferPointer) throws -> R) rethrows -> R {
        return try body(UnsafeRawBufferPointer(self))
    }
}
extension UnsafeMutableBufferPointer : Foundation.ContiguousBytes where Element == Swift.UInt8 {
  @inlinable public func withUnsafeBytes<R>(_ body: (Swift.UnsafeRawBufferPointer) throws -> R) rethrows -> R {
        return try body(UnsafeRawBufferPointer(self))
    }
}
extension EmptyCollection : Foundation.ContiguousBytes where Element == Swift.UInt8 {
  @inlinable public func withUnsafeBytes<R>(_ body: (Swift.UnsafeRawBufferPointer) throws -> R) rethrows -> R {
        return try body(UnsafeRawBufferPointer(start: nil, count: 0))
    }
}
extension CollectionOfOne : Foundation.ContiguousBytes where Element == Swift.UInt8 {
  @inlinable public func withUnsafeBytes<R>(_ body: (Swift.UnsafeRawBufferPointer) throws -> R) rethrows -> R {
        let element = self.first!
        return try Swift.withUnsafeBytes(of: element) {
            return try body($0)
        }
    }
}
extension Slice : Foundation.ContiguousBytes where Base : Foundation.ContiguousBytes {
  public func withUnsafeBytes<ResultType>(_ body: (Swift.UnsafeRawBufferPointer) throws -> ResultType) rethrows -> ResultType
}
extension _NSRange : Swift._ObjectiveCBridgeable {
  public func _bridgeToObjectiveC() -> Foundation.NSValue
  public static func _forceBridgeFromObjectiveC(_ source: Foundation.NSValue, result: inout Foundation.NSRange?)
  public static func _conditionallyBridgeFromObjectiveC(_ source: Foundation.NSValue, result: inout Foundation.NSRange?) -> Swift.Bool
  public static func _unconditionallyBridgeFromObjectiveC(_ source: Foundation.NSValue?) -> Foundation.NSRange
  public typealias _ObjectiveCType = Foundation.NSValue
}
extension CGRect : Swift._ObjectiveCBridgeable {
  public func _bridgeToObjectiveC() -> Foundation.NSValue
  public static func _forceBridgeFromObjectiveC(_ source: Foundation.NSValue, result: inout CoreGraphics.CGRect?)
  public static func _conditionallyBridgeFromObjectiveC(_ source: Foundation.NSValue, result: inout CoreGraphics.CGRect?) -> Swift.Bool
  public static func _unconditionallyBridgeFromObjectiveC(_ source: Foundation.NSValue?) -> CoreGraphics.CGRect
  public typealias _ObjectiveCType = Foundation.NSValue
}
extension CGPoint : Swift._ObjectiveCBridgeable {
  public func _bridgeToObjectiveC() -> Foundation.NSValue
  public static func _forceBridgeFromObjectiveC(_ source: Foundation.NSValue, result: inout CoreGraphics.CGPoint?)
  public static func _conditionallyBridgeFromObjectiveC(_ source: Foundation.NSValue, result: inout CoreGraphics.CGPoint?) -> Swift.Bool
  public static func _unconditionallyBridgeFromObjectiveC(_ source: Foundation.NSValue?) -> CoreGraphics.CGPoint
  public typealias _ObjectiveCType = Foundation.NSValue
}
extension CGVector : Swift._ObjectiveCBridgeable {
  public func _bridgeToObjectiveC() -> Foundation.NSValue
  public static func _forceBridgeFromObjectiveC(_ source: Foundation.NSValue, result: inout CoreGraphics.CGVector?)
  public static func _conditionallyBridgeFromObjectiveC(_ source: Foundation.NSValue, result: inout CoreGraphics.CGVector?) -> Swift.Bool
  public static func _unconditionallyBridgeFromObjectiveC(_ source: Foundation.NSValue?) -> CoreGraphics.CGVector
  public typealias _ObjectiveCType = Foundation.NSValue
}
extension CGSize : Swift._ObjectiveCBridgeable {
  public func _bridgeToObjectiveC() -> Foundation.NSValue
  public static func _forceBridgeFromObjectiveC(_ source: Foundation.NSValue, result: inout CoreGraphics.CGSize?)
  public static func _conditionallyBridgeFromObjectiveC(_ source: Foundation.NSValue, result: inout CoreGraphics.CGSize?) -> Swift.Bool
  public static func _unconditionallyBridgeFromObjectiveC(_ source: Foundation.NSValue?) -> CoreGraphics.CGSize
  public typealias _ObjectiveCType = Foundation.NSValue
}
extension CGAffineTransform : Swift._ObjectiveCBridgeable {
  public func _bridgeToObjectiveC() -> Foundation.NSValue
  public static func _forceBridgeFromObjectiveC(_ source: Foundation.NSValue, result: inout CoreGraphics.CGAffineTransform?)
  public static func _conditionallyBridgeFromObjectiveC(_ source: Foundation.NSValue, result: inout CoreGraphics.CGAffineTransform?) -> Swift.Bool
  public static func _unconditionallyBridgeFromObjectiveC(_ source: Foundation.NSValue?) -> CoreGraphics.CGAffineTransform
  public typealias _ObjectiveCType = Foundation.NSValue
}
extension NSValue {
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public func value<StoredType>(of type: StoredType.Type) -> StoredType?
}
public struct NSIndexSetIterator : Swift.IteratorProtocol {
  public typealias Element = Swift.Int
  public mutating func next() -> Swift.Int?
}
extension NSIndexSet : Swift.Sequence {
  public func makeIterator() -> Foundation.NSIndexSetIterator
  public typealias Element = Foundation.NSIndexSetIterator.Element
  public typealias Iterator = Foundation.NSIndexSetIterator
}
@available(macOS 10.11, iOS 9.0, *)
public struct PersonNameComponents : Foundation.ReferenceConvertible, Swift.Hashable, Swift.Equatable {
  public typealias ReferenceType = Foundation.NSPersonNameComponents
  public init()
  public var namePrefix: Swift.String? {
    get
    set
  }
  public var givenName: Swift.String? {
    get
    set
  }
  public var middleName: Swift.String? {
    get
    set
  }
  public var familyName: Swift.String? {
    get
    set
  }
  public var nameSuffix: Swift.String? {
    get
    set
  }
  public var nickname: Swift.String? {
    get
    set
  }
  public var phoneticRepresentation: Foundation.PersonNameComponents? {
    get
    set
  }
  public func hash(into hasher: inout Swift.Hasher)
  @available(macOS 10.11, iOS 9.0, *)
  public static func == (lhs: Foundation.PersonNameComponents, rhs: Foundation.PersonNameComponents) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
@available(macOS 10.11, iOS 9.0, *)
extension PersonNameComponents : Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible, Swift.CustomReflectable {
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
  public var customMirror: Swift.Mirror {
    get
  }
}
@available(macOS 10.11, iOS 9.0, *)
extension PersonNameComponents : Swift._ObjectiveCBridgeable {
  public static func _getObjectiveCType() -> Any.Type
  @_semantics("convertToObjectiveC") public func _bridgeToObjectiveC() -> Foundation.NSPersonNameComponents
  public static func _forceBridgeFromObjectiveC(_ personNameComponents: Foundation.NSPersonNameComponents, result: inout Foundation.PersonNameComponents?)
  public static func _conditionallyBridgeFromObjectiveC(_ personNameComponents: Foundation.NSPersonNameComponents, result: inout Foundation.PersonNameComponents?) -> Swift.Bool
  @_effects(readonly) public static func _unconditionallyBridgeFromObjectiveC(_ source: Foundation.NSPersonNameComponents?) -> Foundation.PersonNameComponents
  public typealias _ObjectiveCType = Foundation.NSPersonNameComponents
}
@available(macOS 10.11, iOS 9.0, *)
extension NSPersonNameComponents : Swift._HasCustomAnyHashableRepresentation {
  @nonobjc public func _toCustomAnyHashable() -> Swift.AnyHashable?
}
@available(macOS 10.11, iOS 9.0, *)
extension PersonNameComponents : Swift.Codable {
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
public struct CharacterSet : Foundation.ReferenceConvertible, Swift.Equatable, Swift.Hashable, Swift.SetAlgebra {
  public typealias ReferenceType = Foundation.NSCharacterSet
  public init()
  public init(charactersIn range: Swift.Range<Swift.Unicode.Scalar>)
  public init(charactersIn range: Swift.ClosedRange<Swift.Unicode.Scalar>)
  public init(charactersIn string: __shared Swift.String)
  public init(bitmapRepresentation data: __shared Foundation.Data)
  public init?(contentsOfFile file: __shared Swift.String)
  public static var controlCharacters: Foundation.CharacterSet {
    get
  }
  public static var whitespaces: Foundation.CharacterSet {
    get
  }
  public static var whitespacesAndNewlines: Foundation.CharacterSet {
    get
  }
  public static var decimalDigits: Foundation.CharacterSet {
    get
  }
  public static var letters: Foundation.CharacterSet {
    get
  }
  public static var lowercaseLetters: Foundation.CharacterSet {
    get
  }
  public static var uppercaseLetters: Foundation.CharacterSet {
    get
  }
  public static var nonBaseCharacters: Foundation.CharacterSet {
    get
  }
  public static var alphanumerics: Foundation.CharacterSet {
    get
  }
  public static var decomposables: Foundation.CharacterSet {
    get
  }
  public static var illegalCharacters: Foundation.CharacterSet {
    get
  }
  @available(*, unavailable, renamed: "punctuationCharacters")
  public static var punctuation: Foundation.CharacterSet {
    get
  }
  public static var punctuationCharacters: Foundation.CharacterSet {
    get
  }
  public static var capitalizedLetters: Foundation.CharacterSet {
    get
  }
  public static var symbols: Foundation.CharacterSet {
    get
  }
  public static var newlines: Foundation.CharacterSet {
    get
  }
  public static var urlUserAllowed: Foundation.CharacterSet {
    get
  }
  public static var urlPasswordAllowed: Foundation.CharacterSet {
    get
  }
  public static var urlHostAllowed: Foundation.CharacterSet {
    get
  }
  public static var urlPathAllowed: Foundation.CharacterSet {
    get
  }
  public static var urlQueryAllowed: Foundation.CharacterSet {
    get
  }
  public static var urlFragmentAllowed: Foundation.CharacterSet {
    get
  }
  @nonobjc public var bitmapRepresentation: Foundation.Data {
    get
  }
  @nonobjc public var inverted: Foundation.CharacterSet {
    get
  }
  public func hasMember(inPlane plane: Swift.UInt8) -> Swift.Bool
  public mutating func insert(charactersIn range: Swift.Range<Swift.Unicode.Scalar>)
  public mutating func insert(charactersIn range: Swift.ClosedRange<Swift.Unicode.Scalar>)
  public mutating func remove(charactersIn range: Swift.Range<Swift.Unicode.Scalar>)
  public mutating func remove(charactersIn range: Swift.ClosedRange<Swift.Unicode.Scalar>)
  public mutating func insert(charactersIn string: Swift.String)
  public mutating func remove(charactersIn string: Swift.String)
  public mutating func invert()
  @discardableResult
  public mutating func insert(_ character: Swift.Unicode.Scalar) -> (inserted: Swift.Bool, memberAfterInsert: Swift.Unicode.Scalar)
  @discardableResult
  public mutating func update(with character: Swift.Unicode.Scalar) -> Swift.Unicode.Scalar?
  @discardableResult
  public mutating func remove(_ character: Swift.Unicode.Scalar) -> Swift.Unicode.Scalar?
  public func contains(_ member: Swift.Unicode.Scalar) -> Swift.Bool
  public func union(_ other: Foundation.CharacterSet) -> Foundation.CharacterSet
  public mutating func formUnion(_ other: Foundation.CharacterSet)
  public func intersection(_ other: Foundation.CharacterSet) -> Foundation.CharacterSet
  public mutating func formIntersection(_ other: Foundation.CharacterSet)
  public func subtracting(_ other: Foundation.CharacterSet) -> Foundation.CharacterSet
  public mutating func subtract(_ other: Foundation.CharacterSet)
  public func symmetricDifference(_ other: Foundation.CharacterSet) -> Foundation.CharacterSet
  public mutating func formSymmetricDifference(_ other: Foundation.CharacterSet)
  public func isSuperset(of other: Foundation.CharacterSet) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (lhs: Foundation.CharacterSet, rhs: Foundation.CharacterSet) -> Swift.Bool
  public typealias ArrayLiteralElement = Swift.Unicode.Scalar
  public typealias Element = Swift.Unicode.Scalar
  public var hashValue: Swift.Int {
    get
  }
}
extension CharacterSet : Swift._ObjectiveCBridgeable {
  public static func _getObjectiveCType() -> Any.Type
  @_semantics("convertToObjectiveC") public func _bridgeToObjectiveC() -> Foundation.NSCharacterSet
  public static func _forceBridgeFromObjectiveC(_ input: Foundation.NSCharacterSet, result: inout Foundation.CharacterSet?)
  public static func _conditionallyBridgeFromObjectiveC(_ input: Foundation.NSCharacterSet, result: inout Foundation.CharacterSet?) -> Swift.Bool
  @_effects(readonly) public static func _unconditionallyBridgeFromObjectiveC(_ source: Foundation.NSCharacterSet?) -> Foundation.CharacterSet
  public typealias _ObjectiveCType = Foundation.NSCharacterSet
}
extension CharacterSet : Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible {
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
}
extension NSCharacterSet : Swift._HasCustomAnyHashableRepresentation {
  @nonobjc public func _toCustomAnyHashable() -> Swift.AnyHashable?
}
extension CharacterSet : Swift.Codable {
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
public struct URLComponents : Foundation.ReferenceConvertible, Swift.Hashable, Swift.Equatable {
  public typealias ReferenceType = Foundation.NSURLComponents
  public init()
  public init?(url: __shared Foundation.URL, resolvingAgainstBaseURL resolve: Swift.Bool)
  public init?(string: __shared Swift.String)
  public var url: Foundation.URL? {
    get
  }
  public func url(relativeTo base: Foundation.URL?) -> Foundation.URL?
  @available(macOS 10.10, iOS 8.0, *)
  public var string: Swift.String? {
    get
  }
  public var scheme: Swift.String? {
    get
    set
  }
  public var user: Swift.String? {
    get
    set
  }
  public var password: Swift.String? {
    get
    set
  }
  public var host: Swift.String? {
    get
    set
  }
  public var port: Swift.Int? {
    get
    set
  }
  public var path: Swift.String {
    get
    set
  }
  public var query: Swift.String? {
    get
    set
  }
  public var fragment: Swift.String? {
    get
    set
  }
  public var percentEncodedUser: Swift.String? {
    get
    set
  }
  public var percentEncodedPassword: Swift.String? {
    get
    set
  }
  public var percentEncodedHost: Swift.String? {
    get
    set
  }
  public var percentEncodedPath: Swift.String {
    get
    set
  }
  public var percentEncodedQuery: Swift.String? {
    get
    set
  }
  public var percentEncodedFragment: Swift.String? {
    get
    set
  }
  @available(macOS 10.11, iOS 9.0, *)
  public var rangeOfScheme: Swift.Range<Swift.String.Index>? {
    get
  }
  @available(macOS 10.11, iOS 9.0, *)
  public var rangeOfUser: Swift.Range<Swift.String.Index>? {
    get
  }
  @available(macOS 10.11, iOS 9.0, *)
  public var rangeOfPassword: Swift.Range<Swift.String.Index>? {
    get
  }
  @available(macOS 10.11, iOS 9.0, *)
  public var rangeOfHost: Swift.Range<Swift.String.Index>? {
    get
  }
  @available(macOS 10.11, iOS 9.0, *)
  public var rangeOfPort: Swift.Range<Swift.String.Index>? {
    get
  }
  @available(macOS 10.11, iOS 9.0, *)
  public var rangeOfPath: Swift.Range<Swift.String.Index>? {
    get
  }
  @available(macOS 10.11, iOS 9.0, *)
  public var rangeOfQuery: Swift.Range<Swift.String.Index>? {
    get
  }
  @available(macOS 10.11, iOS 9.0, *)
  public var rangeOfFragment: Swift.Range<Swift.String.Index>? {
    get
  }
  @available(macOS 10.10, iOS 8.0, *)
  public var queryItems: [Foundation.URLQueryItem]? {
    get
    set
  }
  @available(macOS 10.13, iOS 11.0, tvOS 11.0, watchOS 4.0, *)
  public var percentEncodedQueryItems: [Foundation.URLQueryItem]? {
    get
    set
  }
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (lhs: Foundation.URLComponents, rhs: Foundation.URLComponents) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
extension URLComponents : Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible, Swift.CustomReflectable {
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
  public var customMirror: Swift.Mirror {
    get
  }
}
extension URLComponents : Swift._ObjectiveCBridgeable {
  public static func _getObjectiveCType() -> Any.Type
  @_semantics("convertToObjectiveC") public func _bridgeToObjectiveC() -> Foundation.NSURLComponents
  public static func _forceBridgeFromObjectiveC(_ x: Foundation.NSURLComponents, result: inout Foundation.URLComponents?)
  public static func _conditionallyBridgeFromObjectiveC(_ x: Foundation.NSURLComponents, result: inout Foundation.URLComponents?) -> Swift.Bool
  @_effects(readonly) public static func _unconditionallyBridgeFromObjectiveC(_ source: Foundation.NSURLComponents?) -> Foundation.URLComponents
  public typealias _ObjectiveCType = Foundation.NSURLComponents
}
extension NSURLComponents : Swift._HasCustomAnyHashableRepresentation {
  @nonobjc public func _toCustomAnyHashable() -> Swift.AnyHashable?
}
@available(macOS 10.10, iOS 8.0, *)
public struct URLQueryItem : Foundation.ReferenceConvertible, Swift.Hashable, Swift.Equatable {
  public typealias ReferenceType = Foundation.NSURLQueryItem
  public init(name: __shared Swift.String, value: __shared Swift.String?)
  public var name: Swift.String {
    get
    set
  }
  public var value: Swift.String? {
    get
    set
  }
  public func hash(into hasher: inout Swift.Hasher)
  @available(macOS 10.10, iOS 8.0, *)
  public static func == (lhs: Foundation.URLQueryItem, rhs: Foundation.URLQueryItem) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
@available(macOS 10.10, iOS 8.0, *)
extension URLQueryItem : Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible, Swift.CustomReflectable {
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
  public var customMirror: Swift.Mirror {
    get
  }
}
@available(macOS 10.10, iOS 8.0, *)
extension URLQueryItem : Swift._ObjectiveCBridgeable {
  public static func _getObjectiveCType() -> Any.Type
  @_semantics("convertToObjectiveC") public func _bridgeToObjectiveC() -> Foundation.NSURLQueryItem
  public static func _forceBridgeFromObjectiveC(_ x: Foundation.NSURLQueryItem, result: inout Foundation.URLQueryItem?)
  public static func _conditionallyBridgeFromObjectiveC(_ x: Foundation.NSURLQueryItem, result: inout Foundation.URLQueryItem?) -> Swift.Bool
  @_effects(readonly) public static func _unconditionallyBridgeFromObjectiveC(_ source: Foundation.NSURLQueryItem?) -> Foundation.URLQueryItem
  public typealias _ObjectiveCType = Foundation.NSURLQueryItem
}
@available(macOS 10.10, iOS 8.0, *)
extension NSURLQueryItem : Swift._HasCustomAnyHashableRepresentation {
  @nonobjc public func _toCustomAnyHashable() -> Swift.AnyHashable?
}
extension URLComponents : Swift.Codable {
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
public struct Date : Foundation.ReferenceConvertible, Swift.Comparable, Swift.Equatable {
  public typealias ReferenceType = Foundation.NSDate
  public static let timeIntervalBetween1970AndReferenceDate: Swift.Double
  public static var timeIntervalSinceReferenceDate: Foundation.TimeInterval {
    get
  }
  public init()
  public init(timeIntervalSinceNow: Foundation.TimeInterval)
  public init(timeIntervalSince1970: Foundation.TimeInterval)
  public init(timeInterval: Foundation.TimeInterval, since date: Foundation.Date)
  public init(timeIntervalSinceReferenceDate ti: Foundation.TimeInterval)
  public var timeIntervalSinceReferenceDate: Foundation.TimeInterval {
    get
  }
  public func timeIntervalSince(_ date: Foundation.Date) -> Foundation.TimeInterval
  public var timeIntervalSinceNow: Foundation.TimeInterval {
    get
  }
  public var timeIntervalSince1970: Foundation.TimeInterval {
    get
  }
  public func addingTimeInterval(_ timeInterval: Foundation.TimeInterval) -> Foundation.Date
  public mutating func addTimeInterval(_ timeInterval: Foundation.TimeInterval)
  public static let distantFuture: Foundation.Date
  public static let distantPast: Foundation.Date
  public func hash(into hasher: inout Swift.Hasher)
  public func compare(_ other: Foundation.Date) -> Foundation.ComparisonResult
  public static func == (lhs: Foundation.Date, rhs: Foundation.Date) -> Swift.Bool
  public static func < (lhs: Foundation.Date, rhs: Foundation.Date) -> Swift.Bool
  public static func > (lhs: Foundation.Date, rhs: Foundation.Date) -> Swift.Bool
  public static func + (lhs: Foundation.Date, rhs: Foundation.TimeInterval) -> Foundation.Date
  public static func - (lhs: Foundation.Date, rhs: Foundation.TimeInterval) -> Foundation.Date
  public static func += (lhs: inout Foundation.Date, rhs: Foundation.TimeInterval)
  public static func -= (lhs: inout Foundation.Date, rhs: Foundation.TimeInterval)
  public var hashValue: Swift.Int {
    get
  }
}
extension Date : Swift.CustomDebugStringConvertible, Swift.CustomStringConvertible, Swift.CustomReflectable {
  public var description: Swift.String {
    get
  }
  public func description(with locale: Foundation.Locale?) -> Swift.String
  public var debugDescription: Swift.String {
    get
  }
  public var customMirror: Swift.Mirror {
    get
  }
}
extension Date : Swift._ObjectiveCBridgeable {
  @_semantics("convertToObjectiveC") public func _bridgeToObjectiveC() -> Foundation.NSDate
  public static func _forceBridgeFromObjectiveC(_ x: Foundation.NSDate, result: inout Foundation.Date?)
  public static func _conditionallyBridgeFromObjectiveC(_ x: Foundation.NSDate, result: inout Foundation.Date?) -> Swift.Bool
  @_effects(readonly) public static func _unconditionallyBridgeFromObjectiveC(_ source: Foundation.NSDate?) -> Foundation.Date
  public typealias _ObjectiveCType = Foundation.NSDate
}
extension NSDate : Swift._HasCustomAnyHashableRepresentation {
  @nonobjc public func _toCustomAnyHashable() -> Swift.AnyHashable?
}
extension Date : Swift._CustomPlaygroundQuickLookable {
  @available(*, deprecated, message: "Date.customPlaygroundQuickLook will be removed in a future Swift version")
  public var customPlaygroundQuickLook: Swift.PlaygroundQuickLook {
    get
  }
}
extension Date : Swift.Codable {
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
public struct Notification : Foundation.ReferenceConvertible, Swift.Equatable, Swift.Hashable {
  public typealias ReferenceType = Foundation.NSNotification
  public var name: Foundation.Notification.Name
  public var object: Any?
  public var userInfo: [Swift.AnyHashable : Any]?
  public init(name: Foundation.Notification.Name, object: Any? = nil, userInfo: [Swift.AnyHashable : Any]? = nil)
  public func hash(into hasher: inout Swift.Hasher)
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
  public typealias Name = Foundation.NSNotification.Name
  public static func == (lhs: Foundation.Notification, rhs: Foundation.Notification) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
extension Notification : Swift.CustomReflectable {
  public var customMirror: Swift.Mirror {
    get
  }
}
extension Notification : Swift._ObjectiveCBridgeable {
  public static func _getObjectiveCType() -> Any.Type
  @_semantics("convertToObjectiveC") public func _bridgeToObjectiveC() -> Foundation.NSNotification
  public static func _forceBridgeFromObjectiveC(_ x: Foundation.NSNotification, result: inout Foundation.Notification?)
  public static func _conditionallyBridgeFromObjectiveC(_ x: Foundation.NSNotification, result: inout Foundation.Notification?) -> Swift.Bool
  @_effects(readonly) public static func _unconditionallyBridgeFromObjectiveC(_ source: Foundation.NSNotification?) -> Foundation.Notification
  public typealias _ObjectiveCType = Foundation.NSNotification
}
extension NSNotification : Swift._HasCustomAnyHashableRepresentation {
  @nonobjc public func _toCustomAnyHashable() -> Swift.AnyHashable?
}
public struct Calendar : Swift.Hashable, Swift.Equatable, Foundation.ReferenceConvertible {
  public typealias ReferenceType = Foundation.NSCalendar
  public enum Identifier {
    case gregorian
    case buddhist
    case chinese
    case coptic
    case ethiopicAmeteMihret
    case ethiopicAmeteAlem
    case hebrew
    case iso8601
    case indian
    case islamic
    case islamicCivil
    case japanese
    case persian
    case republicOfChina
    @available(macOS 10.10, iOS 8.0, *)
    case islamicTabular
    @available(macOS 10.10, iOS 8.0, *)
    case islamicUmmAlQura
    public static func == (a: Foundation.Calendar.Identifier, b: Foundation.Calendar.Identifier) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public enum Component {
    case era
    case year
    case month
    case day
    case hour
    case minute
    case second
    case weekday
    case weekdayOrdinal
    case quarter
    case weekOfMonth
    case weekOfYear
    case yearForWeekOfYear
    case nanosecond
    case calendar
    case timeZone
    public static func == (a: Foundation.Calendar.Component, b: Foundation.Calendar.Component) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public static var current: Foundation.Calendar {
    get
  }
  public static var autoupdatingCurrent: Foundation.Calendar {
    get
  }
  public init(identifier: __shared Foundation.Calendar.Identifier)
  public var identifier: Foundation.Calendar.Identifier {
    get
  }
  public var locale: Foundation.Locale? {
    get
    set
  }
  public var timeZone: Foundation.TimeZone {
    get
    set
  }
  public var firstWeekday: Swift.Int {
    get
    set
  }
  public var minimumDaysInFirstWeek: Swift.Int {
    get
    set
  }
  public var eraSymbols: [Swift.String] {
    get
  }
  public var longEraSymbols: [Swift.String] {
    get
  }
  public var monthSymbols: [Swift.String] {
    get
  }
  public var shortMonthSymbols: [Swift.String] {
    get
  }
  public var veryShortMonthSymbols: [Swift.String] {
    get
  }
  public var standaloneMonthSymbols: [Swift.String] {
    get
  }
  public var shortStandaloneMonthSymbols: [Swift.String] {
    get
  }
  public var veryShortStandaloneMonthSymbols: [Swift.String] {
    get
  }
  public var weekdaySymbols: [Swift.String] {
    get
  }
  public var shortWeekdaySymbols: [Swift.String] {
    get
  }
  public var veryShortWeekdaySymbols: [Swift.String] {
    get
  }
  public var standaloneWeekdaySymbols: [Swift.String] {
    get
  }
  public var shortStandaloneWeekdaySymbols: [Swift.String] {
    get
  }
  public var veryShortStandaloneWeekdaySymbols: [Swift.String] {
    get
  }
  public var quarterSymbols: [Swift.String] {
    get
  }
  public var shortQuarterSymbols: [Swift.String] {
    get
  }
  public var standaloneQuarterSymbols: [Swift.String] {
    get
  }
  public var shortStandaloneQuarterSymbols: [Swift.String] {
    get
  }
  public var amSymbol: Swift.String {
    get
  }
  public var pmSymbol: Swift.String {
    get
  }
  public func minimumRange(of component: Foundation.Calendar.Component) -> Swift.Range<Swift.Int>?
  public func maximumRange(of component: Foundation.Calendar.Component) -> Swift.Range<Swift.Int>?
  @available(*, unavailable, message: "use range(of:in:for:) instead")
  public func range(of smaller: Foundation.NSCalendar.Unit, in larger: Foundation.NSCalendar.Unit, for date: Foundation.Date) -> Foundation.NSRange
  public func range(of smaller: Foundation.Calendar.Component, in larger: Foundation.Calendar.Component, for date: Foundation.Date) -> Swift.Range<Swift.Int>?
  @available(*, unavailable, message: "use range(of:in:for:) instead")
  public func range(of unit: Foundation.NSCalendar.Unit, start datep: Swift.AutoreleasingUnsafeMutablePointer<Foundation.NSDate?>?, interval tip: Swift.UnsafeMutablePointer<Foundation.TimeInterval>?, for date: Foundation.Date) -> Swift.Bool
  public func dateInterval(of component: Foundation.Calendar.Component, start: inout Foundation.Date, interval: inout Foundation.TimeInterval, for date: Foundation.Date) -> Swift.Bool
  @available(macOS 10.12, iOS 10.0, tvOS 10.0, watchOS 3.0, *)
  public func dateInterval(of component: Foundation.Calendar.Component, for date: Foundation.Date) -> Foundation.DateInterval?
  public func ordinality(of smaller: Foundation.Calendar.Component, in larger: Foundation.Calendar.Component, for date: Foundation.Date) -> Swift.Int?
  @available(*, unavailable, message: "use dateComponents(_:from:) instead")
  public func getEra(_ eraValuePointer: Swift.UnsafeMutablePointer<Swift.Int>?, year yearValuePointer: Swift.UnsafeMutablePointer<Swift.Int>?, month monthValuePointer: Swift.UnsafeMutablePointer<Swift.Int>?, day dayValuePointer: Swift.UnsafeMutablePointer<Swift.Int>?, from date: Foundation.Date)
  @available(*, unavailable, message: "use dateComponents(_:from:) instead")
  public func getEra(_ eraValuePointer: Swift.UnsafeMutablePointer<Swift.Int>?, yearForWeekOfYear yearValuePointer: Swift.UnsafeMutablePointer<Swift.Int>?, weekOfYear weekValuePointer: Swift.UnsafeMutablePointer<Swift.Int>?, weekday weekdayValuePointer: Swift.UnsafeMutablePointer<Swift.Int>?, from date: Foundation.Date)
  @available(*, unavailable, message: "use dateComponents(_:from:) instead")
  public func getHour(_ hourValuePointer: Swift.UnsafeMutablePointer<Swift.Int>?, minute minuteValuePointer: Swift.UnsafeMutablePointer<Swift.Int>?, second secondValuePointer: Swift.UnsafeMutablePointer<Swift.Int>?, nanosecond nanosecondValuePointer: Swift.UnsafeMutablePointer<Swift.Int>?, from date: Foundation.Date)
  @available(*, unavailable, message: "use date(byAdding:to:wrappingComponents:) instead")
  public func date(byAdding unit: Foundation.NSCalendar.Unit, value: Swift.Int, to date: Foundation.Date, options: Foundation.NSCalendar.Options = []) -> Foundation.Date?
  public func date(byAdding components: Foundation.DateComponents, to date: Foundation.Date, wrappingComponents: Swift.Bool = false) -> Foundation.Date?
  @available(*, unavailable, message: "use date(byAdding:to:wrappingComponents:) instead")
  public func date(byAdding comps: Foundation.DateComponents, to date: Foundation.Date, options opts: Foundation.NSCalendar.Options = []) -> Foundation.Date?
  @available(iOS 8.0, *)
  public func date(byAdding component: Foundation.Calendar.Component, value: Swift.Int, to date: Foundation.Date, wrappingComponents: Swift.Bool = false) -> Foundation.Date?
  public func date(from components: Foundation.DateComponents) -> Foundation.Date?
  @available(*, unavailable, renamed: "dateComponents(_:from:)")
  public func components(_ unitFlags: Foundation.NSCalendar.Unit, from date: Foundation.Date) -> Foundation.DateComponents
  public func dateComponents(_ components: Swift.Set<Foundation.Calendar.Component>, from date: Foundation.Date) -> Foundation.DateComponents
  @available(*, unavailable, renamed: "dateComponents(in:from:)")
  public func components(in timezone: Foundation.TimeZone, from date: Foundation.Date) -> Foundation.DateComponents
  @available(iOS 8.0, *)
  public func dateComponents(in timeZone: Foundation.TimeZone, from date: Foundation.Date) -> Foundation.DateComponents
  @available(*, unavailable, renamed: "dateComponents(_:from:to:)")
  public func components(_ unitFlags: Foundation.NSCalendar.Unit, from startingDate: Foundation.Date, to resultDate: Foundation.Date, options opts: Foundation.NSCalendar.Options = []) -> Foundation.DateComponents
  public func dateComponents(_ components: Swift.Set<Foundation.Calendar.Component>, from start: Foundation.Date, to end: Foundation.Date) -> Foundation.DateComponents
  @available(*, unavailable, renamed: "dateComponents(_:from:to:)")
  public func components(_ unitFlags: Foundation.NSCalendar.Unit, from startingDateComp: Foundation.DateComponents, to resultDateComp: Foundation.DateComponents, options: Foundation.NSCalendar.Options = []) -> Foundation.DateComponents
  @available(iOS 8.0, *)
  public func dateComponents(_ components: Swift.Set<Foundation.Calendar.Component>, from start: Foundation.DateComponents, to end: Foundation.DateComponents) -> Foundation.DateComponents
  @available(iOS 8.0, *)
  public func component(_ component: Foundation.Calendar.Component, from date: Foundation.Date) -> Swift.Int
  @available(*, unavailable, message: "Use date(from:) instead")
  public func date(era: Swift.Int, year: Swift.Int, month: Swift.Int, day: Swift.Int, hour: Swift.Int, minute: Swift.Int, second: Swift.Int, nanosecond: Swift.Int) -> Foundation.Date?
  @available(*, unavailable, message: "Use date(from:) instead")
  public func date(era: Swift.Int, yearForWeekOfYear: Swift.Int, weekOfYear: Swift.Int, weekday: Swift.Int, hour: Swift.Int, minute: Swift.Int, second: Swift.Int, nanosecond: Swift.Int) -> Foundation.Date?
  @available(iOS 8.0, *)
  public func startOfDay(for date: Foundation.Date) -> Foundation.Date
  @available(*, unavailable, renamed: "compare(_:to:toGranularity:)")
  public func compare(_ date1: Foundation.Date, to date2: Foundation.Date, toUnitGranularity unit: Foundation.NSCalendar.Unit) -> Foundation.ComparisonResult
  @available(iOS 8.0, *)
  public func compare(_ date1: Foundation.Date, to date2: Foundation.Date, toGranularity component: Foundation.Calendar.Component) -> Foundation.ComparisonResult
  @available(*, unavailable, renamed: "isDate(_:equalTo:toGranularity:)")
  public func isDate(_ date1: Foundation.Date, equalTo date2: Foundation.Date, toUnitGranularity unit: Foundation.NSCalendar.Unit) -> Swift.Bool
  @available(iOS 8.0, *)
  public func isDate(_ date1: Foundation.Date, equalTo date2: Foundation.Date, toGranularity component: Foundation.Calendar.Component) -> Swift.Bool
  @available(iOS 8.0, *)
  public func isDate(_ date1: Foundation.Date, inSameDayAs date2: Foundation.Date) -> Swift.Bool
  @available(iOS 8.0, *)
  public func isDateInToday(_ date: Foundation.Date) -> Swift.Bool
  @available(iOS 8.0, *)
  public func isDateInYesterday(_ date: Foundation.Date) -> Swift.Bool
  @available(iOS 8.0, *)
  public func isDateInTomorrow(_ date: Foundation.Date) -> Swift.Bool
  @available(iOS 8.0, *)
  public func isDateInWeekend(_ date: Foundation.Date) -> Swift.Bool
  @available(*, unavailable, message: "use dateIntervalOfWeekend(containing:start:interval:) instead")
  public func range(ofWeekendStart datep: Swift.AutoreleasingUnsafeMutablePointer<Foundation.NSDate?>?, interval tip: Swift.UnsafeMutablePointer<Foundation.TimeInterval>?, containing date: Foundation.Date) -> Swift.Bool
  @available(iOS 8.0, *)
  public func dateIntervalOfWeekend(containing date: Foundation.Date, start: inout Foundation.Date, interval: inout Foundation.TimeInterval) -> Swift.Bool
  @available(macOS 10.12, iOS 10.0, tvOS 10.0, watchOS 3.0, *)
  public func dateIntervalOfWeekend(containing date: Foundation.Date) -> Foundation.DateInterval?
  @available(*, unavailable, message: "use nextWeekend(startingAfter:start:interval:direction:) instead")
  public func nextWeekendStart(_ datep: Swift.AutoreleasingUnsafeMutablePointer<Foundation.NSDate?>?, interval tip: Swift.UnsafeMutablePointer<Foundation.TimeInterval>?, options: Foundation.NSCalendar.Options = [], after date: Foundation.Date) -> Swift.Bool
  @available(iOS 8.0, *)
  public func nextWeekend(startingAfter date: Foundation.Date, start: inout Foundation.Date, interval: inout Foundation.TimeInterval, direction: Foundation.Calendar.SearchDirection = .forward) -> Swift.Bool
  @available(macOS 10.12, iOS 10.0, tvOS 10.0, watchOS 3.0, *)
  public func nextWeekend(startingAfter date: Foundation.Date, direction: Foundation.Calendar.SearchDirection = .forward) -> Foundation.DateInterval?
  public enum SearchDirection {
    case forward
    case backward
    public static func == (a: Foundation.Calendar.SearchDirection, b: Foundation.Calendar.SearchDirection) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public enum RepeatedTimePolicy {
    case first
    case last
    public static func == (a: Foundation.Calendar.RepeatedTimePolicy, b: Foundation.Calendar.RepeatedTimePolicy) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public enum MatchingPolicy {
    case nextTime
    case nextTimePreservingSmallerComponents
    case previousTimePreservingSmallerComponents
    case strict
    public static func == (a: Foundation.Calendar.MatchingPolicy, b: Foundation.Calendar.MatchingPolicy) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  @available(*, unavailable, message: "use nextWeekend(startingAfter:matching:matchingPolicy:repeatedTimePolicy:direction:using:) instead")
  public func enumerateDates(startingAfter start: Foundation.Date, matching comps: Foundation.DateComponents, options opts: Foundation.NSCalendar.Options = [], using block: (Foundation.Date?, Swift.Bool, Swift.UnsafeMutablePointer<ObjectiveC.ObjCBool>) -> Swift.Void)
  @available(iOS 8.0, *)
  public func enumerateDates(startingAfter start: Foundation.Date, matching components: Foundation.DateComponents, matchingPolicy: Foundation.Calendar.MatchingPolicy, repeatedTimePolicy: Foundation.Calendar.RepeatedTimePolicy = .first, direction: Foundation.Calendar.SearchDirection = .forward, using block: (Foundation.Date?, Swift.Bool, inout Swift.Bool) -> Swift.Void)
  @available(*, unavailable, message: "use nextDate(after:matching:matchingPolicy:repeatedTimePolicy:direction:) instead")
  public func nextDate(after date: Foundation.Date, matching comps: Foundation.DateComponents, options: Foundation.NSCalendar.Options = []) -> Foundation.Date?
  @available(iOS 8.0, *)
  public func nextDate(after date: Foundation.Date, matching components: Foundation.DateComponents, matchingPolicy: Foundation.Calendar.MatchingPolicy, repeatedTimePolicy: Foundation.Calendar.RepeatedTimePolicy = .first, direction: Foundation.Calendar.SearchDirection = .forward) -> Foundation.Date?
  @available(*, unavailable, message: "use nextDate(after:matching:matchingPolicy:repeatedTimePolicy:direction:) instead")
  public func nextDate(after date: Foundation.Date, matchingHour hourValue: Swift.Int, minute minuteValue: Swift.Int, second secondValue: Swift.Int, options: Foundation.NSCalendar.Options = []) -> Foundation.Date?
  @available(*, unavailable, renamed: "date(bySetting:value:of:)")
  public func date(bySettingUnit unit: Foundation.NSCalendar.Unit, value v: Swift.Int, of date: Foundation.Date, options opts: Foundation.NSCalendar.Options = []) -> Foundation.Date?
  @available(iOS 8.0, *)
  public func date(bySetting component: Foundation.Calendar.Component, value: Swift.Int, of date: Foundation.Date) -> Foundation.Date?
  @available(*, unavailable, message: "use date(bySettingHour:minute:second:of:matchingPolicy:repeatedTimePolicy:direction:) instead")
  public func date(bySettingHour h: Swift.Int, minute m: Swift.Int, second s: Swift.Int, of date: Foundation.Date, options opts: Foundation.NSCalendar.Options = []) -> Foundation.Date?
  @available(iOS 8.0, *)
  public func date(bySettingHour hour: Swift.Int, minute: Swift.Int, second: Swift.Int, of date: Foundation.Date, matchingPolicy: Foundation.Calendar.MatchingPolicy = .nextTime, repeatedTimePolicy: Foundation.Calendar.RepeatedTimePolicy = .first, direction: Foundation.Calendar.SearchDirection = .forward) -> Foundation.Date?
  @available(iOS 8.0, *)
  public func date(_ date: Foundation.Date, matchesComponents components: Foundation.DateComponents) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (lhs: Foundation.Calendar, rhs: Foundation.Calendar) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
extension Calendar : Swift.CustomDebugStringConvertible, Swift.CustomStringConvertible, Swift.CustomReflectable {
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
  public var customMirror: Swift.Mirror {
    get
  }
}
extension Calendar : Swift._ObjectiveCBridgeable {
  @_semantics("convertToObjectiveC") public func _bridgeToObjectiveC() -> Foundation.NSCalendar
  public static func _forceBridgeFromObjectiveC(_ input: Foundation.NSCalendar, result: inout Foundation.Calendar?)
  public static func _conditionallyBridgeFromObjectiveC(_ input: Foundation.NSCalendar, result: inout Foundation.Calendar?) -> Swift.Bool
  @_effects(readonly) public static func _unconditionallyBridgeFromObjectiveC(_ source: Foundation.NSCalendar?) -> Foundation.Calendar
  public typealias _ObjectiveCType = Foundation.NSCalendar
}
extension NSCalendar : Swift._HasCustomAnyHashableRepresentation {
  @nonobjc public func _toCustomAnyHashable() -> Swift.AnyHashable?
}
extension Calendar : Swift.Codable {
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
extension String {
  public static var availableStringEncodings: [Swift.String.Encoding] {
    get
  }
  public static var defaultCStringEncoding: Swift.String.Encoding {
    get
  }
  public static func localizedName(of encoding: Swift.String.Encoding) -> Swift.String
  public static func localizedStringWithFormat(_ format: Swift.String, _ arguments: Swift.CVarArg...) -> Swift.String
  public init?(utf8String bytes: Swift.UnsafePointer<Swift.CChar>)
}
extension String {
  public init?<S>(bytes: __shared S, encoding: Swift.String.Encoding) where S : Swift.Sequence, S.Element == Swift.UInt8
  public init?(bytesNoCopy bytes: Swift.UnsafeMutableRawPointer, length: Swift.Int, encoding: Swift.String.Encoding, freeWhenDone flag: Swift.Bool)
  public init(utf16CodeUnits: Swift.UnsafePointer<Foundation.unichar>, count: Swift.Int)
  public init(utf16CodeUnitsNoCopy: Swift.UnsafePointer<Foundation.unichar>, count: Swift.Int, freeWhenDone flag: Swift.Bool)
  public init(contentsOfFile path: __shared Swift.String, encoding enc: Swift.String.Encoding) throws
  public init(contentsOfFile path: __shared Swift.String, usedEncoding: inout Swift.String.Encoding) throws
  public init(contentsOfFile path: __shared Swift.String) throws
  public init(contentsOf url: __shared Foundation.URL, encoding enc: Swift.String.Encoding) throws
  public init(contentsOf url: __shared Foundation.URL, usedEncoding: inout Swift.String.Encoding) throws
  public init(contentsOf url: __shared Foundation.URL) throws
  public init?(cString: Swift.UnsafePointer<Swift.CChar>, encoding enc: Swift.String.Encoding)
  public init?(data: __shared Foundation.Data, encoding: Swift.String.Encoding)
  public init(format: __shared Swift.String, _ arguments: Swift.CVarArg...)
  public init(format: __shared Swift.String, arguments: __shared [Swift.CVarArg])
  public init(format: __shared Swift.String, locale: __shared Foundation.Locale?, _ args: Swift.CVarArg...)
  public init(format: __shared Swift.String, locale: __shared Foundation.Locale?, arguments: __shared [Swift.CVarArg])
}
extension StringProtocol {
  @inlinable internal func _toRelativeNSRange(_ r: Swift.Range<Swift.String.Index>) -> Foundation.NSRange {
    return NSRange(self._toUTF16Offsets(r))
  }
  public func canBeConverted(to encoding: Swift.String.Encoding) -> Swift.Bool
  public var capitalized: Swift.String {
    get
  }
  @available(macOS 10.11, iOS 9.0, *)
  public var localizedCapitalized: Swift.String {
    get
  }
  public func capitalized(with locale: Foundation.Locale?) -> Swift.String
  public func caseInsensitiveCompare<T>(_ aString: T) -> Foundation.ComparisonResult where T : Swift.StringProtocol
  public func commonPrefix<T>(with aString: T, options: Swift.String.CompareOptions = []) -> Swift.String where T : Swift.StringProtocol
  public func compare<T>(_ aString: T, options mask: Swift.String.CompareOptions = [], range: Swift.Range<Self.Index>? = nil, locale: Foundation.Locale? = nil) -> Foundation.ComparisonResult where T : Swift.StringProtocol
  public func completePath(into outputName: Swift.UnsafeMutablePointer<Swift.String>? = nil, caseSensitive: Swift.Bool, matchesInto outputArray: Swift.UnsafeMutablePointer<[Swift.String]>? = nil, filterTypes: [Swift.String]? = nil) -> Swift.Int
  public func components(separatedBy separator: Foundation.CharacterSet) -> [Swift.String]
  public func components<T>(separatedBy separator: T) -> [Swift.String] where T : Swift.StringProtocol
  public func cString(using encoding: Swift.String.Encoding) -> [Swift.CChar]?
  public func data(using encoding: Swift.String.Encoding, allowLossyConversion: Swift.Bool = false) -> Foundation.Data?
  public var decomposedStringWithCanonicalMapping: Swift.String {
    get
  }
  public var decomposedStringWithCompatibilityMapping: Swift.String {
    get
  }
  public func enumerateLines(invoking body: @escaping (Swift.String, inout Swift.Bool) -> Swift.Void)
  public var fastestEncoding: Swift.String.Encoding {
    get
  }
  public func getCString(_ buffer: inout [Swift.CChar], maxLength: Swift.Int, encoding: Swift.String.Encoding) -> Swift.Bool
  public var hash: Swift.Int {
    get
  }
  public func lengthOfBytes(using encoding: Swift.String.Encoding) -> Swift.Int
  public func localizedCaseInsensitiveCompare<T>(_ aString: T) -> Foundation.ComparisonResult where T : Swift.StringProtocol
  public func localizedCompare<T>(_ aString: T) -> Foundation.ComparisonResult where T : Swift.StringProtocol
  public func localizedStandardCompare<T>(_ string: T) -> Foundation.ComparisonResult where T : Swift.StringProtocol
  @available(macOS 10.11, iOS 9.0, *)
  public var localizedLowercase: Swift.String {
    get
  }
  public func lowercased(with locale: Foundation.Locale?) -> Swift.String
  public func maximumLengthOfBytes(using encoding: Swift.String.Encoding) -> Swift.Int
  public var precomposedStringWithCanonicalMapping: Swift.String {
    get
  }
  public var precomposedStringWithCompatibilityMapping: Swift.String {
    get
  }
  public func propertyList() -> Any
  public func propertyListFromStringsFileFormat() -> [Swift.String : Swift.String]
  @available(macOS 10.11, iOS 9.0, *)
  public func localizedStandardContains<T>(_ string: T) -> Swift.Bool where T : Swift.StringProtocol
  public var smallestEncoding: Swift.String.Encoding {
    get
  }
  public func addingPercentEncoding(withAllowedCharacters allowedCharacters: Foundation.CharacterSet) -> Swift.String?
  public func appendingFormat<T>(_ format: T, _ arguments: Swift.CVarArg...) -> Swift.String where T : Swift.StringProtocol
  public func appending<T>(_ aString: T) -> Swift.String where T : Swift.StringProtocol
  public func folding(options: Swift.String.CompareOptions = [], locale: Foundation.Locale?) -> Swift.String
  public func padding<T>(toLength newLength: Swift.Int, withPad padString: T, startingAt padIndex: Swift.Int) -> Swift.String where T : Swift.StringProtocol
  public var removingPercentEncoding: Swift.String? {
    get
  }
  public func replacingCharacters<T, R>(in range: R, with replacement: T) -> Swift.String where T : Swift.StringProtocol, R : Swift.RangeExpression, R.Bound == Swift.String.Index
  public func replacingOccurrences<Target, Replacement>(of target: Target, with replacement: Replacement, options: Swift.String.CompareOptions = [], range searchRange: Swift.Range<Self.Index>? = nil) -> Swift.String where Target : Swift.StringProtocol, Replacement : Swift.StringProtocol
  @available(swift, deprecated: 3.0, obsoleted: 4.0, message: "Use removingPercentEncoding instead, which always uses the recommended UTF-8 encoding.")
  public func replacingPercentEscapes(using encoding: Swift.String.Encoding) -> Swift.String?
  public func trimmingCharacters(in set: Foundation.CharacterSet) -> Swift.String
  @available(macOS 10.11, iOS 9.0, *)
  public var localizedUppercase: Swift.String {
    get
  }
  public func uppercased(with locale: Foundation.Locale?) -> Swift.String
  public func write<T>(toFile path: T, atomically useAuxiliaryFile: Swift.Bool, encoding enc: Swift.String.Encoding) throws where T : Swift.StringProtocol
  public func write(to url: Foundation.URL, atomically useAuxiliaryFile: Swift.Bool, encoding enc: Swift.String.Encoding) throws
  @available(macOS 10.11, iOS 9.0, *)
  public func applyingTransform(_ transform: Foundation.StringTransform, reverse: Swift.Bool) -> Swift.String?
  public func enumerateLinguisticTags<T, R>(in range: R, scheme tagScheme: T, options opts: Foundation.NSLinguisticTagger.Options = [], orthography: Foundation.NSOrthography? = nil, invoking body: (Swift.String, Swift.Range<Self.Index>, Swift.Range<Self.Index>, inout Swift.Bool) -> Swift.Void) where T : Swift.StringProtocol, R : Swift.RangeExpression, R.Bound == Swift.String.Index
  public func enumerateSubstrings<R>(in range: R, options opts: Swift.String.EnumerationOptions = [], _ body: @escaping (Swift.String?, Swift.Range<Self.Index>, Swift.Range<Self.Index>, inout Swift.Bool) -> Swift.Void) where R : Swift.RangeExpression, R.Bound == Swift.String.Index
  public func getBytes<R>(_ buffer: inout [Swift.UInt8], maxLength maxBufferCount: Swift.Int, usedLength usedBufferCount: Swift.UnsafeMutablePointer<Swift.Int>, encoding: Swift.String.Encoding, options: Swift.String.EncodingConversionOptions = [], range: R, remaining leftover: Swift.UnsafeMutablePointer<Swift.Range<Self.Index>>) -> Swift.Bool where R : Swift.RangeExpression, R.Bound == Swift.String.Index
  public func getLineStart<R>(_ start: Swift.UnsafeMutablePointer<Self.Index>, end: Swift.UnsafeMutablePointer<Self.Index>, contentsEnd: Swift.UnsafeMutablePointer<Self.Index>, for range: R) where R : Swift.RangeExpression, R.Bound == Swift.String.Index
  public func getParagraphStart<R>(_ start: Swift.UnsafeMutablePointer<Self.Index>, end: Swift.UnsafeMutablePointer<Self.Index>, contentsEnd: Swift.UnsafeMutablePointer<Self.Index>, for range: R) where R : Swift.RangeExpression, R.Bound == Swift.String.Index
  public func lineRange<R>(for aRange: R) -> Swift.Range<Self.Index> where R : Swift.RangeExpression, R.Bound == Swift.String.Index
  public func linguisticTags<T, R>(in range: R, scheme tagScheme: T, options opts: Foundation.NSLinguisticTagger.Options = [], orthography: Foundation.NSOrthography? = nil, tokenRanges: Swift.UnsafeMutablePointer<[Swift.Range<Self.Index>]>? = nil) -> [Swift.String] where T : Swift.StringProtocol, R : Swift.RangeExpression, R.Bound == Swift.String.Index
  public func paragraphRange<R>(for aRange: R) -> Swift.Range<Self.Index> where R : Swift.RangeExpression, R.Bound == Swift.String.Index
  public func rangeOfCharacter(from aSet: Foundation.CharacterSet, options mask: Swift.String.CompareOptions = [], range aRange: Swift.Range<Self.Index>? = nil) -> Swift.Range<Self.Index>?
  public func rangeOfComposedCharacterSequence(at anIndex: Self.Index) -> Swift.Range<Self.Index>
  public func rangeOfComposedCharacterSequences<R>(for range: R) -> Swift.Range<Self.Index> where R : Swift.RangeExpression, R.Bound == Swift.String.Index
  public func range<T>(of aString: T, options mask: Swift.String.CompareOptions = [], range searchRange: Swift.Range<Self.Index>? = nil, locale: Foundation.Locale? = nil) -> Swift.Range<Self.Index>? where T : Swift.StringProtocol
  @available(macOS 10.11, iOS 9.0, *)
  public func localizedStandardRange<T>(of string: T) -> Swift.Range<Self.Index>? where T : Swift.StringProtocol
  @available(swift, deprecated: 3.0, obsoleted: 4.0, message: "Use addingPercentEncoding(withAllowedCharacters:) instead, which always uses the recommended UTF-8 encoding, and which encodes for a specific URL component or subcomponent since each URL component or subcomponent has different rules for what characters are valid.")
  public func addingPercentEscapes(using encoding: Swift.String.Encoding) -> Swift.String?
  public func contains<T>(_ other: T) -> Swift.Bool where T : Swift.StringProtocol
  public func localizedCaseInsensitiveContains<T>(_ other: T) -> Swift.Bool where T : Swift.StringProtocol
}
extension StringProtocol {
  @available(swift, deprecated: 4.0, message: "Please use String slicing subscript with a 'partial range from' operator.")
  public func substring(from index: Self.Index) -> Swift.String
  @available(swift, deprecated: 4.0, message: "Please use String slicing subscript with a 'partial range upto' operator.")
  public func substring(to index: Self.Index) -> Swift.String
  @available(swift, deprecated: 4.0, message: "Please use String slicing subscript.")
  public func substring(with aRange: Swift.Range<Self.Index>) -> Swift.String
}
extension StringProtocol {
  @available(*, unavailable, message: "Use getFileSystemRepresentation on URL instead.")
  public var fileSystemRepresentation: [Swift.CChar] {
    get
  }
  @available(*, unavailable, message: "Use getFileSystemRepresentation on URL instead.")
  public func getFileSystemRepresentation(_ buffer: inout [Swift.CChar], maxLength: Swift.Int) -> Swift.Bool
  @available(*, unavailable, message: "Use lastPathComponent on URL instead.")
  public var lastPathComponent: Swift.String {
    get
  }
  @available(*, unavailable, message: "Take the count of a UTF-16 view instead, i.e. str.utf16.count")
  public var utf16Count: Swift.Int {
    get
  }
  @available(*, unavailable, message: "Use pathComponents on URL instead.")
  public var pathComponents: [Swift.String] {
    get
  }
  @available(*, unavailable, message: "Use pathExtension on URL instead.")
  public var pathExtension: Swift.String {
    get
  }
  @available(*, unavailable, message: "Use abbreviatingWithTildeInPath on NSString instead.")
  public var abbreviatingWithTildeInPath: Swift.String {
    get
  }
  @available(*, unavailable, message: "Use appendingPathComponent on URL instead.")
  public func appendingPathComponent(_ aString: Swift.String) -> Swift.String
  @available(*, unavailable, message: "Use appendingPathExtension on URL instead.")
  public func appendingPathExtension(_ ext: Swift.String) -> Swift.String?
  @available(*, unavailable, message: "Use deletingLastPathComponent on URL instead.")
  public var deletingLastPathComponent: Swift.String {
    get
  }
  @available(*, unavailable, message: "Use deletingPathExtension on URL instead.")
  public var deletingPathExtension: Swift.String {
    get
  }
  @available(*, unavailable, message: "Use expandingTildeInPath on NSString instead.")
  public var expandingTildeInPath: Swift.String {
    get
  }
  @available(*, unavailable, renamed: "folding(options:locale:)")
  public func folding(_ options: Swift.String.CompareOptions = [], locale: Foundation.Locale?) -> Swift.String
  @available(*, unavailable, message: "Use resolvingSymlinksInPath on URL instead.")
  public var resolvingSymlinksInPath: Swift.String {
    get
  }
  @available(*, unavailable, message: "Use standardizingPath on URL instead.")
  public var standardizingPath: Swift.String {
    get
  }
  @available(*, unavailable, message: "Map over paths with appendingPathComponent instead.")
  public func strings(byAppendingPaths paths: [Swift.String]) -> [Swift.String]
}
extension String {
  @available(*, unavailable, renamed: "localizedName(of:)")
  public static func localizedNameOfStringEncoding(_ encoding: Swift.String.Encoding) -> Swift.String
  @available(*, unavailable, message: "Use fileURL(withPathComponents:) on URL instead.")
  public static func pathWithComponents(_ components: [Swift.String]) -> Swift.String
  @available(*, unavailable, message: "Use fileURL(withPathComponents:) on URL instead.")
  public static func path(withComponents components: [Swift.String]) -> Swift.String
}
extension StringProtocol {
  @available(*, unavailable, renamed: "canBeConverted(to:)")
  public func canBeConvertedToEncoding(_ encoding: Swift.String.Encoding) -> Swift.Bool
  @available(*, unavailable, renamed: "capitalizedString(with:)")
  public func capitalizedStringWith(_ locale: Foundation.Locale?) -> Swift.String
  @available(*, unavailable, renamed: "commonPrefix(with:options:)")
  public func commonPrefixWith(_ aString: Swift.String, options: Swift.String.CompareOptions) -> Swift.String
  @available(*, unavailable, renamed: "completePath(into:outputName:caseSensitive:matchesInto:filterTypes:)")
  public func completePathInto(_ outputName: Swift.UnsafeMutablePointer<Swift.String>? = nil, caseSensitive: Swift.Bool, matchesInto matchesIntoArray: Swift.UnsafeMutablePointer<[Swift.String]>? = nil, filterTypes: [Swift.String]? = nil) -> Swift.Int
  @available(*, unavailable, renamed: "components(separatedBy:)")
  public func componentsSeparatedByCharactersIn(_ separator: Foundation.CharacterSet) -> [Swift.String]
  @available(*, unavailable, renamed: "components(separatedBy:)")
  public func componentsSeparatedBy(_ separator: Swift.String) -> [Swift.String]
  @available(*, unavailable, renamed: "cString(usingEncoding:)")
  public func cStringUsingEncoding(_ encoding: Swift.String.Encoding) -> [Swift.CChar]?
  @available(*, unavailable, renamed: "data(usingEncoding:allowLossyConversion:)")
  public func dataUsingEncoding(_ encoding: Swift.String.Encoding, allowLossyConversion: Swift.Bool = false) -> Foundation.Data?
  @available(*, unavailable, renamed: "enumerateLinguisticTags(in:scheme:options:orthography:_:)")
  public func enumerateLinguisticTagsIn(_ range: Swift.Range<Self.Index>, scheme tagScheme: Swift.String, options opts: Foundation.NSLinguisticTagger.Options, orthography: Foundation.NSOrthography?, _ body: (Swift.String, Swift.Range<Self.Index>, Swift.Range<Self.Index>, inout Swift.Bool) -> Swift.Void)
  @available(*, unavailable, renamed: "enumerateSubstrings(in:options:_:)")
  public func enumerateSubstringsIn(_ range: Swift.Range<Self.Index>, options opts: Swift.String.EnumerationOptions = [], _ body: (Swift.String?, Swift.Range<Self.Index>, Swift.Range<Self.Index>, inout Swift.Bool) -> Swift.Void)
  @available(*, unavailable, renamed: "getBytes(_:maxLength:usedLength:encoding:options:range:remaining:)")
  public func getBytes(_ buffer: inout [Swift.UInt8], maxLength maxBufferCount: Swift.Int, usedLength usedBufferCount: Swift.UnsafeMutablePointer<Swift.Int>, encoding: Swift.String.Encoding, options: Swift.String.EncodingConversionOptions = [], range: Swift.Range<Self.Index>, remainingRange leftover: Swift.UnsafeMutablePointer<Swift.Range<Self.Index>>) -> Swift.Bool
  @available(*, unavailable, renamed: "getLineStart(_:end:contentsEnd:for:)")
  public func getLineStart(_ start: Swift.UnsafeMutablePointer<Self.Index>, end: Swift.UnsafeMutablePointer<Self.Index>, contentsEnd: Swift.UnsafeMutablePointer<Self.Index>, forRange: Swift.Range<Self.Index>)
  @available(*, unavailable, renamed: "getParagraphStart(_:end:contentsEnd:for:)")
  public func getParagraphStart(_ start: Swift.UnsafeMutablePointer<Self.Index>, end: Swift.UnsafeMutablePointer<Self.Index>, contentsEnd: Swift.UnsafeMutablePointer<Self.Index>, forRange: Swift.Range<Self.Index>)
  @available(*, unavailable, renamed: "lengthOfBytes(using:)")
  public func lengthOfBytesUsingEncoding(_ encoding: Swift.String.Encoding) -> Swift.Int
  @available(*, unavailable, renamed: "lineRange(for:)")
  public func lineRangeFor(_ aRange: Swift.Range<Self.Index>) -> Swift.Range<Self.Index>
  @available(*, unavailable, renamed: "linguisticTags(in:scheme:options:orthography:tokenRanges:)")
  public func linguisticTagsIn(_ range: Swift.Range<Self.Index>, scheme tagScheme: Swift.String, options opts: Foundation.NSLinguisticTagger.Options = [], orthography: Foundation.NSOrthography? = nil, tokenRanges: Swift.UnsafeMutablePointer<[Swift.Range<Self.Index>]>? = nil) -> [Swift.String]
  @available(*, unavailable, renamed: "lowercased(with:)")
  public func lowercaseStringWith(_ locale: Foundation.Locale?) -> Swift.String
  @available(*, unavailable, renamed: "maximumLengthOfBytes(using:)")
  public func maximumLengthOfBytesUsingEncoding(_ encoding: Swift.String.Encoding) -> Swift.Int
  @available(*, unavailable, renamed: "paragraphRange(for:)")
  public func paragraphRangeFor(_ aRange: Swift.Range<Self.Index>) -> Swift.Range<Self.Index>
  @available(*, unavailable, renamed: "rangeOfCharacter(from:options:range:)")
  public func rangeOfCharacterFrom(_ aSet: Foundation.CharacterSet, options mask: Swift.String.CompareOptions = [], range aRange: Swift.Range<Self.Index>? = nil) -> Swift.Range<Self.Index>?
  @available(*, unavailable, renamed: "rangeOfComposedCharacterSequence(at:)")
  public func rangeOfComposedCharacterSequenceAt(_ anIndex: Self.Index) -> Swift.Range<Self.Index>
  @available(*, unavailable, renamed: "rangeOfComposedCharacterSequences(for:)")
  public func rangeOfComposedCharacterSequencesFor(_ range: Swift.Range<Self.Index>) -> Swift.Range<Self.Index>
  @available(*, unavailable, renamed: "range(of:options:range:locale:)")
  public func rangeOf(_ aString: Swift.String, options mask: Swift.String.CompareOptions = [], range searchRange: Swift.Range<Self.Index>? = nil, locale: Foundation.Locale? = nil) -> Swift.Range<Self.Index>?
  @available(*, unavailable, renamed: "localizedStandardRange(of:)")
  public func localizedStandardRangeOf(_ string: Swift.String) -> Swift.Range<Self.Index>?
  @available(*, unavailable, renamed: "addingPercentEncoding(withAllowedCharacters:)")
  public func addingPercentEncodingWithAllowedCharacters(_ allowedCharacters: Foundation.CharacterSet) -> Swift.String?
  @available(*, unavailable, renamed: "addingPercentEscapes(using:)")
  public func addingPercentEscapesUsingEncoding(_ encoding: Swift.String.Encoding) -> Swift.String?
  @available(*, unavailable, renamed: "appendingFormat")
  public func stringByAppendingFormat(_ format: Swift.String, _ arguments: Swift.CVarArg...) -> Swift.String
  @available(*, unavailable, renamed: "padding(toLength:with:startingAt:)")
  public func byPaddingToLength(_ newLength: Swift.Int, withString padString: Swift.String, startingAt padIndex: Swift.Int) -> Swift.String
  @available(*, unavailable, renamed: "replacingCharacters(in:with:)")
  public func replacingCharactersIn(_ range: Swift.Range<Self.Index>, withString replacement: Swift.String) -> Swift.String
  @available(*, unavailable, renamed: "replacingOccurrences(of:with:options:range:)")
  public func replacingOccurrencesOf(_ target: Swift.String, withString replacement: Swift.String, options: Swift.String.CompareOptions = [], range searchRange: Swift.Range<Self.Index>? = nil) -> Swift.String
  @available(*, unavailable, renamed: "replacingPercentEscapes(usingEncoding:)")
  public func replacingPercentEscapesUsingEncoding(_ encoding: Swift.String.Encoding) -> Swift.String?
  @available(*, unavailable, renamed: "trimmingCharacters(in:)")
  public func byTrimmingCharactersIn(_ set: Foundation.CharacterSet) -> Swift.String
  @available(*, unavailable, renamed: "strings(byAppendingPaths:)")
  public func stringsByAppendingPaths(_ paths: [Swift.String]) -> [Swift.String]
  @available(*, unavailable, renamed: "substring(from:)")
  public func substringFrom(_ index: Self.Index) -> Swift.String
  @available(*, unavailable, renamed: "substring(to:)")
  public func substringTo(_ index: Self.Index) -> Swift.String
  @available(*, unavailable, renamed: "substring(with:)")
  public func substringWith(_ aRange: Swift.Range<Self.Index>) -> Swift.String
  @available(*, unavailable, renamed: "uppercased(with:)")
  public func uppercaseStringWith(_ locale: Foundation.Locale?) -> Swift.String
  @available(*, unavailable, renamed: "write(toFile:atomically:encoding:)")
  public func writeToFile(_ path: Swift.String, atomically useAuxiliaryFile: Swift.Bool, encoding enc: Swift.String.Encoding) throws
  @available(*, unavailable, renamed: "write(to:atomically:encoding:)")
  public func writeToURL(_ url: Foundation.URL, atomically useAuxiliaryFile: Swift.Bool, encoding enc: Swift.String.Encoding) throws
}
extension NSSet : Swift.Sequence {
  public func makeIterator() -> Foundation.NSFastEnumerationIterator
  public typealias Element = Any
  public typealias Iterator = Foundation.NSFastEnumerationIterator
}
extension NSOrderedSet : Swift.Sequence {
  public func makeIterator() -> Foundation.NSFastEnumerationIterator
  public typealias Element = Any
  public typealias Iterator = Foundation.NSFastEnumerationIterator
}
extension Set : Swift._ObjectiveCBridgeable {
  @_semantics("convertToObjectiveC") public func _bridgeToObjectiveC() -> Foundation.NSSet
  public static func _forceBridgeFromObjectiveC(_ s: Foundation.NSSet, result: inout Swift.Set<Element>?)
  public static func _conditionallyBridgeFromObjectiveC(_ x: Foundation.NSSet, result: inout Swift.Set<Element>?) -> Swift.Bool
  @_effects(readonly) public static func _unconditionallyBridgeFromObjectiveC(_ s: Foundation.NSSet?) -> Swift.Set<Element>
  public typealias _ObjectiveCType = Foundation.NSSet
}
extension NSSet : Swift._HasCustomAnyHashableRepresentation {
  @nonobjc public func _toCustomAnyHashable() -> Swift.AnyHashable?
}
extension NSOrderedSet {
  convenience public init(objects elements: Any...)
}
extension NSSet {
  convenience public init(objects elements: Any...)
}
extension NSSet : Swift.ExpressibleByArrayLiteral {
  required convenience public init(arrayLiteral elements: Any...)
  public typealias ArrayLiteralElement = Any
}
extension NSOrderedSet : Swift.ExpressibleByArrayLiteral {
  required convenience public init(arrayLiteral elements: Any...)
  public typealias ArrayLiteralElement = Any
}
extension NSSet {
  @nonobjc convenience public init(set anSet: __shared Foundation.NSSet)
}
extension NSSet : Swift.CustomReflectable {
  public var customMirror: Swift.Mirror {
    get
  }
}
extension Set : Swift.CVarArg {
}
@available(*, deprecated, message: "Please use the struct type URLRequest")
public typealias MutableURLRequest = Foundation.NSMutableURLRequest
public struct URLRequest : Foundation.ReferenceConvertible, Swift.Equatable, Swift.Hashable {
  public typealias ReferenceType = Foundation.NSURLRequest
  public typealias CachePolicy = Foundation.NSURLRequest.CachePolicy
  public typealias NetworkServiceType = Foundation.NSURLRequest.NetworkServiceType
  public init(url: Foundation.URL, cachePolicy: Foundation.URLRequest.CachePolicy = .useProtocolCachePolicy, timeoutInterval: Foundation.TimeInterval = 60.0)
  public var url: Foundation.URL? {
    get
    set
  }
  public var cachePolicy: Foundation.URLRequest.CachePolicy {
    get
    set
  }
  public var timeoutInterval: Foundation.TimeInterval {
    get
    set
  }
  public var mainDocumentURL: Foundation.URL? {
    get
    set
  }
  @available(macOS 10.7, iOS 4.0, *)
  public var networkServiceType: Foundation.URLRequest.NetworkServiceType {
    get
    set
  }
  @available(macOS 10.8, iOS 6.0, *)
  public var allowsCellularAccess: Swift.Bool {
    get
    set
  }
  @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
  public var allowsExpensiveNetworkAccess: Swift.Bool {
    get
    set
  }
  @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
  public var allowsConstrainedNetworkAccess: Swift.Bool {
    get
    set
  }
  @available(macOS 11.3, iOS 14.5, watchOS 7.4, tvOS 14.5, *)
  public var assumesHTTP3Capable: Swift.Bool {
    get
    set
  }
  public var httpMethod: Swift.String? {
    get
    set
  }
  public var allHTTPHeaderFields: [Swift.String : Swift.String]? {
    get
    set
  }
  public func value(forHTTPHeaderField field: Swift.String) -> Swift.String?
  public mutating func setValue(_ value: Swift.String?, forHTTPHeaderField field: Swift.String)
  public mutating func addValue(_ value: Swift.String, forHTTPHeaderField field: Swift.String)
  public var httpBody: Foundation.Data? {
    get
    set
  }
  public var httpBodyStream: Foundation.InputStream? {
    get
    set
  }
  public var httpShouldHandleCookies: Swift.Bool {
    get
    set
  }
  @available(macOS 10.7, iOS 4.0, *)
  public var httpShouldUsePipelining: Swift.Bool {
    get
    set
  }
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (lhs: Foundation.URLRequest, rhs: Foundation.URLRequest) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
extension URLRequest : Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible, Swift.CustomReflectable {
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
  public var customMirror: Swift.Mirror {
    get
  }
}
extension URLRequest : Swift._ObjectiveCBridgeable {
  public static func _getObjectiveCType() -> Any.Type
  @_semantics("convertToObjectiveC") public func _bridgeToObjectiveC() -> Foundation.NSURLRequest
  public static func _forceBridgeFromObjectiveC(_ input: Foundation.NSURLRequest, result: inout Foundation.URLRequest?)
  public static func _conditionallyBridgeFromObjectiveC(_ input: Foundation.NSURLRequest, result: inout Foundation.URLRequest?) -> Swift.Bool
  @_effects(readonly) public static func _unconditionallyBridgeFromObjectiveC(_ source: Foundation.NSURLRequest?) -> Foundation.URLRequest
  public typealias _ObjectiveCType = Foundation.NSURLRequest
}
extension NSURLRequest : Swift._HasCustomAnyHashableRepresentation {
  @nonobjc public func _toCustomAnyHashable() -> Swift.AnyHashable?
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension RunLoop : Combine.Scheduler {
  public struct SchedulerTimeType : Swift.Strideable, Swift.Codable, Swift.Hashable {
    public var date: Foundation.Date
    public init(_ date: Foundation.Date)
    public func distance(to other: Foundation.RunLoop.SchedulerTimeType) -> Foundation.RunLoop.SchedulerTimeType.Stride
    public func advanced(by n: Foundation.RunLoop.SchedulerTimeType.Stride) -> Foundation.RunLoop.SchedulerTimeType
    public struct Stride : Swift.ExpressibleByFloatLiteral, Swift.Comparable, Swift.SignedNumeric, Swift.Codable, Combine.SchedulerTimeIntervalConvertible {
      public typealias FloatLiteralType = Foundation.TimeInterval
      public typealias IntegerLiteralType = Foundation.TimeInterval
      public typealias Magnitude = Foundation.TimeInterval
      public var magnitude: Foundation.TimeInterval
      public var timeInterval: Foundation.TimeInterval {
        get
      }
      public init(integerLiteral value: Foundation.TimeInterval)
      public init(floatLiteral value: Foundation.TimeInterval)
      public init(_ timeInterval: Foundation.TimeInterval)
      public init?<T>(exactly source: T) where T : Swift.BinaryInteger
      public static func < (lhs: Foundation.RunLoop.SchedulerTimeType.Stride, rhs: Foundation.RunLoop.SchedulerTimeType.Stride) -> Swift.Bool
      public static func * (lhs: Foundation.RunLoop.SchedulerTimeType.Stride, rhs: Foundation.RunLoop.SchedulerTimeType.Stride) -> Foundation.RunLoop.SchedulerTimeType.Stride
      public static func + (lhs: Foundation.RunLoop.SchedulerTimeType.Stride, rhs: Foundation.RunLoop.SchedulerTimeType.Stride) -> Foundation.RunLoop.SchedulerTimeType.Stride
      public static func - (lhs: Foundation.RunLoop.SchedulerTimeType.Stride, rhs: Foundation.RunLoop.SchedulerTimeType.Stride) -> Foundation.RunLoop.SchedulerTimeType.Stride
      public static func *= (lhs: inout Foundation.RunLoop.SchedulerTimeType.Stride, rhs: Foundation.RunLoop.SchedulerTimeType.Stride)
      public static func += (lhs: inout Foundation.RunLoop.SchedulerTimeType.Stride, rhs: Foundation.RunLoop.SchedulerTimeType.Stride)
      public static func -= (lhs: inout Foundation.RunLoop.SchedulerTimeType.Stride, rhs: Foundation.RunLoop.SchedulerTimeType.Stride)
      public static func seconds(_ s: Swift.Int) -> Foundation.RunLoop.SchedulerTimeType.Stride
      public static func seconds(_ s: Swift.Double) -> Foundation.RunLoop.SchedulerTimeType.Stride
      public static func milliseconds(_ ms: Swift.Int) -> Foundation.RunLoop.SchedulerTimeType.Stride
      public static func microseconds(_ us: Swift.Int) -> Foundation.RunLoop.SchedulerTimeType.Stride
      public static func nanoseconds(_ ns: Swift.Int) -> Foundation.RunLoop.SchedulerTimeType.Stride
      public static func == (a: Foundation.RunLoop.SchedulerTimeType.Stride, b: Foundation.RunLoop.SchedulerTimeType.Stride) -> Swift.Bool
      public func encode(to encoder: Swift.Encoder) throws
      public init(from decoder: Swift.Decoder) throws
    }
    public func hash(into hasher: inout Swift.Hasher)
    public func encode(to encoder: Swift.Encoder) throws
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: Swift.Decoder) throws
  }
  public struct SchedulerOptions {
  }
  public func schedule(options: Foundation.RunLoop.SchedulerOptions?, _ action: @escaping () -> Swift.Void)
  public func schedule(after date: Foundation.RunLoop.SchedulerTimeType, tolerance: Foundation.RunLoop.SchedulerTimeType.Stride, options: Foundation.RunLoop.SchedulerOptions?, _ action: @escaping () -> Swift.Void)
  public func schedule(after date: Foundation.RunLoop.SchedulerTimeType, interval: Foundation.RunLoop.SchedulerTimeType.Stride, tolerance: Foundation.RunLoop.SchedulerTimeType.Stride, options: Foundation.RunLoop.SchedulerOptions?, _ action: @escaping () -> Swift.Void) -> Combine.Cancellable
  public var now: Foundation.RunLoop.SchedulerTimeType {
    get
  }
  public var minimumTolerance: Foundation.RunLoop.SchedulerTimeType.Stride {
    get
  }
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension Foundation.Scanner.NumberRepresentation : Swift.Equatable {}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension Foundation.Scanner.NumberRepresentation : Swift.Hashable {}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension Foundation.URLError.BackgroundTaskCancelledReason : Swift.Equatable {}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension Foundation.URLError.BackgroundTaskCancelledReason : Swift.Hashable {}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension Foundation.URLError.BackgroundTaskCancelledReason : Swift.RawRepresentable {}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension Foundation.URLError.NetworkUnavailableReason : Swift.Equatable {}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension Foundation.URLError.NetworkUnavailableReason : Swift.Hashable {}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension Foundation.URLError.NetworkUnavailableReason : Swift.RawRepresentable {}
extension Foundation.Calendar.Identifier : Swift.Equatable {}
extension Foundation.Calendar.Identifier : Swift.Hashable {}
extension Foundation.Calendar.Component : Swift.Equatable {}
extension Foundation.Calendar.Component : Swift.Hashable {}
extension Foundation.Calendar.SearchDirection : Swift.Equatable {}
extension Foundation.Calendar.SearchDirection : Swift.Hashable {}
extension Foundation.Calendar.RepeatedTimePolicy : Swift.Equatable {}
extension Foundation.Calendar.RepeatedTimePolicy : Swift.Hashable {}
extension Foundation.Calendar.MatchingPolicy : Swift.Equatable {}
extension Foundation.Calendar.MatchingPolicy : Swift.Hashable {}
