// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 5.4 (swiftlang-1205.0.24.14 clang-1205.0.19.54)
// swift-module-flags: -target arm64e-apple-macos11.3 -enable-objc-interop -enable-library-evolution -module-link-name swiftSystem -swift-version 5 -enforce-exclusivity=checked -O -module-name System
import Swift
@available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
public typealias CModeT = Swift.UInt16
@available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
@frozen public struct FilePermissions : Swift.OptionSet, Swift.Hashable, Swift.Codable {
  @_alwaysEmitIntoClient public let rawValue: System.CModeT
  @_alwaysEmitIntoClient public init(rawValue: System.CModeT) { self.rawValue = rawValue }
  @_alwaysEmitIntoClient private init(_ raw: System.CModeT) { self.init(rawValue: raw) }
  @_alwaysEmitIntoClient public static var otherRead: System.FilePermissions {
    get { FilePermissions(0o4) }
  }
  @_alwaysEmitIntoClient public static var otherWrite: System.FilePermissions {
    get { FilePermissions(0o2) }
  }
  @_alwaysEmitIntoClient public static var otherExecute: System.FilePermissions {
    get { FilePermissions(0o1) }
  }
  @_alwaysEmitIntoClient public static var otherReadWrite: System.FilePermissions {
    get { FilePermissions(0o6) }
  }
  @_alwaysEmitIntoClient public static var otherReadExecute: System.FilePermissions {
    get { FilePermissions(0o5) }
  }
  @_alwaysEmitIntoClient public static var otherWriteExecute: System.FilePermissions {
    get { FilePermissions(0o3) }
  }
  @_alwaysEmitIntoClient public static var otherReadWriteExecute: System.FilePermissions {
    get { FilePermissions(0o7) }
  }
  @_alwaysEmitIntoClient public static var groupRead: System.FilePermissions {
    get { FilePermissions(0o40) }
  }
  @_alwaysEmitIntoClient public static var groupWrite: System.FilePermissions {
    get { FilePermissions(0o20) }
  }
  @_alwaysEmitIntoClient public static var groupExecute: System.FilePermissions {
    get { FilePermissions(0o10) }
  }
  @_alwaysEmitIntoClient public static var groupReadWrite: System.FilePermissions {
    get { FilePermissions(0o60) }
  }
  @_alwaysEmitIntoClient public static var groupReadExecute: System.FilePermissions {
    get { FilePermissions(0o50) }
  }
  @_alwaysEmitIntoClient public static var groupWriteExecute: System.FilePermissions {
    get { FilePermissions(0o30) }
  }
  @_alwaysEmitIntoClient public static var groupReadWriteExecute: System.FilePermissions {
    get { FilePermissions(0o70) }
  }
  @_alwaysEmitIntoClient public static var ownerRead: System.FilePermissions {
    get { FilePermissions(0o400) }
  }
  @_alwaysEmitIntoClient public static var ownerWrite: System.FilePermissions {
    get { FilePermissions(0o200) }
  }
  @_alwaysEmitIntoClient public static var ownerExecute: System.FilePermissions {
    get { FilePermissions(0o100) }
  }
  @_alwaysEmitIntoClient public static var ownerReadWrite: System.FilePermissions {
    get { FilePermissions(0o600) }
  }
  @_alwaysEmitIntoClient public static var ownerReadExecute: System.FilePermissions {
    get { FilePermissions(0o500) }
  }
  @_alwaysEmitIntoClient public static var ownerWriteExecute: System.FilePermissions {
    get { FilePermissions(0o300) }
  }
  @_alwaysEmitIntoClient public static var ownerReadWriteExecute: System.FilePermissions {
    get { FilePermissions(0o700) }
  }
  @_alwaysEmitIntoClient public static var setUserID: System.FilePermissions {
    get { FilePermissions(0o4000) }
  }
  @_alwaysEmitIntoClient public static var setGroupID: System.FilePermissions {
    get { FilePermissions(0o2000) }
  }
  @_alwaysEmitIntoClient public static var saveText: System.FilePermissions {
    get { FilePermissions(0o1000) }
  }
  public typealias ArrayLiteralElement = System.FilePermissions
  public typealias Element = System.FilePermissions
  public typealias RawValue = System.CModeT
}
@available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
extension FilePermissions : Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible {
  @inline(never) public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
}
@available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
extension FileDescriptor {
  @_alwaysEmitIntoClient public static func open(_ path: System.FilePath, _ mode: System.FileDescriptor.AccessMode, options: System.FileDescriptor.OpenOptions = FileDescriptor.OpenOptions(), permissions: System.FilePermissions? = nil, retryOnInterrupt: Swift.Bool = true) throws -> System.FileDescriptor {
    try path.withCString {
      try FileDescriptor.open(
        $0, mode, options: options, permissions: permissions, retryOnInterrupt: retryOnInterrupt)
    }
  }
  @_alwaysEmitIntoClient public static func open(_ path: Swift.UnsafePointer<Swift.CChar>, _ mode: System.FileDescriptor.AccessMode, options: System.FileDescriptor.OpenOptions = FileDescriptor.OpenOptions(), permissions: System.FilePermissions? = nil, retryOnInterrupt: Swift.Bool = true) throws -> System.FileDescriptor {
    try FileDescriptor._open(
      path, mode, options: options, permissions: permissions, retryOnInterrupt: retryOnInterrupt
    ).get()
  }
  @usableFromInline
  internal static func _open(_ path: Swift.UnsafePointer<Swift.CChar>, _ mode: System.FileDescriptor.AccessMode, options: System.FileDescriptor.OpenOptions, permissions: System.FilePermissions?, retryOnInterrupt: Swift.Bool = true) -> Swift.Result<System.FileDescriptor, System.Errno>
  @_alwaysEmitIntoClient public func close() throws { try _close().get() }
  @usableFromInline
  internal func _close() -> Swift.Result<(), System.Errno>
  @discardableResult
  @_alwaysEmitIntoClient public func seek(offset: Swift.Int64, from whence: System.FileDescriptor.SeekOrigin) throws -> Swift.Int64 {
    try _seek(offset: offset, from: whence).get()
  }
  @usableFromInline
  internal func _seek(offset: Swift.Int64, from whence: System.FileDescriptor.SeekOrigin) -> Swift.Result<Swift.Int64, System.Errno>
  @available(*, unavailable, renamed: "seek")
  @_alwaysEmitIntoClient public func lseek(offset: Swift.Int64, from whence: System.FileDescriptor.SeekOrigin) throws -> Swift.Int64 {
    try seek(offset: offset, from: whence)
  }
  @_alwaysEmitIntoClient public func read(into buffer: Swift.UnsafeMutableRawBufferPointer, retryOnInterrupt: Swift.Bool = true) throws -> Swift.Int {
    try _read(into: buffer, retryOnInterrupt: retryOnInterrupt).get()
  }
  @usableFromInline
  internal func _read(into buffer: Swift.UnsafeMutableRawBufferPointer, retryOnInterrupt: Swift.Bool = true) throws -> Swift.Result<Swift.Int, System.Errno>
  @_alwaysEmitIntoClient public func read(fromAbsoluteOffset offset: Swift.Int64, into buffer: Swift.UnsafeMutableRawBufferPointer, retryOnInterrupt: Swift.Bool = true) throws -> Swift.Int {
    try _read(
      fromAbsoluteOffset: offset,
      into: buffer,
      retryOnInterrupt: retryOnInterrupt
    ).get()
  }
  @usableFromInline
  internal func _read(fromAbsoluteOffset offset: Swift.Int64, into buffer: Swift.UnsafeMutableRawBufferPointer, retryOnInterrupt: Swift.Bool) -> Swift.Result<Swift.Int, System.Errno>
  @available(*, unavailable, renamed: "read")
  @_alwaysEmitIntoClient public func pread(fromAbsoluteOffset offset: Swift.Int64, into buffer: Swift.UnsafeMutableRawBufferPointer, retryOnInterrupt: Swift.Bool = true) throws -> Swift.Int {
    try read(
      fromAbsoluteOffset: offset,
      into: buffer,
      retryOnInterrupt: retryOnInterrupt)
  }
  @_alwaysEmitIntoClient public func write(_ buffer: Swift.UnsafeRawBufferPointer, retryOnInterrupt: Swift.Bool = true) throws -> Swift.Int {
    try _write(buffer, retryOnInterrupt: retryOnInterrupt).get()
  }
  @usableFromInline
  internal func _write(_ buffer: Swift.UnsafeRawBufferPointer, retryOnInterrupt: Swift.Bool) -> Swift.Result<Swift.Int, System.Errno>
  @_alwaysEmitIntoClient public func write(toAbsoluteOffset offset: Swift.Int64, _ buffer: Swift.UnsafeRawBufferPointer, retryOnInterrupt: Swift.Bool = true) throws -> Swift.Int {
    try _write(toAbsoluteOffset: offset, buffer, retryOnInterrupt: retryOnInterrupt).get()
  }
  @usableFromInline
  internal func _write(toAbsoluteOffset offset: Swift.Int64, _ buffer: Swift.UnsafeRawBufferPointer, retryOnInterrupt: Swift.Bool) -> Swift.Result<Swift.Int, System.Errno>
  @available(*, unavailable, renamed: "write")
  @_alwaysEmitIntoClient public func pwrite(toAbsoluteOffset offset: Swift.Int64, into buffer: Swift.UnsafeRawBufferPointer, retryOnInterrupt: Swift.Bool = true) throws -> Swift.Int {
    try write(
      toAbsoluteOffset: offset,
      buffer,
      retryOnInterrupt: retryOnInterrupt)
  }
}
@available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
public struct FilePath {
  public init()
}
@available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
extension FilePath {
  public var length: Swift.Int {
    get
  }
}
@available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
extension FilePath {
  public init(cString: Swift.UnsafePointer<Swift.CChar>)
  public func withCString<Result>(_ body: (Swift.UnsafePointer<Swift.Int8>) throws -> Result) rethrows -> Result
}
@available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
extension FilePath : Swift.ExpressibleByStringLiteral {
  public init(stringLiteral: Swift.String)
  public init(_ string: Swift.String)
  public typealias ExtendedGraphemeClusterLiteralType = Swift.String
  public typealias StringLiteralType = Swift.String
  public typealias UnicodeScalarLiteralType = Swift.String
}
@available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
extension String {
  public init(decoding path: System.FilePath)
  @available(*, deprecated, renamed: "String.init(decoding:)")
  public init(_ path: System.FilePath)
  public init?(validatingUTF8 path: System.FilePath)
}
@available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
extension FilePath : Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible {
  @inline(never) public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
}
@available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
extension FilePath : Swift.Hashable, Swift.Codable {
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: System.FilePath, b: System.FilePath) -> Swift.Bool
  public func encode(to encoder: Swift.Encoder) throws
  public var hashValue: Swift.Int {
    get
  }
  public init(from decoder: Swift.Decoder) throws
}
@available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
@frozen public struct Errno : Swift.RawRepresentable, Swift.Error, Swift.Hashable, Swift.Codable {
  @_alwaysEmitIntoClient public let rawValue: Swift.CInt
  @_alwaysEmitIntoClient public init(rawValue: Swift.CInt) { self.rawValue = rawValue }
  @_alwaysEmitIntoClient private init(_ raw: Swift.CInt) { self.init(rawValue: raw) }
  @_alwaysEmitIntoClient public static var notUsed: System.Errno {
    get { Errno(_ERRNO_NOT_USED) }
  }
  @available(*, unavailable, renamed: "notUsed")
  @_alwaysEmitIntoClient public static var ERRNO_NOT_USED: System.Errno {
    get { notUsed }
  }
  @_alwaysEmitIntoClient public static var notPermitted: System.Errno {
    get { Errno(_EPERM) }
  }
  @available(*, unavailable, renamed: "notPermitted")
  @_alwaysEmitIntoClient public static var EPERM: System.Errno {
    get { notPermitted }
  }
  @_alwaysEmitIntoClient public static var noSuchFileOrDirectory: System.Errno {
    get { Errno(_ENOENT) }
  }
  @available(*, unavailable, renamed: "noSuchFileOrDirectory")
  @_alwaysEmitIntoClient public static var ENOENT: System.Errno {
    get { noSuchFileOrDirectory }
  }
  @_alwaysEmitIntoClient public static var noSuchProcess: System.Errno {
    get { Errno(_ESRCH) }
  }
  @available(*, unavailable, renamed: "noSuchProcess")
  @_alwaysEmitIntoClient public static var ESRCH: System.Errno {
    get { noSuchProcess }
  }
  @_alwaysEmitIntoClient public static var interrupted: System.Errno {
    get { Errno(_EINTR) }
  }
  @available(*, unavailable, renamed: "interrupted")
  @_alwaysEmitIntoClient public static var EINTR: System.Errno {
    get { interrupted }
  }
  @_alwaysEmitIntoClient public static var ioError: System.Errno {
    get { Errno(_EIO) }
  }
  @available(*, unavailable, renamed: "ioError")
  @_alwaysEmitIntoClient public static var EIO: System.Errno {
    get { ioError }
  }
  @_alwaysEmitIntoClient public static var noSuchAddressOrDevice: System.Errno {
    get { Errno(_ENXIO) }
  }
  @available(*, unavailable, renamed: "noSuchAddressOrDevice")
  @_alwaysEmitIntoClient public static var ENXIO: System.Errno {
    get { noSuchAddressOrDevice }
  }
  @_alwaysEmitIntoClient public static var argListTooLong: System.Errno {
    get { Errno(_E2BIG) }
  }
  @available(*, unavailable, renamed: "argListTooLong")
  @_alwaysEmitIntoClient public static var E2BIG: System.Errno {
    get { argListTooLong }
  }
  @_alwaysEmitIntoClient public static var execFormatError: System.Errno {
    get { Errno(_ENOEXEC) }
  }
  @available(*, unavailable, renamed: "noExec")
  @_alwaysEmitIntoClient public static var ENOEXEC: System.Errno {
    get { execFormatError }
  }
  @_alwaysEmitIntoClient public static var badFileDescriptor: System.Errno {
    get { Errno(_EBADF) }
  }
  @available(*, unavailable, renamed: "badFileDescriptor")
  @_alwaysEmitIntoClient public static var EBADF: System.Errno {
    get { badFileDescriptor }
  }
  @_alwaysEmitIntoClient public static var noChildProcess: System.Errno {
    get { Errno(_ECHILD) }
  }
  @available(*, unavailable, renamed: "noChildProcess")
  @_alwaysEmitIntoClient public static var ECHILD: System.Errno {
    get { noChildProcess }
  }
  @_alwaysEmitIntoClient public static var deadlock: System.Errno {
    get { Errno(_EDEADLK) }
  }
  @available(*, unavailable, renamed: "deadlock")
  @_alwaysEmitIntoClient public static var EDEADLK: System.Errno {
    get { deadlock }
  }
  @_alwaysEmitIntoClient public static var noMemory: System.Errno {
    get { Errno(_ENOMEM) }
  }
  @available(*, unavailable, renamed: "noMemory")
  @_alwaysEmitIntoClient public static var ENOMEM: System.Errno {
    get { noMemory }
  }
  @_alwaysEmitIntoClient public static var permissionDenied: System.Errno {
    get { Errno(_EACCES) }
  }
  @available(*, unavailable, renamed: "permissionDenied")
  @_alwaysEmitIntoClient public static var EACCES: System.Errno {
    get { permissionDenied }
  }
  @_alwaysEmitIntoClient public static var badAddress: System.Errno {
    get { Errno(_EFAULT) }
  }
  @available(*, unavailable, renamed: "badAddress")
  @_alwaysEmitIntoClient public static var EFAULT: System.Errno {
    get { badAddress }
  }
  @_alwaysEmitIntoClient public static var notBlockDevice: System.Errno {
    get { Errno(_ENOTBLK) }
  }
  @available(*, unavailable, renamed: "notBlockDevice")
  @_alwaysEmitIntoClient public static var ENOTBLK: System.Errno {
    get { notBlockDevice }
  }
  @_alwaysEmitIntoClient public static var resourceBusy: System.Errno {
    get { Errno(_EBUSY) }
  }
  @available(*, unavailable, renamed: "resourceBusy")
  @_alwaysEmitIntoClient public static var EBUSY: System.Errno {
    get { resourceBusy }
  }
  @_alwaysEmitIntoClient public static var fileExists: System.Errno {
    get { Errno(_EEXIST) }
  }
  @available(*, unavailable, renamed: "fileExists")
  @_alwaysEmitIntoClient public static var EEXIST: System.Errno {
    get { fileExists }
  }
  @_alwaysEmitIntoClient public static var improperLink: System.Errno {
    get { Errno(_EXDEV) }
  }
  @available(*, unavailable, renamed: "improperLink")
  @_alwaysEmitIntoClient public static var EXDEV: System.Errno {
    get { improperLink }
  }
  @_alwaysEmitIntoClient public static var operationNotSupportedByDevice: System.Errno {
    get { Errno(_ENODEV) }
  }
  @available(*, unavailable, renamed: "operationNotSupportedByDevice")
  @_alwaysEmitIntoClient public static var ENODEV: System.Errno {
    get { operationNotSupportedByDevice }
  }
  @_alwaysEmitIntoClient public static var notDirectory: System.Errno {
    get { Errno(_ENOTDIR) }
  }
  @available(*, unavailable, renamed: "notDirectory")
  @_alwaysEmitIntoClient public static var ENOTDIR: System.Errno {
    get { notDirectory }
  }
  @_alwaysEmitIntoClient public static var isDirectory: System.Errno {
    get { Errno(_EISDIR) }
  }
  @available(*, unavailable, renamed: "isDirectory")
  @_alwaysEmitIntoClient public static var EISDIR: System.Errno {
    get { isDirectory }
  }
  @_alwaysEmitIntoClient public static var invalidArgument: System.Errno {
    get { Errno(_EINVAL) }
  }
  @available(*, unavailable, renamed: "invalidArgument")
  @_alwaysEmitIntoClient public static var EINVAL: System.Errno {
    get { invalidArgument }
  }
  @_alwaysEmitIntoClient public static var tooManyOpenFilesInSystem: System.Errno {
    get { Errno(_ENFILE) }
  }
  @available(*, unavailable, renamed: "tooManyOpenFilesInSystem")
  @_alwaysEmitIntoClient public static var ENFILE: System.Errno {
    get { tooManyOpenFilesInSystem }
  }
  @_alwaysEmitIntoClient public static var tooManyOpenFiles: System.Errno {
    get { Errno(_EMFILE) }
  }
  @available(*, unavailable, renamed: "tooManyOpenFiles")
  @_alwaysEmitIntoClient public static var EMFILE: System.Errno {
    get { tooManyOpenFiles }
  }
  @_alwaysEmitIntoClient public static var inappropriateIOCTLForDevice: System.Errno {
    get { Errno(_ENOTTY) }
  }
  @available(*, unavailable, renamed: "inappropriateIOCTLForDevice")
  @_alwaysEmitIntoClient public static var ENOTTY: System.Errno {
    get { inappropriateIOCTLForDevice }
  }
  @_alwaysEmitIntoClient public static var textFileBusy: System.Errno {
    get { Errno(_ETXTBSY) }
  }
  @available(*, unavailable, renamed: "textFileBusy")
  @_alwaysEmitIntoClient public static var ETXTBSY: System.Errno {
    get { textFileBusy }
  }
  @_alwaysEmitIntoClient public static var fileTooLarge: System.Errno {
    get { Errno(_EFBIG) }
  }
  @available(*, unavailable, renamed: "fileTooLarge")
  @_alwaysEmitIntoClient public static var EFBIG: System.Errno {
    get { fileTooLarge }
  }
  @_alwaysEmitIntoClient public static var noSpace: System.Errno {
    get { Errno(_ENOSPC) }
  }
  @available(*, unavailable, renamed: "noSpace")
  @_alwaysEmitIntoClient public static var ENOSPC: System.Errno {
    get { noSpace }
  }
  @_alwaysEmitIntoClient public static var illegalSeek: System.Errno {
    get { Errno(_ESPIPE) }
  }
  @available(*, unavailable, renamed: "illegalSeek")
  @_alwaysEmitIntoClient public static var ESPIPE: System.Errno {
    get { illegalSeek }
  }
  @_alwaysEmitIntoClient public static var readOnlyFileSystem: System.Errno {
    get { Errno(_EROFS) }
  }
  @available(*, unavailable, renamed: "readOnlyFileSystem")
  @_alwaysEmitIntoClient public static var EROFS: System.Errno {
    get { readOnlyFileSystem }
  }
  @_alwaysEmitIntoClient public static var tooManyLinks: System.Errno {
    get { Errno(_EMLINK) }
  }
  @available(*, unavailable, renamed: "tooManyLinks")
  @_alwaysEmitIntoClient public static var EMLINK: System.Errno {
    get { tooManyLinks }
  }
  @_alwaysEmitIntoClient public static var brokenPipe: System.Errno {
    get { Errno(_EPIPE) }
  }
  @available(*, unavailable, renamed: "brokenPipe")
  @_alwaysEmitIntoClient public static var EPIPE: System.Errno {
    get { brokenPipe }
  }
  @_alwaysEmitIntoClient public static var outOfDomain: System.Errno {
    get { Errno(_EDOM) }
  }
  @available(*, unavailable, renamed: "outOfDomain")
  @_alwaysEmitIntoClient public static var EDOM: System.Errno {
    get { outOfDomain }
  }
  @_alwaysEmitIntoClient public static var outOfRange: System.Errno {
    get { Errno(_ERANGE) }
  }
  @available(*, unavailable, renamed: "outOfRange")
  @_alwaysEmitIntoClient public static var ERANGE: System.Errno {
    get { outOfRange }
  }
  @_alwaysEmitIntoClient public static var resourceTemporarilyUnavailable: System.Errno {
    get { Errno(_EAGAIN) }
  }
  @available(*, unavailable, renamed: "resourceTemporarilyUnavailable")
  @_alwaysEmitIntoClient public static var EAGAIN: System.Errno {
    get { resourceTemporarilyUnavailable }
  }
  @_alwaysEmitIntoClient public static var nowInProgress: System.Errno {
    get { Errno(_EINPROGRESS) }
  }
  @available(*, unavailable, renamed: "nowInProcess")
  @_alwaysEmitIntoClient public static var EINPROGRESS: System.Errno {
    get { nowInProgress }
  }
  @_alwaysEmitIntoClient public static var alreadyInProcess: System.Errno {
    get { Errno(_EALREADY) }
  }
  @available(*, unavailable, renamed: "alreadyInProcess")
  @_alwaysEmitIntoClient public static var EALREADY: System.Errno {
    get { alreadyInProcess }
  }
  @_alwaysEmitIntoClient public static var notSocket: System.Errno {
    get { Errno(_ENOTSOCK) }
  }
  @available(*, unavailable, renamed: "notSocket")
  @_alwaysEmitIntoClient public static var ENOTSOCK: System.Errno {
    get { notSocket }
  }
  @_alwaysEmitIntoClient public static var addressRequired: System.Errno {
    get { Errno(_EDESTADDRREQ) }
  }
  @available(*, unavailable, renamed: "addressRequired")
  @_alwaysEmitIntoClient public static var EDESTADDRREQ: System.Errno {
    get { addressRequired }
  }
  @_alwaysEmitIntoClient public static var messageTooLong: System.Errno {
    get { Errno(_EMSGSIZE) }
  }
  @available(*, unavailable, renamed: "messageTooLong")
  @_alwaysEmitIntoClient public static var EMSGSIZE: System.Errno {
    get { messageTooLong }
  }
  @_alwaysEmitIntoClient public static var protocolWrongTypeForSocket: System.Errno {
    get { Errno(_EPROTOTYPE) }
  }
  @available(*, unavailable, renamed: "protocolWrongTypeForSocket")
  @_alwaysEmitIntoClient public static var EPROTOTYPE: System.Errno {
    get { protocolWrongTypeForSocket }
  }
  @_alwaysEmitIntoClient public static var protocolNotAvailable: System.Errno {
    get { Errno(_ENOPROTOOPT) }
  }
  @available(*, unavailable, renamed: "protocolNotAvailable")
  @_alwaysEmitIntoClient public static var ENOPROTOOPT: System.Errno {
    get { protocolNotAvailable }
  }
  @_alwaysEmitIntoClient public static var protocolNotSupported: System.Errno {
    get { Errno(_EPROTONOSUPPORT) }
  }
  @available(*, unavailable, renamed: "protocolNotSupported")
  @_alwaysEmitIntoClient public static var EPROTONOSUPPORT: System.Errno {
    get { protocolNotSupported }
  }
  @_alwaysEmitIntoClient public static var socketTypeNotSupported: System.Errno {
    get { Errno(_ESOCKTNOSUPPORT) }
  }
  @available(*, unavailable, renamed: "socketTypeNotSupported")
  @_alwaysEmitIntoClient public static var ESOCKTNOSUPPORT: System.Errno {
    get { socketTypeNotSupported }
  }
  @_alwaysEmitIntoClient public static var notSupported: System.Errno {
    get { Errno(_ENOTSUP) }
  }
  @available(*, unavailable, renamed: "notSupported")
  @_alwaysEmitIntoClient public static var ENOTSUP: System.Errno {
    get { notSupported }
  }
  @_alwaysEmitIntoClient public static var protocolFamilyNotSupported: System.Errno {
    get { Errno(_EPFNOSUPPORT) }
  }
  @available(*, unavailable, renamed: "protocolFamilyNotSupported")
  @_alwaysEmitIntoClient public static var EPFNOSUPPORT: System.Errno {
    get { protocolFamilyNotSupported }
  }
  @_alwaysEmitIntoClient public static var addressFamilyNotSupported: System.Errno {
    get { Errno(_EAFNOSUPPORT) }
  }
  @available(*, unavailable, renamed: "addressFamilyNotSupported")
  @_alwaysEmitIntoClient public static var EAFNOSUPPORT: System.Errno {
    get { addressFamilyNotSupported }
  }
  @_alwaysEmitIntoClient public static var addressInUse: System.Errno {
    get { Errno(_EADDRINUSE) }
  }
  @available(*, unavailable, renamed: "addressInUse")
  @_alwaysEmitIntoClient public static var EADDRINUSE: System.Errno {
    get { addressInUse }
  }
  @_alwaysEmitIntoClient public static var addressNotAvailable: System.Errno {
    get { Errno(_EADDRNOTAVAIL) }
  }
  @available(*, unavailable, renamed: "addressNotAvailable")
  @_alwaysEmitIntoClient public static var EADDRNOTAVAIL: System.Errno {
    get { addressNotAvailable }
  }
  @_alwaysEmitIntoClient public static var networkDown: System.Errno {
    get { Errno(_ENETDOWN) }
  }
  @available(*, unavailable, renamed: "networkDown")
  @_alwaysEmitIntoClient public static var ENETDOWN: System.Errno {
    get { networkDown }
  }
  @_alwaysEmitIntoClient public static var networkUnreachable: System.Errno {
    get { Errno(_ENETUNREACH) }
  }
  @available(*, unavailable, renamed: "networkUnreachable")
  @_alwaysEmitIntoClient public static var ENETUNREACH: System.Errno {
    get { networkUnreachable }
  }
  @_alwaysEmitIntoClient public static var networkReset: System.Errno {
    get { Errno(_ENETRESET) }
  }
  @available(*, unavailable, renamed: "networkReset")
  @_alwaysEmitIntoClient public static var ENETRESET: System.Errno {
    get { networkReset }
  }
  @_alwaysEmitIntoClient public static var connectionAbort: System.Errno {
    get { Errno(_ECONNABORTED) }
  }
  @available(*, unavailable, renamed: "connectionAbort")
  @_alwaysEmitIntoClient public static var ECONNABORTED: System.Errno {
    get { connectionAbort }
  }
  @_alwaysEmitIntoClient public static var connectionReset: System.Errno {
    get { Errno(_ECONNRESET) }
  }
  @available(*, unavailable, renamed: "connectionReset")
  @_alwaysEmitIntoClient public static var ECONNRESET: System.Errno {
    get { connectionReset }
  }
  @_alwaysEmitIntoClient public static var noBufferSpace: System.Errno {
    get { Errno(_ENOBUFS) }
  }
  @available(*, unavailable, renamed: "noBufferSpace")
  @_alwaysEmitIntoClient public static var ENOBUFS: System.Errno {
    get { noBufferSpace }
  }
  @_alwaysEmitIntoClient public static var socketIsConnected: System.Errno {
    get { Errno(_EISCONN) }
  }
  @available(*, unavailable, renamed: "socketIsConnected")
  @_alwaysEmitIntoClient public static var EISCONN: System.Errno {
    get { socketIsConnected }
  }
  @_alwaysEmitIntoClient public static var socketNotConnected: System.Errno {
    get { Errno(_ENOTCONN) }
  }
  @available(*, unavailable, renamed: "socketNotConnected")
  @_alwaysEmitIntoClient public static var ENOTCONN: System.Errno {
    get { socketNotConnected }
  }
  @_alwaysEmitIntoClient public static var socketShutdown: System.Errno {
    get { Errno(_ESHUTDOWN) }
  }
  @available(*, unavailable, renamed: "socketShutdown")
  @_alwaysEmitIntoClient public static var ESHUTDOWN: System.Errno {
    get { socketShutdown }
  }
  @_alwaysEmitIntoClient public static var timedOut: System.Errno {
    get { Errno(_ETIMEDOUT) }
  }
  @available(*, unavailable, renamed: "timedOut")
  @_alwaysEmitIntoClient public static var ETIMEDOUT: System.Errno {
    get { timedOut }
  }
  @_alwaysEmitIntoClient public static var connectionRefused: System.Errno {
    get { Errno(_ECONNREFUSED) }
  }
  @available(*, unavailable, renamed: "connectionRefused")
  @_alwaysEmitIntoClient public static var ECONNREFUSED: System.Errno {
    get { connectionRefused }
  }
  @_alwaysEmitIntoClient public static var tooManySymbolicLinkLevels: System.Errno {
    get { Errno(_ELOOP) }
  }
  @available(*, unavailable, renamed: "tooManySymbolicLinkLevels")
  @_alwaysEmitIntoClient public static var ELOOP: System.Errno {
    get { tooManySymbolicLinkLevels }
  }
  @_alwaysEmitIntoClient public static var fileNameTooLong: System.Errno {
    get { Errno(_ENAMETOOLONG) }
  }
  @available(*, unavailable, renamed: "fileNameTooLong")
  @_alwaysEmitIntoClient public static var ENAMETOOLONG: System.Errno {
    get { fileNameTooLong }
  }
  @_alwaysEmitIntoClient public static var hostIsDown: System.Errno {
    get { Errno(_EHOSTDOWN) }
  }
  @available(*, unavailable, renamed: "hostIsDown")
  @_alwaysEmitIntoClient public static var EHOSTDOWN: System.Errno {
    get { hostIsDown }
  }
  @_alwaysEmitIntoClient public static var noRouteToHost: System.Errno {
    get { Errno(_EHOSTUNREACH) }
  }
  @available(*, unavailable, renamed: "noRouteToHost")
  @_alwaysEmitIntoClient public static var EHOSTUNREACH: System.Errno {
    get { noRouteToHost }
  }
  @_alwaysEmitIntoClient public static var directoryNotEmpty: System.Errno {
    get { Errno(_ENOTEMPTY) }
  }
  @available(*, unavailable, renamed: "directoryNotEmpty")
  @_alwaysEmitIntoClient public static var ENOTEMPTY: System.Errno {
    get { directoryNotEmpty }
  }
  @_alwaysEmitIntoClient public static var tooManyProcesses: System.Errno {
    get { Errno(_EPROCLIM) }
  }
  @available(*, unavailable, renamed: "tooManyProcesses")
  @_alwaysEmitIntoClient public static var EPROCLIM: System.Errno {
    get { tooManyProcesses }
  }
  @_alwaysEmitIntoClient public static var tooManyUsers: System.Errno {
    get { Errno(_EUSERS) }
  }
  @available(*, unavailable, renamed: "tooManyUsers")
  @_alwaysEmitIntoClient public static var EUSERS: System.Errno {
    get { tooManyUsers }
  }
  @_alwaysEmitIntoClient public static var diskQuotaExceeded: System.Errno {
    get { Errno(_EDQUOT) }
  }
  @available(*, unavailable, renamed: "diskQuotaExceeded")
  @_alwaysEmitIntoClient public static var EDQUOT: System.Errno {
    get { diskQuotaExceeded }
  }
  @_alwaysEmitIntoClient public static var staleNFSFileHandle: System.Errno {
    get { Errno(_ESTALE) }
  }
  @available(*, unavailable, renamed: "staleNFSFileHandle")
  @_alwaysEmitIntoClient public static var ESTALE: System.Errno {
    get { staleNFSFileHandle }
  }
  @_alwaysEmitIntoClient public static var rpcUnsuccessful: System.Errno {
    get { Errno(_EBADRPC) }
  }
  @available(*, unavailable, renamed: "rpcUnsuccessful")
  @_alwaysEmitIntoClient public static var EBADRPC: System.Errno {
    get { rpcUnsuccessful }
  }
  @_alwaysEmitIntoClient public static var rpcVersionMismatch: System.Errno {
    get { Errno(_ERPCMISMATCH) }
  }
  @available(*, unavailable, renamed: "rpcVersionMismatch")
  @_alwaysEmitIntoClient public static var ERPCMISMATCH: System.Errno {
    get { rpcVersionMismatch }
  }
  @_alwaysEmitIntoClient public static var rpcProgramUnavailable: System.Errno {
    get { Errno(_EPROGUNAVAIL) }
  }
  @available(*, unavailable, renamed: "rpcProgramUnavailable")
  @_alwaysEmitIntoClient public static var EPROGUNAVAIL: System.Errno {
    get { rpcProgramUnavailable }
  }
  @_alwaysEmitIntoClient public static var rpcProgramVersionMismatch: System.Errno {
    get { Errno(_EPROGMISMATCH) }
  }
  @available(*, unavailable, renamed: "rpcProgramVersionMismatch")
  @_alwaysEmitIntoClient public static var EPROGMISMATCH: System.Errno {
    get { rpcProgramVersionMismatch }
  }
  @_alwaysEmitIntoClient public static var rpcProcedureUnavailable: System.Errno {
    get { Errno(_EPROCUNAVAIL) }
  }
  @available(*, unavailable, renamed: "rpcProcedureUnavailable")
  @_alwaysEmitIntoClient public static var EPROCUNAVAIL: System.Errno {
    get { rpcProcedureUnavailable }
  }
  @_alwaysEmitIntoClient public static var noLocks: System.Errno {
    get { Errno(_ENOLCK) }
  }
  @available(*, unavailable, renamed: "noLocks")
  @_alwaysEmitIntoClient public static var ENOLCK: System.Errno {
    get { noLocks }
  }
  @_alwaysEmitIntoClient public static var noFunction: System.Errno {
    get { Errno(_ENOSYS) }
  }
  @available(*, unavailable, renamed: "noFunction")
  @_alwaysEmitIntoClient public static var ENOSYS: System.Errno {
    get { noFunction }
  }
  @_alwaysEmitIntoClient public static var badFileTypeOrFormat: System.Errno {
    get { Errno(_EFTYPE) }
  }
  @available(*, unavailable, renamed: "badFileTypeOrFormat")
  @_alwaysEmitIntoClient public static var EFTYPE: System.Errno {
    get { badFileTypeOrFormat }
  }
  @_alwaysEmitIntoClient public static var authenticationError: System.Errno {
    get { Errno(_EAUTH) }
  }
  @available(*, unavailable, renamed: "authenticationError")
  @_alwaysEmitIntoClient public static var EAUTH: System.Errno {
    get { authenticationError }
  }
  @_alwaysEmitIntoClient public static var needAuthenticator: System.Errno {
    get { Errno(_ENEEDAUTH) }
  }
  @available(*, unavailable, renamed: "needAuthenticator")
  @_alwaysEmitIntoClient public static var ENEEDAUTH: System.Errno {
    get { needAuthenticator }
  }
  @_alwaysEmitIntoClient public static var devicePowerIsOff: System.Errno {
    get { Errno(_EPWROFF) }
  }
  @available(*, unavailable, renamed: "devicePowerIsOff")
  @_alwaysEmitIntoClient public static var EPWROFF: System.Errno {
    get { devicePowerIsOff }
  }
  @_alwaysEmitIntoClient public static var deviceError: System.Errno {
    get { Errno(_EDEVERR) }
  }
  @available(*, unavailable, renamed: "deviceError")
  @_alwaysEmitIntoClient public static var EDEVERR: System.Errno {
    get { deviceError }
  }
  @_alwaysEmitIntoClient public static var overflow: System.Errno {
    get { Errno(_EOVERFLOW) }
  }
  @available(*, unavailable, renamed: "overflow")
  @_alwaysEmitIntoClient public static var EOVERFLOW: System.Errno {
    get { overflow }
  }
  @_alwaysEmitIntoClient public static var badExecutable: System.Errno {
    get { Errno(_EBADEXEC) }
  }
  @available(*, unavailable, renamed: "badExecutable")
  @_alwaysEmitIntoClient public static var EBADEXEC: System.Errno {
    get { badExecutable }
  }
  @_alwaysEmitIntoClient public static var badCPUType: System.Errno {
    get { Errno(_EBADARCH) }
  }
  @available(*, unavailable, renamed: "badCPUType")
  @_alwaysEmitIntoClient public static var EBADARCH: System.Errno {
    get { badCPUType }
  }
  @_alwaysEmitIntoClient public static var sharedLibraryVersionMismatch: System.Errno {
    get { Errno(_ESHLIBVERS) }
  }
  @available(*, unavailable, renamed: "sharedLibraryVersionMismatch")
  @_alwaysEmitIntoClient public static var ESHLIBVERS: System.Errno {
    get { sharedLibraryVersionMismatch }
  }
  @_alwaysEmitIntoClient public static var malformedMachO: System.Errno {
    get { Errno(_EBADMACHO) }
  }
  @available(*, unavailable, renamed: "malformedMachO")
  @_alwaysEmitIntoClient public static var EBADMACHO: System.Errno {
    get { malformedMachO }
  }
  @_alwaysEmitIntoClient public static var canceled: System.Errno {
    get { Errno(_ECANCELED) }
  }
  @available(*, unavailable, renamed: "canceled")
  @_alwaysEmitIntoClient public static var ECANCELED: System.Errno {
    get { canceled }
  }
  @_alwaysEmitIntoClient public static var identifierRemoved: System.Errno {
    get { Errno(_EIDRM) }
  }
  @available(*, unavailable, renamed: "identifierRemoved")
  @_alwaysEmitIntoClient public static var EIDRM: System.Errno {
    get { identifierRemoved }
  }
  @_alwaysEmitIntoClient public static var noMessage: System.Errno {
    get { Errno(_ENOMSG) }
  }
  @available(*, unavailable, renamed: "noMessage")
  @_alwaysEmitIntoClient public static var ENOMSG: System.Errno {
    get { noMessage }
  }
  @_alwaysEmitIntoClient public static var illegalByteSequence: System.Errno {
    get { Errno(_EILSEQ) }
  }
  @available(*, unavailable, renamed: "illegalByteSequence")
  @_alwaysEmitIntoClient public static var EILSEQ: System.Errno {
    get { illegalByteSequence }
  }
  @_alwaysEmitIntoClient public static var attributeNotFound: System.Errno {
    get { Errno(_ENOATTR) }
  }
  @available(*, unavailable, renamed: "attributeNotFound")
  @_alwaysEmitIntoClient public static var ENOATTR: System.Errno {
    get { attributeNotFound }
  }
  @_alwaysEmitIntoClient public static var badMessage: System.Errno {
    get { Errno(_EBADMSG) }
  }
  @available(*, unavailable, renamed: "badMessage")
  @_alwaysEmitIntoClient public static var EBADMSG: System.Errno {
    get { badMessage }
  }
  @_alwaysEmitIntoClient public static var multiHop: System.Errno {
    get { Errno(_EMULTIHOP) }
  }
  @available(*, unavailable, renamed: "multiHop")
  @_alwaysEmitIntoClient public static var EMULTIHOP: System.Errno {
    get { multiHop }
  }
  @_alwaysEmitIntoClient public static var noData: System.Errno {
    get { Errno(_ENODATA) }
  }
  @available(*, unavailable, renamed: "noData")
  @_alwaysEmitIntoClient public static var ENODATA: System.Errno {
    get { noData }
  }
  @_alwaysEmitIntoClient public static var noLink: System.Errno {
    get { Errno(_ENOLINK) }
  }
  @available(*, unavailable, renamed: "noLink")
  @_alwaysEmitIntoClient public static var ENOLINK: System.Errno {
    get { noLink }
  }
  @_alwaysEmitIntoClient public static var noStreamResources: System.Errno {
    get { Errno(_ENOSR) }
  }
  @available(*, unavailable, renamed: "noStreamResources")
  @_alwaysEmitIntoClient public static var ENOSR: System.Errno {
    get { noStreamResources }
  }
  @_alwaysEmitIntoClient public static var notStream: System.Errno {
    get { Errno(_ENOSTR) }
  }
  @available(*, unavailable, renamed: "notStream")
  @_alwaysEmitIntoClient public static var ENOSTR: System.Errno {
    get { notStream }
  }
  @_alwaysEmitIntoClient public static var protocolError: System.Errno {
    get { Errno(_EPROTO) }
  }
  @available(*, unavailable, renamed: "protocolError")
  @_alwaysEmitIntoClient public static var EPROTO: System.Errno {
    get { protocolError }
  }
  @_alwaysEmitIntoClient public static var timeout: System.Errno {
    get { Errno(_ETIME) }
  }
  @available(*, unavailable, renamed: "timeout")
  @_alwaysEmitIntoClient public static var ETIME: System.Errno {
    get { timeout }
  }
  @_alwaysEmitIntoClient public static var notSupportedOnSocket: System.Errno {
    get { Errno(_EOPNOTSUPP) }
  }
  @available(*, unavailable, renamed: "notSupportedOnSocket")
  @_alwaysEmitIntoClient public static var EOPNOTSUPP: System.Errno {
    get { notSupportedOnSocket }
  }
  public typealias RawValue = Swift.CInt
}
@available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
extension Errno {
  @_alwaysEmitIntoClient public static var wouldBlock: System.Errno {
    get { Errno(_EWOULDBLOCK) }
  }
  @available(*, unavailable, renamed: "wouldBlock")
  @_alwaysEmitIntoClient public static var EWOULDBLOCK: System.Errno {
    get { wouldBlock }
  }
  @_alwaysEmitIntoClient public static var tooManyReferences: System.Errno {
    get { Errno(_ETOOMANYREFS) }
  }
  @available(*, unavailable, renamed: "tooManyReferences")
  @_alwaysEmitIntoClient public static var ETOOMANYREFS: System.Errno {
    get { tooManyReferences }
  }
  @_alwaysEmitIntoClient public static var tooManyRemoteLevels: System.Errno {
    get { Errno(_EREMOTE) }
  }
  @available(*, unavailable, renamed: "tooManyRemoteLevels")
  @_alwaysEmitIntoClient public static var EREMOTE: System.Errno {
    get { tooManyRemoteLevels }
  }
  @_alwaysEmitIntoClient public static var noSuchPolicy: System.Errno {
    get { Errno(_ENOPOLICY) }
  }
  @available(*, unavailable, renamed: "noSuchPolicy")
  @_alwaysEmitIntoClient public static var ENOPOLICY: System.Errno {
    get { noSuchPolicy }
  }
  @_alwaysEmitIntoClient public static var notRecoverable: System.Errno {
    get { Errno(_ENOTRECOVERABLE) }
  }
  @available(*, unavailable, renamed: "notRecoverable")
  @_alwaysEmitIntoClient public static var ENOTRECOVERABLE: System.Errno {
    get { notRecoverable }
  }
  @_alwaysEmitIntoClient public static var previousOwnerDied: System.Errno {
    get { Errno(_EOWNERDEAD) }
  }
  @available(*, unavailable, renamed: "previousOwnerDied")
  @_alwaysEmitIntoClient public static var EOWNERDEAD: System.Errno {
    get { previousOwnerDied }
  }
  @_alwaysEmitIntoClient public static var outputQueueFull: System.Errno {
    get { Errno(_EQFULL) }
  }
  @available(*, unavailable, renamed: "outputQueueFull")
  @_alwaysEmitIntoClient public static var EQFULL: System.Errno {
    get { outputQueueFull }
  }
  @_alwaysEmitIntoClient public static var lastErrnoValue: System.Errno {
    get { Errno(_ELAST) }
  }
  @available(*, unavailable, renamed: "lastErrnoValue")
  @_alwaysEmitIntoClient public static var ELAST: System.Errno {
    get { lastErrnoValue }
  }
}
@available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
extension Errno {
  public var _code: Swift.Int {
    get
  }
  public var _domain: Swift.String {
    get
  }
}
@available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
extension Errno : Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible {
  @inline(never) public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
}
@available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
extension Errno {
  @_alwaysEmitIntoClient public static func ~= (lhs: System.Errno, rhs: Swift.Error) -> Swift.Bool {
    guard let value = rhs as? Errno else { return false }
    return lhs == value
  }
}
@available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
@frozen public struct FileDescriptor : Swift.RawRepresentable, Swift.Hashable, Swift.Codable {
  @_alwaysEmitIntoClient public let rawValue: Swift.CInt
  @_alwaysEmitIntoClient public init(rawValue: Swift.CInt) { self.rawValue = rawValue }
  public typealias RawValue = Swift.CInt
}
@available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
extension FileDescriptor {
  @frozen public struct AccessMode : Swift.RawRepresentable, Swift.Hashable, Swift.Codable {
    @_alwaysEmitIntoClient public var rawValue: Swift.CInt
    @_alwaysEmitIntoClient public init(rawValue: Swift.CInt) { self.rawValue = rawValue }
    @_alwaysEmitIntoClient public static var readOnly: System.FileDescriptor.AccessMode {
      get { AccessMode(rawValue: _O_RDONLY) }
    }
    @available(*, unavailable, renamed: "readOnly")
    @_alwaysEmitIntoClient public static var O_RDONLY: System.FileDescriptor.AccessMode {
      get { readOnly }
    }
    @_alwaysEmitIntoClient public static var writeOnly: System.FileDescriptor.AccessMode {
      get { AccessMode(rawValue: _O_WRONLY) }
    }
    @available(*, unavailable, renamed: "writeOnly")
    @_alwaysEmitIntoClient public static var O_WRONLY: System.FileDescriptor.AccessMode {
      get { writeOnly }
    }
    @_alwaysEmitIntoClient public static var readWrite: System.FileDescriptor.AccessMode {
      get { AccessMode(rawValue: _O_RDWR) }
    }
    @available(*, unavailable, renamed: "readWrite")
    @_alwaysEmitIntoClient public static var O_RDWR: System.FileDescriptor.AccessMode {
      get { readWrite }
    }
    public typealias RawValue = Swift.CInt
  }
  @frozen public struct OpenOptions : Swift.OptionSet, Swift.Hashable, Swift.Codable {
    @_alwaysEmitIntoClient public var rawValue: Swift.CInt
    @_alwaysEmitIntoClient public init(rawValue: Swift.CInt) { self.rawValue = rawValue }
    @_alwaysEmitIntoClient private init(_ raw: Swift.CInt) { self.init(rawValue: raw) }
    @_alwaysEmitIntoClient public static var nonBlocking: System.FileDescriptor.OpenOptions {
      get { OpenOptions(_O_NONBLOCK) }
    }
    @available(*, unavailable, renamed: "nonBlocking")
    @_alwaysEmitIntoClient public static var O_NONBLOCK: System.FileDescriptor.OpenOptions {
      get { nonBlocking }
    }
    @_alwaysEmitIntoClient public static var append: System.FileDescriptor.OpenOptions {
      get { OpenOptions(_O_APPEND) }
    }
    @available(*, unavailable, renamed: "append")
    @_alwaysEmitIntoClient public static var O_APPEND: System.FileDescriptor.OpenOptions {
      get { append }
    }
    @_alwaysEmitIntoClient public static var create: System.FileDescriptor.OpenOptions {
      get { OpenOptions(_O_CREAT) }
    }
    @available(*, unavailable, renamed: "create")
    @_alwaysEmitIntoClient public static var O_CREAT: System.FileDescriptor.OpenOptions {
      get { create }
    }
    @_alwaysEmitIntoClient public static var truncate: System.FileDescriptor.OpenOptions {
      get { OpenOptions(_O_TRUNC) }
    }
    @available(*, unavailable, renamed: "truncate")
    @_alwaysEmitIntoClient public static var O_TRUNC: System.FileDescriptor.OpenOptions {
      get { truncate }
    }
    @_alwaysEmitIntoClient public static var exclusiveCreate: System.FileDescriptor.OpenOptions {
      get { OpenOptions(_O_EXCL) }
    }
    @available(*, unavailable, renamed: "exclusiveCreate")
    @_alwaysEmitIntoClient public static var O_EXCL: System.FileDescriptor.OpenOptions {
      get { exclusiveCreate }
    }
    @_alwaysEmitIntoClient public static var sharedLock: System.FileDescriptor.OpenOptions {
      get { OpenOptions(_O_SHLOCK) }
    }
    @available(*, unavailable, renamed: "sharedLock")
    @_alwaysEmitIntoClient public static var O_SHLOCK: System.FileDescriptor.OpenOptions {
      get { sharedLock }
    }
    @_alwaysEmitIntoClient public static var exclusiveLock: System.FileDescriptor.OpenOptions {
      get { OpenOptions(_O_EXLOCK) }
    }
    @available(*, unavailable, renamed: "exclusiveLock")
    @_alwaysEmitIntoClient public static var O_EXLOCK: System.FileDescriptor.OpenOptions {
      get { exclusiveLock }
    }
    @_alwaysEmitIntoClient public static var noFollow: System.FileDescriptor.OpenOptions {
      get { OpenOptions(_O_NOFOLLOW) }
    }
    @available(*, unavailable, renamed: "noFollow")
    @_alwaysEmitIntoClient public static var O_NOFOLLOW: System.FileDescriptor.OpenOptions {
      get { noFollow }
    }
    @_alwaysEmitIntoClient public static var symlink: System.FileDescriptor.OpenOptions {
      get { OpenOptions(_O_SYMLINK) }
    }
    @available(*, unavailable, renamed: "symlink")
    @_alwaysEmitIntoClient public static var O_SYMLINK: System.FileDescriptor.OpenOptions {
      get { symlink }
    }
    @_alwaysEmitIntoClient public static var eventOnly: System.FileDescriptor.OpenOptions {
      get { OpenOptions(_O_EVTONLY) }
    }
    @available(*, unavailable, renamed: "eventOnly")
    @_alwaysEmitIntoClient public static var O_EVTONLY: System.FileDescriptor.OpenOptions {
      get { eventOnly }
    }
    @_alwaysEmitIntoClient public static var closeOnExec: System.FileDescriptor.OpenOptions {
      get { OpenOptions(_O_CLOEXEC) }
    }
    @available(*, unavailable, renamed: "closeOnExec")
    @_alwaysEmitIntoClient public static var O_CLOEXEC: System.FileDescriptor.OpenOptions {
      get { closeOnExec }
    }
    public typealias ArrayLiteralElement = System.FileDescriptor.OpenOptions
    public typealias Element = System.FileDescriptor.OpenOptions
    public typealias RawValue = Swift.CInt
  }
  @frozen public struct SeekOrigin : Swift.RawRepresentable, Swift.Hashable, Swift.Codable {
    @_alwaysEmitIntoClient public var rawValue: Swift.CInt
    @_alwaysEmitIntoClient public init(rawValue: Swift.CInt) { self.rawValue = rawValue }
    @_alwaysEmitIntoClient public static var start: System.FileDescriptor.SeekOrigin {
      get { SeekOrigin(rawValue: _SEEK_SET) }
    }
    @available(*, unavailable, renamed: "start")
    @_alwaysEmitIntoClient public static var SEEK_SET: System.FileDescriptor.SeekOrigin {
      get { start }
    }
    @_alwaysEmitIntoClient public static var current: System.FileDescriptor.SeekOrigin {
      get { SeekOrigin(rawValue: _SEEK_CUR) }
    }
    @available(*, unavailable, renamed: "current")
    @_alwaysEmitIntoClient public static var SEEK_CUR: System.FileDescriptor.SeekOrigin {
      get { current }
    }
    @_alwaysEmitIntoClient public static var end: System.FileDescriptor.SeekOrigin {
      get { SeekOrigin(rawValue: _SEEK_END) }
    }
    @available(*, unavailable, renamed: "end")
    @_alwaysEmitIntoClient public static var SEEK_END: System.FileDescriptor.SeekOrigin {
      get { end }
    }
    @_alwaysEmitIntoClient public static var nextHole: System.FileDescriptor.SeekOrigin {
      get { SeekOrigin(rawValue: _SEEK_HOLE) }
    }
    @available(*, unavailable, renamed: "nextHole")
    @_alwaysEmitIntoClient public static var SEEK_HOLE: System.FileDescriptor.SeekOrigin {
      get { nextHole }
    }
    @_alwaysEmitIntoClient public static var nextData: System.FileDescriptor.SeekOrigin {
      get { SeekOrigin(rawValue: _SEEK_DATA) }
    }
    @available(*, unavailable, renamed: "nextData")
    @_alwaysEmitIntoClient public static var SEEK_DATA: System.FileDescriptor.SeekOrigin {
      get { nextData }
    }
    public typealias RawValue = Swift.CInt
  }
}
@available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
extension FileDescriptor.AccessMode : Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible {
  @inline(never) public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
}
@available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
extension FileDescriptor.SeekOrigin : Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible {
  @inline(never) public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
}
@available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
extension FileDescriptor.OpenOptions : Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible {
  @inline(never) public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
}
@available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
extension FileDescriptor {
  public func closeAfter<R>(_ body: () throws -> R) throws -> R
  @discardableResult
  @_alwaysEmitIntoClient public func writeAll<S>(_ sequence: S) throws -> Swift.Int where S : Swift.Sequence, S.Element == Swift.UInt8 {
    return try _writeAll(sequence).get()
  }
  @usableFromInline
  internal func _writeAll<S>(_ sequence: S) -> Swift.Result<Swift.Int, System.Errno> where S : Swift.Sequence, S.Element == Swift.UInt8
  @discardableResult
  @_alwaysEmitIntoClient public func writeAll<S>(toAbsoluteOffset offset: Swift.Int64, _ sequence: S) throws -> Swift.Int where S : Swift.Sequence, S.Element == Swift.UInt8 {
    try _writeAll(toAbsoluteOffset: offset, sequence).get()
  }
  @usableFromInline
  internal func _writeAll<S>(toAbsoluteOffset offset: Swift.Int64, _ sequence: S) -> Swift.Result<Swift.Int, System.Errno> where S : Swift.Sequence, S.Element == Swift.UInt8
}
@_alwaysEmitIntoClient internal var _ERRNO_NOT_USED: Swift.CInt {
  get { 0 }
}
@_alwaysEmitIntoClient internal var _EPERM: Swift.CInt {
  get { 1 }
}
@_alwaysEmitIntoClient internal var _ENOENT: Swift.CInt {
  get { 2 }
}
@_alwaysEmitIntoClient internal var _ESRCH: Swift.CInt {
  get { 3 }
}
@_alwaysEmitIntoClient internal var _EINTR: Swift.CInt {
  get { 4 }
}
@_alwaysEmitIntoClient internal var _EIO: Swift.CInt {
  get { 5 }
}
@_alwaysEmitIntoClient internal var _ENXIO: Swift.CInt {
  get { 6 }
}
@_alwaysEmitIntoClient internal var _E2BIG: Swift.CInt {
  get { 7 }
}
@_alwaysEmitIntoClient internal var _ENOEXEC: Swift.CInt {
  get { 8 }
}
@_alwaysEmitIntoClient internal var _EBADF: Swift.CInt {
  get { 9 }
}
@_alwaysEmitIntoClient internal var _ECHILD: Swift.CInt {
  get { 10 }
}
@_alwaysEmitIntoClient internal var _EDEADLK: Swift.CInt {
  get { 11 }
}
@_alwaysEmitIntoClient internal var _ENOMEM: Swift.CInt {
  get { 12 }
}
@_alwaysEmitIntoClient internal var _EACCES: Swift.CInt {
  get { 13 }
}
@_alwaysEmitIntoClient internal var _EFAULT: Swift.CInt {
  get { 14 }
}
@_alwaysEmitIntoClient internal var _ENOTBLK: Swift.CInt {
  get { 15 }
}
@_alwaysEmitIntoClient internal var _EBUSY: Swift.CInt {
  get { 16 }
}
@_alwaysEmitIntoClient internal var _EEXIST: Swift.CInt {
  get { 17 }
}
@_alwaysEmitIntoClient internal var _EXDEV: Swift.CInt {
  get { 18 }
}
@_alwaysEmitIntoClient internal var _ENODEV: Swift.CInt {
  get { 19 }
}
@_alwaysEmitIntoClient internal var _ENOTDIR: Swift.CInt {
  get { 20 }
}
@_alwaysEmitIntoClient internal var _EISDIR: Swift.CInt {
  get { 21 }
}
@_alwaysEmitIntoClient internal var _EINVAL: Swift.CInt {
  get { 22 }
}
@_alwaysEmitIntoClient internal var _ENFILE: Swift.CInt {
  get { 23 }
}
@_alwaysEmitIntoClient internal var _EMFILE: Swift.CInt {
  get { 24 }
}
@_alwaysEmitIntoClient internal var _ENOTTY: Swift.CInt {
  get { 25 }
}
@_alwaysEmitIntoClient internal var _ETXTBSY: Swift.CInt {
  get { 26 }
}
@_alwaysEmitIntoClient internal var _EFBIG: Swift.CInt {
  get { 27 }
}
@_alwaysEmitIntoClient internal var _ENOSPC: Swift.CInt {
  get { 28 }
}
@_alwaysEmitIntoClient internal var _ESPIPE: Swift.CInt {
  get { 29 }
}
@_alwaysEmitIntoClient internal var _EROFS: Swift.CInt {
  get { 30 }
}
@_alwaysEmitIntoClient internal var _EMLINK: Swift.CInt {
  get { 31 }
}
@_alwaysEmitIntoClient internal var _EPIPE: Swift.CInt {
  get { 32 }
}
@_alwaysEmitIntoClient internal var _EDOM: Swift.CInt {
  get { 33 }
}
@_alwaysEmitIntoClient internal var _ERANGE: Swift.CInt {
  get { 34 }
}
@_alwaysEmitIntoClient internal var _EAGAIN: Swift.CInt {
  get { 35 }
}
@_alwaysEmitIntoClient internal var _EWOULDBLOCK: Swift.CInt {
  get { _EAGAIN }
}
@_alwaysEmitIntoClient internal var _EINPROGRESS: Swift.CInt {
  get { 36 }
}
@_alwaysEmitIntoClient internal var _EALREADY: Swift.CInt {
  get { 37 }
}
@_alwaysEmitIntoClient internal var _ENOTSOCK: Swift.CInt {
  get { 38 }
}
@_alwaysEmitIntoClient internal var _EDESTADDRREQ: Swift.CInt {
  get { 39 }
}
@_alwaysEmitIntoClient internal var _EMSGSIZE: Swift.CInt {
  get { 40 }
}
@_alwaysEmitIntoClient internal var _EPROTOTYPE: Swift.CInt {
  get { 41 }
}
@_alwaysEmitIntoClient internal var _ENOPROTOOPT: Swift.CInt {
  get { 42 }
}
@_alwaysEmitIntoClient internal var _EPROTONOSUPPORT: Swift.CInt {
  get { 43 }
}
@_alwaysEmitIntoClient internal var _ESOCKTNOSUPPORT: Swift.CInt {
  get { 44 }
}
@_alwaysEmitIntoClient internal var _ENOTSUP: Swift.CInt {
  get { 45 }
}
@_alwaysEmitIntoClient internal var _EPFNOSUPPORT: Swift.CInt {
  get { 46 }
}
@_alwaysEmitIntoClient internal var _EAFNOSUPPORT: Swift.CInt {
  get { 47 }
}
@_alwaysEmitIntoClient internal var _EADDRINUSE: Swift.CInt {
  get { 48 }
}
@_alwaysEmitIntoClient internal var _EADDRNOTAVAIL: Swift.CInt {
  get { 49 }
}
@_alwaysEmitIntoClient internal var _ENETDOWN: Swift.CInt {
  get { 50 }
}
@_alwaysEmitIntoClient internal var _ENETUNREACH: Swift.CInt {
  get { 51 }
}
@_alwaysEmitIntoClient internal var _ENETRESET: Swift.CInt {
  get { 52 }
}
@_alwaysEmitIntoClient internal var _ECONNABORTED: Swift.CInt {
  get { 53 }
}
@_alwaysEmitIntoClient internal var _ECONNRESET: Swift.CInt {
  get { 54 }
}
@_alwaysEmitIntoClient internal var _ENOBUFS: Swift.CInt {
  get { 55 }
}
@_alwaysEmitIntoClient internal var _EISCONN: Swift.CInt {
  get { 56 }
}
@_alwaysEmitIntoClient internal var _ENOTCONN: Swift.CInt {
  get { 57 }
}
@_alwaysEmitIntoClient internal var _ESHUTDOWN: Swift.CInt {
  get { 58 }
}
@_alwaysEmitIntoClient internal var _ETOOMANYREFS: Swift.CInt {
  get { 59 }
}
@_alwaysEmitIntoClient internal var _ETIMEDOUT: Swift.CInt {
  get { 60 }
}
@_alwaysEmitIntoClient internal var _ECONNREFUSED: Swift.CInt {
  get { 61 }
}
@_alwaysEmitIntoClient internal var _ELOOP: Swift.CInt {
  get { 62 }
}
@_alwaysEmitIntoClient internal var _ENAMETOOLONG: Swift.CInt {
  get { 63 }
}
@_alwaysEmitIntoClient internal var _EHOSTDOWN: Swift.CInt {
  get { 64 }
}
@_alwaysEmitIntoClient internal var _EHOSTUNREACH: Swift.CInt {
  get { 65 }
}
@_alwaysEmitIntoClient internal var _ENOTEMPTY: Swift.CInt {
  get { 66 }
}
@_alwaysEmitIntoClient internal var _EPROCLIM: Swift.CInt {
  get { 67 }
}
@_alwaysEmitIntoClient internal var _EUSERS: Swift.CInt {
  get { 68 }
}
@_alwaysEmitIntoClient internal var _EDQUOT: Swift.CInt {
  get { 69 }
}
@_alwaysEmitIntoClient internal var _ESTALE: Swift.CInt {
  get { 70 }
}
@_alwaysEmitIntoClient internal var _EREMOTE: Swift.CInt {
  get { 71 }
}
@_alwaysEmitIntoClient internal var _EBADRPC: Swift.CInt {
  get { 72 }
}
@_alwaysEmitIntoClient internal var _ERPCMISMATCH: Swift.CInt {
  get { 73 }
}
@_alwaysEmitIntoClient internal var _EPROGUNAVAIL: Swift.CInt {
  get { 74 }
}
@_alwaysEmitIntoClient internal var _EPROGMISMATCH: Swift.CInt {
  get { 75 }
}
@_alwaysEmitIntoClient internal var _EPROCUNAVAIL: Swift.CInt {
  get { 76 }
}
@_alwaysEmitIntoClient internal var _ENOLCK: Swift.CInt {
  get { 77 }
}
@_alwaysEmitIntoClient internal var _ENOSYS: Swift.CInt {
  get { 78 }
}
@_alwaysEmitIntoClient internal var _EFTYPE: Swift.CInt {
  get { 79 }
}
@_alwaysEmitIntoClient internal var _EAUTH: Swift.CInt {
  get { 80 }
}
@_alwaysEmitIntoClient internal var _ENEEDAUTH: Swift.CInt {
  get { 81 }
}
@_alwaysEmitIntoClient internal var _EPWROFF: Swift.CInt {
  get { 82 }
}
@_alwaysEmitIntoClient internal var _EDEVERR: Swift.CInt {
  get { 83 }
}
@_alwaysEmitIntoClient internal var _EOVERFLOW: Swift.CInt {
  get { 84 }
}
@_alwaysEmitIntoClient internal var _EBADEXEC: Swift.CInt {
  get { 85 }
}
@_alwaysEmitIntoClient internal var _EBADARCH: Swift.CInt {
  get { 86 }
}
@_alwaysEmitIntoClient internal var _ESHLIBVERS: Swift.CInt {
  get { 87 }
}
@_alwaysEmitIntoClient internal var _EBADMACHO: Swift.CInt {
  get { 88 }
}
@_alwaysEmitIntoClient internal var _ECANCELED: Swift.CInt {
  get { 89 }
}
@_alwaysEmitIntoClient internal var _EIDRM: Swift.CInt {
  get { 90 }
}
@_alwaysEmitIntoClient internal var _ENOMSG: Swift.CInt {
  get { 91 }
}
@_alwaysEmitIntoClient internal var _EILSEQ: Swift.CInt {
  get { 92 }
}
@_alwaysEmitIntoClient internal var _ENOATTR: Swift.CInt {
  get { 93 }
}
@_alwaysEmitIntoClient internal var _EBADMSG: Swift.CInt {
  get { 94 }
}
@_alwaysEmitIntoClient internal var _EMULTIHOP: Swift.CInt {
  get { 95 }
}
@_alwaysEmitIntoClient internal var _ENODATA: Swift.CInt {
  get { 96 }
}
@_alwaysEmitIntoClient internal var _ENOLINK: Swift.CInt {
  get { 97 }
}
@_alwaysEmitIntoClient internal var _ENOSR: Swift.CInt {
  get { 98 }
}
@_alwaysEmitIntoClient internal var _ENOSTR: Swift.CInt {
  get { 99 }
}
@_alwaysEmitIntoClient internal var _EPROTO: Swift.CInt {
  get { 100 }
}
@_alwaysEmitIntoClient internal var _ETIME: Swift.CInt {
  get { 101 }
}
@_alwaysEmitIntoClient internal var _EOPNOTSUPP: Swift.CInt {
  get { 102 }
}
@_alwaysEmitIntoClient internal var _ENOPOLICY: Swift.CInt {
  get { 103 }
}
@_alwaysEmitIntoClient internal var _ENOTRECOVERABLE: Swift.CInt {
  get { 104 }
}
@_alwaysEmitIntoClient internal var _EOWNERDEAD: Swift.CInt {
  get { 105 }
}
@_alwaysEmitIntoClient internal var _EQFULL: Swift.CInt {
  get { 106 }
}
@_alwaysEmitIntoClient internal var _ELAST: Swift.CInt {
  get { 106 }
}
@_alwaysEmitIntoClient internal var _O_RDONLY: Swift.CInt {
  get { 0x0000 }
}
@_alwaysEmitIntoClient internal var _O_WRONLY: Swift.CInt {
  get { 0x0001 }
}
@_alwaysEmitIntoClient internal var _O_RDWR: Swift.CInt {
  get { 0x0002 }
}
@_alwaysEmitIntoClient internal var _O_ACCMODE: Swift.CInt {
  get { 0x0003 }
}
@_alwaysEmitIntoClient internal var _O_NONBLOCK: Swift.CInt {
  get { 0x0004 }
}
@_alwaysEmitIntoClient internal var _O_APPEND: Swift.CInt {
  get { 0x0008 }
}
@_alwaysEmitIntoClient internal var _O_SHLOCK: Swift.CInt {
  get { 0x0010 }
}
@_alwaysEmitIntoClient internal var _O_EXLOCK: Swift.CInt {
  get { 0x0020 }
}
@_alwaysEmitIntoClient internal var _O_ASYNC: Swift.CInt {
  get { 0x0040 }
}
@_alwaysEmitIntoClient internal var _O_NOFOLLOW: Swift.CInt {
  get { 0x0100 }
}
@_alwaysEmitIntoClient internal var _O_CREAT: Swift.CInt {
  get { 0x0200 }
}
@_alwaysEmitIntoClient internal var _O_TRUNC: Swift.CInt {
  get { 0x0400 }
}
@_alwaysEmitIntoClient internal var _O_EXCL: Swift.CInt {
  get { 0x0800 }
}
@_alwaysEmitIntoClient internal var _O_EVTONLY: Swift.CInt {
  get { 0x8000 }
}
@_alwaysEmitIntoClient internal var _O_NOCTTY: Swift.CInt {
  get { 0x20000 }
}
@_alwaysEmitIntoClient internal var _O_DIRECTORY: Swift.CInt {
  get { 0x100000 }
}
@_alwaysEmitIntoClient internal var _O_SYMLINK: Swift.CInt {
  get { 0x200000 }
}
@_alwaysEmitIntoClient internal var _O_CLOEXEC: Swift.CInt {
  get { 0x1000000 }
}
@_alwaysEmitIntoClient internal var _O_DP_GETRAWENCRYPTED: Swift.CInt {
  get { 0x0001 }
}
@_alwaysEmitIntoClient internal var _O_DP_GETRAWUNENCRYPTED: Swift.CInt {
  get { 0x0002 }
}
@_alwaysEmitIntoClient internal var _SEEK_SET: Swift.CInt {
  get { 0 }
}
@_alwaysEmitIntoClient internal var _SEEK_CUR: Swift.CInt {
  get { 1 }
}
@_alwaysEmitIntoClient internal var _SEEK_END: Swift.CInt {
  get { 2 }
}
@_alwaysEmitIntoClient internal var _SEEK_HOLE: Swift.CInt {
  get { 3 }
}
@_alwaysEmitIntoClient internal var _SEEK_DATA: Swift.CInt {
  get { 4 }
}
