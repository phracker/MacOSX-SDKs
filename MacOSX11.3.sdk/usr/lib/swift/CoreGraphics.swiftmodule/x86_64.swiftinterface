// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 5.4 (swiftlang-1205.0.24.14 clang-1205.0.19.54)
// swift-module-flags: -target x86_64-apple-macos11.3 -enable-objc-interop -autolink-force-load -enable-library-evolution -module-link-name swiftCoreGraphics -swift-version 5 -enforce-exclusivity=checked -O -module-name CoreGraphics
@_exported import CoreGraphics
import Darwin
import Swift
@frozen public struct CGFloat {
  public typealias NativeType = Swift.Double
  @_transparent public init() {
    self.native = 0.0
  }
  @_transparent public init(_ value: Swift.Float) {
    self.native = NativeType(value)
  }
  @_transparent public init(_ value: Swift.Double) {
    self.native = NativeType(value)
  }
  @_transparent public init(_ value: Swift.Float80) {
    self.native = NativeType(value)
  }
  @_transparent public init(_ value: CoreGraphics.CGFloat) {
    self.native = value.native
  }
  public var native: CoreGraphics.CGFloat.NativeType
}
extension CGFloat : Swift.SignedNumeric {
  @_alwaysEmitIntoClient public init<T>(_ source: T) where T : Swift.BinaryInteger {
    self.native = NativeType(source)
  }
  @_transparent public init?<T>(exactly source: T) where T : Swift.BinaryInteger {
    guard let native = NativeType(exactly: source) else { return nil }
    self.native = native
  }
  @_transparent public var magnitude: CoreGraphics.CGFloat {
    @_transparent get {
    return CGFloat(native.magnitude)
  }
  }
  public typealias IntegerLiteralType = Swift.Int
  public typealias Magnitude = CoreGraphics.CGFloat
}
extension CGFloat : Swift.BinaryFloatingPoint {
  public typealias RawSignificand = Swift.UInt
  public typealias Exponent = Swift.Int
  @_transparent public static var exponentBitCount: Swift.Int {
    @_transparent get {
    return NativeType.exponentBitCount
  }
  }
  @_transparent public static var significandBitCount: Swift.Int {
    @_transparent get {
    return NativeType.significandBitCount
  }
  }
  @_transparent public var bitPattern: Swift.UInt {
    @_transparent get {
    return UInt(native.bitPattern)
  }
  }
  @_transparent public init(bitPattern: Swift.UInt) {
    native = NativeType(bitPattern: UInt64(bitPattern))
  }
  @_transparent public var sign: Swift.FloatingPointSign {
    @_transparent get {
    return native.sign
  }
  }
  @_transparent public var exponentBitPattern: Swift.UInt {
    @_transparent get {
    return native.exponentBitPattern
  }
  }
  @_transparent public var significandBitPattern: Swift.UInt {
    @_transparent get {
    return UInt(native.significandBitPattern)
  }
  }
  @_transparent public init(sign: Swift.FloatingPointSign, exponentBitPattern: Swift.UInt, significandBitPattern: Swift.UInt) {
    native = NativeType(sign: sign,
      exponentBitPattern: exponentBitPattern,
      significandBitPattern: NativeType.RawSignificand(significandBitPattern))
  }
  @_transparent public init(nan payload: CoreGraphics.CGFloat.RawSignificand, signaling: Swift.Bool) {
    native = NativeType(nan: NativeType.RawSignificand(payload),
                        signaling: signaling)
  }
  @_transparent public static var infinity: CoreGraphics.CGFloat {
    @_transparent get {
    return CGFloat(NativeType.infinity)
  }
  }
  @_transparent public static var nan: CoreGraphics.CGFloat {
    @_transparent get {
    return CGFloat(NativeType.nan)
  }
  }
  @_transparent public static var signalingNaN: CoreGraphics.CGFloat {
    @_transparent get {
    return CGFloat(NativeType.signalingNaN)
  }
  }
  @available(*, unavailable, renamed: "nan")
  public static var quietNaN: CoreGraphics.CGFloat {
    get
  }
  @_transparent public static var greatestFiniteMagnitude: CoreGraphics.CGFloat {
    @_transparent get {
    return CGFloat(NativeType.greatestFiniteMagnitude)
  }
  }
  @_transparent public static var pi: CoreGraphics.CGFloat {
    @_transparent get {
    return CGFloat(NativeType.pi)
  }
  }
  @_transparent public var ulp: CoreGraphics.CGFloat {
    @_transparent get {
    return CGFloat(native.ulp)
  }
  }
  @_transparent public static var leastNormalMagnitude: CoreGraphics.CGFloat {
    @_transparent get {
    return CGFloat(NativeType.leastNormalMagnitude)
  }
  }
  @_transparent public static var leastNonzeroMagnitude: CoreGraphics.CGFloat {
    @_transparent get {
    return CGFloat(NativeType.leastNonzeroMagnitude)
  }
  }
  @_transparent public var exponent: Swift.Int {
    @_transparent get {
    return native.exponent
  }
  }
  @_transparent public var significand: CoreGraphics.CGFloat {
    @_transparent get {
    return CGFloat(native.significand)
  }
  }
  @_transparent public init(sign: Swift.FloatingPointSign, exponent: Swift.Int, significand: CoreGraphics.CGFloat) {
    native = NativeType(sign: sign,
      exponent: exponent, significand: significand.native)
  }
  @_transparent public mutating func round(_ rule: Swift.FloatingPointRoundingRule) {
    native.round(rule)
  }
  @_transparent public var nextUp: CoreGraphics.CGFloat {
    @_transparent get {
    return CGFloat(native.nextUp)
  }
  }
  @_transparent public mutating func negate() {
    native.negate()
  }
  @_transparent public static func += (lhs: inout CoreGraphics.CGFloat, rhs: CoreGraphics.CGFloat) {
    lhs.native += rhs.native
  }
  @_transparent public static func -= (lhs: inout CoreGraphics.CGFloat, rhs: CoreGraphics.CGFloat) {
    lhs.native -= rhs.native
  }
  @_transparent public static func *= (lhs: inout CoreGraphics.CGFloat, rhs: CoreGraphics.CGFloat) {
    lhs.native *= rhs.native
  }
  @_transparent public static func /= (lhs: inout CoreGraphics.CGFloat, rhs: CoreGraphics.CGFloat) {
    lhs.native /= rhs.native
  }
  @_transparent public mutating func formTruncatingRemainder(dividingBy other: CoreGraphics.CGFloat) {
    native.formTruncatingRemainder(dividingBy: other.native)
  }
  @_transparent public mutating func formRemainder(dividingBy other: CoreGraphics.CGFloat) {
    native.formRemainder(dividingBy: other.native)
  }
  @_transparent public mutating func formSquareRoot() {
    native.formSquareRoot( )
  }
  @_transparent public mutating func addProduct(_ lhs: CoreGraphics.CGFloat, _ rhs: CoreGraphics.CGFloat) {
    native.addProduct(lhs.native, rhs.native)
  }
  @_transparent public func isEqual(to other: CoreGraphics.CGFloat) -> Swift.Bool {
    return self.native.isEqual(to: other.native)
  }
  @_transparent public func isLess(than other: CoreGraphics.CGFloat) -> Swift.Bool {
    return self.native.isLess(than: other.native)
  }
  @_transparent public func isLessThanOrEqualTo(_ other: CoreGraphics.CGFloat) -> Swift.Bool {
    return self.native.isLessThanOrEqualTo(other.native)
  }
  @_transparent public var isNormal: Swift.Bool {
    @_transparent get {
    return native.isNormal
  }
  }
  @_transparent public var isFinite: Swift.Bool {
    @_transparent get {
    return native.isFinite
  }
  }
  @_transparent public var isZero: Swift.Bool {
    @_transparent get {
    return native.isZero
  }
  }
  @_transparent public var isSubnormal: Swift.Bool {
    @_transparent get {
    return native.isSubnormal
  }
  }
  @_transparent public var isInfinite: Swift.Bool {
    @_transparent get {
    return native.isInfinite
  }
  }
  @_transparent public var isNaN: Swift.Bool {
    @_transparent get {
    return native.isNaN
  }
  }
  @_transparent public var isSignalingNaN: Swift.Bool {
    @_transparent get {
    return native.isSignalingNaN
  }
  }
  @available(*, unavailable, renamed: "isSignalingNaN")
  public var isSignaling: Swift.Bool {
    get
  }
  @_transparent public var isCanonical: Swift.Bool {
    @_transparent get {
    return true
  }
  }
  @_transparent public var floatingPointClass: Swift.FloatingPointClassification {
    @_transparent get {
    return native.floatingPointClass
  }
  }
  @_transparent public var binade: CoreGraphics.CGFloat {
    @_transparent get {
    return CGFloat(native.binade)
  }
  }
  @_transparent public var significandWidth: Swift.Int {
    @_transparent get {
    return native.significandWidth
  }
  }
  @_transparent public init(floatLiteral value: CoreGraphics.CGFloat.NativeType) {
    native = value
  }
  @_transparent public init(integerLiteral value: Swift.Int) {
    native = NativeType(value)
  }
  public typealias FloatLiteralType = CoreGraphics.CGFloat.NativeType
  public typealias RawExponent = Swift.UInt
}
extension CGFloat {
  @available(*, unavailable, renamed: "leastNormalMagnitude")
  public static var min: CoreGraphics.CGFloat {
    get
  }
  @available(*, unavailable, renamed: "greatestFiniteMagnitude")
  public static var max: CoreGraphics.CGFloat {
    get
  }
}
@available(*, unavailable, renamed: "CGFloat.leastNormalMagnitude")
public var CGFLOAT_MIN: CoreGraphics.CGFloat {
  get
}
@available(*, unavailable, renamed: "CGFloat.greatestFiniteMagnitude")
public var CGFLOAT_MAX: CoreGraphics.CGFloat {
  get
}
extension CGFloat : Swift.CustomReflectable {
  public var customMirror: Swift.Mirror {
    get
  }
}
extension CGFloat : Swift.CustomStringConvertible {
  @_transparent public var description: Swift.String {
    @_transparent get {
    return native.description
  }
  }
}
extension CGFloat : Swift.Hashable {
  @_transparent public var hashValue: Swift.Int {
    @_transparent get {
    return native.hashValue
  }
  }
  @inlinable @_transparent public func hash(into hasher: inout Swift.Hasher) {
    hasher.combine(native)
  }
  @_alwaysEmitIntoClient @inlinable public func _rawHashValue(seed: Swift.Int) -> Swift.Int {
    return native._rawHashValue(seed: seed)
  }
}
extension UInt8 {
  @_transparent public init(_ value: CoreGraphics.CGFloat) {
    self = UInt8(value.native)
  }
}
extension Int8 {
  @_transparent public init(_ value: CoreGraphics.CGFloat) {
    self = Int8(value.native)
  }
}
extension UInt16 {
  @_transparent public init(_ value: CoreGraphics.CGFloat) {
    self = UInt16(value.native)
  }
}
extension Int16 {
  @_transparent public init(_ value: CoreGraphics.CGFloat) {
    self = Int16(value.native)
  }
}
extension UInt32 {
  @_transparent public init(_ value: CoreGraphics.CGFloat) {
    self = UInt32(value.native)
  }
}
extension Int32 {
  @_transparent public init(_ value: CoreGraphics.CGFloat) {
    self = Int32(value.native)
  }
}
extension UInt64 {
  @_transparent public init(_ value: CoreGraphics.CGFloat) {
    self = UInt64(value.native)
  }
}
extension Int64 {
  @_transparent public init(_ value: CoreGraphics.CGFloat) {
    self = Int64(value.native)
  }
}
extension UInt {
  @_transparent public init(_ value: CoreGraphics.CGFloat) {
    self = UInt(value.native)
  }
}
extension Int {
  @_transparent public init(_ value: CoreGraphics.CGFloat) {
    self = Int(value.native)
  }
}
extension Double {
  @_transparent public init(_ value: CoreGraphics.CGFloat) {
    self = Double(value.native)
  }
}
extension Float {
  @_transparent public init(_ value: CoreGraphics.CGFloat) {
    self = Float(value.native)
  }
}
extension CGFloat {
  @_transparent public static func + (lhs: CoreGraphics.CGFloat, rhs: CoreGraphics.CGFloat) -> CoreGraphics.CGFloat {
    var lhs = lhs
    lhs += rhs
    return lhs
  }
  @_transparent public static func - (lhs: CoreGraphics.CGFloat, rhs: CoreGraphics.CGFloat) -> CoreGraphics.CGFloat {
    var lhs = lhs
    lhs -= rhs
    return lhs
  }
  @_transparent public static func * (lhs: CoreGraphics.CGFloat, rhs: CoreGraphics.CGFloat) -> CoreGraphics.CGFloat {
    var lhs = lhs
    lhs *= rhs
    return lhs
  }
  @_transparent public static func / (lhs: CoreGraphics.CGFloat, rhs: CoreGraphics.CGFloat) -> CoreGraphics.CGFloat {
    var lhs = lhs
    lhs /= rhs
    return lhs
  }
}
extension CGFloat : Swift.Strideable {
  @_transparent public func distance(to other: CoreGraphics.CGFloat) -> CoreGraphics.CGFloat {
    return CGFloat(other.native - self.native)
  }
  @_transparent public func advanced(by amount: CoreGraphics.CGFloat) -> CoreGraphics.CGFloat {
    return CGFloat(self.native + amount.native)
  }
  public typealias Stride = CoreGraphics.CGFloat
}
@available(*, unavailable, message: "Use truncatingRemainder instead")
@_transparent public func % (lhs: CoreGraphics.CGFloat, rhs: CoreGraphics.CGFloat) -> CoreGraphics.CGFloat {
  fatalError("% is not available.")
}
@available(*, unavailable, message: "Use formTruncatingRemainder instead")
@_transparent public func %= (lhs: inout CoreGraphics.CGFloat, rhs: CoreGraphics.CGFloat) {
  fatalError("%= is not available.")
}
@_transparent public func acos(_ x: CoreGraphics.CGFloat) -> CoreGraphics.CGFloat {
  return CGFloat(acos(x.native))
}
@_transparent public func asin(_ x: CoreGraphics.CGFloat) -> CoreGraphics.CGFloat {
  return CGFloat(asin(x.native))
}
@_transparent public func atan(_ x: CoreGraphics.CGFloat) -> CoreGraphics.CGFloat {
  return CGFloat(atan(x.native))
}
@_transparent public func cos(_ x: CoreGraphics.CGFloat) -> CoreGraphics.CGFloat {
  return CGFloat(cos(x.native))
}
@_transparent public func sin(_ x: CoreGraphics.CGFloat) -> CoreGraphics.CGFloat {
  return CGFloat(sin(x.native))
}
@_transparent public func tan(_ x: CoreGraphics.CGFloat) -> CoreGraphics.CGFloat {
  return CGFloat(tan(x.native))
}
@_transparent public func acosh(_ x: CoreGraphics.CGFloat) -> CoreGraphics.CGFloat {
  return CGFloat(acosh(x.native))
}
@_transparent public func asinh(_ x: CoreGraphics.CGFloat) -> CoreGraphics.CGFloat {
  return CGFloat(asinh(x.native))
}
@_transparent public func atanh(_ x: CoreGraphics.CGFloat) -> CoreGraphics.CGFloat {
  return CGFloat(atanh(x.native))
}
@_transparent public func cosh(_ x: CoreGraphics.CGFloat) -> CoreGraphics.CGFloat {
  return CGFloat(cosh(x.native))
}
@_transparent public func sinh(_ x: CoreGraphics.CGFloat) -> CoreGraphics.CGFloat {
  return CGFloat(sinh(x.native))
}
@_transparent public func tanh(_ x: CoreGraphics.CGFloat) -> CoreGraphics.CGFloat {
  return CGFloat(tanh(x.native))
}
@_transparent public func exp(_ x: CoreGraphics.CGFloat) -> CoreGraphics.CGFloat {
  return CGFloat(exp(x.native))
}
@_transparent public func exp2(_ x: CoreGraphics.CGFloat) -> CoreGraphics.CGFloat {
  return CGFloat(exp2(x.native))
}
@_transparent public func expm1(_ x: CoreGraphics.CGFloat) -> CoreGraphics.CGFloat {
  return CGFloat(expm1(x.native))
}
@_transparent public func log(_ x: CoreGraphics.CGFloat) -> CoreGraphics.CGFloat {
  return CGFloat(log(x.native))
}
@_transparent public func log10(_ x: CoreGraphics.CGFloat) -> CoreGraphics.CGFloat {
  return CGFloat(log10(x.native))
}
@_transparent public func log1p(_ x: CoreGraphics.CGFloat) -> CoreGraphics.CGFloat {
  return CGFloat(log1p(x.native))
}
@_transparent public func log2(_ x: CoreGraphics.CGFloat) -> CoreGraphics.CGFloat {
  return CGFloat(log2(x.native))
}
@_transparent public func logb(_ x: CoreGraphics.CGFloat) -> CoreGraphics.CGFloat {
  return CGFloat(logb(x.native))
}
@_transparent public func cbrt(_ x: CoreGraphics.CGFloat) -> CoreGraphics.CGFloat {
  return CGFloat(cbrt(x.native))
}
@_transparent public func erf(_ x: CoreGraphics.CGFloat) -> CoreGraphics.CGFloat {
  return CGFloat(erf(x.native))
}
@_transparent public func erfc(_ x: CoreGraphics.CGFloat) -> CoreGraphics.CGFloat {
  return CGFloat(erfc(x.native))
}
@_transparent public func tgamma(_ x: CoreGraphics.CGFloat) -> CoreGraphics.CGFloat {
  return CGFloat(tgamma(x.native))
}
@_transparent public func nearbyint(_ x: CoreGraphics.CGFloat) -> CoreGraphics.CGFloat {
  return CGFloat(nearbyint(x.native))
}
@_transparent public func rint(_ x: CoreGraphics.CGFloat) -> CoreGraphics.CGFloat {
  return CGFloat(rint(x.native))
}
@_transparent public func atan2(_ lhs: CoreGraphics.CGFloat, _ rhs: CoreGraphics.CGFloat) -> CoreGraphics.CGFloat {
  return CGFloat(atan2(lhs.native, rhs.native))
}
@_transparent public func hypot(_ lhs: CoreGraphics.CGFloat, _ rhs: CoreGraphics.CGFloat) -> CoreGraphics.CGFloat {
  return CGFloat(hypot(lhs.native, rhs.native))
}
@_transparent public func pow(_ lhs: CoreGraphics.CGFloat, _ rhs: CoreGraphics.CGFloat) -> CoreGraphics.CGFloat {
  return CGFloat(pow(lhs.native, rhs.native))
}
@_transparent public func copysign(_ lhs: CoreGraphics.CGFloat, _ rhs: CoreGraphics.CGFloat) -> CoreGraphics.CGFloat {
  return CGFloat(copysign(lhs.native, rhs.native))
}
@_transparent public func nextafter(_ lhs: CoreGraphics.CGFloat, _ rhs: CoreGraphics.CGFloat) -> CoreGraphics.CGFloat {
  return CGFloat(nextafter(lhs.native, rhs.native))
}
@_transparent public func fdim(_ lhs: CoreGraphics.CGFloat, _ rhs: CoreGraphics.CGFloat) -> CoreGraphics.CGFloat {
  return CGFloat(fdim(lhs.native, rhs.native))
}
@_transparent public func fmax(_ lhs: CoreGraphics.CGFloat, _ rhs: CoreGraphics.CGFloat) -> CoreGraphics.CGFloat {
  return CGFloat(fmax(lhs.native, rhs.native))
}
@_transparent public func fmin(_ lhs: CoreGraphics.CGFloat, _ rhs: CoreGraphics.CGFloat) -> CoreGraphics.CGFloat {
  return CGFloat(fmin(lhs.native, rhs.native))
}
@available(*, unavailable, message: "use the floatingPointClass property.")
@_transparent public func fpclassify(_ x: CoreGraphics.CGFloat) -> Swift.Int {
  fatalError("unavailable")
}
@available(*, unavailable, message: "use the isNormal property.")
public func isnormal(_ value: CoreGraphics.CGFloat) -> Swift.Bool
@available(*, unavailable, message: "use the isFinite property.")
public func isfinite(_ value: CoreGraphics.CGFloat) -> Swift.Bool
@available(*, unavailable, message: "use the isInfinite property.")
public func isinf(_ value: CoreGraphics.CGFloat) -> Swift.Bool
@available(*, unavailable, message: "use the isNaN property.")
public func isnan(_ value: CoreGraphics.CGFloat) -> Swift.Bool
@available(*, unavailable, message: "use the sign property.")
public func signbit(_ value: CoreGraphics.CGFloat) -> Swift.Int
@available(swift, deprecated: 4.2, renamed: "scalbn")
@_transparent public func ldexp(_ x: CoreGraphics.CGFloat, _ n: Swift.Int) -> CoreGraphics.CGFloat {
  return CGFloat(ldexp(x.native, n))
}
@available(swift, deprecated: 4.2, message: "use the exponent property.")
@_transparent public func ilogb(_ x: CoreGraphics.CGFloat) -> Swift.Int {
  return Int(x.exponent)
}
@_transparent public func lgamma(_ x: CoreGraphics.CGFloat) -> (CoreGraphics.CGFloat, Swift.Int) {
  let (value, sign) = lgamma(x.native)
  return (CGFloat(value), sign)
}
@_transparent public func remquo(_ x: CoreGraphics.CGFloat, _ y: CoreGraphics.CGFloat) -> (CoreGraphics.CGFloat, Swift.Int) {
  let (rem, quo) = remquo(x.native, y.native)
  return (CGFloat(rem), quo)
}
@available(swift, deprecated: 4.2, message: "use CGFloat(nan: CGFloat.RawSignificand) instead.")
@_transparent public func nan(_ tag: Swift.String) -> CoreGraphics.CGFloat {
  return CGFloat(nan(tag) as CGFloat.NativeType)
}
@_transparent public func j0(_ x: CoreGraphics.CGFloat) -> CoreGraphics.CGFloat {
  return CGFloat(j0(Double(x.native)))
}
@_transparent public func j1(_ x: CoreGraphics.CGFloat) -> CoreGraphics.CGFloat {
  return CGFloat(j1(Double(x.native)))
}
@_transparent public func jn(_ n: Swift.Int, _ x: CoreGraphics.CGFloat) -> CoreGraphics.CGFloat {
  return CGFloat(jn(n, Double(x.native)))
}
@_transparent public func y0(_ x: CoreGraphics.CGFloat) -> CoreGraphics.CGFloat {
  return CGFloat(y0(Double(x.native)))
}
@_transparent public func y1(_ x: CoreGraphics.CGFloat) -> CoreGraphics.CGFloat {
  return CGFloat(y1(Double(x.native)))
}
@_transparent public func yn(_ n: Swift.Int, _ x: CoreGraphics.CGFloat) -> CoreGraphics.CGFloat {
  return CGFloat(yn(n, Double(x.native)))
}
extension CGFloat : Swift._CVarArgPassedAsDouble, Swift._CVarArgAligned {
  @_transparent public var _cVarArgEncoding: [Swift.Int] {
    @_transparent get {
    return native._cVarArgEncoding
  }
  }
  @_transparent public var _cVarArgAlignment: Swift.Int {
    @_transparent get {
    return native._cVarArgAlignment
  }
  }
}
extension CGFloat : Swift.Codable {
  @_transparent public init(from decoder: Swift.Decoder) throws {
    let container = try decoder.singleValueContainer()
    do {
      self.native = try container.decode(NativeType.self)
    } catch DecodingError.typeMismatch(let type, let context) {
      // We may have encoded as a different type on a different platform. A
      // strict fixed-format decoder may disallow a conversion, so let's try the
      // other type.
      do {
        if NativeType.self == Float.self {
          self.native = NativeType(try container.decode(Double.self))
        } else {
          self.native = NativeType(try container.decode(Float.self))
        }
      } catch {
        // Failed to decode as the other type, too. This is neither a Float nor
        // a Double. Throw the old error; we don't want to clobber the original
        // info.
        throw DecodingError.typeMismatch(type, context)
      }
    }
  }
  @_transparent public func encode(to encoder: Swift.Encoder) throws {
    var container = encoder.singleValueContainer()
    try container.encode(self.native)
  }
}
extension CGAffineTransform : Swift.Equatable {
  public static func == (lhs: CoreGraphics.CGAffineTransform, rhs: CoreGraphics.CGAffineTransform) -> Swift.Bool
}
extension CGColor {
  @available(macOS 10.3, iOS 2.0, *)
  public var components: [CoreGraphics.CGFloat]? {
    get
  }
  public class var white: CoreGraphics.CGColor {
    get
  }
  public class var black: CoreGraphics.CGColor {
    get
  }
  public class var clear: CoreGraphics.CGColor {
    get
  }
}
public protocol _CGColorInitTrampoline {
  init(red: CoreGraphics.CGFloat, green: CoreGraphics.CGFloat, blue: CoreGraphics.CGFloat, alpha: CoreGraphics.CGFloat)
}
extension _CGColorInitTrampoline {
  public init(_colorLiteralRed red: Swift.Float, green: Swift.Float, blue: Swift.Float, alpha: Swift.Float)
}
extension CGColor : CoreGraphics._CGColorInitTrampoline, Swift._ExpressibleByColorLiteral {
}
extension CGColorSpace {
  public var colorTable: [Swift.UInt8]? {
    get
  }
}
extension CGContext {
  public func setLineDash(phase: CoreGraphics.CGFloat, lengths: [CoreGraphics.CGFloat])
  public func move(to point: CoreGraphics.CGPoint)
  public func addLine(to point: CoreGraphics.CGPoint)
  public func addCurve(to end: CoreGraphics.CGPoint, control1: CoreGraphics.CGPoint, control2: CoreGraphics.CGPoint)
  public func addQuadCurve(to end: CoreGraphics.CGPoint, control: CoreGraphics.CGPoint)
  public func addRects(_ rects: [CoreGraphics.CGRect])
  public func addLines(between points: [CoreGraphics.CGPoint])
  public func addArc(center: CoreGraphics.CGPoint, radius: CoreGraphics.CGFloat, startAngle: CoreGraphics.CGFloat, endAngle: CoreGraphics.CGFloat, clockwise: Swift.Bool)
  public func addArc(tangent1End: CoreGraphics.CGPoint, tangent2End: CoreGraphics.CGPoint, radius: CoreGraphics.CGFloat)
  public func fillPath(using rule: CoreGraphics.CGPathFillRule = .winding)
  public func clip(using rule: CoreGraphics.CGPathFillRule = .winding)
  public func fill(_ rects: [CoreGraphics.CGRect])
  public func strokeLineSegments(between points: [CoreGraphics.CGPoint])
  public func clip(to rects: [CoreGraphics.CGRect])
  public func draw(_ image: CoreGraphics.CGImage, in rect: CoreGraphics.CGRect, byTiling: Swift.Bool = false)
  public var textPosition: CoreGraphics.CGPoint {
    get
    set
  }
  public func showGlyphs(_ glyphs: [CoreGraphics.CGGlyph], at positions: [CoreGraphics.CGPoint])
}
public func CGGetLastMouseDelta() -> (x: Swift.Int32, y: Swift.Int32)
extension CGPoint {
  public static var zero: CoreGraphics.CGPoint {
    @_transparent get { return CGPoint(x: 0, y: 0) }
  }
  @_transparent public init(x: Swift.Int, y: Swift.Int) {
    self.init(x: CGFloat(x), y: CGFloat(y))
  }
  @_transparent public init(x: Swift.Double, y: Swift.Double) {
    self.init(x: CGFloat(x), y: CGFloat(y))
  }
  public init?(dictionaryRepresentation dict: CoreFoundation.CFDictionary)
}
extension CGPoint : Swift.CustomReflectable {
  public var customMirror: Swift.Mirror {
    get
  }
}
extension CGPoint : Swift._CustomPlaygroundQuickLookable {
  @available(*, deprecated, message: "CGPoint.customPlaygroundQuickLook will be removed in a future Swift version")
  public var customPlaygroundQuickLook: Swift.PlaygroundQuickLook {
    get
  }
}
extension CGPoint : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
extension CGPoint : Swift.Equatable {
  @_transparent public static func == (lhs: CoreGraphics.CGPoint, rhs: CoreGraphics.CGPoint) -> Swift.Bool {
    return lhs.x == rhs.x  &&  lhs.y == rhs.y
  }
}
extension CGPoint : Swift.Codable {
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
extension CGSize {
  public static var zero: CoreGraphics.CGSize {
    @_transparent get { return CGSize(width: 0, height: 0) }
  }
  @_transparent public init(width: Swift.Int, height: Swift.Int) {
    self.init(width: CGFloat(width), height: CGFloat(height))
  }
  @_transparent public init(width: Swift.Double, height: Swift.Double) {
    self.init(width: CGFloat(width), height: CGFloat(height))
  }
  public init?(dictionaryRepresentation dict: CoreFoundation.CFDictionary)
}
extension CGSize : Swift.CustomReflectable {
  public var customMirror: Swift.Mirror {
    get
  }
}
extension CGSize : Swift._CustomPlaygroundQuickLookable {
  @available(*, deprecated, message: "CGSize.customPlaygroundQuickLook will be removed in a future Swift version")
  public var customPlaygroundQuickLook: Swift.PlaygroundQuickLook {
    get
  }
}
extension CGSize : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
extension CGSize : Swift.Equatable {
  @_transparent public static func == (lhs: CoreGraphics.CGSize, rhs: CoreGraphics.CGSize) -> Swift.Bool {
    return lhs.width == rhs.width  &&  lhs.height == rhs.height
  }
}
extension CGSize : Swift.Codable {
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
extension CGVector {
  public static var zero: CoreGraphics.CGVector {
    @_transparent get { return CGVector(dx: 0, dy: 0) }
  }
  @_transparent public init(dx: Swift.Int, dy: Swift.Int) {
    self.init(dx: CGFloat(dx), dy: CGFloat(dy))
  }
  @_transparent public init(dx: Swift.Double, dy: Swift.Double) {
    self.init(dx: CGFloat(dx), dy: CGFloat(dy))
  }
}
extension CGVector : Swift.Equatable {
  @_transparent public static func == (lhs: CoreGraphics.CGVector, rhs: CoreGraphics.CGVector) -> Swift.Bool {
    return lhs.dx == rhs.dx  &&  lhs.dy == rhs.dy
  }
}
extension CGVector : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
extension CGVector : Swift.Codable {
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
extension CGRect {
  public static var zero: CoreGraphics.CGRect {
    @_transparent get { return CGRect(x: 0, y: 0, width: 0, height: 0) }
  }
  @_transparent public init(x: CoreGraphics.CGFloat, y: CoreGraphics.CGFloat, width: CoreGraphics.CGFloat, height: CoreGraphics.CGFloat) {
    self.init(origin: CGPoint(x: x, y: y),
              size: CGSize(width: width, height: height))
  }
  @_transparent public init(x: Swift.Double, y: Swift.Double, width: Swift.Double, height: Swift.Double) {
    self.init(origin: CGPoint(x: x, y: y),
              size: CGSize(width: width, height: height))
  }
  @_transparent public init(x: Swift.Int, y: Swift.Int, width: Swift.Int, height: Swift.Int) {
    self.init(origin: CGPoint(x: x, y: y),
              size: CGSize(width: width, height: height))
  }
  public init?(dictionaryRepresentation dict: CoreFoundation.CFDictionary)
  @_transparent public func divided(atDistance: CoreGraphics.CGFloat, from fromEdge: CoreGraphics.CGRectEdge) -> (slice: CoreGraphics.CGRect, remainder: CoreGraphics.CGRect) {
    var slice = CGRect.zero
    var remainder = CGRect.zero
    self.__divided(slice: &slice, remainder: &remainder, atDistance: atDistance,
           from: fromEdge)
    return (slice, remainder)
  }
  @available(*, unavailable, renamed: "minX")
  public var x: CoreGraphics.CGFloat {
    get
  }
  @available(*, unavailable, renamed: "minY")
  public var y: CoreGraphics.CGFloat {
    get
  }
}
extension CGRect : Swift.CustomReflectable {
  public var customMirror: Swift.Mirror {
    get
  }
}
extension CGRect : Swift._CustomPlaygroundQuickLookable {
  @available(*, deprecated, message: "CGRect.customPlaygroundQuickLook will be removed in a future Swift version")
  public var customPlaygroundQuickLook: Swift.PlaygroundQuickLook {
    get
  }
}
extension CGRect : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
extension CGRect : Swift.Equatable {
  @_transparent public static func == (lhs: CoreGraphics.CGRect, rhs: CoreGraphics.CGRect) -> Swift.Bool {
    return lhs.equalTo(rhs)
  }
}
extension CGRect : Swift.Codable {
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
extension CGAffineTransform {
  public static var identity: CoreGraphics.CGAffineTransform {
    @_transparent get { return CGAffineTransform(a: 1, b: 0, c: 0, d: 1, tx: 0, ty: 0) }
  }
}
extension CGAffineTransform : Swift.Codable {
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
extension CGImage {
  public func copy(maskingColorComponents components: [CoreGraphics.CGFloat]) -> CoreGraphics.CGImage?
}
extension CGContext {
  public func draw(_ layer: CoreGraphics.CGLayer, in rect: CoreGraphics.CGRect)
  public func draw(_ layer: CoreGraphics.CGLayer, at point: CoreGraphics.CGPoint)
}
public enum CGPathFillRule : Swift.Int {
  case winding
  case evenOdd
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
extension CGPath {
  public func copy(dashingWithPhase phase: CoreGraphics.CGFloat, lengths: [CoreGraphics.CGFloat], transform: CoreGraphics.CGAffineTransform = .identity) -> CoreGraphics.CGPath
  public func copy(strokingWithWidth lineWidth: CoreGraphics.CGFloat, lineCap: CoreGraphics.CGLineCap, lineJoin: CoreGraphics.CGLineJoin, miterLimit: CoreGraphics.CGFloat, transform: CoreGraphics.CGAffineTransform = .identity) -> CoreGraphics.CGPath
  public func contains(_ point: CoreGraphics.CGPoint, using rule: CoreGraphics.CGPathFillRule = .winding, transform: CoreGraphics.CGAffineTransform = .identity) -> Swift.Bool
}
extension CGMutablePath {
  public func addRoundedRect(in rect: CoreGraphics.CGRect, cornerWidth: CoreGraphics.CGFloat, cornerHeight: CoreGraphics.CGFloat, transform: CoreGraphics.CGAffineTransform = .identity)
  public func move(to point: CoreGraphics.CGPoint, transform: CoreGraphics.CGAffineTransform = .identity)
  public func addLine(to point: CoreGraphics.CGPoint, transform: CoreGraphics.CGAffineTransform = .identity)
  public func addQuadCurve(to end: CoreGraphics.CGPoint, control: CoreGraphics.CGPoint, transform: CoreGraphics.CGAffineTransform = .identity)
  public func addCurve(to end: CoreGraphics.CGPoint, control1: CoreGraphics.CGPoint, control2: CoreGraphics.CGPoint, transform: CoreGraphics.CGAffineTransform = .identity)
  public func addRect(_ rect: CoreGraphics.CGRect, transform: CoreGraphics.CGAffineTransform = .identity)
  public func addRects(_ rects: [CoreGraphics.CGRect], transform: CoreGraphics.CGAffineTransform = .identity)
  public func addLines(between points: [CoreGraphics.CGPoint], transform: CoreGraphics.CGAffineTransform = .identity)
  public func addEllipse(in rect: CoreGraphics.CGRect, transform: CoreGraphics.CGAffineTransform = .identity)
  public func addRelativeArc(center: CoreGraphics.CGPoint, radius: CoreGraphics.CGFloat, startAngle: CoreGraphics.CGFloat, delta: CoreGraphics.CGFloat, transform: CoreGraphics.CGAffineTransform = .identity)
  public func addArc(center: CoreGraphics.CGPoint, radius: CoreGraphics.CGFloat, startAngle: CoreGraphics.CGFloat, endAngle: CoreGraphics.CGFloat, clockwise: Swift.Bool, transform: CoreGraphics.CGAffineTransform = .identity)
  public func addArc(tangent1End: CoreGraphics.CGPoint, tangent2End: CoreGraphics.CGPoint, radius: CoreGraphics.CGFloat, transform: CoreGraphics.CGAffineTransform = .identity)
  public func addPath(_ path: CoreGraphics.CGPath, transform: CoreGraphics.CGAffineTransform = .identity)
}
@available(*, unavailable, message: "Use == instead")
public func CGAffineTransformEqualToTransform(_ t1: CoreGraphics.CGAffineTransform, _ t2: CoreGraphics.CGAffineTransform) -> Swift.Bool
@available(*, unavailable, message: "Use class var white/black/clear instead")
public func CGColorGetConstantColor(_ colorName: CoreFoundation.CFString?) -> CoreGraphics.CGColor?
@available(*, unavailable, message: "Use == instead")
public func CGColorEqualToColor(_ color1: CoreGraphics.CGColor?, _ color2: CoreGraphics.CGColor?) -> Swift.Bool
@available(*, unavailable, renamed: "getter:CGColor.components(self:)")
public func CGColorGetComponents(_ color: CoreGraphics.CGColor?) -> Swift.UnsafePointer<CoreGraphics.CGFloat>
@available(*, unavailable, message: "Use colorTable.count instead")
public func CGColorSpaceGetColorTableCount(_ space: CoreGraphics.CGColorSpace?) -> Swift.Int
@available(*, unavailable, renamed: "CGColorSpace.colorTable(self:_:)")
public func CGColorSpaceGetColorTable(_ space: CoreGraphics.CGColorSpace?, _ table: Swift.UnsafeMutablePointer<Swift.UInt8>)
@available(*, unavailable, message: "Use setLineDash(self:phase:lengths:)")
public func CGContextSetLineDash(_ c: CoreGraphics.CGContext?, _ phase: CoreGraphics.CGFloat, _ lengths: Swift.UnsafePointer<CoreGraphics.CGFloat>, _ count: Swift.Int)
@available(*, unavailable, message: "Use move(to:) instead")
public func CGContextMoveToPoint(_ c: CoreGraphics.CGContext?, _ x: CoreGraphics.CGFloat, _ y: CoreGraphics.CGFloat)
@available(*, unavailable, message: "Use addLine(to:) instead")
public func CGContextAddLineToPoint(_ c: CoreGraphics.CGContext?, _ x: CoreGraphics.CGFloat, _ y: CoreGraphics.CGFloat)
@available(*, unavailable, message: "Use addCurve(to:control1:control2:) instead")
public func CGContextAddCurveToPoint(_ c: CoreGraphics.CGContext?, _ cp1x: CoreGraphics.CGFloat, _ cp1y: CoreGraphics.CGFloat, _ cp2x: CoreGraphics.CGFloat, _ cp2y: CoreGraphics.CGFloat, _ x: CoreGraphics.CGFloat, _ y: CoreGraphics.CGFloat)
@available(*, unavailable, message: "Use addQuadCurve(to:control:)")
public func CGContextAddQuadCurveToPoint(_ c: CoreGraphics.CGContext?, _ cpx: CoreGraphics.CGFloat, _ cpy: CoreGraphics.CGFloat, _ x: CoreGraphics.CGFloat, _ y: CoreGraphics.CGFloat)
@available(*, unavailable, message: "Use addRects(_:)")
public func CGContextAddRects(_ c: CoreGraphics.CGContext?, _ rects: Swift.UnsafePointer<CoreGraphics.CGRect>, _ count: Swift.Int)
@available(*, unavailable, message: "Use addLines(between:)")
public func CGContextAddLines(_ c: CoreGraphics.CGContext?, _ points: Swift.UnsafePointer<CoreGraphics.CGPoint>, _ count: Swift.Int)
@available(*, unavailable, message: "Use addArc(center:radius:startAngle:endAngle:clockwise:)")
public func CGContextAddArc(_ c: CoreGraphics.CGContext?, _ x: CoreGraphics.CGFloat, _ y: CoreGraphics.CGFloat, _ radius: CoreGraphics.CGFloat, _ startAngle: CoreGraphics.CGFloat, _ endAngle: CoreGraphics.CGFloat, _ clockwise: Swift.Int32)
@available(*, unavailable, message: "Use addArc(self:x1:y1:x2:y2:radius:)")
public func CGContextAddArcToPoint(_ c: CoreGraphics.CGContext?, _ x1: CoreGraphics.CGFloat, _ y1: CoreGraphics.CGFloat, _ x2: CoreGraphics.CGFloat, _ y2: CoreGraphics.CGFloat, _ radius: CoreGraphics.CGFloat)
@available(*, unavailable, message: "Use fill(self:_:count:)")
public func CGContextFillRects(_ c: CoreGraphics.CGContext?, _ rects: Swift.UnsafePointer<CoreGraphics.CGRect>, _ count: Swift.Int)
@available(*, unavailable, message: "Use strokeLineSegments(self:between:count:)")
public func CGContextStrokeLineSegments(_ c: CoreGraphics.CGContext?, _ points: Swift.UnsafePointer<CoreGraphics.CGPoint>, _ count: Swift.Int)
@available(*, unavailable, message: "Use clip(to:)")
public func CGContextClipToRects(_ c: CoreGraphics.CGContext?, _ rects: Swift.UnsafePointer<CoreGraphics.CGRect>, _ count: Swift.Int)
@available(*, unavailable, message: "Use draw(_:in:)")
public func CGContextDrawImage(_ c: CoreGraphics.CGContext?, _ rect: CoreGraphics.CGRect, _ image: CoreGraphics.CGImage?)
@available(*, unavailable, message: "Use draw(_:in:byTiling:)")
public func CGContextDrawTiledImage(_ c: CoreGraphics.CGContext?, _ rect: CoreGraphics.CGRect, _ image: CoreGraphics.CGImage?)
@available(*, unavailable, renamed: "getter:CGContext.textPosition(self:)")
public func CGContextGetTextPosition(_ c: CoreGraphics.CGContext?) -> CoreGraphics.CGPoint
@available(*, unavailable, message: "Use var textPosition")
public func CGContextSetTextPosition(_ c: CoreGraphics.CGContext?, _ x: CoreGraphics.CGFloat, _ y: CoreGraphics.CGFloat)
@available(*, unavailable, message: "Use showGlyphs(_:at:)")
public func CGContextShowGlyphsAtPositions(_ c: CoreGraphics.CGContext?, _ glyphs: Swift.UnsafePointer<CoreGraphics.CGGlyph>, _ Lpositions: Swift.UnsafePointer<CoreGraphics.CGPoint>, _ count: Swift.Int)
@available(*, unavailable, renamed: "CGContext.fillPath(self:)")
public func CGContextFillPath(_ c: CoreGraphics.CGContext?)
@available(*, unavailable, message: "Use fillPath(using:)")
public func CGContextEOFillPath(_ c: CoreGraphics.CGContext?)
@available(*, unavailable, renamed: "CGContext.clip(self:)")
public func CGContextClip(_ c: CoreGraphics.CGContext?)
@available(*, unavailable, message: "Use clip(using:)")
public func CGContextEOClip(_ c: CoreGraphics.CGContext?)
@available(*, unavailable, renamed: "CGGetLastMouseDelta")
public func CGGetLastMouseDelta(_ deltaX: Swift.UnsafeMutablePointer<Swift.Int32>?, _ deltaY: Swift.UnsafeMutablePointer<Swift.Int32>?)
@available(*, unavailable, message: "Use divided(atDistance:from:)")
public func CGRectDivide(_ rect: CoreGraphics.CGRect, _ slice: Swift.UnsafeMutablePointer<CoreGraphics.CGRect>, _ remainder: Swift.UnsafeMutablePointer<CoreGraphics.CGRect>, _ amount: CoreGraphics.CGFloat, _ edge: CoreGraphics.CGRectEdge)
@available(*, unavailable, message: "Use CGPoint.init(dictionaryRepresentation:)")
public func CGPointMakeWithDictionaryRepresentation(_ dict: CoreFoundation.CFDictionary?, _ point: Swift.UnsafeMutablePointer<CoreGraphics.CGPoint>) -> Swift.Bool
@available(*, unavailable, message: "Use CGSize.init(dictionaryRepresentation:)")
public func CGSizeMakeWithDictionaryRepresentation(_ dict: CoreFoundation.CFDictionary?, _ size: Swift.UnsafeMutablePointer<CoreGraphics.CGSize>) -> Swift.Bool
@available(*, unavailable, message: "Use CGRect.init(dictionaryRepresentation:)")
public func CGRectMakeWithDictionaryRepresentation(_ dict: CoreFoundation.CFDictionary?, _ rect: Swift.UnsafeMutablePointer<CoreGraphics.CGRect>) -> Swift.Bool
@available(*, unavailable, renamed: "CGImage.copy(self:maskingColorComponents:)")
public func CGImageCreateWithMaskingColors(_ image: CoreGraphics.CGImage?, _ components: Swift.UnsafePointer<CoreGraphics.CGFloat>) -> CoreGraphics.CGImage?
@available(*, unavailable, message: "Use draw(_:in:)")
public func CGContextDrawLayerInRect(_ context: CoreGraphics.CGContext?, _ rect: CoreGraphics.CGRect, _ layer: CoreGraphics.CGLayer?)
@available(*, unavailable, message: "Use draw(_:at:)")
public func CGContextDrawLayerAtPoint(_ context: CoreGraphics.CGContext?, _ point: CoreGraphics.CGPoint, _ layer: CoreGraphics.CGLayer?)
@available(*, unavailable, message: "Use copy(byDashingWithPhase:lengths:transform:)")
public func CGPathCreateCopyByDashingPath(_ path: CoreGraphics.CGPath?, _ transform: Swift.UnsafePointer<CoreGraphics.CGAffineTransform>, _ phase: CoreGraphics.CGFloat, _ lengths: Swift.UnsafePointer<CoreGraphics.CGFloat>, _ count: Swift.Int) -> CoreGraphics.CGPath?
@available(*, unavailable, message: "Use copy(byStroking:lineWidth:lineCap:lineJoin:miterLimit:transform:)")
public func CGPathCreateCopyByStrokingPath(_ path: CoreGraphics.CGPath?, _ transform: Swift.UnsafePointer<CoreGraphics.CGAffineTransform>, _ lineWidth: CoreGraphics.CGFloat, _ lineCap: CoreGraphics.CGLineCap, _ lineJoin: CoreGraphics.CGLineJoin, _ miterLimit: CoreGraphics.CGFloat) -> CoreGraphics.CGPath?
@available(*, unavailable, message: "Use == instead")
public func CGPathEqualToPath(_ path1: CoreGraphics.CGPath?, _ path2: CoreGraphics.CGPath?) -> Swift.Bool
@available(*, unavailable, message: "Use move(to:transform:)")
public func CGPathMoveToPoint(_ path: CoreGraphics.CGMutablePath?, _ m: Swift.UnsafePointer<CoreGraphics.CGAffineTransform>, _ x: CoreGraphics.CGFloat, _ y: CoreGraphics.CGFloat)
@available(*, unavailable, message: "Use addLine(to:transform:)")
public func CGPathAddLineToPoint(_ path: CoreGraphics.CGMutablePath?, _ m: Swift.UnsafePointer<CoreGraphics.CGAffineTransform>, _ x: CoreGraphics.CGFloat, _ y: CoreGraphics.CGFloat)
@available(*, unavailable, message: "Use addCurve(to:control1:control2:transform:)")
public func CGPathAddCurveToPoint(_ path: CoreGraphics.CGMutablePath?, _ m: Swift.UnsafePointer<CoreGraphics.CGAffineTransform>, _ cp1x: CoreGraphics.CGFloat, _ cp1y: CoreGraphics.CGFloat, _ cp2x: CoreGraphics.CGFloat, _ cp2y: CoreGraphics.CGFloat, _ x: CoreGraphics.CGFloat, _ y: CoreGraphics.CGFloat)
@available(*, unavailable, message: "Use addQuadCurve(to:control:transform:)")
public func CGPathAddQuadCurveToPoint(_ path: CoreGraphics.CGMutablePath?, _ m: Swift.UnsafePointer<CoreGraphics.CGAffineTransform>, _ cpx: CoreGraphics.CGFloat, _ cpy: CoreGraphics.CGFloat, _ x: CoreGraphics.CGFloat, _ y: CoreGraphics.CGFloat)
@available(*, unavailable, message: "Use addRect(_:transform:)")
public func CGPathAddRect(_ path: CoreGraphics.CGMutablePath?, _ m: Swift.UnsafePointer<CoreGraphics.CGAffineTransform>, _ rect: CoreGraphics.CGRect)
@available(*, unavailable, message: "Use addRects(_:transform:)")
public func CGPathAddRects(_ path: CoreGraphics.CGMutablePath?, _ m: Swift.UnsafePointer<CoreGraphics.CGAffineTransform>, _ rects: Swift.UnsafePointer<CoreGraphics.CGRect>, _ count: Swift.Int)
@available(*, unavailable, message: "Use addLines(between:transform:)")
public func CGPathAddLines(_ path: CoreGraphics.CGMutablePath?, _ m: Swift.UnsafePointer<CoreGraphics.CGAffineTransform>, _ points: Swift.UnsafePointer<CoreGraphics.CGPoint>, _ count: Swift.Int)
@available(*, unavailable, message: "Use addEllipse(rect:transform:)")
public func CGPathAddEllipseInRect(_ path: CoreGraphics.CGMutablePath?, _ m: Swift.UnsafePointer<CoreGraphics.CGAffineTransform>, _ rect: CoreGraphics.CGRect)
@available(*, unavailable, message: "Use addRelativeArc(center:radius:startAngle:delta:transform:)")
public func CGPathAddRelativeArc(_ path: CoreGraphics.CGMutablePath?, _ matrix: Swift.UnsafePointer<CoreGraphics.CGAffineTransform>, _ x: CoreGraphics.CGFloat, _ y: CoreGraphics.CGFloat, _ radius: CoreGraphics.CGFloat, _ startAngle: CoreGraphics.CGFloat, _ delta: CoreGraphics.CGFloat)
@available(*, unavailable, message: "Use addArc(center:radius:startAngle:endAngle:clockwise:transform:)")
public func CGPathAddArc(_ path: CoreGraphics.CGMutablePath?, _ m: Swift.UnsafePointer<CoreGraphics.CGAffineTransform>, _ x: CoreGraphics.CGFloat, _ y: CoreGraphics.CGFloat, _ radius: CoreGraphics.CGFloat, _ startAngle: CoreGraphics.CGFloat, _ endAngle: CoreGraphics.CGFloat, _ clockwise: Swift.Bool)
@available(*, unavailable, message: "Use addArc(tangent1End:tangent2End:radius:transform:)")
public func CGPathAddArcToPoint(_ path: CoreGraphics.CGMutablePath?, _ m: Swift.UnsafePointer<CoreGraphics.CGAffineTransform>, _ x1: CoreGraphics.CGFloat, _ y1: CoreGraphics.CGFloat, _ x2: CoreGraphics.CGFloat, _ y2: CoreGraphics.CGFloat, _ radius: CoreGraphics.CGFloat)
@available(*, unavailable, message: "Use addPath(_:transform:)")
public func CGPathAddPath(_ path1: CoreGraphics.CGMutablePath?, _ m: Swift.UnsafePointer<CoreGraphics.CGAffineTransform>, _ path2: CoreGraphics.CGPath?)
@available(*, unavailable, message: "Use CGColor.white")
public var kCGColorWhite: CoreFoundation.CFString {
  get
}
@available(*, unavailable, message: "Use CGColor.black")
public var kCGColorBlack: CoreFoundation.CFString {
  get
}
@available(*, unavailable, message: "Use CGColor.clear")
public var kCGColorClear: CoreFoundation.CFString {
  get
}
extension CoreGraphics.CGPathFillRule : Swift.Equatable {}
extension CoreGraphics.CGPathFillRule : Swift.Hashable {}
extension CoreGraphics.CGPathFillRule : Swift.RawRepresentable {}
